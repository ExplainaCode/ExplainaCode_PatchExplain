record_number,buggy_code,fixed_code,code_similarity
53001,"private Optional<BuildResult> performManifestBasedCacheFetch(final BuildRule rule,final BuildEngineBuildContext context,final BuildInfoRecorder buildInfoRecorder) throws IOException {
  if (!useManifestCaching(rule)) {
    return Optional.empty();
  }
  final Optional<Pair<RuleKey,ImmutableSet<SourcePath>>> manifestKey=ruleKeyFactories.getUnchecked(rule.getProjectFilesystem()).depFileRuleKeyFactory.buildManifestKey((SupportsDependencyFileRuleKey)rule);
  if (!manifestKey.isPresent()) {
    buildInfoRecorder.addBuildMetadata(BuildInfo.MetadataKey.MANIFEST_KEY,manifestKey.get().getFirst().toString());
    return Optional.empty();
  }
  final LazyPath tempFile=new LazyPath(){
    @Override protected Path create() throws IOException {
      return Files.createTempFile(""String_Node_Str"",""String_Node_Str"");
    }
  }
;
  CacheResult manifestResult=fetchArtifactForBuildable(manifestKey.get().getFirst(),tempFile,context.getArtifactCache(),buildInfoRecorder);
  if (!manifestResult.getType().isSuccess()) {
    return Optional.empty();
  }
  Path manifestPath=getManifestPath(rule);
  rule.getProjectFilesystem().deleteFileAtPathIfExists(manifestPath);
  rule.getProjectFilesystem().createParentDirs(manifestPath);
  try (OutputStream outputStream=rule.getProjectFilesystem().newFileOutputStream(manifestPath);InputStream inputStream=new GZIPInputStream(new BufferedInputStream(Files.newInputStream(tempFile.get())))){
    ByteStreams.copy(inputStream,outputStream);
  }
   Files.delete(tempFile.get());
  Manifest manifest;
  try (InputStream input=rule.getProjectFilesystem().newFileInputStream(manifestPath)){
    manifest=new Manifest(input);
  }
   Optional<RuleKey> ruleKey=manifest.lookup(fileHashCaches.getUnchecked(rule.getProjectFilesystem()),pathResolver,manifestKey.get().getSecond());
  if (!ruleKey.isPresent()) {
    return Optional.empty();
  }
  CacheResult cacheResult=tryToFetchArtifactFromBuildCacheAndOverlayOnTopOfProjectFilesystem(rule,ruleKey.get(),buildInfoRecorder,context.getArtifactCache(),rule.getProjectFilesystem(),context);
  if (cacheResult.getType().isSuccess()) {
    return Optional.of(BuildResult.success(rule,BuildRuleSuccessType.FETCHED_FROM_CACHE_MANIFEST_BASED,cacheResult));
  }
  return Optional.empty();
}","private Optional<BuildResult> performManifestBasedCacheFetch(final BuildRule rule,final BuildEngineBuildContext context,final BuildInfoRecorder buildInfoRecorder) throws IOException {
  if (!useManifestCaching(rule)) {
    return Optional.empty();
  }
  final Optional<Pair<RuleKey,ImmutableSet<SourcePath>>> manifestKey=ruleKeyFactories.getUnchecked(rule.getProjectFilesystem()).depFileRuleKeyFactory.buildManifestKey((SupportsDependencyFileRuleKey)rule);
  if (!manifestKey.isPresent()) {
    return Optional.empty();
  }
  buildInfoRecorder.addBuildMetadata(BuildInfo.MetadataKey.MANIFEST_KEY,manifestKey.get().getFirst().toString());
  final LazyPath tempFile=new LazyPath(){
    @Override protected Path create() throws IOException {
      return Files.createTempFile(""String_Node_Str"",""String_Node_Str"");
    }
  }
;
  CacheResult manifestResult=fetchArtifactForBuildable(manifestKey.get().getFirst(),tempFile,context.getArtifactCache(),buildInfoRecorder);
  if (!manifestResult.getType().isSuccess()) {
    return Optional.empty();
  }
  Path manifestPath=getManifestPath(rule);
  rule.getProjectFilesystem().deleteFileAtPathIfExists(manifestPath);
  rule.getProjectFilesystem().createParentDirs(manifestPath);
  try (OutputStream outputStream=rule.getProjectFilesystem().newFileOutputStream(manifestPath);InputStream inputStream=new GZIPInputStream(new BufferedInputStream(Files.newInputStream(tempFile.get())))){
    ByteStreams.copy(inputStream,outputStream);
  }
   Files.delete(tempFile.get());
  Manifest manifest;
  try (InputStream input=rule.getProjectFilesystem().newFileInputStream(manifestPath)){
    manifest=new Manifest(input);
  }
   Optional<RuleKey> ruleKey=manifest.lookup(fileHashCaches.getUnchecked(rule.getProjectFilesystem()),pathResolver,manifestKey.get().getSecond());
  if (!ruleKey.isPresent()) {
    return Optional.empty();
  }
  CacheResult cacheResult=tryToFetchArtifactFromBuildCacheAndOverlayOnTopOfProjectFilesystem(rule,ruleKey.get(),buildInfoRecorder,context.getArtifactCache(),rule.getProjectFilesystem(),context);
  if (cacheResult.getType().isSuccess()) {
    return Optional.of(BuildResult.success(rule,BuildRuleSuccessType.FETCHED_FROM_CACHE_MANIFEST_BASED,cacheResult));
  }
  return Optional.empty();
}",0.9857967154904572
53002,"@Override public final int runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {
  Preconditions.checkNotNull(binary,BINARY_OPTION + ""String_Node_Str"");
  Preconditions.checkNotNull(output,OUTPUT_OPTION + ""String_Node_Str"");
  Preconditions.checkNotNull(oldCompDir,OLD_COMPDIR_OPTION + ""String_Node_Str"");
  Preconditions.checkNotNull(updatedCompDir,NEW_COMPDIR_OPTION + ""String_Node_Str"");
  Preconditions.checkNotNull(!binary.equals(output),BINARY_OPTION + ""String_Node_Str"" + OUTPUT_OPTION);
  Preconditions.checkArgument(oldCompDir.length() >= updatedCompDir.length(),""String_Node_Str"" + ""String_Node_Str"");
  Preconditions.checkArgument(!oldCompDir.equals(updatedCompDir),""String_Node_Str"");
  Files.copy(binary,output,StandardCopyOption.REPLACE_EXISTING);
  return invokeWithParams(params);
}","@Override public final int runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {
  Preconditions.checkNotNull(binary,BINARY_OPTION + ""String_Node_Str"");
  Preconditions.checkNotNull(output,OUTPUT_OPTION + ""String_Node_Str"");
  Preconditions.checkNotNull(oldCompDir,OLD_COMPDIR_OPTION + ""String_Node_Str"");
  Preconditions.checkNotNull(updatedCompDir,NEW_COMPDIR_OPTION + ""String_Node_Str"");
  Preconditions.checkState(!binary.equals(output),BINARY_OPTION + ""String_Node_Str"" + OUTPUT_OPTION);
  Preconditions.checkArgument(oldCompDir.length() >= updatedCompDir.length(),""String_Node_Str"" + ""String_Node_Str"");
  Preconditions.checkArgument(!oldCompDir.equals(updatedCompDir),""String_Node_Str"");
  Files.copy(binary,output,StandardCopyOption.REPLACE_EXISTING);
  return invokeWithParams(params);
}",0.9927623642943304
53003,"@Override public CxxPreprocessorInput getCxxPreprocessorInput(final CxxPlatform cxxPlatform,HeaderVisibility headerVisibility) throws NoSuchBuildTargetException {
  CxxPreprocessorInput.Builder builder=CxxPreprocessorInput.builder();
switch (headerVisibility) {
case PUBLIC:
    if (Preconditions.checkNotNull(hasHeaders(cxxPlatform))) {
      CxxPreprocessables.addHeaderSymlinkTree(builder,getBuildTarget(),ruleResolver,cxxPlatform,headerVisibility,CxxPreprocessables.IncludeType.SYSTEM);
    }
  builder.putAllPreprocessorFlags(Preconditions.checkNotNull(getExportedPreprocessorFlags(cxxPlatform)));
builder.addAllFrameworks(args.frameworks);
final Iterable<SourcePath> includePaths=args.includeDirs.stream().map(input -> PrebuiltCxxLibraryDescription.getApplicableSourcePath(params.getBuildTarget(),params.getCellRoots(),params.getProjectFilesystem(),ruleResolver,cxxPlatform,input,Optional.empty())).collect(MoreCollectors.toImmutableList());
for (SourcePath includePath : includePaths) {
builder.addIncludes(CxxHeadersDir.of(CxxPreprocessables.IncludeType.SYSTEM,includePath));
}
return builder.build();
case PRIVATE:
return builder.build();
}
throw new RuntimeException(""String_Node_Str"" + headerVisibility);
}","@Override public CxxPreprocessorInput getCxxPreprocessorInput(final CxxPlatform cxxPlatform,HeaderVisibility headerVisibility) throws NoSuchBuildTargetException {
  CxxPreprocessorInput.Builder builder=CxxPreprocessorInput.builder();
switch (headerVisibility) {
case PUBLIC:
    if (hasHeaders(cxxPlatform)) {
      CxxPreprocessables.addHeaderSymlinkTree(builder,getBuildTarget(),ruleResolver,cxxPlatform,headerVisibility,CxxPreprocessables.IncludeType.SYSTEM);
    }
  builder.putAllPreprocessorFlags(Preconditions.checkNotNull(getExportedPreprocessorFlags(cxxPlatform)));
builder.addAllFrameworks(args.frameworks);
final Iterable<SourcePath> includePaths=args.includeDirs.stream().map(input -> PrebuiltCxxLibraryDescription.getApplicableSourcePath(params.getBuildTarget(),params.getCellRoots(),params.getProjectFilesystem(),ruleResolver,cxxPlatform,input,Optional.empty())).collect(MoreCollectors.toImmutableList());
for (SourcePath includePath : includePaths) {
builder.addIncludes(CxxHeadersDir.of(CxxPreprocessables.IncludeType.SYSTEM,includePath));
}
return builder.build();
case PRIVATE:
return builder.build();
}
throw new RuntimeException(""String_Node_Str"" + headerVisibility);
}",0.9883624272651704
53004,"@Override public <A extends Arg>BuildRule createBuildRule(TargetGraph targetGraph,final BuildRuleParams params,final BuildRuleResolver ruleResolver,final A args) throws NoSuchBuildTargetException {
  Optional<Map.Entry<Flavor,Type>> type=LIBRARY_TYPE.getFlavorAndValue(params.getBuildTarget());
  Optional<Map.Entry<Flavor,CxxPlatform>> platform=cxxPlatforms.getFlavorAndValue(params.getBuildTarget());
  if (type.isPresent()) {
    Preconditions.checkState(platform.isPresent());
    if (type.get().getValue() == Type.EXPORTED_HEADERS) {
      return createExportedHeaderSymlinkTreeBuildRule(params,ruleResolver,platform.get().getValue(),args);
    }
 else     if (type.get().getValue() == Type.SHARED) {
      return createSharedLibraryBuildRule(params,ruleResolver,platform.get().getValue(),args);
    }
  }
  final SourcePathResolver pathResolver=new SourcePathResolver(ruleResolver);
  final boolean headerOnly=args.headerOnly.orElse(false);
  final boolean forceStatic=args.forceStatic.orElse(false);
  return new PrebuiltCxxLibrary(params,pathResolver){
    private final Map<Pair<Flavor,Linker.LinkableDepType>,NativeLinkableInput> nativeLinkableCache=new HashMap<>();
    private final LoadingCache<CxxPreprocessables.CxxPreprocessorInputCacheKey,ImmutableMap<BuildTarget,CxxPreprocessorInput>> transitiveCxxPreprocessorInputCache=CxxPreprocessables.getTransitiveCxxPreprocessorInputCache(this);
    private boolean hasHeaders(    CxxPlatform cxxPlatform){
      if (!args.exportedHeaders.isEmpty()) {
        return true;
      }
      for (      SourceList sourceList : args.exportedPlatformHeaders.getMatchingValues(cxxPlatform.getFlavor().toString())) {
        if (!sourceList.isEmpty()) {
          return true;
        }
      }
      return false;
    }
    private ImmutableListMultimap<CxxSource.Type,String> getExportedPreprocessorFlags(    CxxPlatform cxxPlatform){
      return CxxFlags.getLanguageFlags(args.exportedPreprocessorFlags,args.exportedPlatformPreprocessorFlags,args.exportedLangPreprocessorFlags,cxxPlatform);
    }
    @Override public ImmutableList<String> getExportedLinkerFlags(    CxxPlatform cxxPlatform){
      return CxxFlags.getFlags(args.exportedLinkerFlags,args.exportedPlatformLinkerFlags,cxxPlatform);
    }
    private String getSoname(    CxxPlatform cxxPlatform){
      return PrebuiltCxxLibraryDescription.getSoname(getBuildTarget(),params.getCellRoots(),ruleResolver,cxxPlatform,args.soname,args.libName);
    }
    private boolean isPlatformSupported(    CxxPlatform cxxPlatform){
      return !args.supportedPlatformsRegex.isPresent() || args.supportedPlatformsRegex.get().matcher(cxxPlatform.getFlavor().toString()).find();
    }
    /** 
 * Makes sure all build rules needed to produce the shared library are added to the action graph.
 * @return the {@link SourcePath} representing the actual shared library.
 */
    private SourcePath requireSharedLibrary(    CxxPlatform cxxPlatform) throws NoSuchBuildTargetException {
      SourcePath sharedLibraryPath=PrebuiltCxxLibraryDescription.getSharedLibraryPath(getBuildTarget(),params.getCellRoots(),getProjectFilesystem(),ruleResolver,cxxPlatform,args.libDir,args.libName);
      if (sharedLibraryPath instanceof BuildTargetSourcePath || params.getProjectFilesystem().exists(getResolver().getAbsolutePath(sharedLibraryPath))) {
        return sharedLibraryPath;
      }
      BuildRule sharedLibrary=ruleResolver.requireRule(getBuildTarget().withFlavors(cxxPlatform.getFlavor(),CxxDescriptionEnhancer.SHARED_FLAVOR));
      return new BuildTargetSourcePath(sharedLibrary.getBuildTarget());
    }
    /** 
 * @return the {@link Optional} containing a {@link SourcePath} representing the actualstatic PIC library.
 */
    private Optional<SourcePath> getStaticPicLibrary(    CxxPlatform cxxPlatform){
      SourcePath staticPicLibraryPath=PrebuiltCxxLibraryDescription.getStaticPicLibraryPath(getBuildTarget(),params.getCellRoots(),params.getProjectFilesystem(),ruleResolver,cxxPlatform,args.libDir,args.libName);
      if (params.getProjectFilesystem().exists(getResolver().getAbsolutePath(staticPicLibraryPath))) {
        return Optional.of(staticPicLibraryPath);
      }
      SourcePath staticLibraryPath=PrebuiltCxxLibraryDescription.getStaticLibraryPath(getBuildTarget(),params.getCellRoots(),getProjectFilesystem(),ruleResolver,cxxPlatform,args.libDir,args.libName);
      if (params.getProjectFilesystem().exists(getResolver().getAbsolutePath(staticLibraryPath))) {
        return Optional.of(staticLibraryPath);
      }
      return Optional.empty();
    }
    @Override public Iterable<? extends CxxPreprocessorDep> getCxxPreprocessorDeps(    CxxPlatform cxxPlatform){
      if (!isPlatformSupported(cxxPlatform)) {
        return ImmutableList.of();
      }
      return FluentIterable.from(getDeps()).filter(CxxPreprocessorDep.class);
    }
    @Override public CxxPreprocessorInput getCxxPreprocessorInput(    final CxxPlatform cxxPlatform,    HeaderVisibility headerVisibility) throws NoSuchBuildTargetException {
      CxxPreprocessorInput.Builder builder=CxxPreprocessorInput.builder();
switch (headerVisibility) {
case PUBLIC:
        if (Preconditions.checkNotNull(hasHeaders(cxxPlatform))) {
          CxxPreprocessables.addHeaderSymlinkTree(builder,getBuildTarget(),ruleResolver,cxxPlatform,headerVisibility,CxxPreprocessables.IncludeType.SYSTEM);
        }
      builder.putAllPreprocessorFlags(Preconditions.checkNotNull(getExportedPreprocessorFlags(cxxPlatform)));
    builder.addAllFrameworks(args.frameworks);
  final Iterable<SourcePath> includePaths=args.includeDirs.stream().map(input -> PrebuiltCxxLibraryDescription.getApplicableSourcePath(params.getBuildTarget(),params.getCellRoots(),params.getProjectFilesystem(),ruleResolver,cxxPlatform,input,Optional.empty())).collect(MoreCollectors.toImmutableList());
for (SourcePath includePath : includePaths) {
  builder.addIncludes(CxxHeadersDir.of(CxxPreprocessables.IncludeType.SYSTEM,includePath));
}
return builder.build();
case PRIVATE:
return builder.build();
}
throw new RuntimeException(""String_Node_Str"" + headerVisibility);
}
@Override public Optional<HeaderSymlinkTree> getExportedHeaderSymlinkTree(CxxPlatform cxxPlatform){
if (hasHeaders(cxxPlatform)) {
return Optional.of(CxxPreprocessables.requireHeaderSymlinkTreeForLibraryTarget(ruleResolver,getBuildTarget(),cxxPlatform.getFlavor()));
}
 else {
return Optional.empty();
}
}
@Override public ImmutableMap<BuildTarget,CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(CxxPlatform cxxPlatform,HeaderVisibility headerVisibility) throws NoSuchBuildTargetException {
return transitiveCxxPreprocessorInputCache.getUnchecked(ImmutableCxxPreprocessorInputCacheKey.of(cxxPlatform,headerVisibility));
}
@Override public Iterable<NativeLinkable> getNativeLinkableDeps(){
return getDeclaredDeps().stream().filter(r -> r instanceof NativeLinkable).map(r -> (NativeLinkable)r).collect(MoreCollectors.toImmutableList());
}
@Override public Iterable<NativeLinkable> getNativeLinkableDepsForPlatform(CxxPlatform cxxPlatform){
if (!isPlatformSupported(cxxPlatform)) {
return ImmutableList.of();
}
return getNativeLinkableDeps();
}
@Override public Iterable<? extends NativeLinkable> getNativeLinkableExportedDeps(){
return args.exportedDeps.stream().map(ruleResolver::getRule).filter(r -> r instanceof NativeLinkable).map(r -> (NativeLinkable)r).collect(MoreCollectors.toImmutableList());
}
@Override public Iterable<? extends NativeLinkable> getNativeLinkableExportedDepsForPlatform(CxxPlatform cxxPlatform){
if (!isPlatformSupported(cxxPlatform)) {
return ImmutableList.of();
}
return getNativeLinkableExportedDeps();
}
private NativeLinkableInput getNativeLinkableInputUncached(CxxPlatform cxxPlatform,Linker.LinkableDepType type) throws NoSuchBuildTargetException {
if (!isPlatformSupported(cxxPlatform)) {
return NativeLinkableInput.of();
}
ImmutableList.Builder<com.facebook.buck.rules.args.Arg> linkerArgsBuilder=ImmutableList.builder();
linkerArgsBuilder.addAll(StringArg.from(Preconditions.checkNotNull(getExportedLinkerFlags(cxxPlatform))));
if (!headerOnly) {
if (type == Linker.LinkableDepType.SHARED) {
Preconditions.checkState(getPreferredLinkage(cxxPlatform) != Linkage.STATIC);
final SourcePath sharedLibrary=requireSharedLibrary(cxxPlatform);
if (args.linkWithoutSoname) {
if (!(sharedLibrary instanceof PathSourcePath)) {
throw new HumanReadableException(""String_Node_Str"",getBuildTarget());
}
linkerArgsBuilder.add(new RelativeLinkArg((PathSourcePath)sharedLibrary));
}
 else {
linkerArgsBuilder.add(new SourcePathArg(getResolver(),requireSharedLibrary(cxxPlatform)));
}
}
 else {
Preconditions.checkState(getPreferredLinkage(cxxPlatform) != Linkage.SHARED);
SourcePath staticLibraryPath=type == Linker.LinkableDepType.STATIC_PIC ? getStaticPicLibrary(cxxPlatform).get() : PrebuiltCxxLibraryDescription.getStaticLibraryPath(getBuildTarget(),params.getCellRoots(),params.getProjectFilesystem(),ruleResolver,cxxPlatform,args.libDir,args.libName);
SourcePathArg staticLibrary=new SourcePathArg(getResolver(),staticLibraryPath);
if (args.linkWhole) {
Linker linker=cxxPlatform.getLd().resolve(ruleResolver);
linkerArgsBuilder.addAll(linker.linkWhole(staticLibrary));
}
 else {
linkerArgsBuilder.add(FileListableLinkerInputArg.withSourcePathArg(staticLibrary));
}
}
}
final ImmutableList<com.facebook.buck.rules.args.Arg> linkerArgs=linkerArgsBuilder.build();
return NativeLinkableInput.of(linkerArgs,args.frameworks,args.libraries);
}
@Override public NativeLinkableInput getNativeLinkableInput(CxxPlatform cxxPlatform,Linker.LinkableDepType type) throws NoSuchBuildTargetException {
Pair<Flavor,Linker.LinkableDepType> key=new Pair<>(cxxPlatform.getFlavor(),type);
NativeLinkableInput input=nativeLinkableCache.get(key);
if (input == null) {
input=getNativeLinkableInputUncached(cxxPlatform,type);
nativeLinkableCache.put(key,input);
}
return input;
}
@Override public NativeLinkable.Linkage getPreferredLinkage(CxxPlatform cxxPlatform){
if (headerOnly) {
return Linkage.ANY;
}
if (forceStatic) {
return Linkage.STATIC;
}
if (args.provided || !getStaticPicLibrary(cxxPlatform).isPresent()) {
return Linkage.SHARED;
}
return Linkage.ANY;
}
@Override public Iterable<AndroidPackageable> getRequiredPackageables(){
return AndroidPackageableCollector.getPackageableRules(params.getDeps());
}
@Override public void addToCollector(AndroidPackageableCollector collector){
if (args.canBeAsset) {
collector.addNativeLinkableAsset(this);
}
 else {
collector.addNativeLinkable(this);
}
}
@Override public ImmutableMap<String,SourcePath> getSharedLibraries(CxxPlatform cxxPlatform) throws NoSuchBuildTargetException {
if (!isPlatformSupported(cxxPlatform)) {
return ImmutableMap.of();
}
String resolvedSoname=getSoname(cxxPlatform);
ImmutableMap.Builder<String,SourcePath> solibs=ImmutableMap.builder();
if (!headerOnly && !args.provided) {
SourcePath sharedLibrary=requireSharedLibrary(cxxPlatform);
solibs.put(resolvedSoname,sharedLibrary);
}
return solibs.build();
}
@Override public Optional<NativeLinkTarget> getNativeLinkTarget(CxxPlatform cxxPlatform){
if (getPreferredLinkage(cxxPlatform) == Linkage.SHARED) {
return Optional.empty();
}
return Optional.of(new NativeLinkTarget(){
@Override public BuildTarget getBuildTarget(){
return params.getBuildTarget();
}
@Override public NativeLinkTargetMode getNativeLinkTargetMode(CxxPlatform cxxPlatform){
return NativeLinkTargetMode.library(getSoname(cxxPlatform));
}
@Override public Iterable<? extends NativeLinkable> getNativeLinkTargetDeps(CxxPlatform cxxPlatform){
return Iterables.concat(getNativeLinkableDepsForPlatform(cxxPlatform),getNativeLinkableExportedDepsForPlatform(cxxPlatform));
}
@Override public NativeLinkableInput getNativeLinkTargetInput(CxxPlatform cxxPlatform) throws NoSuchBuildTargetException {
return NativeLinkableInput.builder().addAllArgs(StringArg.from(getExportedLinkerFlags(cxxPlatform))).addAllArgs(cxxPlatform.getLd().resolve(ruleResolver).linkWhole(new SourcePathArg(getResolver(),getStaticPicLibrary(cxxPlatform).get()))).build();
}
@Override public Optional<Path> getNativeLinkTargetOutputPath(CxxPlatform cxxPlatform){
return Optional.empty();
}
}
);
}
}
;
}","@Override public <A extends Arg>BuildRule createBuildRule(TargetGraph targetGraph,final BuildRuleParams params,final BuildRuleResolver ruleResolver,final A args) throws NoSuchBuildTargetException {
  Optional<Map.Entry<Flavor,Type>> type=LIBRARY_TYPE.getFlavorAndValue(params.getBuildTarget());
  Optional<Map.Entry<Flavor,CxxPlatform>> platform=cxxPlatforms.getFlavorAndValue(params.getBuildTarget());
  if (type.isPresent()) {
    Preconditions.checkState(platform.isPresent());
    if (type.get().getValue() == Type.EXPORTED_HEADERS) {
      return createExportedHeaderSymlinkTreeBuildRule(params,ruleResolver,platform.get().getValue(),args);
    }
 else     if (type.get().getValue() == Type.SHARED) {
      return createSharedLibraryBuildRule(params,ruleResolver,platform.get().getValue(),args);
    }
  }
  final SourcePathResolver pathResolver=new SourcePathResolver(ruleResolver);
  final boolean headerOnly=args.headerOnly.orElse(false);
  final boolean forceStatic=args.forceStatic.orElse(false);
  return new PrebuiltCxxLibrary(params,pathResolver){
    private final Map<Pair<Flavor,Linker.LinkableDepType>,NativeLinkableInput> nativeLinkableCache=new HashMap<>();
    private final LoadingCache<CxxPreprocessables.CxxPreprocessorInputCacheKey,ImmutableMap<BuildTarget,CxxPreprocessorInput>> transitiveCxxPreprocessorInputCache=CxxPreprocessables.getTransitiveCxxPreprocessorInputCache(this);
    private boolean hasHeaders(    CxxPlatform cxxPlatform){
      if (!args.exportedHeaders.isEmpty()) {
        return true;
      }
      for (      SourceList sourceList : args.exportedPlatformHeaders.getMatchingValues(cxxPlatform.getFlavor().toString())) {
        if (!sourceList.isEmpty()) {
          return true;
        }
      }
      return false;
    }
    private ImmutableListMultimap<CxxSource.Type,String> getExportedPreprocessorFlags(    CxxPlatform cxxPlatform){
      return CxxFlags.getLanguageFlags(args.exportedPreprocessorFlags,args.exportedPlatformPreprocessorFlags,args.exportedLangPreprocessorFlags,cxxPlatform);
    }
    @Override public ImmutableList<String> getExportedLinkerFlags(    CxxPlatform cxxPlatform){
      return CxxFlags.getFlags(args.exportedLinkerFlags,args.exportedPlatformLinkerFlags,cxxPlatform);
    }
    private String getSoname(    CxxPlatform cxxPlatform){
      return PrebuiltCxxLibraryDescription.getSoname(getBuildTarget(),params.getCellRoots(),ruleResolver,cxxPlatform,args.soname,args.libName);
    }
    private boolean isPlatformSupported(    CxxPlatform cxxPlatform){
      return !args.supportedPlatformsRegex.isPresent() || args.supportedPlatformsRegex.get().matcher(cxxPlatform.getFlavor().toString()).find();
    }
    /** 
 * Makes sure all build rules needed to produce the shared library are added to the action graph.
 * @return the {@link SourcePath} representing the actual shared library.
 */
    private SourcePath requireSharedLibrary(    CxxPlatform cxxPlatform) throws NoSuchBuildTargetException {
      SourcePath sharedLibraryPath=PrebuiltCxxLibraryDescription.getSharedLibraryPath(getBuildTarget(),params.getCellRoots(),getProjectFilesystem(),ruleResolver,cxxPlatform,args.libDir,args.libName);
      if (sharedLibraryPath instanceof BuildTargetSourcePath || params.getProjectFilesystem().exists(getResolver().getAbsolutePath(sharedLibraryPath))) {
        return sharedLibraryPath;
      }
      BuildRule sharedLibrary=ruleResolver.requireRule(getBuildTarget().withFlavors(cxxPlatform.getFlavor(),CxxDescriptionEnhancer.SHARED_FLAVOR));
      return new BuildTargetSourcePath(sharedLibrary.getBuildTarget());
    }
    /** 
 * @return the {@link Optional} containing a {@link SourcePath} representing the actualstatic PIC library.
 */
    private Optional<SourcePath> getStaticPicLibrary(    CxxPlatform cxxPlatform){
      SourcePath staticPicLibraryPath=PrebuiltCxxLibraryDescription.getStaticPicLibraryPath(getBuildTarget(),params.getCellRoots(),params.getProjectFilesystem(),ruleResolver,cxxPlatform,args.libDir,args.libName);
      if (params.getProjectFilesystem().exists(getResolver().getAbsolutePath(staticPicLibraryPath))) {
        return Optional.of(staticPicLibraryPath);
      }
      SourcePath staticLibraryPath=PrebuiltCxxLibraryDescription.getStaticLibraryPath(getBuildTarget(),params.getCellRoots(),getProjectFilesystem(),ruleResolver,cxxPlatform,args.libDir,args.libName);
      if (params.getProjectFilesystem().exists(getResolver().getAbsolutePath(staticLibraryPath))) {
        return Optional.of(staticLibraryPath);
      }
      return Optional.empty();
    }
    @Override public Iterable<? extends CxxPreprocessorDep> getCxxPreprocessorDeps(    CxxPlatform cxxPlatform){
      if (!isPlatformSupported(cxxPlatform)) {
        return ImmutableList.of();
      }
      return FluentIterable.from(getDeps()).filter(CxxPreprocessorDep.class);
    }
    @Override public CxxPreprocessorInput getCxxPreprocessorInput(    final CxxPlatform cxxPlatform,    HeaderVisibility headerVisibility) throws NoSuchBuildTargetException {
      CxxPreprocessorInput.Builder builder=CxxPreprocessorInput.builder();
switch (headerVisibility) {
case PUBLIC:
        if (hasHeaders(cxxPlatform)) {
          CxxPreprocessables.addHeaderSymlinkTree(builder,getBuildTarget(),ruleResolver,cxxPlatform,headerVisibility,CxxPreprocessables.IncludeType.SYSTEM);
        }
      builder.putAllPreprocessorFlags(Preconditions.checkNotNull(getExportedPreprocessorFlags(cxxPlatform)));
    builder.addAllFrameworks(args.frameworks);
  final Iterable<SourcePath> includePaths=args.includeDirs.stream().map(input -> PrebuiltCxxLibraryDescription.getApplicableSourcePath(params.getBuildTarget(),params.getCellRoots(),params.getProjectFilesystem(),ruleResolver,cxxPlatform,input,Optional.empty())).collect(MoreCollectors.toImmutableList());
for (SourcePath includePath : includePaths) {
  builder.addIncludes(CxxHeadersDir.of(CxxPreprocessables.IncludeType.SYSTEM,includePath));
}
return builder.build();
case PRIVATE:
return builder.build();
}
throw new RuntimeException(""String_Node_Str"" + headerVisibility);
}
@Override public Optional<HeaderSymlinkTree> getExportedHeaderSymlinkTree(CxxPlatform cxxPlatform){
if (hasHeaders(cxxPlatform)) {
return Optional.of(CxxPreprocessables.requireHeaderSymlinkTreeForLibraryTarget(ruleResolver,getBuildTarget(),cxxPlatform.getFlavor()));
}
 else {
return Optional.empty();
}
}
@Override public ImmutableMap<BuildTarget,CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(CxxPlatform cxxPlatform,HeaderVisibility headerVisibility) throws NoSuchBuildTargetException {
return transitiveCxxPreprocessorInputCache.getUnchecked(ImmutableCxxPreprocessorInputCacheKey.of(cxxPlatform,headerVisibility));
}
@Override public Iterable<NativeLinkable> getNativeLinkableDeps(){
return getDeclaredDeps().stream().filter(r -> r instanceof NativeLinkable).map(r -> (NativeLinkable)r).collect(MoreCollectors.toImmutableList());
}
@Override public Iterable<NativeLinkable> getNativeLinkableDepsForPlatform(CxxPlatform cxxPlatform){
if (!isPlatformSupported(cxxPlatform)) {
return ImmutableList.of();
}
return getNativeLinkableDeps();
}
@Override public Iterable<? extends NativeLinkable> getNativeLinkableExportedDeps(){
return args.exportedDeps.stream().map(ruleResolver::getRule).filter(r -> r instanceof NativeLinkable).map(r -> (NativeLinkable)r).collect(MoreCollectors.toImmutableList());
}
@Override public Iterable<? extends NativeLinkable> getNativeLinkableExportedDepsForPlatform(CxxPlatform cxxPlatform){
if (!isPlatformSupported(cxxPlatform)) {
return ImmutableList.of();
}
return getNativeLinkableExportedDeps();
}
private NativeLinkableInput getNativeLinkableInputUncached(CxxPlatform cxxPlatform,Linker.LinkableDepType type) throws NoSuchBuildTargetException {
if (!isPlatformSupported(cxxPlatform)) {
return NativeLinkableInput.of();
}
ImmutableList.Builder<com.facebook.buck.rules.args.Arg> linkerArgsBuilder=ImmutableList.builder();
linkerArgsBuilder.addAll(StringArg.from(Preconditions.checkNotNull(getExportedLinkerFlags(cxxPlatform))));
if (!headerOnly) {
if (type == Linker.LinkableDepType.SHARED) {
Preconditions.checkState(getPreferredLinkage(cxxPlatform) != Linkage.STATIC);
final SourcePath sharedLibrary=requireSharedLibrary(cxxPlatform);
if (args.linkWithoutSoname) {
if (!(sharedLibrary instanceof PathSourcePath)) {
throw new HumanReadableException(""String_Node_Str"",getBuildTarget());
}
linkerArgsBuilder.add(new RelativeLinkArg((PathSourcePath)sharedLibrary));
}
 else {
linkerArgsBuilder.add(new SourcePathArg(getResolver(),requireSharedLibrary(cxxPlatform)));
}
}
 else {
Preconditions.checkState(getPreferredLinkage(cxxPlatform) != Linkage.SHARED);
SourcePath staticLibraryPath=type == Linker.LinkableDepType.STATIC_PIC ? getStaticPicLibrary(cxxPlatform).get() : PrebuiltCxxLibraryDescription.getStaticLibraryPath(getBuildTarget(),params.getCellRoots(),params.getProjectFilesystem(),ruleResolver,cxxPlatform,args.libDir,args.libName);
SourcePathArg staticLibrary=new SourcePathArg(getResolver(),staticLibraryPath);
if (args.linkWhole) {
Linker linker=cxxPlatform.getLd().resolve(ruleResolver);
linkerArgsBuilder.addAll(linker.linkWhole(staticLibrary));
}
 else {
linkerArgsBuilder.add(FileListableLinkerInputArg.withSourcePathArg(staticLibrary));
}
}
}
final ImmutableList<com.facebook.buck.rules.args.Arg> linkerArgs=linkerArgsBuilder.build();
return NativeLinkableInput.of(linkerArgs,args.frameworks,args.libraries);
}
@Override public NativeLinkableInput getNativeLinkableInput(CxxPlatform cxxPlatform,Linker.LinkableDepType type) throws NoSuchBuildTargetException {
Pair<Flavor,Linker.LinkableDepType> key=new Pair<>(cxxPlatform.getFlavor(),type);
NativeLinkableInput input=nativeLinkableCache.get(key);
if (input == null) {
input=getNativeLinkableInputUncached(cxxPlatform,type);
nativeLinkableCache.put(key,input);
}
return input;
}
@Override public NativeLinkable.Linkage getPreferredLinkage(CxxPlatform cxxPlatform){
if (headerOnly) {
return Linkage.ANY;
}
if (forceStatic) {
return Linkage.STATIC;
}
if (args.provided || !getStaticPicLibrary(cxxPlatform).isPresent()) {
return Linkage.SHARED;
}
return Linkage.ANY;
}
@Override public Iterable<AndroidPackageable> getRequiredPackageables(){
return AndroidPackageableCollector.getPackageableRules(params.getDeps());
}
@Override public void addToCollector(AndroidPackageableCollector collector){
if (args.canBeAsset) {
collector.addNativeLinkableAsset(this);
}
 else {
collector.addNativeLinkable(this);
}
}
@Override public ImmutableMap<String,SourcePath> getSharedLibraries(CxxPlatform cxxPlatform) throws NoSuchBuildTargetException {
if (!isPlatformSupported(cxxPlatform)) {
return ImmutableMap.of();
}
String resolvedSoname=getSoname(cxxPlatform);
ImmutableMap.Builder<String,SourcePath> solibs=ImmutableMap.builder();
if (!headerOnly && !args.provided) {
SourcePath sharedLibrary=requireSharedLibrary(cxxPlatform);
solibs.put(resolvedSoname,sharedLibrary);
}
return solibs.build();
}
@Override public Optional<NativeLinkTarget> getNativeLinkTarget(CxxPlatform cxxPlatform){
if (getPreferredLinkage(cxxPlatform) == Linkage.SHARED) {
return Optional.empty();
}
return Optional.of(new NativeLinkTarget(){
@Override public BuildTarget getBuildTarget(){
return params.getBuildTarget();
}
@Override public NativeLinkTargetMode getNativeLinkTargetMode(CxxPlatform cxxPlatform){
return NativeLinkTargetMode.library(getSoname(cxxPlatform));
}
@Override public Iterable<? extends NativeLinkable> getNativeLinkTargetDeps(CxxPlatform cxxPlatform){
return Iterables.concat(getNativeLinkableDepsForPlatform(cxxPlatform),getNativeLinkableExportedDepsForPlatform(cxxPlatform));
}
@Override public NativeLinkableInput getNativeLinkTargetInput(CxxPlatform cxxPlatform) throws NoSuchBuildTargetException {
return NativeLinkableInput.builder().addAllArgs(StringArg.from(getExportedLinkerFlags(cxxPlatform))).addAllArgs(cxxPlatform.getLd().resolve(ruleResolver).linkWhole(new SourcePathArg(getResolver(),getStaticPicLibrary(cxxPlatform).get()))).build();
}
@Override public Optional<Path> getNativeLinkTargetOutputPath(CxxPlatform cxxPlatform){
return Optional.empty();
}
}
);
}
}
;
}",0.9988500082142272
53005,"@Override public void evaluate() throws Throwable {
  Future<Throwable> submitted=executor.submit(callable);
  try {
    Throwable result=submitted.get(timeout,TimeUnit.MILLISECONDS);
    if (result == null) {
      return;
    }
    if (result instanceof TimeoutException) {
      throw new Exception(""String_Node_Str"",result);
    }
    throw result;
  }
 catch (  TimeoutException e) {
    System.err.printf(""String_Node_Str"",testName);
    for (    Map.Entry<Thread,StackTraceElement[]> t : Thread.getAllStackTraces().entrySet()) {
      Thread thread=t.getKey();
      System.err.printf(""String_Node_Str"",thread.getName(),thread.getId(),thread.getId());
      System.err.printf(""String_Node_Str"",thread.getState());
      for (      StackTraceElement element : t.getValue()) {
        System.err.printf(""String_Node_Str"",element);
      }
    }
    submitted.cancel(true);
    String message=String.format(""String_Node_Str"",testName,timeout);
    throw new Exception(message);
  }
}","@Override public void evaluate() throws Throwable {
  Future<Throwable> submitted=executor.submit(callable);
  try {
    Throwable result=submitted.get(timeout,TimeUnit.MILLISECONDS);
    if (result == null) {
      return;
    }
    if (result instanceof TimeoutException) {
      throw new Exception(""String_Node_Str"",result);
    }
    throw result;
  }
 catch (  TimeoutException e) {
    System.err.printf(""String_Node_Str"",testName);
    for (    Map.Entry<Thread,StackTraceElement[]> t : Thread.getAllStackTraces().entrySet()) {
      Thread thread=t.getKey();
      System.err.printf(""String_Node_Str"",thread.getName(),thread.getId());
      System.err.printf(""String_Node_Str"",thread.getState());
      for (      StackTraceElement element : t.getValue()) {
        System.err.printf(""String_Node_Str"",element);
      }
    }
    submitted.cancel(true);
    String message=String.format(""String_Node_Str"",testName,timeout);
    throw new Exception(message);
  }
}",0.9923430321592648
53006,"@Nullable public ListenableFuture<Void> getShutdownFullyCompleteFuture(){
  Preconditions.checkState(closing.get(),""String_Node_Str"");
  return Preconditions.checkNotNull(shutdownFuture);
}","@Nullable public synchronized ListenableFuture<Void> getShutdownFullyCompleteFuture(){
  Preconditions.checkState(closing.get(),""String_Node_Str"");
  return Preconditions.checkNotNull(shutdownFuture);
}",0.9667519181585678
53007,"public static AppleCxxPlatform build(AppleSdk targetSdk,String minVersion,String targetArchitecture,AppleSdkPaths sdkPaths,BuckConfig buckConfig,AppleConfig appleConfig,Optional<ProcessExecutor> processExecutor,Optional<AppleToolchain> swiftToolChain){
  return buildWithExecutableChecker(targetSdk,minVersion,targetArchitecture,sdkPaths,buckConfig,appleConfig,new ExecutableFinder(),processExecutor,swiftToolChain);
}","public static AppleCxxPlatform build(ProjectFilesystem filesystem,AppleSdk targetSdk,String minVersion,String targetArchitecture,AppleSdkPaths sdkPaths,BuckConfig buckConfig,AppleConfig appleConfig,Optional<ProcessExecutor> processExecutor,Optional<AppleToolchain> swiftToolChain){
  return buildWithExecutableChecker(filesystem,targetSdk,minVersion,targetArchitecture,sdkPaths,buckConfig,appleConfig,new ExecutableFinder(),processExecutor,swiftToolChain);
}",0.954337899543379
53008,"@VisibleForTesting static AppleCxxPlatform buildWithExecutableChecker(AppleSdk targetSdk,String minVersion,String targetArchitecture,final AppleSdkPaths sdkPaths,BuckConfig buckConfig,AppleConfig appleConfig,ExecutableFinder executableFinder,Optional<ProcessExecutor> processExecutor,Optional<AppleToolchain> swiftToolChain){
  AppleCxxPlatform.Builder platformBuilder=AppleCxxPlatform.builder();
  ImmutableList.Builder<Path> toolSearchPathsBuilder=ImmutableList.builder();
  toolSearchPathsBuilder.add(sdkPaths.getSdkPath().resolve(USR_BIN)).add(sdkPaths.getSdkPath().resolve(""String_Node_Str"").resolve(USR_BIN)).add(sdkPaths.getPlatformPath().resolve(""String_Node_Str"").resolve(USR_BIN));
  for (  Path toolchainPath : sdkPaths.getToolchainPaths()) {
    toolSearchPathsBuilder.add(toolchainPath.resolve(USR_BIN));
  }
  if (sdkPaths.getDeveloperPath().isPresent()) {
    toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve(USR_BIN));
    toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve(""String_Node_Str""));
  }
  ImmutableList.Builder<String> cflagsBuilder=ImmutableList.builder();
  cflagsBuilder.add(""String_Node_Str"",sdkPaths.getSdkPath().toString());
  cflagsBuilder.add(""String_Node_Str"",targetArchitecture);
  cflagsBuilder.add(targetSdk.getApplePlatform().getMinVersionFlagPrefix() + minVersion);
  if (targetSdk.getApplePlatform().equals(ApplePlatform.WATCHOS)) {
    cflagsBuilder.add(""String_Node_Str"");
  }
  ImmutableList.Builder<String> ldflagsBuilder=ImmutableList.builder();
  ldflagsBuilder.addAll(Linkers.iXlinker(""String_Node_Str"",targetSdk.getVersion(),""String_Node_Str""));
  if (targetSdk.getApplePlatform().equals(ApplePlatform.WATCHOS)) {
    ldflagsBuilder.addAll(Linkers.iXlinker(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  Optional<String> xcodeBuildVersion=Optional.empty();
  Optional<Path> developerPath=sdkPaths.getDeveloperPath();
  if (developerPath.isPresent()) {
    Path xcodeBundlePath=developerPath.get().getParent();
    if (xcodeBundlePath != null) {
      File xcodeInfoPlistPath=xcodeBundlePath.resolve(""String_Node_Str"").toFile();
      try {
        NSDictionary parsedXcodeInfoPlist=(NSDictionary)PropertyListParser.parse(xcodeInfoPlistPath);
        NSObject xcodeVersionObject=parsedXcodeInfoPlist.objectForKey(""String_Node_Str"");
        if (xcodeVersionObject != null) {
          Optional<String> xcodeVersion=Optional.of(xcodeVersionObject.toString());
          platformBuilder.setXcodeVersion(xcodeVersion);
        }
      }
 catch (      IOException e) {
        LOG.debug(""String_Node_Str"",xcodeInfoPlistPath);
      }
catch (      PropertyListFormatException|ParseException|ParserConfigurationException|SAXException e) {
        LOG.debug(""String_Node_Str"",xcodeInfoPlistPath);
      }
    }
    if (processExecutor.isPresent()) {
      xcodeBuildVersion=appleConfig.getXcodeBuildVersionSupplier(developerPath.get(),processExecutor.get()).get();
      platformBuilder.setXcodeBuildVersion(xcodeBuildVersion);
      LOG.debug(""String_Node_Str"" + xcodeBuildVersion.orElse(""String_Node_Str""));
    }
  }
  ImmutableList.Builder<String> versions=ImmutableList.builder();
  versions.add(targetSdk.getVersion());
  ImmutableList<String> toolchainVersions=targetSdk.getToolchains().stream().map(AppleToolchain::getVersion).flatMap(Optionals::toStream).collect(MoreCollectors.toImmutableList());
  if (toolchainVersions.isEmpty()) {
    if (!xcodeBuildVersion.isPresent()) {
      throw new HumanReadableException(""String_Node_Str"");
    }
    versions.add(xcodeBuildVersion.get());
  }
 else {
    versions.addAll(toolchainVersions);
  }
  String version=Joiner.on(':').join(versions.build());
  ImmutableList<Path> toolSearchPaths=toolSearchPathsBuilder.build();
  Tool clangPath=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool clangXxPath=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool ar=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool ranlib=VersionedTool.builder().setPath(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder)).setName(""String_Node_Str"").setVersion(version).build();
  Tool strip=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool nm=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool actool=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool ibtool=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool momc=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool xctest=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool dsymutil=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool lipo=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool lldb=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Optional<Path> stubBinaryPath=targetSdk.getApplePlatform().getStubBinaryPath().map(input -> sdkPaths.getSdkPath().resolve(input));
  CxxBuckConfig config=new CxxBuckConfig(buckConfig);
  ImmutableFlavor targetFlavor=ImmutableFlavor.of(ImmutableFlavor.replaceInvalidCharacters(targetSdk.getName() + ""String_Node_Str"" + targetArchitecture));
  ImmutableBiMap.Builder<Path,Path> sanitizerPaths=ImmutableBiMap.builder();
  sanitizerPaths.put(sdkPaths.getSdkPath(),Paths.get(""String_Node_Str""));
  sanitizerPaths.put(sdkPaths.getPlatformPath(),Paths.get(""String_Node_Str""));
  if (sdkPaths.getDeveloperPath().isPresent()) {
    sanitizerPaths.put(sdkPaths.getDeveloperPath().get(),Paths.get(""String_Node_Str""));
  }
  DebugPathSanitizer compilerDebugPathSanitizer=new MungingDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),sanitizerPaths.build());
  DebugPathSanitizer assemblerDebugPathSanitizer=new MungingDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),sanitizerPaths.build());
  ImmutableList<String> cflags=cflagsBuilder.build();
  ImmutableMap.Builder<String,String> macrosBuilder=ImmutableMap.builder();
  macrosBuilder.put(""String_Node_Str"",sdkPaths.getSdkPath().toString());
  macrosBuilder.put(""String_Node_Str"",sdkPaths.getPlatformPath().toString());
  macrosBuilder.put(""String_Node_Str"",targetArchitecture);
  if (sdkPaths.getDeveloperPath().isPresent()) {
    macrosBuilder.put(""String_Node_Str"",sdkPaths.getDeveloperPath().get().toString());
  }
  ImmutableMap<String,String> macros=macrosBuilder.build();
  Optional<String> buildVersion;
  Path platformVersionPlistPath=sdkPaths.getPlatformPath().resolve(""String_Node_Str"");
  try (InputStream versionPlist=Files.newInputStream(platformVersionPlistPath)){
    NSDictionary versionInfo=(NSDictionary)PropertyListParser.parse(versionPlist);
    try {
      buildVersion=Optional.of(versionInfo.objectForKey(""String_Node_Str"").toString());
    }
 catch (    NullPointerException e) {
      LOG.warn(""String_Node_Str"",platformVersionPlistPath);
      buildVersion=Optional.empty();
    }
  }
 catch (  NoSuchFileException e) {
    LOG.warn(""String_Node_Str"",platformVersionPlistPath);
    buildVersion=Optional.empty();
  }
catch (  PropertyListFormatException|SAXException|ParserConfigurationException|ParseException|IOException e) {
    LOG.warn(e,""String_Node_Str"",platformVersionPlistPath);
    buildVersion=Optional.empty();
  }
  PreprocessorProvider aspp=new PreprocessorProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  CompilerProvider as=new CompilerProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  PreprocessorProvider cpp=new PreprocessorProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  CompilerProvider cc=new CompilerProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  PreprocessorProvider cxxpp=new PreprocessorProvider(new ConstantToolProvider(clangXxPath),CxxToolProvider.Type.CLANG);
  CompilerProvider cxx=new CompilerProvider(new ConstantToolProvider(clangXxPath),CxxToolProvider.Type.CLANG);
  CxxPlatform cxxPlatform=CxxPlatforms.build(targetFlavor,config,as,aspp,cc,cxx,cpp,cxxpp,new DefaultLinkerProvider(LinkerProvider.Type.DARWIN,new ConstantToolProvider(clangXxPath)),ImmutableList.<String>builder().addAll(cflags).addAll(ldflagsBuilder.build()).build(),strip,new BsdArchiver(ar),ranlib,new PosixNmSymbolNameTool(nm),cflagsBuilder.build(),ImmutableList.of(),cflags,ImmutableList.of(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",Optional.of(compilerDebugPathSanitizer),Optional.of(assemblerDebugPathSanitizer),macros);
  ApplePlatform applePlatform=targetSdk.getApplePlatform();
  ImmutableList.Builder<Path> swiftOverrideSearchPathBuilder=ImmutableList.builder();
  AppleSdkPaths.Builder swiftSdkPathsBuilder=AppleSdkPaths.builder().from(sdkPaths);
  if (swiftToolChain.isPresent()) {
    swiftOverrideSearchPathBuilder.add(swiftToolChain.get().getPath().resolve(USR_BIN));
    swiftSdkPathsBuilder.setToolchainPaths(ImmutableList.of(swiftToolChain.get().getPath()));
  }
  Optional<SwiftPlatform> swiftPlatform=getSwiftPlatform(applePlatform.getName(),targetArchitecture + ""String_Node_Str"" + applePlatform.getSwiftName().orElse(applePlatform.getName())+ minVersion,version,swiftSdkPathsBuilder.build(),swiftOverrideSearchPathBuilder.addAll(toolSearchPaths).build(),executableFinder);
  platformBuilder.setCxxPlatform(cxxPlatform).setSwiftPlatform(swiftPlatform).setAppleSdk(targetSdk).setAppleSdkPaths(sdkPaths).setMinVersion(minVersion).setBuildVersion(buildVersion).setActool(actool).setIbtool(ibtool).setMomc(momc).setCopySceneKitAssets(getOptionalTool(""String_Node_Str"",toolSearchPaths,executableFinder,version)).setXctest(xctest).setDsymutil(dsymutil).setLipo(lipo).setStubBinary(stubBinaryPath).setLldb(lldb).setCodesignAllocate(getOptionalTool(""String_Node_Str"",toolSearchPaths,executableFinder,version));
  return platformBuilder.build();
}","@VisibleForTesting static AppleCxxPlatform buildWithExecutableChecker(ProjectFilesystem filesystem,AppleSdk targetSdk,String minVersion,String targetArchitecture,final AppleSdkPaths sdkPaths,BuckConfig buckConfig,AppleConfig appleConfig,ExecutableFinder executableFinder,Optional<ProcessExecutor> processExecutor,Optional<AppleToolchain> swiftToolChain){
  AppleCxxPlatform.Builder platformBuilder=AppleCxxPlatform.builder();
  ImmutableList.Builder<Path> toolSearchPathsBuilder=ImmutableList.builder();
  toolSearchPathsBuilder.add(sdkPaths.getSdkPath().resolve(USR_BIN)).add(sdkPaths.getSdkPath().resolve(""String_Node_Str"").resolve(USR_BIN)).add(sdkPaths.getPlatformPath().resolve(""String_Node_Str"").resolve(USR_BIN));
  for (  Path toolchainPath : sdkPaths.getToolchainPaths()) {
    toolSearchPathsBuilder.add(toolchainPath.resolve(USR_BIN));
  }
  if (sdkPaths.getDeveloperPath().isPresent()) {
    toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve(USR_BIN));
    toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve(""String_Node_Str""));
  }
  ImmutableList.Builder<String> cflagsBuilder=ImmutableList.builder();
  cflagsBuilder.add(""String_Node_Str"",sdkPaths.getSdkPath().toString());
  cflagsBuilder.add(""String_Node_Str"",targetArchitecture);
  cflagsBuilder.add(targetSdk.getApplePlatform().getMinVersionFlagPrefix() + minVersion);
  if (targetSdk.getApplePlatform().equals(ApplePlatform.WATCHOS)) {
    cflagsBuilder.add(""String_Node_Str"");
  }
  ImmutableList.Builder<String> ldflagsBuilder=ImmutableList.builder();
  ldflagsBuilder.addAll(Linkers.iXlinker(""String_Node_Str"",targetSdk.getVersion(),""String_Node_Str""));
  if (targetSdk.getApplePlatform().equals(ApplePlatform.WATCHOS)) {
    ldflagsBuilder.addAll(Linkers.iXlinker(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  Optional<String> xcodeBuildVersion=Optional.empty();
  Optional<Path> developerPath=sdkPaths.getDeveloperPath();
  if (developerPath.isPresent()) {
    Path xcodeBundlePath=developerPath.get().getParent();
    if (xcodeBundlePath != null) {
      File xcodeInfoPlistPath=xcodeBundlePath.resolve(""String_Node_Str"").toFile();
      try {
        NSDictionary parsedXcodeInfoPlist=(NSDictionary)PropertyListParser.parse(xcodeInfoPlistPath);
        NSObject xcodeVersionObject=parsedXcodeInfoPlist.objectForKey(""String_Node_Str"");
        if (xcodeVersionObject != null) {
          Optional<String> xcodeVersion=Optional.of(xcodeVersionObject.toString());
          platformBuilder.setXcodeVersion(xcodeVersion);
        }
      }
 catch (      IOException e) {
        LOG.debug(""String_Node_Str"",xcodeInfoPlistPath);
      }
catch (      PropertyListFormatException|ParseException|ParserConfigurationException|SAXException e) {
        LOG.debug(""String_Node_Str"",xcodeInfoPlistPath);
      }
    }
    if (processExecutor.isPresent()) {
      xcodeBuildVersion=appleConfig.getXcodeBuildVersionSupplier(developerPath.get(),processExecutor.get()).get();
      platformBuilder.setXcodeBuildVersion(xcodeBuildVersion);
      LOG.debug(""String_Node_Str"" + xcodeBuildVersion.orElse(""String_Node_Str""));
    }
  }
  ImmutableList.Builder<String> versions=ImmutableList.builder();
  versions.add(targetSdk.getVersion());
  ImmutableList<String> toolchainVersions=targetSdk.getToolchains().stream().map(AppleToolchain::getVersion).flatMap(Optionals::toStream).collect(MoreCollectors.toImmutableList());
  if (toolchainVersions.isEmpty()) {
    if (!xcodeBuildVersion.isPresent()) {
      throw new HumanReadableException(""String_Node_Str"");
    }
    versions.add(xcodeBuildVersion.get());
  }
 else {
    versions.addAll(toolchainVersions);
  }
  String version=Joiner.on(':').join(versions.build());
  ImmutableList<Path> toolSearchPaths=toolSearchPathsBuilder.build();
  Tool clangPath=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool clangXxPath=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool ar=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool ranlib=VersionedTool.builder().setPath(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder)).setName(""String_Node_Str"").setVersion(version).build();
  Tool strip=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool nm=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool actool=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool ibtool=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool momc=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool xctest=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool dsymutil=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool lipo=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Tool lldb=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),""String_Node_Str"",version);
  Optional<Path> stubBinaryPath=targetSdk.getApplePlatform().getStubBinaryPath().map(input -> sdkPaths.getSdkPath().resolve(input));
  CxxBuckConfig config=new CxxBuckConfig(buckConfig);
  ImmutableFlavor targetFlavor=ImmutableFlavor.of(ImmutableFlavor.replaceInvalidCharacters(targetSdk.getName() + ""String_Node_Str"" + targetArchitecture));
  ImmutableBiMap.Builder<Path,Path> sanitizerPaths=ImmutableBiMap.builder();
  sanitizerPaths.put(sdkPaths.getSdkPath(),Paths.get(""String_Node_Str""));
  sanitizerPaths.put(sdkPaths.getPlatformPath(),Paths.get(""String_Node_Str""));
  if (sdkPaths.getDeveloperPath().isPresent()) {
    sanitizerPaths.put(sdkPaths.getDeveloperPath().get(),Paths.get(""String_Node_Str""));
  }
  DebugPathSanitizer compilerDebugPathSanitizer=new PrefixMapDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),sanitizerPaths.build(),filesystem.getRootPath().toAbsolutePath(),CxxToolProvider.Type.CLANG);
  DebugPathSanitizer assemblerDebugPathSanitizer=new MungingDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),sanitizerPaths.build());
  ImmutableList<String> cflags=cflagsBuilder.build();
  ImmutableMap.Builder<String,String> macrosBuilder=ImmutableMap.builder();
  macrosBuilder.put(""String_Node_Str"",sdkPaths.getSdkPath().toString());
  macrosBuilder.put(""String_Node_Str"",sdkPaths.getPlatformPath().toString());
  macrosBuilder.put(""String_Node_Str"",targetArchitecture);
  if (sdkPaths.getDeveloperPath().isPresent()) {
    macrosBuilder.put(""String_Node_Str"",sdkPaths.getDeveloperPath().get().toString());
  }
  ImmutableMap<String,String> macros=macrosBuilder.build();
  Optional<String> buildVersion;
  Path platformVersionPlistPath=sdkPaths.getPlatformPath().resolve(""String_Node_Str"");
  try (InputStream versionPlist=Files.newInputStream(platformVersionPlistPath)){
    NSDictionary versionInfo=(NSDictionary)PropertyListParser.parse(versionPlist);
    try {
      buildVersion=Optional.of(versionInfo.objectForKey(""String_Node_Str"").toString());
    }
 catch (    NullPointerException e) {
      LOG.warn(""String_Node_Str"",platformVersionPlistPath);
      buildVersion=Optional.empty();
    }
  }
 catch (  NoSuchFileException e) {
    LOG.warn(""String_Node_Str"",platformVersionPlistPath);
    buildVersion=Optional.empty();
  }
catch (  PropertyListFormatException|SAXException|ParserConfigurationException|ParseException|IOException e) {
    LOG.warn(e,""String_Node_Str"",platformVersionPlistPath);
    buildVersion=Optional.empty();
  }
  PreprocessorProvider aspp=new PreprocessorProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  CompilerProvider as=new CompilerProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  PreprocessorProvider cpp=new PreprocessorProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  CompilerProvider cc=new CompilerProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  PreprocessorProvider cxxpp=new PreprocessorProvider(new ConstantToolProvider(clangXxPath),CxxToolProvider.Type.CLANG);
  CompilerProvider cxx=new CompilerProvider(new ConstantToolProvider(clangXxPath),CxxToolProvider.Type.CLANG);
  CxxPlatform cxxPlatform=CxxPlatforms.build(targetFlavor,config,as,aspp,cc,cxx,cpp,cxxpp,new DefaultLinkerProvider(LinkerProvider.Type.DARWIN,new ConstantToolProvider(clangXxPath)),ImmutableList.<String>builder().addAll(cflags).addAll(ldflagsBuilder.build()).build(),strip,new BsdArchiver(ar),ranlib,new PosixNmSymbolNameTool(nm),cflagsBuilder.build(),ImmutableList.of(),cflags,ImmutableList.of(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",compilerDebugPathSanitizer,assemblerDebugPathSanitizer,macros);
  ApplePlatform applePlatform=targetSdk.getApplePlatform();
  ImmutableList.Builder<Path> swiftOverrideSearchPathBuilder=ImmutableList.builder();
  AppleSdkPaths.Builder swiftSdkPathsBuilder=AppleSdkPaths.builder().from(sdkPaths);
  if (swiftToolChain.isPresent()) {
    swiftOverrideSearchPathBuilder.add(swiftToolChain.get().getPath().resolve(USR_BIN));
    swiftSdkPathsBuilder.setToolchainPaths(ImmutableList.of(swiftToolChain.get().getPath()));
  }
  Optional<SwiftPlatform> swiftPlatform=getSwiftPlatform(applePlatform.getName(),targetArchitecture + ""String_Node_Str"" + applePlatform.getSwiftName().orElse(applePlatform.getName())+ minVersion,version,swiftSdkPathsBuilder.build(),swiftOverrideSearchPathBuilder.addAll(toolSearchPaths).build(),executableFinder);
  platformBuilder.setCxxPlatform(cxxPlatform).setSwiftPlatform(swiftPlatform).setAppleSdk(targetSdk).setAppleSdkPaths(sdkPaths).setMinVersion(minVersion).setBuildVersion(buildVersion).setActool(actool).setIbtool(ibtool).setMomc(momc).setCopySceneKitAssets(getOptionalTool(""String_Node_Str"",toolSearchPaths,executableFinder,version)).setXctest(xctest).setDsymutil(dsymutil).setLipo(lipo).setStubBinary(stubBinaryPath).setLldb(lldb).setCodesignAllocate(getOptionalTool(""String_Node_Str"",toolSearchPaths,executableFinder,version));
  return platformBuilder.build();
}",0.9933498004940148
53009,"public static CxxPlatform build(Flavor flavor,final CxxBuckConfig config,CompilerProvider as,PreprocessorProvider aspp,CompilerProvider cc,CompilerProvider cxx,PreprocessorProvider cpp,PreprocessorProvider cxxpp,LinkerProvider ld,Iterable<String> ldFlags,Tool strip,final Archiver ar,final Tool ranlib,final SymbolNameTool nm,ImmutableList<String> asflags,ImmutableList<String> asppflags,ImmutableList<String> cflags,ImmutableList<String> cppflags,String sharedLibraryExtension,String sharedLibraryVersionedExtensionFormat,String staticLibraryExtension,String objectFileExtension,Optional<DebugPathSanitizer> compilerDebugPathSanitizer,Optional<DebugPathSanitizer> assemblerDebugPathSanitizer,ImmutableMap<String,String> flagMacros){
  CxxPlatform.Builder builder=CxxPlatform.builder();
  final Archiver arDelegate=ar instanceof LazyDelegatingArchiver ? ((LazyDelegatingArchiver)ar).getDelegate() : ar;
  builder.setFlavor(flavor).setAs(config.getCompilerProvider(""String_Node_Str"").orElse(as)).setAspp(config.getPreprocessorProvider(""String_Node_Str"").orElse(aspp)).setCc(config.getCompilerProvider(""String_Node_Str"").orElse(cc)).setCxx(config.getCompilerProvider(""String_Node_Str"").orElse(cxx)).setCpp(config.getPreprocessorProvider(""String_Node_Str"").orElse(cpp)).setCxxpp(config.getPreprocessorProvider(""String_Node_Str"").orElse(cxxpp)).setCuda(config.getCompilerProvider(""String_Node_Str"")).setCudapp(config.getPreprocessorProvider(""String_Node_Str"")).setAsm(config.getCompilerProvider(""String_Node_Str"")).setAsmpp(config.getPreprocessorProvider(""String_Node_Str"")).setLd(config.getLinkerProvider(""String_Node_Str"",ld.getType()).orElse(ld)).addAllLdflags(ldFlags).setAr(new LazyDelegatingArchiver(() -> getTool(""String_Node_Str"",config).map(getArchiver(arDelegate.getClass(),config)::apply).orElse(arDelegate))).setRanlib(new LazyDelegatingTool(() -> getTool(""String_Node_Str"",config).orElse(ranlib))).setStrip(getTool(""String_Node_Str"",config).orElse(strip)).setSharedLibraryExtension(sharedLibraryExtension).setSharedLibraryVersionedExtensionFormat(sharedLibraryVersionedExtensionFormat).setStaticLibraryExtension(staticLibraryExtension).setObjectFileExtension(objectFileExtension).setCompilerDebugPathSanitizer(compilerDebugPathSanitizer.orElse(new MungingDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),ImmutableBiMap.of()))).setAssemblerDebugPathSanitizer(assemblerDebugPathSanitizer.orElse(new MungingDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),ImmutableBiMap.of()))).setFlagMacros(flagMacros);
  builder.setSymbolNameTool(new LazyDelegatingSymbolNameTool(() -> {
    Optional<Tool> configNm=getTool(""String_Node_Str"",config);
    if (configNm.isPresent()) {
      return new PosixNmSymbolNameTool(configNm.get());
    }
 else {
      return nm;
    }
  }
));
  builder.addAllCflags(cflags);
  builder.addAllCxxflags(cflags);
  builder.addAllCppflags(cppflags);
  builder.addAllCxxppflags(cppflags);
  builder.addAllAsflags(asflags);
  builder.addAllAsppflags(asppflags);
  CxxPlatforms.addToolFlagsFromConfig(config,builder);
  return builder.build();
}","public static CxxPlatform build(Flavor flavor,final CxxBuckConfig config,CompilerProvider as,PreprocessorProvider aspp,CompilerProvider cc,CompilerProvider cxx,PreprocessorProvider cpp,PreprocessorProvider cxxpp,LinkerProvider ld,Iterable<String> ldFlags,Tool strip,final Archiver ar,final Tool ranlib,final SymbolNameTool nm,ImmutableList<String> asflags,ImmutableList<String> asppflags,ImmutableList<String> cflags,ImmutableList<String> cppflags,String sharedLibraryExtension,String sharedLibraryVersionedExtensionFormat,String staticLibraryExtension,String objectFileExtension,DebugPathSanitizer compilerDebugPathSanitizer,DebugPathSanitizer assemblerDebugPathSanitizer,ImmutableMap<String,String> flagMacros){
  CxxPlatform.Builder builder=CxxPlatform.builder();
  final Archiver arDelegate=ar instanceof LazyDelegatingArchiver ? ((LazyDelegatingArchiver)ar).getDelegate() : ar;
  builder.setFlavor(flavor).setAs(config.getCompilerProvider(""String_Node_Str"").orElse(as)).setAspp(config.getPreprocessorProvider(""String_Node_Str"").orElse(aspp)).setCc(config.getCompilerProvider(""String_Node_Str"").orElse(cc)).setCxx(config.getCompilerProvider(""String_Node_Str"").orElse(cxx)).setCpp(config.getPreprocessorProvider(""String_Node_Str"").orElse(cpp)).setCxxpp(config.getPreprocessorProvider(""String_Node_Str"").orElse(cxxpp)).setCuda(config.getCompilerProvider(""String_Node_Str"")).setCudapp(config.getPreprocessorProvider(""String_Node_Str"")).setAsm(config.getCompilerProvider(""String_Node_Str"")).setAsmpp(config.getPreprocessorProvider(""String_Node_Str"")).setLd(config.getLinkerProvider(""String_Node_Str"",ld.getType()).orElse(ld)).addAllLdflags(ldFlags).setAr(new LazyDelegatingArchiver(() -> getTool(""String_Node_Str"",config).map(getArchiver(arDelegate.getClass(),config)::apply).orElse(arDelegate))).setRanlib(new LazyDelegatingTool(() -> getTool(""String_Node_Str"",config).orElse(ranlib))).setStrip(getTool(""String_Node_Str"",config).orElse(strip)).setSharedLibraryExtension(sharedLibraryExtension).setSharedLibraryVersionedExtensionFormat(sharedLibraryVersionedExtensionFormat).setStaticLibraryExtension(staticLibraryExtension).setObjectFileExtension(objectFileExtension).setCompilerDebugPathSanitizer(compilerDebugPathSanitizer).setAssemblerDebugPathSanitizer(assemblerDebugPathSanitizer).setFlagMacros(flagMacros);
  builder.setSymbolNameTool(new LazyDelegatingSymbolNameTool(() -> {
    Optional<Tool> configNm=getTool(""String_Node_Str"",config);
    if (configNm.isPresent()) {
      return new PosixNmSymbolNameTool(configNm.get());
    }
 else {
      return nm;
    }
  }
));
  builder.addAllCflags(cflags);
  builder.addAllCxxflags(cflags);
  builder.addAllCppflags(cppflags);
  builder.addAllCxxppflags(cppflags);
  builder.addAllAsflags(asflags);
  builder.addAllAsppflags(asppflags);
  CxxPlatforms.addToolFlagsFromConfig(config,builder);
  return builder.build();
}",0.9418374091209516
53010,"/** 
 * Creates a CxxPlatform with a defined flavor for a CxxBuckConfig with default values provided from another default CxxPlatform
 */
public static CxxPlatform copyPlatformWithFlavorAndConfig(CxxPlatform defaultPlatform,CxxBuckConfig config,Flavor flavor){
  return CxxPlatforms.build(flavor,config,defaultPlatform.getAs(),defaultPlatform.getAspp(),defaultPlatform.getCc(),defaultPlatform.getCxx(),defaultPlatform.getCpp(),defaultPlatform.getCxxpp(),defaultPlatform.getLd(),defaultPlatform.getLdflags(),defaultPlatform.getStrip(),defaultPlatform.getAr(),defaultPlatform.getRanlib(),defaultPlatform.getSymbolNameTool(),defaultPlatform.getAsflags(),defaultPlatform.getAsppflags(),defaultPlatform.getCflags(),defaultPlatform.getCppflags(),defaultPlatform.getSharedLibraryExtension(),defaultPlatform.getSharedLibraryVersionedExtensionFormat(),defaultPlatform.getStaticLibraryExtension(),defaultPlatform.getObjectFileExtension(),Optional.of(defaultPlatform.getCompilerDebugPathSanitizer()),Optional.of(defaultPlatform.getAssemblerDebugPathSanitizer()),defaultPlatform.getFlagMacros());
}","/** 
 * Creates a CxxPlatform with a defined flavor for a CxxBuckConfig with default values provided from another default CxxPlatform
 */
public static CxxPlatform copyPlatformWithFlavorAndConfig(CxxPlatform defaultPlatform,CxxBuckConfig config,Flavor flavor){
  return CxxPlatforms.build(flavor,config,defaultPlatform.getAs(),defaultPlatform.getAspp(),defaultPlatform.getCc(),defaultPlatform.getCxx(),defaultPlatform.getCpp(),defaultPlatform.getCxxpp(),defaultPlatform.getLd(),defaultPlatform.getLdflags(),defaultPlatform.getStrip(),defaultPlatform.getAr(),defaultPlatform.getRanlib(),defaultPlatform.getSymbolNameTool(),defaultPlatform.getAsflags(),defaultPlatform.getAsppflags(),defaultPlatform.getCflags(),defaultPlatform.getCppflags(),defaultPlatform.getSharedLibraryExtension(),defaultPlatform.getSharedLibraryVersionedExtensionFormat(),defaultPlatform.getStaticLibraryExtension(),defaultPlatform.getObjectFileExtension(),defaultPlatform.getCompilerDebugPathSanitizer(),defaultPlatform.getAssemblerDebugPathSanitizer(),defaultPlatform.getFlagMacros());
}",0.9869524697110904
53011,"public static CxxPlatform build(Platform platform,CxxBuckConfig config){
  String sharedLibraryExtension;
  String sharedLibraryVersionedExtensionFormat;
  String staticLibraryExtension;
  String objectFileExtension;
  Path defaultCFrontend;
  Path defaultCxxFrontend;
  LinkerProvider.Type linkerType;
  Archiver archiver;
switch (platform) {
case LINUX:
    sharedLibraryExtension=""String_Node_Str"";
  sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=DEFAULT_C_FRONTEND;
defaultCxxFrontend=DEFAULT_CXX_FRONTEND;
linkerType=LinkerProvider.Type.GNU;
archiver=new GnuArchiver(new HashedFileTool(DEFAULT_AR));
break;
case MACOS:
sharedLibraryExtension=""String_Node_Str"";
sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=DEFAULT_OSX_C_FRONTEND;
defaultCxxFrontend=DEFAULT_OSX_CXX_FRONTEND;
linkerType=LinkerProvider.Type.DARWIN;
archiver=new BsdArchiver(new HashedFileTool(DEFAULT_AR));
break;
case WINDOWS:
sharedLibraryExtension=""String_Node_Str"";
sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=DEFAULT_C_FRONTEND;
defaultCxxFrontend=DEFAULT_CXX_FRONTEND;
linkerType=LinkerProvider.Type.WINDOWS;
archiver=new WindowsArchiver(new HashedFileTool(DEFAULT_AR));
break;
case FREEBSD:
sharedLibraryExtension=""String_Node_Str"";
sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=DEFAULT_C_FRONTEND;
defaultCxxFrontend=DEFAULT_CXX_FRONTEND;
linkerType=LinkerProvider.Type.GNU;
archiver=new BsdArchiver(new HashedFileTool(DEFAULT_AR));
break;
default :
throw new RuntimeException(String.format(""String_Node_Str"",platform));
}
PreprocessorProvider aspp=new PreprocessorProvider(defaultCFrontend,Optional.empty());
CompilerProvider as=new CompilerProvider(defaultCFrontend,Optional.empty());
PreprocessorProvider cpp=new PreprocessorProvider(defaultCFrontend,Optional.empty());
CompilerProvider cc=new CompilerProvider(defaultCFrontend,Optional.empty());
PreprocessorProvider cxxpp=new PreprocessorProvider(defaultCxxFrontend,Optional.empty());
CompilerProvider cxx=new CompilerProvider(defaultCxxFrontend,Optional.empty());
return CxxPlatforms.build(FLAVOR,config,as,aspp,cc,cxx,cpp,cxxpp,new DefaultLinkerProvider(linkerType,new ConstantToolProvider(new HashedFileTool(defaultCxxFrontend))),ImmutableList.of(),new HashedFileTool(DEFAULT_STRIP),archiver,new HashedFileTool(DEFAULT_RANLIB),new PosixNmSymbolNameTool(new HashedFileTool(DEFAULT_NM)),ImmutableList.of(),ImmutableList.of(),ImmutableList.of(),ImmutableList.of(),sharedLibraryExtension,sharedLibraryVersionedExtensionFormat,staticLibraryExtension,objectFileExtension,Optional.empty(),Optional.empty(),ImmutableMap.of());
}","public static CxxPlatform build(Platform platform,ProjectFilesystem filesystem,CxxBuckConfig config){
  String sharedLibraryExtension;
  String sharedLibraryVersionedExtensionFormat;
  String staticLibraryExtension;
  String objectFileExtension;
  Path defaultCFrontend;
  Path defaultCxxFrontend;
  LinkerProvider.Type linkerType;
  Archiver archiver;
  DebugPathSanitizer compilerSanitizer;
switch (platform) {
case LINUX:
    sharedLibraryExtension=""String_Node_Str"";
  sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=DEFAULT_C_FRONTEND;
defaultCxxFrontend=DEFAULT_CXX_FRONTEND;
linkerType=LinkerProvider.Type.GNU;
archiver=new GnuArchiver(new HashedFileTool(DEFAULT_AR));
compilerSanitizer=new PrefixMapDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),ImmutableBiMap.of(),filesystem.getRootPath().toAbsolutePath(),CxxToolProvider.Type.GCC);
break;
case MACOS:
sharedLibraryExtension=""String_Node_Str"";
sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=DEFAULT_OSX_C_FRONTEND;
defaultCxxFrontend=DEFAULT_OSX_CXX_FRONTEND;
linkerType=LinkerProvider.Type.DARWIN;
archiver=new BsdArchiver(new HashedFileTool(DEFAULT_AR));
compilerSanitizer=new PrefixMapDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),ImmutableBiMap.of(),filesystem.getRootPath().toAbsolutePath(),CxxToolProvider.Type.CLANG);
break;
case WINDOWS:
sharedLibraryExtension=""String_Node_Str"";
sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=DEFAULT_C_FRONTEND;
defaultCxxFrontend=DEFAULT_CXX_FRONTEND;
linkerType=LinkerProvider.Type.WINDOWS;
archiver=new WindowsArchiver(new HashedFileTool(DEFAULT_AR));
compilerSanitizer=new PrefixMapDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),ImmutableBiMap.of(),filesystem.getRootPath().toAbsolutePath(),CxxToolProvider.Type.GCC);
break;
case FREEBSD:
sharedLibraryExtension=""String_Node_Str"";
sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=DEFAULT_C_FRONTEND;
defaultCxxFrontend=DEFAULT_CXX_FRONTEND;
linkerType=LinkerProvider.Type.GNU;
archiver=new BsdArchiver(new HashedFileTool(DEFAULT_AR));
compilerSanitizer=new PrefixMapDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),ImmutableBiMap.of(),filesystem.getRootPath().toAbsolutePath(),CxxToolProvider.Type.GCC);
break;
default :
throw new RuntimeException(String.format(""String_Node_Str"",platform));
}
PreprocessorProvider aspp=new PreprocessorProvider(defaultCFrontend,Optional.empty());
CompilerProvider as=new CompilerProvider(defaultCFrontend,Optional.empty());
PreprocessorProvider cpp=new PreprocessorProvider(defaultCFrontend,Optional.empty());
CompilerProvider cc=new CompilerProvider(defaultCFrontend,Optional.empty());
PreprocessorProvider cxxpp=new PreprocessorProvider(defaultCxxFrontend,Optional.empty());
CompilerProvider cxx=new CompilerProvider(defaultCxxFrontend,Optional.empty());
return CxxPlatforms.build(FLAVOR,config,as,aspp,cc,cxx,cpp,cxxpp,new DefaultLinkerProvider(linkerType,new ConstantToolProvider(new HashedFileTool(defaultCxxFrontend))),ImmutableList.of(),new HashedFileTool(DEFAULT_STRIP),archiver,new HashedFileTool(DEFAULT_RANLIB),new PosixNmSymbolNameTool(new HashedFileTool(DEFAULT_NM)),ImmutableList.of(),ImmutableList.of(),ImmutableList.of(),ImmutableList.of(),sharedLibraryExtension,sharedLibraryVersionedExtensionFormat,staticLibraryExtension,objectFileExtension,compilerSanitizer,new MungingDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),ImmutableBiMap.of()),ImmutableMap.of());
}",0.8379524886877828
53012,"public OcamlBuckConfig(Platform platform,BuckConfig delegate){
  this.delegate=delegate;
  this.cxxPlatform=DefaultCxxPlatforms.build(platform,new CxxBuckConfig(delegate));
}","public OcamlBuckConfig(Platform platform,ProjectFilesystem filesystem,BuckConfig delegate){
  this.delegate=delegate;
  this.cxxPlatform=DefaultCxxPlatforms.build(platform,filesystem,new CxxBuckConfig(delegate));
}",0.8969072164948454
53013,"private static ImmutableList<AppleCxxPlatform> buildAppleCxxPlatforms(Supplier<Optional<Path>> appleDeveloperDirectorySupplier,ImmutableList<Path> extraToolchainPaths,ImmutableList<Path> extraPlatformPaths,BuckConfig buckConfig,AppleConfig appleConfig,SwiftBuckConfig swiftBuckConfig,ProcessExecutor processExecutor) throws IOException {
  Optional<Path> appleDeveloperDirectory=appleDeveloperDirectorySupplier.get();
  if (appleDeveloperDirectory.isPresent() && !Files.isDirectory(appleDeveloperDirectory.get())) {
    LOG.error(""String_Node_Str"",appleDeveloperDirectory.get());
    return ImmutableList.of();
  }
  ImmutableList.Builder<AppleCxxPlatform> appleCxxPlatformsBuilder=ImmutableList.builder();
  ImmutableMap<String,AppleToolchain> toolchains=AppleToolchainDiscovery.discoverAppleToolchains(appleDeveloperDirectory,extraToolchainPaths);
  ImmutableMap<AppleSdk,AppleSdkPaths> sdkPaths=AppleSdkDiscovery.discoverAppleSdkPaths(appleDeveloperDirectory,extraPlatformPaths,toolchains,appleConfig);
  Optional<String> swiftVersion=swiftBuckConfig.getVersion();
  Optional<AppleToolchain> swiftToolChain=Optional.empty();
  if (swiftVersion.isPresent()) {
    Optional<String> swiftToolChainName=swiftVersion.map(AppleCxxPlatform.SWIFT_VERSION_TO_TOOLCHAIN_IDENTIFIER);
    swiftToolChain=toolchains.values().stream().filter(input -> input.getIdentifier().equals(swiftToolChainName.get())).findFirst();
  }
  for (  Map.Entry<AppleSdk,AppleSdkPaths> entry : sdkPaths.entrySet()) {
    AppleSdk sdk=entry.getKey();
    AppleSdkPaths appleSdkPaths=entry.getValue();
    String targetSdkVersion=appleConfig.getTargetSdkVersion(sdk.getApplePlatform()).orElse(sdk.getVersion());
    LOG.debug(""String_Node_Str"",sdk,targetSdkVersion);
    for (    String architecture : sdk.getArchitectures()) {
      AppleCxxPlatform appleCxxPlatform=AppleCxxPlatforms.build(sdk,targetSdkVersion,architecture,appleSdkPaths,buckConfig,appleConfig,Optional.of(processExecutor),swiftToolChain);
      appleCxxPlatformsBuilder.add(appleCxxPlatform);
    }
  }
  return appleCxxPlatformsBuilder.build();
}","private static ImmutableList<AppleCxxPlatform> buildAppleCxxPlatforms(ProjectFilesystem filesystem,Supplier<Optional<Path>> appleDeveloperDirectorySupplier,ImmutableList<Path> extraToolchainPaths,ImmutableList<Path> extraPlatformPaths,BuckConfig buckConfig,AppleConfig appleConfig,SwiftBuckConfig swiftBuckConfig,ProcessExecutor processExecutor) throws IOException {
  Optional<Path> appleDeveloperDirectory=appleDeveloperDirectorySupplier.get();
  if (appleDeveloperDirectory.isPresent() && !Files.isDirectory(appleDeveloperDirectory.get())) {
    LOG.error(""String_Node_Str"",appleDeveloperDirectory.get());
    return ImmutableList.of();
  }
  ImmutableList.Builder<AppleCxxPlatform> appleCxxPlatformsBuilder=ImmutableList.builder();
  ImmutableMap<String,AppleToolchain> toolchains=AppleToolchainDiscovery.discoverAppleToolchains(appleDeveloperDirectory,extraToolchainPaths);
  ImmutableMap<AppleSdk,AppleSdkPaths> sdkPaths=AppleSdkDiscovery.discoverAppleSdkPaths(appleDeveloperDirectory,extraPlatformPaths,toolchains,appleConfig);
  Optional<String> swiftVersion=swiftBuckConfig.getVersion();
  Optional<AppleToolchain> swiftToolChain=Optional.empty();
  if (swiftVersion.isPresent()) {
    Optional<String> swiftToolChainName=swiftVersion.map(AppleCxxPlatform.SWIFT_VERSION_TO_TOOLCHAIN_IDENTIFIER);
    swiftToolChain=toolchains.values().stream().filter(input -> input.getIdentifier().equals(swiftToolChainName.get())).findFirst();
  }
  for (  Map.Entry<AppleSdk,AppleSdkPaths> entry : sdkPaths.entrySet()) {
    AppleSdk sdk=entry.getKey();
    AppleSdkPaths appleSdkPaths=entry.getValue();
    String targetSdkVersion=appleConfig.getTargetSdkVersion(sdk.getApplePlatform()).orElse(sdk.getVersion());
    LOG.debug(""String_Node_Str"",sdk,targetSdkVersion);
    for (    String architecture : sdk.getArchitectures()) {
      AppleCxxPlatform appleCxxPlatform=AppleCxxPlatforms.build(filesystem,sdk,targetSdkVersion,architecture,appleSdkPaths,buckConfig,appleConfig,Optional.of(processExecutor),swiftToolChain);
      appleCxxPlatformsBuilder.add(appleCxxPlatform);
    }
  }
  return appleCxxPlatformsBuilder.build();
}",0.990498812351544
53014,"@VisibleForTesting static Builder createBuilder(BuckConfig config,ProjectFilesystem filesystem,ProcessExecutor processExecutor,AndroidDirectoryResolver androidDirectoryResolver) throws InterruptedException, IOException {
  Platform platform=Platform.detect();
  AndroidBuckConfig androidConfig=new AndroidBuckConfig(config,platform);
  Optional<String> ndkVersion=androidConfig.getNdkVersion();
  if (!ndkVersion.isPresent()) {
    ndkVersion=androidDirectoryResolver.getNdkVersion();
  }
  AppleConfig appleConfig=new AppleConfig(config);
  SwiftBuckConfig swiftBuckConfig=new SwiftBuckConfig(config);
  final ImmutableList<AppleCxxPlatform> appleCxxPlatforms=buildAppleCxxPlatforms(appleConfig.getAppleDeveloperDirectorySupplier(processExecutor),appleConfig.getExtraToolchainPaths(),appleConfig.getExtraPlatformPaths(),config,appleConfig,swiftBuckConfig,processExecutor);
  final FlavorDomain<AppleCxxPlatform> platformFlavorsToAppleCxxPlatforms=FlavorDomain.from(""String_Node_Str"",appleCxxPlatforms);
  ImmutableMap.Builder<Flavor,SwiftPlatform> swiftPlatforms=ImmutableMap.builder();
  for (  Flavor flavor : platformFlavorsToAppleCxxPlatforms.getFlavors()) {
    Optional<SwiftPlatform> swiftPlatformOptional=platformFlavorsToAppleCxxPlatforms.getValue(flavor).getSwiftPlatform();
    if (swiftPlatformOptional.isPresent()) {
      swiftPlatforms.put(flavor,swiftPlatformOptional.get());
    }
  }
  CxxBuckConfig cxxBuckConfig=new CxxBuckConfig(config);
  Optional<Path> ndkRoot=androidDirectoryResolver.getNdkOrAbsent();
  ImmutableMap.Builder<NdkCxxPlatforms.TargetCpuType,NdkCxxPlatform> ndkCxxPlatformsBuilder=ImmutableMap.builder();
  if (ndkRoot.isPresent()) {
    NdkCxxPlatformCompiler.Type compilerType=androidConfig.getNdkCompiler().orElse(NdkCxxPlatforms.DEFAULT_COMPILER_TYPE);
    String gccVersion=androidConfig.getNdkGccVersion().orElse(NdkCxxPlatforms.getDefaultGccVersionForNdk(ndkVersion));
    String clangVersion=androidConfig.getNdkClangVersion().orElse(NdkCxxPlatforms.getDefaultClangVersionForNdk(ndkVersion));
    String compilerVersion=compilerType == NdkCxxPlatformCompiler.Type.GCC ? gccVersion : clangVersion;
    NdkCxxPlatformCompiler compiler=NdkCxxPlatformCompiler.builder().setType(compilerType).setVersion(compilerVersion).setGccVersion(gccVersion).build();
    ndkCxxPlatformsBuilder.putAll(NdkCxxPlatforms.getPlatforms(cxxBuckConfig,filesystem,ndkRoot.get(),compiler,androidConfig.getNdkCxxRuntime().orElse(NdkCxxPlatforms.DEFAULT_CXX_RUNTIME),androidConfig.getNdkAppPlatform().orElse(NdkCxxPlatforms.DEFAULT_TARGET_APP_PLATFORM),androidConfig.getNdkCpuAbis().orElse(NdkCxxPlatforms.DEFAULT_CPU_ABIS),platform));
  }
  ImmutableMap<NdkCxxPlatforms.TargetCpuType,NdkCxxPlatform> ndkCxxPlatforms=ndkCxxPlatformsBuilder.build();
  ImmutableMap.Builder<Flavor,CxxPlatform> cxxSystemPlatformsBuilder=ImmutableMap.builder();
  for (  NdkCxxPlatform ndkCxxPlatform : ndkCxxPlatforms.values()) {
    cxxSystemPlatformsBuilder.put(ndkCxxPlatform.getCxxPlatform().getFlavor(),ndkCxxPlatform.getCxxPlatform());
  }
  for (  AppleCxxPlatform appleCxxPlatform : platformFlavorsToAppleCxxPlatforms.getValues()) {
    cxxSystemPlatformsBuilder.put(appleCxxPlatform.getCxxPlatform().getFlavor(),appleCxxPlatform.getCxxPlatform());
  }
  CxxPlatform defaultHostCxxPlatform=DefaultCxxPlatforms.build(platform,cxxBuckConfig);
  cxxSystemPlatformsBuilder.put(defaultHostCxxPlatform.getFlavor(),defaultHostCxxPlatform);
  ImmutableMap<Flavor,CxxPlatform> cxxSystemPlatformsMap=cxxSystemPlatformsBuilder.build();
  Flavor hostFlavor=CxxPlatforms.getHostFlavor();
  if (!cxxSystemPlatformsMap.containsKey(hostFlavor)) {
    cxxSystemPlatformsBuilder.put(hostFlavor,CxxPlatform.builder().from(defaultHostCxxPlatform).setFlavor(hostFlavor).build());
    cxxSystemPlatformsMap=cxxSystemPlatformsBuilder.build();
  }
  ImmutableList<ImmutableFlavor> possibleHostFlavors=CxxPlatforms.getAllPossibleHostFlavors();
  HashMap<Flavor,CxxPlatform> cxxOverridePlatformsMap=new HashMap<Flavor,CxxPlatform>(cxxSystemPlatformsMap);
  ImmutableSet<Flavor> cxxFlavors=CxxBuckConfig.getCxxFlavors(config);
  for (  Flavor flavor : cxxFlavors) {
    if (!cxxSystemPlatformsMap.containsKey(flavor)) {
      if (possibleHostFlavors.contains(flavor)) {
        continue;
      }
      LOG.warn(""String_Node_Str"" + flavor);
    }
    cxxOverridePlatformsMap.put(flavor,CxxPlatforms.copyPlatformWithFlavorAndConfig(cxxOverridePlatformsMap.get(flavor),new CxxBuckConfig(config,flavor),flavor));
  }
  hostFlavor=DefaultCxxPlatforms.FLAVOR;
  Optional<String> hostCxxPlatformOverride=cxxBuckConfig.getHostPlatform();
  if (hostCxxPlatformOverride.isPresent()) {
    Flavor overrideFlavor=ImmutableFlavor.of(hostCxxPlatformOverride.get());
    if (cxxOverridePlatformsMap.containsKey(overrideFlavor)) {
      hostFlavor=overrideFlavor;
    }
  }
  CxxPlatform hostCxxPlatform=CxxPlatform.builder().from(cxxOverridePlatformsMap.get(hostFlavor)).setFlavor(DefaultCxxPlatforms.FLAVOR).build();
  cxxOverridePlatformsMap.put(DefaultCxxPlatforms.FLAVOR,hostCxxPlatform);
  ImmutableMap<Flavor,CxxPlatform> cxxPlatformsMap=ImmutableMap.<Flavor,CxxPlatform>builder().putAll(cxxOverridePlatformsMap).build();
  ExecutableFinder executableFinder=new ExecutableFinder();
  FlavorDomain<CxxPlatform> cxxPlatforms=new FlavorDomain<>(""String_Node_Str"",cxxPlatformsMap);
  CxxPlatform defaultCxxPlatform=CxxPlatforms.getConfigDefaultCxxPlatform(cxxBuckConfig,cxxPlatformsMap,hostCxxPlatform);
  DBuckConfig dBuckConfig=new DBuckConfig(config);
  ReactNativeBuckConfig reactNativeBuckConfig=new ReactNativeBuckConfig(config);
  RustBuckConfig rustBuckConfig=new RustBuckConfig(config);
  GoBuckConfig goBuckConfig=new GoBuckConfig(config,processExecutor,cxxPlatforms);
  HalideBuckConfig halideBuckConfig=new HalideBuckConfig(config);
  ProGuardConfig proGuardConfig=new ProGuardConfig(config);
  PythonBuckConfig pyConfig=new PythonBuckConfig(config,executableFinder);
  ImmutableList<PythonPlatform> pythonPlatformsList=pyConfig.getPythonPlatforms(processExecutor);
  FlavorDomain<PythonPlatform> pythonPlatforms=FlavorDomain.from(""String_Node_Str"",pythonPlatformsList);
  PythonBinaryDescription pythonBinaryDescription=new PythonBinaryDescription(pyConfig,pythonPlatforms,cxxBuckConfig,defaultCxxPlatform,cxxPlatforms);
  Optional<Long> defaultTestRuleTimeoutMs=config.getLong(""String_Node_Str"",""String_Node_Str"");
  Downloader downloader;
  DownloadConfig downloadConfig=new DownloadConfig(config);
  if (downloadConfig.isDownloadAtRuntimeOk()) {
    downloader=StackedDownloader.createFromConfig(config,androidDirectoryResolver.getSdkOrAbsent());
  }
 else {
    downloader=new ExplodingDownloader();
  }
  Builder builder=builder();
  JavaBuckConfig javaConfig=config.getView(JavaBuckConfig.class);
  JavacOptions defaultJavacOptions=javaConfig.getDefaultJavacOptions();
  JavaOptions defaultJavaOptions=javaConfig.getDefaultJavaOptions();
  JavaOptions defaultJavaOptionsForTests=javaConfig.getDefaultJavaOptionsForTests();
  KotlinBuckConfig kotlinBuckConfig=new KotlinBuckConfig(config);
  ScalaBuckConfig scalaConfig=new ScalaBuckConfig(config);
  InferBuckConfig inferBuckConfig=new InferBuckConfig(config);
  LuaConfig luaConfig=new LuaBuckConfig(config,executableFinder);
  CxxBinaryDescription cxxBinaryDescription=new CxxBinaryDescription(cxxBuckConfig,inferBuckConfig,defaultCxxPlatform,cxxPlatforms);
  CxxLibraryDescription cxxLibraryDescription=new CxxLibraryDescription(cxxBuckConfig,defaultCxxPlatform,inferBuckConfig,cxxPlatforms);
  FlavorDomain<SwiftPlatform> platformFlavorsToSwiftPlatforms=new FlavorDomain<>(""String_Node_Str"",swiftPlatforms.build());
  SwiftLibraryDescription swiftLibraryDescription=new SwiftLibraryDescription(cxxBuckConfig,swiftBuckConfig,cxxPlatforms,platformFlavorsToSwiftPlatforms);
  builder.register(swiftLibraryDescription);
  CodeSignIdentityStore codeSignIdentityStore=appleConfig.useDryRunCodeSigning() ? CodeSignIdentityStore.fromIdentities(ImmutableList.of()) : CodeSignIdentityStore.fromSystem(processExecutor);
  ProvisioningProfileStore provisioningProfileStore=ProvisioningProfileStore.fromSearchPath(processExecutor,appleConfig.getProvisioningProfileReadCommand(),appleConfig.getProvisioningProfileSearchPath());
  AppleLibraryDescription appleLibraryDescription=new AppleLibraryDescription(cxxLibraryDescription,swiftLibraryDescription,platformFlavorsToAppleCxxPlatforms,defaultCxxPlatform,codeSignIdentityStore,provisioningProfileStore,appleConfig);
  builder.register(appleLibraryDescription);
  PrebuiltAppleFrameworkDescription appleFrameworkDescription=new PrebuiltAppleFrameworkDescription();
  builder.register(appleFrameworkDescription);
  AppleBinaryDescription appleBinaryDescription=new AppleBinaryDescription(cxxBinaryDescription,swiftLibraryDescription,platformFlavorsToAppleCxxPlatforms,codeSignIdentityStore,provisioningProfileStore,appleConfig);
  builder.register(appleBinaryDescription);
  HaskellBuckConfig haskellBuckConfig=new HaskellBuckConfig(config,executableFinder);
  builder.register(new HaskellLibraryDescription(haskellBuckConfig,cxxBuckConfig,cxxPlatforms));
  builder.register(new HaskellBinaryDescription(haskellBuckConfig,cxxPlatforms,defaultCxxPlatform));
  builder.register(new HaskellPrebuiltLibraryDescription());
  ListeningExecutorService dxExecutorService=MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(javaConfig.getDxThreadCount().orElse(SmartDexingStep.determineOptimalThreadCount()),new CommandThreadFactory(""String_Node_Str"")));
  builder.register(new AndroidAarDescription(new AndroidManifestDescription(),cxxBuckConfig,ndkCxxPlatforms));
  builder.register(new AndroidBinaryDescription(defaultJavaOptions,defaultJavacOptions,proGuardConfig,ndkCxxPlatforms,dxExecutorService,cxxBuckConfig));
  builder.register(new AndroidBuildConfigDescription(defaultJavacOptions));
  builder.register(new AndroidInstrumentationApkDescription(proGuardConfig,defaultJavacOptions,ndkCxxPlatforms,dxExecutorService,cxxBuckConfig));
  builder.register(new AndroidInstrumentationTestDescription(defaultJavaOptions,defaultTestRuleTimeoutMs));
  builder.register(new AndroidLibraryDescription(defaultJavacOptions,new DefaultAndroidLibraryCompilerFactory(scalaConfig,kotlinBuckConfig)));
  builder.register(new AndroidManifestDescription());
  builder.register(new AndroidPrebuiltAarDescription(defaultJavacOptions));
  builder.register(new AndroidReactNativeLibraryDescription(reactNativeBuckConfig));
  builder.register(new AndroidResourceDescription(config.isGrayscaleImageProcessingEnabled()));
  builder.register(new ApkGenruleDescription());
  builder.register(new AppleAssetCatalogDescription());
  builder.register(new ApplePackageDescription(appleConfig,defaultCxxPlatform,platformFlavorsToAppleCxxPlatforms));
  AppleBundleDescription appleBundleDescription=new AppleBundleDescription(appleBinaryDescription,appleLibraryDescription,cxxPlatforms,platformFlavorsToAppleCxxPlatforms,defaultCxxPlatform,codeSignIdentityStore,provisioningProfileStore,appleConfig);
  builder.register(appleBundleDescription);
  builder.register(new AppleResourceDescription());
  builder.register(new AppleTestDescription(appleConfig,appleLibraryDescription,cxxPlatforms,platformFlavorsToAppleCxxPlatforms,defaultCxxPlatform,codeSignIdentityStore,provisioningProfileStore,appleConfig.getAppleDeveloperDirectorySupplierForTests(processExecutor),defaultTestRuleTimeoutMs));
  builder.register(new CoreDataModelDescription());
  builder.register(new CsharpLibraryDescription());
  builder.register(cxxBinaryDescription);
  builder.register(cxxLibraryDescription);
  builder.register(new CxxGenruleDescription(cxxPlatforms));
  builder.register(new CxxLuaExtensionDescription(luaConfig,cxxBuckConfig,cxxPlatforms));
  builder.register(new CxxPythonExtensionDescription(pythonPlatforms,cxxBuckConfig,cxxPlatforms));
  builder.register(new CxxTestDescription(cxxBuckConfig,defaultCxxPlatform,cxxPlatforms,defaultTestRuleTimeoutMs));
  builder.register(new DBinaryDescription(dBuckConfig,cxxBuckConfig,defaultCxxPlatform));
  builder.register(new DLibraryDescription(dBuckConfig,cxxBuckConfig,defaultCxxPlatform));
  builder.register(new DTestDescription(dBuckConfig,cxxBuckConfig,defaultCxxPlatform,defaultTestRuleTimeoutMs));
  builder.register(new ExportFileDescription());
  builder.register(new GenruleDescription());
  builder.register(new GenAidlDescription());
  builder.register(new GoBinaryDescription(goBuckConfig));
  builder.register(new GoLibraryDescription(goBuckConfig));
  builder.register(new GoTestDescription(goBuckConfig,defaultTestRuleTimeoutMs));
  builder.register(new GraphqlLibraryDescription());
  GroovyBuckConfig groovyBuckConfig=new GroovyBuckConfig(config);
  builder.register(new GroovyLibraryDescription(groovyBuckConfig,defaultJavacOptions));
  builder.register(new GroovyTestDescription(groovyBuckConfig,defaultJavaOptionsForTests,defaultJavacOptions,defaultTestRuleTimeoutMs));
  builder.register(new GwtBinaryDescription(defaultJavaOptions));
  builder.register(new HalideLibraryDescription(cxxBuckConfig,defaultCxxPlatform,cxxPlatforms,halideBuckConfig));
  builder.register(new IosReactNativeLibraryDescription(reactNativeBuckConfig));
  builder.register(new JavaBinaryDescription(defaultJavaOptions,defaultJavacOptions,defaultCxxPlatform));
  builder.register(new JavaLibraryDescription(defaultJavacOptions));
  builder.register(new JavaTestDescription(defaultJavaOptionsForTests,defaultJavacOptions,defaultTestRuleTimeoutMs,defaultCxxPlatform));
  builder.register(new KeystoreDescription());
  builder.register(new KotlinLibraryDescription(kotlinBuckConfig));
  builder.register(new KotlinTestDescription(kotlinBuckConfig,defaultJavaOptionsForTests,defaultJavacOptions,defaultTestRuleTimeoutMs));
  builder.register(new LuaBinaryDescription(luaConfig,cxxBuckConfig,defaultCxxPlatform,cxxPlatforms,pythonPlatforms));
  builder.register(new LuaLibraryDescription());
  builder.register(new NdkLibraryDescription(ndkVersion,ndkCxxPlatforms));
  OcamlBuckConfig ocamlBuckConfig=new OcamlBuckConfig(platform,config);
  builder.register(new OcamlBinaryDescription(ocamlBuckConfig));
  builder.register(new OcamlLibraryDescription(ocamlBuckConfig));
  builder.register(new PrebuiltCxxLibraryDescription(cxxBuckConfig,cxxPlatforms));
  builder.register(PrebuiltCxxLibraryGroupDescription.of());
  builder.register(new PrebuiltDotnetLibraryDescription());
  builder.register(new PrebuiltJarDescription());
  builder.register(new PrebuiltNativeLibraryDescription());
  builder.register(new PrebuiltOcamlLibraryDescription());
  builder.register(new PrebuiltPythonLibraryDescription());
  builder.register(new ProjectConfigDescription());
  builder.register(pythonBinaryDescription);
  builder.register(new PythonLibraryDescription());
  builder.register(new PythonTestDescription(pythonBinaryDescription,pyConfig,pythonPlatforms,cxxBuckConfig,defaultCxxPlatform,defaultTestRuleTimeoutMs,cxxPlatforms));
  builder.register(new RemoteFileDescription(downloader));
  builder.register(new RobolectricTestDescription(defaultJavaOptionsForTests,defaultJavacOptions,defaultTestRuleTimeoutMs,defaultCxxPlatform));
  builder.register(new RustBinaryDescription(rustBuckConfig,defaultCxxPlatform));
  builder.register(new RustLibraryDescription(rustBuckConfig,defaultCxxPlatform));
  builder.register(new RustTestDescription(rustBuckConfig,defaultCxxPlatform));
  builder.register(new PrebuiltRustLibraryDescription(rustBuckConfig,defaultCxxPlatform));
  builder.register(new ScalaLibraryDescription(scalaConfig));
  builder.register(new ScalaTestDescription(scalaConfig,defaultJavaOptionsForTests,defaultTestRuleTimeoutMs,defaultCxxPlatform));
  builder.register(new SceneKitAssetsDescription());
  builder.register(new ShBinaryDescription());
  builder.register(new ShTestDescription(defaultTestRuleTimeoutMs));
  ThriftBuckConfig thriftBuckConfig=new ThriftBuckConfig(config);
  builder.register(new ThriftLibraryDescription(thriftBuckConfig,ImmutableList.of(new ThriftJavaEnhancer(thriftBuckConfig,defaultJavacOptions),new ThriftCxxEnhancer(thriftBuckConfig,cxxLibraryDescription,false),new ThriftCxxEnhancer(thriftBuckConfig,cxxLibraryDescription,true),new ThriftPythonEnhancer(thriftBuckConfig,ThriftPythonEnhancer.Type.NORMAL),new ThriftPythonEnhancer(thriftBuckConfig,ThriftPythonEnhancer.Type.TWISTED),new ThriftPythonEnhancer(thriftBuckConfig,ThriftPythonEnhancer.Type.ASYNCIO))));
  builder.register(new WorkerToolDescription(config));
  builder.register(new XcodePostbuildScriptDescription());
  builder.register(new XcodePrebuildScriptDescription());
  builder.register(new XcodeWorkspaceConfigDescription());
  builder.register(new ZipFileDescription());
  builder.register(new TargetGroupDescription());
  builder.setCxxPlatforms(cxxPlatforms);
  builder.setDefaultCxxPlatform(defaultCxxPlatform);
  builder.register(VersionedAliasDescription.of());
  return builder;
}","@VisibleForTesting static Builder createBuilder(BuckConfig config,ProjectFilesystem filesystem,ProcessExecutor processExecutor,AndroidDirectoryResolver androidDirectoryResolver) throws InterruptedException, IOException {
  Platform platform=Platform.detect();
  AndroidBuckConfig androidConfig=new AndroidBuckConfig(config,platform);
  Optional<String> ndkVersion=androidConfig.getNdkVersion();
  if (!ndkVersion.isPresent()) {
    ndkVersion=androidDirectoryResolver.getNdkVersion();
  }
  AppleConfig appleConfig=new AppleConfig(config);
  SwiftBuckConfig swiftBuckConfig=new SwiftBuckConfig(config);
  final ImmutableList<AppleCxxPlatform> appleCxxPlatforms=buildAppleCxxPlatforms(filesystem,appleConfig.getAppleDeveloperDirectorySupplier(processExecutor),appleConfig.getExtraToolchainPaths(),appleConfig.getExtraPlatformPaths(),config,appleConfig,swiftBuckConfig,processExecutor);
  final FlavorDomain<AppleCxxPlatform> platformFlavorsToAppleCxxPlatforms=FlavorDomain.from(""String_Node_Str"",appleCxxPlatforms);
  ImmutableMap.Builder<Flavor,SwiftPlatform> swiftPlatforms=ImmutableMap.builder();
  for (  Flavor flavor : platformFlavorsToAppleCxxPlatforms.getFlavors()) {
    Optional<SwiftPlatform> swiftPlatformOptional=platformFlavorsToAppleCxxPlatforms.getValue(flavor).getSwiftPlatform();
    if (swiftPlatformOptional.isPresent()) {
      swiftPlatforms.put(flavor,swiftPlatformOptional.get());
    }
  }
  CxxBuckConfig cxxBuckConfig=new CxxBuckConfig(config);
  Optional<Path> ndkRoot=androidDirectoryResolver.getNdkOrAbsent();
  ImmutableMap.Builder<NdkCxxPlatforms.TargetCpuType,NdkCxxPlatform> ndkCxxPlatformsBuilder=ImmutableMap.builder();
  if (ndkRoot.isPresent()) {
    NdkCxxPlatformCompiler.Type compilerType=androidConfig.getNdkCompiler().orElse(NdkCxxPlatforms.DEFAULT_COMPILER_TYPE);
    String gccVersion=androidConfig.getNdkGccVersion().orElse(NdkCxxPlatforms.getDefaultGccVersionForNdk(ndkVersion));
    String clangVersion=androidConfig.getNdkClangVersion().orElse(NdkCxxPlatforms.getDefaultClangVersionForNdk(ndkVersion));
    String compilerVersion=compilerType == NdkCxxPlatformCompiler.Type.GCC ? gccVersion : clangVersion;
    NdkCxxPlatformCompiler compiler=NdkCxxPlatformCompiler.builder().setType(compilerType).setVersion(compilerVersion).setGccVersion(gccVersion).build();
    ndkCxxPlatformsBuilder.putAll(NdkCxxPlatforms.getPlatforms(cxxBuckConfig,filesystem,ndkRoot.get(),compiler,androidConfig.getNdkCxxRuntime().orElse(NdkCxxPlatforms.DEFAULT_CXX_RUNTIME),androidConfig.getNdkAppPlatform().orElse(NdkCxxPlatforms.DEFAULT_TARGET_APP_PLATFORM),androidConfig.getNdkCpuAbis().orElse(NdkCxxPlatforms.DEFAULT_CPU_ABIS),platform));
  }
  ImmutableMap<NdkCxxPlatforms.TargetCpuType,NdkCxxPlatform> ndkCxxPlatforms=ndkCxxPlatformsBuilder.build();
  ImmutableMap.Builder<Flavor,CxxPlatform> cxxSystemPlatformsBuilder=ImmutableMap.builder();
  for (  NdkCxxPlatform ndkCxxPlatform : ndkCxxPlatforms.values()) {
    cxxSystemPlatformsBuilder.put(ndkCxxPlatform.getCxxPlatform().getFlavor(),ndkCxxPlatform.getCxxPlatform());
  }
  for (  AppleCxxPlatform appleCxxPlatform : platformFlavorsToAppleCxxPlatforms.getValues()) {
    cxxSystemPlatformsBuilder.put(appleCxxPlatform.getCxxPlatform().getFlavor(),appleCxxPlatform.getCxxPlatform());
  }
  CxxPlatform defaultHostCxxPlatform=DefaultCxxPlatforms.build(platform,filesystem,cxxBuckConfig);
  cxxSystemPlatformsBuilder.put(defaultHostCxxPlatform.getFlavor(),defaultHostCxxPlatform);
  ImmutableMap<Flavor,CxxPlatform> cxxSystemPlatformsMap=cxxSystemPlatformsBuilder.build();
  Flavor hostFlavor=CxxPlatforms.getHostFlavor();
  if (!cxxSystemPlatformsMap.containsKey(hostFlavor)) {
    cxxSystemPlatformsBuilder.put(hostFlavor,CxxPlatform.builder().from(defaultHostCxxPlatform).setFlavor(hostFlavor).build());
    cxxSystemPlatformsMap=cxxSystemPlatformsBuilder.build();
  }
  ImmutableList<ImmutableFlavor> possibleHostFlavors=CxxPlatforms.getAllPossibleHostFlavors();
  HashMap<Flavor,CxxPlatform> cxxOverridePlatformsMap=new HashMap<Flavor,CxxPlatform>(cxxSystemPlatformsMap);
  ImmutableSet<Flavor> cxxFlavors=CxxBuckConfig.getCxxFlavors(config);
  for (  Flavor flavor : cxxFlavors) {
    if (!cxxSystemPlatformsMap.containsKey(flavor)) {
      if (possibleHostFlavors.contains(flavor)) {
        continue;
      }
      LOG.warn(""String_Node_Str"" + flavor);
    }
    cxxOverridePlatformsMap.put(flavor,CxxPlatforms.copyPlatformWithFlavorAndConfig(cxxOverridePlatformsMap.get(flavor),new CxxBuckConfig(config,flavor),flavor));
  }
  hostFlavor=DefaultCxxPlatforms.FLAVOR;
  Optional<String> hostCxxPlatformOverride=cxxBuckConfig.getHostPlatform();
  if (hostCxxPlatformOverride.isPresent()) {
    Flavor overrideFlavor=ImmutableFlavor.of(hostCxxPlatformOverride.get());
    if (cxxOverridePlatformsMap.containsKey(overrideFlavor)) {
      hostFlavor=overrideFlavor;
    }
  }
  CxxPlatform hostCxxPlatform=CxxPlatform.builder().from(cxxOverridePlatformsMap.get(hostFlavor)).setFlavor(DefaultCxxPlatforms.FLAVOR).build();
  cxxOverridePlatformsMap.put(DefaultCxxPlatforms.FLAVOR,hostCxxPlatform);
  ImmutableMap<Flavor,CxxPlatform> cxxPlatformsMap=ImmutableMap.<Flavor,CxxPlatform>builder().putAll(cxxOverridePlatformsMap).build();
  ExecutableFinder executableFinder=new ExecutableFinder();
  FlavorDomain<CxxPlatform> cxxPlatforms=new FlavorDomain<>(""String_Node_Str"",cxxPlatformsMap);
  CxxPlatform defaultCxxPlatform=CxxPlatforms.getConfigDefaultCxxPlatform(cxxBuckConfig,cxxPlatformsMap,hostCxxPlatform);
  DBuckConfig dBuckConfig=new DBuckConfig(config);
  ReactNativeBuckConfig reactNativeBuckConfig=new ReactNativeBuckConfig(config);
  RustBuckConfig rustBuckConfig=new RustBuckConfig(config);
  GoBuckConfig goBuckConfig=new GoBuckConfig(config,processExecutor,cxxPlatforms);
  HalideBuckConfig halideBuckConfig=new HalideBuckConfig(config);
  ProGuardConfig proGuardConfig=new ProGuardConfig(config);
  PythonBuckConfig pyConfig=new PythonBuckConfig(config,executableFinder);
  ImmutableList<PythonPlatform> pythonPlatformsList=pyConfig.getPythonPlatforms(processExecutor);
  FlavorDomain<PythonPlatform> pythonPlatforms=FlavorDomain.from(""String_Node_Str"",pythonPlatformsList);
  PythonBinaryDescription pythonBinaryDescription=new PythonBinaryDescription(pyConfig,pythonPlatforms,cxxBuckConfig,defaultCxxPlatform,cxxPlatforms);
  Optional<Long> defaultTestRuleTimeoutMs=config.getLong(""String_Node_Str"",""String_Node_Str"");
  Downloader downloader;
  DownloadConfig downloadConfig=new DownloadConfig(config);
  if (downloadConfig.isDownloadAtRuntimeOk()) {
    downloader=StackedDownloader.createFromConfig(config,androidDirectoryResolver.getSdkOrAbsent());
  }
 else {
    downloader=new ExplodingDownloader();
  }
  Builder builder=builder();
  JavaBuckConfig javaConfig=config.getView(JavaBuckConfig.class);
  JavacOptions defaultJavacOptions=javaConfig.getDefaultJavacOptions();
  JavaOptions defaultJavaOptions=javaConfig.getDefaultJavaOptions();
  JavaOptions defaultJavaOptionsForTests=javaConfig.getDefaultJavaOptionsForTests();
  KotlinBuckConfig kotlinBuckConfig=new KotlinBuckConfig(config);
  ScalaBuckConfig scalaConfig=new ScalaBuckConfig(config);
  InferBuckConfig inferBuckConfig=new InferBuckConfig(config);
  LuaConfig luaConfig=new LuaBuckConfig(config,executableFinder);
  CxxBinaryDescription cxxBinaryDescription=new CxxBinaryDescription(cxxBuckConfig,inferBuckConfig,defaultCxxPlatform,cxxPlatforms);
  CxxLibraryDescription cxxLibraryDescription=new CxxLibraryDescription(cxxBuckConfig,defaultCxxPlatform,inferBuckConfig,cxxPlatforms);
  FlavorDomain<SwiftPlatform> platformFlavorsToSwiftPlatforms=new FlavorDomain<>(""String_Node_Str"",swiftPlatforms.build());
  SwiftLibraryDescription swiftLibraryDescription=new SwiftLibraryDescription(cxxBuckConfig,swiftBuckConfig,cxxPlatforms,platformFlavorsToSwiftPlatforms);
  builder.register(swiftLibraryDescription);
  CodeSignIdentityStore codeSignIdentityStore=appleConfig.useDryRunCodeSigning() ? CodeSignIdentityStore.fromIdentities(ImmutableList.of()) : CodeSignIdentityStore.fromSystem(processExecutor);
  ProvisioningProfileStore provisioningProfileStore=ProvisioningProfileStore.fromSearchPath(processExecutor,appleConfig.getProvisioningProfileReadCommand(),appleConfig.getProvisioningProfileSearchPath());
  AppleLibraryDescription appleLibraryDescription=new AppleLibraryDescription(cxxLibraryDescription,swiftLibraryDescription,platformFlavorsToAppleCxxPlatforms,defaultCxxPlatform,codeSignIdentityStore,provisioningProfileStore,appleConfig);
  builder.register(appleLibraryDescription);
  PrebuiltAppleFrameworkDescription appleFrameworkDescription=new PrebuiltAppleFrameworkDescription();
  builder.register(appleFrameworkDescription);
  AppleBinaryDescription appleBinaryDescription=new AppleBinaryDescription(cxxBinaryDescription,swiftLibraryDescription,platformFlavorsToAppleCxxPlatforms,codeSignIdentityStore,provisioningProfileStore,appleConfig);
  builder.register(appleBinaryDescription);
  HaskellBuckConfig haskellBuckConfig=new HaskellBuckConfig(config,executableFinder);
  builder.register(new HaskellLibraryDescription(haskellBuckConfig,cxxBuckConfig,cxxPlatforms));
  builder.register(new HaskellBinaryDescription(haskellBuckConfig,cxxPlatforms,defaultCxxPlatform));
  builder.register(new HaskellPrebuiltLibraryDescription());
  ListeningExecutorService dxExecutorService=MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(javaConfig.getDxThreadCount().orElse(SmartDexingStep.determineOptimalThreadCount()),new CommandThreadFactory(""String_Node_Str"")));
  builder.register(new AndroidAarDescription(new AndroidManifestDescription(),cxxBuckConfig,ndkCxxPlatforms));
  builder.register(new AndroidBinaryDescription(defaultJavaOptions,defaultJavacOptions,proGuardConfig,ndkCxxPlatforms,dxExecutorService,cxxBuckConfig));
  builder.register(new AndroidBuildConfigDescription(defaultJavacOptions));
  builder.register(new AndroidInstrumentationApkDescription(proGuardConfig,defaultJavacOptions,ndkCxxPlatforms,dxExecutorService,cxxBuckConfig));
  builder.register(new AndroidInstrumentationTestDescription(defaultJavaOptions,defaultTestRuleTimeoutMs));
  builder.register(new AndroidLibraryDescription(defaultJavacOptions,new DefaultAndroidLibraryCompilerFactory(scalaConfig,kotlinBuckConfig)));
  builder.register(new AndroidManifestDescription());
  builder.register(new AndroidPrebuiltAarDescription(defaultJavacOptions));
  builder.register(new AndroidReactNativeLibraryDescription(reactNativeBuckConfig));
  builder.register(new AndroidResourceDescription(config.isGrayscaleImageProcessingEnabled()));
  builder.register(new ApkGenruleDescription());
  builder.register(new AppleAssetCatalogDescription());
  builder.register(new ApplePackageDescription(appleConfig,defaultCxxPlatform,platformFlavorsToAppleCxxPlatforms));
  AppleBundleDescription appleBundleDescription=new AppleBundleDescription(appleBinaryDescription,appleLibraryDescription,cxxPlatforms,platformFlavorsToAppleCxxPlatforms,defaultCxxPlatform,codeSignIdentityStore,provisioningProfileStore,appleConfig);
  builder.register(appleBundleDescription);
  builder.register(new AppleResourceDescription());
  builder.register(new AppleTestDescription(appleConfig,appleLibraryDescription,cxxPlatforms,platformFlavorsToAppleCxxPlatforms,defaultCxxPlatform,codeSignIdentityStore,provisioningProfileStore,appleConfig.getAppleDeveloperDirectorySupplierForTests(processExecutor),defaultTestRuleTimeoutMs));
  builder.register(new CoreDataModelDescription());
  builder.register(new CsharpLibraryDescription());
  builder.register(cxxBinaryDescription);
  builder.register(cxxLibraryDescription);
  builder.register(new CxxGenruleDescription(cxxPlatforms));
  builder.register(new CxxLuaExtensionDescription(luaConfig,cxxBuckConfig,cxxPlatforms));
  builder.register(new CxxPythonExtensionDescription(pythonPlatforms,cxxBuckConfig,cxxPlatforms));
  builder.register(new CxxTestDescription(cxxBuckConfig,defaultCxxPlatform,cxxPlatforms,defaultTestRuleTimeoutMs));
  builder.register(new DBinaryDescription(dBuckConfig,cxxBuckConfig,defaultCxxPlatform));
  builder.register(new DLibraryDescription(dBuckConfig,cxxBuckConfig,defaultCxxPlatform));
  builder.register(new DTestDescription(dBuckConfig,cxxBuckConfig,defaultCxxPlatform,defaultTestRuleTimeoutMs));
  builder.register(new ExportFileDescription());
  builder.register(new GenruleDescription());
  builder.register(new GenAidlDescription());
  builder.register(new GoBinaryDescription(goBuckConfig));
  builder.register(new GoLibraryDescription(goBuckConfig));
  builder.register(new GoTestDescription(goBuckConfig,defaultTestRuleTimeoutMs));
  builder.register(new GraphqlLibraryDescription());
  GroovyBuckConfig groovyBuckConfig=new GroovyBuckConfig(config);
  builder.register(new GroovyLibraryDescription(groovyBuckConfig,defaultJavacOptions));
  builder.register(new GroovyTestDescription(groovyBuckConfig,defaultJavaOptionsForTests,defaultJavacOptions,defaultTestRuleTimeoutMs));
  builder.register(new GwtBinaryDescription(defaultJavaOptions));
  builder.register(new HalideLibraryDescription(cxxBuckConfig,defaultCxxPlatform,cxxPlatforms,halideBuckConfig));
  builder.register(new IosReactNativeLibraryDescription(reactNativeBuckConfig));
  builder.register(new JavaBinaryDescription(defaultJavaOptions,defaultJavacOptions,defaultCxxPlatform));
  builder.register(new JavaLibraryDescription(defaultJavacOptions));
  builder.register(new JavaTestDescription(defaultJavaOptionsForTests,defaultJavacOptions,defaultTestRuleTimeoutMs,defaultCxxPlatform));
  builder.register(new KeystoreDescription());
  builder.register(new KotlinLibraryDescription(kotlinBuckConfig));
  builder.register(new KotlinTestDescription(kotlinBuckConfig,defaultJavaOptionsForTests,defaultJavacOptions,defaultTestRuleTimeoutMs));
  builder.register(new LuaBinaryDescription(luaConfig,cxxBuckConfig,defaultCxxPlatform,cxxPlatforms,pythonPlatforms));
  builder.register(new LuaLibraryDescription());
  builder.register(new NdkLibraryDescription(ndkVersion,ndkCxxPlatforms));
  OcamlBuckConfig ocamlBuckConfig=new OcamlBuckConfig(platform,filesystem,config);
  builder.register(new OcamlBinaryDescription(ocamlBuckConfig));
  builder.register(new OcamlLibraryDescription(ocamlBuckConfig));
  builder.register(new PrebuiltCxxLibraryDescription(cxxBuckConfig,cxxPlatforms));
  builder.register(PrebuiltCxxLibraryGroupDescription.of());
  builder.register(new PrebuiltDotnetLibraryDescription());
  builder.register(new PrebuiltJarDescription());
  builder.register(new PrebuiltNativeLibraryDescription());
  builder.register(new PrebuiltOcamlLibraryDescription());
  builder.register(new PrebuiltPythonLibraryDescription());
  builder.register(new ProjectConfigDescription());
  builder.register(pythonBinaryDescription);
  builder.register(new PythonLibraryDescription());
  builder.register(new PythonTestDescription(pythonBinaryDescription,pyConfig,pythonPlatforms,cxxBuckConfig,defaultCxxPlatform,defaultTestRuleTimeoutMs,cxxPlatforms));
  builder.register(new RemoteFileDescription(downloader));
  builder.register(new RobolectricTestDescription(defaultJavaOptionsForTests,defaultJavacOptions,defaultTestRuleTimeoutMs,defaultCxxPlatform));
  builder.register(new RustBinaryDescription(rustBuckConfig,defaultCxxPlatform));
  builder.register(new RustLibraryDescription(rustBuckConfig,defaultCxxPlatform));
  builder.register(new RustTestDescription(rustBuckConfig,defaultCxxPlatform));
  builder.register(new PrebuiltRustLibraryDescription(rustBuckConfig,defaultCxxPlatform));
  builder.register(new ScalaLibraryDescription(scalaConfig));
  builder.register(new ScalaTestDescription(scalaConfig,defaultJavaOptionsForTests,defaultTestRuleTimeoutMs,defaultCxxPlatform));
  builder.register(new SceneKitAssetsDescription());
  builder.register(new ShBinaryDescription());
  builder.register(new ShTestDescription(defaultTestRuleTimeoutMs));
  ThriftBuckConfig thriftBuckConfig=new ThriftBuckConfig(config);
  builder.register(new ThriftLibraryDescription(thriftBuckConfig,ImmutableList.of(new ThriftJavaEnhancer(thriftBuckConfig,defaultJavacOptions),new ThriftCxxEnhancer(thriftBuckConfig,cxxLibraryDescription,false),new ThriftCxxEnhancer(thriftBuckConfig,cxxLibraryDescription,true),new ThriftPythonEnhancer(thriftBuckConfig,ThriftPythonEnhancer.Type.NORMAL),new ThriftPythonEnhancer(thriftBuckConfig,ThriftPythonEnhancer.Type.TWISTED),new ThriftPythonEnhancer(thriftBuckConfig,ThriftPythonEnhancer.Type.ASYNCIO))));
  builder.register(new WorkerToolDescription(config));
  builder.register(new XcodePostbuildScriptDescription());
  builder.register(new XcodePrebuildScriptDescription());
  builder.register(new XcodeWorkspaceConfigDescription());
  builder.register(new ZipFileDescription());
  builder.register(new TargetGroupDescription());
  builder.setCxxPlatforms(cxxPlatforms);
  builder.setDefaultCxxPlatform(defaultCxxPlatform);
  builder.register(VersionedAliasDescription.of());
  return builder;
}",0.9990284688079608
53015,"@Override public int compareTo(ModuleIndexEntry o){
  if (this == o) {
    return 0;
  }
  return getFilePath().compareTo(o.getFilePath());
}","@Override public int compareTo(ModuleIndexEntry o){
  if (this == o) {
    return 0;
  }
  return getFilePath().toString().replace(File.separatorChar,' ').compareTo(o.getFilePath().toString().replace(File.separatorChar,' '));
}",0.7663043478260869
53016,"@Value.Derived public Optional<String> getInitialError(){
  Throwable throwable=getRecord().getThrown();
  if (throwable != null) {
    return Optional.of(getInitialCause(throwable).getClass().getName());
  }
  return Optional.empty();
}","@Value.Derived public Optional<String> getInitialError(){
  Throwable throwable=getRecord().getThrown();
  if (throwable != null) {
    return Optional.ofNullable(getInitialCause(throwable).getClass().getName());
  }
  return Optional.empty();
}",0.983402489626556
53017,"@Value.Derived public Optional<String> getOrigin(){
  Throwable throwable=getRecord().getThrown();
  if (throwable != null) {
    return Optional.of(getThrowableOrigin(throwable));
  }
  return Optional.empty();
}","@Value.Derived public Optional<String> getOrigin(){
  Throwable throwable=getRecord().getThrown();
  if (throwable != null) {
    return Optional.ofNullable(getThrowableOrigin(throwable));
  }
  return Optional.empty();
}",0.9815668202764976
53018,"@Value.Derived public String getMessage(){
  Optional<String> initialErr=Optional.empty();
  Optional<String> initialErrorMsg=Optional.empty();
  Optional<String> errorMsg=Optional.empty();
  Throwable throwable=getRecord().getThrown();
  if (throwable != null) {
    initialErr=Optional.of(getInitialCause(throwable).getClass().getName());
    if (throwable.getMessage() != null) {
      initialErrorMsg=Optional.of(getInitialCause(throwable).getLocalizedMessage());
    }
  }
  String message=getRecord().getMessage();
  if (message != null) {
    errorMsg=Optional.of(message);
  }
  StringBuilder sb=new StringBuilder();
  for (  Optional<String> field : ImmutableList.of(initialErr,initialErrorMsg,errorMsg)) {
    sb.append(field.orElse(""String_Node_Str""));
    if (field.isPresent()) {
      sb.append(""String_Node_Str"");
    }
  }
  sb.append(getRecord().getLoggerName());
  return sb.toString();
}","@Value.Derived public String getMessage(){
  Optional<String> initialErr=Optional.empty();
  Optional<String> initialErrorMsg=Optional.empty();
  Optional<String> errorMsg=Optional.empty();
  Throwable throwable=getRecord().getThrown();
  if (throwable != null) {
    initialErr=Optional.ofNullable(getInitialCause(throwable).getClass().getName());
    if (throwable.getMessage() != null) {
      initialErrorMsg=Optional.ofNullable(getInitialCause(throwable).getLocalizedMessage());
    }
  }
  errorMsg=Optional.ofNullable(getRecord().getMessage());
  StringBuilder sb=new StringBuilder();
  for (  Optional<String> field : ImmutableList.of(initialErr,initialErrorMsg,errorMsg)) {
    sb.append(field.orElse(""String_Node_Str""));
    if (field.isPresent()) {
      sb.append(""String_Node_Str"");
    }
  }
  sb.append(getRecord().getLoggerName());
  return sb.toString();
}",0.9286115795390668
53019,"@Value.Derived public Optional<String> getLogger(){
  String logger=getRecord().getLoggerName();
  if (logger != null) {
    return Optional.of(logger);
  }
  return Optional.empty();
}","@Value.Derived public Optional<String> getLogger(){
  return Optional.ofNullable(getRecord().getLoggerName());
}",0.6195286195286195
53020,"@Value.Derived public Optional<StackTraceElement[]> getStack(){
  Throwable throwable=getRecord().getThrown();
  if (throwable != null) {
    return Optional.of(throwable.getStackTrace());
  }
  return Optional.empty();
}","@Value.Derived public Optional<StackTraceElement[]> getStack(){
  Throwable throwable=getRecord().getThrown();
  if (throwable != null) {
    return Optional.ofNullable(throwable.getStackTrace());
  }
  return Optional.empty();
}",0.9822222222222222
53021,"@Value.Derived public Optional<String> getBuildUuid(){
  String buildUuid=MAPPER.threadIdToCommandId(getRecord().getThreadID());
  if (buildUuid != null) {
    return Optional.of(buildUuid);
  }
  return Optional.empty();
}","@Value.Derived public Optional<String> getBuildUuid(){
  String buildUuid=MAPPER.threadIdToCommandId(getRecord().getThreadID());
  return Optional.ofNullable(buildUuid);
}",0.8274111675126904
53022,"@Value.Derived public Optional<String> getErrorMessage(){
  Throwable throwable=getRecord().getThrown();
  if (throwable != null && throwable.getMessage() != null) {
    return Optional.of(throwable.getMessage());
  }
  return Optional.empty();
}","@Value.Derived public Optional<String> getErrorMessage(){
  Throwable throwable=getRecord().getThrown();
  if (throwable != null && throwable.getMessage() != null) {
    return Optional.ofNullable(throwable.getMessage());
  }
  return Optional.empty();
}",0.984
53023,"/** 
 * Fetch the artifact matching ruleKey and store it to output. If any of the encapsulated ArtifactCaches contains the desired artifact, this method succeeds, and it may store the artifact to one or more of the other encapsulated ArtifactCaches as a side effect.
 */
@Override public CacheResult fetch(RuleKey ruleKey,LazyPath output){
  CacheResult cacheResult=CacheResult.miss();
  for (  ArtifactCache artifactCache : artifactCaches) {
    cacheResult=artifactCache.fetch(ruleKey,output);
    if (cacheResult.getType().isSuccess()) {
      for (      ArtifactCache priorArtifactCache : artifactCaches) {
        if (priorArtifactCache.equals(artifactCache)) {
          break;
        }
        BorrowablePath outputPath;
        if (priorArtifactCache.equals(artifactCaches.get(artifactCaches.size() - 1))) {
          outputPath=BorrowablePath.borrowablePath(output.getUnchecked());
        }
 else {
          outputPath=BorrowablePath.notBorrowablePath(output.getUnchecked());
        }
        priorArtifactCache.store(ArtifactInfo.builder().addRuleKeys(ruleKey).setMetadata(cacheResult.getMetadata()).build(),outputPath);
      }
      return cacheResult;
    }
  }
  return cacheResult;
}","/** 
 * Fetch the artifact matching ruleKey and store it to output. If any of the encapsulated ArtifactCaches contains the desired artifact, this method succeeds, and it may store the artifact to one or more of the other encapsulated ArtifactCaches as a side effect.
 */
@Override public CacheResult fetch(RuleKey ruleKey,LazyPath output){
  CacheResult cacheResult=CacheResult.miss();
  ImmutableList.Builder<ArtifactCache> priorCaches=ImmutableList.builder();
  for (  ArtifactCache artifactCache : artifactCaches) {
    cacheResult=artifactCache.fetch(ruleKey,output);
    if (cacheResult.getType().isSuccess()) {
      break;
    }
    if (artifactCache.isStoreSupported()) {
      priorCaches.add(artifactCache);
    }
  }
  if (cacheResult.getType().isSuccess()) {
    storeToCaches(priorCaches.build(),ArtifactInfo.builder().addRuleKeys(ruleKey).setMetadata(cacheResult.getMetadata()).build(),BorrowablePath.borrowablePath(output.getUnchecked()));
  }
  return cacheResult;
}",0.532967032967033
53024,"/** 
 * Store the artifact to all encapsulated ArtifactCaches.
 */
@Override public ListenableFuture<Void> store(ArtifactInfo info,BorrowablePath output){
  List<ListenableFuture<Void>> storeFutures=Lists.newArrayListWithExpectedSize(writableArtifactCaches.size());
  for (  ArtifactCache artifactCache : writableArtifactCaches) {
    if (output.canBorrow() && artifactCache.equals(writableArtifactCaches.get(writableArtifactCaches.size() - 1))) {
      output=BorrowablePath.borrowablePath(output.getPath());
    }
 else {
      output=BorrowablePath.notBorrowablePath(output.getPath());
    }
    storeFutures.add(artifactCache.store(info,output));
  }
  return Futures.transform(Futures.allAsList(storeFutures),Functions.<Void>constant(null));
}","/** 
 * Store the artifact to all encapsulated ArtifactCaches.
 */
@Override public ListenableFuture<Void> store(ArtifactInfo info,BorrowablePath output){
  return storeToCaches(writableArtifactCaches,info,output);
}",0.3817427385892116
53025,"public static Optional<CoreDataModel> createBuildRulesForCoreDataDependencies(TargetGraph targetGraph,BuildRuleParams params,SourcePathResolver sourcePathResolver,String moduleName,AppleCxxPlatform appleCxxPlatform){
  TargetNode<?,?> targetNode=targetGraph.get(params.getBuildTarget());
  ImmutableSet<CoreDataModelDescription.Arg> coreDataModelArgs=AppleBuildRules.collectTransitiveCoreDataModels(targetGraph,ImmutableList.of(targetNode));
  BuildRuleParams coreDataModelParams=params.copyWithChanges(params.getBuildTarget().withAppendedFlavors(AppleAssetCatalog.FLAVOR),Suppliers.ofInstance(ImmutableSortedSet.of()),Suppliers.ofInstance(ImmutableSortedSet.of()));
  if (coreDataModelArgs.isEmpty()) {
    return Optional.empty();
  }
 else {
    return Optional.of(new CoreDataModel(coreDataModelParams,sourcePathResolver,appleCxxPlatform,moduleName,coreDataModelArgs.stream().map(input -> new PathSourcePath(params.getProjectFilesystem(),input.path)).collect(MoreCollectors.toImmutableSet())));
  }
}","public static Optional<CoreDataModel> createBuildRulesForCoreDataDependencies(TargetGraph targetGraph,BuildRuleParams params,SourcePathResolver sourcePathResolver,String moduleName,AppleCxxPlatform appleCxxPlatform){
  TargetNode<?,?> targetNode=targetGraph.get(params.getBuildTarget());
  ImmutableSet<CoreDataModelDescription.Arg> coreDataModelArgs=AppleBuildRules.collectTransitiveCoreDataModels(targetGraph,ImmutableList.of(targetNode));
  BuildRuleParams coreDataModelParams=params.copyWithChanges(params.getBuildTarget().withAppendedFlavors(CoreDataModel.FLAVOR),Suppliers.ofInstance(ImmutableSortedSet.of()),Suppliers.ofInstance(ImmutableSortedSet.of()));
  if (coreDataModelArgs.isEmpty()) {
    return Optional.empty();
  }
 else {
    return Optional.of(new CoreDataModel(coreDataModelParams,sourcePathResolver,appleCxxPlatform,moduleName,coreDataModelArgs.stream().map(input -> new PathSourcePath(params.getProjectFilesystem(),input.path)).collect(MoreCollectors.toImmutableSet())));
  }
}",0.9860279441117764
53026,"@Override public void close() throws Exception {
  executorService.shutdown();
  thriftService.close();
}","@Override public void close() throws IOException {
  executorService.shutdown();
  thriftService.close();
}",0.9905660377358492
53027,"@Override public void close() throws Exception {
  startedClosing=true;
synchronized (this) {
    try {
      if (filesystem.isDirectory(logDir)) {
        deleteOldLogsIfNeeded(maxScribeOfflineLogsBytes - bytesStoredSoFar);
      }
    }
 catch (    Exception e) {
      LOG.error(e,""String_Node_Str"");
    }
    if (logFileStoreStream != null) {
      logFileStoreStream.close();
    }
    storingAvailable=false;
  }
  scribeLogger.close();
}","@Override public void close() throws IOException {
  startedClosing=true;
synchronized (this) {
    try {
      if (filesystem.isDirectory(logDir)) {
        deleteOldLogsIfNeeded(maxScribeOfflineLogsBytes - bytesStoredSoFar);
      }
    }
 catch (    Exception e) {
      LOG.error(e,""String_Node_Str"");
    }
    if (logFileStoreStream != null) {
      logFileStoreStream.close();
    }
    storingAvailable=false;
  }
  scribeLogger.close();
}",0.9977578475336324
53028,"@Override public void close() throws Exception {
}","@Override public void close() throws IOException {
}",0.9803921568627452
53029,"@Override public void close() throws Exception {
}","@Override public void close() throws IOException {
}",0.9803921568627452
53030,"@Test public void sendStoredLogs() throws Exception {
  final ImmutableList<String> blacklistCategories=ImmutableList.of();
  final int maxScribeOfflineLogsKB=2;
  final ProjectFilesystem filesystem=new ProjectFilesystem(tmp.getRoot());
  final Path logDir=filesystem.getBuckPaths().getOfflineLogDir();
  final ObjectMapper objectMapper=ObjectMappers.newDefaultInstance();
  final String[] ids={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final String[] uniqueCategories={""String_Node_Str"",""String_Node_Str""};
  final String[] categories={uniqueCategories[0],uniqueCategories[1],uniqueCategories[0]};
  final String testCategory=""String_Node_Str"";
  final String line=""String_Node_Str"";
  final List<Pair<String,Iterable<String>>> sentData=new ArrayList<>();
  final ScribeLogger succeeddingLogger=new ScribeLogger(){
    @Override public ListenableFuture<Void> log(    String category,    Iterable<String> lines){
      if (!category.equals(testCategory)) {
        sentData.add(new Pair<>(category,lines));
      }
      return Futures.immediateFuture(null);
    }
    @Override public void close() throws Exception {
    }
  }
;
  filesystem.mkdirs(logDir);
  for (  String id : ids) {
    File log=filesystem.resolve(logDir.resolve(LOGFILE_PREFIX + id + LOGFILE_SUFFIX)).toFile();
    BufferedOutputStream logFileStoreStream=new BufferedOutputStream(new FileOutputStream(log));
    for (    String category : categories) {
      byte[] scribeData=objectMapper.writeValueAsString(ScribeData.builder().setCategory(category).setLines(ImmutableList.of(line,line,line,line)).build()).getBytes(Charsets.UTF_8);
      logFileStoreStream.write(scribeData);
    }
    logFileStoreStream.close();
  }
  OfflineScribeLogger offlineLogger=new OfflineScribeLogger(succeeddingLogger,blacklistCategories,maxScribeOfflineLogsKB,filesystem,objectMapper,BuckEventBusFactory.newInstance(),new BuildId(""String_Node_Str""));
  offlineLogger.log(testCategory,ImmutableList.of(""String_Node_Str"",""String_Node_Str""));
  offlineLogger.close();
  assertEquals(4,sentData.size());
  final String[] expectedCategories=ObjectArrays.concat(uniqueCategories,uniqueCategories,String.class);
  final String[] seenCategories=new String[sentData.size()];
  for (int i=0; i < sentData.size(); i++) {
    seenCategories[i]=sentData.get(i).getFirst();
    int expectedCount=(sentData.get(i).getFirst().equals(uniqueCategories[0])) ? 8 : 4;
    assertThat(sentData.get(i).getSecond(),Matchers.allOf(everyItem(equalTo(line)),IsIterableWithSize.<String>iterableWithSize(expectedCount)));
  }
  assertThat(seenCategories,arrayContainingInAnyOrder(expectedCategories));
  ImmutableSortedSet<Path> logs=filesystem.getMtimeSortedMatchingDirectoryContents(logDir,LOGFILE_PATTERN);
  Path notRemovedLog=filesystem.resolve(logDir.resolve(LOGFILE_PREFIX + ids[0] + LOGFILE_SUFFIX));
  assertThat(logs,Matchers.allOf(hasItem(notRemovedLog),IsIterableWithSize.<Path>iterableWithSize(1)));
}","@Test public void sendStoredLogs() throws Exception {
  final ImmutableList<String> blacklistCategories=ImmutableList.of();
  final int maxScribeOfflineLogsKB=2;
  final ProjectFilesystem filesystem=new ProjectFilesystem(tmp.getRoot());
  final Path logDir=filesystem.getBuckPaths().getOfflineLogDir();
  final ObjectMapper objectMapper=ObjectMappers.newDefaultInstance();
  final String[] ids={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final String[] uniqueCategories={""String_Node_Str"",""String_Node_Str""};
  final String[] categories={uniqueCategories[0],uniqueCategories[1],uniqueCategories[0]};
  final String testCategory=""String_Node_Str"";
  final String line=""String_Node_Str"";
  final List<Pair<String,Iterable<String>>> sentData=new ArrayList<>();
  final ScribeLogger succeeddingLogger=new ScribeLogger(){
    @Override public ListenableFuture<Void> log(    String category,    Iterable<String> lines){
      if (!category.equals(testCategory)) {
        sentData.add(new Pair<>(category,lines));
      }
      return Futures.immediateFuture(null);
    }
    @Override public void close() throws IOException {
    }
  }
;
  filesystem.mkdirs(logDir);
  for (  String id : ids) {
    File log=filesystem.resolve(logDir.resolve(LOGFILE_PREFIX + id + LOGFILE_SUFFIX)).toFile();
    BufferedOutputStream logFileStoreStream=new BufferedOutputStream(new FileOutputStream(log));
    for (    String category : categories) {
      byte[] scribeData=objectMapper.writeValueAsString(ScribeData.builder().setCategory(category).setLines(ImmutableList.of(line,line,line,line)).build()).getBytes(Charsets.UTF_8);
      logFileStoreStream.write(scribeData);
    }
    logFileStoreStream.close();
  }
  OfflineScribeLogger offlineLogger=new OfflineScribeLogger(succeeddingLogger,blacklistCategories,maxScribeOfflineLogsKB,filesystem,objectMapper,BuckEventBusFactory.newInstance(),new BuildId(""String_Node_Str""));
  offlineLogger.log(testCategory,ImmutableList.of(""String_Node_Str"",""String_Node_Str""));
  offlineLogger.close();
  assertEquals(4,sentData.size());
  final String[] expectedCategories=ObjectArrays.concat(uniqueCategories,uniqueCategories,String.class);
  final String[] seenCategories=new String[sentData.size()];
  for (int i=0; i < sentData.size(); i++) {
    seenCategories[i]=sentData.get(i).getFirst();
    int expectedCount=(sentData.get(i).getFirst().equals(uniqueCategories[0])) ? 8 : 4;
    assertThat(sentData.get(i).getSecond(),Matchers.allOf(everyItem(equalTo(line)),IsIterableWithSize.<String>iterableWithSize(expectedCount)));
  }
  assertThat(seenCategories,arrayContainingInAnyOrder(expectedCategories));
  ImmutableSortedSet<Path> logs=filesystem.getMtimeSortedMatchingDirectoryContents(logDir,LOGFILE_PATTERN);
  Path notRemovedLog=filesystem.resolve(logDir.resolve(LOGFILE_PREFIX + ids[0] + LOGFILE_SUFFIX));
  assertThat(logs,Matchers.allOf(hasItem(notRemovedLog),IsIterableWithSize.<Path>iterableWithSize(1)));
}",0.999661705006766
53031,"@Override public void close() throws Exception {
  offlineScribeLogger.close();
}","@Override public void close() throws IOException {
  offlineScribeLogger.close();
}",0.9878048780487804
53032,"/** 
 * Helper method to add coerced elements to the builder.
 */
protected void fill(CellPathResolver cellRoots,ProjectFilesystem filesystem,Path pathRelativeToProjectRoot,C.Builder<T> builder,Object object) throws CoerceFailedException {
  if (object instanceof Collection) {
    for (    Object element : (Iterable<?>)object) {
      T coercedElement=elementTypeCoercer.coerce(cellRoots,filesystem,pathRelativeToProjectRoot,element);
      builder.add(coercedElement);
    }
  }
 else {
    throw CoerceFailedException.simple(object,getOutputClass());
  }
}","/** 
 * Helper method to add coerced elements to the builder.
 */
protected void fill(CellPathResolver cellRoots,ProjectFilesystem filesystem,Path pathRelativeToProjectRoot,ImmutableCollection.Builder<T> builder,Object object) throws CoerceFailedException {
  if (object instanceof Collection) {
    for (    Object element : (Iterable<?>)object) {
      T coercedElement=elementTypeCoercer.coerce(cellRoots,filesystem,pathRelativeToProjectRoot,element);
      builder.add(coercedElement);
    }
  }
 else {
    throw CoerceFailedException.simple(object,getOutputClass());
  }
}",0.9824253075571178
53033,"private Pair<Path,Path> findSymlinkRoot(Path symlinkPath){
  for (int componentCount=1; componentCount <= symlinkPath.getNameCount(); componentCount++) {
    Path symlinkSubpath=symlinkPath.subpath(0,componentCount);
    Path realSymlinkSubpath=findRealPath(symlinkSubpath);
    boolean realPathOutsideProject=projectFilesystem.getPathRelativeToProjectRoot(realSymlinkSubpath).isPresent();
    if (realPathOutsideProject) {
      return new Pair<>(projectFilesystem.getPathRelativeToProjectRoot(symlinkSubpath).get(),realSymlinkSubpath);
    }
  }
  throw new RuntimeException(String.format(""String_Node_Str"",symlinkPath.toAbsolutePath()));
}","private Pair<Path,Path> findSymlinkRoot(Path symlinkPath){
  int projectPathComponents=projectFilesystem.getRootPath().getNameCount();
  for (int pathEndIndex=(projectPathComponents + 1); pathEndIndex <= symlinkPath.getNameCount(); pathEndIndex++) {
    Path symlinkSubpath=symlinkPath.getRoot().resolve(symlinkPath.subpath(0,pathEndIndex));
    Path realSymlinkSubpath=findRealPath(symlinkSubpath);
    boolean realPathOutsideProject=!projectFilesystem.getPathRelativeToProjectRoot(realSymlinkSubpath).isPresent();
    if (realPathOutsideProject) {
      return new Pair<>(projectFilesystem.getPathRelativeToProjectRoot(symlinkSubpath).get(),realSymlinkSubpath);
    }
  }
  throw new RuntimeException(String.format(""String_Node_Str"",symlinkPath.toAbsolutePath()));
}",0.8326241134751773
53034,"private static ImmutableList<String> getCxxppflags(NdkCxxPlatformTargetConfiguration targetConfiguration,NdkCxxToolchainPaths toolchainPaths){
  ImmutableList.Builder<String> flags=ImmutableList.builder();
  flags.addAll(getCxxRuntimeIncludeFlags(targetConfiguration,toolchainPaths));
  flags.addAll(getCommonIncludes(toolchainPaths));
  flags.addAll(getCommonPreprocessorFlags());
  flags.addAll(getCommonFlags(targetConfiguration,toolchainPaths));
  flags.addAll(getCommonCxxFlags());
  if (targetConfiguration.getCompiler().getType() == NdkCxxPlatformCompiler.Type.GCC) {
    flags.add(""String_Node_Str"");
  }
  flags.addAll(targetConfiguration.getCompilerFlags(targetConfiguration.getCompiler().getType()));
  return flags.build();
}","private static ImmutableList<String> getCxxppflags(NdkCxxPlatformTargetConfiguration targetConfiguration,NdkCxxToolchainPaths toolchainPaths,ImmutableList<String> sanitizerFlags){
  ImmutableList.Builder<String> flags=ImmutableList.builder();
  flags.addAll(getCxxRuntimeIncludeFlags(targetConfiguration,toolchainPaths));
  flags.addAll(getCommonIncludes(toolchainPaths));
  flags.addAll(getCommonPreprocessorFlags());
  flags.addAll(getCommonFlags(targetConfiguration,toolchainPaths));
  flags.addAll(getCommonCxxFlags());
  flags.addAll(sanitizerFlags);
  if (targetConfiguration.getCompiler().getType() == NdkCxxPlatformCompiler.Type.GCC) {
    flags.add(""String_Node_Str"");
  }
  flags.addAll(targetConfiguration.getCompilerFlags(targetConfiguration.getCompiler().getType()));
  return flags.build();
}",0.9384316267012314
53035,"private static ImmutableList<String> getCxxflagsInternal(NdkCxxPlatformTargetConfiguration targetConfiguration,NdkCxxToolchainPaths toolchainPaths){
  return ImmutableList.<String>builder().addAll(targetConfiguration.getCompilerFlags(targetConfiguration.getCompiler().getType())).addAll(getCommonCxxFlags()).addAll(getCommonFlags(targetConfiguration,toolchainPaths)).addAll(getCommonNdkCxxPlatformCompilerFlags()).build();
}","private static ImmutableList<String> getCxxflagsInternal(NdkCxxPlatformTargetConfiguration targetConfiguration,NdkCxxToolchainPaths toolchainPaths,ImmutableList<String> sanitizerFlags){
  return ImmutableList.<String>builder().addAll(targetConfiguration.getCompilerFlags(targetConfiguration.getCompiler().getType())).addAll(getCommonCxxFlags()).addAll(getCommonFlags(targetConfiguration,toolchainPaths)).addAll(getCommonNdkCxxPlatformCompilerFlags()).addAll(sanitizerFlags).build();
}",0.933920704845815
53036,"private static ImmutableList<String> getCppflags(NdkCxxPlatformTargetConfiguration targetConfiguration,NdkCxxToolchainPaths toolchainPaths){
  return ImmutableList.<String>builder().addAll(getCommonIncludes(toolchainPaths)).addAll(getCommonPreprocessorFlags()).addAll(getCommonFlags(targetConfiguration,toolchainPaths)).addAll(getCommonCFlags()).addAll(targetConfiguration.getCompilerFlags(targetConfiguration.getCompiler().getType())).build();
}","private static ImmutableList<String> getCppflags(NdkCxxPlatformTargetConfiguration targetConfiguration,NdkCxxToolchainPaths toolchainPaths,ImmutableList<String> sanitizerFlags){
  return ImmutableList.<String>builder().addAll(getCommonIncludes(toolchainPaths)).addAll(getCommonPreprocessorFlags()).addAll(getCommonFlags(targetConfiguration,toolchainPaths)).addAll(getCommonCFlags()).addAll(sanitizerFlags).addAll(targetConfiguration.getCompilerFlags(targetConfiguration.getCompiler().getType())).build();
}",0.9369747899159664
53037,"private NdkCxxToolchainPaths(Path ndkRoot,String ndkVersion,NdkCxxPlatformTargetConfiguration targetConfiguration,String hostName,CxxRuntime cxxRuntime,boolean strict){
  this.cachedPaths=new HashMap<>();
  this.strict=strict;
  this.targetConfiguration=targetConfiguration;
  this.hostName=hostName;
  this.cxxRuntime=cxxRuntime;
  this.ndkRoot=ndkRoot;
  this.ndkVersion=ndkVersion;
  this.ndkMajorVersion=getNdkMajorVersion(ndkVersion);
  Assertions.assertCondition(ndkMajorVersion > 0,""String_Node_Str"" + ndkVersion);
}","private NdkCxxToolchainPaths(ProjectFilesystem filesystem,Path ndkRoot,String ndkVersion,NdkCxxPlatformTargetConfiguration targetConfiguration,String hostName,CxxRuntime cxxRuntime,boolean strict){
  this.filesystem=filesystem;
  this.cachedPaths=new HashMap<>();
  this.strict=strict;
  this.targetConfiguration=targetConfiguration;
  this.hostName=hostName;
  this.cxxRuntime=cxxRuntime;
  this.ndkRoot=ndkRoot;
  this.ndkVersion=ndkVersion;
  this.ndkMajorVersion=getNdkMajorVersion(ndkVersion);
  Assertions.assertCondition(ndkMajorVersion > 0,""String_Node_Str"" + ndkVersion);
}",0.9466063348416288
53038,"NdkCxxToolchainPaths getSanitizedPaths(){
  return new NdkCxxToolchainPaths(Paths.get(ANDROID_NDK_ROOT),ndkVersion,targetConfiguration,BUILD_HOST_SUBST,cxxRuntime,false);
}","NdkCxxToolchainPaths getSanitizedPaths(){
  return new NdkCxxToolchainPaths(filesystem,Paths.get(ANDROID_NDK_ROOT),ndkVersion,targetConfiguration,BUILD_HOST_SUBST,cxxRuntime,false);
}",0.9690140845070424
53039,"private static ImmutableList<String> getAsflags(NdkCxxPlatformTargetConfiguration targetConfiguration,NdkCxxToolchainPaths toolchainPaths){
  return ImmutableList.<String>builder().addAll(getCommonFlags(targetConfiguration,toolchainPaths)).add(""String_Node_Str"",""String_Node_Str"").addAll(targetConfiguration.getAssemblerFlags(targetConfiguration.getCompiler().getType())).build();
}","private static ImmutableList<String> getAsflags(NdkCxxPlatformTargetConfiguration targetConfiguration,NdkCxxToolchainPaths toolchainPaths,ImmutableList<String> sanitizerFlags){
  return ImmutableList.<String>builder().addAll(getCommonFlags(targetConfiguration,toolchainPaths)).addAll(sanitizerFlags).add(""String_Node_Str"",""String_Node_Str"").addAll(targetConfiguration.getAssemblerFlags(targetConfiguration.getCompiler().getType())).build();
}",0.9271844660194176
53040,"@VisibleForTesting static NdkCxxPlatform build(CxxBuckConfig config,Flavor flavor,Platform platform,Path ndkRoot,NdkCxxPlatformTargetConfiguration targetConfiguration,CxxRuntime cxxRuntime,ExecutableFinder executableFinder,boolean strictToolchainPaths){
  NdkCxxPlatformCompiler.Type compilerType=targetConfiguration.getCompiler().getType();
  String version=Joiner.on('-').join(ImmutableList.of(readVersion(ndkRoot),targetConfiguration.getToolchain(),targetConfiguration.getTargetAppPlatform(),compilerType,targetConfiguration.getCompiler().getVersion(),targetConfiguration.getCompiler().getGccVersion(),cxxRuntime));
  Host host=Preconditions.checkNotNull(BUILD_PLATFORMS.get(platform));
  NdkCxxToolchainPaths toolchainPaths=new NdkCxxToolchainPaths(ndkRoot,targetConfiguration,host.toString(),cxxRuntime,strictToolchainPaths);
  NdkCxxToolchainPaths sanitizedPaths=toolchainPaths.getSanitizedPaths();
  ImmutableBiMap.Builder<Path,Path> sanitizePaths=ImmutableBiMap.builder();
  sanitizePaths.put(toolchainPaths.getNdkToolRoot(),sanitizedPaths.getNdkToolRoot());
  if (compilerType != NdkCxxPlatformCompiler.Type.GCC) {
    sanitizePaths.put(toolchainPaths.getNdkGccToolRoot(),sanitizedPaths.getNdkGccToolRoot());
  }
  sanitizePaths.put(ndkRoot,Paths.get(ANDROID_NDK_ROOT));
  CxxToolProvider.Type type=compilerType == NdkCxxPlatformCompiler.Type.CLANG ? CxxToolProvider.Type.CLANG : CxxToolProvider.Type.GCC;
  ToolProvider ccTool=new ConstantToolProvider(getCTool(toolchainPaths,compilerType.getCc(),version,executableFinder));
  ToolProvider cxxTool=new ConstantToolProvider(getCTool(toolchainPaths,compilerType.getCxx(),version,executableFinder));
  CompilerProvider cc=new CompilerProvider(ccTool,type);
  PreprocessorProvider cpp=new PreprocessorProvider(ccTool,type);
  CompilerProvider cxx=new CompilerProvider(cxxTool,type);
  PreprocessorProvider cxxpp=new PreprocessorProvider(cxxTool,type);
  CxxPlatform.Builder cxxPlatformBuilder=CxxPlatform.builder();
  cxxPlatformBuilder.setFlavor(flavor).setAs(cc).addAllAsflags(getAsflags(targetConfiguration,toolchainPaths)).setAspp(cpp).setCc(cc).addAllCflags(getCflagsInternal(targetConfiguration,toolchainPaths)).setCpp(cpp).addAllCppflags(getCppflags(targetConfiguration,toolchainPaths)).setCxx(cxx).addAllCxxflags(getCxxflagsInternal(targetConfiguration,toolchainPaths)).setCxxpp(cxxpp).addAllCxxppflags(getCxxppflags(targetConfiguration,toolchainPaths)).setLd(new DefaultLinkerProvider(LinkerProvider.Type.GNU,new ConstantToolProvider(getCcLinkTool(targetConfiguration,toolchainPaths,compilerType.getCxx(),version,executableFinder)))).addAllLdflags(targetConfiguration.getLinkerFlags(compilerType)).addLdflags(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").setStrip(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)).setSymbolNameTool(new PosixNmSymbolNameTool(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder))).setAr(new GnuArchiver(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder))).setRanlib(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)).setDebugPathSanitizer(new MungingDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),sanitizePaths.build())).setSharedLibraryExtension(""String_Node_Str"").setSharedLibraryVersionedExtensionFormat(""String_Node_Str"").setStaticLibraryExtension(""String_Node_Str"").setObjectFileExtension(""String_Node_Str"");
  if (cxxRuntime != CxxRuntime.SYSTEM) {
    cxxPlatformBuilder.putRuntimeLdflags(Linker.LinkableDepType.SHARED,""String_Node_Str"" + cxxRuntime.getSharedName());
    cxxPlatformBuilder.putRuntimeLdflags(Linker.LinkableDepType.STATIC,""String_Node_Str"" + cxxRuntime.getStaticName());
  }
  CxxPlatform cxxPlatform=cxxPlatformBuilder.build();
  return NdkCxxPlatform.builder().setCxxPlatform(cxxPlatform).setCxxRuntime(cxxRuntime).setCxxSharedRuntimePath(toolchainPaths.getCxxRuntimeLibsDirectory().resolve(cxxRuntime.getSoname())).setObjdump(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)).build();
}","@VisibleForTesting static NdkCxxPlatform build(CxxBuckConfig config,ProjectFilesystem filesystem,Flavor flavor,Platform platform,Path ndkRoot,NdkCxxPlatformTargetConfiguration targetConfiguration,CxxRuntime cxxRuntime,ExecutableFinder executableFinder,boolean strictToolchainPaths){
  NdkCxxPlatformCompiler.Type compilerType=targetConfiguration.getCompiler().getType();
  String version=Joiner.on('-').join(ImmutableList.of(readVersion(ndkRoot),targetConfiguration.getToolchain(),targetConfiguration.getTargetAppPlatform(),compilerType,targetConfiguration.getCompiler().getVersion(),targetConfiguration.getCompiler().getGccVersion(),cxxRuntime));
  Host host=Preconditions.checkNotNull(BUILD_PLATFORMS.get(platform));
  NdkCxxToolchainPaths toolchainPaths=new NdkCxxToolchainPaths(filesystem,ndkRoot,targetConfiguration,host.toString(),cxxRuntime,strictToolchainPaths);
  NdkCxxToolchainPaths sanitizedPaths=toolchainPaths.getSanitizedPaths();
  ImmutableBiMap.Builder<Path,Path> sanitizePaths=ImmutableBiMap.builder();
  sanitizePaths.put(toolchainPaths.getNdkToolRoot(),sanitizedPaths.getNdkToolRoot());
  if (compilerType != NdkCxxPlatformCompiler.Type.GCC) {
    sanitizePaths.put(toolchainPaths.getNdkGccToolRoot(),sanitizedPaths.getNdkGccToolRoot());
  }
  sanitizePaths.put(ndkRoot,Paths.get(ANDROID_NDK_ROOT));
  CxxToolProvider.Type type=compilerType == NdkCxxPlatformCompiler.Type.CLANG ? CxxToolProvider.Type.CLANG : CxxToolProvider.Type.GCC;
  ToolProvider ccTool=new ConstantToolProvider(getCTool(toolchainPaths,compilerType.getCc(),version,executableFinder));
  ToolProvider cxxTool=new ConstantToolProvider(getCTool(toolchainPaths,compilerType.getCxx(),version,executableFinder));
  CompilerProvider cc=new CompilerProvider(ccTool,type);
  PreprocessorProvider cpp=new PreprocessorProvider(ccTool,type);
  CompilerProvider cxx=new CompilerProvider(cxxTool,type);
  PreprocessorProvider cxxpp=new PreprocessorProvider(cxxTool,type);
  CxxPlatform.Builder cxxPlatformBuilder=CxxPlatform.builder();
  PrefixMapDebugPathSanitizer debugPathSanitizer=new PrefixMapDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),sanitizePaths.build(),filesystem.getRootPath().toAbsolutePath(),type);
  ImmutableList<String> sanitizerFlags=debugPathSanitizer.getCompilationFlags();
  cxxPlatformBuilder.setFlavor(flavor).setAs(cc).addAllAsflags(getAsflags(targetConfiguration,toolchainPaths,sanitizerFlags)).setAspp(cpp).setCc(cc).addAllCflags(getCflagsInternal(targetConfiguration,toolchainPaths)).setCpp(cpp).addAllCppflags(getCppflags(targetConfiguration,toolchainPaths,sanitizerFlags)).setCxx(cxx).addAllCxxflags(getCxxflagsInternal(targetConfiguration,toolchainPaths,sanitizerFlags)).setCxxpp(cxxpp).addAllCxxppflags(getCxxppflags(targetConfiguration,toolchainPaths,sanitizerFlags)).setLd(new DefaultLinkerProvider(LinkerProvider.Type.GNU,new ConstantToolProvider(getCcLinkTool(targetConfiguration,toolchainPaths,compilerType.getCxx(),version,executableFinder)))).addAllLdflags(targetConfiguration.getLinkerFlags(compilerType)).addLdflags(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").setStrip(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)).setSymbolNameTool(new PosixNmSymbolNameTool(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder))).setAr(new GnuArchiver(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder))).setRanlib(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)).setDebugPathSanitizer(debugPathSanitizer).setSharedLibraryExtension(""String_Node_Str"").setSharedLibraryVersionedExtensionFormat(""String_Node_Str"").setStaticLibraryExtension(""String_Node_Str"").setObjectFileExtension(""String_Node_Str"");
  if (cxxRuntime != CxxRuntime.SYSTEM) {
    cxxPlatformBuilder.putRuntimeLdflags(Linker.LinkableDepType.SHARED,""String_Node_Str"" + cxxRuntime.getSharedName());
    cxxPlatformBuilder.putRuntimeLdflags(Linker.LinkableDepType.STATIC,""String_Node_Str"" + cxxRuntime.getStaticName());
  }
  CxxPlatform cxxPlatform=cxxPlatformBuilder.build();
  return NdkCxxPlatform.builder().setCxxPlatform(cxxPlatform).setCxxRuntime(cxxRuntime).setCxxSharedRuntimePath(toolchainPaths.getCxxRuntimeLibsDirectory().resolve(cxxRuntime.getSoname())).setObjdump(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)).build();
}",0.9372150122763944
53041,"/** 
 * @return the map holding the available {@link NdkCxxPlatform}s.
 */
public static ImmutableMap<TargetCpuType,NdkCxxPlatform> getPlatforms(CxxBuckConfig config,Path ndkRoot,NdkCxxPlatformCompiler compiler,CxxRuntime cxxRuntime,String androidPlatform,Set<String> cpuAbis,Platform platform,ExecutableFinder executableFinder,boolean strictToolchainPaths){
  ImmutableMap.Builder<TargetCpuType,NdkCxxPlatform> ndkCxxPlatformBuilder=ImmutableMap.builder();
  if (cpuAbis.contains(""String_Node_Str"")) {
    NdkCxxPlatformTargetConfiguration targetConfiguration=getTargetConfiguration(TargetCpuType.ARM,compiler,androidPlatform);
    NdkCxxPlatform armeabi=build(config,ImmutableFlavor.of(""String_Node_Str""),platform,ndkRoot,targetConfiguration,cxxRuntime,executableFinder,strictToolchainPaths);
    ndkCxxPlatformBuilder.put(TargetCpuType.ARM,armeabi);
  }
  if (cpuAbis.contains(""String_Node_Str"")) {
    NdkCxxPlatformTargetConfiguration targetConfiguration=getTargetConfiguration(TargetCpuType.ARMV7,compiler,androidPlatform);
    NdkCxxPlatform armeabiv7=build(config,ImmutableFlavor.of(""String_Node_Str""),platform,ndkRoot,targetConfiguration,cxxRuntime,executableFinder,strictToolchainPaths);
    ndkCxxPlatformBuilder.put(TargetCpuType.ARMV7,armeabiv7);
  }
  if (cpuAbis.contains(""String_Node_Str"")) {
    NdkCxxPlatformTargetConfiguration targetConfiguration=getTargetConfiguration(TargetCpuType.X86,compiler,androidPlatform);
    NdkCxxPlatform x86=build(config,ImmutableFlavor.of(""String_Node_Str""),platform,ndkRoot,targetConfiguration,cxxRuntime,executableFinder,strictToolchainPaths);
    ndkCxxPlatformBuilder.put(TargetCpuType.X86,x86);
  }
  if (cpuAbis.contains(""String_Node_Str"")) {
    NdkCxxPlatformTargetConfiguration targetConfiguration=getTargetConfiguration(TargetCpuType.X86_64,compiler,androidPlatform);
    NdkCxxPlatform x86_64=build(config,ImmutableFlavor.of(""String_Node_Str""),platform,ndkRoot,targetConfiguration,cxxRuntime,executableFinder,strictToolchainPaths);
    ndkCxxPlatformBuilder.put(TargetCpuType.X86_64,x86_64);
  }
  return ndkCxxPlatformBuilder.build();
}","/** 
 * @return the map holding the available {@link NdkCxxPlatform}s.
 */
public static ImmutableMap<TargetCpuType,NdkCxxPlatform> getPlatforms(CxxBuckConfig config,ProjectFilesystem filesystem,Path ndkRoot,NdkCxxPlatformCompiler compiler,CxxRuntime cxxRuntime,String androidPlatform,Set<String> cpuAbis,Platform platform,ExecutableFinder executableFinder,boolean strictToolchainPaths){
  ImmutableMap.Builder<TargetCpuType,NdkCxxPlatform> ndkCxxPlatformBuilder=ImmutableMap.builder();
  if (cpuAbis.contains(""String_Node_Str"")) {
    NdkCxxPlatformTargetConfiguration targetConfiguration=getTargetConfiguration(TargetCpuType.ARM,compiler,androidPlatform);
    NdkCxxPlatform armeabi=build(config,filesystem,ImmutableFlavor.of(""String_Node_Str""),platform,ndkRoot,targetConfiguration,cxxRuntime,executableFinder,strictToolchainPaths);
    ndkCxxPlatformBuilder.put(TargetCpuType.ARM,armeabi);
  }
  if (cpuAbis.contains(""String_Node_Str"")) {
    NdkCxxPlatformTargetConfiguration targetConfiguration=getTargetConfiguration(TargetCpuType.ARMV7,compiler,androidPlatform);
    NdkCxxPlatform armeabiv7=build(config,filesystem,ImmutableFlavor.of(""String_Node_Str""),platform,ndkRoot,targetConfiguration,cxxRuntime,executableFinder,strictToolchainPaths);
    ndkCxxPlatformBuilder.put(TargetCpuType.ARMV7,armeabiv7);
  }
  if (cpuAbis.contains(""String_Node_Str"")) {
    NdkCxxPlatformTargetConfiguration targetConfiguration=getTargetConfiguration(TargetCpuType.X86,compiler,androidPlatform);
    NdkCxxPlatform x86=build(config,filesystem,ImmutableFlavor.of(""String_Node_Str""),platform,ndkRoot,targetConfiguration,cxxRuntime,executableFinder,strictToolchainPaths);
    ndkCxxPlatformBuilder.put(TargetCpuType.X86,x86);
  }
  if (cpuAbis.contains(""String_Node_Str"")) {
    NdkCxxPlatformTargetConfiguration targetConfiguration=getTargetConfiguration(TargetCpuType.X86_64,compiler,androidPlatform);
    NdkCxxPlatform x86_64=build(config,filesystem,ImmutableFlavor.of(""String_Node_Str""),platform,ndkRoot,targetConfiguration,cxxRuntime,executableFinder,strictToolchainPaths);
    ndkCxxPlatformBuilder.put(TargetCpuType.X86_64,x86_64);
  }
  return ndkCxxPlatformBuilder.build();
}",0.98290798407867
53042,"/** 
 * Should only be constructed by   {@link CellProvider}.
 */
Cell(final ImmutableSet<Path> knownRoots,final ProjectFilesystem filesystem,final Watchman watchman,final BuckConfig config,final KnownBuildRuleTypesFactory knownBuildRuleTypesFactory,final CellProvider cellProvider,WatchmanDiagnosticCache watchmanDiagnosticCache) throws IOException, InterruptedException {
  this.knownRoots=knownRoots;
  this.filesystem=filesystem;
  this.watchman=watchman;
  this.config=config;
  PythonBuckConfig pythonConfig=new PythonBuckConfig(config,new ExecutableFinder());
  this.pythonInterpreter=pythonConfig.getPythonInterpreter();
  this.knownBuildRuleTypesFactory=knownBuildRuleTypesFactory;
  this.knownBuildRuleTypes=knownBuildRuleTypesFactory.create(config);
  this.cellProvider=cellProvider;
  this.watchmanDiagnosticCache=watchmanDiagnosticCache;
}","/** 
 * Should only be constructed by   {@link CellProvider}.
 */
Cell(final ImmutableSet<Path> knownRoots,final ProjectFilesystem filesystem,final Watchman watchman,final BuckConfig config,final KnownBuildRuleTypesFactory knownBuildRuleTypesFactory,final CellProvider cellProvider,WatchmanDiagnosticCache watchmanDiagnosticCache) throws IOException, InterruptedException {
  this.knownRoots=knownRoots;
  this.filesystem=filesystem;
  this.watchman=watchman;
  this.config=config;
  PythonBuckConfig pythonConfig=new PythonBuckConfig(config,new ExecutableFinder());
  this.pythonInterpreter=pythonConfig.getPythonInterpreter();
  this.knownBuildRuleTypesFactory=knownBuildRuleTypesFactory;
  this.knownBuildRuleTypes=knownBuildRuleTypesFactory.create(config,filesystem);
  this.cellProvider=cellProvider;
  this.watchmanDiagnosticCache=watchmanDiagnosticCache;
}",0.9935860058309038
53043,"@Override public void publish(LogRecord record){
  if (!isLoggable(record)) {
    return;
  }
  int ix=(start + count) % buffer.length;
  buffer[ix]=record;
  if (count < buffer.length) {
    count++;
  }
 else {
    start++;
    start%=buffer.length;
  }
  if (record.getLevel().intValue() >= pushLevel.intValue()) {
    push();
  }
}","@Override public void publish(LogRecord record){
  if (!isLoggable(record)) {
    return;
  }
  List<LogRecord> recordsToLog=null;
synchronized (buffer) {
    int ix=(start + count) % buffer.length;
    buffer[ix]=record;
    if (count < buffer.length) {
      count++;
    }
 else {
      start++;
      start%=buffer.length;
    }
    if (record.getLevel().intValue() >= pushLevel.intValue()) {
      recordsToLog=new ArrayList<>();
      while (count > 0) {
        LogRecord oldRecord=buffer[start];
        recordsToLog.add(oldRecord);
        buffer[start]=null;
        start++;
        start%=buffer.length;
        count--;
      }
    }
  }
}",0.662613981762918
53044,"@Override public void documentChanged(DocumentEvent documentEvent){
  if (BuckSettingsProvider.getInstance().getState().enableAutoDeps) {
    String newLine=documentEvent.getNewFragment().toString();
    if (importPattern.matcher(newLine).matches()) {
      addDependency(getVirtualFileFromImportLine(newLine),Optional.fromNullable(FileDocumentManager.getInstance().getFile(document)));
    }
  }
}","@Override public void documentChanged(DocumentEvent documentEvent){
  if (!BuckSettingsProvider.getInstance().getState().enableAutoDeps) {
    return;
  }
  VirtualFile documentFile=FileDocumentManager.getInstance().getFile(document);
  if (documentFile == null) {
    return;
  }
  CharSequence fragment=documentEvent.getNewFragment();
  Matcher matcher=importPattern.matcher(fragment);
  while (matcher.find()) {
    String classname=matcher.group(1);
    VirtualFile classFile=getVirtualFileFromClassname(classname);
    if (classFile == null) {
      continue;
    }
    addDependency(classFile,documentFile);
  }
}",0.4051130776794494
53045,"@Override public void documentCreated(@NotNull final Document document,final PsiFile psiFile){
  document.addDocumentListener(new DocumentListener(){
    @Override public void beforeDocumentChange(    DocumentEvent documentEvent){
    }
    @Override public void documentChanged(    DocumentEvent documentEvent){
      if (BuckSettingsProvider.getInstance().getState().enableAutoDeps) {
        String newLine=documentEvent.getNewFragment().toString();
        if (importPattern.matcher(newLine).matches()) {
          addDependency(getVirtualFileFromImportLine(newLine),Optional.fromNullable(FileDocumentManager.getInstance().getFile(document)));
        }
      }
    }
  }
);
}","@Override public void documentCreated(@NotNull final Document document,final PsiFile psiFile){
  document.addDocumentListener(new DocumentListener(){
    @Override public void beforeDocumentChange(    DocumentEvent documentEvent){
    }
    @Override public void documentChanged(    DocumentEvent documentEvent){
      if (!BuckSettingsProvider.getInstance().getState().enableAutoDeps) {
        return;
      }
      VirtualFile documentFile=FileDocumentManager.getInstance().getFile(document);
      if (documentFile == null) {
        return;
      }
      CharSequence fragment=documentEvent.getNewFragment();
      Matcher matcher=importPattern.matcher(fragment);
      while (matcher.find()) {
        String classname=matcher.group(1);
        VirtualFile classFile=getVirtualFileFromClassname(classname);
        if (classFile == null) {
          continue;
        }
        addDependency(classFile,documentFile);
      }
    }
  }
);
}",0.5329230769230769
53046,"public void addDependency(final Optional<VirtualFile> importClass,final Optional<VirtualFile> currentClass){
  if (!importClass.isPresent() || !currentClass.isPresent()) {
    return;
  }
  BuckAuditOwner.execute(mProject,new FutureCallback<String>(){
    @Override public void onSuccess(    @Nullable String buckTargetResult){
      try {
        String currentClassPath=currentClass.get().getPath();
        Map<String,List<String>> pathAndTargetData=mObjectMapper.readValue(buckTargetResult,Map.class);
        String importTargetName=""String_Node_Str"";
        String importPath=""String_Node_Str"";
        String currentTargetName=""String_Node_Str"";
        String currentPath=""String_Node_Str"";
        for (        Map.Entry<String,List<String>> targetAndPathEntry : pathAndTargetData.entrySet()) {
          String[] pathAndTarget=targetAndPathEntry.getValue().get(0).replaceFirst(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"");
          if (currentClassPath.contains(targetAndPathEntry.getKey())) {
            currentTargetName=pathAndTarget[1];
            currentPath=pathAndTarget[0];
          }
 else {
            importTargetName=pathAndTarget[1];
            importPath=pathAndTarget[0];
          }
        }
        BuckDeps.addDeps(mProject,importPath,currentPath,importTargetName,currentTargetName);
      }
 catch (      IOException e) {
        LOG.error(e.toString());
      }
    }
    @Override public void onFailure(    Throwable throwable){
    }
  }
,importClass.get().getPath(),currentClass.get().getPath());
}","public void addDependency(final VirtualFile importClass,final VirtualFile currentClass){
  BuckAuditOwner.execute(mProject,new FutureCallback<String>(){
    @Override public void onSuccess(    @Nullable String buckTargetResult){
      try {
        String currentClassPath=currentClass.getPath();
        Map<String,List<String>> pathAndTargetData=mObjectMapper.readValue(buckTargetResult,Map.class);
        String importTargetName=""String_Node_Str"";
        String importPath=""String_Node_Str"";
        String currentTargetName=""String_Node_Str"";
        String currentPath=""String_Node_Str"";
        for (        Map.Entry<String,List<String>> targetAndPathEntry : pathAndTargetData.entrySet()) {
          String[] pathAndTarget=targetAndPathEntry.getValue().get(0).replaceFirst(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"");
          if (currentClassPath.contains(targetAndPathEntry.getKey())) {
            currentTargetName=pathAndTarget[1];
            currentPath=pathAndTarget[0];
          }
 else {
            importTargetName=pathAndTarget[1];
            importPath=pathAndTarget[0];
          }
        }
        if (!Strings.isNullOrEmpty(currentTargetName) && !Strings.isNullOrEmpty(currentPath) && !Strings.isNullOrEmpty(importTargetName)&& !Strings.isNullOrEmpty(importPath)) {
          BuckDeps.addDeps(mProject,importPath,currentPath,importTargetName,currentTargetName);
          BuckDeps.addVisibility(mProject,importPath,currentPath,importTargetName,currentTargetName);
        }
      }
 catch (      IOException e) {
        LOG.error(e.toString());
      }
    }
    @Override public void onFailure(    Throwable throwable){
    }
  }
,importClass.getPath(),currentClass.getPath());
}",0.8758368837492392
53047,"@Override public void onSuccess(@Nullable String buckTargetResult){
  try {
    String currentClassPath=currentClass.get().getPath();
    Map<String,List<String>> pathAndTargetData=mObjectMapper.readValue(buckTargetResult,Map.class);
    String importTargetName=""String_Node_Str"";
    String importPath=""String_Node_Str"";
    String currentTargetName=""String_Node_Str"";
    String currentPath=""String_Node_Str"";
    for (    Map.Entry<String,List<String>> targetAndPathEntry : pathAndTargetData.entrySet()) {
      String[] pathAndTarget=targetAndPathEntry.getValue().get(0).replaceFirst(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"");
      if (currentClassPath.contains(targetAndPathEntry.getKey())) {
        currentTargetName=pathAndTarget[1];
        currentPath=pathAndTarget[0];
      }
 else {
        importTargetName=pathAndTarget[1];
        importPath=pathAndTarget[0];
      }
    }
    BuckDeps.addDeps(mProject,importPath,currentPath,importTargetName,currentTargetName);
  }
 catch (  IOException e) {
    LOG.error(e.toString());
  }
}","@Override public void onSuccess(@Nullable String buckTargetResult){
  try {
    String currentClassPath=currentClass.getPath();
    Map<String,List<String>> pathAndTargetData=mObjectMapper.readValue(buckTargetResult,Map.class);
    String importTargetName=""String_Node_Str"";
    String importPath=""String_Node_Str"";
    String currentTargetName=""String_Node_Str"";
    String currentPath=""String_Node_Str"";
    for (    Map.Entry<String,List<String>> targetAndPathEntry : pathAndTargetData.entrySet()) {
      String[] pathAndTarget=targetAndPathEntry.getValue().get(0).replaceFirst(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"");
      if (currentClassPath.contains(targetAndPathEntry.getKey())) {
        currentTargetName=pathAndTarget[1];
        currentPath=pathAndTarget[0];
      }
 else {
        importTargetName=pathAndTarget[1];
        importPath=pathAndTarget[0];
      }
    }
    if (!Strings.isNullOrEmpty(currentTargetName) && !Strings.isNullOrEmpty(currentPath) && !Strings.isNullOrEmpty(importTargetName)&& !Strings.isNullOrEmpty(importPath)) {
      BuckDeps.addDeps(mProject,importPath,currentPath,importTargetName,currentTargetName);
      BuckDeps.addVisibility(mProject,importPath,currentPath,importTargetName,currentTargetName);
    }
  }
 catch (  IOException e) {
    LOG.error(e.toString());
  }
}",0.8814968814968815
53048,"public static void addDeps(Project project,String importBuckPath,String currentBuckPath,String importTarget,String currentTarget){
  String absoluteCurrentBuckPath=project.getBaseDir().getPath() + ""String_Node_Str"" + currentBuckPath;
  StringBuilder importBuck=new StringBuilder(readBuckFile(absoluteCurrentBuckPath + ""String_Node_Str""));
  String newDep=""String_Node_Str"" + importBuckPath + ""String_Node_Str""+ importTarget+ ""String_Node_Str"";
  int startOfNewTarget=importBuck.indexOf(""String_Node_Str"" + currentTarget + ""String_Node_Str"");
  int startOfDeps=0;
  int endOfDeps;
  Matcher startMatcher=depsStartPattern.matcher(importBuck);
  if (startMatcher.find(startOfNewTarget)) {
    startOfDeps=startMatcher.end();
  }
  endOfDeps=importBuck.indexOf(""String_Node_Str"",startOfDeps);
  if (!importBuck.substring(startOfDeps,endOfDeps).contains(newDep)) {
    importBuck.insert(startOfDeps,""String_Node_Str"" + newDep + ""String_Node_Str"");
    writeBuckFile(absoluteCurrentBuckPath + ""String_Node_Str"",importBuck.toString());
  }
  addVisibility(project,importBuckPath,currentBuckPath,importTarget,currentTarget);
}","public static void addDeps(Project project,String importBuckPath,String currentBuckPath,String importTarget,String currentTarget){
  String buckPath=project.getBaseDir().getPath() + ""String_Node_Str"" + currentBuckPath+ ""String_Node_Str"";
  String contents=readBuckFile(buckPath);
  String dependency=""String_Node_Str"" + importBuckPath + ""String_Node_Str""+ importTarget;
  String newContents=maybeAddDepToTarget(contents,dependency,currentTarget);
  if (!contents.equals(newContents)) {
    writeBuckFile(buckPath,newContents);
  }
}",0.1842424242424242
53049,"public static void addVisibility(Project project,String importBuckPath,String currentBuckPath,String importTarget,String currentTarget){
  String absoluteImportBuckPath=project.getBaseDir().getPath() + ""String_Node_Str"" + importBuckPath;
  StringBuilder currentBuck=new StringBuilder(readBuckFile(absoluteImportBuckPath + ""String_Node_Str""));
  String newVisibility=""String_Node_Str"" + currentBuckPath + ""String_Node_Str""+ currentTarget+ ""String_Node_Str"";
  int startOfNewTarget=currentBuck.indexOf(""String_Node_Str"" + importTarget + ""String_Node_Str"");
  int startOfVisibility=0;
  int endOfVisibility;
  Matcher startMatcher=visibilityStartPattern.matcher(currentBuck);
  if (startMatcher.find(startOfNewTarget)) {
    startOfVisibility=startMatcher.end();
  }
  endOfVisibility=currentBuck.indexOf(""String_Node_Str"",startOfVisibility);
  if (!currentBuck.substring(startOfVisibility,endOfVisibility).contains(newVisibility) && !currentBuck.substring(startOfVisibility,endOfVisibility).contains(""String_Node_Str"")) {
    currentBuck.insert(startOfVisibility,""String_Node_Str"" + newVisibility + ""String_Node_Str"");
    writeBuckFile(absoluteImportBuckPath + ""String_Node_Str"",currentBuck.toString());
  }
}","public static void addVisibility(Project project,String importBuckPath,String currentBuckPath,String importTarget,String currentTarget){
  String buckPath=project.getBaseDir().getPath() + ""String_Node_Str"" + importBuckPath+ ""String_Node_Str"";
  String contents=readBuckFile(buckPath);
  String visibility=""String_Node_Str"" + currentBuckPath + ""String_Node_Str""+ currentTarget;
  String newContents=maybeAddVisibilityToTarget(contents,visibility,importTarget);
  if (!contents.equals(newContents)) {
    writeBuckFile(buckPath,newContents);
  }
}",0.3023388476896748
53050,"@Override public Iterable<String> getIgnoreUndefinedSymbolsFlags(){
  return Linkers.iXlinker(""String_Node_Str"");
}","@Override public Iterable<String> getIgnoreUndefinedSymbolsFlags(){
  return Linkers.iXlinker(""String_Node_Str"",""String_Node_Str"");
}",0.9274193548387096
53051,"@Override public <A extends Arg>BuildRule createBuildRule(TargetGraph targetGraph,BuildRuleParams params,BuildRuleResolver resolver,A args) throws NoSuchBuildTargetException {
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  CxxPlatform cxxPlatform=cxxPlatforms.getValue(params.getBuildTarget()).or(defaultCxxPlatform);
  Linker.LinkableDepType depType=getLinkStyle(params.getBuildTarget(),args);
  BuildTarget binaryTarget=params.getBuildTarget().withFlavors(cxxPlatform.getFlavor(),ImmutableFlavor.of(""String_Node_Str""));
  ImmutableList.Builder<String> linkFlagsBuilder=ImmutableList.builder();
  ImmutableList.Builder<com.facebook.buck.rules.args.Arg> linkArgsBuilder=ImmutableList.builder();
  CommandTool.Builder executableBuilder=new CommandTool.Builder();
  executableBuilder.addArg(new SourcePathArg(pathResolver,new BuildTargetSourcePath(binaryTarget)));
  if (depType == Linker.LinkableDepType.SHARED) {
    SymlinkTree sharedLibraries=resolver.addToIndex(CxxDescriptionEnhancer.createSharedLibrarySymlinkTree(params,pathResolver,cxxPlatform,params.getDeps(),Predicates.instanceOf(NativeLinkable.class)));
    Path absBinaryDir=params.getBuildTarget().getCellPath().resolve(HaskellLinkRule.getOutputDir(binaryTarget,params.getProjectFilesystem()));
    linkFlagsBuilder.addAll(MoreIterables.zipAndConcat(Iterables.cycle(""String_Node_Str""),Linkers.iXlinker(""String_Node_Str"",String.format(""String_Node_Str"",cxxPlatform.getLd().resolve(resolver).origin(),absBinaryDir.relativize(sharedLibraries.getRoot()).toString()))));
    executableBuilder.addDep(sharedLibraries);
    executableBuilder.addInputs(sharedLibraries.getLinks().values());
  }
  HaskellCompileRule compileRule=resolver.addToIndex(HaskellDescriptionUtils.requireCompileRule(params,resolver,pathResolver,cxxPlatform,haskellConfig,depType,args.main,Optional.<HaskellPackageInfo>absent(),args.compilerFlags.or(ImmutableList.<String>of()),HaskellSources.from(params.getBuildTarget(),resolver,pathResolver,cxxPlatform,""String_Node_Str"",args.srcs.or(SourceList.EMPTY))));
  linkArgsBuilder.addAll(SourcePathArg.from(pathResolver,compileRule.getObjects()));
  ImmutableList<String> linkFlags=linkFlagsBuilder.build();
  ImmutableList<com.facebook.buck.rules.args.Arg> linkArgs=linkArgsBuilder.build();
  final CommandTool executable=executableBuilder.build();
  final HaskellLinkRule linkRule=HaskellDescriptionUtils.createLinkRule(binaryTarget,params,resolver,pathResolver,cxxPlatform,haskellConfig,Linker.LinkType.EXECUTABLE,linkFlags,linkArgs,FluentIterable.from(params.getDeps()).filter(NativeLinkable.class),depType);
  return new BinaryWrapperRule(params,pathResolver){
    @Override public Tool getExecutableCommand(){
      return executable;
    }
    @Override public Path getPathToOutput(){
      return linkRule.getPathToOutput();
    }
  }
;
}","@Override public <A extends Arg>BuildRule createBuildRule(TargetGraph targetGraph,BuildRuleParams params,BuildRuleResolver resolver,A args) throws NoSuchBuildTargetException {
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  CxxPlatform cxxPlatform=cxxPlatforms.getValue(params.getBuildTarget()).or(defaultCxxPlatform);
  Linker.LinkableDepType depType=getLinkStyle(params.getBuildTarget(),args);
  BuildTarget binaryTarget=params.getBuildTarget().withFlavors(cxxPlatform.getFlavor(),ImmutableFlavor.of(""String_Node_Str""));
  ImmutableList.Builder<String> linkFlagsBuilder=ImmutableList.builder();
  ImmutableList.Builder<com.facebook.buck.rules.args.Arg> linkArgsBuilder=ImmutableList.builder();
  CommandTool.Builder executableBuilder=new CommandTool.Builder();
  executableBuilder.addArg(new SourcePathArg(pathResolver,new BuildTargetSourcePath(binaryTarget)));
  if (depType == Linker.LinkableDepType.SHARED) {
    SymlinkTree sharedLibraries=resolver.addToIndex(CxxDescriptionEnhancer.createSharedLibrarySymlinkTree(params,pathResolver,cxxPlatform,params.getDeps(),Predicates.instanceOf(NativeLinkable.class)));
    Path absBinaryDir=params.getBuildTarget().getCellPath().resolve(HaskellLinkRule.getOutputDir(binaryTarget,params.getProjectFilesystem()));
    linkFlagsBuilder.addAll(MoreIterables.zipAndConcat(Iterables.cycle(""String_Node_Str""),Linkers.iXlinker(""String_Node_Str"",String.format(""String_Node_Str"",cxxPlatform.getLd().resolve(resolver).origin(),absBinaryDir.relativize(sharedLibraries.getRoot()).toString()))));
    executableBuilder.addDep(sharedLibraries);
    executableBuilder.addInputs(sharedLibraries.getLinks().values());
  }
  HaskellCompileRule compileRule=resolver.addToIndex(HaskellDescriptionUtils.requireCompileRule(params,resolver,pathResolver,cxxPlatform,haskellConfig,depType,args.main,Optional.<HaskellPackageInfo>absent(),args.compilerFlags.or(ImmutableList.<String>of()),HaskellSources.from(params.getBuildTarget(),resolver,pathResolver,cxxPlatform,""String_Node_Str"",args.srcs.or(SourceList.EMPTY))));
  linkArgsBuilder.addAll(SourcePathArg.from(pathResolver,compileRule.getObjects()));
  ImmutableList<String> linkFlags=linkFlagsBuilder.build();
  ImmutableList<com.facebook.buck.rules.args.Arg> linkArgs=linkArgsBuilder.build();
  final CommandTool executable=executableBuilder.build();
  final HaskellLinkRule linkRule=HaskellDescriptionUtils.createLinkRule(binaryTarget,params,resolver,pathResolver,cxxPlatform,haskellConfig,Linker.LinkType.EXECUTABLE,linkFlags,linkArgs,FluentIterable.from(params.getDeps()).filter(NativeLinkable.class),depType);
  return new BinaryWrapperRule(params.appendExtraDeps(linkRule),pathResolver){
    @Override public Tool getExecutableCommand(){
      return executable;
    }
    @Override public Path getPathToOutput(){
      return linkRule.getPathToOutput();
    }
  }
;
}",0.9954497724886244
53052,"public BuildRuleParams appendExtraDeps(Iterable<? extends BuildRule> additional){
  return appendExtraDeps(Suppliers.ofInstance(additional));
}","public BuildRuleParams appendExtraDeps(BuildRule... additional){
  return appendExtraDeps(Suppliers.ofInstance(ImmutableList.copyOf(additional)));
}",0.845360824742268
53053,"private Archive requireStaticLibrary(BuildTarget baseTarget,BuildRuleParams baseParams,BuildRuleResolver resolver,SourcePathResolver pathResolver,CxxPlatform cxxPlatform,Arg args,Linker.LinkableDepType depType) throws NoSuchBuildTargetException {
  Preconditions.checkArgument(Sets.intersection(baseTarget.getFlavors(),Sets.union(Type.FLAVOR_VALUES,cxxPlatforms.getFlavors())).isEmpty());
  BuildTarget target=baseTarget.withFlavors(Type.STATIC.getFlavor(),cxxPlatform.getFlavor());
  Optional<Archive> archive=resolver.getRuleOptionalWithType(target,Archive.class);
  if (archive.isPresent()) {
    return archive.get();
  }
  return resolver.addToIndex(createStaticLibrary(target,baseParams,resolver,pathResolver,cxxPlatform,args,depType));
}","private Archive requireStaticLibrary(BuildTarget baseTarget,BuildRuleParams baseParams,BuildRuleResolver resolver,SourcePathResolver pathResolver,CxxPlatform cxxPlatform,Arg args,Linker.LinkableDepType depType) throws NoSuchBuildTargetException {
  Preconditions.checkArgument(Sets.intersection(baseTarget.getFlavors(),Sets.union(Type.FLAVOR_VALUES,cxxPlatforms.getFlavors())).isEmpty());
  BuildTarget target=baseTarget.withFlavors(depType == Linker.LinkableDepType.STATIC ? Type.STATIC.getFlavor() : Type.STATIC_PIC.getFlavor(),cxxPlatform.getFlavor());
  Optional<Archive> archive=resolver.getRuleOptionalWithType(target,Archive.class);
  if (archive.isPresent()) {
    return archive.get();
  }
  return resolver.addToIndex(createStaticLibrary(target,baseParams,resolver,pathResolver,cxxPlatform,args,depType));
}",0.9417040358744396
53054,"private HaskellLinkRule requireSharedLibrary(BuildTarget baseTarget,BuildRuleParams baseParams,BuildRuleResolver resolver,SourcePathResolver pathResolver,CxxPlatform cxxPlatform,Arg args) throws NoSuchBuildTargetException {
  Preconditions.checkArgument(Sets.intersection(baseTarget.getFlavors(),Sets.union(Type.FLAVOR_VALUES,cxxPlatforms.getFlavors())).isEmpty());
  BuildTarget target=baseTarget.withFlavors(Type.STATIC.getFlavor(),cxxPlatform.getFlavor());
  Optional<HaskellLinkRule> linkRule=resolver.getRuleOptionalWithType(target,HaskellLinkRule.class);
  if (linkRule.isPresent()) {
    return linkRule.get();
  }
  return resolver.addToIndex(createSharedLibrary(target,baseParams,resolver,pathResolver,cxxPlatform,args));
}","private HaskellLinkRule requireSharedLibrary(BuildTarget baseTarget,BuildRuleParams baseParams,BuildRuleResolver resolver,SourcePathResolver pathResolver,CxxPlatform cxxPlatform,Arg args) throws NoSuchBuildTargetException {
  Preconditions.checkArgument(Sets.intersection(baseTarget.getFlavors(),Sets.union(Type.FLAVOR_VALUES,cxxPlatforms.getFlavors())).isEmpty());
  BuildTarget target=baseTarget.withFlavors(Type.SHARED.getFlavor(),cxxPlatform.getFlavor());
  Optional<HaskellLinkRule> linkRule=resolver.getRuleOptionalWithType(target,HaskellLinkRule.class);
  if (linkRule.isPresent()) {
    return linkRule.get();
  }
  return resolver.addToIndex(createSharedLibrary(target,baseParams,resolver,pathResolver,cxxPlatform,args));
}",0.994535519125683
53055,"private Archive createStaticLibrary(BuildTarget target,BuildRuleParams baseParams,BuildRuleResolver resolver,SourcePathResolver pathResolver,CxxPlatform cxxPlatform,Arg args,Linker.LinkableDepType depType) throws NoSuchBuildTargetException {
  HaskellCompileRule compileRule=requireCompileRule(baseParams,resolver,pathResolver,cxxPlatform,args,depType);
  return Archive.from(target,baseParams,pathResolver,cxxPlatform,cxxBuckConfig.getArchiveContents(),CxxDescriptionEnhancer.getStaticLibraryPath(baseParams.getProjectFilesystem(),target,cxxPlatform.getFlavor(),CxxSourceRuleFactory.PicType.PDC),compileRule.getObjects());
}","private Archive createStaticLibrary(BuildTarget target,BuildRuleParams baseParams,BuildRuleResolver resolver,SourcePathResolver pathResolver,CxxPlatform cxxPlatform,Arg args,Linker.LinkableDepType depType) throws NoSuchBuildTargetException {
  HaskellCompileRule compileRule=requireCompileRule(baseParams,resolver,pathResolver,cxxPlatform,args,depType);
  return Archive.from(target,baseParams,pathResolver,cxxPlatform,cxxBuckConfig.getArchiveContents(),CxxDescriptionEnhancer.getStaticLibraryPath(baseParams.getProjectFilesystem(),target,cxxPlatform.getFlavor(),depType == Linker.LinkableDepType.STATIC ? CxxSourceRuleFactory.PicType.PDC : CxxSourceRuleFactory.PicType.PIC),compileRule.getObjects());
}",0.9367469879518072
53056,"@VisibleForTesting static boolean isTestRunRequiredForTest(TestRule test,BuildEngine cachingBuildEngine,ExecutionContext executionContext,TestRuleKeyFileHelper testRuleKeyFileHelper,boolean isResultsCacheEnabled,boolean isRunningWithTestSelectors,boolean hasEnvironmentOverrides) throws IOException, ExecutionException, InterruptedException {
  boolean isTestRunRequired;
  BuildResult result;
  if (executionContext.isDebugEnabled()) {
    isTestRunRequired=true;
  }
 else   if (isRunningWithTestSelectors) {
    isTestRunRequired=true;
  }
 else   if (hasEnvironmentOverrides) {
    isTestRunRequired=true;
  }
 else   if (((result=cachingBuildEngine.getBuildRuleResult(test.getBuildTarget())) != null) && result.getSuccess() == BuildRuleSuccessType.MATCHING_RULE_KEY && isResultsCacheEnabled && test.hasTestResultFiles() && testRuleKeyFileHelper.isRuleKeyInDir(test)) {
    isTestRunRequired=false;
  }
 else {
    isTestRunRequired=true;
  }
  return isTestRunRequired;
}","@VisibleForTesting static boolean isTestRunRequiredForTest(TestRule test,BuildEngine cachingBuildEngine,ExecutionContext executionContext,TestRuleKeyFileHelper testRuleKeyFileHelper,boolean isResultsCacheEnabled,boolean isRunningWithTestSelectors,boolean hasEnvironmentOverrides,boolean isDryRun) throws IOException, ExecutionException, InterruptedException {
  boolean isTestRunRequired;
  BuildResult result;
  if (executionContext.isDebugEnabled()) {
    isTestRunRequired=true;
  }
 else   if (isRunningWithTestSelectors) {
    isTestRunRequired=true;
  }
 else   if (hasEnvironmentOverrides) {
    isTestRunRequired=true;
  }
 else   if (isDryRun) {
    isTestRunRequired=true;
  }
 else   if (((result=cachingBuildEngine.getBuildRuleResult(test.getBuildTarget())) != null) && result.getSuccess() == BuildRuleSuccessType.MATCHING_RULE_KEY && isResultsCacheEnabled && test.hasTestResultFiles() && testRuleKeyFileHelper.isRuleKeyInDir(test)) {
    isTestRunRequired=false;
  }
 else {
    isTestRunRequired=true;
  }
  return isTestRunRequired;
}",0.9639506172839506
53057,"@SuppressWarnings(""String_Node_Str"") public static int runTests(final CommandRunnerParams params,Iterable<TestRule> tests,ExecutionContext executionContext,final TestRunningOptions options,ListeningExecutorService service,BuildEngine buildEngine,final StepRunner stepRunner) throws IOException, ExecutionException, InterruptedException {
  ImmutableSet<JavaLibrary> rulesUnderTest;
  if (options.isCodeCoverageEnabled()) {
    rulesUnderTest=getRulesUnderTest(tests);
    if (!rulesUnderTest.isEmpty()) {
      try {
        JavaLibrary library=rulesUnderTest.iterator().next();
        stepRunner.runStepForBuildTarget(new MakeCleanDirectoryStep(library.getProjectFilesystem(),JacocoConstants.getJacocoOutputDir(library.getProjectFilesystem())),Optional.<BuildTarget>absent());
      }
 catch (      StepFailedException e) {
        params.getBuckEventBus().post(ConsoleEvent.severe(Throwables.getRootCause(e).getLocalizedMessage()));
        return 1;
      }
    }
  }
 else {
    rulesUnderTest=ImmutableSet.of();
  }
  final ImmutableSet<String> testTargets=FluentIterable.from(tests).transform(HasBuildTarget.TO_TARGET).transform(Functions.toStringFunction()).toSet();
  final int totalNumberOfTests=Iterables.size(tests);
  params.getBuckEventBus().post(TestRunEvent.started(options.isRunAllTests(),options.getTestSelectorList(),options.shouldExplainTestSelectorList(),testTargets));
  List<ListenableFuture<TestResults>> results=Lists.newArrayList();
  TestRuleKeyFileHelper testRuleKeyFileHelper=new TestRuleKeyFileHelper(buildEngine);
  final AtomicInteger lastReportedTestSequenceNumber=new AtomicInteger();
  final List<TestRun> separateTestRuns=Lists.newArrayList();
  List<TestRun> parallelTestRuns=Lists.newArrayList();
  for (  final TestRule test : tests) {
    boolean isTestRunRequired;
    isTestRunRequired=isTestRunRequiredForTest(test,buildEngine,executionContext,testRuleKeyFileHelper,options.isResultsCacheEnabled(),!options.getTestSelectorList().isEmpty(),!options.getEnvironmentOverrides().isEmpty());
    final Map<String,UUID> testUUIDMap=new HashMap<>();
    final AtomicReference<TestStatusMessageEvent.Started> currentTestStatusMessageEvent=new AtomicReference<>();
    TestRule.TestReportingCallback testReportingCallback=new TestRule.TestReportingCallback(){
      @Override public void testsDidBegin(){
        LOG.debug(""String_Node_Str"",test.getBuildTarget());
      }
      @Override public void statusDidBegin(      TestStatusMessage didBeginMessage){
        LOG.debug(""String_Node_Str"",didBeginMessage);
        TestStatusMessageEvent.Started startedEvent=TestStatusMessageEvent.started(didBeginMessage);
        TestStatusMessageEvent.Started previousEvent=currentTestStatusMessageEvent.getAndSet(startedEvent);
        Preconditions.checkState(previousEvent == null,""String_Node_Str"",previousEvent);
        params.getBuckEventBus().post(startedEvent);
      }
      @Override public void statusDidEnd(      TestStatusMessage didEndMessage){
        LOG.debug(""String_Node_Str"",didEndMessage);
        TestStatusMessageEvent.Started previousEvent=currentTestStatusMessageEvent.getAndSet(null);
        Preconditions.checkState(previousEvent != null,""String_Node_Str"",previousEvent);
        params.getBuckEventBus().post(TestStatusMessageEvent.finished(previousEvent,didEndMessage));
      }
      @Override public void testDidBegin(      String testCaseName,      String testName){
        LOG.debug(""String_Node_Str"",test.getBuildTarget(),testCaseName,testName);
        UUID testUUID=UUID.randomUUID();
        testUUIDMap.put(testCaseName + ""String_Node_Str"" + testName,testUUID);
        params.getBuckEventBus().post(TestSummaryEvent.started(testUUID,testCaseName,testName));
      }
      @Override public void testDidEnd(      TestResultSummary testResultSummary){
        LOG.debug(""String_Node_Str"",test.getBuildTarget(),testResultSummary);
        UUID testUUID=testUUIDMap.get(testResultSummary.getTestCaseName() + ""String_Node_Str"" + testResultSummary.getTestName());
        Preconditions.checkNotNull(testUUID);
        params.getBuckEventBus().post(TestSummaryEvent.finished(testUUID,testResultSummary));
      }
      @Override public void testsDidEnd(      List<TestCaseSummary> testCaseSummaries){
        LOG.debug(""String_Node_Str"",test.getBuildTarget(),testCaseSummaries);
      }
    }
;
    List<Step> steps;
    if (isTestRunRequired) {
      params.getBuckEventBus().post(IndividualTestEvent.started(testTargets));
      ImmutableList.Builder<Step> stepsBuilder=ImmutableList.builder();
      Preconditions.checkState(buildEngine.isRuleBuilt(test.getBuildTarget()));
      List<Step> testSteps=test.runTests(executionContext,options,testReportingCallback);
      if (!testSteps.isEmpty()) {
        stepsBuilder.addAll(testSteps);
        stepsBuilder.add(testRuleKeyFileHelper.createRuleKeyInDirStep(test));
      }
      steps=stepsBuilder.build();
    }
 else {
      steps=ImmutableList.of();
    }
    TestRun testRun=TestRun.of(test,steps,getCachingStatusTransformingCallable(isTestRunRequired,test.interpretTestResults(executionContext,!options.getTestSelectorList().isEmpty(),options.isDryRun())),testReportingCallback);
    if (test.runTestSeparately()) {
      LOG.debug(""String_Node_Str"",test);
      separateTestRuns.add(testRun);
    }
 else {
      LOG.debug(""String_Node_Str"",test);
      parallelTestRuns.add(testRun);
    }
  }
  final StepRunner.StepRunningCallback testStepRunningCallback=new StepRunner.StepRunningCallback(){
    @Override public void stepsWillRun(    Optional<BuildTarget> buildTarget){
      Preconditions.checkState(buildTarget.isPresent());
      LOG.debug(""String_Node_Str"",buildTarget);
      params.getBuckEventBus().post(TestRuleEvent.started(buildTarget.get()));
    }
    @Override public void stepsDidRun(    Optional<BuildTarget> buildTarget){
      Preconditions.checkState(buildTarget.isPresent());
      LOG.debug(""String_Node_Str"",buildTarget);
      params.getBuckEventBus().post(TestRuleEvent.finished(buildTarget.get()));
    }
  }
;
  for (  TestRun testRun : parallelTestRuns) {
    ListenableFuture<TestResults> testResults=stepRunner.runStepsAndYieldResult(testRun.getSteps(),testRun.getTestResultsCallable(),Optional.of(testRun.getTest().getBuildTarget()),service,testStepRunningCallback);
    results.add(transformTestResults(params,testResults,testRun.getTest(),testRun.getTestReportingCallback(),testTargets,lastReportedTestSequenceNumber,totalNumberOfTests));
  }
  ListenableFuture<List<TestResults>> parallelTestStepsFuture=Futures.allAsList(results);
  final List<TestResults> completedResults=Lists.newArrayList();
  final ListeningExecutorService directExecutorService=MoreExecutors.newDirectExecutorService();
  ListenableFuture<Void> uberFuture=stepRunner.addCallback(parallelTestStepsFuture,new FutureCallback<List<TestResults>>(){
    @Override public void onSuccess(    List<TestResults> parallelTestResults){
      LOG.debug(""String_Node_Str"");
      completedResults.addAll(parallelTestResults);
      List<ListenableFuture<TestResults>> separateResultsList=Lists.newArrayList();
      for (      TestRun testRun : separateTestRuns) {
        separateResultsList.add(transformTestResults(params,stepRunner.runStepsAndYieldResult(testRun.getSteps(),testRun.getTestResultsCallable(),Optional.of(testRun.getTest().getBuildTarget()),directExecutorService,testStepRunningCallback),testRun.getTest(),testRun.getTestReportingCallback(),testTargets,lastReportedTestSequenceNumber,totalNumberOfTests));
      }
      ListenableFuture<List<TestResults>> serialResults=Futures.allAsList(separateResultsList);
      try {
        completedResults.addAll(serialResults.get());
      }
 catch (      ExecutionException e) {
        LOG.error(e,""String_Node_Str"");
        throw new HumanReadableException(e,""String_Node_Str"");
      }
catch (      InterruptedException e) {
        LOG.error(e,""String_Node_Str"");
        try {
          serialResults.cancel(true);
        }
 catch (        CancellationException ignored) {
        }
        Thread.currentThread().interrupt();
        throw new HumanReadableException(e,""String_Node_Str"");
      }
      LOG.debug(""String_Node_Str"");
    }
    @Override public void onFailure(    Throwable e){
      LOG.error(e,""String_Node_Str"");
      throw new HumanReadableException(e,""String_Node_Str"");
    }
  }
,directExecutorService);
  try {
    uberFuture.get();
  }
 catch (  ExecutionException e) {
    e.printStackTrace(params.getConsole().getStdErr());
    return 1;
  }
catch (  InterruptedException e) {
    try {
      uberFuture.cancel(true);
    }
 catch (    CancellationException ignored) {
    }
    Thread.currentThread().interrupt();
    throw e;
  }
  params.getBuckEventBus().post(TestRunEvent.finished(testTargets,completedResults));
  Optional<String> path=options.getPathToXmlTestOutput();
  if (path.isPresent()) {
    try (Writer writer=Files.newWriter(new File(path.get()),Charsets.UTF_8)){
      writeXmlOutput(completedResults,writer);
    }
   }
  if (options.isCodeCoverageEnabled() && !rulesUnderTest.isEmpty()) {
    try {
      Optional<DefaultJavaPackageFinder> defaultJavaPackageFinderOptional=Optional.fromNullable(params.getBuckConfig().createDefaultJavaPackageFinder());
      stepRunner.runStepForBuildTarget(getReportCommand(rulesUnderTest,defaultJavaPackageFinderOptional,new JavaBuckConfig(params.getBuckConfig()).getDefaultJavaOptions().getJavaRuntimeLauncher(),params.getCell().getFilesystem(),JacocoConstants.getJacocoOutputDir(params.getCell().getFilesystem()),options.getCoverageReportFormat(),options.getCoverageReportTitle(),options.getCoverageIncludes(),options.getCoverageExcludes()),Optional.<BuildTarget>absent());
    }
 catch (    StepFailedException e) {
      params.getBuckEventBus().post(ConsoleEvent.severe(Throwables.getRootCause(e).getLocalizedMessage()));
      return 1;
    }
  }
  boolean failures=Iterables.any(completedResults,new Predicate<TestResults>(){
    @Override public boolean apply(    TestResults results){
      LOG.debug(""String_Node_Str"",results);
      return !results.isSuccess();
    }
  }
);
  return failures ? TEST_FAILURES_EXIT_CODE : 0;
}","@SuppressWarnings(""String_Node_Str"") public static int runTests(final CommandRunnerParams params,Iterable<TestRule> tests,ExecutionContext executionContext,final TestRunningOptions options,ListeningExecutorService service,BuildEngine buildEngine,final StepRunner stepRunner) throws IOException, ExecutionException, InterruptedException {
  ImmutableSet<JavaLibrary> rulesUnderTest;
  if (options.isCodeCoverageEnabled()) {
    rulesUnderTest=getRulesUnderTest(tests);
    if (!rulesUnderTest.isEmpty()) {
      try {
        JavaLibrary library=rulesUnderTest.iterator().next();
        stepRunner.runStepForBuildTarget(new MakeCleanDirectoryStep(library.getProjectFilesystem(),JacocoConstants.getJacocoOutputDir(library.getProjectFilesystem())),Optional.<BuildTarget>absent());
      }
 catch (      StepFailedException e) {
        params.getBuckEventBus().post(ConsoleEvent.severe(Throwables.getRootCause(e).getLocalizedMessage()));
        return 1;
      }
    }
  }
 else {
    rulesUnderTest=ImmutableSet.of();
  }
  final ImmutableSet<String> testTargets=FluentIterable.from(tests).transform(HasBuildTarget.TO_TARGET).transform(Functions.toStringFunction()).toSet();
  final int totalNumberOfTests=Iterables.size(tests);
  params.getBuckEventBus().post(TestRunEvent.started(options.isRunAllTests(),options.getTestSelectorList(),options.shouldExplainTestSelectorList(),testTargets));
  List<ListenableFuture<TestResults>> results=Lists.newArrayList();
  TestRuleKeyFileHelper testRuleKeyFileHelper=new TestRuleKeyFileHelper(buildEngine);
  final AtomicInteger lastReportedTestSequenceNumber=new AtomicInteger();
  final List<TestRun> separateTestRuns=Lists.newArrayList();
  List<TestRun> parallelTestRuns=Lists.newArrayList();
  for (  final TestRule test : tests) {
    boolean isTestRunRequired;
    isTestRunRequired=isTestRunRequiredForTest(test,buildEngine,executionContext,testRuleKeyFileHelper,options.isResultsCacheEnabled(),!options.getTestSelectorList().isEmpty(),!options.getEnvironmentOverrides().isEmpty(),options.isDryRun());
    final Map<String,UUID> testUUIDMap=new HashMap<>();
    final AtomicReference<TestStatusMessageEvent.Started> currentTestStatusMessageEvent=new AtomicReference<>();
    TestRule.TestReportingCallback testReportingCallback=new TestRule.TestReportingCallback(){
      @Override public void testsDidBegin(){
        LOG.debug(""String_Node_Str"",test.getBuildTarget());
      }
      @Override public void statusDidBegin(      TestStatusMessage didBeginMessage){
        LOG.debug(""String_Node_Str"",didBeginMessage);
        TestStatusMessageEvent.Started startedEvent=TestStatusMessageEvent.started(didBeginMessage);
        TestStatusMessageEvent.Started previousEvent=currentTestStatusMessageEvent.getAndSet(startedEvent);
        Preconditions.checkState(previousEvent == null,""String_Node_Str"",previousEvent);
        params.getBuckEventBus().post(startedEvent);
      }
      @Override public void statusDidEnd(      TestStatusMessage didEndMessage){
        LOG.debug(""String_Node_Str"",didEndMessage);
        TestStatusMessageEvent.Started previousEvent=currentTestStatusMessageEvent.getAndSet(null);
        Preconditions.checkState(previousEvent != null,""String_Node_Str"",previousEvent);
        params.getBuckEventBus().post(TestStatusMessageEvent.finished(previousEvent,didEndMessage));
      }
      @Override public void testDidBegin(      String testCaseName,      String testName){
        LOG.debug(""String_Node_Str"",test.getBuildTarget(),testCaseName,testName);
        UUID testUUID=UUID.randomUUID();
        testUUIDMap.put(testCaseName + ""String_Node_Str"" + testName,testUUID);
        params.getBuckEventBus().post(TestSummaryEvent.started(testUUID,testCaseName,testName));
      }
      @Override public void testDidEnd(      TestResultSummary testResultSummary){
        LOG.debug(""String_Node_Str"",test.getBuildTarget(),testResultSummary);
        UUID testUUID=testUUIDMap.get(testResultSummary.getTestCaseName() + ""String_Node_Str"" + testResultSummary.getTestName());
        Preconditions.checkNotNull(testUUID);
        params.getBuckEventBus().post(TestSummaryEvent.finished(testUUID,testResultSummary));
      }
      @Override public void testsDidEnd(      List<TestCaseSummary> testCaseSummaries){
        LOG.debug(""String_Node_Str"",test.getBuildTarget(),testCaseSummaries);
      }
    }
;
    List<Step> steps;
    if (isTestRunRequired) {
      params.getBuckEventBus().post(IndividualTestEvent.started(testTargets));
      ImmutableList.Builder<Step> stepsBuilder=ImmutableList.builder();
      Preconditions.checkState(buildEngine.isRuleBuilt(test.getBuildTarget()));
      List<Step> testSteps=test.runTests(executionContext,options,testReportingCallback);
      if (!testSteps.isEmpty()) {
        stepsBuilder.addAll(testSteps);
        stepsBuilder.add(testRuleKeyFileHelper.createRuleKeyInDirStep(test));
      }
      steps=stepsBuilder.build();
    }
 else {
      steps=ImmutableList.of();
    }
    TestRun testRun=TestRun.of(test,steps,getCachingStatusTransformingCallable(isTestRunRequired,test.interpretTestResults(executionContext,!options.getTestSelectorList().isEmpty(),options.isDryRun())),testReportingCallback);
    if (test.runTestSeparately()) {
      LOG.debug(""String_Node_Str"",test);
      separateTestRuns.add(testRun);
    }
 else {
      LOG.debug(""String_Node_Str"",test);
      parallelTestRuns.add(testRun);
    }
  }
  final StepRunner.StepRunningCallback testStepRunningCallback=new StepRunner.StepRunningCallback(){
    @Override public void stepsWillRun(    Optional<BuildTarget> buildTarget){
      Preconditions.checkState(buildTarget.isPresent());
      LOG.debug(""String_Node_Str"",buildTarget);
      params.getBuckEventBus().post(TestRuleEvent.started(buildTarget.get()));
    }
    @Override public void stepsDidRun(    Optional<BuildTarget> buildTarget){
      Preconditions.checkState(buildTarget.isPresent());
      LOG.debug(""String_Node_Str"",buildTarget);
      params.getBuckEventBus().post(TestRuleEvent.finished(buildTarget.get()));
    }
  }
;
  for (  TestRun testRun : parallelTestRuns) {
    ListenableFuture<TestResults> testResults=stepRunner.runStepsAndYieldResult(testRun.getSteps(),testRun.getTestResultsCallable(),Optional.of(testRun.getTest().getBuildTarget()),service,testStepRunningCallback);
    results.add(transformTestResults(params,testResults,testRun.getTest(),testRun.getTestReportingCallback(),testTargets,lastReportedTestSequenceNumber,totalNumberOfTests));
  }
  ListenableFuture<List<TestResults>> parallelTestStepsFuture=Futures.allAsList(results);
  final List<TestResults> completedResults=Lists.newArrayList();
  final ListeningExecutorService directExecutorService=MoreExecutors.newDirectExecutorService();
  ListenableFuture<Void> uberFuture=stepRunner.addCallback(parallelTestStepsFuture,new FutureCallback<List<TestResults>>(){
    @Override public void onSuccess(    List<TestResults> parallelTestResults){
      LOG.debug(""String_Node_Str"");
      completedResults.addAll(parallelTestResults);
      List<ListenableFuture<TestResults>> separateResultsList=Lists.newArrayList();
      for (      TestRun testRun : separateTestRuns) {
        separateResultsList.add(transformTestResults(params,stepRunner.runStepsAndYieldResult(testRun.getSteps(),testRun.getTestResultsCallable(),Optional.of(testRun.getTest().getBuildTarget()),directExecutorService,testStepRunningCallback),testRun.getTest(),testRun.getTestReportingCallback(),testTargets,lastReportedTestSequenceNumber,totalNumberOfTests));
      }
      ListenableFuture<List<TestResults>> serialResults=Futures.allAsList(separateResultsList);
      try {
        completedResults.addAll(serialResults.get());
      }
 catch (      ExecutionException e) {
        LOG.error(e,""String_Node_Str"");
        throw new HumanReadableException(e,""String_Node_Str"");
      }
catch (      InterruptedException e) {
        LOG.error(e,""String_Node_Str"");
        try {
          serialResults.cancel(true);
        }
 catch (        CancellationException ignored) {
        }
        Thread.currentThread().interrupt();
        throw new HumanReadableException(e,""String_Node_Str"");
      }
      LOG.debug(""String_Node_Str"");
    }
    @Override public void onFailure(    Throwable e){
      LOG.error(e,""String_Node_Str"");
      throw new HumanReadableException(e,""String_Node_Str"");
    }
  }
,directExecutorService);
  try {
    uberFuture.get();
  }
 catch (  ExecutionException e) {
    e.printStackTrace(params.getConsole().getStdErr());
    return 1;
  }
catch (  InterruptedException e) {
    try {
      uberFuture.cancel(true);
    }
 catch (    CancellationException ignored) {
    }
    Thread.currentThread().interrupt();
    throw e;
  }
  params.getBuckEventBus().post(TestRunEvent.finished(testTargets,completedResults));
  Optional<String> path=options.getPathToXmlTestOutput();
  if (path.isPresent()) {
    try (Writer writer=Files.newWriter(new File(path.get()),Charsets.UTF_8)){
      writeXmlOutput(completedResults,writer);
    }
   }
  if (options.isCodeCoverageEnabled() && !rulesUnderTest.isEmpty()) {
    try {
      Optional<DefaultJavaPackageFinder> defaultJavaPackageFinderOptional=Optional.fromNullable(params.getBuckConfig().createDefaultJavaPackageFinder());
      stepRunner.runStepForBuildTarget(getReportCommand(rulesUnderTest,defaultJavaPackageFinderOptional,new JavaBuckConfig(params.getBuckConfig()).getDefaultJavaOptions().getJavaRuntimeLauncher(),params.getCell().getFilesystem(),JacocoConstants.getJacocoOutputDir(params.getCell().getFilesystem()),options.getCoverageReportFormat(),options.getCoverageReportTitle(),options.getCoverageIncludes(),options.getCoverageExcludes()),Optional.<BuildTarget>absent());
    }
 catch (    StepFailedException e) {
      params.getBuckEventBus().post(ConsoleEvent.severe(Throwables.getRootCause(e).getLocalizedMessage()));
      return 1;
    }
  }
  boolean failures=Iterables.any(completedResults,new Predicate<TestResults>(){
    @Override public boolean apply(    TestResults results){
      LOG.debug(""String_Node_Str"",results);
      return !results.isSuccess();
    }
  }
);
  return failures ? TEST_FAILURES_EXIT_CODE : 0;
}",0.9990697674418604
53058,"@Test public void testIsTestRunRequiredForTestInDebugMode() throws IOException, ExecutionException, InterruptedException {
  ExecutionContext executionContext=TestExecutionContext.newBuilder().setDebugEnabled(true).build();
  assertTrue(executionContext.isDebugEnabled());
  assertTrue(""String_Node_Str"" + ""String_Node_Str"",TestRunning.isTestRunRequiredForTest(createMock(TestRule.class),createMock(CachingBuildEngine.class),executionContext,createMock(TestRuleKeyFileHelper.class),true,false,false));
}","@Test public void testIsTestRunRequiredForTestInDebugMode() throws IOException, ExecutionException, InterruptedException {
  ExecutionContext executionContext=TestExecutionContext.newBuilder().setDebugEnabled(true).build();
  assertTrue(executionContext.isDebugEnabled());
  assertTrue(""String_Node_Str"" + ""String_Node_Str"",TestRunning.isTestRunRequiredForTest(createMock(TestRule.class),createMock(CachingBuildEngine.class),executionContext,createMock(TestRuleKeyFileHelper.class),true,false,false,false));
}",0.9940711462450592
53059,"@Test public void testIsTestRunRequiredForTestBuiltLocally() throws IOException, ExecutionException, InterruptedException {
  ExecutionContext executionContext=TestExecutionContext.newInstance();
  assertFalse(executionContext.isDebugEnabled());
  FakeTestRule testRule=new FakeTestRule(ImmutableSet.of(Label.of(""String_Node_Str"")),BuildTargetFactory.newInstance(""String_Node_Str""),new SourcePathResolver(new BuildRuleResolver(TargetGraph.EMPTY,new DefaultTargetNodeToBuildRuleTransformer())),ImmutableSortedSet.<BuildRule>of());
  CachingBuildEngine cachingBuildEngine=createMock(CachingBuildEngine.class);
  BuildResult result=BuildResult.success(testRule,BUILT_LOCALLY,CacheResult.miss());
  expect(cachingBuildEngine.getBuildRuleResult(BuildTargetFactory.newInstance(""String_Node_Str""))).andReturn(result);
  replay(cachingBuildEngine);
  assertTrue(""String_Node_Str"",TestRunning.isTestRunRequiredForTest(testRule,cachingBuildEngine,executionContext,createMock(TestRuleKeyFileHelper.class),true,false,false));
  verify(cachingBuildEngine);
}","@Test public void testIsTestRunRequiredForTestBuiltLocally() throws IOException, ExecutionException, InterruptedException {
  ExecutionContext executionContext=TestExecutionContext.newInstance();
  assertFalse(executionContext.isDebugEnabled());
  FakeTestRule testRule=new FakeTestRule(ImmutableSet.of(Label.of(""String_Node_Str"")),BuildTargetFactory.newInstance(""String_Node_Str""),new SourcePathResolver(new BuildRuleResolver(TargetGraph.EMPTY,new DefaultTargetNodeToBuildRuleTransformer())),ImmutableSortedSet.<BuildRule>of());
  CachingBuildEngine cachingBuildEngine=createMock(CachingBuildEngine.class);
  BuildResult result=BuildResult.success(testRule,BUILT_LOCALLY,CacheResult.miss());
  expect(cachingBuildEngine.getBuildRuleResult(BuildTargetFactory.newInstance(""String_Node_Str""))).andReturn(result);
  replay(cachingBuildEngine);
  assertTrue(""String_Node_Str"",TestRunning.isTestRunRequiredForTest(testRule,cachingBuildEngine,executionContext,createMock(TestRuleKeyFileHelper.class),true,false,false,false));
  verify(cachingBuildEngine);
}",0.9971374045801528
53060,"@Test public void testIsTestRunRequiredIfRuleKeyNotPresent() throws IOException, ExecutionException, InterruptedException {
  ExecutionContext executionContext=TestExecutionContext.newInstance();
  assertFalse(executionContext.isDebugEnabled());
  FakeTestRule testRule=new FakeTestRule(ImmutableSet.of(Label.of(""String_Node_Str"")),BuildTargetFactory.newInstance(""String_Node_Str""),new SourcePathResolver(new BuildRuleResolver(TargetGraph.EMPTY,new DefaultTargetNodeToBuildRuleTransformer())),ImmutableSortedSet.<BuildRule>of()){
    @Override public boolean hasTestResultFiles(){
      return true;
    }
  }
;
  TestRuleKeyFileHelper testRuleKeyFileHelper=createNiceMock(TestRuleKeyFileHelper.class);
  expect(testRuleKeyFileHelper.isRuleKeyInDir(testRule)).andReturn(false);
  CachingBuildEngine cachingBuildEngine=createMock(CachingBuildEngine.class);
  BuildResult result=BuildResult.success(testRule,MATCHING_RULE_KEY,CacheResult.miss());
  expect(cachingBuildEngine.getBuildRuleResult(BuildTargetFactory.newInstance(""String_Node_Str""))).andReturn(result);
  replay(cachingBuildEngine,testRuleKeyFileHelper);
  assertTrue(""String_Node_Str"" + ""String_Node_Str"",TestRunning.isTestRunRequiredForTest(testRule,cachingBuildEngine,executionContext,testRuleKeyFileHelper,true,false,false));
  verify(cachingBuildEngine,testRuleKeyFileHelper);
}","@Test public void testIsTestRunRequiredIfRuleKeyNotPresent() throws IOException, ExecutionException, InterruptedException {
  ExecutionContext executionContext=TestExecutionContext.newInstance();
  assertFalse(executionContext.isDebugEnabled());
  FakeTestRule testRule=new FakeTestRule(ImmutableSet.of(Label.of(""String_Node_Str"")),BuildTargetFactory.newInstance(""String_Node_Str""),new SourcePathResolver(new BuildRuleResolver(TargetGraph.EMPTY,new DefaultTargetNodeToBuildRuleTransformer())),ImmutableSortedSet.<BuildRule>of()){
    @Override public boolean hasTestResultFiles(){
      return true;
    }
  }
;
  TestRuleKeyFileHelper testRuleKeyFileHelper=createNiceMock(TestRuleKeyFileHelper.class);
  expect(testRuleKeyFileHelper.isRuleKeyInDir(testRule)).andReturn(false);
  CachingBuildEngine cachingBuildEngine=createMock(CachingBuildEngine.class);
  BuildResult result=BuildResult.success(testRule,MATCHING_RULE_KEY,CacheResult.miss());
  expect(cachingBuildEngine.getBuildRuleResult(BuildTargetFactory.newInstance(""String_Node_Str""))).andReturn(result);
  replay(cachingBuildEngine,testRuleKeyFileHelper);
  assertTrue(""String_Node_Str"" + ""String_Node_Str"",TestRunning.isTestRunRequiredForTest(testRule,cachingBuildEngine,executionContext,testRuleKeyFileHelper,true,false,false,false));
  verify(cachingBuildEngine,testRuleKeyFileHelper);
}",0.9977711738484398
53061,"@Test public void testRunAlwaysRequiredIfEnvironmentOverridesPresent() throws Exception {
  ExecutionContext executionContext=TestExecutionContext.newBuilder().setDebugEnabled(false).build();
  FakeTestRule testRule=new FakeTestRule(ImmutableSet.of(Label.of(""String_Node_Str"")),BuildTargetFactory.newInstance(""String_Node_Str""),new SourcePathResolver(new BuildRuleResolver(TargetGraph.EMPTY,new DefaultTargetNodeToBuildRuleTransformer())),ImmutableSortedSet.<BuildRule>of()){
    @Override public boolean hasTestResultFiles(){
      return true;
    }
  }
;
  TestRuleKeyFileHelper testRuleKeyFileHelper=createNiceMock(TestRuleKeyFileHelper.class);
  expect(testRuleKeyFileHelper.isRuleKeyInDir(testRule)).andReturn(true).times(1);
  CachingBuildEngine cachingBuildEngine=createMock(CachingBuildEngine.class);
  BuildResult result=BuildResult.success(testRule,MATCHING_RULE_KEY,CacheResult.miss());
  expect(cachingBuildEngine.getBuildRuleResult(BuildTargetFactory.newInstance(""String_Node_Str""))).andReturn(result).times(1);
  replay(cachingBuildEngine,testRuleKeyFileHelper);
  assertFalse(""String_Node_Str"",TestRunning.isTestRunRequiredForTest(testRule,cachingBuildEngine,executionContext,testRuleKeyFileHelper,true,false,false));
  assertTrue(""String_Node_Str"",TestRunning.isTestRunRequiredForTest(testRule,cachingBuildEngine,executionContext,testRuleKeyFileHelper,true,false,true));
  verify(cachingBuildEngine,testRuleKeyFileHelper);
}","@Test public void testRunAlwaysRequiredIfEnvironmentOverridesPresent() throws Exception {
  ExecutionContext executionContext=TestExecutionContext.newBuilder().setDebugEnabled(false).build();
  FakeTestRule testRule=new FakeTestRule(ImmutableSet.of(Label.of(""String_Node_Str"")),BuildTargetFactory.newInstance(""String_Node_Str""),new SourcePathResolver(new BuildRuleResolver(TargetGraph.EMPTY,new DefaultTargetNodeToBuildRuleTransformer())),ImmutableSortedSet.<BuildRule>of()){
    @Override public boolean hasTestResultFiles(){
      return true;
    }
  }
;
  TestRuleKeyFileHelper testRuleKeyFileHelper=createNiceMock(TestRuleKeyFileHelper.class);
  expect(testRuleKeyFileHelper.isRuleKeyInDir(testRule)).andReturn(true).times(1);
  CachingBuildEngine cachingBuildEngine=createMock(CachingBuildEngine.class);
  BuildResult result=BuildResult.success(testRule,MATCHING_RULE_KEY,CacheResult.miss());
  expect(cachingBuildEngine.getBuildRuleResult(BuildTargetFactory.newInstance(""String_Node_Str""))).andReturn(result).times(1);
  replay(cachingBuildEngine,testRuleKeyFileHelper);
  assertFalse(""String_Node_Str"",TestRunning.isTestRunRequiredForTest(testRule,cachingBuildEngine,executionContext,testRuleKeyFileHelper,true,false,false,false));
  assertTrue(""String_Node_Str"",TestRunning.isTestRunRequiredForTest(testRule,cachingBuildEngine,executionContext,testRuleKeyFileHelper,true,false,true,false));
  verify(cachingBuildEngine,testRuleKeyFileHelper);
}",0.9958534899792676
53062,"@Test public void testIsTestRunRequiredForTestBuiltFromCacheIfHasTestResultFiles() throws IOException, ExecutionException, InterruptedException {
  ExecutionContext executionContext=TestExecutionContext.newInstance();
  assertFalse(executionContext.isDebugEnabled());
  FakeTestRule testRule=new FakeTestRule(ImmutableSet.of(Label.of(""String_Node_Str"")),BuildTargetFactory.newInstance(""String_Node_Str""),new SourcePathResolver(new BuildRuleResolver(TargetGraph.EMPTY,new DefaultTargetNodeToBuildRuleTransformer())),ImmutableSortedSet.<BuildRule>of());
  CachingBuildEngine cachingBuildEngine=createMock(CachingBuildEngine.class);
  BuildResult result=BuildResult.success(testRule,FETCHED_FROM_CACHE,CacheResult.hit(""String_Node_Str""));
  expect(cachingBuildEngine.getBuildRuleResult(BuildTargetFactory.newInstance(""String_Node_Str""))).andReturn(result);
  replay(cachingBuildEngine);
  assertTrue(""String_Node_Str"" + ""String_Node_Str"",TestRunning.isTestRunRequiredForTest(testRule,cachingBuildEngine,executionContext,createMock(TestRuleKeyFileHelper.class),true,false,false));
  verify(cachingBuildEngine);
}","@Test public void testIsTestRunRequiredForTestBuiltFromCacheIfHasTestResultFiles() throws IOException, ExecutionException, InterruptedException {
  ExecutionContext executionContext=TestExecutionContext.newInstance();
  assertFalse(executionContext.isDebugEnabled());
  FakeTestRule testRule=new FakeTestRule(ImmutableSet.of(Label.of(""String_Node_Str"")),BuildTargetFactory.newInstance(""String_Node_Str""),new SourcePathResolver(new BuildRuleResolver(TargetGraph.EMPTY,new DefaultTargetNodeToBuildRuleTransformer())),ImmutableSortedSet.<BuildRule>of());
  CachingBuildEngine cachingBuildEngine=createMock(CachingBuildEngine.class);
  BuildResult result=BuildResult.success(testRule,FETCHED_FROM_CACHE,CacheResult.hit(""String_Node_Str""));
  expect(cachingBuildEngine.getBuildRuleResult(BuildTargetFactory.newInstance(""String_Node_Str""))).andReturn(result);
  replay(cachingBuildEngine);
  assertTrue(""String_Node_Str"" + ""String_Node_Str"",TestRunning.isTestRunRequiredForTest(testRule,cachingBuildEngine,executionContext,createMock(TestRuleKeyFileHelper.class),true,false,false,false));
  verify(cachingBuildEngine);
}",0.9972997299729972
53063,"/** 
 * Use our own method to compare 'deps' stings. 'deps' should be sorted with local references ':' preceding any cross-repo references '@' e.g :inner, //world:empty, //world/asia:jp, @mars, @moon
 */
private static int compareDependencyStrings(String baseString,String anotherString){
  int endBaseString=baseString.length();
  int endAnotherString=anotherString.length();
  int i=0;
  int j=0;
  while (i < endBaseString && j < endAnotherString) {
    char c1=baseString.charAt(i);
    char c2=anotherString.charAt(j);
    if (c1 == ' ') {
      i++;
      continue;
    }
 else     if (c2 == ' ') {
      j++;
      continue;
    }
 else     if (c1 == c2) {
      i++;
      j++;
      continue;
    }
 else     if (c1 == ':') {
      return -1;
    }
 else     if (c2 == ':') {
      return 1;
    }
 else     if (c1 == '@') {
      return 1;
    }
 else     if (c2 == '@') {
      return -1;
    }
 else     if (c1 < c2) {
      return -1;
    }
 else {
      return 1;
    }
  }
  return baseString.compareTo(anotherString);
}","/** 
 * Use our own method to compare 'deps' strings. 'deps' should be sorted with local references ':' preceding any cross-repo references 'cell//' e.g :inner, //world:empty, //world/asia:jp, mars//olympus, moon//sea:tranquility
 */
private static int compareDependencyStrings(String baseString,String anotherString){
  int endBaseString=baseString.length();
  int endAnotherString=anotherString.length();
  int i=0;
  int j=0;
  while (i < endBaseString && j < endAnotherString) {
    char c1=baseString.charAt(i);
    char c2=anotherString.charAt(j);
    if (c1 == ' ') {
      i++;
      continue;
    }
 else     if (c2 == ' ') {
      j++;
      continue;
    }
 else     if (c1 == c2) {
      i++;
      j++;
      continue;
    }
 else     if (c1 == ':') {
      return -1;
    }
 else     if (c2 == ':') {
      return 1;
    }
 else     if (c1 < c2) {
      return -1;
    }
 else {
      return 1;
    }
  }
  return baseString.compareTo(anotherString);
}",0.8715642178910544
53064,"private CounterSnapshot.Builder generateCounterSnapshot(){
  CounterSnapshot.Builder builder=CounterSnapshot.builder().setCategory(""String_Node_Str"").putValues(""String_Node_Str"",uploadThreadCount).putValues(""String_Node_Str"",artifactCount).putValues(""String_Node_Str"",totalUploadedBytes);
  if (totalNetworkTimeMillis != -1) {
    builder.putValues(""String_Node_Str"",totalNetworkTimeMillis);
  }
  if (totalNetworkTimeMillis > 0) {
    builder.putValues(""String_Node_Str"",totalUploadedBytes / TimeUnit.MILLISECONDS.toSeconds(totalNetworkTimeMillis));
  }
  if (buildFinishMillis != -1 && lastUploadFinishMillis != -1) {
    builder.putValues(""String_Node_Str"",buildFinishMillis - lastUploadFinishMillis);
  }
  return builder;
}","private CounterSnapshot.Builder generateCounterSnapshot(){
  CounterSnapshot.Builder builder=CounterSnapshot.builder().setCategory(""String_Node_Str"").putValues(""String_Node_Str"",uploadThreadCount).putValues(""String_Node_Str"",artifactCount).putValues(""String_Node_Str"",totalUploadedBytes);
  if (totalNetworkTimeMillis != -1) {
    builder.putValues(""String_Node_Str"",totalNetworkTimeMillis);
  }
  if (totalNetworkTimeMillis > 0) {
    builder.putValues(""String_Node_Str"",(1000 * totalUploadedBytes) / totalNetworkTimeMillis);
  }
  if (buildFinishMillis != -1 && lastUploadFinishMillis != -1) {
    builder.putValues(""String_Node_Str"",buildFinishMillis - lastUploadFinishMillis);
  }
  return builder;
}",0.9706703910614524
53065,"private static ArtifactCache newInstanceInternal(ArtifactCacheBuckConfig buckConfig,BuckEventBus buckEventBus,ProjectFilesystem projectFilesystem,Optional<String> wifiSsid,ListeningExecutorService httpWriteExecutorService) throws InterruptedException {
  ImmutableSet<ArtifactCacheBuckConfig.ArtifactCacheMode> modes=buckConfig.getArtifactCacheModes();
  if (modes.isEmpty()) {
    return new NoopArtifactCache();
  }
  ImmutableList.Builder<ArtifactCache> builder=ImmutableList.builder();
  for (  ArtifactCacheBuckConfig.ArtifactCacheMode mode : modes) {
switch (mode) {
case dir:
      builder.add(createDirArtifactCache(Optional.of(buckEventBus),buckConfig.getDirCache(),projectFilesystem));
    break;
case http:
  initializeDistributedCaches(buckConfig,buckEventBus,projectFilesystem,wifiSsid,httpWriteExecutorService,builder,HTTP_PROTOCOL);
break;
case thrift_over_http:
initializeDistributedCaches(buckConfig,buckEventBus,projectFilesystem,wifiSsid,httpWriteExecutorService,builder,THRIFT_PROTOCOL);
break;
}
}
ImmutableList<ArtifactCache> artifactCaches=builder.build();
ArtifactCache result;
if (artifactCaches.size() == 1) {
result=artifactCaches.get(0);
}
 else {
result=new MultiArtifactCache(artifactCaches);
}
result=new TwoLevelArtifactCacheDecorator(result,projectFilesystem,buckEventBus,httpWriteExecutorService,buckConfig.getTwoLevelCachingEnabled(),buckConfig.getTwoLevelCachingMinimumSize(),buckConfig.getTwoLevelCachingMaximumSize());
return result;
}","private static ArtifactCache newInstanceInternal(ArtifactCacheBuckConfig buckConfig,BuckEventBus buckEventBus,ProjectFilesystem projectFilesystem,Optional<String> wifiSsid,ListeningExecutorService httpWriteExecutorService) throws InterruptedException {
  ImmutableSet<ArtifactCacheBuckConfig.ArtifactCacheMode> modes=buckConfig.getArtifactCacheModes();
  if (modes.isEmpty()) {
    return new NoopArtifactCache();
  }
  ImmutableList.Builder<ArtifactCache> builder=ImmutableList.builder();
  for (  ArtifactCacheBuckConfig.ArtifactCacheMode mode : modes) {
switch (mode) {
case dir:
      builder.add(createDirArtifactCache(Optional.of(buckEventBus),buckConfig.getDirCache(),projectFilesystem));
    break;
case http:
  initializeDistributedCaches(buckConfig,buckEventBus,projectFilesystem,wifiSsid,httpWriteExecutorService,builder,HTTP_PROTOCOL);
break;
case thrift_over_http:
initializeDistributedCaches(buckConfig,buckEventBus,projectFilesystem,wifiSsid,httpWriteExecutorService,builder,THRIFT_PROTOCOL);
break;
}
}
ImmutableList<ArtifactCache> artifactCaches=builder.build();
ArtifactCache result;
if (artifactCaches.size() == 1) {
result=artifactCaches.get(0);
}
 else {
result=new MultiArtifactCache(artifactCaches);
}
result=new TwoLevelArtifactCacheDecorator(result,projectFilesystem,buckEventBus,buckConfig.getTwoLevelCachingEnabled(),buckConfig.getTwoLevelCachingMinimumSize(),buckConfig.getTwoLevelCachingMaximumSize());
return result;
}",0.9914412872304006
53066,"public TwoLevelArtifactCacheDecorator(ArtifactCache delegate,ProjectFilesystem projectFilesystem,BuckEventBus buckEventBus,ListeningExecutorService listeningExecutorService,boolean performTwoLevelStores,long minimumTwoLevelStoredArtifactSize,Optional<Long> maximumTwoLevelStoredArtifactSize){
  this.delegate=delegate;
  this.projectFilesystem=projectFilesystem;
  this.listeningExecutorService=listeningExecutorService;
  this.performTwoLevelStores=performTwoLevelStores;
  this.minimumTwoLevelStoredArtifactSize=minimumTwoLevelStoredArtifactSize;
  this.maximumTwoLevelStoredArtifactSize=maximumTwoLevelStoredArtifactSize;
  Path scratchDir=projectFilesystem.getBuckPaths().getScratchDir();
  try {
    projectFilesystem.mkdirs(scratchDir);
    this.emptyFilePath=projectFilesystem.resolve(projectFilesystem.createTempFile(scratchDir,""String_Node_Str"",""String_Node_Str""));
  }
 catch (  IOException e) {
    throw new HumanReadableException(""String_Node_Str"" + projectFilesystem.resolve(scratchDir));
  }
  secondLevelCacheHitTypes=new TagSetCounter(COUNTER_CATEGORY,""String_Node_Str"",ImmutableMap.<String,String>of());
  secondLevelCacheHitBytes=new SamplingCounter(COUNTER_CATEGORY,""String_Node_Str"",ImmutableMap.<String,String>of());
  secondLevelCacheMisses=new IntegerCounter(COUNTER_CATEGORY,""String_Node_Str"",ImmutableMap.<String,String>of());
  secondLevelHashComputationTimeMs=new SamplingCounter(COUNTER_CATEGORY,""String_Node_Str"",ImmutableMap.<String,String>of());
  buckEventBus.post(new CounterRegistry.AsyncCounterRegistrationEvent(ImmutableSet.of(secondLevelCacheHitTypes,secondLevelCacheHitBytes,secondLevelCacheMisses,secondLevelHashComputationTimeMs)));
}","public TwoLevelArtifactCacheDecorator(ArtifactCache delegate,ProjectFilesystem projectFilesystem,BuckEventBus buckEventBus,boolean performTwoLevelStores,long minimumTwoLevelStoredArtifactSize,Optional<Long> maximumTwoLevelStoredArtifactSize){
  this.delegate=delegate;
  this.projectFilesystem=projectFilesystem;
  this.performTwoLevelStores=performTwoLevelStores;
  this.minimumTwoLevelStoredArtifactSize=minimumTwoLevelStoredArtifactSize;
  this.maximumTwoLevelStoredArtifactSize=maximumTwoLevelStoredArtifactSize;
  Path scratchDir=projectFilesystem.getBuckPaths().getScratchDir();
  try {
    projectFilesystem.mkdirs(scratchDir);
    this.emptyFilePath=projectFilesystem.resolve(projectFilesystem.createTempFile(scratchDir,""String_Node_Str"",""String_Node_Str""));
  }
 catch (  IOException e) {
    throw new HumanReadableException(""String_Node_Str"" + projectFilesystem.resolve(scratchDir));
  }
  secondLevelCacheHitTypes=new TagSetCounter(COUNTER_CATEGORY,""String_Node_Str"",ImmutableMap.<String,String>of());
  secondLevelCacheHitBytes=new SamplingCounter(COUNTER_CATEGORY,""String_Node_Str"",ImmutableMap.<String,String>of());
  secondLevelCacheMisses=new IntegerCounter(COUNTER_CATEGORY,""String_Node_Str"",ImmutableMap.<String,String>of());
  secondLevelHashComputationTimeMs=new SamplingCounter(COUNTER_CATEGORY,""String_Node_Str"",ImmutableMap.<String,String>of());
  buckEventBus.post(new CounterRegistry.AsyncCounterRegistrationEvent(ImmutableSet.of(secondLevelCacheHitTypes,secondLevelCacheHitBytes,secondLevelCacheMisses,secondLevelHashComputationTimeMs)));
}",0.9000616903146206
53067,"@Override public ListenableFuture<Boolean> apply(Optional<String> contentHash) throws Exception {
  if (!contentHash.isPresent()) {
    return Futures.immediateFuture(false);
  }
  ImmutableMap<String,String> metadataWithCacheKey=ImmutableMap.<String,String>builder().putAll(info.getMetadata()).put(METADATA_KEY,contentHash.get()).build();
  return Futures.transform(delegate.store(ArtifactInfo.builder().setRuleKeys(info.getRuleKeys()).setMetadata(metadataWithCacheKey).build(),BorrowablePath.notBorrowablePath(emptyFilePath)),Functions.constant(true));
}","@Override public ListenableFuture<Boolean> apply(Void input) throws Exception {
  long fileSize=projectFilesystem.getFileSize(output.getPath());
  if (!performTwoLevelStores || fileSize < minimumTwoLevelStoredArtifactSize || (maximumTwoLevelStoredArtifactSize.isPresent() && fileSize > maximumTwoLevelStoredArtifactSize.get())) {
    return Futures.immediateFuture(false);
  }
  long hashComputationStart=System.currentTimeMillis();
  String hashCode=projectFilesystem.computeSha1(output.getPath()) + ""String_Node_Str"";
  long hashComputationEnd=System.currentTimeMillis();
  secondLevelHashComputationTimeMs.addSample(hashComputationEnd - hashComputationStart);
  ImmutableMap<String,String> metadataWithCacheKey=ImmutableMap.<String,String>builder().putAll(info.getMetadata()).put(METADATA_KEY,hashCode).build();
  return Futures.transform(Futures.allAsList(delegate.store(ArtifactInfo.builder().setRuleKeys(info.getRuleKeys()).setMetadata(metadataWithCacheKey).build(),BorrowablePath.notBorrowablePath(emptyFilePath)),delegate.store(ArtifactInfo.builder().addRuleKeys(new RuleKey(hashCode)).build(),output)),Functions.constant(true));
}",0.5899705014749262
53068,"private ListenableFuture<Boolean> attemptTwoLevelStore(final ArtifactInfo info,final BorrowablePath output){
  ListenableFuture<Optional<String>> contentHash=Futures.transformAsync(Futures.<Void>immediateFuture(null),new AsyncFunction<Void,Optional<String>>(){
    @Override public ListenableFuture<Optional<String>> apply(    Void input) throws Exception {
      long fileSize=projectFilesystem.getFileSize(output.getPath());
      if (!performTwoLevelStores || fileSize < minimumTwoLevelStoredArtifactSize || (maximumTwoLevelStoredArtifactSize.isPresent() && fileSize > maximumTwoLevelStoredArtifactSize.get())) {
        return Futures.immediateFuture(Optional.<String>absent());
      }
      long hashComputationStart=System.currentTimeMillis();
      String hashCode=projectFilesystem.computeSha1(output.getPath()) + ""String_Node_Str"";
      long hashComputationEnd=System.currentTimeMillis();
      secondLevelHashComputationTimeMs.addSample(hashComputationEnd - hashComputationStart);
      return Futures.transform(delegate.store(ArtifactInfo.builder().addRuleKeys(new RuleKey(hashCode)).build(),output),Functions.constant(Optional.of(hashCode)));
    }
  }
,listeningExecutorService);
  return Futures.transformAsync(contentHash,new AsyncFunction<Optional<String>,Boolean>(){
    @Override public ListenableFuture<Boolean> apply(    Optional<String> contentHash) throws Exception {
      if (!contentHash.isPresent()) {
        return Futures.immediateFuture(false);
      }
      ImmutableMap<String,String> metadataWithCacheKey=ImmutableMap.<String,String>builder().putAll(info.getMetadata()).put(METADATA_KEY,contentHash.get()).build();
      return Futures.transform(delegate.store(ArtifactInfo.builder().setRuleKeys(info.getRuleKeys()).setMetadata(metadataWithCacheKey).build(),BorrowablePath.notBorrowablePath(emptyFilePath)),Functions.constant(true));
    }
  }
,listeningExecutorService);
}","private ListenableFuture<Boolean> attemptTwoLevelStore(final ArtifactInfo info,final BorrowablePath output){
  return Futures.transformAsync(Futures.<Void>immediateFuture(null),new AsyncFunction<Void,Boolean>(){
    @Override public ListenableFuture<Boolean> apply(    Void input) throws Exception {
      long fileSize=projectFilesystem.getFileSize(output.getPath());
      if (!performTwoLevelStores || fileSize < minimumTwoLevelStoredArtifactSize || (maximumTwoLevelStoredArtifactSize.isPresent() && fileSize > maximumTwoLevelStoredArtifactSize.get())) {
        return Futures.immediateFuture(false);
      }
      long hashComputationStart=System.currentTimeMillis();
      String hashCode=projectFilesystem.computeSha1(output.getPath()) + ""String_Node_Str"";
      long hashComputationEnd=System.currentTimeMillis();
      secondLevelHashComputationTimeMs.addSample(hashComputationEnd - hashComputationStart);
      ImmutableMap<String,String> metadataWithCacheKey=ImmutableMap.<String,String>builder().putAll(info.getMetadata()).put(METADATA_KEY,hashCode).build();
      return Futures.transform(Futures.allAsList(delegate.store(ArtifactInfo.builder().setRuleKeys(info.getRuleKeys()).setMetadata(metadataWithCacheKey).build(),BorrowablePath.notBorrowablePath(emptyFilePath)),delegate.store(ArtifactInfo.builder().addRuleKeys(new RuleKey(hashCode)).build(),output)),Functions.constant(true));
    }
  }
);
}",0.7650602409638554
53069,"@Test public void testMetadataIsNotShared() throws InterruptedException, IOException {
  try (InMemoryArtifactCache inMemoryArtifactCache=new InMemoryArtifactCache();TwoLevelArtifactCacheDecorator twoLevelCache=new TwoLevelArtifactCacheDecorator(inMemoryArtifactCache,new ProjectFilesystem(tmp.getRoot()),BuckEventBusFactory.newInstance(),MoreExecutors.newDirectExecutorService(),true,0L,Optional.<Long>absent())){
    LazyPath dummyFile=LazyPath.ofInstance(tmp.newFile());
    final String testMetadataKey=""String_Node_Str"";
    twoLevelCache.store(ArtifactInfo.builder().addRuleKeys(dummyRuleKey).setMetadata(ImmutableMap.of(testMetadataKey,""String_Node_Str"")).build(),BorrowablePath.notBorrowablePath(dummyFile.get()));
    twoLevelCache.store(ArtifactInfo.builder().addRuleKeys(dummyRuleKey2).setMetadata(ImmutableMap.of(testMetadataKey,""String_Node_Str"")).build(),BorrowablePath.notBorrowablePath(dummyFile.get()));
    CacheResult fetch1=twoLevelCache.fetch(dummyRuleKey,dummyFile);
    CacheResult fetch2=twoLevelCache.fetch(dummyRuleKey2,dummyFile);
    assertEquals(fetch1.getMetadata().get(TwoLevelArtifactCacheDecorator.METADATA_KEY),fetch2.getMetadata().get(TwoLevelArtifactCacheDecorator.METADATA_KEY));
    assertNotEquals(fetch1.getMetadata().get(testMetadataKey),fetch2.getMetadata().get(testMetadataKey));
  }
 }","@Test public void testMetadataIsNotShared() throws InterruptedException, IOException {
  try (InMemoryArtifactCache inMemoryArtifactCache=new InMemoryArtifactCache();TwoLevelArtifactCacheDecorator twoLevelCache=new TwoLevelArtifactCacheDecorator(inMemoryArtifactCache,new ProjectFilesystem(tmp.getRoot()),BuckEventBusFactory.newInstance(),true,0L,Optional.<Long>absent())){
    LazyPath dummyFile=LazyPath.ofInstance(tmp.newFile());
    final String testMetadataKey=""String_Node_Str"";
    twoLevelCache.store(ArtifactInfo.builder().addRuleKeys(dummyRuleKey).setMetadata(ImmutableMap.of(testMetadataKey,""String_Node_Str"")).build(),BorrowablePath.notBorrowablePath(dummyFile.get()));
    twoLevelCache.store(ArtifactInfo.builder().addRuleKeys(dummyRuleKey2).setMetadata(ImmutableMap.of(testMetadataKey,""String_Node_Str"")).build(),BorrowablePath.notBorrowablePath(dummyFile.get()));
    CacheResult fetch1=twoLevelCache.fetch(dummyRuleKey,dummyFile);
    CacheResult fetch2=twoLevelCache.fetch(dummyRuleKey2,dummyFile);
    assertEquals(fetch1.getMetadata().get(TwoLevelArtifactCacheDecorator.METADATA_KEY),fetch2.getMetadata().get(TwoLevelArtifactCacheDecorator.METADATA_KEY));
    assertNotEquals(fetch1.getMetadata().get(testMetadataKey),fetch2.getMetadata().get(testMetadataKey));
  }
 }",0.984333205961024
53070,"private void testStoreThresholds(int artifactSize,int expectedArtifactsInCache) throws InterruptedException, IOException {
  try (InMemoryArtifactCache inMemoryArtifactCache=new InMemoryArtifactCache();TwoLevelArtifactCacheDecorator twoLevelCache=new TwoLevelArtifactCacheDecorator(inMemoryArtifactCache,new ProjectFilesystem(tmp.getRoot()),BuckEventBusFactory.newInstance(),MoreExecutors.newDirectExecutorService(),true,5L,Optional.of(10L))){
    LazyPath lazyPath=LazyPath.ofInstance(tmp.newFile());
    Files.write(lazyPath.get(),new byte[artifactSize]);
    twoLevelCache.store(ArtifactInfo.builder().addRuleKeys(dummyRuleKey).build(),BorrowablePath.notBorrowablePath(lazyPath.get()));
    assertThat(inMemoryArtifactCache.getArtifactCount(),Matchers.equalTo(expectedArtifactsInCache));
  }
 }","private void testStoreThresholds(int artifactSize,int expectedArtifactsInCache) throws InterruptedException, IOException {
  try (InMemoryArtifactCache inMemoryArtifactCache=new InMemoryArtifactCache();TwoLevelArtifactCacheDecorator twoLevelCache=new TwoLevelArtifactCacheDecorator(inMemoryArtifactCache,new ProjectFilesystem(tmp.getRoot()),BuckEventBusFactory.newInstance(),true,5L,Optional.of(10L))){
    LazyPath lazyPath=LazyPath.ofInstance(tmp.newFile());
    Files.write(lazyPath.get(),new byte[artifactSize]);
    twoLevelCache.store(ArtifactInfo.builder().addRuleKeys(dummyRuleKey).build(),BorrowablePath.notBorrowablePath(lazyPath.get()));
    assertThat(inMemoryArtifactCache.getArtifactCount(),Matchers.equalTo(expectedArtifactsInCache));
  }
 }",0.9735994848679974
53071,"@Test public void testCanRead2LStoresIfStoresDisabled() throws InterruptedException, IOException {
  try (InMemoryArtifactCache inMemoryArtifactCache=new InMemoryArtifactCache();TwoLevelArtifactCacheDecorator twoLevelCache=new TwoLevelArtifactCacheDecorator(inMemoryArtifactCache,new ProjectFilesystem(tmp.getRoot()),BuckEventBusFactory.newInstance(),MoreExecutors.newDirectExecutorService(),true,0L,Optional.<Long>absent());TwoLevelArtifactCacheDecorator twoLevelCacheNoStore=new TwoLevelArtifactCacheDecorator(inMemoryArtifactCache,new ProjectFilesystem(tmp.getRoot()),BuckEventBusFactory.newInstance(),MoreExecutors.newDirectExecutorService(),false,0L,Optional.<Long>absent())){
    LazyPath dummyFile=LazyPath.ofInstance(tmp.newFile());
    twoLevelCache.store(ArtifactInfo.builder().addRuleKeys(dummyRuleKey).build(),BorrowablePath.notBorrowablePath(dummyFile.get()));
    assertThat(inMemoryArtifactCache.getArtifactCount(),Matchers.equalTo(2));
    assertThat(twoLevelCacheNoStore.fetch(dummyRuleKey,dummyFile).getType(),Matchers.equalTo(CacheResultType.HIT));
  }
 }","@Test public void testCanRead2LStoresIfStoresDisabled() throws InterruptedException, IOException {
  try (InMemoryArtifactCache inMemoryArtifactCache=new InMemoryArtifactCache();TwoLevelArtifactCacheDecorator twoLevelCache=new TwoLevelArtifactCacheDecorator(inMemoryArtifactCache,new ProjectFilesystem(tmp.getRoot()),BuckEventBusFactory.newInstance(),true,0L,Optional.<Long>absent());TwoLevelArtifactCacheDecorator twoLevelCacheNoStore=new TwoLevelArtifactCacheDecorator(inMemoryArtifactCache,new ProjectFilesystem(tmp.getRoot()),BuckEventBusFactory.newInstance(),false,0L,Optional.<Long>absent())){
    LazyPath dummyFile=LazyPath.ofInstance(tmp.newFile());
    twoLevelCache.store(ArtifactInfo.builder().addRuleKeys(dummyRuleKey).build(),BorrowablePath.notBorrowablePath(dummyFile.get()));
    assertThat(inMemoryArtifactCache.getArtifactCount(),Matchers.equalTo(2));
    assertThat(twoLevelCacheNoStore.fetch(dummyRuleKey,dummyFile).getType(),Matchers.equalTo(CacheResultType.HIT));
  }
 }",0.9603097773475314
53072,"@Test public void testCacheFetch() throws InterruptedException, IOException {
  try (InMemoryArtifactCache inMemoryArtifactCache=new InMemoryArtifactCache();TwoLevelArtifactCacheDecorator twoLevelCache=new TwoLevelArtifactCacheDecorator(inMemoryArtifactCache,new ProjectFilesystem(tmp.getRoot()),BuckEventBusFactory.newInstance(),MoreExecutors.newDirectExecutorService(),true,0L,Optional.<Long>absent())){
    LazyPath dummyFile=LazyPath.ofInstance(tmp.newFile());
    assertThat(twoLevelCache.fetch(dummyRuleKey,dummyFile).getType(),Matchers.equalTo(CacheResultType.MISS));
    twoLevelCache.store(ArtifactInfo.builder().addRuleKeys(dummyRuleKey).build(),BorrowablePath.notBorrowablePath(dummyFile.get()));
    assertThat(twoLevelCache.fetch(dummyRuleKey,dummyFile).getType(),Matchers.equalTo(CacheResultType.HIT));
    twoLevelCache.store(ArtifactInfo.builder().addRuleKeys(dummyRuleKey2).build(),BorrowablePath.notBorrowablePath(dummyFile.get()));
    assertThat(twoLevelCache.fetch(dummyRuleKey2,dummyFile).getType(),Matchers.equalTo(CacheResultType.HIT));
    assertThat(inMemoryArtifactCache.getArtifactCount(),Matchers.equalTo(3));
  }
 }","@Test public void testCacheFetch() throws InterruptedException, IOException {
  try (InMemoryArtifactCache inMemoryArtifactCache=new InMemoryArtifactCache();TwoLevelArtifactCacheDecorator twoLevelCache=new TwoLevelArtifactCacheDecorator(inMemoryArtifactCache,new ProjectFilesystem(tmp.getRoot()),BuckEventBusFactory.newInstance(),true,0L,Optional.<Long>absent())){
    LazyPath dummyFile=LazyPath.ofInstance(tmp.newFile());
    assertThat(twoLevelCache.fetch(dummyRuleKey,dummyFile).getType(),Matchers.equalTo(CacheResultType.MISS));
    twoLevelCache.store(ArtifactInfo.builder().addRuleKeys(dummyRuleKey).build(),BorrowablePath.notBorrowablePath(dummyFile.get()));
    assertThat(twoLevelCache.fetch(dummyRuleKey,dummyFile).getType(),Matchers.equalTo(CacheResultType.HIT));
    twoLevelCache.store(ArtifactInfo.builder().addRuleKeys(dummyRuleKey2).build(),BorrowablePath.notBorrowablePath(dummyFile.get()));
    assertThat(twoLevelCache.fetch(dummyRuleKey2,dummyFile).getType(),Matchers.equalTo(CacheResultType.HIT));
    assertThat(inMemoryArtifactCache.getArtifactCount(),Matchers.equalTo(3));
  }
 }",0.981769675411294
53073,"@Override public void consumeConsoleEvent(final String message){
  if (!BuckToolWindowFactory.isToolWindowVisible(mProject)) {
    BuckToolWindowFactory.showToolWindow(mProject);
  }
  ApplicationManager.getApplication().invokeLater(new Runnable(){
    @Override public void run(){
      mCurrentBuildRootElement.addChild(new BuckTreeNodeDetail(mCurrentBuildRootElement,BuckTreeNodeDetail.DetailType.ERROR,message));
      BuckEventsConsumer.this.mTreeModel.reload();
    }
  }
);
}","@Override public void consumeConsoleEvent(final String message){
  if (!BuckToolWindowFactory.isToolWindowInstantiated(mProject)) {
    return;
  }
  if (!BuckToolWindowFactory.isToolWindowVisible(mProject)) {
    BuckToolWindowFactory.showToolWindow(mProject);
  }
  ApplicationManager.getApplication().invokeLater(new Runnable(){
    @Override public void run(){
      mCurrentBuildRootElement.addChild(new BuckTreeNodeDetail(mCurrentBuildRootElement,BuckTreeNodeDetail.DetailType.ERROR,message));
      BuckEventsConsumer.this.mTreeModel.reload();
    }
  }
);
}",0.9207258834765998
53074,"@Override public CacheResult fetchImpl(RuleKey ruleKey,LazyPath output,HttpArtifactCacheEvent.Finished.Builder eventBuilder) throws IOException {
  BuckCacheFetchRequest fetchRequest=new BuckCacheFetchRequest();
  BuckCacheRequest cacheRequest=new BuckCacheRequest();
  cacheRequest.setType(BuckCacheRequestType.FETCH);
  cacheRequest.setFetchRequest(fetchRequest);
  final ThriftArtifactCacheProtocol.Request request=ThriftArtifactCacheProtocol.createRequest(PROTOCOL,cacheRequest);
  Request.Builder builder=toOkHttpRequest(request);
  try (HttpResponse httpResponse=fetchClient.makeRequest(hybridThriftEndpoint,builder)){
    if (httpResponse.code() != 200) {
      String message=String.format(""String_Node_Str"" + ""String_Node_Str"",httpResponse.code(),httpResponse.requestUrl(),ruleKey.toString());
      LOG.error(message);
      return CacheResult.error(name,message);
    }
    try (ThriftArtifactCacheProtocol.Response response=ThriftArtifactCacheProtocol.parseResponse(PROTOCOL,httpResponse.getBody())){
      BuckCacheResponse cacheResponse=response.getThriftData();
      if (!cacheResponse.isWasSuccessful()) {
        return CacheResult.error(name,cacheResponse.getErrorMessage());
      }
      BuckCacheFetchResponse fetchResponse=cacheResponse.getFetchResponse();
      if (!fetchResponse.isArtifactExists()) {
        return CacheResult.miss();
      }
      Path tmp=createTempFileForDownload();
      ThriftArtifactCacheProtocol.Response.ReadPayloadInfo readResult=null;
      try (OutputStream tmpFile=projectFilesystem.newFileOutputStream(tmp)){
        readResult=response.readPayload(tmpFile);
      }
       ArtifactMetadata metadata=fetchResponse.getMetadata();
      if (!metadata.isSetArtifactPayloadCrc32()) {
        String msg=""String_Node_Str"";
        LOG.error(msg);
        return CacheResult.error(name,msg);
      }
      if (readResult.getCrc32Hash() != fetchResponse.getMetadata().getArtifactPayloadCrc32()) {
        String msg=String.format(""String_Node_Str"",fetchResponse.getMetadata().getArtifactPayloadCrc32(),readResult.getCrc32Hash());
        LOG.error(msg);
        return CacheResult.error(name,msg);
      }
      projectFilesystem.move(tmp,output.get(),StandardCopyOption.REPLACE_EXISTING);
      return CacheResult.hit(name,ImmutableMap.copyOf(fetchResponse.getMetadata().getMetadata()),readResult.getBytesRead());
    }
   }
 }","@Override public CacheResult fetchImpl(RuleKey ruleKey,LazyPath output,HttpArtifactCacheEvent.Finished.Builder eventBuilder) throws IOException {
  BuckCacheFetchRequest fetchRequest=new BuckCacheFetchRequest();
  com.facebook.buck.artifact_cache.thrift.RuleKey thriftRuleKey=new com.facebook.buck.artifact_cache.thrift.RuleKey();
  thriftRuleKey.setHashString(ruleKey.getHashCode().toString());
  fetchRequest.setRuleKey(thriftRuleKey);
  BuckCacheRequest cacheRequest=new BuckCacheRequest();
  cacheRequest.setType(BuckCacheRequestType.FETCH);
  cacheRequest.setFetchRequest(fetchRequest);
  final ThriftArtifactCacheProtocol.Request request=ThriftArtifactCacheProtocol.createRequest(PROTOCOL,cacheRequest);
  Request.Builder builder=toOkHttpRequest(request);
  try (HttpResponse httpResponse=fetchClient.makeRequest(hybridThriftEndpoint,builder)){
    if (httpResponse.code() != 200) {
      String message=String.format(""String_Node_Str"" + ""String_Node_Str"",httpResponse.code(),httpResponse.requestUrl(),ruleKey.toString());
      LOG.error(message);
      return CacheResult.error(name,message);
    }
    try (ThriftArtifactCacheProtocol.Response response=ThriftArtifactCacheProtocol.parseResponse(PROTOCOL,httpResponse.getBody())){
      BuckCacheResponse cacheResponse=response.getThriftData();
      if (!cacheResponse.isWasSuccessful()) {
        return CacheResult.error(name,cacheResponse.getErrorMessage());
      }
      BuckCacheFetchResponse fetchResponse=cacheResponse.getFetchResponse();
      if (!fetchResponse.isArtifactExists()) {
        return CacheResult.miss();
      }
      Path tmp=createTempFileForDownload();
      ThriftArtifactCacheProtocol.Response.ReadPayloadInfo readResult=null;
      try (OutputStream tmpFile=projectFilesystem.newFileOutputStream(tmp)){
        readResult=response.readPayload(tmpFile);
      }
       ArtifactMetadata metadata=fetchResponse.getMetadata();
      if (!metadata.isSetArtifactPayloadCrc32()) {
        String msg=""String_Node_Str"";
        LOG.error(msg);
        return CacheResult.error(name,msg);
      }
      if (!readResult.getCrc32Hash().equals(fetchResponse.getMetadata().getArtifactPayloadCrc32())) {
        String msg=String.format(""String_Node_Str"",fetchResponse.getMetadata().getArtifactPayloadCrc32(),readResult.getCrc32Hash());
        LOG.error(msg);
        return CacheResult.error(name,msg);
      }
      projectFilesystem.move(tmp,output.get(),StandardCopyOption.REPLACE_EXISTING);
      return CacheResult.hit(name,ImmutableMap.copyOf(fetchResponse.getMetadata().getMetadata()),readResult.getBytesRead());
    }
   }
 }",0.9519038076152304
53075,"@Override protected void storeImpl(final ArtifactInfo info,final Path file,final HttpArtifactCacheEvent.Finished.Builder eventBuilder) throws IOException {
  final ByteSource artifact=new ByteSource(){
    @Override public InputStream openStream() throws IOException {
      return projectFilesystem.newFileInputStream(file);
    }
  }
;
  BuckCacheStoreRequest storeRequest=new BuckCacheStoreRequest();
  storeRequest.setMetadata(infoToMetadata(info,artifact));
  PayloadInfo payloadInfo=new PayloadInfo();
  payloadInfo.setSizeBytes(artifact.size());
  BuckCacheRequest cacheRequest=new BuckCacheRequest();
  cacheRequest.addToPayloads(payloadInfo);
  cacheRequest.setType(BuckCacheRequestType.STORE);
  cacheRequest.setStoreRequest(storeRequest);
  final ThriftArtifactCacheProtocol.Request request=ThriftArtifactCacheProtocol.createRequest(PROTOCOL,cacheRequest,artifact);
  Request.Builder builder=toOkHttpRequest(request);
  try (HttpResponse httpResponse=storeClient.makeRequest(hybridThriftEndpoint,builder)){
    if (httpResponse.code() != 200) {
      throw new IOException(String.format(""String_Node_Str"" + ""String_Node_Str"",httpResponse.code(),httpResponse.requestUrl(),info.getBuildTarget().orNull(),artifact.size()));
    }
    try (ThriftArtifactCacheProtocol.Response response=ThriftArtifactCacheProtocol.parseResponse(PROTOCOL,httpResponse.getBody())){
      if (!response.getThriftData().isWasSuccessful()) {
        throw new IOException(String.format(""String_Node_Str"" + ""String_Node_Str"",response.getThriftData().getErrorMessage(),httpResponse.requestUrl(),artifact.size()));
      }
    }
   }
 }","@Override protected void storeImpl(final ArtifactInfo info,final Path file,final HttpArtifactCacheEvent.Finished.Builder eventBuilder) throws IOException {
  final ByteSource artifact=new ByteSource(){
    @Override public InputStream openStream() throws IOException {
      return projectFilesystem.newFileInputStream(file);
    }
  }
;
  BuckCacheStoreRequest storeRequest=new BuckCacheStoreRequest();
  storeRequest.setMetadata(infoToMetadata(info,artifact));
  PayloadInfo payloadInfo=new PayloadInfo();
  payloadInfo.setSizeBytes(artifact.size());
  BuckCacheRequest cacheRequest=new BuckCacheRequest();
  cacheRequest.addToPayloads(payloadInfo);
  cacheRequest.setType(BuckCacheRequestType.STORE);
  cacheRequest.setStoreRequest(storeRequest);
  final ThriftArtifactCacheProtocol.Request request=ThriftArtifactCacheProtocol.createRequest(PROTOCOL,cacheRequest,artifact);
  Request.Builder builder=toOkHttpRequest(request);
  try (HttpResponse httpResponse=storeClient.makeRequest(hybridThriftEndpoint,builder)){
    if (httpResponse.code() != 200) {
      throw new IOException(String.format(""String_Node_Str"" + ""String_Node_Str"",httpResponse.code(),httpResponse.requestUrl(),info.getBuildTarget().orNull(),artifact.size()));
    }
    try (ThriftArtifactCacheProtocol.Response response=ThriftArtifactCacheProtocol.parseResponse(PROTOCOL,httpResponse.getBody())){
      if (!response.getThriftData().isWasSuccessful()) {
        reportFailure(""String_Node_Str"" + ""String_Node_Str"",response.getThriftData().getErrorMessage(),httpResponse.requestUrl(),artifact.size());
      }
      eventBuilder.setWasUploadSuccessful(response.getThriftData().isWasSuccessful());
    }
   }
 }",0.9587878787878787
53076,"public void disconnect(){
  if (mConnected) {
    scheduledFuture.cancel(true);
    ApplicationManager.getApplication().executeOnPooledThread(new Runnable(){
      @Override public void run(){
        try {
          mWSClient.stop();
          mConnected=false;
        }
 catch (        InterruptedException e) {
          LOG.debug(""String_Node_Str"" + e);
        }
catch (        Throwable t) {
          LOG.error(""String_Node_Str"" + t.getMessage());
        }
      }
    }
);
  }
}","public void disconnect(){
  if (mConnected.get()) {
    scheduledFuture.cancel(true);
    scheduledThreadPoolExecutor.shutdown();
    ApplicationManager.getApplication().executeOnPooledThread(new Runnable(){
      @Override public void run(){
        try {
          mWSClient.stop();
          mConnected.set(false);
        }
 catch (        InterruptedException e) {
          LOG.debug(""String_Node_Str"" + e);
        }
catch (        Throwable t) {
          LOG.error(""String_Node_Str"" + t.getMessage());
        }
      }
    }
);
  }
}",0.944713870029098
53077,"private void ping(){
  if ((new Date()).getTime() - mLastActionTime < PING_PERIOD) {
    return;
  }
  if (mConnected) {
    try {
      mWSSocket.sendMessage(""String_Node_Str"");
synchronized (syncObject) {
        mLastActionTime=(new Date()).getTime();
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"" + e);
    }
  }
}","private void ping(){
  if ((new Date()).getTime() - mLastActionTime < PING_PERIOD) {
    return;
  }
  if (mConnected.get()) {
    try {
      mWSSocket.sendMessage(""String_Node_Str"");
synchronized (syncObject) {
        mLastActionTime=(new Date()).getTime();
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"" + e);
    }
  }
}",0.9914285714285714
53078,"@Override public void run(){
  try {
    mWSClient.stop();
    mConnected=false;
  }
 catch (  InterruptedException e) {
    LOG.debug(""String_Node_Str"" + e);
  }
catch (  Throwable t) {
    LOG.error(""String_Node_Str"" + t.getMessage());
  }
}","@Override public void run(){
  try {
    mWSClient.stop();
    mConnected.set(false);
  }
 catch (  InterruptedException e) {
    LOG.debug(""String_Node_Str"" + e);
  }
catch (  Throwable t) {
    LOG.error(""String_Node_Str"" + t.getMessage());
  }
}",0.9857433808553973
53079,"public void connect(){
  if (mPort != -1) {
    try {
      mWSClient.start();
      URI uri=new URI(""String_Node_Str"" + mHost + ""String_Node_Str""+ mPort+ ""String_Node_Str"");
      mWSClient.connect(mWSSocket,uri);
synchronized (syncObject) {
        mLastActionTime=(new Date()).getTime();
      }
      mConnected=true;
      scheduledFuture=scheduledThreadPoolExecutor.scheduleAtFixedRate(new Runnable(){
        @Override public void run(){
          BuckClient.this.ping();
        }
      }
,10,10,TimeUnit.SECONDS);
    }
 catch (    Throwable t) {
      mConnected=false;
    }
  }
}","public void connect(){
  if (mPort != -1) {
    try {
      mWSClient.start();
      URI uri=new URI(""String_Node_Str"" + mHost + ""String_Node_Str""+ mPort+ ""String_Node_Str"");
      mWSClient.connect(mWSSocket,uri);
synchronized (syncObject) {
        mLastActionTime=(new Date()).getTime();
      }
      mConnected.set(true);
      if (scheduledFuture != null && !scheduledFuture.isCancelled()) {
        scheduledFuture.cancel(true);
      }
      scheduledFuture=scheduledThreadPoolExecutor.scheduleAtFixedRate(new Runnable(){
        @Override public void run(){
          BuckClient.this.ping();
        }
      }
,10,10,TimeUnit.SECONDS);
    }
 catch (    Throwable t) {
      mConnected.set(false);
    }
  }
}",0.8938120702826585
53080,"@Override public Optional<ImmutableSet<SourcePath>> getPossibleInputSourcePaths() throws IOException {
  Preconditions.checkState(useDependencyFileRuleKeys());
  return Optional.<ImmutableSet<SourcePath>>of(((JarArchiveDependencySupplier)abiClasspath).getArchiveMembers(getResolver()));
}","@Override public Optional<ImmutableSet<SourcePath>> getPossibleInputSourcePaths() throws IOException {
  return Optional.<ImmutableSet<SourcePath>>of(abiClasspath.getArchiveMembers(getResolver()));
}",0.8172484599589322
53081,"private DefaultJavaLibrary(BuildRuleParams params,final SourcePathResolver resolver,Set<? extends SourcePath> srcs,Set<? extends SourcePath> resources,Optional<Path> generatedSourceFolder,Optional<SourcePath> proguardConfig,ImmutableList<String> postprocessClassesCommands,ImmutableSortedSet<BuildRule> exportedDeps,ImmutableSortedSet<BuildRule> providedDeps,SourcePath abiJar,boolean trackClassUsage,final Supplier<ImmutableSortedSet<SourcePath>> abiClasspath,ImmutableSet<Path> additionalClasspathEntries,CompileToJarStepFactory compileStepFactory,Optional<Path> resourcesRoot,Optional<String> mavenCoords,ImmutableSortedSet<BuildTarget> tests){
  super(params.appendExtraDeps(new Supplier<Iterable<? extends BuildRule>>(){
    @Override public Iterable<? extends BuildRule> get(){
      return resolver.filterBuildRuleInputs(abiClasspath.get());
    }
  }
),resolver);
  this.compileStepFactory=compileStepFactory;
  for (  BuildRule dep : exportedDeps) {
    if (!(dep instanceof JavaLibrary)) {
      throw new HumanReadableException(params.getBuildTarget() + ""String_Node_Str"" + dep.getBuildTarget()+ ""String_Node_Str""+ dep.getType()+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  this.srcs=ImmutableSortedSet.copyOf(srcs);
  this.resources=ImmutableSortedSet.copyOf(resources);
  this.proguardConfig=proguardConfig;
  this.postprocessClassesCommands=postprocessClassesCommands;
  this.exportedDeps=exportedDeps;
  this.providedDeps=providedDeps;
  this.additionalClasspathEntries=FluentIterable.from(additionalClasspathEntries).transform(getProjectFilesystem().getAbsolutifier()).toSet();
  this.resourcesRoot=resourcesRoot;
  this.mavenCoords=mavenCoords;
  this.tests=tests;
  this.abiJar=abiJar;
  this.trackClassUsage=trackClassUsage;
  if (this.trackClassUsage) {
    this.abiClasspath=new JarArchiveDependencySupplier(abiClasspath,getProjectFilesystem());
  }
 else {
    this.abiClasspath=abiClasspath;
  }
  this.deps=params.getDeps();
  if (!srcs.isEmpty() || !resources.isEmpty()) {
    this.outputJar=Optional.of(getOutputJarPath(getBuildTarget(),getProjectFilesystem()));
  }
 else {
    this.outputJar=Optional.absent();
  }
  this.outputClasspathEntriesSupplier=Suppliers.memoize(new Supplier<ImmutableSetMultimap<JavaLibrary,Path>>(){
    @Override public ImmutableSetMultimap<JavaLibrary,Path> get(){
      return JavaLibraryClasspathProvider.getOutputClasspathEntries(DefaultJavaLibrary.this,getResolver(),sourcePathForOutputJar());
    }
  }
);
  this.transitiveClasspathEntriesSupplier=Suppliers.memoize(new Supplier<ImmutableSetMultimap<JavaLibrary,Path>>(){
    @Override public ImmutableSetMultimap<JavaLibrary,Path> get(){
      return JavaLibraryClasspathProvider.getTransitiveClasspathEntries(DefaultJavaLibrary.this,getResolver(),sourcePathForOutputJar());
    }
  }
);
  this.transitiveClasspathDepsSupplier=Suppliers.memoize(new Supplier<ImmutableSet<JavaLibrary>>(){
    @Override public ImmutableSet<JavaLibrary> get(){
      return JavaLibraryClasspathProvider.getTransitiveClasspathDeps(DefaultJavaLibrary.this,sourcePathForOutputJar());
    }
  }
);
  this.declaredClasspathEntriesSupplier=Suppliers.memoize(new Supplier<ImmutableSetMultimap<JavaLibrary,Path>>(){
    @Override public ImmutableSetMultimap<JavaLibrary,Path> get(){
      return JavaLibraryClasspathProvider.getDeclaredClasspathEntries(DefaultJavaLibrary.this);
    }
  }
);
  this.buildOutputInitializer=new BuildOutputInitializer<>(params.getBuildTarget(),this);
  this.generatedSourceFolder=generatedSourceFolder;
}","private DefaultJavaLibrary(BuildRuleParams params,final SourcePathResolver resolver,Set<? extends SourcePath> srcs,Set<? extends SourcePath> resources,Optional<Path> generatedSourceFolder,Optional<SourcePath> proguardConfig,ImmutableList<String> postprocessClassesCommands,ImmutableSortedSet<BuildRule> exportedDeps,ImmutableSortedSet<BuildRule> providedDeps,SourcePath abiJar,boolean trackClassUsage,final JarArchiveDependencySupplier abiClasspath,ImmutableSet<Path> additionalClasspathEntries,CompileToJarStepFactory compileStepFactory,Optional<Path> resourcesRoot,Optional<String> mavenCoords,ImmutableSortedSet<BuildTarget> tests){
  super(params.appendExtraDeps(new Supplier<Iterable<? extends BuildRule>>(){
    @Override public Iterable<? extends BuildRule> get(){
      return resolver.filterBuildRuleInputs(abiClasspath.get());
    }
  }
),resolver);
  this.compileStepFactory=compileStepFactory;
  for (  BuildRule dep : exportedDeps) {
    if (!(dep instanceof JavaLibrary)) {
      throw new HumanReadableException(params.getBuildTarget() + ""String_Node_Str"" + dep.getBuildTarget()+ ""String_Node_Str""+ dep.getType()+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  this.srcs=ImmutableSortedSet.copyOf(srcs);
  this.resources=ImmutableSortedSet.copyOf(resources);
  this.proguardConfig=proguardConfig;
  this.postprocessClassesCommands=postprocessClassesCommands;
  this.exportedDeps=exportedDeps;
  this.providedDeps=providedDeps;
  this.additionalClasspathEntries=FluentIterable.from(additionalClasspathEntries).transform(getProjectFilesystem().getAbsolutifier()).toSet();
  this.resourcesRoot=resourcesRoot;
  this.mavenCoords=mavenCoords;
  this.tests=tests;
  this.abiJar=abiJar;
  this.trackClassUsage=trackClassUsage;
  this.abiClasspath=abiClasspath;
  this.deps=params.getDeps();
  if (!srcs.isEmpty() || !resources.isEmpty()) {
    this.outputJar=Optional.of(getOutputJarPath(getBuildTarget(),getProjectFilesystem()));
  }
 else {
    this.outputJar=Optional.absent();
  }
  this.outputClasspathEntriesSupplier=Suppliers.memoize(new Supplier<ImmutableSetMultimap<JavaLibrary,Path>>(){
    @Override public ImmutableSetMultimap<JavaLibrary,Path> get(){
      return JavaLibraryClasspathProvider.getOutputClasspathEntries(DefaultJavaLibrary.this,getResolver(),sourcePathForOutputJar());
    }
  }
);
  this.transitiveClasspathEntriesSupplier=Suppliers.memoize(new Supplier<ImmutableSetMultimap<JavaLibrary,Path>>(){
    @Override public ImmutableSetMultimap<JavaLibrary,Path> get(){
      return JavaLibraryClasspathProvider.getTransitiveClasspathEntries(DefaultJavaLibrary.this,getResolver(),sourcePathForOutputJar());
    }
  }
);
  this.transitiveClasspathDepsSupplier=Suppliers.memoize(new Supplier<ImmutableSet<JavaLibrary>>(){
    @Override public ImmutableSet<JavaLibrary> get(){
      return JavaLibraryClasspathProvider.getTransitiveClasspathDeps(DefaultJavaLibrary.this,sourcePathForOutputJar());
    }
  }
);
  this.declaredClasspathEntriesSupplier=Suppliers.memoize(new Supplier<ImmutableSetMultimap<JavaLibrary,Path>>(){
    @Override public ImmutableSetMultimap<JavaLibrary,Path> get(){
      return JavaLibraryClasspathProvider.getDeclaredClasspathEntries(DefaultJavaLibrary.this);
    }
  }
);
  this.buildOutputInitializer=new BuildOutputInitializer<>(params.getBuildTarget(),this);
  this.generatedSourceFolder=generatedSourceFolder;
}",0.9662465594668984
53082,"public DefaultDependencyFileRuleKeyBuilderFactory(int seed,FileHashLoader fileHashLoader,SourcePathResolver pathResolver){
  super(seed,fileHashLoader,pathResolver,InputHandling.IGNORE);
  this.pathResolver=pathResolver;
}","public DefaultDependencyFileRuleKeyBuilderFactory(int seed,FileHashLoader fileHashLoader,SourcePathResolver pathResolver){
  super(seed,fileHashLoader,pathResolver,InputHandling.IGNORE,ArchiveHandling.MEMBERS);
  this.pathResolver=pathResolver;
}",0.9487179487179488
53083,"public InputBasedRuleKeyBuilderFactory(int seed,FileHashLoader hashLoader,SourcePathResolver pathResolver){
  this(seed,hashLoader,pathResolver,InputHandling.HASH);
}","public InputBasedRuleKeyBuilderFactory(int seed,FileHashLoader hashLoader,SourcePathResolver pathResolver){
  this(seed,hashLoader,pathResolver,InputHandling.HASH,ArchiveHandling.ARCHIVES);
}",0.9299719887955182
53084,"@Override public Builder setReflectively(String key,@Nullable Object val){
  if (val instanceof ArchiveDependencySupplier) {
    super.setReflectively(key,((ArchiveDependencySupplier)val).getArchiveMembers(pathResolver));
  }
 else {
    super.setReflectively(key,val);
  }
  return this;
}","@Override public Builder setReflectively(String key,@Nullable Object val){
  if (val instanceof ArchiveDependencySupplier && archiveHandling == ArchiveHandling.MEMBERS) {
    super.setReflectively(key,((ArchiveDependencySupplier)val).getArchiveMembers(pathResolver));
  }
 else {
    super.setReflectively(key,val);
  }
  return this;
}",0.926517571884984
53085,"@Override public void run(){
  FileTypeManager fileTypeManager=FileTypeManagerImpl.getInstance();
  FileType fileType=fileTypeManager.getFileTypeByFileName(BuckFileType.INSTANCE.getDefaultExtension());
  while (!(fileType instanceof BuckFileType || fileType instanceof UnknownFileType)) {
    List<FileNameMatcher> fileNameMatchers=fileTypeManager.getAssociations(fileType);
    for (    FileNameMatcher fileNameMatcher : fileNameMatchers) {
      if (fileNameMatcher.accept(BuckFileType.INSTANCE.getDefaultExtension())) {
        fileTypeManager.removeAssociation(fileType,fileNameMatcher);
      }
    }
    fileType=fileTypeManager.getFileTypeByFileName(BuckFileType.INSTANCE.getDefaultExtension());
  }
}","@Override public void run(){
  if (!mClient.isConnected()) {
    BuckWSServerPortUtils wsPortUtils=new BuckWSServerPortUtils();
    try {
      int port=wsPortUtils.getPort(BuckModule.this.mProject.getBasePath());
      mClient=new BuckClient(port,mEventHandler);
      BuckModule.this.mClient.connect();
    }
 catch (    NumberFormatException e) {
      LOG.error(e);
    }
catch (    ExecutionException e) {
      LOG.error(e);
    }
catch (    IOException e) {
      LOG.error(e);
    }
catch (    HumanReadableException e) {
      if (mBu == null) {
        attach(new BuckEventsConsumer(mProject),""String_Node_Str"");
      }
      mBu.consumeConsoleEvent(e.toString());
    }
  }
}",0.050179211469534
53086,"public void connect(){
  ApplicationManager.getApplication().executeOnPooledThread(new Runnable(){
    @Override public void run(){
      if (!mClient.isConnected()) {
        BuckWSServerPortUtils wsPortUtils=new BuckWSServerPortUtils();
        try {
          int port=wsPortUtils.getPort(BuckModule.this.mProject.getBasePath());
          mClient=new BuckClient(port,mEventHandler);
          BuckModule.this.mClient.connect();
        }
 catch (        NumberFormatException e) {
          LOG.error(e);
        }
catch (        ExecutionException e) {
          LOG.error(e);
        }
catch (        IOException e) {
          LOG.error(e);
        }
catch (        HumanReadableException e) {
          if (mBu == null) {
            attach(new BuckEventsConsumer(mProject),""String_Node_Str"");
          }
          mBu.consumeConsoleEvent(e.toString());
        }
      }
    }
  }
);
  ApplicationManager.getApplication().runWriteAction(new Runnable(){
    @Override public void run(){
      FileTypeManager fileTypeManager=FileTypeManagerImpl.getInstance();
      FileType fileType=fileTypeManager.getFileTypeByFileName(BuckFileType.INSTANCE.getDefaultExtension());
      while (!(fileType instanceof BuckFileType || fileType instanceof UnknownFileType)) {
        List<FileNameMatcher> fileNameMatchers=fileTypeManager.getAssociations(fileType);
        for (        FileNameMatcher fileNameMatcher : fileNameMatchers) {
          if (fileNameMatcher.accept(BuckFileType.INSTANCE.getDefaultExtension())) {
            fileTypeManager.removeAssociation(fileType,fileNameMatcher);
          }
        }
        fileType=fileTypeManager.getFileTypeByFileName(BuckFileType.INSTANCE.getDefaultExtension());
      }
    }
  }
);
}","public void connect(){
  ApplicationManager.getApplication().executeOnPooledThread(new Runnable(){
    @Override public void run(){
      if (!mClient.isConnected()) {
        BuckWSServerPortUtils wsPortUtils=new BuckWSServerPortUtils();
        try {
          int port=wsPortUtils.getPort(BuckModule.this.mProject.getBasePath());
          mClient=new BuckClient(port,mEventHandler);
          BuckModule.this.mClient.connect();
        }
 catch (        NumberFormatException e) {
          LOG.error(e);
        }
catch (        ExecutionException e) {
          LOG.error(e);
        }
catch (        IOException e) {
          LOG.error(e);
        }
catch (        HumanReadableException e) {
          if (mBu == null) {
            attach(new BuckEventsConsumer(mProject),""String_Node_Str"");
          }
          mBu.consumeConsoleEvent(e.toString());
        }
      }
    }
  }
);
  BuckFileUtil.setBuckFileType();
}",0.6791744840525328
53087,"public BuckModule(final Project project){
  mProject=project;
  mEventHandler=new BuckEventsHandler(new BuckEventsConsumerFactory(mProject),new Runnable(){
    @Override public void run(){
      ApplicationManager.getApplication().invokeLater(new Runnable(){
        @Override public void run(){
          BuckToolWindowFactory.outputConsoleMessage(project,""String_Node_Str"",ConsoleViewContentType.SYSTEM_OUTPUT);
        }
      }
);
    }
  }
,new Runnable(){
    @Override public void run(){
      ApplicationManager.getApplication().invokeLater(new Runnable(){
        @Override public void run(){
          BuckToolWindowFactory.outputConsoleMessage(project,""String_Node_Str"",ConsoleViewContentType.SYSTEM_OUTPUT);
        }
      }
);
      BuckModule mod=project.getComponent(BuckModule.class);
      mod.disconnect();
    }
  }
);
  if (!UISettings.getInstance().SHOW_MAIN_TOOLBAR) {
    BuckPluginNotifications.notifyActionToolbar(mProject);
  }
  mBuckEventsConsumer=new BuckEventsConsumer(project);
}","public BuckModule(final Project project){
  mProject=project;
  mEventHandler=new BuckEventsHandler(new BuckEventsConsumerFactory(mProject),new Runnable(){
    @Override public void run(){
      ApplicationManager.getApplication().invokeLater(new Runnable(){
        @Override public void run(){
          if (!project.isDisposed()) {
            BuckToolWindowFactory.outputConsoleMessage(project,""String_Node_Str"",ConsoleViewContentType.SYSTEM_OUTPUT);
          }
        }
      }
);
    }
  }
,new Runnable(){
    @Override public void run(){
      ApplicationManager.getApplication().invokeLater(new Runnable(){
        @Override public void run(){
          if (!project.isDisposed()) {
            BuckToolWindowFactory.outputConsoleMessage(project,""String_Node_Str"",ConsoleViewContentType.SYSTEM_OUTPUT);
          }
        }
      }
);
      BuckModule mod=project.getComponent(BuckModule.class);
      mod.disconnect();
    }
  }
);
  if (!UISettings.getInstance().SHOW_MAIN_TOOLBAR) {
    BuckPluginNotifications.notifyActionToolbar(mProject);
  }
  mBuckEventsConsumer=new BuckEventsConsumer(project);
}",0.950187969924812
53088,"public static PythonPackageComponents getAllComponents(BuildRuleParams params,BuildRuleResolver ruleResolver,SourcePathResolver pathResolver,final PythonPackageComponents packageComponents,final PythonPlatform pythonPlatform,CxxBuckConfig cxxBuckConfig,final CxxPlatform cxxPlatform,ImmutableList<? extends Arg> extraLdflags,final NativeLinkStrategy nativeLinkStrategy) throws NoSuchBuildTargetException {
  final PythonPackageComponents.Builder allComponents=new PythonPackageComponents.Builder(params.getBuildTarget());
  final Map<BuildTarget,CxxPythonExtension> extensions=new LinkedHashMap<>();
  final Map<BuildTarget,SharedNativeLinkTarget> nativeLinkTargetRoots=new LinkedHashMap<>();
  final Map<BuildTarget,NativeLinkable> nativeLinkableRoots=new LinkedHashMap<>();
  final Set<BuildTarget> excludedNativeLinkableRoots=new LinkedHashSet<>();
  allComponents.addComponent(packageComponents,params.getBuildTarget());
  new AbstractBreadthFirstThrowingTraversal<BuildRule,NoSuchBuildTargetException>(params.getDeps()){
    private final ImmutableList<BuildRule> empty=ImmutableList.of();
    @Override public Iterable<BuildRule> visit(    BuildRule rule) throws NoSuchBuildTargetException {
      Iterable<BuildRule> deps=empty;
      Optional<SharedNativeLinkTarget> linkTarget=nativeLinkStrategy == NativeLinkStrategy.MERGED ? NativeLinkables.getSharedNativeLinkTarget(rule,cxxPlatform) : Optional.<SharedNativeLinkTarget>absent();
      if (rule instanceof CxxPythonExtension) {
        extensions.put(rule.getBuildTarget(),(CxxPythonExtension)rule);
      }
 else       if (rule instanceof PythonPackagable) {
        PythonPackagable packagable=(PythonPackagable)rule;
        PythonPackageComponents comps=packagable.getPythonPackageComponents(pythonPlatform,cxxPlatform);
        allComponents.addComponent(comps,rule.getBuildTarget());
        if (hasNativeCode(cxxPlatform,comps)) {
          for (          BuildRule dep : rule.getDeps()) {
            if (dep instanceof NativeLinkable) {
              NativeLinkable linkable=(NativeLinkable)dep;
              excludedNativeLinkableRoots.add(linkable.getBuildTarget());
              nativeLinkableRoots.put(linkable.getBuildTarget(),linkable);
            }
          }
        }
        deps=rule.getDeps();
      }
 else       if (linkTarget.isPresent()) {
        nativeLinkTargetRoots.put(linkTarget.get().getBuildTarget(),linkTarget.get());
      }
 else       if (rule instanceof NativeLinkable) {
        nativeLinkableRoots.put(rule.getBuildTarget(),(NativeLinkable)rule);
      }
      return deps;
    }
  }
.start();
  if (nativeLinkStrategy == NativeLinkStrategy.MERGED) {
    Map<BuildTarget,SharedNativeLinkTarget> includedNativeLinkTargetRoots=new LinkedHashMap<>();
    for (    Map.Entry<BuildTarget,SharedNativeLinkTarget> ent : nativeLinkTargetRoots.entrySet()) {
      if (!excludedNativeLinkableRoots.contains(ent.getKey())) {
        includedNativeLinkTargetRoots.put(ent.getKey(),ent.getValue());
      }
    }
    Map<BuildTarget,CxxPythonExtension> includedExtensions=new LinkedHashMap<>();
    for (    CxxPythonExtension extension : extensions.values()) {
      SharedNativeLinkTarget target=extension.getNativeLinkTarget(pythonPlatform);
      includedExtensions.put(target.getBuildTarget(),extension);
      includedNativeLinkTargetRoots.put(target.getBuildTarget(),target);
    }
    OmnibusLibraries libraries=Omnibus.getSharedLibraries(params,ruleResolver,pathResolver,cxxBuckConfig,cxxPlatform,extraLdflags,includedNativeLinkTargetRoots.values(),Maps.filterKeys(nativeLinkableRoots,Predicates.not(Predicates.in(includedNativeLinkTargetRoots.keySet()))).values());
    for (    Map.Entry<BuildTarget,OmnibusRoot> root : libraries.getRoots().entrySet()) {
      CxxPythonExtension extension=includedExtensions.get(root.getKey());
      if (extension != null) {
        allComponents.addModule(extension.getModule(),root.getValue().getPath(),root.getKey());
      }
 else {
        String soname=Preconditions.checkNotNull(root.getValue().getSoname().orNull(),""String_Node_Str"",params.getBuildTarget(),root.getKey());
        allComponents.addNativeLibraries(Paths.get(soname),root.getValue().getPath(),root.getKey());
      }
    }
    for (    OmnibusLibrary library : libraries.getLibraries()) {
      allComponents.addNativeLibraries(Paths.get(library.getSoname()),library.getPath(),params.getBuildTarget());
    }
  }
 else {
    Map<BuildTarget,NativeLinkable> extensionNativeDeps=new LinkedHashMap<>();
    for (    Map.Entry<BuildTarget,CxxPythonExtension> entry : extensions.entrySet()) {
      allComponents.addComponent(entry.getValue().getPythonPackageComponents(pythonPlatform,cxxPlatform),entry.getKey());
      extensionNativeDeps.putAll(Maps.uniqueIndex(entry.getValue().getNativeLinkTarget(pythonPlatform).getSharedNativeLinkTargetDeps(cxxPlatform),HasBuildTarget.TO_TARGET));
    }
    ImmutableMap<BuildTarget,NativeLinkable> nativeLinkables=NativeLinkables.getTransitiveNativeLinkables(cxxPlatform,Iterables.concat(nativeLinkableRoots.values(),extensionNativeDeps.values()));
    for (    NativeLinkable nativeLinkable : nativeLinkables.values()) {
      NativeLinkable.Linkage linkage=nativeLinkable.getPreferredLinkage(cxxPlatform);
      if (nativeLinkableRoots.containsKey(nativeLinkable.getBuildTarget()) || linkage != NativeLinkable.Linkage.STATIC) {
        ImmutableMap<String,SourcePath> libs=nativeLinkable.getSharedLibraries(cxxPlatform);
        for (        Map.Entry<String,SourcePath> ent : libs.entrySet()) {
          allComponents.addNativeLibraries(Paths.get(ent.getKey()),ent.getValue(),nativeLinkable.getBuildTarget());
        }
      }
    }
  }
  return allComponents.build();
}","public static PythonPackageComponents getAllComponents(BuildRuleParams params,BuildRuleResolver ruleResolver,SourcePathResolver pathResolver,final PythonPackageComponents packageComponents,final PythonPlatform pythonPlatform,CxxBuckConfig cxxBuckConfig,final CxxPlatform cxxPlatform,ImmutableList<? extends Arg> extraLdflags,final NativeLinkStrategy nativeLinkStrategy) throws NoSuchBuildTargetException {
  final PythonPackageComponents.Builder allComponents=new PythonPackageComponents.Builder(params.getBuildTarget());
  final Map<BuildTarget,CxxPythonExtension> extensions=new LinkedHashMap<>();
  final Map<BuildTarget,SharedNativeLinkTarget> nativeLinkTargetRoots=new LinkedHashMap<>();
  final Map<BuildTarget,NativeLinkable> nativeLinkableRoots=new LinkedHashMap<>();
  final Set<BuildTarget> excludedNativeLinkableRoots=new LinkedHashSet<>();
  allComponents.addComponent(packageComponents,params.getBuildTarget());
  new AbstractBreadthFirstThrowingTraversal<BuildRule,NoSuchBuildTargetException>(params.getDeps()){
    private final ImmutableList<BuildRule> empty=ImmutableList.of();
    @Override public Iterable<BuildRule> visit(    BuildRule rule) throws NoSuchBuildTargetException {
      Iterable<BuildRule> deps=empty;
      Optional<SharedNativeLinkTarget> linkTarget=nativeLinkStrategy == NativeLinkStrategy.MERGED ? NativeLinkables.getSharedNativeLinkTarget(rule,cxxPlatform) : Optional.<SharedNativeLinkTarget>absent();
      if (rule instanceof CxxPythonExtension) {
        extensions.put(rule.getBuildTarget(),(CxxPythonExtension)rule);
      }
 else       if (rule instanceof PythonPackagable) {
        PythonPackagable packagable=(PythonPackagable)rule;
        PythonPackageComponents comps=packagable.getPythonPackageComponents(pythonPlatform,cxxPlatform);
        allComponents.addComponent(comps,rule.getBuildTarget());
        if (hasNativeCode(cxxPlatform,comps)) {
          for (          BuildRule dep : rule.getDeps()) {
            if (dep instanceof NativeLinkable) {
              NativeLinkable linkable=(NativeLinkable)dep;
              excludedNativeLinkableRoots.add(linkable.getBuildTarget());
              nativeLinkableRoots.put(linkable.getBuildTarget(),linkable);
            }
          }
        }
        deps=rule.getDeps();
      }
 else       if (linkTarget.isPresent()) {
        nativeLinkTargetRoots.put(linkTarget.get().getBuildTarget(),linkTarget.get());
      }
 else       if (rule instanceof NativeLinkable) {
        nativeLinkableRoots.put(rule.getBuildTarget(),(NativeLinkable)rule);
      }
      return deps;
    }
  }
.start();
  if (nativeLinkStrategy == NativeLinkStrategy.MERGED) {
    final Set<BuildTarget> transitivelyExcludedNativeLinkables=new HashSet<>();
    new AbstractBreadthFirstTraversal<NativeLinkable>(Iterables.transform(excludedNativeLinkableRoots,Functions.forMap(nativeLinkableRoots))){
      @Override public Iterable<NativeLinkable> visit(      NativeLinkable linkable){
        transitivelyExcludedNativeLinkables.add(linkable.getBuildTarget());
        return Iterables.concat(linkable.getNativeLinkableDeps(cxxPlatform),linkable.getNativeLinkableExportedDeps(cxxPlatform));
      }
    }
.start();
    Map<BuildTarget,SharedNativeLinkTarget> includedNativeLinkTargetRoots=new LinkedHashMap<>();
    for (    Map.Entry<BuildTarget,SharedNativeLinkTarget> ent : nativeLinkTargetRoots.entrySet()) {
      if (!transitivelyExcludedNativeLinkables.contains(ent.getKey())) {
        includedNativeLinkTargetRoots.put(ent.getKey(),ent.getValue());
      }
    }
    Map<BuildTarget,CxxPythonExtension> includedExtensions=new LinkedHashMap<>();
    for (    CxxPythonExtension extension : extensions.values()) {
      SharedNativeLinkTarget target=extension.getNativeLinkTarget(pythonPlatform);
      includedExtensions.put(target.getBuildTarget(),extension);
      includedNativeLinkTargetRoots.put(target.getBuildTarget(),target);
    }
    OmnibusLibraries libraries=Omnibus.getSharedLibraries(params,ruleResolver,pathResolver,cxxBuckConfig,cxxPlatform,extraLdflags,includedNativeLinkTargetRoots.values(),Maps.filterKeys(nativeLinkableRoots,Predicates.not(Predicates.in(includedNativeLinkTargetRoots.keySet()))).values());
    for (    Map.Entry<BuildTarget,OmnibusRoot> root : libraries.getRoots().entrySet()) {
      CxxPythonExtension extension=includedExtensions.get(root.getKey());
      if (extension != null) {
        allComponents.addModule(extension.getModule(),root.getValue().getPath(),root.getKey());
      }
 else {
        String soname=Preconditions.checkNotNull(root.getValue().getSoname().orNull(),""String_Node_Str"",params.getBuildTarget(),root.getKey());
        allComponents.addNativeLibraries(Paths.get(soname),root.getValue().getPath(),root.getKey());
      }
    }
    for (    OmnibusLibrary library : libraries.getLibraries()) {
      allComponents.addNativeLibraries(Paths.get(library.getSoname()),library.getPath(),params.getBuildTarget());
    }
  }
 else {
    Map<BuildTarget,NativeLinkable> extensionNativeDeps=new LinkedHashMap<>();
    for (    Map.Entry<BuildTarget,CxxPythonExtension> entry : extensions.entrySet()) {
      allComponents.addComponent(entry.getValue().getPythonPackageComponents(pythonPlatform,cxxPlatform),entry.getKey());
      extensionNativeDeps.putAll(Maps.uniqueIndex(entry.getValue().getNativeLinkTarget(pythonPlatform).getSharedNativeLinkTargetDeps(cxxPlatform),HasBuildTarget.TO_TARGET));
    }
    ImmutableMap<BuildTarget,NativeLinkable> nativeLinkables=NativeLinkables.getTransitiveNativeLinkables(cxxPlatform,Iterables.concat(nativeLinkableRoots.values(),extensionNativeDeps.values()));
    for (    NativeLinkable nativeLinkable : nativeLinkables.values()) {
      NativeLinkable.Linkage linkage=nativeLinkable.getPreferredLinkage(cxxPlatform);
      if (nativeLinkableRoots.containsKey(nativeLinkable.getBuildTarget()) || linkage != NativeLinkable.Linkage.STATIC) {
        ImmutableMap<String,SourcePath> libs=nativeLinkable.getSharedLibraries(cxxPlatform);
        for (        Map.Entry<String,SourcePath> ent : libs.entrySet()) {
          allComponents.addNativeLibraries(Paths.get(ent.getKey()),ent.getValue(),nativeLinkable.getBuildTarget());
        }
      }
    }
  }
  return allComponents.build();
}",0.9535562411406654
53089,"@Override public Iterable<BuildRule> visit(BuildRule rule) throws NoSuchBuildTargetException {
  Iterable<BuildRule> deps=empty;
  Optional<SharedNativeLinkTarget> linkTarget=nativeLinkStrategy == NativeLinkStrategy.MERGED ? NativeLinkables.getSharedNativeLinkTarget(rule,cxxPlatform) : Optional.<SharedNativeLinkTarget>absent();
  if (rule instanceof CxxPythonExtension) {
    extensions.put(rule.getBuildTarget(),(CxxPythonExtension)rule);
  }
 else   if (rule instanceof PythonPackagable) {
    PythonPackagable packagable=(PythonPackagable)rule;
    PythonPackageComponents comps=packagable.getPythonPackageComponents(pythonPlatform,cxxPlatform);
    allComponents.addComponent(comps,rule.getBuildTarget());
    if (hasNativeCode(cxxPlatform,comps)) {
      for (      BuildRule dep : rule.getDeps()) {
        if (dep instanceof NativeLinkable) {
          NativeLinkable linkable=(NativeLinkable)dep;
          excludedNativeLinkableRoots.add(linkable.getBuildTarget());
          nativeLinkableRoots.put(linkable.getBuildTarget(),linkable);
        }
      }
    }
    deps=rule.getDeps();
  }
 else   if (linkTarget.isPresent()) {
    nativeLinkTargetRoots.put(linkTarget.get().getBuildTarget(),linkTarget.get());
  }
 else   if (rule instanceof NativeLinkable) {
    nativeLinkableRoots.put(rule.getBuildTarget(),(NativeLinkable)rule);
  }
  return deps;
}","@Override public Iterable<NativeLinkable> visit(NativeLinkable linkable){
  transitivelyExcludedNativeLinkables.add(linkable.getBuildTarget());
  return Iterables.concat(linkable.getNativeLinkableDeps(cxxPlatform),linkable.getNativeLinkableExportedDeps(cxxPlatform));
}",0.0807833537331701
53090,"public IjFolder merge(IjFolder otherFolder){
  if (!canMergeWith(otherFolder)) {
    throw new IllegalArgumentException(""String_Node_Str"" + this.getClass().getSimpleName() + ""String_Node_Str""+ otherFolder.getClass().getSimpleName());
  }
  if (equals(otherFolder)) {
    return this;
  }
  return getFactory().create(otherFolder.getPath(),getWantsPackagePrefix() || otherFolder.getWantsPackagePrefix(),combineInputs(this,otherFolder));
}","public IjFolder merge(IjFolder otherFolder){
  if (equals(otherFolder)) {
    return this;
  }
  return getFactory().create(otherFolder.getPath(),getWantsPackagePrefix() || otherFolder.getWantsPackagePrefix(),combineInputs(this,otherFolder));
}",0.7165932452276065
53091,"@Override public String toString(){
  return getClass().getSimpleName() + ""String_Node_Str"" + getPath().toString();
}","@Override public String toString(){
  return getClass().getSimpleName() + ""String_Node_Str"" + getPath().toString()+ (wantsPackagePrefix ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ getInputs();
}",0.7134146341463414
53092,"private IjFolder mergeAllowingTestToBePromotedToSource(IjFolder from,IjFolder to){
  if ((from instanceof TestFolder && to instanceof SourceFolder) || (to instanceof TestFolder && from instanceof SourceFolder)) {
    return new SourceFolder(to.getPath(),from.getWantsPackagePrefix() || to.getWantsPackagePrefix(),IjFolder.combineInputs(from,to));
  }
  return from.merge(to);
}","private IjFolder mergeAllowingTestToBePromotedToSource(IjFolder from,IjFolder to){
  if ((from instanceof TestFolder && to instanceof SourceFolder) || (to instanceof TestFolder && from instanceof SourceFolder)) {
    return new SourceFolder(to.getPath(),from.getWantsPackagePrefix() || to.getWantsPackagePrefix(),IjFolder.combineInputs(from,to));
  }
  Preconditions.checkArgument(from.getClass() == to.getClass());
  return from.merge(to);
}",0.8717948717948718
53093,"private BuckTracing(BuckTracingInterface tracingInterface,String pluginName){
  this.tracingInterface=tracingInterface;
  this.pluginName=pluginName;
}","private BuckTracing(String pluginName){
  this.pluginName=pluginName;
}",0.6396396396396397
53094,"/** 
 * Records the end of the traced section started by the most recent call to  {@link #begin(String,Map)}, on <em>any</em>   {@link BuckTracing} object, on the current thread.Arguments supplied here will be added to those supplied to  {@link #begin(String,Map)}; conflicting entries will be overwritten. For best results, this call should be in a finally block, with the corresponding  {@link #begin(String,Map)} call immediately before the try.
 */
public void end(final Map<String,String> args){
  if (tracingInterface == null) {
    return;
  }
  tracingInterface.end(args);
}","/** 
 * Records the end of the traced section started by the most recent call to  {@link #begin(String,Map)}, on <em>any</em>   {@link BuckTracing} object, on the current thread.Arguments supplied here will be added to those supplied to  {@link #begin(String,Map)}; conflicting entries will be overwritten. For best results, this call should be in a finally block, with the corresponding  {@link #begin(String,Map)} call immediately before the try.
 */
public void end(final Map<String,String> args){
  final BuckTracingInterface tracingInterface=curThreadTracingInterface.get();
  if (tracingInterface == null) {
    return;
  }
  tracingInterface.end(args);
}",0.9364440868865648
53095,"/** 
 * Gets an instance of   {@link BuckTracing} for tracing in the given plugin. All{@link BuckTracing} instances are backed by the same trace buffer, so{@link #begin(String,Map)} and {@link #end(Map)}} calls on a given thread must nest across all instances.
 */
public static BuckTracing getInstance(String pluginName){
  return new BuckTracing(curThreadTracingInterface.get(),pluginName);
}","/** 
 * Gets an instance of   {@link BuckTracing} for tracing in the given plugin. All{@link BuckTracing} instances are backed by the same trace buffer, so{@link #begin(String,Map)} and {@link #end(Map)}} calls on a given thread must nest across all instances.
 */
public static BuckTracing getInstance(String pluginName){
  return new BuckTracing(pluginName);
}",0.9576719576719576
53096,"/** 
 * Records the beginning of a traced section. The section will appear in the trace labeled with eventName, and the supplied arguments will be visible when the section is selected. For best results, this call should be immediately before a try block, and a corresponding call to   {@link #end(Map)} should be in the finally block.
 */
public void begin(final String eventName,final Map<String,String> args){
  if (tracingInterface == null) {
    return;
  }
  tracingInterface.begin(pluginName,eventName,args);
}","/** 
 * Records the beginning of a traced section. The section will appear in the trace labeled with eventName, and the supplied arguments will be visible when the section is selected. For best results, this call should be immediately before a try block, and a corresponding call to   {@link #end(Map)} should be in the finally block.
 */
public void begin(final String eventName,final Map<String,String> args){
  final BuckTracingInterface tracingInterface=curThreadTracingInterface.get();
  if (tracingInterface == null) {
    return;
  }
  tracingInterface.begin(pluginName,eventName,args);
}",0.9288928892889288
53097,"public static JavacOptions.Builder builder(JavacOptions options){
  Preconditions.checkNotNull(options);
  JavacOptions.Builder builder=JavacOptions.builder();
  builder.setVerbose(options.isVerbose());
  builder.setProductionBuild(options.isProductionBuild());
  builder.setJavacPath(options.getJavacPath());
  builder.setJavacJarPath(options.getJavacJarPath());
  builder.setSpoolMode(options.getSpoolMode());
  builder.setAnnotationProcessingParams(options.getAnnotationProcessingParams());
  builder.putAllSourceToBootclasspath(options.getSourceToBootclasspath());
  builder.setBootclasspath(options.getBootclasspath());
  builder.setSourceLevel(options.getSourceLevel());
  builder.setTargetLevel(options.getTargetLevel());
  builder.addAllExtraArguments(options.getExtraArguments());
  return builder;
}","public static JavacOptions.Builder builder(JavacOptions options){
  Preconditions.checkNotNull(options);
  JavacOptions.Builder builder=JavacOptions.builder();
  builder.setVerbose(options.isVerbose());
  builder.setProductionBuild(options.isProductionBuild());
  builder.setJavacPath(options.getJavacPath());
  builder.setJavacJarPath(options.getJavacJarPath());
  builder.setSpoolMode(options.getSpoolMode());
  builder.setAnnotationProcessingParams(options.getAnnotationProcessingParams());
  builder.setSafeAnnotationProcessors(options.getSafeAnnotationProcessors());
  builder.putAllSourceToBootclasspath(options.getSourceToBootclasspath());
  builder.setBootclasspath(options.getBootclasspath());
  builder.setSourceLevel(options.getSourceLevel());
  builder.setTargetLevel(options.getTargetLevel());
  builder.addAllExtraArguments(options.getExtraArguments());
  return builder;
}",0.954009433962264
53098,"@Override public int buildWithClasspath(ExecutionContext context,ProjectFilesystem filesystem,SourcePathResolver resolver,BuildTarget invokingRule,ImmutableList<String> options,ImmutableSortedSet<Path> javaSourceFilePaths,Path pathToSrcsList,Optional<Path> workingDirectory,Optional<Path> usedClassesFile,Optional<StandardJavaFileManagerFactory> fileManagerFactory) throws InterruptedException {
  ImmutableList.Builder<String> command=ImmutableList.builder();
  command.add(pathToJavac.toString());
  command.addAll(options);
  ImmutableList<Path> expandedSources;
  try {
    expandedSources=getExpandedSourcePaths(filesystem,invokingRule,javaSourceFilePaths,workingDirectory);
  }
 catch (  IOException e) {
    throw new HumanReadableException(""String_Node_Str"",invokingRule,workingDirectory);
  }
  try {
    filesystem.writeLinesToPath(FluentIterable.from(expandedSources).transform(Functions.toStringFunction()).transform(ARGFILES_ESCAPER),pathToSrcsList);
    command.add(""String_Node_Str"" + pathToSrcsList);
  }
 catch (  IOException e) {
    context.logError(e,""String_Node_Str"",pathToSrcsList);
    return 1;
  }
  ProcessBuilder processBuilder=new ProcessBuilder(command.build());
  Map<String,String> env=processBuilder.environment();
  env.clear();
  env.putAll(context.getEnvironment());
  processBuilder.directory(filesystem.getRootPath().toAbsolutePath().toFile());
  int exitCode=-1;
  try {
    Process p=BgProcessKiller.startProcess(processBuilder);
    ProcessExecutor.Result result=context.getProcessExecutor().execute(p);
    exitCode=result.getExitCode();
  }
 catch (  IOException e) {
    e.printStackTrace(context.getStdErr());
    return exitCode;
  }
  return exitCode;
}","@Override public int buildWithClasspath(ExecutionContext context,ProjectFilesystem filesystem,SourcePathResolver resolver,BuildTarget invokingRule,ImmutableList<String> options,ImmutableSet<String> safeAnnotationProcessors,ImmutableSortedSet<Path> javaSourceFilePaths,Path pathToSrcsList,Optional<Path> workingDirectory,Optional<Path> usedClassesFile,Optional<StandardJavaFileManagerFactory> fileManagerFactory) throws InterruptedException {
  ImmutableList.Builder<String> command=ImmutableList.builder();
  command.add(pathToJavac.toString());
  command.addAll(options);
  ImmutableList<Path> expandedSources;
  try {
    expandedSources=getExpandedSourcePaths(filesystem,invokingRule,javaSourceFilePaths,workingDirectory);
  }
 catch (  IOException e) {
    throw new HumanReadableException(""String_Node_Str"",invokingRule,workingDirectory);
  }
  try {
    filesystem.writeLinesToPath(FluentIterable.from(expandedSources).transform(Functions.toStringFunction()).transform(ARGFILES_ESCAPER),pathToSrcsList);
    command.add(""String_Node_Str"" + pathToSrcsList);
  }
 catch (  IOException e) {
    context.logError(e,""String_Node_Str"",pathToSrcsList);
    return 1;
  }
  ProcessBuilder processBuilder=new ProcessBuilder(command.build());
  Map<String,String> env=processBuilder.environment();
  env.clear();
  env.putAll(context.getEnvironment());
  processBuilder.directory(filesystem.getRootPath().toAbsolutePath().toFile());
  int exitCode=-1;
  try {
    Process p=BgProcessKiller.startProcess(processBuilder);
    ProcessExecutor.Result result=context.getProcessExecutor().execute(p);
    exitCode=result.getExitCode();
  }
 catch (  IOException e) {
    e.printStackTrace(context.getStdErr());
    return exitCode;
  }
  return exitCode;
}",0.9866511897852582
53099,"public JavacOptions getDefaultJavacOptions(){
  Optional<String> sourceLevel=delegate.getValue(""String_Node_Str"",""String_Node_Str"");
  Optional<String> targetLevel=delegate.getValue(""String_Node_Str"",""String_Node_Str"");
  ImmutableList<String> extraArguments=delegate.getListWithoutComments(""String_Node_Str"",""String_Node_Str"");
  AbstractJavacOptions.SpoolMode spoolMode=delegate.getEnum(""String_Node_Str"",""String_Node_Str"",AbstractJavacOptions.SpoolMode.class).or(AbstractJavacOptions.SpoolMode.INTERMEDIATE_TO_DISK);
  ImmutableMap<String,String> allEntries=delegate.getEntriesForSection(""String_Node_Str"");
  ImmutableMap.Builder<String,String> bootclasspaths=ImmutableMap.builder();
  for (  Map.Entry<String,String> entry : allEntries.entrySet()) {
    if (entry.getKey().startsWith(""String_Node_Str"")) {
      bootclasspaths.put(entry.getKey().substring(""String_Node_Str"".length()),entry.getValue());
    }
  }
  return JavacOptions.builderForUseInJavaBuckConfig().setJavacPath(getJavacPath()).setJavacJarPath(getJavacJarPath()).setSourceLevel(sourceLevel.or(TARGETED_JAVA_VERSION)).setTargetLevel(targetLevel.or(TARGETED_JAVA_VERSION)).setSpoolMode(spoolMode).putAllSourceToBootclasspath(bootclasspaths.build()).addAllExtraArguments(extraArguments).build();
}","public JavacOptions getDefaultJavacOptions(){
  Optional<String> sourceLevel=delegate.getValue(""String_Node_Str"",""String_Node_Str"");
  Optional<String> targetLevel=delegate.getValue(""String_Node_Str"",""String_Node_Str"");
  ImmutableList<String> extraArguments=delegate.getListWithoutComments(""String_Node_Str"",""String_Node_Str"");
  ImmutableList<String> safeAnnotationProcessors=delegate.getListWithoutComments(""String_Node_Str"",""String_Node_Str"");
  AbstractJavacOptions.SpoolMode spoolMode=delegate.getEnum(""String_Node_Str"",""String_Node_Str"",AbstractJavacOptions.SpoolMode.class).or(AbstractJavacOptions.SpoolMode.INTERMEDIATE_TO_DISK);
  ImmutableMap<String,String> allEntries=delegate.getEntriesForSection(""String_Node_Str"");
  ImmutableMap.Builder<String,String> bootclasspaths=ImmutableMap.builder();
  for (  Map.Entry<String,String> entry : allEntries.entrySet()) {
    if (entry.getKey().startsWith(""String_Node_Str"")) {
      bootclasspaths.put(entry.getKey().substring(""String_Node_Str"".length()),entry.getValue());
    }
  }
  return JavacOptions.builderForUseInJavaBuckConfig().setJavacPath(getJavacPath()).setJavacJarPath(getJavacJarPath()).setSourceLevel(sourceLevel.or(TARGETED_JAVA_VERSION)).setTargetLevel(targetLevel.or(TARGETED_JAVA_VERSION)).setSpoolMode(spoolMode).putAllSourceToBootclasspath(bootclasspaths.build()).addAllExtraArguments(extraArguments).setSafeAnnotationProcessors(safeAnnotationProcessors).build();
}",0.9360916143332102
53100,"int buildWithClasspath(ExecutionContext context,ProjectFilesystem filesystem,SourcePathResolver resolver,BuildTarget invokingRule,ImmutableList<String> options,ImmutableSortedSet<Path> javaSourceFilePaths,Path pathToSrcsList,Optional<Path> workingDirectory,Optional<Path> usedClassesFile,Optional<StandardJavaFileManagerFactory> fileManagerFactory) throws InterruptedException ;","int buildWithClasspath(ExecutionContext context,ProjectFilesystem filesystem,SourcePathResolver resolver,BuildTarget invokingRule,ImmutableList<String> options,ImmutableSet<String> safeAnnotationProcessors,ImmutableSortedSet<Path> javaSourceFilePaths,Path pathToSrcsList,Optional<Path> workingDirectory,Optional<Path> usedClassesFile,Optional<StandardJavaFileManagerFactory> fileManagerFactory) throws InterruptedException ;",0.942643391521197
53101,"private int tryBuildWithFirstOrderDeps(ExecutionContext context,ProjectFilesystem filesystem) throws InterruptedException, IOException {
  Verbosity verbosity=context.getVerbosity().isSilent() ? Verbosity.STANDARD_INFORMATION : context.getVerbosity();
  try (CapturingPrintStream stdout=new CapturingPrintStream();CapturingPrintStream stderr=new CapturingPrintStream();ExecutionContext firstOrderContext=context.createSubContext(stdout,stderr,Optional.of(verbosity))){
    Javac javac=getJavac();
    int declaredDepsResult=javac.buildWithClasspath(firstOrderContext,filesystem,resolver,invokingRule,getOptions(context,declaredClasspathEntries),javaSourceFilePaths,pathToSrcsList,workingDirectory,usedClassesFile,fileManagerFactory);
    String firstOrderStdout=stdout.getContentsAsString(Charsets.UTF_8);
    String firstOrderStderr=stderr.getContentsAsString(Charsets.UTF_8);
    if (declaredDepsResult != 0) {
      ImmutableList.Builder<String> errorMessage=ImmutableList.builder();
      errorMessage.add(firstOrderStderr);
      if (suggestBuildRules.isPresent()) {
        ImmutableSet<String> failedImports=findFailedImports(firstOrderStderr);
        ImmutableSet<String> suggestions=suggestBuildRules.get().suggest(failedImports);
        if (!suggestions.isEmpty()) {
          String invoker=invokingRule.toString();
          errorMessage.add(String.format(""String_Node_Str"",invoker));
          errorMessage.add(Joiner.on(LINE_SEPARATOR).join(failedImports));
          errorMessage.add(""String_Node_Str"");
          errorMessage.add(Joiner.on(LINE_SEPARATOR).join(suggestions));
          errorMessage.add(""String_Node_Str"");
          errorMessage.add(""String_Node_Str"");
        }
        CompilerErrorEvent evt=CompilerErrorEvent.create(invokingRule,firstOrderStderr,CompilerErrorEvent.CompilerType.Java,suggestions);
        context.postEvent(evt);
      }
 else {
        ImmutableSet<String> suggestions=ImmutableSet.of();
        CompilerErrorEvent evt=CompilerErrorEvent.create(invokingRule,firstOrderStderr,CompilerErrorEvent.CompilerType.Java,suggestions);
        context.postEvent(evt);
      }
      if (!context.getVerbosity().isSilent()) {
        context.getStdOut().print(firstOrderStdout);
        context.getStdErr().println(Joiner.on(""String_Node_Str"").join(errorMessage.build()));
      }
    }
    return declaredDepsResult;
  }
 }","private int tryBuildWithFirstOrderDeps(ExecutionContext context,ProjectFilesystem filesystem) throws InterruptedException, IOException {
  Verbosity verbosity=context.getVerbosity().isSilent() ? Verbosity.STANDARD_INFORMATION : context.getVerbosity();
  try (CapturingPrintStream stdout=new CapturingPrintStream();CapturingPrintStream stderr=new CapturingPrintStream();ExecutionContext firstOrderContext=context.createSubContext(stdout,stderr,Optional.of(verbosity))){
    Javac javac=getJavac();
    int declaredDepsResult=javac.buildWithClasspath(firstOrderContext,filesystem,resolver,invokingRule,getOptions(context,declaredClasspathEntries),javacOptions.getSafeAnnotationProcessors(),javaSourceFilePaths,pathToSrcsList,workingDirectory,usedClassesFile,fileManagerFactory);
    String firstOrderStdout=stdout.getContentsAsString(Charsets.UTF_8);
    String firstOrderStderr=stderr.getContentsAsString(Charsets.UTF_8);
    if (declaredDepsResult != 0) {
      ImmutableList.Builder<String> errorMessage=ImmutableList.builder();
      errorMessage.add(firstOrderStderr);
      if (suggestBuildRules.isPresent()) {
        ImmutableSet<String> failedImports=findFailedImports(firstOrderStderr);
        ImmutableSet<String> suggestions=suggestBuildRules.get().suggest(failedImports);
        if (!suggestions.isEmpty()) {
          String invoker=invokingRule.toString();
          errorMessage.add(String.format(""String_Node_Str"",invoker));
          errorMessage.add(Joiner.on(LINE_SEPARATOR).join(failedImports));
          errorMessage.add(""String_Node_Str"");
          errorMessage.add(Joiner.on(LINE_SEPARATOR).join(suggestions));
          errorMessage.add(""String_Node_Str"");
          errorMessage.add(""String_Node_Str"");
        }
        CompilerErrorEvent evt=CompilerErrorEvent.create(invokingRule,firstOrderStderr,CompilerErrorEvent.CompilerType.Java,suggestions);
        context.postEvent(evt);
      }
 else {
        ImmutableSet<String> suggestions=ImmutableSet.of();
        CompilerErrorEvent evt=CompilerErrorEvent.create(invokingRule,firstOrderStderr,CompilerErrorEvent.CompilerType.Java,suggestions);
        context.postEvent(evt);
      }
      if (!context.getVerbosity().isSilent()) {
        context.getStdOut().print(firstOrderStdout);
        context.getStdErr().println(Joiner.on(""String_Node_Str"").join(errorMessage.build()));
      }
    }
    return declaredDepsResult;
  }
 }",0.9910023017367652
53102,"private int buildWithClasspath(ExecutionContext context,ProjectFilesystem filesystem,BuildTarget invokingRule,ImmutableList<String> options,ImmutableSortedSet<Path> javaSourceFilePaths,Path pathToSrcsList,JavaCompiler compiler,Optional<Path> usedClassesFile,StandardJavaFileManager fileManager,Iterable<? extends JavaFileObject> compilationUnits){
  try {
    filesystem.writeLinesToPath(FluentIterable.from(javaSourceFilePaths).transform(Functions.toStringFunction()).transform(ARGFILES_ESCAPER),pathToSrcsList);
  }
 catch (  IOException e) {
    context.logError(e,""String_Node_Str"",pathToSrcsList);
    return 1;
  }
  DiagnosticCollector<JavaFileObject> diagnostics=new DiagnosticCollector<>();
  List<String> classNamesForAnnotationProcessing=ImmutableList.of();
  Writer compilerOutputWriter=new PrintWriter(context.getStdErr());
  ClassUsageTracker classTracker=new ClassUsageTracker();
  final StandardJavaFileManager maybeWrappedFileManager=usedClassesFile.isPresent() ? classTracker.wrapFileManager(fileManager) : fileManager;
  JavaCompiler.CompilationTask compilationTask=compiler.getTask(compilerOutputWriter,maybeWrappedFileManager,diagnostics,options,classNamesForAnnotationProcessing,compilationUnits);
  boolean isSuccess=false;
  BuckTracing.setCurrentThreadTracingInterfaceFromJsr199Javac(new BuckTracingEventBusBridge(context.getBuckEventBus(),invokingRule));
  try {
    try (TranslatingJavacPhaseTracer tracer=TranslatingJavacPhaseTracer.setupTracing(invokingRule,context.getClassLoaderCache(),context.getBuckEventBus(),compilationTask);ProcessorBundle bundle=prepareProcessors(context.getBuckEventBus(),compiler.getClass().getClassLoader(),invokingRule,options)){
      compilationTask.setProcessors(bundle.processors);
      isSuccess=compilationTask.call();
    }
 catch (    IOException e) {
      LOG.warn(e,""String_Node_Str"");
    }
  }
  finally {
    BuckTracing.clearCurrentThreadTracingInterfaceFromJsr199Javac();
  }
  for (  Diagnostic<? extends JavaFileObject> diagnostic : diagnostics.getDiagnostics()) {
    LOG.debug(""String_Node_Str"",DiagnosticPrettyPrinter.format(diagnostic));
  }
  if (isSuccess) {
    if (usedClassesFile.isPresent()) {
      ClassUsageFile.writeFromTrackerData(filesystem,filesystem.resolve(usedClassesFile.get()),classTracker,context.getObjectMapper());
    }
    return 0;
  }
 else {
    if (context.getVerbosity().shouldPrintStandardInformation()) {
      int numErrors=0;
      int numWarnings=0;
      for (      Diagnostic<? extends JavaFileObject> diagnostic : diagnostics.getDiagnostics()) {
        Diagnostic.Kind kind=diagnostic.getKind();
        if (kind == Diagnostic.Kind.ERROR) {
          ++numErrors;
          handleMissingSymbolError(invokingRule,diagnostic,context,filesystem);
        }
 else         if (kind == Diagnostic.Kind.WARNING || kind == Diagnostic.Kind.MANDATORY_WARNING) {
          ++numWarnings;
        }
        context.getStdErr().println(DiagnosticPrettyPrinter.format(diagnostic));
      }
      if (numErrors > 0 || numWarnings > 0) {
        context.getStdErr().printf(""String_Node_Str"",numErrors,numWarnings);
      }
    }
    return 1;
  }
}","private int buildWithClasspath(ExecutionContext context,ProjectFilesystem filesystem,BuildTarget invokingRule,ImmutableList<String> options,ImmutableSet<String> safeAnnotationProcessors,ImmutableSortedSet<Path> javaSourceFilePaths,Path pathToSrcsList,JavaCompiler compiler,Optional<Path> usedClassesFile,StandardJavaFileManager fileManager,Iterable<? extends JavaFileObject> compilationUnits){
  try {
    filesystem.writeLinesToPath(FluentIterable.from(javaSourceFilePaths).transform(Functions.toStringFunction()).transform(ARGFILES_ESCAPER),pathToSrcsList);
  }
 catch (  IOException e) {
    context.logError(e,""String_Node_Str"",pathToSrcsList);
    return 1;
  }
  DiagnosticCollector<JavaFileObject> diagnostics=new DiagnosticCollector<>();
  List<String> classNamesForAnnotationProcessing=ImmutableList.of();
  Writer compilerOutputWriter=new PrintWriter(context.getStdErr());
  ClassUsageTracker classTracker=new ClassUsageTracker();
  final StandardJavaFileManager maybeWrappedFileManager=usedClassesFile.isPresent() ? classTracker.wrapFileManager(fileManager) : fileManager;
  JavaCompiler.CompilationTask compilationTask=compiler.getTask(compilerOutputWriter,maybeWrappedFileManager,diagnostics,options,classNamesForAnnotationProcessing,compilationUnits);
  boolean isSuccess=false;
  BuckTracing.setCurrentThreadTracingInterfaceFromJsr199Javac(new BuckTracingEventBusBridge(context.getBuckEventBus(),invokingRule));
  try {
    try (TranslatingJavacPhaseTracer tracer=TranslatingJavacPhaseTracer.setupTracing(invokingRule,context.getClassLoaderCache(),context.getBuckEventBus(),compilationTask);ProcessorBundle bundle=prepareProcessors(context.getBuckEventBus(),compiler.getClass().getClassLoader(),context.getClassLoaderCache(),safeAnnotationProcessors,invokingRule,options)){
      compilationTask.setProcessors(bundle.processors);
      isSuccess=compilationTask.call();
    }
 catch (    IOException e) {
      LOG.warn(e,""String_Node_Str"");
    }
  }
  finally {
    BuckTracing.clearCurrentThreadTracingInterfaceFromJsr199Javac();
  }
  for (  Diagnostic<? extends JavaFileObject> diagnostic : diagnostics.getDiagnostics()) {
    LOG.debug(""String_Node_Str"",DiagnosticPrettyPrinter.format(diagnostic));
  }
  if (isSuccess) {
    if (usedClassesFile.isPresent()) {
      ClassUsageFile.writeFromTrackerData(filesystem,filesystem.resolve(usedClassesFile.get()),classTracker,context.getObjectMapper());
    }
    return 0;
  }
 else {
    if (context.getVerbosity().shouldPrintStandardInformation()) {
      int numErrors=0;
      int numWarnings=0;
      for (      Diagnostic<? extends JavaFileObject> diagnostic : diagnostics.getDiagnostics()) {
        Diagnostic.Kind kind=diagnostic.getKind();
        if (kind == Diagnostic.Kind.ERROR) {
          ++numErrors;
          handleMissingSymbolError(invokingRule,diagnostic,context,filesystem);
        }
 else         if (kind == Diagnostic.Kind.WARNING || kind == Diagnostic.Kind.MANDATORY_WARNING) {
          ++numWarnings;
        }
        context.getStdErr().println(DiagnosticPrettyPrinter.format(diagnostic));
      }
      if (numErrors > 0 || numWarnings > 0) {
        context.getStdErr().printf(""String_Node_Str"",numErrors,numWarnings);
      }
    }
    return 1;
  }
}",0.9842212154350882
53103,"@Override public void close() throws IOException {
  if (classLoader != null) {
    classLoader.close();
  }
}","@Override public void close() throws IOException {
  if (closeClassLoader && classLoader != null) {
    classLoader.close();
    classLoader=null;
  }
}",0.8396946564885496
53104,"private ProcessorBundle prepareProcessors(BuckEventBus buckEventBus,ClassLoader compilerClassLoader,BuildTarget target,List<String> options){
  String processorClassPath=null;
  String processorNames=null;
  Iterator<String> iterator=options.iterator();
  while (iterator.hasNext()) {
    String curr=iterator.next();
    if (""String_Node_Str"".equals(curr) && iterator.hasNext()) {
      processorClassPath=iterator.next();
    }
 else     if (""String_Node_Str"".equals(curr) && iterator.hasNext()) {
      processorNames=iterator.next();
    }
  }
  ProcessorBundle processorBundle=new ProcessorBundle();
  if (processorClassPath == null || processorNames == null) {
    return processorBundle;
  }
  Iterable<String> rawPaths=Splitter.on(File.pathSeparator).omitEmptyStrings().split(processorClassPath);
  URL[] urls=FluentIterable.from(rawPaths).transform(new Function<String,URL>(){
    @Override public URL apply(    String pathRelativeToProjectRoot){
      try {
        return Paths.get(pathRelativeToProjectRoot).toUri().toURL();
      }
 catch (      MalformedURLException e) {
        throw new RuntimeException(e);
      }
    }
  }
).toArray(URL.class);
  processorBundle.classLoader=new URLClassLoader(urls,compilerClassLoader);
  Iterable<String> names=Splitter.on(""String_Node_Str"").trimResults().omitEmptyStrings().split(processorNames);
  for (  String name : names) {
    try {
      LOG.debug(""String_Node_Str"",name);
      Class<? extends Processor> aClass=Preconditions.checkNotNull(processorBundle.classLoader).loadClass(name).asSubclass(Processor.class);
      processorBundle.processors.add(new TracingProcessorWrapper(buckEventBus,target,aClass.newInstance()));
    }
 catch (    ReflectiveOperationException e) {
      throw new HumanReadableException(""String_Node_Str"",target.getFullyQualifiedName(),name);
    }
  }
  return processorBundle;
}","private ProcessorBundle prepareProcessors(BuckEventBus buckEventBus,ClassLoader compilerClassLoader,ClassLoaderCache classLoaderCache,Set<String> safeAnnotationProcessors,BuildTarget target,List<String> options){
  String processorClassPath=null;
  String processorNames=null;
  Iterator<String> iterator=options.iterator();
  while (iterator.hasNext()) {
    String curr=iterator.next();
    if (""String_Node_Str"".equals(curr) && iterator.hasNext()) {
      processorClassPath=iterator.next();
    }
 else     if (""String_Node_Str"".equals(curr) && iterator.hasNext()) {
      processorNames=iterator.next();
    }
  }
  if (processorClassPath == null || processorNames == null) {
    return new ProcessorBundle();
  }
  Iterable<String> rawPaths=Splitter.on(File.pathSeparator).omitEmptyStrings().split(processorClassPath);
  URL[] urls=FluentIterable.from(rawPaths).transform(new Function<String,URL>(){
    @Override public URL apply(    String pathRelativeToProjectRoot){
      try {
        return Paths.get(pathRelativeToProjectRoot).toUri().toURL();
      }
 catch (      MalformedURLException e) {
        throw new RuntimeException(e);
      }
    }
  }
).toArray(URL.class);
  List<String> names=Splitter.on(""String_Node_Str"").trimResults().omitEmptyStrings().splitToList(processorNames);
  ProcessorBundle processorBundle=new ProcessorBundle();
  setProcessorBundleClassLoader(names,urls,compilerClassLoader,classLoaderCache,safeAnnotationProcessors,target,processorBundle);
  for (  String name : names) {
    try {
      LOG.debug(""String_Node_Str"",name);
      Class<? extends Processor> aClass=Preconditions.checkNotNull(processorBundle.classLoader).loadClass(name).asSubclass(Processor.class);
      processorBundle.processors.add(new TracingProcessorWrapper(buckEventBus,target,aClass.newInstance()));
    }
 catch (    ReflectiveOperationException e) {
      throw new HumanReadableException(""String_Node_Str"",target.getFullyQualifiedName(),name);
    }
  }
  return processorBundle;
}",0.8928479215078751
53105,"/** 
 * There was a bug where `BuildTargetSourcePath` sources were written to the classes file using their string representation, rather than their resolved path.
 */
@Test public void shouldWriteResolvedBuildTargetSourcePathsToClassesFile() throws IOException, InterruptedException {
  BuildRuleResolver resolver=new BuildRuleResolver(TargetGraph.EMPTY,new DefaultTargetNodeToBuildRuleTransformer());
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  BuildRule rule=new FakeBuildRule(""String_Node_Str"",pathResolver);
  resolver.addToIndex(rule);
  Jsr199Javac javac=createJavac(false);
  ExecutionContext executionContext=TestExecutionContext.newInstance();
  int exitCode=javac.buildWithClasspath(executionContext,createProjectFilesystem(),PATH_RESOLVER,BuildTargetFactory.newInstance(""String_Node_Str""),ImmutableList.<String>of(),SOURCE_PATHS,pathToSrcsList,Optional.<Path>absent(),Optional.<Path>absent(),Optional.<StandardJavaFileManagerFactory>absent());
  assertEquals(""String_Node_Str"",exitCode,0);
  File srcsListFile=pathToSrcsList.toFile();
  assertTrue(srcsListFile.exists());
  assertTrue(srcsListFile.isFile());
  assertEquals(""String_Node_Str"",Files.toString(srcsListFile,Charsets.UTF_8).trim());
}","/** 
 * There was a bug where `BuildTargetSourcePath` sources were written to the classes file using their string representation, rather than their resolved path.
 */
@Test public void shouldWriteResolvedBuildTargetSourcePathsToClassesFile() throws IOException, InterruptedException {
  BuildRuleResolver resolver=new BuildRuleResolver(TargetGraph.EMPTY,new DefaultTargetNodeToBuildRuleTransformer());
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  BuildRule rule=new FakeBuildRule(""String_Node_Str"",pathResolver);
  resolver.addToIndex(rule);
  Jsr199Javac javac=createJavac(false);
  ExecutionContext executionContext=TestExecutionContext.newInstance();
  int exitCode=javac.buildWithClasspath(executionContext,createProjectFilesystem(),PATH_RESOLVER,BuildTargetFactory.newInstance(""String_Node_Str""),ImmutableList.<String>of(),ImmutableSet.<String>of(),SOURCE_PATHS,pathToSrcsList,Optional.<Path>absent(),Optional.<Path>absent(),Optional.<StandardJavaFileManagerFactory>absent());
  assertEquals(""String_Node_Str"",exitCode,0);
  File srcsListFile=pathToSrcsList.toFile();
  assertTrue(srcsListFile.exists());
  assertTrue(srcsListFile.isFile());
  assertEquals(""String_Node_Str"",Files.toString(srcsListFile,Charsets.UTF_8).trim());
}",0.9895666131621188
53106,"@Test public void shouldUseSpecifiedJavacJar() throws Exception {
  BuildRuleResolver resolver=new BuildRuleResolver(TargetGraph.EMPTY,new DefaultTargetNodeToBuildRuleTransformer());
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  BuildRule rule=new FakeBuildRule(""String_Node_Str"",pathResolver);
  resolver.addToIndex(rule);
  Path fakeJavacJar=Paths.get(""String_Node_Str"",""String_Node_Str"");
  ExecutionContext executionContext=TestExecutionContext.newInstance();
  MockClassLoader mockClassLoader=new MockClassLoader(ClassLoader.getSystemClassLoader(),ImmutableMap.<String,Class<?>>of(""String_Node_Str"",MockJavac.class));
  executionContext.getClassLoaderCache().injectClassLoader(ClassLoader.getSystemClassLoader(),ImmutableList.of(fakeJavacJar.toUri().toURL()),mockClassLoader);
  Jsr199Javac javac=createJavac(false,Optional.of(fakeJavacJar));
  boolean caught=false;
  try {
    javac.buildWithClasspath(executionContext,createProjectFilesystem(),PATH_RESOLVER,BuildTargetFactory.newInstance(""String_Node_Str""),ImmutableList.<String>of(),SOURCE_PATHS,pathToSrcsList,Optional.<Path>absent(),Optional.<Path>absent(),Optional.<StandardJavaFileManagerFactory>absent());
    fail(""String_Node_Str"");
  }
 catch (  UnsupportedOperationException ex) {
    if (ex.toString().contains(""String_Node_Str"")) {
      caught=true;
    }
  }
  assertTrue(""String_Node_Str"",caught);
}","@Test public void shouldUseSpecifiedJavacJar() throws Exception {
  BuildRuleResolver resolver=new BuildRuleResolver(TargetGraph.EMPTY,new DefaultTargetNodeToBuildRuleTransformer());
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  BuildRule rule=new FakeBuildRule(""String_Node_Str"",pathResolver);
  resolver.addToIndex(rule);
  Path fakeJavacJar=Paths.get(""String_Node_Str"",""String_Node_Str"");
  ExecutionContext executionContext=TestExecutionContext.newInstance();
  MockClassLoader mockClassLoader=new MockClassLoader(ClassLoader.getSystemClassLoader(),ImmutableMap.<String,Class<?>>of(""String_Node_Str"",MockJavac.class));
  executionContext.getClassLoaderCache().injectClassLoader(ClassLoader.getSystemClassLoader(),ImmutableList.of(fakeJavacJar.toUri().toURL()),mockClassLoader);
  Jsr199Javac javac=createJavac(false,Optional.of(fakeJavacJar));
  boolean caught=false;
  try {
    javac.buildWithClasspath(executionContext,createProjectFilesystem(),PATH_RESOLVER,BuildTargetFactory.newInstance(""String_Node_Str""),ImmutableList.<String>of(),ImmutableSet.<String>of(),SOURCE_PATHS,pathToSrcsList,Optional.<Path>absent(),Optional.<Path>absent(),Optional.<StandardJavaFileManagerFactory>absent());
    fail(""String_Node_Str"");
  }
 catch (  UnsupportedOperationException ex) {
    if (ex.toString().contains(""String_Node_Str"")) {
      caught=true;
    }
  }
  assertTrue(""String_Node_Str"",caught);
}",0.9907801418439716
53107,"@Test public void testClassesFile() throws IOException, InterruptedException {
  Jsr199Javac javac=createJavac(false);
  ExecutionContext executionContext=TestExecutionContext.newInstance();
  int exitCode=javac.buildWithClasspath(executionContext,createProjectFilesystem(),PATH_RESOLVER,BuildTargetFactory.newInstance(""String_Node_Str""),ImmutableList.<String>of(),SOURCE_PATHS,pathToSrcsList,Optional.<Path>absent(),Optional.<Path>absent(),Optional.<StandardJavaFileManagerFactory>absent());
  assertEquals(""String_Node_Str"",exitCode,0);
  File srcsListFile=pathToSrcsList.toFile();
  assertTrue(srcsListFile.exists());
  assertTrue(srcsListFile.isFile());
  assertEquals(""String_Node_Str"",Files.toString(srcsListFile,Charsets.UTF_8).trim());
}","@Test public void testClassesFile() throws IOException, InterruptedException {
  Jsr199Javac javac=createJavac(false);
  ExecutionContext executionContext=TestExecutionContext.newInstance();
  int exitCode=javac.buildWithClasspath(executionContext,createProjectFilesystem(),PATH_RESOLVER,BuildTargetFactory.newInstance(""String_Node_Str""),ImmutableList.<String>of(),ImmutableSet.<String>of(),SOURCE_PATHS,pathToSrcsList,Optional.<Path>absent(),Optional.<Path>absent(),Optional.<StandardJavaFileManagerFactory>absent());
  assertEquals(""String_Node_Str"",exitCode,0);
  File srcsListFile=pathToSrcsList.toFile();
  assertTrue(srcsListFile.exists());
  assertTrue(srcsListFile.isFile());
  assertEquals(""String_Node_Str"",Files.toString(srcsListFile,Charsets.UTF_8).trim());
}",0.982849604221636
53108,"private void addReadFile(FileObject fileObject){
  Preconditions.checkState(result == null);
  if (!(fileObject instanceof JavaFileObject)) {
    return;
  }
  JavaFileObject javaFileObject=(JavaFileObject)fileObject;
  if (javaFileObject.getKind() != JavaFileObject.Kind.CLASS) {
    return;
  }
  Matcher classFileMatcher=CLASS_FILE_PATTERN.matcher(javaFileObject.toUri().toString());
  boolean matches=classFileMatcher.matches();
  if (!matches) {
    return;
  }
  resultBuilder.put(Paths.get(classFileMatcher.group(""String_Node_Str"")),Paths.get(classFileMatcher.group(""String_Node_Str"")));
}","private void addReadFile(FileObject fileObject){
  Preconditions.checkState(result == null);
  if (!(fileObject instanceof JavaFileObject)) {
    return;
  }
  JavaFileObject javaFileObject=(JavaFileObject)fileObject;
  if (javaFileObject.getKind() != JavaFileObject.Kind.CLASS) {
    return;
  }
  URI classFileJarUri=javaFileObject.toUri();
  if (!classFileJarUri.getScheme().equals(JAR_SCHEME)) {
    return;
  }
  String jarUriSchemeSpecificPart=classFileJarUri.getRawSchemeSpecificPart();
  final String[] split=jarUriSchemeSpecificPart.split(""String_Node_Str"");
  Preconditions.checkState(split.length == 2);
  URI jarFileUri=URI.create(split[0]);
  Preconditions.checkState(jarFileUri.getScheme().equals(FILE_SCHEME));
  Path jarFilePath=Paths.get(jarFileUri);
  Path classPath=Paths.get(URI.create(split[1]).toString());
  Preconditions.checkState(jarFilePath.isAbsolute());
  Preconditions.checkState(!classPath.isAbsolute());
  resultBuilder.put(jarFilePath,classPath);
}",0.393151553582752
53109,"public DIncludes getIncludes() throws NoSuchBuildTargetException {
  buildRuleResolver.requireRule(BuildTarget.builder(getBuildTarget()).addFlavors(DDescriptionUtils.SOURCE_LINK_TREE).build());
  return includes;
}","public DIncludes getIncludes() throws NoSuchBuildTargetException {
  buildRuleResolver.requireRule(getBuildTarget().withFlavors(DDescriptionUtils.SOURCE_LINK_TREE));
  return includes;
}",0.91
53110,"@Override public <A extends Arg>BuildRule createBuildRule(TargetGraph targetGraph,BuildRuleParams params,BuildRuleResolver buildRuleResolver,A args) throws NoSuchBuildTargetException {
  SourcePathResolver pathResolver=new SourcePathResolver(buildRuleResolver);
  if (params.getBuildTarget().getFlavors().contains(DDescriptionUtils.SOURCE_LINK_TREE)) {
    return DDescriptionUtils.createSourceSymlinkTree(params.getBuildTarget(),params,pathResolver,args.srcs);
  }
  BuildTarget baseTarget=params.getBuildTarget().withoutFlavors(ImmutableSet.of(cxxPlatform.getFlavor(),CxxDescriptionEnhancer.STATIC_FLAVOR,DDescriptionUtils.SOURCE_LINK_TREE));
  DIncludes dIncludes=DIncludes.builder().setLinkTree(new BuildTargetSourcePath(DDescriptionUtils.getSymlinkTreeTarget(baseTarget))).setSources(args.srcs.getPaths()).build();
  if (params.getBuildTarget().getFlavors().contains(CxxDescriptionEnhancer.STATIC_FLAVOR)) {
    return createStaticLibraryBuildRule(params,buildRuleResolver,pathResolver,cxxPlatform,dBuckConfig,ImmutableList.<String>of(),args.srcs.getPaths(),dIncludes,CxxSourceRuleFactory.PicType.PDC);
  }
  return new DLibrary(params,buildRuleResolver,pathResolver,dIncludes);
}","@Override public <A extends Arg>BuildRule createBuildRule(TargetGraph targetGraph,BuildRuleParams params,BuildRuleResolver buildRuleResolver,A args) throws NoSuchBuildTargetException {
  SourcePathResolver pathResolver=new SourcePathResolver(buildRuleResolver);
  if (params.getBuildTarget().getFlavors().contains(DDescriptionUtils.SOURCE_LINK_TREE)) {
    return DDescriptionUtils.createSourceSymlinkTree(params.getBuildTarget(),params,pathResolver,args.srcs);
  }
  BuildTarget sourceTreeTarget=params.getBuildTarget().withFlavors(DDescriptionUtils.SOURCE_LINK_TREE);
  DIncludes dIncludes=DIncludes.builder().setLinkTree(new BuildTargetSourcePath(sourceTreeTarget)).setSources(args.srcs.getPaths()).build();
  if (params.getBuildTarget().getFlavors().contains(CxxDescriptionEnhancer.STATIC_FLAVOR)) {
    buildRuleResolver.requireRule(sourceTreeTarget);
    return createStaticLibraryBuildRule(params,buildRuleResolver,pathResolver,cxxPlatform,dBuckConfig,ImmutableList.<String>of(),args.srcs.getPaths(),dIncludes,CxxSourceRuleFactory.PicType.PDC);
  }
  return new DLibrary(params,buildRuleResolver,pathResolver,dIncludes);
}",0.5652549697493517
53111,"public static PythonPackageComponents getAllComponents(BuildRuleParams params,BuildRuleResolver ruleResolver,SourcePathResolver pathResolver,final PythonPackageComponents packageComponents,final PythonPlatform pythonPlatform,final CxxPlatform cxxPlatform,ImmutableList<? extends Arg> extraLdflags,final NativeLinkStrategy nativeLinkStrategy) throws NoSuchBuildTargetException {
  final PythonPackageComponents.Builder allComponents=new PythonPackageComponents.Builder(params.getBuildTarget());
  final Map<BuildTarget,CxxPythonExtension> extensions=new LinkedHashMap<>();
  final Map<BuildTarget,SharedNativeLinkTarget> nativeLinkTargetRoots=new LinkedHashMap<>();
  final Map<BuildTarget,NativeLinkable> nativeLinkableRoots=new LinkedHashMap<>();
  final Set<BuildTarget> excludedNativeLinkableRoots=new LinkedHashSet<>();
  allComponents.addComponent(packageComponents,params.getBuildTarget());
  new AbstractBreadthFirstThrowingTraversal<BuildRule,NoSuchBuildTargetException>(params.getDeps()){
    private final ImmutableList<BuildRule> empty=ImmutableList.of();
    @Override public Iterable<BuildRule> visit(    BuildRule rule) throws NoSuchBuildTargetException {
      Iterable<BuildRule> deps=empty;
      Optional<SharedNativeLinkTarget> linkTarget=nativeLinkStrategy == NativeLinkStrategy.MERGED ? NativeLinkables.getSharedNativeLinkTarget(rule,cxxPlatform) : Optional.<SharedNativeLinkTarget>absent();
      if (rule instanceof CxxPythonExtension) {
        extensions.put(rule.getBuildTarget(),(CxxPythonExtension)rule);
      }
 else       if (rule instanceof PythonPackagable) {
        PythonPackagable packagable=(PythonPackagable)rule;
        PythonPackageComponents comps=packagable.getPythonPackageComponents(pythonPlatform,cxxPlatform);
        allComponents.addComponent(comps,rule.getBuildTarget());
        if (hasNativeCode(cxxPlatform,comps)) {
          for (          BuildRule dep : rule.getDeps()) {
            if (dep instanceof NativeLinkable) {
              NativeLinkable linkable=(NativeLinkable)dep;
              excludedNativeLinkableRoots.add(linkable.getBuildTarget());
              nativeLinkableRoots.put(linkable.getBuildTarget(),linkable);
            }
          }
        }
        deps=rule.getDeps();
      }
 else       if (linkTarget.isPresent()) {
        nativeLinkTargetRoots.put(linkTarget.get().getBuildTarget(),linkTarget.get());
      }
 else       if (rule instanceof NativeLinkable) {
        nativeLinkableRoots.put(rule.getBuildTarget(),(NativeLinkable)rule);
      }
      return deps;
    }
  }
.start();
  if (nativeLinkStrategy == NativeLinkStrategy.MERGED) {
    Map<BuildTarget,SharedNativeLinkTarget> includedNativeLinkTargetRoots=new LinkedHashMap<>();
    for (    Map.Entry<BuildTarget,SharedNativeLinkTarget> ent : nativeLinkTargetRoots.entrySet()) {
      if (!excludedNativeLinkableRoots.contains(ent.getKey())) {
        includedNativeLinkTargetRoots.put(ent.getKey(),ent.getValue());
      }
    }
    Map<BuildTarget,CxxPythonExtension> includedExtensions=new LinkedHashMap<>();
    for (    CxxPythonExtension extension : extensions.values()) {
      SharedNativeLinkTarget target=extension.getNativeLinkTarget(pythonPlatform);
      includedExtensions.put(target.getBuildTarget(),extension);
      includedNativeLinkTargetRoots.put(target.getBuildTarget(),target);
    }
    OmnibusLibraries libraries=Omnibus.getSharedLibraries(params,ruleResolver,pathResolver,cxxPlatform,extraLdflags,includedNativeLinkTargetRoots.values(),Maps.filterKeys(nativeLinkableRoots,Predicates.not(Predicates.in(includedNativeLinkTargetRoots.keySet()))).values());
    for (    Map.Entry<BuildTarget,SharedLibrary> root : libraries.getRoots().entrySet()) {
      CxxPythonExtension extension=includedExtensions.get(root.getKey());
      if (extension != null) {
        allComponents.addModule(extension.getModule(),root.getValue().getPath(),root.getKey());
      }
 else {
        allComponents.addNativeLibraries(Paths.get(root.getValue().getSoname()),root.getValue().getPath(),root.getKey());
      }
    }
    for (    SharedLibrary library : libraries.getLibraries()) {
      allComponents.addNativeLibraries(Paths.get(library.getSoname()),library.getPath(),params.getBuildTarget());
    }
  }
 else {
    Map<BuildTarget,NativeLinkable> allNativeRoots=new LinkedHashMap<>();
    allNativeRoots.putAll(nativeLinkableRoots);
    for (    Map.Entry<BuildTarget,CxxPythonExtension> entry : extensions.entrySet()) {
      allComponents.addComponent(entry.getValue().getPythonPackageComponents(pythonPlatform,cxxPlatform),entry.getKey());
      allNativeRoots.putAll(Maps.uniqueIndex(entry.getValue().getNativeLinkTarget(pythonPlatform).getSharedNativeLinkTargetDeps(cxxPlatform),HasBuildTarget.TO_TARGET));
    }
    ImmutableMap<BuildTarget,NativeLinkable> nativeLinkables=NativeLinkables.getTransitiveNativeLinkables(cxxPlatform,allNativeRoots.values());
    for (    NativeLinkable nativeLinkable : nativeLinkables.values()) {
      NativeLinkable.Linkage linkage=nativeLinkable.getPreferredLinkage(cxxPlatform);
      if (linkage != NativeLinkable.Linkage.STATIC) {
        ImmutableMap<String,SourcePath> libs=nativeLinkable.getSharedLibraries(cxxPlatform);
        for (        Map.Entry<String,SourcePath> ent : libs.entrySet()) {
          allComponents.addNativeLibraries(Paths.get(ent.getKey()),ent.getValue(),params.getBuildTarget());
        }
      }
    }
  }
  return allComponents.build();
}","public static PythonPackageComponents getAllComponents(BuildRuleParams params,BuildRuleResolver ruleResolver,SourcePathResolver pathResolver,final PythonPackageComponents packageComponents,final PythonPlatform pythonPlatform,final CxxPlatform cxxPlatform,ImmutableList<? extends Arg> extraLdflags,final NativeLinkStrategy nativeLinkStrategy) throws NoSuchBuildTargetException {
  final PythonPackageComponents.Builder allComponents=new PythonPackageComponents.Builder(params.getBuildTarget());
  final Map<BuildTarget,CxxPythonExtension> extensions=new LinkedHashMap<>();
  final Map<BuildTarget,SharedNativeLinkTarget> nativeLinkTargetRoots=new LinkedHashMap<>();
  final Map<BuildTarget,NativeLinkable> nativeLinkableRoots=new LinkedHashMap<>();
  final Set<BuildTarget> excludedNativeLinkableRoots=new LinkedHashSet<>();
  allComponents.addComponent(packageComponents,params.getBuildTarget());
  new AbstractBreadthFirstThrowingTraversal<BuildRule,NoSuchBuildTargetException>(params.getDeps()){
    private final ImmutableList<BuildRule> empty=ImmutableList.of();
    @Override public Iterable<BuildRule> visit(    BuildRule rule) throws NoSuchBuildTargetException {
      Iterable<BuildRule> deps=empty;
      Optional<SharedNativeLinkTarget> linkTarget=nativeLinkStrategy == NativeLinkStrategy.MERGED ? NativeLinkables.getSharedNativeLinkTarget(rule,cxxPlatform) : Optional.<SharedNativeLinkTarget>absent();
      if (rule instanceof CxxPythonExtension) {
        extensions.put(rule.getBuildTarget(),(CxxPythonExtension)rule);
      }
 else       if (rule instanceof PythonPackagable) {
        PythonPackagable packagable=(PythonPackagable)rule;
        PythonPackageComponents comps=packagable.getPythonPackageComponents(pythonPlatform,cxxPlatform);
        allComponents.addComponent(comps,rule.getBuildTarget());
        if (hasNativeCode(cxxPlatform,comps)) {
          for (          BuildRule dep : rule.getDeps()) {
            if (dep instanceof NativeLinkable) {
              NativeLinkable linkable=(NativeLinkable)dep;
              excludedNativeLinkableRoots.add(linkable.getBuildTarget());
              nativeLinkableRoots.put(linkable.getBuildTarget(),linkable);
            }
          }
        }
        deps=rule.getDeps();
      }
 else       if (linkTarget.isPresent()) {
        nativeLinkTargetRoots.put(linkTarget.get().getBuildTarget(),linkTarget.get());
      }
 else       if (rule instanceof NativeLinkable) {
        nativeLinkableRoots.put(rule.getBuildTarget(),(NativeLinkable)rule);
      }
      return deps;
    }
  }
.start();
  if (nativeLinkStrategy == NativeLinkStrategy.MERGED) {
    Map<BuildTarget,SharedNativeLinkTarget> includedNativeLinkTargetRoots=new LinkedHashMap<>();
    for (    Map.Entry<BuildTarget,SharedNativeLinkTarget> ent : nativeLinkTargetRoots.entrySet()) {
      if (!excludedNativeLinkableRoots.contains(ent.getKey())) {
        includedNativeLinkTargetRoots.put(ent.getKey(),ent.getValue());
      }
    }
    Map<BuildTarget,CxxPythonExtension> includedExtensions=new LinkedHashMap<>();
    for (    CxxPythonExtension extension : extensions.values()) {
      SharedNativeLinkTarget target=extension.getNativeLinkTarget(pythonPlatform);
      includedExtensions.put(target.getBuildTarget(),extension);
      includedNativeLinkTargetRoots.put(target.getBuildTarget(),target);
    }
    OmnibusLibraries libraries=Omnibus.getSharedLibraries(params,ruleResolver,pathResolver,cxxPlatform,extraLdflags,includedNativeLinkTargetRoots.values(),Maps.filterKeys(nativeLinkableRoots,Predicates.not(Predicates.in(includedNativeLinkTargetRoots.keySet()))).values());
    for (    Map.Entry<BuildTarget,SharedLibrary> root : libraries.getRoots().entrySet()) {
      CxxPythonExtension extension=includedExtensions.get(root.getKey());
      if (extension != null) {
        allComponents.addModule(extension.getModule(),root.getValue().getPath(),root.getKey());
      }
 else {
        allComponents.addNativeLibraries(Paths.get(root.getValue().getSoname()),root.getValue().getPath(),root.getKey());
      }
    }
    for (    SharedLibrary library : libraries.getLibraries()) {
      allComponents.addNativeLibraries(Paths.get(library.getSoname()),library.getPath(),params.getBuildTarget());
    }
  }
 else {
    Map<BuildTarget,NativeLinkable> allNativeRoots=new LinkedHashMap<>();
    allNativeRoots.putAll(nativeLinkableRoots);
    for (    Map.Entry<BuildTarget,CxxPythonExtension> entry : extensions.entrySet()) {
      allComponents.addComponent(entry.getValue().getPythonPackageComponents(pythonPlatform,cxxPlatform),entry.getKey());
      allNativeRoots.putAll(Maps.uniqueIndex(entry.getValue().getNativeLinkTarget(pythonPlatform).getSharedNativeLinkTargetDeps(cxxPlatform),HasBuildTarget.TO_TARGET));
    }
    ImmutableMap<BuildTarget,NativeLinkable> nativeLinkables=NativeLinkables.getTransitiveNativeLinkables(cxxPlatform,allNativeRoots.values());
    for (    NativeLinkable nativeLinkable : nativeLinkables.values()) {
      NativeLinkable.Linkage linkage=nativeLinkable.getPreferredLinkage(cxxPlatform);
      if (linkage != NativeLinkable.Linkage.STATIC) {
        ImmutableMap<String,SourcePath> libs=nativeLinkable.getSharedLibraries(cxxPlatform);
        for (        Map.Entry<String,SourcePath> ent : libs.entrySet()) {
          allComponents.addNativeLibraries(Paths.get(ent.getKey()),ent.getValue(),nativeLinkable.getBuildTarget());
        }
      }
    }
  }
  return allComponents.build();
}",0.9981728485291432
53112,"@Override public int runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {
  if (isResolveAlias()) {
    return doResolveAlias(params);
  }
  if (isShowRuleKey() && isShowTargetHash()) {
    throw new HumanReadableException(""String_Node_Str"");
  }
  try (CommandThreadManager pool=new CommandThreadManager(""String_Node_Str"",params.getBuckConfig().getWorkQueueExecutionOrder(),getConcurrencyLimit(params.getBuckConfig()))){
    if (isShowOutput() || isShowRuleKey() || isShowTargetHash()) {
      try {
        return doShowRules(params,pool.getExecutor());
      }
 catch (      NoSuchBuildTargetException e) {
        throw new HumanReadableException(""String_Node_Str"",e.getHumanReadableErrorMessage());
      }
    }
    ImmutableSet<String> types=getTypes();
    ImmutableSet.Builder<BuildRuleType> buildRuleTypesBuilder=ImmutableSet.builder();
    for (    String name : types) {
      try {
        buildRuleTypesBuilder.add(params.getCell().getBuildRuleType(name));
      }
 catch (      IllegalArgumentException e) {
        params.getBuckEventBus().post(ConsoleEvent.severe(""String_Node_Str"" + name));
        return 1;
      }
    }
    ImmutableSet<BuildTarget> matchingBuildTargets;
    TargetGraph graph;
    try {
      if (getArguments().isEmpty() || isDetectTestChanges()) {
        matchingBuildTargets=ImmutableSet.of();
        graph=params.getParser().buildTargetGraphForTargetNodeSpecs(params.getBuckEventBus(),params.getCell(),getEnableProfiling(),pool.getExecutor(),ImmutableList.of(TargetNodePredicateSpec.of(Predicates.<TargetNode<?>>alwaysTrue(),BuildFileSpec.fromRecursivePath(Paths.get(""String_Node_Str""))))).getSecond();
      }
 else {
        Pair<ImmutableSet<BuildTarget>,TargetGraph> results=params.getParser().buildTargetGraphForTargetNodeSpecs(params.getBuckEventBus(),params.getCell(),getEnableProfiling(),pool.getExecutor(),parseArgumentsAsTargetNodeSpecs(params.getBuckConfig(),getArguments()));
        matchingBuildTargets=results.getFirst();
        graph=results.getSecond();
      }
    }
 catch (    BuildTargetException|BuildFileParseException e) {
      params.getBuckEventBus().post(ConsoleEvent.severe(MoreExceptions.getHumanReadableOrLocalizedMessage(e)));
      return 1;
    }
    PathArguments.ReferencedFiles referencedFiles=getReferencedFiles(params.getCell().getFilesystem().getRootPath());
    SortedMap<String,TargetNode<?>> matchingNodes;
    if (!referencedFiles.absolutePathsOutsideProjectRootOrNonExistingPaths.isEmpty() && referencedFiles.relativePathsUnderProjectRoot.isEmpty()) {
      matchingNodes=ImmutableSortedMap.of();
    }
 else {
      ImmutableSet<BuildRuleType> buildRuleTypes=buildRuleTypesBuilder.build();
      ParserConfig parserConfig=new ParserConfig(params.getBuckConfig());
      matchingNodes=getMatchingNodes(graph,referencedFiles.relativePathsUnderProjectRoot.isEmpty() ? Optional.<ImmutableSet<Path>>absent() : Optional.of(referencedFiles.relativePathsUnderProjectRoot),matchingBuildTargets.isEmpty() ? Optional.<ImmutableSet<BuildTarget>>absent() : Optional.of(matchingBuildTargets),buildRuleTypes.isEmpty() ? Optional.<ImmutableSet<BuildRuleType>>absent() : Optional.of(buildRuleTypes),isDetectTestChanges(),parserConfig.getBuildFileName());
    }
    if (getPrintJson()) {
      try {
        printJsonForTargets(params,pool.getExecutor(),matchingNodes);
      }
 catch (      BuildFileParseException e) {
        params.getBuckEventBus().post(ConsoleEvent.severe(MoreExceptions.getHumanReadableOrLocalizedMessage(e)));
        return 1;
      }
    }
 else     if (isPrint0()) {
      printNullDelimitedTargets(matchingNodes.keySet(),params.getConsole().getStdOut());
    }
 else {
      for (      String target : matchingNodes.keySet()) {
        params.getConsole().getStdOut().println(target);
      }
    }
  }
   return 0;
}","@Override public int runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {
  if (isResolveAlias()) {
    return doResolveAlias(params);
  }
  if (isShowRuleKey() && isShowTargetHash()) {
    throw new HumanReadableException(""String_Node_Str"");
  }
  ImmutableMap<String,ShowOptions> showRulesResult=ImmutableMap.of();
  try (CommandThreadManager pool=new CommandThreadManager(""String_Node_Str"",params.getBuckConfig().getWorkQueueExecutionOrder(),getConcurrencyLimit(params.getBuckConfig()))){
    if (isShowOutput() || isShowRuleKey() || isShowTargetHash()) {
      try {
        showRulesResult=computeShowRules(params,pool.getExecutor());
      }
 catch (      NoSuchBuildTargetException e) {
        throw new HumanReadableException(""String_Node_Str"",e.getHumanReadableErrorMessage());
      }
catch (      BuildTargetException|BuildFileParseException e) {
        params.getBuckEventBus().post(ConsoleEvent.severe(MoreExceptions.getHumanReadableOrLocalizedMessage(e)));
        return 1;
      }
      if (!getPrintJson()) {
        printShowRules(showRulesResult,params);
        return 0;
      }
    }
    ImmutableSet<String> types=getTypes();
    ImmutableSet.Builder<BuildRuleType> buildRuleTypesBuilder=ImmutableSet.builder();
    for (    String name : types) {
      try {
        buildRuleTypesBuilder.add(params.getCell().getBuildRuleType(name));
      }
 catch (      IllegalArgumentException e) {
        params.getBuckEventBus().post(ConsoleEvent.severe(""String_Node_Str"" + name));
        return 1;
      }
    }
    ImmutableSet<BuildTarget> matchingBuildTargets;
    TargetGraph graph;
    try {
      if (getArguments().isEmpty() || isDetectTestChanges()) {
        matchingBuildTargets=ImmutableSet.of();
        graph=params.getParser().buildTargetGraphForTargetNodeSpecs(params.getBuckEventBus(),params.getCell(),getEnableProfiling(),pool.getExecutor(),ImmutableList.of(TargetNodePredicateSpec.of(Predicates.<TargetNode<?>>alwaysTrue(),BuildFileSpec.fromRecursivePath(Paths.get(""String_Node_Str""))))).getSecond();
      }
 else {
        Pair<ImmutableSet<BuildTarget>,TargetGraph> results=params.getParser().buildTargetGraphForTargetNodeSpecs(params.getBuckEventBus(),params.getCell(),getEnableProfiling(),pool.getExecutor(),parseArgumentsAsTargetNodeSpecs(params.getBuckConfig(),getArguments()));
        matchingBuildTargets=results.getFirst();
        graph=results.getSecond();
      }
    }
 catch (    BuildTargetException|BuildFileParseException e) {
      params.getBuckEventBus().post(ConsoleEvent.severe(MoreExceptions.getHumanReadableOrLocalizedMessage(e)));
      return 1;
    }
    PathArguments.ReferencedFiles referencedFiles=getReferencedFiles(params.getCell().getFilesystem().getRootPath());
    SortedMap<String,TargetNode<?>> matchingNodes;
    if (!referencedFiles.absolutePathsOutsideProjectRootOrNonExistingPaths.isEmpty() && referencedFiles.relativePathsUnderProjectRoot.isEmpty()) {
      matchingNodes=ImmutableSortedMap.of();
    }
 else {
      ImmutableSet<BuildRuleType> buildRuleTypes=buildRuleTypesBuilder.build();
      ParserConfig parserConfig=new ParserConfig(params.getBuckConfig());
      matchingNodes=getMatchingNodes(graph,referencedFiles.relativePathsUnderProjectRoot.isEmpty() ? Optional.<ImmutableSet<Path>>absent() : Optional.of(referencedFiles.relativePathsUnderProjectRoot),matchingBuildTargets.isEmpty() ? Optional.<ImmutableSet<BuildTarget>>absent() : Optional.of(matchingBuildTargets),buildRuleTypes.isEmpty() ? Optional.<ImmutableSet<BuildRuleType>>absent() : Optional.of(buildRuleTypes),isDetectTestChanges(),parserConfig.getBuildFileName());
    }
    if (getPrintJson()) {
      try {
        printJsonForTargets(params,pool.getExecutor(),matchingNodes,showRulesResult);
      }
 catch (      BuildFileParseException e) {
        params.getBuckEventBus().post(ConsoleEvent.severe(MoreExceptions.getHumanReadableOrLocalizedMessage(e)));
        return 1;
      }
    }
 else     if (isPrint0()) {
      printNullDelimitedTargets(matchingNodes.keySet(),params.getConsole().getStdOut());
    }
 else {
      for (      String target : matchingNodes.keySet()) {
        params.getConsole().getStdOut().println(target);
      }
    }
  }
   return 0;
}",0.9474852071005916
53113,"@VisibleForTesting void printJsonForTargets(CommandRunnerParams params,Executor executor,SortedMap<String,TargetNode<?>> buildIndex) throws BuildFileParseException, IOException, InterruptedException {
  params.getConsole().getStdOut().println(""String_Node_Str"");
  ObjectMapper mapper=params.getObjectMapper();
  Iterator<TargetNode<?>> valueIterator=buildIndex.values().iterator();
  while (valueIterator.hasNext()) {
    TargetNode<?> targetNode=valueIterator.next();
    SortedMap<String,Object> sortedTargetRule=null;
    sortedTargetRule=params.getParser().getRawTargetNode(params.getBuckEventBus(),params.getCell(),getEnableProfiling(),executor,targetNode);
    if (sortedTargetRule == null) {
      params.getConsole().printErrorText(""String_Node_Str"" + targetNode.getBuildTarget().getFullyQualifiedName());
      continue;
    }
    StringWriter stringWriter=new StringWriter();
    try {
      mapper.writerWithDefaultPrettyPrinter().writeValue(stringWriter,sortedTargetRule);
    }
 catch (    IOException e) {
      throw Throwables.propagate(e);
    }
    String output=stringWriter.getBuffer().toString();
    if (valueIterator.hasNext()) {
      output+=""String_Node_Str"";
    }
    params.getConsole().getStdOut().println(output);
  }
  params.getConsole().getStdOut().println(""String_Node_Str"");
}","@VisibleForTesting void printJsonForTargets(CommandRunnerParams params,Executor executor,SortedMap<String,TargetNode<?>> buildIndex,ImmutableMap<String,ShowOptions> showRulesResult) throws BuildFileParseException, IOException, InterruptedException {
  params.getConsole().getStdOut().println(""String_Node_Str"");
  ObjectMapper mapper=params.getObjectMapper();
  Iterator<Entry<String,TargetNode<?>>> mapIterator=buildIndex.entrySet().iterator();
  while (mapIterator.hasNext()) {
    Entry<String,TargetNode<?>> current=mapIterator.next();
    String target=current.getKey();
    TargetNode<?> targetNode=current.getValue();
    SortedMap<String,Object> sortedTargetRule;
    sortedTargetRule=params.getParser().getRawTargetNode(params.getBuckEventBus(),params.getCell(),getEnableProfiling(),executor,targetNode);
    if (sortedTargetRule == null) {
      params.getConsole().printErrorText(""String_Node_Str"" + targetNode.getBuildTarget().getFullyQualifiedName());
      continue;
    }
    ShowOptions showOptions=showRulesResult.get(target);
    if (showOptions != null) {
      putIfValuePresent(ShowOptionsName.RULE_KEY.getName(),showOptions.getRuleKey(),sortedTargetRule);
      putIfValuePresent(ShowOptionsName.OUTPUT_PATH.getName(),showOptions.getOutputPath(),sortedTargetRule);
      putIfValuePresent(ShowOptionsName.TARGET_HASH.getName(),showOptions.getTargetHash(),sortedTargetRule);
    }
    StringWriter stringWriter=new StringWriter();
    try {
      mapper.writerWithDefaultPrettyPrinter().writeValue(stringWriter,sortedTargetRule);
    }
 catch (    IOException e) {
      throw Throwables.propagate(e);
    }
    String output=stringWriter.getBuffer().toString();
    if (mapIterator.hasNext()) {
      output+=""String_Node_Str"";
    }
    params.getConsole().getStdOut().println(output);
  }
  params.getConsole().getStdOut().println(""String_Node_Str"");
}",0.7814361868924428
53114,"@Override public FileVisitResult visitFile(Path file,BasicFileAttributes attr) throws IOException {
  if (isResource(file)) {
    paths.add(new PathSourcePath(filesystem,file));
  }
  return FileVisitResult.CONTINUE;
}","@Override public FileVisitResult visitFile(Path file,BasicFileAttributes attr) throws IOException {
  String filename=file.getFileName().toString();
  if (isResource(filename)) {
    paths.add(new PathSourcePath(filesystem,file));
  }
  return FileVisitResult.CONTINUE;
}",0.8916155419222904
53115,"private boolean isResource(Path fileOrDir) throws IOException {
  for (  String nonAssetFilename : NON_ASSET_FILENAMES) {
    if (filesystem.isSameRelativePathIfFileExists(fileOrDir,fileOrDir.resolveSibling(nonAssetFilename))) {
      return false;
    }
  }
  String fileOrDirName=fileOrDir.getFileName().toString();
  if (fileOrDirName.charAt(fileOrDirName.length() - 1) == '~') {
    return false;
  }
  String fileOrDirNameWithoutExtension=Files.getNameWithoutExtension(fileOrDirName);
  for (  String ignoredMiniAaptExtension : MiniAapt.IGNORED_FILE_EXTENSIONS) {
    if (filesystem.isSameRelativePathIfFileExists(fileOrDir,fileOrDir.resolveSibling(fileOrDirNameWithoutExtension + ""String_Node_Str"" + ignoredMiniAaptExtension))) {
      return false;
    }
  }
  return true;
}","private boolean isResource(String fileOrDirName){
  if (NON_ASSET_FILENAMES.contains(fileOrDirName.toLowerCase())) {
    return false;
  }
  if (fileOrDirName.charAt(fileOrDirName.length() - 1) == '~') {
    return false;
  }
  if (MiniAapt.IGNORED_FILE_EXTENSIONS.contains(Files.getFileExtension(fileOrDirName))) {
    return false;
  }
  return true;
}",0.397887323943662
53116,"@VisibleForTesting ImmutableSortedSet<SourcePath> collectInputFiles(final ProjectFilesystem filesystem,Optional<Path> inputDir){
  if (!inputDir.isPresent()) {
    return ImmutableSortedSet.of();
  }
  final ImmutableSortedSet.Builder<SourcePath> paths=ImmutableSortedSet.naturalOrder();
  FileVisitor<Path> fileVisitor=new SimpleFileVisitor<Path>(){
    @Override public FileVisitResult preVisitDirectory(    Path dir,    BasicFileAttributes attr) throws IOException {
      if (dir.getFileName().toString().charAt(0) == '_' || !isResource(dir)) {
        return FileVisitResult.SKIP_SUBTREE;
      }
      return FileVisitResult.CONTINUE;
    }
    @Override public FileVisitResult visitFile(    Path file,    BasicFileAttributes attr) throws IOException {
      if (isResource(file)) {
        paths.add(new PathSourcePath(filesystem,file));
      }
      return FileVisitResult.CONTINUE;
    }
    private boolean isResource(    Path fileOrDir) throws IOException {
      for (      String nonAssetFilename : NON_ASSET_FILENAMES) {
        if (filesystem.isSameRelativePathIfFileExists(fileOrDir,fileOrDir.resolveSibling(nonAssetFilename))) {
          return false;
        }
      }
      String fileOrDirName=fileOrDir.getFileName().toString();
      if (fileOrDirName.charAt(fileOrDirName.length() - 1) == '~') {
        return false;
      }
      String fileOrDirNameWithoutExtension=Files.getNameWithoutExtension(fileOrDirName);
      for (      String ignoredMiniAaptExtension : MiniAapt.IGNORED_FILE_EXTENSIONS) {
        if (filesystem.isSameRelativePathIfFileExists(fileOrDir,fileOrDir.resolveSibling(fileOrDirNameWithoutExtension + ""String_Node_Str"" + ignoredMiniAaptExtension))) {
          return false;
        }
      }
      return true;
    }
  }
;
  try {
    filesystem.walkRelativeFileTree(inputDir.get(),fileVisitor);
  }
 catch (  IOException e) {
    throw new HumanReadableException(e,""String_Node_Str"",inputDir.get());
  }
  return paths.build();
}","@VisibleForTesting ImmutableSortedSet<SourcePath> collectInputFiles(final ProjectFilesystem filesystem,Optional<Path> inputDir){
  if (!inputDir.isPresent()) {
    return ImmutableSortedSet.of();
  }
  final ImmutableSortedSet.Builder<SourcePath> paths=ImmutableSortedSet.naturalOrder();
  FileVisitor<Path> fileVisitor=new SimpleFileVisitor<Path>(){
    @Override public FileVisitResult preVisitDirectory(    Path dir,    BasicFileAttributes attr) throws IOException {
      String dirName=dir.getFileName().toString();
      if (dirName.charAt(0) == '_' || !isResource(dirName)) {
        return FileVisitResult.SKIP_SUBTREE;
      }
      return FileVisitResult.CONTINUE;
    }
    @Override public FileVisitResult visitFile(    Path file,    BasicFileAttributes attr) throws IOException {
      String filename=file.getFileName().toString();
      if (isResource(filename)) {
        paths.add(new PathSourcePath(filesystem,file));
      }
      return FileVisitResult.CONTINUE;
    }
    private boolean isResource(    String fileOrDirName){
      if (NON_ASSET_FILENAMES.contains(fileOrDirName.toLowerCase())) {
        return false;
      }
      if (fileOrDirName.charAt(fileOrDirName.length() - 1) == '~') {
        return false;
      }
      if (MiniAapt.IGNORED_FILE_EXTENSIONS.contains(Files.getFileExtension(fileOrDirName))) {
        return false;
      }
      return true;
    }
  }
;
  try {
    filesystem.walkRelativeFileTree(inputDir.get(),fileVisitor);
  }
 catch (  IOException e) {
    throw new HumanReadableException(e,""String_Node_Str"",inputDir.get());
  }
  return paths.build();
}",0.7811541678282687
53117,"@Override public FileVisitResult preVisitDirectory(Path dir,BasicFileAttributes attr) throws IOException {
  if (dir.getFileName().toString().charAt(0) == '_' || !isResource(dir)) {
    return FileVisitResult.SKIP_SUBTREE;
  }
  return FileVisitResult.CONTINUE;
}","@Override public FileVisitResult preVisitDirectory(Path dir,BasicFileAttributes attr) throws IOException {
  String dirName=dir.getFileName().toString();
  if (dirName.charAt(0) == '_' || !isResource(dirName)) {
    return FileVisitResult.SKIP_SUBTREE;
  }
  return FileVisitResult.CONTINUE;
}",0.8561151079136691
53118,"@Override public int runWithoutHelp(final CommandRunnerParams params) throws IOException, InterruptedException {
  final ImmutableSet<BuildTarget> targets=FluentIterable.from(getArgumentsFormattedAsBuildTargets(params.getBuckConfig())).transform(new Function<String,BuildTarget>(){
    @Override public BuildTarget apply(    String input){
      return BuildTargetParser.INSTANCE.parse(input,BuildTargetPatternParser.fullyQualified(),params.getCell().getCellRoots());
    }
  }
).toSet();
  if (targets.isEmpty()) {
    params.getBuckEventBus().post(ConsoleEvent.severe(""String_Node_Str""));
    return 1;
  }
  TargetGraph targetGraph;
  try (CommandThreadManager pool=new CommandThreadManager(""String_Node_Str"",params.getBuckConfig().getWorkQueueExecutionOrder(),getConcurrencyLimit(params.getBuckConfig()))){
    targetGraph=params.getParser().buildTargetGraph(params.getBuckEventBus(),params.getCell(),getEnableProfiling(),pool.getExecutor(),targets);
  }
 catch (  BuildFileParseException e) {
    params.getBuckEventBus().post(ConsoleEvent.severe(MoreExceptions.getHumanReadableOrLocalizedMessage(e)));
    return 1;
  }
  TargetGraphTransformer targetGraphTransformer=new TargetGraphToActionGraph(params.getBuckEventBus(),new BuildTargetNodeToBuildRuleTransformer());
  try {
    if (shouldGenerateDotOutput()) {
      return printDotOutput(params,targetGraph);
    }
 else     if (shouldGenerateJsonOutput()) {
      return printJsonClasspath(params,targetGraph,targetGraphTransformer,targets);
    }
 else {
      return printClasspath(params,targetGraph,targetGraphTransformer,targets);
    }
  }
 catch (  NoSuchBuildTargetException e) {
    throw new HumanReadableException(e.getHumanReadableErrorMessage());
  }
}","@Override public int runWithoutHelp(final CommandRunnerParams params) throws IOException, InterruptedException {
  final ImmutableSet<BuildTarget> targets=FluentIterable.from(getArgumentsFormattedAsBuildTargets(params.getBuckConfig())).transform(new Function<String,BuildTarget>(){
    @Override public BuildTarget apply(    String input){
      return BuildTargetParser.INSTANCE.parse(input,BuildTargetPatternParser.fullyQualified(),params.getCell().getCellRoots());
    }
  }
).toSet();
  if (targets.isEmpty()) {
    params.getBuckEventBus().post(ConsoleEvent.severe(""String_Node_Str""));
    return 1;
  }
  TargetGraph targetGraph;
  try (CommandThreadManager pool=new CommandThreadManager(""String_Node_Str"",params.getBuckConfig().getWorkQueueExecutionOrder(),getConcurrencyLimit(params.getBuckConfig()))){
    targetGraph=params.getParser().buildTargetGraph(params.getBuckEventBus(),params.getCell(),getEnableProfiling(),pool.getExecutor(),targets);
  }
 catch (  BuildFileParseException|BuildTargetException e) {
    params.getBuckEventBus().post(ConsoleEvent.severe(MoreExceptions.getHumanReadableOrLocalizedMessage(e)));
    return 1;
  }
  TargetGraphTransformer targetGraphTransformer=new TargetGraphToActionGraph(params.getBuckEventBus(),new BuildTargetNodeToBuildRuleTransformer());
  try {
    if (shouldGenerateDotOutput()) {
      return printDotOutput(params,targetGraph);
    }
 else     if (shouldGenerateJsonOutput()) {
      return printJsonClasspath(params,targetGraph,targetGraphTransformer,targets);
    }
 else {
      return printClasspath(params,targetGraph,targetGraphTransformer,targets);
    }
  }
 catch (  NoSuchBuildTargetException e) {
    throw new HumanReadableException(e.getHumanReadableErrorMessage());
  }
}",0.9939498703543648
53119,"@Override public int runWithoutHelp(final CommandRunnerParams params) throws IOException, InterruptedException {
  final ImmutableSet<String> fullyQualifiedBuildTargets=ImmutableSet.copyOf(getArgumentsFormattedAsBuildTargets(params.getBuckConfig()));
  if (fullyQualifiedBuildTargets.isEmpty()) {
    params.getBuckEventBus().post(ConsoleEvent.severe(""String_Node_Str""));
    return 1;
  }
  ImmutableSet<BuildTarget> targets=FluentIterable.from(getArgumentsFormattedAsBuildTargets(params.getBuckConfig())).transform(new Function<String,BuildTarget>(){
    @Override public BuildTarget apply(    String input){
      return BuildTargetParser.INSTANCE.parse(input,BuildTargetPatternParser.fullyQualified(),params.getCell().getCellRoots());
    }
  }
).toSet();
  LOG.debug(""String_Node_Str"",targets);
  TargetGraph graph;
  try (CommandThreadManager pool=new CommandThreadManager(""String_Node_Str"",params.getBuckConfig().getWorkQueueExecutionOrder(),getConcurrencyLimit(params.getBuckConfig()))){
    graph=params.getParser().buildTargetGraph(params.getBuckEventBus(),params.getCell(),getEnableProfiling(),pool.getExecutor(),targets);
  }
 catch (  BuildFileParseException e) {
    params.getBuckEventBus().post(ConsoleEvent.severe(MoreExceptions.getHumanReadableOrLocalizedMessage(e)));
    return 1;
  }
  if (shouldGenerateJsonOutput()) {
    return printJsonInputs(params,graph);
  }
  return printInputs(params,graph);
}","@Override public int runWithoutHelp(final CommandRunnerParams params) throws IOException, InterruptedException {
  final ImmutableSet<String> fullyQualifiedBuildTargets=ImmutableSet.copyOf(getArgumentsFormattedAsBuildTargets(params.getBuckConfig()));
  if (fullyQualifiedBuildTargets.isEmpty()) {
    params.getBuckEventBus().post(ConsoleEvent.severe(""String_Node_Str""));
    return 1;
  }
  ImmutableSet<BuildTarget> targets=FluentIterable.from(getArgumentsFormattedAsBuildTargets(params.getBuckConfig())).transform(new Function<String,BuildTarget>(){
    @Override public BuildTarget apply(    String input){
      return BuildTargetParser.INSTANCE.parse(input,BuildTargetPatternParser.fullyQualified(),params.getCell().getCellRoots());
    }
  }
).toSet();
  LOG.debug(""String_Node_Str"",targets);
  TargetGraph graph;
  try (CommandThreadManager pool=new CommandThreadManager(""String_Node_Str"",params.getBuckConfig().getWorkQueueExecutionOrder(),getConcurrencyLimit(params.getBuckConfig()))){
    graph=params.getParser().buildTargetGraph(params.getBuckEventBus(),params.getCell(),getEnableProfiling(),pool.getExecutor(),targets);
  }
 catch (  BuildFileParseException|BuildTargetException e) {
    params.getBuckEventBus().post(ConsoleEvent.severe(MoreExceptions.getHumanReadableOrLocalizedMessage(e)));
    return 1;
  }
  if (shouldGenerateJsonOutput()) {
    return printJsonInputs(params,graph);
  }
  return printInputs(params,graph);
}",0.9926803764377832
53120,"private void buildGraphForBuildTargets(Set<BuildTarget> targets,Executor executor) throws QueryException, InterruptedException {
  try {
    graph=params.getParser().buildTargetGraph(params.getBuckEventBus(),params.getCell(),enableProfiling,executor,targets);
  }
 catch (  BuildFileParseException|IOException e) {
    throw new QueryException(""String_Node_Str"");
  }
}","private void buildGraphForBuildTargets(Set<BuildTarget> targets,Executor executor) throws QueryException, InterruptedException {
  try {
    graph=params.getParser().buildTargetGraph(params.getBuckEventBus(),params.getCell(),enableProfiling,executor,targets);
  }
 catch (  BuildFileParseException|BuildTargetException|IOException e) {
    throw new QueryException(""String_Node_Str"");
  }
}",0.9723320158102768
53121,"@Override public int runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {
  Ide projectIde=getIdeFromBuckConfig(params.getBuckConfig()).orNull();
  boolean needsFullRecursiveParse=!isExperimentalIntelliJProjectGenerationEnabled() && projectIde != Ide.XCODE;
  try (CommandThreadManager pool=new CommandThreadManager(""String_Node_Str"",params.getBuckConfig().getWorkQueueExecutionOrder(),getConcurrencyLimit(params.getBuckConfig()))){
    ImmutableSet<BuildTarget> passedInTargetsSet;
    TargetGraph projectGraph;
    try {
      passedInTargetsSet=params.getParser().resolveTargetSpecs(params.getBuckEventBus(),params.getCell(),getEnableProfiling(),pool.getExecutor(),parseArgumentsAsTargetNodeSpecs(params.getBuckConfig(),getArguments()));
      needsFullRecursiveParse=needsFullRecursiveParse || passedInTargetsSet.isEmpty();
      projectGraph=getProjectGraphForIde(params,pool.getExecutor(),passedInTargetsSet,needsFullRecursiveParse);
    }
 catch (    BuildTargetException|BuildFileParseException|HumanReadableException e) {
      params.getBuckEventBus().post(ConsoleEvent.severe(MoreExceptions.getHumanReadableOrLocalizedMessage(e)));
      return 1;
    }
    projectIde=getIdeBasedOnPassedInTargetsAndProjectGraph(params.getBuckConfig(),passedInTargetsSet,Optional.of(projectGraph));
    if (projectIde == ProjectCommand.Ide.XCODE) {
      checkForAndKillXcodeIfRunning(params,getIdePrompt(params.getBuckConfig()));
    }
    ProjectPredicates projectPredicates=ProjectPredicates.forIde(projectIde);
    ImmutableSet<BuildTarget> graphRoots;
    if (!passedInTargetsSet.isEmpty()) {
      ImmutableSet<BuildTarget> supplementalGraphRoots=ImmutableSet.of();
      if (projectIde == Ide.INTELLIJ && needsFullRecursiveParse) {
        supplementalGraphRoots=getRootBuildTargetsForIntelliJ(projectIde,projectGraph,projectPredicates);
      }
      graphRoots=Sets.union(passedInTargetsSet,supplementalGraphRoots).immutableCopy();
    }
 else {
      graphRoots=getRootsFromPredicate(projectGraph,projectPredicates.getProjectRootsPredicate());
    }
    TargetGraphAndTargets targetGraphAndTargets;
    try {
      targetGraphAndTargets=createTargetGraph(params,projectGraph,graphRoots,projectPredicates.getAssociatedProjectPredicate(),isWithTests(),isWithDependenciesTests(),needsFullRecursiveParse,pool.getExecutor());
    }
 catch (    BuildFileParseException|HumanReadableException e) {
      params.getBuckEventBus().post(ConsoleEvent.severe(MoreExceptions.getHumanReadableOrLocalizedMessage(e)));
      return 1;
    }
    if (getDryRun()) {
      for (      TargetNode<?> targetNode : targetGraphAndTargets.getTargetGraph().getNodes()) {
        params.getConsole().getStdOut().println(targetNode.toString());
      }
      return 0;
    }
    params.getBuckEventBus().post(ProjectGenerationEvent.started());
    int result;
    try {
switch (projectIde) {
case INTELLIJ:
        result=runIntellijProjectGenerator(params,projectGraph,targetGraphAndTargets,passedInTargetsSet);
      break;
case XCODE:
    result=runXcodeProjectGenerator(params,targetGraphAndTargets,passedInTargetsSet);
  break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
}
  finally {
params.getBuckEventBus().post(ProjectGenerationEvent.finished());
}
return result;
}
 }","@Override public int runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {
  Ide projectIde=getIdeFromBuckConfig(params.getBuckConfig()).orNull();
  boolean needsFullRecursiveParse=!isExperimentalIntelliJProjectGenerationEnabled() && projectIde != Ide.XCODE;
  try (CommandThreadManager pool=new CommandThreadManager(""String_Node_Str"",params.getBuckConfig().getWorkQueueExecutionOrder(),getConcurrencyLimit(params.getBuckConfig()))){
    ImmutableSet<BuildTarget> passedInTargetsSet;
    TargetGraph projectGraph;
    try {
      passedInTargetsSet=params.getParser().resolveTargetSpecs(params.getBuckEventBus(),params.getCell(),getEnableProfiling(),pool.getExecutor(),parseArgumentsAsTargetNodeSpecs(params.getBuckConfig(),getArguments()));
      needsFullRecursiveParse=needsFullRecursiveParse || passedInTargetsSet.isEmpty();
      projectGraph=getProjectGraphForIde(params,pool.getExecutor(),passedInTargetsSet,needsFullRecursiveParse);
    }
 catch (    BuildTargetException|BuildFileParseException|HumanReadableException e) {
      params.getBuckEventBus().post(ConsoleEvent.severe(MoreExceptions.getHumanReadableOrLocalizedMessage(e)));
      return 1;
    }
    projectIde=getIdeBasedOnPassedInTargetsAndProjectGraph(params.getBuckConfig(),passedInTargetsSet,Optional.of(projectGraph));
    if (projectIde == ProjectCommand.Ide.XCODE) {
      checkForAndKillXcodeIfRunning(params,getIdePrompt(params.getBuckConfig()));
    }
    ProjectPredicates projectPredicates=ProjectPredicates.forIde(projectIde);
    ImmutableSet<BuildTarget> graphRoots;
    if (!passedInTargetsSet.isEmpty()) {
      ImmutableSet<BuildTarget> supplementalGraphRoots=ImmutableSet.of();
      if (projectIde == Ide.INTELLIJ && needsFullRecursiveParse) {
        supplementalGraphRoots=getRootBuildTargetsForIntelliJ(projectIde,projectGraph,projectPredicates);
      }
      graphRoots=Sets.union(passedInTargetsSet,supplementalGraphRoots).immutableCopy();
    }
 else {
      graphRoots=getRootsFromPredicate(projectGraph,projectPredicates.getProjectRootsPredicate());
    }
    TargetGraphAndTargets targetGraphAndTargets;
    try {
      targetGraphAndTargets=createTargetGraph(params,projectGraph,graphRoots,projectPredicates.getAssociatedProjectPredicate(),isWithTests(),isWithDependenciesTests(),needsFullRecursiveParse,pool.getExecutor());
    }
 catch (    BuildFileParseException|BuildTargetException|HumanReadableException e) {
      params.getBuckEventBus().post(ConsoleEvent.severe(MoreExceptions.getHumanReadableOrLocalizedMessage(e)));
      return 1;
    }
    if (getDryRun()) {
      for (      TargetNode<?> targetNode : targetGraphAndTargets.getTargetGraph().getNodes()) {
        params.getConsole().getStdOut().println(targetNode.toString());
      }
      return 0;
    }
    params.getBuckEventBus().post(ProjectGenerationEvent.started());
    int result;
    try {
switch (projectIde) {
case INTELLIJ:
        result=runIntellijProjectGenerator(params,projectGraph,targetGraphAndTargets,passedInTargetsSet);
      break;
case XCODE:
    result=runXcodeProjectGenerator(params,targetGraphAndTargets,passedInTargetsSet);
  break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
}
  finally {
params.getBuckEventBus().post(ProjectGenerationEvent.finished());
}
return result;
}
 }",0.9968359198433028
53122,"private TargetGraphAndTargets createTargetGraph(CommandRunnerParams params,TargetGraph projectGraph,ImmutableSet<BuildTarget> graphRoots,AssociatedTargetNodePredicate associatedProjectPredicate,boolean isWithTests,boolean isWithDependenciesTests,boolean needsFullRecursiveParse,Executor executor) throws IOException, InterruptedException, BuildFileParseException {
  ImmutableSet<BuildTarget> explicitTestTargets=ImmutableSet.of();
  ImmutableSet<BuildTarget> graphRootsOrSourceTargets=replaceWorkspacesWithSourceTargetsIfPossible(graphRoots,projectGraph);
  if (isWithTests) {
    explicitTestTargets=TargetGraphAndTargets.getExplicitTestTargets(graphRootsOrSourceTargets,projectGraph,isWithDependenciesTests);
    if (!needsFullRecursiveParse) {
      projectGraph=params.getParser().buildTargetGraph(params.getBuckEventBus(),params.getCell(),getEnableProfiling(),executor,Sets.union(graphRoots,explicitTestTargets));
    }
  }
  return TargetGraphAndTargets.create(graphRoots,graphRootsOrSourceTargets,projectGraph,associatedProjectPredicate,isWithTests,isWithDependenciesTests,explicitTestTargets);
}","private TargetGraphAndTargets createTargetGraph(CommandRunnerParams params,TargetGraph projectGraph,ImmutableSet<BuildTarget> graphRoots,AssociatedTargetNodePredicate associatedProjectPredicate,boolean isWithTests,boolean isWithDependenciesTests,boolean needsFullRecursiveParse,Executor executor) throws IOException, InterruptedException, BuildFileParseException, BuildTargetException {
  ImmutableSet<BuildTarget> explicitTestTargets=ImmutableSet.of();
  ImmutableSet<BuildTarget> graphRootsOrSourceTargets=replaceWorkspacesWithSourceTargetsIfPossible(graphRoots,projectGraph);
  if (isWithTests) {
    explicitTestTargets=TargetGraphAndTargets.getExplicitTestTargets(graphRootsOrSourceTargets,projectGraph,isWithDependenciesTests);
    if (!needsFullRecursiveParse) {
      projectGraph=params.getParser().buildTargetGraph(params.getBuckEventBus(),params.getCell(),getEnableProfiling(),executor,Sets.union(graphRoots,explicitTestTargets));
    }
  }
  return TargetGraphAndTargets.create(graphRoots,graphRootsOrSourceTargets,projectGraph,associatedProjectPredicate,isWithTests,isWithDependenciesTests,explicitTestTargets);
}",0.990134529147982
53123,"private int doShowTargetHash(CommandRunnerParams params,Executor executor,ImmutableSet<BuildTarget> matchingBuildTargets,TargetGraph targetGraph) throws IOException, InterruptedException, BuildFileParseException {
  LOG.debug(""String_Node_Str"",matchingBuildTargets);
  Iterable<BuildTarget> matchingBuildTargetsWithTests;
  final TargetGraph targetGraphWithTests;
  if (isDetectTestChanges()) {
    ImmutableSet<BuildTarget> explicitTestTargets;
    explicitTestTargets=TargetGraphAndTargets.getExplicitTestTargets(matchingBuildTargets,targetGraph,true);
    LOG.debug(""String_Node_Str"",explicitTestTargets);
    matchingBuildTargetsWithTests=Sets.union(matchingBuildTargets,explicitTestTargets);
    targetGraphWithTests=params.getParser().buildTargetGraph(params.getBuckEventBus(),params.getCell(),getEnableProfiling(),executor,matchingBuildTargetsWithTests);
  }
 else {
    matchingBuildTargetsWithTests=matchingBuildTargets;
    targetGraphWithTests=targetGraph;
  }
  TargetHashFileMode targetHashFileMode=getTargetHashFileMode();
  FileHashLoader fileHashLoader=null;
switch (targetHashFileMode) {
case PATHS_AND_CONTENTS:
    fileHashLoader=params.getFileHashCache();
  break;
case PATHS_ONLY:
fileHashLoader=new FilePathHashLoader(params.getCell().getRoot(),getTargetHashModifiedPaths());
break;
}
if (fileHashLoader == null) {
throw new IllegalStateException(""String_Node_Str"" + targetHashFileMode);
}
ImmutableMap<BuildTarget,HashCode> buildTargetHashes=TargetGraphHashing.hashTargetGraph(params.getCell().getFilesystem(),targetGraphWithTests,fileHashLoader,matchingBuildTargetsWithTests);
for (BuildTarget target : matchingBuildTargets) {
TargetNode<?> targetNode=Preconditions.checkNotNull(targetGraphWithTests.get(target),""String_Node_Str"",target);
ImmutableSet<TargetNode<?>> dependencyClosure=getDependencyClosure(targetGraphWithTests,targetNode);
Hasher hasher=Hashing.sha1().newHasher();
ImmutableSortedSet.Builder<TargetNode<?>> nodesWithDepsAndTests=ImmutableSortedSet.naturalOrder();
nodesWithDepsAndTests.addAll(dependencyClosure);
if (isDetectTestChanges()) {
nodesWithDepsAndTests.addAll(FluentIterable.from(dependencyClosure).transformAndConcat(new Function<TargetNode<?>,Iterable<TargetNode<?>>>(){
@Override public Iterable<TargetNode<?>> apply(TargetNode<?> node){
  return targetGraphWithTests.getAll(TargetNodes.getTestTargetsForNode(node));
}
}
));
}
LOG.debug(""String_Node_Str"",target,nodesWithDepsAndTests.build());
for (TargetNode<?> nodeToHash : nodesWithDepsAndTests.build()) {
HashCode dependencyHash=buildTargetHashes.get(nodeToHash.getBuildTarget());
Preconditions.checkNotNull(dependencyHash,""String_Node_Str"",nodeToHash);
hasher.putBytes(dependencyHash.asBytes());
}
params.getConsole().getStdOut().format(""String_Node_Str"",target.getFullyQualifiedName(),hasher.hash().toString());
}
return 0;
}","private int doShowTargetHash(CommandRunnerParams params,Executor executor,ImmutableSet<BuildTarget> matchingBuildTargets,TargetGraph targetGraph) throws IOException, InterruptedException, BuildFileParseException, BuildTargetException {
  LOG.debug(""String_Node_Str"",matchingBuildTargets);
  Iterable<BuildTarget> matchingBuildTargetsWithTests;
  final TargetGraph targetGraphWithTests;
  if (isDetectTestChanges()) {
    ImmutableSet<BuildTarget> explicitTestTargets;
    explicitTestTargets=TargetGraphAndTargets.getExplicitTestTargets(matchingBuildTargets,targetGraph,true);
    LOG.debug(""String_Node_Str"",explicitTestTargets);
    matchingBuildTargetsWithTests=Sets.union(matchingBuildTargets,explicitTestTargets);
    targetGraphWithTests=params.getParser().buildTargetGraph(params.getBuckEventBus(),params.getCell(),getEnableProfiling(),executor,matchingBuildTargetsWithTests);
  }
 else {
    matchingBuildTargetsWithTests=matchingBuildTargets;
    targetGraphWithTests=targetGraph;
  }
  TargetHashFileMode targetHashFileMode=getTargetHashFileMode();
  FileHashLoader fileHashLoader=null;
switch (targetHashFileMode) {
case PATHS_AND_CONTENTS:
    fileHashLoader=params.getFileHashCache();
  break;
case PATHS_ONLY:
fileHashLoader=new FilePathHashLoader(params.getCell().getRoot(),getTargetHashModifiedPaths());
break;
}
if (fileHashLoader == null) {
throw new IllegalStateException(""String_Node_Str"" + targetHashFileMode);
}
ImmutableMap<BuildTarget,HashCode> buildTargetHashes=TargetGraphHashing.hashTargetGraph(params.getCell().getFilesystem(),targetGraphWithTests,fileHashLoader,matchingBuildTargetsWithTests);
for (BuildTarget target : matchingBuildTargets) {
TargetNode<?> targetNode=Preconditions.checkNotNull(targetGraphWithTests.get(target),""String_Node_Str"",target);
ImmutableSet<TargetNode<?>> dependencyClosure=getDependencyClosure(targetGraphWithTests,targetNode);
Hasher hasher=Hashing.sha1().newHasher();
ImmutableSortedSet.Builder<TargetNode<?>> nodesWithDepsAndTests=ImmutableSortedSet.naturalOrder();
nodesWithDepsAndTests.addAll(dependencyClosure);
if (isDetectTestChanges()) {
nodesWithDepsAndTests.addAll(FluentIterable.from(dependencyClosure).transformAndConcat(new Function<TargetNode<?>,Iterable<TargetNode<?>>>(){
@Override public Iterable<TargetNode<?>> apply(TargetNode<?> node){
  return targetGraphWithTests.getAll(TargetNodes.getTestTargetsForNode(node));
}
}
));
}
LOG.debug(""String_Node_Str"",target,nodesWithDepsAndTests.build());
for (TargetNode<?> nodeToHash : nodesWithDepsAndTests.build()) {
HashCode dependencyHash=buildTargetHashes.get(nodeToHash.getBuildTarget());
Preconditions.checkNotNull(dependencyHash,""String_Node_Str"",nodeToHash);
hasher.putBytes(dependencyHash.asBytes());
}
params.getConsole().getStdOut().format(""String_Node_Str"",target.getFullyQualifiedName(),hasher.hash().toString());
}
return 0;
}",0.9961362838075168
53124,"public TargetNode<?> getTargetNode(final BuckEventBus eventBus,final Cell cell,final ProjectBuildFileParser parser,final BuildTarget target,final TargetNodeListener nodeListener) throws BuildFileParseException, InterruptedException {
  invalidateIfProjectBuildFileParserStateChanged(cell);
  try {
    return allTargetNodes.get(target,new Callable<TargetNode<?>>(){
      @Override public TargetNode<?> call() throws Exception {
        Path buildFile=cell.getAbsolutePathToBuildFile(target);
        Preconditions.checkState(buildFile.isAbsolute());
        List<Map<String,Object>> rawNodes=loadRawNodes(cell,buildFile,parser);
        for (        Map<String,Object> rawNode : rawNodes) {
          Object shortName=rawNode.get(""String_Node_Str"");
          if (target.getShortName().equals(shortName)) {
            return createTargetNode(eventBus,cell,buildFile,target,rawNode,nodeListener);
          }
        }
        throw new HumanReadableException(NoSuchBuildTargetException.createForMissingBuildRule(target,BuildTargetPatternParser.forBaseName(target.getBaseName()),cell.getBuildFileName(),""String_Node_Str"" + buildFile));
      }
    }
);
  }
 catch (  UncheckedExecutionException|ExecutionException e) {
    throw propagate(e);
  }
}","public TargetNode<?> getTargetNode(final BuckEventBus eventBus,final Cell cell,final ProjectBuildFileParser parser,final BuildTarget target,final TargetNodeListener nodeListener) throws BuildFileParseException, BuildTargetException, InterruptedException {
  invalidateIfProjectBuildFileParserStateChanged(cell);
  try {
    return allTargetNodes.get(target,new Callable<TargetNode<?>>(){
      @Override public TargetNode<?> call() throws Exception {
        Path buildFile=cell.getAbsolutePathToBuildFile(target);
        Preconditions.checkState(buildFile.isAbsolute());
        List<Map<String,Object>> rawNodes=loadRawNodes(cell,buildFile,parser);
        for (        Map<String,Object> rawNode : rawNodes) {
          Object shortName=rawNode.get(""String_Node_Str"");
          if (target.getShortName().equals(shortName)) {
            return createTargetNode(eventBus,cell,buildFile,target,rawNode,nodeListener);
          }
        }
        throw new HumanReadableException(NoSuchBuildTargetException.createForMissingBuildRule(target,BuildTargetPatternParser.forBaseName(target.getBaseName()),cell.getBuildFileName(),""String_Node_Str"" + buildFile));
      }
    }
);
  }
 catch (  UncheckedExecutionException|ExecutionException e) {
    Throwables.propagateIfInstanceOf(e.getCause(),BuildTargetException.class);
    throw propagate(e);
  }
}",0.951135051943055
53125,"private RuntimeException propagate(Throwable e) throws BuildFileParseException, InterruptedException {
  Throwables.propagateIfInstanceOf(e.getCause(),BuildFileParseException.class);
  Throwables.propagateIfInstanceOf(e.getCause(),BuildTargetParseException.class);
  Throwables.propagateIfInstanceOf(e.getCause(),HumanReadableException.class);
  Throwables.propagateIfInstanceOf(e.getCause(),InterruptedException.class);
  if (e instanceof ExecutionException | e instanceof UncheckedExecutionException) {
    Throwable cause=e.getCause();
    if (cause instanceof ExecutionException | cause instanceof UncheckedExecutionException) {
      throw propagate(cause);
    }
    if (cause instanceof BuildFileParseException) {
      throw (BuildFileParseException)cause;
    }
    if (cause != null) {
      Throwables.propagate(cause);
    }
  }
  return Throwables.propagate(e);
}","private RuntimeException propagate(Throwable e) throws BuildFileParseException, InterruptedException {
  Throwables.propagateIfInstanceOf(e.getCause(),BuildFileParseException.class);
  Throwables.propagateIfInstanceOf(e.getCause(),BuildTargetParseException.class);
  Throwables.propagateIfInstanceOf(e.getCause(),HumanReadableException.class);
  Throwables.propagateIfInstanceOf(e.getCause(),InterruptedException.class);
  if (e instanceof ExecutionException | e instanceof UncheckedExecutionException) {
    Throwable cause=e.getCause();
    if (cause instanceof ExecutionException | cause instanceof UncheckedExecutionException) {
      throw propagate(cause);
    }
    if (cause != null) {
      return Throwables.propagate(cause);
    }
  }
  return Throwables.propagate(e);
}",0.9342184671092336
53126,"private TargetGraph buildTargetGraphInParallel(final BuckEventBus eventBus,final Cell rootCell,final boolean enableProfiling,Executor executor,final Iterable<BuildTarget> toExplore) throws IOException, InterruptedException, BuildFileParseException {
  final MutableDirectedGraph<TargetNode<?>> graph=new MutableDirectedGraph<>();
  final Map<BuildTarget,TargetNode<?>> index=new HashMap<>();
  ParseEvent.Started parseStart=ParseEvent.started(toExplore);
  eventBus.post(parseStart);
  TargetGraph targetGraph=null;
  try (final ParallelPerBuildState state=new ParallelPerBuildState(permState,marshaller,eventBus,rootCell,enableProfiling)){
    state.startParsing(ImmutableSet.<BuildTarget>builder().addAll(toExplore).build(),new ParserConfig(rootCell.getBuckConfig()),executor);
    final AbstractAcyclicDepthFirstPostOrderTraversal<BuildTarget> traversal=new AbstractAcyclicDepthFirstPostOrderTraversal<BuildTarget>(){
      @Override protected Iterator<BuildTarget> findChildren(      BuildTarget target) throws IOException, InterruptedException {
        TargetNode<?> node;
        try (SimplePerfEvent.Scope scope=getTargetNodeEventScope(eventBus,target)){
          try {
            node=state.getTargetNode(target);
          }
 catch (          BuildFileParseException|BuildTargetException e) {
            throw new RuntimeException(e);
          }
        }
         Set<BuildTarget> deps=Sets.newHashSet();
        for (        BuildTarget dep : node.getDeps()) {
          TargetNode<?> depTargetNode;
          try (SimplePerfEvent.Scope scope=getTargetNodeEventScope(eventBus,dep)){
            try {
              depTargetNode=state.getTargetNode(dep);
            }
 catch (            BuildFileParseException|BuildTargetException|HumanReadableException e) {
              throw new HumanReadableException(e,""String_Node_Str"",dep,target,e.getMessage());
            }
          }
           depTargetNode.checkVisibility(target);
          deps.add(dep);
        }
        return deps.iterator();
      }
      @Override protected void onNodeExplored(      BuildTarget target) throws IOException, InterruptedException {
        try {
          TargetNode<?> targetNode=state.getTargetNode(target);
          Preconditions.checkNotNull(targetNode,""String_Node_Str"",target);
          graph.addNode(targetNode);
          MoreMaps.putCheckEquals(index,target,targetNode);
          if (target.isFlavored()) {
            BuildTarget unflavoredTarget=BuildTarget.of(target.getUnflavoredBuildTarget());
            MoreMaps.putCheckEquals(index,unflavoredTarget,state.getTargetNode(unflavoredTarget));
          }
          for (          BuildTarget dep : targetNode.getDeps()) {
            graph.addEdge(targetNode,state.getTargetNode(dep));
          }
        }
 catch (        BuildFileParseException|BuildTargetException e) {
          throw new RuntimeException(e);
        }
      }
      @Override protected void onTraversalComplete(      Iterable<BuildTarget> nodesInExplorationOrder){
      }
    }
;
    traversal.traverse(toExplore);
    targetGraph=new TargetGraph(graph,ImmutableMap.copyOf(index));
    return targetGraph;
  }
 catch (  AbstractAcyclicDepthFirstPostOrderTraversal.CycleException e) {
    throw new HumanReadableException(e.getMessage());
  }
 finally {
    eventBus.post(ParseEvent.finished(parseStart,Optional.fromNullable(targetGraph)));
  }
}","private TargetGraph buildTargetGraphInParallel(final BuckEventBus eventBus,final Cell rootCell,final boolean enableProfiling,Executor executor,final Iterable<BuildTarget> toExplore) throws IOException, InterruptedException, BuildFileParseException, BuildTargetException {
  final MutableDirectedGraph<TargetNode<?>> graph=new MutableDirectedGraph<>();
  final Map<BuildTarget,TargetNode<?>> index=new HashMap<>();
  ParseEvent.Started parseStart=ParseEvent.started(toExplore);
  eventBus.post(parseStart);
  TargetGraph targetGraph=null;
  try (final ParallelPerBuildState state=new ParallelPerBuildState(permState,marshaller,eventBus,rootCell,enableProfiling)){
    state.startParsing(ImmutableSet.<BuildTarget>builder().addAll(toExplore).build(),new ParserConfig(rootCell.getBuckConfig()),executor);
    final AbstractAcyclicDepthFirstPostOrderTraversal<BuildTarget> traversal=new AbstractAcyclicDepthFirstPostOrderTraversal<BuildTarget>(){
      @Override protected Iterator<BuildTarget> findChildren(      BuildTarget target) throws IOException, InterruptedException {
        TargetNode<?> node;
        try (SimplePerfEvent.Scope scope=getTargetNodeEventScope(eventBus,target)){
          try {
            node=state.getTargetNode(target);
          }
 catch (          BuildFileParseException|BuildTargetException e) {
            throw new RuntimeException(e);
          }
        }
         Set<BuildTarget> deps=Sets.newHashSet();
        for (        BuildTarget dep : node.getDeps()) {
          TargetNode<?> depTargetNode;
          try (SimplePerfEvent.Scope scope=getTargetNodeEventScope(eventBus,dep)){
            try {
              depTargetNode=state.getTargetNode(dep);
            }
 catch (            BuildFileParseException|BuildTargetException|HumanReadableException e) {
              throw new HumanReadableException(e,""String_Node_Str"",dep,target,e.getMessage());
            }
          }
           depTargetNode.checkVisibility(target);
          deps.add(dep);
        }
        return deps.iterator();
      }
      @Override protected void onNodeExplored(      BuildTarget target) throws IOException, InterruptedException {
        try {
          TargetNode<?> targetNode=state.getTargetNode(target);
          Preconditions.checkNotNull(targetNode,""String_Node_Str"",target);
          graph.addNode(targetNode);
          MoreMaps.putCheckEquals(index,target,targetNode);
          if (target.isFlavored()) {
            BuildTarget unflavoredTarget=BuildTarget.of(target.getUnflavoredBuildTarget());
            MoreMaps.putCheckEquals(index,unflavoredTarget,state.getTargetNode(unflavoredTarget));
          }
          for (          BuildTarget dep : targetNode.getDeps()) {
            graph.addEdge(targetNode,state.getTargetNode(dep));
          }
        }
 catch (        BuildFileParseException|BuildTargetException e) {
          throw new RuntimeException(e);
        }
      }
      @Override protected void onTraversalComplete(      Iterable<BuildTarget> nodesInExplorationOrder){
      }
    }
;
    traversal.traverse(toExplore);
    targetGraph=new TargetGraph(graph,ImmutableMap.copyOf(index));
    return targetGraph;
  }
 catch (  AbstractAcyclicDepthFirstPostOrderTraversal.CycleException e) {
    throw new HumanReadableException(e.getMessage());
  }
catch (  RuntimeException e) {
    throw propagateRuntimeCause(e);
  }
 finally {
    eventBus.post(ParseEvent.finished(parseStart,Optional.fromNullable(targetGraph)));
  }
}",0.9864805931094636
53127,"public TargetGraph buildTargetGraph(final BuckEventBus eventBus,final Cell rootCell,final boolean enableProfiling,final Executor executor,final Iterable<BuildTarget> toExplore) throws IOException, InterruptedException, BuildFileParseException {
  ParserConfig config=new ParserConfig(rootCell.getBuckConfig());
  if (config.getEnableParallelParsing() && FluentIterable.from(toExplore).size() > 0) {
    return buildTargetGraphInParallel(eventBus,rootCell,enableProfiling,executor,toExplore);
  }
  return buildTargetGraphSerially(eventBus,rootCell,enableProfiling,toExplore);
}","public TargetGraph buildTargetGraph(final BuckEventBus eventBus,final Cell rootCell,final boolean enableProfiling,final Executor executor,final Iterable<BuildTarget> toExplore) throws IOException, InterruptedException, BuildFileParseException, BuildTargetException {
  ParserConfig config=new ParserConfig(rootCell.getBuckConfig());
  if (config.getEnableParallelParsing() && FluentIterable.from(toExplore).size() > 0) {
    return buildTargetGraphInParallel(eventBus,rootCell,enableProfiling,executor,toExplore);
  }
  return buildTargetGraphSerially(eventBus,rootCell,enableProfiling,toExplore);
}",0.9812925170068028
53128,"private TargetGraph buildTargetGraphSerially(final BuckEventBus eventBus,final Cell rootCell,final boolean enableProfiling,final Iterable<BuildTarget> toExplore) throws IOException, InterruptedException, BuildFileParseException {
  final MutableDirectedGraph<TargetNode<?>> graph=new MutableDirectedGraph<>();
  final Map<BuildTarget,TargetNode<?>> index=new HashMap<>();
  ParseEvent.Started parseStart=ParseEvent.started(toExplore);
  eventBus.post(parseStart);
  TargetGraph targetGraph=null;
  try (final PerBuildState state=new SerialPerBuildState(permState,marshaller,eventBus,rootCell,enableProfiling)){
    final AbstractAcyclicDepthFirstPostOrderTraversal<BuildTarget> traversal=new AbstractAcyclicDepthFirstPostOrderTraversal<BuildTarget>(){
      @Override protected Iterator<BuildTarget> findChildren(      BuildTarget target) throws IOException, InterruptedException {
        try (SimplePerfEvent.Scope getTargetDepsEventScope=SimplePerfEvent.scope(eventBus,PerfEventId.of(""String_Node_Str""),""String_Node_Str"",target)){
          TargetNode<?> node;
          try (SimplePerfEvent.Scope scope=getTargetNodeEventScope(eventBus,target)){
            try {
              node=state.getTargetNode(target);
            }
 catch (            BuildFileParseException|BuildTargetException e) {
              throw new RuntimeException(e);
            }
          }
           Set<BuildTarget> deps=Sets.newHashSet();
          for (          BuildTarget dep : node.getDeps()) {
            TargetNode<?> depTargetNode;
            try (SimplePerfEvent.Scope scope=getTargetNodeEventScope(eventBus,dep)){
              try {
                depTargetNode=state.getTargetNode(dep);
              }
 catch (              BuildFileParseException|BuildTargetException|HumanReadableException e) {
                throw new HumanReadableException(e,""String_Node_Str"",dep,target,e.getMessage());
              }
            }
             depTargetNode.checkVisibility(target);
            deps.add(dep);
          }
          return deps.iterator();
        }
       }
      @Override protected void onNodeExplored(      BuildTarget target) throws IOException, InterruptedException {
        try {
          TargetNode<?> targetNode=state.getTargetNode(target);
          Preconditions.checkNotNull(targetNode,""String_Node_Str"",target);
          graph.addNode(targetNode);
          MoreMaps.putCheckEquals(index,target,targetNode);
          if (target.isFlavored()) {
            BuildTarget unflavoredTarget=BuildTarget.of(target.getUnflavoredBuildTarget());
            MoreMaps.putCheckEquals(index,unflavoredTarget,state.getTargetNode(unflavoredTarget));
          }
          for (          BuildTarget dep : targetNode.getDeps()) {
            graph.addEdge(targetNode,state.getTargetNode(dep));
          }
        }
 catch (        BuildFileParseException|BuildTargetException e) {
          throw new RuntimeException(e);
        }
      }
      @Override protected void onTraversalComplete(      Iterable<BuildTarget> nodesInExplorationOrder){
      }
    }
;
    traversal.traverse(toExplore);
    targetGraph=new TargetGraph(graph,ImmutableMap.copyOf(index));
    return targetGraph;
  }
 catch (  AbstractAcyclicDepthFirstPostOrderTraversal.CycleException e) {
    throw new HumanReadableException(e.getMessage());
  }
 finally {
    eventBus.post(ParseEvent.finished(parseStart,Optional.fromNullable(targetGraph)));
  }
}","private TargetGraph buildTargetGraphSerially(final BuckEventBus eventBus,final Cell rootCell,final boolean enableProfiling,final Iterable<BuildTarget> toExplore) throws IOException, InterruptedException, BuildFileParseException, BuildTargetException {
  final MutableDirectedGraph<TargetNode<?>> graph=new MutableDirectedGraph<>();
  final Map<BuildTarget,TargetNode<?>> index=new HashMap<>();
  ParseEvent.Started parseStart=ParseEvent.started(toExplore);
  eventBus.post(parseStart);
  TargetGraph targetGraph=null;
  try (final PerBuildState state=new SerialPerBuildState(permState,marshaller,eventBus,rootCell,enableProfiling)){
    final AbstractAcyclicDepthFirstPostOrderTraversal<BuildTarget> traversal=new AbstractAcyclicDepthFirstPostOrderTraversal<BuildTarget>(){
      @Override protected Iterator<BuildTarget> findChildren(      BuildTarget target) throws IOException, InterruptedException {
        try (SimplePerfEvent.Scope getTargetDepsEventScope=SimplePerfEvent.scope(eventBus,PerfEventId.of(""String_Node_Str""),""String_Node_Str"",target)){
          TargetNode<?> node;
          try (SimplePerfEvent.Scope scope=getTargetNodeEventScope(eventBus,target)){
            try {
              node=state.getTargetNode(target);
            }
 catch (            BuildFileParseException|BuildTargetException e) {
              throw new RuntimeException(e);
            }
          }
           Set<BuildTarget> deps=Sets.newHashSet();
          for (          BuildTarget dep : node.getDeps()) {
            TargetNode<?> depTargetNode;
            try (SimplePerfEvent.Scope scope=getTargetNodeEventScope(eventBus,dep)){
              try {
                depTargetNode=state.getTargetNode(dep);
              }
 catch (              BuildFileParseException|BuildTargetException|HumanReadableException e) {
                throw new HumanReadableException(e,""String_Node_Str"",dep,target,e.getMessage());
              }
            }
             depTargetNode.checkVisibility(target);
            deps.add(dep);
          }
          return deps.iterator();
        }
       }
      @Override protected void onNodeExplored(      BuildTarget target) throws IOException, InterruptedException {
        try {
          TargetNode<?> targetNode=state.getTargetNode(target);
          Preconditions.checkNotNull(targetNode,""String_Node_Str"",target);
          graph.addNode(targetNode);
          MoreMaps.putCheckEquals(index,target,targetNode);
          if (target.isFlavored()) {
            BuildTarget unflavoredTarget=BuildTarget.of(target.getUnflavoredBuildTarget());
            MoreMaps.putCheckEquals(index,unflavoredTarget,state.getTargetNode(unflavoredTarget));
          }
          for (          BuildTarget dep : targetNode.getDeps()) {
            graph.addEdge(targetNode,state.getTargetNode(dep));
          }
        }
 catch (        BuildFileParseException|BuildTargetException e) {
          throw new RuntimeException(e);
        }
      }
      @Override protected void onTraversalComplete(      Iterable<BuildTarget> nodesInExplorationOrder){
      }
    }
;
    traversal.traverse(toExplore);
    targetGraph=new TargetGraph(graph,ImmutableMap.copyOf(index));
    return targetGraph;
  }
 catch (  AbstractAcyclicDepthFirstPostOrderTraversal.CycleException e) {
    throw new HumanReadableException(e.getMessage());
  }
catch (  RuntimeException e) {
    throw propagateRuntimeCause(e);
  }
 finally {
    eventBus.post(ParseEvent.finished(parseStart,Optional.fromNullable(targetGraph)));
  }
}",0.9866513563944308
53129,"@SuppressWarnings(""String_Node_Str"") @Test public void xCellVisibilityShouldWorkAsExpected() throws IOException, InterruptedException, BuildFileParseException {
  try {
    parseTargetForXCellVisibility(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  HumanReadableException expected) {
  }
}","@SuppressWarnings(""String_Node_Str"") @Test public void xCellVisibilityShouldWorkAsExpected() throws IOException, InterruptedException, BuildFileParseException, BuildTargetException {
  try {
    parseTargetForXCellVisibility(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  HumanReadableException expected) {
  }
}",0.9652996845425869
53130,"@Test public void xCellSingleDirectoryVisibilityPatternsWork() throws InterruptedException, BuildFileParseException, IOException {
  parseTargetForXCellVisibility(""String_Node_Str"");
}","@Test public void xCellSingleDirectoryVisibilityPatternsWork() throws InterruptedException, BuildFileParseException, IOException, BuildTargetException {
  parseTargetForXCellVisibility(""String_Node_Str"");
}",0.9435897435897436
53131,"private void parseTargetForXCellVisibility(String targetName) throws IOException, InterruptedException, BuildFileParseException {
  Pair<ProjectWorkspace,ProjectWorkspace> cells=prepare(""String_Node_Str"",""String_Node_Str"");
  ProjectWorkspace primary=cells.getFirst();
  ProjectWorkspace secondary=cells.getSecond();
  registerCell(secondary,""String_Node_Str"",primary);
  TypeCoercerFactory coercerFactory=new DefaultTypeCoercerFactory();
  Parser parser=new Parser(new ParserConfig(cells.getFirst().asCell().getBuckConfig()),coercerFactory,new ConstructorArgMarshaller(coercerFactory));
  BuckEventBus eventBus=BuckEventBusFactory.newInstance();
  Cell primaryCell=primary.asCell();
  BuildTarget namedTarget=BuildTargetFactory.newInstance(primaryCell.getFilesystem(),targetName);
  parser.buildTargetGraph(eventBus,primaryCell,false,Executors.newSingleThreadExecutor(),ImmutableSet.of(namedTarget));
}","private void parseTargetForXCellVisibility(String targetName) throws IOException, InterruptedException, BuildFileParseException, BuildTargetException {
  Pair<ProjectWorkspace,ProjectWorkspace> cells=prepare(""String_Node_Str"",""String_Node_Str"");
  ProjectWorkspace primary=cells.getFirst();
  ProjectWorkspace secondary=cells.getSecond();
  registerCell(secondary,""String_Node_Str"",primary);
  TypeCoercerFactory coercerFactory=new DefaultTypeCoercerFactory();
  Parser parser=new Parser(new ParserConfig(cells.getFirst().asCell().getBuckConfig()),coercerFactory,new ConstructorArgMarshaller(coercerFactory));
  BuckEventBus eventBus=BuckEventBusFactory.newInstance();
  Cell primaryCell=primary.asCell();
  BuildTarget namedTarget=BuildTargetFactory.newInstance(primaryCell.getFilesystem(),targetName);
  parser.buildTargetGraph(eventBus,primaryCell,false,Executors.newSingleThreadExecutor(),ImmutableSet.of(namedTarget));
}",0.9879649890590808
53132,"@Test public void xCellSubDirectoryVisibilityPatternsWork() throws InterruptedException, BuildFileParseException, IOException {
  parseTargetForXCellVisibility(""String_Node_Str"");
}","@Test public void xCellSubDirectoryVisibilityPatternsWork() throws InterruptedException, BuildFileParseException, IOException, BuildTargetException {
  parseTargetForXCellVisibility(""String_Node_Str"");
}",0.9427083333333334
53133,"@Test public void xCellVisibilityPatternsBasedOnExplicitBuildTargetsWork() throws InterruptedException, BuildFileParseException, IOException {
  parseTargetForXCellVisibility(""String_Node_Str"");
}","@Test public void xCellVisibilityPatternsBasedOnExplicitBuildTargetsWork() throws InterruptedException, BuildFileParseException, IOException, BuildTargetException {
  parseTargetForXCellVisibility(""String_Node_Str"");
}",0.9468599033816424
53134,"@Test public void testMissingBuildRuleInValidFile() throws BuildFileParseException, BuildTargetException, IOException, InterruptedException {
  BuildTarget fooTarget=BuildTarget.builder(cellRoot,""String_Node_Str"",""String_Node_Str"").build();
  BuildTarget razTarget=BuildTarget.builder(cellRoot,""String_Node_Str"",""String_Node_Str"").build();
  Iterable<BuildTarget> buildTargets=ImmutableList.of(fooTarget,razTarget);
  thrown.expect(HumanReadableException.class);
  thrown.expectMessage(""String_Node_Str"" + ""String_Node_Str"");
  thrown.expectMessage(""String_Node_Str"" + filesystem.resolve(razTarget.getBasePath()).resolve(DEFAULT_BUILD_FILE_NAME));
  parser.buildTargetGraph(eventBus,cell,false,executorService,buildTargets);
}","@Test public void testMissingBuildRuleInValidFile() throws BuildFileParseException, BuildTargetException, IOException, InterruptedException {
  BuildTarget fooTarget=BuildTarget.builder(cellRoot,""String_Node_Str"",""String_Node_Str"").build();
  BuildTarget razTarget=BuildTarget.builder(cellRoot,""String_Node_Str"",""String_Node_Str"").build();
  Iterable<BuildTarget> buildTargets=ImmutableList.of(fooTarget,razTarget);
  thrown.expectMessage(""String_Node_Str"" + ""String_Node_Str"");
  thrown.expectMessage(""String_Node_Str"" + filesystem.resolve(razTarget.getBasePath()).resolve(DEFAULT_BUILD_FILE_NAME));
  parser.buildTargetGraph(eventBus,cell,false,executorService,buildTargets);
}",0.9665480427046264
53135,"@Test public void shouldThrowAnExceptionIfADepIsInAFileThatCannotBeParsed() throws IOException, InterruptedException, BuildTargetException, BuildFileParseException {
  thrown.expect(HumanReadableException.class);
  thrown.expectMessage(""String_Node_Str"");
  thrown.expectMessage(""String_Node_Str"");
  Path buckFile=cellRoot.resolve(""String_Node_Str"");
  Files.write(buckFile,""String_Node_Str"".getBytes(UTF_8));
  buckFile=cellRoot.resolve(""String_Node_Str"");
  Files.createDirectories(buckFile.getParent());
  Files.write(buckFile,""String_Node_Str"".getBytes(UTF_8));
  parser.buildTargetGraph(eventBus,cell,false,executorService,Collections.singleton(BuildTargetFactory.newInstance(cell.getFilesystem(),""String_Node_Str"")));
}","@Test public void shouldThrowAnExceptionIfADepIsInAFileThatCannotBeParsed() throws IOException, InterruptedException, BuildTargetException, BuildFileParseException {
  thrown.expectMessage(""String_Node_Str"");
  thrown.expectMessage(Paths.get(""String_Node_Str"").toString());
  Path buckFile=cellRoot.resolve(""String_Node_Str"");
  Files.write(buckFile,""String_Node_Str"".getBytes(UTF_8));
  buckFile=cellRoot.resolve(""String_Node_Str"");
  Files.createDirectories(buckFile.getParent());
  Files.write(buckFile,""String_Node_Str"".getBytes(UTF_8));
  parser.buildTargetGraph(eventBus,cell,false,executorService,Collections.singleton(BuildTargetFactory.newInstance(cell.getFilesystem(),""String_Node_Str"")));
}",0.8997897687456202
53136,"@Override public FileVisitResult visitFile(Path file,BasicFileAttributes attr) throws IOException {
  String filename=file.getFileName().toString();
  if (isResource(filename)) {
    paths.add(new PathSourcePath(filesystem,file));
  }
  return FileVisitResult.CONTINUE;
}","@Override public FileVisitResult visitFile(Path file,BasicFileAttributes attr) throws IOException {
  if (isResource(file)) {
    paths.add(new PathSourcePath(filesystem,file));
  }
  return FileVisitResult.CONTINUE;
}",0.8916155419222904
53137,"private boolean isResource(String fileOrDirName){
  if (NON_ASSET_FILENAMES.contains(fileOrDirName.toLowerCase())) {
    return false;
  }
  if (fileOrDirName.charAt(fileOrDirName.length() - 1) == '~') {
    return false;
  }
  if (MiniAapt.IGNORED_FILE_EXTENSIONS.contains(Files.getFileExtension(fileOrDirName))) {
    return false;
  }
  return true;
}","private boolean isResource(Path fileOrDir) throws IOException {
  for (  String nonAssetFilename : NON_ASSET_FILENAMES) {
    if (filesystem.isSameRelativePathIfFileExists(fileOrDir,fileOrDir.resolveSibling(nonAssetFilename))) {
      return false;
    }
  }
  String fileOrDirName=fileOrDir.getFileName().toString();
  if (fileOrDirName.charAt(fileOrDirName.length() - 1) == '~') {
    return false;
  }
  String fileOrDirNameWithoutExtension=Files.getNameWithoutExtension(fileOrDirName);
  for (  String ignoredMiniAaptExtension : MiniAapt.IGNORED_FILE_EXTENSIONS) {
    if (filesystem.isSameRelativePathIfFileExists(fileOrDir,fileOrDir.resolveSibling(fileOrDirNameWithoutExtension + ""String_Node_Str"" + ignoredMiniAaptExtension))) {
      return false;
    }
  }
  return true;
}",0.4348591549295774
53138,"@VisibleForTesting ImmutableSortedSet<SourcePath> collectInputFiles(final ProjectFilesystem filesystem,Optional<Path> inputDir){
  if (!inputDir.isPresent()) {
    return ImmutableSortedSet.of();
  }
  final ImmutableSortedSet.Builder<SourcePath> paths=ImmutableSortedSet.naturalOrder();
  FileVisitor<Path> fileVisitor=new SimpleFileVisitor<Path>(){
    @Override public FileVisitResult preVisitDirectory(    Path dir,    BasicFileAttributes attr) throws IOException {
      String dirName=dir.getFileName().toString();
      if (dirName.charAt(0) == '_' || !isResource(dirName)) {
        return FileVisitResult.SKIP_SUBTREE;
      }
      return FileVisitResult.CONTINUE;
    }
    @Override public FileVisitResult visitFile(    Path file,    BasicFileAttributes attr) throws IOException {
      String filename=file.getFileName().toString();
      if (isResource(filename)) {
        paths.add(new PathSourcePath(filesystem,file));
      }
      return FileVisitResult.CONTINUE;
    }
    private boolean isResource(    String fileOrDirName){
      if (NON_ASSET_FILENAMES.contains(fileOrDirName.toLowerCase())) {
        return false;
      }
      if (fileOrDirName.charAt(fileOrDirName.length() - 1) == '~') {
        return false;
      }
      if (MiniAapt.IGNORED_FILE_EXTENSIONS.contains(Files.getFileExtension(fileOrDirName))) {
        return false;
      }
      return true;
    }
  }
;
  try {
    filesystem.walkRelativeFileTree(inputDir.get(),fileVisitor);
  }
 catch (  IOException e) {
    throw new HumanReadableException(e,""String_Node_Str"",inputDir.get());
  }
  return paths.build();
}","@VisibleForTesting ImmutableSortedSet<SourcePath> collectInputFiles(final ProjectFilesystem filesystem,Optional<Path> inputDir){
  if (!inputDir.isPresent()) {
    return ImmutableSortedSet.of();
  }
  final ImmutableSortedSet.Builder<SourcePath> paths=ImmutableSortedSet.naturalOrder();
  FileVisitor<Path> fileVisitor=new SimpleFileVisitor<Path>(){
    @Override public FileVisitResult preVisitDirectory(    Path dir,    BasicFileAttributes attr) throws IOException {
      if (dir.getFileName().toString().charAt(0) == '_' || !isResource(dir)) {
        return FileVisitResult.SKIP_SUBTREE;
      }
      return FileVisitResult.CONTINUE;
    }
    @Override public FileVisitResult visitFile(    Path file,    BasicFileAttributes attr) throws IOException {
      if (isResource(file)) {
        paths.add(new PathSourcePath(filesystem,file));
      }
      return FileVisitResult.CONTINUE;
    }
    private boolean isResource(    Path fileOrDir) throws IOException {
      for (      String nonAssetFilename : NON_ASSET_FILENAMES) {
        if (filesystem.isSameRelativePathIfFileExists(fileOrDir,fileOrDir.resolveSibling(nonAssetFilename))) {
          return false;
        }
      }
      String fileOrDirName=fileOrDir.getFileName().toString();
      if (fileOrDirName.charAt(fileOrDirName.length() - 1) == '~') {
        return false;
      }
      String fileOrDirNameWithoutExtension=Files.getNameWithoutExtension(fileOrDirName);
      for (      String ignoredMiniAaptExtension : MiniAapt.IGNORED_FILE_EXTENSIONS) {
        if (filesystem.isSameRelativePathIfFileExists(fileOrDir,fileOrDir.resolveSibling(fileOrDirNameWithoutExtension + ""String_Node_Str"" + ignoredMiniAaptExtension))) {
          return false;
        }
      }
      return true;
    }
  }
;
  try {
    filesystem.walkRelativeFileTree(inputDir.get(),fileVisitor);
  }
 catch (  IOException e) {
    throw new HumanReadableException(e,""String_Node_Str"",inputDir.get());
  }
  return paths.build();
}",0.7789238918316141
53139,"@Override public FileVisitResult preVisitDirectory(Path dir,BasicFileAttributes attr) throws IOException {
  String dirName=dir.getFileName().toString();
  if (dirName.charAt(0) == '_' || !isResource(dirName)) {
    return FileVisitResult.SKIP_SUBTREE;
  }
  return FileVisitResult.CONTINUE;
}","@Override public FileVisitResult preVisitDirectory(Path dir,BasicFileAttributes attr) throws IOException {
  if (dir.getFileName().toString().charAt(0) == '_' || !isResource(dir)) {
    return FileVisitResult.SKIP_SUBTREE;
  }
  return FileVisitResult.CONTINUE;
}",0.8525179856115108
53140,"private void updateAndStoreManifest(BuildRule rule,RuleKey key,ImmutableSet<SourcePath> inputs,ArtifactCache cache) throws IOException, InterruptedException {
  Preconditions.checkState(useManifestCaching(rule));
  Pair<RuleKey,ImmutableSet<SourcePath>> manifestKey=ruleKeyFactories.getUnchecked(rule.getProjectFilesystem()).depFileRuleKeyBuilderFactory.buildManifestKey(rule);
  Path manifestPath=getManifestPath(rule);
  Manifest manifest=new Manifest();
  if (rule.getProjectFilesystem().exists(manifestPath)) {
    try (InputStream inputStream=rule.getProjectFilesystem().newFileInputStream(manifestPath)){
      manifest=new Manifest(inputStream);
    }
   }
  if (manifest.size() >= maxDepFileCacheEntries) {
    manifest=new Manifest();
  }
  manifest.addEntry(fileHashCaches.getUnchecked(rule.getProjectFilesystem()),key,pathResolver,manifestKey.getSecond(),inputs);
  try (OutputStream outputStream=rule.getProjectFilesystem().newFileOutputStream(manifestPath)){
    manifest.serialize(outputStream);
  }
   try (NamedTemporaryFile tempFile=new NamedTemporaryFile(""String_Node_Str"",""String_Node_Str"")){
    try (InputStream inputStream=rule.getProjectFilesystem().newFileInputStream(manifestPath);OutputStream outputStream=new GZIPOutputStream(new BufferedOutputStream(Files.newOutputStream(tempFile.get())))){
      ByteStreams.copy(inputStream,outputStream);
    }
     cache.store(ImmutableSet.of(manifestKey.getFirst()),ImmutableMap.<String,String>of(),tempFile.get());
  }
 }","private void updateAndStoreManifest(BuildRule rule,RuleKey key,ImmutableSet<SourcePath> inputs,ArtifactCache cache) throws IOException, InterruptedException {
  Preconditions.checkState(useManifestCaching(rule));
  Pair<RuleKey,ImmutableSet<SourcePath>> manifestKey=ruleKeyFactories.getUnchecked(rule.getProjectFilesystem()).depFileRuleKeyBuilderFactory.buildManifestKey(rule);
  final Path manifestPath=getManifestPath(rule);
  Manifest manifest=new Manifest();
  if (rule.getProjectFilesystem().exists(manifestPath)) {
    try (InputStream inputStream=rule.getProjectFilesystem().newFileInputStream(manifestPath)){
      manifest=new Manifest(inputStream);
    }
   }
  if (manifest.size() >= maxDepFileCacheEntries) {
    manifest=new Manifest();
  }
  manifest.addEntry(fileHashCaches.getUnchecked(rule.getProjectFilesystem()),key,pathResolver,manifestKey.getSecond(),inputs);
  try (OutputStream outputStream=rule.getProjectFilesystem().newFileOutputStream(manifestPath)){
    manifest.serialize(outputStream);
  }
   final NamedTemporaryFile tempFile=new NamedTemporaryFile(""String_Node_Str"",""String_Node_Str"");
  try {
    try (InputStream inputStream=rule.getProjectFilesystem().newFileInputStream(manifestPath);OutputStream outputStream=new GZIPOutputStream(new BufferedOutputStream(Files.newOutputStream(tempFile.get())))){
      ByteStreams.copy(inputStream,outputStream);
    }
     cache.store(ImmutableSet.of(manifestKey.getFirst()),ImmutableMap.<String,String>of(),tempFile.get()).addListener(new Runnable(){
      @Override public void run(){
        try {
          tempFile.close();
        }
 catch (        IOException e) {
          LOG.warn(e,""String_Node_Str"",manifestPath);
        }
      }
    }
,MoreExecutors.directExecutor());
  }
 catch (  InterruptedException e) {
    tempFile.close();
    throw e;
  }
}",0.89203007518797
53141,"@Override public NativeLinkableInput getNativeLinkableInput(CxxPlatform cxxPlatform,Linker.LinkableDepType type){
  HalideLibrary rule=(HalideLibrary)requireBuildRule(cxxPlatform);
  Path libPath=getPathToOutput().resolve(rule.getLibraryName());
  return NativeLinkableInput.of(SourcePathArg.from(getResolver(),new BuildTargetSourcePath(rule.getBuildTarget(),libPath)),ImmutableSet.<FrameworkPath>of(),ImmutableSet.<FrameworkPath>of());
}","@Override public NativeLinkableInput getNativeLinkableInput(CxxPlatform cxxPlatform,Linker.LinkableDepType type){
  HalideLibrary rule=(HalideLibrary)requireBuildRule(cxxPlatform);
  Path libPath=rule.getPathToOutput().resolve(rule.getLibraryName());
  return NativeLinkableInput.of(SourcePathArg.from(getResolver(),new BuildTargetSourcePath(rule.getBuildTarget(),libPath)),ImmutableSet.<FrameworkPath>of(),ImmutableSet.<FrameworkPath>of());
}",0.9943246311010216
53142,"/** 
 * Modified version of <a href=""http://fburl.com/8840769"">Device.uninstallPackage()</a>.
 * @param device an {@link IDevice}
 * @param packageName application package name
 * @param keepData  true if user data is to be kept
 * @return error message or null if successful
 * @throws InstallException
 */
@Nullable private String deviceUninstallPackage(IDevice device,String packageName,boolean keepData) throws InstallException {
  try {
    AdbHelper.ErrorParsingReceiver receiver=new AdbHelper.ErrorParsingReceiver(){
      @Override @Nullable protected String matchForError(      String line){
        return line.toLowerCase().contains(""String_Node_Str"") ? line : null;
      }
    }
;
    device.executeShellCommand(""String_Node_Str"" + (keepData ? ""String_Node_Str"" : ""String_Node_Str"") + packageName,receiver,AdbHelper.INSTALL_TIMEOUT,TimeUnit.MILLISECONDS);
    return receiver.getErrorMessage();
  }
 catch (  AdbCommandRejectedException|IOException|ShellCommandUnresponsiveException|TimeoutException e) {
    throw new InstallException(e);
  }
}","/** 
 * Modified version of <a href=""http://fburl.com/8840769"">Device.uninstallPackage()</a>.
 * @param device an {@link IDevice}
 * @param packageName application package name
 * @param keepData  true if user data is to be kept
 * @return error message or null if successful
 * @throws InstallException
 */
@Nullable private String deviceUninstallPackage(IDevice device,String packageName,boolean keepData) throws InstallException {
  try {
    AdbHelper.ErrorParsingReceiver receiver=new AdbHelper.ErrorParsingReceiver(){
      @Override @Nullable protected String matchForError(      String line){
        return line.toLowerCase(Locale.US).contains(""String_Node_Str"") ? line : null;
      }
    }
;
    device.executeShellCommand(""String_Node_Str"" + (keepData ? ""String_Node_Str"" : ""String_Node_Str"") + packageName,receiver,AdbHelper.INSTALL_TIMEOUT,TimeUnit.MILLISECONDS);
    return receiver.getErrorMessage();
  }
 catch (  AdbCommandRejectedException|IOException|ShellCommandUnresponsiveException|TimeoutException e) {
    throw new InstallException(e);
  }
}",0.995764705882353
53143,"@VisibleForTesting protected boolean isDeviceTempWritable(IDevice device,String name){
  StringBuilder loggingInfo=new StringBuilder();
  try {
    String output=null;
    try {
      output=executeCommandWithErrorChecking(device,""String_Node_Str"");
      if (!(output.matches(""String_Node_Str"") || output.matches(""String_Node_Str""))) {
        loggingInfo.append(String.format(java.util.Locale.ENGLISH,""String_Node_Str"",output));
      }
      executeCommandWithErrorChecking(device,""String_Node_Str"");
      output=executeCommandWithErrorChecking(device,""String_Node_Str"");
      if (!output.matches(""String_Node_Str"")) {
        loggingInfo.append(String.format(java.util.Locale.ENGLISH,""String_Node_Str"",output));
      }
      executeCommandWithErrorChecking(device,""String_Node_Str"");
    }
 catch (    CommandFailedException e) {
      loggingInfo.append(String.format(java.util.Locale.ENGLISH,""String_Node_Str"",e.exitCode,e.command,e.output));
    }
    if (!loggingInfo.toString().isEmpty()) {
      CollectingOutputReceiver receiver=new CollectingOutputReceiver();
      device.executeShellCommand(""String_Node_Str"",receiver);
      for (      String line : com.google.common.base.Splitter.on('\n').split(receiver.getOutput())) {
        if (line.contains(""String_Node_Str"") || line.contains(""String_Node_Str"")) {
          loggingInfo.append(line).append('\n');
        }
      }
    }
  }
 catch (  AdbCommandRejectedException|ShellCommandUnresponsiveException|TimeoutException|IOException e) {
    console.printBuildFailure(String.format(""String_Node_Str"",name));
    e.printStackTrace(console.getStdErr());
    return false;
  }
  String logMessage=loggingInfo.toString();
  if (!logMessage.isEmpty()) {
    StringBuilder fullMessage=new StringBuilder();
    fullMessage.append(""String_Node_Str"");
    fullMessage.append('\n');
    fullMessage.append(""String_Node_Str"");
    fullMessage.append('\n');
    fullMessage.append(""String_Node_Str"");
    fullMessage.append(""String_Node_Str"");
    fullMessage.append(logMessage);
    fullMessage.append(""String_Node_Str"");
    console.getStdErr().println(fullMessage.toString());
  }
  return true;
}","@VisibleForTesting protected boolean isDeviceTempWritable(IDevice device,String name){
  StringBuilder loggingInfo=new StringBuilder();
  try {
    String output=null;
    try {
      output=executeCommandWithErrorChecking(device,""String_Node_Str"");
      if (!(output.matches(""String_Node_Str"") || output.matches(""String_Node_Str""))) {
        loggingInfo.append(String.format(Locale.ENGLISH,""String_Node_Str"",output));
      }
      executeCommandWithErrorChecking(device,""String_Node_Str"");
      output=executeCommandWithErrorChecking(device,""String_Node_Str"");
      if (!output.matches(""String_Node_Str"")) {
        loggingInfo.append(String.format(Locale.ENGLISH,""String_Node_Str"",output));
      }
      executeCommandWithErrorChecking(device,""String_Node_Str"");
    }
 catch (    CommandFailedException e) {
      loggingInfo.append(String.format(Locale.ENGLISH,""String_Node_Str"",e.exitCode,e.command,e.output));
    }
    if (!loggingInfo.toString().isEmpty()) {
      CollectingOutputReceiver receiver=new CollectingOutputReceiver();
      device.executeShellCommand(""String_Node_Str"",receiver);
      for (      String line : com.google.common.base.Splitter.on('\n').split(receiver.getOutput())) {
        if (line.contains(""String_Node_Str"") || line.contains(""String_Node_Str"")) {
          loggingInfo.append(line).append('\n');
        }
      }
    }
  }
 catch (  AdbCommandRejectedException|ShellCommandUnresponsiveException|TimeoutException|IOException e) {
    console.printBuildFailure(String.format(""String_Node_Str"",name));
    e.printStackTrace(console.getStdErr());
    return false;
  }
  String logMessage=loggingInfo.toString();
  if (!logMessage.isEmpty()) {
    StringBuilder fullMessage=new StringBuilder();
    fullMessage.append(""String_Node_Str"");
    fullMessage.append('\n');
    fullMessage.append(""String_Node_Str"");
    fullMessage.append('\n');
    fullMessage.append(""String_Node_Str"");
    fullMessage.append(""String_Node_Str"");
    fullMessage.append(logMessage);
    fullMessage.append(""String_Node_Str"");
    console.getStdErr().println(fullMessage.toString());
  }
  return true;
}",0.9929971988795518
53144,"@Override @Nullable protected String matchForError(String line){
  return line.toLowerCase().contains(""String_Node_Str"") ? line : null;
}","@Override @Nullable protected String matchForError(String line){
  return line.toLowerCase(Locale.US).contains(""String_Node_Str"") ? line : null;
}",0.9681978798586572
53145,"@SuppressWarnings(""String_Node_Str"") private Optional<PBXTarget> generateProjectTarget(TargetNode<?> targetNode) throws IOException {
  Preconditions.checkState(isBuiltByCurrentProject(targetNode.getBuildTarget()),""String_Node_Str"");
  Optional<PBXTarget> result=Optional.absent();
  if (targetNode.getType().equals(AppleLibraryDescription.TYPE)) {
    result=Optional.<PBXTarget>of(generateAppleLibraryTarget(project,(TargetNode<AppleNativeTargetDescriptionArg>)targetNode,Optional.<TargetNode<AppleBundleDescription.Arg>>absent()));
  }
 else   if (targetNode.getType().equals(CxxLibraryDescription.TYPE)) {
    result=Optional.<PBXTarget>of(generateCxxLibraryTarget(project,(TargetNode<CxxLibraryDescription.Arg>)targetNode,ImmutableSet.<AppleResourceDescription.Arg>of(),ImmutableSet.<AppleAssetCatalogDescription.Arg>of(),Optional.<TargetNode<AppleBundleDescription.Arg>>absent()));
  }
 else   if (targetNode.getType().equals(AppleBinaryDescription.TYPE)) {
    result=Optional.<PBXTarget>of(generateAppleBinaryTarget(project,(TargetNode<AppleNativeTargetDescriptionArg>)targetNode));
  }
 else   if (targetNode.getType().equals(AppleBundleDescription.TYPE)) {
    TargetNode<AppleBundleDescription.Arg> bundleTargetNode=(TargetNode<AppleBundleDescription.Arg>)targetNode;
    result=Optional.<PBXTarget>of(generateAppleBundleTarget(project,bundleTargetNode,(TargetNode<AppleNativeTargetDescriptionArg>)Preconditions.checkNotNull(targetGraph.get(bundleTargetNode.getConstructorArg().binary)),Optional.<TargetNode<AppleBundleDescription.Arg>>absent()));
  }
 else   if (targetNode.getType().equals(AppleTestDescription.TYPE)) {
    result=generateAppleTestTarget((TargetNode<AppleTestDescription.Arg>)targetNode);
  }
 else   if (targetNode.getType().equals(AppleResourceDescription.TYPE)) {
    checkAppleResourceTargetNodeReferencingValidContents((TargetNode<AppleResourceDescription.Arg>)targetNode);
  }
 else   if (targetNode.getType().equals(HalideLibraryDescription.TYPE)) {
    TargetNode<HalideLibraryDescription.Arg> halideTargetNode=(TargetNode<HalideLibraryDescription.Arg>)targetNode;
    BuildTarget buildTarget=targetNode.getBuildTarget();
    if (!HalideLibraryDescription.isHalideCompilerTarget(buildTarget)) {
      result=generateHalideLibraryTarget(project,halideTargetNode);
      requiredBuildTargetsBuilder.add(buildTarget);
    }
  }
  buckEventBus.post(ProjectGenerationEvent.processed());
  return result;
}","@SuppressWarnings(""String_Node_Str"") private Optional<PBXTarget> generateProjectTarget(TargetNode<?> targetNode) throws IOException {
  Preconditions.checkState(isBuiltByCurrentProject(targetNode.getBuildTarget()),""String_Node_Str"");
  Optional<PBXTarget> result=Optional.absent();
  if (targetNode.getType().equals(AppleLibraryDescription.TYPE)) {
    result=Optional.<PBXTarget>of(generateAppleLibraryTarget(project,(TargetNode<AppleNativeTargetDescriptionArg>)targetNode,Optional.<TargetNode<AppleBundleDescription.Arg>>absent()));
  }
 else   if (targetNode.getType().equals(CxxLibraryDescription.TYPE)) {
    result=Optional.<PBXTarget>of(generateCxxLibraryTarget(project,(TargetNode<CxxLibraryDescription.Arg>)targetNode,ImmutableSet.<AppleResourceDescription.Arg>of(),ImmutableSet.<AppleAssetCatalogDescription.Arg>of(),Optional.<TargetNode<AppleBundleDescription.Arg>>absent()));
  }
 else   if (targetNode.getType().equals(AppleBinaryDescription.TYPE)) {
    result=Optional.<PBXTarget>of(generateAppleBinaryTarget(project,(TargetNode<AppleNativeTargetDescriptionArg>)targetNode));
  }
 else   if (targetNode.getType().equals(AppleBundleDescription.TYPE)) {
    TargetNode<AppleBundleDescription.Arg> bundleTargetNode=(TargetNode<AppleBundleDescription.Arg>)targetNode;
    result=Optional.<PBXTarget>of(generateAppleBundleTarget(project,bundleTargetNode,(TargetNode<AppleNativeTargetDescriptionArg>)Preconditions.checkNotNull(targetGraph.get(bundleTargetNode.getConstructorArg().binary)),Optional.<TargetNode<AppleBundleDescription.Arg>>absent()));
  }
 else   if (targetNode.getType().equals(AppleTestDescription.TYPE)) {
    result=generateAppleTestTarget((TargetNode<AppleTestDescription.Arg>)targetNode);
  }
 else   if (targetNode.getType().equals(AppleResourceDescription.TYPE)) {
    checkAppleResourceTargetNodeReferencingValidContents((TargetNode<AppleResourceDescription.Arg>)targetNode);
  }
 else   if (targetNode.getType().equals(HalideLibraryDescription.TYPE)) {
    TargetNode<HalideLibraryDescription.Arg> halideTargetNode=(TargetNode<HalideLibraryDescription.Arg>)targetNode;
    BuildTarget buildTarget=targetNode.getBuildTarget();
    if (!HalideLibraryDescription.isHalideCompilerTarget(buildTarget)) {
      result=generateHalideLibraryTarget(project,halideTargetNode);
      requiredBuildTargetsBuilder.add(HalideLibraryDescription.createHalideCompilerBuildTarget(buildTarget));
      requiredBuildTargetsBuilder.add(buildTarget);
    }
  }
  buckEventBus.post(ProjectGenerationEvent.processed());
  return result;
}",0.9779382270357
53146,"@Test public void testHalideLibraryRule() throws IOException {
  BuildTarget compilerTarget=BuildTarget.builder(rootPath,""String_Node_Str"",""String_Node_Str"").addFlavors(HalideLibraryDescription.HALIDE_COMPILER_FLAVOR).build();
  TargetNode<?> compiler=new HalideLibraryBuilder(compilerTarget).setSrcs(ImmutableSortedSet.of(SourceWithFlags.of(new TestSourcePath(""String_Node_Str"")),SourceWithFlags.of(new TestSourcePath(""String_Node_Str"")))).build();
  BuildTarget libTarget=BuildTarget.builder(rootPath,""String_Node_Str"",""String_Node_Str"").build();
  TargetNode<?> lib=new HalideLibraryBuilder(libTarget).build();
  ProjectGenerator projectGenerator=createProjectGeneratorForCombinedProject(ImmutableSet.<TargetNode<?>>of(compiler,lib));
  projectGenerator.createXcodeProjects();
  PBXTarget target=assertTargetExistsAndReturnTarget(projectGenerator.getGeneratedProject(),""String_Node_Str"");
  assertThat(target.isa(),equalTo(""String_Node_Str""));
  assertHasConfigurations(target,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(1,target.getBuildPhases().size());
  PBXShellScriptBuildPhase scriptPhase=getSingletonPhaseByType(target,PBXShellScriptBuildPhase.class);
  assertEquals(0,scriptPhase.getInputPaths().size());
  assertEquals(0,scriptPhase.getOutputPaths().size());
}","@Test public void testHalideLibraryRule() throws IOException {
  BuildTarget compilerTarget=BuildTarget.builder(rootPath,""String_Node_Str"",""String_Node_Str"").addFlavors(HalideLibraryDescription.HALIDE_COMPILER_FLAVOR).build();
  TargetNode<?> compiler=new HalideLibraryBuilder(compilerTarget).setSrcs(ImmutableSortedSet.of(SourceWithFlags.of(new TestSourcePath(""String_Node_Str"")),SourceWithFlags.of(new TestSourcePath(""String_Node_Str"")))).build();
  BuildTarget libTarget=BuildTarget.builder(rootPath,""String_Node_Str"",""String_Node_Str"").build();
  TargetNode<?> lib=new HalideLibraryBuilder(libTarget).build();
  ProjectGenerator projectGenerator=createProjectGeneratorForCombinedProject(ImmutableSet.<TargetNode<?>>of(compiler,lib));
  projectGenerator.createXcodeProjects();
  PBXTarget target=assertTargetExistsAndReturnTarget(projectGenerator.getGeneratedProject(),""String_Node_Str"");
  assertThat(target.isa(),equalTo(""String_Node_Str""));
  assertHasConfigurations(target,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(1,target.getBuildPhases().size());
  PBXShellScriptBuildPhase scriptPhase=getSingletonPhaseByType(target,PBXShellScriptBuildPhase.class);
  assertEquals(0,scriptPhase.getInputPaths().size());
  assertEquals(0,scriptPhase.getOutputPaths().size());
  ImmutableSet<BuildTarget> requiredBuildTargets=projectGenerator.getRequiredBuildTargets();
  assertTrue(requiredBuildTargets.contains(compilerTarget));
  assertTrue(requiredBuildTargets.contains(libTarget));
}",0.9252136752136751
53147,"private ImmutableSet<Path> collectRecursiveHalideLibraryHeaderPaths(TargetNode<? extends CxxLibraryDescription.Arg> targetNode){
  ImmutableSet.Builder<Path> builder=ImmutableSet.builder();
  for (  TargetNode<?> input : AppleBuildRules.getRecursiveTargetNodeDependenciesOfTypes(targetGraph,AppleBuildRules.RecursiveDependenciesMode.BUILDING,targetNode,Optional.of(ImmutableSet.<BuildRuleType>of(HalideLibraryDescription.TYPE)))) {
    BuildTarget buildTarget=input.getBuildTarget();
    if (!HalideLibraryDescription.isHalideCompilerTarget(buildTarget)) {
      Path outputDir=getHalideOutputPath(buildTarget);
      builder.add(pathRelativizer.outputDirToRootRelative(outputDir));
    }
  }
  return builder.build();
}","private ImmutableSet<Path> collectRecursiveHalideLibraryHeaderPaths(TargetNode<? extends CxxLibraryDescription.Arg> targetNode){
  ImmutableSet.Builder<Path> builder=ImmutableSet.builder();
  for (  TargetNode<?> input : AppleBuildRules.getRecursiveTargetNodeDependenciesOfTypes(targetGraph,AppleBuildRules.RecursiveDependenciesMode.BUILDING,targetNode,Optional.of(ImmutableSet.<BuildRuleType>of(HalideLibraryDescription.TYPE)))) {
    BuildTarget buildTarget=input.getBuildTarget();
    if (!HalideLibraryDescription.isHalideCompilerTarget(buildTarget)) {
      builder.add(pathRelativizer.outputDirToRootRelative(BuildTargets.getGenPath(BuildTarget.of(buildTarget.getUnflavoredBuildTarget()),""String_Node_Str"")));
    }
  }
  return builder.build();
}",0.7847929395790902
53148,"@SuppressWarnings(""String_Node_Str"") private Optional<PBXTarget> generateProjectTarget(TargetNode<?> targetNode) throws IOException {
  Preconditions.checkState(isBuiltByCurrentProject(targetNode.getBuildTarget()),""String_Node_Str"");
  Optional<PBXTarget> result=Optional.absent();
  if (targetNode.getType().equals(AppleLibraryDescription.TYPE)) {
    result=Optional.<PBXTarget>of(generateAppleLibraryTarget(project,(TargetNode<AppleNativeTargetDescriptionArg>)targetNode,Optional.<TargetNode<AppleBundleDescription.Arg>>absent()));
  }
 else   if (targetNode.getType().equals(CxxLibraryDescription.TYPE)) {
    result=Optional.<PBXTarget>of(generateCxxLibraryTarget(project,(TargetNode<CxxLibraryDescription.Arg>)targetNode,ImmutableSet.<AppleResourceDescription.Arg>of(),ImmutableSet.<AppleAssetCatalogDescription.Arg>of(),Optional.<TargetNode<AppleBundleDescription.Arg>>absent()));
  }
 else   if (targetNode.getType().equals(AppleBinaryDescription.TYPE)) {
    result=Optional.<PBXTarget>of(generateAppleBinaryTarget(project,(TargetNode<AppleNativeTargetDescriptionArg>)targetNode));
  }
 else   if (targetNode.getType().equals(AppleBundleDescription.TYPE)) {
    TargetNode<AppleBundleDescription.Arg> bundleTargetNode=(TargetNode<AppleBundleDescription.Arg>)targetNode;
    result=Optional.<PBXTarget>of(generateAppleBundleTarget(project,bundleTargetNode,(TargetNode<AppleNativeTargetDescriptionArg>)Preconditions.checkNotNull(targetGraph.get(bundleTargetNode.getConstructorArg().binary)),Optional.<TargetNode<AppleBundleDescription.Arg>>absent()));
  }
 else   if (targetNode.getType().equals(AppleTestDescription.TYPE)) {
    result=generateAppleTestTarget((TargetNode<AppleTestDescription.Arg>)targetNode);
  }
 else   if (targetNode.getType().equals(AppleResourceDescription.TYPE)) {
    checkAppleResourceTargetNodeReferencingValidContents((TargetNode<AppleResourceDescription.Arg>)targetNode);
  }
 else   if (targetNode.getType().equals(HalideLibraryDescription.TYPE)) {
    TargetNode<HalideLibraryDescription.Arg> halideTargetNode=(TargetNode<HalideLibraryDescription.Arg>)targetNode;
    BuildTarget buildTarget=targetNode.getBuildTarget();
    if (!HalideLibraryDescription.isHalideCompilerTarget(buildTarget)) {
      result=generateHalideLibraryTarget(project,halideTargetNode);
    }
 else {
      BuildTarget compilerTarget=HalideLibraryDescription.createHalideCompilerBuildTarget(buildTarget);
      requiredBuildTargetsBuilder.add(compilerTarget);
    }
  }
  buckEventBus.post(ProjectGenerationEvent.processed());
  return result;
}","@SuppressWarnings(""String_Node_Str"") private Optional<PBXTarget> generateProjectTarget(TargetNode<?> targetNode) throws IOException {
  Preconditions.checkState(isBuiltByCurrentProject(targetNode.getBuildTarget()),""String_Node_Str"");
  Optional<PBXTarget> result=Optional.absent();
  if (targetNode.getType().equals(AppleLibraryDescription.TYPE)) {
    result=Optional.<PBXTarget>of(generateAppleLibraryTarget(project,(TargetNode<AppleNativeTargetDescriptionArg>)targetNode,Optional.<TargetNode<AppleBundleDescription.Arg>>absent()));
  }
 else   if (targetNode.getType().equals(CxxLibraryDescription.TYPE)) {
    result=Optional.<PBXTarget>of(generateCxxLibraryTarget(project,(TargetNode<CxxLibraryDescription.Arg>)targetNode,ImmutableSet.<AppleResourceDescription.Arg>of(),ImmutableSet.<AppleAssetCatalogDescription.Arg>of(),Optional.<TargetNode<AppleBundleDescription.Arg>>absent()));
  }
 else   if (targetNode.getType().equals(AppleBinaryDescription.TYPE)) {
    result=Optional.<PBXTarget>of(generateAppleBinaryTarget(project,(TargetNode<AppleNativeTargetDescriptionArg>)targetNode));
  }
 else   if (targetNode.getType().equals(AppleBundleDescription.TYPE)) {
    TargetNode<AppleBundleDescription.Arg> bundleTargetNode=(TargetNode<AppleBundleDescription.Arg>)targetNode;
    result=Optional.<PBXTarget>of(generateAppleBundleTarget(project,bundleTargetNode,(TargetNode<AppleNativeTargetDescriptionArg>)Preconditions.checkNotNull(targetGraph.get(bundleTargetNode.getConstructorArg().binary)),Optional.<TargetNode<AppleBundleDescription.Arg>>absent()));
  }
 else   if (targetNode.getType().equals(AppleTestDescription.TYPE)) {
    result=generateAppleTestTarget((TargetNode<AppleTestDescription.Arg>)targetNode);
  }
 else   if (targetNode.getType().equals(AppleResourceDescription.TYPE)) {
    checkAppleResourceTargetNodeReferencingValidContents((TargetNode<AppleResourceDescription.Arg>)targetNode);
  }
 else   if (targetNode.getType().equals(HalideLibraryDescription.TYPE)) {
    TargetNode<HalideLibraryDescription.Arg> halideTargetNode=(TargetNode<HalideLibraryDescription.Arg>)targetNode;
    BuildTarget buildTarget=targetNode.getBuildTarget();
    if (!HalideLibraryDescription.isHalideCompilerTarget(buildTarget)) {
      result=generateHalideLibraryTarget(project,halideTargetNode);
      requiredBuildTargetsBuilder.add(buildTarget);
    }
  }
  buckEventBus.post(ProjectGenerationEvent.processed());
  return result;
}",0.9649789873924356
53149,"/** 
 * @param buildId an identifier for this command execution.
 * @param context an optional NGContext that is present if running inside a Nailgun server.
 * @param args command line arguments
 * @return an exit code or {@code null} if this is a process that should not exit
 */
@SuppressWarnings(""String_Node_Str"") public int runMainWithExitCode(BuildId buildId,Path projectRoot,Optional<NGContext> context,ImmutableMap<String,String> clientEnvironment,String... args) throws IOException, InterruptedException {
  Verbosity verbosity=VerbosityParser.parse(args);
  Optional<String> color;
  if (context.isPresent() && (context.get().getEnv() != null)) {
    String colorString=context.get().getEnv().getProperty(BUCKD_COLOR_DEFAULT_ENV_VAR);
    color=Optional.fromNullable(colorString);
  }
 else {
    color=Optional.absent();
  }
  BuckCommand command=new BuckCommand();
  AdditionalOptionsCmdLineParser cmdLineParser=new AdditionalOptionsCmdLineParser(command);
  try {
    cmdLineParser.parseArgument(args);
  }
 catch (  CmdLineException e) {
    stdErr.println(e.getLocalizedMessage());
    return 1;
  }
  ImmutableMap<String,ImmutableMap<String,String>> configOverrides=command.getConfigOverrides();
  Path canonicalRootPath=projectRoot.toRealPath().normalize();
  Config rawConfig=Config.createDefaultConfig(canonicalRootPath,configOverrides);
  ProjectFilesystem filesystem=new ProjectFilesystem(canonicalRootPath,rawConfig);
  BuckConfig buckConfig=new BuckConfig(rawConfig,filesystem,architecture,platform,clientEnvironment);
  final Console console=new Console(verbosity,stdOut,stdErr,buckConfig.createAnsi(color));
  boolean commandSemaphoreAcquired=false;
  if (!command.isReadOnly()) {
    commandSemaphoreAcquired=commandSemaphore.tryAcquire();
    if (!commandSemaphoreAcquired) {
      return BUSY_EXIT_CODE;
    }
    Optional<String> currentVersion=filesystem.readFileIfItExists(BuckConstant.CURRENT_VERSION_FILE);
    if (!currentVersion.isPresent() || !currentVersion.get().equals(BuckVersion.getVersion())) {
      filesystem.deleteRecursivelyIfExists(BuckConstant.ANNOTATION_PATH);
      filesystem.deleteRecursivelyIfExists(BuckConstant.GEN_PATH);
      filesystem.deleteRecursivelyIfExists(BuckConstant.SCRATCH_PATH);
      filesystem.mkdirs(BuckConstant.CURRENT_VERSION_FILE.getParent());
      filesystem.writeContentsToPath(BuckVersion.getVersion(),BuckConstant.CURRENT_VERSION_FILE);
    }
  }
  PropertyFinder propertyFinder=new DefaultPropertyFinder(filesystem,clientEnvironment);
  AndroidBuckConfig androidBuckConfig=new AndroidBuckConfig(buckConfig,platform);
  AndroidDirectoryResolver androidDirectoryResolver=new DefaultAndroidDirectoryResolver(filesystem,androidBuckConfig.getNdkVersion(),propertyFinder);
  ProcessExecutor processExecutor=new ProcessExecutor(console);
  Optional<Path> testTempDirOverride=getTestTempDirOverride(buckConfig,clientEnvironment,""String_Node_Str"" + buildId.toString());
  if (testTempDirOverride.isPresent()) {
    LOG.debug(""String_Node_Str"",testTempDirOverride.get());
  }
  Clock clock;
  if (BUCKD_LAUNCH_TIME_NANOS.isPresent()) {
    long nanosEpoch=Long.parseLong(BUCKD_LAUNCH_TIME_NANOS.get(),10);
    LOG.verbose(""String_Node_Str"",nanosEpoch);
    clock=new NanosAdjustedClock(nanosEpoch);
  }
 else {
    clock=new DefaultClock();
  }
  ParserConfig parserConfig=new ParserConfig(buckConfig);
  Watchman watchman;
  ParserConfig.GlobHandler globHandler;
  if (context.isPresent() || parserConfig.getGlobHandler() == ParserConfig.GlobHandler.WATCHMAN) {
    watchman=Watchman.build(projectRoot,clientEnvironment,console,clock);
    if (parserConfig.getGlobHandler() == ParserConfig.GlobHandler.WATCHMAN && watchman.hasWildmatchGlob()) {
      globHandler=ParserConfig.GlobHandler.WATCHMAN;
    }
 else {
      globHandler=ParserConfig.GlobHandler.PYTHON;
    }
    LOG.debug(""String_Node_Str"" + ""String_Node_Str"",watchman.getCapabilities(),watchman.getWatchRoot(),watchman.getProjectPrefix(),parserConfig.getGlobHandler(),globHandler);
  }
 else {
    watchman=Watchman.NULL_WATCHMAN;
    globHandler=ParserConfig.GlobHandler.PYTHON;
  }
  final boolean isDaemon=context.isPresent() && (watchman != Watchman.NULL_WATCHMAN);
  KnownBuildRuleTypesFactory factory=new KnownBuildRuleTypesFactory(processExecutor,androidDirectoryResolver,testTempDirOverride);
  Cell rootCell=new Cell(filesystem,console,watchman,buckConfig,factory,androidDirectoryResolver,clock);
  int exitCode;
  ImmutableList<BuckEventListener> eventListeners=ImmutableList.of();
  ExecutionEnvironment executionEnvironment=new DefaultExecutionEnvironment(processExecutor,clientEnvironment,System.getProperties());
  ParserConfig.AllowSymlinks allowSymlinks=parserConfig.getAllowSymlinks();
  ProjectFileHashCache cellHashCache;
  ProjectFileHashCache buckOutHashCache;
  if (isDaemon) {
    cellHashCache=getFileHashCacheFromDaemon(rootCell,globHandler,allowSymlinks);
    buckOutHashCache=getBuckOutFileHashCacheFromDaemon(rootCell,globHandler,allowSymlinks);
  }
 else {
    cellHashCache=new DefaultFileHashCache(rootCell.getFilesystem());
    buckOutHashCache=new DefaultFileHashCache(new ProjectFilesystem(rootCell.getFilesystem().getRootPath(),Optional.of(ImmutableSet.of(BuckConstant.BUCK_OUTPUT_PATH)),ImmutableSet.<Path>of()));
  }
  ImmutableList.Builder<FileHashCache> allCaches=ImmutableList.builder();
  allCaches.add(cellHashCache);
  allCaches.add(buckOutHashCache);
  allCaches.add(new DefaultFileHashCache(new ProjectFilesystem(rootCell.getFilesystem().getRootPath())));
  for (  Path root : FileSystems.getDefault().getRootDirectories()) {
    allCaches.add(new DefaultFileHashCache(new ProjectFilesystem(root)));
  }
  FileHashCache fileHashCache=new StackedFileHashCache(allCaches.build());
  Optional<WebServer> webServer=getWebServerIfDaemon(context,rootCell,globHandler,allowSymlinks);
  TestConfig testConfig=new TestConfig(buckConfig);
  ArtifactCacheBuckConfig cacheBuckConfig=new ArtifactCacheBuckConfig(buckConfig);
  ExecutorService diskIoExecutorService=MoreExecutors.newSingleThreadExecutor(""String_Node_Str"");
  VersionControlStatsGenerator vcStatsGenerator=null;
  try (ConsoleLogLevelOverrider consoleLogLevelOverrider=new ConsoleLogLevelOverrider(buildId.toString(),verbosity);ConsoleHandlerRedirector consoleHandlerRedirector=new ConsoleHandlerRedirector(buildId.toString(),console.getStdErr(),Optional.<OutputStream>of(stdErr));AbstractConsoleEventBusListener consoleListener=createConsoleEventListener(clock,console,testConfig.getResultSummaryVerbosity(),executionEnvironment,webServer);TempDirectoryCreator tempDirectoryCreator=new TempDirectoryCreator(testTempDirOverride);AsyncCloseable asyncCloseable=new AsyncCloseable(diskIoExecutorService);BuckEventBus buildEventBus=new BuckEventBus(clock,buildId)){
    ArtifactCache artifactCache=asyncCloseable.closeAsync(ArtifactCaches.newInstance(cacheBuckConfig,buildEventBus,filesystem,executionEnvironment.getWifiSsid()));
    ProgressEstimator progressEstimator=new ProgressEstimator(filesystem.getRootPath(),buildEventBus);
    consoleListener.setProgressEstimator(progressEstimator);
    eventListeners=addEventListeners(buildEventBus,rootCell.getFilesystem(),buildId,rootCell.getBuckConfig(),webServer,clock,executionEnvironment,console,consoleListener,rootCell.getKnownBuildRuleTypes(),clientEnvironment);
    VersionControlBuckConfig vcBuckConfig=new VersionControlBuckConfig(buckConfig);
    if (vcBuckConfig.shouldGenerateStatistics()) {
      vcStatsGenerator=new VersionControlStatsGenerator(diskIoExecutorService,new DefaultVersionControlCmdLineInterfaceFactory(rootCell.getFilesystem().getRootPath(),new PrintStreamProcessExecutorFactory(),vcBuckConfig),buildEventBus);
      vcStatsGenerator.generateStatsAsync();
    }
    ImmutableList<String> remainingArgs=args.length > 1 ? ImmutableList.copyOf(Arrays.copyOfRange(args,1,args.length)) : ImmutableList.<String>of();
    CommandEvent.Started startedEvent=CommandEvent.started(args.length > 0 ? args[0] : ""String_Node_Str"",remainingArgs,isDaemon);
    buildEventBus.post(startedEvent);
    Parser parser=null;
    if (isDaemon && watchman != Watchman.NULL_WATCHMAN) {
      try {
        Daemon daemon=getDaemon(rootCell,globHandler,allowSymlinks,objectMapper);
        WatchmanWatcher watchmanWatcher=new WatchmanWatcher(watchman.getWatchRoot().or(canonicalRootPath.toString()),daemon.getFileEventBus(),clock,objectMapper,processExecutor,filesystem.getIgnorePaths(),DEFAULT_IGNORE_GLOBS,watchman,daemon.getWatchmanQueryUUID());
        parser=getParserFromDaemon(context,rootCell,startedEvent,buildEventBus,watchmanWatcher,globHandler,allowSymlinks);
      }
 catch (      WatchmanWatcherException|IOException e) {
        buildEventBus.post(ConsoleEvent.warning(""String_Node_Str"",e.getMessage()));
      }
    }
    if (parser == null) {
      parser=Parser.createBuildFileParser(rootCell,globHandler == ParserConfig.GlobHandler.WATCHMAN,allowSymlinks);
    }
    JavaUtilsLoggingBuildListener.ensureLogFileIsWritten(rootCell.getFilesystem());
    Optional<ProcessManager> processManager;
    if (platform == Platform.WINDOWS) {
      processManager=Optional.absent();
    }
 else {
      processManager=Optional.<ProcessManager>of(new PkillProcessManager(processExecutor));
    }
    Supplier<AndroidPlatformTarget> androidPlatformTargetSupplier=createAndroidPlatformTargetSupplier(androidDirectoryResolver,androidBuckConfig,buildEventBus);
    if (command.subcommand instanceof AbstractCommand) {
      AbstractCommand subcommand=(AbstractCommand)command.subcommand;
      Optional<Path> eventsOutputPath=subcommand.getEventsOutputPath();
      if (eventsOutputPath.isPresent()) {
        BuckEventListener listener=new FileSerializationEventBusListener(eventsOutputPath.get());
        buildEventBus.register(listener);
      }
    }
    exitCode=command.run(new CommandRunnerParams(console,rootCell,androidPlatformTargetSupplier,artifactCache,buildEventBus,parser,platform,clientEnvironment,rootCell.getBuckConfig().createDefaultJavaPackageFinder(),objectMapper,clock,processManager,webServer,buckConfig,fileHashCache));
    parser.cleanCache();
    buildEventBus.post(CommandEvent.finished(startedEvent,exitCode));
  }
 catch (  Throwable t) {
    LOG.debug(t,""String_Node_Str"");
    closeDiskIoExecutorService(diskIoExecutorService);
    flushEventListeners(console,buildId,eventListeners);
    throw t;
  }
 finally {
    if (commandSemaphoreAcquired) {
      commandSemaphore.release();
    }
  }
  if (context.isPresent() && !rootCell.getBuckConfig().getFlushEventsBeforeExit()) {
    context.get().in.close();
    context.get().exit(exitCode);
  }
  closeDiskIoExecutorService(diskIoExecutorService);
  flushEventListeners(console,buildId,eventListeners);
  return exitCode;
}","/** 
 * @param buildId an identifier for this command execution.
 * @param context an optional NGContext that is present if running inside a Nailgun server.
 * @param args command line arguments
 * @return an exit code or {@code null} if this is a process that should not exit
 */
@SuppressWarnings(""String_Node_Str"") public int runMainWithExitCode(BuildId buildId,Path projectRoot,Optional<NGContext> context,ImmutableMap<String,String> clientEnvironment,String... args) throws IOException, InterruptedException {
  Verbosity verbosity=VerbosityParser.parse(args);
  Optional<String> color;
  if (context.isPresent() && (context.get().getEnv() != null)) {
    String colorString=context.get().getEnv().getProperty(BUCKD_COLOR_DEFAULT_ENV_VAR);
    color=Optional.fromNullable(colorString);
  }
 else {
    color=Optional.absent();
  }
  BuckCommand command=new BuckCommand();
  AdditionalOptionsCmdLineParser cmdLineParser=new AdditionalOptionsCmdLineParser(command);
  try {
    cmdLineParser.parseArgument(args);
  }
 catch (  CmdLineException e) {
    stdErr.println(e.getLocalizedMessage());
    return 1;
  }
  ImmutableMap<String,ImmutableMap<String,String>> configOverrides=command.getConfigOverrides();
  Path canonicalRootPath=projectRoot.toRealPath().normalize();
  Config rawConfig=Config.createDefaultConfig(canonicalRootPath,configOverrides);
  ProjectFilesystem filesystem=new ProjectFilesystem(canonicalRootPath,rawConfig);
  BuckConfig buckConfig=new BuckConfig(rawConfig,filesystem,architecture,platform,clientEnvironment);
  final Console console=new Console(verbosity,stdOut,stdErr,buckConfig.createAnsi(color));
  boolean commandSemaphoreAcquired=false;
  if (!command.isReadOnly()) {
    commandSemaphoreAcquired=commandSemaphore.tryAcquire();
    if (!commandSemaphoreAcquired) {
      return BUSY_EXIT_CODE;
    }
    Optional<String> currentVersion=filesystem.readFileIfItExists(BuckConstant.CURRENT_VERSION_FILE);
    if (!currentVersion.isPresent() || !currentVersion.get().equals(BuckVersion.getVersion())) {
      filesystem.deleteRecursivelyIfExists(BuckConstant.ANNOTATION_PATH);
      filesystem.deleteRecursivelyIfExists(BuckConstant.GEN_PATH);
      filesystem.deleteRecursivelyIfExists(BuckConstant.SCRATCH_PATH);
      filesystem.mkdirs(BuckConstant.CURRENT_VERSION_FILE.getParent());
      filesystem.writeContentsToPath(BuckVersion.getVersion(),BuckConstant.CURRENT_VERSION_FILE);
    }
  }
  PropertyFinder propertyFinder=new DefaultPropertyFinder(filesystem,clientEnvironment);
  AndroidBuckConfig androidBuckConfig=new AndroidBuckConfig(buckConfig,platform);
  AndroidDirectoryResolver androidDirectoryResolver=new DefaultAndroidDirectoryResolver(filesystem,androidBuckConfig.getNdkVersion(),propertyFinder);
  ProcessExecutor processExecutor=new ProcessExecutor(console);
  Optional<Path> testTempDirOverride=getTestTempDirOverride(buckConfig,clientEnvironment,""String_Node_Str"" + buildId.toString());
  if (testTempDirOverride.isPresent()) {
    LOG.debug(""String_Node_Str"",testTempDirOverride.get());
  }
  Clock clock;
  if (BUCKD_LAUNCH_TIME_NANOS.isPresent()) {
    long nanosEpoch=Long.parseLong(BUCKD_LAUNCH_TIME_NANOS.get(),10);
    LOG.verbose(""String_Node_Str"",nanosEpoch);
    clock=new NanosAdjustedClock(nanosEpoch);
  }
 else {
    clock=new DefaultClock();
  }
  ParserConfig parserConfig=new ParserConfig(buckConfig);
  Watchman watchman;
  ParserConfig.GlobHandler globHandler;
  if (context.isPresent() || parserConfig.getGlobHandler() == ParserConfig.GlobHandler.WATCHMAN) {
    watchman=Watchman.build(projectRoot,clientEnvironment,console,clock);
    if (parserConfig.getGlobHandler() == ParserConfig.GlobHandler.WATCHMAN && watchman.hasWildmatchGlob()) {
      globHandler=ParserConfig.GlobHandler.WATCHMAN;
    }
 else {
      globHandler=ParserConfig.GlobHandler.PYTHON;
    }
    LOG.debug(""String_Node_Str"" + ""String_Node_Str"",watchman.getCapabilities(),watchman.getWatchRoot(),watchman.getProjectPrefix(),parserConfig.getGlobHandler(),globHandler);
  }
 else {
    watchman=Watchman.NULL_WATCHMAN;
    globHandler=ParserConfig.GlobHandler.PYTHON;
  }
  final boolean isDaemon=context.isPresent() && (watchman != Watchman.NULL_WATCHMAN);
  KnownBuildRuleTypesFactory factory=new KnownBuildRuleTypesFactory(processExecutor,androidDirectoryResolver,testTempDirOverride);
  Cell rootCell=new Cell(filesystem,console,watchman,buckConfig,factory,androidDirectoryResolver,clock);
  int exitCode;
  ImmutableList<BuckEventListener> eventListeners=ImmutableList.of();
  ExecutionEnvironment executionEnvironment=new DefaultExecutionEnvironment(processExecutor,clientEnvironment,System.getProperties());
  ParserConfig.AllowSymlinks allowSymlinks=parserConfig.getAllowSymlinks();
  ProjectFileHashCache cellHashCache;
  ProjectFileHashCache buckOutHashCache;
  if (isDaemon) {
    cellHashCache=getFileHashCacheFromDaemon(rootCell,globHandler,allowSymlinks);
    buckOutHashCache=getBuckOutFileHashCacheFromDaemon(rootCell,globHandler,allowSymlinks);
  }
 else {
    cellHashCache=new DefaultFileHashCache(rootCell.getFilesystem());
    buckOutHashCache=new DefaultFileHashCache(new ProjectFilesystem(rootCell.getFilesystem().getRootPath(),Optional.of(ImmutableSet.of(BuckConstant.BUCK_OUTPUT_PATH)),ImmutableSet.<Path>of()));
  }
  ImmutableList.Builder<FileHashCache> allCaches=ImmutableList.builder();
  allCaches.add(cellHashCache);
  allCaches.add(buckOutHashCache);
  allCaches.add(new DefaultFileHashCache(new ProjectFilesystem(rootCell.getFilesystem().getRootPath())));
  for (  Path root : FileSystems.getDefault().getRootDirectories()) {
    if (!root.toFile().exists()) {
      continue;
    }
    allCaches.add(new DefaultFileHashCache(new ProjectFilesystem(root)));
  }
  FileHashCache fileHashCache=new StackedFileHashCache(allCaches.build());
  Optional<WebServer> webServer=getWebServerIfDaemon(context,rootCell,globHandler,allowSymlinks);
  TestConfig testConfig=new TestConfig(buckConfig);
  ArtifactCacheBuckConfig cacheBuckConfig=new ArtifactCacheBuckConfig(buckConfig);
  ExecutorService diskIoExecutorService=MoreExecutors.newSingleThreadExecutor(""String_Node_Str"");
  VersionControlStatsGenerator vcStatsGenerator=null;
  try (ConsoleLogLevelOverrider consoleLogLevelOverrider=new ConsoleLogLevelOverrider(buildId.toString(),verbosity);ConsoleHandlerRedirector consoleHandlerRedirector=new ConsoleHandlerRedirector(buildId.toString(),console.getStdErr(),Optional.<OutputStream>of(stdErr));AbstractConsoleEventBusListener consoleListener=createConsoleEventListener(clock,console,testConfig.getResultSummaryVerbosity(),executionEnvironment,webServer);TempDirectoryCreator tempDirectoryCreator=new TempDirectoryCreator(testTempDirOverride);AsyncCloseable asyncCloseable=new AsyncCloseable(diskIoExecutorService);BuckEventBus buildEventBus=new BuckEventBus(clock,buildId)){
    ArtifactCache artifactCache=asyncCloseable.closeAsync(ArtifactCaches.newInstance(cacheBuckConfig,buildEventBus,filesystem,executionEnvironment.getWifiSsid()));
    ProgressEstimator progressEstimator=new ProgressEstimator(filesystem.getRootPath(),buildEventBus);
    consoleListener.setProgressEstimator(progressEstimator);
    eventListeners=addEventListeners(buildEventBus,rootCell.getFilesystem(),buildId,rootCell.getBuckConfig(),webServer,clock,executionEnvironment,console,consoleListener,rootCell.getKnownBuildRuleTypes(),clientEnvironment);
    VersionControlBuckConfig vcBuckConfig=new VersionControlBuckConfig(buckConfig);
    if (vcBuckConfig.shouldGenerateStatistics()) {
      vcStatsGenerator=new VersionControlStatsGenerator(diskIoExecutorService,new DefaultVersionControlCmdLineInterfaceFactory(rootCell.getFilesystem().getRootPath(),new PrintStreamProcessExecutorFactory(),vcBuckConfig),buildEventBus);
      vcStatsGenerator.generateStatsAsync();
    }
    ImmutableList<String> remainingArgs=args.length > 1 ? ImmutableList.copyOf(Arrays.copyOfRange(args,1,args.length)) : ImmutableList.<String>of();
    CommandEvent.Started startedEvent=CommandEvent.started(args.length > 0 ? args[0] : ""String_Node_Str"",remainingArgs,isDaemon);
    buildEventBus.post(startedEvent);
    Parser parser=null;
    if (isDaemon && watchman != Watchman.NULL_WATCHMAN) {
      try {
        Daemon daemon=getDaemon(rootCell,globHandler,allowSymlinks,objectMapper);
        WatchmanWatcher watchmanWatcher=new WatchmanWatcher(watchman.getWatchRoot().or(canonicalRootPath.toString()),daemon.getFileEventBus(),clock,objectMapper,processExecutor,filesystem.getIgnorePaths(),DEFAULT_IGNORE_GLOBS,watchman,daemon.getWatchmanQueryUUID());
        parser=getParserFromDaemon(context,rootCell,startedEvent,buildEventBus,watchmanWatcher,globHandler,allowSymlinks);
      }
 catch (      WatchmanWatcherException|IOException e) {
        buildEventBus.post(ConsoleEvent.warning(""String_Node_Str"",e.getMessage()));
      }
    }
    if (parser == null) {
      parser=Parser.createBuildFileParser(rootCell,globHandler == ParserConfig.GlobHandler.WATCHMAN,allowSymlinks);
    }
    JavaUtilsLoggingBuildListener.ensureLogFileIsWritten(rootCell.getFilesystem());
    Optional<ProcessManager> processManager;
    if (platform == Platform.WINDOWS) {
      processManager=Optional.absent();
    }
 else {
      processManager=Optional.<ProcessManager>of(new PkillProcessManager(processExecutor));
    }
    Supplier<AndroidPlatformTarget> androidPlatformTargetSupplier=createAndroidPlatformTargetSupplier(androidDirectoryResolver,androidBuckConfig,buildEventBus);
    if (command.subcommand instanceof AbstractCommand) {
      AbstractCommand subcommand=(AbstractCommand)command.subcommand;
      Optional<Path> eventsOutputPath=subcommand.getEventsOutputPath();
      if (eventsOutputPath.isPresent()) {
        BuckEventListener listener=new FileSerializationEventBusListener(eventsOutputPath.get());
        buildEventBus.register(listener);
      }
    }
    exitCode=command.run(new CommandRunnerParams(console,rootCell,androidPlatformTargetSupplier,artifactCache,buildEventBus,parser,platform,clientEnvironment,rootCell.getBuckConfig().createDefaultJavaPackageFinder(),objectMapper,clock,processManager,webServer,buckConfig,fileHashCache));
    parser.cleanCache();
    buildEventBus.post(CommandEvent.finished(startedEvent,exitCode));
  }
 catch (  Throwable t) {
    LOG.debug(t,""String_Node_Str"");
    closeDiskIoExecutorService(diskIoExecutorService);
    flushEventListeners(console,buildId,eventListeners);
    throw t;
  }
 finally {
    if (commandSemaphoreAcquired) {
      commandSemaphore.release();
    }
  }
  if (context.isPresent() && !rootCell.getBuckConfig().getFlushEventsBeforeExit()) {
    context.get().in.close();
    context.get().exit(exitCode);
  }
  closeDiskIoExecutorService(diskIoExecutorService);
  flushEventListeners(console,buildId,eventListeners);
  return exitCode;
}",0.997365136596866
53150,"@Override public boolean equals(Object obj){
  return (obj instanceof TestDescription) && this.hashCode() == obj.hashCode();
}","@Override public boolean equals(Object obj){
  if (!(obj instanceof TestDescription)) {
    return false;
  }
  TestDescription other=(TestDescription)obj;
  return Objects.equals(this.className,other.className) && Objects.equals(this.methodName,other.methodName);
}",0.3928571428571428
53151,"/** 
 * @param buildId an identifier for this command execution.
 * @param context an optional NGContext that is present if running inside a Nailgun server.
 * @param args command line arguments
 * @return an exit code or {@code null} if this is a process that should not exit
 */
@SuppressWarnings(""String_Node_Str"") public int runMainWithExitCode(BuildId buildId,Path projectRoot,Optional<NGContext> context,ImmutableMap<String,String> clientEnvironment,String... args) throws IOException, InterruptedException {
  Verbosity verbosity=VerbosityParser.parse(args);
  Optional<String> color;
  if (context.isPresent() && (context.get().getEnv() != null)) {
    String colorString=context.get().getEnv().getProperty(BUCKD_COLOR_DEFAULT_ENV_VAR);
    color=Optional.fromNullable(colorString);
  }
 else {
    color=Optional.absent();
  }
  BuckCommand command=new BuckCommand();
  AdditionalOptionsCmdLineParser cmdLineParser=new AdditionalOptionsCmdLineParser(command);
  try {
    cmdLineParser.parseArgument(args);
  }
 catch (  CmdLineException e) {
    stdErr.println(e.getLocalizedMessage());
    return 1;
  }
  ImmutableMap<String,ImmutableMap<String,String>> configOverrides=command.getConfigOverrides();
  Path canonicalRootPath=projectRoot.toRealPath().normalize();
  Config rawConfig=Config.createDefaultConfig(canonicalRootPath,configOverrides);
  ProjectFilesystem filesystem=new ProjectFilesystem(canonicalRootPath,rawConfig);
  BuckConfig buckConfig=new BuckConfig(rawConfig,filesystem,architecture,platform,clientEnvironment);
  final Console console=new Console(verbosity,stdOut,stdErr,buckConfig.createAnsi(color));
  boolean commandSemaphoreAcquired=false;
  if (!command.isReadOnly()) {
    commandSemaphoreAcquired=commandSemaphore.tryAcquire();
    if (!commandSemaphoreAcquired) {
      return BUSY_EXIT_CODE;
    }
  }
  PropertyFinder propertyFinder=new DefaultPropertyFinder(filesystem,clientEnvironment);
  AndroidBuckConfig androidBuckConfig=new AndroidBuckConfig(buckConfig,platform);
  AndroidDirectoryResolver androidDirectoryResolver=new DefaultAndroidDirectoryResolver(filesystem,androidBuckConfig.getNdkVersion(),propertyFinder);
  ProcessExecutor processExecutor=new ProcessExecutor(console);
  Optional<Path> testTempDirOverride=getTestTempDirOverride(buckConfig,clientEnvironment,""String_Node_Str"" + buildId.toString());
  if (testTempDirOverride.isPresent()) {
    LOG.debug(""String_Node_Str"",testTempDirOverride.get());
  }
  Clock clock;
  if (BUCKD_LAUNCH_TIME_NANOS.isPresent()) {
    long nanosEpoch=Long.parseLong(BUCKD_LAUNCH_TIME_NANOS.get(),10);
    LOG.verbose(""String_Node_Str"",nanosEpoch);
    clock=new NanosAdjustedClock(nanosEpoch);
  }
 else {
    clock=new DefaultClock();
  }
  ParserConfig parserConfig=new ParserConfig(buckConfig);
  Watchman watchman;
  ParserConfig.GlobHandler globHandler;
  if (context.isPresent() || parserConfig.getGlobHandler() == ParserConfig.GlobHandler.WATCHMAN) {
    watchman=Watchman.build(projectRoot,clientEnvironment,console,clock);
    if (parserConfig.getGlobHandler() == ParserConfig.GlobHandler.WATCHMAN && watchman.hasWildmatchGlob()) {
      globHandler=ParserConfig.GlobHandler.WATCHMAN;
    }
 else {
      globHandler=ParserConfig.GlobHandler.PYTHON;
    }
    LOG.debug(""String_Node_Str"" + ""String_Node_Str"",watchman.getCapabilities(),watchman.getWatchRoot(),watchman.getProjectPrefix(),parserConfig.getGlobHandler(),globHandler);
  }
 else {
    watchman=Watchman.NULL_WATCHMAN;
    globHandler=ParserConfig.GlobHandler.PYTHON;
  }
  final boolean isDaemon=context.isPresent() && (watchman != Watchman.NULL_WATCHMAN);
  KnownBuildRuleTypesFactory factory=new KnownBuildRuleTypesFactory(processExecutor,androidDirectoryResolver,testTempDirOverride);
  Cell rootCell=new Cell(filesystem,console,watchman,buckConfig,factory,androidDirectoryResolver,clock);
  int exitCode;
  ImmutableList<BuckEventListener> eventListeners=ImmutableList.of();
  ExecutionEnvironment executionEnvironment=new DefaultExecutionEnvironment(processExecutor,clientEnvironment,System.getProperties());
  ParserConfig.AllowSymlinks allowSymlinks=parserConfig.getAllowSymlinks();
  ProjectFileHashCache cellHashCache;
  ProjectFileHashCache buckOutHashCache;
  if (isDaemon) {
    cellHashCache=getFileHashCacheFromDaemon(rootCell,globHandler,allowSymlinks);
    buckOutHashCache=getBuckOutFileHashCacheFromDaemon(rootCell,globHandler,allowSymlinks);
  }
 else {
    cellHashCache=new DefaultFileHashCache(rootCell.getFilesystem());
    buckOutHashCache=new DefaultFileHashCache(new ProjectFilesystem(rootCell.getFilesystem().getRootPath(),Optional.of(ImmutableSet.of(BuckConstant.BUCK_OUTPUT_PATH)),ImmutableSet.<Path>of()));
  }
  FileHashCache fileHashCache=new StackedFileHashCache(ImmutableList.of(cellHashCache,buckOutHashCache,new DefaultFileHashCache(new ProjectFilesystem(rootCell.getFilesystem().getRootPath())),new DefaultFileHashCache(new ProjectFilesystem(Paths.get(""String_Node_Str"")))));
  Optional<WebServer> webServer=getWebServerIfDaemon(context,rootCell,globHandler,allowSymlinks);
  TestConfig testConfig=new TestConfig(buckConfig);
  ArtifactCacheBuckConfig cacheBuckConfig=new ArtifactCacheBuckConfig(buckConfig);
  ExecutorService diskIoExecutorService=MoreExecutors.newSingleThreadExecutor(""String_Node_Str"");
  VersionControlStatsGenerator vcStatsGenerator=null;
  try (ConsoleLogLevelOverrider consoleLogLevelOverrider=new ConsoleLogLevelOverrider(buildId.toString(),verbosity);ConsoleHandlerRedirector consoleHandlerRedirector=new ConsoleHandlerRedirector(buildId.toString(),console.getStdErr(),Optional.<OutputStream>of(stdErr));AbstractConsoleEventBusListener consoleListener=createConsoleEventListener(clock,console,testConfig.getResultSummaryVerbosity(),executionEnvironment,webServer);TempDirectoryCreator tempDirectoryCreator=new TempDirectoryCreator(testTempDirOverride);AsyncCloseable asyncCloseable=new AsyncCloseable(diskIoExecutorService);BuckEventBus buildEventBus=new BuckEventBus(clock,buildId)){
    ArtifactCache artifactCache=asyncCloseable.closeAsync(ArtifactCaches.newInstance(cacheBuckConfig,buildEventBus,filesystem,executionEnvironment.getWifiSsid()));
    ProgressEstimator progressEstimator=new ProgressEstimator(filesystem.getRootPath(),buildEventBus);
    consoleListener.setProgressEstimator(progressEstimator);
    eventListeners=addEventListeners(buildEventBus,rootCell.getFilesystem(),buildId,rootCell.getBuckConfig(),webServer,clock,executionEnvironment,console,consoleListener,rootCell.getKnownBuildRuleTypes(),clientEnvironment);
    VersionControlBuckConfig vcBuckConfig=new VersionControlBuckConfig(buckConfig);
    if (vcBuckConfig.shouldGenerateStatistics()) {
      vcStatsGenerator=new VersionControlStatsGenerator(diskIoExecutorService,new DefaultVersionControlCmdLineInterfaceFactory(rootCell.getFilesystem().getRootPath(),processExecutor,vcBuckConfig),buildEventBus);
      vcStatsGenerator.generateStatsAsync();
    }
    ImmutableList<String> remainingArgs=args.length > 1 ? ImmutableList.copyOf(Arrays.copyOfRange(args,1,args.length)) : ImmutableList.<String>of();
    CommandEvent.Started startedEvent=CommandEvent.started(args.length > 0 ? args[0] : ""String_Node_Str"",remainingArgs,isDaemon);
    buildEventBus.post(startedEvent);
    Parser parser=null;
    if (isDaemon && watchman != Watchman.NULL_WATCHMAN) {
      try {
        Daemon daemon=getDaemon(rootCell,globHandler,allowSymlinks,objectMapper);
        WatchmanWatcher watchmanWatcher=new WatchmanWatcher(watchman.getWatchRoot().or(canonicalRootPath.toString()),daemon.getFileEventBus(),clock,objectMapper,processExecutor,filesystem.getIgnorePaths(),DEFAULT_IGNORE_GLOBS,watchman,daemon.getWatchmanQueryUUID());
        parser=getParserFromDaemon(context,rootCell,startedEvent,buildEventBus,watchmanWatcher,globHandler,allowSymlinks);
      }
 catch (      WatchmanWatcherException|IOException e) {
        buildEventBus.post(ConsoleEvent.warning(""String_Node_Str"",e.getMessage()));
      }
    }
    if (parser == null) {
      parser=Parser.createBuildFileParser(rootCell,globHandler == ParserConfig.GlobHandler.WATCHMAN,allowSymlinks);
    }
    JavaUtilsLoggingBuildListener.ensureLogFileIsWritten(rootCell.getFilesystem());
    Optional<ProcessManager> processManager;
    if (platform == Platform.WINDOWS) {
      processManager=Optional.absent();
    }
 else {
      processManager=Optional.<ProcessManager>of(new PkillProcessManager(processExecutor));
    }
    Supplier<AndroidPlatformTarget> androidPlatformTargetSupplier=createAndroidPlatformTargetSupplier(androidDirectoryResolver,androidBuckConfig,buildEventBus);
    if (command.subcommand instanceof AbstractCommand) {
      AbstractCommand subcommand=(AbstractCommand)command.subcommand;
      Optional<Path> eventsOutputPath=subcommand.getEventsOutputPath();
      if (eventsOutputPath.isPresent()) {
        BuckEventListener listener=new FileSerializationEventBusListener(eventsOutputPath.get());
        buildEventBus.register(listener);
      }
    }
    exitCode=command.run(new CommandRunnerParams(console,rootCell,androidPlatformTargetSupplier,artifactCache,buildEventBus,parser,platform,clientEnvironment,rootCell.getBuckConfig().createDefaultJavaPackageFinder(),objectMapper,clock,processManager,webServer,buckConfig,fileHashCache));
    parser.cleanCache();
    buildEventBus.post(CommandEvent.finished(startedEvent,exitCode));
  }
 catch (  Throwable t) {
    LOG.debug(t,""String_Node_Str"");
    closeDiskIoExecutorService(diskIoExecutorService);
    flushEventListeners(console,buildId,eventListeners);
    throw t;
  }
 finally {
    if (commandSemaphoreAcquired) {
      commandSemaphore.release();
    }
  }
  if (context.isPresent() && !rootCell.getBuckConfig().getFlushEventsBeforeExit()) {
    context.get().in.close();
    context.get().exit(exitCode);
  }
  closeDiskIoExecutorService(diskIoExecutorService);
  flushEventListeners(console,buildId,eventListeners);
  return exitCode;
}","/** 
 * @param buildId an identifier for this command execution.
 * @param context an optional NGContext that is present if running inside a Nailgun server.
 * @param args command line arguments
 * @return an exit code or {@code null} if this is a process that should not exit
 */
@SuppressWarnings(""String_Node_Str"") public int runMainWithExitCode(BuildId buildId,Path projectRoot,Optional<NGContext> context,ImmutableMap<String,String> clientEnvironment,String... args) throws IOException, InterruptedException {
  Verbosity verbosity=VerbosityParser.parse(args);
  Optional<String> color;
  if (context.isPresent() && (context.get().getEnv() != null)) {
    String colorString=context.get().getEnv().getProperty(BUCKD_COLOR_DEFAULT_ENV_VAR);
    color=Optional.fromNullable(colorString);
  }
 else {
    color=Optional.absent();
  }
  BuckCommand command=new BuckCommand();
  AdditionalOptionsCmdLineParser cmdLineParser=new AdditionalOptionsCmdLineParser(command);
  try {
    cmdLineParser.parseArgument(args);
  }
 catch (  CmdLineException e) {
    stdErr.println(e.getLocalizedMessage());
    return 1;
  }
  ImmutableMap<String,ImmutableMap<String,String>> configOverrides=command.getConfigOverrides();
  Path canonicalRootPath=projectRoot.toRealPath().normalize();
  Config rawConfig=Config.createDefaultConfig(canonicalRootPath,configOverrides);
  ProjectFilesystem filesystem=new ProjectFilesystem(canonicalRootPath,rawConfig);
  BuckConfig buckConfig=new BuckConfig(rawConfig,filesystem,architecture,platform,clientEnvironment);
  final Console console=new Console(verbosity,stdOut,stdErr,buckConfig.createAnsi(color));
  boolean commandSemaphoreAcquired=false;
  if (!command.isReadOnly()) {
    commandSemaphoreAcquired=commandSemaphore.tryAcquire();
    if (!commandSemaphoreAcquired) {
      return BUSY_EXIT_CODE;
    }
  }
  PropertyFinder propertyFinder=new DefaultPropertyFinder(filesystem,clientEnvironment);
  AndroidBuckConfig androidBuckConfig=new AndroidBuckConfig(buckConfig,platform);
  AndroidDirectoryResolver androidDirectoryResolver=new DefaultAndroidDirectoryResolver(filesystem,androidBuckConfig.getNdkVersion(),propertyFinder);
  ProcessExecutor processExecutor=new ProcessExecutor(console);
  Optional<Path> testTempDirOverride=getTestTempDirOverride(buckConfig,clientEnvironment,""String_Node_Str"" + buildId.toString());
  if (testTempDirOverride.isPresent()) {
    LOG.debug(""String_Node_Str"",testTempDirOverride.get());
  }
  Clock clock;
  if (BUCKD_LAUNCH_TIME_NANOS.isPresent()) {
    long nanosEpoch=Long.parseLong(BUCKD_LAUNCH_TIME_NANOS.get(),10);
    LOG.verbose(""String_Node_Str"",nanosEpoch);
    clock=new NanosAdjustedClock(nanosEpoch);
  }
 else {
    clock=new DefaultClock();
  }
  ParserConfig parserConfig=new ParserConfig(buckConfig);
  Watchman watchman;
  ParserConfig.GlobHandler globHandler;
  if (context.isPresent() || parserConfig.getGlobHandler() == ParserConfig.GlobHandler.WATCHMAN) {
    watchman=Watchman.build(projectRoot,clientEnvironment,console,clock);
    if (parserConfig.getGlobHandler() == ParserConfig.GlobHandler.WATCHMAN && watchman.hasWildmatchGlob()) {
      globHandler=ParserConfig.GlobHandler.WATCHMAN;
    }
 else {
      globHandler=ParserConfig.GlobHandler.PYTHON;
    }
    LOG.debug(""String_Node_Str"" + ""String_Node_Str"",watchman.getCapabilities(),watchman.getWatchRoot(),watchman.getProjectPrefix(),parserConfig.getGlobHandler(),globHandler);
  }
 else {
    watchman=Watchman.NULL_WATCHMAN;
    globHandler=ParserConfig.GlobHandler.PYTHON;
  }
  final boolean isDaemon=context.isPresent() && (watchman != Watchman.NULL_WATCHMAN);
  KnownBuildRuleTypesFactory factory=new KnownBuildRuleTypesFactory(processExecutor,androidDirectoryResolver,testTempDirOverride);
  Cell rootCell=new Cell(filesystem,console,watchman,buckConfig,factory,androidDirectoryResolver,clock);
  int exitCode;
  ImmutableList<BuckEventListener> eventListeners=ImmutableList.of();
  ExecutionEnvironment executionEnvironment=new DefaultExecutionEnvironment(processExecutor,clientEnvironment,System.getProperties());
  ParserConfig.AllowSymlinks allowSymlinks=parserConfig.getAllowSymlinks();
  ProjectFileHashCache cellHashCache;
  ProjectFileHashCache buckOutHashCache;
  if (isDaemon) {
    cellHashCache=getFileHashCacheFromDaemon(rootCell,globHandler,allowSymlinks);
    buckOutHashCache=getBuckOutFileHashCacheFromDaemon(rootCell,globHandler,allowSymlinks);
  }
 else {
    cellHashCache=new DefaultFileHashCache(rootCell.getFilesystem());
    buckOutHashCache=new DefaultFileHashCache(new ProjectFilesystem(rootCell.getFilesystem().getRootPath(),Optional.of(ImmutableSet.of(BuckConstant.BUCK_OUTPUT_PATH)),ImmutableSet.<Path>of()));
  }
  FileHashCache fileHashCache=new StackedFileHashCache(ImmutableList.of(cellHashCache,buckOutHashCache,new DefaultFileHashCache(new ProjectFilesystem(rootCell.getFilesystem().getRootPath())),new DefaultFileHashCache(new ProjectFilesystem(Paths.get(""String_Node_Str"")))));
  Optional<WebServer> webServer=getWebServerIfDaemon(context,rootCell,globHandler,allowSymlinks);
  TestConfig testConfig=new TestConfig(buckConfig);
  ArtifactCacheBuckConfig cacheBuckConfig=new ArtifactCacheBuckConfig(buckConfig);
  ExecutorService diskIoExecutorService=MoreExecutors.newSingleThreadExecutor(""String_Node_Str"");
  VersionControlStatsGenerator vcStatsGenerator=null;
  try (ConsoleLogLevelOverrider consoleLogLevelOverrider=new ConsoleLogLevelOverrider(buildId.toString(),verbosity);ConsoleHandlerRedirector consoleHandlerRedirector=new ConsoleHandlerRedirector(buildId.toString(),console.getStdErr(),Optional.<OutputStream>of(stdErr));AbstractConsoleEventBusListener consoleListener=createConsoleEventListener(clock,console,testConfig.getResultSummaryVerbosity(),executionEnvironment,webServer);TempDirectoryCreator tempDirectoryCreator=new TempDirectoryCreator(testTempDirOverride);AsyncCloseable asyncCloseable=new AsyncCloseable(diskIoExecutorService);BuckEventBus buildEventBus=new BuckEventBus(clock,buildId)){
    ArtifactCache artifactCache=asyncCloseable.closeAsync(ArtifactCaches.newInstance(cacheBuckConfig,buildEventBus,filesystem,executionEnvironment.getWifiSsid()));
    ProgressEstimator progressEstimator=new ProgressEstimator(filesystem.getRootPath(),buildEventBus);
    consoleListener.setProgressEstimator(progressEstimator);
    eventListeners=addEventListeners(buildEventBus,rootCell.getFilesystem(),buildId,rootCell.getBuckConfig(),webServer,clock,executionEnvironment,console,consoleListener,rootCell.getKnownBuildRuleTypes(),clientEnvironment);
    VersionControlBuckConfig vcBuckConfig=new VersionControlBuckConfig(buckConfig);
    if (vcBuckConfig.shouldGenerateStatistics()) {
      vcStatsGenerator=new VersionControlStatsGenerator(diskIoExecutorService,new DefaultVersionControlCmdLineInterfaceFactory(rootCell.getFilesystem().getRootPath(),new PrintStreamProcessExecutorFactory(),vcBuckConfig),buildEventBus);
      vcStatsGenerator.generateStatsAsync();
    }
    ImmutableList<String> remainingArgs=args.length > 1 ? ImmutableList.copyOf(Arrays.copyOfRange(args,1,args.length)) : ImmutableList.<String>of();
    CommandEvent.Started startedEvent=CommandEvent.started(args.length > 0 ? args[0] : ""String_Node_Str"",remainingArgs,isDaemon);
    buildEventBus.post(startedEvent);
    Parser parser=null;
    if (isDaemon && watchman != Watchman.NULL_WATCHMAN) {
      try {
        Daemon daemon=getDaemon(rootCell,globHandler,allowSymlinks,objectMapper);
        WatchmanWatcher watchmanWatcher=new WatchmanWatcher(watchman.getWatchRoot().or(canonicalRootPath.toString()),daemon.getFileEventBus(),clock,objectMapper,processExecutor,filesystem.getIgnorePaths(),DEFAULT_IGNORE_GLOBS,watchman,daemon.getWatchmanQueryUUID());
        parser=getParserFromDaemon(context,rootCell,startedEvent,buildEventBus,watchmanWatcher,globHandler,allowSymlinks);
      }
 catch (      WatchmanWatcherException|IOException e) {
        buildEventBus.post(ConsoleEvent.warning(""String_Node_Str"",e.getMessage()));
      }
    }
    if (parser == null) {
      parser=Parser.createBuildFileParser(rootCell,globHandler == ParserConfig.GlobHandler.WATCHMAN,allowSymlinks);
    }
    JavaUtilsLoggingBuildListener.ensureLogFileIsWritten(rootCell.getFilesystem());
    Optional<ProcessManager> processManager;
    if (platform == Platform.WINDOWS) {
      processManager=Optional.absent();
    }
 else {
      processManager=Optional.<ProcessManager>of(new PkillProcessManager(processExecutor));
    }
    Supplier<AndroidPlatformTarget> androidPlatformTargetSupplier=createAndroidPlatformTargetSupplier(androidDirectoryResolver,androidBuckConfig,buildEventBus);
    if (command.subcommand instanceof AbstractCommand) {
      AbstractCommand subcommand=(AbstractCommand)command.subcommand;
      Optional<Path> eventsOutputPath=subcommand.getEventsOutputPath();
      if (eventsOutputPath.isPresent()) {
        BuckEventListener listener=new FileSerializationEventBusListener(eventsOutputPath.get());
        buildEventBus.register(listener);
      }
    }
    exitCode=command.run(new CommandRunnerParams(console,rootCell,androidPlatformTargetSupplier,artifactCache,buildEventBus,parser,platform,clientEnvironment,rootCell.getBuckConfig().createDefaultJavaPackageFinder(),objectMapper,clock,processManager,webServer,buckConfig,fileHashCache));
    parser.cleanCache();
    buildEventBus.post(CommandEvent.finished(startedEvent,exitCode));
  }
 catch (  Throwable t) {
    LOG.debug(t,""String_Node_Str"");
    closeDiskIoExecutorService(diskIoExecutorService);
    flushEventListeners(console,buildId,eventListeners);
    throw t;
  }
 finally {
    if (commandSemaphoreAcquired) {
      commandSemaphore.release();
    }
  }
  if (context.isPresent() && !rootCell.getBuckConfig().getFlushEventsBeforeExit()) {
    context.get().in.close();
    context.get().exit(exitCode);
  }
  closeDiskIoExecutorService(diskIoExecutorService);
  flushEventListeners(console,buildId,eventListeners);
  return exitCode;
}",0.9986988289460514
53152,"@Override public VersionControlCmdLineInterface createCmdLineInterface() throws InterruptedException {
  HgCmdLineInterface hgCmdLineInterface=new HgCmdLineInterface(processExecutor,projectRoot.toFile(),hgCmd);
  try {
    hgCmdLineInterface.currentRevisionId();
    LOG.debug(""String_Node_Str"");
    return hgCmdLineInterface;
  }
 catch (  VersionControlCommandFailedException ex) {
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
  }
  LOG.debug(""String_Node_Str"");
  return new NoOpCmdLineInterface();
}","@Override public VersionControlCmdLineInterface createCmdLineInterface() throws InterruptedException {
  HgCmdLineInterface hgCmdLineInterface=new HgCmdLineInterface(processExecutorFactory,projectRoot.toFile(),hgCmd);
  try {
    hgCmdLineInterface.currentRevisionId();
    LOG.debug(""String_Node_Str"");
    return hgCmdLineInterface;
  }
 catch (  VersionControlCommandFailedException ex) {
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
  }
  LOG.debug(""String_Node_Str"");
  return new NoOpCmdLineInterface();
}",0.9935004642525532
53153,"public DefaultVersionControlCmdLineInterfaceFactory(Path projectRoot,ProcessExecutor processExecutor,VersionControlBuckConfig buckConfig){
  this.projectRoot=projectRoot;
  this.processExecutor=processExecutor;
  this.hgCmd=buckConfig.getHgCmd();
}","public DefaultVersionControlCmdLineInterfaceFactory(Path projectRoot,ProcessExecutorFactory processExecutorFactory,VersionControlBuckConfig buckConfig){
  this.projectRoot=projectRoot;
  this.processExecutorFactory=processExecutorFactory;
  this.hgCmd=buckConfig.getHgCmd();
}",0.8854961832061069
53154,"private String executeCommand(Iterable<String> command) throws VersionControlCommandFailedException, InterruptedException {
  command=replaceTemplateValue(command,HG_CMD_TEMPLATE,hgCmd);
  ProcessExecutorParams processExecutorParams=ProcessExecutorParams.builder().setCommand(command).setDirectory(projectRoot).build();
  String commandString=commandAsString(command);
  LOG.debug(""String_Node_Str"" + commandString);
  try {
    ProcessExecutor.Result result=processExecutor.launchAndExecute(processExecutorParams,ImmutableSet.of(ProcessExecutor.Option.EXPECTING_STD_OUT),Optional.<String>absent(),Optional.<Long>absent(),Optional.<Function<Process,Void>>absent());
    Optional<String> resultString=result.getStdout();
    if (!resultString.isPresent()) {
      throw new VersionControlCommandFailedException(""String_Node_Str"" + commandString);
    }
    if (result.getExitCode() != 0) {
      throw new VersionControlCommandFailedException(""String_Node_Str"" + commandString);
    }
    return cleanResultString(resultString.get());
  }
 catch (  IOException e) {
    throw new VersionControlCommandFailedException(e);
  }
}","private String executeCommand(Iterable<String> command) throws VersionControlCommandFailedException, InterruptedException {
  command=replaceTemplateValue(command,HG_CMD_TEMPLATE,hgCmd);
  String commandString=commandAsString(command);
  LOG.debug(""String_Node_Str"" + commandString);
  ProcessExecutorParams processExecutorParams=ProcessExecutorParams.builder().setCommand(command).setDirectory(projectRoot).build();
  ProcessExecutor.Result result;
  try (PrintStream stdout=new PrintStream(new ByteArrayOutputStream());PrintStream stderr=new PrintStream(new ByteArrayOutputStream())){
    ProcessExecutor processExecutor=processExecutorFactory.createProcessExecutor(stdout,stderr);
    result=processExecutor.launchAndExecute(processExecutorParams);
  }
 catch (  IOException e) {
    throw new VersionControlCommandFailedException(e);
  }
  Optional<String> resultString=result.getStdout();
  if (!resultString.isPresent()) {
    throw new VersionControlCommandFailedException(""String_Node_Str"" + commandString);
  }
  if (result.getExitCode() != 0) {
    Optional<String> stderr=result.getStderr();
    String stdErrString=stderr.isPresent() ? stderr.get() : ""String_Node_Str"";
    throw new VersionControlCommandFailedException(""String_Node_Str"" + commandString + ""String_Node_Str""+ stdErrString);
  }
  return cleanResultString(resultString.get());
}",0.4997984683595324
53155,"public HgCmdLineInterface(ProcessExecutor processExecutor,File projectRoot,String hgCmd){
  this.processExecutor=processExecutor;
  this.projectRoot=projectRoot;
  this.hgCmd=hgCmd;
}","public HgCmdLineInterface(ProcessExecutorFactory processExecutorFactory,File projectRoot,String hgCmd){
  this.processExecutorFactory=processExecutorFactory;
  this.projectRoot=projectRoot;
  this.hgCmd=hgCmd;
}",0.8477157360406091
53156,"/** 
 * @return a memoizing {@link Supplier} that caches the output of{@code security -v -p codesigning} to find all valid code signing identities.
 */
public static Supplier<ImmutableSet<CodeSignIdentity>> createCodeSignIdentitiesSupplier(final ProcessExecutor processExecutor){
  return Suppliers.memoize(new Supplier<ImmutableSet<CodeSignIdentity>>(){
    @Override public ImmutableSet<CodeSignIdentity> get(){
      ProcessExecutorParams processExecutorParams=ProcessExecutorParams.builder().setCommand(ImmutableList.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).build();
      Set<ProcessExecutor.Option> options=EnumSet.of(ProcessExecutor.Option.EXPECTING_STD_OUT);
      ProcessExecutor.Result result;
      try {
        result=processExecutor.launchAndExecute(processExecutorParams,options,Optional.<String>absent(),Optional.<Long>absent(),Optional.<Function<Process,Void>>absent());
      }
 catch (      InterruptedException|IOException e) {
        LOG.warn(""String_Node_Str"");
        return ImmutableSet.of();
      }
      if (result.getExitCode() != 0) {
        throw new RuntimeException(""String_Node_Str"" + result.getStderr());
      }
      Matcher matcher=CODE_SIGN_IDENTITY_PATTERN.matcher(result.getStdout().get());
      ImmutableSet.Builder<CodeSignIdentity> builder=ImmutableSet.builder();
      while (matcher.find()) {
        String hash=matcher.group(1);
        String fullName=matcher.group(2);
        CodeSignIdentity identity=CodeSignIdentity.builder().setHash(hash).setFullName(fullName).build();
        builder.add(identity);
        LOG.debug(""String_Node_Str"" + identity.toString());
      }
      ImmutableSet<CodeSignIdentity> allValidIdentities=builder.build();
      if (allValidIdentities.isEmpty()) {
        LOG.warn(""String_Node_Str"");
      }
 else       if (allValidIdentities.size() > 1) {
        LOG.warn(""String_Node_Str"" + ""String_Node_Str"");
      }
      return allValidIdentities;
    }
  }
);
}","/** 
 * @return a memoizing {@link Supplier} that caches the output of{@code security -v -p codesigning} to find all valid code signing identities.
 */
public static Supplier<ImmutableSet<CodeSignIdentity>> createCodeSignIdentitiesSupplier(final ProcessExecutor processExecutor){
  return Suppliers.memoize(new Supplier<ImmutableSet<CodeSignIdentity>>(){
    @Override public ImmutableSet<CodeSignIdentity> get(){
      ProcessExecutorParams processExecutorParams=ProcessExecutorParams.builder().setCommand(ImmutableList.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).build();
      Set<ProcessExecutor.Option> options=EnumSet.of(ProcessExecutor.Option.EXPECTING_STD_OUT);
      ProcessExecutor.Result result;
      try {
        result=processExecutor.launchAndExecute(processExecutorParams,options,Optional.<String>absent(),Optional.<Long>absent(),Optional.<Function<Process,Void>>absent());
      }
 catch (      InterruptedException|IOException e) {
        LOG.warn(""String_Node_Str"");
        return ImmutableSet.of();
      }
      if (result.getExitCode() != 0) {
        throw new RuntimeException(""String_Node_Str"" + result.getStderr());
      }
      Matcher matcher=CODE_SIGN_IDENTITY_PATTERN.matcher(result.getStdout().get());
      ImmutableSet.Builder<CodeSignIdentity> builder=ImmutableSet.builder();
      while (matcher.find()) {
        String hash=matcher.group(1);
        String fullName=matcher.group(2);
        CodeSignIdentity identity=CodeSignIdentity.builder().setHash(hash).setFullName(fullName).build();
        builder.add(identity);
        LOG.debug(""String_Node_Str"" + identity.toString());
      }
      ImmutableSet<CodeSignIdentity> allValidIdentities=builder.build();
      if (allValidIdentities.isEmpty()) {
        LOG.warn(""String_Node_Str"");
      }
 else       if (allValidIdentities.size() > 1) {
        LOG.info(""String_Node_Str"" + ""String_Node_Str"");
      }
      return allValidIdentities;
    }
  }
);
}",0.998001998001998
53157,"@VisibleForTesting static AppleCxxPlatform buildWithExecutableChecker(AppleSdk targetSdk,String minVersion,String targetArchitecture,AppleSdkPaths sdkPaths,BuckConfig buckConfig,ExecutableFinder executableFinder){
  ImmutableList.Builder<Path> toolSearchPathsBuilder=ImmutableList.builder();
  toolSearchPathsBuilder.add(sdkPaths.getSdkPath().resolve(USR_BIN)).add(sdkPaths.getSdkPath().resolve(""String_Node_Str"").resolve(USR_BIN)).add(sdkPaths.getPlatformPath().resolve(""String_Node_Str"").resolve(USR_BIN));
  for (  Path toolchainPath : sdkPaths.getToolchainPaths()) {
    toolSearchPathsBuilder.add(toolchainPath.resolve(USR_BIN));
  }
  if (sdkPaths.getDeveloperPath().isPresent()) {
    toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve(USR_BIN));
    toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve(""String_Node_Str""));
  }
  ImmutableList<Path> toolSearchPaths=toolSearchPathsBuilder.build();
  ImmutableList.Builder<String> cflagsBuilder=ImmutableList.builder();
  cflagsBuilder.add(""String_Node_Str"",sdkPaths.getSdkPath().toString());
  cflagsBuilder.add(""String_Node_Str"",targetArchitecture);
switch (targetSdk.getApplePlatform().getName()) {
case ApplePlatform.Name.IPHONEOS:
    cflagsBuilder.add(""String_Node_Str"" + minVersion);
  break;
case ApplePlatform.Name.IPHONESIMULATOR:
cflagsBuilder.add(""String_Node_Str"" + minVersion);
break;
case ApplePlatform.Name.WATCHOS:
cflagsBuilder.add(""String_Node_Str"" + minVersion);
break;
case ApplePlatform.Name.WATCHSIMULATOR:
cflagsBuilder.add(""String_Node_Str"" + minVersion);
break;
default :
cflagsBuilder.add(""String_Node_Str"" + targetSdk.getApplePlatform().getName() + ""String_Node_Str""+ minVersion);
break;
}
ImmutableList<String> ldflags=ImmutableList.copyOf(Linkers.iXlinker(""String_Node_Str"",targetSdk.getVersion()));
ImmutableList<String> asflags=ImmutableList.of(""String_Node_Str"",targetArchitecture);
ImmutableList.Builder<String> versionsBuilder=ImmutableList.builder();
versionsBuilder.add(targetSdk.getVersion());
for (AppleToolchain toolchain : targetSdk.getToolchains()) {
versionsBuilder.add(toolchain.getVersion());
}
String version=Joiner.on(':').join(versionsBuilder.build());
Tool clangPath=new VersionedTool(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),ImmutableList.<String>of(),""String_Node_Str"",version);
Tool clangXxPath=new VersionedTool(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),ImmutableList.<String>of(),""String_Node_Str"",version);
Tool ar=new VersionedTool(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),ImmutableList.<String>of(),""String_Node_Str"",version);
Tool strip=new VersionedTool(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),ImmutableList.<String>of(),""String_Node_Str"",version);
Tool actool=new VersionedTool(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),ImmutableList.<String>of(),""String_Node_Str"",version);
Tool ibtool=new VersionedTool(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),ImmutableList.<String>of(),""String_Node_Str"",version);
Tool xctest=new VersionedTool(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),ImmutableList.<String>of(),""String_Node_Str"",version);
Optional<Tool> otest=getOptionalTool(""String_Node_Str"",toolSearchPaths,executableFinder,version);
Tool dsymutil=new VersionedTool(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),ImmutableList.<String>of(),""String_Node_Str"",version);
CxxBuckConfig config=new CxxBuckConfig(buckConfig);
ImmutableFlavor targetFlavor=ImmutableFlavor.of(ImmutableFlavor.replaceInvalidCharacters(targetSdk.getName() + ""String_Node_Str"" + targetArchitecture));
ImmutableBiMap.Builder<Path,Path> sanitizerPaths=ImmutableBiMap.builder();
sanitizerPaths.put(sdkPaths.getSdkPath(),Paths.get(""String_Node_Str""));
sanitizerPaths.put(sdkPaths.getPlatformPath(),Paths.get(""String_Node_Str""));
if (sdkPaths.getDeveloperPath().isPresent()) {
sanitizerPaths.put(sdkPaths.getDeveloperPath().get(),Paths.get(""String_Node_Str""));
}
DebugPathSanitizer debugPathSanitizer=new DebugPathSanitizer(250,File.separatorChar,Paths.get(""String_Node_Str""),sanitizerPaths.build());
ImmutableList<String> cflags=cflagsBuilder.build();
ImmutableMap.Builder<String,String> macrosBuilder=ImmutableMap.builder();
macrosBuilder.put(""String_Node_Str"",sdkPaths.getSdkPath().toString());
macrosBuilder.put(""String_Node_Str"",sdkPaths.getPlatformPath().toString());
if (sdkPaths.getDeveloperPath().isPresent()) {
macrosBuilder.put(""String_Node_Str"",sdkPaths.getDeveloperPath().get().toString());
}
ImmutableMap<String,String> macros=macrosBuilder.build();
CxxPlatform cxxPlatform=CxxPlatforms.build(targetFlavor,config,clangPath,new ClangPreprocessor(clangPath),new ClangCompiler(clangPath),new ClangCompiler(clangXxPath),new ClangPreprocessor(clangPath),new ClangPreprocessor(clangXxPath),new DarwinLinker(clangXxPath),ImmutableList.<String>builder().addAll(cflags).addAll(ldflags).build(),strip,new BsdArchiver(ar),asflags,ImmutableList.<String>of(),cflags,ImmutableList.<String>of(),getOptionalTool(""String_Node_Str"",toolSearchPaths,executableFinder,version),getOptionalTool(""String_Node_Str"",toolSearchPaths,executableFinder,version),""String_Node_Str"",Optional.of(debugPathSanitizer),macros);
return AppleCxxPlatform.builder().setCxxPlatform(cxxPlatform).setAppleSdk(targetSdk).setAppleSdkPaths(sdkPaths).setActool(actool).setIbtool(ibtool).setXctest(xctest).setOtest(otest).setDsymutil(dsymutil).build();
}","@VisibleForTesting static AppleCxxPlatform buildWithExecutableChecker(AppleSdk targetSdk,String minVersion,String targetArchitecture,AppleSdkPaths sdkPaths,BuckConfig buckConfig,ExecutableFinder executableFinder){
  ImmutableList.Builder<Path> toolSearchPathsBuilder=ImmutableList.builder();
  toolSearchPathsBuilder.add(sdkPaths.getSdkPath().resolve(USR_BIN)).add(sdkPaths.getSdkPath().resolve(""String_Node_Str"").resolve(USR_BIN)).add(sdkPaths.getPlatformPath().resolve(""String_Node_Str"").resolve(USR_BIN));
  for (  Path toolchainPath : sdkPaths.getToolchainPaths()) {
    toolSearchPathsBuilder.add(toolchainPath.resolve(USR_BIN));
  }
  if (sdkPaths.getDeveloperPath().isPresent()) {
    toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve(USR_BIN));
    toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve(""String_Node_Str""));
  }
  ImmutableList<Path> toolSearchPaths=toolSearchPathsBuilder.build();
  ImmutableList.Builder<String> cflagsBuilder=ImmutableList.builder();
  cflagsBuilder.add(""String_Node_Str"",sdkPaths.getSdkPath().toString());
  cflagsBuilder.add(""String_Node_Str"",targetArchitecture);
switch (targetSdk.getApplePlatform().getName()) {
case ApplePlatform.Name.IPHONEOS:
    cflagsBuilder.add(""String_Node_Str"" + minVersion);
  break;
case ApplePlatform.Name.IPHONESIMULATOR:
cflagsBuilder.add(""String_Node_Str"" + minVersion);
break;
case ApplePlatform.Name.WATCHOS:
cflagsBuilder.add(""String_Node_Str"" + minVersion);
break;
case ApplePlatform.Name.WATCHSIMULATOR:
cflagsBuilder.add(""String_Node_Str"" + minVersion);
break;
default :
cflagsBuilder.add(""String_Node_Str"" + targetSdk.getApplePlatform().getName() + ""String_Node_Str""+ minVersion);
break;
}
ImmutableList<String> asflags=cflagsBuilder.build();
ImmutableList<String> ldflags=ImmutableList.copyOf(Linkers.iXlinker(""String_Node_Str"",targetSdk.getVersion()));
ImmutableList.Builder<String> versionsBuilder=ImmutableList.builder();
versionsBuilder.add(targetSdk.getVersion());
for (AppleToolchain toolchain : targetSdk.getToolchains()) {
versionsBuilder.add(toolchain.getVersion());
}
String version=Joiner.on(':').join(versionsBuilder.build());
Tool clangPath=new VersionedTool(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),ImmutableList.<String>of(),""String_Node_Str"",version);
Tool clangXxPath=new VersionedTool(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),ImmutableList.<String>of(),""String_Node_Str"",version);
Tool ar=new VersionedTool(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),ImmutableList.<String>of(),""String_Node_Str"",version);
Tool strip=new VersionedTool(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),ImmutableList.<String>of(),""String_Node_Str"",version);
Tool actool=new VersionedTool(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),ImmutableList.<String>of(),""String_Node_Str"",version);
Tool ibtool=new VersionedTool(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),ImmutableList.<String>of(),""String_Node_Str"",version);
Tool xctest=new VersionedTool(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),ImmutableList.<String>of(),""String_Node_Str"",version);
Optional<Tool> otest=getOptionalTool(""String_Node_Str"",toolSearchPaths,executableFinder,version);
Tool dsymutil=new VersionedTool(getToolPath(""String_Node_Str"",toolSearchPaths,executableFinder),ImmutableList.<String>of(),""String_Node_Str"",version);
CxxBuckConfig config=new CxxBuckConfig(buckConfig);
ImmutableFlavor targetFlavor=ImmutableFlavor.of(ImmutableFlavor.replaceInvalidCharacters(targetSdk.getName() + ""String_Node_Str"" + targetArchitecture));
ImmutableBiMap.Builder<Path,Path> sanitizerPaths=ImmutableBiMap.builder();
sanitizerPaths.put(sdkPaths.getSdkPath(),Paths.get(""String_Node_Str""));
sanitizerPaths.put(sdkPaths.getPlatformPath(),Paths.get(""String_Node_Str""));
if (sdkPaths.getDeveloperPath().isPresent()) {
sanitizerPaths.put(sdkPaths.getDeveloperPath().get(),Paths.get(""String_Node_Str""));
}
DebugPathSanitizer debugPathSanitizer=new DebugPathSanitizer(250,File.separatorChar,Paths.get(""String_Node_Str""),sanitizerPaths.build());
ImmutableList<String> cflags=cflagsBuilder.build();
ImmutableMap.Builder<String,String> macrosBuilder=ImmutableMap.builder();
macrosBuilder.put(""String_Node_Str"",sdkPaths.getSdkPath().toString());
macrosBuilder.put(""String_Node_Str"",sdkPaths.getPlatformPath().toString());
if (sdkPaths.getDeveloperPath().isPresent()) {
macrosBuilder.put(""String_Node_Str"",sdkPaths.getDeveloperPath().get().toString());
}
ImmutableMap<String,String> macros=macrosBuilder.build();
CxxPlatform cxxPlatform=CxxPlatforms.build(targetFlavor,config,clangPath,new ClangPreprocessor(clangPath),new ClangCompiler(clangPath),new ClangCompiler(clangXxPath),new ClangPreprocessor(clangPath),new ClangPreprocessor(clangXxPath),new DarwinLinker(clangXxPath),ImmutableList.<String>builder().addAll(cflags).addAll(ldflags).build(),strip,new BsdArchiver(ar),asflags,ImmutableList.<String>of(),cflags,ImmutableList.<String>of(),getOptionalTool(""String_Node_Str"",toolSearchPaths,executableFinder,version),getOptionalTool(""String_Node_Str"",toolSearchPaths,executableFinder,version),""String_Node_Str"",Optional.of(debugPathSanitizer),macros);
return AppleCxxPlatform.builder().setCxxPlatform(cxxPlatform).setAppleSdk(targetSdk).setAppleSdkPaths(sdkPaths).setActool(actool).setIbtool(ibtool).setXctest(xctest).setOtest(otest).setDsymutil(dsymutil).build();
}",0.9873371595153504
53158,"@Test public void testAppleBinaryBuildsSomething() throws IOException {
  ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",tmp);
  workspace.setUp();
  workspace.runBuckCommand(""String_Node_Str"",""String_Node_Str"").assertSuccess();
  assertTrue(Files.exists(tmp.getRootPath().resolve(BuckConstant.GEN_DIR)));
}","@Test public void testAppleBinaryBuildsSomething() throws IOException {
  assumeTrue(Platform.detect() == Platform.MACOS);
  ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",tmp);
  workspace.setUp();
  workspace.runBuckCommand(""String_Node_Str"",""String_Node_Str"").assertSuccess();
  assertTrue(Files.exists(tmp.getRootPath().resolve(BuckConstant.GEN_DIR)));
}",0.9336801040312094
53159,"@Test public void bundleBinaryHasDsymBundle() throws IOException, InterruptedException {
  assumeTrue(Platform.detect() == Platform.MACOS);
  ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",tmp);
  workspace.setUp();
  workspace.runBuckCommand(""String_Node_Str"",""String_Node_Str"").assertSuccess();
  workspace.verify();
  Path bundlePath=tmp.getRootPath().resolve(BuckConstant.GEN_DIR).resolve(""String_Node_Str"");
  Path dwarfPath=bundlePath.getParent().resolve(""String_Node_Str"");
  Path binaryPath=bundlePath.resolve(""String_Node_Str"");
  assertTrue(Files.exists(dwarfPath));
  String dwarfdumpMainStdout=workspace.runCommand(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",dwarfPath.toString()).getStdout().or(""String_Node_Str"");
  assertTrue(dwarfdumpMainStdout.contains(""String_Node_Str""));
  assertTrue(dwarfdumpMainStdout.contains(""String_Node_Str""));
  assertTrue(dwarfdumpMainStdout.contains(""String_Node_Str""));
  ProcessExecutor.Result result=workspace.runCommand(""String_Node_Str"",""String_Node_Str"",binaryPath.toString() + ""String_Node_Str"",binaryPath.toString());
  assertThat(result.getStdout().isPresent(),is(true));
  assertThat(result.getStdout().get(),containsString(""String_Node_Str""));
}","@Test public void bundleBinaryHasDsymBundle() throws IOException, InterruptedException {
  assumeTrue(Platform.detect() == Platform.MACOS);
  ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",tmp);
  workspace.setUp();
  workspace.runBuckCommand(""String_Node_Str"",""String_Node_Str"").assertSuccess();
  workspace.verify();
  Path bundlePath=tmp.getRootPath().resolve(BuckConstant.GEN_DIR).resolve(""String_Node_Str"");
  Path dwarfPath=bundlePath.getParent().resolve(""String_Node_Str"");
  Path binaryPath=bundlePath.resolve(""String_Node_Str"");
  assertTrue(Files.exists(dwarfPath));
  String dwarfdumpMainStdout=workspace.runCommand(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",dwarfPath.toString()).getStdout().or(""String_Node_Str"");
  assertTrue(dwarfdumpMainStdout.contains(""String_Node_Str""));
  assertTrue(dwarfdumpMainStdout.contains(""String_Node_Str""));
  assertTrue(dwarfdumpMainStdout.contains(""String_Node_Str""));
  ProcessExecutor.Result result=workspace.runCommand(""String_Node_Str"",""String_Node_Str"",binaryPath.toString() + ""String_Node_Str"",binaryPath.toString());
  String dsymutilOutput=""String_Node_Str"";
  if (result.getStderr().isPresent()) {
    dsymutilOutput=result.getStderr().get();
  }
  if (dsymutilOutput.isEmpty()) {
    assertThat(result.getStdout().isPresent(),is(true));
    dsymutilOutput=result.getStdout().get();
  }
  assertThat(dsymutilOutput,containsString(""String_Node_Str""));
}",0.906764168190128
53160,"private void assertFlags(String source,String output,boolean isLibrary,Map<String,CxxCompilationDatabaseEntry> fileToEntry,ImmutableSet<String> additionalFrameworks,Iterable<String> includes) throws IOException {
  Path tmpRoot=tmp.getRootPath().toRealPath();
  String key=tmpRoot.resolve(source).toString();
  CxxCompilationDatabaseEntry entry=fileToEntry.get(key);
  assertNotNull(""String_Node_Str"" + key + ""String_Node_Str"",entry);
  String clang=tmpRoot.resolve(XCODE_DEVELOPER_DIR).resolve(""String_Node_Str"").toString();
  String sdkRoot=tmpRoot.resolve(XCODE_DEVELOPER_DIR).resolve(""String_Node_Str"").toString();
  String language=""String_Node_Str"";
  String languageStandard=""String_Node_Str"";
  if (source.endsWith(""String_Node_Str"")) {
    language=""String_Node_Str"";
    languageStandard=""String_Node_Str"";
    clang+=""String_Node_Str"";
  }
  List<String> commandArgs=Lists.newArrayList();
  commandArgs.add(clang);
  commandArgs.add(""String_Node_Str"" + languageStandard + ""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  if (isLibrary) {
    commandArgs.add(""String_Node_Str"");
  }
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(sdkRoot);
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"" + languageStandard + ""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  for (  String include : includes) {
    commandArgs.add(""String_Node_Str"");
    commandArgs.add(include);
  }
  for (  String framework : additionalFrameworks) {
    commandArgs.add(""String_Node_Str"");
    commandArgs.add(sdkRoot + framework);
  }
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"" + Strings.repeat(""String_Node_Str"",249));
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(language);
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(output + ""String_Node_Str"");
  commandArgs.add(source);
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(output);
  MoreAsserts.assertIterablesEquals(commandArgs,ImmutableList.copyOf(entry.command.split(""String_Node_Str"")));
}","private void assertFlags(String source,String output,boolean isLibrary,Map<String,CxxCompilationDatabaseEntry> fileToEntry,ImmutableSet<String> additionalFrameworks,Iterable<String> includes) throws IOException {
  Path tmpRoot=tmp.getRootPath().toRealPath();
  String key=tmpRoot.resolve(source).toString();
  CxxCompilationDatabaseEntry entry=fileToEntry.get(key);
  assertNotNull(""String_Node_Str"" + key + ""String_Node_Str"",entry);
  String clang=tmpRoot.resolve(XCODE_DEVELOPER_DIR).resolve(""String_Node_Str"").toString();
  String sdkRoot=tmpRoot.resolve(XCODE_DEVELOPER_DIR).resolve(""String_Node_Str"").toString();
  String language=""String_Node_Str"";
  String languageStandard=""String_Node_Str"";
  if (source.endsWith(""String_Node_Str"")) {
    language=""String_Node_Str"";
    languageStandard=""String_Node_Str"";
    clang+=""String_Node_Str"";
  }
  List<String> commandArgs=Lists.newArrayList();
  commandArgs.add(clang);
  commandArgs.add(""String_Node_Str"" + languageStandard + ""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  if (isLibrary) {
    commandArgs.add(""String_Node_Str"");
  }
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(sdkRoot);
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"" + languageStandard + ""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(sdkRoot);
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  for (  String include : includes) {
    commandArgs.add(""String_Node_Str"");
    commandArgs.add(include);
  }
  for (  String framework : additionalFrameworks) {
    commandArgs.add(""String_Node_Str"");
    commandArgs.add(sdkRoot + framework);
  }
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"" + Strings.repeat(""String_Node_Str"",249));
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(language);
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(output + ""String_Node_Str"");
  commandArgs.add(source);
  commandArgs.add(""String_Node_Str"");
  commandArgs.add(output);
  MoreAsserts.assertIterablesEquals(commandArgs,ImmutableList.copyOf(entry.command.split(""String_Node_Str"")));
}",0.9790068631408962
53161,"public static Path getHeaderPathPrefix(AppleNativeTargetDescriptionArg arg,BuildTarget buildTarget){
  return Paths.get(arg.headerPathPrefix.or(buildTarget.getShortName()));
}","public static Path getHeaderPathPrefix(CxxLibraryDescription.Arg arg,BuildTarget buildTarget){
  Optional<String> prefix;
  if (arg instanceof AppleNativeTargetDescriptionArg) {
    prefix=((AppleNativeTargetDescriptionArg)arg).headerPathPrefix;
  }
 else {
    prefix=arg.headerNamespace;
  }
  return Paths.get(prefix.or(buildTarget.getShortName()));
}",0.4763705103969754
53162,"private PBXNativeTarget generateBinaryTarget(PBXProject project,Optional<? extends TargetNode<? extends HasAppleBundleFields>> bundle,TargetNode<? extends CxxLibraryDescription.Arg> targetNode,ProductType productType,String productOutputFormat,Optional<Path> infoPlistOptional,boolean includeFrameworks,ImmutableSet<AppleResourceDescription.Arg> recursiveResources,ImmutableSet<AppleResourceDescription.Arg> directResources,ImmutableSet<AppleAssetCatalogDescription.Arg> recursiveAssetCatalogs,ImmutableSet<AppleAssetCatalogDescription.Arg> directAssetCatalogs,Optional<Iterable<PBXBuildPhase>> copyFilesPhases,Optional<TargetNode<AppleBundleDescription.Arg>> bundleLoaderNode) throws IOException {
  LOG.debug(""String_Node_Str"",targetNode);
  TargetNode<?> buildTargetNode=bundle.isPresent() ? bundle.get() : targetNode;
  final BuildTarget buildTarget=buildTargetNode.getBuildTarget();
  String productName=getProductName(buildTarget);
  CxxLibraryDescription.Arg arg=targetNode.getConstructorArg();
  NewNativeTargetProjectMutator mutator=new NewNativeTargetProjectMutator(pathRelativizer,sourcePathResolver);
  ImmutableSet<SourcePath> exportedHeaders=ImmutableSet.copyOf(getHeaderSourcePaths(arg.exportedHeaders));
  ImmutableSet<SourcePath> headers=ImmutableSet.copyOf(getHeaderSourcePaths(arg.headers));
  mutator.setTargetName(getXcodeTargetName(buildTarget)).setProduct(productType,productName,Paths.get(String.format(productOutputFormat,productName))).setSourcesWithFlags(ImmutableSet.copyOf(arg.srcs.get())).setPublicHeaders(exportedHeaders).setPrivateHeaders(headers).setPrefixHeader(arg.prefixHeader).setRecursiveResources(recursiveResources).setDirectResources(directResources);
  Optional<TargetNode<AppleNativeTargetDescriptionArg>> appleTargetNode=targetNode.castArg(AppleNativeTargetDescriptionArg.class);
  if (appleTargetNode.isPresent()) {
    AppleNativeTargetDescriptionArg appleArg=appleTargetNode.get().getConstructorArg();
    mutator=mutator.setExtraXcodeSources(ImmutableSet.copyOf(appleArg.extraXcodeSources.get()));
  }
  if (options.contains(Option.CREATE_DIRECTORY_STRUCTURE)) {
    mutator.setTargetGroupPath(FluentIterable.from(buildTarget.getBasePath()).transform(Functions.toStringFunction()).toList());
  }
  if (!recursiveAssetCatalogs.isEmpty()) {
    mutator.setRecursiveAssetCatalogs(recursiveAssetCatalogs);
  }
  if (!directAssetCatalogs.isEmpty()) {
    mutator.setDirectAssetCatalogs(directAssetCatalogs);
  }
  if (includeFrameworks) {
    ImmutableSet.Builder<FrameworkPath> frameworksBuilder=ImmutableSet.builder();
    frameworksBuilder.addAll(targetNode.getConstructorArg().frameworks.get());
    frameworksBuilder.addAll(targetNode.getConstructorArg().libraries.get());
    frameworksBuilder.addAll(collectRecursiveFrameworkDependencies(ImmutableList.of(targetNode)));
    mutator.setFrameworks(frameworksBuilder.build());
    mutator.setArchives(collectRecursiveLibraryDependencies(ImmutableList.of(targetNode)));
  }
  ImmutableList.Builder<TargetNode<?>> preScriptPhases=ImmutableList.builder();
  ImmutableList.Builder<TargetNode<?>> postScriptPhases=ImmutableList.builder();
  boolean skipRNBundle=ReactNativeFlavors.skipBundling(buildTargetNode.getBuildTarget());
  if (bundle.isPresent() && targetNode != bundle.get()) {
    collectBuildScriptDependencies(targetGraph.getAll(bundle.get().getDeclaredDeps()),preScriptPhases,postScriptPhases,skipRNBundle);
  }
  collectBuildScriptDependencies(targetGraph.getAll(targetNode.getDeclaredDeps()),preScriptPhases,postScriptPhases,skipRNBundle);
  mutator.setPreBuildRunScriptPhases(preScriptPhases.build());
  if (copyFilesPhases.isPresent()) {
    mutator.setCopyFilesPhases(copyFilesPhases.get());
  }
  mutator.setPostBuildRunScriptPhases(postScriptPhases.build());
  mutator.skipReactNativeBundle(skipRNBundle);
  if (skipRNBundle && reactNativeServer.isPresent()) {
    mutator.setAdditionalRunScripts(ImmutableList.of(projectFilesystem.resolve(reactNativeServer.get())));
  }
  NewNativeTargetProjectMutator.Result targetBuilderResult;
  try {
    targetBuilderResult=mutator.buildTargetAndAddToProject(project);
  }
 catch (  NoSuchBuildTargetException e) {
    throw new HumanReadableException(e);
  }
  PBXGroup targetGroup=targetBuilderResult.targetGroup;
  SourceTreePath buckFilePath=new SourceTreePath(PBXReference.SourceTree.SOURCE_ROOT,pathRelativizer.outputPathToBuildTargetPath(buildTarget).resolve(buildFileName),Optional.<String>absent());
  PBXFileReference buckReference=targetGroup.getOrCreateFileReferenceBySourceTreePath(buckFilePath);
  buckReference.setExplicitFileType(Optional.of(""String_Node_Str""));
  ImmutableMap.Builder<String,String> extraSettingsBuilder=ImmutableMap.builder();
  extraSettingsBuilder.put(""String_Node_Str"",getProductName(buildTarget)).put(""String_Node_Str"",pathRelativizer.outputPathToBuildTargetPath(buildTarget).toString());
  if (bundleLoaderNode.isPresent()) {
    TargetNode<AppleBundleDescription.Arg> bundleLoader=bundleLoaderNode.get();
    String bundleLoaderProductName=getProductName(bundleLoader.getBuildTarget());
    String bundleName=bundleLoaderProductName + ""String_Node_Str"" + getExtensionString(bundleLoader.getConstructorArg().getExtension());
    String bundleLoaderOutputPath=Joiner.on('/').join(getTargetOutputPath(bundleLoader),bundleName,bundleLoaderProductName);
    extraSettingsBuilder.put(""String_Node_Str"",bundleLoaderOutputPath).put(""String_Node_Str"",""String_Node_Str"");
  }
  if (infoPlistOptional.isPresent()) {
    Path infoPlistPath=pathRelativizer.outputDirToRootRelative(infoPlistOptional.get());
    extraSettingsBuilder.put(""String_Node_Str"",infoPlistPath.toString());
  }
  Optional<SourcePath> prefixHeaderOptional=targetNode.getConstructorArg().prefixHeader;
  if (prefixHeaderOptional.isPresent()) {
    Path prefixHeaderRelative=sourcePathResolver.apply(prefixHeaderOptional.get());
    Path prefixHeaderPath=pathRelativizer.outputDirToRootRelative(prefixHeaderRelative);
    extraSettingsBuilder.put(""String_Node_Str"",prefixHeaderPath.toString());
    extraSettingsBuilder.put(""String_Node_Str"",""String_Node_Str"");
  }
  extraSettingsBuilder.put(""String_Node_Str"",""String_Node_Str"");
  ImmutableMap.Builder<String,String> defaultSettingsBuilder=ImmutableMap.builder();
  defaultSettingsBuilder.put(""String_Node_Str"",projectFilesystem.getRootPath().toAbsolutePath().normalize().toString());
  defaultSettingsBuilder.put(""String_Node_Str"",getProductName(buildTarget));
  if (bundle.isPresent()) {
    defaultSettingsBuilder.put(""String_Node_Str"",getExtensionString(bundle.get().getConstructorArg().getExtension()));
  }
  defaultSettingsBuilder.put(""String_Node_Str"",Joiner.on('/').join(""String_Node_Str"",""String_Node_Str""));
  defaultSettingsBuilder.put(""String_Node_Str"",""String_Node_Str"");
  if (!bundle.isPresent() && (targetNode.getType().equals(AppleLibraryDescription.TYPE) || targetNode.getType().equals(CxxLibraryDescription.TYPE))) {
    defaultSettingsBuilder.put(""String_Node_Str"",""String_Node_Str"");
  }
  ImmutableMap.Builder<String,String> appendConfigsBuilder=ImmutableMap.builder();
  ImmutableSet<Path> recursiveHeaderMaps=collectRecursiveHeaderMaps(targetNode);
  ImmutableSet<Path> headerMapBases=recursiveHeaderMaps.isEmpty() ? ImmutableSet.<Path>of() : ImmutableSet.of(pathRelativizer.outputDirToRootRelative(BuckConstant.BUCK_OUTPUT_PATH));
  appendConfigsBuilder.put(""String_Node_Str"",Joiner.on(' ').join(Iterables.concat(recursiveHeaderMaps,headerMapBases))).put(""String_Node_Str"",Joiner.on(' ').join(collectRecursiveLibrarySearchPaths(ImmutableSet.of(targetNode)))).put(""String_Node_Str"",Joiner.on(' ').join(collectRecursiveFrameworkSearchPaths(ImmutableList.of(targetNode)))).put(""String_Node_Str"",Joiner.on(' ').join(Iterables.transform(Iterables.concat(targetNode.getConstructorArg().compilerFlags.get(),targetNode.getConstructorArg().preprocessorFlags.get(),collectRecursiveExportedPreprocessorFlags(ImmutableList.of(targetNode))),Escaper.BASH_ESCAPER))).put(""String_Node_Str"",Joiner.on(' ').join(Iterables.transform(MoreIterables.zipAndConcat(Iterables.cycle(""String_Node_Str""),Iterables.concat(targetNode.getConstructorArg().linkerFlags.get(),collectRecursiveExportedLinkerFlags(ImmutableList.of(targetNode)))),Escaper.BASH_ESCAPER)));
  ImmutableMap<CxxSource.Type,ImmutableList<String>> langPreprocessorFlags=targetNode.getConstructorArg().langPreprocessorFlags.get();
  Sets.SetView<CxxSource.Type> unsupportedLangPreprocessorFlags=Sets.difference(langPreprocessorFlags.keySet(),SUPPORTED_LANG_PREPROCESSOR_FLAG_TYPES);
  if (!unsupportedLangPreprocessorFlags.isEmpty()) {
    throw new HumanReadableException(""String_Node_Str"" + ""String_Node_Str"",buildTarget,unsupportedLangPreprocessorFlags);
  }
  ImmutableSet.Builder<String> allCxxFlagsBuilder=ImmutableSet.builder();
  ImmutableList<String> cxxFlags=langPreprocessorFlags.get(CxxSource.Type.CXX);
  if (cxxFlags != null) {
    allCxxFlagsBuilder.addAll(cxxFlags);
  }
  ImmutableList<String> objcxxFlags=langPreprocessorFlags.get(CxxSource.Type.OBJCXX);
  if (objcxxFlags != null) {
    allCxxFlagsBuilder.addAll(objcxxFlags);
  }
  ImmutableSet<String> allCxxFlags=allCxxFlagsBuilder.build();
  if (!allCxxFlags.isEmpty()) {
    appendConfigsBuilder.put(""String_Node_Str"",Joiner.on(' ').join(allCxxFlags));
  }
  Optional<ImmutableSortedMap<String,ImmutableMap<String,String>>> configs=Optional.absent();
  if (appleTargetNode.isPresent()) {
    configs=appleTargetNode.get().getConstructorArg().configs;
  }
 else   if (targetNode.getType().equals(CxxLibraryDescription.TYPE)) {
    ImmutableMap<String,String> appendedConfig=appendConfigsBuilder.build();
    ImmutableMap<String,ImmutableMap<String,String>> defaultConfig=CxxPlatformXcodeConfigGenerator.getDefaultXcodeBuildConfigurationsFromCxxPlatform(defaultCxxPlatform,appendedConfig);
    configs=Optional.of(ImmutableSortedMap.copyOf(defaultConfig));
  }
 else {
    throw new HumanReadableException(""String_Node_Str"",targetNode);
  }
  PBXNativeTarget target=targetBuilderResult.target;
  setTargetBuildConfigurations(getConfigurationNameToXcconfigPath(buildTarget),target,project.getMainGroup(),configs.get(),extraSettingsBuilder.build(),defaultSettingsBuilder.build(),appendConfigsBuilder.build());
  if (appleTargetNode.isPresent()) {
    Path headerPathPrefix=AppleDescriptions.getHeaderPathPrefix(appleTargetNode.get().getConstructorArg(),targetNode.getBuildTarget());
    createHeaderSymlinkTree(sourcePathResolver,AppleDescriptions.convertAppleHeadersToPublicCxxHeaders(sourcePathResolver,headerPathPrefix,arg),AppleDescriptions.getPathToHeaderSymlinkTree(appleTargetNode.get(),HeaderVisibility.PUBLIC));
    createHeaderSymlinkTree(sourcePathResolver,AppleDescriptions.convertAppleHeadersToPrivateCxxHeaders(sourcePathResolver,headerPathPrefix,arg),AppleDescriptions.getPathToHeaderSymlinkTree(appleTargetNode.get(),HeaderVisibility.PRIVATE));
    addCoreDataModelsIntoTarget(appleTargetNode.get(),targetGroup);
  }
  return target;
}","private PBXNativeTarget generateBinaryTarget(PBXProject project,Optional<? extends TargetNode<? extends HasAppleBundleFields>> bundle,TargetNode<? extends CxxLibraryDescription.Arg> targetNode,ProductType productType,String productOutputFormat,Optional<Path> infoPlistOptional,boolean includeFrameworks,ImmutableSet<AppleResourceDescription.Arg> recursiveResources,ImmutableSet<AppleResourceDescription.Arg> directResources,ImmutableSet<AppleAssetCatalogDescription.Arg> recursiveAssetCatalogs,ImmutableSet<AppleAssetCatalogDescription.Arg> directAssetCatalogs,Optional<Iterable<PBXBuildPhase>> copyFilesPhases,Optional<TargetNode<AppleBundleDescription.Arg>> bundleLoaderNode) throws IOException {
  LOG.debug(""String_Node_Str"",targetNode);
  TargetNode<?> buildTargetNode=bundle.isPresent() ? bundle.get() : targetNode;
  final BuildTarget buildTarget=buildTargetNode.getBuildTarget();
  String productName=getProductName(buildTarget);
  CxxLibraryDescription.Arg arg=targetNode.getConstructorArg();
  NewNativeTargetProjectMutator mutator=new NewNativeTargetProjectMutator(pathRelativizer,sourcePathResolver);
  ImmutableSet<SourcePath> exportedHeaders=ImmutableSet.copyOf(getHeaderSourcePaths(arg.exportedHeaders));
  ImmutableSet<SourcePath> headers=ImmutableSet.copyOf(getHeaderSourcePaths(arg.headers));
  mutator.setTargetName(getXcodeTargetName(buildTarget)).setProduct(productType,productName,Paths.get(String.format(productOutputFormat,productName))).setSourcesWithFlags(ImmutableSet.copyOf(arg.srcs.get())).setPublicHeaders(exportedHeaders).setPrivateHeaders(headers).setPrefixHeader(arg.prefixHeader).setRecursiveResources(recursiveResources).setDirectResources(directResources);
  Optional<TargetNode<AppleNativeTargetDescriptionArg>> appleTargetNode=targetNode.castArg(AppleNativeTargetDescriptionArg.class);
  if (appleTargetNode.isPresent()) {
    AppleNativeTargetDescriptionArg appleArg=appleTargetNode.get().getConstructorArg();
    mutator=mutator.setExtraXcodeSources(ImmutableSet.copyOf(appleArg.extraXcodeSources.get()));
  }
  if (options.contains(Option.CREATE_DIRECTORY_STRUCTURE)) {
    mutator.setTargetGroupPath(FluentIterable.from(buildTarget.getBasePath()).transform(Functions.toStringFunction()).toList());
  }
  if (!recursiveAssetCatalogs.isEmpty()) {
    mutator.setRecursiveAssetCatalogs(recursiveAssetCatalogs);
  }
  if (!directAssetCatalogs.isEmpty()) {
    mutator.setDirectAssetCatalogs(directAssetCatalogs);
  }
  if (includeFrameworks) {
    ImmutableSet.Builder<FrameworkPath> frameworksBuilder=ImmutableSet.builder();
    frameworksBuilder.addAll(targetNode.getConstructorArg().frameworks.get());
    frameworksBuilder.addAll(targetNode.getConstructorArg().libraries.get());
    frameworksBuilder.addAll(collectRecursiveFrameworkDependencies(ImmutableList.of(targetNode)));
    mutator.setFrameworks(frameworksBuilder.build());
    mutator.setArchives(collectRecursiveLibraryDependencies(ImmutableList.of(targetNode)));
  }
  ImmutableList.Builder<TargetNode<?>> preScriptPhases=ImmutableList.builder();
  ImmutableList.Builder<TargetNode<?>> postScriptPhases=ImmutableList.builder();
  boolean skipRNBundle=ReactNativeFlavors.skipBundling(buildTargetNode.getBuildTarget());
  if (bundle.isPresent() && targetNode != bundle.get()) {
    collectBuildScriptDependencies(targetGraph.getAll(bundle.get().getDeclaredDeps()),preScriptPhases,postScriptPhases,skipRNBundle);
  }
  collectBuildScriptDependencies(targetGraph.getAll(targetNode.getDeclaredDeps()),preScriptPhases,postScriptPhases,skipRNBundle);
  mutator.setPreBuildRunScriptPhases(preScriptPhases.build());
  if (copyFilesPhases.isPresent()) {
    mutator.setCopyFilesPhases(copyFilesPhases.get());
  }
  mutator.setPostBuildRunScriptPhases(postScriptPhases.build());
  mutator.skipReactNativeBundle(skipRNBundle);
  if (skipRNBundle && reactNativeServer.isPresent()) {
    mutator.setAdditionalRunScripts(ImmutableList.of(projectFilesystem.resolve(reactNativeServer.get())));
  }
  NewNativeTargetProjectMutator.Result targetBuilderResult;
  try {
    targetBuilderResult=mutator.buildTargetAndAddToProject(project);
  }
 catch (  NoSuchBuildTargetException e) {
    throw new HumanReadableException(e);
  }
  PBXGroup targetGroup=targetBuilderResult.targetGroup;
  SourceTreePath buckFilePath=new SourceTreePath(PBXReference.SourceTree.SOURCE_ROOT,pathRelativizer.outputPathToBuildTargetPath(buildTarget).resolve(buildFileName),Optional.<String>absent());
  PBXFileReference buckReference=targetGroup.getOrCreateFileReferenceBySourceTreePath(buckFilePath);
  buckReference.setExplicitFileType(Optional.of(""String_Node_Str""));
  ImmutableMap.Builder<String,String> extraSettingsBuilder=ImmutableMap.builder();
  extraSettingsBuilder.put(""String_Node_Str"",getProductName(buildTarget)).put(""String_Node_Str"",pathRelativizer.outputPathToBuildTargetPath(buildTarget).toString());
  if (bundleLoaderNode.isPresent()) {
    TargetNode<AppleBundleDescription.Arg> bundleLoader=bundleLoaderNode.get();
    String bundleLoaderProductName=getProductName(bundleLoader.getBuildTarget());
    String bundleName=bundleLoaderProductName + ""String_Node_Str"" + getExtensionString(bundleLoader.getConstructorArg().getExtension());
    String bundleLoaderOutputPath=Joiner.on('/').join(getTargetOutputPath(bundleLoader),bundleName,bundleLoaderProductName);
    extraSettingsBuilder.put(""String_Node_Str"",bundleLoaderOutputPath).put(""String_Node_Str"",""String_Node_Str"");
  }
  if (infoPlistOptional.isPresent()) {
    Path infoPlistPath=pathRelativizer.outputDirToRootRelative(infoPlistOptional.get());
    extraSettingsBuilder.put(""String_Node_Str"",infoPlistPath.toString());
  }
  Optional<SourcePath> prefixHeaderOptional=targetNode.getConstructorArg().prefixHeader;
  if (prefixHeaderOptional.isPresent()) {
    Path prefixHeaderRelative=sourcePathResolver.apply(prefixHeaderOptional.get());
    Path prefixHeaderPath=pathRelativizer.outputDirToRootRelative(prefixHeaderRelative);
    extraSettingsBuilder.put(""String_Node_Str"",prefixHeaderPath.toString());
    extraSettingsBuilder.put(""String_Node_Str"",""String_Node_Str"");
  }
  extraSettingsBuilder.put(""String_Node_Str"",""String_Node_Str"");
  ImmutableMap.Builder<String,String> defaultSettingsBuilder=ImmutableMap.builder();
  defaultSettingsBuilder.put(""String_Node_Str"",projectFilesystem.getRootPath().toAbsolutePath().normalize().toString());
  defaultSettingsBuilder.put(""String_Node_Str"",getProductName(buildTarget));
  if (bundle.isPresent()) {
    defaultSettingsBuilder.put(""String_Node_Str"",getExtensionString(bundle.get().getConstructorArg().getExtension()));
  }
  defaultSettingsBuilder.put(""String_Node_Str"",Joiner.on('/').join(""String_Node_Str"",""String_Node_Str""));
  defaultSettingsBuilder.put(""String_Node_Str"",""String_Node_Str"");
  if (!bundle.isPresent() && (targetNode.getType().equals(AppleLibraryDescription.TYPE) || targetNode.getType().equals(CxxLibraryDescription.TYPE))) {
    defaultSettingsBuilder.put(""String_Node_Str"",""String_Node_Str"");
  }
  ImmutableMap.Builder<String,String> appendConfigsBuilder=ImmutableMap.builder();
  ImmutableSet<Path> recursiveHeaderMaps=collectRecursiveHeaderMaps(targetNode);
  ImmutableSet<Path> headerMapBases=recursiveHeaderMaps.isEmpty() ? ImmutableSet.<Path>of() : ImmutableSet.of(pathRelativizer.outputDirToRootRelative(BuckConstant.BUCK_OUTPUT_PATH));
  appendConfigsBuilder.put(""String_Node_Str"",Joiner.on(' ').join(Iterables.concat(recursiveHeaderMaps,headerMapBases))).put(""String_Node_Str"",Joiner.on(' ').join(collectRecursiveLibrarySearchPaths(ImmutableSet.of(targetNode)))).put(""String_Node_Str"",Joiner.on(' ').join(collectRecursiveFrameworkSearchPaths(ImmutableList.of(targetNode)))).put(""String_Node_Str"",Joiner.on(' ').join(Iterables.transform(Iterables.concat(targetNode.getConstructorArg().compilerFlags.get(),targetNode.getConstructorArg().preprocessorFlags.get(),collectRecursiveExportedPreprocessorFlags(ImmutableList.of(targetNode))),Escaper.BASH_ESCAPER))).put(""String_Node_Str"",Joiner.on(' ').join(Iterables.transform(MoreIterables.zipAndConcat(Iterables.cycle(""String_Node_Str""),Iterables.concat(targetNode.getConstructorArg().linkerFlags.get(),collectRecursiveExportedLinkerFlags(ImmutableList.of(targetNode)))),Escaper.BASH_ESCAPER)));
  ImmutableMap<CxxSource.Type,ImmutableList<String>> langPreprocessorFlags=targetNode.getConstructorArg().langPreprocessorFlags.get();
  Sets.SetView<CxxSource.Type> unsupportedLangPreprocessorFlags=Sets.difference(langPreprocessorFlags.keySet(),SUPPORTED_LANG_PREPROCESSOR_FLAG_TYPES);
  if (!unsupportedLangPreprocessorFlags.isEmpty()) {
    throw new HumanReadableException(""String_Node_Str"" + ""String_Node_Str"",buildTarget,unsupportedLangPreprocessorFlags);
  }
  ImmutableSet.Builder<String> allCxxFlagsBuilder=ImmutableSet.builder();
  ImmutableList<String> cxxFlags=langPreprocessorFlags.get(CxxSource.Type.CXX);
  if (cxxFlags != null) {
    allCxxFlagsBuilder.addAll(cxxFlags);
  }
  ImmutableList<String> objcxxFlags=langPreprocessorFlags.get(CxxSource.Type.OBJCXX);
  if (objcxxFlags != null) {
    allCxxFlagsBuilder.addAll(objcxxFlags);
  }
  ImmutableSet<String> allCxxFlags=allCxxFlagsBuilder.build();
  if (!allCxxFlags.isEmpty()) {
    appendConfigsBuilder.put(""String_Node_Str"",Joiner.on(' ').join(allCxxFlags));
  }
  Optional<ImmutableSortedMap<String,ImmutableMap<String,String>>> configs=Optional.absent();
  if (appleTargetNode.isPresent()) {
    configs=appleTargetNode.get().getConstructorArg().configs;
  }
 else   if (targetNode.getType().equals(CxxLibraryDescription.TYPE)) {
    ImmutableMap<String,String> appendedConfig=appendConfigsBuilder.build();
    ImmutableMap<String,ImmutableMap<String,String>> defaultConfig=CxxPlatformXcodeConfigGenerator.getDefaultXcodeBuildConfigurationsFromCxxPlatform(defaultCxxPlatform,appendedConfig);
    configs=Optional.of(ImmutableSortedMap.copyOf(defaultConfig));
  }
 else {
    throw new HumanReadableException(""String_Node_Str"",targetNode);
  }
  PBXNativeTarget target=targetBuilderResult.target;
  setTargetBuildConfigurations(getConfigurationNameToXcconfigPath(buildTarget),target,project.getMainGroup(),configs.get(),extraSettingsBuilder.build(),defaultSettingsBuilder.build(),appendConfigsBuilder.build());
  Path headerPathPrefix=AppleDescriptions.getHeaderPathPrefix(arg,targetNode.getBuildTarget());
  createHeaderSymlinkTree(sourcePathResolver,AppleDescriptions.convertAppleHeadersToPublicCxxHeaders(sourcePathResolver,headerPathPrefix,arg),AppleDescriptions.getPathToHeaderSymlinkTree(targetNode,HeaderVisibility.PUBLIC));
  createHeaderSymlinkTree(sourcePathResolver,AppleDescriptions.convertAppleHeadersToPrivateCxxHeaders(sourcePathResolver,headerPathPrefix,arg),AppleDescriptions.getPathToHeaderSymlinkTree(targetNode,HeaderVisibility.PRIVATE));
  if (appleTargetNode.isPresent()) {
    addCoreDataModelsIntoTarget(appleTargetNode.get(),targetGroup);
  }
  return target;
}",0.9897772909821104
53163,"@Override public Optional<Function<String,Iterable<String>>> getExtraLineProcessor(){
  return Optional.<Function<String,Iterable<String>>>of(new Function<String,Iterable<String>>(){
    @Override public Iterable<String> apply(    String input){
      String remainder=input;
      ImmutableList.Builder<String> processedLines=ImmutableList.builder();
      while (!remainder.isEmpty()) {
        Matcher m=PRAGMA_TOKEN_PLACEHOLDER_PATTERN.matcher(remainder);
        if (!m.matches()) {
          processedLines.add(remainder);
          break;
        }
        processedLines.add(m.group(1));
        processedLines.add(""String_Node_Str"" + m.group(2).replaceAll(""String_Node_Str"",""String_Node_Str""));
        remainder=m.group(3);
      }
      return processedLines.build();
    }
  }
);
}","@Override public Optional<Function<String,Iterable<String>>> getExtraLineProcessor(){
  return Optional.<Function<String,Iterable<String>>>of(new Function<String,Iterable<String>>(){
    @Override public Iterable<String> apply(    String input){
      String remainder=input;
      ImmutableList.Builder<String> processedLines=ImmutableList.builder();
      if (remainder.isEmpty()) {
        processedLines.add(remainder);
      }
      while (!remainder.isEmpty()) {
        Matcher m=PRAGMA_TOKEN_PLACEHOLDER_PATTERN.matcher(remainder);
        if (!m.matches()) {
          processedLines.add(remainder);
          break;
        }
        processedLines.add(m.group(1));
        processedLines.add(""String_Node_Str"" + m.group(2).replaceAll(""String_Node_Str"",""String_Node_Str""));
        remainder=m.group(3);
      }
      return processedLines.build();
    }
  }
);
}",0.9519807923169268
53164,"@Override public Iterable<String> apply(String input){
  String remainder=input;
  ImmutableList.Builder<String> processedLines=ImmutableList.builder();
  while (!remainder.isEmpty()) {
    Matcher m=PRAGMA_TOKEN_PLACEHOLDER_PATTERN.matcher(remainder);
    if (!m.matches()) {
      processedLines.add(remainder);
      break;
    }
    processedLines.add(m.group(1));
    processedLines.add(""String_Node_Str"" + m.group(2).replaceAll(""String_Node_Str"",""String_Node_Str""));
    remainder=m.group(3);
  }
  return processedLines.build();
}","@Override public Iterable<String> apply(String input){
  String remainder=input;
  ImmutableList.Builder<String> processedLines=ImmutableList.builder();
  if (remainder.isEmpty()) {
    processedLines.add(remainder);
  }
  while (!remainder.isEmpty()) {
    Matcher m=PRAGMA_TOKEN_PLACEHOLDER_PATTERN.matcher(remainder);
    if (!m.matches()) {
      processedLines.add(remainder);
      break;
    }
    processedLines.add(m.group(1));
    processedLines.add(""String_Node_Str"" + m.group(2).replaceAll(""String_Node_Str"",""String_Node_Str""));
    remainder=m.group(3);
  }
  return processedLines.build();
}",0.9404553415061296
53165,"/** 
 * Evaluate multiple queries in a single `buck query` run. Usage: buck query <query format> <input1> <input2> <...> <inputN>
 */
static int runMultipleQuery(CommandRunnerParams params,BuckQueryEnvironment env,String queryFormat,List<String> inputsFormattedAsBuildTargets,boolean generateJsonOutput) throws IOException, InterruptedException {
  if (inputsFormattedAsBuildTargets.isEmpty()) {
    params.getConsole().printBuildFailure(""String_Node_Str"");
    return 1;
  }
  try {
    TreeMultimap<BuildTarget,BuildTarget> queryResultMap=TreeMultimap.create();
    for (    String input : inputsFormattedAsBuildTargets) {
      BuildTarget target=BuildTargetParser.INSTANCE.parse(input,BuildTargetPatternParser.fullyQualified());
      String query=queryFormat.replace(""String_Node_Str"",input);
      Set<BuildTarget> queryResult=env.evaluateQuery(query);
      queryResultMap.putAll(target,queryResult);
    }
    LOG.debug(""String_Node_Str"" + queryResultMap);
    if (generateJsonOutput) {
      CommandHelper.printJSON(params,queryResultMap);
    }
 else {
      CommandHelper.printToConsole(params,queryResultMap);
    }
  }
 catch (  QueryException e) {
    if (e.getCause() instanceof InterruptedException) {
      throw (InterruptedException)e.getCause();
    }
    params.getConsole().printBuildFailureWithoutStacktrace(e);
    return 1;
  }
  return 0;
}","/** 
 * Evaluate multiple queries in a single `buck query` run. Usage: buck query <query format> <input1> <input2> <...> <inputN>
 */
static int runMultipleQuery(CommandRunnerParams params,BuckQueryEnvironment env,String queryFormat,List<String> inputsFormattedAsBuildTargets,boolean generateJsonOutput) throws IOException, InterruptedException {
  if (inputsFormattedAsBuildTargets.isEmpty()) {
    params.getConsole().printBuildFailure(""String_Node_Str"");
    return 1;
  }
  try {
    TreeMultimap<String,BuildTarget> queryResultMap=TreeMultimap.create();
    for (    String input : inputsFormattedAsBuildTargets) {
      String query=queryFormat.replace(""String_Node_Str"",input);
      Set<BuildTarget> queryResult=env.evaluateQuery(query);
      queryResultMap.putAll(input,queryResult);
    }
    LOG.debug(""String_Node_Str"" + queryResultMap);
    if (generateJsonOutput) {
      CommandHelper.printJSON(params,queryResultMap);
    }
 else {
      CommandHelper.printToConsole(params,queryResultMap);
    }
  }
 catch (  QueryException e) {
    if (e.getCause() instanceof InterruptedException) {
      throw (InterruptedException)e.getCause();
    }
    params.getConsole().printBuildFailureWithoutStacktrace(e);
    return 1;
  }
  return 0;
}",0.9488158899923606
53166,"@Override public int runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {
  if (arguments.isEmpty()) {
    params.getConsole().printBuildFailure(""String_Node_Str"");
    return 1;
  }
  Set<QueryEnvironment.Setting> settings=new HashSet<>();
  BuckQueryEnvironment env=new BuckQueryEnvironment(params,settings,getEnableProfiling());
  String queryFormat=arguments.remove(0);
  if (queryFormat.contains(""String_Node_Str"")) {
    return runMultipleQuery(params,env,queryFormat,getArgumentsFormattedAsBuildTargets(params.getBuckConfig()),shouldGenerateJsonOutput());
  }
 else {
    return runSingleQuery(params,env,queryFormat);
  }
}","@Override public int runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {
  if (arguments.isEmpty()) {
    params.getConsole().printBuildFailure(""String_Node_Str"");
    return 1;
  }
  Set<QueryEnvironment.Setting> settings=new HashSet<>();
  BuckQueryEnvironment env=new BuckQueryEnvironment(params,settings,getEnableProfiling());
  String queryFormat=arguments.remove(0);
  if (queryFormat.contains(""String_Node_Str"")) {
    return runMultipleQuery(params,env,queryFormat,arguments,shouldGenerateJsonOutput());
  }
 else {
    return runSingleQuery(params,env,queryFormat);
  }
}",0.94679186228482
53167,"/** 
 * If   {@code isKeepGoing} is false, then this returns a future that succeeds only if all of{@code rulesToBuild} build successfully. Otherwise, this returns a future that should alwayssucceed, even if individual rules fail to build. In that case, a failed build rule is indicated by a  {@code null} value in the corresponding position in the iteration order of{@code rulesToBuild}.
 * @param targetish The targets to build. All targets in this iterable must be unique.
 */
@SuppressWarnings(""String_Node_Str"") public LinkedHashMap<BuildRule,Optional<BuildResult>> executeBuild(Iterable<? extends HasBuildTarget> targetish,boolean isKeepGoing) throws IOException, StepFailedException, ExecutionException, InterruptedException {
  buildContext=ImmutableBuildContext.builder().setActionGraph(actionGraph).setStepRunner(stepRunner).setProjectFilesystem(executionContext.getProjectFilesystem()).setClock(clock).setArtifactCache(artifactCache).setJavaPackageFinder(javaPackageFinder).setEventBus(executionContext.getBuckEventBus()).setAndroidBootclasspathSupplier(BuildContext.createBootclasspathSupplier(executionContext.getAndroidPlatformTargetSupplier())).setBuildId(executionContext.getBuildId()).putAllEnvironment(executionContext.getEnvironment()).build();
  ImmutableSet<BuildTarget> targetsToBuild=FluentIterable.from(targetish).transform(HasBuildTarget.TO_TARGET).toSet();
  ImmutableList<BuildRule> rulesToBuild=ImmutableList.copyOf(FluentIterable.from(targetsToBuild).transform(new Function<HasBuildTarget,BuildRule>(){
    @Override public BuildRule apply(    HasBuildTarget hasBuildTarget){
      return Preconditions.checkNotNull(actionGraph.findBuildRuleByTarget(hasBuildTarget.getBuildTarget()));
    }
  }
).toSet());
  int numRules=getNumRulesToBuild(targetsToBuild,actionGraph);
  getExecutionContext().getBuckEventBus().post(BuildEvent.ruleCountCalculated(targetsToBuild,numRules));
  final BuildContext currentBuildContext=buildContext;
  List<ListenableFuture<BuildResult>> futures=FluentIterable.from(rulesToBuild).transform(new Function<BuildRule,ListenableFuture<BuildResult>>(){
    @Override public ListenableFuture<BuildResult> apply(    BuildRule rule){
      return buildEngine.build(currentBuildContext,rule);
    }
  }
).toList();
  ListenableFuture<List<BuildResult>> buildFuture;
  if (isKeepGoing) {
    buildFuture=Futures.successfulAsList(futures);
  }
 else {
    buildFuture=Futures.allAsList(futures);
  }
  List<BuildResult> results;
  try {
    results=buildFuture.get();
  }
 catch (  InterruptedException e) {
    try {
      buildFuture.cancel(true);
    }
 catch (    CancellationException ignored) {
    }
    Thread.currentThread().interrupt();
    throw e;
  }
  LinkedHashMap<BuildRule,Optional<BuildResult>> resultBuilder=new LinkedHashMap<>();
  Preconditions.checkState(rulesToBuild.size() == results.size());
  for (int i=0, len=rulesToBuild.size(); i < len; i++) {
    BuildRule rule=rulesToBuild.get(i);
    resultBuilder.put(rule,Optional.fromNullable(results.get(i)));
  }
  return resultBuilder;
}","/** 
 * If   {@code isKeepGoing} is false, then this returns a future that succeeds only if all of{@code rulesToBuild} build successfully. Otherwise, this returns a future that should alwayssucceed, even if individual rules fail to build. In that case, a failed build rule is indicated by a  {@code null} value in the corresponding position in the iteration order of{@code rulesToBuild}.
 * @param targetish The targets to build. All targets in this iterable must be unique.
 */
@SuppressWarnings(""String_Node_Str"") public LinkedHashMap<BuildRule,Optional<BuildResult>> executeBuild(Iterable<? extends HasBuildTarget> targetish,boolean isKeepGoing) throws IOException, StepFailedException, ExecutionException, InterruptedException {
  buildContext=ImmutableBuildContext.builder().setActionGraph(actionGraph).setStepRunner(stepRunner).setProjectFilesystem(executionContext.getProjectFilesystem()).setClock(clock).setArtifactCache(artifactCache).setJavaPackageFinder(javaPackageFinder).setEventBus(executionContext.getBuckEventBus()).setAndroidBootclasspathSupplier(BuildContext.createBootclasspathSupplier(executionContext.getAndroidPlatformTargetSupplier())).setBuildId(executionContext.getBuildId()).putAllEnvironment(executionContext.getEnvironment()).setKeepGoing(isKeepGoing).build();
  ImmutableSet<BuildTarget> targetsToBuild=FluentIterable.from(targetish).transform(HasBuildTarget.TO_TARGET).toSet();
  ImmutableList<BuildRule> rulesToBuild=ImmutableList.copyOf(FluentIterable.from(targetsToBuild).transform(new Function<HasBuildTarget,BuildRule>(){
    @Override public BuildRule apply(    HasBuildTarget hasBuildTarget){
      return Preconditions.checkNotNull(actionGraph.findBuildRuleByTarget(hasBuildTarget.getBuildTarget()));
    }
  }
).toSet());
  int numRules=getNumRulesToBuild(targetsToBuild,actionGraph);
  getExecutionContext().getBuckEventBus().post(BuildEvent.ruleCountCalculated(targetsToBuild,numRules));
  final BuildContext currentBuildContext=buildContext;
  List<ListenableFuture<BuildResult>> futures=FluentIterable.from(rulesToBuild).transform(new Function<BuildRule,ListenableFuture<BuildResult>>(){
    @Override public ListenableFuture<BuildResult> apply(    BuildRule rule){
      return buildEngine.build(currentBuildContext,rule);
    }
  }
).toList();
  ListenableFuture<List<BuildResult>> buildFuture=Futures.allAsList(futures);
  List<BuildResult> results;
  try {
    results=buildFuture.get();
    if (!isKeepGoing) {
      for (      BuildResult result : results) {
        Throwable thrown=result.getFailure();
        if (thrown != null) {
          throw new ExecutionException(thrown);
        }
      }
    }
  }
 catch (  InterruptedException e) {
    try {
      buildFuture.cancel(true);
    }
 catch (    CancellationException ignored) {
    }
    Thread.currentThread().interrupt();
    throw e;
  }
  LinkedHashMap<BuildRule,Optional<BuildResult>> resultBuilder=new LinkedHashMap<>();
  Preconditions.checkState(rulesToBuild.size() == results.size());
  for (int i=0, len=rulesToBuild.size(); i < len; i++) {
    BuildRule rule=rulesToBuild.get(i);
    resultBuilder.put(rule,Optional.fromNullable(results.get(i)));
  }
  return resultBuilder;
}",0.9226095299008634
53168,"@Subscribe public void incrementNumRulesCompleted(@SuppressWarnings(""String_Node_Str"") BuildRuleEvent.Finished finished){
  numRulesCompleted.getAndIncrement();
}","@Subscribe public void incrementNumRulesCompleted(BuildRuleEvent.Finished finished){
  if (finished.getStatus() != BuildRuleStatus.CANCELED) {
    numRulesCompleted.getAndIncrement();
  }
}",0.7122507122507122
53169,"@Subscribe public void buildRuleFinished(BuildRuleEvent.Finished finished){
  String line=String.format(""String_Node_Str"",finished.getBuildRule().getFullyQualifiedName());
  if (ruleCount.isPresent()) {
    line+=String.format(""String_Node_Str"",numRulesCompleted.get(),ruleCount.get());
  }
  console.getStdErr().println(line);
}","@Subscribe public void buildRuleFinished(BuildRuleEvent.Finished finished){
  if (finished.getStatus() == BuildRuleStatus.SUCCESS) {
    String line=String.format(""String_Node_Str"",finished.getBuildRule().getFullyQualifiedName());
    if (ruleCount.isPresent()) {
      line+=String.format(""String_Node_Str"",numRulesCompleted.get(),ruleCount.get());
    }
    console.getStdErr().println(line);
  }
}",0.9026063100137174
53170,"@Subscribe public void buildRuleFinished(BuildRuleEvent.Finished finished){
  threadsToRunningBuildRuleEvent.put(finished.getThreadId(),Optional.<BuildRuleEvent>absent());
  accumulatedRuleTime.remove(finished.getBuildRule().getBuildTarget());
  CacheResult cacheResult=finished.getCacheResult();
  if (cacheResult.getType() != CacheResult.Type.LOCAL_KEY_UNCHANGED_HIT) {
    updated.incrementAndGet();
    if (cacheResult.getType() == CacheResult.Type.HIT) {
      cacheHits.incrementAndGet();
    }
 else     if (cacheResult.getType() == CacheResult.Type.ERROR) {
      cacheErrors.incrementAndGet();
    }
  }
}","@Subscribe public void buildRuleFinished(BuildRuleEvent.Finished finished){
  threadsToRunningBuildRuleEvent.put(finished.getThreadId(),Optional.<BuildRuleEvent>absent());
  accumulatedRuleTime.remove(finished.getBuildRule().getBuildTarget());
  if (finished.getStatus() == BuildRuleStatus.SUCCESS) {
    CacheResult cacheResult=finished.getCacheResult();
    if (cacheResult.getType() != CacheResult.Type.LOCAL_KEY_UNCHANGED_HIT) {
      updated.incrementAndGet();
      if (cacheResult.getType() == CacheResult.Type.HIT) {
        cacheHits.incrementAndGet();
      }
 else       if (cacheResult.getType() == CacheResult.Type.ERROR) {
        cacheErrors.incrementAndGet();
      }
    }
  }
}",0.9381207028265852
53171,"/** 
 * Note: This should only be used inside   {@link CachingBuildEngine} and unit tests.
 */
public BuildResult(BuildRule rule,Throwable failure){
  this.rule=rule;
  this.status=BuildRuleStatus.FAIL;
  this.cacheResult=CacheResult.miss();
  this.success=null;
  this.failure=failure;
}","private BuildResult(BuildRule rule,BuildRuleStatus status,CacheResult cacheResult,@Nullable BuildRuleSuccessType success,@Nullable Throwable failure){
  this.rule=rule;
  this.status=status;
  this.cacheResult=cacheResult;
  this.success=success;
  this.failure=failure;
}",0.2964285714285714
53172,"@Nullable Throwable getFailure(){
  return failure;
}","@Nullable public Throwable getFailure(){
  return failure;
}",0.9380530973451328
53173,"@Override protected ImmutableList<String> getShellCommandInternal(ExecutionContext context){
  ImmutableList.Builder<String> commandBuilder=ImmutableList.builder();
  commandBuilder.addAll(command);
  commandBuilder.add(""String_Node_Str"" + context.getProjectFilesystem().getRootPath().toString() + ""String_Node_Str"",""String_Node_Str"",context.getProjectFilesystem().resolve(output).toString(),context.getProjectFilesystem().resolve(input).toString());
  return commandBuilder.build();
}","@Override protected ImmutableList<String> getShellCommandInternal(ExecutionContext context){
  ImmutableList.Builder<String> commandBuilder=ImmutableList.builder();
  commandBuilder.addAll(command);
  commandBuilder.add(""String_Node_Str"",context.getProjectFilesystem().resolve(output).toString(),context.getProjectFilesystem().resolve(input).toString());
  return commandBuilder.build();
}",0.7986270022883295
53174,"static void relativizeOsoSymbols(FileChannel file,Path linkingDirectory) throws IOException, MachoException {
  Preconditions.checkState(linkingDirectory.isAbsolute());
  long size=file.size();
  MappedByteBuffer map=file.map(FileChannel.MapMode.READ_WRITE,0,size);
  MachoHeader header=getHeader(map);
  int symbolTableOffset=0;
  int symbolTableCount=0;
  int stringTableOffset=0;
  int stringTableSizePosition=0;
  int stringTableSize=0;
  boolean symbolTableSegmentFound=false;
  int segmentSizePosition=0;
  int segmentSize=0;
  int commandsCount=header.getCommandsCount();
  for (int i=0; i < commandsCount; i++) {
    int commandStart=map.position();
    int command=ObjectFileScrubbers.getLittleEndianInt(map);
    int commandSize=ObjectFileScrubbers.getLittleEndianInt(map);
switch (command) {
case LC_SYMTAB:
      symbolTableOffset=ObjectFileScrubbers.getLittleEndianInt(map);
    symbolTableCount=ObjectFileScrubbers.getLittleEndianInt(map);
  stringTableOffset=ObjectFileScrubbers.getLittleEndianInt(map);
stringTableSizePosition=map.position();
stringTableSize=ObjectFileScrubbers.getLittleEndianInt(map);
symbolTableSegmentFound=true;
break;
case LC_SEGMENT:
ObjectFileScrubbers.getBytes(map,16);
ObjectFileScrubbers.getLittleEndianInt(map);
ObjectFileScrubbers.getLittleEndianInt(map);
int segmentFileOffset=ObjectFileScrubbers.getLittleEndianInt(map);
int segmentFileSizePosition=map.position();
int segmentFileSize=ObjectFileScrubbers.getLittleEndianInt(map);
ObjectFileScrubbers.getLittleEndianInt(map);
ObjectFileScrubbers.getLittleEndianInt(map);
ObjectFileScrubbers.getLittleEndianInt(map);
ObjectFileScrubbers.getLittleEndianInt(map);
if (segmentFileOffset + segmentFileSize == size) {
if (segmentSizePosition != 0) {
throw new MachoException(""String_Node_Str"");
}
segmentSizePosition=segmentFileSizePosition;
segmentSize=segmentFileSize;
}
break;
case LC_SEGMENT_64:
ObjectFileScrubbers.getBytes(map,16);
ObjectFileScrubbers.getLittleEndianLong(map);
ObjectFileScrubbers.getLittleEndianLong(map);
long segment64FileOffset=ObjectFileScrubbers.getLittleEndianLong(map);
int segment64FileSizePosition=map.position();
long segment64FileSize=ObjectFileScrubbers.getLittleEndianLong(map);
ObjectFileScrubbers.getLittleEndianInt(map);
ObjectFileScrubbers.getLittleEndianInt(map);
ObjectFileScrubbers.getLittleEndianInt(map);
ObjectFileScrubbers.getLittleEndianInt(map);
if (segment64FileOffset + segment64FileSize == size) {
if (segmentSizePosition != 0) {
throw new MachoException(""String_Node_Str"");
}
segmentSizePosition=segment64FileSizePosition;
if (segment64FileSize > Ints.MAX_POWER_OF_TWO) {
throw new MachoException(""String_Node_Str"");
}
segmentSize=(int)segment64FileSize;
}
break;
}
map.position(commandStart + commandSize);
}
if (!symbolTableSegmentFound) {
throw new MachoException(""String_Node_Str"");
}
if (stringTableOffset + stringTableSize != size) {
throw new MachoException(""String_Node_Str"");
}
if (stringTableSize == 0) {
return;
}
if (segmentSizePosition == 0 || segmentSize == 0) {
throw new MachoException(""String_Node_Str"");
}
map.position(stringTableOffset);
if (map.get() != 0x20) {
throw new MachoException(""String_Node_Str"");
}
if (map.get() != 0x00) {
throw new MachoException(""String_Node_Str"");
}
int currentStringTableOffset=map.position();
byte[] stringTableBytes=new byte[stringTableSize];
map.position(stringTableOffset);
map.get(stringTableBytes);
ByteBuffer stringTable=ByteBuffer.wrap(stringTableBytes);
map.position(symbolTableOffset);
Map<Integer,Integer> strings=new HashMap<>();
String prefix=linkingDirectory.toString() + ""String_Node_Str"";
for (int i=0; i < symbolTableCount; i++) {
int stringTableIndexPosition=map.position();
int stringTableIndex=ObjectFileScrubbers.getLittleEndianInt(map);
byte type=map.get();
map.get();
ObjectFileScrubbers.getLittleEndianShort(map);
int valuePosition=map.position();
if (header.getIs64Bit()) {
ObjectFileScrubbers.getLittleEndianLong(map);
}
 else {
ObjectFileScrubbers.getLittleEndianInt(map);
}
if (stringTableIndex < 2) {
continue;
}
int position=map.position();
try {
int newStringTableIndex;
if (strings.containsKey(stringTableIndex)) {
newStringTableIndex=strings.get(stringTableIndex);
}
 else {
stringTable.position(stringTableIndex);
String string=ObjectFileScrubbers.getAsciiString(stringTable);
if (type == N_OSO) {
string=MoreStrings.stripPrefix(string,prefix).or(string);
map.position(valuePosition);
if (header.getIs64Bit()) {
ObjectFileScrubbers.putLittleEndianLong(map,Ints.MAX_POWER_OF_TWO);
}
 else {
ObjectFileScrubbers.putLittleEndianInt(map,Ints.MAX_POWER_OF_TWO);
}
}
map.position(currentStringTableOffset);
ObjectFileScrubbers.putAsciiString(map,string);
newStringTableIndex=currentStringTableOffset - stringTableOffset;
currentStringTableOffset=map.position();
strings.put(stringTableIndex,newStringTableIndex);
}
map.position(stringTableIndexPosition);
ObjectFileScrubbers.putLittleEndianInt(map,newStringTableIndex);
}
  finally {
map.position(position);
}
}
map.position(stringTableSizePosition);
int newStringTableSize=currentStringTableOffset - stringTableOffset;
ObjectFileScrubbers.putLittleEndianInt(map,newStringTableSize);
map.position(segmentSizePosition);
ObjectFileScrubbers.putLittleEndianInt(map,segmentSize + (newStringTableSize - stringTableSize));
file.truncate(currentStringTableOffset);
}","static void relativizeOsoSymbols(FileChannel file,Path linkingDirectory) throws IOException, MachoException {
  Preconditions.checkState(linkingDirectory.isAbsolute());
  long size=file.size();
  MappedByteBuffer map=file.map(FileChannel.MapMode.READ_WRITE,0,size);
  MachoHeader header=getHeader(map);
  int symbolTableOffset=0;
  int symbolTableCount=0;
  int stringTableOffset=0;
  int stringTableSizePosition=0;
  int stringTableSize=0;
  boolean symbolTableSegmentFound=false;
  int segmentSizePosition=0;
  int segmentSize=0;
  int commandsCount=header.getCommandsCount();
  for (int i=0; i < commandsCount; i++) {
    int commandStart=map.position();
    int command=ObjectFileScrubbers.getLittleEndianInt(map);
    int commandSize=ObjectFileScrubbers.getLittleEndianInt(map);
switch (command) {
case LC_SYMTAB:
      symbolTableOffset=ObjectFileScrubbers.getLittleEndianInt(map);
    symbolTableCount=ObjectFileScrubbers.getLittleEndianInt(map);
  stringTableOffset=ObjectFileScrubbers.getLittleEndianInt(map);
stringTableSizePosition=map.position();
stringTableSize=ObjectFileScrubbers.getLittleEndianInt(map);
symbolTableSegmentFound=true;
break;
case LC_SEGMENT:
ObjectFileScrubbers.getBytes(map,16);
ObjectFileScrubbers.getLittleEndianInt(map);
ObjectFileScrubbers.getLittleEndianInt(map);
int segmentFileOffset=ObjectFileScrubbers.getLittleEndianInt(map);
int segmentFileSizePosition=map.position();
int segmentFileSize=ObjectFileScrubbers.getLittleEndianInt(map);
ObjectFileScrubbers.getLittleEndianInt(map);
ObjectFileScrubbers.getLittleEndianInt(map);
ObjectFileScrubbers.getLittleEndianInt(map);
ObjectFileScrubbers.getLittleEndianInt(map);
if (segmentFileOffset + segmentFileSize == size) {
if (segmentSizePosition != 0) {
throw new MachoException(""String_Node_Str"");
}
segmentSizePosition=segmentFileSizePosition;
segmentSize=segmentFileSize;
}
break;
case LC_SEGMENT_64:
ObjectFileScrubbers.getBytes(map,16);
ObjectFileScrubbers.getLittleEndianLong(map);
ObjectFileScrubbers.getLittleEndianLong(map);
long segment64FileOffset=ObjectFileScrubbers.getLittleEndianLong(map);
int segment64FileSizePosition=map.position();
long segment64FileSize=ObjectFileScrubbers.getLittleEndianLong(map);
ObjectFileScrubbers.getLittleEndianInt(map);
ObjectFileScrubbers.getLittleEndianInt(map);
ObjectFileScrubbers.getLittleEndianInt(map);
ObjectFileScrubbers.getLittleEndianInt(map);
if (segment64FileOffset + segment64FileSize == size) {
if (segmentSizePosition != 0) {
throw new MachoException(""String_Node_Str"");
}
segmentSizePosition=segment64FileSizePosition;
if (segment64FileSize > Ints.MAX_POWER_OF_TWO) {
throw new MachoException(""String_Node_Str"");
}
segmentSize=(int)segment64FileSize;
}
break;
}
map.position(commandStart + commandSize);
}
if (!symbolTableSegmentFound) {
throw new MachoException(""String_Node_Str"");
}
if (stringTableOffset + stringTableSize != size) {
throw new MachoException(""String_Node_Str"");
}
if (stringTableSize == 0) {
return;
}
if (segmentSizePosition == 0 || segmentSize == 0) {
throw new MachoException(""String_Node_Str"");
}
map.position(stringTableOffset);
if (map.get() != 0x20) {
throw new MachoException(""String_Node_Str"");
}
if (map.get() != 0x00) {
throw new MachoException(""String_Node_Str"");
}
int currentStringTableOffset=map.position();
byte[] stringTableBytes=new byte[stringTableSize];
map.position(stringTableOffset);
map.get(stringTableBytes);
ByteBuffer stringTable=ByteBuffer.wrap(stringTableBytes);
map.position(symbolTableOffset);
Map<Integer,Integer> strings=new HashMap<>();
String prefix=linkingDirectory.toString() + ""String_Node_Str"";
for (int i=0; i < symbolTableCount; i++) {
int stringTableIndexPosition=map.position();
int stringTableIndex=ObjectFileScrubbers.getLittleEndianInt(map);
byte type=map.get();
map.get();
ObjectFileScrubbers.getLittleEndianShort(map);
int valuePosition=map.position();
if (header.getIs64Bit()) {
ObjectFileScrubbers.getLittleEndianLong(map);
}
 else {
ObjectFileScrubbers.getLittleEndianInt(map);
}
if (stringTableIndex < 2) {
continue;
}
int position=map.position();
try {
int newStringTableIndex;
if (strings.containsKey(stringTableIndex)) {
newStringTableIndex=strings.get(stringTableIndex);
}
 else {
stringTable.position(stringTableIndex);
String string=ObjectFileScrubbers.getAsciiString(stringTable);
if (type == N_OSO) {
string=MoreStrings.stripPrefix(string,prefix).transform(new Function<String,String>(){
@Override public String apply(String input){
return ""String_Node_Str"" + input;
}
}
).or(string);
map.position(valuePosition);
if (header.getIs64Bit()) {
ObjectFileScrubbers.putLittleEndianLong(map,0);
}
 else {
ObjectFileScrubbers.putLittleEndianInt(map,0);
}
}
map.position(currentStringTableOffset);
ObjectFileScrubbers.putAsciiString(map,string);
newStringTableIndex=currentStringTableOffset - stringTableOffset;
currentStringTableOffset=map.position();
strings.put(stringTableIndex,newStringTableIndex);
}
map.position(stringTableIndexPosition);
ObjectFileScrubbers.putLittleEndianInt(map,newStringTableIndex);
}
  finally {
map.position(position);
}
}
map.position(stringTableSizePosition);
int newStringTableSize=currentStringTableOffset - stringTableOffset;
ObjectFileScrubbers.putLittleEndianInt(map,newStringTableSize);
map.position(segmentSizePosition);
ObjectFileScrubbers.putLittleEndianInt(map,segmentSize + (newStringTableSize - stringTableSize));
file.truncate(currentStringTableOffset);
}",0.9752650176678446
53175,"/** 
 * Finds the build file responsible for the given   {@link Path} and invalidatesall of the cached rules dependent on it.
 * @param path A {@link Path}, relative to the project root and ""contained"" within the build file to find and invalidate.
 */
private synchronized void invalidateContainingBuildFile(Path path) throws IOException {
  Optional<Path> packageBuildFile=buildFileTreeCache.get().getBasePathOfAncestorTarget(path);
  if (!packageBuildFile.isPresent()) {
    return;
  }
  state.invalidateDependents(repository.getFilesystem().getPathForRelativePath(packageBuildFile.get().resolve(new ParserConfig(repository.getBuckConfig()).getBuildFileName())));
}","/** 
 * Finds the build file responsible for the given   {@link Path} and invalidatesall of the cached rules dependent on it.
 * @param path A {@link Path}, relative to the project root and ""contained"" within the build file to find and invalidate.
 */
private synchronized void invalidateContainingBuildFile(Path path) throws IOException {
  List<Path> packageBuildFiles=Lists.newArrayList();
  Optional<Path> packageBuildFile=buildFileTreeCache.get().getBasePathOfAncestorTarget(path);
  packageBuildFiles.addAll(packageBuildFile.asSet());
  if (!enforceBuckPackageBoundary) {
    while (packageBuildFile.isPresent() && packageBuildFile.get().getParent() != null) {
      packageBuildFile=buildFileTreeCache.get().getBasePathOfAncestorTarget(packageBuildFile.get().getParent());
      packageBuildFiles.addAll(packageBuildFile.asSet());
    }
  }
  for (  Path buildFile : packageBuildFiles) {
    state.invalidateDependents(repository.getFilesystem().getPathForRelativePath(buildFile.resolve(new ParserConfig(repository.getBuckConfig()).getBuildFileName())));
  }
}",0.7054755043227666
53176,"@Override public Optional<Linker.LinkableDepType> getPreferredLinkage(CxxPlatform cxxPlatform){
  if (linkage == Linkage.STATIC) {
    return Optional.of(Linker.LinkableDepType.STATIC);
  }
  return Optional.absent();
}","@Override public NativeLinkable.Linkage getPreferredLinkage(CxxPlatform cxxPlatform){
  return linkage;
}",0.5493827160493827
53177,Optional<Linker.LinkableDepType> getPreferredLinkage(CxxPlatform cxxPlatform);,Linkage getPreferredLinkage(CxxPlatform cxxPlatform);,0.7938931297709924
53178,"private static NativeLinkableNode processBuildRule(CxxPlatform cxxPlatform,Map<BuildTarget,Linker.LinkableDepType> wanted,BuildRule rule,Linker.LinkableDepType type,NativeLinkableNode.Pass pass){
  if (!(rule instanceof NativeLinkable)) {
    return NativeLinkableNode.of(rule,pass);
  }
  NativeLinkable linkable=(NativeLinkable)rule;
  Linker.LinkableDepType depType=linkable.getPreferredLinkage(cxxPlatform).or(type);
  if (pass == AbstractNativeLinkableNode.Pass.ANY || depType == Linker.LinkableDepType.SHARED) {
    Linker.LinkableDepType oldType=wanted.put(rule.getBuildTarget(),depType);
    Preconditions.checkState(oldType == null || oldType == depType);
  }
  if (depType == Linker.LinkableDepType.SHARED) {
    pass=AbstractNativeLinkableNode.Pass.SHARED_ONLY;
  }
  return NativeLinkableNode.of(rule,pass);
}","private static NativeLinkableNode processBuildRule(CxxPlatform cxxPlatform,Map<BuildTarget,Linker.LinkableDepType> wanted,BuildRule rule,Linker.LinkableDepType type,NativeLinkableNode.Pass pass){
  if (!(rule instanceof NativeLinkable)) {
    return NativeLinkableNode.of(rule,pass);
  }
  NativeLinkable linkable=(NativeLinkable)rule;
  NativeLinkable.Linkage depLinkage=linkable.getPreferredLinkage(cxxPlatform);
  Linker.LinkableDepType depType;
switch (depLinkage) {
case STATIC:
{
      depType=type == Linker.LinkableDepType.STATIC ? Linker.LinkableDepType.STATIC : Linker.LinkableDepType.STATIC_PIC;
      break;
    }
case ANY:
{
    depType=type;
    break;
  }
default :
{
  throw new IllegalStateException();
}
}
if (pass == AbstractNativeLinkableNode.Pass.ANY || depType == Linker.LinkableDepType.SHARED) {
Linker.LinkableDepType oldType=wanted.put(rule.getBuildTarget(),depType);
Preconditions.checkState(oldType == null || oldType == depType);
}
if (depType == Linker.LinkableDepType.SHARED) {
pass=AbstractNativeLinkableNode.Pass.SHARED_ONLY;
}
return NativeLinkableNode.of(rule,pass);
}",0.7893915756630265
53179,"@Override public Optional<Linker.LinkableDepType> getPreferredLinkage(CxxPlatform cxxPlatform){
  return Optional.absent();
}","@Override public NativeLinkable.Linkage getPreferredLinkage(CxxPlatform cxxPlatform){
  return Linkage.ANY;
}",0.7863247863247863
53180,"@Override public Optional<Linker.LinkableDepType> getPreferredLinkage(CxxPlatform cxxPlatform){
  return Optional.absent();
}","@Override public NativeLinkable.Linkage getPreferredLinkage(CxxPlatform cxxPlatform){
  return Linkage.ANY;
}",0.7863247863247863
53181,"@Override public Optional<Linker.LinkableDepType> getPreferredLinkage(CxxPlatform cxxPlatform){
  return Optional.absent();
}","@Override public NativeLinkable.Linkage getPreferredLinkage(CxxPlatform cxxPlatform){
  return Linkage.ANY;
}",0.7863247863247863
53182,"@Override public Optional<Linker.LinkableDepType> getPreferredLinkage(CxxPlatform cxxPlatform){
  return Optional.absent();
}","@Override public NativeLinkable.Linkage getPreferredLinkage(CxxPlatform cxxPlatform){
  return Linkage.ANY;
}",0.7863247863247863
53183,"@Test @SuppressWarnings(""String_Node_Str"") public void createBuildRule(){
  ProjectFilesystem projectFilesystem=new FakeProjectFilesystem();
  BuildRuleResolver resolver=new BuildRuleResolver();
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  CxxPlatform cxxPlatform=CxxBinaryBuilder.createDefaultPlatform();
  String genHeaderName=""String_Node_Str"";
  BuildTarget genHeaderTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  Genrule genHeader=(Genrule)GenruleBuilder.newGenruleBuilder(genHeaderTarget).setOut(genHeaderName).build(resolver);
  String genSourceName=""String_Node_Str"";
  BuildTarget genSourceTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  Genrule genSource=(Genrule)GenruleBuilder.newGenruleBuilder(genSourceTarget).setOut(genSourceName).build(resolver);
  final BuildRule header=createFakeBuildRule(""String_Node_Str"",pathResolver);
  final BuildRule headerSymlinkTree=createFakeBuildRule(""String_Node_Str"",pathResolver);
  final Path headerSymlinkTreeRoot=Paths.get(""String_Node_Str"");
  final BuildRule archive=createFakeBuildRule(""String_Node_Str"",pathResolver);
  final Path archiveOutput=Paths.get(""String_Node_Str"");
  BuildTarget depTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  BuildRuleParams depParams=BuildRuleParamsFactory.createTrivialBuildRuleParams(depTarget);
  AbstractCxxLibrary dep=new AbstractCxxLibrary(depParams,pathResolver){
    @Override public CxxPreprocessorInput getCxxPreprocessorInput(    CxxPlatform cxxPlatform,    HeaderVisibility headerVisibility){
      return CxxPreprocessorInput.builder().addRules(header.getBuildTarget(),headerSymlinkTree.getBuildTarget()).addIncludeRoots(headerSymlinkTreeRoot).build();
    }
    @Override public ImmutableMap<BuildTarget,CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(    CxxPlatform cxxPlatform,    HeaderVisibility headerVisibility){
      return ImmutableMap.of(getBuildTarget(),getCxxPreprocessorInput(cxxPlatform,headerVisibility));
    }
    @Override public NativeLinkableInput getNativeLinkableInput(    CxxPlatform cxxPlatform,    Linker.LinkableDepType type){
      return NativeLinkableInput.of(ImmutableList.<SourcePath>of(new BuildTargetSourcePath(archive.getBuildTarget())),ImmutableList.of(archiveOutput.toString()),ImmutableSet.<Path>of());
    }
    @Override public Optional<Linker.LinkableDepType> getPreferredLinkage(    CxxPlatform cxxPlatform){
      return Optional.absent();
    }
    @Override public PythonPackageComponents getPythonPackageComponents(    CxxPlatform cxxPlatform){
      return PythonPackageComponents.of(ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableSet.<SourcePath>of(),Optional.<Boolean>absent());
    }
    @Override public Iterable<AndroidPackageable> getRequiredPackageables(){
      return ImmutableList.of();
    }
    @Override public void addToCollector(    AndroidPackageableCollector collector){
    }
    @Override public ImmutableMap<String,SourcePath> getSharedLibraries(    CxxPlatform cxxPlatform){
      return ImmutableMap.of();
    }
    @Override public boolean isTestedBy(    BuildTarget buildTarget){
      return false;
    }
  }
;
  resolver.addAllToIndex(ImmutableList.of(header,headerSymlinkTree,archive,dep));
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  CxxBinaryBuilder cxxBinaryBuilder=(CxxBinaryBuilder)new CxxBinaryBuilder(target).setSrcs(ImmutableList.of(SourceWithFlags.of(new TestSourcePath(""String_Node_Str"")),SourceWithFlags.of(new BuildTargetSourcePath(genSource.getBuildTarget())))).setHeaders(ImmutableSortedSet.<SourcePath>of(new TestSourcePath(""String_Node_Str""),new BuildTargetSourcePath(genHeader.getBuildTarget()))).setDeps(ImmutableSortedSet.of(dep.getBuildTarget()));
  CxxBinary binRule=(CxxBinary)cxxBinaryBuilder.build(resolver);
  CxxLink rule=binRule.getRule();
  CxxSourceRuleFactory cxxSourceRuleFactory=new CxxSourceRuleFactory(cxxBinaryBuilder.createBuildRuleParams(resolver,projectFilesystem,TargetGraph.EMPTY),resolver,pathResolver,cxxPlatform,ImmutableList.<CxxPreprocessorInput>of(),ImmutableList.<String>of());
  assertEquals(ImmutableSet.of(cxxSourceRuleFactory.createCompileBuildTarget(""String_Node_Str"",CxxSourceRuleFactory.PicType.PDC),cxxSourceRuleFactory.createCompileBuildTarget(genSourceName,CxxSourceRuleFactory.PicType.PDC),archive.getBuildTarget()),FluentIterable.from(rule.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule preprocessRule1=resolver.getRule(cxxSourceRuleFactory.createPreprocessBuildTarget(""String_Node_Str"",CxxSource.Type.CXX,CxxSourceRuleFactory.PicType.PDC));
  assertEquals(ImmutableSet.of(genHeaderTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE)),FluentIterable.from(preprocessRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule compileRule1=resolver.getRule(cxxSourceRuleFactory.createCompileBuildTarget(""String_Node_Str"",CxxSourceRuleFactory.PicType.PDC));
  assertNotNull(compileRule1);
  assertEquals(ImmutableSet.of(preprocessRule1.getBuildTarget()),FluentIterable.from(compileRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule preprocessRule2=resolver.getRule(cxxSourceRuleFactory.createPreprocessBuildTarget(genSourceName,CxxSource.Type.CXX,CxxSourceRuleFactory.PicType.PDC));
  assertEquals(ImmutableSet.of(genHeaderTarget,genSourceTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE)),FluentIterable.from(preprocessRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule compileRule2=resolver.getRule(cxxSourceRuleFactory.createCompileBuildTarget(genSourceName,CxxSourceRuleFactory.PicType.PDC));
  assertNotNull(compileRule2);
  assertEquals(ImmutableSet.of(preprocessRule2.getBuildTarget()),FluentIterable.from(compileRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
}","@Test @SuppressWarnings(""String_Node_Str"") public void createBuildRule(){
  ProjectFilesystem projectFilesystem=new FakeProjectFilesystem();
  BuildRuleResolver resolver=new BuildRuleResolver();
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  CxxPlatform cxxPlatform=CxxBinaryBuilder.createDefaultPlatform();
  String genHeaderName=""String_Node_Str"";
  BuildTarget genHeaderTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  Genrule genHeader=(Genrule)GenruleBuilder.newGenruleBuilder(genHeaderTarget).setOut(genHeaderName).build(resolver);
  String genSourceName=""String_Node_Str"";
  BuildTarget genSourceTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  Genrule genSource=(Genrule)GenruleBuilder.newGenruleBuilder(genSourceTarget).setOut(genSourceName).build(resolver);
  final BuildRule header=createFakeBuildRule(""String_Node_Str"",pathResolver);
  final BuildRule headerSymlinkTree=createFakeBuildRule(""String_Node_Str"",pathResolver);
  final Path headerSymlinkTreeRoot=Paths.get(""String_Node_Str"");
  final BuildRule archive=createFakeBuildRule(""String_Node_Str"",pathResolver);
  final Path archiveOutput=Paths.get(""String_Node_Str"");
  BuildTarget depTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  BuildRuleParams depParams=BuildRuleParamsFactory.createTrivialBuildRuleParams(depTarget);
  AbstractCxxLibrary dep=new AbstractCxxLibrary(depParams,pathResolver){
    @Override public CxxPreprocessorInput getCxxPreprocessorInput(    CxxPlatform cxxPlatform,    HeaderVisibility headerVisibility){
      return CxxPreprocessorInput.builder().addRules(header.getBuildTarget(),headerSymlinkTree.getBuildTarget()).addIncludeRoots(headerSymlinkTreeRoot).build();
    }
    @Override public ImmutableMap<BuildTarget,CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(    CxxPlatform cxxPlatform,    HeaderVisibility headerVisibility){
      return ImmutableMap.of(getBuildTarget(),getCxxPreprocessorInput(cxxPlatform,headerVisibility));
    }
    @Override public NativeLinkableInput getNativeLinkableInput(    CxxPlatform cxxPlatform,    Linker.LinkableDepType type){
      return NativeLinkableInput.of(ImmutableList.<SourcePath>of(new BuildTargetSourcePath(archive.getBuildTarget())),ImmutableList.of(archiveOutput.toString()),ImmutableSet.<Path>of());
    }
    @Override public NativeLinkable.Linkage getPreferredLinkage(    CxxPlatform cxxPlatform){
      return Linkage.ANY;
    }
    @Override public PythonPackageComponents getPythonPackageComponents(    CxxPlatform cxxPlatform){
      return PythonPackageComponents.of(ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableSet.<SourcePath>of(),Optional.<Boolean>absent());
    }
    @Override public Iterable<AndroidPackageable> getRequiredPackageables(){
      return ImmutableList.of();
    }
    @Override public void addToCollector(    AndroidPackageableCollector collector){
    }
    @Override public ImmutableMap<String,SourcePath> getSharedLibraries(    CxxPlatform cxxPlatform){
      return ImmutableMap.of();
    }
    @Override public boolean isTestedBy(    BuildTarget buildTarget){
      return false;
    }
  }
;
  resolver.addAllToIndex(ImmutableList.of(header,headerSymlinkTree,archive,dep));
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  CxxBinaryBuilder cxxBinaryBuilder=(CxxBinaryBuilder)new CxxBinaryBuilder(target).setSrcs(ImmutableList.of(SourceWithFlags.of(new TestSourcePath(""String_Node_Str"")),SourceWithFlags.of(new BuildTargetSourcePath(genSource.getBuildTarget())))).setHeaders(ImmutableSortedSet.<SourcePath>of(new TestSourcePath(""String_Node_Str""),new BuildTargetSourcePath(genHeader.getBuildTarget()))).setDeps(ImmutableSortedSet.of(dep.getBuildTarget()));
  CxxBinary binRule=(CxxBinary)cxxBinaryBuilder.build(resolver);
  CxxLink rule=binRule.getRule();
  CxxSourceRuleFactory cxxSourceRuleFactory=new CxxSourceRuleFactory(cxxBinaryBuilder.createBuildRuleParams(resolver,projectFilesystem,TargetGraph.EMPTY),resolver,pathResolver,cxxPlatform,ImmutableList.<CxxPreprocessorInput>of(),ImmutableList.<String>of());
  assertEquals(ImmutableSet.of(cxxSourceRuleFactory.createCompileBuildTarget(""String_Node_Str"",CxxSourceRuleFactory.PicType.PDC),cxxSourceRuleFactory.createCompileBuildTarget(genSourceName,CxxSourceRuleFactory.PicType.PDC),archive.getBuildTarget()),FluentIterable.from(rule.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule preprocessRule1=resolver.getRule(cxxSourceRuleFactory.createPreprocessBuildTarget(""String_Node_Str"",CxxSource.Type.CXX,CxxSourceRuleFactory.PicType.PDC));
  assertEquals(ImmutableSet.of(genHeaderTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE)),FluentIterable.from(preprocessRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule compileRule1=resolver.getRule(cxxSourceRuleFactory.createCompileBuildTarget(""String_Node_Str"",CxxSourceRuleFactory.PicType.PDC));
  assertNotNull(compileRule1);
  assertEquals(ImmutableSet.of(preprocessRule1.getBuildTarget()),FluentIterable.from(compileRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule preprocessRule2=resolver.getRule(cxxSourceRuleFactory.createPreprocessBuildTarget(genSourceName,CxxSource.Type.CXX,CxxSourceRuleFactory.PicType.PDC));
  assertEquals(ImmutableSet.of(genHeaderTarget,genSourceTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE)),FluentIterable.from(preprocessRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule compileRule2=resolver.getRule(cxxSourceRuleFactory.createCompileBuildTarget(genSourceName,CxxSourceRuleFactory.PicType.PDC));
  assertNotNull(compileRule2);
  assertEquals(ImmutableSet.of(preprocessRule2.getBuildTarget()),FluentIterable.from(compileRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
}",0.9949263502454992
53184,"@Override public Optional<Linker.LinkableDepType> getPreferredLinkage(CxxPlatform cxxPlatform){
  return Optional.absent();
}","@Override public NativeLinkable.Linkage getPreferredLinkage(CxxPlatform cxxPlatform){
  return Linkage.ANY;
}",0.7863247863247863
53185,"@Test @SuppressWarnings(""String_Node_Str"") public void createBuildRule(){
  BuildRuleResolver resolver=new BuildRuleResolver();
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  CxxPlatform cxxPlatform=CxxLibraryBuilder.createDefaultPlatform();
  String genHeaderName=""String_Node_Str"";
  BuildTarget genHeaderTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  GenruleBuilder genHeaderBuilder=GenruleBuilder.newGenruleBuilder(genHeaderTarget).setOut(genHeaderName);
  genHeaderBuilder.build(resolver);
  String genSourceName=""String_Node_Str"";
  BuildTarget genSourceTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  GenruleBuilder genSourceBuilder=GenruleBuilder.newGenruleBuilder(genSourceTarget).setOut(genSourceName);
  genSourceBuilder.build(resolver);
  final BuildRule header=new FakeBuildRule(""String_Node_Str"",pathResolver);
  final BuildRule headerSymlinkTree=new FakeBuildRule(""String_Node_Str"",pathResolver);
  final Path headerSymlinkTreeRoot=Paths.get(""String_Node_Str"");
  final BuildRule privateHeader=new FakeBuildRule(""String_Node_Str"",pathResolver);
  final BuildRule privateHeaderSymlinkTree=new FakeBuildRule(""String_Node_Str"",pathResolver);
  final Path privateHeaderSymlinkTreeRoot=Paths.get(""String_Node_Str"");
  final BuildRule archive=new FakeBuildRule(""String_Node_Str"",pathResolver);
  final Path archiveOutput=Paths.get(""String_Node_Str"");
  BuildTarget depTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  BuildRuleParams depParams=BuildRuleParamsFactory.createTrivialBuildRuleParams(depTarget);
  AbstractCxxLibrary dep=new AbstractCxxLibrary(depParams,pathResolver){
    @Override public CxxPreprocessorInput getCxxPreprocessorInput(    CxxPlatform cxxPlatform,    HeaderVisibility headerVisibility){
switch (headerVisibility) {
case PUBLIC:
        return CxxPreprocessorInput.builder().addRules(header.getBuildTarget(),headerSymlinkTree.getBuildTarget()).addIncludeRoots(headerSymlinkTreeRoot).build();
case PRIVATE:
      return CxxPreprocessorInput.builder().addRules(privateHeader.getBuildTarget(),privateHeaderSymlinkTree.getBuildTarget()).addIncludeRoots(privateHeaderSymlinkTreeRoot).build();
  }
  throw new RuntimeException(""String_Node_Str"" + headerVisibility);
}
@Override public ImmutableMap<BuildTarget,CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(CxxPlatform cxxPlatform,HeaderVisibility headerVisibility){
  return ImmutableMap.of(getBuildTarget(),getCxxPreprocessorInput(cxxPlatform,headerVisibility));
}
@Override public NativeLinkableInput getNativeLinkableInput(CxxPlatform cxxPlatform,Linker.LinkableDepType type){
  return NativeLinkableInput.of(ImmutableList.<SourcePath>of(new BuildTargetSourcePath(archive.getBuildTarget())),ImmutableList.of(archiveOutput.toString()),ImmutableSet.<Path>of());
}
@Override public Optional<Linker.LinkableDepType> getPreferredLinkage(CxxPlatform cxxPlatform){
  return Optional.absent();
}
@Override public PythonPackageComponents getPythonPackageComponents(CxxPlatform cxxPlatform){
  return PythonPackageComponents.of(ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableSet.<SourcePath>of(),Optional.<Boolean>absent());
}
@Override public Iterable<AndroidPackageable> getRequiredPackageables(){
  return ImmutableList.of();
}
@Override public void addToCollector(AndroidPackageableCollector collector){
}
@Override public ImmutableMap<String,SourcePath> getSharedLibraries(CxxPlatform cxxPlatform){
  return ImmutableMap.of();
}
@Override public boolean isTestedBy(BuildTarget buildTarget){
  return false;
}
}
;
resolver.addAllToIndex(ImmutableList.of(header,headerSymlinkTree,privateHeader,privateHeaderSymlinkTree,archive,dep));
BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
CxxSourceRuleFactory cxxSourceRuleFactory=CxxSourceRuleFactoryHelper.of(target,cxxPlatform);
String headerName=""String_Node_Str"";
String privateHeaderName=""String_Node_Str"";
CxxLibraryBuilder cxxLibraryBuilder=(CxxLibraryBuilder)new CxxLibraryBuilder(target).setExportedHeaders(ImmutableSortedSet.<SourcePath>of(new TestSourcePath(headerName),new BuildTargetSourcePath(genHeaderTarget))).setHeaders(ImmutableSortedSet.<SourcePath>of(new TestSourcePath(privateHeaderName))).setSrcs(ImmutableList.of(SourceWithFlags.of(new TestSourcePath(""String_Node_Str"")),SourceWithFlags.of(new BuildTargetSourcePath(genSourceTarget)))).setFrameworkSearchPaths(ImmutableSet.of(Paths.get(""String_Node_Str""),Paths.get(""String_Node_Str""))).setDeps(ImmutableSortedSet.of(dep.getBuildTarget()));
CxxLibrary rule=(CxxLibrary)cxxLibraryBuilder.build(resolver,new FakeProjectFilesystem(),TargetGraphFactory.newInstance(cxxLibraryBuilder.build(),genSourceBuilder.build(),genHeaderBuilder.build(),GenruleBuilder.newGenruleBuilder(depTarget).build()));
Path headerRoot=CxxDescriptionEnhancer.getHeaderSymlinkTreePath(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC);
assertEquals(CxxPreprocessorInput.builder().addRules(CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)).setIncludes(CxxHeaders.builder().putNameToPathMap(Paths.get(headerName),new TestSourcePath(headerName)).putNameToPathMap(Paths.get(genHeaderName),new BuildTargetSourcePath(genHeaderTarget)).putFullNameToPathMap(headerRoot.resolve(headerName),new TestSourcePath(headerName)).putFullNameToPathMap(headerRoot.resolve(genHeaderName),new BuildTargetSourcePath(genHeaderTarget)).build()).addIncludeRoots(CxxDescriptionEnhancer.getHeaderSymlinkTreePath(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)).addFrameworkRoots(Paths.get(""String_Node_Str""),Paths.get(""String_Node_Str"")).build(),rule.getCxxPreprocessorInput(cxxPlatform,HeaderVisibility.PUBLIC));
Path privateHeaderRoot=CxxDescriptionEnhancer.getHeaderSymlinkTreePath(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE);
assertEquals(CxxPreprocessorInput.builder().addRules(CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE)).setIncludes(CxxHeaders.builder().putNameToPathMap(Paths.get(privateHeaderName),new TestSourcePath(privateHeaderName)).putFullNameToPathMap(privateHeaderRoot.resolve(privateHeaderName),new TestSourcePath(privateHeaderName)).build()).addIncludeRoots(CxxDescriptionEnhancer.getHeaderSymlinkTreePath(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE)).addFrameworkRoots(Paths.get(""String_Node_Str""),Paths.get(""String_Node_Str"")).build(),rule.getCxxPreprocessorInput(cxxPlatform,HeaderVisibility.PRIVATE));
rule.getNativeLinkableInput(cxxPlatform,Linker.LinkableDepType.STATIC);
BuildRule archiveRule=resolver.getRule(CxxDescriptionEnhancer.createStaticLibraryBuildTarget(target,cxxPlatform.getFlavor(),CxxSourceRuleFactory.PicType.PDC));
assertNotNull(archiveRule);
assertEquals(ImmutableSet.of(cxxSourceRuleFactory.createCompileBuildTarget(""String_Node_Str"",CxxSourceRuleFactory.PicType.PDC),cxxSourceRuleFactory.createCompileBuildTarget(genSourceName,CxxSourceRuleFactory.PicType.PDC)),FluentIterable.from(archiveRule.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
BuildRule preprocessRule1=resolver.getRule(cxxSourceRuleFactory.createPreprocessBuildTarget(""String_Node_Str"",CxxSource.Type.CXX,CxxSourceRuleFactory.PicType.PDC));
assertEquals(ImmutableSet.of(genHeaderTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)),FluentIterable.from(preprocessRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
BuildRule compileRule1=resolver.getRule(cxxSourceRuleFactory.createCompileBuildTarget(""String_Node_Str"",CxxSourceRuleFactory.PicType.PDC));
assertNotNull(compileRule1);
assertEquals(ImmutableSet.of(preprocessRule1.getBuildTarget()),FluentIterable.from(compileRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
BuildRule preprocessRule2=resolver.getRule(cxxSourceRuleFactory.createPreprocessBuildTarget(genSourceName,CxxSource.Type.CXX,CxxSourceRuleFactory.PicType.PDC));
assertEquals(ImmutableSet.of(genHeaderTarget,genSourceTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)),FluentIterable.from(preprocessRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
BuildRule compileRule2=resolver.getRule(cxxSourceRuleFactory.createCompileBuildTarget(genSourceName,CxxSourceRuleFactory.PicType.PDC));
assertNotNull(compileRule2);
assertEquals(ImmutableSet.of(preprocessRule2.getBuildTarget()),FluentIterable.from(compileRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
}","@Test @SuppressWarnings(""String_Node_Str"") public void createBuildRule(){
  BuildRuleResolver resolver=new BuildRuleResolver();
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  CxxPlatform cxxPlatform=CxxLibraryBuilder.createDefaultPlatform();
  String genHeaderName=""String_Node_Str"";
  BuildTarget genHeaderTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  GenruleBuilder genHeaderBuilder=GenruleBuilder.newGenruleBuilder(genHeaderTarget).setOut(genHeaderName);
  genHeaderBuilder.build(resolver);
  String genSourceName=""String_Node_Str"";
  BuildTarget genSourceTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  GenruleBuilder genSourceBuilder=GenruleBuilder.newGenruleBuilder(genSourceTarget).setOut(genSourceName);
  genSourceBuilder.build(resolver);
  final BuildRule header=new FakeBuildRule(""String_Node_Str"",pathResolver);
  final BuildRule headerSymlinkTree=new FakeBuildRule(""String_Node_Str"",pathResolver);
  final Path headerSymlinkTreeRoot=Paths.get(""String_Node_Str"");
  final BuildRule privateHeader=new FakeBuildRule(""String_Node_Str"",pathResolver);
  final BuildRule privateHeaderSymlinkTree=new FakeBuildRule(""String_Node_Str"",pathResolver);
  final Path privateHeaderSymlinkTreeRoot=Paths.get(""String_Node_Str"");
  final BuildRule archive=new FakeBuildRule(""String_Node_Str"",pathResolver);
  final Path archiveOutput=Paths.get(""String_Node_Str"");
  BuildTarget depTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  BuildRuleParams depParams=BuildRuleParamsFactory.createTrivialBuildRuleParams(depTarget);
  AbstractCxxLibrary dep=new AbstractCxxLibrary(depParams,pathResolver){
    @Override public CxxPreprocessorInput getCxxPreprocessorInput(    CxxPlatform cxxPlatform,    HeaderVisibility headerVisibility){
switch (headerVisibility) {
case PUBLIC:
        return CxxPreprocessorInput.builder().addRules(header.getBuildTarget(),headerSymlinkTree.getBuildTarget()).addIncludeRoots(headerSymlinkTreeRoot).build();
case PRIVATE:
      return CxxPreprocessorInput.builder().addRules(privateHeader.getBuildTarget(),privateHeaderSymlinkTree.getBuildTarget()).addIncludeRoots(privateHeaderSymlinkTreeRoot).build();
  }
  throw new RuntimeException(""String_Node_Str"" + headerVisibility);
}
@Override public ImmutableMap<BuildTarget,CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(CxxPlatform cxxPlatform,HeaderVisibility headerVisibility){
  return ImmutableMap.of(getBuildTarget(),getCxxPreprocessorInput(cxxPlatform,headerVisibility));
}
@Override public NativeLinkableInput getNativeLinkableInput(CxxPlatform cxxPlatform,Linker.LinkableDepType type){
  return NativeLinkableInput.of(ImmutableList.<SourcePath>of(new BuildTargetSourcePath(archive.getBuildTarget())),ImmutableList.of(archiveOutput.toString()),ImmutableSet.<Path>of());
}
@Override public NativeLinkable.Linkage getPreferredLinkage(CxxPlatform cxxPlatform){
  return Linkage.ANY;
}
@Override public PythonPackageComponents getPythonPackageComponents(CxxPlatform cxxPlatform){
  return PythonPackageComponents.of(ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableSet.<SourcePath>of(),Optional.<Boolean>absent());
}
@Override public Iterable<AndroidPackageable> getRequiredPackageables(){
  return ImmutableList.of();
}
@Override public void addToCollector(AndroidPackageableCollector collector){
}
@Override public ImmutableMap<String,SourcePath> getSharedLibraries(CxxPlatform cxxPlatform){
  return ImmutableMap.of();
}
@Override public boolean isTestedBy(BuildTarget buildTarget){
  return false;
}
}
;
resolver.addAllToIndex(ImmutableList.of(header,headerSymlinkTree,privateHeader,privateHeaderSymlinkTree,archive,dep));
BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
CxxSourceRuleFactory cxxSourceRuleFactory=CxxSourceRuleFactoryHelper.of(target,cxxPlatform);
String headerName=""String_Node_Str"";
String privateHeaderName=""String_Node_Str"";
CxxLibraryBuilder cxxLibraryBuilder=(CxxLibraryBuilder)new CxxLibraryBuilder(target).setExportedHeaders(ImmutableSortedSet.<SourcePath>of(new TestSourcePath(headerName),new BuildTargetSourcePath(genHeaderTarget))).setHeaders(ImmutableSortedSet.<SourcePath>of(new TestSourcePath(privateHeaderName))).setSrcs(ImmutableList.of(SourceWithFlags.of(new TestSourcePath(""String_Node_Str"")),SourceWithFlags.of(new BuildTargetSourcePath(genSourceTarget)))).setFrameworkSearchPaths(ImmutableSet.of(Paths.get(""String_Node_Str""),Paths.get(""String_Node_Str""))).setDeps(ImmutableSortedSet.of(dep.getBuildTarget()));
CxxLibrary rule=(CxxLibrary)cxxLibraryBuilder.build(resolver,new FakeProjectFilesystem(),TargetGraphFactory.newInstance(cxxLibraryBuilder.build(),genSourceBuilder.build(),genHeaderBuilder.build(),GenruleBuilder.newGenruleBuilder(depTarget).build()));
Path headerRoot=CxxDescriptionEnhancer.getHeaderSymlinkTreePath(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC);
assertEquals(CxxPreprocessorInput.builder().addRules(CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)).setIncludes(CxxHeaders.builder().putNameToPathMap(Paths.get(headerName),new TestSourcePath(headerName)).putNameToPathMap(Paths.get(genHeaderName),new BuildTargetSourcePath(genHeaderTarget)).putFullNameToPathMap(headerRoot.resolve(headerName),new TestSourcePath(headerName)).putFullNameToPathMap(headerRoot.resolve(genHeaderName),new BuildTargetSourcePath(genHeaderTarget)).build()).addIncludeRoots(CxxDescriptionEnhancer.getHeaderSymlinkTreePath(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)).addFrameworkRoots(Paths.get(""String_Node_Str""),Paths.get(""String_Node_Str"")).build(),rule.getCxxPreprocessorInput(cxxPlatform,HeaderVisibility.PUBLIC));
Path privateHeaderRoot=CxxDescriptionEnhancer.getHeaderSymlinkTreePath(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE);
assertEquals(CxxPreprocessorInput.builder().addRules(CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE)).setIncludes(CxxHeaders.builder().putNameToPathMap(Paths.get(privateHeaderName),new TestSourcePath(privateHeaderName)).putFullNameToPathMap(privateHeaderRoot.resolve(privateHeaderName),new TestSourcePath(privateHeaderName)).build()).addIncludeRoots(CxxDescriptionEnhancer.getHeaderSymlinkTreePath(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE)).addFrameworkRoots(Paths.get(""String_Node_Str""),Paths.get(""String_Node_Str"")).build(),rule.getCxxPreprocessorInput(cxxPlatform,HeaderVisibility.PRIVATE));
rule.getNativeLinkableInput(cxxPlatform,Linker.LinkableDepType.STATIC);
BuildRule archiveRule=resolver.getRule(CxxDescriptionEnhancer.createStaticLibraryBuildTarget(target,cxxPlatform.getFlavor(),CxxSourceRuleFactory.PicType.PDC));
assertNotNull(archiveRule);
assertEquals(ImmutableSet.of(cxxSourceRuleFactory.createCompileBuildTarget(""String_Node_Str"",CxxSourceRuleFactory.PicType.PDC),cxxSourceRuleFactory.createCompileBuildTarget(genSourceName,CxxSourceRuleFactory.PicType.PDC)),FluentIterable.from(archiveRule.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
BuildRule preprocessRule1=resolver.getRule(cxxSourceRuleFactory.createPreprocessBuildTarget(""String_Node_Str"",CxxSource.Type.CXX,CxxSourceRuleFactory.PicType.PDC));
assertEquals(ImmutableSet.of(genHeaderTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)),FluentIterable.from(preprocessRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
BuildRule compileRule1=resolver.getRule(cxxSourceRuleFactory.createCompileBuildTarget(""String_Node_Str"",CxxSourceRuleFactory.PicType.PDC));
assertNotNull(compileRule1);
assertEquals(ImmutableSet.of(preprocessRule1.getBuildTarget()),FluentIterable.from(compileRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
BuildRule preprocessRule2=resolver.getRule(cxxSourceRuleFactory.createPreprocessBuildTarget(genSourceName,CxxSource.Type.CXX,CxxSourceRuleFactory.PicType.PDC));
assertEquals(ImmutableSet.of(genHeaderTarget,genSourceTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)),FluentIterable.from(preprocessRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
BuildRule compileRule2=resolver.getRule(cxxSourceRuleFactory.createCompileBuildTarget(genSourceName,CxxSourceRuleFactory.PicType.PDC));
assertNotNull(compileRule2);
assertEquals(ImmutableSet.of(preprocessRule2.getBuildTarget()),FluentIterable.from(compileRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
}",0.9965409506806516
53186,"@Override public Optional<Linker.LinkableDepType> getPreferredLinkage(CxxPlatform cxxPlatform){
  return Optional.absent();
}","@Override public NativeLinkable.Linkage getPreferredLinkage(CxxPlatform cxxPlatform){
  return Linkage.ANY;
}",0.7863247863247863
53187,"@Test @SuppressWarnings(""String_Node_Str"") public void createCxxLibraryBuildRules(){
  BuildRuleResolver resolver=new BuildRuleResolver();
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  CxxPlatform cxxPlatform=CxxLibraryBuilder.createDefaultPlatform();
  String sourceName=""String_Node_Str"";
  String genHeaderName=""String_Node_Str"";
  BuildTarget genHeaderTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  GenruleBuilder genHeaderBuilder=GenruleBuilder.newGenruleBuilder(genHeaderTarget).setOut(genHeaderName);
  genHeaderBuilder.build(resolver);
  String genSourceName=""String_Node_Str"";
  BuildTarget genSourceTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  GenruleBuilder genSourceBuilder=GenruleBuilder.newGenruleBuilder(genSourceTarget).setOut(genSourceName);
  genSourceBuilder.build(resolver);
  final BuildRule header=new FakeBuildRule(""String_Node_Str"",pathResolver);
  final BuildRule headerSymlinkTree=new FakeBuildRule(""String_Node_Str"",pathResolver);
  final Path headerSymlinkTreeRoot=Paths.get(""String_Node_Str"");
  final BuildRule staticLibraryDep=new FakeBuildRule(""String_Node_Str"",pathResolver);
  final Path staticLibraryOutput=Paths.get(""String_Node_Str"");
  final BuildRule sharedLibraryDep=new FakeBuildRule(""String_Node_Str"",pathResolver);
  final Path sharedLibraryOutput=Paths.get(""String_Node_Str"");
  final String sharedLibrarySoname=""String_Node_Str"";
  BuildTarget depTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  BuildRuleParams depParams=BuildRuleParamsFactory.createTrivialBuildRuleParams(depTarget);
  AbstractCxxLibrary dep=new AbstractCxxLibrary(depParams,pathResolver){
    @Override public CxxPreprocessorInput getCxxPreprocessorInput(    CxxPlatform cxxPlatform,    HeaderVisibility headerVisibility){
      return CxxPreprocessorInput.builder().addRules(header.getBuildTarget(),headerSymlinkTree.getBuildTarget()).addIncludeRoots(headerSymlinkTreeRoot).build();
    }
    @Override public ImmutableMap<BuildTarget,CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(    CxxPlatform cxxPlatform,    HeaderVisibility headerVisibility){
      return ImmutableMap.of(getBuildTarget(),getCxxPreprocessorInput(cxxPlatform,headerVisibility));
    }
    @Override public NativeLinkableInput getNativeLinkableInput(    CxxPlatform cxxPlatform,    Linker.LinkableDepType type){
      return type == Linker.LinkableDepType.STATIC ? NativeLinkableInput.of(ImmutableList.<SourcePath>of(new BuildTargetSourcePath(staticLibraryDep.getBuildTarget())),ImmutableList.of(staticLibraryOutput.toString()),ImmutableSet.<Path>of()) : NativeLinkableInput.of(ImmutableList.<SourcePath>of(new BuildTargetSourcePath(sharedLibraryDep.getBuildTarget())),ImmutableList.of(sharedLibraryOutput.toString()),ImmutableSet.<Path>of());
    }
    @Override public Optional<Linker.LinkableDepType> getPreferredLinkage(    CxxPlatform cxxPlatform){
      return Optional.absent();
    }
    @Override public PythonPackageComponents getPythonPackageComponents(    CxxPlatform cxxPlatform){
      return PythonPackageComponents.of(ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(Paths.get(sharedLibrarySoname),new PathSourcePath(getProjectFilesystem(),sharedLibraryOutput)),ImmutableSet.<SourcePath>of(),Optional.<Boolean>absent());
    }
    @Override public Iterable<AndroidPackageable> getRequiredPackageables(){
      return ImmutableList.of();
    }
    @Override public void addToCollector(    AndroidPackageableCollector collector){
    }
    @Override public ImmutableMap<String,SourcePath> getSharedLibraries(    CxxPlatform cxxPlatform){
      return ImmutableMap.of();
    }
    @Override public boolean isTestedBy(    BuildTarget buildTarget){
      return false;
    }
  }
;
  resolver.addAllToIndex(ImmutableList.of(header,headerSymlinkTree,staticLibraryDep,sharedLibraryDep,dep));
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  CxxSourceRuleFactory cxxSourceRuleFactory=CxxSourceRuleFactoryHelper.of(target,cxxPlatform);
  CxxLibraryBuilder cxxLibraryBuilder=(CxxLibraryBuilder)new CxxLibraryBuilder(target).setExportedHeaders(ImmutableMap.<String,SourcePath>of(genHeaderName,new BuildTargetSourcePath(genHeaderTarget))).setSrcs(ImmutableMap.of(sourceName,SourceWithFlags.of(new TestSourcePath(sourceName)),genSourceName,SourceWithFlags.of(new BuildTargetSourcePath(genSourceTarget)))).setFrameworkSearchPaths(ImmutableSet.of(Paths.get(""String_Node_Str""),Paths.get(""String_Node_Str""))).setDeps(ImmutableSortedSet.of(dep.getBuildTarget()));
  CxxLibrary rule=(CxxLibrary)cxxLibraryBuilder.build(resolver,new FakeProjectFilesystem(),TargetGraphFactory.newInstance(cxxLibraryBuilder.build(),genSourceBuilder.build(),genHeaderBuilder.build(),GenruleBuilder.newGenruleBuilder(depTarget).build()));
  Path headerRoot=CxxDescriptionEnhancer.getHeaderSymlinkTreePath(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC);
  assertEquals(CxxPreprocessorInput.builder().addRules(CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)).setIncludes(CxxHeaders.builder().putNameToPathMap(Paths.get(genHeaderName),new BuildTargetSourcePath(genHeaderTarget)).putFullNameToPathMap(headerRoot.resolve(genHeaderName),new BuildTargetSourcePath(genHeaderTarget)).build()).addIncludeRoots(CxxDescriptionEnhancer.getHeaderSymlinkTreePath(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)).addFrameworkRoots(Paths.get(""String_Node_Str""),Paths.get(""String_Node_Str"")).build(),rule.getCxxPreprocessorInput(cxxPlatform,HeaderVisibility.PUBLIC));
  rule.getNativeLinkableInput(cxxPlatform,Linker.LinkableDepType.STATIC);
  BuildRule staticRule=resolver.getRule(CxxDescriptionEnhancer.createStaticLibraryBuildTarget(target,cxxPlatform.getFlavor(),CxxSourceRuleFactory.PicType.PDC));
  assertNotNull(staticRule);
  assertEquals(ImmutableSet.of(cxxSourceRuleFactory.createCompileBuildTarget(""String_Node_Str"",CxxSourceRuleFactory.PicType.PDC),cxxSourceRuleFactory.createCompileBuildTarget(genSourceName,CxxSourceRuleFactory.PicType.PDC)),FluentIterable.from(staticRule.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule staticPreprocessRule1=resolver.getRule(cxxSourceRuleFactory.createPreprocessBuildTarget(""String_Node_Str"",CxxSource.Type.CXX,CxxSourceRuleFactory.PicType.PDC));
  assertNotNull(staticPreprocessRule1);
  assertEquals(ImmutableSet.of(genHeaderTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)),FluentIterable.from(staticPreprocessRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule staticCompileRule1=resolver.getRule(cxxSourceRuleFactory.createCompileBuildTarget(""String_Node_Str"",CxxSourceRuleFactory.PicType.PDC));
  assertNotNull(staticCompileRule1);
  assertEquals(ImmutableSet.of(staticPreprocessRule1.getBuildTarget()),FluentIterable.from(staticCompileRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule staticPreprocessRule2=resolver.getRule(cxxSourceRuleFactory.createPreprocessBuildTarget(genSourceName,CxxSource.Type.CXX,CxxSourceRuleFactory.PicType.PDC));
  assertNotNull(staticPreprocessRule2);
  assertEquals(ImmutableSet.of(genHeaderTarget,genSourceTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)),FluentIterable.from(staticPreprocessRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule staticCompileRule2=resolver.getRule(cxxSourceRuleFactory.createCompileBuildTarget(genSourceName,CxxSourceRuleFactory.PicType.PDC));
  assertNotNull(staticCompileRule2);
  assertEquals(ImmutableSet.of(staticPreprocessRule2.getBuildTarget()),FluentIterable.from(staticCompileRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  rule.getNativeLinkableInput(cxxPlatform,Linker.LinkableDepType.SHARED);
  BuildRule sharedRule=resolver.getRule(CxxDescriptionEnhancer.createSharedLibraryBuildTarget(target,cxxPlatform.getFlavor()));
  assertNotNull(sharedRule);
  assertEquals(ImmutableSet.of(sharedLibraryDep.getBuildTarget(),cxxSourceRuleFactory.createCompileBuildTarget(""String_Node_Str"",CxxSourceRuleFactory.PicType.PIC),cxxSourceRuleFactory.createCompileBuildTarget(genSourceName,CxxSourceRuleFactory.PicType.PIC)),FluentIterable.from(sharedRule.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule sharedPreprocessRule1=resolver.getRule(cxxSourceRuleFactory.createPreprocessBuildTarget(""String_Node_Str"",CxxSource.Type.CXX,CxxSourceRuleFactory.PicType.PIC));
  assertNotNull(sharedPreprocessRule1);
  assertEquals(ImmutableSet.of(genHeaderTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)),FluentIterable.from(sharedPreprocessRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule sharedCompileRule1=resolver.getRule(cxxSourceRuleFactory.createCompileBuildTarget(""String_Node_Str"",CxxSourceRuleFactory.PicType.PIC));
  assertNotNull(sharedCompileRule1);
  assertEquals(ImmutableSet.of(sharedPreprocessRule1.getBuildTarget()),FluentIterable.from(sharedCompileRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule sharedPreprocessRule2=resolver.getRule(cxxSourceRuleFactory.createPreprocessBuildTarget(genSourceName,CxxSource.Type.CXX,CxxSourceRuleFactory.PicType.PIC));
  assertNotNull(sharedPreprocessRule2);
  assertEquals(ImmutableSet.of(genHeaderTarget,genSourceTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)),FluentIterable.from(sharedPreprocessRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule sharedCompileRule2=resolver.getRule(cxxSourceRuleFactory.createCompileBuildTarget(genSourceName,CxxSourceRuleFactory.PicType.PIC));
  assertNotNull(sharedCompileRule2);
  assertEquals(ImmutableSet.of(sharedPreprocessRule2.getBuildTarget()),FluentIterable.from(sharedCompileRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  PythonPackageComponents expectedPythonPackageComponents=PythonPackageComponents.of(ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(Paths.get(CxxDescriptionEnhancer.getDefaultSharedLibrarySoname(target,cxxPlatform)),new BuildTargetSourcePath(sharedRule.getBuildTarget())),ImmutableSet.<SourcePath>of(),Optional.<Boolean>absent());
  assertEquals(expectedPythonPackageComponents,rule.getPythonPackageComponents(cxxPlatform));
}","@Test @SuppressWarnings(""String_Node_Str"") public void createCxxLibraryBuildRules(){
  BuildRuleResolver resolver=new BuildRuleResolver();
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  CxxPlatform cxxPlatform=CxxLibraryBuilder.createDefaultPlatform();
  String sourceName=""String_Node_Str"";
  String genHeaderName=""String_Node_Str"";
  BuildTarget genHeaderTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  GenruleBuilder genHeaderBuilder=GenruleBuilder.newGenruleBuilder(genHeaderTarget).setOut(genHeaderName);
  genHeaderBuilder.build(resolver);
  String genSourceName=""String_Node_Str"";
  BuildTarget genSourceTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  GenruleBuilder genSourceBuilder=GenruleBuilder.newGenruleBuilder(genSourceTarget).setOut(genSourceName);
  genSourceBuilder.build(resolver);
  final BuildRule header=new FakeBuildRule(""String_Node_Str"",pathResolver);
  final BuildRule headerSymlinkTree=new FakeBuildRule(""String_Node_Str"",pathResolver);
  final Path headerSymlinkTreeRoot=Paths.get(""String_Node_Str"");
  final BuildRule staticLibraryDep=new FakeBuildRule(""String_Node_Str"",pathResolver);
  final Path staticLibraryOutput=Paths.get(""String_Node_Str"");
  final BuildRule sharedLibraryDep=new FakeBuildRule(""String_Node_Str"",pathResolver);
  final Path sharedLibraryOutput=Paths.get(""String_Node_Str"");
  final String sharedLibrarySoname=""String_Node_Str"";
  BuildTarget depTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  BuildRuleParams depParams=BuildRuleParamsFactory.createTrivialBuildRuleParams(depTarget);
  AbstractCxxLibrary dep=new AbstractCxxLibrary(depParams,pathResolver){
    @Override public CxxPreprocessorInput getCxxPreprocessorInput(    CxxPlatform cxxPlatform,    HeaderVisibility headerVisibility){
      return CxxPreprocessorInput.builder().addRules(header.getBuildTarget(),headerSymlinkTree.getBuildTarget()).addIncludeRoots(headerSymlinkTreeRoot).build();
    }
    @Override public ImmutableMap<BuildTarget,CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(    CxxPlatform cxxPlatform,    HeaderVisibility headerVisibility){
      return ImmutableMap.of(getBuildTarget(),getCxxPreprocessorInput(cxxPlatform,headerVisibility));
    }
    @Override public NativeLinkableInput getNativeLinkableInput(    CxxPlatform cxxPlatform,    Linker.LinkableDepType type){
      return type == Linker.LinkableDepType.STATIC ? NativeLinkableInput.of(ImmutableList.<SourcePath>of(new BuildTargetSourcePath(staticLibraryDep.getBuildTarget())),ImmutableList.of(staticLibraryOutput.toString()),ImmutableSet.<Path>of()) : NativeLinkableInput.of(ImmutableList.<SourcePath>of(new BuildTargetSourcePath(sharedLibraryDep.getBuildTarget())),ImmutableList.of(sharedLibraryOutput.toString()),ImmutableSet.<Path>of());
    }
    @Override public NativeLinkable.Linkage getPreferredLinkage(    CxxPlatform cxxPlatform){
      return Linkage.ANY;
    }
    @Override public PythonPackageComponents getPythonPackageComponents(    CxxPlatform cxxPlatform){
      return PythonPackageComponents.of(ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(Paths.get(sharedLibrarySoname),new PathSourcePath(getProjectFilesystem(),sharedLibraryOutput)),ImmutableSet.<SourcePath>of(),Optional.<Boolean>absent());
    }
    @Override public Iterable<AndroidPackageable> getRequiredPackageables(){
      return ImmutableList.of();
    }
    @Override public void addToCollector(    AndroidPackageableCollector collector){
    }
    @Override public ImmutableMap<String,SourcePath> getSharedLibraries(    CxxPlatform cxxPlatform){
      return ImmutableMap.of();
    }
    @Override public boolean isTestedBy(    BuildTarget buildTarget){
      return false;
    }
  }
;
  resolver.addAllToIndex(ImmutableList.of(header,headerSymlinkTree,staticLibraryDep,sharedLibraryDep,dep));
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  CxxSourceRuleFactory cxxSourceRuleFactory=CxxSourceRuleFactoryHelper.of(target,cxxPlatform);
  CxxLibraryBuilder cxxLibraryBuilder=(CxxLibraryBuilder)new CxxLibraryBuilder(target).setExportedHeaders(ImmutableMap.<String,SourcePath>of(genHeaderName,new BuildTargetSourcePath(genHeaderTarget))).setSrcs(ImmutableMap.of(sourceName,SourceWithFlags.of(new TestSourcePath(sourceName)),genSourceName,SourceWithFlags.of(new BuildTargetSourcePath(genSourceTarget)))).setFrameworkSearchPaths(ImmutableSet.of(Paths.get(""String_Node_Str""),Paths.get(""String_Node_Str""))).setDeps(ImmutableSortedSet.of(dep.getBuildTarget()));
  CxxLibrary rule=(CxxLibrary)cxxLibraryBuilder.build(resolver,new FakeProjectFilesystem(),TargetGraphFactory.newInstance(cxxLibraryBuilder.build(),genSourceBuilder.build(),genHeaderBuilder.build(),GenruleBuilder.newGenruleBuilder(depTarget).build()));
  Path headerRoot=CxxDescriptionEnhancer.getHeaderSymlinkTreePath(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC);
  assertEquals(CxxPreprocessorInput.builder().addRules(CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)).setIncludes(CxxHeaders.builder().putNameToPathMap(Paths.get(genHeaderName),new BuildTargetSourcePath(genHeaderTarget)).putFullNameToPathMap(headerRoot.resolve(genHeaderName),new BuildTargetSourcePath(genHeaderTarget)).build()).addIncludeRoots(CxxDescriptionEnhancer.getHeaderSymlinkTreePath(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)).addFrameworkRoots(Paths.get(""String_Node_Str""),Paths.get(""String_Node_Str"")).build(),rule.getCxxPreprocessorInput(cxxPlatform,HeaderVisibility.PUBLIC));
  rule.getNativeLinkableInput(cxxPlatform,Linker.LinkableDepType.STATIC);
  BuildRule staticRule=resolver.getRule(CxxDescriptionEnhancer.createStaticLibraryBuildTarget(target,cxxPlatform.getFlavor(),CxxSourceRuleFactory.PicType.PDC));
  assertNotNull(staticRule);
  assertEquals(ImmutableSet.of(cxxSourceRuleFactory.createCompileBuildTarget(""String_Node_Str"",CxxSourceRuleFactory.PicType.PDC),cxxSourceRuleFactory.createCompileBuildTarget(genSourceName,CxxSourceRuleFactory.PicType.PDC)),FluentIterable.from(staticRule.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule staticPreprocessRule1=resolver.getRule(cxxSourceRuleFactory.createPreprocessBuildTarget(""String_Node_Str"",CxxSource.Type.CXX,CxxSourceRuleFactory.PicType.PDC));
  assertNotNull(staticPreprocessRule1);
  assertEquals(ImmutableSet.of(genHeaderTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)),FluentIterable.from(staticPreprocessRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule staticCompileRule1=resolver.getRule(cxxSourceRuleFactory.createCompileBuildTarget(""String_Node_Str"",CxxSourceRuleFactory.PicType.PDC));
  assertNotNull(staticCompileRule1);
  assertEquals(ImmutableSet.of(staticPreprocessRule1.getBuildTarget()),FluentIterable.from(staticCompileRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule staticPreprocessRule2=resolver.getRule(cxxSourceRuleFactory.createPreprocessBuildTarget(genSourceName,CxxSource.Type.CXX,CxxSourceRuleFactory.PicType.PDC));
  assertNotNull(staticPreprocessRule2);
  assertEquals(ImmutableSet.of(genHeaderTarget,genSourceTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)),FluentIterable.from(staticPreprocessRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule staticCompileRule2=resolver.getRule(cxxSourceRuleFactory.createCompileBuildTarget(genSourceName,CxxSourceRuleFactory.PicType.PDC));
  assertNotNull(staticCompileRule2);
  assertEquals(ImmutableSet.of(staticPreprocessRule2.getBuildTarget()),FluentIterable.from(staticCompileRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  rule.getNativeLinkableInput(cxxPlatform,Linker.LinkableDepType.SHARED);
  BuildRule sharedRule=resolver.getRule(CxxDescriptionEnhancer.createSharedLibraryBuildTarget(target,cxxPlatform.getFlavor()));
  assertNotNull(sharedRule);
  assertEquals(ImmutableSet.of(sharedLibraryDep.getBuildTarget(),cxxSourceRuleFactory.createCompileBuildTarget(""String_Node_Str"",CxxSourceRuleFactory.PicType.PIC),cxxSourceRuleFactory.createCompileBuildTarget(genSourceName,CxxSourceRuleFactory.PicType.PIC)),FluentIterable.from(sharedRule.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule sharedPreprocessRule1=resolver.getRule(cxxSourceRuleFactory.createPreprocessBuildTarget(""String_Node_Str"",CxxSource.Type.CXX,CxxSourceRuleFactory.PicType.PIC));
  assertNotNull(sharedPreprocessRule1);
  assertEquals(ImmutableSet.of(genHeaderTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)),FluentIterable.from(sharedPreprocessRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule sharedCompileRule1=resolver.getRule(cxxSourceRuleFactory.createCompileBuildTarget(""String_Node_Str"",CxxSourceRuleFactory.PicType.PIC));
  assertNotNull(sharedCompileRule1);
  assertEquals(ImmutableSet.of(sharedPreprocessRule1.getBuildTarget()),FluentIterable.from(sharedCompileRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule sharedPreprocessRule2=resolver.getRule(cxxSourceRuleFactory.createPreprocessBuildTarget(genSourceName,CxxSource.Type.CXX,CxxSourceRuleFactory.PicType.PIC));
  assertNotNull(sharedPreprocessRule2);
  assertEquals(ImmutableSet.of(genHeaderTarget,genSourceTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)),FluentIterable.from(sharedPreprocessRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule sharedCompileRule2=resolver.getRule(cxxSourceRuleFactory.createCompileBuildTarget(genSourceName,CxxSourceRuleFactory.PicType.PIC));
  assertNotNull(sharedCompileRule2);
  assertEquals(ImmutableSet.of(sharedPreprocessRule2.getBuildTarget()),FluentIterable.from(sharedCompileRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  PythonPackageComponents expectedPythonPackageComponents=PythonPackageComponents.of(ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(Paths.get(CxxDescriptionEnhancer.getDefaultSharedLibrarySoname(target,cxxPlatform)),new BuildTargetSourcePath(sharedRule.getBuildTarget())),ImmutableSet.<SourcePath>of(),Optional.<Boolean>absent());
  assertEquals(expectedPythonPackageComponents,rule.getPythonPackageComponents(cxxPlatform));
}",0.9972432192085372
53188,"@Test public void staticLinkage(){
  BuildRuleResolver ruleResolver=new BuildRuleResolver();
  SourcePathResolver pathResolver=new SourcePathResolver(ruleResolver);
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  BuildRuleParams params=BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
  CxxPlatform cxxPlatform=DefaultCxxPlatforms.build(new CxxBuckConfig(new FakeBuckConfig()));
  BuildTarget staticPicLibraryTarget=BuildTarget.builder(params.getBuildTarget()).addFlavors(cxxPlatform.getFlavor(),CxxDescriptionEnhancer.STATIC_PIC_FLAVOR).build();
  ruleResolver.addToIndex(new FakeBuildRule(BuildRuleParamsFactory.createTrivialBuildRuleParams(staticPicLibraryTarget),pathResolver));
  CxxLibrary cxxLibrary=new CxxLibrary(params,ruleResolver,pathResolver,Predicates.<CxxPlatform>alwaysFalse(),Functions.constant(ImmutableMultimap.<CxxSource.Type,String>of()),Functions.constant(ImmutableList.<String>of()),Optional.<Pattern>absent(),Functions.constant(ImmutableSet.<Path>of()),CxxLibrary.Linkage.STATIC,false,Optional.<String>absent(),ImmutableSortedSet.<BuildTarget>of());
  assertThat(cxxLibrary.getSharedLibraries(cxxPlatform).entrySet(),Matchers.empty());
  assertThat(cxxLibrary.getPythonPackageComponents(cxxPlatform).getNativeLibraries().entrySet(),Matchers.empty());
  NativeLinkableInput expectedSharedNativeLinkableInput=NativeLinkableInput.of(ImmutableList.<SourcePath>of(new BuildTargetSourcePath(staticPicLibraryTarget)),ImmutableList.of(CxxDescriptionEnhancer.getStaticLibraryPath(target,cxxPlatform.getFlavor(),CxxSourceRuleFactory.PicType.PIC).toString()),ImmutableSet.<Path>of());
  assertEquals(expectedSharedNativeLinkableInput,cxxLibrary.getNativeLinkableInput(cxxPlatform,Linker.LinkableDepType.SHARED));
}","@Test public void staticLinkage(){
  BuildRuleResolver ruleResolver=new BuildRuleResolver();
  SourcePathResolver pathResolver=new SourcePathResolver(ruleResolver);
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  BuildRuleParams params=BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
  CxxPlatform cxxPlatform=DefaultCxxPlatforms.build(new CxxBuckConfig(new FakeBuckConfig()));
  BuildTarget staticPicLibraryTarget=BuildTarget.builder(params.getBuildTarget()).addFlavors(cxxPlatform.getFlavor(),CxxDescriptionEnhancer.STATIC_PIC_FLAVOR).build();
  ruleResolver.addToIndex(new FakeBuildRule(BuildRuleParamsFactory.createTrivialBuildRuleParams(staticPicLibraryTarget),pathResolver));
  CxxLibrary cxxLibrary=new CxxLibrary(params,ruleResolver,pathResolver,Predicates.<CxxPlatform>alwaysFalse(),Functions.constant(ImmutableMultimap.<CxxSource.Type,String>of()),Functions.constant(ImmutableList.<String>of()),Optional.<Pattern>absent(),Functions.constant(ImmutableSet.<Path>of()),NativeLinkable.Linkage.STATIC,false,Optional.<String>absent(),ImmutableSortedSet.<BuildTarget>of());
  assertThat(cxxLibrary.getSharedLibraries(cxxPlatform).entrySet(),Matchers.empty());
  assertThat(cxxLibrary.getPythonPackageComponents(cxxPlatform).getNativeLibraries().entrySet(),Matchers.empty());
  NativeLinkableInput expectedSharedNativeLinkableInput=NativeLinkableInput.of(ImmutableList.<SourcePath>of(new BuildTargetSourcePath(staticPicLibraryTarget)),ImmutableList.of(CxxDescriptionEnhancer.getStaticLibraryPath(target,cxxPlatform.getFlavor(),CxxSourceRuleFactory.PicType.PIC).toString()),ImmutableSet.<Path>of());
  assertEquals(expectedSharedNativeLinkableInput,cxxLibrary.getNativeLinkableInput(cxxPlatform,Linker.LinkableDepType.SHARED));
}",0.9932088285229204
53189,"@Override public Optional<Linker.LinkableDepType> getPreferredLinkage(CxxPlatform cxxPlatform){
  return Optional.absent();
}","@Override public NativeLinkable.Linkage getPreferredLinkage(CxxPlatform cxxPlatform){
  return Linkage.ANY;
}",0.7863247863247863
53190,"@Test public void createBuildRuleNativeLinkableDep(){
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  BuildRuleResolver resolver=new BuildRuleResolver();
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  CxxPlatform cxxPlatform=CxxPythonExtensionBuilder.createDefaultPlatform();
  final BuildRule sharedLibraryDep=createFakeBuildRule(""String_Node_Str"",pathResolver);
  final Path sharedLibraryOutput=Paths.get(""String_Node_Str"");
  final String sharedLibrarySoname=""String_Node_Str"";
  BuildTarget depTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  BuildRuleParams depParams=BuildRuleParamsFactory.createTrivialBuildRuleParams(depTarget);
  AbstractCxxLibrary dep=new AbstractCxxLibrary(depParams,pathResolver){
    @Override public CxxPreprocessorInput getCxxPreprocessorInput(    CxxPlatform cxxPlatform,    HeaderVisibility headerVisibility){
      return CxxPreprocessorInput.EMPTY;
    }
    @Override public ImmutableMap<BuildTarget,CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(    CxxPlatform cxxPlatform,    HeaderVisibility headerVisibility){
      return ImmutableMap.of(getBuildTarget(),getCxxPreprocessorInput(cxxPlatform,headerVisibility));
    }
    @Override public NativeLinkableInput getNativeLinkableInput(    CxxPlatform cxxPlatform,    Linker.LinkableDepType type){
      return type == Linker.LinkableDepType.STATIC ? NativeLinkableInput.of(ImmutableList.<SourcePath>of(),ImmutableList.<String>of(),ImmutableSet.<Path>of()) : NativeLinkableInput.of(ImmutableList.<SourcePath>of(new BuildTargetSourcePath(sharedLibraryDep.getBuildTarget(),sharedLibraryOutput)),ImmutableList.of(sharedLibraryOutput.toString()),ImmutableSet.<Path>of());
    }
    @Override public Optional<Linker.LinkableDepType> getPreferredLinkage(    CxxPlatform cxxPlatform){
      return Optional.absent();
    }
    @Override public PythonPackageComponents getPythonPackageComponents(    CxxPlatform cxxPlatform){
      return PythonPackageComponents.of(ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(Paths.get(sharedLibrarySoname),new PathSourcePath(getProjectFilesystem(),sharedLibraryOutput)),ImmutableSet.<SourcePath>of(),Optional.<Boolean>absent());
    }
    @Override public Iterable<AndroidPackageable> getRequiredPackageables(){
      return ImmutableList.of();
    }
    @Override public void addToCollector(    AndroidPackageableCollector collector){
    }
    @Override public ImmutableMap<String,SourcePath> getSharedLibraries(    CxxPlatform cxxPlatform){
      return ImmutableMap.of();
    }
    @Override public boolean isTestedBy(    BuildTarget buildTarget){
      return false;
    }
  }
;
  resolver.addAllToIndex(ImmutableList.of(sharedLibraryDep,dep));
  GenruleBuilder pyDepBuilder=GenruleBuilder.newGenruleBuilder(PYTHON_DEP_TARGET).setOut(""String_Node_Str"");
  pyDepBuilder.build(resolver);
  CxxPythonExtensionBuilder extensionBuilder=(CxxPythonExtensionBuilder)getBuilder(target).setDeps(ImmutableSortedSet.of(depTarget));
  CxxPythonExtensionDescription desc=(CxxPythonExtensionDescription)extensionBuilder.build().getDescription();
  CxxPythonExtension extension=(CxxPythonExtension)extensionBuilder.build(resolver,new FakeProjectFilesystem(),TargetGraphFactory.newInstance(extensionBuilder.build(),pyDepBuilder.build(),GenruleBuilder.newGenruleBuilder(depTarget).build()));
  extension.getPythonPackageComponents(cxxPlatform);
  BuildRule rule=resolver.getRule(desc.getExtensionTarget(target,cxxPlatform.getFlavor()));
  assertEquals(ImmutableSortedSet.of(sharedLibraryDep),rule.getDeps());
}","@Test public void createBuildRuleNativeLinkableDep(){
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  BuildRuleResolver resolver=new BuildRuleResolver();
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  CxxPlatform cxxPlatform=CxxPythonExtensionBuilder.createDefaultPlatform();
  final BuildRule sharedLibraryDep=createFakeBuildRule(""String_Node_Str"",pathResolver);
  final Path sharedLibraryOutput=Paths.get(""String_Node_Str"");
  final String sharedLibrarySoname=""String_Node_Str"";
  BuildTarget depTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  BuildRuleParams depParams=BuildRuleParamsFactory.createTrivialBuildRuleParams(depTarget);
  AbstractCxxLibrary dep=new AbstractCxxLibrary(depParams,pathResolver){
    @Override public CxxPreprocessorInput getCxxPreprocessorInput(    CxxPlatform cxxPlatform,    HeaderVisibility headerVisibility){
      return CxxPreprocessorInput.EMPTY;
    }
    @Override public ImmutableMap<BuildTarget,CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(    CxxPlatform cxxPlatform,    HeaderVisibility headerVisibility){
      return ImmutableMap.of(getBuildTarget(),getCxxPreprocessorInput(cxxPlatform,headerVisibility));
    }
    @Override public NativeLinkableInput getNativeLinkableInput(    CxxPlatform cxxPlatform,    Linker.LinkableDepType type){
      return type == Linker.LinkableDepType.STATIC ? NativeLinkableInput.of(ImmutableList.<SourcePath>of(),ImmutableList.<String>of(),ImmutableSet.<Path>of()) : NativeLinkableInput.of(ImmutableList.<SourcePath>of(new BuildTargetSourcePath(sharedLibraryDep.getBuildTarget(),sharedLibraryOutput)),ImmutableList.of(sharedLibraryOutput.toString()),ImmutableSet.<Path>of());
    }
    @Override public NativeLinkable.Linkage getPreferredLinkage(    CxxPlatform cxxPlatform){
      return Linkage.ANY;
    }
    @Override public PythonPackageComponents getPythonPackageComponents(    CxxPlatform cxxPlatform){
      return PythonPackageComponents.of(ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(Paths.get(sharedLibrarySoname),new PathSourcePath(getProjectFilesystem(),sharedLibraryOutput)),ImmutableSet.<SourcePath>of(),Optional.<Boolean>absent());
    }
    @Override public Iterable<AndroidPackageable> getRequiredPackageables(){
      return ImmutableList.of();
    }
    @Override public void addToCollector(    AndroidPackageableCollector collector){
    }
    @Override public ImmutableMap<String,SourcePath> getSharedLibraries(    CxxPlatform cxxPlatform){
      return ImmutableMap.of();
    }
    @Override public boolean isTestedBy(    BuildTarget buildTarget){
      return false;
    }
  }
;
  resolver.addAllToIndex(ImmutableList.of(sharedLibraryDep,dep));
  GenruleBuilder pyDepBuilder=GenruleBuilder.newGenruleBuilder(PYTHON_DEP_TARGET).setOut(""String_Node_Str"");
  pyDepBuilder.build(resolver);
  CxxPythonExtensionBuilder extensionBuilder=(CxxPythonExtensionBuilder)getBuilder(target).setDeps(ImmutableSortedSet.of(depTarget));
  CxxPythonExtensionDescription desc=(CxxPythonExtensionDescription)extensionBuilder.build().getDescription();
  CxxPythonExtension extension=(CxxPythonExtension)extensionBuilder.build(resolver,new FakeProjectFilesystem(),TargetGraphFactory.newInstance(extensionBuilder.build(),pyDepBuilder.build(),GenruleBuilder.newGenruleBuilder(depTarget).build()));
  extension.getPythonPackageComponents(cxxPlatform);
  BuildRule rule=resolver.getRule(desc.getExtensionTarget(target,cxxPlatform.getFlavor()));
  assertEquals(ImmutableSortedSet.of(sharedLibraryDep),rule.getDeps());
}",0.9914647577092512
53191,"@Override public Optional<Linker.LinkableDepType> getPreferredLinkage(CxxPlatform cxxPlatform){
  return Optional.absent();
}","@Override public NativeLinkable.Linkage getPreferredLinkage(CxxPlatform cxxPlatform){
  return Linkage.ANY;
}",0.7863247863247863
53192,"@Override public Optional<Linker.LinkableDepType> getPreferredLinkage(CxxPlatform cxxPlatform){
  return Optional.absent();
}","@Override public NativeLinkable.Linkage getPreferredLinkage(CxxPlatform cxxPlatform){
  return Linkage.ANY;
}",0.7863247863247863
53193,"/** 
 * Consider the following graph of C/C++ library dependencies of a python binary rule.  In this case we dynamically link all C/C++ library deps except for ones that request static linkage via the `force_static` parameter (e.g. library `C` in this example): Python Binary | | A (shared) / \ /   \ /     \ /       \ B (shared)   ... /    \ /      \ /      ... C (static) \ \ \ \ D (shared) Handling this force static dep is tricky -- we need to make sure we *only* statically link it into the shared lib `B` and that it does *not* contribute to the link line formed for `A`. What's more, we need to make sure `D` still contributes to the link for `A`.
 */
@Test public void doNotPullInStaticLibsAcrossSharedLibs(){
  SourcePathResolver resolver=new SourcePathResolver(new BuildRuleResolver());
  BuildRule d=new FakeNativeLinkable(""String_Node_Str"",resolver,NativeLinkableInput.builder().addArgs(""String_Node_Str"").build(),Optional.<Linker.LinkableDepType>absent(),ImmutableMap.<String,SourcePath>of());
  BuildRule c=new FakeNativeLinkable(""String_Node_Str"",resolver,NativeLinkableInput.builder().addArgs(""String_Node_Str"").build(),Optional.of(Linker.LinkableDepType.STATIC),ImmutableMap.<String,SourcePath>of(),d);
  BuildRule b=new FakeNativeLinkable(""String_Node_Str"",resolver,NativeLinkableInput.builder().addArgs(""String_Node_Str"").build(),Optional.<Linker.LinkableDepType>absent(),ImmutableMap.<String,SourcePath>of(),c);
  BuildRule a=new FakeNativeLinkable(""String_Node_Str"",resolver,NativeLinkableInput.builder().addArgs(""String_Node_Str"").build(),Optional.<Linker.LinkableDepType>absent(),ImmutableMap.<String,SourcePath>of(),b);
  NativeLinkableInput inputForTop=NativeLinkables.getTransitiveNativeLinkableInput(CxxPlatformUtils.DEFAULT_PLATFORM,ImmutableList.of(a),Linker.LinkableDepType.SHARED,false);
  assertThat(inputForTop.getArgs(),Matchers.containsInAnyOrder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertThat(inputForTop.getArgs(),Matchers.not(Matchers.contains(""String_Node_Str"")));
  NativeLinkableInput inputForB=NativeLinkables.getTransitiveNativeLinkableInput(CxxPlatformUtils.DEFAULT_PLATFORM,ImmutableList.of(c),Linker.LinkableDepType.SHARED,false);
  assertThat(inputForB.getArgs(),Matchers.containsInAnyOrder(""String_Node_Str"",""String_Node_Str""));
}","/** 
 * Consider the following graph of C/C++ library dependencies of a python binary rule.  In this case we dynamically link all C/C++ library deps except for ones that request static linkage via the `force_static` parameter (e.g. library `C` in this example): Python Binary | | A (shared) / \ /   \ /     \ /       \ B (shared)   ... /    \ /      \ /      ... C (static) \ \ \ \ D (shared) Handling this force static dep is tricky -- we need to make sure we *only* statically link it into the shared lib `B` and that it does *not* contribute to the link line formed for `A`. What's more, we need to make sure `D` still contributes to the link for `A`.
 */
@Test public void doNotPullInStaticLibsAcrossSharedLibs(){
  SourcePathResolver resolver=new SourcePathResolver(new BuildRuleResolver());
  BuildRule d=new FakeNativeLinkable(""String_Node_Str"",resolver,NativeLinkableInput.builder().addArgs(""String_Node_Str"").build(),NativeLinkable.Linkage.ANY,ImmutableMap.<String,SourcePath>of());
  BuildRule c=new FakeNativeLinkable(""String_Node_Str"",resolver,NativeLinkableInput.builder().addArgs(""String_Node_Str"").build(),NativeLinkable.Linkage.STATIC,ImmutableMap.<String,SourcePath>of(),d);
  BuildRule b=new FakeNativeLinkable(""String_Node_Str"",resolver,NativeLinkableInput.builder().addArgs(""String_Node_Str"").build(),NativeLinkable.Linkage.ANY,ImmutableMap.<String,SourcePath>of(),c);
  BuildRule a=new FakeNativeLinkable(""String_Node_Str"",resolver,NativeLinkableInput.builder().addArgs(""String_Node_Str"").build(),NativeLinkable.Linkage.ANY,ImmutableMap.<String,SourcePath>of(),b);
  NativeLinkableInput inputForTop=NativeLinkables.getTransitiveNativeLinkableInput(CxxPlatformUtils.DEFAULT_PLATFORM,ImmutableList.of(a),Linker.LinkableDepType.SHARED,false);
  assertThat(inputForTop.getArgs(),Matchers.containsInAnyOrder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertThat(inputForTop.getArgs(),Matchers.not(Matchers.contains(""String_Node_Str"")));
  NativeLinkableInput inputForB=NativeLinkables.getTransitiveNativeLinkableInput(CxxPlatformUtils.DEFAULT_PLATFORM,ImmutableList.of(c),Linker.LinkableDepType.SHARED,false);
  assertThat(inputForB.getArgs(),Matchers.containsInAnyOrder(""String_Node_Str"",""String_Node_Str""));
}",0.943661971830986
53194,"public FakeNativeLinkable(String target,SourcePathResolver resolver,NativeLinkableInput nativeLinkableInput,Optional<Linker.LinkableDepType> preferredLinkage,ImmutableMap<String,SourcePath> sharedLibraries,BuildRule... deps){
  super(target,resolver,deps);
  this.nativeLinkableInput=nativeLinkableInput;
  this.preferredLinkage=preferredLinkage;
  this.sharedLibraries=sharedLibraries;
}","public FakeNativeLinkable(String target,SourcePathResolver resolver,NativeLinkableInput nativeLinkableInput,NativeLinkable.Linkage preferredLinkage,ImmutableMap<String,SourcePath> sharedLibraries,BuildRule... deps){
  super(target,resolver,deps);
  this.nativeLinkableInput=nativeLinkableInput;
  this.preferredLinkage=preferredLinkage;
  this.sharedLibraries=sharedLibraries;
}",0.929503916449086
53195,"@Override public Optional<Linker.LinkableDepType> getPreferredLinkage(CxxPlatform cxxPlatform){
  return preferredLinkage;
}","@Override public NativeLinkable.Linkage getPreferredLinkage(CxxPlatform cxxPlatform){
  return preferredLinkage;
}",0.8739495798319328
53196,"@Test public void gatherTransitiveSharedLibraries(){
  SourcePathResolver resolver=new SourcePathResolver(new BuildRuleResolver());
  BuildRule c=new FakeNativeLinkable(""String_Node_Str"",resolver,NativeLinkableInput.builder().build(),Optional.<Linker.LinkableDepType>absent(),ImmutableMap.<String,SourcePath>of(""String_Node_Str"",new TestSourcePath(""String_Node_Str"")));
  BuildRule b=new FakeNativeLinkable(""String_Node_Str"",resolver,NativeLinkableInput.builder().build(),Optional.of(Linker.LinkableDepType.STATIC),ImmutableMap.<String,SourcePath>of(""String_Node_Str"",new TestSourcePath(""String_Node_Str"")),c);
  BuildRule a=new FakeNativeLinkable(""String_Node_Str"",resolver,NativeLinkableInput.builder().build(),Optional.<Linker.LinkableDepType>absent(),ImmutableMap.<String,SourcePath>of(""String_Node_Str"",new TestSourcePath(""String_Node_Str"")),b);
  ImmutableSortedMap<String,SourcePath> sharedLibs=NativeLinkables.getTransitiveSharedLibraries(CxxPlatformUtils.DEFAULT_PLATFORM,ImmutableList.of(a),Linker.LinkableDepType.SHARED,Predicates.instanceOf(NativeLinkable.class));
  assertThat(sharedLibs,Matchers.equalTo(ImmutableSortedMap.<String,SourcePath>of(""String_Node_Str"",new TestSourcePath(""String_Node_Str""),""String_Node_Str"",new TestSourcePath(""String_Node_Str""))));
}","@Test public void gatherTransitiveSharedLibraries(){
  SourcePathResolver resolver=new SourcePathResolver(new BuildRuleResolver());
  BuildRule c=new FakeNativeLinkable(""String_Node_Str"",resolver,NativeLinkableInput.builder().build(),NativeLinkable.Linkage.ANY,ImmutableMap.<String,SourcePath>of(""String_Node_Str"",new TestSourcePath(""String_Node_Str"")));
  BuildRule b=new FakeNativeLinkable(""String_Node_Str"",resolver,NativeLinkableInput.builder().build(),NativeLinkable.Linkage.STATIC,ImmutableMap.<String,SourcePath>of(""String_Node_Str"",new TestSourcePath(""String_Node_Str"")),c);
  BuildRule a=new FakeNativeLinkable(""String_Node_Str"",resolver,NativeLinkableInput.builder().build(),NativeLinkable.Linkage.ANY,ImmutableMap.<String,SourcePath>of(""String_Node_Str"",new TestSourcePath(""String_Node_Str"")),b);
  ImmutableSortedMap<String,SourcePath> sharedLibs=NativeLinkables.getTransitiveSharedLibraries(CxxPlatformUtils.DEFAULT_PLATFORM,ImmutableList.of(a),Linker.LinkableDepType.SHARED,Predicates.instanceOf(NativeLinkable.class));
  assertThat(sharedLibs,Matchers.equalTo(ImmutableSortedMap.<String,SourcePath>of(""String_Node_Str"",new TestSourcePath(""String_Node_Str""),""String_Node_Str"",new TestSourcePath(""String_Node_Str""))));
}",0.9246711837385412
53197,"@Test public void testThatInputChangesCauseRuleKeyChanges(){
  SourcePathResolver pathResolver=new SourcePathResolver(new BuildRuleResolver());
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  BuildRuleParams params=BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
  RuleKeyBuilderFactory ruleKeyBuilderFactory=new DefaultRuleKeyBuilderFactory(FakeFileHashCache.createFromStrings(ImmutableMap.of(""String_Node_Str"",Strings.repeat(""String_Node_Str"",40),""String_Node_Str"",Strings.repeat(""String_Node_Str"",40),""String_Node_Str"",Strings.repeat(""String_Node_Str"",40))),pathResolver);
  RuleKey defaultRuleKey=generateRuleKey(ruleKeyBuilderFactory,new Lex(params,pathResolver,DEFAULT_LEX,DEFAULT_FLAGS,DEFAULT_OUTPUT_SOURCE,DEFAULT_OUTPUT_HEADER,DEFAULT_INPUT));
  RuleKey lexChange=generateRuleKey(ruleKeyBuilderFactory,new Lex(params,pathResolver,new HashedFileTool(Paths.get(""String_Node_Str"")),DEFAULT_FLAGS,DEFAULT_OUTPUT_SOURCE,DEFAULT_OUTPUT_HEADER,DEFAULT_INPUT));
  assertNotEquals(defaultRuleKey,lexChange);
  RuleKey flagsChange=generateRuleKey(ruleKeyBuilderFactory,new Lex(params,pathResolver,DEFAULT_LEX,ImmutableList.of(""String_Node_Str""),DEFAULT_OUTPUT_SOURCE,DEFAULT_OUTPUT_HEADER,DEFAULT_INPUT));
  assertNotEquals(defaultRuleKey,flagsChange);
  RuleKey outputSourceChange=generateRuleKey(ruleKeyBuilderFactory,new Lex(params,pathResolver,DEFAULT_LEX,DEFAULT_FLAGS,Paths.get(""String_Node_Str""),DEFAULT_OUTPUT_HEADER,DEFAULT_INPUT));
  assertNotEquals(defaultRuleKey,outputSourceChange);
  RuleKey outputHeaderChange=generateRuleKey(ruleKeyBuilderFactory,new Lex(params,pathResolver,DEFAULT_LEX,DEFAULT_FLAGS,DEFAULT_OUTPUT_SOURCE,Paths.get(""String_Node_Str""),DEFAULT_INPUT));
  assertNotEquals(defaultRuleKey,outputHeaderChange);
  RuleKey inputChange=generateRuleKey(ruleKeyBuilderFactory,new Lex(params,pathResolver,DEFAULT_LEX,DEFAULT_FLAGS,DEFAULT_OUTPUT_SOURCE,DEFAULT_OUTPUT_HEADER,new TestSourcePath(""String_Node_Str"")));
  assertNotEquals(defaultRuleKey,inputChange);
}","@Test public void testThatInputChangesCauseRuleKeyChanges(){
  SourcePathResolver pathResolver=new SourcePathResolver(new BuildRuleResolver());
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  BuildRuleParams params=BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
  FakeFileHashCache hashCache=FakeFileHashCache.createFromStrings(ImmutableMap.of(""String_Node_Str"",Strings.repeat(""String_Node_Str"",40),""String_Node_Str"",Strings.repeat(""String_Node_Str"",40)));
  RuleKeyBuilderFactory ruleKeyBuilderFactory=new DefaultRuleKeyBuilderFactory(hashCache,pathResolver);
  RuleKey defaultRuleKey=generateRuleKey(ruleKeyBuilderFactory,new Lex(params,pathResolver,DEFAULT_LEX,DEFAULT_FLAGS,DEFAULT_OUTPUT_SOURCE,DEFAULT_OUTPUT_HEADER,DEFAULT_INPUT));
  RuleKey lexChange=generateRuleKey(new DefaultRuleKeyBuilderFactory(FakeFileHashCache.createFromStrings(ImmutableMap.of(""String_Node_Str"",Strings.repeat(""String_Node_Str"",40),""String_Node_Str"",Strings.repeat(""String_Node_Str"",40))),pathResolver),new Lex(params,pathResolver,DEFAULT_LEX,DEFAULT_FLAGS,DEFAULT_OUTPUT_SOURCE,DEFAULT_OUTPUT_HEADER,DEFAULT_INPUT));
  assertNotEquals(defaultRuleKey,lexChange);
  RuleKey flagsChange=generateRuleKey(ruleKeyBuilderFactory,new Lex(params,pathResolver,DEFAULT_LEX,ImmutableList.of(""String_Node_Str""),DEFAULT_OUTPUT_SOURCE,DEFAULT_OUTPUT_HEADER,DEFAULT_INPUT));
  assertNotEquals(defaultRuleKey,flagsChange);
  RuleKey outputSourceChange=generateRuleKey(ruleKeyBuilderFactory,new Lex(params,pathResolver,DEFAULT_LEX,DEFAULT_FLAGS,Paths.get(""String_Node_Str""),DEFAULT_OUTPUT_HEADER,DEFAULT_INPUT));
  assertNotEquals(defaultRuleKey,outputSourceChange);
  RuleKey outputHeaderChange=generateRuleKey(ruleKeyBuilderFactory,new Lex(params,pathResolver,DEFAULT_LEX,DEFAULT_FLAGS,DEFAULT_OUTPUT_SOURCE,Paths.get(""String_Node_Str""),DEFAULT_INPUT));
  assertNotEquals(defaultRuleKey,outputHeaderChange);
  RuleKey inputChange=generateRuleKey(new DefaultRuleKeyBuilderFactory(FakeFileHashCache.createFromStrings(ImmutableMap.of(""String_Node_Str"",Strings.repeat(""String_Node_Str"",40),""String_Node_Str"",Strings.repeat(""String_Node_Str"",40))),pathResolver),new Lex(params,pathResolver,DEFAULT_LEX,DEFAULT_FLAGS,DEFAULT_OUTPUT_SOURCE,DEFAULT_OUTPUT_HEADER,DEFAULT_INPUT));
  assertNotEquals(defaultRuleKey,inputChange);
}",0.5416953824948312
53198,"private CacheResult tryToFetchArtifactFromBuildCacheAndOverlayOnTopOfProjectFilesystem(BuildRule rule,RuleKey ruleKey,BuildInfoRecorder buildInfoRecorder,ArtifactCache artifactCache,ProjectFilesystem filesystem,BuildContext buildContext) throws InterruptedException {
  File zipFile;
  try {
    zipFile=File.createTempFile(""String_Node_Str"" + MoreFiles.sanitize(rule.getBuildTarget().getShortName()),""String_Node_Str"");
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  CacheResult cacheResult=buildInfoRecorder.fetchArtifactForBuildable(ruleKey,zipFile,artifactCache);
  if (!cacheResult.getType().isSuccess()) {
    try {
      Files.delete(zipFile.toPath());
    }
 catch (    IOException e) {
      LOG.warn(e,""String_Node_Str"",zipFile);
    }
    return cacheResult;
  }
  buildContext.getEventBus().post(ArtifactCacheEvent.started(ArtifactCacheEvent.Operation.DECOMPRESS,ImmutableSet.of(ruleKey)));
  try {
    Unzip.extractZipFile(zipFile.toPath().toAbsolutePath(),filesystem,Unzip.ExistingFileMode.OVERWRITE_AND_CLEAN_DIRECTORIES);
    Files.delete(zipFile.toPath());
    if (cacheResult.getType() == CacheResult.Type.HIT) {
      Path metadataDir=BuildInfo.getPathToMetadataDirectory(rule.getBuildTarget());
      for (      Map.Entry<String,String> ent : cacheResult.getMetadata().entrySet()) {
        Path dest=metadataDir.resolve(ent.getKey());
        filesystem.createParentDirs(dest);
        filesystem.writeContentsToPath(ent.getValue(),dest);
      }
    }
  }
 catch (  IOException e) {
    buildContext.getEventBus().post(ConsoleEvent.warning(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ rule.getBuildTarget(),zipFile.getAbsolutePath(),Throwables.getStackTraceAsString(e)));
    return CacheResult.miss();
  }
 finally {
    buildContext.getEventBus().post(ArtifactCacheEvent.finished(ArtifactCacheEvent.Operation.DECOMPRESS,ImmutableSet.of(rule.getRuleKey())));
  }
  return cacheResult;
}","private CacheResult tryToFetchArtifactFromBuildCacheAndOverlayOnTopOfProjectFilesystem(BuildRule rule,RuleKey ruleKey,BuildInfoRecorder buildInfoRecorder,ArtifactCache artifactCache,ProjectFilesystem filesystem,BuildContext buildContext) throws InterruptedException {
  File zipFile;
  try {
    zipFile=File.createTempFile(""String_Node_Str"" + MoreFiles.sanitize(rule.getBuildTarget().getShortName()),""String_Node_Str"");
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  CacheResult cacheResult=buildInfoRecorder.fetchArtifactForBuildable(ruleKey,zipFile,artifactCache);
  if (!cacheResult.getType().isSuccess()) {
    try {
      Files.delete(zipFile.toPath());
    }
 catch (    IOException e) {
      LOG.warn(e,""String_Node_Str"",zipFile);
    }
    return cacheResult;
  }
  buildContext.getEventBus().post(ArtifactCacheEvent.started(ArtifactCacheEvent.Operation.DECOMPRESS,ImmutableSet.of(ruleKey)));
  try {
    ImmutableList<Path> unpacked=Unzip.extractZipFile(zipFile.toPath().toAbsolutePath(),filesystem,Unzip.ExistingFileMode.OVERWRITE_AND_CLEAN_DIRECTORIES);
    Files.delete(zipFile.toPath());
    if (cacheResult.getType() == CacheResult.Type.HIT) {
      Path metadataDir=BuildInfo.getPathToMetadataDirectory(rule.getBuildTarget());
      for (      Map.Entry<String,String> ent : cacheResult.getMetadata().entrySet()) {
        Path dest=metadataDir.resolve(ent.getKey());
        filesystem.createParentDirs(dest);
        filesystem.writeContentsToPath(ent.getValue(),dest);
      }
      for (      Path input : unpacked) {
        buildInfoRecorder.recordArtifact(input);
      }
    }
  }
 catch (  IOException e) {
    buildContext.getEventBus().post(ConsoleEvent.warning(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ rule.getBuildTarget(),zipFile.getAbsolutePath(),Throwables.getStackTraceAsString(e)));
    return CacheResult.miss();
  }
 finally {
    buildContext.getEventBus().post(ArtifactCacheEvent.finished(ArtifactCacheEvent.Operation.DECOMPRESS,ImmutableSet.of(rule.getRuleKey())));
  }
  return cacheResult;
}",0.9681908548707754
53199,"public static ImmutableList<Path> extractZipFile(Path zipFile,Path destination,ExistingFileMode existingFileMode) throws IOException {
  Files.createDirectories(destination);
  return extractZipFile(zipFile,new ProjectFilesystem(destination),existingFileMode);
}","public static ImmutableList<Path> extractZipFile(Path zipFile,final Path destination,ExistingFileMode existingFileMode) throws IOException {
  Files.createDirectories(destination);
  return FluentIterable.from(extractZipFile(zipFile,new ProjectFilesystem(destination),existingFileMode)).transform(new Function<Path,Path>(){
    @Override public Path apply(    Path input){
      return destination.resolve(input).toAbsolutePath();
    }
  }
).toList();
}",0.7318435754189944
53200,"@Test public void inputBasedRuleKeyCacheHitAvoidsBuildingLocally() throws Exception {
  FakeProjectFilesystem filesystem=new FakeProjectFilesystem();
  InMemoryArtifactCache cache=new InMemoryArtifactCache();
  BuildContext buildContext=FakeBuildContext.newBuilder(filesystem).setArtifactCache(cache).setJavaPackageFinder(new FakeJavaPackageFinder()).setActionGraph(new ActionGraph(ImmutableList.<BuildRule>of())).build();
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  RuleKey inputRuleKey=new RuleKey(""String_Node_Str"");
  BuildRuleParams params=new FakeBuildRuleParamsBuilder(target).setProjectFilesystem(filesystem).build();
  BuildRuleResolver resolver=new BuildRuleResolver();
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  final Path output=Paths.get(""String_Node_Str"");
  BuildRule rule=new InputRuleKeyBuildRule(params,pathResolver){
    @Override public ImmutableList<Step> getBuildSteps(    BuildContext context,    BuildableContext buildableContext){
      return ImmutableList.<Step>of(new AbstractExecutionStep(""String_Node_Str""){
        @Override public int execute(        ExecutionContext context){
          return 1;
        }
      }
);
    }
    @Override public Path getPathToOutput(){
      return output;
    }
  }
;
  File temp=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  writeEntriesToZip(temp,ImmutableMap.of(BuildInfo.getPathToMetadataDirectory(target).resolve(BuildInfo.METADATA_KEY_FOR_RULE_KEY).toString(),new RuleKey(""String_Node_Str"").toString(),BuildInfo.getPathToMetadataDirectory(target).resolve(BuildInfo.METADATA_KEY_FOR_INPUT_BASED_RULE_KEY).toString(),inputRuleKey.toString(),output.toString(),""String_Node_Str""));
  cache.store(ImmutableSet.of(inputRuleKey),ImmutableMap.<String,String>of(),temp);
  CachingBuildEngine cachingBuildEngine=new CachingBuildEngine(MoreExecutors.newDirectExecutorService(),CachingBuildEngine.BuildMode.SHALLOW,new FixedRuleKeyBuilderFactory(ImmutableMap.of(rule.getBuildTarget(),inputRuleKey)));
  BuildResult result=cachingBuildEngine.build(buildContext,rule).get();
  assertEquals(BuildRuleSuccessType.FETCHED_FROM_CACHE_INPUT_BASED,result.getSuccess());
  OnDiskBuildInfo onDiskBuildInfo=buildContext.createOnDiskBuildInfoFor(target);
  assertThat(onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_RULE_KEY),Matchers.equalTo(Optional.of(rule.getRuleKey())));
  assertThat(onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_INPUT_BASED_RULE_KEY),Matchers.equalTo(Optional.of(inputRuleKey)));
}","@Test public void inputBasedRuleKeyCacheHitAvoidsBuildingLocally() throws Exception {
  FakeProjectFilesystem filesystem=new FakeProjectFilesystem();
  InMemoryArtifactCache cache=new InMemoryArtifactCache();
  BuildContext buildContext=FakeBuildContext.newBuilder(filesystem).setArtifactCache(cache).setJavaPackageFinder(new FakeJavaPackageFinder()).setActionGraph(new ActionGraph(ImmutableList.<BuildRule>of())).build();
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  RuleKey inputRuleKey=new RuleKey(""String_Node_Str"");
  BuildRuleParams params=new FakeBuildRuleParamsBuilder(target).setProjectFilesystem(filesystem).build();
  BuildRuleResolver resolver=new BuildRuleResolver();
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  final Path output=Paths.get(""String_Node_Str"");
  BuildRule rule=new InputRuleKeyBuildRule(params,pathResolver){
    @Override public ImmutableList<Step> getBuildSteps(    BuildContext context,    BuildableContext buildableContext){
      return ImmutableList.<Step>of(new AbstractExecutionStep(""String_Node_Str""){
        @Override public int execute(        ExecutionContext context){
          return 1;
        }
      }
);
    }
    @Override public Path getPathToOutput(){
      return output;
    }
  }
;
  File artifact=tmp.newFile(""String_Node_Str"");
  writeEntriesToZip(artifact,ImmutableMap.of(output.toString(),""String_Node_Str""));
  cache.store(ImmutableSet.of(inputRuleKey),ImmutableMap.of(BuildInfo.METADATA_KEY_FOR_RULE_KEY,new RuleKey(""String_Node_Str"").toString(),BuildInfo.METADATA_KEY_FOR_INPUT_BASED_RULE_KEY,inputRuleKey.toString()),artifact);
  CachingBuildEngine cachingBuildEngine=new CachingBuildEngine(MoreExecutors.newDirectExecutorService(),CachingBuildEngine.BuildMode.SHALLOW,new FixedRuleKeyBuilderFactory(ImmutableMap.of(rule.getBuildTarget(),inputRuleKey)));
  BuildResult result=cachingBuildEngine.build(buildContext,rule).get();
  assertEquals(BuildRuleSuccessType.FETCHED_FROM_CACHE_INPUT_BASED,result.getSuccess());
  OnDiskBuildInfo onDiskBuildInfo=buildContext.createOnDiskBuildInfoFor(target);
  assertThat(onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_RULE_KEY),Matchers.equalTo(Optional.of(rule.getRuleKey())));
  assertThat(onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_INPUT_BASED_RULE_KEY),Matchers.equalTo(Optional.of(inputRuleKey)));
  File fetchedArtifact=tmp.newFile(""String_Node_Str"");
  assertThat(cache.fetch(rule.getRuleKey(),fetchedArtifact).getType(),Matchers.equalTo(CacheResult.Type.HIT));
  assertEquals(new ZipInspector(artifact).getZipFileEntries(),new ZipInspector(fetchedArtifact).getZipFileEntries());
  assertTrue(Files.equal(artifact,fetchedArtifact));
}",0.8570884871550903
53201,"private static void writeEntriesToZip(File file,ImmutableMap<String,String> entries) throws IOException {
  try (ZipOutputStream zip=new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(file)))){
    for (    Map.Entry<String,String> mapEntry : entries.entrySet()) {
      ZipEntry entry=new ZipEntry(mapEntry.getKey());
      zip.putNextEntry(entry);
      zip.write(mapEntry.getValue().getBytes());
      zip.closeEntry();
    }
  }
 }","private static void writeEntriesToZip(File file,ImmutableMap<String,String> entries) throws IOException {
  try (ZipOutputStream zip=new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(file)))){
    for (    Map.Entry<String,String> mapEntry : entries.entrySet()) {
      ZipEntry entry=new ZipEntry(mapEntry.getKey());
      entry.setTime(0);
      zip.putNextEntry(entry);
      zip.write(mapEntry.getValue().getBytes());
      zip.closeEntry();
    }
  }
 }",0.974025974025974
53202,"public void runComplete(ImmutableList.Builder<String> addTo,List<TestResults> completedResults){
  boolean isAllTestsPassed=true;
  boolean isAnyAssumptionViolated=false;
  ListMultimap<TestResults,TestCaseSummary> failingTests=ArrayListMultimap.create();
  int numFailures=0;
  for (  TestResults summary : completedResults) {
    if (!summary.isSuccess()) {
      isAllTestsPassed=false;
      numFailures+=summary.getFailureCount();
      failingTests.putAll(summary,summary.getFailures());
    }
    for (    TestCaseSummary testCaseSummary : summary.getTestCases()) {
      if (testCaseSummary.hasAssumptionViolations()) {
        isAnyAssumptionViolated=true;
        break;
      }
    }
  }
  if (completedResults.isEmpty()) {
    addTo.add(ansi.asHighlightedFailureText(""String_Node_Str""));
  }
 else   if (isAllTestsPassed) {
    if (isAnyAssumptionViolated) {
      addTo.add(ansi.asHighlightedWarningText(""String_Node_Str""));
    }
 else {
      addTo.add(ansi.asHighlightedSuccessText(""String_Node_Str""));
    }
  }
 else {
    addTo.add(ansi.asHighlightedFailureText(String.format(""String_Node_Str"",numFailures)));
    for (    TestResults results : failingTests.keySet()) {
      addTo.add(""String_Node_Str"" + results.getBuildTarget().getFullyQualifiedName());
      for (      TestCaseSummary summary : failingTests.get(results)) {
        addTo.add(summary.toString());
      }
    }
  }
}","public void runComplete(ImmutableList.Builder<String> addTo,List<TestResults> completedResults){
  boolean isAllTestsPassed=true;
  boolean isAnyAssumptionViolated=false;
  ListMultimap<TestResults,TestCaseSummary> failingTests=ArrayListMultimap.create();
  int numFailures=0;
  for (  TestResults summary : completedResults) {
    if (!summary.isSuccess()) {
      isAllTestsPassed=false;
      numFailures+=summary.getFailureCount();
      failingTests.putAll(summary,summary.getFailures());
    }
    for (    TestCaseSummary testCaseSummary : summary.getTestCases()) {
      if (testCaseSummary.hasAssumptionViolations()) {
        isAnyAssumptionViolated=true;
        break;
      }
    }
  }
  if (completedResults.isEmpty()) {
    addTo.add(ansi.asHighlightedFailureText(""String_Node_Str""));
  }
 else   if (isAllTestsPassed) {
    if (isAnyAssumptionViolated) {
      addTo.add(ansi.asHighlightedWarningText(""String_Node_Str""));
    }
 else {
      addTo.add(ansi.asHighlightedSuccessText(""String_Node_Str""));
    }
  }
 else {
    addTo.add(ansi.asHighlightedFailureText(String.format(""String_Node_Str"",numFailures,numFailures == 1 ? ""String_Node_Str"" : ""String_Node_Str"")));
    for (    TestResults results : failingTests.keySet()) {
      addTo.add(""String_Node_Str"" + results.getBuildTarget().getFullyQualifiedName());
      for (      TestCaseSummary summary : failingTests.get(results)) {
        addTo.add(summary.toString());
      }
    }
  }
}",0.9236667828511675
53203,"public <T extends Enum<T>>Optional<T> getEnum(String section,String field,Class<T> clazz){
  Optional<String> value=getValue(section,field);
  if (!value.isPresent()) {
    return Optional.absent();
  }
  try {
    return Optional.of(Enum.valueOf(clazz,value.get().toUpperCase(Locale.ROOT)));
  }
 catch (  IllegalArgumentException e) {
    throw new HumanReadableException(""String_Node_Str"",section,field,clazz.getEnumConstants(),value.get());
  }
}","public <T extends Enum<T>>Optional<T> getEnum(String section,String field,Class<T> clazz){
  Optional<String> value=getValue(section,field);
  if (!value.isPresent()) {
    return Optional.absent();
  }
  try {
    return Optional.of(Enum.valueOf(clazz,value.get().toUpperCase(Locale.ROOT)));
  }
 catch (  IllegalArgumentException e) {
    throw new HumanReadableException(""String_Node_Str"",section,field,Joiner.on(""String_Node_Str"").join(clazz.getEnumConstants()),value.get());
  }
}",0.962566844919786
53204,"@SuppressWarnings(""String_Node_Str"") @Override public ImmutableList<Step> getBuildSteps(BuildContext context,BuildableContext buildableContext){
  ImmutableList.Builder<Step> steps=ImmutableList.builder();
  Path signedApkPath=getSignedApkPath();
  DexFilesInfo dexFilesInfo=addFinalDxSteps(context,buildableContext,steps);
  AndroidPackageableCollection packageableCollection=enhancementResult.getPackageableCollection();
  ImmutableSet<Path> nativeLibraryDirectories=ImmutableSet.of();
  if (!ExopackageMode.enabledForNativeLibraries(exopackageModes) && enhancementResult.getCopyNativeLibraries().isPresent()) {
    nativeLibraryDirectories=ImmutableSet.of(enhancementResult.getCopyNativeLibraries().get().getPathToNativeLibsDir());
  }
  ImmutableSet<Path> nativeLibraryAsAssetDirectories;
  if (!packageableCollection.getNativeLibAssetsDirectories().isEmpty()) {
    Path pathForNativeLibsAsAssets=getPathForNativeLibsAsAssets();
    Path libSubdirectory=pathForNativeLibsAsAssets.resolve(""String_Node_Str"").resolve(""String_Node_Str"");
    steps.add(new MakeCleanDirectoryStep(libSubdirectory));
    for (    SourcePath nativeLibDir : packageableCollection.getNativeLibAssetsDirectories()) {
      CopyNativeLibraries.copyNativeLibrary(getResolver().getPath(nativeLibDir),libSubdirectory,cpuFilters,steps);
    }
    nativeLibraryAsAssetDirectories=ImmutableSet.of(pathForNativeLibsAsAssets);
  }
 else {
    nativeLibraryAsAssetDirectories=ImmutableSet.of();
  }
  ImmutableSet.Builder<Path> zipFiles=ImmutableSet.builder();
  Optional<PackageStringAssets> packageStringAssets=enhancementResult.getPackageStringAssets();
  if (packageStringAssets.isPresent()) {
    final Path pathToStringAssetsZip=packageStringAssets.get().getPathToStringAssetsZip();
    zipFiles.add(pathToStringAssetsZip);
  }
  if (ExopackageMode.enabledForNativeLibraries(exopackageModes)) {
    String fakeNativeLibraryBundle=System.getProperty(""String_Node_Str"");
    if (fakeNativeLibraryBundle == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    zipFiles.add(Paths.get(fakeNativeLibraryBundle));
  }
  ImmutableSet<Path> allAssetDirectories=ImmutableSet.<Path>builder().addAll(nativeLibraryAsAssetDirectories).addAll(dexFilesInfo.secondaryDexDirs).build();
  ApkBuilderStep apkBuilderCommand=new ApkBuilderStep(enhancementResult.getAaptPackageResources().getResourceApkPath(),getSignedApkPath(),dexFilesInfo.primaryDexPath,allAssetDirectories,nativeLibraryDirectories,zipFiles.build(),FluentIterable.from(packageableCollection.getPathsToThirdPartyJars()).transform(getResolver().getPathFunction()).toSet(),keystore.getPathToStore(),keystore.getPathToPropertiesFile(),false);
  steps.add(apkBuilderCommand);
  Path apkToAlign;
  if (this.isCompressResources()) {
    Path compressedApkPath=getCompressedResourcesApkPath();
    apkToAlign=compressedApkPath;
    RepackZipEntriesStep arscComp=new RepackZipEntriesStep(signedApkPath,compressedApkPath,ImmutableSet.of(""String_Node_Str""));
    steps.add(arscComp);
  }
 else {
    apkToAlign=signedApkPath;
  }
  Path apkPath=getApkPath();
  ZipalignStep zipalign=new ZipalignStep(apkToAlign,apkPath);
  steps.add(zipalign);
  EchoStep success=new EchoStep(String.format(""String_Node_Str"",getBuildTarget().getFullyQualifiedName(),apkPath));
  steps.add(success);
  buildableContext.recordArtifact(getApkPath());
  return steps.build();
}","@SuppressWarnings(""String_Node_Str"") @Override public ImmutableList<Step> getBuildSteps(BuildContext context,BuildableContext buildableContext){
  ImmutableList.Builder<Step> steps=ImmutableList.builder();
  steps.add(new MkdirStep(getManifestPath().getParent()));
  steps.add(CopyStep.forFile(enhancementResult.getAaptPackageResources().getAndroidManifestXml(),getManifestPath()));
  buildableContext.recordArtifact(getManifestPath());
  Path signedApkPath=getSignedApkPath();
  DexFilesInfo dexFilesInfo=addFinalDxSteps(context,buildableContext,steps);
  AndroidPackageableCollection packageableCollection=enhancementResult.getPackageableCollection();
  ImmutableSet<Path> nativeLibraryDirectories=ImmutableSet.of();
  if (!ExopackageMode.enabledForNativeLibraries(exopackageModes) && enhancementResult.getCopyNativeLibraries().isPresent()) {
    nativeLibraryDirectories=ImmutableSet.of(enhancementResult.getCopyNativeLibraries().get().getPathToNativeLibsDir());
  }
  ImmutableSet<Path> nativeLibraryAsAssetDirectories;
  if (!packageableCollection.getNativeLibAssetsDirectories().isEmpty()) {
    Path pathForNativeLibsAsAssets=getPathForNativeLibsAsAssets();
    Path libSubdirectory=pathForNativeLibsAsAssets.resolve(""String_Node_Str"").resolve(""String_Node_Str"");
    steps.add(new MakeCleanDirectoryStep(libSubdirectory));
    for (    SourcePath nativeLibDir : packageableCollection.getNativeLibAssetsDirectories()) {
      CopyNativeLibraries.copyNativeLibrary(getResolver().getPath(nativeLibDir),libSubdirectory,cpuFilters,steps);
    }
    nativeLibraryAsAssetDirectories=ImmutableSet.of(pathForNativeLibsAsAssets);
  }
 else {
    nativeLibraryAsAssetDirectories=ImmutableSet.of();
  }
  ImmutableSet.Builder<Path> zipFiles=ImmutableSet.builder();
  Optional<PackageStringAssets> packageStringAssets=enhancementResult.getPackageStringAssets();
  if (packageStringAssets.isPresent()) {
    final Path pathToStringAssetsZip=packageStringAssets.get().getPathToStringAssetsZip();
    zipFiles.add(pathToStringAssetsZip);
  }
  if (ExopackageMode.enabledForNativeLibraries(exopackageModes)) {
    String fakeNativeLibraryBundle=System.getProperty(""String_Node_Str"");
    if (fakeNativeLibraryBundle == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    zipFiles.add(Paths.get(fakeNativeLibraryBundle));
  }
  ImmutableSet<Path> allAssetDirectories=ImmutableSet.<Path>builder().addAll(nativeLibraryAsAssetDirectories).addAll(dexFilesInfo.secondaryDexDirs).build();
  ApkBuilderStep apkBuilderCommand=new ApkBuilderStep(enhancementResult.getAaptPackageResources().getResourceApkPath(),getSignedApkPath(),dexFilesInfo.primaryDexPath,allAssetDirectories,nativeLibraryDirectories,zipFiles.build(),FluentIterable.from(packageableCollection.getPathsToThirdPartyJars()).transform(getResolver().getPathFunction()).toSet(),keystore.getPathToStore(),keystore.getPathToPropertiesFile(),false);
  steps.add(apkBuilderCommand);
  Path apkToAlign;
  if (this.isCompressResources()) {
    Path compressedApkPath=getCompressedResourcesApkPath();
    apkToAlign=compressedApkPath;
    RepackZipEntriesStep arscComp=new RepackZipEntriesStep(signedApkPath,compressedApkPath,ImmutableSet.of(""String_Node_Str""));
    steps.add(arscComp);
  }
 else {
    apkToAlign=signedApkPath;
  }
  Path apkPath=getApkPath();
  ZipalignStep zipalign=new ZipalignStep(apkToAlign,apkPath);
  steps.add(zipalign);
  EchoStep success=new EchoStep(String.format(""String_Node_Str"",getBuildTarget().getFullyQualifiedName(),apkPath));
  steps.add(success);
  buildableContext.recordArtifact(getApkPath());
  return steps.build();
}",0.9670047136123412
53205,"@Override public Path getManifestPath(){
  return enhancementResult.getAaptPackageResources().getAndroidManifestXml();
}","@Override public Path getManifestPath(){
  return BuildTargets.getGenPath(getBuildTarget(),""String_Node_Str"");
}",0.603448275862069
53206,"@VisibleForTesting ImmutableList<Step> buildSteps(){
  ImmutableList.Builder<Step> allSteps=ImmutableList.builder();
  if (resources.isEmpty()) {
    return allSteps.build();
  }
  String targetPackageDir=javaPackageFinder.findJavaPackage(target);
  for (  SourcePath rawResource : resources) {
    final Path pathToResource=resolver.getPath(rawResource);
    String resource=MorePaths.pathWithUnixSeparators(pathToResource);
    Matcher matcher;
    if ((matcher=GENERATED_FILE_PATTERN.matcher(resource)).matches()) {
      resource=matcher.group(1);
    }
    Path javaPackageAsPath=javaPackageFinder.findJavaPackageFolder(Paths.get(resource));
    Path relativeSymlinkPath;
    if (""String_Node_Str"".equals(javaPackageAsPath.toString())) {
      relativeSymlinkPath=pathToResource.getFileName();
    }
 else {
      int lastIndex=resource.lastIndexOf(MorePaths.pathWithUnixSeparators(javaPackageAsPath));
      if (lastIndex < 0) {
        Preconditions.checkState(rawResource instanceof BuildTargetSourcePath,""String_Node_Str"",pathToResource,javaPackageAsPath);
        relativeSymlinkPath=Paths.get(String.format(""String_Node_Str"",targetPackageDir,targetPackageDir.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"",resolver.getPath(rawResource).getFileName()));
      }
 else {
        relativeSymlinkPath=Paths.get(resource.substring(lastIndex));
      }
    }
    Path target=outputDirectory.resolve(relativeSymlinkPath);
    MkdirAndSymlinkFileStep link=new MkdirAndSymlinkFileStep(pathToResource,target);
    allSteps.add(link);
  }
  return allSteps.build();
}","@VisibleForTesting ImmutableList<Step> buildSteps(){
  ImmutableList.Builder<Step> allSteps=ImmutableList.builder();
  if (resources.isEmpty()) {
    return allSteps.build();
  }
  String targetPackageDir=javaPackageFinder.findJavaPackage(target);
  for (  SourcePath rawResource : resources) {
    final Path pathToResource=resolver.getPath(rawResource);
    String resource=MorePaths.pathWithUnixSeparators(pathToResource);
    Matcher matcher;
    if ((matcher=GENERATED_FILE_PATTERN.matcher(resource)).matches()) {
      resource=matcher.group(1);
    }
    Path javaPackageAsPath=javaPackageFinder.findJavaPackageFolder(Paths.get(resource));
    Path relativeSymlinkPath;
    if (""String_Node_Str"".equals(javaPackageAsPath.toString())) {
      relativeSymlinkPath=pathToResource.getFileName();
    }
 else {
      int lastIndex=resource.lastIndexOf(MorePaths.pathWithUnixSeparatorsAndTrailingSlash(javaPackageAsPath));
      if (lastIndex < 0) {
        Preconditions.checkState(rawResource instanceof BuildTargetSourcePath,""String_Node_Str"",pathToResource,javaPackageAsPath);
        relativeSymlinkPath=Paths.get(String.format(""String_Node_Str"",targetPackageDir,targetPackageDir.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"",resolver.getPath(rawResource).getFileName()));
      }
 else {
        relativeSymlinkPath=Paths.get(resource.substring(lastIndex));
      }
    }
    Path target=outputDirectory.resolve(relativeSymlinkPath);
    MkdirAndSymlinkFileStep link=new MkdirAndSymlinkFileStep(pathToResource,target);
    allSteps.add(link);
  }
  return allSteps.build();
}",0.9949302915082384
53207,"@Nullable @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public TargetNode<?> get(BuildTarget buildTarget) throws IOException, InterruptedException {
  TargetNode<?> toReturn=memoizedTargetNodes.get(buildTarget);
  if (toReturn != null) {
    return toReturn;
  }
  Repository targetRepo=repositoryFactory.getRepositoryByCanonicalName(buildTarget.getRepository());
  Path buildFilePath;
  try {
    buildFilePath=targetRepo.getAbsolutePathToBuildFile(buildTarget);
  }
 catch (  Repository.MissingBuildFileException e) {
    throw new HumanReadableException(e);
  }
  UnflavoredBuildTarget unflavored=buildTarget.getUnflavoredBuildTarget();
  List<Map<String,Object>> rules=state.getRawRules(buildFilePath);
  for (  Map<String,Object> map : rules) {
    if (!buildTarget.getShortName().equals(map.get(""String_Node_Str""))) {
      continue;
    }
    BuildRuleType buildRuleType=parseBuildRuleTypeFromRawRule(map);
    targetsToFile.put(BuildTarget.of(unflavored),normalize(Paths.get((String)map.get(""String_Node_Str""))).resolve(buildFileName).toAbsolutePath());
    Description<?> description=repository.getDescription(buildRuleType);
    if (description == null) {
      throw new HumanReadableException(""String_Node_Str"",buildRuleType,UnflavoredBuildTarget.BUILD_TARGET_PREFIX,unflavored.getBasePath().resolve(buildFileName));
    }
    if (buildTarget.isFlavored()) {
      if (description instanceof Flavored) {
        if (!((Flavored)description).hasFlavors(ImmutableSet.copyOf(buildTarget.getFlavors()))) {
          throw new HumanReadableException(""String_Node_Str"",buildTarget,UnflavoredBuildTarget.BUILD_TARGET_PREFIX,buildTarget.getBasePath().resolve(buildFileName));
        }
      }
 else {
        LOG.warn(""String_Node_Str"" + ""String_Node_Str"",buildTarget.getUnflavoredBuildTarget(),buildRuleType,buildTarget.getFlavors());
        throw new HumanReadableException(""String_Node_Str"",buildTarget.getUnflavoredBuildTarget(),buildRuleType,buildTarget.getFlavors());
      }
    }
    this.pathsToBuildTargets.put(buildFilePath,buildTarget);
    BuildRuleFactoryParams factoryParams=new BuildRuleFactoryParams(targetRepo.getFilesystem(),targetRepo.getBuildTargetParser(),buildTarget,ruleKeyBuilderFactory,buildFileTreeCache.get(),enforceBuckPackageBoundary);
    Object constructorArg=description.createUnpopulatedConstructorArg();
    TargetNode<?> targetNode;
    try {
      ImmutableSet.Builder<BuildTarget> declaredDeps=ImmutableSet.builder();
      ImmutableSet.Builder<BuildTargetPattern> visibilityPatterns=ImmutableSet.builder();
      marshaller.populate(targetRepo.getFilesystem(),factoryParams,constructorArg,declaredDeps,visibilityPatterns,map);
      targetNode=new TargetNode(description,constructorArg,factoryParams,declaredDeps.build(),visibilityPatterns.build());
    }
 catch (    NoSuchBuildTargetException|TargetNode.InvalidSourcePathInputException e) {
      throw new HumanReadableException(e);
    }
catch (    ConstructorArgMarshalException e) {
      throw new HumanReadableException(""String_Node_Str"",buildTarget,e.getMessage());
    }
    Map<Path,Path> newSymlinksEncountered=Maps.newHashMap();
    if (inputFilesUnderSymlink(targetNode.getInputs(),targetRepo.getFilesystem(),symlinkExistenceCache,newSymlinksEncountered)) {
      LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",targetNode.getBuildTarget(),newSymlinksEncountered);
      buildInputPathsUnderSymlink.add(buildFilePath);
    }
    TargetNode<?> existingTargetNode=memoizedTargetNodes.put(buildTarget,targetNode);
    if (existingTargetNode != null) {
      throw new HumanReadableException(""String_Node_Str"" + unflavored);
    }
  }
  return memoizedTargetNodes.get(buildTarget);
}","@Nullable @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public TargetNode<?> get(BuildTarget buildTarget) throws IOException, InterruptedException {
  TargetNode<?> toReturn=memoizedTargetNodes.get(buildTarget);
  if (toReturn != null) {
    return toReturn;
  }
  Repository targetRepo=repositoryFactory.getRepositoryByCanonicalName(buildTarget.getRepository());
  Path buildFilePath;
  try {
    buildFilePath=targetRepo.getAbsolutePathToBuildFile(buildTarget);
  }
 catch (  Repository.MissingBuildFileException e) {
    throw new HumanReadableException(e);
  }
  UnflavoredBuildTarget unflavored=buildTarget.getUnflavoredBuildTarget();
  List<Map<String,Object>> rules=state.getRawRules(buildFilePath);
  for (  Map<String,Object> map : rules) {
    if (!buildTarget.getShortName().equals(map.get(""String_Node_Str""))) {
      continue;
    }
    BuildRuleType buildRuleType=parseBuildRuleTypeFromRawRule(map);
    targetsToFile.put(BuildTarget.of(unflavored),normalize(Paths.get((String)map.get(""String_Node_Str""))).resolve(buildFileName).toAbsolutePath());
    Description<?> description=repository.getDescription(buildRuleType);
    if (description == null) {
      throw new HumanReadableException(""String_Node_Str"",buildRuleType,UnflavoredBuildTarget.BUILD_TARGET_PREFIX,MorePaths.pathWithUnixSeparators(unflavored.getBasePath().resolve(buildFileName)));
    }
    if (buildTarget.isFlavored()) {
      if (description instanceof Flavored) {
        if (!((Flavored)description).hasFlavors(ImmutableSet.copyOf(buildTarget.getFlavors()))) {
          throw new HumanReadableException(""String_Node_Str"",buildTarget,UnflavoredBuildTarget.BUILD_TARGET_PREFIX,MorePaths.pathWithUnixSeparators(buildTarget.getBasePath().resolve(buildFileName)));
        }
      }
 else {
        LOG.warn(""String_Node_Str"" + ""String_Node_Str"",buildTarget.getUnflavoredBuildTarget(),buildRuleType,buildTarget.getFlavors());
        throw new HumanReadableException(""String_Node_Str"",buildTarget.getUnflavoredBuildTarget(),buildRuleType,buildTarget.getFlavors());
      }
    }
    this.pathsToBuildTargets.put(buildFilePath,buildTarget);
    BuildRuleFactoryParams factoryParams=new BuildRuleFactoryParams(targetRepo.getFilesystem(),targetRepo.getBuildTargetParser(),buildTarget,ruleKeyBuilderFactory,buildFileTreeCache.get(),enforceBuckPackageBoundary);
    Object constructorArg=description.createUnpopulatedConstructorArg();
    TargetNode<?> targetNode;
    try {
      ImmutableSet.Builder<BuildTarget> declaredDeps=ImmutableSet.builder();
      ImmutableSet.Builder<BuildTargetPattern> visibilityPatterns=ImmutableSet.builder();
      marshaller.populate(targetRepo.getFilesystem(),factoryParams,constructorArg,declaredDeps,visibilityPatterns,map);
      targetNode=new TargetNode(description,constructorArg,factoryParams,declaredDeps.build(),visibilityPatterns.build());
    }
 catch (    NoSuchBuildTargetException|TargetNode.InvalidSourcePathInputException e) {
      throw new HumanReadableException(e);
    }
catch (    ConstructorArgMarshalException e) {
      throw new HumanReadableException(""String_Node_Str"",buildTarget,e.getMessage());
    }
    Map<Path,Path> newSymlinksEncountered=Maps.newHashMap();
    if (inputFilesUnderSymlink(targetNode.getInputs(),targetRepo.getFilesystem(),symlinkExistenceCache,newSymlinksEncountered)) {
      LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",targetNode.getBuildTarget(),newSymlinksEncountered);
      buildInputPathsUnderSymlink.add(buildFilePath);
    }
    TargetNode<?> existingTargetNode=memoizedTargetNodes.put(buildTarget,targetNode);
    if (existingTargetNode != null) {
      throw new HumanReadableException(""String_Node_Str"" + unflavored);
    }
  }
  return memoizedTargetNodes.get(buildTarget);
}",0.9909381663113006
53208,"/** 
 * Similar to   {@link #createZip(Collection,File)}, but also takes a list of additional files to write in the zip, including their contents, as a map.
 */
public void createZip(Collection<Path> pathsToIncludeInZip,File out,ImmutableMap<Path,String> additionalFileContents) throws IOException {
  Preconditions.checkState(!Iterables.isEmpty(pathsToIncludeInZip));
  try (CustomZipOutputStream zip=ZipOutputStreams.newOutputStream(out)){
    for (    Path path : pathsToIncludeInZip) {
      CustomZipEntry entry=new CustomZipEntry(path.toString());
      Path full=getPathForRelativePath(path);
      File file=full.toFile();
      if (file.canExecute()) {
        entry.setExternalAttributes(MorePosixFilePermissions.toMode(EnumSet.of(PosixFilePermission.OWNER_EXECUTE)) << 16);
      }
      zip.putNextEntry(entry);
      try (InputStream input=Files.newInputStream(getPathForRelativePath(path))){
        ByteStreams.copy(input,zip);
      }
       zip.closeEntry();
    }
    for (    Map.Entry<Path,String> fileContentsEntry : additionalFileContents.entrySet()) {
      CustomZipEntry entry=new CustomZipEntry(fileContentsEntry.getKey().toString());
      zip.putNextEntry(entry);
      try (InputStream stream=new ByteArrayInputStream(fileContentsEntry.getValue().getBytes(Charsets.UTF_8))){
        ByteStreams.copy(stream,zip);
      }
       zip.closeEntry();
    }
  }
 }","/** 
 * Similar to   {@link #createZip(Collection,File)}, but also takes a list of additional files to write in the zip, including their contents, as a map.
 */
public void createZip(Collection<Path> pathsToIncludeInZip,File out,ImmutableMap<Path,String> additionalFileContents) throws IOException {
  Preconditions.checkState(!Iterables.isEmpty(pathsToIncludeInZip));
  try (CustomZipOutputStream zip=ZipOutputStreams.newOutputStream(out)){
    for (    Path path : pathsToIncludeInZip) {
      Path full=getPathForRelativePath(path);
      File file=full.toFile();
      boolean isDirectory=isDirectory(full);
      String entryName=path.toString();
      if (isDirectory) {
        entryName+=""String_Node_Str"";
      }
      CustomZipEntry entry=new CustomZipEntry(entryName);
      if (file.canExecute()) {
        entry.setExternalAttributes(MorePosixFilePermissions.toMode(EnumSet.of(PosixFilePermission.OWNER_EXECUTE)) << 16);
      }
      zip.putNextEntry(entry);
      if (!isDirectory) {
        try (InputStream input=Files.newInputStream(getPathForRelativePath(path))){
          ByteStreams.copy(input,zip);
        }
       }
      zip.closeEntry();
    }
    for (    Map.Entry<Path,String> fileContentsEntry : additionalFileContents.entrySet()) {
      CustomZipEntry entry=new CustomZipEntry(fileContentsEntry.getKey().toString());
      zip.putNextEntry(entry);
      try (InputStream stream=new ByteArrayInputStream(fileContentsEntry.getValue().getBytes(Charsets.UTF_8))){
        ByteStreams.copy(stream,zip);
      }
       zip.closeEntry();
    }
  }
 }",0.8927125506072875
53209,"private List<Path> getEntries(final Path outputDirectory) throws IOException {
  final ImmutableList.Builder<Path> entries=ImmutableList.builder();
  DirectoryTraversal traversal=new DirectoryTraversal(projectFilesystem.getFileForRelativePath(outputDirectory)){
    @Override public void visit(    File file,    String relativePath) throws IOException {
      entries.add(outputDirectory.resolve(relativePath));
    }
  }
;
  directoryTraverser.traverse(traversal);
  return entries.build();
}","private List<Path> getEntries(final Path outputDirectory) throws IOException {
  final ImmutableList.Builder<Path> entries=ImmutableList.builder();
  DirectoryTraversal traversal=new DirectoryTraversal(projectFilesystem.getFileForRelativePath(outputDirectory)){
    @Override public void visit(    File file,    String relativePath) throws IOException {
      entries.add(outputDirectory.resolve(relativePath));
    }
    @Override public void visitDirectory(    File directory,    String relativePath) throws IOException {
      entries.add(outputDirectory.resolve(relativePath));
    }
  }
;
  directoryTraverser.traverse(traversal);
  return entries.build();
}",0.8529411764705882
53210,"/** 
 * Waits up to   {@code millis} milliseconds for the given process to finish.
 */
private void waitForTimeout(final Process process,long millis) throws InterruptedException {
  Thread waiter=new Thread(new Runnable(){
    @Override public void run(){
      try {
        process.waitFor();
      }
 catch (      InterruptedException e) {
      }
    }
  }
);
  waiter.join(millis);
  waiter.interrupt();
  waiter.join();
}","/** 
 * Waits up to   {@code millis} milliseconds for the given process to finish.
 */
private void waitForTimeout(final Process process,long millis) throws InterruptedException {
  Thread waiter=new Thread(new Runnable(){
    @Override public void run(){
      try {
        process.waitFor();
      }
 catch (      InterruptedException e) {
      }
    }
  }
);
  waiter.start();
  waiter.join(millis);
  waiter.interrupt();
  waiter.join();
}",0.9793577981651376
53211,"@Test public void spinningTestTimesOut() throws IOException {
  ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",temp);
  workspace.setUp();
  ProjectWorkspace.ProcessResult result=workspace.runBuckCommand(""String_Node_Str"",""String_Node_Str"");
  result.assertSpecialExitCode(""String_Node_Str"",42);
  String stderr=result.getStderr();
  assertTrue(stderr,stderr.contains(""String_Node_Str""));
}","@Test public void spinningTestTimesOut() throws IOException {
  ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",temp);
  workspace.setUp();
  workspace.writeContentsToPath(""String_Node_Str"",""String_Node_Str"");
  ProjectWorkspace.ProcessResult result=workspace.runBuckCommand(""String_Node_Str"",""String_Node_Str"");
  result.assertSpecialExitCode(""String_Node_Str"",42);
  String stderr=result.getStderr();
  assertTrue(stderr,stderr.contains(""String_Node_Str""));
}",0.9266247379454928
53212,"public FieldMirror(int access,String name,String desc,String signature,Object value){
  super(Opcodes.ASM5,access,name,desc,signature,value);
}","public FieldMirror(int access,String name,String desc,String signature,Object value){
  super(Opcodes.ASM5,access,name,desc,signature,value);
  this.key=name + desc + signature;
}",0.8881987577639752
53213,"@Override public int compareTo(FieldMirror o){
  return desc.compareTo(o.desc);
}","@Override public int compareTo(FieldMirror o){
  return key.compareTo(o.key);
}",0.9375
53214,"private void addAssetCatalogBuildPhase(PBXNativeTarget target,PBXGroup targetGroup,final Iterable<AppleAssetCatalog> assetCatalogs){
  PBXGroup resourcesGroup=targetGroup.getOrCreateChildGroupByName(""String_Node_Str"");
  ImmutableList.Builder<String> commonAssetCatalogsBuilder=ImmutableList.builder();
  ImmutableList.Builder<String> assetCatalogsToSplitIntoBundlesBuilder=ImmutableList.builder();
  for (  AppleAssetCatalog assetCatalog : assetCatalogs) {
    List<String> scriptArguments=Lists.newArrayList();
    for (    Path dir : assetCatalog.getDirs()) {
      resourcesGroup.getOrCreateFileReferenceBySourceTreePath(new SourceTreePath(PBXReference.SourceTree.SOURCE_ROOT,pathRelativizer.outputDirToRootRelative(dir)));
      Path pathRelativeToProjectRoot=MorePaths.relativize(outputDirectory,dir);
      LOG.debug(""String_Node_Str"",dir,outputDirectory,pathRelativeToProjectRoot);
      scriptArguments.add(""String_Node_Str"" + pathRelativeToProjectRoot.toString());
    }
    if (assetCatalog.getCopyToBundles()) {
      assetCatalogsToSplitIntoBundlesBuilder.addAll(scriptArguments);
    }
 else {
      commonAssetCatalogsBuilder.addAll(scriptArguments);
    }
  }
  ImmutableList<String> commonAssetCatalogs=commonAssetCatalogsBuilder.build();
  ImmutableList<String> assetCatalogsToSplitIntoBundles=assetCatalogsToSplitIntoBundlesBuilder.build();
  if (commonAssetCatalogs.size() == 0 && assetCatalogsToSplitIntoBundles.size() == 0) {
    return;
  }
  Path assetCatalogBuildPhaseScriptRelativeToProjectRoot;
  if (PATH_OVERRIDE_FOR_ASSET_CATALOG_BUILD_PHASE_SCRIPT != null) {
    assetCatalogBuildPhaseScriptRelativeToProjectRoot=pathRelativizer.outputDirToRootRelative(Paths.get(PATH_OVERRIDE_FOR_ASSET_CATALOG_BUILD_PHASE_SCRIPT));
  }
 else {
    shouldPlaceAssetCatalogCompiler=true;
    assetCatalogBuildPhaseScriptRelativeToProjectRoot=MorePaths.relativize(outputDirectory,placedAssetCatalogBuildPhaseScript);
  }
  String combinedAssetCatalogsToBeSplitIntoBundlesScriptArguments=Joiner.on(' ').join(assetCatalogsToSplitIntoBundles);
  String combinedCommonAssetCatalogsScriptArguments=Joiner.on(' ').join(commonAssetCatalogs);
  PBXShellScriptBuildPhase phase=new PBXShellScriptBuildPhase();
  StringBuilder scriptBuilder=new StringBuilder(""String_Node_Str"");
  if (commonAssetCatalogs.size() != 0) {
    scriptBuilder.append(""String_Node_Str"" + assetCatalogBuildPhaseScriptRelativeToProjectRoot.toString() + ""String_Node_Str""+ combinedCommonAssetCatalogsScriptArguments+ ""String_Node_Str"");
  }
  if (assetCatalogsToSplitIntoBundles.size() != 0) {
    scriptBuilder.append(""String_Node_Str"" + assetCatalogBuildPhaseScriptRelativeToProjectRoot.toString() + ""String_Node_Str""+ combinedAssetCatalogsToBeSplitIntoBundlesScriptArguments);
  }
  phase.setShellScript(scriptBuilder.toString());
  LOG.debug(""String_Node_Str"",phase);
  target.getBuildPhases().add(phase);
}","private void addAssetCatalogBuildPhase(PBXNativeTarget target,PBXGroup targetGroup,final Iterable<AppleAssetCatalog> assetCatalogs){
  PBXGroup resourcesGroup=targetGroup.getOrCreateChildGroupByName(""String_Node_Str"");
  ImmutableList.Builder<String> commonAssetCatalogsBuilder=ImmutableList.builder();
  ImmutableList.Builder<String> assetCatalogsToSplitIntoBundlesBuilder=ImmutableList.builder();
  for (  AppleAssetCatalog assetCatalog : assetCatalogs) {
    List<String> scriptArguments=Lists.newArrayList();
    for (    Path dir : assetCatalog.getDirs()) {
      Path pathRelativeToProjectRoot=pathRelativizer.outputDirToRootRelative(dir);
      resourcesGroup.getOrCreateFileReferenceBySourceTreePath(new SourceTreePath(PBXReference.SourceTree.SOURCE_ROOT,pathRelativeToProjectRoot));
      LOG.debug(""String_Node_Str"",dir,outputDirectory,pathRelativeToProjectRoot);
      scriptArguments.add(""String_Node_Str"" + pathRelativeToProjectRoot.toString());
    }
    if (assetCatalog.getCopyToBundles()) {
      assetCatalogsToSplitIntoBundlesBuilder.addAll(scriptArguments);
    }
 else {
      commonAssetCatalogsBuilder.addAll(scriptArguments);
    }
  }
  ImmutableList<String> commonAssetCatalogs=commonAssetCatalogsBuilder.build();
  ImmutableList<String> assetCatalogsToSplitIntoBundles=assetCatalogsToSplitIntoBundlesBuilder.build();
  if (commonAssetCatalogs.size() == 0 && assetCatalogsToSplitIntoBundles.size() == 0) {
    return;
  }
  Path assetCatalogBuildPhaseScriptRelativeToProjectRoot;
  if (PATH_OVERRIDE_FOR_ASSET_CATALOG_BUILD_PHASE_SCRIPT != null) {
    assetCatalogBuildPhaseScriptRelativeToProjectRoot=pathRelativizer.outputDirToRootRelative(Paths.get(PATH_OVERRIDE_FOR_ASSET_CATALOG_BUILD_PHASE_SCRIPT));
  }
 else {
    shouldPlaceAssetCatalogCompiler=true;
    assetCatalogBuildPhaseScriptRelativeToProjectRoot=MorePaths.relativize(outputDirectory,placedAssetCatalogBuildPhaseScript);
  }
  String combinedAssetCatalogsToBeSplitIntoBundlesScriptArguments=Joiner.on(' ').join(assetCatalogsToSplitIntoBundles);
  String combinedCommonAssetCatalogsScriptArguments=Joiner.on(' ').join(commonAssetCatalogs);
  PBXShellScriptBuildPhase phase=new PBXShellScriptBuildPhase();
  StringBuilder scriptBuilder=new StringBuilder(""String_Node_Str"");
  if (commonAssetCatalogs.size() != 0) {
    scriptBuilder.append(""String_Node_Str"" + assetCatalogBuildPhaseScriptRelativeToProjectRoot.toString() + ""String_Node_Str""+ combinedCommonAssetCatalogsScriptArguments+ ""String_Node_Str"");
  }
  if (assetCatalogsToSplitIntoBundles.size() != 0) {
    scriptBuilder.append(""String_Node_Str"" + assetCatalogBuildPhaseScriptRelativeToProjectRoot.toString() + ""String_Node_Str""+ combinedAssetCatalogsToBeSplitIntoBundlesScriptArguments);
  }
  phase.setShellScript(scriptBuilder.toString());
  LOG.debug(""String_Node_Str"",phase);
  target.getBuildPhases().add(phase);
}",0.9680444598819036
53215,"@Override public int execute(ExecutionContext context){
  ProjectFilesystem filesystem=context.getProjectFilesystem();
  final ImmutableSet.Builder<Path> executablesBuilder=ImmutableSet.builder();
  try {
    filesystem.walkRelativeFileTree(destinationDir,new SimpleFileVisitor<Path>(){
      @Override public FileVisitResult visitFile(      Path file,      BasicFileAttributes attrs) throws IOException {
        if (file.toString().endsWith(""String_Node_Str"")) {
          executablesBuilder.add(file);
        }
        return FileVisitResult.CONTINUE;
      }
    }
);
    for (    Path exePath : executablesBuilder.build()) {
      Path fakeSoPath=Paths.get(exePath.toString().replaceAll(""String_Node_Str"",""String_Node_Str""));
      filesystem.move(exePath,fakeSoPath);
    }
  }
 catch (  IOException e) {
    context.logError(e,""String_Node_Str"");
    return 1;
  }
  return 0;
}","@Override public int execute(ExecutionContext context){
  for (  Path path : classPathEntriesToDex) {
    Optional<ImmutableSortedMap<String,HashCode>> hashes=AccumulateClassNamesStep.calculateClassHashes(context,path);
    if (!hashes.isPresent()) {
      return 1;
    }
    builder.putAll(hashes.get());
  }
  return 0;
}",0.171900826446281
53216,"/** 
 * Adds steps to do the final dexing or dex merging before building the apk.
 */
private DexFilesInfo addFinalDxSteps(BuildContext context,ImmutableList<Path> resDirectories,BuildableContext buildableContext,ImmutableList.Builder<Step> steps){
  AndroidPackageableCollection packageableCollection=enhancementResult.getPackageableCollection();
  ImmutableSet<Path> classpathEntriesToDex;
  if (preprocessJavaClassesBash.isPresent()) {
    final Path preprocessJavaClassesInDir=getBinPath(""String_Node_Str"");
    final Path preprocessJavaClassesOutDir=getBinPath(""String_Node_Str"");
    steps.add(new MakeCleanDirectoryStep(preprocessJavaClassesInDir));
    steps.add(new MakeCleanDirectoryStep(preprocessJavaClassesOutDir));
    steps.add(new SymlinkFilesIntoDirectoryStep(context.getProjectRoot(),enhancementResult.getClasspathEntriesToDex(),preprocessJavaClassesInDir));
    classpathEntriesToDex=FluentIterable.from(enhancementResult.getClasspathEntriesToDex()).transform(new Function<Path,Path>(){
      @Override public Path apply(      Path classpathEntry){
        return preprocessJavaClassesOutDir.resolve(classpathEntry);
      }
    }
).toSet();
    AbstractGenruleStep.CommandString commandString=new AbstractGenruleStep.CommandString(Optional.<String>absent(),preprocessJavaClassesBash,Optional.<String>absent());
    steps.add(new AbstractGenruleStep(this.getBuildTarget(),commandString,context.getProjectRoot().resolve(preprocessJavaClassesInDir).toFile()){
      @Override protected void addEnvironmentVariables(      ExecutionContext context,      ImmutableMap.Builder<String,String> environmentVariablesBuilder){
        Function<Path,Path> aboslutifier=context.getProjectFilesystem().getAbsolutifier();
        environmentVariablesBuilder.put(""String_Node_Str"",aboslutifier.apply(preprocessJavaClassesInDir).toString());
        environmentVariablesBuilder.put(""String_Node_Str"",aboslutifier.apply(preprocessJavaClassesOutDir).toString());
        Optional<AndroidPlatformTarget> platformTarget=context.getAndroidPlatformTargetOptional();
        if (!platformTarget.isPresent()) {
          return;
        }
        String bootclasspath=Joiner.on(':').join(Iterables.transform(platformTarget.get().getBootclasspathEntries(),aboslutifier));
        environmentVariablesBuilder.put(""String_Node_Str"",bootclasspath);
      }
    }
);
  }
 else {
    classpathEntriesToDex=enhancementResult.getClasspathEntriesToDex();
  }
  if (packageType.isBuildWithObfuscation()) {
    classpathEntriesToDex=addProguardCommands(classpathEntriesToDex,packageableCollection.proguardConfigs,steps,resDirectories,buildableContext);
  }
  ImmutableSet.Builder<Path> secondaryDexDirectoriesBuilder=ImmutableSet.builder();
  Optional<PreDexMerge> preDexMerge=enhancementResult.getPreDexMerge();
  if (!preDexMerge.isPresent()) {
    steps.add(new MkdirStep(primaryDexPath.getParent()));
    addDexingSteps(classpathEntriesToDex,packageableCollection.classNamesToHashesSupplier,secondaryDexDirectoriesBuilder,steps,primaryDexPath);
  }
 else   if (!exopackage) {
    secondaryDexDirectoriesBuilder.addAll(preDexMerge.get().getSecondaryDexDirectories());
  }
  return new DexFilesInfo(primaryDexPath,secondaryDexDirectoriesBuilder.build());
}","/** 
 * Adds steps to do the final dexing or dex merging before building the apk.
 */
private DexFilesInfo addFinalDxSteps(BuildContext context,ImmutableList<Path> resDirectories,BuildableContext buildableContext,ImmutableList.Builder<Step> steps){
  AndroidPackageableCollection packageableCollection=enhancementResult.getPackageableCollection();
  ImmutableSet<Path> classpathEntriesToDex;
  if (preprocessJavaClassesBash.isPresent()) {
    final Path preprocessJavaClassesInDir=getBinPath(""String_Node_Str"");
    final Path preprocessJavaClassesOutDir=getBinPath(""String_Node_Str"");
    steps.add(new MakeCleanDirectoryStep(preprocessJavaClassesInDir));
    steps.add(new MakeCleanDirectoryStep(preprocessJavaClassesOutDir));
    steps.add(new SymlinkFilesIntoDirectoryStep(context.getProjectRoot(),enhancementResult.getClasspathEntriesToDex(),preprocessJavaClassesInDir));
    classpathEntriesToDex=FluentIterable.from(enhancementResult.getClasspathEntriesToDex()).transform(new Function<Path,Path>(){
      @Override public Path apply(      Path classpathEntry){
        return preprocessJavaClassesOutDir.resolve(classpathEntry);
      }
    }
).toSet();
    AbstractGenruleStep.CommandString commandString=new AbstractGenruleStep.CommandString(Optional.<String>absent(),preprocessJavaClassesBash,Optional.<String>absent());
    steps.add(new AbstractGenruleStep(this.getBuildTarget(),commandString,context.getProjectRoot().resolve(preprocessJavaClassesInDir).toFile()){
      @Override protected void addEnvironmentVariables(      ExecutionContext context,      ImmutableMap.Builder<String,String> environmentVariablesBuilder){
        Function<Path,Path> aboslutifier=context.getProjectFilesystem().getAbsolutifier();
        environmentVariablesBuilder.put(""String_Node_Str"",aboslutifier.apply(preprocessJavaClassesInDir).toString());
        environmentVariablesBuilder.put(""String_Node_Str"",aboslutifier.apply(preprocessJavaClassesOutDir).toString());
        Optional<AndroidPlatformTarget> platformTarget=context.getAndroidPlatformTargetOptional();
        if (!platformTarget.isPresent()) {
          return;
        }
        String bootclasspath=Joiner.on(':').join(Iterables.transform(platformTarget.get().getBootclasspathEntries(),aboslutifier));
        environmentVariablesBuilder.put(""String_Node_Str"",bootclasspath);
      }
    }
);
  }
 else {
    classpathEntriesToDex=enhancementResult.getClasspathEntriesToDex();
  }
  if (packageType.isBuildWithObfuscation()) {
    classpathEntriesToDex=addProguardCommands(classpathEntriesToDex,packageableCollection.proguardConfigs,steps,resDirectories,buildableContext);
  }
  Supplier<Map<String,HashCode>> classNamesToHashesSupplier;
  boolean classFilesHaveChanged=preprocessJavaClassesBash.isPresent() || packageType.isBuildWithObfuscation();
  if (classFilesHaveChanged) {
    classNamesToHashesSupplier=addAccumulateClassNamesStep(classpathEntriesToDex,steps);
  }
 else {
    classNamesToHashesSupplier=packageableCollection.classNamesToHashesSupplier;
  }
  ImmutableSet.Builder<Path> secondaryDexDirectoriesBuilder=ImmutableSet.builder();
  Optional<PreDexMerge> preDexMerge=enhancementResult.getPreDexMerge();
  if (!preDexMerge.isPresent()) {
    steps.add(new MkdirStep(primaryDexPath.getParent()));
    addDexingSteps(classpathEntriesToDex,classNamesToHashesSupplier,secondaryDexDirectoriesBuilder,steps,primaryDexPath);
  }
 else   if (!exopackage) {
    secondaryDexDirectoriesBuilder.addAll(preDexMerge.get().getSecondaryDexDirectories());
  }
  return new DexFilesInfo(primaryDexPath,secondaryDexDirectoriesBuilder.build());
}",0.8675719083077822
53217,"/** 
 * @return an Optional that will be absent if there was an error.
 */
private Optional<ImmutableSortedMap<String,HashCode>> calculateClassHashes(ExecutionContext context,Path path){
  final ImmutableSortedMap.Builder<String,HashCode> classNamesBuilder=ImmutableSortedMap.naturalOrder();
  ClasspathTraversal traversal=new ClasspathTraversal(Collections.singleton(path),context.getProjectFilesystem()){
    @Override public void visit(    final FileLike fileLike) throws IOException {
      if (!FileLikes.isClassFile(fileLike)) {
        return;
      }
      String key=FileLikes.getFileNameWithoutClassSuffix(fileLike);
      ByteSource input=new ByteSource(){
        @Override public InputStream openStream() throws IOException {
          return fileLike.getInput();
        }
      }
;
      HashCode value=input.hash(Hashing.sha1());
      classNamesBuilder.put(key,value);
    }
  }
;
  try {
    new DefaultClasspathTraverser().traverse(traversal);
  }
 catch (  IOException e) {
    context.logError(e,""String_Node_Str"",pathToJarOrClassesDirectory);
    return Optional.absent();
  }
  return Optional.of(classNamesBuilder.build());
}","/** 
 * @return an Optional that will be absent if there was an error.
 */
public static Optional<ImmutableSortedMap<String,HashCode>> calculateClassHashes(ExecutionContext context,Path path){
  final ImmutableSortedMap.Builder<String,HashCode> classNamesBuilder=ImmutableSortedMap.naturalOrder();
  ClasspathTraversal traversal=new ClasspathTraversal(Collections.singleton(path),context.getProjectFilesystem()){
    @Override public void visit(    final FileLike fileLike) throws IOException {
      if (!FileLikes.isClassFile(fileLike)) {
        return;
      }
      String key=FileLikes.getFileNameWithoutClassSuffix(fileLike);
      ByteSource input=new ByteSource(){
        @Override public InputStream openStream() throws IOException {
          return fileLike.getInput();
        }
      }
;
      HashCode value=input.hash(Hashing.sha1());
      classNamesBuilder.put(key,value);
    }
  }
;
  try {
    new DefaultClasspathTraverser().traverse(traversal);
  }
 catch (  IOException e) {
    context.logError(e,""String_Node_Str"",path);
    return Optional.absent();
  }
  return Optional.of(classNamesBuilder.build());
}",0.9311705392371766
53218,"private Builder(OCamlBuildContext context,OCamlBuckConfig config){
  this.context=Preconditions.checkNotNull(context);
  context.ocamlDepTool=config.getOCamlDepTool().or(DEFAULT_OCAML_DEP_TOOL);
  context.cCompiler=config.getCCompiler();
  context.ocamlCompiler=config.getOCamlCompiler().or(DEFAULT_OCAML_COMPILER);
  context.ocamlBytecodeCompiler=config.getOCamlBytecodeCompiler().or(DEFAULT_OCAML_BYTECODE_COMPILER);
  context.yaccCompiler=config.getYaccCompiler().or(DEFAULT_OCAML_YACC_COMPILER);
  context.lexCompiler=config.getLexCompiler().or(DEFAULT_OCAML_LEX_COMPILER);
}","private Builder(OCamlBuildContext context,OCamlBuckConfig config){
  this.context=Preconditions.checkNotNull(context);
  context.ocamlDepTool=config.getOCamlDepTool().or(DEFAULT_OCAML_DEP_TOOL);
  context.cCompiler=config.getCCompiler();
  context.cxxCompiler=config.getCxxCompiler();
  context.ocamlCompiler=config.getOCamlCompiler().or(DEFAULT_OCAML_COMPILER);
  context.ocamlBytecodeCompiler=config.getOCamlBytecodeCompiler().or(DEFAULT_OCAML_BYTECODE_COMPILER);
  context.yaccCompiler=config.getYaccCompiler().or(DEFAULT_OCAML_YACC_COMPILER);
  context.lexCompiler=config.getLexCompiler().or(DEFAULT_OCAML_LEX_COMPILER);
}",0.9609958506224068
53219,"private int executeLinking(ExecutionContext context,ImmutableList<String> linkerInputs) throws InterruptedException {
  OCamlLinkStep linkStep=new OCamlLinkStep(ocamlContext.getCCompiler(),ocamlContext.getOcamlCompiler(),ocamlContext.getOutput(),ocamlContext.getLinkableInput().getArgs(),linkerInputs,ocamlContext.getFlags(),ocamlContext.isLibrary(),false);
  return linkStep.execute(context);
}","private int executeLinking(ExecutionContext context,ImmutableList<String> linkerInputs) throws InterruptedException {
  OCamlLinkStep linkStep=new OCamlLinkStep(ocamlContext.getCxxCompiler(),ocamlContext.getOcamlCompiler(),ocamlContext.getOutput(),ocamlContext.getLinkableInput().getArgs(),linkerInputs,ocamlContext.getFlags(),ocamlContext.isLibrary(),false);
  return linkStep.execute(context);
}",0.9974747474747476
53220,"private int executeBytecodeLinking(ExecutionContext context,ImmutableList<String> linkerInputs) throws InterruptedException {
  OCamlLinkStep linkStep=new OCamlLinkStep(ocamlContext.getCCompiler(),ocamlContext.getOcamlBytecodeCompiler(),ocamlContext.getBytecodeOutput(),ocamlContext.getLinkableInput().getArgs(),linkerInputs,ocamlContext.getFlags(),ocamlContext.isLibrary(),true);
  return linkStep.execute(context);
}","private int executeBytecodeLinking(ExecutionContext context,ImmutableList<String> linkerInputs) throws InterruptedException {
  OCamlLinkStep linkStep=new OCamlLinkStep(ocamlContext.getCxxCompiler(),ocamlContext.getOcamlBytecodeCompiler(),ocamlContext.getBytecodeOutput(),ocamlContext.getLinkableInput().getArgs(),linkerInputs,ocamlContext.getFlags(),ocamlContext.isLibrary(),true);
  return linkStep.execute(context);
}",0.9976133651551312
53221,"public OCamlLinkStep(Path cCompiler,Path ocamlCompiler,Path output,ImmutableList<String> depInput,ImmutableList<String> input,ImmutableList<String> flags,boolean isLibrary,boolean isBytecode){
  this.isLibrary=isLibrary;
  this.isBytecode=isBytecode;
  this.ocamlCompiler=Preconditions.checkNotNull(ocamlCompiler);
  this.cCompiler=Preconditions.checkNotNull(cCompiler);
  this.flags=Preconditions.checkNotNull(flags);
  this.output=Preconditions.checkNotNull(output);
  this.depInput=Preconditions.checkNotNull(depInput);
  this.input=Preconditions.checkNotNull(input);
  ImmutableList.Builder<String> aAndOInputBuilder=ImmutableList.builder();
  ImmutableList.Builder<String> ocamlInputBuilder=ImmutableList.builder();
  for (  String linkInput : this.depInput) {
    if (linkInput.endsWith(OCamlCompilables.OCAML_O) || linkInput.endsWith(OCamlCompilables.OCAML_A)) {
      aAndOInputBuilder.add(linkInput);
    }
 else {
      if (!(isLibrary && linkInput.endsWith(OCamlCompilables.OCAML_CMXA))) {
        if (!isBytecode) {
          ocamlInputBuilder.add(linkInput);
        }
 else {
          String bytecodeLinkInput=linkInput.replaceAll(OCamlCompilables.OCAML_CMXA_REGEX,OCamlCompilables.OCAML_CMA);
          ocamlInputBuilder.add(bytecodeLinkInput);
        }
      }
    }
  }
  this.ocamlInput=ocamlInputBuilder.build();
  this.aAndOInput=aAndOInputBuilder.build().reverse();
}","public OCamlLinkStep(Path cxxCompiler,Path ocamlCompiler,Path output,ImmutableList<String> depInput,ImmutableList<String> input,ImmutableList<String> flags,boolean isLibrary,boolean isBytecode){
  this.isLibrary=isLibrary;
  this.isBytecode=isBytecode;
  this.ocamlCompiler=Preconditions.checkNotNull(ocamlCompiler);
  this.cxxCompiler=Preconditions.checkNotNull(cxxCompiler);
  this.flags=Preconditions.checkNotNull(flags);
  this.output=Preconditions.checkNotNull(output);
  this.depInput=Preconditions.checkNotNull(depInput);
  this.input=Preconditions.checkNotNull(input);
  ImmutableList.Builder<String> aAndOInputBuilder=ImmutableList.builder();
  ImmutableList.Builder<String> ocamlInputBuilder=ImmutableList.builder();
  for (  String linkInput : this.depInput) {
    if (linkInput.endsWith(OCamlCompilables.OCAML_O) || linkInput.endsWith(OCamlCompilables.OCAML_A)) {
      aAndOInputBuilder.add(linkInput);
    }
 else {
      if (!(isLibrary && linkInput.endsWith(OCamlCompilables.OCAML_CMXA))) {
        if (!isBytecode) {
          ocamlInputBuilder.add(linkInput);
        }
 else {
          String bytecodeLinkInput=linkInput.replaceAll(OCamlCompilables.OCAML_CMXA_REGEX,OCamlCompilables.OCAML_CMA);
          ocamlInputBuilder.add(bytecodeLinkInput);
        }
      }
    }
  }
  this.ocamlInput=ocamlInputBuilder.build();
  this.aAndOInput=aAndOInputBuilder.build().reverse();
}",0.9978463747307968
53222,"@Override protected ImmutableList<String> getShellCommandInternal(ExecutionContext context){
  return ImmutableList.<String>builder().add(ocamlCompiler.toString()).addAll(OCamlCompilables.DEFAULT_OCAML_FLAGS).add(""String_Node_Str"").add(cCompiler.toString()).addAll((isLibrary ? Optional.of(""String_Node_Str"") : Optional.<String>absent()).asSet()).addAll((!isLibrary && isBytecode ? Optional.of(""String_Node_Str"") : Optional.<String>absent()).asSet()).add(""String_Node_Str"",output.toString()).addAll(flags).addAll(this.ocamlInput).addAll(this.input).addAll(this.aAndOInput).build();
}","@Override protected ImmutableList<String> getShellCommandInternal(ExecutionContext context){
  return ImmutableList.<String>builder().add(ocamlCompiler.toString()).addAll(OCamlCompilables.DEFAULT_OCAML_FLAGS).add(""String_Node_Str"").add(cxxCompiler.toString()).addAll((isLibrary ? Optional.of(""String_Node_Str"") : Optional.<String>absent()).asSet()).addAll((!isLibrary && isBytecode ? Optional.of(""String_Node_Str"") : Optional.<String>absent()).asSet()).add(""String_Node_Str"",output.toString()).addAll(flags).addAll(this.ocamlInput).addAll(this.input).addAll(this.aAndOInput).build();
}",0.9982876712328768
53223,"@Override protected void actuallyClose() throws IOException {
  long currentOffset=0;
  for (  Map.Entry<File,EntryAccounting> mapEntry : entries.entrySet()) {
    EntryAccounting entry=mapEntry.getValue();
    entry.setOffset(currentOffset);
    currentOffset+=entry.writeLocalFileHeader(delegate);
    Files.copy(mapEntry.getKey().toPath(),delegate);
    currentOffset+=entry.close(delegate);
  }
  new CentralDirectory().writeCentralDirectory(delegate,currentOffset,entries.values());
  delegate.close();
  SimpleFileVisitor<Path> visitor=new SimpleFileVisitor<Path>(){
    @Override public FileVisitResult visitFile(    Path file,    BasicFileAttributes attrs) throws IOException {
      Files.delete(file);
      return FileVisitResult.CONTINUE;
    }
    @Override public FileVisitResult postVisitDirectory(    Path dir,    IOException exc) throws IOException {
      if (exc == null) {
        Files.delete(dir);
        return FileVisitResult.CONTINUE;
      }
      throw exc;
    }
  }
;
  Files.walkFileTree(scratchDir.toPath(),visitor);
}","@Override protected void actuallyClose() throws IOException {
  long currentOffset=0;
  for (  Map.Entry<File,EntryAccounting> mapEntry : entries.entrySet()) {
    EntryAccounting entry=mapEntry.getValue();
    entry.setOffset(currentOffset);
    currentOffset+=entry.writeLocalFileHeader(delegate);
    Files.copy(mapEntry.getKey().toPath(),delegate);
    long closeSize=entry.close(delegate);
    if (closeSize == 0) {
      currentOffset+=entry.getSize();
    }
 else {
      currentOffset+=closeSize;
    }
  }
  new CentralDirectory().writeCentralDirectory(delegate,currentOffset,entries.values());
  delegate.close();
  SimpleFileVisitor<Path> visitor=new SimpleFileVisitor<Path>(){
    @Override public FileVisitResult visitFile(    Path file,    BasicFileAttributes attrs) throws IOException {
      Files.delete(file);
      return FileVisitResult.CONTINUE;
    }
    @Override public FileVisitResult postVisitDirectory(    Path dir,    IOException exc) throws IOException {
      if (exc == null) {
        Files.delete(dir);
        return FileVisitResult.CONTINUE;
      }
      throw exc;
    }
  }
;
  Files.walkFileTree(scratchDir.toPath(),visitor);
}",0.934115523465704
53224,"@Override public FileVisitResult visitFile(Path file,BasicFileAttributes attributes) throws IOException {
  if (!paths.isEmpty() && !paths.contains(file)) {
    return FileVisitResult.CONTINUE;
  }
  Path relativePath=junkPaths ? file.getFileName() : baseDir.relativize(file);
  String entryName=MorePaths.pathWithUnixSeparators(relativePath);
  CustomZipEntry entry=new CustomZipEntry(entryName);
  entry.setTime(attributes.lastModifiedTime().toMillis());
  entry.setSize(attributes.size());
  entry.setCompressionLevel(compressionLevel);
  out.putNextEntry(entry);
  Files.copy(filesystem.resolve(file),out);
  out.closeEntry();
  return FileVisitResult.CONTINUE;
}","@Override public FileVisitResult visitFile(Path file,BasicFileAttributes attributes) throws IOException {
  if (!paths.isEmpty() && !paths.contains(file)) {
    return FileVisitResult.CONTINUE;
  }
  Path resolvedPath=filesystem.resolve(file);
  Path relativePath=junkPaths ? file.getFileName() : baseDir.relativize(file);
  String entryName=MorePaths.pathWithUnixSeparators(relativePath);
  CustomZipEntry entry=new CustomZipEntry(entryName);
  entry.setTime(attributes.lastModifiedTime().toMillis());
  entry.setCompressionLevel(compressionLevel);
  if (entry.getMethod() == ZipEntry.STORED) {
    entry.setSize(attributes.size());
    entry.setCompressedSize(attributes.size());
    entry.setCrc(com.google.common.io.Files.hash(resolvedPath.toFile(),Hashing.crc32()).padToLong());
  }
  out.putNextEntry(entry);
  Files.copy(resolvedPath,out);
  out.closeEntry();
  return FileVisitResult.CONTINUE;
}",0.7859872611464969
53225,"@Override public int execute(ExecutionContext context){
  final ProjectFilesystem filesystem=context.getProjectFilesystem();
  if (filesystem.exists(pathToZipFile)) {
    context.postEvent(ConsoleEvent.severe(""String_Node_Str"",pathToZipFile));
    return 1;
  }
  try (BufferedOutputStream baseOut=new BufferedOutputStream(filesystem.newFileOutputStream(pathToZipFile));final CustomZipOutputStream out=ZipOutputStreams.newOutputStream(baseOut,OVERWRITE_EXISTING)){
    final FileVisitor<Path> pathFileVisitor=new SimpleFileVisitor<Path>(){
      @Override public FileVisitResult visitFile(      Path file,      BasicFileAttributes attributes) throws IOException {
        if (!paths.isEmpty() && !paths.contains(file)) {
          return FileVisitResult.CONTINUE;
        }
        Path relativePath=junkPaths ? file.getFileName() : baseDir.relativize(file);
        String entryName=MorePaths.pathWithUnixSeparators(relativePath);
        CustomZipEntry entry=new CustomZipEntry(entryName);
        entry.setTime(attributes.lastModifiedTime().toMillis());
        entry.setSize(attributes.size());
        entry.setCompressionLevel(compressionLevel);
        out.putNextEntry(entry);
        Files.copy(filesystem.resolve(file),out);
        out.closeEntry();
        return FileVisitResult.CONTINUE;
      }
    }
;
    filesystem.walkRelativeFileTree(baseDir,pathFileVisitor);
  }
 catch (  IOException e) {
    context.logError(e,""String_Node_Str"",pathToZipFile);
    return 1;
  }
  return 0;
}","@Override public int execute(ExecutionContext context){
  final ProjectFilesystem filesystem=context.getProjectFilesystem();
  if (filesystem.exists(pathToZipFile)) {
    context.postEvent(ConsoleEvent.severe(""String_Node_Str"",pathToZipFile));
    return 1;
  }
  try (BufferedOutputStream baseOut=new BufferedOutputStream(filesystem.newFileOutputStream(pathToZipFile));final CustomZipOutputStream out=ZipOutputStreams.newOutputStream(baseOut,OVERWRITE_EXISTING)){
    final FileVisitor<Path> pathFileVisitor=new SimpleFileVisitor<Path>(){
      @Override public FileVisitResult visitFile(      Path file,      BasicFileAttributes attributes) throws IOException {
        if (!paths.isEmpty() && !paths.contains(file)) {
          return FileVisitResult.CONTINUE;
        }
        Path resolvedPath=filesystem.resolve(file);
        Path relativePath=junkPaths ? file.getFileName() : baseDir.relativize(file);
        String entryName=MorePaths.pathWithUnixSeparators(relativePath);
        CustomZipEntry entry=new CustomZipEntry(entryName);
        entry.setTime(attributes.lastModifiedTime().toMillis());
        entry.setCompressionLevel(compressionLevel);
        if (entry.getMethod() == ZipEntry.STORED) {
          entry.setSize(attributes.size());
          entry.setCompressedSize(attributes.size());
          entry.setCrc(com.google.common.io.Files.hash(resolvedPath.toFile(),Hashing.crc32()).padToLong());
        }
        out.putNextEntry(entry);
        Files.copy(resolvedPath,out);
        out.closeEntry();
        return FileVisitResult.CONTINUE;
      }
    }
;
    filesystem.walkRelativeFileTree(baseDir,pathFileVisitor);
  }
 catch (  IOException e) {
    context.logError(e,""String_Node_Str"",pathToZipFile);
    return 1;
  }
  return 0;
}",0.8566176470588235
53226,"@Test public void shouldPreferStrongLinkingFrameworks() throws IOException {
  BuildRule rule=createBuildRuleWithDefaults(BuildTarget.builder(""String_Node_Str"",""String_Node_Str"").setFlavor(AppleLibraryDescription.DYNAMIC_LIBRARY).build(),ImmutableSortedSet.<BuildRule>of(),appleLibraryDescription,new Function<AppleNativeTargetDescriptionArg,AppleNativeTargetDescriptionArg>(){
    @Override public AppleNativeTargetDescriptionArg apply(    AppleNativeTargetDescriptionArg input){
      input.frameworks=Optional.of(ImmutableSortedSet.of(""String_Node_Str""));
      input.weakFrameworks=Optional.of(ImmutableSortedSet.of(""String_Node_Str""));
      return input;
    }
  }
);
  ProjectGenerator projectGenerator=createProjectGeneratorForCombinedProject(ImmutableSet.of(rule),ImmutableSet.of(rule.getBuildTarget()));
  projectGenerator.createXcodeProjects();
  PBXProject generatedProject=projectGenerator.getGeneratedProject();
  PBXTarget target=assertTargetExistsAndReturnTarget(generatedProject,""String_Node_Str"");
  PBXBuildPhase buildPhase=ProjectGeneratorTestUtils.getSingletonPhaseByType(target,PBXFrameworksBuildPhase.class);
  assertEquals(buildPhase.getFiles().size(),1);
  PBXBuildFile file=buildPhase.getFiles().get(0);
  assertFalse(file.getSettings().isPresent());
  PBXReference.SourceTree sourceTree=file.getFileRef().getSourceTree();
  String serialized=""String_Node_Str"" + sourceTree + ""String_Node_Str""+ file.getFileRef().getPath();
  assertEquals(serialized,""String_Node_Str"");
}","@Test public void shouldPreferStrongLinkingFrameworks() throws IOException {
  BuildRule rule=createBuildRuleWithDefaults(BuildTarget.builder(""String_Node_Str"",""String_Node_Str"").setFlavor(AppleLibraryDescription.DYNAMIC_LIBRARY).build(),new BuildRuleResolver(),ImmutableSortedSet.<BuildRule>of(),appleLibraryDescription,new Function<AppleNativeTargetDescriptionArg,AppleNativeTargetDescriptionArg>(){
    @Override public AppleNativeTargetDescriptionArg apply(    AppleNativeTargetDescriptionArg input){
      input.frameworks=Optional.of(ImmutableSortedSet.of(""String_Node_Str""));
      input.weakFrameworks=Optional.of(ImmutableSortedSet.of(""String_Node_Str""));
      return input;
    }
  }
);
  ProjectGenerator projectGenerator=createProjectGeneratorForCombinedProject(ImmutableSet.of(rule),ImmutableSet.of(rule.getBuildTarget()));
  projectGenerator.createXcodeProjects();
  PBXProject generatedProject=projectGenerator.getGeneratedProject();
  PBXTarget target=assertTargetExistsAndReturnTarget(generatedProject,""String_Node_Str"");
  PBXBuildPhase buildPhase=ProjectGeneratorTestUtils.getSingletonPhaseByType(target,PBXFrameworksBuildPhase.class);
  assertEquals(buildPhase.getFiles().size(),1);
  PBXBuildFile file=buildPhase.getFiles().get(0);
  assertFalse(file.getSettings().isPresent());
  PBXReference.SourceTree sourceTree=file.getFileRef().getSourceTree();
  String serialized=""String_Node_Str"" + sourceTree + ""String_Node_Str""+ file.getFileRef().getPath();
  assertEquals(serialized,""String_Node_Str"");
}",0.6461232604373758
53227,"@Test public void shouldIncludeSettingsForWeakFrameworks() throws IOException {
  BuildRule rule=createBuildRuleWithDefaults(BuildTarget.builder(""String_Node_Str"",""String_Node_Str"").setFlavor(AppleLibraryDescription.DYNAMIC_LIBRARY).build(),ImmutableSortedSet.<BuildRule>of(),appleLibraryDescription,new Function<AppleNativeTargetDescriptionArg,AppleNativeTargetDescriptionArg>(){
    @Override public AppleNativeTargetDescriptionArg apply(    AppleNativeTargetDescriptionArg input){
      input.weakFrameworks=Optional.of(ImmutableSortedSet.of(""String_Node_Str""));
      return input;
    }
  }
);
  ProjectGenerator projectGenerator=createProjectGeneratorForCombinedProject(ImmutableSet.of(rule),ImmutableSet.of(rule.getBuildTarget()));
  projectGenerator.createXcodeProjects();
  PBXProject generatedProject=projectGenerator.getGeneratedProject();
  PBXTarget target=assertTargetExistsAndReturnTarget(generatedProject,""String_Node_Str"");
  PBXBuildPhase buildPhase=ProjectGeneratorTestUtils.getSingletonPhaseByType(target,PBXFrameworksBuildPhase.class);
  assertEquals(buildPhase.getFiles().size(),1);
  PBXBuildFile file=buildPhase.getFiles().get(0);
  assertTrue(file.getSettings().isPresent());
  NSDictionary settings=file.getSettings().get();
  assertEquals(settings.get(""String_Node_Str""),new NSArray(new NSString(""String_Node_Str"")));
  PBXReference.SourceTree sourceTree=file.getFileRef().getSourceTree();
  String serialized=""String_Node_Str"" + sourceTree + ""String_Node_Str""+ file.getFileRef().getPath();
  assertEquals(serialized,""String_Node_Str"");
}","@Test public void shouldIncludeSettingsForWeakFrameworks() throws IOException {
  BuildRule rule=createBuildRuleWithDefaults(BuildTarget.builder(""String_Node_Str"",""String_Node_Str"").setFlavor(AppleLibraryDescription.DYNAMIC_LIBRARY).build(),new BuildRuleResolver(),ImmutableSortedSet.<BuildRule>of(),appleLibraryDescription,new Function<AppleNativeTargetDescriptionArg,AppleNativeTargetDescriptionArg>(){
    @Override public AppleNativeTargetDescriptionArg apply(    AppleNativeTargetDescriptionArg input){
      input.weakFrameworks=Optional.of(ImmutableSortedSet.of(""String_Node_Str""));
      return input;
    }
  }
);
  ProjectGenerator projectGenerator=createProjectGeneratorForCombinedProject(ImmutableSet.of(rule),ImmutableSet.of(rule.getBuildTarget()));
  projectGenerator.createXcodeProjects();
  PBXProject generatedProject=projectGenerator.getGeneratedProject();
  PBXTarget target=assertTargetExistsAndReturnTarget(generatedProject,""String_Node_Str"");
  PBXBuildPhase buildPhase=ProjectGeneratorTestUtils.getSingletonPhaseByType(target,PBXFrameworksBuildPhase.class);
  assertEquals(buildPhase.getFiles().size(),1);
  PBXBuildFile file=buildPhase.getFiles().get(0);
  assertTrue(file.getSettings().isPresent());
  NSDictionary settings=file.getSettings().get();
  assertEquals(settings.get(""String_Node_Str""),new NSArray(new NSString(""String_Node_Str"")));
  PBXReference.SourceTree sourceTree=file.getFileRef().getSourceTree();
  String serialized=""String_Node_Str"" + sourceTree + ""String_Node_Str""+ file.getFileRef().getPath();
  assertEquals(serialized,""String_Node_Str"");
}",0.7108433734939759
53228,"/** 
 * @param directory that must not contain symlinks with loops.
 * @param jar is the file being written.
 */
private void addFilesInDirectoryToJar(File directory,final CustomZipOutputStream jar,final Set<String> alreadyAddedEntries,final BuckEventBus eventBus) throws IOException {
  new DirectoryTraversal(directory){
    @Override public void visit(    File file,    String relativePath){
      JarEntry entry=new JarEntry(relativePath);
      String entryName=entry.getName();
      entry.setTime(file.lastModified());
      try {
        if (!isDuplicateAllowed(entryName) && !alreadyAddedEntries.add(entryName)) {
          if (!entryName.endsWith(""String_Node_Str"")) {
            eventBus.post(ConsoleEvent.create(determineSeverity(entry),""String_Node_Str"",relativePath));
          }
          return;
        }
        jar.putNextEntry(entry);
        Files.copy(file,jar);
        jar.closeEntry();
      }
 catch (      IOException e) {
        Throwables.propagate(e);
      }
    }
    @Override public void visitDirectory(    File directory,    String relativePath) throws IOException {
      if (relativePath.isEmpty()) {
        return;
      }
      String entryName=relativePath + ""String_Node_Str"";
      if (alreadyAddedEntries.contains(entryName)) {
        return;
      }
      JarEntry entry=new JarEntry(entryName);
      entry.setTime(directory.lastModified());
      jar.putNextEntry(entry);
      jar.closeEntry();
    }
  }
.traverse();
}","/** 
 * @param directory that must not contain symlinks with loops.
 * @param jar is the file being written.
 */
private void addFilesInDirectoryToJar(File directory,final CustomZipOutputStream jar,final Set<String> alreadyAddedEntries,final BuckEventBus eventBus) throws IOException {
  new DirectoryTraversal(directory){
    @Override public void visit(    File file,    String relativePath){
      JarEntry entry=new JarEntry(relativePath.replace('\\','/'));
      String entryName=entry.getName();
      entry.setTime(file.lastModified());
      try {
        if (!isDuplicateAllowed(entryName) && !alreadyAddedEntries.add(entryName)) {
          if (!entryName.endsWith(""String_Node_Str"")) {
            eventBus.post(ConsoleEvent.create(determineSeverity(entry),""String_Node_Str"",relativePath));
          }
          return;
        }
        jar.putNextEntry(entry);
        Files.copy(file,jar);
        jar.closeEntry();
      }
 catch (      IOException e) {
        Throwables.propagate(e);
      }
    }
    @Override public void visitDirectory(    File directory,    String relativePath) throws IOException {
      if (relativePath.isEmpty()) {
        return;
      }
      String entryName=relativePath.replace('\\','/') + ""String_Node_Str"";
      if (alreadyAddedEntries.contains(entryName)) {
        return;
      }
      JarEntry entry=new JarEntry(entryName);
      entry.setTime(directory.lastModified());
      jar.putNextEntry(entry);
      jar.closeEntry();
    }
  }
.traverse();
}",0.9879113498992612
53229,"@Override public void visitDirectory(File directory,String relativePath) throws IOException {
  if (relativePath.isEmpty()) {
    return;
  }
  String entryName=relativePath + ""String_Node_Str"";
  if (alreadyAddedEntries.contains(entryName)) {
    return;
  }
  JarEntry entry=new JarEntry(entryName);
  entry.setTime(directory.lastModified());
  jar.putNextEntry(entry);
  jar.closeEntry();
}","@Override public void visitDirectory(File directory,String relativePath) throws IOException {
  if (relativePath.isEmpty()) {
    return;
  }
  String entryName=relativePath.replace('\\','/') + ""String_Node_Str"";
  if (alreadyAddedEntries.contains(entryName)) {
    return;
  }
  JarEntry entry=new JarEntry(entryName);
  entry.setTime(directory.lastModified());
  jar.putNextEntry(entry);
  jar.closeEntry();
}",0.9776119402985076
53230,"@Override public void visit(File file,String relativePath){
  JarEntry entry=new JarEntry(relativePath);
  String entryName=entry.getName();
  entry.setTime(file.lastModified());
  try {
    if (!isDuplicateAllowed(entryName) && !alreadyAddedEntries.add(entryName)) {
      if (!entryName.endsWith(""String_Node_Str"")) {
        eventBus.post(ConsoleEvent.create(determineSeverity(entry),""String_Node_Str"",relativePath));
      }
      return;
    }
    jar.putNextEntry(entry);
    Files.copy(file,jar);
    jar.closeEntry();
  }
 catch (  IOException e) {
    Throwables.propagate(e);
  }
}","@Override public void visit(File file,String relativePath){
  JarEntry entry=new JarEntry(relativePath.replace('\\','/'));
  String entryName=entry.getName();
  entry.setTime(file.lastModified());
  try {
    if (!isDuplicateAllowed(entryName) && !alreadyAddedEntries.add(entryName)) {
      if (!entryName.endsWith(""String_Node_Str"")) {
        eventBus.post(ConsoleEvent.create(determineSeverity(entry),""String_Node_Str"",relativePath));
      }
      return;
    }
    jar.putNextEntry(entry);
    Files.copy(file,jar);
    jar.closeEntry();
  }
 catch (  IOException e) {
    Throwables.propagate(e);
  }
}",0.985
53231,"@Override public FileVisitResult visitFile(Path file,BasicFileAttributes attributes) throws IOException {
  if (!paths.isEmpty() && !paths.contains(file)) {
    return FileVisitResult.CONTINUE;
  }
  Path relativePath=junkPaths ? file.getFileName() : baseDir.relativize(file);
  String entryName=relativePath.toString();
  CustomZipEntry entry=new CustomZipEntry(entryName);
  entry.setTime(attributes.lastModifiedTime().toMillis());
  entry.setSize(attributes.size());
  entry.setCompressionLevel(compressionLevel);
  out.putNextEntry(entry);
  Files.copy(filesystem.resolve(file),out);
  out.closeEntry();
  return FileVisitResult.CONTINUE;
}","@Override public FileVisitResult visitFile(Path file,BasicFileAttributes attributes) throws IOException {
  if (!paths.isEmpty() && !paths.contains(file)) {
    return FileVisitResult.CONTINUE;
  }
  Path relativePath=junkPaths ? file.getFileName() : baseDir.relativize(file);
  String entryName=MorePaths.pathWithUnixSeparators(relativePath);
  CustomZipEntry entry=new CustomZipEntry(entryName);
  entry.setTime(attributes.lastModifiedTime().toMillis());
  entry.setSize(attributes.size());
  entry.setCompressionLevel(compressionLevel);
  out.putNextEntry(entry);
  Files.copy(filesystem.resolve(file),out);
  out.closeEntry();
  return FileVisitResult.CONTINUE;
}",0.958047292143402
53232,"@Override public int execute(ExecutionContext context){
  final ProjectFilesystem filesystem=context.getProjectFilesystem();
  if (filesystem.exists(pathToZipFile)) {
    context.postEvent(ConsoleEvent.severe(""String_Node_Str"",pathToZipFile));
    return 1;
  }
  try (BufferedOutputStream baseOut=new BufferedOutputStream(filesystem.newFileOutputStream(pathToZipFile));final CustomZipOutputStream out=ZipOutputStreams.newOutputStream(baseOut,OVERWRITE_EXISTING)){
    final FileVisitor<Path> pathFileVisitor=new SimpleFileVisitor<Path>(){
      @Override public FileVisitResult visitFile(      Path file,      BasicFileAttributes attributes) throws IOException {
        if (!paths.isEmpty() && !paths.contains(file)) {
          return FileVisitResult.CONTINUE;
        }
        Path relativePath=junkPaths ? file.getFileName() : baseDir.relativize(file);
        String entryName=relativePath.toString();
        CustomZipEntry entry=new CustomZipEntry(entryName);
        entry.setTime(attributes.lastModifiedTime().toMillis());
        entry.setSize(attributes.size());
        entry.setCompressionLevel(compressionLevel);
        out.putNextEntry(entry);
        Files.copy(filesystem.resolve(file),out);
        out.closeEntry();
        return FileVisitResult.CONTINUE;
      }
    }
;
    filesystem.walkRelativeFileTree(baseDir,pathFileVisitor);
  }
 catch (  IOException e) {
    context.logError(e,""String_Node_Str"",pathToZipFile);
    return 1;
  }
  return 0;
}","@Override public int execute(ExecutionContext context){
  final ProjectFilesystem filesystem=context.getProjectFilesystem();
  if (filesystem.exists(pathToZipFile)) {
    context.postEvent(ConsoleEvent.severe(""String_Node_Str"",pathToZipFile));
    return 1;
  }
  try (BufferedOutputStream baseOut=new BufferedOutputStream(filesystem.newFileOutputStream(pathToZipFile));final CustomZipOutputStream out=ZipOutputStreams.newOutputStream(baseOut,OVERWRITE_EXISTING)){
    final FileVisitor<Path> pathFileVisitor=new SimpleFileVisitor<Path>(){
      @Override public FileVisitResult visitFile(      Path file,      BasicFileAttributes attributes) throws IOException {
        if (!paths.isEmpty() && !paths.contains(file)) {
          return FileVisitResult.CONTINUE;
        }
        Path relativePath=junkPaths ? file.getFileName() : baseDir.relativize(file);
        String entryName=MorePaths.pathWithUnixSeparators(relativePath);
        CustomZipEntry entry=new CustomZipEntry(entryName);
        entry.setTime(attributes.lastModifiedTime().toMillis());
        entry.setSize(attributes.size());
        entry.setCompressionLevel(compressionLevel);
        out.putNextEntry(entry);
        Files.copy(filesystem.resolve(file),out);
        out.closeEntry();
        return FileVisitResult.CONTINUE;
      }
    }
;
    filesystem.walkRelativeFileTree(baseDir,pathFileVisitor);
  }
 catch (  IOException e) {
    context.logError(e,""String_Node_Str"",pathToZipFile);
    return 1;
  }
  return 0;
}",0.985546218487395
53233,"public @Nullable String getSuperClassName(){
  return superClassName;
}","@Nullable public String getSuperClassName(){
  return superClassName;
}",0.9014084507042254
53234,"public @Nullable String getRawSuperParams(){
  return rawSuperParams;
}","@Nullable public String getRawSuperParams(){
  return rawSuperParams;
}",0.9014084507042254
53235,"public @Nullable String getJsonProperty(){
  return jsonProperty;
}","@Nullable public String getJsonProperty(){
  return jsonProperty;
}",0.8955223880597015
53236,"public @Nullable String getVisibility(){
  return visibility;
}","@Nullable public String getVisibility(){
  return visibility;
}",0.8888888888888888
53237,"public @Nullable String getDefaultValue(){
  return defaultValue;
}","@Nullable public String getDefaultValue(){
  return defaultValue;
}",0.8955223880597015
53238,"@Override int runCommandWithOptionsInternal(RunCommandOptions options) throws IOException, InterruptedException {
  if (!options.hasTargetSpecified()) {
    console.printBuildFailure(""String_Node_Str"");
    console.getStdOut().println(""String_Node_Str"");
    return 1;
  }
  BuildCommand buildCommand=new BuildCommand(getCommandRunnerParams());
  BuildCommandOptions buildCommandOptions=new BuildCommandOptions(options.getBuckConfig());
  buildCommandOptions.setArguments(ImmutableList.of(options.getTarget()));
  int exitCode=buildCommand.runCommandWithOptions(buildCommandOptions);
  if (exitCode != 0) {
    return exitCode;
  }
  String targetName=options.getTarget();
  BuildTarget target;
  try {
    target=Iterables.getOnlyElement(getBuildTargets(ImmutableSet.of(targetName)));
  }
 catch (  NoSuchBuildTargetException e) {
    console.printBuildFailure(e.getMessage());
    return 1;
  }
  Build build=buildCommand.getBuild();
  BuildRule targetRule=build.getActionGraph().findBuildRuleByTarget(target);
  BinaryBuildRule binaryBuildRule=null;
  if (targetRule instanceof BinaryBuildRule) {
    binaryBuildRule=(BinaryBuildRule)targetRule;
  }
  if (binaryBuildRule == null) {
    console.printBuildFailure(""String_Node_Str"" + targetName + ""String_Node_Str"");
    return 1;
  }
  ImmutableList<String> fullCommand=new ImmutableList.Builder<String>().addAll(binaryBuildRule.getExecutableCommand(getProjectFilesystem())).addAll(options.getTargetArguments()).build();
  ShellStep step=new DefaultShellStep(fullCommand);
  return step.execute(build.getExecutionContext());
}","@Override int runCommandWithOptionsInternal(RunCommandOptions options) throws IOException, InterruptedException {
  if (!options.hasTargetSpecified()) {
    console.printBuildFailure(""String_Node_Str"");
    console.getStdOut().println(""String_Node_Str"");
    return 1;
  }
  BuildCommand buildCommand=new BuildCommand(getCommandRunnerParams());
  BuildCommandOptions buildCommandOptions=new BuildCommandOptions(options.getBuckConfig());
  buildCommandOptions.setArguments(ImmutableList.of(options.getTarget()));
  int exitCode=buildCommand.runCommandWithOptions(buildCommandOptions);
  if (exitCode != 0) {
    return exitCode;
  }
  String targetName=options.getTarget();
  BuildTarget target;
  try {
    target=Iterables.getOnlyElement(getBuildTargets(ImmutableSet.of(targetName)));
  }
 catch (  NoSuchBuildTargetException e) {
    console.printBuildFailure(e.getMessage());
    return 1;
  }
  Build build=buildCommand.getBuild();
  BuildRule targetRule=build.getActionGraph().findBuildRuleByTarget(target);
  BinaryBuildRule binaryBuildRule=null;
  if (targetRule instanceof BinaryBuildRule) {
    binaryBuildRule=(BinaryBuildRule)targetRule;
  }
  if (binaryBuildRule == null) {
    console.printBuildFailure(""String_Node_Str"" + targetName + ""String_Node_Str"");
    return 1;
  }
  ImmutableList<String> fullCommand=new ImmutableList.Builder<String>().addAll(binaryBuildRule.getExecutableCommand(getProjectFilesystem())).addAll(options.getTargetArguments()).build();
  ShellStep step=new DefaultShellStep(fullCommand){
    @Override protected boolean shouldFlushStdOutErrAsProgressIsMade(){
      return true;
    }
  }
;
  return step.execute(build.getExecutionContext());
}",0.9684145967494634
53239,"/** 
 * Initialize the parser, starting buck.py.
 */
private void init() throws IOException {
  ProcessBuilder processBuilder=new ProcessBuilder(buildArgs());
  processBuilder.environment().clear();
  processBuilder.environment().putAll(environment);
  LOG.debug(""String_Node_Str"",processBuilder.command(),processBuilder.environment());
  buckPyProcess=processBuilder.start();
  LOG.debug(""String_Node_Str"",buckPyProcess);
  OutputStream stdin=buckPyProcess.getOutputStream();
  InputStream stderr=buckPyProcess.getErrorStream();
  Thread stderrConsumer=Threads.namedThread(ProjectBuildFileParser.class.getSimpleName(),new InputStreamConsumer(stderr,console.getStdErr(),console.getAnsi()));
  stderrConsumer.start();
  buckPyStdinWriter=new BufferedWriter(new OutputStreamWriter(stdin));
  Reader reader=new InputStreamReader(buckPyProcess.getInputStream(),Charsets.UTF_8);
  buckPyStdoutParser=new BuildFileToJsonParser(reader,isServerMode);
}","/** 
 * Initialize the parser, starting buck.py.
 */
private void init() throws IOException {
  ProcessBuilder processBuilder=new ProcessBuilder(buildArgs());
  processBuilder.environment().clear();
  processBuilder.environment().putAll(environment);
  LOG.debug(""String_Node_Str"",processBuilder.command(),processBuilder.environment());
  buckPyProcess=processBuilder.start();
  LOG.debug(""String_Node_Str"",buckPyProcess);
  OutputStream stdin=buckPyProcess.getOutputStream();
  InputStream stderr=buckPyProcess.getErrorStream();
  Thread stderrConsumer=Threads.namedThread(ProjectBuildFileParser.class.getSimpleName(),new InputStreamConsumer(stderr,console.getStdErr(),console.getAnsi(),true));
  stderrConsumer.start();
  buckPyStdinWriter=new BufferedWriter(new OutputStreamWriter(stdin));
  Reader reader=new InputStreamReader(buckPyProcess.getInputStream(),Charsets.UTF_8);
  buckPyStdoutParser=new BuildFileToJsonParser(reader,isServerMode);
}",0.9973586899101956
53240,"@VisibleForTesting int interactWithProcess(ExecutionContext context,Process process) throws InterruptedException {
  ProcessExecutor executor=context.getProcessExecutor();
  ProcessExecutor.Result result=executor.execute(process,false,false,context.getVerbosity() == Verbosity.SILENT,getStdin());
  stdout=result.getStdout();
  stderr=result.getStderr();
  Verbosity verbosity=context.getVerbosity();
  if (!stderr.isEmpty() && shouldPrintStderr(verbosity)) {
    context.postEvent(ConsoleEvent.severe(""String_Node_Str"",stderr));
  }
  if (!stdout.isEmpty() && shouldPrintStdout(verbosity)) {
    context.postEvent(ConsoleEvent.info(""String_Node_Str"",stdout));
  }
  return result.getExitCode();
}","@VisibleForTesting int interactWithProcess(ExecutionContext context,Process process) throws InterruptedException {
  ImmutableSet.Builder<Option> options=ImmutableSet.builder();
  if (shouldFlushStdOutErrAsProgressIsMade()) {
    options.add(Option.PRINT_STD_OUT);
    options.add(Option.PRINT_STD_ERR);
  }
  if (context.getVerbosity() == Verbosity.SILENT) {
    options.add(Option.IS_SILENT);
  }
  ProcessExecutor executor=context.getProcessExecutor();
  ProcessExecutor.Result result=executor.execute(process,options.build(),getStdin());
  stdout=result.getStdout();
  stderr=result.getStderr();
  Verbosity verbosity=context.getVerbosity();
  if (!Strings.isNullOrEmpty(stdout) && shouldPrintStdout(verbosity)) {
    context.postEvent(ConsoleEvent.info(""String_Node_Str"",stdout));
  }
  if (!Strings.isNullOrEmpty(stderr) && shouldPrintStderr(verbosity)) {
    context.postEvent(ConsoleEvent.severe(""String_Node_Str"",stderr));
  }
  return result.getExitCode();
}",0.6486486486486487
53241,"public InputStreamConsumer(Reader reader,PrintStream printStream,Ansi ansi){
  this.inputReader=new BufferedReader(reader);
  this.printStream=Preconditions.checkNotNull(printStream);
  this.ansi=Preconditions.checkNotNull(ansi);
}","public InputStreamConsumer(Reader reader,PrintStream printStream,Ansi ansi,boolean flagOutputWrittenToStream){
  this.inputReader=new BufferedReader(reader);
  this.printStream=Preconditions.checkNotNull(printStream);
  this.ansi=Preconditions.checkNotNull(ansi);
  this.flagOutputWrittenToStream=flagOutputWrittenToStream;
}",0.8309352517985612
53242,"@Override public void run(){
  String line;
  try {
    while ((line=inputReader.readLine()) != null) {
      if (!hasWrittenOutputToPrintStream) {
        printStream.print(ansi.getHighlightedWarningSequence());
        hasWrittenOutputToPrintStream=true;
      }
      printStream.println(line);
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 finally {
    if (hasWrittenOutputToPrintStream) {
      printStream.print(ansi.getHighlightedResetSequence());
    }
  }
}","@Override public void run(){
  String line;
  try {
    while ((line=inputReader.readLine()) != null) {
      if (!hasWrittenOutputToPrintStream && flagOutputWrittenToStream) {
        printStream.print(ansi.getHighlightedWarningSequence());
        hasWrittenOutputToPrintStream=true;
      }
      printStream.print(line + LINE_SEPARATOR);
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 finally {
    if (hasWrittenOutputToPrintStream) {
      printStream.print(ansi.getHighlightedResetSequence());
    }
  }
}",0.9442307692307692
53243,"/** 
 * Executes the specified process.
 * @param process The {@code Process} to execute.
 * @param shouldPrintStdOut If {@code true}, then the stdout of the process will be written directly to the stdout passed to the constructor of this executor. If   {@code false}, then the stdout of the process will be made available via   {@link Result#getStdout()}.
 * @param shouldPrintStdErr If {@code true}, then the stderr of the process will be written directly to the stderr passed to the constructor of this executor. If   {@code false}, then the stderr of the process will be made available via   {@link Result#getStderr()}.
 */
public Result execute(Process process,boolean shouldPrintStdOut,boolean shouldPrintStdErr,boolean isSilent,Optional<String> stdin) throws InterruptedException {
  @SuppressWarnings(""String_Node_Str"") PrintStream stdOutToWriteTo=shouldPrintStdOut ? stdOutStream : new CapturingPrintStream();
  InputStreamConsumer stdOut=new InputStreamConsumer(process.getInputStream(),stdOutToWriteTo,ansi);
  @SuppressWarnings(""String_Node_Str"") PrintStream stdErrToWriteTo=shouldPrintStdErr ? stdErrStream : new CapturingPrintStream();
  InputStreamConsumer stdErr=new InputStreamConsumer(process.getErrorStream(),stdErrToWriteTo,ansi);
  Thread stdOutConsumer=Threads.namedThread(""String_Node_Str"",stdOut);
  stdOutConsumer.start();
  Thread stdErrConsumer=Threads.namedThread(""String_Node_Str"",stdErr);
  stdErrConsumer.start();
  try {
    if (stdin.isPresent()) {
      try (OutputStreamWriter stdinWriter=new OutputStreamWriter(process.getOutputStream())){
        stdinWriter.write(stdin.get());
      }
     }
    process.waitFor();
    stdOutConsumer.join();
    stdErrConsumer.join();
  }
 catch (  IOException e) {
    return new Result(1,null,null);
  }
 finally {
    process.destroy();
    process.waitFor();
  }
  String stdoutText=getDataIfNotPrinted(stdOutToWriteTo,shouldPrintStdOut);
  String stderrText=getDataIfNotPrinted(stdErrToWriteTo,shouldPrintStdErr);
  int exitCode=process.exitValue();
  if (exitCode != 0 && !isSilent) {
    if (!shouldPrintStdOut) {
      stdOutStream.print(stdoutText);
    }
    if (!shouldPrintStdErr) {
      stdErrStream.print(stderrText);
    }
  }
  return new Result(exitCode,stdoutText,stderrText);
}","/** 
 * Executes the specified process. <p> If   {@code options} contains {@link Option#PRINT_STD_OUT}, then the stdout of the process will be written directly to the stdout passed to the constructor of this executor. Otherwise, the stdout of the process will be made available via   {@link Result#getStdout()}. <p> If   {@code options} contains {@link Option#PRINT_STD_ERR}, then the stderr of the process will be written directly to the stderr passed to the constructor of this executor. Otherwise, the stderr of the process will be made available via   {@link Result#getStderr()}.
 */
public Result execute(Process process,Set<Option> options,Optional<String> stdin) throws InterruptedException {
  boolean shouldPrintStdOut=options.contains(Option.PRINT_STD_OUT);
  @SuppressWarnings(""String_Node_Str"") PrintStream stdOutToWriteTo=shouldPrintStdOut ? stdOutStream : new CapturingPrintStream();
  InputStreamConsumer stdOut=new InputStreamConsumer(process.getInputStream(),stdOutToWriteTo,ansi,!shouldPrintStdOut);
  boolean shouldPrintStdErr=options.contains(Option.PRINT_STD_ERR);
  @SuppressWarnings(""String_Node_Str"") PrintStream stdErrToWriteTo=shouldPrintStdErr ? stdErrStream : new CapturingPrintStream();
  InputStreamConsumer stdErr=new InputStreamConsumer(process.getErrorStream(),stdErrToWriteTo,ansi,!shouldPrintStdErr);
  Thread stdOutConsumer=Threads.namedThread(""String_Node_Str"",stdOut);
  stdOutConsumer.start();
  Thread stdErrConsumer=Threads.namedThread(""String_Node_Str"",stdErr);
  stdErrConsumer.start();
  try {
    if (stdin.isPresent()) {
      try (OutputStreamWriter stdinWriter=new OutputStreamWriter(process.getOutputStream())){
        stdinWriter.write(stdin.get());
      }
     }
    process.waitFor();
    stdOutConsumer.join();
    stdErrConsumer.join();
  }
 catch (  IOException e) {
    return new Result(1,null,null);
  }
 finally {
    process.destroy();
    process.waitFor();
  }
  String stdoutText=getDataIfNotPrinted(stdOutToWriteTo,shouldPrintStdOut);
  String stderrText=getDataIfNotPrinted(stdErrToWriteTo,shouldPrintStdErr);
  int exitCode=process.exitValue();
  if (exitCode != 0 && !options.contains(Option.IS_SILENT)) {
    if (!shouldPrintStdOut) {
      stdOutStream.print(stdoutText);
    }
    if (!shouldPrintStdErr) {
      stdErrStream.print(stderrText);
    }
  }
  return new Result(exitCode,stdoutText,stderrText);
}",0.7658568049881745
53244,"@Test public void testRunCommandWithArguments() throws IOException {
  ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",temporaryFolder);
  workspace.setUp();
  ProcessResult result=workspace.runBuckCommand(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",workspace.getFile(""String_Node_Str"").toPath().toAbsolutePath().toString());
  result.assertSuccess(""String_Node_Str"");
  System.out.print(result.getStdout());
  workspace.verify();
}","@Test public void testRunCommandWithArguments() throws IOException {
  ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",temporaryFolder);
  workspace.setUp();
  ProcessResult result=workspace.runBuckCommand(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",workspace.getFile(""String_Node_Str"").toPath().toAbsolutePath().toString());
  result.assertSuccess(""String_Node_Str"");
  assertEquals(""String_Node_Str"",result.getStdout());
  workspace.verify();
}",0.952
53245,"/** 
 * Look at all the directories above a given source file, up to the project root, and return the paths to any BUCK files that exist at those locations. These files are the only ones that could define a rule that includes the given source file.
 */
private ImmutableList<Path> possibleBuckFilesForSourceFile(Path sourceFilePath){
  ImmutableList.Builder<Path> possibleBuckFiles=ImmutableList.builder();
  Path dir=sourceFilePath.getParent();
  while (dir != null) {
    Path buckFile=dir.resolve(BuckConstant.BUILD_RULES_FILE_NAME);
    if (projectFilesystem.exists(buckFile)) {
      possibleBuckFiles.add(buckFile);
    }
    dir=dir.getParent();
  }
  Path rootBuckFile=Paths.get(BuckConstant.BUILD_RULES_FILE_NAME);
  if (projectFilesystem.exists(rootBuckFile)) {
    possibleBuckFiles.add(rootBuckFile);
  }
  return possibleBuckFiles.build();
}","/** 
 * Look at all the directories above a given source file, up to the project root, and return the paths to any BUCK files that exist at those locations. These files are the only ones that could define a rule that includes the given source file.
 */
private ImmutableList<Path> possibleBuckFilesForSourceFile(Path sourceFilePath){
  ImmutableList.Builder<Path> possibleBuckFiles=ImmutableList.builder();
  Path dir=sourceFilePath.getParent();
  while (dir != null) {
    Path buckFile=dir.resolve(BuckConstant.BUILD_RULES_FILE_NAME);
    if (projectFilesystem.isFile(buckFile)) {
      possibleBuckFiles.add(buckFile);
    }
    dir=dir.getParent();
  }
  Path rootBuckFile=Paths.get(BuckConstant.BUILD_RULES_FILE_NAME);
  if (projectFilesystem.exists(rootBuckFile)) {
    possibleBuckFiles.add(rootBuckFile);
  }
  return possibleBuckFiles.build();
}",0.9929742388758782
53246,"/** 
 * Timestamp event. A timestamped event cannot subsequently being posted and is useful only to pass its timestamp on to another posted event.
 */
public void timestamp(BuckEvent event){
  event.configure(clock.currentTimeMillis(),clock.nanoTime(),threadIdSupplier.get(),buildId);
}","/** 
 * Timestamp event. A timestamped event cannot subsequently being posted and is useful only to pass its timestamp on to another posted event.
 */
public void timestamp(BuckEvent event){
  long nanos=clock.nanoTime();
  event.configure(TimeUnit.NANOSECONDS.toMillis(nanos),nanos,threadIdSupplier.get(),buildId);
}",0.8524046434494196
53247,"/** 
 * Timestamp event. A timestamped event cannot subsequently being posted and is useful only to pass its timestamp on to another posted event.
 */
public void timestamp(BuckEvent event){
  long nanos=clock.nanoTime();
  event.configure(TimeUnit.NANOSECONDS.toMillis(nanos),nanos,threadIdSupplier.get(),buildId);
}","/** 
 * Timestamp event. A timestamped event cannot subsequently being posted and is useful only to pass its timestamp on to another posted event.
 */
public void timestamp(BuckEvent event){
  event.configure(clock.currentTimeMillis(),clock.nanoTime(),threadIdSupplier.get(),buildId);
}",0.6898839137645107
53248,"/** 
 * Creates RunListener that will prepare individual result for each test and store it to results list afterwards.
 */
static RunListener createSingleTestResultRunListener(final List<TestResult> results){
  return new RunListener(){
    private PrintStream originalOut, originalErr, stdOutStream, stdErrStream;
    private ByteArrayOutputStream rawStdOutBytes, rawStdErrBytes;
    private Result result;
    private RunListener resultListener;
    private final List<Failure> assumptionFailures=new ArrayList<>();
    private long startTime=System.currentTimeMillis();
    @Override public void testStarted(    Description description) throws Exception {
      originalOut=System.out;
      originalErr=System.err;
      rawStdOutBytes=new ByteArrayOutputStream();
      rawStdErrBytes=new ByteArrayOutputStream();
      stdOutStream=new PrintStream(rawStdOutBytes,true,ENCODING);
      stdErrStream=new PrintStream(rawStdErrBytes,true,ENCODING);
      System.setOut(stdOutStream);
      System.setErr(stdErrStream);
      result=new Result();
      resultListener=result.createListener();
      resultListener.testRunStarted(description);
      resultListener.testStarted(description);
    }
    @Override public void testFinished(    Description description) throws Exception {
      resultListener.testFinished(description);
      resultListener.testRunFinished(result);
      resultListener=null;
      System.setOut(originalOut);
      System.setErr(originalErr);
      stdOutStream.flush();
      stdErrStream.flush();
      int numFailures=result.getFailureCount();
      String className=description.getClassName();
      String methodName=description.getMethodName();
      if (numFailures < 0) {
        throw new IllegalStateException(String.format(""String_Node_Str"",className,methodName,numFailures,result.getFailures()));
      }
      Failure failure;
      ResultType type;
      if (assumptionFailures.size() > 0) {
        failure=assumptionFailures.get(0);
        type=ResultType.ASSUMPTION_VIOLATION;
      }
 else       if (numFailures == 0) {
        failure=null;
        type=ResultType.SUCCESS;
      }
 else {
        failure=result.getFailures().get(0);
        type=ResultType.FAILURE;
      }
      String stdOut=rawStdOutBytes.size() == 0 ? null : rawStdOutBytes.toString(ENCODING);
      String stdErr=rawStdErrBytes.size() == 0 ? null : rawStdErrBytes.toString(ENCODING);
      results.add(new TestResult(className,methodName,result.getRunTime(),type,failure,stdOut,stdErr));
    }
    /** 
 * The regular listener we created from the singular result, in this class, will not by default treat assumption failures as regular failures, and will not store them.  As a consequence, we store them ourselves!
 */
    @Override public void testAssumptionFailure(    Failure failure){
      assumptionFailures.add(failure);
      if (resultListener != null) {
        resultListener.testAssumptionFailure(failure);
      }
    }
    @Override public void testFailure(    Failure failure) throws Exception {
      if (resultListener == null) {
        recordUnpairedFailure(failure);
      }
 else {
        resultListener.testFailure(failure);
      }
    }
    @Override public void testIgnored(    Description description) throws Exception {
      if (resultListener != null) {
        resultListener.testIgnored(description);
      }
    }
    /** 
 * It's possible to encounter a Failure before we've started any tests (and therefore before testStarted() has been called).  The known example is a @BeforeClass that throws an exception, but there may be others. <p> Recording these unexpected failures helps us propagate failures back up to the ""buck test"" process.
 */
    private void recordUnpairedFailure(    Failure failure){
      long runtime=System.currentTimeMillis() - startTime;
      Description description=failure.getDescription();
      results.add(new TestResult(description.getClassName(),description.getMethodName(),runtime,ResultType.FAILURE,failure,null,null));
    }
  }
;
}","/** 
 * Creates RunListener that will prepare individual result for each test and store it to results list afterwards.
 */
static RunListener createSingleTestResultRunListener(final List<TestResult> results){
  return new RunListener(){
    private PrintStream originalOut, originalErr, stdOutStream, stdErrStream;
    private ByteArrayOutputStream rawStdOutBytes, rawStdErrBytes;
    private Result result;
    private RunListener resultListener;
    private Failure assumptionFailure;
    private long startTime=System.currentTimeMillis();
    @Override public void testStarted(    Description description) throws Exception {
      originalOut=System.out;
      originalErr=System.err;
      rawStdOutBytes=new ByteArrayOutputStream();
      rawStdErrBytes=new ByteArrayOutputStream();
      stdOutStream=new PrintStream(rawStdOutBytes,true,ENCODING);
      stdErrStream=new PrintStream(rawStdErrBytes,true,ENCODING);
      System.setOut(stdOutStream);
      System.setErr(stdErrStream);
      result=new Result();
      resultListener=result.createListener();
      resultListener.testRunStarted(description);
      resultListener.testStarted(description);
    }
    @Override public void testFinished(    Description description) throws Exception {
      resultListener.testFinished(description);
      resultListener.testRunFinished(result);
      resultListener=null;
      System.setOut(originalOut);
      System.setErr(originalErr);
      stdOutStream.flush();
      stdErrStream.flush();
      int numFailures=result.getFailureCount();
      String className=description.getClassName();
      String methodName=description.getMethodName();
      if (numFailures < 0) {
        throw new IllegalStateException(String.format(""String_Node_Str"",className,methodName,numFailures,result.getFailures()));
      }
      Failure failure;
      ResultType type;
      if (assumptionFailure != null) {
        failure=assumptionFailure;
        type=ResultType.ASSUMPTION_VIOLATION;
        assumptionFailure=null;
      }
 else       if (numFailures == 0) {
        failure=null;
        type=ResultType.SUCCESS;
      }
 else {
        failure=result.getFailures().get(0);
        type=ResultType.FAILURE;
      }
      String stdOut=rawStdOutBytes.size() == 0 ? null : rawStdOutBytes.toString(ENCODING);
      String stdErr=rawStdErrBytes.size() == 0 ? null : rawStdErrBytes.toString(ENCODING);
      results.add(new TestResult(className,methodName,result.getRunTime(),type,failure,stdOut,stdErr));
    }
    /** 
 * The regular listener we created from the singular result, in this class, will not by default treat assumption failures as regular failures, and will not store them.  As a consequence, we store them ourselves! We store the assumption-failure in a temporary field, which we'll make sure we clear each time we write results.
 */
    @Override public void testAssumptionFailure(    Failure failure){
      assumptionFailure=failure;
      if (resultListener != null) {
        resultListener.testAssumptionFailure(failure);
      }
    }
    @Override public void testFailure(    Failure failure) throws Exception {
      if (resultListener == null) {
        recordUnpairedFailure(failure);
      }
 else {
        resultListener.testFailure(failure);
      }
    }
    @Override public void testIgnored(    Description description) throws Exception {
      if (resultListener != null) {
        resultListener.testIgnored(description);
      }
    }
    /** 
 * It's possible to encounter a Failure before we've started any tests (and therefore before testStarted() has been called).  The known example is a @BeforeClass that throws an exception, but there may be others. <p> Recording these unexpected failures helps us propagate failures back up to the ""buck test"" process.
 */
    private void recordUnpairedFailure(    Failure failure){
      long runtime=System.currentTimeMillis() - startTime;
      Description description=failure.getDescription();
      results.add(new TestResult(description.getClassName(),description.getMethodName(),runtime,ResultType.FAILURE,failure,null,null));
    }
  }
;
}",0.9739813451153656
53249,"@Override public void testFinished(Description description) throws Exception {
  resultListener.testFinished(description);
  resultListener.testRunFinished(result);
  resultListener=null;
  System.setOut(originalOut);
  System.setErr(originalErr);
  stdOutStream.flush();
  stdErrStream.flush();
  int numFailures=result.getFailureCount();
  String className=description.getClassName();
  String methodName=description.getMethodName();
  if (numFailures < 0) {
    throw new IllegalStateException(String.format(""String_Node_Str"",className,methodName,numFailures,result.getFailures()));
  }
  Failure failure;
  ResultType type;
  if (assumptionFailures.size() > 0) {
    failure=assumptionFailures.get(0);
    type=ResultType.ASSUMPTION_VIOLATION;
  }
 else   if (numFailures == 0) {
    failure=null;
    type=ResultType.SUCCESS;
  }
 else {
    failure=result.getFailures().get(0);
    type=ResultType.FAILURE;
  }
  String stdOut=rawStdOutBytes.size() == 0 ? null : rawStdOutBytes.toString(ENCODING);
  String stdErr=rawStdErrBytes.size() == 0 ? null : rawStdErrBytes.toString(ENCODING);
  results.add(new TestResult(className,methodName,result.getRunTime(),type,failure,stdOut,stdErr));
}","@Override public void testFinished(Description description) throws Exception {
  resultListener.testFinished(description);
  resultListener.testRunFinished(result);
  resultListener=null;
  System.setOut(originalOut);
  System.setErr(originalErr);
  stdOutStream.flush();
  stdErrStream.flush();
  int numFailures=result.getFailureCount();
  String className=description.getClassName();
  String methodName=description.getMethodName();
  if (numFailures < 0) {
    throw new IllegalStateException(String.format(""String_Node_Str"",className,methodName,numFailures,result.getFailures()));
  }
  Failure failure;
  ResultType type;
  if (assumptionFailure != null) {
    failure=assumptionFailure;
    type=ResultType.ASSUMPTION_VIOLATION;
    assumptionFailure=null;
  }
 else   if (numFailures == 0) {
    failure=null;
    type=ResultType.SUCCESS;
  }
 else {
    failure=result.getFailures().get(0);
    type=ResultType.FAILURE;
  }
  String stdOut=rawStdOutBytes.size() == 0 ? null : rawStdOutBytes.toString(ENCODING);
  String stdErr=rawStdErrBytes.size() == 0 ? null : rawStdErrBytes.toString(ENCODING);
  results.add(new TestResult(className,methodName,result.getRunTime(),type,failure,stdOut,stdErr));
}",0.9766666666666668
53250,"/** 
 * The regular listener we created from the singular result, in this class, will not by default treat assumption failures as regular failures, and will not store them.  As a consequence, we store them ourselves!
 */
@Override public void testAssumptionFailure(Failure failure){
  assumptionFailures.add(failure);
  if (resultListener != null) {
    resultListener.testAssumptionFailure(failure);
  }
}","/** 
 * The regular listener we created from the singular result, in this class, will not by default treat assumption failures as regular failures, and will not store them.  As a consequence, we store them ourselves! We store the assumption-failure in a temporary field, which we'll make sure we clear each time we write results.
 */
@Override public void testAssumptionFailure(Failure failure){
  assumptionFailure=failure;
  if (resultListener != null) {
    resultListener.testAssumptionFailure(failure);
  }
}",0.6942328618063112
53251,"/** 
 * Format a target string so that the path to the BUCK file its in is easily copyable.
 */
private String formatTarget(BuildTarget buildTarget){
  String targetString=buildTarget.toString();
  return String.format(""String_Node_Str"",buildTarget.getBuildFilePath(),buildTarget.getShortNameOnly());
}","/** 
 * Format a target string so that the path to the BUCK file its in is easily copyable.
 */
private String formatTarget(BuildTarget buildTarget){
  return String.format(""String_Node_Str"",buildTarget.getBuildFilePath(),buildTarget.getShortNameOnly());
}",0.9175627240143368
53252,"/** 
 * @return the list of arguments to pass to ProGuard. 
 */
@VisibleForTesting ImmutableList<String> getParameters(ExecutionContext context){
  ImmutableList.Builder<String> args=ImmutableList.builder();
  AndroidPlatformTarget androidPlatformTarget=context.getAndroidPlatformTarget();
  Joiner pathJoiner=Joiner.on(':');
  args.add(""String_Node_Str"").add(context.getProjectDirectoryRoot().getAbsolutePath());
switch (sdkProguardConfig) {
case OPTIMIZED:
    args.add(""String_Node_Str"").add(androidPlatformTarget.getOptimizedProguardConfig().toString());
  if (optimizationPasses.isPresent()) {
    args.add(""String_Node_Str"").add(optimizationPasses.get().toString());
  }
break;
case DEFAULT:
args.add(""String_Node_Str"").add(androidPlatformTarget.getProguardConfig().toString());
break;
case NONE:
break;
default :
throw new RuntimeException(""String_Node_Str"" + sdkProguardConfig);
}
for (Path proguardConfig : customProguardConfigs) {
args.add(""String_Node_Str"").add(proguardConfig.toString());
}
args.add(""String_Node_Str"").add(generatedProGuardConfig.toString());
for (Map.Entry<Path,Path> inputOutputEntry : inputAndOutputEntries.entrySet()) {
args.add(""String_Node_Str"").add(inputOutputEntry.getKey().toString());
args.add(""String_Node_Str"").add(inputOutputEntry.getValue().toString());
}
Iterable<Path> bootclasspathPaths=androidPlatformTarget.getBootclasspathEntries();
Iterable<Path> libraryJars=Iterables.concat(bootclasspathPaths,additionalLibraryJarsForProguard);
args.add(""String_Node_Str"").add(pathJoiner.join(libraryJars));
args.add(""String_Node_Str"").add(getMappingTxt().toString());
args.add(""String_Node_Str"").add(getConfigurationTxt().toString());
return args.build();
}","/** 
 * @return the list of arguments to pass to ProGuard. 
 */
@VisibleForTesting ImmutableList<String> getParameters(ExecutionContext context){
  ImmutableList.Builder<String> args=ImmutableList.builder();
  AndroidPlatformTarget androidPlatformTarget=context.getAndroidPlatformTarget();
  args.add(""String_Node_Str"").add(context.getProjectDirectoryRoot().getAbsolutePath());
switch (sdkProguardConfig) {
case OPTIMIZED:
    args.add(""String_Node_Str"").add(androidPlatformTarget.getOptimizedProguardConfig().toString());
  if (optimizationPasses.isPresent()) {
    args.add(""String_Node_Str"").add(optimizationPasses.get().toString());
  }
break;
case DEFAULT:
args.add(""String_Node_Str"").add(androidPlatformTarget.getProguardConfig().toString());
break;
case NONE:
break;
default :
throw new RuntimeException(""String_Node_Str"" + sdkProguardConfig);
}
for (Path proguardConfig : customProguardConfigs) {
args.add(""String_Node_Str"").add(proguardConfig.toString());
}
args.add(""String_Node_Str"").add(generatedProGuardConfig.toString());
for (Map.Entry<Path,Path> inputOutputEntry : inputAndOutputEntries.entrySet()) {
args.add(""String_Node_Str"").add(inputOutputEntry.getKey().toString());
args.add(""String_Node_Str"").add(inputOutputEntry.getValue().toString());
}
Iterable<Path> bootclasspathPaths=androidPlatformTarget.getBootclasspathEntries();
Iterable<Path> libraryJars=Iterables.concat(bootclasspathPaths,additionalLibraryJarsForProguard);
args.add(""String_Node_Str"").add(Joiner.on(':').join(libraryJars));
args.add(""String_Node_Str"").add(getMappingTxt().toString());
args.add(""String_Node_Str"").add(getConfigurationTxt().toString());
return args.build();
}",0.9856887298747764
53253,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  PythonPackageComponents that=(PythonPackageComponents)o;
  if (modules != null ? !modules.equals(that.modules) : that.modules != null)   return false;
  if (nativeLibraries != null ? !nativeLibraries.equals(that.nativeLibraries) : that.nativeLibraries != null)   return false;
  if (resources != null ? !resources.equals(that.resources) : that.resources != null)   return false;
  return true;
}","@Override public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (o == null || getClass() != o.getClass()) {
    return false;
  }
  PythonPackageComponents that=(PythonPackageComponents)o;
  if (modules != null ? !modules.equals(that.modules) : that.modules != null) {
    return false;
  }
  if (nativeLibraries != null ? !nativeLibraries.equals(that.nativeLibraries) : that.nativeLibraries != null) {
    return false;
  }
  if (resources != null ? !resources.equals(that.resources) : that.resources != null) {
    return false;
  }
  return true;
}",0.8018018018018018
53254,"/** 
 * Verify that owners are correctly detected: - one owner, multiple inputs, json output
 */
@Test public void verifyInputsWithOneOwnerAreCorrectlyReportedInJson() throws CmdLineException, IOException {
  FakeProjectFilesystem filesystem=new FakeProjectFilesystem(){
    @Override public File getFileForRelativePath(    String pathRelativeToProjectRoot){
      return new ExistingFile(getProjectRoot(),pathRelativeToProjectRoot);
    }
  }
;
  String[] args=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ImmutableSortedSet<Path> inputs=MorePaths.asPaths(ImmutableSortedSet.copyOf(args));
  BuildTarget target=new BuildTarget(""String_Node_Str"",""String_Node_Str"");
  BuildRule ownerRule=new StubBuildRule(target,inputs);
  MutableDirectedGraph<BuildRule> mutableGraph=new MutableDirectedGraph<BuildRule>();
  mutableGraph.addNode(ownerRule);
  DependencyGraph graph=new DependencyGraph(mutableGraph);
  AuditOwnerOptions options=getOptions(args);
  AuditOwnerCommand command=createAuditOwnerCommand(filesystem);
  AuditOwnerCommand.OwnersReport report=command.generateOwnersReport(graph,options);
  command.printOwnersOnlyJsonReport(report);
  String EXPECTED_JSON=Joiner.on(""String_Node_Str"").join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(EXPECTED_JSON,console.getTextWrittenToStdOut());
  assertEquals(""String_Node_Str"",console.getTextWrittenToStdErr());
}","/** 
 * Verify that owners are correctly detected: - one owner, multiple inputs, json output
 */
@Test public void verifyInputsWithOneOwnerAreCorrectlyReportedInJson() throws CmdLineException, IOException {
  FakeProjectFilesystem filesystem=new FakeProjectFilesystem(){
    @Override public File getFileForRelativePath(    String pathRelativeToProjectRoot){
      return new ExistingFile(getProjectRoot(),pathRelativeToProjectRoot);
    }
  }
;
  String[] args=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ImmutableSortedSet<Path> inputs=MorePaths.asPaths(ImmutableSortedSet.copyOf(args));
  BuildTarget target=new BuildTarget(""String_Node_Str"",""String_Node_Str"");
  BuildRule ownerRule=new StubBuildRule(target,inputs);
  MutableDirectedGraph<BuildRule> mutableGraph=new MutableDirectedGraph<BuildRule>();
  mutableGraph.addNode(ownerRule);
  DependencyGraph graph=new DependencyGraph(mutableGraph);
  AuditOwnerOptions options=getOptions(args);
  AuditOwnerCommand command=createAuditOwnerCommand(filesystem);
  AuditOwnerCommand.OwnersReport report=command.generateOwnersReport(graph,options);
  command.printOwnersOnlyJsonReport(report);
  String expectedJson=Joiner.on(""String_Node_Str"").join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(expectedJson,console.getTextWrittenToStdOut());
  assertEquals(""String_Node_Str"",console.getTextWrittenToStdErr());
}",0.9841379310344828
53255,"@Override public int compare(File file1,File file2){
  long lastModifiedTimeDifference=file2.lastModified() - file1.lastModified();
  if (lastModifiedTimeDifference != 0) {
    return (int)lastModifiedTimeDifference;
  }
  return file1.toPath().normalize().compareTo(file2.toPath().normalize());
}","@Override public int compare(File file1,File file2){
  long lastModifiedTimeDifference=file2.lastModified() - file1.lastModified();
  if (lastModifiedTimeDifference != 0) {
    return Long.signum(lastModifiedTimeDifference);
  }
  return file1.toPath().normalize().compareTo(file2.toPath().normalize());
}",0.9700996677740864
53256,"/** 
 * @param context an optional NGContext that is present if running inside a Nailgun server.
 * @param args command line arguments
 * @return an exit code or {@code null} if this is a process that should not exit
 */
@SuppressWarnings(""String_Node_Str"") public int executeCommand(File projectRoot,Command.ParseResult commandParseResult,Optional<NGContext> context,String... args) throws IOException {
  ProjectFilesystem projectFilesystem=new ProjectFilesystem(Paths.get(projectRoot.getPath()),createBuckConfig(new ProjectFilesystem(projectRoot),platform).getIgnorePaths());
  BuckConfig config=createBuckConfig(projectFilesystem,platform);
  Verbosity verbosity=VerbosityParser.parse(args);
  Optional<String> color;
  final boolean isDaemon=context.isPresent();
  if (isDaemon && (context.get().getEnv() != null)) {
    String colorString=context.get().getEnv().getProperty(BUCKD_COLOR_DEFAULT_ENV_VAR);
    color=Optional.fromNullable(colorString);
  }
 else {
    color=Optional.absent();
  }
  final Console console=new Console(verbosity,stdOut,stdErr,config.createAnsi(color));
  if (commandParseResult.getErrorText().isPresent()) {
    console.getStdErr().println(commandParseResult.getErrorText().get());
  }
  if (!commandSemaphore.tryAcquire()) {
    return BUSY_EXIT_CODE;
  }
  ProcessExecutor processExecutor=new ProcessExecutor(console);
  int exitCode;
  ImmutableList<BuckEventListener> eventListeners;
  BuildId buildId=new BuildId();
  Clock clock=new DefaultClock();
  ExecutionEnvironment executionEnvironment=new DefaultExecutionEnvironment(processExecutor);
  PropertyFinder propertyFinder=new DefaultPropertyFinder(projectFilesystem);
  AndroidDirectoryResolver androidDirectoryResolver=new DefaultAndroidDirectoryResolver(projectFilesystem,config.getNdkVersion(),propertyFinder);
  JavaBuckConfig javaConfig=new JavaBuckConfig(config);
  JavaCompilerEnvironment javacEnv=javaConfig.getJavaCompilerEnvironment(processExecutor);
  KnownBuildRuleTypes buildRuleTypes=KnownBuildRuleTypes.createInstance(config,androidDirectoryResolver,javacEnv);
  try (AbstractConsoleEventBusListener consoleListener=createConsoleEventListener(clock,console,verbosity,executionEnvironment);BuckEventBus buildEventBus=new BuckEventBus(clock,buildId)){
    Optional<WebServer> webServer=getWebServerIfDaemon(context,projectFilesystem,config,buildRuleTypes,androidDirectoryResolver,console);
    eventListeners=addEventListeners(buildEventBus,projectFilesystem,config,webServer,consoleListener);
    ImmutableList<String> remainingArgs=ImmutableList.copyOf(Arrays.copyOfRange(args,1,args.length));
    Command executingCommand=commandParseResult.getCommand().get();
    String commandName=executingCommand.name().toLowerCase();
    CommandEvent commandEvent=CommandEvent.started(commandName,remainingArgs,isDaemon);
    buildEventBus.post(commandEvent);
    ArtifactCacheFactory artifactCacheFactory=new LoggingArtifactCacheFactory(executionEnvironment,buildEventBus);
    Parser parser;
    if (isDaemon) {
      parser=getParserFromDaemon(context,projectFilesystem,config,buildRuleTypes,androidDirectoryResolver,console,commandEvent,buildEventBus);
    }
 else {
      JavaUtilsLoggingBuildListener.ensureLogFileIsWritten(projectFilesystem);
      parser=new Parser(projectFilesystem,buildRuleTypes,console,config.getPythonInterpreter(),config.getTempFilePatterns(),createRuleKeyBuilderFactory(new DefaultFileHashCache(projectFilesystem,console)));
    }
    CachingBuildEngine buildEngine=new CachingBuildEngine();
    exitCode=executingCommand.execute(remainingArgs,config,new CommandRunnerParams(console,projectFilesystem,androidDirectoryResolver,buildRuleTypes,buildEngine,artifactCacheFactory,buildEventBus,parser,platform));
    artifactCacheFactory.closeCreatedArtifactCaches(ARTIFACT_CACHE_TIMEOUT_IN_SECONDS);
    if (webServer.isPresent()) {
      int port=webServer.get().getPort();
      buildEventBus.post(LogEvent.info(""String_Node_Str"",port,buildId));
    }
    buildEventBus.post(CommandEvent.finished(commandName,remainingArgs,isDaemon,exitCode));
  }
  finally {
    commandSemaphore.release();
  }
  if (isDaemon && !config.getFlushEventsBeforeExit()) {
    context.get().in.close();
    context.get().exit(exitCode);
  }
  for (  BuckEventListener eventListener : eventListeners) {
    try {
      eventListener.outputTrace(buildId);
    }
 catch (    RuntimeException e) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
    }
  }
  return exitCode;
}","/** 
 * @param context an optional NGContext that is present if running inside a Nailgun server.
 * @param args command line arguments
 * @return an exit code or {@code null} if this is a process that should not exit
 */
@SuppressWarnings(""String_Node_Str"") public int executeCommand(File projectRoot,Command.ParseResult commandParseResult,Optional<NGContext> context,String... args) throws IOException {
  ProjectFilesystem projectFilesystem=new ProjectFilesystem(Paths.get(projectRoot.getPath()),createBuckConfig(new ProjectFilesystem(projectRoot),platform).getIgnorePaths());
  BuckConfig config=createBuckConfig(projectFilesystem,platform);
  Verbosity verbosity=VerbosityParser.parse(args);
  Optional<String> color;
  final boolean isDaemon=context.isPresent();
  if (isDaemon && (context.get().getEnv() != null)) {
    String colorString=context.get().getEnv().getProperty(BUCKD_COLOR_DEFAULT_ENV_VAR);
    color=Optional.fromNullable(colorString);
  }
 else {
    color=Optional.absent();
  }
  final Console console=new Console(verbosity,stdOut,stdErr,config.createAnsi(color));
  if (commandParseResult.getErrorText().isPresent()) {
    console.getStdErr().println(commandParseResult.getErrorText().get());
  }
  if (!commandSemaphore.tryAcquire()) {
    return BUSY_EXIT_CODE;
  }
  ProcessExecutor processExecutor=new ProcessExecutor(console);
  int exitCode;
  ImmutableList<BuckEventListener> eventListeners;
  BuildId buildId=new BuildId();
  Clock clock=new DefaultClock();
  ExecutionEnvironment executionEnvironment=new DefaultExecutionEnvironment(processExecutor);
  PropertyFinder propertyFinder=new DefaultPropertyFinder(projectFilesystem);
  AndroidDirectoryResolver androidDirectoryResolver=new DefaultAndroidDirectoryResolver(projectFilesystem,config.getNdkVersion(),propertyFinder);
  JavaBuckConfig javaConfig=new JavaBuckConfig(config);
  JavaCompilerEnvironment javacEnv=javaConfig.getJavaCompilerEnvironment(processExecutor);
  KnownBuildRuleTypes buildRuleTypes=KnownBuildRuleTypes.createInstance(config,androidDirectoryResolver,javacEnv);
  try (AbstractConsoleEventBusListener consoleListener=createConsoleEventListener(clock,console,verbosity,executionEnvironment);BuckEventBus buildEventBus=new BuckEventBus(clock,buildId)){
    Optional<WebServer> webServer=getWebServerIfDaemon(context,projectFilesystem,config,buildRuleTypes,androidDirectoryResolver,console);
    eventListeners=addEventListeners(buildEventBus,projectFilesystem,config,webServer,consoleListener);
    ImmutableList<String> remainingArgs=ImmutableList.copyOf(Arrays.copyOfRange(args,1,args.length));
    Command executingCommand=commandParseResult.getCommand().get();
    String commandName=executingCommand.name().toLowerCase();
    CommandEvent commandEvent=CommandEvent.started(commandName,remainingArgs,isDaemon);
    buildEventBus.post(commandEvent);
    ArtifactCacheFactory artifactCacheFactory=new LoggingArtifactCacheFactory(executionEnvironment,buildEventBus);
    Parser parser;
    if (isDaemon) {
      parser=getParserFromDaemon(context,projectFilesystem,config,buildRuleTypes,androidDirectoryResolver,console,commandEvent,buildEventBus);
    }
 else {
      parser=new Parser(projectFilesystem,buildRuleTypes,console,config.getPythonInterpreter(),config.getTempFilePatterns(),createRuleKeyBuilderFactory(new DefaultFileHashCache(projectFilesystem,console)));
    }
    JavaUtilsLoggingBuildListener.ensureLogFileIsWritten(projectFilesystem);
    CachingBuildEngine buildEngine=new CachingBuildEngine();
    exitCode=executingCommand.execute(remainingArgs,config,new CommandRunnerParams(console,projectFilesystem,androidDirectoryResolver,buildRuleTypes,buildEngine,artifactCacheFactory,buildEventBus,parser,platform));
    artifactCacheFactory.closeCreatedArtifactCaches(ARTIFACT_CACHE_TIMEOUT_IN_SECONDS);
    if (webServer.isPresent()) {
      int port=webServer.get().getPort();
      buildEventBus.post(LogEvent.info(""String_Node_Str"",port,buildId));
    }
    buildEventBus.post(CommandEvent.finished(commandName,remainingArgs,isDaemon,exitCode));
  }
  finally {
    commandSemaphore.release();
  }
  if (isDaemon && !config.getFlushEventsBeforeExit()) {
    context.get().in.close();
    context.get().exit(exitCode);
  }
  for (  BuckEventListener eventListener : eventListeners) {
    try {
      eventListener.outputTrace(buildId);
    }
 catch (    RuntimeException e) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
    }
  }
  return exitCode;
}",0.9529098178587294
53257,"private int execute(ImmutableList<String> command,ImmutableMap<String,String> environment){
  Preconditions.checkNotNull(command);
  ProcessBuilder processBuilder=new ProcessBuilder(command);
  processBuilder.directory(workingDirectory);
  for (  ImmutableMap.Entry<String,String> entry : environment.entrySet()) {
    processBuilder.environment().put(entry.getKey(),entry.getValue());
  }
  try {
    Process process=processBuilder.start();
    int exitCode;
    Future<String> stdoutFuture=readStream(process.getInputStream());
    Future<String> stderrFuture=readStream(process.getErrorStream());
    exitCode=process.waitFor();
    stdout=stdoutFuture.get();
    stderr=stderrFuture.get();
    return exitCode;
  }
 catch (  IOException e) {
    LOG.error(e);
  }
catch (  ExecutionException e) {
    LOG.error(e);
  }
catch (  InterruptedException e) {
    LOG.error(e);
  }
  return -1;
}","public int execute(String... args){
  ImmutableList<String> command=ImmutableList.<String>builder().add(buckPath).addAll(ImmutableList.copyOf(args)).build();
  return execute(command,ImmutableMap.<String,String>of());
}",0.0557053009883198
53258,"@Override public List<Step> getBuildSteps(BuildContext context,BuildableContext buildableContext) throws IOException {
  if (filteredResourcesProvider.getResDirectories().isEmpty()) {
    buildableContext.addMetadata(STRING_ASSETS_ZIP_HASH,Hashing.sha1().hashInt(0).toString());
    return ImmutableList.of();
  }
  ImmutableList.Builder<Step> steps=ImmutableList.builder();
  Path pathToBaseDir=getPathToStringAssetsDir();
  Path pathToDirContainingAssetsDir=pathToBaseDir.resolve(""String_Node_Str"");
  steps.add(new MakeCleanDirectoryStep(pathToDirContainingAssetsDir));
  Path pathToStrings=pathToDirContainingAssetsDir.resolve(""String_Node_Str"").resolve(""String_Node_Str"");
  Path pathToStringAssetsZip=getPathToStringAssetsZip();
  steps.add(new MakeCleanDirectoryStep(pathToStrings));
  steps.add(new CompileStringsStep(filteredResourcesProvider.getNonEnglishStringFiles(),uberRDotJava.getPathToGeneratedRDotJavaSrcFiles(),pathToStrings));
  steps.add(new ZipStep(pathToStringAssetsZip,ImmutableSet.<Path>of(),false,ZipStep.MAX_COMPRESSION_LEVEL,pathToDirContainingAssetsDir));
  steps.add(new RecordFileSha1Step(pathToStringAssetsZip,STRING_ASSETS_ZIP_HASH,buildableContext));
  return steps.build();
}","@Override public List<Step> getBuildSteps(BuildContext context,BuildableContext buildableContext) throws IOException {
  if (filteredResourcesProvider.getResDirectories().isEmpty()) {
    buildableContext.addMetadata(STRING_ASSETS_ZIP_HASH,Hashing.sha1().hashInt(0).toString());
    return ImmutableList.of();
  }
  ImmutableList.Builder<Step> steps=ImmutableList.builder();
  Path pathToBaseDir=getPathToStringAssetsDir();
  Path pathToDirContainingAssetsDir=pathToBaseDir.resolve(""String_Node_Str"");
  steps.add(new MakeCleanDirectoryStep(pathToDirContainingAssetsDir));
  Path pathToStrings=pathToDirContainingAssetsDir.resolve(""String_Node_Str"").resolve(""String_Node_Str"");
  Path pathToStringAssetsZip=getPathToStringAssetsZip();
  steps.add(new MakeCleanDirectoryStep(pathToStrings));
  steps.add(new CompileStringsStep(filteredResourcesProvider.getNonEnglishStringFiles(),uberRDotJava.getPathToGeneratedRDotJavaSrcFiles(),pathToStrings));
  steps.add(new ZipStep(pathToStringAssetsZip,ImmutableSet.<Path>of(),false,ZipStep.MAX_COMPRESSION_LEVEL,pathToDirContainingAssetsDir));
  steps.add(new RecordFileSha1Step(pathToStringAssetsZip,STRING_ASSETS_ZIP_HASH,buildableContext));
  buildableContext.recordArtifact(pathToStringAssetsZip);
  return steps.build();
}",0.9765751211631664
53259,"private Parser getParserFromDaemon(Optional<NGContext> context,ProjectFilesystem projectFilesystem,BuckConfig config,Console console,CommandEvent commandEvent,BuckEventBus eventBus) throws IOException {
  Daemon daemon=getDaemon(projectFilesystem,config,console);
  daemon.watchClient(context.get());
  daemon.watchFileSystem(console,commandEvent,eventBus);
  daemon.initWebServer();
  return daemon.getParser();
}","private Parser getParserFromDaemon(Optional<NGContext> context,ProjectFilesystem projectFilesystem,BuckConfig config,KnownBuildRuleTypes knownBuildRuleTypes,AndroidDirectoryResolver androidDirectoryResolver,Console console,CommandEvent commandEvent,BuckEventBus eventBus) throws IOException {
  Daemon daemon=getDaemon(projectFilesystem,config,knownBuildRuleTypes,androidDirectoryResolver,console);
  daemon.watchClient(context.get());
  daemon.watchFileSystem(console,commandEvent,eventBus);
  daemon.initWebServer();
  return daemon.getParser();
}",0.8598130841121495
53260,"private Optional<WebServer> getWebServerIfDaemon(Optional<NGContext> context,ProjectFilesystem projectFilesystem,BuckConfig config,Console console) throws IOException {
  if (context.isPresent()) {
    return getDaemon(projectFilesystem,config,console).getWebServer();
  }
  return Optional.absent();
}","private Optional<WebServer> getWebServerIfDaemon(Optional<NGContext> context,ProjectFilesystem projectFilesystem,BuckConfig config,KnownBuildRuleTypes knownBuildRuleTypes,AndroidDirectoryResolver androidDirectoryResolver,Console console) throws IOException {
  if (context.isPresent()) {
    Daemon daemon=getDaemon(projectFilesystem,config,knownBuildRuleTypes,androidDirectoryResolver,console);
    return daemon.getWebServer();
  }
  return Optional.absent();
}",0.7503267973856209
53261,"/** 
 * @param context an optional NGContext that is present if running inside a Nailgun server.
 * @param args command line arguments
 * @return an exit code or {@code null} if this is a process that should not exit
 */
@SuppressWarnings(""String_Node_Str"") public int executeCommand(File projectRoot,Command.ParseResult commandParseResult,Optional<NGContext> context,String... args) throws IOException {
  ProjectFilesystem projectFilesystem=new ProjectFilesystem(Paths.get(projectRoot.getPath()),createBuckConfig(new ProjectFilesystem(projectRoot),platform).getIgnorePaths());
  BuckConfig config=createBuckConfig(projectFilesystem,platform);
  Verbosity verbosity=VerbosityParser.parse(args);
  Optional<String> color;
  final boolean isDaemon=context.isPresent();
  if (isDaemon && (context.get().getEnv() != null)) {
    String colorString=context.get().getEnv().getProperty(BUCKD_COLOR_DEFAULT_ENV_VAR);
    color=Optional.fromNullable(colorString);
  }
 else {
    color=Optional.absent();
  }
  final Console console=new Console(verbosity,stdOut,stdErr,config.createAnsi(color));
  if (commandParseResult.getErrorText().isPresent()) {
    console.getStdErr().println(commandParseResult.getErrorText().get());
  }
  if (!commandSemaphore.tryAcquire()) {
    return BUSY_EXIT_CODE;
  }
  int exitCode;
  ImmutableList<BuckEventListener> eventListeners;
  String buildId=MoreStrings.createRandomString();
  Clock clock=new DefaultClock();
  ExecutionEnvironment executionEnvironment=new DefaultExecutionEnvironment();
  try (AbstractConsoleEventBusListener consoleListener=createConsoleEventListener(clock,console,verbosity,executionEnvironment);BuckEventBus buildEventBus=new BuckEventBus(clock,buildId)){
    Optional<WebServer> webServer=getWebServerIfDaemon(context,projectFilesystem,config,console);
    eventListeners=addEventListeners(buildEventBus,projectFilesystem,config,webServer,consoleListener);
    ImmutableList<String> remainingArgs=ImmutableList.copyOf(Arrays.copyOfRange(args,1,args.length));
    Command executingCommand=commandParseResult.getCommand().get();
    String commandName=executingCommand.name().toLowerCase();
    CommandEvent commandEvent=CommandEvent.started(commandName,remainingArgs,isDaemon);
    buildEventBus.post(commandEvent);
    ArtifactCacheFactory artifactCacheFactory=new LoggingArtifactCacheFactory(buildEventBus);
    PropertyFinder propertyFinder=new DefaultPropertyFinder(projectFilesystem);
    AndroidDirectoryResolver androidDirectoryResolver=new DefaultAndroidDirectoryResolver(projectFilesystem,config.getNdkVersion(),propertyFinder);
    Parser parser;
    KnownBuildRuleTypes buildRuleTypes=KnownBuildRuleTypes.getConfigured(config,new ProcessExecutor(console),androidDirectoryResolver);
    if (isDaemon) {
      parser=getParserFromDaemon(context,projectFilesystem,config,console,commandEvent,buildEventBus);
    }
 else {
      JavaUtilsLoggingBuildListener.ensureLogFileIsWritten(projectFilesystem);
      parser=new Parser(projectFilesystem,buildRuleTypes,console,config.getPythonInterpreter(),config.getTempFilePatterns(),createRuleKeyBuilderFactory(new DefaultFileHashCache(projectFilesystem,console)));
    }
    exitCode=executingCommand.execute(remainingArgs,config,new CommandRunnerParams(console,projectFilesystem,androidDirectoryResolver,buildRuleTypes,artifactCacheFactory,buildEventBus,parser,platform));
    artifactCacheFactory.closeCreatedArtifactCaches(ARTIFACT_CACHE_TIMEOUT_IN_SECONDS);
    if (webServer.isPresent()) {
      int port=webServer.get().getPort();
      buildEventBus.post(LogEvent.info(""String_Node_Str"",port,buildId));
    }
    buildEventBus.post(CommandEvent.finished(commandName,remainingArgs,isDaemon,exitCode));
  }
  finally {
    commandSemaphore.release();
  }
  if (isDaemon) {
    context.get().in.close();
    context.get().exit(exitCode);
  }
  for (  BuckEventListener eventListener : eventListeners) {
    try {
      eventListener.outputTrace(buildId);
    }
 catch (    RuntimeException e) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
    }
  }
  return exitCode;
}","/** 
 * @param context an optional NGContext that is present if running inside a Nailgun server.
 * @param args command line arguments
 * @return an exit code or {@code null} if this is a process that should not exit
 */
@SuppressWarnings(""String_Node_Str"") public int executeCommand(File projectRoot,Command.ParseResult commandParseResult,Optional<NGContext> context,String... args) throws IOException {
  ProjectFilesystem projectFilesystem=new ProjectFilesystem(Paths.get(projectRoot.getPath()),createBuckConfig(new ProjectFilesystem(projectRoot),platform).getIgnorePaths());
  BuckConfig config=createBuckConfig(projectFilesystem,platform);
  Verbosity verbosity=VerbosityParser.parse(args);
  Optional<String> color;
  final boolean isDaemon=context.isPresent();
  if (isDaemon && (context.get().getEnv() != null)) {
    String colorString=context.get().getEnv().getProperty(BUCKD_COLOR_DEFAULT_ENV_VAR);
    color=Optional.fromNullable(colorString);
  }
 else {
    color=Optional.absent();
  }
  final Console console=new Console(verbosity,stdOut,stdErr,config.createAnsi(color));
  if (commandParseResult.getErrorText().isPresent()) {
    console.getStdErr().println(commandParseResult.getErrorText().get());
  }
  if (!commandSemaphore.tryAcquire()) {
    return BUSY_EXIT_CODE;
  }
  int exitCode;
  ImmutableList<BuckEventListener> eventListeners;
  String buildId=MoreStrings.createRandomString();
  Clock clock=new DefaultClock();
  ExecutionEnvironment executionEnvironment=new DefaultExecutionEnvironment();
  PropertyFinder propertyFinder=new DefaultPropertyFinder(projectFilesystem);
  AndroidDirectoryResolver androidDirectoryResolver=new DefaultAndroidDirectoryResolver(projectFilesystem,config.getNdkVersion(),propertyFinder);
  KnownBuildRuleTypes buildRuleTypes=KnownBuildRuleTypes.getConfigured(config,new ProcessExecutor(console),androidDirectoryResolver);
  try (AbstractConsoleEventBusListener consoleListener=createConsoleEventListener(clock,console,verbosity,executionEnvironment);BuckEventBus buildEventBus=new BuckEventBus(clock,buildId)){
    Optional<WebServer> webServer=getWebServerIfDaemon(context,projectFilesystem,config,buildRuleTypes,androidDirectoryResolver,console);
    eventListeners=addEventListeners(buildEventBus,projectFilesystem,config,webServer,consoleListener);
    ImmutableList<String> remainingArgs=ImmutableList.copyOf(Arrays.copyOfRange(args,1,args.length));
    Command executingCommand=commandParseResult.getCommand().get();
    String commandName=executingCommand.name().toLowerCase();
    CommandEvent commandEvent=CommandEvent.started(commandName,remainingArgs,isDaemon);
    buildEventBus.post(commandEvent);
    ArtifactCacheFactory artifactCacheFactory=new LoggingArtifactCacheFactory(buildEventBus);
    Parser parser;
    if (isDaemon) {
      parser=getParserFromDaemon(context,projectFilesystem,config,buildRuleTypes,androidDirectoryResolver,console,commandEvent,buildEventBus);
    }
 else {
      JavaUtilsLoggingBuildListener.ensureLogFileIsWritten(projectFilesystem);
      parser=new Parser(projectFilesystem,buildRuleTypes,console,config.getPythonInterpreter(),config.getTempFilePatterns(),createRuleKeyBuilderFactory(new DefaultFileHashCache(projectFilesystem,console)));
    }
    exitCode=executingCommand.execute(remainingArgs,config,new CommandRunnerParams(console,projectFilesystem,androidDirectoryResolver,buildRuleTypes,artifactCacheFactory,buildEventBus,parser,platform));
    artifactCacheFactory.closeCreatedArtifactCaches(ARTIFACT_CACHE_TIMEOUT_IN_SECONDS);
    if (webServer.isPresent()) {
      int port=webServer.get().getPort();
      buildEventBus.post(LogEvent.info(""String_Node_Str"",port,buildId));
    }
    buildEventBus.post(CommandEvent.finished(commandName,remainingArgs,isDaemon,exitCode));
  }
  finally {
    commandSemaphore.release();
  }
  if (isDaemon) {
    context.get().in.close();
    context.get().exit(exitCode);
  }
  for (  BuckEventListener eventListener : eventListeners) {
    try {
      eventListener.outputTrace(buildId);
    }
 catch (    RuntimeException e) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
    }
  }
  return exitCode;
}",0.8841978287092883
53262,"public Daemon(ProjectFilesystem projectFilesystem,BuckConfig config,Console console) throws IOException {
  this.config=Preconditions.checkNotNull(config);
  this.console=Preconditions.checkNotNull(console);
  this.hashCache=new DefaultFileHashCache(projectFilesystem,console);
  this.parser=new Parser(projectFilesystem,KnownBuildRuleTypes.getDefault(),console,config.getPythonInterpreter(),config.getTempFilePatterns(),createRuleKeyBuilderFactory(hashCache));
  this.fileEventBus=new EventBus(""String_Node_Str"");
  this.filesystemWatcher=createWatcher(projectFilesystem);
  fileEventBus.register(parser);
  fileEventBus.register(hashCache);
  webServer=createWebServer(config,console,projectFilesystem);
  JavaUtilsLoggingBuildListener.ensureLogFileIsWritten(projectFilesystem);
}","public Daemon(ProjectFilesystem projectFilesystem,KnownBuildRuleTypes knownBuildRuleTypes,AndroidDirectoryResolver androidDirectoryResolver,BuckConfig config,Console console) throws IOException {
  this.config=Preconditions.checkNotNull(config);
  this.console=Preconditions.checkNotNull(console);
  this.hashCache=new DefaultFileHashCache(projectFilesystem,console);
  this.parser=new Parser(projectFilesystem,knownBuildRuleTypes,console,config.getPythonInterpreter(),config.getTempFilePatterns(),createRuleKeyBuilderFactory(hashCache));
  this.androidDirectoryResolver=Preconditions.checkNotNull(androidDirectoryResolver);
  this.fileEventBus=new EventBus(""String_Node_Str"");
  this.filesystemWatcher=createWatcher(projectFilesystem);
  fileEventBus.register(parser);
  fileEventBus.register(hashCache);
  webServer=createWebServer(config,console,projectFilesystem);
  JavaUtilsLoggingBuildListener.ensureLogFileIsWritten(projectFilesystem);
}",0.7562246670526925
53263,"/** 
 * Get or create Daemon.
 */
private Daemon getDaemon(ProjectFilesystem filesystem,BuckConfig config,Console console) throws IOException {
  if (daemon == null) {
    daemon=new Daemon(filesystem,config,console);
  }
 else {
    File parserRoot=daemon.getParser().getProjectRoot();
    if (!filesystem.getProjectRoot().equals(parserRoot)) {
      throw new HumanReadableException(String.format(""String_Node_Str"",filesystem.getProjectRoot(),parserRoot));
    }
    if (!daemon.getConfig().equals(config)) {
      daemon.close();
      daemon=new Daemon(filesystem,config,console);
    }
  }
  return daemon;
}","/** 
 * Get or create Daemon.
 */
private Daemon getDaemon(ProjectFilesystem filesystem,BuckConfig config,KnownBuildRuleTypes knownBuildRuleTypes,AndroidDirectoryResolver androidDirectoryResolver,Console console) throws IOException {
  if (daemon == null) {
    daemon=new Daemon(filesystem,knownBuildRuleTypes,androidDirectoryResolver,config,console);
  }
 else {
    File parserRoot=daemon.getParser().getProjectRoot();
    if (!filesystem.getProjectRoot().equals(parserRoot)) {
      throw new HumanReadableException(String.format(""String_Node_Str"",filesystem.getProjectRoot(),parserRoot));
    }
    if (!daemon.getConfig().equals(config) || !daemon.getAndroidDirectoryResolver().equals(androidDirectoryResolver)) {
      daemon.close();
      daemon=new Daemon(filesystem,knownBuildRuleTypes,androidDirectoryResolver,config,console);
    }
  }
  return daemon;
}",0.8283783783783784
53264,"@Test public void whenSourceInputRemovedThenRebuildFails() throws IOException, InterruptedException {
  final ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",tmp);
  workspace.setUp();
  workspace.runBuckdCommand(""String_Node_Str"",""String_Node_Str"").assertSuccess();
  String fileName=""String_Node_Str"";
  assertTrue(""String_Node_Str"",workspace.getFile(fileName).delete());
  waitForChange(Paths.get(fileName));
  try {
    workspace.runBuckdCommand(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  java.lang.RuntimeException e) {
    assertThat(""String_Node_Str"",e.getMessage(),Matchers.containsString(fileName));
  }
}","@Test public void whenSourceInputRemovedThenRebuildFails() throws IOException, InterruptedException {
  final ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",tmp);
  workspace.setUp();
  workspace.runBuckdCommand(""String_Node_Str"",""String_Node_Str"").assertSuccess();
  String fileName=""String_Node_Str"";
  assertTrue(""String_Node_Str"",workspace.getFile(fileName).delete());
  waitForChange(Paths.get(fileName));
  try {
    workspace.runBuckdCommand(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  java.lang.RuntimeException e) {
    assertThat(""String_Node_Str"",e.getMessage(),containsString(fileName));
  }
}",0.9935576234788832
53265,"@Test public void whenAppBuckFileRemovedThenRebuildFails() throws IOException, InterruptedException {
  final ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",tmp);
  workspace.setUp();
  ProjectWorkspace.ProcessResult result=workspace.runBuckdCommand(""String_Node_Str"",""String_Node_Str"");
  result.assertSuccess();
  String fileName=""String_Node_Str"";
  assertTrue(""String_Node_Str"",workspace.getFile(fileName).delete());
  waitForChange(Paths.get(fileName));
  try {
    workspace.runBuckdCommand(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  HumanReadableException e) {
    assertThat(""String_Node_Str"",e.getMessage(),Matchers.containsString(fileName));
  }
}","@Test public void whenAppBuckFileRemovedThenRebuildFails() throws IOException, InterruptedException {
  final ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",tmp);
  workspace.setUp();
  ProjectWorkspace.ProcessResult result=workspace.runBuckdCommand(""String_Node_Str"",""String_Node_Str"");
  result.assertSuccess();
  String fileName=""String_Node_Str"";
  assertTrue(""String_Node_Str"",workspace.getFile(fileName).delete());
  waitForChange(Paths.get(fileName));
  try {
    workspace.runBuckdCommand(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  HumanReadableException e) {
    assertThat(""String_Node_Str"",e.getMessage(),containsString(fileName));
  }
}",0.993939393939394
53266,"@Test public void whenAppBuckFileInvalidatedThenRebuildFails() throws IOException, InterruptedException {
  final ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",tmp);
  workspace.setUp();
  workspace.runBuckdCommand(""String_Node_Str"",""String_Node_Str"").assertSuccess();
  String fileName=""String_Node_Str"";
  Files.write(""String_Node_Str"".getBytes(Charsets.US_ASCII),workspace.getFile(fileName));
  waitForChange(Paths.get(fileName));
  ProjectWorkspace.ProcessResult result=workspace.runBuckdCommand(""String_Node_Str"",""String_Node_Str"");
  assertThat(""String_Node_Str"",result.getStderr(),Matchers.containsString(""String_Node_Str""));
  result.assertFailure();
}","@Test public void whenAppBuckFileInvalidatedThenRebuildFails() throws IOException, InterruptedException {
  final ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",tmp);
  workspace.setUp();
  workspace.runBuckdCommand(""String_Node_Str"",""String_Node_Str"").assertSuccess();
  String fileName=""String_Node_Str"";
  Files.write(""String_Node_Str"".getBytes(Charsets.US_ASCII),workspace.getFile(fileName));
  waitForChange(Paths.get(fileName));
  ProjectWorkspace.ProcessResult result=workspace.runBuckdCommand(""String_Node_Str"",""String_Node_Str"");
  assertThat(""String_Node_Str"",result.getStderr(),containsString(""String_Node_Str""));
  result.assertFailure();
}",0.9936485532815807
53267,"public InputResolver(Path primaryOutputPath,Supplier<Set<Path>> primaryInputsToDex,Optional<Path> secondaryOutputDir,Optional<Supplier<Multimap<Path,Path>>> secondaryOutputToInputs){
  this.primaryOutputPath=Preconditions.checkNotNull(primaryOutputPath);
  this.primaryInputsToDex=Preconditions.checkNotNull(primaryInputsToDex);
  Preconditions.checkArgument(!(secondaryOutputDir.isPresent() ^ secondaryOutputToInputs.isPresent()),""String_Node_Str"");
  this.secondaryOutputDir=secondaryOutputDir;
  this.secondaryOutputToInputs=secondaryOutputToInputs;
}","public InputResolver(Path primaryOutputPath,Supplier<Set<Path>> primaryInputsToDex,Optional<Path> secondaryOutputDir,Optional<Supplier<Multimap<Path,Path>>> secondaryOutputToInputs){
  this.primaryOutputPath=Preconditions.checkNotNull(primaryOutputPath);
  this.primaryInputsToDex=Preconditions.checkNotNull(primaryInputsToDex);
  Preconditions.checkArgument(!(secondaryOutputDir.isPresent() ^ secondaryOutputToInputs.isPresent()),""String_Node_Str"" + ""String_Node_Str"");
  this.secondaryOutputDir=secondaryOutputDir;
  this.secondaryOutputToInputs=secondaryOutputToInputs;
}",0.9822695035460992
53268,"/** 
 * @param inputPathsToSplit Input paths that would otherwise have been passed to a single dx --dexinvocation.
 * @param secondaryJarMetaPath Output location for the metadata text file describing eachsecondary jar artifact.
 * @param primaryJarPath Output path for the primary jar file.
 * @param secondaryJarDir Output location for secondary jar files.  Note that this directory maybe empty if no secondary jar files are needed.
 * @param secondaryJarPattern Filename pattern for secondary jar files.  Pattern contains one %dargument representing the enumerated secondary zip count (starting at 1).
 * @param proguardFullConfigFile Path to the full generated ProGuard configuration, generatedby the -printconfiguration flag.  This is part of the *output* of ProGuard.
 * @param proguardMappingFile Path to the mapping file generated by ProGuard's obfuscation.
 * @param primaryDexPatterns Set of substrings that, when matched, will cause individual inputclass or resource files to be placed into the primary jar (and thus the primary dex output).
 * @param useLinearAllocSplitDex If true, {@link com.facebook.buck.dalvik.DalvikAwareZipSplitter} will be used. Also,{@code linearAllocHardLimit} must have a positive value in this case.
 */
public SplitZipStep(Set<Path> inputPathsToSplit,Path secondaryJarMetaPath,Path primaryJarPath,Path secondaryJarDir,String secondaryJarPattern,Optional<Path> proguardFullConfigFile,Optional<Path> proguardMappingFile,Set<String> primaryDexPatterns,Optional<Path> primaryDexClassesFile,ZipSplitter.DexSplitStrategy dexSplitStrategy,DexStore dexStore,Path pathToReportDir,boolean useLinearAllocSplitDex,long linearAllocHardLimit){
  this.inputPathsToSplit=ImmutableSet.copyOf(inputPathsToSplit);
  this.secondaryJarMetaPath=Preconditions.checkNotNull(secondaryJarMetaPath);
  this.primaryJarPath=Preconditions.checkNotNull(primaryJarPath);
  this.secondaryJarDir=Preconditions.checkNotNull(secondaryJarDir);
  this.secondaryJarPattern=Preconditions.checkNotNull(secondaryJarPattern);
  this.proguardFullConfigFile=Preconditions.checkNotNull(proguardFullConfigFile);
  this.proguardMappingFile=Preconditions.checkNotNull(proguardMappingFile);
  this.primaryDexPatterns=ImmutableSet.copyOf(primaryDexPatterns);
  this.primaryDexClassesFile=Preconditions.checkNotNull(primaryDexClassesFile);
  this.dexSplitStrategy=Preconditions.checkNotNull(dexSplitStrategy);
  this.dexStore=Preconditions.checkNotNull(dexStore);
  this.pathToReportDir=Preconditions.checkNotNull(pathToReportDir);
  this.useLinearAllocSplitDex=useLinearAllocSplitDex;
  this.linearAllocHardLimit=linearAllocHardLimit;
  this.stepFinished=false;
  Preconditions.checkArgument(proguardFullConfigFile.isPresent() == proguardMappingFile.isPresent(),""String_Node_Str"");
}","/** 
 * @param inputPathsToSplit Input paths that would otherwise have been passed to a single dx --dexinvocation.
 * @param secondaryJarMetaPath Output location for the metadata text file describing eachsecondary jar artifact.
 * @param primaryJarPath Output path for the primary jar file.
 * @param secondaryJarDir Output location for secondary jar files.  Note that this directory maybe empty if no secondary jar files are needed.
 * @param secondaryJarPattern Filename pattern for secondary jar files.  Pattern contains one %dargument representing the enumerated secondary zip count (starting at 1).
 * @param proguardFullConfigFile Path to the full generated ProGuard configuration, generatedby the -printconfiguration flag.  This is part of the *output* of ProGuard.
 * @param proguardMappingFile Path to the mapping file generated by ProGuard's obfuscation.
 * @param primaryDexPatterns Set of substrings that, when matched, will cause individual inputclass or resource files to be placed into the primary jar (and thus the primary dex output).
 * @param useLinearAllocSplitDex If true, {@link com.facebook.buck.dalvik.DalvikAwareZipSplitter}will be used. Also,  {@code linearAllocHardLimit} must have a positive value in this case.
 */
public SplitZipStep(Set<Path> inputPathsToSplit,Path secondaryJarMetaPath,Path primaryJarPath,Path secondaryJarDir,String secondaryJarPattern,Optional<Path> proguardFullConfigFile,Optional<Path> proguardMappingFile,Set<String> primaryDexPatterns,Optional<Path> primaryDexClassesFile,ZipSplitter.DexSplitStrategy dexSplitStrategy,DexStore dexStore,Path pathToReportDir,boolean useLinearAllocSplitDex,long linearAllocHardLimit){
  this.inputPathsToSplit=ImmutableSet.copyOf(inputPathsToSplit);
  this.secondaryJarMetaPath=Preconditions.checkNotNull(secondaryJarMetaPath);
  this.primaryJarPath=Preconditions.checkNotNull(primaryJarPath);
  this.secondaryJarDir=Preconditions.checkNotNull(secondaryJarDir);
  this.secondaryJarPattern=Preconditions.checkNotNull(secondaryJarPattern);
  this.proguardFullConfigFile=Preconditions.checkNotNull(proguardFullConfigFile);
  this.proguardMappingFile=Preconditions.checkNotNull(proguardMappingFile);
  this.primaryDexPatterns=ImmutableSet.copyOf(primaryDexPatterns);
  this.primaryDexClassesFile=Preconditions.checkNotNull(primaryDexClassesFile);
  this.dexSplitStrategy=Preconditions.checkNotNull(dexSplitStrategy);
  this.dexStore=Preconditions.checkNotNull(dexStore);
  this.pathToReportDir=Preconditions.checkNotNull(pathToReportDir);
  this.useLinearAllocSplitDex=useLinearAllocSplitDex;
  this.linearAllocHardLimit=linearAllocHardLimit;
  this.stepFinished=false;
  Preconditions.checkArgument(proguardFullConfigFile.isPresent() == proguardMappingFile.isPresent(),""String_Node_Str"");
}",0.999458972046889
53269,"@Override public int execute(ExecutionContext context){
  List<DexWithClasses> primaryDexContents=Lists.newArrayList();
  List<List<DexWithClasses>> secondaryDexesContents=Lists.newArrayList();
  int primaryDexSize=0;
  if (rDotJavaDex.isPresent()) {
    primaryDexSize+=rDotJavaDex.get().getSizeEstimate();
    primaryDexContents.add(rDotJavaDex.get());
  }
  ImmutableList<DexWithClasses> sortedDexFilesToMerge=FluentIterable.from(dexFilesToMerge).toSortedList(DexWithClasses.DEX_WITH_CLASSES_COMPARATOR);
  List<DexWithClasses> currentSecondaryDexContents=null;
  int currentSecondaryDexSize=0;
  for (  DexWithClasses dexWithClasses : sortedDexFilesToMerge) {
    if (mustBeInPrimaryDex(dexWithClasses)) {
      primaryDexSize+=dexWithClasses.getSizeEstimate();
      if (primaryDexSize > linearAllocHardLimit) {
        context.postEvent(LogEvent.severe(""String_Node_Str"" + ""String_Node_Str"",dexWithClasses.getPathToDexFile(),dexWithClasses.getSizeEstimate(),primaryDexSize,linearAllocHardLimit));
        return 1;
      }
      primaryDexContents.add(dexWithClasses);
    }
 else {
      if (dexWithClasses.getSizeEstimate() > linearAllocHardLimit) {
        context.postEvent(LogEvent.severe(""String_Node_Str"",dexWithClasses.getPathToDexFile(),dexWithClasses.getSizeEstimate(),linearAllocHardLimit));
        return 1;
      }
      if (currentSecondaryDexContents == null || dexWithClasses.getSizeEstimate() + currentSecondaryDexSize > linearAllocHardLimit) {
        DexWithClasses canary;
        try {
          canary=createCanary(secondaryDexesContents.size() + 1,context);
        }
 catch (        IOException e) {
          context.logError(e,""String_Node_Str"");
          return 1;
        }
        currentSecondaryDexContents=Lists.newArrayList(canary);
        currentSecondaryDexSize=canary.getSizeEstimate();
        secondaryDexesContents.add(currentSecondaryDexContents);
      }
      currentSecondaryDexContents.add(dexWithClasses);
      currentSecondaryDexSize+=dexWithClasses.getSizeEstimate();
    }
  }
  primaryDexInputs=FluentIterable.from(primaryDexContents).transform(DexWithClasses.TO_PATH).toSet();
  metadataTxtEntries=Maps.newHashMap();
  String pattern=""String_Node_Str"" + dexStore.getExtension();
  ImmutableMultimap.Builder<Path,Path> builder=ImmutableMultimap.builder();
  for (int index=0; index < secondaryDexesContents.size(); index++) {
    String secondaryDexFilename=String.format(pattern,index + 1);
    Path pathToSecondaryDex=secondaryDexJarFilesDir.resolve(secondaryDexFilename);
    metadataTxtEntries.put(pathToSecondaryDex,secondaryDexesContents.get(0).get(0));
    Collection<Path> dexContentPaths=Collections2.transform(secondaryDexesContents.get(index),DexWithClasses.TO_PATH);
    builder.putAll(pathToSecondaryDex,dexContentPaths);
  }
  secondaryOutputToInputs=builder.build();
  return 0;
}","@Override public int execute(ExecutionContext context){
  List<DexWithClasses> primaryDexContents=Lists.newArrayList();
  List<List<DexWithClasses>> secondaryDexesContents=Lists.newArrayList();
  int primaryDexSize=0;
  if (rDotJavaDex.isPresent()) {
    primaryDexSize+=rDotJavaDex.get().getSizeEstimate();
    primaryDexContents.add(rDotJavaDex.get());
  }
  ImmutableList<DexWithClasses> sortedDexFilesToMerge=FluentIterable.from(dexFilesToMerge).toSortedList(DexWithClasses.DEX_WITH_CLASSES_COMPARATOR);
  List<DexWithClasses> currentSecondaryDexContents=null;
  int currentSecondaryDexSize=0;
  for (  DexWithClasses dexWithClasses : sortedDexFilesToMerge) {
    if (mustBeInPrimaryDex(dexWithClasses)) {
      primaryDexSize+=dexWithClasses.getSizeEstimate();
      if (primaryDexSize > linearAllocHardLimit) {
        context.postEvent(LogEvent.severe(""String_Node_Str"" + ""String_Node_Str"",dexWithClasses.getPathToDexFile(),dexWithClasses.getSizeEstimate(),primaryDexSize,linearAllocHardLimit));
        return 1;
      }
      primaryDexContents.add(dexWithClasses);
    }
 else {
      if (dexWithClasses.getSizeEstimate() > linearAllocHardLimit) {
        context.postEvent(LogEvent.severe(""String_Node_Str"",dexWithClasses.getPathToDexFile(),dexWithClasses.getSizeEstimate(),linearAllocHardLimit));
        return 1;
      }
      if (currentSecondaryDexContents == null || dexWithClasses.getSizeEstimate() + currentSecondaryDexSize > linearAllocHardLimit) {
        DexWithClasses canary;
        try {
          canary=createCanary(secondaryDexesContents.size() + 1,context);
        }
 catch (        IOException e) {
          context.logError(e,""String_Node_Str"");
          return 1;
        }
        currentSecondaryDexContents=Lists.newArrayList(canary);
        currentSecondaryDexSize=canary.getSizeEstimate();
        secondaryDexesContents.add(currentSecondaryDexContents);
      }
      currentSecondaryDexContents.add(dexWithClasses);
      currentSecondaryDexSize+=dexWithClasses.getSizeEstimate();
    }
  }
  primaryDexInputs=FluentIterable.from(primaryDexContents).transform(DexWithClasses.TO_PATH).toSet();
  metadataTxtEntries=Maps.newHashMap();
  String pattern=""String_Node_Str"" + dexStore.getExtension();
  ImmutableMultimap.Builder<Path,Path> builder=ImmutableMultimap.builder();
  for (int index=0; index < secondaryDexesContents.size(); index++) {
    String secondaryDexFilename=String.format(pattern,index + 1);
    Path pathToSecondaryDex=secondaryDexJarFilesDir.resolve(secondaryDexFilename);
    metadataTxtEntries.put(pathToSecondaryDex,secondaryDexesContents.get(index).get(0));
    Collection<Path> dexContentPaths=Collections2.transform(secondaryDexesContents.get(index),DexWithClasses.TO_PATH);
    builder.putAll(pathToSecondaryDex,dexContentPaths);
  }
  secondaryOutputToInputs=builder.build();
  return 0;
}",0.9989495798319328
53270,"/** 
 * The step to produce the .dex file will be determined by the file extension of outputPath, much as   {@code dx} itself chooses whether to embed the dex inside a jar/zip based on the destinationfile passed to it.
 */
static Step createDxStepForDxPseudoRule(Iterable<Path> filesToDex,String outputPath,EnumSet<Option> dxOptions){
  if (outputPath.endsWith(DexStore.XZ.getExtension())) {
    List<Step> steps=Lists.newArrayList();
    String tempDexJarOutput=outputPath.replaceAll(""String_Node_Str"",""String_Node_Str"");
    steps.add(new DxStep(tempDexJarOutput,filesToDex,dxOptions));
    String repackedJar=outputPath.replaceAll(""String_Node_Str"",""String_Node_Str"");
    steps.add(new RepackZipEntriesStep(tempDexJarOutput,repackedJar,ImmutableSet.of(""String_Node_Str""),ZipStep.MIN_COMPRESSION_LEVEL));
    steps.add(new RmStep(tempDexJarOutput,true));
    steps.add(new XzStep(repackedJar));
    return new CompositeStep(steps);
  }
 else   if (outputPath.endsWith(DexStore.JAR.getExtension())) {
    return new DxStep(outputPath,filesToDex,dxOptions);
  }
 else {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",outputPath));
  }
}","/** 
 * The step to produce the .dex file will be determined by the file extension of outputPath, much as   {@code dx} itself chooses whether to embed the dex inside a jar/zip based on the destinationfile passed to it.
 */
static Step createDxStepForDxPseudoRule(Iterable<Path> filesToDex,String outputPath,EnumSet<Option> dxOptions){
  if (outputPath.endsWith(DexStore.XZ.getExtension())) {
    List<Step> steps=Lists.newArrayList();
    String tempDexJarOutput=outputPath.replaceAll(""String_Node_Str"",""String_Node_Str"");
    steps.add(new DxStep(tempDexJarOutput,filesToDex,dxOptions));
    String repackedJar=outputPath.replaceAll(""String_Node_Str"",""String_Node_Str"");
    steps.add(new RepackZipEntriesStep(tempDexJarOutput,repackedJar,ImmutableSet.of(""String_Node_Str""),ZipStep.MIN_COMPRESSION_LEVEL));
    steps.add(new RmStep(tempDexJarOutput,true));
    steps.add(new XzStep(repackedJar));
    return new CompositeStep(steps);
  }
 else   if (outputPath.endsWith(DexStore.JAR.getExtension()) || outputPath.endsWith(""String_Node_Str"")) {
    return new DxStep(outputPath,filesToDex,dxOptions);
  }
 else {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",outputPath));
  }
}",0.9822335025380712
53271,"protected void runStepInternal(final Step step,final Optional<BuildTarget> buildTarget) throws StepFailedException {
  Preconditions.checkNotNull(step);
  if (context.getVerbosity().shouldPrintCommand()) {
    context.getStdErr().println(step.getDescription(context));
  }
  context.postEvent(StepEvent.started(step,step.getDescription(context)));
  int exitCode=step.execute(context);
  context.postEvent(StepEvent.finished(step,step.getDescription(context),exitCode));
  if (exitCode != 0) {
    throw StepFailedException.createForFailingStep(step,context,exitCode,buildTarget);
  }
}","protected void runStepInternal(final Step step,final Optional<BuildTarget> buildTarget) throws StepFailedException {
  Preconditions.checkNotNull(step);
  if (context.getVerbosity().shouldPrintCommand()) {
    context.getStdErr().println(step.getDescription(context));
  }
  context.postEvent(StepEvent.started(step,step.getDescription(context)));
  int exitCode=1;
  try {
    exitCode=step.execute(context);
  }
 catch (  Throwable t) {
    throw StepFailedException.createForFailingStepWithException(step,context,t,buildTarget);
  }
 finally {
    context.postEvent(StepEvent.finished(step,step.getDescription(context),exitCode));
  }
  if (exitCode != 0) {
    throw StepFailedException.createForFailingStepWithExitCode(step,context,exitCode,buildTarget);
  }
}",0.8675055514433753
53272,"@Test public void testCreateForFailingStepWithoutBuildTarget(){
  final int exitCode=17;
  Step step=new FakeStep(""String_Node_Str"",""String_Node_Str"",exitCode);
  ExecutionContext context=TestExecutionContext.newInstance();
  StepFailedException exception=StepFailedException.createForFailingStep(step,context,exitCode,Optional.<BuildTarget>absent());
  assertEquals(step,exception.getStep());
  assertEquals(exitCode,exception.getExitCode());
  assertEquals(""String_Node_Str"",exception.getMessage());
}","@Test public void testCreateForFailingStepWithoutBuildTarget(){
  final int exitCode=17;
  Step step=new FakeStep(""String_Node_Str"",""String_Node_Str"",exitCode);
  ExecutionContext context=TestExecutionContext.newInstance();
  StepFailedException exception=StepFailedException.createForFailingStepWithException(step,context,new IOException(""String_Node_Str""),Optional.<BuildTarget>absent());
  assertEquals(step,exception.getStep());
  assertEquals(1,exception.getExitCode());
  assertEquals(""String_Node_Str"",exception.getMessage());
}",0.8111753371868978
53273,"@Test public void testCreateForFailingStepWithBuildTarget(){
  final int exitCode=17;
  Step step=new FakeStep(""String_Node_Str"",""String_Node_Str"",exitCode);
  ExecutionContext context=TestExecutionContext.newInstance();
  BuildTarget buildTarget=new BuildTarget(""String_Node_Str"",""String_Node_Str"");
  StepFailedException exception=StepFailedException.createForFailingStep(step,context,exitCode,Optional.of(buildTarget));
  assertEquals(step,exception.getStep());
  assertEquals(exitCode,exception.getExitCode());
  assertEquals(""String_Node_Str"",exception.getMessage());
}","@Test public void testCreateForFailingStepWithBuildTarget(){
  final int exitCode=17;
  Step step=new FakeStep(""String_Node_Str"",""String_Node_Str"",exitCode);
  ExecutionContext context=TestExecutionContext.newInstance();
  BuildTarget buildTarget=new BuildTarget(""String_Node_Str"",""String_Node_Str"");
  StepFailedException exception=StepFailedException.createForFailingStepWithException(step,context,new IOException(""String_Node_Str""),Optional.of(buildTarget));
  assertEquals(step,exception.getStep());
  assertEquals(1,exception.getExitCode());
  assertEquals(""String_Node_Str"",exception.getMessage());
}",0.6728813559322034
53274,"/** 
 * Returns a list of command-line options to pass to javac.  These options reflect the configuration of this javac command.
 * @param context the ExecutionContext with in which javac will run
 * @return list of String command-line options.
 */
@VisibleForTesting protected ImmutableList<String> getOptions(ExecutionContext context,Set<String> buildClasspathEntries){
  ImmutableList.Builder<String> builder=ImmutableList.builder();
  ProjectFilesystem filesystem=context.getProjectFilesystem();
  AnnotationProcessingDataDecorator decorator;
  if (pathToOutputAbiFile.isPresent()) {
    abiKeyFile=filesystem.getFileForRelativePath(pathToOutputAbiFile.get());
    decorator=new AbiWritingAnnotationProcessingDataDecorator(abiKeyFile);
  }
 else {
    decorator=AnnotationProcessingDataDecorators.identity();
  }
  javacOptions.appendOptionsToList(builder,context.getProjectFilesystem().getPathRelativizer(),decorator);
  if (context.getVerbosity().shouldUseVerbosityFlagIfAvailable()) {
    builder.add(""String_Node_Str"");
  }
  Function<String,Path> pathRelativizer=filesystem.getPathRelativizer();
  builder.add(""String_Node_Str"").add(pathRelativizer.apply(outputDirectory).toString());
  if (!buildClasspathEntries.isEmpty()) {
    String classpath=Joiner.on(File.pathSeparator).join(Iterables.transform(buildClasspathEntries,pathRelativizer));
    builder.add(""String_Node_Str"",classpath);
  }
  return builder.build();
}","/** 
 * Returns a list of command-line options to pass to javac.  These options reflect the configuration of this javac command.
 * @param context the ExecutionContext with in which javac will run
 * @return list of String command-line options.
 */
@VisibleForTesting protected ImmutableList<String> getOptions(ExecutionContext context,Set<String> buildClasspathEntries){
  ImmutableList.Builder<String> builder=ImmutableList.builder();
  ProjectFilesystem filesystem=context.getProjectFilesystem();
  AnnotationProcessingDataDecorator decorator;
  if (pathToOutputAbiFile.isPresent()) {
    abiKeyFile=filesystem.getFileForRelativePath(pathToOutputAbiFile.get());
    decorator=new AbiWritingAnnotationProcessingDataDecorator(abiKeyFile);
  }
 else {
    decorator=AnnotationProcessingDataDecorators.identity();
  }
  javacOptions.appendOptionsToList(builder,context.getProjectFilesystem().getPathRelativizer(),decorator);
  if (context.getVerbosity().shouldUseVerbosityFlagIfAvailable()) {
    builder.add(""String_Node_Str"");
  }
  Function<String,Path> pathRelativizer=filesystem.getPathRelativizer();
  builder.add(""String_Node_Str"").add(pathRelativizer.apply(outputDirectory).toString());
  if (!buildClasspathEntries.isEmpty()) {
    String classpath=Joiner.on(File.pathSeparator).join(Iterables.transform(buildClasspathEntries,pathRelativizer));
    builder.add(""String_Node_Str"",classpath);
  }
 else {
    builder.add(""String_Node_Str"",""String_Node_Str"");
  }
  return builder.build();
}",0.962406015037594
53275,"@Test public void testGetDescription() throws IOException {
  JavacInMemoryStep javac=createJavac(false);
  ExecutionContext executionContext=createExecutionContext();
  String pathToOutputDir=new File(tmp.getRoot(),""String_Node_Str"").getAbsolutePath();
  String pathToAbiFile=new File(tmp.getRoot(),""String_Node_Str"").getAbsolutePath();
  assertEquals(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",AbiWritingAnnotationProcessingDataDecorator.ABI_PROCESSOR_CLASSPATH,AbiWriterProtocol.ABI_ANNOTATION_PROCESSOR_CLASS_NAME,AbiWriterProtocol.PARAM_ABI_OUTPUT_FILE,pathToAbiFile,pathToOutputDir),javac.getDescription(executionContext));
}","@Test public void testGetDescription() throws IOException {
  JavacInMemoryStep javac=createJavac(false);
  ExecutionContext executionContext=createExecutionContext();
  String pathToOutputDir=new File(tmp.getRoot(),""String_Node_Str"").getAbsolutePath();
  String pathToAbiFile=new File(tmp.getRoot(),""String_Node_Str"").getAbsolutePath();
  assertEquals(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",AbiWritingAnnotationProcessingDataDecorator.ABI_PROCESSOR_CLASSPATH,AbiWriterProtocol.ABI_ANNOTATION_PROCESSOR_CLASS_NAME,AbiWriterProtocol.PARAM_ABI_OUTPUT_FILE,pathToAbiFile,pathToOutputDir),javac.getDescription(executionContext));
}",0.9735006973500696
53276,"/** 
 * A set of paths to subtrees that do not contain source files, build files or files that could affect either (buck-out, .idea, .buckd, buck-cache, .git, etc.).
 */
public ImmutableSet<String> getIgnorePaths(){
  final ImmutableMap<String,String> projectConfig=getEntriesForSection(""String_Node_Str"");
  final String IGNORE_KEY=""String_Node_Str"";
  ImmutableSet.Builder<String> builder=ImmutableSet.builder();
  builder.add(BuckConstant.BUCK_OUTPUT_DIRECTORY);
  builder.add(""String_Node_Str"");
  String buckdDir=System.getProperty(BUCK_BUCKD_DIR_KEY,""String_Node_Str"");
  Path cacheDir=getCacheDir();
  for (  String path : ImmutableList.of(buckdDir,cacheDir.toString())) {
    if (!path.isEmpty() && path.charAt(0) != '/') {
      builder.add(path);
    }
  }
  if (projectConfig.containsKey(IGNORE_KEY)) {
    builder.addAll(Splitter.on(',').omitEmptyStrings().trimResults().split(projectConfig.get(IGNORE_KEY)));
  }
  return ImmutableSet.<String>builder().addAll(Iterables.transform(builder.build(),new Function<String,String>(){
    @Override public String apply(    String path){
      return MorePaths.newPathInstance(path).toString();
    }
  }
)).build();
}","/** 
 * A set of paths to subtrees that do not contain source files, build files or files that could affect either (buck-out, .idea, .buckd, buck-cache, .git, etc.).  May return absolute paths as well as relative paths.
 */
public ImmutableSet<Path> getIgnorePaths(){
  final ImmutableMap<String,String> projectConfig=getEntriesForSection(""String_Node_Str"");
  final String IGNORE_KEY=""String_Node_Str"";
  ImmutableSet.Builder<Path> builder=ImmutableSet.builder();
  builder.add(Paths.get(BuckConstant.BUCK_OUTPUT_DIRECTORY));
  builder.add(Paths.get(""String_Node_Str""));
  Path buckdDir=Paths.get(System.getProperty(BUCK_BUCKD_DIR_KEY,""String_Node_Str""));
  Path cacheDir=getCacheDir();
  for (  Path path : ImmutableList.of(buckdDir,cacheDir)) {
    if (!path.toString().isEmpty()) {
      builder.add(path);
    }
  }
  if (projectConfig.containsKey(IGNORE_KEY)) {
    builder.addAll(MorePaths.asPaths(Splitter.on(',').omitEmptyStrings().trimResults().split(projectConfig.get(IGNORE_KEY))));
  }
  return builder.build();
}",0.8007279344858963
53277,"private boolean addSourceFolders(Module module,@Nullable BuildRule buildRule,@Nullable ImmutableList<SourceRoot> sourceRoots,boolean isTestSource){
  if (buildRule == null || sourceRoots == null) {
    return false;
  }
  if (buildRule instanceof AndroidBinaryRule && sourceRoots.isEmpty()) {
    return false;
  }
  if (sourceRoots.isEmpty()) {
    String url=""String_Node_Str"";
    String packagePrefix=javaPackageFinder.findJavaPackageForPath(module.pathToImlFile);
    SourceFolder sourceFolder=new SourceFolder(url,isTestSource,packagePrefix);
    module.sourceFolders.add(sourceFolder);
  }
 else {
    for (    SourceRoot sourceRoot : sourceRoots) {
      SourceFolder sourceFolder=new SourceFolder(String.format(""String_Node_Str"",sourceRoot.getName()),isTestSource);
      module.sourceFolders.add(sourceFolder);
    }
  }
  for (  String relativePath : this.buildFileTree.getChildPaths(buildRule.getBuildTarget())) {
    String excludeFolderUrl=""String_Node_Str"" + relativePath;
    SourceFolder excludeFolder=new SourceFolder(excludeFolderUrl,false);
    module.excludeFolders.add(excludeFolder);
  }
  if (""String_Node_Str"".equals(buildRule.getBuildTarget().getBasePathWithSlash())) {
    for (    String path : projectFilesystem.getIgnorePaths()) {
      module.excludeFolders.add(new SourceFolder(String.format(""String_Node_Str"",path),false));
    }
  }
  return true;
}","private boolean addSourceFolders(Module module,@Nullable BuildRule buildRule,@Nullable ImmutableList<SourceRoot> sourceRoots,boolean isTestSource){
  if (buildRule == null || sourceRoots == null) {
    return false;
  }
  if (buildRule.getProperties().is(PACKAGING) && sourceRoots.isEmpty()) {
    return false;
  }
  if (sourceRoots.isEmpty()) {
    String url=""String_Node_Str"";
    String packagePrefix=javaPackageFinder.findJavaPackageForPath(module.pathToImlFile);
    SourceFolder sourceFolder=new SourceFolder(url,isTestSource,packagePrefix);
    module.sourceFolders.add(sourceFolder);
  }
 else {
    for (    SourceRoot sourceRoot : sourceRoots) {
      SourceFolder sourceFolder=new SourceFolder(String.format(""String_Node_Str"",sourceRoot.getName()),isTestSource);
      module.sourceFolders.add(sourceFolder);
    }
  }
  for (  String relativePath : this.buildFileTree.getChildPaths(buildRule.getBuildTarget())) {
    String excludeFolderUrl=""String_Node_Str"" + relativePath;
    SourceFolder excludeFolder=new SourceFolder(excludeFolderUrl,false);
    module.excludeFolders.add(excludeFolder);
  }
  return true;
}",0.8665870171246516
53278,"private Module createModuleForProjectConfig(ProjectConfigRule projectConfig) throws IOException {
  BuildRule projectRule=projectConfig.getProjectRule();
  Buildable buildable=projectRule.getBuildable();
  Preconditions.checkState(projectRule instanceof JavaLibraryRule || projectRule instanceof AndroidLibraryRule || projectRule instanceof AndroidResourceRule|| projectRule instanceof AndroidBinaryRule|| buildable instanceof NdkLibrary,""String_Node_Str"",projectRule.getType().getName());
  LinkedHashSet<DependentModule> dependencies=Sets.newLinkedHashSet();
  final BuildTarget target=projectConfig.getBuildTarget();
  Module module=new Module(projectRule,target);
  module.name=getIntellijNameForRule(projectRule);
  module.isIntelliJPlugin=projectConfig.getIsIntelliJPlugin();
  String relativePath=projectConfig.getBuildTarget().getBasePathWithSlash();
  module.pathToImlFile=String.format(""String_Node_Str"",relativePath,module.name);
  boolean includeSourceFolder=true;
  boolean hasSourceFoldersForTestRule=addSourceFolders(module,projectConfig.getTestRule(),projectConfig.getTestsSourceRoots(),true);
  BuildRule testRule=projectConfig.getTestRule();
  if (testRule != null) {
    walkRuleAndAdd(testRule,true,dependencies,projectConfig.getSrcRule());
  }
  boolean hasSourceFoldersForSrcRule=addSourceFolders(module,projectConfig.getSrcRule(),projectConfig.getSourceRoots(),false);
  if (!hasSourceFoldersForTestRule && !hasSourceFoldersForSrcRule) {
    includeSourceFolder=false;
  }
  boolean isAndroidRule=projectRule.getProperties().is(ANDROID);
  if (isAndroidRule) {
    boolean hasSourceFolders=!module.sourceFolders.isEmpty();
    module.sourceFolders.add(SourceFolder.GEN);
    if (!hasSourceFolders) {
      includeSourceFolder=true;
    }
  }
  walkRuleAndAdd(projectRule,false,dependencies,projectConfig.getSrcRule());
  String basePathWithSlash=projectConfig.getBuildTarget().getBasePathWithSlash();
  module.moduleGenPath=generateRelativeGenPath(basePathWithSlash).toString();
  DependentModule jdkDependency;
  if (isAndroidRule) {
    if (projectRule.getBuildable() instanceof NdkLibrary) {
      NdkLibrary ndkLibrary=(NdkLibrary)projectRule.getBuildable();
      module.isAndroidLibraryProject=true;
      module.keystorePath=null;
      module.nativeLibs=Paths.get(relativePath).relativize(Paths.get(ndkLibrary.getLibraryPath())).toString();
    }
 else     if (projectRule instanceof AndroidResourceRule) {
      AndroidResourceRule androidResourceRule=(AndroidResourceRule)projectRule;
      module.resFolder=createRelativePath(androidResourceRule.getRes(),target);
      module.isAndroidLibraryProject=true;
      module.keystorePath=null;
    }
 else     if (projectRule instanceof AndroidBinaryRule) {
      AndroidBinaryRule androidBinaryRule=(AndroidBinaryRule)projectRule;
      module.resFolder=null;
      module.isAndroidLibraryProject=false;
      KeystoreProperties keystoreProperties=KeystoreProperties.createFromPropertiesFile(androidBinaryRule.getKeystore().getPathToStore(),androidBinaryRule.getKeystore().getPathToPropertiesFile(),projectFilesystem);
      module.keystorePath=Paths.get(relativePath).relativize(Paths.get(keystoreProperties.getKeystore())).toString();
    }
 else {
      module.isAndroidLibraryProject=true;
      module.keystorePath=null;
    }
    module.hasAndroidFacet=true;
    module.proguardConfigPath=null;
    if (pathToDefaultAndroidManifest.isPresent()) {
      String androidManifest=basePathWithSlash + ""String_Node_Str"";
      if (!projectFilesystem.exists(androidManifest)) {
        String manifestPath=this.pathToDefaultAndroidManifest.get();
        String rootPrefix=""String_Node_Str"";
        Preconditions.checkState(manifestPath.startsWith(rootPrefix),""String_Node_Str"" + ""String_Node_Str"",rootPrefix);
        manifestPath=manifestPath.substring(rootPrefix.length());
        String relativePathToManifest=Paths.get(basePathWithSlash).relativize(Paths.get(manifestPath)).toString();
        module.androidManifest=""String_Node_Str"" + relativePathToManifest;
      }
    }
    jdkDependency=DependentModule.newInheritedJdk();
  }
 else {
    module.hasAndroidFacet=false;
    if (module.isIntelliJPlugin()) {
      jdkDependency=DependentModule.newIntelliJPluginJdk();
    }
 else {
      jdkDependency=DependentModule.newStandardJdk();
    }
  }
  module.dependencies=createDependenciesInOrder(includeSourceFolder,dependencies,jdkDependency);
  if (projectRule instanceof JavaLibraryRule) {
    JavaLibraryRule javaLibraryRule=(JavaLibraryRule)projectRule;
    AnnotationProcessingData processingData=javaLibraryRule.getAnnotationProcessingData();
    String annotationGenSrc=processingData.getGeneratedSourceFolderName();
    if (annotationGenSrc != null) {
      module.annotationGenPath=""String_Node_Str"" + Paths.get(basePathWithSlash).relativize(Paths.get(annotationGenSrc)).toString();
      module.annotationGenIsForTest=!hasSourceFoldersForSrcRule;
    }
  }
  return module;
}","private Module createModuleForProjectConfig(ProjectConfigRule projectConfig) throws IOException {
  BuildRule projectRule=projectConfig.getProjectRule();
  Buildable buildable=projectRule.getBuildable();
  Preconditions.checkState(projectRule instanceof JavaLibraryRule || projectRule instanceof JavaBinaryRule || projectRule instanceof AndroidLibraryRule|| projectRule instanceof AndroidResourceRule|| projectRule instanceof AndroidBinaryRule|| buildable instanceof NdkLibrary,""String_Node_Str"",projectRule.getType().getName());
  LinkedHashSet<DependentModule> dependencies=Sets.newLinkedHashSet();
  final BuildTarget target=projectConfig.getBuildTarget();
  Module module=new Module(projectRule,target);
  module.name=getIntellijNameForRule(projectRule);
  module.isIntelliJPlugin=projectConfig.getIsIntelliJPlugin();
  String relativePath=projectConfig.getBuildTarget().getBasePathWithSlash();
  module.pathToImlFile=String.format(""String_Node_Str"",relativePath,module.name);
  boolean includeSourceFolder=true;
  boolean hasSourceFoldersForTestRule=addSourceFolders(module,projectConfig.getTestRule(),projectConfig.getTestsSourceRoots(),true);
  BuildRule testRule=projectConfig.getTestRule();
  if (testRule != null) {
    walkRuleAndAdd(testRule,true,dependencies,projectConfig.getSrcRule());
  }
  boolean hasSourceFoldersForSrcRule=addSourceFolders(module,projectConfig.getSrcRule(),projectConfig.getSourceRoots(),false);
  addRootExcludes(module,projectConfig.getSrcRule());
  if (!hasSourceFoldersForTestRule && !hasSourceFoldersForSrcRule) {
    includeSourceFolder=false;
  }
  boolean isAndroidRule=projectRule.getProperties().is(ANDROID);
  if (isAndroidRule) {
    boolean hasSourceFolders=!module.sourceFolders.isEmpty();
    module.sourceFolders.add(SourceFolder.GEN);
    if (!hasSourceFolders) {
      includeSourceFolder=true;
    }
  }
  walkRuleAndAdd(projectRule,false,dependencies,projectConfig.getSrcRule());
  String basePathWithSlash=projectConfig.getBuildTarget().getBasePathWithSlash();
  module.moduleGenPath=generateRelativeGenPath(basePathWithSlash).toString();
  DependentModule jdkDependency;
  if (isAndroidRule) {
    if (projectRule.getBuildable() instanceof NdkLibrary) {
      NdkLibrary ndkLibrary=(NdkLibrary)projectRule.getBuildable();
      module.isAndroidLibraryProject=true;
      module.keystorePath=null;
      module.nativeLibs=Paths.get(relativePath).relativize(Paths.get(ndkLibrary.getLibraryPath())).toString();
    }
 else     if (projectRule instanceof AndroidResourceRule) {
      AndroidResourceRule androidResourceRule=(AndroidResourceRule)projectRule;
      module.resFolder=createRelativePath(androidResourceRule.getRes(),target);
      module.isAndroidLibraryProject=true;
      module.keystorePath=null;
    }
 else     if (projectRule instanceof AndroidBinaryRule) {
      AndroidBinaryRule androidBinaryRule=(AndroidBinaryRule)projectRule;
      module.resFolder=null;
      module.isAndroidLibraryProject=false;
      KeystoreProperties keystoreProperties=KeystoreProperties.createFromPropertiesFile(androidBinaryRule.getKeystore().getPathToStore(),androidBinaryRule.getKeystore().getPathToPropertiesFile(),projectFilesystem);
      module.keystorePath=Paths.get(relativePath).relativize(Paths.get(keystoreProperties.getKeystore())).toString();
    }
 else {
      module.isAndroidLibraryProject=true;
      module.keystorePath=null;
    }
    module.hasAndroidFacet=true;
    module.proguardConfigPath=null;
    if (pathToDefaultAndroidManifest.isPresent()) {
      String androidManifest=basePathWithSlash + ""String_Node_Str"";
      if (!projectFilesystem.exists(androidManifest)) {
        String manifestPath=this.pathToDefaultAndroidManifest.get();
        String rootPrefix=""String_Node_Str"";
        Preconditions.checkState(manifestPath.startsWith(rootPrefix),""String_Node_Str"" + ""String_Node_Str"",rootPrefix);
        manifestPath=manifestPath.substring(rootPrefix.length());
        String relativePathToManifest=Paths.get(basePathWithSlash).relativize(Paths.get(manifestPath)).toString();
        module.androidManifest=""String_Node_Str"" + relativePathToManifest;
      }
    }
    jdkDependency=DependentModule.newInheritedJdk();
  }
 else {
    module.hasAndroidFacet=false;
    if (module.isIntelliJPlugin()) {
      jdkDependency=DependentModule.newIntelliJPluginJdk();
    }
 else {
      jdkDependency=DependentModule.newStandardJdk();
    }
  }
  module.dependencies=createDependenciesInOrder(includeSourceFolder,dependencies,jdkDependency);
  if (projectRule instanceof JavaLibraryRule) {
    JavaLibraryRule javaLibraryRule=(JavaLibraryRule)projectRule;
    AnnotationProcessingData processingData=javaLibraryRule.getAnnotationProcessingData();
    String annotationGenSrc=processingData.getGeneratedSourceFolderName();
    if (annotationGenSrc != null) {
      module.annotationGenPath=""String_Node_Str"" + Paths.get(basePathWithSlash).relativize(Paths.get(annotationGenSrc)).toString();
      module.annotationGenIsForTest=!hasSourceFoldersForSrcRule;
    }
  }
  return module;
}",0.9904382470119522
53279,"private ImmutableList<String> buildArgs(){
  ImmutableList.Builder<String> argBuilder=ImmutableList.builder();
  argBuilder.add(pythonInterpreter);
  argBuilder.add(""String_Node_Str"");
  argBuilder.add(PATH_TO_BUCK_PY);
  if (isServerMode) {
    argBuilder.add(""String_Node_Str"");
  }
  argBuilder.add(""String_Node_Str"",projectRoot.getAbsolutePath());
  for (  String include : commonIncludes) {
    argBuilder.add(""String_Node_Str"");
    argBuilder.add(include);
  }
  for (  String path : ignorePaths) {
    argBuilder.add(""String_Node_Str"");
    argBuilder.add(path);
  }
  return argBuilder.build();
}","private ImmutableList<String> buildArgs(){
  ImmutableList.Builder<String> argBuilder=ImmutableList.builder();
  argBuilder.add(pythonInterpreter);
  argBuilder.add(""String_Node_Str"");
  argBuilder.add(PATH_TO_BUCK_PY);
  if (isServerMode) {
    argBuilder.add(""String_Node_Str"");
  }
  argBuilder.add(""String_Node_Str"",projectRoot.getAbsolutePath());
  for (  String include : commonIncludes) {
    argBuilder.add(""String_Node_Str"");
    argBuilder.add(include);
  }
  for (  Path path : ignorePaths) {
    argBuilder.add(""String_Node_Str"");
    argBuilder.add(path.toString());
  }
  return argBuilder.build();
}",0.9827727645611156
53280,"@Override public int execute(final ExecutionContext context){
  final ProjectFilesystem projectFilesystem=context.getProjectFilesystem();
  ImmutableSet<String> ignorePaths=ImmutableSet.of();
  DirectoryTraversal traversal=new DirectoryTraversal(projectFilesystem.getFileForRelativePath(binDirectory),ignorePaths){
    @Override public void visit(    File file,    String relativePath) throws IOException {
      Path source=binDirectory.resolve(relativePath);
      Path target=genDirectory.resolve(relativePath);
      projectFilesystem.createParentDirs(target);
      projectFilesystem.copyFile(source,target);
      buildableContext.recordArtifact(target);
    }
  }
;
  try {
    traversal.traverse();
  }
 catch (  IOException e) {
    e.printStackTrace(context.getStdErr());
    return 1;
  }
  return 0;
}","@Override public int execute(final ExecutionContext context){
  final ProjectFilesystem projectFilesystem=context.getProjectFilesystem();
  ImmutableSet<Path> ignorePaths=ImmutableSet.of();
  DirectoryTraversal traversal=new DirectoryTraversal(projectFilesystem.getFileForRelativePath(binDirectory),ignorePaths){
    @Override public void visit(    File file,    String relativePath) throws IOException {
      Path source=binDirectory.resolve(relativePath);
      Path target=genDirectory.resolve(relativePath);
      projectFilesystem.createParentDirs(target);
      projectFilesystem.copyFile(source,target);
      buildableContext.recordArtifact(target);
    }
  }
;
  try {
    traversal.traverse();
  }
 catch (  IOException e) {
    e.printStackTrace(context.getStdErr());
    return 1;
  }
  return 0;
}",0.9938423645320196
53281,"public final void traverse() throws IOException {
  Preconditions.checkState(root.isDirectory(),""String_Node_Str"",root);
  final Path rootPath=root.toPath();
  FileVisitor<Path> visitor=new FileVisitor<Path>(){
    @Override public FileVisitResult preVisitDirectory(    Path dir,    BasicFileAttributes attrs) throws IOException {
      if (ignorePaths.contains(rootPath.relativize(dir).toString())) {
        return FileVisitResult.SKIP_SUBTREE;
      }
 else {
        return FileVisitResult.CONTINUE;
      }
    }
    @Override public FileVisitResult visitFile(    Path file,    BasicFileAttributes attrs) throws IOException {
      visit(file.toFile(),rootPath.relativize(file).toString());
      return FileVisitResult.CONTINUE;
    }
    @Override public FileVisitResult visitFileFailed(    Path file,    IOException exc) throws IOException {
      return FileVisitResult.CONTINUE;
    }
    @Override public FileVisitResult postVisitDirectory(    Path dir,    IOException exc) throws IOException {
      return FileVisitResult.CONTINUE;
    }
  }
;
  Files.walkFileTree(rootPath,EnumSet.of(FileVisitOption.FOLLOW_LINKS),Integer.MAX_VALUE,visitor);
}","public final void traverse() throws IOException {
  Preconditions.checkState(root.isDirectory(),""String_Node_Str"",root);
  final Path rootPath=root.toPath();
  FileVisitor<Path> visitor=new FileVisitor<Path>(){
    @Override public FileVisitResult preVisitDirectory(    Path dir,    BasicFileAttributes attrs) throws IOException {
      if (ignorePaths.contains(rootPath.relativize(dir))) {
        return FileVisitResult.SKIP_SUBTREE;
      }
 else {
        return FileVisitResult.CONTINUE;
      }
    }
    @Override public FileVisitResult visitFile(    Path file,    BasicFileAttributes attrs) throws IOException {
      visit(file.toFile(),rootPath.relativize(file).toString());
      return FileVisitResult.CONTINUE;
    }
    @Override public FileVisitResult visitFileFailed(    Path file,    IOException exc) throws IOException {
      return FileVisitResult.CONTINUE;
    }
    @Override public FileVisitResult postVisitDirectory(    Path dir,    IOException exc) throws IOException {
      return FileVisitResult.CONTINUE;
    }
  }
;
  Files.walkFileTree(rootPath,EnumSet.of(FileVisitOption.FOLLOW_LINKS),Integer.MAX_VALUE,visitor);
}",0.995223621363439
53282,"public DirectoryTraversal(File root){
  this(root,ImmutableSet.<String>of());
}","public DirectoryTraversal(File root){
  this(root,ImmutableSet.<Path>of());
}",0.9487179487179488
53283,"@Override public FileVisitResult preVisitDirectory(Path dir,BasicFileAttributes attrs) throws IOException {
  if (ignorePaths.contains(rootPath.relativize(dir).toString())) {
    return FileVisitResult.SKIP_SUBTREE;
  }
 else {
    return FileVisitResult.CONTINUE;
  }
}","@Override public FileVisitResult preVisitDirectory(Path dir,BasicFileAttributes attrs) throws IOException {
  if (ignorePaths.contains(rootPath.relativize(dir))) {
    return FileVisitResult.SKIP_SUBTREE;
  }
 else {
    return FileVisitResult.CONTINUE;
  }
}",0.9792060491493384
53284,"public ProjectFilesystem(File projectRoot){
  this(projectRoot,ImmutableSet.<String>of());
}","public ProjectFilesystem(File projectRoot){
  this(projectRoot,ImmutableSet.<Path>of());
}",0.956043956043956
53285,"public ImmutableSet<String> getIgnorePaths(){
  return ignorePaths;
}","/** 
 * @return A {@link ImmutableSet} of {@link Path} objects to have buck ignore.  All paths will berelative to the  {@link ProjectFilesystem#getRootPath()}.
 */
public ImmutableSet<Path> getIgnorePaths(){
  return ignorePaths;
}",0.1866666666666666
53286,"private boolean shouldIgnore(Path path){
  Path normalizedPath=path.normalize();
  for (  String prefix : ignoredPrefixes) {
    if (normalizedPath.startsWith(prefix)) {
      return true;
    }
  }
  return false;
}","private boolean shouldIgnore(Path path){
  Path normalizedPath=path.normalize();
  for (  Path prefix : ignoredPrefixes) {
    if (normalizedPath.startsWith(prefix)) {
      return true;
    }
  }
  return false;
}",0.7023255813953488
53287,"public ProjectFilesystemWatcher(ProjectFilesystem filesystem,EventBus fileChangeEventBus,ImmutableSet<String> excludeDirectories,WatchService watchService) throws IOException {
  this.filesystem=Preconditions.checkNotNull(filesystem);
  this.ignoredPrefixes=Preconditions.checkNotNull(excludeDirectories);
  this.eventBus=Preconditions.checkNotNull(fileChangeEventBus);
  this.watchService=Preconditions.checkNotNull(watchService);
  this.keys=Maps.newHashMap();
  registerAll(filesystem.getRootPath());
}","public ProjectFilesystemWatcher(ProjectFilesystem filesystem,EventBus fileChangeEventBus,ImmutableSet<Path> excludeDirectories,WatchService watchService) throws IOException {
  this.filesystem=Preconditions.checkNotNull(filesystem);
  this.ignoredPrefixes=Preconditions.checkNotNull(excludeDirectories);
  this.eventBus=Preconditions.checkNotNull(fileChangeEventBus);
  this.watchService=Preconditions.checkNotNull(watchService);
  this.keys=Maps.newHashMap();
  registerAll(filesystem.getRootPath());
}",0.9900793650793652
53288,"@Test public void testIgnorePaths() throws IOException {
  ProjectFilesystem filesystem=EasyMock.createMock(ProjectFilesystem.class);
  EasyMock.expect(filesystem.getPathRelativizer()).andReturn(IdentityPathRelativizer.getIdentityRelativizer()).times(2);
  BuildTargetParser parser=EasyMock.createMock(BuildTargetParser.class);
  EasyMock.replay(filesystem,parser);
  Reader reader=new StringReader(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""));
  BuckConfig config=BuckConfig.createFromReader(reader,filesystem,parser,Platform.detect());
  ImmutableSet<String> ignorePaths=config.getIgnorePaths();
  assertEquals(""String_Node_Str"",ignorePaths,ImmutableSet.of(BuckConstant.BUCK_OUTPUT_DIRECTORY,""String_Node_Str"",System.getProperty(BuckConfig.BUCK_BUCKD_DIR_KEY,""String_Node_Str""),config.getCacheDir().toString(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  EasyMock.verify(filesystem,parser);
}","@Test public void testIgnorePaths() throws IOException {
  ProjectFilesystem filesystem=EasyMock.createMock(ProjectFilesystem.class);
  EasyMock.expect(filesystem.getPathRelativizer()).andReturn(IdentityPathRelativizer.getIdentityRelativizer()).times(2);
  BuildTargetParser parser=EasyMock.createMock(BuildTargetParser.class);
  EasyMock.replay(filesystem,parser);
  Reader reader=new StringReader(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""));
  BuckConfig config=BuckConfig.createFromReader(reader,filesystem,parser,Platform.detect());
  ImmutableSet<Path> ignorePaths=config.getIgnorePaths();
  assertEquals(""String_Node_Str"",ignorePaths,MorePaths.asPaths(ImmutableSet.of(BuckConstant.BUCK_OUTPUT_DIRECTORY,""String_Node_Str"",System.getProperty(BuckConfig.BUCK_BUCKD_DIR_KEY,""String_Node_Str""),config.getCacheDir().toString(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
  EasyMock.verify(filesystem,parser);
}",0.9849974133471288
53289,"@Test public void testIgnorePathsWithAbsoluteCacheDir() throws IOException {
  ProjectFilesystem filesystem=EasyMock.createMock(ProjectFilesystem.class);
  BuildTargetParser parser=EasyMock.createMock(BuildTargetParser.class);
  EasyMock.replay(filesystem,parser);
  Reader reader=new StringReader(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""));
  BuckConfig config=BuckConfig.createFromReader(reader,filesystem,parser,Platform.detect());
  ImmutableSet<String> ignorePaths=config.getIgnorePaths();
  assertFalse(""String_Node_Str"",ignorePaths.contains(""String_Node_Str""));
  EasyMock.verify(filesystem,parser);
}","@Test public void testIgnorePathsWithAbsoluteCacheDir() throws IOException {
  ProjectFilesystem filesystem=EasyMock.createMock(ProjectFilesystem.class);
  BuildTargetParser parser=EasyMock.createMock(BuildTargetParser.class);
  EasyMock.replay(filesystem,parser);
  Reader reader=new StringReader(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""));
  BuckConfig config=BuckConfig.createFromReader(reader,filesystem,parser,Platform.detect());
  ImmutableSet<Path> ignorePaths=config.getIgnorePaths();
  assertFalse(""String_Node_Str"",ignorePaths.contains(""String_Node_Str""));
  EasyMock.verify(filesystem,parser);
}",0.9919743178170144
53290,"@Test public void testIgnorePathsWithRelativeCacheDir() throws IOException {
  ProjectFilesystem filesystem=EasyMock.createMock(ProjectFilesystem.class);
  EasyMock.expect(filesystem.getPathRelativizer()).andReturn(IdentityPathRelativizer.getIdentityRelativizer());
  BuildTargetParser parser=EasyMock.createMock(BuildTargetParser.class);
  EasyMock.replay(filesystem,parser);
  Reader reader=new StringReader(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""));
  BuckConfig config=BuckConfig.createFromReader(reader,filesystem,parser,Platform.detect());
  ImmutableSet<String> ignorePaths=config.getIgnorePaths();
  assertTrue(""String_Node_Str"",ignorePaths.contains(""String_Node_Str""));
  EasyMock.verify(filesystem,parser);
}","@Test public void testIgnorePathsWithRelativeCacheDir() throws IOException {
  ProjectFilesystem filesystem=EasyMock.createMock(ProjectFilesystem.class);
  EasyMock.expect(filesystem.getPathRelativizer()).andReturn(IdentityPathRelativizer.getIdentityRelativizer());
  BuildTargetParser parser=EasyMock.createMock(BuildTargetParser.class);
  EasyMock.replay(filesystem,parser);
  Reader reader=new StringReader(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""));
  BuckConfig config=BuckConfig.createFromReader(reader,filesystem,parser,Platform.detect());
  ImmutableSet<Path> ignorePaths=config.getIgnorePaths();
  assertTrue(""String_Node_Str"",ignorePaths.contains(Paths.get(""String_Node_Str"")));
  EasyMock.verify(filesystem,parser);
}",0.9858012170385396
53291,"@Test public void testBuckProject() throws IOException {
  ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",temporaryFolder);
  workspace.setUp();
  ProcessResult result=workspace.runBuckCommand(""String_Node_Str"");
  result.assertExitCode(""String_Node_Str"",0);
  workspace.verify();
  assertEquals(""String_Node_Str"",Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"") + '\n',result.getStdout());
  assertThat(""String_Node_Str"",result.getStderr(),containsString(""String_Node_Str""));
}","@Test public void testBuckProject() throws IOException {
  ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",temporaryFolder);
  workspace.setUp();
  ProcessResult result=workspace.runBuckCommand(""String_Node_Str"");
  result.assertExitCode(""String_Node_Str"",0);
  workspace.verify();
  assertEquals(""String_Node_Str"",Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"") + '\n',result.getStdout());
  assertThat(""String_Node_Str"",result.getStderr(),containsString(""String_Node_Str""));
}",0.9866468842729972
53292,"/** 
 * Create a   {@link Function} that will deobfuscate internal class names for this build.
 * @return the Function.
 */
private Function<String,String> createProguardDeobfuscator(ExecutionContext context) throws IOException {
  if (!proguardMappingFile.isPresent()) {
    return Functions.identity();
  }
  Map<String,String> rawProguardMap=ProguardMapping.readClassMapping(context.getProjectFilesystem().readLines(proguardMappingFile.get()));
  ImmutableMap.Builder<String,String> internalNameBuilder=ImmutableMap.builder();
  for (  Map.Entry<String,String> entry : rawProguardMap.entrySet()) {
    internalNameBuilder.put(entry.getValue().replace('.','/'),entry.getKey().replace('.','/'));
  }
  final Map<String,String> deobfuscator=internalNameBuilder.build();
  return new Function<String,String>(){
    @Nullable @Override public String apply(    @Nullable String input){
      return deobfuscator.get(input);
    }
  }
;
}","/** 
 * Create a   {@link Function} that will deobfuscate internal class names for this build.
 * @return the Function.
 */
private Function<String,String> createProguardDeobfuscator(ExecutionContext context) throws IOException {
  if (!proguardMappingFile.isPresent()) {
    return Functions.identity();
  }
  ProjectFilesystem projectFilesystem=context.getProjectFilesystem();
  Path pathToProguardMappingFile=proguardMappingFile.get();
  if (!projectFilesystem.exists(pathToProguardMappingFile.toString())) {
    return Functions.identity();
  }
  List<String> lines=projectFilesystem.readLines(pathToProguardMappingFile);
  Map<String,String> rawProguardMap=ProguardMapping.readClassMapping(lines);
  ImmutableMap.Builder<String,String> internalNameBuilder=ImmutableMap.builder();
  for (  Map.Entry<String,String> entry : rawProguardMap.entrySet()) {
    internalNameBuilder.put(entry.getValue().replace('.','/'),entry.getKey().replace('.','/'));
  }
  final Map<String,String> deobfuscator=internalNameBuilder.build();
  return new Function<String,String>(){
    @Nullable @Override public String apply(    @Nullable String input){
      return deobfuscator.get(input);
    }
  }
;
}",0.8167687235044748
53293,"@Test public void testRequiredInPrimaryZipPredicateWithProguard() throws IOException {
  Path proguardMappingFile=Paths.get(""String_Node_Str"");
  Path primaryDexClassesFile=Paths.get(""String_Node_Str"");
  SplitZipStep splitZipStep=new SplitZipStep(ImmutableSet.<String>of(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",Optional.of(proguardMappingFile),ImmutableSet.of(""String_Node_Str"",""String_Node_Str""),Optional.of(primaryDexClassesFile),ZipSplitter.DexSplitStrategy.MAXIMIZE_PRIMARY_DEX_SIZE,DexStore.JAR,""String_Node_Str"",true,4 * 1024 * 1024);
  List<String> linesInMappingFile=ImmutableList.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  List<String> linesInManifestFile=ImmutableList.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  ProjectFilesystem projectFilesystem=EasyMock.createMock(ProjectFilesystem.class);
  EasyMock.expect(projectFilesystem.readLines(primaryDexClassesFile)).andReturn(linesInManifestFile);
  EasyMock.expect(projectFilesystem.readLines(proguardMappingFile)).andReturn(linesInMappingFile);
  ExecutionContext context=EasyMock.createMock(ExecutionContext.class);
  EasyMock.expect(context.getProjectFilesystem()).andReturn(projectFilesystem).anyTimes();
  EasyMock.replay(projectFilesystem,context);
  Predicate<String> requiredInPrimaryZipPredicate=splitZipStep.createRequiredInPrimaryZipPredicate(context);
  assertTrue(""String_Node_Str"",requiredInPrimaryZipPredicate.apply(""String_Node_Str""));
  assertTrue(""String_Node_Str"",requiredInPrimaryZipPredicate.apply(""String_Node_Str""));
  assertTrue(""String_Node_Str"",requiredInPrimaryZipPredicate.apply(""String_Node_Str""));
  assertTrue(""String_Node_Str"",requiredInPrimaryZipPredicate.apply(""String_Node_Str""));
  assertFalse(""String_Node_Str"",requiredInPrimaryZipPredicate.apply(""String_Node_Str""));
  assertFalse(""String_Node_Str"",requiredInPrimaryZipPredicate.apply(""String_Node_Str""));
  assertFalse(""String_Node_Str"",requiredInPrimaryZipPredicate.apply(""String_Node_Str""));
  EasyMock.verify(projectFilesystem,context);
}","@Test public void testRequiredInPrimaryZipPredicateWithProguard() throws IOException {
  Path proguardMappingFile=Paths.get(""String_Node_Str"");
  Path primaryDexClassesFile=Paths.get(""String_Node_Str"");
  SplitZipStep splitZipStep=new SplitZipStep(ImmutableSet.<String>of(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",Optional.of(proguardMappingFile),ImmutableSet.of(""String_Node_Str"",""String_Node_Str""),Optional.of(primaryDexClassesFile),ZipSplitter.DexSplitStrategy.MAXIMIZE_PRIMARY_DEX_SIZE,DexStore.JAR,""String_Node_Str"",true,4 * 1024 * 1024);
  List<String> linesInMappingFile=ImmutableList.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  List<String> linesInManifestFile=ImmutableList.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  ProjectFilesystem projectFilesystem=EasyMock.createMock(ProjectFilesystem.class);
  EasyMock.expect(projectFilesystem.readLines(primaryDexClassesFile)).andReturn(linesInManifestFile);
  EasyMock.expect(projectFilesystem.exists(proguardMappingFile.toString())).andReturn(true);
  EasyMock.expect(projectFilesystem.readLines(proguardMappingFile)).andReturn(linesInMappingFile);
  ExecutionContext context=EasyMock.createMock(ExecutionContext.class);
  EasyMock.expect(context.getProjectFilesystem()).andReturn(projectFilesystem).anyTimes();
  EasyMock.replay(projectFilesystem,context);
  Predicate<String> requiredInPrimaryZipPredicate=splitZipStep.createRequiredInPrimaryZipPredicate(context);
  assertTrue(""String_Node_Str"",requiredInPrimaryZipPredicate.apply(""String_Node_Str""));
  assertTrue(""String_Node_Str"",requiredInPrimaryZipPredicate.apply(""String_Node_Str""));
  assertTrue(""String_Node_Str"",requiredInPrimaryZipPredicate.apply(""String_Node_Str""));
  assertTrue(""String_Node_Str"",requiredInPrimaryZipPredicate.apply(""String_Node_Str""));
  assertFalse(""String_Node_Str"",requiredInPrimaryZipPredicate.apply(""String_Node_Str""));
  assertFalse(""String_Node_Str"",requiredInPrimaryZipPredicate.apply(""String_Node_Str""));
  assertFalse(""String_Node_Str"",requiredInPrimaryZipPredicate.apply(""String_Node_Str""));
  EasyMock.verify(projectFilesystem,context);
}",0.978829956749374
53294,"protected DefaultJavaLibraryRule(BuildRuleParams buildRuleParams,Set<String> srcs,Set<? extends SourcePath> resources,Optional<String> proguardConfig,boolean exportDeps,JavacOptions javacOptions){
  super(buildRuleParams);
  this.srcs=ImmutableSortedSet.copyOf(srcs);
  this.resources=ImmutableSortedSet.copyOf(resources);
  this.proguardConfig=Preconditions.checkNotNull(proguardConfig);
  this.exportDeps=exportDeps;
  this.javacOptions=Preconditions.checkNotNull(javacOptions);
  if (!srcs.isEmpty() || !resources.isEmpty()) {
    this.outputJar=Optional.of(getOutputJarPath(getBuildTarget()));
  }
 else {
    this.outputJar=Optional.absent();
  }
  ImmutableList.Builder<String> builder=ImmutableList.<String>builder().addAll(this.srcs);
  builder.addAll(SourcePaths.filterInputsToCompareToOutput(resources));
  inputsToConsiderForCachingPurposes=builder.build();
  outputClasspathEntriesSupplier=Suppliers.memoize(new Supplier<ImmutableSetMultimap<JavaLibraryRule,String>>(){
    @Override public ImmutableSetMultimap<JavaLibraryRule,String> get(){
      ImmutableSetMultimap<JavaLibraryRule,String> outputClasspathEntries;
      if (DefaultJavaLibraryRule.this.exportDeps) {
        outputClasspathEntries=getTransitiveClasspathEntries();
      }
 else       if (outputJar.isPresent()) {
        outputClasspathEntries=ImmutableSetMultimap.<JavaLibraryRule,String>builder().put(DefaultJavaLibraryRule.this,getPathToOutputFile()).build();
      }
 else {
        outputClasspathEntries=ImmutableSetMultimap.of();
      }
      return outputClasspathEntries;
    }
  }
);
  transitiveClasspathEntriesSupplier=Suppliers.memoize(new Supplier<ImmutableSetMultimap<JavaLibraryRule,String>>(){
    @Override public ImmutableSetMultimap<JavaLibraryRule,String> get(){
      final ImmutableSetMultimap.Builder<JavaLibraryRule,String> classpathEntries=ImmutableSetMultimap.builder();
      ImmutableSetMultimap<JavaLibraryRule,String> classpathEntriesForDeps=Classpaths.getClasspathEntries(getDeps());
      classpathEntries.putAll(classpathEntriesForDeps);
      if (DefaultJavaLibraryRule.this.exportDeps) {
        classpathEntries.putAll(DefaultJavaLibraryRule.this,classpathEntriesForDeps.values());
      }
      if (outputJar.isPresent()) {
        classpathEntries.putAll(DefaultJavaLibraryRule.this,getPathToOutputFile());
      }
      return classpathEntries.build();
    }
  }
);
  declaredClasspathEntriesSupplier=Suppliers.memoize(new Supplier<ImmutableSetMultimap<JavaLibraryRule,String>>(){
    @Override public ImmutableSetMultimap<JavaLibraryRule,String> get(){
      final ImmutableSetMultimap.Builder<JavaLibraryRule,String> classpathEntries=ImmutableSetMultimap.builder();
      Iterable<JavaLibraryRule> javaLibraryDeps=Iterables.filter(Sets.union(getDeps(),ImmutableSet.of(DefaultJavaLibraryRule.this)),JavaLibraryRule.class);
      for (      JavaLibraryRule rule : javaLibraryDeps) {
        classpathEntries.putAll(rule,rule.getOutputClasspathEntries().values());
      }
      return classpathEntries.build();
    }
  }
);
}","protected DefaultJavaLibraryRule(BuildRuleParams buildRuleParams,Set<String> srcs,Set<? extends SourcePath> resources,Optional<String> proguardConfig,boolean exportDeps,JavacOptions javacOptions){
  super(buildRuleParams);
  this.srcs=ImmutableSortedSet.copyOf(srcs);
  this.resources=ImmutableSortedSet.copyOf(resources);
  this.proguardConfig=Preconditions.checkNotNull(proguardConfig);
  this.exportDeps=exportDeps;
  this.javacOptions=Preconditions.checkNotNull(javacOptions);
  if (!srcs.isEmpty() || !resources.isEmpty()) {
    this.outputJar=Optional.of(getOutputJarPath(getBuildTarget()));
  }
 else {
    this.outputJar=Optional.absent();
  }
  ImmutableList.Builder<String> builder=ImmutableList.<String>builder().addAll(this.srcs);
  builder.addAll(SourcePaths.filterInputsToCompareToOutput(resources));
  inputsToConsiderForCachingPurposes=builder.build();
  outputClasspathEntriesSupplier=Suppliers.memoize(new Supplier<ImmutableSetMultimap<JavaLibraryRule,String>>(){
    @Override public ImmutableSetMultimap<JavaLibraryRule,String> get(){
      ImmutableSetMultimap<JavaLibraryRule,String> outputClasspathEntries;
      if (DefaultJavaLibraryRule.this.exportDeps) {
        outputClasspathEntries=getTransitiveClasspathEntries();
      }
 else       if (outputJar.isPresent()) {
        outputClasspathEntries=ImmutableSetMultimap.<JavaLibraryRule,String>builder().put(DefaultJavaLibraryRule.this,getPathToOutputFile()).build();
      }
 else {
        outputClasspathEntries=ImmutableSetMultimap.of();
      }
      return outputClasspathEntries;
    }
  }
);
  transitiveClasspathEntriesSupplier=Suppliers.memoize(new Supplier<ImmutableSetMultimap<JavaLibraryRule,String>>(){
    @Override public ImmutableSetMultimap<JavaLibraryRule,String> get(){
      final ImmutableSetMultimap.Builder<JavaLibraryRule,String> classpathEntries=ImmutableSetMultimap.builder();
      ImmutableSetMultimap<JavaLibraryRule,String> classpathEntriesForDeps=Classpaths.getClasspathEntries(getDeps());
      classpathEntries.putAll(classpathEntriesForDeps);
      if (DefaultJavaLibraryRule.this.exportDeps) {
        classpathEntries.putAll(DefaultJavaLibraryRule.this,classpathEntriesForDeps.values());
      }
      if (outputJar.isPresent()) {
        classpathEntries.putAll(DefaultJavaLibraryRule.this,getPathToOutputFile());
      }
      return classpathEntries.build();
    }
  }
);
  declaredClasspathEntriesSupplier=Suppliers.memoize(new Supplier<ImmutableSetMultimap<JavaLibraryRule,String>>(){
    @Override public ImmutableSetMultimap<JavaLibraryRule,String> get(){
      final ImmutableSetMultimap.Builder<JavaLibraryRule,String> classpathEntries=ImmutableSetMultimap.builder();
      Iterable<JavaLibraryRule> javaLibraryDeps=Iterables.filter(getDeps(),JavaLibraryRule.class);
      for (      JavaLibraryRule rule : javaLibraryDeps) {
        classpathEntries.putAll(rule,rule.getOutputClasspathEntries().values());
      }
      return classpathEntries.build();
    }
  }
);
}",0.9822818347408512
53295,"private BuildContext createBuildContext(DefaultJavaLibraryRule javaLibrary,@Nullable String bootclasspath,@Nullable ProjectFilesystem projectFilesystem){
  AndroidPlatformTarget platformTarget=EasyMock.createMock(AndroidPlatformTarget.class);
  ImmutableList<Path> bootclasspathEntries=(bootclasspath == null) ? ImmutableList.<Path>of(Paths.get(""String_Node_Str"")) : ImmutableList.of(Paths.get(bootclasspath));
  EasyMock.expect(platformTarget.getBootclasspathEntries()).andReturn(bootclasspathEntries).anyTimes();
  replay(platformTarget);
  if (projectFilesystem == null) {
    projectFilesystem=EasyMock.createMock(ProjectFilesystem.class);
  }
  return BuildContext.builder().setDependencyGraph(RuleMap.createGraphFromSingleRule(javaLibrary)).setStepRunner(EasyMock.createMock(StepRunner.class)).setProjectFilesystem(projectFilesystem).setArtifactCache(new NoopArtifactCache()).setBuildDependencies(BuildDependencies.TRANSITIVE).setJavaPackageFinder(EasyMock.createMock(JavaPackageFinder.class)).setAndroidBootclasspathForAndroidPlatformTarget(Optional.of(platformTarget)).setEventBus(BuckEventBusFactory.newInstance()).build();
}","private BuildContext createBuildContext(DefaultJavaLibraryRule javaLibrary,@Nullable String bootclasspath,@Nullable ProjectFilesystem projectFilesystem){
  AndroidPlatformTarget platformTarget=EasyMock.createMock(AndroidPlatformTarget.class);
  ImmutableList<Path> bootclasspathEntries=(bootclasspath == null) ? ImmutableList.<Path>of(Paths.get(""String_Node_Str"")) : ImmutableList.of(Paths.get(bootclasspath));
  expect(platformTarget.getBootclasspathEntries()).andReturn(bootclasspathEntries).anyTimes();
  replay(platformTarget);
  if (projectFilesystem == null) {
    projectFilesystem=EasyMock.createMock(ProjectFilesystem.class);
  }
  return BuildContext.builder().setDependencyGraph(RuleMap.createGraphFromSingleRule(javaLibrary)).setStepRunner(EasyMock.createMock(StepRunner.class)).setProjectFilesystem(projectFilesystem).setArtifactCache(new NoopArtifactCache()).setBuildDependencies(BuildDependencies.TRANSITIVE).setJavaPackageFinder(EasyMock.createMock(JavaPackageFinder.class)).setAndroidBootclasspathForAndroidPlatformTarget(Optional.of(platformTarget)).setEventBus(BuckEventBusFactory.newInstance()).build();
}",0.99601593625498
53296,"private BuildContext createSuggestContext(BuildRuleResolver ruleResolver,BuildDependencies buildDependencies){
  DependencyGraph graph=RuleMap.createGraphFromBuildRules(ruleResolver);
  BuildContext context=EasyMock.createMock(BuildContext.class);
  EasyMock.expect(context.getDependencyGraph()).andReturn(graph).anyTimes();
  EasyMock.expect(context.getBuildDependencies()).andReturn(buildDependencies).anyTimes();
  replay(context);
  return context;
}","private BuildContext createSuggestContext(BuildRuleResolver ruleResolver,BuildDependencies buildDependencies){
  DependencyGraph graph=RuleMap.createGraphFromBuildRules(ruleResolver);
  BuildContext context=EasyMock.createMock(BuildContext.class);
  expect(context.getDependencyGraph()).andReturn(graph).anyTimes();
  expect(context.getBuildDependencies()).andReturn(buildDependencies).anyTimes();
  replay(context);
  return context;
}",0.9797752808988764
53297,"@Test public void testExportDeps(){
  BuildRuleResolver ruleResolver=new BuildRuleResolver();
  BuildTarget libraryOneTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  JavaLibraryRule libraryOne=ruleResolver.buildAndAddToIndex(DefaultJavaLibraryRule.newJavaLibraryRuleBuilder(new FakeAbstractBuildRuleBuilderParams()).setBuildTarget(libraryOneTarget).addSrc(""String_Node_Str""));
  BuildTarget libraryTwoTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  JavaLibraryRule libraryTwo=ruleResolver.buildAndAddToIndex(DefaultJavaLibraryRule.newJavaLibraryRuleBuilder(new FakeAbstractBuildRuleBuilderParams()).setBuildTarget(libraryTwoTarget).addSrc(""String_Node_Str"").addDep(BuildTargetFactory.newInstance(""String_Node_Str"")).setExportDeps(true));
  BuildTarget parentTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  JavaLibraryRule parent=ruleResolver.buildAndAddToIndex(DefaultJavaLibraryRule.newJavaLibraryRuleBuilder(new FakeAbstractBuildRuleBuilderParams()).setBuildTarget(parentTarget).addSrc(""String_Node_Str"").addDep(BuildTargetFactory.newInstance(""String_Node_Str"")));
  assertEquals(ImmutableSetMultimap.builder().put(libraryOne,""String_Node_Str"").build(),libraryOne.getOutputClasspathEntries());
  assertEquals(ImmutableSetMultimap.builder().put(libraryOne,""String_Node_Str"").put(libraryTwo,""String_Node_Str"").put(libraryTwo,""String_Node_Str"").build(),libraryTwo.getOutputClasspathEntries());
  ImmutableSetMultimap.Builder<BuildRule,String> expected=ImmutableSetMultimap.builder();
  expected.put(parent,""String_Node_Str"");
  expected.putAll(libraryTwo,""String_Node_Str"",""String_Node_Str"");
  assertEquals(expected.build(),parent.getDeclaredClasspathEntries());
}","@Test public void testExportDeps(){
  BuildRuleResolver ruleResolver=new BuildRuleResolver();
  BuildTarget libraryOneTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  JavaLibraryRule libraryOne=ruleResolver.buildAndAddToIndex(DefaultJavaLibraryRule.newJavaLibraryRuleBuilder(new FakeAbstractBuildRuleBuilderParams()).setBuildTarget(libraryOneTarget).addSrc(""String_Node_Str""));
  BuildTarget libraryTwoTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  JavaLibraryRule libraryTwo=ruleResolver.buildAndAddToIndex(DefaultJavaLibraryRule.newJavaLibraryRuleBuilder(new FakeAbstractBuildRuleBuilderParams()).setBuildTarget(libraryTwoTarget).addSrc(""String_Node_Str"").addDep(BuildTargetFactory.newInstance(""String_Node_Str"")).setExportDeps(true));
  BuildTarget parentTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  JavaLibraryRule parent=ruleResolver.buildAndAddToIndex(DefaultJavaLibraryRule.newJavaLibraryRuleBuilder(new FakeAbstractBuildRuleBuilderParams()).setBuildTarget(parentTarget).addSrc(""String_Node_Str"").addDep(BuildTargetFactory.newInstance(""String_Node_Str"")));
  assertEquals(""String_Node_Str"" + ""String_Node_Str"",ImmutableSetMultimap.builder().put(libraryOne,""String_Node_Str"").build(),libraryOne.getOutputClasspathEntries());
  assertEquals(""String_Node_Str"" + ""String_Node_Str"",ImmutableSetMultimap.builder().put(libraryOne,""String_Node_Str"").put(libraryTwo,""String_Node_Str"").put(libraryTwo,""String_Node_Str"").build(),libraryTwo.getOutputClasspathEntries());
  assertEquals(""String_Node_Str"" + ""String_Node_Str"",ImmutableSetMultimap.builder().put(libraryTwo,""String_Node_Str"").put(libraryTwo,""String_Node_Str"").build(),parent.getDeclaredClasspathEntries());
  assertEquals(""String_Node_Str"" + ""String_Node_Str"",ImmutableSetMultimap.builder().put(libraryOne,""String_Node_Str"").put(libraryTwo,""String_Node_Str"").put(libraryTwo,""String_Node_Str"").put(parent,""String_Node_Str"").build(),parent.getTransitiveClasspathEntries());
  assertEquals(""String_Node_Str"" + ""String_Node_Str"",ImmutableSetMultimap.builder().put(parent,""String_Node_Str"").build(),parent.getOutputClasspathEntries());
}",0.7965526247061896
53298,"private ExitCodeAndStdOut processJsonConfig(File jsonTempFile) throws IOException {
  final ImmutableList<String> args=ImmutableList.of(pythonInterpreter,PATH_TO_INTELLIJ_PY,jsonTempFile.getAbsolutePath());
  ShellStep command=new ShellStep(){
    @Override public String getShortName(){
      return ""String_Node_Str"";
    }
    @Override protected ImmutableList<String> getShellCommandInternal(    ExecutionContext context){
      return args;
    }
  }
;
  int exitCode=command.execute(executionContext);
  return new ExitCodeAndStdOut(exitCode,command.getStdout());
}","private ExitCodeAndStdOut processJsonConfig(File jsonTempFile) throws IOException {
  final ImmutableList<String> args=ImmutableList.of(pythonInterpreter,PATH_TO_INTELLIJ_PY,jsonTempFile.getAbsolutePath());
  ShellStep command=new ShellStep(){
    @Override public String getShortName(){
      return ""String_Node_Str"";
    }
    @Override protected ImmutableList<String> getShellCommandInternal(    ExecutionContext context){
      return args;
    }
  }
;
  Console console=executionContext.getConsole();
  Console childConsole=new Console(console.getVerbosity(),console.getStdOut(),console.getStdErr(),Ansi.withoutTty());
  ExecutionContext childContext=ExecutionContext.builder().setExecutionContext(executionContext).setConsole(childConsole).build();
  int exitCode=command.execute(childContext);
  return new ExitCodeAndStdOut(exitCode,command.getStdout());
}",0.7158774373259053
53299,"@Override public Set<String> findDrawables(Iterable<String> dirs) throws IOException {
  final ImmutableSet.Builder<String> drawableBuilder=ImmutableSet.builder();
  for (  String dir : dirs) {
    new DirectoryTraversal(new File(dir)){
      @Override public void visit(      File file,      String relativePath){
        if (DRAWABLE_PATH_PATTERN.matcher(relativePath).matches()) {
          drawableBuilder.add(file.getPath());
        }
      }
    }
.traverse();
  }
  return drawableBuilder.build();
}","@Override public Set<String> findDrawables(Iterable<String> dirs) throws IOException {
  final ImmutableSet.Builder<String> drawableBuilder=ImmutableSet.builder();
  for (  String dir : dirs) {
    new DirectoryTraversal(new File(dir)){
      @Override public void visit(      File file,      String relativePath){
        if (DRAWABLE_PATH_PATTERN.matcher(relativePath).matches()) {
          drawableBuilder.add(Paths.normalizePathSeparator(file.getPath()));
        }
      }
    }
.traverse();
  }
  return drawableBuilder.build();
}",0.971264367816092
53300,"@Override public void visit(File file,String relativePath){
  if (DRAWABLE_PATH_PATTERN.matcher(relativePath).matches()) {
    drawableBuilder.add(file.getPath());
  }
}","@Override public void visit(File file,String relativePath){
  if (DRAWABLE_PATH_PATTERN.matcher(relativePath).matches()) {
    drawableBuilder.add(Paths.normalizePathSeparator(file.getPath()));
  }
}",0.9184782608695652
53301,"private String getFile(String dir,String qualifier,String filename){
  return new File(dir,String.format(""String_Node_Str"",qualifier,filename)).getPath();
}","private String getFile(String dir,String qualifier,String filename){
  return Paths.normalizePathSeparator(new File(dir,String.format(""String_Node_Str"",qualifier,filename)).getPath());
}",0.912280701754386
53302,"@Override public RuleKey.Builder appendToRuleKey(RuleKey.Builder builder) throws IOException {
  ImmutableSortedSet.Builder<String> resFiles=ImmutableSortedSet.naturalOrder();
  addResContents(resFiles);
  ImmutableSortedSet.Builder<String> assetsFiles=ImmutableSortedSet.naturalOrder();
  addAssetsContents(assetsFiles);
  return super.appendToRuleKey(builder).set(""String_Node_Str"",resFiles.build()).set(""String_Node_Str"",assetsFiles.build());
}","@Override public RuleKey.Builder appendToRuleKey(RuleKey.Builder builder) throws IOException {
  ImmutableSortedSet.Builder<String> resFiles=ImmutableSortedSet.naturalOrder();
  addResContents(resFiles);
  ImmutableSortedSet.Builder<String> assetsFiles=ImmutableSortedSet.naturalOrder();
  addAssetsContents(assetsFiles);
  return super.appendToRuleKey(builder).set(""String_Node_Str"",resFiles.build()).set(""String_Node_Str"",rDotJavaPackage).set(""String_Node_Str"",assetsFiles.build()).set(""String_Node_Str"",manifestFile);
}",0.8833849329205367
53303,"protected AndroidResourceRule(BuildRuleParams buildRuleParams,@Nullable String res,@Nullable String rDotJavaPackage,@Nullable String assets,@Nullable String manifestFile,DirectoryTraverser directoryTraverser){
  super(buildRuleParams);
  this.directoryTraverser=Preconditions.checkNotNull(directoryTraverser);
  this.res=res;
  this.rDotJavaPackage=rDotJavaPackage;
  this.assets=assets;
  this.manifestFile=manifestFile;
  if (res == null) {
    pathToTextSymbolsDir=null;
    pathToTextSymbolsFile=null;
  }
 else {
    BuildTarget buildTarget=buildRuleParams.getBuildTarget();
    pathToTextSymbolsDir=String.format(""String_Node_Str"",BuckConstant.BIN_DIR,buildTarget.getBasePathWithSlash(),buildTarget.getShortName());
    pathToTextSymbolsFile=pathToTextSymbolsDir + ""String_Node_Str"";
  }
}","protected AndroidResourceRule(BuildRuleParams buildRuleParams,@Nullable String res,@Nullable String rDotJavaPackage,@Nullable String assets,@Nullable String manifestFile,DirectoryTraverser directoryTraverser){
  super(buildRuleParams);
  this.directoryTraverser=Preconditions.checkNotNull(directoryTraverser);
  this.res=res;
  this.rDotJavaPackage=rDotJavaPackage;
  this.assets=assets;
  this.manifestFile=manifestFile;
  if (res == null) {
    pathToTextSymbolsDir=null;
    pathToTextSymbolsFile=null;
  }
 else {
    BuildTarget buildTarget=buildRuleParams.getBuildTarget();
    pathToTextSymbolsDir=String.format(""String_Node_Str"",BuckConstant.GEN_DIR,buildTarget.getBasePathWithSlash(),buildTarget.getShortName());
    pathToTextSymbolsFile=pathToTextSymbolsDir + ""String_Node_Str"";
  }
}",0.9974842767295596
53304,"/** 
 * This will copy the template directory, renaming files named   {@code BUCK.test} to {@code BUCK}in the process. Files whose names end in   {@code .expected} will not be copied.
 */
public void setUp() throws IOException {
  MoreFiles.copyRecursively(templatePath,destPath,BUILD_FILE_RENAME);
  if (Platform.detect() == Platform.WINDOWS) {
    SimpleFileVisitor<Path> copyDirVisitor=new SimpleFileVisitor<Path>(){
      @Override public FileVisitResult visitFile(      Path path,      BasicFileAttributes attrs) throws IOException {
        if (attrs.size() <= 4096) {
          File file=path.toFile();
          String linkTo=Files.toString(file,Charsets.UTF_8);
          File linkToFile=new File(templatePath.toFile(),linkTo);
          if (linkToFile.isFile()) {
            java.nio.file.Files.copy(linkToFile.toPath(),path,StandardCopyOption.REPLACE_EXISTING);
          }
 else           if (linkToFile.isDirectory()) {
            if (!file.delete()) {
              throw new IOException();
            }
            MoreFiles.copyRecursively(linkToFile.toPath(),path);
          }
        }
        return FileVisitResult.CONTINUE;
      }
    }
;
    java.nio.file.Files.walkFileTree(destPath,copyDirVisitor);
  }
  isSetUp=true;
}","/** 
 * This will copy the template directory, renaming files named   {@code BUCK.test} to {@code BUCK}in the process. Files whose names end in   {@code .expected} will not be copied.
 */
public void setUp() throws IOException {
  MoreFiles.copyRecursively(templatePath,destPath,BUILD_FILE_RENAME);
  if (Platform.detect() == Platform.WINDOWS) {
    SimpleFileVisitor<Path> copyDirVisitor=new SimpleFileVisitor<Path>(){
      @Override public FileVisitResult visitFile(      Path path,      BasicFileAttributes attrs) throws IOException {
        if (attrs.size() > 0 && attrs.size() <= 4096) {
          File file=path.toFile();
          String linkTo=Files.toString(file,Charsets.UTF_8);
          File linkToFile=new File(templatePath.toFile(),linkTo);
          if (linkToFile.isFile()) {
            java.nio.file.Files.copy(linkToFile.toPath(),path,StandardCopyOption.REPLACE_EXISTING);
          }
 else           if (linkToFile.isDirectory()) {
            if (!file.delete()) {
              throw new IOException();
            }
            MoreFiles.copyRecursively(linkToFile.toPath(),path);
          }
        }
        return FileVisitResult.CONTINUE;
      }
    }
;
    java.nio.file.Files.walkFileTree(destPath,copyDirVisitor);
  }
  isSetUp=true;
}",0.9920571882446386
53305,"/** 
 * TODO(mbolin): Try to eliminate this method.
 * @deprecated {@link AbstractCachingBuildRule#getBuildSteps(BuildContext)} should be producingrelative paths that should be resolved by a  {@link ProjectFilesystem} from an{@link ExecutionContext} rather than from a {@link BuildContext}.
 */
@Deprecated public ProjectFilesystem getProjectFilesystem(){
  return projectFilesystem;
}","/** 
 * TODO(mbolin): Try to eliminate this method.
 * @deprecated {@link Buildable#getBuildSteps(BuildContext)} should be producingrelative paths that should be resolved by a  {@link ProjectFilesystem} from an{@link ExecutionContext} rather than from a {@link BuildContext}.
 */
@Deprecated public ProjectFilesystem getProjectFilesystem(){
  return projectFilesystem;
}",0.9748344370860929
53306,"/** 
 * Takes an   {@link Iterable} of {@link SourcePath} objects and filters those that are suitable tobe returned by  {@link AbstractCachingBuildRule#getInputsToCompareToOutput()}.
 */
public static Iterable<String> filterInputsToCompareToOutput(Iterable<? extends SourcePath> sources){
  return Iterables.transform(Iterables.filter(sources,FileSourcePath.class),SourcePath.TO_REFERENCE);
}","/** 
 * Takes an   {@link Iterable} of {@link SourcePath} objects and filters those that are suitable tobe returned by  {@link Buildable#getInputsToCompareToOutput()}.
 */
public static Iterable<String> filterInputsToCompareToOutput(Iterable<? extends SourcePath> sources){
  return Iterables.transform(Iterables.filter(sources,FileSourcePath.class),SourcePath.TO_REFERENCE);
}",0.9752925877763328
53307,"/** 
 * Tests the following methods: <ul> <li>  {@link AndroidManifestRule#getType()}<li>  {@link com.facebook.buck.rules.AbstractCachingBuildRule#getInputsToCompareToOutput()}<li>  {@link AndroidManifestRule#getPathToOutputFile()}</ul>
 */
@Test public void testSimpleObserverMethods(){
  AndroidManifestRule androidManifestRule=createSimpleAndroidManifestRule();
  assertEquals(""String_Node_Str"",androidManifestRule.getType().getName());
  assertEquals(ImmutableList.of(""String_Node_Str""),androidManifestRule.getInputsToCompareToOutput());
  assertEquals(BuckConstant.GEN_DIR + ""String_Node_Str"",androidManifestRule.getPathToOutputFile());
}","/** 
 * Tests the following methods: <ul> <li>  {@link AndroidManifestRule#getType()}<li>  {@link Buildable#getInputsToCompareToOutput()}<li>  {@link AndroidManifestRule#getPathToOutputFile()}</ul>
 */
@Test public void testSimpleObserverMethods(){
  AndroidManifestRule androidManifestRule=createSimpleAndroidManifestRule();
  assertEquals(""String_Node_Str"",androidManifestRule.getType().getName());
  assertEquals(ImmutableList.of(""String_Node_Str""),androidManifestRule.getInputsToCompareToOutput());
  assertEquals(BuckConstant.GEN_DIR + ""String_Node_Str"",androidManifestRule.getPathToOutputFile());
}",0.959101844426624
53308,"/** 
 * Get the path of the directory to make.
 * @param context
 * @return Path of the directory to make.
 */
public String getPath(ExecutionContext context){
  return context.getProjectFilesystem().getPathRelativizer().apply(pathRelativeToProjectRoot);
}","/** 
 * Get the path of the directory to make.
 * @return Path of the directory to make.
 */
public String getPath(ExecutionContext context){
  return context.getProjectFilesystem().getPathRelativizer().apply(pathRelativeToProjectRoot);
}",0.2753036437246963
53309,"@Test public void testSimpleGenAidlRule() throws IOException {
  BuildContext context=null;
  String pathToAidl=""String_Node_Str"";
  String importPath=""String_Node_Str"";
  BuildRuleResolver ruleResolver=new BuildRuleResolver();
  GenAidlRule genAidlRule=ruleResolver.buildAndAddToIndex(GenAidlRule.newGenAidlRuleBuilder(new FakeAbstractBuildRuleBuilderParams()).setBuildTarget(BuildTargetFactory.newInstance(""String_Node_Str"")).setAidl(pathToAidl).setImportPath(importPath));
  assertEquals(BuildRuleType.GEN_AIDL,genAidlRule.getType());
  assertTrue(genAidlRule.isAndroidRule());
  assertEquals(ImmutableList.of(pathToAidl),genAidlRule.getInputsToCompareToOutput());
  List<Step> steps=genAidlRule.buildInternal(context);
  final String pathToAidlExecutable=""String_Node_Str"";
  final String pathToFrameworkAidl=""String_Node_Str"";
  AndroidPlatformTarget androidPlatformTarget=createMock(AndroidPlatformTarget.class);
  File aidlExecutable=createMock(File.class);
  expect(aidlExecutable.getAbsolutePath()).andReturn(pathToAidlExecutable);
  expect(androidPlatformTarget.getAidlExecutable()).andReturn(aidlExecutable);
  File frameworkIdlFile=createMock(File.class);
  expect(frameworkIdlFile.getAbsolutePath()).andReturn(pathToFrameworkAidl);
  expect(androidPlatformTarget.getAndroidFrameworkIdlFile()).andReturn(frameworkIdlFile);
  ExecutionContext executionContext=createMock(ExecutionContext.class);
  expect(executionContext.getAndroidPlatformTarget()).andReturn(androidPlatformTarget);
  expect(executionContext.getProjectFilesystem()).andReturn(new ProjectFilesystem(new File(""String_Node_Str"")){
    @Override public Function<String,String> getPathRelativizer(){
      return Functions.identity();
    }
  }
);
  replay(androidPlatformTarget,aidlExecutable,frameworkIdlFile,executionContext);
  String outputDirectory=String.format(""String_Node_Str"",BuckConstant.GEN_DIR,importPath);
  MkdirStep mkdirStep=(MkdirStep)steps.get(0);
  assertEquals(""String_Node_Str"" + outputDirectory,mkdirStep.getPath(executionContext),outputDirectory);
  MoreAsserts.assertShellCommands(""String_Node_Str"",ImmutableList.of(String.format(""String_Node_Str"",pathToAidlExecutable,pathToFrameworkAidl,importPath,outputDirectory,pathToAidl)),steps.subList(1,2),executionContext);
  verify(androidPlatformTarget,aidlExecutable,frameworkIdlFile,executionContext);
}","@Test public void testSimpleGenAidlRule() throws IOException {
  BuildContext context=null;
  String pathToAidl=""String_Node_Str"";
  String importPath=""String_Node_Str"";
  BuildRuleResolver ruleResolver=new BuildRuleResolver();
  GenAidlRule genAidlRule=ruleResolver.buildAndAddToIndex(GenAidlRule.newGenAidlRuleBuilder(new FakeAbstractBuildRuleBuilderParams()).setBuildTarget(BuildTargetFactory.newInstance(""String_Node_Str"")).setAidl(pathToAidl).setImportPath(importPath));
  assertEquals(BuildRuleType.GEN_AIDL,genAidlRule.getType());
  assertTrue(genAidlRule.isAndroidRule());
  assertEquals(ImmutableList.of(pathToAidl),genAidlRule.getInputsToCompareToOutput());
  List<Step> steps=genAidlRule.buildInternal(context);
  final String pathToAidlExecutable=""String_Node_Str"";
  final String pathToFrameworkAidl=""String_Node_Str"";
  AndroidPlatformTarget androidPlatformTarget=createMock(AndroidPlatformTarget.class);
  File aidlExecutable=createMock(File.class);
  expect(aidlExecutable.getAbsolutePath()).andReturn(pathToAidlExecutable);
  expect(androidPlatformTarget.getAidlExecutable()).andReturn(aidlExecutable);
  File frameworkIdlFile=createMock(File.class);
  expect(frameworkIdlFile.getAbsolutePath()).andReturn(pathToFrameworkAidl);
  expect(androidPlatformTarget.getAndroidFrameworkIdlFile()).andReturn(frameworkIdlFile);
  ExecutionContext executionContext=createMock(ExecutionContext.class);
  expect(executionContext.getAndroidPlatformTarget()).andReturn(androidPlatformTarget);
  expect(executionContext.getProjectFilesystem()).andReturn(new ProjectFilesystem(new File(""String_Node_Str"")){
    @Override public Function<String,String> getPathRelativizer(){
      return Functions.identity();
    }
  }
);
  replay(androidPlatformTarget,aidlExecutable,frameworkIdlFile,executionContext);
  String outputDirectory=String.format(""String_Node_Str"",BuckConstant.GEN_DIR,importPath);
  MkdirStep mkdirStep=(MkdirStep)steps.get(0);
  assertEquals(""String_Node_Str"" + outputDirectory,mkdirStep.getPath(executionContext),outputDirectory);
  ShellStep aidlStep=(ShellStep)steps.get(1);
  assertEquals(""String_Node_Str"",String.format(""String_Node_Str"",pathToAidlExecutable,pathToFrameworkAidl,importPath,outputDirectory,pathToAidl),aidlStep.getDescription(executionContext));
  assertEquals(2,steps.size());
  verify(androidPlatformTarget,aidlExecutable,frameworkIdlFile,executionContext);
}",0.957657467874447
53310,"@Override protected ImmutableSortedSet<String> getInputsToCompareToOutput(){
  return srcs;
}","@Override protected ImmutableSortedSet<String> getInputsToCompareToOutput(){
  return ImmutableSortedSet.copyOf(srcs);
}",0.8732394366197183
53311,"protected Genrule(BuildRuleParams buildRuleParams,List<String> srcs,String cmd,String out,Function<String,String> relativeToAbsolutePathFunction){
  super(buildRuleParams);
  this.srcs=ImmutableSortedSet.<String>naturalOrder().addAll(srcs).build();
  this.cmd=Preconditions.checkNotNull(cmd);
  this.srcsToAbsolutePaths=Maps.toMap(srcs,relativeToAbsolutePathFunction);
  Preconditions.checkNotNull(out);
  this.pathToOutDirectory=String.format(""String_Node_Str"",BuckConstant.GEN_DIR,buildRuleParams.getBuildTarget().getBasePathWithSlash());
  this.pathToOutFile=String.format(""String_Node_Str"",pathToOutDirectory,out);
  this.absolutePathToOutFile=relativeToAbsolutePathFunction.apply(this.pathToOutFile);
  this.pathToTmpDirectory=String.format(""String_Node_Str"",BuckConstant.GEN_DIR,buildRuleParams.getBuildTarget().getBasePathWithSlash(),getBuildTarget().getShortName());
  this.absolutePathToTmpDirectory=relativeToAbsolutePathFunction.apply(pathToTmpDirectory);
  this.pathToSrcDirectory=String.format(""String_Node_Str"",BuckConstant.GEN_DIR,buildRuleParams.getBuildTarget().getBasePathWithSlash(),getBuildTarget().getShortName());
  this.absolutePathToSrcDirectory=relativeToAbsolutePathFunction.apply(pathToSrcDirectory);
  this.relativeToAbsolutePathFunction=relativeToAbsolutePathFunction;
}","protected Genrule(BuildRuleParams buildRuleParams,List<String> srcs,String cmd,String out,Function<String,String> relativeToAbsolutePathFunction){
  super(buildRuleParams);
  this.srcs=ImmutableList.copyOf(srcs);
  this.cmd=Preconditions.checkNotNull(cmd);
  this.srcsToAbsolutePaths=Maps.toMap(srcs,relativeToAbsolutePathFunction);
  Preconditions.checkNotNull(out);
  this.pathToOutDirectory=String.format(""String_Node_Str"",BuckConstant.GEN_DIR,buildRuleParams.getBuildTarget().getBasePathWithSlash());
  this.pathToOutFile=String.format(""String_Node_Str"",pathToOutDirectory,out);
  this.absolutePathToOutFile=relativeToAbsolutePathFunction.apply(this.pathToOutFile);
  this.pathToTmpDirectory=String.format(""String_Node_Str"",BuckConstant.GEN_DIR,buildRuleParams.getBuildTarget().getBasePathWithSlash(),getBuildTarget().getShortName());
  this.absolutePathToTmpDirectory=relativeToAbsolutePathFunction.apply(pathToTmpDirectory);
  this.pathToSrcDirectory=String.format(""String_Node_Str"",BuckConstant.GEN_DIR,buildRuleParams.getBuildTarget().getBasePathWithSlash(),getBuildTarget().getShortName());
  this.absolutePathToSrcDirectory=relativeToAbsolutePathFunction.apply(pathToSrcDirectory);
  this.relativeToAbsolutePathFunction=relativeToAbsolutePathFunction;
}",0.97423887587822
53312,"@Override public boolean hasUncachedDescendants(final BuildContext context) throws IOException {
  if (hasUncachedDescendants.isSet()) {
    return hasUncachedDescendants.asBoolean();
  }
  if (!isCached(context)) {
    hasUncachedDescendants=TriState.TRUE;
  }
 else {
    boolean depHasUncachedDescendant=false;
    for (    BuildRule dep : getDeps()) {
      if (dep.hasUncachedDescendants(context)) {
        depHasUncachedDescendant=true;
        break;
      }
    }
    hasUncachedDescendants=TriState.forBooleanValue(depHasUncachedDescendant);
  }
  return hasUncachedDescendants.asBoolean();
}","@Override public boolean hasUncachedDescendants(final BuildContext context) throws IOException {
  if (hasUncachedDescendants.isSet()) {
    return hasUncachedDescendants.asBoolean();
  }
  if (!isCached(context)) {
    hasUncachedDescendants=TriState.TRUE;
  }
 else {
    hasUncachedDescendants=TriState.forBooleanValue(!getDepsWithUncachedDescendants(context).isEmpty());
  }
  return hasUncachedDescendants.asBoolean();
}",0.7341772151898734
53313,"@Override public final synchronized ListenableFuture<BuildRuleSuccess> build(final BuildContext context){
  if (buildRuleResult != null) {
    return buildRuleResult;
  }
  context.getEventBus().post(BuildEvents.started(this));
  boolean isCached;
  try {
    isCached=isCached(context);
  }
 catch (  IOException e) {
    buildRuleResult=Futures.immediateFailedFuture(e);
    context.getEventBus().post(BuildEvents.finished(this,BuildRuleStatus.FAIL,CacheResult.MISS));
    return buildRuleResult;
  }
  if (isCached) {
    logger.info(String.format(""String_Node_Str"",getFullyQualifiedName()));
    buildRuleResult=Futures.immediateFuture(new BuildRuleSuccess(this));
    context.getEventBus().post(BuildEvents.finished(this,BuildRuleStatus.SUCCESS,CacheResult.HIT));
    return buildRuleResult;
  }
  logger.info(String.format(""String_Node_Str"",getFullyQualifiedName()));
  buildRuleResult=SettableFuture.create();
  ListenableFuture<List<BuildRuleSuccess>> builtDeps=Builder.getInstance().buildRules(getDeps(),context);
  OnDepsBuiltCallback onDepsBuiltCallback=new OnDepsBuiltCallback(context);
  Futures.addCallback(builtDeps,onDepsBuiltCallback,context.getExecutor());
  Futures.addCallback(buildRuleResult,new FutureCallback<BuildRuleSuccess>(){
    @Override public void onSuccess(    BuildRuleSuccess buildRuleSuccess){
      context.getEventBus().post(BuildEvents.finished(AbstractCachingBuildRule.this,BuildRuleStatus.SUCCESS,CacheResult.MISS));
    }
    @Override public void onFailure(    Throwable throwable){
      context.getEventBus().post(BuildEvents.finished(AbstractCachingBuildRule.this,BuildRuleStatus.FAIL,CacheResult.MISS));
    }
  }
,context.getExecutor());
  return buildRuleResult;
}","@Override public final synchronized ListenableFuture<BuildRuleSuccess> build(final BuildContext context){
  if (buildRuleResult != null) {
    return buildRuleResult;
  }
  context.getEventBus().post(BuildEvents.started(this));
  boolean isCached;
  ImmutableSet<BuildRule> depsWithUncachedDescendants;
  try {
    isCached=isCached(context);
    depsWithUncachedDescendants=getDepsWithUncachedDescendants(context);
  }
 catch (  IOException e) {
    buildRuleResult=Futures.immediateFailedFuture(e);
    context.getEventBus().post(BuildEvents.finished(this,BuildRuleStatus.FAIL,CacheResult.MISS));
    return buildRuleResult;
  }
  buildRuleResult=SettableFuture.create();
  ListenableFuture<List<BuildRuleSuccess>> builtDeps=Builder.getInstance().buildRules(depsWithUncachedDescendants,context);
  if (isCached) {
    logger.info(String.format(""String_Node_Str"",getFullyQualifiedName()));
    context.getEventBus().post(BuildEvents.finished(this,BuildRuleStatus.SUCCESS,CacheResult.HIT));
    Futures.addCallback(builtDeps,new FutureCallback<List<BuildRuleSuccess>>(){
      final SettableFuture<BuildRuleSuccess> result=(SettableFuture<BuildRuleSuccess>)buildRuleResult;
      @Override public void onSuccess(      List<BuildRuleSuccess> results){
        result.set(new BuildRuleSuccess(AbstractCachingBuildRule.this));
      }
      @Override public void onFailure(      Throwable t){
        result.setException(t);
      }
    }
,context.getExecutor());
    return buildRuleResult;
  }
  logger.info(String.format(""String_Node_Str"",getFullyQualifiedName()));
  buildRuleResult=SettableFuture.create();
  OnDepsBuiltCallback onDepsBuiltCallback=new OnDepsBuiltCallback(context);
  Futures.addCallback(builtDeps,onDepsBuiltCallback,context.getExecutor());
  Futures.addCallback(buildRuleResult,new FutureCallback<BuildRuleSuccess>(){
    @Override public void onSuccess(    BuildRuleSuccess buildRuleSuccess){
      context.getEventBus().post(BuildEvents.finished(AbstractCachingBuildRule.this,BuildRuleStatus.SUCCESS,CacheResult.MISS));
    }
    @Override public void onFailure(    Throwable throwable){
      context.getEventBus().post(BuildEvents.finished(AbstractCachingBuildRule.this,BuildRuleStatus.FAIL,CacheResult.MISS));
    }
  }
,context.getExecutor());
  return buildRuleResult;
}",0.7645885286783043
53314,"@Test public void whenBuildFinishesThenBuildSuccessEventFired() throws ExecutionException, InterruptedException {
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  CachingBuildRuleParams params=new CachingBuildRuleParams(target,ImmutableSortedSet.<BuildRule>of(),ImmutableSet.of(BuildTargetPattern.MATCH_ALL),artifactCache);
  StepRunner stepRunner=createNiceMock(StepRunner.class);
  expect(stepRunner.getListeningExecutorService()).andStubReturn(MoreExecutors.sameThreadExecutor());
  JavaPackageFinder packageFinder=createNiceMock(JavaPackageFinder.class);
  replay(stepRunner,packageFinder);
  EventBus bus=new EventBus();
  Listener listener=new Listener();
  bus.register(listener);
  DummyRule rule=new DummyRule(params,false,false);
  File root=new File(""String_Node_Str"");
  BuildContext context=BuildContext.builder().setEventBus(bus).setProjectRoot(root).setDependencyGraph(createMock(DependencyGraph.class)).setProjectFilesystem(new ProjectFilesystem(root)).setCommandRunner(stepRunner).setJavaPackageFinder(packageFinder).build();
  ListenableFuture<BuildRuleSuccess> build=rule.build(context);
  build.get();
  assertSeenEventsContain(ImmutableList.<BuildEvent>of(BuildEvents.started(rule),BuildEvents.finished(rule,SUCCESS,MISS)),listener.getSeen());
}","@Test public void whenBuildFinishesThenBuildSuccessEventFired() throws ExecutionException, InterruptedException {
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  CachingBuildRuleParams params=new CachingBuildRuleParams(target,ImmutableSortedSet.<BuildRule>of(),ImmutableSet.of(BuildTargetPattern.MATCH_ALL),artifactCache);
  StepRunner stepRunner=createNiceMock(StepRunner.class);
  expect(stepRunner.getListeningExecutorService()).andStubReturn(MoreExecutors.sameThreadExecutor());
  JavaPackageFinder packageFinder=createNiceMock(JavaPackageFinder.class);
  replay(stepRunner,packageFinder);
  EventBus bus=new EventBus();
  Listener listener=new Listener();
  bus.register(listener);
  DummyRule rule=new DummyRule(params,false,false,false);
  File root=new File(""String_Node_Str"");
  BuildContext context=BuildContext.builder().setEventBus(bus).setProjectRoot(root).setDependencyGraph(createMock(DependencyGraph.class)).setProjectFilesystem(new ProjectFilesystem(root)).setCommandRunner(stepRunner).setJavaPackageFinder(packageFinder).build();
  ListenableFuture<BuildRuleSuccess> build=rule.build(context);
  build.get();
  assertSeenEventsContain(ImmutableList.<BuildEvent>of(BuildEvents.started(rule),BuildEvents.finished(rule,SUCCESS,MISS)),listener.getSeen());
}",0.9976816074188564
53315,"protected DummyRule(CachingBuildRuleParams cachingBuildRuleParams,boolean isCached,boolean cacheDetonates){
  super(cachingBuildRuleParams);
  cached=isCached;
  this.cacheDetonates=cacheDetonates;
}","protected DummyRule(CachingBuildRuleParams cachingBuildRuleParams,boolean isCached,boolean cacheDetonates,boolean hasUncachedDescendants){
  super(cachingBuildRuleParams);
  cached=isCached;
  this.cacheDetonates=cacheDetonates;
  this.hasUncachedDescendants=hasUncachedDescendants;
  deps=Sets.newHashSet();
}",0.7819253438113949
53316,"@Test @SuppressWarnings(""String_Node_Str"") public void whenCacheRaisesExceptionThenBuildFailEventFired() throws ExecutionException, InterruptedException {
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  CachingBuildRuleParams params=new CachingBuildRuleParams(target,ImmutableSortedSet.<BuildRule>of(),ImmutableSet.of(BuildTargetPattern.MATCH_ALL),artifactCache);
  StepRunner stepRunner=createNiceMock(StepRunner.class);
  expect(stepRunner.getListeningExecutorService()).andStubReturn(MoreExecutors.sameThreadExecutor());
  JavaPackageFinder packageFinder=createNiceMock(JavaPackageFinder.class);
  replay(stepRunner,packageFinder);
  EventBus bus=new EventBus();
  Listener listener=new Listener();
  bus.register(listener);
  DummyRule rule=new DummyRule(params,false,true);
  File root=new File(""String_Node_Str"");
  BuildContext context=BuildContext.builder().setEventBus(bus).setProjectRoot(root).setDependencyGraph(createMock(DependencyGraph.class)).setProjectFilesystem(new ProjectFilesystem(root)).setCommandRunner(stepRunner).setJavaPackageFinder(packageFinder).build();
  ListenableFuture<BuildRuleSuccess> build=rule.build(context);
  try {
    build.get();
    fail(""String_Node_Str"");
  }
 catch (  ExecutionException ignored) {
  }
  assertSeenEventsContain(ImmutableList.<BuildEvent>of(BuildEvents.started(rule),BuildEvents.finished(rule,FAIL,MISS)),listener.getSeen());
}","@Test @SuppressWarnings(""String_Node_Str"") public void whenCacheRaisesExceptionThenBuildFailEventFired() throws ExecutionException, InterruptedException {
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  CachingBuildRuleParams params=new CachingBuildRuleParams(target,ImmutableSortedSet.<BuildRule>of(),ImmutableSet.of(BuildTargetPattern.MATCH_ALL),artifactCache);
  StepRunner stepRunner=createNiceMock(StepRunner.class);
  expect(stepRunner.getListeningExecutorService()).andStubReturn(MoreExecutors.sameThreadExecutor());
  JavaPackageFinder packageFinder=createNiceMock(JavaPackageFinder.class);
  replay(stepRunner,packageFinder);
  EventBus bus=new EventBus();
  Listener listener=new Listener();
  bus.register(listener);
  DummyRule rule=new DummyRule(params,false,true,false);
  File root=new File(""String_Node_Str"");
  BuildContext context=BuildContext.builder().setEventBus(bus).setProjectRoot(root).setDependencyGraph(createMock(DependencyGraph.class)).setProjectFilesystem(new ProjectFilesystem(root)).setCommandRunner(stepRunner).setJavaPackageFinder(packageFinder).build();
  ListenableFuture<BuildRuleSuccess> build=rule.build(context);
  try {
    build.get();
    fail(""String_Node_Str"");
  }
 catch (  ExecutionException ignored) {
  }
  assertSeenEventsContain(ImmutableList.<BuildEvent>of(BuildEvents.started(rule),BuildEvents.finished(rule,FAIL,MISS)),listener.getSeen());
}",0.9978843441466856
53317,"@Test public void whenBuildResultCachedThenBuildCachedEventFired() throws ExecutionException, InterruptedException {
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  CachingBuildRuleParams params=new CachingBuildRuleParams(target,ImmutableSortedSet.<BuildRule>of(),ImmutableSet.of(BuildTargetPattern.MATCH_ALL),artifactCache);
  StepRunner stepRunner=createNiceMock(StepRunner.class);
  expect(stepRunner.getListeningExecutorService()).andStubReturn(MoreExecutors.sameThreadExecutor());
  JavaPackageFinder packageFinder=createNiceMock(JavaPackageFinder.class);
  replay(stepRunner,packageFinder);
  EventBus bus=new EventBus();
  Listener listener=new Listener();
  bus.register(listener);
  DummyRule rule=new DummyRule(params,true,false);
  File root=new File(""String_Node_Str"");
  BuildContext context=BuildContext.builder().setEventBus(bus).setProjectRoot(root).setDependencyGraph(createMock(DependencyGraph.class)).setProjectFilesystem(new ProjectFilesystem(root)).setCommandRunner(stepRunner).setJavaPackageFinder(packageFinder).build();
  ListenableFuture<BuildRuleSuccess> build=rule.build(context);
  build.get();
  assertSeenEventsContain(ImmutableList.<BuildEvent>of(BuildEvents.started(rule),BuildEvents.finished(rule,SUCCESS,HIT)),listener.getSeen());
}","@Test public void whenBuildResultCachedThenBuildCachedEventFired() throws ExecutionException, InterruptedException {
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  CachingBuildRuleParams params=new CachingBuildRuleParams(target,ImmutableSortedSet.<BuildRule>of(),ImmutableSet.of(BuildTargetPattern.MATCH_ALL),artifactCache);
  StepRunner stepRunner=createNiceMock(StepRunner.class);
  expect(stepRunner.getListeningExecutorService()).andStubReturn(MoreExecutors.sameThreadExecutor());
  JavaPackageFinder packageFinder=createNiceMock(JavaPackageFinder.class);
  replay(stepRunner,packageFinder);
  EventBus bus=new EventBus();
  Listener listener=new Listener();
  bus.register(listener);
  DummyRule rule=new DummyRule(params,true,false,false);
  File root=new File(""String_Node_Str"");
  BuildContext context=BuildContext.builder().setEventBus(bus).setProjectRoot(root).setDependencyGraph(createMock(DependencyGraph.class)).setProjectFilesystem(new ProjectFilesystem(root)).setCommandRunner(stepRunner).setJavaPackageFinder(packageFinder).build();
  ListenableFuture<BuildRuleSuccess> build=rule.build(context);
  build.get();
  assertSeenEventsContain(ImmutableList.<BuildEvent>of(BuildEvents.started(rule),BuildEvents.finished(rule,SUCCESS,HIT)),listener.getSeen());
}",0.9976833976833976
53318,"public DependencyGraph parseBuildFilesForTargets(Iterable<BuildTarget> buildTargets,Iterable<String> defaultIncludes) throws IOException, NoSuchBuildTargetException {
  if (!parserWasPopulatedViaParseRawRules) {
    Set<File> buildTargetFiles=Sets.newHashSet();
    for (    BuildTarget buildTarget : buildTargets) {
      File buildFile=buildTarget.getBuildFile();
      boolean isNewElement=buildTargetFiles.add(buildFile);
      if (isNewElement) {
        parseBuildFile(buildFile,defaultIncludes);
      }
    }
  }
  DependencyGraph graph=findAllTransitiveDependencies(buildTargets,defaultIncludes);
  Tracer.addComment(""String_Node_Str"");
  return graph;
}","public DependencyGraph parseBuildFilesForTargets(Iterable<BuildTarget> buildTargets,Iterable<String> defaultIncludes) throws IOException, NoSuchBuildTargetException {
  if (!parserWasPopulatedViaParseRawRules) {
    Set<File> buildTargetFiles=Sets.newHashSet();
    for (    BuildTarget buildTarget : buildTargets) {
      File buildFile=buildTarget.getBuildFile();
      boolean isNewElement=buildTargetFiles.add(buildFile);
      if (isNewElement) {
        parseBuildFile(buildFile,defaultIncludes);
      }
      if (!knownBuildTargets.containsKey(buildTarget.getFullyQualifiedName())) {
        throw NoSuchBuildTargetException.createForMissingBuildRule(buildTarget);
      }
    }
  }
  DependencyGraph graph=findAllTransitiveDependencies(buildTargets,defaultIncludes);
  Tracer.addComment(""String_Node_Str"");
  return graph;
}",0.8863636363636364
53319,"@Test public void testParseBuildFilesForTargetsWithOverlappingTargets() throws IOException, NoSuchBuildTargetException {
  File projectDirectoryRoot=tempDir.getRoot();
  tempDir.newFolder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  File buildFile=tempDir.newFile(""String_Node_Str"" + BuckConstant.BUILD_RULES_FILE_NAME);
  Files.write(""String_Node_Str"" + ""String_Node_Str"",buildFile,Charsets.UTF_8);
  Ansi ansi=new Ansi();
  ProjectFilesystem filesystem=new ProjectFilesystem(projectDirectoryRoot);
  Parser parser=new Parser(filesystem,new BuildFileTree(ImmutableSet.<BuildTarget>of()),ansi);
  BuildTarget fooTarget=BuildTargetFactory.newInstance(""String_Node_Str"",""String_Node_Str"",buildFile);
  BuildTarget barTarget=BuildTargetFactory.newInstance(""String_Node_Str"",""String_Node_Str"",buildFile);
  Iterable<BuildTarget> buildTargets=ImmutableList.of(fooTarget,barTarget);
  Iterable<String> defaultIncludes=ImmutableList.of();
  DependencyGraph graph=parser.parseBuildFilesForTargets(buildTargets,defaultIncludes);
  BuildRule fooRule=graph.findBuildRuleByTarget(fooTarget);
  assertNotNull(fooRule);
  BuildRule barRule=graph.findBuildRuleByTarget(barTarget);
  assertNotNull(barRule);
}","@Test public void testParseBuildFilesForTargetsWithOverlappingTargets() throws IOException, NoSuchBuildTargetException {
  BuildTarget fooTarget=BuildTargetFactory.newInstance(""String_Node_Str"",""String_Node_Str"",testBuildFile);
  BuildTarget barTarget=BuildTargetFactory.newInstance(""String_Node_Str"",""String_Node_Str"",testBuildFile);
  Iterable<BuildTarget> buildTargets=ImmutableList.of(fooTarget,barTarget);
  Iterable<String> defaultIncludes=ImmutableList.of();
  DependencyGraph graph=testParser.parseBuildFilesForTargets(buildTargets,defaultIncludes);
  BuildRule fooRule=graph.findBuildRuleByTarget(fooTarget);
  assertNotNull(fooRule);
  BuildRule barRule=graph.findBuildRuleByTarget(barTarget);
  assertNotNull(barRule);
}",0.6711409395973155
53320,"@Override protected List<String> getInputsToCompareToOutput(BuildContext context){
  ImmutableList.Builder<String> inputsToConsiderForCachingPurposes=ImmutableList.builder();
  addInputsToList(res,inputsToConsiderForCachingPurposes,directoryTraverser);
  addInputsToList(assets,inputsToConsiderForCachingPurposes,directoryTraverser);
  if (manifestFile != null) {
    inputsToConsiderForCachingPurposes.add(manifestFile);
  }
  return inputsToConsiderForCachingPurposes.build();
}","@Override protected Iterable<String> getInputsToCompareToOutput(BuildContext context){
  ImmutableSortedSet.Builder<String> inputsToConsiderForCachingPurposes=ImmutableSortedSet.naturalOrder();
  addResContents(inputsToConsiderForCachingPurposes);
  addAssetsContents(inputsToConsiderForCachingPurposes);
  if (manifestFile != null) {
    inputsToConsiderForCachingPurposes.add(manifestFile);
  }
  return inputsToConsiderForCachingPurposes.build();
}",0.3501611170784103
53321,"@Override protected RuleKey.Builder ruleKeyBuilder(){
  return super.ruleKeyBuilder().set(""String_Node_Str"",res).set(""String_Node_Str"",assets);
}","@Override protected RuleKey.Builder ruleKeyBuilder(){
  ImmutableSortedSet.Builder<String> resFiles=ImmutableSortedSet.naturalOrder();
  addResContents(resFiles);
  ImmutableSortedSet.Builder<String> assetsFiles=ImmutableSortedSet.naturalOrder();
  addAssetsContents(assetsFiles);
  return super.ruleKeyBuilder().set(""String_Node_Str"",resFiles.build()).set(""String_Node_Str"",assetsFiles.build());
}",0.5340699815837937
53322,"@Override protected RuleKey.Builder ruleKeyBuilder(){
  return super.ruleKeyBuilder().set(""String_Node_Str"",srcs).set(""String_Node_Str"",resources).set(""String_Node_Str"",getClasspathEntries()).set(""String_Node_Str"",inputsToConsiderForCachingPurposes).set(""String_Node_Str"",isAndroidRule()).set(""String_Node_Str"",sourceLevel).set(""String_Node_Str"",targetLevel);
}","@Override protected RuleKey.Builder ruleKeyBuilder(){
  return super.ruleKeyBuilder().set(""String_Node_Str"",srcs).set(""String_Node_Str"",resources).set(""String_Node_Str"",getClasspathEntries()).set(""String_Node_Str"",isAndroidRule()).set(""String_Node_Str"",sourceLevel).set(""String_Node_Str"",targetLevel);
}",0.9126506024096386
53323,"@Override protected Iterable<String> getInputsToCompareToOutput(BuildContext context){
  ImmutableSortedSet.Builder<String> builder=ImmutableSortedSet.naturalOrder();
  if (manifestFile != null) {
    builder.add(manifestFile);
  }
  if (metaInfDirectory != null) {
    metaInfDirectoryRecurse(builder,new File(metaInfDirectory));
  }
  return builder.build();
}","@Override protected Iterable<String> getInputsToCompareToOutput(BuildContext context){
  ImmutableSortedSet.Builder<String> builder=ImmutableSortedSet.naturalOrder();
  if (manifestFile != null) {
    builder.add(manifestFile);
  }
  addMetaInfContents(builder);
  return builder.build();
}",0.7208588957055214
53324,"@Override public JavaBinaryRule build(Map<String,BuildRule> buildRuleIndex){
  return new JavaBinaryRule(createBuildRuleParams(buildRuleIndex),mainClass,manifestFile,metaInfDirectory);
}","@Override public JavaBinaryRule build(Map<String,BuildRule> buildRuleIndex){
  return new JavaBinaryRule(createBuildRuleParams(buildRuleIndex),mainClass,manifestFile,metaInfDirectory,new DefaultDirectoryTraverser());
}",0.9207920792079208
53325,"@Override protected RuleKey.Builder ruleKeyBuilder(){
  return super.ruleKeyBuilder().set(""String_Node_Str"",mainClass).set(""String_Node_Str"",manifestFile).set(""String_Node_Str"",metaInfDirectory);
}","@Override protected RuleKey.Builder ruleKeyBuilder(){
  ImmutableSortedSet.Builder<String> metaInfFiles=ImmutableSortedSet.naturalOrder();
  addMetaInfContents(metaInfFiles);
  return super.ruleKeyBuilder().set(""String_Node_Str"",mainClass).set(""String_Node_Str"",manifestFile).set(""String_Node_Str"",metaInfFiles.build());
}",0.7244701348747592
53326,"JavaBinaryRule(BuildRuleParams buildRuleParams,@Nullable String mainClass,@Nullable String manifestFile,@Nullable String metaInfDirectory){
  super(buildRuleParams);
  this.mainClass=mainClass;
  this.manifestFile=manifestFile;
  this.metaInfDirectory=metaInfDirectory;
  classpathEntriesSupplier=Suppliers.memoize(new Supplier<ImmutableSet<String>>(){
    @Override public ImmutableSet<String> get(){
      return ImmutableSet.copyOf(getClasspathEntriesMap().values());
    }
  }
);
}","JavaBinaryRule(BuildRuleParams buildRuleParams,@Nullable String mainClass,@Nullable String manifestFile,@Nullable String metaInfDirectory,DirectoryTraverser directoryTraverser){
  super(buildRuleParams);
  this.mainClass=mainClass;
  this.manifestFile=manifestFile;
  this.metaInfDirectory=metaInfDirectory;
  this.classpathEntriesSupplier=Suppliers.memoize(new Supplier<ImmutableSet<String>>(){
    @Override public ImmutableSet<String> get(){
      return ImmutableSet.copyOf(getClasspathEntriesMap().values());
    }
  }
);
  this.directoryTraverser=Preconditions.checkNotNull(directoryTraverser);
}",0.8923643054277829
53327,"@Override protected List<String> getInputsToCompareToOutput(BuildContext context){
  ImmutableList.Builder<String> inputsToConsiderForCachingPurposes=ImmutableList.builder();
  addInputsToList(nativeLibs,inputsToConsiderForCachingPurposes,directoryTraverser);
  return inputsToConsiderForCachingPurposes.build();
}","@Override protected Iterable<String> getInputsToCompareToOutput(BuildContext context){
  ImmutableSortedSet.Builder<String> inputsToConsiderForCachingPurposes=ImmutableSortedSet.naturalOrder();
  addInputsToSortedSet(nativeLibs,inputsToConsiderForCachingPurposes,directoryTraverser);
  return inputsToConsiderForCachingPurposes.build();
}",0.911042944785276
53328,"public Builder set(String key,@Nullable ImmutableSet<String> val){
  setKey(key);
  if (val != null) {
    ImmutableSortedSet<String> sortedVal=ImmutableSortedSet.copyOf(val);
    for (    String s : sortedVal) {
      setVal(s);
    }
  }
  return separate();
}","public Builder set(String key,@Nullable ImmutableSet<String> val){
  setKey(key);
  if (val != null) {
    ImmutableSortedSet<String> sortedValues=ImmutableSortedSet.copyOf(val);
    for (    String value : sortedValues) {
      setVal(value);
    }
  }
  return separate();
}",0.966542750929368
53329,"/** 
 * The idempotence of the RuleKey to be built is false if this method is ever called with a false argument.
 */
public Builder mergeIdempotence(boolean i){
  if (!i) {
    idempotent=false;
  }
  return this;
}","/** 
 * The idempotence of the RuleKey to be built is false if this method is ever called with a false argument.
 */
public Builder mergeIdempotence(boolean idempotence){
  if (!idempotence) {
    idempotent=false;
  }
  return this;
}",0.9555555555555556
53330,"@Test public void testGetInputsToCompareToOutput(){
  DirectoryTraverser traverser=new DirectoryTraverser(){
    @Override public void traverse(    DirectoryTraversal traversal){
      String rootPath=traversal.getRoot().getPath();
      if (""String_Node_Str"".equals(rootPath)) {
        traversal.visit(null,""String_Node_Str"");
        traversal.visit(null,""String_Node_Str"");
        traversal.visit(null,""String_Node_Str"");
      }
 else       if (""String_Node_Str"".equals(rootPath)) {
        traversal.visit(null,""String_Node_Str"");
        traversal.visit(null,""String_Node_Str"");
        traversal.visit(null,""String_Node_Str"");
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + rootPath);
      }
    }
  }
;
  BuildTarget buildTarget=BuildTargetFactory.newInstance(""String_Node_Str"",""String_Node_Str"");
  BuildRuleParams buildRuleParams=new BuildRuleParams(buildTarget,ImmutableSortedSet.<BuildRule>of(),ImmutableSet.of(BuildTargetPattern.MATCH_ALL));
  AndroidResourceRule androidResourceRule=new AndroidResourceRule(buildRuleParams,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",traverser);
  BuildContext context=null;
  MoreAsserts.assertListEquals(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ImmutableList.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),androidResourceRule.getInputsToCompareToOutput(context));
}","@Test public void testGetInputsToCompareToOutput(){
  DirectoryTraverser traverser=new DirectoryTraverser(){
    @Override public void traverse(    DirectoryTraversal traversal){
      String rootPath=traversal.getRoot().getPath();
      if (""String_Node_Str"".equals(rootPath)) {
        traversal.visit(null,""String_Node_Str"");
        traversal.visit(null,""String_Node_Str"");
        traversal.visit(null,""String_Node_Str"");
      }
 else       if (""String_Node_Str"".equals(rootPath)) {
        traversal.visit(null,""String_Node_Str"");
        traversal.visit(null,""String_Node_Str"");
        traversal.visit(null,""String_Node_Str"");
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + rootPath);
      }
    }
  }
;
  BuildTarget buildTarget=BuildTargetFactory.newInstance(""String_Node_Str"",""String_Node_Str"");
  BuildRuleParams buildRuleParams=new BuildRuleParams(buildTarget,ImmutableSortedSet.<BuildRule>of(),ImmutableSet.of(BuildTargetPattern.MATCH_ALL));
  AndroidResourceRule androidResourceRule=new AndroidResourceRule(buildRuleParams,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",traverser);
  BuildContext context=null;
  MoreAsserts.assertIterablesEquals(""String_Node_Str"" + ""String_Node_Str"",ImmutableList.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),androidResourceRule.getInputsToCompareToOutput(context));
}",0.9887102292165584
53331,"private JavaBinaryRule createSampleJavaBinaryRule(Map<String,BuildRule> buildRuleIndex){
  JavaLibraryRule javaLibrary=new DefaultJavaLibraryRule(new BuildRuleParams(BuildTargetFactory.newInstance(""String_Node_Str""),ImmutableSortedSet.<BuildRule>of(),ImmutableSet.of(BuildTargetPattern.MATCH_ALL)),ImmutableSet.<String>of(""String_Node_Str""),ImmutableSet.<String>of(),null,AnnotationProcessingParams.EMPTY);
  buildRuleIndex.put(javaLibrary.getFullyQualifiedName(),javaLibrary);
  JavaBinaryRule javaBinary=new JavaBinaryRule(new BuildRuleParams(BuildTargetFactory.newInstance(""String_Node_Str""),ImmutableSortedSet.<BuildRule>of(javaLibrary),ImmutableSet.<BuildTargetPattern>of()),""String_Node_Str"",null,null);
  buildRuleIndex.put(javaBinary.getFullyQualifiedName(),javaBinary);
  return javaBinary;
}","private JavaBinaryRule createSampleJavaBinaryRule(Map<String,BuildRule> buildRuleIndex){
  JavaLibraryRule javaLibrary=new DefaultJavaLibraryRule(new BuildRuleParams(BuildTargetFactory.newInstance(""String_Node_Str""),ImmutableSortedSet.<BuildRule>of(),ImmutableSet.of(BuildTargetPattern.MATCH_ALL)),ImmutableSet.<String>of(""String_Node_Str""),ImmutableSet.<String>of(),null,AnnotationProcessingParams.EMPTY);
  buildRuleIndex.put(javaLibrary.getFullyQualifiedName(),javaLibrary);
  JavaBinaryRule javaBinary=new JavaBinaryRule(new BuildRuleParams(BuildTargetFactory.newInstance(""String_Node_Str""),ImmutableSortedSet.<BuildRule>of(javaLibrary),ImmutableSet.<BuildTargetPattern>of()),""String_Node_Str"",null,null,new DefaultDirectoryTraverser());
  buildRuleIndex.put(javaBinary.getFullyQualifiedName(),javaBinary);
  return javaBinary;
}",0.9804161566707468
53332,"@Test public void testGetInputsToCompareToOutput(){
  DirectoryTraverser traverser=new DirectoryTraverser(){
    @Override public void traverse(    DirectoryTraversal traversal){
      String rootPath=traversal.getRoot().getPath();
      if (""String_Node_Str"".equals(rootPath)) {
        traversal.visit(null,""String_Node_Str"");
        traversal.visit(null,""String_Node_Str"");
        traversal.visit(null,""String_Node_Str"");
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + rootPath);
      }
    }
  }
;
  BuildTarget buildTarget=BuildTargetFactory.newInstance(""String_Node_Str"",""String_Node_Str"");
  BuildRuleParams buildRuleParams=new BuildRuleParams(buildTarget,ImmutableSortedSet.<BuildRule>of(),ImmutableSet.of(BuildTargetPattern.MATCH_ALL));
  PrebuiltNativeLibraryBuildRule nativeLibraryRule=new PrebuiltNativeLibraryBuildRule(buildRuleParams,""String_Node_Str"",traverser);
  BuildContext context=null;
  MoreAsserts.assertListEquals(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ImmutableList.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),nativeLibraryRule.getInputsToCompareToOutput(context));
}","@Test public void testGetInputsToCompareToOutput(){
  DirectoryTraverser traverser=new DirectoryTraverser(){
    @Override public void traverse(    DirectoryTraversal traversal){
      String rootPath=traversal.getRoot().getPath();
      if (""String_Node_Str"".equals(rootPath)) {
        traversal.visit(null,""String_Node_Str"");
        traversal.visit(null,""String_Node_Str"");
        traversal.visit(null,""String_Node_Str"");
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + rootPath);
      }
    }
  }
;
  BuildTarget buildTarget=BuildTargetFactory.newInstance(""String_Node_Str"",""String_Node_Str"");
  BuildRuleParams buildRuleParams=new BuildRuleParams(buildTarget,ImmutableSortedSet.<BuildRule>of(),ImmutableSet.of(BuildTargetPattern.MATCH_ALL));
  PrebuiltNativeLibraryBuildRule nativeLibraryRule=new PrebuiltNativeLibraryBuildRule(buildRuleParams,""String_Node_Str"",traverser);
  BuildContext context=null;
  MoreAsserts.assertIterablesEquals(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ImmutableList.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),nativeLibraryRule.getInputsToCompareToOutput(context));
}",0.9943698570809876
53333,"public void testPut_ComparableKey(){
  final boolean java6CompatibleSources=!TestUtils.isJvm() || TestUtils.getJdkVersion() < 7;
  TreeMap<String,Object> map=new TreeMap<String,Object>();
  ConflictingKey conflictingKey=new ConflictingKey(""String_Node_Str"");
  try {
    TreeMap untypedMap=map;
    untypedMap.put(conflictingKey,""String_Node_Str"");
    assertTrue(""String_Node_Str"",java6CompatibleSources);
  }
 catch (  ClassCastException e) {
    assertFalse(java6CompatibleSources);
  }
  try {
    map.put(""String_Node_Str"",""String_Node_Str"");
    assertFalse(""String_Node_Str"",java6CompatibleSources);
  }
 catch (  ClassCastException expected) {
    assertTrue(java6CompatibleSources);
  }
}","public void testPut_ComparableKey(){
  final boolean java6CompatibleSources=!TestUtils.isJvm() || TestUtils.getJdkVersion() < 7;
  TreeMap map=new TreeMap();
  ConflictingKey conflictingKey=new ConflictingKey(""String_Node_Str"");
  try {
    TreeMap untypedMap=map;
    untypedMap.put(conflictingKey,""String_Node_Str"");
    assertTrue(""String_Node_Str"",java6CompatibleSources);
  }
 catch (  ClassCastException e) {
    assertFalse(java6CompatibleSources);
  }
  try {
    map.put(""String_Node_Str"",""String_Node_Str"");
    assertFalse(""String_Node_Str"",java6CompatibleSources);
  }
 catch (  ClassCastException expected) {
    assertTrue(java6CompatibleSources);
  }
}",0.9780058651026392
53334,"@Override protected void verifyMap(){
  if (!TestUtils.isJvm()) {
    TreeMapViolator.callAssertCorrectness(map);
  }
  super.verifyMap();
}","@Override protected void verifyMap(){
  if (!TestUtils.isJvm()) {
    TreeMapViolator.callAssertCorrectness((TreeMap)map);
  }
  super.verifyMap();
}",0.9688581314878892
53335,"@SuppressWarnings(""String_Node_Str"") public static native void callAssertCorrectness(Map map);","@SuppressWarnings(""String_Node_Str"") public static native void callAssertCorrectness(TreeMap map);",0.9791666666666666
53336,"private void checkMethodParameters(JMethod method){
  boolean hasOptionalParameters=false;
  for (  JParameter parameter : method.getParams()) {
    if (parameter.isOptional()) {
      if (parameter.getType().isPrimitiveType()) {
        logError(method,""String_Node_Str"",parameter.getName(),getMemberDescription(method));
      }
      hasOptionalParameters=true;
      continue;
    }
    if (hasOptionalParameters && !parameter.isVarargs()) {
      logError(method,""String_Node_Str"" + ""String_Node_Str"",parameter.getName(),getMemberDescription(method));
      break;
    }
  }
  if (hasOptionalParameters && method.getJsMemberType() != JsMemberType.CONSTRUCTOR && method.getJsMemberType() != JsMemberType.METHOD && !method.isOrOverridesJsFunctionMethod()) {
    logError(method,""String_Node_Str"" + ""String_Node_Str"",getMemberDescription(method));
  }
  if (method.isJsMethodVarargs()) {
    checkJsVarargs(method);
  }
  for (  JMethod overriddenMethod : method.getOverriddenMethods()) {
    for (int i=0; i < overriddenMethod.getParams().size(); i++) {
      if (overriddenMethod.getParams().get(i).isOptional()) {
        if (!method.getParams().get(i).isOptional()) {
          logError(method,""String_Node_Str"",getMemberDescription(method),method.getParams().get(i).getName());
          return;
        }
        break;
      }
    }
  }
}","private void checkMethodParameters(JMethod method){
  if (method.isSynthetic()) {
    return;
  }
  boolean hasOptionalParameters=false;
  for (  JParameter parameter : method.getParams()) {
    if (parameter.isOptional()) {
      if (parameter.getType().isPrimitiveType()) {
        logError(method,""String_Node_Str"",parameter.getName(),getMemberDescription(method));
      }
      hasOptionalParameters=true;
      continue;
    }
    if (hasOptionalParameters && !parameter.isVarargs()) {
      logError(method,""String_Node_Str"" + ""String_Node_Str"",parameter.getName(),getMemberDescription(method));
      break;
    }
  }
  if (hasOptionalParameters && method.getJsMemberType() != JsMemberType.CONSTRUCTOR && method.getJsMemberType() != JsMemberType.METHOD && !method.isOrOverridesJsFunctionMethod()) {
    logError(method,""String_Node_Str"" + ""String_Node_Str"",getMemberDescription(method));
  }
  if (method.isJsMethodVarargs()) {
    checkJsVarargs(method);
  }
  for (  JMethod overriddenMethod : method.getOverriddenMethods()) {
    for (int i=0; i < overriddenMethod.getParams().size(); i++) {
      if (overriddenMethod.getParams().get(i).isOptional()) {
        if (!method.getParams().get(i).isOptional()) {
          logError(method,""String_Node_Str"",getMemberDescription(method),method.getParams().get(i).getName());
          return;
        }
        break;
      }
    }
  }
}",0.9832116788321168
53337,"/** 
 * Removes the element at the specified position in the elements array, adjusting head and tail as necessary. This results in motion of elements backwards or forwards in the array.
 * @return -1 if elements moved backwards (left-shifted); 1 if forwards (right-shifted).
 */
private int removeAtIndex(int i){
  final int mask=array.length - 1;
  int headDistance=(i - head) & mask;
  int tailDistance=(tail - i) & mask;
  if (headDistance >= tailDistance) {
    shiftLeftAtIndex(i);
    return -1;
  }
 else {
    shiftRightAtIndex(i);
    return 1;
  }
}","/** 
 * Removes the element at the specified position in the elements array, adjusting head and tail as necessary. This results in motion of elements backwards or forwards in the array.
 * @return -1 if elements moved backwards (left-shifted); 1 if forwards (right-shifted).
 */
private int removeAtIndex(int i){
  final int mask=array.length - 1;
  int headDistance=(i - head) & mask;
  int tailDistance=(tail - i) & mask;
  int size=(tail - head) & mask;
  checkConcurrentModification(headDistance < size);
  if (headDistance >= tailDistance) {
    shiftLeftAtIndex(i);
    return -1;
  }
 else {
    shiftRightAtIndex(i);
    return 1;
  }
}",0.9293433083956776
53338,"@SuppressWarnings(""String_Node_Str"") @Override public <T>T[] toArray(T[] out){
  int size=size();
  if (out.length < size) {
    out=ArrayHelper.createFrom(out,size);
  }
  Object[] dest=out;
  final int mask=size - 1;
  for (int i=head, dstIdx=0; dstIdx < size; i=(i + 1) & mask, ++dstIdx) {
    dest[dstIdx]=array[i];
  }
  if (out.length > size) {
    out[size]=null;
  }
  return out;
}","@SuppressWarnings(""String_Node_Str"") @Override public <T>T[] toArray(T[] out){
  int size=size();
  if (out.length < size) {
    out=ArrayHelper.createFrom(out,size);
  }
  copyElements(out,size);
  if (out.length > size) {
    out[size]=null;
  }
  return out;
}",0.5727411944869831
53339,"/** 
 * Increase the capacity of this deque when full, i.e., when head and tail have wrapped around to become equal.
 */
private void ensureCapacity(){
  if (head != tail) {
    return;
  }
  int numElements=array.length;
  int newLength=nextArrayLength(numElements);
  if (head != 0) {
    E[] newArray=ArrayHelper.createFrom(array,newLength);
    array=toArray(newArray);
  }
 else {
    ArrayHelper.setLength(array,newLength);
  }
  head=0;
  tail=numElements;
}","/** 
 * Increase the capacity of this deque when full, i.e., when head and tail have wrapped around to become equal.
 */
private void ensureCapacity(){
  if (head != tail) {
    return;
  }
  int numElements=array.length;
  int newLength=nextArrayLength(numElements);
  if (head != 0) {
    E[] newArray=ArrayHelper.createFrom(array,newLength);
    copyElements(newArray,numElements);
    array=newArray;
    head=0;
  }
 else {
    ArrayHelper.setLength(array,newLength);
  }
  tail=numElements;
}",0.897196261682243
53340,"@Override public String apply(String constantName){
  return CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL,constantName);
}","@Override public String apply(String constantName){
  String lowerCase=CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL,constantName);
  if (!constantName.equals(CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE,lowerCase))) {
    return constantName;
  }
  return lowerCase;
}",0.5947242206235012
53341,"/** 
 * In GSS, constant names are defined in upper case but a method name to access a constant in a CssResource interface can be written in lower camel case. <p> This method converts all constant names in a lower camel case identifier.
 */
private Collection<String> renameDefs(Iterable<String> constantsNames){
  return Lists.newArrayList(Iterables.transform(constantsNames,new Function<String,String>(){
    @Override public String apply(    String constantName){
      return CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL,constantName);
    }
  }
));
}","/** 
 * In GSS, constant names are defined in upper case but a method name to access a constant in a CssResource interface can be written in lower camel case. <p> This method converts all constant names in a lower camel case identifier.
 */
private Collection<String> renameDefs(Iterable<String> constantsNames){
  return Lists.newArrayList(Iterables.transform(constantsNames,new Function<String,String>(){
    @Override public String apply(    String constantName){
      String lowerCase=CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL,constantName);
      if (!constantName.equals(CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE,lowerCase))) {
        return constantName;
      }
      return lowerCase;
    }
  }
));
}",0.8575827559661278
53342,"private PathPrefixSet createInclusivePathPrefixSet(){
  pathPrefixes=new PathPrefixSet();
  pathPrefixes.add(new PathPrefix(""String_Node_Str"",null));
  return pathPrefixes;
}","private PathPrefixSet createInclusivePathPrefixSet(){
  PathPrefixSet pathPrefixSet=new PathPrefixSet();
  pathPrefixSet.add(new PathPrefix(""String_Node_Str"",null));
  pathPrefixes.add(pathPrefixSet);
  return pathPrefixSet;
}",0.79
53343,"public static <T,K,D,A,M extends Map<K,D>>Collector<T,?,M> groupingBy(Function<? super T,? extends K> classifier,Supplier<M> mapFactory,Collector<? super T,A,D> downstream){
  return groupingBy0(LinkedHashMap::new,classifier,mapFactory,downstream);
}","public static <T,K,D,A,M extends Map<K,D>>Collector<T,?,M> groupingBy(Function<? super T,? extends K> classifier,Supplier<M> mapFactory,Collector<? super T,A,D> downstream){
  return groupingBy0(() -> {
    return new LinkedHashMap<>();
  }
,classifier,mapFactory,downstream);
}",0.8333333333333334
53344,"private static PathPrefixSet createInclusivePathPrefixSet(){
  PathPrefixSet pathPrefixes=new PathPrefixSet();
  pathPrefixes.add(new PathPrefix(""String_Node_Str"",null));
  return pathPrefixes;
}","private PathPrefixSet createInclusivePathPrefixSet(){
  pathPrefixes=new PathPrefixSet();
  pathPrefixes.add(new PathPrefix(""String_Node_Str"",null));
  return pathPrefixes;
}",0.943089430894309
53345,"private boolean mightNeedDevirtualization(JMethod method,JReferenceType instanceType){
  if (instanceType == null || !method.needsDynamicDispatch()) {
    return false;
  }
  if (devirtualMethodByMethod.containsKey(method)) {
    return true;
  }
  if (method.isJsOverlay()) {
    return true;
  }
  if (method.getEnclosingType().isJsNative()) {
    return false;
  }
  EnumSet<DispatchType> dispatchType=program.getDispatchType(instanceType);
  dispatchType.remove(DispatchType.HAS_JAVA_VIRTUAL_DISPATCH);
  return !dispatchType.isEmpty();
}","private boolean mightNeedDevirtualization(JMethod method,JReferenceType instanceType){
  if (instanceType == null || !method.needsDynamicDispatch()) {
    return false;
  }
  if (devirtualMethodByMethod.containsKey(method)) {
    return true;
  }
  if (isOverlayMethod(method)) {
    return true;
  }
  if (method.getEnclosingType().isJsNative()) {
    return false;
  }
  EnumSet<DispatchType> dispatchType=program.getDispatchType(instanceType);
  dispatchType.remove(DispatchType.HAS_JAVA_VIRTUAL_DISPATCH);
  return !dispatchType.isEmpty();
}",0.9770009199632016
53346,"String f(int i,String... args);","@Override public boolean f(){
  return true;
}",0.2857142857142857
53347,"int apply(SomeInteger t,int u);",boolean apply();,0.425531914893617
53348,"public void testSetDefaultValue_noSet(){
  try {
    attribute3.setDefault(div);
    fail();
  }
 catch (  AssertionError e) {
  }
}","public void testSetDefaultValue_noSet(){
  try {
    attribute3.setDefault(div);
    throw new Error();
  }
 catch (  AssertionError e) {
  }
}",0.9309090909090908
53349,"private int throwError(){
  throw new Error();
}","private int throwError(){
  throw new IllegalArgumentException();
}",0.782608695652174
53350,"/** 
 * Test various useless operations like x+0 and x*1.
 */
public void testUselessOps(){
  assertEquals(5,fieldIntFive + returnIntZero());
  assertEquals(5L,fieldLongFive + returnIntZero());
  assertEquals(5.0,fieldFloatFive + returnIntZero());
  assertEquals(5.0,fieldDoubleFive + returnIntZero());
  assertEquals(5.0,fieldDoubleFive + returnCharZero());
  assertEquals(5,returnIntZero() + fieldIntFive);
  assertEquals(5L,returnIntZero() + fieldLongFive);
  assertEquals(5.0,returnIntZero() + fieldFloatFive);
  assertEquals(5.0,returnIntZero() + fieldDoubleFive);
  assertEquals(5.0,returnCharZero() + fieldDoubleFive);
  assertEquals(5,fieldIntFive - returnIntZero());
  assertEquals(5L,fieldLongFive - returnIntZero());
  assertEquals(5.0,fieldFloatFive - returnIntZero());
  assertEquals(5.0,fieldDoubleFive - returnIntZero());
  assertEquals(-5,returnIntZero() - fieldIntFive);
  assertEquals(-5L,returnIntZero() - fieldLongFive);
  assertEquals(-5.0,returnDoubleZero() - fieldLongFive);
  assertEquals(-5.0,returnIntZero() - fieldFloatFive);
  assertEquals(-5.0,returnIntZero() - fieldDoubleFive);
  assertEquals(5,fieldIntFive * returnIntOne());
  assertEquals(5L,fieldLongFive * returnLongOne());
  assertEquals(5.0,fieldFloatFive * returnFloatOne());
  assertEquals(5.0,fieldDoubleFive * returnDoubleOne());
  assertEquals(5,fieldIntFive / returnIntOne());
  assertEquals(5L,fieldLongFive / returnLongOne());
  assertEquals(5.0,fieldFloatFive / returnFloatOne());
  assertEquals(5.0,fieldDoubleFive / returnDoubleOne());
  assertEquals(-5,fieldIntFive * -returnIntOne());
  assertEquals(-5L,fieldLongFive * -returnLongOne());
  assertEquals(-5.0,fieldFloatFive * -returnFloatOne());
  assertEquals(-5.0,fieldDoubleFive * -returnDoubleOne());
  assertEquals(-327675,fieldIntFive * -returnCharNegOne());
  assertEquals(-5,fieldIntFive / -returnIntOne());
  assertEquals(-5L,fieldLongFive / -returnLongOne());
  assertEquals(-5.0,fieldFloatFive / -returnFloatOne());
  assertEquals(-5.0,fieldDoubleFive / -returnDoubleOne());
  assertEquals(5,-returnMinusFieldIntFive());
  assertEquals(5L,-returnMinusFieldLongFive());
  assertEquals(5.0,-returnMinusFieldFloatFive());
  assertEquals(5.0,-returnMinusFieldDoubleFive());
  assertEquals(5,fieldIntFive << returnIntZero());
  assertEquals(5L,fieldLongFive << returnIntZero());
  assertEquals(5,fieldIntFive >> returnIntZero());
  assertEquals(5L,fieldLongFive >> returnIntZero());
  assertEquals(5,fieldIntFive >>> returnIntZero());
  assertEquals(5L,fieldLongFive >>> returnIntZero());
  assertTrue(!returnNotFieldTrue());
  assertTrue(fieldTrue ^ returnFalse());
  assertFalse(fieldTrue ^ returnTrue());
  assertFalse(returnTrue() ^ fieldTrue);
  assertTrue(returnFalse() ^ fieldTrue);
  assertEquals(0.0,fieldIntFive * returnDoubleZero());
  try {
    assertEquals(0.0,throwError() * returnDoubleZero());
    fail(""String_Node_Str"");
  }
 catch (  Error e) {
  }
  assertEquals(0.0,returnDoubleZero() * fieldIntFive);
  try {
    assertEquals(0.0,returnDoubleZero() * throwError());
    fail(""String_Node_Str"");
  }
 catch (  Error e) {
  }
  assertTrue(fieldIntArray != null);
  assertFalse(fieldIntArray == null);
  if (fieldIntArray == null) {
    fail();
  }
  if (fieldIntArray != null) {
  }
 else {
    fail();
  }
  assertTrue(returnEmptyString() != null);
  assertFalse(returnEmptyString() == null);
  if (returnEmptyString() == null) {
    fail();
  }
  assertFalse(fieldObject == null);
  if (fieldObject == null) {
    fail();
  }
}","/** 
 * Test various useless operations like x+0 and x*1.
 */
public void testUselessOps(){
  assertEquals(5,fieldIntFive + returnIntZero());
  assertEquals(5L,fieldLongFive + returnIntZero());
  assertEquals(5.0,fieldFloatFive + returnIntZero());
  assertEquals(5.0,fieldDoubleFive + returnIntZero());
  assertEquals(5.0,fieldDoubleFive + returnCharZero());
  assertEquals(5,returnIntZero() + fieldIntFive);
  assertEquals(5L,returnIntZero() + fieldLongFive);
  assertEquals(5.0,returnIntZero() + fieldFloatFive);
  assertEquals(5.0,returnIntZero() + fieldDoubleFive);
  assertEquals(5.0,returnCharZero() + fieldDoubleFive);
  assertEquals(5,fieldIntFive - returnIntZero());
  assertEquals(5L,fieldLongFive - returnIntZero());
  assertEquals(5.0,fieldFloatFive - returnIntZero());
  assertEquals(5.0,fieldDoubleFive - returnIntZero());
  assertEquals(-5,returnIntZero() - fieldIntFive);
  assertEquals(-5L,returnIntZero() - fieldLongFive);
  assertEquals(-5.0,returnDoubleZero() - fieldLongFive);
  assertEquals(-5.0,returnIntZero() - fieldFloatFive);
  assertEquals(-5.0,returnIntZero() - fieldDoubleFive);
  assertEquals(5,fieldIntFive * returnIntOne());
  assertEquals(5L,fieldLongFive * returnLongOne());
  assertEquals(5.0,fieldFloatFive * returnFloatOne());
  assertEquals(5.0,fieldDoubleFive * returnDoubleOne());
  assertEquals(5,fieldIntFive / returnIntOne());
  assertEquals(5L,fieldLongFive / returnLongOne());
  assertEquals(5.0,fieldFloatFive / returnFloatOne());
  assertEquals(5.0,fieldDoubleFive / returnDoubleOne());
  assertEquals(-5,fieldIntFive * -returnIntOne());
  assertEquals(-5L,fieldLongFive * -returnLongOne());
  assertEquals(-5.0,fieldFloatFive * -returnFloatOne());
  assertEquals(-5.0,fieldDoubleFive * -returnDoubleOne());
  assertEquals(-327675,fieldIntFive * -returnCharNegOne());
  assertEquals(-5,fieldIntFive / -returnIntOne());
  assertEquals(-5L,fieldLongFive / -returnLongOne());
  assertEquals(-5.0,fieldFloatFive / -returnFloatOne());
  assertEquals(-5.0,fieldDoubleFive / -returnDoubleOne());
  assertEquals(5,-returnMinusFieldIntFive());
  assertEquals(5L,-returnMinusFieldLongFive());
  assertEquals(5.0,-returnMinusFieldFloatFive());
  assertEquals(5.0,-returnMinusFieldDoubleFive());
  assertEquals(5,fieldIntFive << returnIntZero());
  assertEquals(5L,fieldLongFive << returnIntZero());
  assertEquals(5,fieldIntFive >> returnIntZero());
  assertEquals(5L,fieldLongFive >> returnIntZero());
  assertEquals(5,fieldIntFive >>> returnIntZero());
  assertEquals(5L,fieldLongFive >>> returnIntZero());
  assertTrue(!returnNotFieldTrue());
  assertTrue(fieldTrue ^ returnFalse());
  assertFalse(fieldTrue ^ returnTrue());
  assertFalse(returnTrue() ^ fieldTrue);
  assertTrue(returnFalse() ^ fieldTrue);
  assertEquals(0.0,fieldIntFive * returnDoubleZero());
  try {
    assertEquals(0.0,throwError() * returnDoubleZero());
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  assertEquals(0.0,returnDoubleZero() * fieldIntFive);
  try {
    assertEquals(0.0,returnDoubleZero() * throwError());
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  assertTrue(fieldIntArray != null);
  assertFalse(fieldIntArray == null);
  if (fieldIntArray == null) {
    fail();
  }
  if (fieldIntArray != null) {
  }
 else {
    fail();
  }
  assertTrue(returnEmptyString() != null);
  assertFalse(returnEmptyString() == null);
  if (returnEmptyString() == null) {
    fail();
  }
  assertFalse(fieldObject == null);
  if (fieldObject == null) {
    fail();
  }
}",0.99177304964539
53351,"/** 
 * Tests HeadingElement.as() (it has slightly more complex assertion logic than most).
 */
public void testHeadingElementAs(){
  DivElement placeHolder=Document.get().createDivElement();
  for (int i=0; i < 6; ++i) {
    placeHolder.setInnerHTML(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
    assertNotNull(HeadingElement.as(placeHolder.getFirstChildElement()));
  }
  if (getClass().desiredAssertionStatus()) {
    Element notHeading=Document.get().createDivElement();
    try {
      HeadingElement.as(notHeading);
      fail(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
  }
}","/** 
 * Tests HeadingElement.as() (it has slightly more complex assertion logic than most).
 */
public void testHeadingElementAs(){
  DivElement placeHolder=Document.get().createDivElement();
  for (int i=0; i < 6; ++i) {
    placeHolder.setInnerHTML(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
    assertNotNull(HeadingElement.as(placeHolder.getFirstChildElement()));
  }
  if (getClass().desiredAssertionStatus()) {
    Element notHeading=Document.get().createDivElement();
    try {
      HeadingElement.as(notHeading);
      throw new Error(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
  }
}",0.9845402766476812
53352,"/** 
 * Test that styles only allow camelCase.
 */
public void testStyleCamelCase(){
  DivElement div=Document.get().createDivElement();
  div.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",div.getStyle().getProperty(""String_Node_Str""));
  div.getStyle().setPropertyPx(""String_Node_Str"",10);
  assertEquals(""String_Node_Str"",div.getStyle().getProperty(""String_Node_Str""));
  if (Style.class.desiredAssertionStatus()) {
    try {
      div.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
      fail(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
    try {
      div.getStyle().setPropertyPx(""String_Node_Str"",20);
      fail(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
    try {
      div.getStyle().getProperty(""String_Node_Str"");
      fail(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
  }
}","/** 
 * Test that styles only allow camelCase.
 */
public void testStyleCamelCase(){
  DivElement div=Document.get().createDivElement();
  div.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",div.getStyle().getProperty(""String_Node_Str""));
  div.getStyle().setPropertyPx(""String_Node_Str"",10);
  assertEquals(""String_Node_Str"",div.getStyle().getProperty(""String_Node_Str""));
  if (Style.class.desiredAssertionStatus()) {
    try {
      div.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
      throw new Error(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
    try {
      div.getStyle().setPropertyPx(""String_Node_Str"",20);
      throw new Error(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
    try {
      div.getStyle().getProperty(""String_Node_Str"");
      throw new Error(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
  }
}",0.969172525689562
53353,"public void testEmptyClassNameAssertion(){
  DivElement div=Document.get().createDivElement();
  if (getClass().desiredAssertionStatus()) {
    div.setClassName(""String_Node_Str"");
    try {
      div.addClassName(""String_Node_Str"");
      fail();
    }
 catch (    AssertionError e) {
    }
    try {
      div.addClassName(""String_Node_Str"");
      fail();
    }
 catch (    AssertionError e) {
    }
    try {
      div.addClassName(null);
      fail();
    }
 catch (    AssertionError e) {
    }
    try {
      div.removeClassName(""String_Node_Str"");
      fail();
    }
 catch (    AssertionError e) {
    }
    try {
      div.removeClassName(""String_Node_Str"");
      fail();
    }
 catch (    AssertionError e) {
    }
    try {
      div.removeClassName(null);
      fail();
    }
 catch (    AssertionError e) {
    }
    assertEquals(""String_Node_Str"",div.getClassName());
  }
}","public void testEmptyClassNameAssertion(){
  DivElement div=Document.get().createDivElement();
  if (getClass().desiredAssertionStatus()) {
    div.setClassName(""String_Node_Str"");
    try {
      div.addClassName(""String_Node_Str"");
      throw new Error();
    }
 catch (    AssertionError e) {
    }
    try {
      div.addClassName(""String_Node_Str"");
      throw new Error();
    }
 catch (    AssertionError e) {
    }
    try {
      div.addClassName(null);
      throw new Error();
    }
 catch (    AssertionError e) {
    }
    try {
      div.removeClassName(""String_Node_Str"");
      throw new Error();
    }
 catch (    AssertionError e) {
    }
    try {
      div.removeClassName(""String_Node_Str"");
      throw new Error();
    }
 catch (    AssertionError e) {
    }
    try {
      div.removeClassName(null);
      throw new Error();
    }
 catch (    AssertionError e) {
    }
    assertEquals(""String_Node_Str"",div.getClassName());
  }
}",0.9383116883116884
53354,"public void testConcurrentAddAfterRemoveIsNotClobbered(){
  final HandlerManager manager=new HandlerManager(""String_Node_Str"");
  MouseDownHandler one=new MouseDownHandler(){
    @Override public void onMouseDown(    MouseDownEvent event){
      manager.removeHandler(MouseDownEvent.getType(),mouse1);
      manager.addHandler(MouseDownEvent.getType(),mouse1);
      add(this);
    }
  }
;
  manager.addHandler(MouseDownEvent.getType(),one);
  boolean assertsOn=getClass().desiredAssertionStatus();
  if (assertsOn) {
    try {
      manager.fireEvent(new MouseDownEvent(){
      }
);
      fail(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
    return;
  }
  manager.fireEvent(new MouseDownEvent(){
  }
);
  assertFired(one);
  reset();
  manager.fireEvent(new MouseDownEvent(){
  }
);
  assertFired(one,mouse1);
}","public void testConcurrentAddAfterRemoveIsNotClobbered(){
  final HandlerManager manager=new HandlerManager(""String_Node_Str"");
  MouseDownHandler one=new MouseDownHandler(){
    @Override public void onMouseDown(    MouseDownEvent event){
      manager.removeHandler(MouseDownEvent.getType(),mouse1);
      manager.addHandler(MouseDownEvent.getType(),mouse1);
      add(this);
    }
  }
;
  manager.addHandler(MouseDownEvent.getType(),one);
  boolean assertsOn=getClass().desiredAssertionStatus();
  if (assertsOn) {
    try {
      manager.fireEvent(new MouseDownEvent(){
      }
);
    }
 catch (    AssertionError e) {
    }
    return;
  }
  manager.fireEvent(new MouseDownEvent(){
  }
);
  assertFired(one);
  reset();
  manager.fireEvent(new MouseDownEvent(){
  }
);
  assertFired(one,mouse1);
}",0.981039755351682
53355,"public void notestRemoveUnhandledType(){
  final HandlerManager manager=new HandlerManager(""String_Node_Str"");
  HandlerRegistration reg=manager.addHandler(MouseDownEvent.getType(),mouse1);
  reg.removeHandler();
  if (!GWT.isScript()) {
    try {
      reg.removeHandler();
      fail(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
  }
 else {
    reg.removeHandler();
  }
}","public void notestRemoveUnhandledType(){
  final HandlerManager manager=new HandlerManager(""String_Node_Str"");
  HandlerRegistration reg=manager.addHandler(MouseDownEvent.getType(),mouse1);
  reg.removeHandler();
  if (!GWT.isScript()) {
    try {
      reg.removeHandler();
      throw new Error(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
  }
 else {
    reg.removeHandler();
  }
}",0.9761006289308176
53356,"public void testAssertThrowsNpe(){
  final SimpleEventBus eventBus=new SimpleEventBus();
  try {
    assertThrowsNpe(new ScheduledCommand(){
      @Override public void execute(){
        eventBus.addHandler(MouseDownEvent.getType(),mouse1);
      }
    }
);
    fail(""String_Node_Str"");
  }
 catch (  AssertionFailedError e) {
  }
}","public void testAssertThrowsNpe(){
  final SimpleEventBus eventBus=new SimpleEventBus();
  try {
    assertThrowsNpe(new ScheduledCommand(){
      @Override public void execute(){
        eventBus.addHandler(MouseDownEvent.getType(),mouse1);
      }
    }
);
    throw new Error(""String_Node_Str"");
  }
 catch (  AssertionFailedError e) {
  }
}",0.9719350073855244
53357,"public void testSet(){
  if (storage == null) {
    return;
  }
  assertEquals(null,storage.getItem(""String_Node_Str""));
  assertEquals(0,storage.getLength());
  storage.setItem(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",storage.getItem(""String_Node_Str""));
  assertEquals(1,storage.getLength());
  storage.setItem(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",""String_Node_Str"",storage.getItem(""String_Node_Str""));
  assertEquals(1,storage.getLength());
  if (!GWT.isScript()) {
    try {
      storage.setItem(""String_Node_Str"",""String_Node_Str"");
      fail(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
  }
}","public void testSet(){
  if (storage == null) {
    return;
  }
  assertEquals(null,storage.getItem(""String_Node_Str""));
  assertEquals(0,storage.getLength());
  storage.setItem(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",storage.getItem(""String_Node_Str""));
  assertEquals(1,storage.getLength());
  storage.setItem(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",""String_Node_Str"",storage.getItem(""String_Node_Str""));
  assertEquals(1,storage.getLength());
  if (!GWT.isScript()) {
    try {
      storage.setItem(""String_Node_Str"",""String_Node_Str"");
      throw new Error(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
  }
}",0.9862018881626724
53358,"/** 
 * Tests that   {@link RootPanel#detachNow(Widget)} can only be called once perwidget.
 */
public void testDetachNowTwiceFails(){
  if (!GWT.isScript()) {
    try {
      ensureDiv().setInnerHTML(""String_Node_Str"" + TEST_URL + ""String_Node_Str"");
      Anchor a=Anchor.wrap(Document.get().getElementById(""String_Node_Str""));
      RootPanel.detachNow(a);
      RootPanel.detachNow(a);
      fail(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
  }
}","/** 
 * Tests that   {@link RootPanel#detachNow(Widget)} can only be called once perwidget.
 */
public void testDetachNowTwiceFails(){
  if (!GWT.isScript()) {
    try {
      ensureDiv().setInnerHTML(""String_Node_Str"" + TEST_URL + ""String_Node_Str"");
      Anchor a=Anchor.wrap(Document.get().getElementById(""String_Node_Str""));
      RootPanel.detachNow(a);
      RootPanel.detachNow(a);
      throw new Error(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
  }
}",0.9800210304942166
53359,"/** 
 * Tests that   {@link RootPanel#detachOnWindowClose(Widget)} can only be calledonce per widget.
 */
public void testDetachOnWindowCloseTwiceFails(){
  if (!GWT.isScript()) {
    try {
      ensureDiv().setInnerHTML(""String_Node_Str"" + TEST_URL + ""String_Node_Str"");
      Anchor a=Anchor.wrap(Document.get().getElementById(""String_Node_Str""));
      RootPanel.detachOnWindowClose(a);
      fail(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
  }
}","/** 
 * Tests that   {@link RootPanel#detachOnWindowClose(Widget)} can only be calledonce per widget.
 */
public void testDetachOnWindowCloseTwiceFails(){
  if (!GWT.isScript()) {
    try {
      ensureDiv().setInnerHTML(""String_Node_Str"" + TEST_URL + ""String_Node_Str"");
      Anchor a=Anchor.wrap(Document.get().getElementById(""String_Node_Str""));
      RootPanel.detachOnWindowClose(a);
      throw new Error(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
  }
}",0.9800210304942166
53360,"/** 
 * Tests that wrap() may only be called on elements that are already attached to the DOM.
 */
public void testWrapUnattachedFails(){
  if (!GWT.isScript()) {
    try {
      AnchorElement aElem=Document.get().createAnchorElement();
      Anchor.wrap(aElem);
      fail(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
  }
}","/** 
 * Tests that wrap() may only be called on elements that are already attached to the DOM.
 */
public void testWrapUnattachedFails(){
  if (!GWT.isScript()) {
    try {
      AnchorElement aElem=Document.get().createAnchorElement();
      Anchor.wrap(aElem);
      throw new Error(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
  }
}",0.9727403156384504
53361,"/** 
 * Tests that wrapping an element that is already a child of an existing widget's element fails.
 */
public void testWrappingChildElementFails(){
  if (!GWT.isScript()) {
    try {
      FlowPanel p=new FlowPanel();
      RootPanel.get().add(p);
      p.add(new HTML(""String_Node_Str""));
      Element unwrappableElement=Document.get().getElementById(""String_Node_Str"");
      Anchor.wrap(unwrappableElement);
      fail(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
  }
}","/** 
 * Tests that wrapping an element that is already a child of an existing widget's element fails.
 */
public void testWrappingChildElementFails(){
  if (!GWT.isScript()) {
    try {
      FlowPanel p=new FlowPanel();
      RootPanel.get().add(p);
      p.add(new HTML(""String_Node_Str""));
      Element unwrappableElement=Document.get().getElementById(""String_Node_Str"");
      Anchor.wrap(unwrappableElement);
      throw new Error(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
  }
}",0.981018981018981
53362,"public void testInlineLabel(){
  new TestInlineLabel();
  if (!GWT.isScript()) {
    try {
      new BrokenInlineLabel();
      fail(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}","public void testInlineLabel(){
  new TestInlineLabel();
  if (!GWT.isScript()) {
    try {
      new BrokenInlineLabel();
      throw new Error(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}",0.9537712895377128
53363,"public void testImage(){
  new TestImage();
  if (!GWT.isScript()) {
    try {
      new BrokenImage();
      fail(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}","public void testImage(){
  new TestImage();
  if (!GWT.isScript()) {
    try {
      new BrokenImage();
      throw new Error(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}",0.9493333333333334
53364,"public void testAnchor(){
  new TestAnchor();
  if (!GWT.isScript()) {
    try {
      new BrokenAnchor();
      fail(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}","public void testAnchor(){
  new TestAnchor();
  if (!GWT.isScript()) {
    try {
      new BrokenAnchor();
      throw new Error(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}",0.9501312335958004
53365,"public void testLabel(){
  new TestLabel();
  if (!GWT.isScript()) {
    try {
      new BrokenLabel();
      fail(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}","public void testLabel(){
  new TestLabel();
  if (!GWT.isScript()) {
    try {
      new BrokenLabel();
      throw new Error(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}",0.9493333333333334
53366,"public void testHTML(){
  new TestHTML();
  if (!GWT.isScript()) {
    try {
      new BrokenHTML();
      fail(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}","public void testHTML(){
  new TestHTML();
  if (!GWT.isScript()) {
    try {
      new BrokenHTML();
      throw new Error(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}",0.948509485094851
53367,"public void testListBox(){
  new TestListBox();
  if (!GWT.isScript()) {
    try {
      new BrokenListBox();
      fail(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}","public void testListBox(){
  new TestListBox();
  if (!GWT.isScript()) {
    try {
      new BrokenListBox();
      throw new Error(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}",0.9509043927648578
53368,"public void testFrame(){
  new TestFrame();
  if (!GWT.isScript()) {
    try {
      new BrokenFrame();
      fail(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}","public void testFrame(){
  new TestFrame();
  if (!GWT.isScript()) {
    try {
      new BrokenFrame();
      throw new Error(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}",0.9493333333333334
53369,"public void testInlineHTML(){
  new TestInlineHTML();
  if (!GWT.isScript()) {
    try {
      new BrokenInlineHTML();
      fail(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}","public void testInlineHTML(){
  new TestInlineHTML();
  if (!GWT.isScript()) {
    try {
      new BrokenInlineHTML();
      throw new Error(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}",0.9530864197530864
53370,"public void testFormPanel(){
  new TestFormPanel();
  if (!GWT.isScript()) {
    try {
      new BrokenFormPanel();
      fail(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}","public void testFormPanel(){
  new TestFormPanel();
  if (!GWT.isScript()) {
    try {
      new BrokenFormPanel();
      throw new Error(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}",0.9523809523809524
53371,"public void testSimpleRadioButton(){
  new TestSimpleRadioButton();
  if (!GWT.isScript()) {
    try {
      new BrokenSimpleRadioButton();
      fail(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}","public void testSimpleRadioButton(){
  new TestSimpleRadioButton();
  if (!GWT.isScript()) {
    try {
      new BrokenSimpleRadioButton();
      throw new Error(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}",0.9574944071588368
53372,"public void testHidden(){
  new TestHidden();
  if (!GWT.isScript()) {
    try {
      new BrokenHidden();
      fail(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}","public void testHidden(){
  new TestHidden();
  if (!GWT.isScript()) {
    try {
      new BrokenHidden();
      throw new Error(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}",0.9501312335958004
53373,"public void testFileUpload(){
  new TestFileUpload();
  if (!GWT.isScript()) {
    try {
      new BrokenFileUpload();
      fail(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}","public void testFileUpload(){
  new TestFileUpload();
  if (!GWT.isScript()) {
    try {
      new BrokenFileUpload();
      throw new Error(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}",0.9530864197530864
53374,"public void testPasswordTextBox(){
  new TestPasswordTextBox();
  if (!GWT.isScript()) {
    try {
      new BrokenPasswordTextBox();
      fail(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}","public void testPasswordTextBox(){
  new TestPasswordTextBox();
  if (!GWT.isScript()) {
    try {
      new BrokenPasswordTextBox();
      throw new Error(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}",0.9563218390804598
53375,"public void testButton(){
  new TestButton();
  if (!GWT.isScript()) {
    try {
      new BrokenButton();
      fail(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}","public void testButton(){
  new TestButton();
  if (!GWT.isScript()) {
    try {
      new BrokenButton();
      throw new Error(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}",0.9501312335958004
53376,"public void testTextBox(){
  new TestTextBox();
  if (!GWT.isScript()) {
    try {
      new BrokenTextBox();
      fail(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}","public void testTextBox(){
  new TestTextBox();
  if (!GWT.isScript()) {
    try {
      new BrokenTextBox();
      throw new Error(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}",0.9509043927648578
53377,"public void testSimpleCheckBox(){
  new TestSimpleCheckBox();
  if (!GWT.isScript()) {
    try {
      new BrokenSimpleCheckBox();
      fail(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}","public void testSimpleCheckBox(){
  new TestSimpleCheckBox();
  if (!GWT.isScript()) {
    try {
      new BrokenSimpleCheckBox();
      throw new Error(ASSERTION_ERROR);
    }
 catch (    AssertionError e) {
    }
  }
}",0.9557109557109555
53378,"public void testAssertThrowsNpe(){
  final SimpleEventBus eventBus=new SimpleEventBus();
  try {
    assertThrowsNpe(new Command(){
      @Override public void execute(){
        FooEvent.register(eventBus,fooHandler1);
      }
    }
);
    fail(""String_Node_Str"");
  }
 catch (  AssertionFailedError e) {
  }
}","public void testAssertThrowsNpe(){
  final SimpleEventBus eventBus=new SimpleEventBus();
  try {
    assertThrowsNpe(new Command(){
      @Override public void execute(){
        FooEvent.register(eventBus,fooHandler1);
      }
    }
);
    throw new Error(""String_Node_Str"");
  }
 catch (  AssertionFailedError e) {
  }
}",0.9699842022116903
53379,"public static long highestOneBit(long i){
  int high=(int)(i >> 32);
  if (high != 0) {
    return ((long)Integer.highestOneBit(high)) << 32;
  }
 else {
    return Integer.highestOneBit((int)i);
  }
}","public static long highestOneBit(long i){
  int high=(int)(i >> 32);
  if (high != 0) {
    return ((long)Integer.highestOneBit(high)) << 32;
  }
 else {
    return Integer.highestOneBit((int)i) & 0xFFFFFFFFL;
  }
}",0.966346153846154
53380,"public void testHighestOneBit(){
  assertEquals(0,Long.highestOneBit(0));
  assertEquals(Long.MIN_VALUE,Long.highestOneBit(-1));
  assertEquals(Long.MIN_VALUE,Long.highestOneBit(-256));
  assertEquals(1,Long.highestOneBit(1));
  assertEquals(0x80,Long.highestOneBit(0x88));
  assertEquals(0x4000000000000000L,Long.highestOneBit(Long.MAX_VALUE));
}","public void testHighestOneBit(){
  assertEquals(0,Long.highestOneBit(0));
  assertEquals(Long.MIN_VALUE,Long.highestOneBit(-1));
  assertEquals(Long.MIN_VALUE,Long.highestOneBit(-256));
  assertEquals(1,Long.highestOneBit(1));
  assertEquals(0x80,Long.highestOneBit(0x88));
  assertEquals(1L << 31,Long.highestOneBit(1L << 31));
  assertEquals(0x4000000000000000L,Long.highestOneBit(Long.MAX_VALUE));
}",0.9265687583444592
53381,"@Override public boolean canBeImplementedExternally(){
  return getLeafType().canBeImplementedExternally();
}","@Override public boolean canBeImplementedExternally(){
  return getLeafType().canBeImplementedExternally() || isJavaScriptObject(getElementType());
}",0.8449612403100775
53382,"public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AnnotationsTest.class);
  suite.addTestSuite(ArrayTest.class);
  suite.addTestSuite(AutoboxTest.class);
  suite.addTestSuite(BasicJsInteropTest.class);
  suite.addTestSuite(BlankInterfaceTest.class);
  suite.addTestSuite(ClassCastTest.class);
  suite.addTestSuite(ClassLiteralsTest.class);
  suite.addTestSuite(CompilerTest.class);
  suite.addTestSuite(CompilerMiscRegressionTest.class);
  suite.addTestSuite(CoverageTest.class);
  suite.addTestSuite(EnhancedForLoopTest.class);
  suite.addTestSuite(EnumsTest.class);
  suite.addTestSuite(EnumsWithNameObfuscationTest.class);
  suite.addTestSuite(FieldInitializationOrderTest.class);
  suite.addTestSuite(GenericCastTest.class);
  suite.addTestSuite(GwtIncompatibleTest.class);
  suite.addTestSuite(HostedTest.class);
  suite.addTestSuite(InitialLoadSequenceTest.class);
  suite.addTestSuite(InnerClassTest.class);
  suite.addTestSuite(InnerOuterSuperTest.class);
  suite.addTestSuite(Java7Test.class);
  suite.addTestSuite(Java8Test.class);
  suite.addTestSuite(JavaAccessFromJavaScriptTest.class);
  suite.addTestSuite(JsniConstructorTest.class);
  suite.addTestSuite(JsniDispatchTest.class);
  suite.addTestSuite(JsoTest.class);
  suite.addTestSuite(JsStaticEvalTest.class);
  suite.addTestSuite(JStaticEvalTest.class);
  suite.addTestSuite(MemberShadowingTest.class);
  suite.addTestSuite(MethodBindTest.class);
  suite.addTestSuite(MethodCallTest.class);
  suite.addTestSuite(MethodInterfaceTest.class);
  suite.addTestSuite(MiscellaneousTest.class);
  suite.addTestSuite(NativeDevirtualizationTest.class);
  suite.addTestSuite(NativeLongTest.class);
  suite.addTestSuite(ObjectIdentityTest.class);
  suite.addTestSuite(ScriptOnlyTest.class);
  suite.addTestSuite(SingleJsoImplTest.class);
  suite.addTestSuite(StackTraceLineNumbersTest.class);
  suite.addTestSuite(TypeHierarchyTest.class);
  suite.addTestSuite(UnusedImportsTest.class);
  suite.addTestSuite(UnstableGeneratorTest.class);
  suite.addTestSuite(VarargsTest.class);
  return suite;
}","public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AnnotationsTest.class);
  suite.addTestSuite(ArrayTest.class);
  suite.addTestSuite(AutoboxTest.class);
  suite.addTestSuite(ClassCastTest.class);
  suite.addTestSuite(ClassLiteralsTest.class);
  suite.addTestSuite(EnhancedForLoopTest.class);
  suite.addTestSuite(EnumsTest.class);
  suite.addTestSuite(FieldInitializationOrderTest.class);
  suite.addTestSuite(GenericCastTest.class);
  suite.addTestSuite(InitialLoadSequenceTest.class);
  suite.addTestSuite(InnerClassTest.class);
  suite.addTestSuite(InnerOuterSuperTest.class);
  suite.addTestSuite(Java7Test.class);
  suite.addTestSuite(Java8Test.class);
  suite.addTestSuite(JavaAccessFromJavaScriptTest.class);
  suite.addTestSuite(JsniConstructorTest.class);
  suite.addTestSuite(JsniDispatchTest.class);
  suite.addTestSuite(JsoTest.class);
  suite.addTestSuite(MethodBindTest.class);
  suite.addTestSuite(MethodCallTest.class);
  suite.addTestSuite(MethodInterfaceTest.class);
  suite.addTestSuite(NativeLongTest.class);
  suite.addTestSuite(ObjectIdentityTest.class);
  suite.addTestSuite(SingleJsoImplTest.class);
  suite.addTestSuite(TypeHierarchyTest.class);
  suite.addTestSuite(VarargsTest.class);
  return suite;
}",0.6075949367088608
53383,"/** 
 * Returns an instantiation expression for   {@code type} using the default constructor,Returns  {@code null} if {@code type} does not have a default constructor.
 */
public static JExpression createDefaultConstructorInstantiation(SourceInfo info,JClassType type){
  JConstructor noArgCtor=(JConstructor)FluentIterable.from(type.getMethods()).firstMatch(new Predicate<JMethod>(){
    @Override public boolean apply(    JMethod method){
      return method instanceof JConstructor && method.getOriginalParamTypes().size() == 0;
    }
  }
).get();
  if (noArgCtor == null) {
    return null;
  }
  return new JNewInstance(info,noArgCtor);
}","/** 
 * Returns an instantiation expression for   {@code type} using the default constructor,Returns  {@code null} if {@code type} does not have a default constructor.
 */
public static JExpression createDefaultConstructorInstantiation(SourceInfo info,JClassType type){
  JConstructor noArgCtor=(JConstructor)FluentIterable.from(type.getMethods()).firstMatch(new Predicate<JMethod>(){
    @Override public boolean apply(    JMethod method){
      return method instanceof JConstructor && method.getOriginalParamTypes().size() == 0;
    }
  }
).orNull();
  if (noArgCtor == null) {
    return null;
  }
  return new JNewInstance(info,noArgCtor);
}",0.9930178432893716
53384,"private String compileToJs(CompilerOptions compilerOptions,File applicationDir,String moduleName,List<MockResource> applicationResources,MinimalRebuildCache minimalRebuildCache,Set<String> expectedProcessedStaleTypeNames,JsOutputOption output) throws IOException, UnableToCompleteException, InterruptedException {
  System.setProperty(UnitCacheSingleton.GWT_PERSISTENTUNITCACHE,""String_Node_Str"");
  Thread.sleep(1001);
  PrintWriterTreeLogger logger=new PrintWriterTreeLogger();
  logger.setMaxDetail(TreeLogger.ERROR);
  File outputDir=new File(applicationDir.getPath() + File.separator + moduleName);
  if (outputDir.exists()) {
    Util.recursiveDelete(outputDir,true);
  }
  ResourceLoader resourceLoader=ResourceLoaders.forClassLoader(Thread.currentThread());
  resourceLoader=ResourceLoaders.forPathAndFallback(ImmutableList.of(applicationDir),resourceLoader);
  compilerOptions.setIncrementalCompileEnabled(true);
  compilerOptions.setJsInteropMode(OptionJsInteropMode.Mode.JS_RC);
  compilerOptions.setWarDir(applicationDir);
  compilerOptions.setModuleNames(ImmutableList.of(moduleName));
  compilerOptions.setOutput(output);
  for (  MockResource applicationResource : applicationResources) {
    writeResourceTo(applicationResource,applicationDir);
  }
  ModuleDefLoader.clearModuleCache();
  ModuleDefLoader.loadFromResources(logger,moduleName,resourceLoader,true);
  Compiler compiler=new Compiler(compilerOptions,minimalRebuildCache);
  compiler.run(logger);
  File outputJsFile=null;
  outputDir=new File(applicationDir.getPath() + File.separator + moduleName);
  if (outputDir.exists()) {
    for (    File outputFile : outputDir.listFiles()) {
      if (outputFile.getPath().endsWith(""String_Node_Str"")) {
        outputJsFile=outputFile;
        break;
      }
    }
  }
  if (outputJsFile == null) {
    throw new UnableToCompleteException();
  }
  if (expectedProcessedStaleTypeNames != null) {
    Set<String> staleTypeNames=new HashSet<>(minimalRebuildCache.getProcessedStaleTypeNames());
    staleTypeNames.remove(""String_Node_Str"");
    staleTypeNames.remove(""String_Node_Str"");
    staleTypeNames.remove(""String_Node_Str"");
    staleTypeNames.remove(""String_Node_Str"");
    assertEquals(expectedProcessedStaleTypeNames,staleTypeNames);
  }
  return Files.toString(outputJsFile,Charsets.UTF_8);
}","private String compileToJs(TreeLogger logger,CompilerOptions compilerOptions,File applicationDir,String moduleName,List<MockResource> applicationResources,MinimalRebuildCache minimalRebuildCache,Set<String> expectedProcessedStaleTypeNames,JsOutputOption output) throws IOException, UnableToCompleteException, InterruptedException {
  System.setProperty(UnitCacheSingleton.GWT_PERSISTENTUNITCACHE,""String_Node_Str"");
  Thread.sleep(1001);
  File outputDir=new File(applicationDir.getPath() + File.separator + moduleName);
  if (outputDir.exists()) {
    Util.recursiveDelete(outputDir,true);
  }
  ResourceLoader resourceLoader=ResourceLoaders.forClassLoader(Thread.currentThread());
  resourceLoader=ResourceLoaders.forPathAndFallback(ImmutableList.of(applicationDir),resourceLoader);
  compilerOptions.setIncrementalCompileEnabled(true);
  compilerOptions.setJsInteropMode(OptionJsInteropMode.Mode.JS_RC);
  compilerOptions.setWarDir(applicationDir);
  compilerOptions.setModuleNames(ImmutableList.of(moduleName));
  compilerOptions.setOutput(output);
  for (  MockResource applicationResource : applicationResources) {
    writeResourceTo(applicationResource,applicationDir);
  }
  ModuleDefLoader.clearModuleCache();
  ModuleDefLoader.loadFromResources(logger,moduleName,resourceLoader,true);
  Compiler compiler=new Compiler(compilerOptions,minimalRebuildCache);
  compiler.run(logger);
  File outputJsFile=null;
  outputDir=new File(applicationDir.getPath() + File.separator + moduleName);
  if (outputDir.exists()) {
    for (    File outputFile : outputDir.listFiles()) {
      if (outputFile.getPath().endsWith(""String_Node_Str"")) {
        outputJsFile=outputFile;
        break;
      }
    }
  }
  if (outputJsFile == null) {
    throw new UnableToCompleteException();
  }
  if (expectedProcessedStaleTypeNames != null) {
    Set<String> staleTypeNames=new HashSet<>(minimalRebuildCache.getProcessedStaleTypeNames());
    staleTypeNames.remove(""String_Node_Str"");
    staleTypeNames.remove(""String_Node_Str"");
    staleTypeNames.remove(""String_Node_Str"");
    staleTypeNames.remove(""String_Node_Str"");
    assertEquals(expectedProcessedStaleTypeNames,staleTypeNames);
  }
  return Files.toString(outputJsFile,Charsets.UTF_8);
}",0.9738977846018864
53385,"@Override public int compareTo(LogEntry that){
  return ComparisonChain.start().compare(this.msg,that.msg,AbstractTreeLogger.LOG_LINE_COMPARATOR).compare(this.type,that.type).result();
}","@Override public int compareTo(LogEntry that){
  return ComparisonChain.start().compare(this.getMessageOrPattern(),that.getMessageOrPattern(),AbstractTreeLogger.LOG_LINE_COMPARATOR).compare(this.type,that.type).result();
}",0.8823529411764706
53386,"/** 
 * True if the type can be casted across different Java types that are unrelated.
 */
private boolean canCrossCastLikeJso(JType type){
  if (legacyJsInterop) {
    return canBeJavaScriptObject(type) || isNativeJsType(type) || isNonNativeJsTypeInterface(type);
  }
  return canBeJavaScriptObject(type) || type.isJsNative();
}","/** 
 * True if the type can be casted across different Java types that are unrelated.
 */
private boolean canCrossCastLikeJso(JType type){
  if (legacyJsInterop) {
    return canBeJavaScriptObject(type) || isNativeJsTypeClass(type) || isNonNativeJsTypeInterface(type);
  }
  return canBeJavaScriptObject(type);
}",0.9595015576323987
53387,"public boolean castFailsTrivially(JReferenceType fromType,JReferenceType toType){
  if (!fromType.canBeNull() && toType.isNullType()) {
    return true;
  }
  if (!fromType.canBeSubclass() && fromType.getUnderlyingType() instanceof JClassType && fromType.getUnderlyingType() != toType.getUnderlyingType() && !isSuperClass(fromType,toType) && !implementsInterface(fromType,toType)) {
    return true;
  }
  fromType=fromType.getUnderlyingType();
  toType=toType.getUnderlyingType();
  if (fromType == toType || isJavaLangObject(fromType)) {
    return false;
  }
  if (canCrossCastLikeJso(fromType) && canCrossCastLikeJso(toType)) {
    return false;
  }
  if (castSucceedsTrivially(fromType,toType)) {
    return false;
  }
  if (fromType instanceof JArrayType) {
    JArrayType fromArrayType=(JArrayType)fromType;
    if (toType instanceof JArrayType) {
      JArrayType toArrayType=(JArrayType)toType;
      JType fromLeafType=fromArrayType.getLeafType();
      JType toLeafType=toArrayType.getLeafType();
      int fromDims=fromArrayType.getDims();
      int toDims=toArrayType.getDims();
      if (fromDims < toDims && !isJavaLangObject(fromLeafType) && !fromLeafType.isNullType()) {
        return true;
      }
      if (fromDims == toDims && fromLeafType instanceof JReferenceType && toLeafType instanceof JReferenceType) {
        return castFailsTrivially((JReferenceType)fromLeafType,(JReferenceType)toLeafType);
      }
    }
  }
 else   if (fromType instanceof JClassType) {
    JClassType cType=(JClassType)fromType;
    if (toType instanceof JClassType) {
      return !isSubClass(cType,(JClassType)toType);
    }
 else     if (toType instanceof JInterfaceType) {
      return !potentialInterfaceByClass.containsEntry(cType.getName(),toType.getName());
    }
  }
 else   if (fromType instanceof JInterfaceType) {
    JInterfaceType fromInterfaceType=(JInterfaceType)fromType;
    if (toType instanceof JClassType) {
      return !potentialInterfaceByClass.containsEntry(toType.getName(),fromInterfaceType.getName());
    }
  }
  return false;
}","public boolean castFailsTrivially(JReferenceType fromType,JReferenceType toType){
  if (!fromType.canBeNull() && toType.isNullType()) {
    return true;
  }
  if (isJsInteropCrossCastTarget(toType.getUnderlyingType())) {
    return false;
  }
  if (!fromType.canBeSubclass() && fromType.getUnderlyingType() instanceof JClassType && fromType.getUnderlyingType() != toType.getUnderlyingType() && !isSuperClass(fromType,toType) && !implementsInterface(fromType,toType)) {
    return true;
  }
  fromType=fromType.getUnderlyingType();
  toType=toType.getUnderlyingType();
  if (fromType == toType || isJavaLangObject(fromType)) {
    return false;
  }
  if (canCrossCastLikeJso(fromType) && canCrossCastLikeJso(toType)) {
    return false;
  }
  if (castSucceedsTrivially(fromType,toType)) {
    return false;
  }
  if (fromType instanceof JArrayType) {
    JArrayType fromArrayType=(JArrayType)fromType;
    if (toType instanceof JArrayType) {
      JArrayType toArrayType=(JArrayType)toType;
      JType fromLeafType=fromArrayType.getLeafType();
      JType toLeafType=toArrayType.getLeafType();
      int fromDims=fromArrayType.getDims();
      int toDims=toArrayType.getDims();
      if (fromDims < toDims && !isJavaLangObject(fromLeafType) && !fromLeafType.isNullType()) {
        return true;
      }
      if (fromDims == toDims && fromLeafType instanceof JReferenceType && toLeafType instanceof JReferenceType) {
        return castFailsTrivially((JReferenceType)fromLeafType,(JReferenceType)toLeafType);
      }
    }
  }
 else   if (fromType instanceof JClassType) {
    JClassType cType=(JClassType)fromType;
    if (toType instanceof JClassType) {
      return !isSubClass(cType,(JClassType)toType);
    }
 else     if (toType instanceof JInterfaceType) {
      return !potentialInterfaceByClass.containsEntry(cType.getName(),toType.getName());
    }
  }
 else   if (fromType instanceof JInterfaceType) {
    JInterfaceType fromInterfaceType=(JInterfaceType)fromType;
    if (toType instanceof JClassType) {
      return !potentialInterfaceByClass.containsEntry(toType.getName(),fromInterfaceType.getName());
    }
  }
  return false;
}",0.9795335554497858
53388,"public void testCast_crossCastJavaInstance(){
  Object o=alwaysTrue() ? new MyJsFunctionInterfaceImpl() : new Object();
  assertEquals(11,((MyOtherJsFunctionInterface)o).bar(10));
  assertSame((MyJsFunctionInterface)o,(MyOtherJsFunctionInterface)o);
}","public void testCast_crossCastJavaInstance(){
  Object o=new MyJsFunctionInterfaceImpl();
  assertEquals(11,((MyOtherJsFunctionInterface)o).bar(10));
  assertSame((MyJsFunctionInterface)o,(MyOtherJsFunctionInterface)o);
}",0.9364406779661016
53389,"public void testInstanceOf_javaInstance(){
  Object object=alwaysTrue() ? new MyJsFunctionInterfaceImpl() : new Object();
  assertTrue(object instanceof MyJsFunctionInterface);
  assertTrue(object instanceof MyJsFunctionInterfaceImpl);
  assertTrue(object instanceof MyJsFunctionIdentityInterface);
  assertTrue(object instanceof MyJsFunctionWithOnlyInstanceofReference);
  assertTrue(object instanceof ElementLikeNativeInterface);
  assertFalse(object instanceof HTMLElementConcreteNativeJsType);
}","public void testInstanceOf_javaInstance(){
  Object object=new MyJsFunctionInterfaceImpl();
  assertTrue(object instanceof MyJsFunctionInterface);
  assertTrue(object instanceof MyJsFunctionInterfaceImpl);
  assertTrue(object instanceof MyJsFunctionIdentityInterface);
  assertTrue(object instanceof MyJsFunctionWithOnlyInstanceofReference);
  assertTrue(object instanceof ElementLikeNativeInterface);
  assertFalse(object instanceof HTMLElementConcreteNativeJsType);
}",0.96900826446281
53390,"public void testCast_inJava(){
  Object object=alwaysTrue() ? new MyJsFunctionInterfaceImpl() : new Object();
  MyJsFunctionInterface c1=(MyJsFunctionInterface)object;
  assertNotNull(c1);
  MyJsFunctionInterfaceImpl c2=(MyJsFunctionInterfaceImpl)c1;
  assertEquals(10,c2.publicField);
  MyJsFunctionInterfaceImpl c3=(MyJsFunctionInterfaceImpl)object;
  assertNotNull(c3);
  MyJsFunctionIdentityInterface c4=(MyJsFunctionIdentityInterface)object;
  assertNotNull(c4);
  ElementLikeNativeInterface c5=(ElementLikeNativeInterface)object;
  assertNotNull(c5);
  try {
    HTMLElementConcreteNativeJsType c6=(HTMLElementConcreteNativeJsType)object;
    assertNotNull(c6);
    fail(""String_Node_Str"");
  }
 catch (  ClassCastException cce) {
  }
}","public void testCast_inJava(){
  Object object=new MyJsFunctionInterfaceImpl();
  MyJsFunctionInterface c1=(MyJsFunctionInterface)object;
  assertNotNull(c1);
  MyJsFunctionInterfaceImpl c2=(MyJsFunctionInterfaceImpl)c1;
  assertEquals(10,c2.publicField);
  MyJsFunctionInterfaceImpl c3=(MyJsFunctionInterfaceImpl)object;
  assertNotNull(c3);
  MyJsFunctionIdentityInterface c4=(MyJsFunctionIdentityInterface)object;
  assertNotNull(c4);
  ElementLikeNativeInterface c5=(ElementLikeNativeInterface)object;
  assertNotNull(c5);
  try {
    HTMLElementConcreteNativeJsType c6=(HTMLElementConcreteNativeJsType)object;
    assertNotNull(c6);
    fail(""String_Node_Str"");
  }
 catch (  ClassCastException cce) {
  }
}",0.9408528198074276
53391,"public void testInstanceOf_implementsJsTypeWithPrototype(){
  Object object=alwaysTrue() ? new MyNativeJsTypeInterfaceImpl() : new Object();
  assertTrue(object instanceof Object);
  assertFalse(object instanceof HTMLElementAnotherConcreteNativeJsType);
  assertFalse(object instanceof HTMLButtonElement);
  assertFalse(object instanceof HTMLElementConcreteNativeJsType);
  assertFalse(object instanceof Iterator);
  assertTrue(object instanceof MyNativeJsTypeInterface);
  assertTrue(object instanceof MyNativeJsTypeInterfaceImpl);
  assertTrue(object instanceof ElementLikeNativeInterface);
  assertFalse(object instanceof ElementLikeNativeInterfaceImpl);
  assertFalse(object instanceof MyJsInterfaceWithOnlyInstanceofReference);
  assertTrue(object instanceof MyNativeJsTypeInterfaceAndOnlyInstanceofReference);
  assertFalse(object instanceof AliasToMyNativeJsTypeWithOnlyInstanceofReference);
  assertFalse(object instanceof ConcreteJsType);
}","public void testInstanceOf_implementsJsTypeWithPrototype(){
  Object object=new MyNativeJsTypeInterfaceImpl();
  assertTrue(object instanceof Object);
  assertFalse(object instanceof HTMLElementAnotherConcreteNativeJsType);
  assertFalse(object instanceof HTMLButtonElement);
  assertFalse(object instanceof HTMLElementConcreteNativeJsType);
  assertFalse(object instanceof Iterator);
  assertTrue(object instanceof MyNativeJsTypeInterface);
  assertTrue(object instanceof MyNativeJsTypeInterfaceImpl);
  assertTrue(object instanceof ElementLikeNativeInterface);
  assertFalse(object instanceof ElementLikeNativeInterfaceImpl);
  assertFalse(object instanceof MyJsInterfaceWithOnlyInstanceofReference);
  assertTrue(object instanceof MyNativeJsTypeInterfaceAndOnlyInstanceofReference);
  assertFalse(object instanceof AliasToMyNativeJsTypeWithOnlyInstanceofReference);
  assertFalse(object instanceof ConcreteJsType);
}",0.981798715203426
53392,"public void testInstanceOf_concreteJsType(){
  Object object=alwaysTrue() ? new ConcreteJsType() : new Object();
  assertTrue(object instanceof Object);
  assertFalse(object instanceof HTMLElementAnotherConcreteNativeJsType);
  assertFalse(object instanceof HTMLButtonElement);
  assertFalse(object instanceof HTMLElementConcreteNativeJsType);
  assertFalse(object instanceof Iterator);
  assertTrue(object instanceof MyNativeJsTypeInterface);
  assertFalse(object instanceof MyNativeJsTypeInterfaceImpl);
  assertTrue(object instanceof ElementLikeNativeInterface);
  assertFalse(object instanceof ElementLikeNativeInterfaceImpl);
  assertFalse(object instanceof MyJsInterfaceWithOnlyInstanceofReference);
  assertTrue(object instanceof MyNativeJsTypeInterfaceAndOnlyInstanceofReference);
  assertFalse(object instanceof AliasToMyNativeJsTypeWithOnlyInstanceofReference);
  assertTrue(object instanceof ConcreteJsType);
}","public void testInstanceOf_concreteJsType(){
  Object object=new ConcreteJsType();
  assertTrue(object instanceof Object);
  assertFalse(object instanceof HTMLElementAnotherConcreteNativeJsType);
  assertFalse(object instanceof HTMLButtonElement);
  assertFalse(object instanceof HTMLElementConcreteNativeJsType);
  assertFalse(object instanceof Iterator);
  assertTrue(object instanceof MyNativeJsTypeInterface);
  assertFalse(object instanceof MyNativeJsTypeInterfaceImpl);
  assertTrue(object instanceof ElementLikeNativeInterface);
  assertFalse(object instanceof ElementLikeNativeInterfaceImpl);
  assertFalse(object instanceof MyJsInterfaceWithOnlyInstanceofReference);
  assertTrue(object instanceof MyNativeJsTypeInterfaceAndOnlyInstanceofReference);
  assertFalse(object instanceof AliasToMyNativeJsTypeWithOnlyInstanceofReference);
  assertTrue(object instanceof ConcreteJsType);
}",0.9812362030905076
53393,"public void testVirtualUpRefs(){
  ListImpl listWithExport=new ListImpl();
  FooImpl listNoExport=new FooImpl();
  Collection collectionWithExport=alwaysTrue() ? listWithExport : listNoExport;
  collectionWithExport.add(""String_Node_Str"");
  assertEquals(""String_Node_Str"",listWithExport.x);
  Collection collectionNoExport=alwaysTrue() ? listNoExport : listWithExport;
  collectionNoExport.add(""String_Node_Str"");
  assertEquals(""String_Node_Str"",listNoExport.x);
  listNoExport.add(""String_Node_Str"");
  assertEquals(""String_Node_Str"",listNoExport.x);
  listWithExport.add(""String_Node_Str"");
  assertEquals(""String_Node_Str"",listWithExport.x);
}","public void testVirtualUpRefs(){
  ListImpl listWithExport=new ListImpl();
  FooImpl listNoExport=new FooImpl();
  Collection collectionWithExport=listWithExport;
  collectionWithExport.add(""String_Node_Str"");
  assertEquals(""String_Node_Str"",listWithExport.x);
  Collection collectionNoExport=listNoExport;
  collectionNoExport.add(""String_Node_Str"");
  assertEquals(""String_Node_Str"",listNoExport.x);
  listNoExport.add(""String_Node_Str"");
  assertEquals(""String_Node_Str"",listNoExport.x);
  listWithExport.add(""String_Node_Str"");
  assertEquals(""String_Node_Str"",listWithExport.x);
}",0.9270664505672608
53394,"public void testInstanceOf_implementsJsType(){
  Object object=alwaysTrue() ? new ElementLikeNativeInterfaceImpl() : new Object();
  assertTrue(object instanceof Object);
  assertFalse(object instanceof HTMLElementAnotherConcreteNativeJsType);
  assertFalse(object instanceof HTMLButtonElement);
  assertFalse(object instanceof HTMLElementConcreteNativeJsType);
  assertFalse(object instanceof Iterator);
  assertTrue(object instanceof MyNativeJsTypeInterface);
  assertFalse(object instanceof MyNativeJsTypeInterfaceImpl);
  assertTrue(object instanceof ElementLikeNativeInterface);
  assertTrue(object instanceof ElementLikeNativeInterfaceImpl);
  assertFalse(object instanceof MyJsInterfaceWithOnlyInstanceofReference);
  assertTrue(object instanceof MyNativeJsTypeInterfaceAndOnlyInstanceofReference);
  assertFalse(object instanceof AliasToMyNativeJsTypeWithOnlyInstanceofReference);
  assertFalse(object instanceof ConcreteJsType);
}","public void testInstanceOf_implementsJsType(){
  Object object=new ElementLikeNativeInterfaceImpl();
  assertTrue(object instanceof Object);
  assertFalse(object instanceof HTMLElementAnotherConcreteNativeJsType);
  assertFalse(object instanceof HTMLButtonElement);
  assertFalse(object instanceof HTMLElementConcreteNativeJsType);
  assertFalse(object instanceof Iterator);
  assertTrue(object instanceof MyNativeJsTypeInterface);
  assertFalse(object instanceof MyNativeJsTypeInterfaceImpl);
  assertTrue(object instanceof ElementLikeNativeInterface);
  assertTrue(object instanceof ElementLikeNativeInterfaceImpl);
  assertFalse(object instanceof MyJsInterfaceWithOnlyInstanceofReference);
  assertTrue(object instanceof MyNativeJsTypeInterfaceAndOnlyInstanceofReference);
  assertFalse(object instanceof AliasToMyNativeJsTypeWithOnlyInstanceofReference);
  assertFalse(object instanceof ConcreteJsType);
}",0.9816017316017316
53395,"public void testRevealedOverrideJsType(){
  PlainParentType plainParentType=new PlainParentType();
  RevealedOverrideSubType revealedOverrideSubType=new RevealedOverrideSubType();
  assertFalse(hasField(plainParentType,""String_Node_Str""));
  assertTrue(hasField(revealedOverrideSubType,""String_Node_Str""));
  ConcreteJsTypeJsSubclass subclass=new ConcreteJsTypeJsSubclass();
  assertEquals(100,subclass.publicMethodAlsoExposedAsNonJsMethod());
  SubclassInterface subclassInterface=alwaysTrue() ? subclass : new SubclassInterface(){
    @Override public int publicMethodAlsoExposedAsNonJsMethod(){
      return 0;
    }
  }
;
  assertEquals(100,subclassInterface.publicMethodAlsoExposedAsNonJsMethod());
}","public void testRevealedOverrideJsType(){
  PlainParentType plainParentType=new PlainParentType();
  RevealedOverrideSubType revealedOverrideSubType=new RevealedOverrideSubType();
  assertFalse(hasField(plainParentType,""String_Node_Str""));
  assertTrue(hasField(revealedOverrideSubType,""String_Node_Str""));
  ConcreteJsTypeJsSubclass subclass=new ConcreteJsTypeJsSubclass();
  assertEquals(100,subclass.publicMethodAlsoExposedAsNonJsMethod());
  SubclassInterface subclassInterface=subclass;
  assertEquals(100,subclassInterface.publicMethodAlsoExposedAsNonJsMethod());
}",0.8824451410658307
53396,"public void testInstanceOf_extendsJsTypeWithProto(){
  Object object=alwaysTrue() ? new MyCustomHtmlButtonWithIterator() : new Object();
  assertTrue(object instanceof Object);
  assertTrue(object instanceof HTMLElementAnotherConcreteNativeJsType);
  assertTrue(object instanceof HTMLButtonElement);
  assertTrue(object instanceof HTMLElementConcreteNativeJsType);
  assertTrue(object instanceof Iterable);
  assertTrue(object instanceof MyNativeJsTypeInterface);
  assertFalse(object instanceof MyNativeJsTypeInterfaceImpl);
  assertTrue(object instanceof ElementLikeNativeInterface);
  assertFalse(object instanceof ElementLikeNativeInterfaceImpl);
  assertFalse(object instanceof MyJsInterfaceWithOnlyInstanceofReference);
  assertTrue(object instanceof MyNativeJsTypeInterfaceAndOnlyInstanceofReference);
  assertFalse(object instanceof AliasToMyNativeJsTypeWithOnlyInstanceofReference);
  assertFalse(object instanceof ConcreteJsType);
}","public void testInstanceOf_extendsJsTypeWithProto(){
  Object object=new MyCustomHtmlButtonWithIterator();
  assertTrue(object instanceof Object);
  assertTrue(object instanceof HTMLElementAnotherConcreteNativeJsType);
  assertTrue(object instanceof HTMLButtonElement);
  assertTrue(object instanceof HTMLElementConcreteNativeJsType);
  assertTrue(object instanceof Iterable);
  assertTrue(object instanceof MyNativeJsTypeInterface);
  assertFalse(object instanceof MyNativeJsTypeInterfaceImpl);
  assertTrue(object instanceof ElementLikeNativeInterface);
  assertFalse(object instanceof ElementLikeNativeInterfaceImpl);
  assertFalse(object instanceof MyJsInterfaceWithOnlyInstanceofReference);
  assertTrue(object instanceof MyNativeJsTypeInterfaceAndOnlyInstanceofReference);
  assertFalse(object instanceof AliasToMyNativeJsTypeWithOnlyInstanceofReference);
  assertFalse(object instanceof ConcreteJsType);
}",0.9838187702265372
53397,"public InliningVisitor(JsProgram program,Set<JsNode> whitelist){
  this.whitelist=whitelist;
  invocationCountingVisitor.accept(program);
  JsName defineClass=getFunctionName(program,""String_Node_Str"");
  safeToInlineAtTopLevel=defineClass != null ? ImmutableSet.of(defineClass) : ImmutableSet.<JsName>of();
}","public InliningVisitor(JsProgram program,Set<JsNode> whitelist){
  this.whitelist=whitelist;
  invocationCountingVisitor.accept(program);
}",0.6205357142857143
53398,"/** 
 * Determine if <code>invokedFunction</code> can be inlined into <code>callerFunction</code> at callsite <code>x</code>.
 * @return An expression equivalent to <code>x</code>
 */
private JsExpression process(JsInvocation x,JsFunction callerFunction,JsFunction invokedFunction){
  List<JsStatement> statements;
  if (invokedFunction.getBody() != null) {
    statements=Lists.newArrayList(invokedFunction.getBody().getStatements());
  }
 else {
    statements=Collections.emptyList();
  }
  List<JsExpression> hoisted=Lists.newArrayListWithCapacity(statements.size());
  JsExpression thisExpr=((JsNameRef)x.getQualifier()).getQualifier();
  HoistedNameVisitor hoistedNameVisitor=new HoistedNameVisitor(callerFunction.getScope(),invokedFunction.getScope());
  boolean sawReturnStatement=false;
  for (  JsStatement statement : statements) {
    if (sawReturnStatement) {
      return x;
    }
    JsExpression h=hoistedExpression(statement);
    if (h == null) {
      return x;
    }
    hoistedNameVisitor.accept(statement);
    if (isReturnStatement(statement)) {
      sawReturnStatement=true;
      hoisted.add(h);
    }
 else     if (hasSideEffects(Collections.singletonList(h))) {
      hoisted.add(h);
    }
  }
  List<JsName> hoistedNames=hoistedNameVisitor.getHoistedNames();
  if (!sawReturnStatement) {
    hoisted.add(new JsNameRef(x.getSourceInfo(),JsRootScope.INSTANCE.getUndefined()));
  }
  assert(hoisted.size() > 0);
  SourceInfo sourceInfo=x.getSourceInfo();
  ListIterator<JsExpression> i=hoisted.listIterator(hoisted.size());
  JsExpression op=i.previous();
  while (i.hasPrevious()) {
    JsBinaryOperation outerOp=new JsBinaryOperation(sourceInfo,JsBinaryOperator.COMMA);
    outerOp.setArg1(i.previous());
    outerOp.setArg2(op);
    op=outerOp;
  }
  if (!isInlinable(callerFunction,invokedFunction,thisExpr,x.getArguments(),op)) {
    return x;
  }
  NameRefReplacerVisitor v=new NameRefReplacerVisitor(thisExpr,x.getArguments(),invokedFunction.getParameters());
  for (ListIterator<JsName> nameIterator=hoistedNames.listIterator(); nameIterator.hasNext(); ) {
    JsName name=nameIterator.next();
    String ident;
    String base=invokedFunction.getName() + ""String_Node_Str"" + name.getIdent();
    JsScope scope=callerFunction.getScope();
    Multiset<String> startIdent=startIdentForScope.get(scope);
    if (startIdent == null) {
      startIdent=HashMultiset.create();
      startIdentForScope.put(scope,startIdent);
    }
    int suffix=startIdent.count(base);
    do {
      ident=base + ""String_Node_Str"" + suffix++;
    }
 while (scope.findExistingName(ident) != null);
    startIdent.setCount(base,suffix);
    JsName newName=scope.declareName(ident,name.getShortIdent());
    v.setReplacementName(name,newName);
    nameIterator.set(newName);
  }
  op=v.accept(op);
  op=(new CommaNormalizer(hoistedNames)).accept(op);
  if (invokedFunction.getInliningMode() != InliningMode.FORCE_INLINE && isTooComplexToInline(x,op) && isInvokedMoreThanOnce(invokedFunction)) {
    return x;
  }
  if (callerFunction == programFunction && hoistedNames.size() > 0) {
    return x;
  }
  newLocalVariableStack.peek().addAll(hoistedNames);
  invocationCountingVisitor.removeCountsFor(x);
  invocationCountingVisitor.accept(op);
  return op;
}","/** 
 * Determine if <code>invokedFunction</code> can be inlined into <code>callerFunction</code> at callsite <code>x</code>.
 * @return An expression equivalent to <code>x</code>
 */
private JsExpression process(JsInvocation x,JsFunction callerFunction,JsFunction invokedFunction){
  List<JsStatement> statements;
  if (invokedFunction.getBody() != null) {
    statements=Lists.newArrayList(invokedFunction.getBody().getStatements());
  }
 else {
    statements=Collections.emptyList();
  }
  List<JsExpression> hoisted=Lists.newArrayListWithCapacity(statements.size());
  JsExpression thisExpr=((JsNameRef)x.getQualifier()).getQualifier();
  HoistedNameVisitor hoistedNameVisitor=new HoistedNameVisitor(callerFunction.getScope(),invokedFunction.getScope());
  boolean sawReturnStatement=false;
  for (  JsStatement statement : statements) {
    if (sawReturnStatement) {
      return x;
    }
    JsExpression h=hoistedExpression(statement);
    if (h == null) {
      return x;
    }
    hoistedNameVisitor.accept(h);
    if (isReturnStatement(statement)) {
      sawReturnStatement=true;
      hoisted.add(h);
    }
 else     if (hasSideEffects(Collections.singletonList(h))) {
      hoisted.add(h);
    }
  }
  List<JsName> hoistedNames=hoistedNameVisitor.getHoistedNames();
  if (hoistedNames.size() != 0 && callerFunction == programFunction) {
    return x;
  }
  if (!sawReturnStatement) {
    hoisted.add(new JsNameRef(x.getSourceInfo(),JsRootScope.INSTANCE.getUndefined()));
  }
  assert(hoisted.size() > 0);
  SourceInfo sourceInfo=x.getSourceInfo();
  ListIterator<JsExpression> i=hoisted.listIterator(hoisted.size());
  JsExpression op=i.previous();
  while (i.hasPrevious()) {
    JsBinaryOperation outerOp=new JsBinaryOperation(sourceInfo,JsBinaryOperator.COMMA);
    outerOp.setArg1(i.previous());
    outerOp.setArg2(op);
    op=outerOp;
  }
  if (!isInlinable(callerFunction,invokedFunction,thisExpr,x.getArguments(),op)) {
    return x;
  }
  NameRefReplacerVisitor v=new NameRefReplacerVisitor(thisExpr,x.getArguments(),invokedFunction.getParameters());
  for (ListIterator<JsName> nameIterator=hoistedNames.listIterator(); nameIterator.hasNext(); ) {
    JsName name=nameIterator.next();
    String ident;
    String base=invokedFunction.getName() + ""String_Node_Str"" + name.getIdent();
    JsScope scope=callerFunction.getScope();
    Multiset<String> startIdent=startIdentForScope.get(scope);
    if (startIdent == null) {
      startIdent=HashMultiset.create();
      startIdentForScope.put(scope,startIdent);
    }
    int suffix=startIdent.count(base);
    do {
      ident=base + ""String_Node_Str"" + suffix++;
    }
 while (scope.findExistingName(ident) != null);
    startIdent.setCount(base,suffix);
    JsName newName=scope.declareName(ident,name.getShortIdent());
    v.setReplacementName(name,newName);
    nameIterator.set(newName);
  }
  op=v.accept(op);
  op=(new CommaNormalizer(hoistedNames)).accept(op);
  if (invokedFunction.getInliningMode() != InliningMode.FORCE_INLINE && isTooComplexToInline(x,op) && isInvokedMoreThanOnce(invokedFunction)) {
    return x;
  }
  if (callerFunction == programFunction && hoistedNames.size() > 0) {
    return x;
  }
  newLocalVariableStack.peek().addAll(hoistedNames);
  invocationCountingVisitor.removeCountsFor(x);
  invocationCountingVisitor.accept(op);
  return op;
}",0.9850294873733556
53399,"private static boolean isTooComplexToInline(List<JExpression> bodyAsExpressionList,boolean ignoringReturn){
  if (ignoringReturn) {
    return bodyAsExpressionList.size() > 2;
  }
  if (bodyAsExpressionList.size() == 3 && bodyAsExpressionList.get(2).hasSideEffects()) {
    return true;
  }
  return false;
}","private static boolean isTooComplexToInline(List<JExpression> bodyAsExpressionList,boolean ignoringReturn){
  if (bodyAsExpressionList.size() > 3) {
    return true;
  }
  if (bodyAsExpressionList.size() == 3 && (!ignoringReturn || bodyAsExpressionList.get(2).hasSideEffects())) {
    return true;
  }
  return false;
}",0.886762360446571
53400,"/** 
 * Inline a call to an expression. Returns   {@code InlineResult.BLACKLIST} if the method isdeemed not inlineable regardless of call site;  {@code InlineResult.DO_NOT_BLACKLIST}otherwise.
 */
private InlineResult tryInlineBody(JMethodCall x,Context ctx,List<JExpression> bodyAsExpressionList,boolean ignoringReturn){
  if (isTooComplexToInline(bodyAsExpressionList,ignoringReturn)) {
    return InlineResult.BLACKLIST;
  }
  ExpressionAnalyzer targetAnalyzer=new ExpressionAnalyzer();
  targetAnalyzer.accept(bodyAsExpressionList);
  if (targetAnalyzer.hasAssignmentToParameter()) {
    return InlineResult.BLACKLIST;
  }
  RecursionCheckVisitor recursionCheckVisitor=new RecursionCheckVisitor(x.getTarget());
  recursionCheckVisitor.accept(bodyAsExpressionList);
  if (recursionCheckVisitor.isRecursive()) {
    return InlineResult.BLACKLIST;
  }
  if (x.getTarget().getParams().size() != x.getArgs().size()) {
    return InlineResult.DO_NOT_BLACKLIST;
  }
  OrderVisitor orderVisitor=new OrderVisitor(x.getTarget().getParams());
  orderVisitor.accept(bodyAsExpressionList);
  if (orderVisitor.checkResults() == SideEffectCheck.NO_REFERENCES) {
    List<JExpression> expressions=expressionsIncludingArgs(x);
    expressions.addAll(bodyAsExpressionList);
    ctx.replaceMe(JjsUtils.createOptimizedMultiExpression(ignoringReturn,expressions));
    return InlineResult.DO_NOT_BLACKLIST;
  }
  if (orderVisitor.checkResults() == SideEffectCheck.FAILS) {
    for (    JExpression arg : x.getArgs()) {
      ExpressionAnalyzer argAnalyzer=new ExpressionAnalyzer();
      argAnalyzer.accept(arg);
      if (argAnalyzer.hasAssignment() || argAnalyzer.accessesField() || argAnalyzer.createsObject()|| argAnalyzer.canThrowException()) {
        return InlineResult.DO_NOT_BLACKLIST;
      }
    }
  }
  boolean hasSideEffects=x.hasSideEffects();
  if (!hasSideEffects) {
    new JModVisitor(){
      @Override public void endVisit(      JMethodCall x,      Context ctx){
        x.markSideEffectFree();
      }
    }
.accept(bodyAsExpressionList);
  }
  ParameterReplacer replacer=new ParameterReplacer(x);
  replacer.accept(bodyAsExpressionList);
  bodyAsExpressionList.add(0,x.getInstance());
  bodyAsExpressionList.add(1,createClinitCall(x));
  ctx.replaceMe(JjsUtils.createOptimizedMultiExpression(ignoringReturn,bodyAsExpressionList));
  return InlineResult.DO_NOT_BLACKLIST;
}","/** 
 * Inline a call to an expression. Returns   {@code InlineResult.BLACKLIST} if the method isdeemed not inlineable regardless of call site;  {@code InlineResult.DO_NOT_BLACKLIST}otherwise.
 */
private InlineResult tryInlineBody(JMethodCall x,Context ctx,List<JExpression> bodyAsExpressionList,boolean ignoringReturn){
  if (isTooComplexToInline(bodyAsExpressionList,ignoringReturn)) {
    return InlineResult.BLACKLIST;
  }
  ExpressionAnalyzer targetAnalyzer=new ExpressionAnalyzer();
  targetAnalyzer.accept(bodyAsExpressionList);
  if (targetAnalyzer.hasAssignmentToParameter()) {
    return InlineResult.BLACKLIST;
  }
  RecursionCheckVisitor recursionCheckVisitor=new RecursionCheckVisitor(x.getTarget());
  recursionCheckVisitor.accept(bodyAsExpressionList);
  if (recursionCheckVisitor.isRecursive()) {
    return InlineResult.BLACKLIST;
  }
  if (x.getTarget().getParams().size() != x.getArgs().size()) {
    return InlineResult.DO_NOT_BLACKLIST;
  }
  boolean hasSideEffects=x.hasSideEffects();
  if (!hasSideEffects) {
    new JModVisitor(){
      @Override public void endVisit(      JMethodCall x,      Context ctx){
        x.markSideEffectFree();
      }
    }
.accept(bodyAsExpressionList);
  }
  OrderVisitor orderVisitor=new OrderVisitor(x.getTarget().getParams());
  orderVisitor.accept(bodyAsExpressionList);
  if (orderVisitor.checkResults() == SideEffectCheck.NO_REFERENCES) {
    List<JExpression> expressions=expressionsIncludingArgs(x);
    expressions.addAll(bodyAsExpressionList);
    ctx.replaceMe(JjsUtils.createOptimizedMultiExpression(ignoringReturn,expressions));
    return InlineResult.DO_NOT_BLACKLIST;
  }
  if (orderVisitor.checkResults() == SideEffectCheck.FAILS) {
    for (    JExpression arg : x.getArgs()) {
      ExpressionAnalyzer argAnalyzer=new ExpressionAnalyzer();
      argAnalyzer.accept(arg);
      if (argAnalyzer.hasAssignment() || argAnalyzer.accessesField() || argAnalyzer.createsObject()|| argAnalyzer.canThrowException()) {
        return InlineResult.DO_NOT_BLACKLIST;
      }
    }
  }
  ParameterReplacer replacer=new ParameterReplacer(x);
  replacer.accept(bodyAsExpressionList);
  bodyAsExpressionList.add(0,x.getInstance());
  bodyAsExpressionList.add(1,createClinitCall(x));
  ctx.replaceMe(JjsUtils.createOptimizedMultiExpression(ignoringReturn,bodyAsExpressionList));
  return InlineResult.DO_NOT_BLACKLIST;
}",0.8944491169049622
53401,"@Override public void remove(){
  checkState(lastEntry != null);
  InternalHashCodeMap.this.remove(lastEntry.getKey());
  if (chain == lastChain && chain.length != 1) {
    itemIndex--;
  }
  lastEntry=null;
}","@Override public void remove(){
  checkState(lastEntry != null);
  boolean isLastChain=itemIndex == lastChain.length;
  InternalHashCodeMap.this.remove(lastEntry.getKey());
  if (!isLastChain) {
    itemIndex--;
  }
  lastEntry=null;
}",0.7702702702702703
53402,"@Override public Iterator<Entry<K,V>> iterator(){
  return new Iterator<Map.Entry<K,V>>(){
    final InternalJsIterator<Object> chains=backingMap.entries();
    int itemIndex=0;
    Entry<K,V>[] chain=newEntryChain();
    Entry<K,V>[] lastChain=null;
    Entry<K,V> lastEntry=null;
    @Override public boolean hasNext(){
      if (itemIndex < chain.length) {
        return true;
      }
      InternalJsIteratorEntry<Object> current=chains.next();
      if (!current.done()) {
        chain=unsafeCastToArray(current.getValue());
        itemIndex=0;
        return true;
      }
      return false;
    }
    @Override public Entry<K,V> next(){
      checkElement(hasNext());
      lastChain=chain;
      lastEntry=chain[itemIndex++];
      return lastEntry;
    }
    @Override public void remove(){
      checkState(lastEntry != null);
      InternalHashCodeMap.this.remove(lastEntry.getKey());
      if (chain == lastChain && chain.length != 1) {
        itemIndex--;
      }
      lastEntry=null;
    }
  }
;
}","@Override public Iterator<Entry<K,V>> iterator(){
  return new Iterator<Map.Entry<K,V>>(){
    final InternalJsIterator<Object> chains=backingMap.entries();
    int itemIndex=0;
    Entry<K,V>[] chain=newEntryChain();
    Entry<K,V>[] lastChain=null;
    Entry<K,V> lastEntry=null;
    @Override public boolean hasNext(){
      if (itemIndex < chain.length) {
        return true;
      }
      InternalJsIteratorEntry<Object> current=chains.next();
      if (!current.done()) {
        chain=unsafeCastToArray(current.getValue());
        itemIndex=0;
        return true;
      }
      return false;
    }
    @Override public Entry<K,V> next(){
      checkElement(hasNext());
      lastChain=chain;
      lastEntry=chain[itemIndex++];
      return lastEntry;
    }
    @Override public void remove(){
      checkState(lastEntry != null);
      boolean isLastChain=itemIndex == lastChain.length;
      InternalHashCodeMap.this.remove(lastEntry.getKey());
      if (!isLastChain) {
        itemIndex--;
      }
      lastEntry=null;
    }
  }
;
}",0.9554263565891472
53403,"@Override public int hashCode(){
  return 0;
}","@Override public int hashCode(){
  return hashCode;
}",0.9090909090909092
53404,"@Override public Entry<K,V> next(){
  checkElement(hasNext());
  lastChain=chain;
  lastEntry=chain[itemIndex++];
  return lastEntry;
}","@Override public Entry<K,V> next(){
  checkElement(hasNext());
  lastEntry=chain[itemIndex++];
  return lastEntry;
}",0.9243027888446216
53405,"@Override public void remove(){
  checkState(lastEntry != null);
  boolean isLastChain=itemIndex == lastChain.length;
  InternalHashCodeMap.this.remove(lastEntry.getKey());
  if (!isLastChain) {
    itemIndex--;
  }
  lastEntry=null;
}","@Override public void remove(){
  checkState(lastEntry != null);
  InternalHashCodeMap.this.remove(lastEntry.getKey());
  if (itemIndex != 0) {
    itemIndex--;
  }
  lastEntry=null;
}",0.8162291169451074
53406,"@Override public Iterator<Entry<K,V>> iterator(){
  return new Iterator<Map.Entry<K,V>>(){
    final InternalJsIterator<Object> chains=backingMap.entries();
    int itemIndex=0;
    Entry<K,V>[] chain=newEntryChain();
    Entry<K,V>[] lastChain=null;
    Entry<K,V> lastEntry=null;
    @Override public boolean hasNext(){
      if (itemIndex < chain.length) {
        return true;
      }
      InternalJsIteratorEntry<Object> current=chains.next();
      if (!current.done()) {
        chain=unsafeCastToArray(current.getValue());
        itemIndex=0;
        return true;
      }
      return false;
    }
    @Override public Entry<K,V> next(){
      checkElement(hasNext());
      lastChain=chain;
      lastEntry=chain[itemIndex++];
      return lastEntry;
    }
    @Override public void remove(){
      checkState(lastEntry != null);
      boolean isLastChain=itemIndex == lastChain.length;
      InternalHashCodeMap.this.remove(lastEntry.getKey());
      if (!isLastChain) {
        itemIndex--;
      }
      lastEntry=null;
    }
  }
;
}","@Override public Iterator<Entry<K,V>> iterator(){
  return new Iterator<Map.Entry<K,V>>(){
    final InternalJsIterator<Object> chains=backingMap.entries();
    int itemIndex=0;
    Entry<K,V>[] chain=newEntryChain();
    Entry<K,V> lastEntry=null;
    @Override public boolean hasNext(){
      if (itemIndex < chain.length) {
        return true;
      }
      InternalJsIteratorEntry<Object> current=chains.next();
      if (!current.done()) {
        chain=unsafeCastToArray(current.getValue());
        itemIndex=0;
        return true;
      }
      return false;
    }
    @Override public Entry<K,V> next(){
      checkElement(hasNext());
      lastEntry=chain[itemIndex++];
      return lastEntry;
    }
    @Override public void remove(){
      checkState(lastEntry != null);
      InternalHashCodeMap.this.remove(lastEntry.getKey());
      if (itemIndex != 0) {
        itemIndex--;
      }
      lastEntry=null;
    }
  }
;
}",0.5375693393847706
53407,"private void replaceLambdaWithInnerClassAllocation(LambdaExpression x,SourceInfo info,JClassType innerLambdaClass,JConstructor ctor,SyntheticArgumentBinding[] synthArgs){
}","private void replaceLambdaWithInnerClassAllocation(LambdaExpression x,final SourceInfo info,JClassType innerLambdaClass,JConstructor ctor,SyntheticArgumentBinding[] synthArgs){
}",0.9828571428571428
53408,"@Override public Integer run(int j,int k){
  int t=x;
  int s=local;
  return t + s + a+ b;
}","public void run(){
  Lambda<Integer> l=(a,b) -> x[0]=x[0] + a + b+ arg+ fA+ fB+ fI;
  l.run(1,2);
}",0.25
53409,int foo();,"public int foo(Integer arg){
  x1[0]=x1[0] + 1;
  x[0]=x[0] + 1;
  return x2[0]=x2[0] + rA + rB+ a+ b;
}",0.175438596491228
53410,"/** 
 * True if the type is a JSO or interface implemented by JSO or a JsType without prototype.
 */
public boolean canCrossCastLikeJso(JType type){
  JDeclaredType dtype=getNearestJsType(type,false);
  return canBeJavaScriptObject(type) || (dtype instanceof JInterfaceType && isOrExtendsJsType(type,false) && !isOrExtendsJsType(type,true));
}","/** 
 * True if the type is a JSO or interface implemented by JSO or a JsType without prototype.
 */
public boolean canCrossCastLikeJso(JType type){
  return canBeJavaScriptObject(type) || isJsTypeInterfaceWithoutPrototype(type);
}",0.5679442508710801
53411,"private JRuntimeTypeReference getElementRuntimeTypeReference(SourceInfo sourceInfo,JArrayType arrayType){
  JType elementType=arrayType.getElementType();
  if (!(elementType instanceof JReferenceType)) {
    elementType=JReferenceType.NULL_TYPE;
  }
  if (program.typeOracle.willCrossCastLikeJso(elementType)) {
    elementType=program.getJavaScriptObject();
  }
 else {
    elementType=elementType.getUnderlyingType();
  }
  elementType=program.normalizeJsoType(elementType);
  return new JRuntimeTypeReference(sourceInfo,program.getTypeJavaLangObject(),(JReferenceType)elementType);
}","private JRuntimeTypeReference getElementRuntimeTypeReference(SourceInfo sourceInfo,JArrayType arrayType){
  JType elementType=arrayType.getElementType();
  if (!(elementType instanceof JReferenceType)) {
    elementType=JReferenceType.NULL_TYPE;
  }
  if (program.typeOracle.isEffectivelyJavaScriptObject(elementType)) {
    elementType=program.getJavaScriptObject();
  }
 else {
    elementType=elementType.getUnderlyingType();
  }
  elementType=program.normalizeJsoType(elementType);
  return new JRuntimeTypeReference(sourceInfo,program.getTypeJavaLangObject(),(JReferenceType)elementType);
}",0.6028789161727349
53412,"@Override public void endVisit(JInstanceOf x,Context ctx){
  JReferenceType argType=(JReferenceType)x.getExpr().getType();
  JReferenceType toType=x.getTestType();
  assert(toType == toType.getUnderlyingType());
  if (toType instanceof JArrayType) {
    toType=(JReferenceType)program.normalizeJsoType(toType);
  }
  boolean isTrivialCast=program.typeOracle.castSucceedsTrivially(argType,toType) || (program.typeOracle.willCrossCastLikeJso(argType) && program.typeOracle.willCrossCastLikeJso(toType));
  if (pruneTrivialCasts && isTrivialCast) {
    JBinaryOperation eq=new JBinaryOperation(x.getSourceInfo(),program.getTypePrimitiveBoolean(),JBinaryOperator.NEQ,x.getExpr(),program.getLiteralNull());
    ctx.replaceMe(eq);
  }
 else {
    ctx.replaceMe(implementCastOrInstanceOfOperation(x.getSourceInfo(),x.getExpr(),toType,instanceOfMethodsByTargetTypeCategory,false));
  }
}","@Override public void endVisit(JInstanceOf x,Context ctx){
  JReferenceType argType=(JReferenceType)x.getExpr().getType();
  JReferenceType toType=x.getTestType();
  assert(toType == toType.getUnderlyingType());
  if (toType instanceof JArrayType) {
    toType=(JReferenceType)program.normalizeJsoType(toType);
  }
  boolean isTrivialCast=program.typeOracle.castSucceedsTrivially(argType,toType) || (program.typeOracle.isEffectivelyJavaScriptObject(argType) && program.typeOracle.isEffectivelyJavaScriptObject(toType));
  if (pruneTrivialCasts && isTrivialCast) {
    JBinaryOperation eq=new JBinaryOperation(x.getSourceInfo(),program.getTypePrimitiveBoolean(),JBinaryOperator.NEQ,x.getExpr(),program.getLiteralNull());
    ctx.replaceMe(eq);
  }
 else {
    ctx.replaceMe(implementCastOrInstanceOfOperation(x.getSourceInfo(),x.getExpr(),toType,instanceOfMethodsByTargetTypeCategory,false));
  }
}",0.9448198198198198
53413,"private ImplementCastsAndTypeChecks(JProgram program,boolean disableCastChecking,boolean pruneTrivialCasts){
  this.program=program;
  this.disableCastChecking=disableCastChecking;
  this.pruneTrivialCasts=pruneTrivialCasts;
  this.instanceOfMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JAVA_OBJECT,program.getIndexedMethod(""String_Node_Str""));
  this.instanceOfMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JAVA_LANG_OBJECT,program.getIndexedMethod(""String_Node_Str""));
  this.instanceOfMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JAVA_OBJECT_OR_JSO,program.getIndexedMethod(""String_Node_Str""));
  this.instanceOfMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JSO,program.getIndexedMethod(""String_Node_Str""));
  this.instanceOfMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JAVA_LANG_STRING,program.getIndexedMethod(""String_Node_Str""));
  this.instanceOfMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JS_INTERFACE,program.getIndexedMethod(""String_Node_Str""));
  this.instanceOfMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JS_FUNCTION,program.getIndexedMethod(""String_Node_Str""));
  this.dynamicCastMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JAVA_OBJECT,program.getIndexedMethod(""String_Node_Str""));
  this.dynamicCastMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JAVA_LANG_OBJECT,program.getIndexedMethod(""String_Node_Str""));
  this.dynamicCastMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JAVA_OBJECT_OR_JSO,program.getIndexedMethod(""String_Node_Str""));
  this.dynamicCastMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JSO,program.getIndexedMethod(""String_Node_Str""));
  this.dynamicCastMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JAVA_LANG_STRING,program.getIndexedMethod(""String_Node_Str""));
  this.dynamicCastMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JS_INTERFACE,program.getIndexedMethod(""String_Node_Str""));
  this.dynamicCastMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JS_FUNCTION,program.getIndexedMethod(""String_Node_Str""));
}","private ImplementCastsAndTypeChecks(JProgram program,boolean disableCastChecking,boolean pruneTrivialCasts){
  this.program=program;
  this.disableCastChecking=disableCastChecking;
  this.pruneTrivialCasts=pruneTrivialCasts;
  this.instanceOfMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JAVA_OBJECT,program.getIndexedMethod(""String_Node_Str""));
  this.instanceOfMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JAVA_LANG_OBJECT,program.getIndexedMethod(""String_Node_Str""));
  this.instanceOfMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JAVA_OBJECT_OR_JSO,program.getIndexedMethod(""String_Node_Str""));
  this.instanceOfMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JSO,program.getIndexedMethod(""String_Node_Str""));
  this.instanceOfMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JAVA_LANG_STRING,program.getIndexedMethod(""String_Node_Str""));
  this.instanceOfMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JS_PROTOTYPE,program.getIndexedMethod(""String_Node_Str""));
  this.instanceOfMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JS_FUNCTION,program.getIndexedMethod(""String_Node_Str""));
  this.dynamicCastMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JAVA_OBJECT,program.getIndexedMethod(""String_Node_Str""));
  this.dynamicCastMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JAVA_LANG_OBJECT,program.getIndexedMethod(""String_Node_Str""));
  this.dynamicCastMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JAVA_OBJECT_OR_JSO,program.getIndexedMethod(""String_Node_Str""));
  this.dynamicCastMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JSO,program.getIndexedMethod(""String_Node_Str""));
  this.dynamicCastMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JAVA_LANG_STRING,program.getIndexedMethod(""String_Node_Str""));
  this.dynamicCastMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JS_PROTOTYPE,program.getIndexedMethod(""String_Node_Str""));
  this.dynamicCastMethodsByTargetTypeCategory.put(TypeCategory.TYPE_JS_FUNCTION,program.getIndexedMethod(""String_Node_Str""));
}",0.9930104842735896
53414,"public void testCastableDestinationTypes(){
  assertCastableDestinationTypes(classObject,classObject);
  assertCastableDestinationTypes(classString,classString,classObject);
  assertCastableDestinationTypes(classJso,classJso,classObject);
  assertCastableDestinationTypes(intfSerializable,intfSerializable,classObject);
  assertCastableDestinationTypes(intfCloneable,intfCloneable,classObject);
  assertCastableDestinationTypes(intfIBase,intfIBase,classObject);
  assertCastableDestinationTypes(intfI,intfI,intfIBase,classObject);
  assertCastableDestinationTypes(intfJ,intfJ,classJso,classObject);
  assertCastableDestinationTypes(intfK,intfK,classJso,classObject);
  assertCastableDestinationTypes(classBase,classBase,classObject);
  assertCastableDestinationTypes(classA,classA,classObject,classBase);
  assertCastableDestinationTypes(classB,classB,classObject,classBase,intfIBase,intfI);
  assertCastableDestinationTypes(classC,classC,classObject,intfIBase,intfI);
  assertCastableDestinationTypes(classBSub,classBSub,classObject,classBase,classB,intfIBase,intfI,intfL);
  assertCastableDestinationTypes(classJso1,classObject,classJso,intfJ);
  assertCastableDestinationTypes(classJso2,classObject,classJso,intfK);
  assertCastableDestinationTypes(arrayOfJso,classObject,intfCloneable,intfSerializable,arrayOfJso,arrayOfObject);
  assertCastableDestinationTypes(arrayOfJso1,classObject,intfCloneable,intfSerializable,arrayOfJso,arrayOfObject,arrayOfIntfJ);
  assertCastableDestinationTypes(arrayOfJso2,classObject,intfCloneable,intfSerializable,arrayOfJso,arrayOfObject,arrayOfIntfK);
  assertCastableDestinationTypes(intfIterable,intfIterable,classObject);
  assertCastableDestinationTypes(intfCollection,intfCollection,intfIterable,classObject);
  assertCastableDestinationTypes(intfList,intfList,intfIterable,intfCollection,classObject);
  assertCastableDestinationTypes(classArrayList,classArrayList,intfList,classObject,intfIterable,intfCollection);
  assertCastableDestinationTypes(arrayOfB,arrayOfB,arrayOfBase,arrayOfObject,arrayOfIntfI,arrayOfIntfIBase,classObject,arrayOfObject,intfCloneable,intfSerializable);
  assertCastableDestinationTypes(arrayOfArrayOfB,arrayOfArrayOfB,arrayOfArrayOfBase,arrayOfArrayOfObject,arrayOfArrayOfIntfI,arrayOfArrayOfIntfIBase,classObject,arrayOfObject,intfCloneable,arrayOfIntfClonable,intfSerializable,arrayOfIntfSerializable);
  assertCastableDestinationTypes(arrayOfInt,arrayOfInt,classObject,intfCloneable,intfSerializable);
  intfCollection=createInterface(""String_Node_Str"");
  program.typeOracle.computeBeforeAST(StandardTypes.createFrom(program),program.getDeclaredTypes(),Sets.<JDeclaredType>newHashSet(classArrayList,intfList,intfCollection,classObject),Lists.newArrayList(intfIterable.getName()));
  assertCastableDestinationTypes(intfCollection,intfCollection,classObject);
  assertCastableDestinationTypes(intfList,intfList,intfCollection,classObject);
  assertCastableDestinationTypes(classArrayList,classArrayList,intfList,classObject,intfCollection);
  classA=createClass(""String_Node_Str"",classObject,false,false);
  program.typeOracle.computeBeforeAST(StandardTypes.createFrom(program),program.getDeclaredTypes(),Sets.<JDeclaredType>newHashSet(classA,classObject),Lists.newArrayList(classBase.getName()));
  assertCastableDestinationTypes(classA,classA,classObject);
  JClassType classASub=createClass(""String_Node_Str"",classA,false,false);
  program.typeOracle.computeBeforeAST(StandardTypes.createFrom(program),program.getDeclaredTypes(),Sets.<JDeclaredType>newHashSet(classASub,classA,classObject),EMPTY_LIST);
  assertCastableDestinationTypes(classASub,classASub,classA,classObject);
}","public void testCastableDestinationTypes(){
  assertCastableDestinationTypes(classObject,classObject);
  assertCastableDestinationTypes(classString,classString,classObject);
  assertCastableDestinationTypes(classJso,classJso,classObject);
  assertCastableDestinationTypes(intfSerializable,intfSerializable,classObject);
  assertCastableDestinationTypes(intfCloneable,intfCloneable,classObject);
  assertCastableDestinationTypes(intfIBase,intfIBase,classObject);
  assertCastableDestinationTypes(intfI,intfI,intfIBase,classObject);
  assertCastableDestinationTypes(intfJ,intfJ,classObject);
  assertCastableDestinationTypes(intfK,intfK,classObject);
  assertCastableDestinationTypes(classBase,classBase,classObject);
  assertCastableDestinationTypes(classA,classA,classObject,classBase);
  assertCastableDestinationTypes(classB,classB,classObject,classBase,intfIBase,intfI);
  assertCastableDestinationTypes(classC,classC,classObject,intfIBase,intfI);
  assertCastableDestinationTypes(classBSub,classBSub,classObject,classBase,classB,intfIBase,intfI,intfL);
  assertCastableDestinationTypes(classJso1,classObject,classJso,intfJ);
  assertCastableDestinationTypes(classJso2,classObject,classJso,intfK);
  assertCastableDestinationTypes(arrayOfJso,classObject,intfCloneable,intfSerializable,arrayOfJso,arrayOfObject);
  assertCastableDestinationTypes(arrayOfJso1,classObject,intfCloneable,intfSerializable,arrayOfJso,arrayOfObject,arrayOfIntfJ);
  assertCastableDestinationTypes(arrayOfJso2,classObject,intfCloneable,intfSerializable,arrayOfJso,arrayOfObject,arrayOfIntfK);
  assertCastableDestinationTypes(intfIterable,intfIterable,classObject);
  assertCastableDestinationTypes(intfCollection,intfCollection,intfIterable,classObject);
  assertCastableDestinationTypes(intfList,intfList,intfIterable,intfCollection,classObject);
  assertCastableDestinationTypes(classArrayList,classArrayList,intfList,classObject,intfIterable,intfCollection);
  assertCastableDestinationTypes(arrayOfB,arrayOfB,arrayOfBase,arrayOfObject,arrayOfIntfI,arrayOfIntfIBase,classObject,arrayOfObject,intfCloneable,intfSerializable);
  assertCastableDestinationTypes(arrayOfArrayOfB,arrayOfArrayOfB,arrayOfArrayOfBase,arrayOfArrayOfObject,arrayOfArrayOfIntfI,arrayOfArrayOfIntfIBase,classObject,arrayOfObject,intfCloneable,arrayOfIntfClonable,intfSerializable,arrayOfIntfSerializable);
  assertCastableDestinationTypes(arrayOfInt,arrayOfInt,classObject,intfCloneable,intfSerializable);
  intfCollection=createInterface(""String_Node_Str"");
  program.typeOracle.computeBeforeAST(StandardTypes.createFrom(program),program.getDeclaredTypes(),Sets.<JDeclaredType>newHashSet(classArrayList,intfList,intfCollection,classObject),Lists.newArrayList(intfIterable.getName()));
  assertCastableDestinationTypes(intfCollection,intfCollection,classObject);
  assertCastableDestinationTypes(intfList,intfList,intfCollection,classObject);
  assertCastableDestinationTypes(classArrayList,classArrayList,intfList,classObject,intfCollection);
  classA=createClass(""String_Node_Str"",classObject,false,false);
  program.typeOracle.computeBeforeAST(StandardTypes.createFrom(program),program.getDeclaredTypes(),Sets.<JDeclaredType>newHashSet(classA,classObject),Lists.newArrayList(classBase.getName()));
  assertCastableDestinationTypes(classA,classA,classObject);
  JClassType classASub=createClass(""String_Node_Str"",classA,false,false);
  program.typeOracle.computeBeforeAST(StandardTypes.createFrom(program),program.getDeclaredTypes(),Sets.<JDeclaredType>newHashSet(classASub,classA,classObject),EMPTY_LIST);
  assertCastableDestinationTypes(classASub,classASub,classA,classObject);
}",0.9975315414152496
53415,"private void assertCrossCasts(JClassType thisType,JClassType thatType){
  assertShouldNotFailTrivially(thisType,thatType);
  assertShouldNotFailTrivially(thatType,thisType);
  assertTrue(typeOracle.canCrossCastLikeJso(thisType));
  assertTrue(typeOracle.canCrossCastLikeJso(thatType));
}","private void assertCrossCasts(JClassType thisType,JClassType thatType){
  assertShouldNotFailTrivially(thisType,thatType);
  assertShouldNotFailTrivially(thatType,thisType);
  assertTrue(typeOracle.canBeJavaScriptObject(thisType));
  assertTrue(typeOracle.canBeJavaScriptObject(thatType));
}",0.8823529411764706
53416,"@Override public String getJavahSignatureName(){
  return ""String_Node_Str"" + name.replaceAll(""String_Node_Str"",""String_Node_Str"").replace('.','_') + ""String_Node_Str"";
}","@Override public String getJavahSignatureName(){
  return JjsUtils.javahSignatureFromName(name);
}",0.5298507462686567
53417,"String mangleName(JField x){
  String s=JjsUtils.mangledNameString(x.getEnclosingType()) + '_' + JjsUtils.mangledNameString(x);
  return s;
}","String mangleName(JField x){
  return JjsUtils.mangleMemberName(x.getEnclosingType().getName(),x.getName());
}",0.6852589641434262
53418,"String mangleNameForGlobal(JMethod x){
  String s=JjsUtils.mangledNameString(x.getEnclosingType()) + '_' + JjsUtils.mangledNameString(x)+ ""String_Node_Str"";
  for (int i=0; i < x.getOriginalParamTypes().size(); ++i) {
    JType type=x.getOriginalParamTypes().get(i);
    s+=type.getJavahSignatureName();
  }
  s+=x.getOriginalReturnType().getJavahSignatureName();
  return StringInterner.get().intern(s);
}","String mangleNameForGlobal(JMethod x){
  String s=JjsUtils.mangleMemberName(x.getEnclosingType().getName(),x.getName()) + ""String_Node_Str"";
  for (int i=0; i < x.getOriginalParamTypes().size(); ++i) {
    JType type=x.getOriginalParamTypes().get(i);
    s+=type.getJavahSignatureName();
  }
  s+=x.getOriginalReturnType().getJavahSignatureName();
  return StringInterner.get().intern(s);
}",0.8015075376884422
53419,"public JExpressionStatement makeStatement(){
  return new JExpressionStatement(getSourceInfo(),this);
}","/** 
 * Returns a statement that executes this expression.
 */
public final JExpressionStatement makeStatement(){
  return new JExpressionStatement(getSourceInfo(),this);
}",0.7490909090909091
53420,"String mangleName(JField x){
  String s=JjsUtils.getNameString(x.getEnclosingType()) + '_' + JjsUtils.getNameString(x);
  return s;
}","String mangleName(JField x){
  String s=JjsUtils.mangledNameString(x.getEnclosingType()) + '_' + JjsUtils.mangledNameString(x);
  return s;
}",0.9562043795620438
53421,"String mangleNameForGlobal(JMethod x){
  String s=JjsUtils.getNameString(x.getEnclosingType()) + '_' + JjsUtils.getNameString(x)+ ""String_Node_Str"";
  for (int i=0; i < x.getOriginalParamTypes().size(); ++i) {
    JType type=x.getOriginalParamTypes().get(i);
    s+=type.getJavahSignatureName();
  }
  s+=x.getOriginalReturnType().getJavahSignatureName();
  return StringInterner.get().intern(s);
}","String mangleNameForGlobal(JMethod x){
  String s=JjsUtils.mangledNameString(x.getEnclosingType()) + '_' + JjsUtils.mangledNameString(x)+ ""String_Node_Str"";
  for (int i=0; i < x.getOriginalParamTypes().size(); ++i) {
    JType type=x.getOriginalParamTypes().get(i);
    s+=type.getJavahSignatureName();
  }
  s+=x.getOriginalReturnType().getJavahSignatureName();
  return StringInterner.get().intern(s);
}",0.9751243781094528
53422,"private JsName declareSynthesizedClosureConstructor(JDeclaredType x,List<JsStatement> globalStmts){
  SourceInfo sourceInfo=x.getSourceInfo();
  JsName classVar=topScope.declareName(JjsUtils.getNameString(x));
  JsFunction closureCtor=JsUtils.createEmptyFunctionLiteral(sourceInfo,topScope,classVar);
  JsExprStmt statement=closureCtor.makeStmt();
  globalStmts.add(statement);
  names.put(x,classVar);
  if (x instanceof JClassType) {
    typeForStatMap.put(statement,(JClassType)x);
  }
  return classVar;
}","private JsName declareSynthesizedClosureConstructor(JDeclaredType x,List<JsStatement> globalStmts){
  SourceInfo sourceInfo=x.getSourceInfo();
  JsName classVar=topScope.declareName(JjsUtils.mangledNameString(x));
  JsFunction closureCtor=JsUtils.createEmptyFunctionLiteral(sourceInfo,topScope,classVar);
  JsExprStmt statement=closureCtor.makeStmt();
  globalStmts.add(statement);
  names.put(x,classVar);
  if (x instanceof JClassType) {
    typeForStatMap.put(statement,(JClassType)x);
  }
  return classVar;
}",0.9921722113502937
53423,"/** 
 * Construct an simple AST representing an entire   {@link CompilationState}. Does not support deferred binding. Implementation mostly copied from  {@link JavaToJavaScriptCompiler}.
 */
public static JProgram construct(TreeLogger logger,final CompilationState state,CompilerContext compilerContext,ConfigurationProperties config) throws UnableToCompleteException {
  InternalCompilerException.preload();
  PrecompilationContext precompilationContext=new PrecompilationContext(new RebindPermutationOracle(){
    @Override public void clear(){
    }
    @Override public String[] getAllPossibleRebindAnswers(    TreeLogger logger,    String sourceTypeName) throws UnableToCompleteException {
      return new String[0];
    }
    @Override public CompilationState getCompilationState(){
      return state;
    }
    @Override public StandardGeneratorContext getGeneratorContext(){
      return null;
    }
  }
);
  JProgram jprogram=new JProgram(compilerContext.getMinimalRebuildCache());
  JsProgram jsProgram=new JsProgram();
  UnifyAst unifyAst=new UnifyAst(logger,compilerContext,jprogram,jsProgram,precompilationContext);
  unifyAst.buildEverything();
  jprogram.typeOracle.computeBeforeAST(StandardTypes.createFrom(jprogram),jprogram.getDeclaredTypes(),jprogram.getModuleDeclaredTypes());
  FixAssignmentsToUnboxOrCast.exec(jprogram);
  if (compilerContext.getOptions().isEnableAssertions()) {
    AssertionNormalizer.exec(jprogram);
  }
 else {
    AssertionRemover.exec(jprogram);
  }
  if (compilerContext.getOptions().isRunAsyncEnabled()) {
    ReplaceRunAsyncs.exec(logger,jprogram);
    if (config != null) {
      CodeSplitters.pickInitialLoadSequence(logger,jprogram,config);
    }
  }
  ImplementClassLiteralsAsFields.exec(jprogram);
  return jprogram;
}","/** 
 * Construct an simple AST representing an entire   {@link CompilationState}. Does not support deferred binding. Implementation mostly copied from  {@link JavaToJavaScriptCompiler}.
 */
public static JProgram construct(TreeLogger logger,final CompilationState state,CompilerContext compilerContext,ConfigurationProperties config) throws UnableToCompleteException {
  InternalCompilerException.preload();
  PrecompilationContext precompilationContext=new PrecompilationContext(new RebindPermutationOracle(){
    @Override public void clear(){
    }
    @Override public String[] getAllPossibleRebindAnswers(    TreeLogger logger,    String sourceTypeName) throws UnableToCompleteException {
      return new String[0];
    }
    @Override public CompilationState getCompilationState(){
      return state;
    }
    @Override public StandardGeneratorContext getGeneratorContext(){
      return null;
    }
  }
);
  JProgram jprogram=new JProgram(compilerContext.getMinimalRebuildCache());
  JsProgram jsProgram=new JsProgram();
  UnifyAst unifyAst=new UnifyAst(logger,compilerContext,jprogram,jsProgram,precompilationContext);
  unifyAst.buildEverything();
  jprogram.typeOracle.computeBeforeAST(StandardTypes.createFrom(jprogram),jprogram.getDeclaredTypes(),jprogram.getModuleDeclaredTypes());
  FixAssignmentsToUnboxOrCast.exec(jprogram);
  if (compilerContext.getOptions().isEnableAssertions()) {
    AssertionNormalizer.exec(jprogram);
  }
 else {
    AssertionRemover.exec(jprogram);
  }
  if (compilerContext.getOptions().isRunAsyncEnabled()) {
    ReplaceRunAsyncs.exec(logger,jprogram);
    if (config != null) {
      CodeSplitters.pickInitialLoadSequence(logger,jprogram,config);
    }
  }
  ImplementClassLiteralsAsFields.exec(jprogram,true);
  return jprogram;
}",0.9985919459307238
53424,"/** 
 * Takes as input a CompilationState and transforms that into a unified by not yet resolved Java AST (a Java AST wherein cross-class references have been connected and all rebind result classes are available and have not yet been pruned down to the set applicable for a particular permutation). This AST is packaged into a UnifiedAst instance and then returned. Precompilation is INTENDED to progress as a series of stages: <pre> 1. initialize local state 2. assert preconditions 3. construct and unify the unresolved Java AST 4. normalize the unresolved Java AST  // arguably should be removed 5. optimize the unresolved Java AST  // arguably should be removed 6. construct and return a value </pre> There are some other types of work here (mostly metrics and data gathering) which do not serve the goal of output program construction. This work should really be moved into subclasses or some sort of callback or plugin system so as not to visually pollute the real compile logic.<br /> Significant amounts of visitors implementing the intended above stages are triggered here but in the wrong order. They have been noted for future cleanup.
 */
private UnifiedAst precompile(PrecompilationContext precompilationContext) throws UnableToCompleteException {
  try {
    if (precompilationContext.getEntryPoints().length + precompilationContext.getAdditionalRootTypes().length == 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    boolean singlePermutation=precompilationContext.getPermutations().length == 1;
    PrecompilationMetricsArtifact precompilationMetrics=precompilationContext.getPrecompilationMetricsArtifact();
    jprogram=new JProgram(compilerContext.getMinimalRebuildCache());
    jprogram.typeOracle.setOptimize(options.getOptimizationLevel() > OptionOptimize.OPTIMIZE_LEVEL_DRAFT);
    jsProgram=new JsProgram();
    CompilationState compilationState=constructJavaAst(precompilationContext);
    JsniRestrictionChecker.exec(logger,jprogram);
    JsInteropRestrictionChecker.exec(logger,jprogram,getMinimalRebuildCache());
    logTypeOracleMetrics(precompilationMetrics,compilationState);
    Memory.maybeDumpMemory(""String_Node_Str"");
    AstDumper.maybeDumpAST(jprogram);
    ConfigurationProperties configurationProperties=new ConfigurationProperties(module);
    EnumNameObfuscator.exec(jprogram,logger,configurationProperties,options);
    ReplaceDefenderMethodReferences.exec(jprogram);
    FixAssignmentsToUnboxOrCast.exec(jprogram);
    if (options.isEnableAssertions()) {
      AssertionNormalizer.exec(jprogram);
    }
 else {
      AssertionRemover.exec(jprogram);
    }
    if (module != null && options.isRunAsyncEnabled()) {
      ReplaceRunAsyncs.exec(logger,jprogram);
      ConfigurationProperties config=new ConfigurationProperties(module);
      CodeSplitters.pickInitialLoadSequence(logger,jprogram,config);
    }
    ImplementClassLiteralsAsFields.exec(jprogram);
    logAstTypeMetrics(precompilationMetrics);
    Event createUnifiedAstEvent=SpeedTracerLogger.start(CompilerEventType.CREATE_UNIFIED_AST);
    UnifiedAst result=new UnifiedAst(options,new AST(jprogram,jsProgram),singlePermutation,RecordRebinds.exec(jprogram));
    createUnifiedAstEvent.end();
    return result;
  }
 catch (  Throwable e) {
    throw CompilationProblemReporter.logAndTranslateException(logger,e);
  }
}","/** 
 * Takes as input a CompilationState and transforms that into a unified by not yet resolved Java AST (a Java AST wherein cross-class references have been connected and all rebind result classes are available and have not yet been pruned down to the set applicable for a particular permutation). This AST is packaged into a UnifiedAst instance and then returned. Precompilation is INTENDED to progress as a series of stages: <pre> 1. initialize local state 2. assert preconditions 3. construct and unify the unresolved Java AST 4. normalize the unresolved Java AST  // arguably should be removed 5. optimize the unresolved Java AST  // arguably should be removed 6. construct and return a value </pre> There are some other types of work here (mostly metrics and data gathering) which do not serve the goal of output program construction. This work should really be moved into subclasses or some sort of callback or plugin system so as not to visually pollute the real compile logic.<br /> Significant amounts of visitors implementing the intended above stages are triggered here but in the wrong order. They have been noted for future cleanup.
 */
private UnifiedAst precompile(PrecompilationContext precompilationContext) throws UnableToCompleteException {
  try {
    if (precompilationContext.getEntryPoints().length + precompilationContext.getAdditionalRootTypes().length == 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    boolean singlePermutation=precompilationContext.getPermutations().length == 1;
    PrecompilationMetricsArtifact precompilationMetrics=precompilationContext.getPrecompilationMetricsArtifact();
    jprogram=new JProgram(compilerContext.getMinimalRebuildCache());
    jprogram.typeOracle.setOptimize(options.getOptimizationLevel() > OptionOptimize.OPTIMIZE_LEVEL_DRAFT);
    jsProgram=new JsProgram();
    CompilationState compilationState=constructJavaAst(precompilationContext);
    JsniRestrictionChecker.exec(logger,jprogram);
    JsInteropRestrictionChecker.exec(logger,jprogram,getMinimalRebuildCache());
    logTypeOracleMetrics(precompilationMetrics,compilationState);
    Memory.maybeDumpMemory(""String_Node_Str"");
    AstDumper.maybeDumpAST(jprogram);
    ConfigurationProperties configurationProperties=new ConfigurationProperties(module);
    EnumNameObfuscator.exec(jprogram,logger,configurationProperties,options);
    ReplaceDefenderMethodReferences.exec(jprogram);
    FixAssignmentsToUnboxOrCast.exec(jprogram);
    if (options.isEnableAssertions()) {
      AssertionNormalizer.exec(jprogram);
    }
 else {
      AssertionRemover.exec(jprogram);
    }
    if (module != null && options.isRunAsyncEnabled()) {
      ReplaceRunAsyncs.exec(logger,jprogram);
      ConfigurationProperties config=new ConfigurationProperties(module);
      CodeSplitters.pickInitialLoadSequence(logger,jprogram,config);
    }
    ImplementClassLiteralsAsFields.exec(jprogram,shouldOptimize());
    logAstTypeMetrics(precompilationMetrics);
    Event createUnifiedAstEvent=SpeedTracerLogger.start(CompilerEventType.CREATE_UNIFIED_AST);
    UnifiedAst result=new UnifiedAst(options,new AST(jprogram,jsProgram),singlePermutation,RecordRebinds.exec(jprogram));
    createUnifiedAstEvent.end();
    return result;
  }
 catch (  Throwable e) {
    throw CompilationProblemReporter.logAndTranslateException(logger,e);
  }
}",0.9974706144918912
53425,"private Set<JDeclaredType> generatePreamble(JProgram program,List<JsStatement> globalStmts){
  JsVars vars=new JsVars(jsProgram.getSourceInfo());
  vars.add(new JsVar(jsProgram.getSourceInfo(),globalTemp));
  globalStmts.add(vars);
  generateImmortalTypes(vars);
  Set<JDeclaredType> alreadyProcessed=Sets.<JDeclaredType>newLinkedHashSet(program.immortalCodeGenTypes);
  alreadyProcessed.add(program.getTypeClassLiteralHolder());
  List<JDeclaredType> classLiteralSupportClasses=computeClassLiteralsSupportClasses(program,alreadyProcessed);
  classLiteralSupportClasses.removeAll(alreadyProcessed);
  for (  JDeclaredType type : classLiteralSupportClasses) {
    accept(type);
  }
  generateClassLiterals(globalStmts,classLiteralSupportClasses);
  Set<JDeclaredType> preambleTypes=Sets.newLinkedHashSet(alreadyProcessed);
  preambleTypes.addAll(classLiteralSupportClasses);
  return preambleTypes;
}","private Set<JDeclaredType> generatePreamble(JProgram program,List<JsStatement> globalStmts){
  JsVars vars=new JsVars(jsProgram.getSourceInfo());
  vars.add(new JsVar(jsProgram.getSourceInfo(),globalTemp));
  globalStmts.add(vars);
  generateImmortalTypes(vars);
  Set<JDeclaredType> alreadyProcessed=Sets.<JDeclaredType>newLinkedHashSet(program.immortalCodeGenTypes);
  alreadyProcessed.add(program.getTypeClassLiteralHolder());
  alreadyRan.addAll(alreadyProcessed);
  List<JDeclaredType> classLiteralSupportClasses=computeClassLiteralsSupportClasses(program,alreadyProcessed);
  classLiteralSupportClasses.removeAll(alreadyProcessed);
  for (  JDeclaredType type : classLiteralSupportClasses) {
    accept(type);
  }
  generateClassLiterals(globalStmts,classLiteralSupportClasses);
  Set<JDeclaredType> preambleTypes=Sets.newLinkedHashSet(alreadyProcessed);
  preambleTypes.addAll(classLiteralSupportClasses);
  return preambleTypes;
}",0.9787697332607512
53426,"private void execImpl(){
  NormalizeVisitor visitor=new NormalizeVisitor();
  visitor.accept(program);
  program.recordClassLiteralFields(classLiteralFields);
}","private void execImpl(){
  if (!shouldOptimize) {
    for (    JPrimitiveType type : JPrimitiveType.types) {
      resolveClassLiteralField(type);
    }
    for (    JType type : program.getDeclaredTypes()) {
      resolveClassLiteralField(type);
    }
  }
  NormalizeVisitor visitor=new NormalizeVisitor();
  visitor.accept(program);
  program.recordClassLiteralFields(classLiteralFields);
}",0.5797101449275363
53427,"private void ImplementClassLiteralsAsFields(JProgram program){
}","private void ImplementClassLiteralsAsFields(JProgram program,boolean shouldOptimize){
}",0.847682119205298
53428,"public static void exec(JProgram program){
  Event normalizerEvent=SpeedTracerLogger.start(CompilerEventType.NORMALIZER);
  new ImplementClassLiteralsAsFields(program).execImpl();
  normalizerEvent.end();
}","public static void exec(JProgram program,boolean shouldOptimize){
  Event normalizerEvent=SpeedTracerLogger.start(CompilerEventType.NORMALIZER);
  new ImplementClassLiteralsAsFields(program,shouldOptimize).execImpl();
  normalizerEvent.end();
}",0.9155555555555556
53429,"@SuppressWarnings(""String_Node_Str"") public void testAnnotatedMessages(){
  TestAnnotatedMessages m=GWT.create(TestAnnotatedMessages.class);
  assertEquals(""String_Node_Str"",m.basicText());
  assertEquals(""String_Node_Str"",m.withMeaning());
  assertEquals(""String_Node_Str"",m.oneArgument(""String_Node_Str""));
  assertEquals(""String_Node_Str"",m.optionalArgument(""String_Node_Str""));
  assertEquals(""String_Node_Str"",m.invertedArguments(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",m.quotedText());
  assertEquals(""String_Node_Str"",m.quotedArg());
  assertEquals(""String_Node_Str"",m.currencyFormat(11305.01));
  assertEquals(""String_Node_Str"",m.defaultNumberFormat(1017.1));
  assertEquals(""String_Node_Str"",m.getTimeDate(new Date(107,11,1,12,1,2)));
  assertEquals(""String_Node_Str"",m.pluralWidgetsOther(13));
}","@SuppressWarnings(""String_Node_Str"") public void testAnnotatedMessages(){
  TestAnnotatedMessages m=GWT.create(TestAnnotatedMessages.class);
  assertEquals(""String_Node_Str"",m.basicText());
  assertEquals(""String_Node_Str"",m.withMeaning());
  assertEquals(""String_Node_Str"",m.oneArgument(""String_Node_Str""));
  assertEquals(""String_Node_Str"",m.optionalArgument(""String_Node_Str""));
  assertEquals(""String_Node_Str"",m.invertedArguments(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",m.quotedText());
  assertEquals(""String_Node_Str"",m.quotedArg());
  assertEquals(""String_Node_Str"",m.currencyFormat(11305.01));
  assertEquals(""String_Node_Str"",m.defaultNumberFormat(1017.1));
  assertEquals(""String_Node_Str"",m.defaultNumberFormattedAsInteger(1017.1));
  assertEquals(""String_Node_Str"",m.getTimeDate(new Date(107,11,1,12,1,2)));
  assertEquals(""String_Node_Str"",m.pluralWidgetsOther(13));
}",0.9560251284980013
53430,"/** 
 * Takes as input an unresolved Java AST (a Java AST wherein all rebind result classes are available and have not yet been pruned down to the set applicable for a particular permutation) that was previously constructed by the Precompiler and from that constructs output Js source code and related information. This Js source and related information is packaged into a Permutation instance and then returned. Permutation compilation is INTENDED to progress as a series of stages: <pre> 1. initialize local state 2. transform unresolved Java AST to resolved Java AST 3. normalize the resolved Java AST 4. optimize the resolved Java AST 5. construct the Js AST 6. normalize the Js AST 7. optimize the Js AST 8. generate Js source 9. construct and return a value </pre> There are some other types of work here (mostly metrics and data gathering) which do not serve the goal of output program construction. This work should really be moved into subclasses or some sort of callback or plugin system so as not to visually pollute the real compile logic.<br /> Significant amounts of visitors implementing the intended above stages are triggered here but in the wrong order. They have been noted for future cleanup.
 */
private PermutationResult compilePermutation(Permutation permutation,UnifiedAst unifiedAst) throws UnableToCompleteException {
  Event jjsCompilePermutationEvent=SpeedTracerLogger.start(CompilerEventType.JJS_COMPILE_PERMUTATION,""String_Node_Str"",permutation.getProperties().prettyPrint());
  long permStartMs=System.currentTimeMillis();
  try {
    Event javaEvent=SpeedTracerLogger.start(CompilerEventType.PERMUTATION_JAVA);
    long startTimeMs=System.currentTimeMillis();
    PermutationProperties properties=permutation.getProperties();
    int permutationId=permutation.getId();
    AST ast=unifiedAst.getFreshAst();
    jprogram=ast.getJProgram();
    jsProgram=ast.getJsProgram();
    Map<StandardSymbolData,JsName> symbolTable=new TreeMap<StandardSymbolData,JsName>(new SymbolData.ClassIdentComparator());
    logger.log(TreeLogger.INFO,""String_Node_Str"" + permutationId + ""String_Node_Str"");
    ResolveRebinds.exec(jprogram,permutation.getGwtCreateAnswers());
    Multimap<String,Integer> instrumentableLines=null;
    if (System.getProperty(""String_Node_Str"") != null) {
      instrumentableLines=BaselineCoverageGatherer.exec(jprogram);
    }
    jprogram.typeOracle.setJsInteropMode(compilerContext.getOptions().getJsInteropMode());
    maybeRecordReferencesAndControlFlow(false);
    CompileTimeConstantsReplacer.exec(jprogram);
    optimizeJava();
    TypeMapper<?> typeMapper=normalizeSemantics();
    postNormalizationOptimizeJava();
    maybeRecordReferencesAndControlFlow(true);
    jprogram.typeOracle.recomputeAfterOptimizations(jprogram.getDeclaredTypes());
    javaEvent.end();
    Event javaScriptEvent=SpeedTracerLogger.start(CompilerEventType.PERMUTATION_JAVASCRIPT);
    Pair<? extends JavaToJavaScriptMap,Set<JsNode>> jjsMapAndInlineableFunctions=GenerateJavaScriptAST.exec(logger,jprogram,jsProgram,compilerContext,typeMapper,symbolTable,properties);
    JavaToJavaScriptMap jjsmap=jjsMapAndInlineableFunctions.getLeft();
    if (System.getProperty(""String_Node_Str"") != null) {
      CoverageInstrumentor.exec(jsProgram,instrumentableLines);
    }
    JsNormalizer.exec(jsProgram);
    JsSymbolResolver.exec(jsProgram);
    if (options.getNamespace() == JsNamespaceOption.PACKAGE) {
      JsNamespaceChooser.exec(jsProgram,jjsmap);
    }
    EvalFunctionsAtTopScope.exec(jsProgram,jjsmap);
    final Set<JsNode> inlinableJsFunctions=jjsMapAndInlineableFunctions.getRight();
    optimizeJs(inlinableJsFunctions);
    JsStackEmulator.exec(jprogram,jsProgram,properties,jjsmap);
    Pair<SyntheticArtifact,MultipleDependencyGraphRecorder> dependenciesAndRecorder=splitJsIntoFragments(properties,permutationId,jjsmap);
    Map<JsName,JsLiteral> internedLiteralByVariableName=renameJsSymbols(properties,jjsmap);
    JsBreakUpLargeVarStatements.exec(jsProgram,properties.getConfigurationProperties());
    List<JsSourceMap> sourceInfoMaps=new ArrayList<JsSourceMap>();
    boolean isSourceMapsEnabled=properties.isTrueInAnyPermutation(""String_Node_Str"");
    String[] jsFragments=new String[jsProgram.getFragmentCount()];
    StatementRanges[] ranges=new StatementRanges[jsFragments.length];
    SizeBreakdown[] sizeBreakdowns=options.isJsonSoycEnabled() || options.isSoycEnabled() || options.isCompilerMetricsEnabled() ? new SizeBreakdown[jsFragments.length] : null;
    generateJavaScriptCode(jjsmap,jsFragments,ranges,sizeBreakdowns,sourceInfoMaps,isSourceMapsEnabled || options.isJsonSoycEnabled());
    javaScriptEvent.end();
    PermutationResult permutationResult=new PermutationResultImpl(jsFragments,permutation,makeSymbolMap(symbolTable),ranges);
    addSyntheticArtifacts(unifiedAst,permutation,startTimeMs,permutationId,jjsmap,dependenciesAndRecorder,internedLiteralByVariableName,isSourceMapsEnabled,jsFragments,sizeBreakdowns,sourceInfoMaps,permutationResult);
    return permutationResult;
  }
 catch (  Throwable e) {
    throw CompilationProblemReporter.logAndTranslateException(logger,e);
  }
 finally {
    jjsCompilePermutationEvent.end();
    if (logger.isLoggable(TreeLogger.TRACE)) {
      logger.log(TreeLogger.TRACE,""String_Node_Str"" + (System.currentTimeMillis() - permStartMs) + ""String_Node_Str"");
    }
  }
}","/** 
 * Takes as input an unresolved Java AST (a Java AST wherein all rebind result classes are available and have not yet been pruned down to the set applicable for a particular permutation) that was previously constructed by the Precompiler and from that constructs output Js source code and related information. This Js source and related information is packaged into a Permutation instance and then returned. Permutation compilation is INTENDED to progress as a series of stages: <pre> 1. initialize local state 2. transform unresolved Java AST to resolved Java AST 3. normalize the resolved Java AST 4. optimize the resolved Java AST 5. construct the Js AST 6. normalize the Js AST 7. optimize the Js AST 8. generate Js source 9. construct and return a value </pre> There are some other types of work here (mostly metrics and data gathering) which do not serve the goal of output program construction. This work should really be moved into subclasses or some sort of callback or plugin system so as not to visually pollute the real compile logic.<br /> Significant amounts of visitors implementing the intended above stages are triggered here but in the wrong order. They have been noted for future cleanup.
 */
private PermutationResult compilePermutation(Permutation permutation,UnifiedAst unifiedAst) throws UnableToCompleteException {
  Event jjsCompilePermutationEvent=SpeedTracerLogger.start(CompilerEventType.JJS_COMPILE_PERMUTATION,""String_Node_Str"",permutation.getProperties().prettyPrint());
  long permStartMs=System.currentTimeMillis();
  try {
    Event javaEvent=SpeedTracerLogger.start(CompilerEventType.PERMUTATION_JAVA);
    long startTimeMs=System.currentTimeMillis();
    PermutationProperties properties=permutation.getProperties();
    int permutationId=permutation.getId();
    AST ast=unifiedAst.getFreshAst();
    jprogram=ast.getJProgram();
    jsProgram=ast.getJsProgram();
    Map<StandardSymbolData,JsName> symbolTable=new TreeMap<StandardSymbolData,JsName>(new SymbolData.ClassIdentComparator());
    logger.log(TreeLogger.INFO,""String_Node_Str"" + permutationId + ""String_Node_Str"");
    ResolveRebinds.exec(jprogram,permutation.getGwtCreateAnswers());
    Multimap<String,Integer> instrumentableLines=null;
    if (System.getProperty(""String_Node_Str"") != null) {
      instrumentableLines=BaselineCoverageGatherer.exec(jprogram);
    }
    jprogram.typeOracle.setJsInteropMode(compilerContext.getOptions().getJsInteropMode());
    maybeRecordReferencesAndControlFlow(false);
    CompileTimeConstantsReplacer.exec(jprogram);
    optimizeJava();
    TypeMapper<?> typeMapper=normalizeSemantics();
    postNormalizationOptimizeJava();
    maybeRecordReferencesAndControlFlow(true);
    javaEvent.end();
    Event javaScriptEvent=SpeedTracerLogger.start(CompilerEventType.PERMUTATION_JAVASCRIPT);
    Pair<? extends JavaToJavaScriptMap,Set<JsNode>> jjsMapAndInlineableFunctions=GenerateJavaScriptAST.exec(logger,jprogram,jsProgram,compilerContext,typeMapper,symbolTable,properties);
    JavaToJavaScriptMap jjsmap=jjsMapAndInlineableFunctions.getLeft();
    if (System.getProperty(""String_Node_Str"") != null) {
      CoverageInstrumentor.exec(jsProgram,instrumentableLines);
    }
    JsNormalizer.exec(jsProgram);
    JsSymbolResolver.exec(jsProgram);
    if (options.getNamespace() == JsNamespaceOption.PACKAGE) {
      JsNamespaceChooser.exec(jsProgram,jjsmap);
    }
    EvalFunctionsAtTopScope.exec(jsProgram,jjsmap);
    final Set<JsNode> inlinableJsFunctions=jjsMapAndInlineableFunctions.getRight();
    optimizeJs(inlinableJsFunctions);
    JsStackEmulator.exec(jprogram,jsProgram,properties,jjsmap);
    Pair<SyntheticArtifact,MultipleDependencyGraphRecorder> dependenciesAndRecorder=splitJsIntoFragments(properties,permutationId,jjsmap);
    Map<JsName,JsLiteral> internedLiteralByVariableName=renameJsSymbols(properties,jjsmap);
    JsBreakUpLargeVarStatements.exec(jsProgram,properties.getConfigurationProperties());
    List<JsSourceMap> sourceInfoMaps=new ArrayList<JsSourceMap>();
    boolean isSourceMapsEnabled=properties.isTrueInAnyPermutation(""String_Node_Str"");
    String[] jsFragments=new String[jsProgram.getFragmentCount()];
    StatementRanges[] ranges=new StatementRanges[jsFragments.length];
    SizeBreakdown[] sizeBreakdowns=options.isJsonSoycEnabled() || options.isSoycEnabled() || options.isCompilerMetricsEnabled() ? new SizeBreakdown[jsFragments.length] : null;
    generateJavaScriptCode(jjsmap,jsFragments,ranges,sizeBreakdowns,sourceInfoMaps,isSourceMapsEnabled || options.isJsonSoycEnabled());
    javaScriptEvent.end();
    PermutationResult permutationResult=new PermutationResultImpl(jsFragments,permutation,makeSymbolMap(symbolTable),ranges);
    addSyntheticArtifacts(unifiedAst,permutation,startTimeMs,permutationId,jjsmap,dependenciesAndRecorder,internedLiteralByVariableName,isSourceMapsEnabled,jsFragments,sizeBreakdowns,sourceInfoMaps,permutationResult);
    return permutationResult;
  }
 catch (  Throwable e) {
    throw CompilationProblemReporter.logAndTranslateException(logger,e);
  }
 finally {
    jjsCompilePermutationEvent.end();
    if (logger.isLoggable(TreeLogger.TRACE)) {
      logger.log(TreeLogger.TRACE,""String_Node_Str"" + (System.currentTimeMillis() - permStartMs) + ""String_Node_Str"");
    }
  }
}",0.9923177815252014
53431,"private void postNormalizationOptimizeJava(){
  Event event=SpeedTracerLogger.start(CompilerEventType.JAVA_POST_NORMALIZER_OPTIMIZERS);
  try {
    if (shouldOptimize()) {
      RemoveSpecializations.exec(jprogram);
      Pruner.exec(jprogram,false);
    }
    ReplaceGetClassOverrides.exec(jprogram);
  }
  finally {
    event.end();
  }
}","private void postNormalizationOptimizeJava(){
  Event event=SpeedTracerLogger.start(CompilerEventType.JAVA_POST_NORMALIZER_OPTIMIZERS);
  try {
    if (shouldOptimize()) {
      RemoveSpecializations.exec(jprogram);
      Pruner.exec(jprogram,false);
      jprogram.typeOracle.recomputeAfterOptimizations(jprogram.getDeclaredTypes());
    }
    ReplaceGetClassOverrides.exec(jprogram);
  }
  finally {
    event.end();
  }
}",0.8900523560209425
53432,"/** 
 * Construct a bare-bones deserialized external class.
 */
JClassType(String name){
  super(SourceOrigin.UNKNOWN,name);
  isAbstract=false;
  isFinal=false;
  setExternal(true);
}","/** 
 * Construct a bare-bones deserialized external class.
 */
JClassType(String name){
  super(SourceOrigin.UNKNOWN,name);
  isAbstract=false;
  isFinal=false;
  isJso=name.equals(JProgram.JAVASCRIPTOBJECT);
  setExternal(true);
}",0.8846153846153846
53433,"/** 
 * Sets this type's super class.
 */
public final void setSuperClass(JClassType superClass){
  this.superClass=superClass;
}","/** 
 * Sets this type's super class.
 */
public final void setSuperClass(JClassType superClass){
}",0.868421052631579
53434,"/** 
 * If the type is a JSO or an array of JSOs it returns cggcc.JavaScriptObject or an array of cggcc.JavaScriptObject respectively; otherwise returns   {@code type}.
 */
public JType normalizeJsoType(JType type){
  type=type.getUnderlyingType();
  if (type instanceof JArrayType) {
    return getOrCreateArrayType(normalizeJsoType(((JArrayType)type).getLeafType()),((JArrayType)type).getDims());
  }
  if (typeOracle.isJavaScriptObject(type)) {
    return getJavaScriptObject();
  }
  return type;
}","/** 
 * If the type is a JSO or an array of JSOs it returns cggcc.JavaScriptObject or an array of cggcc.JavaScriptObject respectively; otherwise returns   {@code type}.
 */
public JType normalizeJsoType(JType type){
  type=type.getUnderlyingType();
  if (type instanceof JArrayType) {
    return getOrCreateArrayType(normalizeJsoType(((JArrayType)type).getLeafType()),((JArrayType)type).getDims());
  }
  if (type.isJsoType()) {
    return getJavaScriptObject();
  }
  return type;
}",0.9197969543147207
53435,"public JField getClassLiteralField(JType type){
  return classLiteralFieldsByType.get(typeOracle.isJavaScriptObject(type) ? getJavaScriptObject() : type);
}","public JField getClassLiteralField(JType type){
  return classLiteralFieldsByType.get(type.isJsoType() ? getJavaScriptObject() : type);
}",0.9078498293515358
53436,"AnalysisResult getAnalysisResult(){
  if (isFinal()) {
    return AnalysisResult.NULLABLE_EXACT;
  }
  return AnalysisResult.NULLABLE_NOT_EXACT;
}","AnalysisResult getAnalysisResult(){
  if (isFinal() && !isJsoType()) {
    return AnalysisResult.NULLABLE_EXACT;
  }
  return AnalysisResult.NULLABLE_NOT_EXACT;
}",0.948051948051948
53437,"/** 
 * If this type is a non-null type, returns the underlying (original) type.
 */
public JReferenceType getUnderlyingType(){
  return this;
}","/** 
 * If this type is a non-null type, returns the underlying (original) type.
 */
@Override public JReferenceType getUnderlyingType(){
  return this;
}",0.9664429530201344
53438,"/** 
 * This method should be called after altering the types that are live in the associated JProgram.
 */
public void recomputeAfterOptimizations(Collection<JDeclaredType> declaredTypes){
  Set<JDeclaredType> computed=Sets.newIdentityHashSet();
  if (hasWholeWorldKnowledge) {
    if (optimize) {
      for (      JDeclaredType type : declaredTypes) {
        computeClinitTarget(type,computed);
      }
    }
    nextDual:     for (Iterator<String> it=dualImplInterfaces.iterator(); it.hasNext(); ) {
      String dualIntf=it.next();
      for (      String implementorName : classesByImplementingInterface.get(dualIntf)) {
        JClassType implementor=(JClassType)referenceTypesByName.get(implementorName);
        if (isInstantiatedType(implementor) && !isJavaScriptObject(implementor)) {
          continue nextDual;
        }
      }
      it.remove();
    }
    Iterator<Entry<String,String>> jit=jsoByInterface.entrySet().iterator();
    while (jit.hasNext()) {
      Entry<String,String> jsoSingleImplEntry=jit.next();
      JClassType clazz=(JClassType)referenceTypesByName.get(jsoSingleImplEntry.getValue());
      if (isInstantiatedType(clazz)) {
        continue;
      }
      dualImplInterfaces.remove(jsoSingleImplEntry.getKey());
      jit.remove();
    }
  }
}","/** 
 * This method should be called after altering the types that are live in the associated JProgram.
 */
public void recomputeAfterOptimizations(Collection<JDeclaredType> declaredTypes){
}",0.2595108695652174
53439,"/** 
 * True if either a JSO, or is an interface that is ONLY implemented by a JSO.
 */
public boolean isEffectivelyJavaScriptObject(JType type){
  if (type instanceof JReferenceType) {
    JReferenceType refType=(JReferenceType)type;
    return isJavaScriptObject(refType) || (isSingleJsoImpl(refType) && !isDualJsoInterface(refType));
  }
 else {
    return false;
  }
}","/** 
 * True if either a JSO, or is an interface that is ONLY implemented by a JSO.
 */
public boolean isEffectivelyJavaScriptObject(JType type){
  return type.isJsoType() || (isSingleJsoImpl(type) && !isDualJsoInterface(type));
}",0.6976744186046512
53440,"/** 
 * True if the type is a JSO or interface implemented by JSO or a JsType without prototype.
 */
public boolean canBeJavaScriptObject(JType type){
  type=type.getUnderlyingType();
  return isJavaScriptObject(type) || isSingleJsoImpl(type);
}","/** 
 * True if the type is a JSO or interface implemented by JSO or a JsType without prototype.
 */
public boolean canBeJavaScriptObject(JType type){
  type=type.getUnderlyingType();
  return type.isJsoType() || isSingleJsoImpl(type);
}",0.921161825726141
53441,"/** 
 * Create the mapping from a class to the types it can be cast to.
 */
private void computeCastMap(JReferenceType type){
  if (type == null || alreadyRan.contains(type)) {
    return;
  }
  assert(type == type.getUnderlyingType());
  alreadyRan.add(type);
  if (type instanceof JClassType) {
    computeCastMap(((JClassType)type).getSuperClass());
  }
  if (!typeOracle.isInstantiatedType(type) || typeOracle.isJavaScriptObject(type)) {
    return;
  }
  Set<JReferenceType> castableTypes=new TreeSet<JReferenceType>(HasName.BY_NAME_COMPARATOR);
  for (  JReferenceType castTargetType : castSourceTypesPerCastTargetType.keySet()) {
    if (!canTriviallyCastJsoSemantics(type,castTargetType)) {
      continue;
    }
    Collection<JReferenceType> castSourceTypes=castSourceTypesPerCastTargetType.get(castTargetType);
    for (    JReferenceType castSourceType : castSourceTypes) {
      if (canTriviallyCastJsoSemantics(type,castSourceType) || typeOracle.isJavaScriptObject(castTargetType)) {
        boolean isTrivialCast=castTargetType == program.getTypeJavaLangObject() || castTargetType == program.getJavaScriptObject();
        if (recordTrivialCasts || !isTrivialCast) {
          castableTypes.add(castTargetType);
        }
        break;
      }
    }
  }
  if (castableTypes.isEmpty() && type != program.getTypeJavaLangObject() && type != program.getTypeJavaLangString()) {
    return;
  }
  castableTypesMap.put(type,new JCastMap(SourceOrigin.UNKNOWN,program.getTypeJavaLangObject(),Collections.unmodifiableSet(castableTypes)));
}","/** 
 * Create the mapping from a class to the types it can be cast to.
 */
private void computeCastMap(JReferenceType type){
  if (type == null || alreadyRan.contains(type)) {
    return;
  }
  assert(type == type.getUnderlyingType());
  alreadyRan.add(type);
  if (type instanceof JClassType) {
    computeCastMap(((JClassType)type).getSuperClass());
  }
  if (!typeOracle.isInstantiatedType(type) || type.isJsoType()) {
    return;
  }
  Set<JReferenceType> castableTypes=new TreeSet<JReferenceType>(HasName.BY_NAME_COMPARATOR);
  for (  JReferenceType castTargetType : castSourceTypesPerCastTargetType.keySet()) {
    if (!castSucceedsTriviallyJsoSemantics(type,castTargetType)) {
      continue;
    }
    Collection<JReferenceType> castSourceTypes=castSourceTypesPerCastTargetType.get(castTargetType);
    for (    JReferenceType castSourceType : castSourceTypes) {
      if (castSucceedsTriviallyJsoSemantics(type,castSourceType) || castTargetType.isJsoType()) {
        boolean isTrivialCast=castTargetType == program.getTypeJavaLangObject() || castTargetType == program.getJavaScriptObject();
        if (recordTrivialCasts || !isTrivialCast) {
          castableTypes.add(castTargetType);
        }
        break;
      }
    }
  }
  if (castableTypes.isEmpty() && type != program.getTypeJavaLangObject() && type != program.getTypeJavaLangString()) {
    return;
  }
  castableTypesMap.put(type,new JCastMap(SourceOrigin.UNKNOWN,program.getTypeJavaLangObject(),Collections.unmodifiableSet(castableTypes)));
}",0.8074412532637075
53442,"private void instantiateJsoInterface(JReferenceType toType){
  if (instantiatedJsoTypes.add(toType)) {
    if (program.typeOracle.getSingleJsoImpl(toType) != null) {
      instantiateJsoInterface(program.typeOracle.getSingleJsoImpl(toType));
    }
    if (toType instanceof JClassType) {
      JClassType superType=((JClassType)toType).getSuperClass();
      if (superType != null && program.typeOracle.isJavaScriptObject(superType)) {
        instantiateJsoInterface(superType);
      }
    }
    for (    JInterfaceType intf : ((JDeclaredType)toType).getImplements()) {
      if (intf.isJsType() || program.typeOracle.getSingleJsoImpl(intf) != null) {
        instantiateJsoInterface(intf);
      }
    }
  }
}","private void instantiateJsoInterface(JReferenceType toType){
  if (instantiatedJsoTypes.add(toType)) {
    if (program.typeOracle.getSingleJsoImpl(toType) != null) {
      instantiateJsoInterface(program.typeOracle.getSingleJsoImpl(toType));
    }
    if (toType instanceof JClassType) {
      JClassType superType=((JClassType)toType).getSuperClass();
      if (superType != null && superType.isJsoType()) {
        instantiateJsoInterface(superType);
      }
    }
    for (    JInterfaceType intf : ((JDeclaredType)toType).getImplements()) {
      if (intf.isJsType() || program.typeOracle.getSingleJsoImpl(intf) != null) {
        instantiateJsoInterface(intf);
      }
    }
  }
}",0.9520400858983536
53443,"public boolean castFailsTrivially(JReferenceType fromType,JReferenceType toType){
  if (!fromType.canBeNull() && toType.isNullType()) {
    return true;
  }
  fromType=fromType.getUnderlyingType();
  toType=toType.getUnderlyingType();
  if (fromType == toType || isJavaLangObject(toType)) {
    return false;
  }
  if (canCrossCastLikeJso(fromType) && canCrossCastLikeJso(toType)) {
    return false;
  }
  if (castSucceedsTrivially(fromType,toType)) {
    return false;
  }
  if (fromType instanceof JArrayType) {
    JArrayType fromArrayType=(JArrayType)fromType;
    if (toType instanceof JArrayType) {
      JArrayType toArrayType=(JArrayType)toType;
      JType fromLeafType=fromArrayType.getLeafType();
      JType toLeafType=toArrayType.getLeafType();
      int fromDims=fromArrayType.getDims();
      int toDims=toArrayType.getDims();
      if (fromDims < toDims && !isJavaLangObject(fromLeafType) && !fromLeafType.isNullType()) {
        return true;
      }
      if (fromDims == toDims && fromLeafType instanceof JReferenceType && toLeafType instanceof JReferenceType) {
        return castFailsTrivially((JReferenceType)fromLeafType,(JReferenceType)toLeafType);
      }
    }
  }
 else   if (fromType instanceof JClassType) {
    JClassType cType=(JClassType)fromType;
    if (toType instanceof JClassType) {
      return !isSubClass(cType,(JClassType)toType);
    }
 else     if (toType instanceof JInterfaceType) {
      return !potentialInterfaceByClass.containsEntry(cType.getName(),toType.getName());
    }
  }
 else   if (fromType instanceof JInterfaceType) {
    JInterfaceType fromInterfaceType=(JInterfaceType)fromType;
    if (toType instanceof JClassType) {
      return !potentialInterfaceByClass.containsEntry(toType.getName(),fromInterfaceType.getName());
    }
  }
  return false;
}","public boolean castFailsTrivially(JReferenceType fromType,JReferenceType toType){
  if (!fromType.canBeNull() && toType.isNullType()) {
    return true;
  }
  fromType=fromType.getUnderlyingType();
  toType=toType.getUnderlyingType();
  if (fromType == toType || isJavaLangObject(fromType)) {
    return false;
  }
  if (canCrossCastLikeJso(fromType) && canCrossCastLikeJso(toType)) {
    return false;
  }
  if (castSucceedsTrivially(fromType,toType)) {
    return false;
  }
  if (fromType instanceof JArrayType) {
    JArrayType fromArrayType=(JArrayType)fromType;
    if (toType instanceof JArrayType) {
      JArrayType toArrayType=(JArrayType)toType;
      JType fromLeafType=fromArrayType.getLeafType();
      JType toLeafType=toArrayType.getLeafType();
      int fromDims=fromArrayType.getDims();
      int toDims=toArrayType.getDims();
      if (fromDims < toDims && !isJavaLangObject(fromLeafType) && !fromLeafType.isNullType()) {
        return true;
      }
      if (fromDims == toDims && fromLeafType instanceof JReferenceType && toLeafType instanceof JReferenceType) {
        return castFailsTrivially((JReferenceType)fromLeafType,(JReferenceType)toLeafType);
      }
    }
  }
 else   if (fromType instanceof JClassType) {
    JClassType cType=(JClassType)fromType;
    if (toType instanceof JClassType) {
      return !isSubClass(cType,(JClassType)toType);
    }
 else     if (toType instanceof JInterfaceType) {
      return !potentialInterfaceByClass.containsEntry(cType.getName(),toType.getName());
    }
  }
 else   if (fromType instanceof JInterfaceType) {
    JInterfaceType fromInterfaceType=(JInterfaceType)fromType;
    if (toType instanceof JClassType) {
      return !potentialInterfaceByClass.containsEntry(toType.getName(),fromInterfaceType.getName());
    }
  }
  return false;
}",0.998342541436464
53444,"private static void addDays(Date date,int days){
  CalendarUtil.addDaysToDate(date,days);
  if (date.getHours() != 0) {
    date.setHours(0);
  }
}","private static void addDays(Date date,int days){
  CalendarUtil.addDaysToDate(date,days);
  CalendarUtil.resetTime(date);
}",0.7555555555555555
53445,"/** 
 * Detects if the requested time falls into a non-existent time range due to local time advancing into daylight savings time or is ambiguous due to going out of daylight savings. If so, adjust accordingly.
 */
private void fixDaylightSavings(int requestedHours){
  int hours=jsdate.getHours();
  if ((hours % 24) != (requestedHours % 24)) {
    JsDate copy=JsDate.create(jsdate.getTime());
    copy.setDate(copy.getDate() + 1);
    int timeDiff=jsdate.getTimezoneOffset() - copy.getTimezoneOffset();
    if (timeDiff > 0) {
      int timeDiffHours=timeDiff / 60;
      int timeDiffMinutes=timeDiff % 60;
      int day=jsdate.getDate();
      int badHours=jsdate.getHours();
      if (badHours + timeDiffHours >= 24) {
        day++;
      }
      JsDate newTime=JsDate.create(jsdate.getFullYear(),jsdate.getMonth(),day,requestedHours + timeDiffHours,jsdate.getMinutes() + timeDiffMinutes,jsdate.getSeconds(),jsdate.getMilliseconds());
      jsdate.setTime(newTime.getTime());
    }
    return;
  }
  double originalTimeInMillis=jsdate.getTime();
  jsdate.setTime(originalTimeInMillis + ONE_HOUR_IN_MILLISECONDS);
  if (hours != jsdate.getHours()) {
    jsdate.setTime(originalTimeInMillis);
  }
}","/** 
 * Detects if the requested time falls into a non-existent time range due to local time advancing into daylight savings time or is ambiguous due to going out of daylight savings. If so, adjust accordingly.
 */
private void fixDaylightSavings(int requestedHours){
  requestedHours%=24;
  if (jsdate.getHours() != requestedHours) {
    JsDate copy=JsDate.create(jsdate.getTime());
    copy.setDate(copy.getDate() + 1);
    int timeDiff=jsdate.getTimezoneOffset() - copy.getTimezoneOffset();
    if (timeDiff > 0) {
      int timeDiffHours=timeDiff / 60;
      int timeDiffMinutes=timeDiff % 60;
      int day=jsdate.getDate();
      int badHours=jsdate.getHours();
      if (badHours + timeDiffHours >= 24) {
        day++;
      }
      JsDate newTime=JsDate.create(jsdate.getFullYear(),jsdate.getMonth(),day,requestedHours + timeDiffHours,jsdate.getMinutes() + timeDiffMinutes,jsdate.getSeconds(),jsdate.getMilliseconds());
      jsdate.setTime(newTime.getTime());
    }
  }
  double originalTimeInMillis=jsdate.getTime();
  jsdate.setTime(originalTimeInMillis + ONE_HOUR_IN_MILLISECONDS);
  if (jsdate.getHours() != requestedHours) {
    jsdate.setTime(originalTimeInMillis);
  }
}",0.9355108877721944
53446,"@Override public Map<AbstractResource,ResourceResolution> findApplicableResources(TreeLogger logger,PathPrefixSet pathPrefixSet){
  try {
    return ResourceAccumulatorManager.get(this,pathPrefixSet).getResources();
  }
 catch (  IOException e) {
    logger.log(TreeLogger.WARN,""String_Node_Str"" + dir + ""String_Node_Str"",e);
    return Maps.newLinkedHashMap();
  }
}","@Override public Map<AbstractResource,ResourceResolution> findApplicableResources(TreeLogger logger,PathPrefixSet pathPrefixSet){
  try {
    return ResourceAccumulatorManager.get(this,pathPrefixSet).getResources();
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + dir + ""String_Node_Str"");
    e.printStackTrace();
    return Maps.newLinkedHashMap();
  }
}",0.9025367156208278
53447,"private void onNewDirectory(Path directory) throws IOException {
  String relativePath=getRelativePath(directory);
  if (!relativePath.isEmpty() && !getPathPrefixSet().includesDirectory(relativePath)) {
    return;
  }
  if (WATCH_FILE_CHANGES) {
    directory.register(watchService,ENTRY_CREATE,ENTRY_DELETE);
  }
  try (DirectoryStream<Path> stream=Files.newDirectoryStream(directory)){
    for (    Path child : stream) {
      childPathsByParentPath.put(directory,child);
      onNewPath(child);
    }
  }
 }","private void onNewDirectory(Path directory) throws IOException {
  String relativePath=getRelativePath(directory);
  if (!relativePath.isEmpty() && !getPathPrefixSet().includesDirectory(relativePath)) {
    return;
  }
  if (watchService != null) {
    directory.register(watchService,ENTRY_CREATE,ENTRY_DELETE);
  }
  try (DirectoryStream<Path> stream=Files.newDirectoryStream(directory)){
    for (    Path child : stream) {
      childPathsByParentPath.put(directory,child);
      onNewPath(child);
    }
  }
 }",0.9649122807017544
53448,"/** 
 * Full refresh clears existing resources and watchers and does a clean refresh.
 */
private void fullRefresh() throws IOException {
  resolutionsByResource=Maps.newIdentityHashMap();
  childPathsByParentPath=ArrayListMultimap.create();
  stopWatchService();
  if (WATCH_FILE_CHANGES) {
    watchService=FileSystems.getDefault().newWatchService();
  }
  onNewDirectory(rootDirectory);
}","/** 
 * Full refresh clears existing resources and watchers and does a clean refresh.
 */
private void fullRefresh() throws IOException {
  resolutionsByResource=Maps.newIdentityHashMap();
  childPathsByParentPath=ArrayListMultimap.create();
  maybeInitializeWatchService();
  onNewDirectory(rootDirectory);
}",0.84
53449,"private String compileToJs(CompilerOptions compilerOptions,File applicationDir,String moduleName,List<MockResource> applicationResources,MinimalRebuildCache minimalRebuildCache,Set<String> expectedProcessedStaleTypeNames,JsOutputOption output) throws IOException, UnableToCompleteException, InterruptedException {
  System.setProperty(UnitCacheSingleton.GWT_PERSISTENTUNITCACHE,""String_Node_Str"");
  Thread.sleep(1001);
  PrintWriterTreeLogger logger=new PrintWriterTreeLogger();
  logger.setMaxDetail(TreeLogger.ERROR);
  File outputDir=new File(applicationDir.getPath() + File.separator + moduleName);
  if (outputDir.exists()) {
    Util.recursiveDelete(outputDir,true);
  }
  ResourceLoader resourceLoader=ResourceLoaders.forClassLoader(Thread.currentThread());
  resourceLoader=ResourceLoaders.forPathAndFallback(ImmutableList.of(applicationDir),resourceLoader);
  compilerOptions.setIncrementalCompileEnabled(true);
  compilerOptions.setWarDir(applicationDir);
  compilerOptions.setModuleNames(ImmutableList.of(moduleName));
  compilerOptions.setOutput(output);
  CompilerContext compilerContext=new CompilerContext.Builder().options(compilerOptions).minimalRebuildCache(minimalRebuildCache).build();
  for (  MockResource applicationResource : applicationResources) {
    writeResourceTo(applicationResource,applicationDir);
  }
  ModuleDefLoader.clearModuleCache();
  ModuleDefLoader.loadFromResources(logger,compilerContext,moduleName,resourceLoader,true);
  Compiler compiler=new Compiler(compilerOptions,minimalRebuildCache);
  compiler.run(logger);
  File outputJsFile=null;
  outputDir=new File(applicationDir.getPath() + File.separator + moduleName);
  if (outputDir.exists()) {
    for (    File outputFile : outputDir.listFiles()) {
      if (outputFile.getPath().endsWith(""String_Node_Str"")) {
        outputJsFile=outputFile;
        break;
      }
    }
  }
  if (outputJsFile == null) {
    throw new UnableToCompleteException();
  }
  if (expectedProcessedStaleTypeNames != null) {
    assertEquals(expectedProcessedStaleTypeNames,minimalRebuildCache.getProcessedStaleTypeNames());
  }
  return Files.toString(outputJsFile,Charsets.UTF_8);
}","private String compileToJs(CompilerOptions compilerOptions,File applicationDir,String moduleName,List<MockResource> applicationResources,MinimalRebuildCache minimalRebuildCache,Set<String> expectedProcessedStaleTypeNames,JsOutputOption output) throws IOException, UnableToCompleteException, InterruptedException {
  System.setProperty(UnitCacheSingleton.GWT_PERSISTENTUNITCACHE,""String_Node_Str"");
  Thread.sleep(1001);
  PrintWriterTreeLogger logger=new PrintWriterTreeLogger();
  logger.setMaxDetail(TreeLogger.WARN);
  File outputDir=new File(applicationDir.getPath() + File.separator + moduleName);
  if (outputDir.exists()) {
    Util.recursiveDelete(outputDir,true);
  }
  ResourceLoader resourceLoader=ResourceLoaders.forClassLoader(Thread.currentThread());
  resourceLoader=ResourceLoaders.forPathAndFallback(ImmutableList.of(applicationDir),resourceLoader);
  compilerOptions.setIncrementalCompileEnabled(true);
  compilerOptions.setWarDir(applicationDir);
  compilerOptions.setModuleNames(ImmutableList.of(moduleName));
  compilerOptions.setOutput(output);
  CompilerContext compilerContext=new CompilerContext.Builder().options(compilerOptions).minimalRebuildCache(minimalRebuildCache).build();
  for (  MockResource applicationResource : applicationResources) {
    writeResourceTo(applicationResource,applicationDir);
  }
  ModuleDefLoader.clearModuleCache();
  ModuleDefLoader.loadFromResources(logger,compilerContext,moduleName,resourceLoader,true);
  Compiler compiler=new Compiler(compilerOptions,minimalRebuildCache);
  compiler.run(logger);
  File outputJsFile=null;
  outputDir=new File(applicationDir.getPath() + File.separator + moduleName);
  if (outputDir.exists()) {
    for (    File outputFile : outputDir.listFiles()) {
      if (outputFile.getPath().endsWith(""String_Node_Str"")) {
        outputJsFile=outputFile;
        break;
      }
    }
  }
  if (outputJsFile == null) {
    throw new UnableToCompleteException();
  }
  if (expectedProcessedStaleTypeNames != null) {
    assertEquals(expectedProcessedStaleTypeNames,minimalRebuildCache.getProcessedStaleTypeNames());
  }
  return Files.toString(outputJsFile,Charsets.UTF_8);
}",0.998380754105945
53450,"@Override protected void setUp() throws Exception {
  super.setUp();
  FooResourceGenerator.runCount=0;
  BarReferencesFooGenerator.runCount=0;
  CauseStringRebindGenerator.runCount=0;
  CauseShortRebindGenerator.runCount=0;
}","@Override protected void setUp() throws Exception {
  super.setUp();
  FooResourceGenerator.runCount=0;
  BarReferencesFooGenerator.runCount=0;
  CauseStringRebindGenerator.runCount=0;
  CauseShortRebindGenerator.runCount=0;
  System.gc();
}",0.9678800856531048
53451,"private void assertDeterministicBuild(String topLevelModule,int optimizationLevel) throws UnableToCompleteException, IOException {
  final CompilerOptionsImpl options=new CompilerOptionsImpl();
  options.setOptimizationLevel(optimizationLevel);
  File firstCompileWorkDir=Utility.makeTemporaryDirectory(null,""String_Node_Str"");
  File secondCompileWorkDir=Utility.makeTemporaryDirectory(null,""String_Node_Str"");
  String oldPersistentUnitCacheValue=System.setProperty(UnitCacheSingleton.GWT_PERSISTENTUNITCACHE,""String_Node_Str"");
  try {
    options.addModuleName(topLevelModule);
    options.setWarDir(new File(firstCompileWorkDir,""String_Node_Str""));
    options.setExtraDir(new File(firstCompileWorkDir,""String_Node_Str""));
    TreeLogger logger=TreeLogger.NULL;
    new Compiler(options).run(logger);
    Set<String> firstTimeOutput=Sets.newHashSet(new File(options.getWarDir() + ""String_Node_Str"").list());
    options.setWarDir(new File(secondCompileWorkDir,""String_Node_Str""));
    options.setExtraDir(new File(secondCompileWorkDir,""String_Node_Str""));
    new Compiler(options).run(logger);
    Set<String> secondTimeOutput=Sets.newHashSet(new File(options.getWarDir() + ""String_Node_Str"").list());
    assertEquals(""String_Node_Str"",firstTimeOutput,secondTimeOutput);
  }
  finally {
    if (oldPersistentUnitCacheValue == null) {
      System.clearProperty(UnitCacheSingleton.GWT_PERSISTENTUNITCACHE);
    }
 else {
      System.setProperty(UnitCacheSingleton.GWT_PERSISTENTUNITCACHE,oldPersistentUnitCacheValue);
    }
    Util.recursiveDelete(firstCompileWorkDir,false);
    Util.recursiveDelete(secondCompileWorkDir,false);
  }
}","private void assertDeterministicBuild(String topLevelModule,int optimizationLevel) throws UnableToCompleteException, IOException {
  final CompilerOptionsImpl options=new CompilerOptionsImpl();
  options.setOptimizationLevel(optimizationLevel);
  File firstCompileWorkDir=Utility.makeTemporaryDirectory(null,""String_Node_Str"");
  File secondCompileWorkDir=Utility.makeTemporaryDirectory(null,""String_Node_Str"");
  String oldPersistentUnitCacheValue=System.setProperty(UnitCacheSingleton.GWT_PERSISTENTUNITCACHE,""String_Node_Str"");
  try {
    options.addModuleName(topLevelModule);
    options.setWarDir(new File(firstCompileWorkDir,""String_Node_Str""));
    options.setExtraDir(new File(firstCompileWorkDir,""String_Node_Str""));
    PrintWriterTreeLogger logger=new PrintWriterTreeLogger();
    logger.setMaxDetail(TreeLogger.WARN);
    new Compiler(options).run(logger);
    Set<String> firstTimeOutput=Sets.newHashSet(new File(options.getWarDir() + ""String_Node_Str"").list());
    options.setWarDir(new File(secondCompileWorkDir,""String_Node_Str""));
    options.setExtraDir(new File(secondCompileWorkDir,""String_Node_Str""));
    new Compiler(options).run(logger);
    Set<String> secondTimeOutput=Sets.newHashSet(new File(options.getWarDir() + ""String_Node_Str"").list());
    assertEquals(""String_Node_Str"",firstTimeOutput,secondTimeOutput);
  }
  finally {
    if (oldPersistentUnitCacheValue == null) {
      System.clearProperty(UnitCacheSingleton.GWT_PERSISTENTUNITCACHE);
    }
 else {
      System.setProperty(UnitCacheSingleton.GWT_PERSISTENTUNITCACHE,oldPersistentUnitCacheValue);
    }
    Util.recursiveDelete(firstCompileWorkDir,false);
    Util.recursiveDelete(secondCompileWorkDir,false);
  }
}",0.9782154580722172
53452,"public String getQualifiedExportName(){
  if (enclosingType == null) {
    return jsNamespace == null || jsNamespace.isEmpty() ? getName() : jsNamespace + ""String_Node_Str"" + getLeafName();
  }
 else {
    return enclosingType.getQualifiedExportName() + ""String_Node_Str"" + getLeafName();
  }
}","public String getQualifiedExportName(){
  if (enclosingType == null && jsNamespace == null) {
    return getName();
  }
  String namespace=jsNamespace == null ? enclosingType.getQualifiedExportName() : jsNamespace;
  return namespace.isEmpty() ? getSimpleName() : namespace + ""String_Node_Str"" + getSimpleName();
}",0.5822368421052632
53453,"private Object readResolve(){
  JConstructor result=new JConstructor(SourceOrigin.UNKNOWN,enclosingType);
  result.signature=signature;
  return result;
}","private Object readResolve(){
  JConstructor result=new JConstructor(SourceOrigin.UNKNOWN,enclosingType,AccessModifier.PUBLIC);
  result.signature=signature;
  return result;
}",0.9333333333333332
53454,"public JConstructor(SourceInfo info,JClassType enclosingType){
  super(info,enclosingType.getShortName(),enclosingType,JPrimitiveType.VOID,false,false,true,AccessModifier.PUBLIC);
}","public JConstructor(SourceInfo info,JClassType enclosingType,AccessModifier access){
  super(info,enclosingType.getShortName(),enclosingType,JPrimitiveType.VOID,false,false,true,access);
}",0.8943089430894309
53455,"JMethod createConstructor(SourceInfo info,MethodBinding b){
  JDeclaredType enclosingType=(JDeclaredType)get(b.declaringClass);
  JMethod method=new JConstructor(info,(JClassType)enclosingType);
  enclosingType.addMethod(method);
  int argPosition=0;
  ReferenceBinding declaringClass=b.declaringClass;
  if (declaringClass.isNestedType() && !declaringClass.isStatic()) {
    if (declaringClass.syntheticEnclosingInstanceTypes() != null) {
      for (      ReferenceBinding argType : declaringClass.syntheticEnclosingInstanceTypes()) {
        createParameter(info,argType,method,argPosition++);
      }
    }
  }
  argPosition=mapParameters(info,method,b,argPosition);
  if (declaringClass.isNestedType() && !declaringClass.isStatic()) {
    if (declaringClass.syntheticOuterLocalVariables() != null) {
      for (      SyntheticArgumentBinding arg : declaringClass.syntheticOuterLocalVariables()) {
        createParameter(info,arg.type,method,argPosition++);
      }
    }
  }
  mapExceptions(method,b);
  if (b.isSynthetic()) {
    method.setSynthetic();
  }
  return method;
}","JMethod createConstructor(SourceInfo info,MethodBinding b){
  JDeclaredType enclosingType=(JDeclaredType)get(b.declaringClass);
  JMethod method=new JConstructor(info,(JClassType)enclosingType,AccessModifier.fromMethodBinding(b));
  enclosingType.addMethod(method);
  int argPosition=0;
  ReferenceBinding declaringClass=b.declaringClass;
  if (declaringClass.isNestedType() && !declaringClass.isStatic()) {
    if (declaringClass.syntheticEnclosingInstanceTypes() != null) {
      for (      ReferenceBinding argType : declaringClass.syntheticEnclosingInstanceTypes()) {
        createParameter(info,argType,method,argPosition++);
      }
    }
  }
  argPosition=mapParameters(info,method,b,argPosition);
  if (declaringClass.isNestedType() && !declaringClass.isStatic()) {
    if (declaringClass.syntheticOuterLocalVariables() != null) {
      for (      SyntheticArgumentBinding arg : declaringClass.syntheticOuterLocalVariables()) {
        createParameter(info,arg.type,method,argPosition++);
      }
    }
  }
  mapExceptions(method,b);
  if (b.isSynthetic()) {
    method.setSynthetic();
  }
  return method;
}",0.983621474067334
53456,"private void assertCompileFails(){
  try {
    optimize(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
    assertTrue(e.getCause() instanceof UnableToCompleteException);
  }
}","private void assertCompileFails(){
  try {
    optimize(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
    assertTrue(e.getCause() instanceof UnableToCompleteException || e instanceof UnableToCompleteException);
  }
}",0.9142857142857144
53457,"/** 
 * Invokes FragmentExtractor with a fragment description claiming that Bar was not made live by the current fragment, but that it has a constructor which *was* made live. Verifies that the defineClass invocation from the global JS block *is* included in the extracted statement output.
 */
public void testDefineClass_DeadTypeLiveConstructor(){
  FragmentExtractor fragmentExtractor;
  LivenessPredicate constructorLivePredicate;
{
    SourceInfo nullSourceInfo=new MockSourceInfo();
    final JClassType barType=new JClassType(nullSourceInfo,""String_Node_Str"",false,false);
    final JsName barConstructorName=new JsName(null,""String_Node_Str"",""String_Node_Str"");
    final JConstructor barConstructor=new JConstructor(nullSourceInfo,barType);
    Map<String,JsFunction> functionsByName=new HashMap<String,JsFunction>();
    functionsByName.put(""String_Node_Str"",new JsFunction(nullSourceInfo,new JsRootScope(),DEFINE_CLASS_FUNCTION_NAME));
    final JsExprStmt defineClassStatement=createDefineClassStatement(barConstructorName);
    JsProgram jsProgram=new JsProgram();
    jsProgram.setIndexedFunctions(functionsByName);
    jsProgram.getGlobalBlock().getStatements().add(defineClassStatement);
    JavaToJavaScriptMap map=new MockJavaToJavaScriptMap(){
      @Override public JMethod nameToMethod(      JsName name){
        if (name == barConstructorName) {
          return barConstructor;
        }
        return null;
      }
      @Override public JClassType typeForStatement(      JsStatement statement){
        if (statement == defineClassStatement) {
          return barType;
        }
        return null;
      }
    }
;
    fragmentExtractor=new FragmentExtractor(null,jsProgram,map);
    constructorLivePredicate=new MockLivenessPredicate(){
      @Override public boolean isLive(      JDeclaredType type){
        return false;
      }
      @Override public boolean isLive(      JMethod method){
        return method == barConstructor;
      }
    }
;
  }
  List<JsStatement> extractedStatements=fragmentExtractor.extractStatements(constructorLivePredicate,new NothingAlivePredicate());
  assertEquals(1,extractedStatements.size());
  JsStatement defineClassStatement=extractedStatements.get(0);
  assertTrue(defineClassStatement.toString().contains(""String_Node_Str""));
}","/** 
 * Invokes FragmentExtractor with a fragment description claiming that Bar was not made live by the current fragment, but that it has a constructor which *was* made live. Verifies that the defineClass invocation from the global JS block *is* included in the extracted statement output.
 */
public void testDefineClass_DeadTypeLiveConstructor(){
  FragmentExtractor fragmentExtractor;
  LivenessPredicate constructorLivePredicate;
{
    SourceInfo nullSourceInfo=new MockSourceInfo();
    final JClassType barType=new JClassType(nullSourceInfo,""String_Node_Str"",false,false);
    final JsName barConstructorName=new JsName(null,""String_Node_Str"",""String_Node_Str"");
    final JConstructor barConstructor=new JConstructor(nullSourceInfo,barType,AccessModifier.PUBLIC);
    Map<String,JsFunction> functionsByName=new HashMap<String,JsFunction>();
    functionsByName.put(""String_Node_Str"",new JsFunction(nullSourceInfo,new JsRootScope(),DEFINE_CLASS_FUNCTION_NAME));
    final JsExprStmt defineClassStatement=createDefineClassStatement(barConstructorName);
    JsProgram jsProgram=new JsProgram();
    jsProgram.setIndexedFunctions(functionsByName);
    jsProgram.getGlobalBlock().getStatements().add(defineClassStatement);
    JavaToJavaScriptMap map=new MockJavaToJavaScriptMap(){
      @Override public JMethod nameToMethod(      JsName name){
        if (name == barConstructorName) {
          return barConstructor;
        }
        return null;
      }
      @Override public JClassType typeForStatement(      JsStatement statement){
        if (statement == defineClassStatement) {
          return barType;
        }
        return null;
      }
    }
;
    fragmentExtractor=new FragmentExtractor(null,jsProgram,map);
    constructorLivePredicate=new MockLivenessPredicate(){
      @Override public boolean isLive(      JDeclaredType type){
        return false;
      }
      @Override public boolean isLive(      JMethod method){
        return method == barConstructor;
      }
    }
;
  }
  List<JsStatement> extractedStatements=fragmentExtractor.extractStatements(constructorLivePredicate,new NothingAlivePredicate());
  assertEquals(1,extractedStatements.size());
  JsStatement defineClassStatement=extractedStatements.get(0);
  assertTrue(defineClassStatement.toString().contains(""String_Node_Str""));
}",0.99524015577672
53458,"public T accept(Lambda<T> foo){
  return foo.run(10,20);
}",void accept(TestLambda_Inner t);,0.4222222222222222
53459,"void f(){
  Ctor c=X2::new;
  X2 x=c.makeX(123456);
  assertEquals(123456,x.field);
  c=Y::new;
  x=c.makeX(987654);
  x=new Y(987654);
  assertEquals(987655,x.field);
  c=Z::new;
  x=c.makeX(456789);
  x=new Z(456789);
  assertEquals(456791,x.field);
}",void f();,0.0687022900763358
53460,"private boolean isGetter(String name,MethodBinding mb){
  if (name.length() > 3 && name.startsWith(""String_Node_Str"") && Character.isUpperCase(name.charAt(3)) && mb.returnType == TypeBinding.VOID && mb.parameters.length == 0) {
    return true;
  }
 else   if (name.length() > 3 && name.startsWith(""String_Node_Str"") && Character.isUpperCase(name.charAt(2)) && mb.returnType == TypeBinding.BOOLEAN && mb.parameters.length == 0) {
    return true;
  }
 else   if (mb.parameters.length == 0 && mb.returnType != TypeBinding.VOID) {
    return true;
  }
  return false;
}","private boolean isGetter(String methodName,MethodBinding methodBinding){
  if (methodBinding.parameters.length > 0 || methodBinding.returnType == TypeBinding.VOID) {
    return false;
  }
  if (startsWithCamelCase(methodName,""String_Node_Str"")) {
    return false;
  }
  if ((startsWithCamelCase(methodName,""String_Node_Str"") || startsWithCamelCase(methodName,""String_Node_Str"")) && methodBinding.returnType != TypeBinding.BOOLEAN) {
    return false;
  }
  return true;
}",0.3272377285851781
53461,"private void checkJsTypeMethodsForOverloads(Map<String,MethodBinding> methodNamesAndSigs,Map<String,MethodBinding> noExports,ReferenceBinding binding){
  if (isJsType(binding)) {
    for (    MethodBinding mb : binding.methods()) {
      String methodName=String.valueOf(mb.selector);
      if (JdtUtil.getAnnotation(mb,JsInteropUtil.JSNOEXPORT_CLASS) != null) {
        noExports.put(methodName,mb);
        continue;
      }
      if (mb.isConstructor() || mb.isStatic()) {
        continue;
      }
      if (JdtUtil.getAnnotation(mb,JsInteropUtil.JSPROPERTY_CLASS) != null) {
        if (isGetter(methodName,mb) || isSetter(methodName,mb) || isHas(methodName,mb)) {
          continue;
        }
      }
      if (methodNamesAndSigs.containsKey(methodName)) {
        if (!methodNamesAndSigs.get(methodName).areParameterErasuresEqual(mb)) {
          if (noExports.containsKey(methodName) && noExports.get(methodName).areParameterErasuresEqual(mb)) {
            continue;
          }
          errorOn(mb,ERR_JSTYPE_OVERLOADS_NOT_ALLOWED);
        }
      }
 else {
        methodNamesAndSigs.put(methodName,mb);
      }
    }
  }
  for (  ReferenceBinding rb : binding.superInterfaces()) {
    checkJsTypeMethodsForOverloads(methodNamesAndSigs,noExports,rb);
  }
}","private void checkJsTypeMethodsForOverloads(Map<String,MethodBinding> methodNamesAndSigs,Map<String,MethodBinding> noExports,ReferenceBinding binding){
  if (isJsType(binding)) {
    for (    MethodBinding mb : binding.methods()) {
      String methodName=String.valueOf(mb.selector);
      if (JdtUtil.getAnnotation(mb,JsInteropUtil.JSNOEXPORT_CLASS) != null) {
        noExports.put(methodName,mb);
        continue;
      }
      if (mb.isConstructor() || mb.isStatic()) {
        continue;
      }
      if (JdtUtil.getAnnotation(mb,JsInteropUtil.JSPROPERTY_CLASS) != null) {
        if (isGetter(methodName,mb) || isSetter(methodName,mb)) {
          continue;
        }
      }
      if (methodNamesAndSigs.containsKey(methodName)) {
        if (!methodNamesAndSigs.get(methodName).areParameterErasuresEqual(mb)) {
          if (noExports.containsKey(methodName) && noExports.get(methodName).areParameterErasuresEqual(mb)) {
            continue;
          }
          errorOn(mb,ERR_JSTYPE_OVERLOADS_NOT_ALLOWED);
        }
      }
 else {
        methodNamesAndSigs.put(methodName,mb);
      }
    }
  }
  for (  ReferenceBinding rb : binding.superInterfaces()) {
    checkJsTypeMethodsForOverloads(methodNamesAndSigs,noExports,rb);
  }
}",0.9904610492845788
53462,"private void checkJsProperty(MethodBinding mb,boolean allowed){
  AnnotationBinding jsProperty=JdtUtil.getAnnotation(mb,JsInteropUtil.JSPROPERTY_CLASS);
  if (jsProperty != null) {
    if (!allowed) {
      errorOn(mb,ERR_JSPROPERTY_ONLY_ON_INTERFACES);
      return;
    }
    String methodName=String.valueOf(mb.selector);
    if (!isGetter(methodName,mb) && !isSetter(methodName,mb) && !isHas(methodName,mb)) {
      errorOn(mb,ERR_JSPROPERTY_ONLY_BEAN_OR_FLUENT_STYLE_NAMING);
    }
  }
}","private void checkJsProperty(MethodBinding mb,boolean allowed){
  AnnotationBinding jsProperty=JdtUtil.getAnnotation(mb,JsInteropUtil.JSPROPERTY_CLASS);
  if (jsProperty != null) {
    if (!allowed) {
      errorOn(mb,ERR_JSPROPERTY_ONLY_ON_INTERFACES);
      return;
    }
    String methodName=String.valueOf(mb.selector);
    if (!isGetter(methodName,mb) && !isSetter(methodName,mb)) {
      errorOn(mb,ERR_JSPROPERTY_ONLY_BEAN_OR_FLUENT_STYLE_NAMING);
    }
  }
}",0.9739311783107404
53463,"private boolean isSetter(String name,MethodBinding mb){
  if (mb.returnType == TypeBinding.VOID || mb.returnType == mb.declaringClass) {
    if (name.length() > 3 && name.startsWith(""String_Node_Str"") && Character.isUpperCase(name.charAt(3)) && mb.parameters.length == 1) {
      return true;
    }
 else     if (mb.parameters.length == 1) {
      return true;
    }
  }
  return false;
}","private boolean isSetter(String methodName,MethodBinding methodBinding){
  if (methodBinding.parameters.length != 1) {
    return false;
  }
  if (startsWithCamelCase(methodName,""String_Node_Str"") || startsWithCamelCase(methodName,""String_Node_Str"") || startsWithCamelCase(methodName,""String_Node_Str"")) {
    return false;
  }
  if (methodBinding.returnType != TypeBinding.VOID && methodBinding.returnType != methodBinding.declaringClass) {
    return false;
  }
  return true;
}",0.347926267281106
53464,"public void testJsPropertyNoErrors(){
  StringBuilder buggyCode=new StringBuilder();
  buggyCode.append(""String_Node_Str"");
  buggyCode.append(""String_Node_Str"");
  buggyCode.append(""String_Node_Str"");
  buggyCode.append(""String_Node_Str"");
  buggyCode.append(""String_Node_Str"");
  buggyCode.append(""String_Node_Str"");
  buggyCode.append(""String_Node_Str"");
  buggyCode.append(""String_Node_Str"");
  buggyCode.append(""String_Node_Str"");
  buggyCode.append(""String_Node_Str"");
  shouldGenerateNoError(buggyCode);
}","public void testJsPropertyNoErrors(){
  StringBuilder buggyCode=new StringBuilder();
  buggyCode.append(""String_Node_Str"");
  buggyCode.append(""String_Node_Str"");
  buggyCode.append(""String_Node_Str"");
  buggyCode.append(""String_Node_Str"");
  buggyCode.append(""String_Node_Str"");
  buggyCode.append(""String_Node_Str"");
  buggyCode.append(""String_Node_Str"");
  buggyCode.append(""String_Node_Str"");
  buggyCode.append(""String_Node_Str"");
  buggyCode.append(""String_Node_Str"");
  buggyCode.append(""String_Node_Str"");
  shouldGenerateNoError(buggyCode);
}",0.9633113828786454
53465,"String mangleName(JField x){
  String s=getNameString(x.getEnclosingType()) + '_' + getNameString(x);
  return s;
}","String mangleName(JField x){
  String s=JjsUtils.getNameString(x.getEnclosingType()) + '_' + JjsUtils.getNameString(x);
  return s;
}",0.9274193548387096
53466,"String mangleNameForGlobal(JMethod x){
  String s=getNameString(x.getEnclosingType()) + '_' + getNameString(x)+ ""String_Node_Str"";
  for (int i=0; i < x.getOriginalParamTypes().size(); ++i) {
    JType type=x.getOriginalParamTypes().get(i);
    s+=type.getJavahSignatureName();
  }
  s+=x.getOriginalReturnType().getJavahSignatureName();
  return StringInterner.get().intern(s);
}","String mangleNameForGlobal(JMethod x){
  String s=JjsUtils.getNameString(x.getEnclosingType()) + '_' + JjsUtils.getNameString(x)+ ""String_Node_Str"";
  for (int i=0; i < x.getOriginalParamTypes().size(); ++i) {
    JType type=x.getOriginalParamTypes().get(i);
    s+=type.getJavahSignatureName();
  }
  s+=x.getOriginalReturnType().getJavahSignatureName();
  return StringInterner.get().intern(s);
}",0.9768637532133676
53467,"private String exportProvidedNamespace(JDeclaredType x,List<JsStatement> globalStmts,String lastProvidedNamespace,Pair<String,String> exportNamespacePair){
  if (!exportNamespacePair.getLeft().equals(lastProvidedNamespace)) {
    if (jsInteropMode == OptionJsInteropMode.Mode.JS) {
      JsName provideFunc=indexedFunctions.get(""String_Node_Str"").getName();
      JsNameRef provideFuncRef=provideFunc.makeRef(x.getSourceInfo());
      JsInvocation provideCall=new JsInvocation(x.getSourceInfo());
      provideCall.setQualifier(provideFuncRef);
      provideCall.getArguments().add(new JsStringLiteral(x.getSourceInfo(),exportNamespacePair.getLeft()));
      JsExprStmt provideStat=createAssignment(globalTemp.makeRef(x.getSourceInfo()),provideCall).makeStmt();
      globalStmts.add(provideStat);
    }
 else     if (jsInteropMode == OptionJsInteropMode.Mode.JS && jsExportClosureStyle) {
      if (x.getEnclosingType() != null) {
        JsNameRef lhs=getExportLhsQualifier(x,x.getQualifiedExportName());
        JsNameRef rhsRef=getExportLhsQualifier(x,x.getQualifiedExportName());
        globalStmts.add(createAssignment(lhs,new JsBinaryOperation(x.getSourceInfo(),JsBinaryOperator.OR,rhsRef,new JsObjectLiteral(x.getSourceInfo()))).makeStmt());
      }
    }
    lastProvidedNamespace=exportNamespacePair.getLeft();
  }
  return lastProvidedNamespace;
}","private String exportProvidedNamespace(JDeclaredType x,List<JsStatement> globalStmts,String lastProvidedNamespace,Pair<String,String> exportNamespacePair){
  if (!exportNamespacePair.getLeft().equals(lastProvidedNamespace)) {
    if (!jsExportClosureStyle) {
      JsName provideFunc=indexedFunctions.get(""String_Node_Str"").getName();
      JsNameRef provideFuncRef=provideFunc.makeRef(x.getSourceInfo());
      JsInvocation provideCall=new JsInvocation(x.getSourceInfo());
      provideCall.setQualifier(provideFuncRef);
      provideCall.getArguments().add(new JsStringLiteral(x.getSourceInfo(),exportNamespacePair.getLeft()));
      JsExprStmt provideStat=createAssignment(globalTemp.makeRef(x.getSourceInfo()),provideCall).makeStmt();
      globalStmts.add(provideStat);
    }
 else {
      if (x.getEnclosingType() != null) {
        JsNameRef lhs=getExportLhsQualifier(x,x.getQualifiedExportName());
        JsNameRef rhsRef=getExportLhsQualifier(x,x.getQualifiedExportName());
        globalStmts.add(createAssignment(lhs,new JsBinaryOperation(x.getSourceInfo(),JsBinaryOperator.OR,rhsRef,new JsObjectLiteral(x.getSourceInfo()))).makeStmt());
      }
    }
    lastProvidedNamespace=exportNamespacePair.getLeft();
  }
  return lastProvidedNamespace;
}",0.5640045854031334
53468,"/** 
 * A callback after the JDT compiler has compiled a .java file and created a matching CompilationUnitDeclaration. We take this opportunity to create a matching CompilationUnit.
 */
@Override public void process(CompilationUnitBuilder builder,CompilationUnitDeclaration cud,List<ImportReference> cudOriginaImports,List<CompiledClass> compiledClasses){
  Event event=SpeedTracerLogger.start(DevModeEventType.CSB_PROCESS);
  try {
    List<JDeclaredType> types=ImmutableList.of();
    final Set<String> jsniDeps=Sets.newHashSet();
    final Map<String,Binding> jsniRefs=Maps.newHashMap();
    Map<MethodDeclaration,JsniMethod> jsniMethods=ImmutableMap.of();
    List<String> apiRefs=ImmutableList.of();
    MethodArgNamesLookup methodArgs=new MethodArgNamesLookup();
    if (!cud.compilationResult().hasErrors()) {
      jsniMethods=JsniMethodCollector.collectJsniMethods(cud,builder.getSourceMapPath(),builder.getSource(),JsRootScope.INSTANCE,DummyCorrelationFactory.INSTANCE);
      JSORestrictionsChecker.check(jsoState,cud);
      JsniReferenceResolver.resolve(cud,cudOriginaImports,jsniMethods,jsniRefs,new JsniReferenceResolver.TypeResolver(){
        @Override public ReferenceBinding resolveType(        String sourceOrBinaryName){
          ReferenceBinding resolveType=compiler.resolveType(sourceOrBinaryName);
          if (resolveType != null) {
            jsniDeps.add(String.valueOf(resolveType.qualifiedSourceName()));
          }
          return resolveType;
        }
      }
);
      BinaryTypeReferenceRestrictionsChecker.check(cud);
      if (!cud.compilationResult().hasErrors()) {
        types=astBuilder.process(cud,builder.getSourceMapPath(),jsniMethods,jsniRefs,compilerContext);
      }
      methodArgs=MethodParamCollector.collect(cud,builder.getSourceMapPath());
    }
    apiRefs=compiler.collectApiRefs(cud);
    final Interner<String> interner=StringInterner.get();
    String packageName=interner.intern(Shared.getPackageName(builder.getTypeName()));
    List<String> unresolvedSimple=Lists.newArrayList();
    for (    char[] simpleRef : cud.compilationResult().simpleNameReferences) {
      unresolvedSimple.add(interner.intern(String.valueOf(simpleRef)));
    }
    List<String> unresolvedQualified=Lists.newArrayList();
    for (    char[][] qualifiedRef : cud.compilationResult().qualifiedReferences) {
      unresolvedQualified.add(interner.intern(CharOperation.toString(qualifiedRef)));
    }
    for (    String jsniDep : jsniDeps) {
      unresolvedQualified.add(interner.intern(jsniDep));
    }
    for (int i=0; i < apiRefs.size(); ++i) {
      apiRefs.set(i,interner.intern(apiRefs.get(i)));
    }
    Dependencies dependencies=new Dependencies(packageName,unresolvedQualified,unresolvedSimple,apiRefs);
    for (    CompiledClass cc : compiledClasses) {
      allValidClasses.put(cc.getSourceName(),cc);
    }
    builder.setTypes(types).setDependencies(dependencies).setJsniMethods(jsniMethods.values()).setMethodArgs(methodArgs).setClasses(compiledClasses).setProblems(cud.compilationResult().getProblems());
    buildQueue.add(builder);
  }
  finally {
    event.end();
  }
}","/** 
 * A callback after the JDT compiler has compiled a .java file and created a matching CompilationUnitDeclaration. We take this opportunity to create a matching CompilationUnit.
 */
@Override public void process(CompilationUnitBuilder builder,CompilationUnitDeclaration cud,List<ImportReference> cudOriginaImports,List<CompiledClass> compiledClasses){
  Event event=SpeedTracerLogger.start(DevModeEventType.CSB_PROCESS);
  try {
    List<JDeclaredType> types=ImmutableList.of();
    final Set<String> jsniDeps=Sets.newHashSet();
    final Map<String,Binding> jsniRefs=Maps.newHashMap();
    Map<MethodDeclaration,JsniMethod> jsniMethods=ImmutableMap.of();
    List<String> apiRefs=ImmutableList.of();
    MethodArgNamesLookup methodArgs=new MethodArgNamesLookup();
    if (!cud.compilationResult().hasErrors()) {
      jsniMethods=JsniMethodCollector.collectJsniMethods(cud,builder.getSourceMapPath(),builder.getSource(),JsRootScope.INSTANCE,DummyCorrelationFactory.INSTANCE);
      JSORestrictionsChecker.check(jsoState,cud);
      JsniReferenceResolver.resolve(cud,cudOriginaImports,jsniMethods,jsniRefs,new JsniReferenceResolver.TypeResolver(){
        @Override public ReferenceBinding resolveType(        String sourceOrBinaryName){
          ReferenceBinding resolveType=compiler.resolveType(sourceOrBinaryName);
          if (resolveType != null) {
            jsniDeps.add(String.valueOf(resolveType.qualifiedSourceName()));
          }
          return resolveType;
        }
      }
);
      BinaryTypeReferenceRestrictionsChecker.check(cud);
      if (!cud.compilationResult().hasErrors()) {
        types=GwtAstBuilder.process(cud,builder.getSourceMapPath(),jsniMethods,jsniRefs,compilerContext);
      }
      methodArgs=MethodParamCollector.collect(cud,builder.getSourceMapPath());
    }
    apiRefs=compiler.collectApiRefs(cud);
    final Interner<String> interner=StringInterner.get();
    String packageName=interner.intern(Shared.getPackageName(builder.getTypeName()));
    List<String> unresolvedSimple=Lists.newArrayList();
    for (    char[] simpleRef : cud.compilationResult().simpleNameReferences) {
      unresolvedSimple.add(interner.intern(String.valueOf(simpleRef)));
    }
    List<String> unresolvedQualified=Lists.newArrayList();
    for (    char[][] qualifiedRef : cud.compilationResult().qualifiedReferences) {
      unresolvedQualified.add(interner.intern(CharOperation.toString(qualifiedRef)));
    }
    for (    String jsniDep : jsniDeps) {
      unresolvedQualified.add(interner.intern(jsniDep));
    }
    for (int i=0; i < apiRefs.size(); ++i) {
      apiRefs.set(i,interner.intern(apiRefs.get(i)));
    }
    Dependencies dependencies=new Dependencies(packageName,unresolvedQualified,unresolvedSimple,apiRefs);
    for (    CompiledClass cc : compiledClasses) {
      allValidClasses.put(cc.getSourceName(),cc);
    }
    builder.setTypes(types).setDependencies(dependencies).setJsniMethods(jsniMethods.values()).setMethodArgs(methodArgs).setClasses(compiledClasses).setProblems(cud.compilationResult().getProblems());
    buildQueue.add(builder);
  }
  finally {
    event.end();
  }
}",0.9992014055262738
53469,"@Override public JType getType(){
  return field.getType();
}","@Override public JType getType(){
}",0.7291666666666666
53470,"public CudInfo(CompilationUnitDeclaration cud){
  separatorPositions=cud.compilationResult().getLineSeparatorPositions();
  scope=cud.scope;
}","public CudInfo(CompilationUnitDeclaration cud){
  separatorPositions=cud.compilationResult().getLineSeparatorPositions();
  scope=cud.scope;
  this.cud=cud;
}",0.9466666666666668
53471,"/** 
 * Builds all the GWT AST nodes that correspond to one Java source file.
 * @param cud The compiled form of the Java source from the JDT.
 * @param sourceMapPath the path that should be included in a sourcemap.
 * @param jsniMethods Native methods to add to the AST.
 * @param jsniRefs Map from JSNI references to their JDT definitions.
 * @param compilerContext the compiler context.
 * @return All the types seen in this source file.
 */
public List<JDeclaredType> process(CompilationUnitDeclaration cud,String sourceMapPath,Map<MethodDeclaration,JsniMethod> jsniMethods,Map<String,Binding> jsniRefs,CompilerContext compilerContext){
  if (cud.types == null) {
    return Collections.emptyList();
  }
  this.sourceMapPath=sourceMapPath;
  this.jsniRefs=jsniRefs;
  this.jsniMethods=jsniMethods;
  this.compilerContext=compilerContext;
  newTypes=Lists.newArrayList();
  curCud=new CudInfo(cud);
  for (  TypeDeclaration typeDecl : cud.types) {
    createTypes(typeDecl);
  }
  javaLangObject=(JClassType)typeMap.get(cud.scope.getJavaLangObject());
  javaLangString=(JClassType)typeMap.get(cud.scope.getJavaLangString());
  javaLangClass=(JClassType)typeMap.get(cud.scope.getJavaLangClass());
  javaLangThrowable=(JClassType)typeMap.get(cud.scope.getJavaLangThrowable());
  for (  TypeDeclaration typeDecl : cud.types) {
    resolveTypeRefs(typeDecl);
  }
  for (  TypeDeclaration typeDecl : cud.types) {
    createMembers(typeDecl);
  }
  for (  TypeDeclaration typeDecl : cud.types) {
    typeDecl.traverse(astVisitor,cud.scope);
  }
  List<JDeclaredType> result=newTypes;
  typeMap.clearSource();
  this.jsniRefs=jsniRefs;
  this.jsniMethods=jsniMethods;
  newTypes=null;
  curCud=null;
  javaLangObject=null;
  javaLangString=null;
  javaLangClass=null;
  javaLangThrowable=null;
  return result;
}","public static List<JDeclaredType> process(CompilationUnitDeclaration cud,String sourceMapPath,Map<MethodDeclaration,JsniMethod> jsniMethods,Map<String,Binding> jsniRefs,CompilerContext compilerContext){
  return new GwtAstBuilder(cud,sourceMapPath,jsniMethods,jsniRefs,compilerContext).processImpl();
}",0.1914691943127962
53472,"@Override public void setUp(){
  sourceLevel=SourceLevel.JAVA8;
  addAll(LAMBDA_METAFACTORY);
  addAll(JavaResourceBase.createMockJavaResource(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  addAll(JavaResourceBase.createMockJavaResource(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  addAll(JavaResourceBase.createMockJavaResource(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  addAll(JavaResourceBase.createMockJavaResource(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  addAll(JavaResourceBase.createMockJavaResource(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","@Override public void setUp(){
  sourceLevel=SourceLevel.JAVA8;
  addAll(LAMBDA_METAFACTORY);
  addAll(JavaResourceBase.createMockJavaResource(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  addAll(JavaResourceBase.createMockJavaResource(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  addAll(JavaResourceBase.createMockJavaResource(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  addAll(JavaResourceBase.createMockJavaResource(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  addAll(JavaResourceBase.createMockJavaResource(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9712765957446808
53473,"private static String computeName(JMethod method){
  return method.getJsniSignature(true,false);
}","private static String computeName(JMethod method){
  return method.getJsniSignature(true,true);
}",0.964102564102564
53474,"/** 
 * Translates and stitches (unifies) type ASTs into one connected graph.<br /> Only types reachable from entry points are traversed. This speeds, saves memory trims unreferenced elements.
 */
public void exec() throws UnableToCompleteException {
  List<String> entryMethodNames=new ArrayList<String>();
  for (  JMethod entryMethod : program.getEntryMethods()) {
    flowInto(entryMethod);
    entryMethodNames.add(entryMethod.getJsniSignature(true,false));
  }
  List<String> rootTypeBinaryNames=new ArrayList<String>();
  for (  String rootTypeSourceName : rootTypeSourceNames) {
    JDeclaredType rootType=internalFindType(rootTypeSourceName,sourceNameBasedTypeLocator,true);
    if (rootType == null) {
      continue;
    }
    rootTypeBinaryNames.add(rootType.getName());
    if (jsInteropEnabled && (isJsType(rootType) || hasAnyExports(rootType))) {
      fullFlowIntoType(rootType);
    }
  }
  minimalRebuildCache.setRootTypeNames(rootTypeBinaryNames);
  minimalRebuildCache.setEntryMethodNames(entryMethodNames);
  for (  JClassType type : program.codeGenTypes) {
    for (    JMethod method : type.getMethods()) {
      flowInto(method);
    }
    for (    JField field : type.getFields()) {
      flowInto(field);
    }
  }
  if (incrementalCompile) {
    fullFlowIntoRemainingStaleTypes();
  }
  instantiate(program.getTypeJavaLangString());
  flowInto(program.getIndexedMethod(""String_Node_Str""));
  mapApi(program.getTypeJavaLangString());
  flowInto(methodMap.get(""String_Node_Str""));
  AutoboxUtils autoboxUtils=new AutoboxUtils(program);
  for (  JMethod method : autoboxUtils.getBoxMethods()) {
    flowInto(method);
  }
  for (  JMethod method : autoboxUtils.getUnboxMethods()) {
    flowInto(method);
  }
  if (compilerContext.getOptions().isRunAsyncEnabled()) {
    flowInto(program.getIndexedMethod(""String_Node_Str""));
    flowInto(program.getIndexedMethod(""String_Node_Str""));
  }
  staticInitialize(program.getTypeClassLiteralHolder());
  for (  JMethod method : program.getTypeJavaLangClass().getMethods()) {
    if (method.isStatic() && method.getName().startsWith(""String_Node_Str"")) {
      flowInto(method);
    }
  }
  mainLoop();
  if (incrementalCompile) {
    int declaredTypesInModule=program.getModuleDeclaredTypes().size();
    MetricName.DECLARED_TYPES_IN_MODULE.setAmount(logger,declaredTypesInModule);
    logger.log(TreeLogger.INFO,""String_Node_Str"" + liveFieldsAndMethods.size() + ""String_Node_Str""+ program.getDeclaredTypes().size()+ ""String_Node_Str""+ declaredTypesInModule+ ""String_Node_Str""+ fullFlowTypes.size()+ ""String_Node_Str"");
    Set<String> remainingStaleTypeNames=computeRemainingStaleTypeNames();
    if (!remainingStaleTypeNames.isEmpty()) {
      logger.log(TreeLogger.WARN,""String_Node_Str"" + remainingStaleTypeNames + ""String_Node_Str""+ ""String_Node_Str"");
    }
    minimalRebuildCache.setProcessedStaleTypeNames(fullFlowTypes);
  }
  computeOverrides();
  pruneDeadFieldsAndMethods();
  if (errorsFound) {
    throw new UnableToCompleteException();
  }
}","/** 
 * Translates and stitches (unifies) type ASTs into one connected graph.<br /> Only types reachable from entry points are traversed. This speeds, saves memory trims unreferenced elements.
 */
public void exec() throws UnableToCompleteException {
  List<String> entryMethodNames=new ArrayList<String>();
  for (  JMethod entryMethod : program.getEntryMethods()) {
    flowInto(entryMethod);
    entryMethodNames.add(entryMethod.getJsniSignature(true,true));
  }
  List<String> rootTypeBinaryNames=new ArrayList<String>();
  for (  String rootTypeSourceName : rootTypeSourceNames) {
    JDeclaredType rootType=internalFindType(rootTypeSourceName,sourceNameBasedTypeLocator,true);
    if (rootType == null) {
      continue;
    }
    rootTypeBinaryNames.add(rootType.getName());
    if (jsInteropEnabled && (isJsType(rootType) || hasAnyExports(rootType))) {
      fullFlowIntoType(rootType);
    }
  }
  minimalRebuildCache.setRootTypeNames(rootTypeBinaryNames);
  minimalRebuildCache.setEntryMethodNames(entryMethodNames);
  for (  JClassType type : program.codeGenTypes) {
    for (    JMethod method : type.getMethods()) {
      flowInto(method);
    }
    for (    JField field : type.getFields()) {
      flowInto(field);
    }
  }
  if (incrementalCompile) {
    fullFlowIntoRemainingStaleTypes();
  }
  instantiate(program.getTypeJavaLangString());
  flowInto(program.getIndexedMethod(""String_Node_Str""));
  mapApi(program.getTypeJavaLangString());
  flowInto(methodMap.get(""String_Node_Str""));
  AutoboxUtils autoboxUtils=new AutoboxUtils(program);
  for (  JMethod method : autoboxUtils.getBoxMethods()) {
    flowInto(method);
  }
  for (  JMethod method : autoboxUtils.getUnboxMethods()) {
    flowInto(method);
  }
  if (compilerContext.getOptions().isRunAsyncEnabled()) {
    flowInto(program.getIndexedMethod(""String_Node_Str""));
    flowInto(program.getIndexedMethod(""String_Node_Str""));
  }
  staticInitialize(program.getTypeClassLiteralHolder());
  for (  JMethod method : program.getTypeJavaLangClass().getMethods()) {
    if (method.isStatic() && method.getName().startsWith(""String_Node_Str"")) {
      flowInto(method);
    }
  }
  mainLoop();
  if (incrementalCompile) {
    int declaredTypesInModule=program.getModuleDeclaredTypes().size();
    MetricName.DECLARED_TYPES_IN_MODULE.setAmount(logger,declaredTypesInModule);
    logger.log(TreeLogger.INFO,""String_Node_Str"" + liveFieldsAndMethods.size() + ""String_Node_Str""+ program.getDeclaredTypes().size()+ ""String_Node_Str""+ declaredTypesInModule+ ""String_Node_Str""+ fullFlowTypes.size()+ ""String_Node_Str"");
    Set<String> remainingStaleTypeNames=computeRemainingStaleTypeNames();
    if (!remainingStaleTypeNames.isEmpty()) {
      logger.log(TreeLogger.WARN,""String_Node_Str"" + remainingStaleTypeNames + ""String_Node_Str""+ ""String_Node_Str"");
    }
    minimalRebuildCache.setProcessedStaleTypeNames(fullFlowTypes);
  }
  computeOverrides();
  pruneDeadFieldsAndMethods();
  if (errorsFound) {
    throw new UnableToCompleteException();
  }
}",0.9988420181968568
53475,"@Override public void endVisit(JParameter x,Context ctx){
  tighten(x);
}","@Override public void endVisit(JParameter x,Context ctx){
  JMethod currentMethod=getCurrentMethod();
  if (program.codeGenTypes.contains(currentMethod.getEnclosingType()) || program.typeOracle.isExportedMethod(currentMethod) || program.typeOracle.isJsTypeMethod(currentMethod)) {
    return;
  }
  tighten(x);
}",0.3324675324675324
53476,"@Override public boolean enter(JMethod x,Context ctx){
  return !program.codeGenTypes.contains(x.getEnclosingType()) && !x.isNative() || program.typeOracle.isJsTypeMethod(x) || program.typeOracle.isExportedMethod(x);
}","@Override public boolean enter(JMethod x,Context ctx){
  return !x.isNative();
}",0.5369127516778524
53477,"/** 
 * Tighten based on assignment, and for parameters, callArgs as well.
 */
private void tighten(JVariable x){
  if (!(x.getType() instanceof JReferenceType)) {
    return;
  }
  JReferenceType refType=(JReferenceType)x.getType();
  if (program.typeOracle.isJsType(refType)) {
    return;
  }
  if (refType == program.getTypeNull()) {
    return;
  }
  if (!program.typeOracle.isInstantiatedType(refType)) {
    x.setType(program.getTypeNull());
    madeChanges();
    return;
  }
  JReferenceType leafType=getSingleConcreteType(refType);
  if (leafType != null) {
    x.setType(leafType);
    madeChanges();
    return;
  }
  List<JReferenceType> typeList=Lists.newArrayList();
  Collection<JExpression> myAssignments=assignments.get(x);
  if (myAssignments != null) {
    for (    JExpression expr : myAssignments) {
      JType type=expr.getType();
      if (!(type instanceof JReferenceType)) {
        return;
      }
      typeList.add((JReferenceType)type);
    }
  }
  if (x instanceof JParameter) {
    Collection<JParameter> myParams=paramUpRefs.get(x);
    if (myParams != null) {
      for (      JParameter param : myParams) {
        typeList.add((JReferenceType)param.getType());
      }
    }
  }
  JReferenceType resultType=program.strengthenType(refType,typeList);
  if (refType != resultType) {
    x.setType(resultType);
    madeChanges();
  }
}","/** 
 * Tighten based on assignment, and for parameters, callArgs as well.
 */
private void tighten(JVariable x){
  if (!(x.getType() instanceof JReferenceType)) {
    return;
  }
  JReferenceType refType=(JReferenceType)x.getType();
  if (refType == program.getTypeNull()) {
    return;
  }
  if (!program.typeOracle.isInstantiatedType(refType)) {
    x.setType(program.getTypeNull());
    madeChanges();
    return;
  }
  JReferenceType leafType=getSingleConcreteType(refType);
  if (leafType != null) {
    x.setType(leafType);
    madeChanges();
    return;
  }
  List<JReferenceType> typeList=Lists.newArrayList();
  Collection<JExpression> myAssignments=assignments.get(x);
  if (myAssignments != null) {
    for (    JExpression expr : myAssignments) {
      JType type=expr.getType();
      if (!(type instanceof JReferenceType)) {
        return;
      }
      typeList.add((JReferenceType)type);
    }
  }
  if (x instanceof JParameter) {
    Collection<JParameter> myParams=paramUpRefs.get(x);
    if (myParams != null) {
      for (      JParameter param : myParams) {
        typeList.add((JReferenceType)param.getType());
      }
    }
  }
  JReferenceType resultType=program.strengthenType(refType,typeList);
  if (refType != resultType) {
    x.setType(resultType);
    madeChanges();
  }
}",0.9768137621540764
53478,"public void testJsExports(){
  ScriptInjector.fromString(""String_Node_Str"").setWindow(ScriptInjector.TOP_WINDOW).inject();
  assertTrue(MyClassImpl2.calledFromJsHostPageWindow);
  ScriptInjector.fromString(""String_Node_Str"").inject();
  assertTrue(MyClassImpl2.calledFromJsModuleWindow);
  ScriptInjector.fromString(""String_Node_Str"").inject();
  assertTrue(MyClassImpl3.calledFromJsModuleWindow);
}","public void testJsExports(){
  ScriptInjector.fromString(""String_Node_Str"").setWindow(ScriptInjector.TOP_WINDOW).inject();
  assertTrue(MyClassImpl2.calledFromJsHostPageWindow);
  ScriptInjector.fromString(""String_Node_Str"").inject();
  assertTrue(MyClassImpl2.calledFromJsModuleWindow);
  ScriptInjector.fromString(""String_Node_Str"").inject();
  assertTrue(MyClassImpl3.calledFromJsModuleWindow);
  ScriptInjector.fromString(""String_Node_Str"").inject();
  assertTrue(MyClassImpl3.calledFromBar);
}",0.8896321070234113
53479,"@Override public boolean supportsDevModeInJunit(LinkerContext context){
  return (getHostedFilename() != ""String_Node_Str"");
}","@Override public boolean supportsDevModeInJunit(LinkerContext context){
  return !""String_Node_Str"".equals(getHostedFilename());
}",0.8203125
53480,"@Override public void endVisit(final JsniMethodBody jsniMethodBody,Context ctx){
}","@Override public void endVisit(JsNameRef x,JsContext ctx){
  if (!x.isJsniReference()) {
    return;
  }
  if (jsniClassLiteralsByJsniReference.get(x.getIdent()).isEmpty()) {
    return;
  }
  JsniClassLiteral jsniClassLiteral=jsniClassLiteralsByJsniReference.get(x.getIdent()).iterator().next();
  jsniClassLiteralsByJsniReference.remove(x.getIdent(),jsniClassLiteral);
  if (jsniClassLiteral.getRefType() instanceof JArrayType) {
    JArrayType arrayType=(JArrayType)jsniClassLiteral.getRefType();
    JType leafType=arrayType.getLeafType();
    jsniClassLiteral=new JsniClassLiteral(jsniClassLiteral.getSourceInfo(),leafType);
    SourceInfo info=x.getSourceInfo();
    JsNameRef getArrayClassLiteralMethodNameRef=new JsNameRef(info,getClassLiteralForArrayMethodIdent);
    JsInvocation invocation=new JsInvocation(info,getArrayClassLiteralMethodNameRef,new JsNameRef(info,jsniClassLiteral.getIdent()),new JsNumberLiteral(info,arrayType.getDims()));
    resolveClassLiteral(jsniClassLiteral);
    ctx.replaceMe(invocation);
  }
  newClassRefs.add(jsniClassLiteral);
}",0.0798611111111111
53481,"/** 
 * Create a method call whose type is overridden to the specified type, ignoring the return type of the target method. This constructor is used during normalizing transformations to preserve type semantics when calling externally-defined compiler implementation methods. For example, Cast.dynamicCast() returns Object but that method is used to implement the cast operation. Using a stronger type on the call expression allows us to preserve type information during the latter phases of compilation.
 */
public JMethodCall(SourceInfo info,JExpression instance,JMethod method,JType overrideReturnType,JExpression... args){
  super(info);
  assert(method != null);
  assert(instance != null || method.isStatic() || this instanceof JNewInstance);
  this.instance=instance;
  this.method=method;
  this.overrideReturnType=overrideReturnType;
  this.methodHasSideEffects=method.hasSideEffects();
  addArgs(args);
}","/** 
 * Create a method call whose type is overridden to the specified type, ignoring the return type of the target method. This constructor is used during normalizing transformations to preserve type semantics when calling externally-defined compiler implementation methods. For example, Cast.dynamicCast() returns Object but that method is used to implement the cast operation. Using a stronger type on the call expression allows us to preserve type information during the latter phases of compilation.
 */
public JMethodCall(SourceInfo info,JExpression instance,JMethod method,JType overrideReturnType,JExpression... args){
  super(info);
  assert(method != null);
  assert(instance != null || method.isStatic() || this instanceof JNewInstance);
  this.instance=instance;
  this.method=method;
  this.overrideReturnType=overrideReturnType;
  addArgs(args);
}",0.9588732394366196
53482,"@Override public boolean hasSideEffects(){
  return isStaticDispatchOnly() || method.isStatic() ? methodHasSideEffects : true;
}","@Override public boolean hasSideEffects(){
  if (markedAsSideAffectFree) {
    return false;
  }
  return isStaticDispatchOnly() || method.isStatic() ? method.hasSideEffects() : true;
}",0.8115015974440895
53483,"/** 
 * Inline a call to an expression. Returns   {@code InlineResult.BLACKLIST} if the method isdeemed not inlineable regardless of call site;  {@code InlineResult.DO_NOT_BLACKLIST}otherwise.
 */
private InlineResult tryInlineBody(JMethodCall x,Context ctx,List<JExpression> bodyAsExpressionList,boolean ignoringReturn){
  if (isTooComplexToInline(bodyAsExpressionList,ignoringReturn)) {
    return InlineResult.BLACKLIST;
  }
  ExpressionAnalyzer targetAnalyzer=new ExpressionAnalyzer();
  targetAnalyzer.accept(bodyAsExpressionList);
  if (targetAnalyzer.hasAssignmentToParameter()) {
    return InlineResult.BLACKLIST;
  }
  RecursionCheckVisitor recursionCheckVisitor=new RecursionCheckVisitor(x.getTarget());
  recursionCheckVisitor.accept(bodyAsExpressionList);
  if (recursionCheckVisitor.isRecursive()) {
    return InlineResult.BLACKLIST;
  }
  if (x.getTarget().getParams().size() != x.getArgs().size()) {
    return InlineResult.DO_NOT_BLACKLIST;
  }
  OrderVisitor orderVisitor=new OrderVisitor(x.getTarget().getParams());
  orderVisitor.accept(bodyAsExpressionList);
  if (orderVisitor.checkResults() == SideEffectCheck.NO_REFERENCES) {
    List<JExpression> expressions=expressionsIncludingArgs(x);
    expressions.addAll(bodyAsExpressionList);
    ctx.replaceMe(JjsUtils.createOptimizedMultiExpression(ignoringReturn,expressions));
    return InlineResult.DO_NOT_BLACKLIST;
  }
  if (orderVisitor.checkResults() == SideEffectCheck.FAILS) {
    for (    JExpression arg : x.getArgs()) {
      ExpressionAnalyzer argAnalyzer=new ExpressionAnalyzer();
      argAnalyzer.accept(arg);
      if (argAnalyzer.hasAssignment() || argAnalyzer.accessesField() || argAnalyzer.createsObject()|| argAnalyzer.canThrowException()) {
        return InlineResult.DO_NOT_BLACKLIST;
      }
    }
  }
  boolean hasSideEffects=x.hasSideEffects();
  if (!hasSideEffects) {
    for (    JExpression expression : bodyAsExpressionList) {
      if (expression instanceof JMethodCall) {
        ((JMethodCall)expression).setMethodHasSideEffects(false);
      }
    }
  }
  ParameterReplacer replacer=new ParameterReplacer(x);
  replacer.accept(bodyAsExpressionList);
  bodyAsExpressionList.add(0,x.getInstance());
  bodyAsExpressionList.add(1,createClinitCall(x));
  ctx.replaceMe(JjsUtils.createOptimizedMultiExpression(ignoringReturn,bodyAsExpressionList));
  return InlineResult.DO_NOT_BLACKLIST;
}","/** 
 * Inline a call to an expression. Returns   {@code InlineResult.BLACKLIST} if the method isdeemed not inlineable regardless of call site;  {@code InlineResult.DO_NOT_BLACKLIST}otherwise.
 */
private InlineResult tryInlineBody(JMethodCall x,Context ctx,List<JExpression> bodyAsExpressionList,boolean ignoringReturn){
  if (isTooComplexToInline(bodyAsExpressionList,ignoringReturn)) {
    return InlineResult.BLACKLIST;
  }
  ExpressionAnalyzer targetAnalyzer=new ExpressionAnalyzer();
  targetAnalyzer.accept(bodyAsExpressionList);
  if (targetAnalyzer.hasAssignmentToParameter()) {
    return InlineResult.BLACKLIST;
  }
  RecursionCheckVisitor recursionCheckVisitor=new RecursionCheckVisitor(x.getTarget());
  recursionCheckVisitor.accept(bodyAsExpressionList);
  if (recursionCheckVisitor.isRecursive()) {
    return InlineResult.BLACKLIST;
  }
  if (x.getTarget().getParams().size() != x.getArgs().size()) {
    return InlineResult.DO_NOT_BLACKLIST;
  }
  OrderVisitor orderVisitor=new OrderVisitor(x.getTarget().getParams());
  orderVisitor.accept(bodyAsExpressionList);
  if (orderVisitor.checkResults() == SideEffectCheck.NO_REFERENCES) {
    List<JExpression> expressions=expressionsIncludingArgs(x);
    expressions.addAll(bodyAsExpressionList);
    ctx.replaceMe(JjsUtils.createOptimizedMultiExpression(ignoringReturn,expressions));
    return InlineResult.DO_NOT_BLACKLIST;
  }
  if (orderVisitor.checkResults() == SideEffectCheck.FAILS) {
    for (    JExpression arg : x.getArgs()) {
      ExpressionAnalyzer argAnalyzer=new ExpressionAnalyzer();
      argAnalyzer.accept(arg);
      if (argAnalyzer.hasAssignment() || argAnalyzer.accessesField() || argAnalyzer.createsObject()|| argAnalyzer.canThrowException()) {
        return InlineResult.DO_NOT_BLACKLIST;
      }
    }
  }
  boolean hasSideEffects=x.hasSideEffects();
  if (!hasSideEffects) {
    new JModVisitor(){
      @Override public void endVisit(      JMethodCall x,      Context ctx){
        x.markSideEffectFree();
      }
    }
.accept(bodyAsExpressionList);
  }
  ParameterReplacer replacer=new ParameterReplacer(x);
  replacer.accept(bodyAsExpressionList);
  bodyAsExpressionList.add(0,x.getInstance());
  bodyAsExpressionList.add(1,createClinitCall(x));
  ctx.replaceMe(JjsUtils.createOptimizedMultiExpression(ignoringReturn,bodyAsExpressionList));
  return InlineResult.DO_NOT_BLACKLIST;
}",0.945469798657718
53484,"private void pushLambdaExpressionLocalsIntoMethodScope(LambdaExpression x,SyntheticArgumentBinding[] synthArgs,JMethod lambdaMethod){
  Iterator<JParameter> it=lambdaMethod.getParams().iterator();
  if (synthArgs != null) {
    for (    SyntheticArgumentBinding sa : synthArgs) {
      curMethod.locals.put(sa.actualOuterLocalVariable,it.next());
    }
    for (    Argument a : x.arguments) {
      curMethod.locals.put(a.binding,it.next());
    }
  }
}","private void pushLambdaExpressionLocalsIntoMethodScope(LambdaExpression x,SyntheticArgumentBinding[] synthArgs,JMethod lambdaMethod){
}",0.4584040747028862
53485,"public void run(){
  assertEquals(94,new AcceptsLambda<Integer>().accept((a,b) -> Java8Test.this.local + local + a+ b).intValue());
}","@Override public Integer run(int j,int k){
  int t=x;
  int s=local;
  return t + s + a+ b;
}",0.336283185840708
53486,"/** 
 * Creates a dummy output directory without compiling the module. Either this method or   {@link #precompile} should be called first.
 */
synchronized Job.Result initWithoutPrecompile(TreeLogger logger) throws UnableToCompleteException {
  long startTime=System.currentTimeMillis();
  CompileDir compileDir=outboxDir.makeCompileDir(logger);
  TreeLogger compileLogger=makeCompileLogger(compileDir,logger);
  ModuleDef module=loadModule(Sets.<String>newHashSet(),compileLogger);
  logger.log(TreeLogger.INFO,""String_Node_Str"" + inputModuleName + ""String_Node_Str"");
  CompilerOptions loadOptions=new CompilerOptionsImpl(compileDir,inputModuleName,options);
  compilerContext=compilerContextBuilder.options(loadOptions).unitCache(Compiler.getOrCreateUnitCache(logger,loadOptions)).build();
  module.getCompilationState(compileLogger,compilerContext);
  setUpCompileDir(compileDir,module,compileLogger);
  if (launcherDir != null) {
    launcherDir.update(module,compileDir,compileLogger);
  }
  outputModuleName.set(module.getName());
  lastBuild.set(compileDir);
  long elapsedTime=System.currentTimeMillis() - startTime;
  compileLogger.log(TreeLogger.Type.INFO,""String_Node_Str"" + elapsedTime + ""String_Node_Str"");
  return new Result(compileDir,module.getName(),null);
}","/** 
 * Creates a dummy output directory without compiling the module. Either this method or   {@link #precompile} should be called first.
 */
synchronized Job.Result initWithoutPrecompile(TreeLogger logger) throws UnableToCompleteException {
  long startTime=System.currentTimeMillis();
  CompileDir compileDir=outboxDir.makeCompileDir(logger);
  TreeLogger compileLogger=makeCompileLogger(compileDir,logger);
  ModuleDef module;
  try {
    module=loadModule(Sets.<String>newHashSet(),compileLogger);
    logger.log(TreeLogger.INFO,""String_Node_Str"" + inputModuleName + ""String_Node_Str"");
    CompilerOptions loadOptions=new CompilerOptionsImpl(compileDir,inputModuleName,options);
    compilerContext=compilerContextBuilder.options(loadOptions).unitCache(Compiler.getOrCreateUnitCache(logger,loadOptions)).build();
    module.getCompilationState(compileLogger,compilerContext);
    setUpCompileDir(compileDir,module,compileLogger);
    if (launcherDir != null) {
      launcherDir.update(module,compileDir,compileLogger);
    }
    outputModuleName.set(module.getName());
  }
  finally {
    lastBuild.set(compileDir);
  }
  long elapsedTime=System.currentTimeMillis() - startTime;
  compileLogger.log(TreeLogger.Type.INFO,""String_Node_Str"" + elapsedTime + ""String_Node_Str"");
  return new Result(compileDir,module.getName(),null);
}",0.9770466717674062
53487,"private boolean doCompile(TreeLogger compileLogger,CompileDir compileDir,Job job) throws UnableToCompleteException {
  job.onProgress(""String_Node_Str"");
  CompilerOptions loadOptions=new CompilerOptionsImpl(compileDir,inputModuleName,options);
  compilerContext=compilerContextBuilder.options(loadOptions).build();
  ModuleDef module=loadModule(job.getBindingProperties().keySet(),compileLogger);
  String recompileJs=generateModuleRecompileJs(module,compileLogger);
  Map<String,String> bindingProperties=restrictPermutations(compileLogger,module,job.getBindingProperties());
  String newModuleName=module.getName();
  outputModuleName.set(newModuleName);
  InputSummary input=new InputSummary(bindingProperties,module);
  if (input.equals(lastBuildInput)) {
    compileLogger.log(Type.INFO,""String_Node_Str"");
    job.setCompileStrategy(CompileStrategy.SKIPPED);
    return true;
  }
  job.onProgress(""String_Node_Str"");
  CompilerOptions runOptions=new CompilerOptionsImpl(compileDir,newModuleName,options);
  compilerContext=compilerContextBuilder.options(runOptions).build();
  MinimalRebuildCache knownGoodMinimalRebuildCache=getKnownGoodMinimalRebuildCache(bindingProperties);
  job.setCompileStrategy(knownGoodMinimalRebuildCache.isPopulated() ? CompileStrategy.INCREMENTAL : CompileStrategy.FULL);
  MinimalRebuildCache mutableMinimalRebuildCache=new MinimalRebuildCache();
  mutableMinimalRebuildCache.copyFrom(knownGoodMinimalRebuildCache);
  boolean success=new Compiler(runOptions,mutableMinimalRebuildCache).run(compileLogger,module);
  if (success) {
    publishedCompileDir=compileDir;
    lastBuildInput=input;
    saveKnownGoodMinimalRebuildCache(bindingProperties,mutableMinimalRebuildCache);
    String moduleName=outputModuleName.get();
    writeRecompileNoCacheJs(new File(publishedCompileDir.getWarDir(),moduleName),moduleName,recompileJs,compileLogger);
    if (launcherDir != null) {
      launcherDir.update(module,compileDir,compileLogger);
    }
  }
 else {
    lastBuildInput=null;
  }
  lastBuild.set(compileDir);
  return success;
}","private boolean doCompile(TreeLogger compileLogger,CompileDir compileDir,Job job) throws UnableToCompleteException {
  job.onProgress(""String_Node_Str"");
  CompilerOptions loadOptions=new CompilerOptionsImpl(compileDir,inputModuleName,options);
  compilerContext=compilerContextBuilder.options(loadOptions).build();
  ModuleDef module=loadModule(job.getBindingProperties().keySet(),compileLogger);
  String recompileJs=generateModuleRecompileJs(module,compileLogger);
  Map<String,String> bindingProperties=restrictPermutations(compileLogger,module,job.getBindingProperties());
  String newModuleName=module.getName();
  outputModuleName.set(newModuleName);
  InputSummary input=new InputSummary(bindingProperties,module);
  if (input.equals(lastBuildInput)) {
    compileLogger.log(Type.INFO,""String_Node_Str"");
    job.setCompileStrategy(CompileStrategy.SKIPPED);
    return true;
  }
  lastBuildInput=null;
  job.onProgress(""String_Node_Str"");
  CompilerOptions runOptions=new CompilerOptionsImpl(compileDir,newModuleName,options);
  compilerContext=compilerContextBuilder.options(runOptions).build();
  MinimalRebuildCache knownGoodMinimalRebuildCache=getKnownGoodMinimalRebuildCache(bindingProperties);
  job.setCompileStrategy(knownGoodMinimalRebuildCache.isPopulated() ? CompileStrategy.INCREMENTAL : CompileStrategy.FULL);
  MinimalRebuildCache mutableMinimalRebuildCache=new MinimalRebuildCache();
  mutableMinimalRebuildCache.copyFrom(knownGoodMinimalRebuildCache);
  boolean success=new Compiler(runOptions,mutableMinimalRebuildCache).run(compileLogger,module);
  if (success) {
    publishedCompileDir=compileDir;
    lastBuildInput=input;
    saveKnownGoodMinimalRebuildCache(bindingProperties,mutableMinimalRebuildCache);
    String moduleName=outputModuleName.get();
    writeRecompileNoCacheJs(new File(publishedCompileDir.getWarDir(),moduleName),moduleName,recompileJs,compileLogger);
    if (launcherDir != null) {
      launcherDir.update(module,compileDir,compileLogger);
    }
  }
  return success;
}",0.969889840881273
53488,"@Override public void runPass(){
  externalClassNames=new HashSet<String>();
  externalClassPrefixes=new ArrayList<String>();
  visitController.startVisit(this);
}","@Override public void runPass(){
  externalClassNames=new HashSet<String>();
  remainingStyleClassNames=new HashSet<String>();
  externalClassPrefixes=new ArrayList<String>();
  visitController.startVisit(this);
}",0.8670212765957447
53489,"/** 
 * Returns an immutable set of external class names that should not be renamed. The returned set contains all complete class names defined with  {@code @external} as well as all of the class names from{@code styleClassesSet} that match prefixes defined with {@code @external}.
 * @param styleClassesSet a set of class names that should be filtered toreturn those matching external prefixes. Note that the passed-in set is not modified.
 * @return an immutable set of class names. Note that the returned names arenot prefixed with "".""; they are the raw name.
 */
public ImmutableSet<String> getExternalClassNames(Set<String> styleClassesSet){
  if (matchAll) {
    return ImmutableSet.copyOf(styleClassesSet);
  }
  SortedSet<String> classNames=new TreeSet<String>(styleClassesSet);
  Builder<String> externalClassesSetBuilder=ImmutableSet.builder();
  externalClassesSetBuilder.addAll(externalClassNames);
  for (  String prefix : externalClassPrefixes) {
    for (    String styleClass : classNames.tailSet(prefix)) {
      if (styleClass.startsWith(prefix)) {
        externalClassesSetBuilder.add(styleClass);
      }
 else {
        break;
      }
    }
  }
  return externalClassesSetBuilder.build();
}","/** 
 * Returns an immutable set of external class names that should not be renamed. The returned set contains all complete class names defined with  {@code @external} as well as all of the class names from{@code styleClassesSet} that match prefixes defined with {@code @external}. <p>The set will contain also the class names that are not in the AST anymore (defined in a conditional node that has been evaluated to false) and are not associated to a java method. That doesn't make sense to rename these class names because they are not in the final css and javascript. Moreover we handle the case where an   {@code @external} related to thesestyle classes has been removed from the AST (because it was also defined in a conditional node evaluated to false) and the compiler doesn't have to throw and error for this case. <pre> / {@literal *} conditional node evaluated to false at compile time {@literal *}/
 * @if (is(""property"", ""true"")) {
 * @external foo;.foo { width: 100%; } } </pre>
 * @param styleClassesSet a set of class names that should be filtered toreturn those matching external prefixes. Note that the passed-in set is not modified.
 * @param orphanClassName a set of class names that aren't associated to a java method of theCssResource interface.
 * @return an immutable set of class names. Note that the returned names arenot prefixed with "".""; they are the raw name.
 */
public ImmutableSet<String> getExternalClassNames(Set<String> styleClassesSet,Set<String> orphanClassName){
  if (matchAll) {
    return ImmutableSet.copyOf(styleClassesSet);
  }
  SortedSet<String> classNames=new TreeSet<String>(styleClassesSet);
  Builder<String> externalClassesSetBuilder=ImmutableSet.builder();
  externalClassesSetBuilder.addAll(externalClassNames);
  for (  String prefix : externalClassPrefixes) {
    for (    String styleClass : classNames.tailSet(prefix)) {
      if (styleClass.startsWith(prefix)) {
        externalClassesSetBuilder.add(styleClass);
      }
 else {
        break;
      }
    }
  }
  for (  String className : orphanClassName) {
    if (!remainingStyleClassNames.contains(className)) {
      externalClassesSetBuilder.add(className);
    }
  }
  return externalClassesSetBuilder.build();
}",0.7046511627906977
53490,"/** 
 * When the tree is fully processed, we can now collect the external classes and revert the renaming for these classes. We cannot collect the external classes during the original renaming because some external at-rule could be located inside a conditional block and could be removed when these blocks are evaluated.
 */
private Set<String> revertRenamingOfExternalClasses(CssTree cssTree,RenamingResult renamingResult){
  ExternalClassesCollector externalClassesCollector=new ExternalClassesCollector(cssTree.getMutatingVisitController(),errorManager);
  externalClassesCollector.runPass();
  Map<String,String> styleClassesMapping=renamingResult.mapping;
  Set<String> allStyleClassSet=Sets.newHashSet(styleClassesMapping.keySet());
  allStyleClassSet.addAll(renamingResult.externalClassCandidate);
  Set<String> externalClasses=externalClassesCollector.getExternalClassNames(allStyleClassSet);
  final Map<String,String> revertMap=new HashMap<String,String>(externalClasses.size());
  for (  String external : externalClasses) {
    revertMap.put(styleClassesMapping.get(external),external);
    styleClassesMapping.put(external,external);
  }
  SubstitutionMap revertExternalClasses=new SubstitutionMap(){
    @Override public String get(    String key){
      return revertMap.get(key);
    }
  }
;
  new CssClassRenaming(cssTree.getMutatingVisitController(),revertExternalClasses,null).runPass();
  return externalClasses;
}","/** 
 * When the tree is fully processed, we can now collect the external classes and revert the renaming for these classes. We cannot collect the external classes during the original renaming because some external at-rule could be located inside a conditional block and could be removed when these blocks are evaluated.
 */
private Set<String> revertRenamingOfExternalClasses(CssTree cssTree,RenamingResult renamingResult){
  ExternalClassesCollector externalClassesCollector=new ExternalClassesCollector(cssTree.getMutatingVisitController(),errorManager);
  externalClassesCollector.runPass();
  Map<String,String> styleClassesMapping=renamingResult.mapping;
  Set<String> allStyleClassSet=Sets.newHashSet(styleClassesMapping.keySet());
  allStyleClassSet.addAll(renamingResult.externalClassCandidate);
  Set<String> externalClasses=externalClassesCollector.getExternalClassNames(allStyleClassSet,renamingResult.externalClassCandidate);
  final Map<String,String> revertMap=new HashMap<String,String>(externalClasses.size());
  for (  String external : externalClasses) {
    revertMap.put(styleClassesMapping.get(external),external);
    styleClassesMapping.put(external,external);
  }
  SubstitutionMap revertExternalClasses=new SubstitutionMap(){
    @Override public String get(    String key){
      return revertMap.get(key);
    }
  }
;
  new CssClassRenaming(cssTree.getMutatingVisitController(),revertExternalClasses,null).runPass();
  return externalClasses;
}",0.9869236063317276
53491,"@Override public void setMethodNameDisplayMode(com.google.gwt.dev.util.arg.OptionMethodNameDisplayMode.Mode methodNameDisplayMode){
  throw new UnsupportedOperationException();
}","@Override public void setMethodNameDisplayMode(OptionMethodNameDisplayMode.Mode methodNameDisplayMode){
  throw new UnsupportedOperationException();
}",0.9146341463414634
53492,"@Override public com.google.gwt.dev.util.arg.OptionMethodNameDisplayMode.Mode getMethodNameDisplayMode(){
  return jjsOptions.getMethodNameDisplayMode();
}","@Override public OptionMethodNameDisplayMode.Mode getMethodNameDisplayMode(){
  return jjsOptions.getMethodNameDisplayMode();
}",0.900709219858156
53493,"@Override public void setMethodNameDisplayMode(com.google.gwt.dev.util.arg.OptionMethodNameDisplayMode.Mode methodNameDisplayMode){
  jjsOptions.setMethodNameDisplayMode(methodNameDisplayMode);
}","@Override public void setMethodNameDisplayMode(OptionMethodNameDisplayMode.Mode methodNameDisplayMode){
  jjsOptions.setMethodNameDisplayMode(methodNameDisplayMode);
}",0.9226519337016574
53494,"private boolean shouldEmitDisplayNames(){
  return methodNameMappingMode != com.google.gwt.dev.util.arg.OptionMethodNameDisplayMode.Mode.NONE;
}","private boolean shouldEmitDisplayNames(){
  return methodNameMappingMode != OptionMethodNameDisplayMode.Mode.NONE;
}",0.8923076923076924
53495,"private static List<String> makeCodeServerArgs(HostedModeOptions options,int port){
  List<String> args=new ArrayList<String>();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(String.valueOf(port));
  args.add(""String_Node_Str"");
  args.add(String.valueOf(options.getSourceLevel()));
  if (options.getBindAddress() != null) {
    args.add(""String_Node_Str"");
    args.add(options.getBindAddress());
  }
  if (options.getWorkDir() != null) {
    args.add(""String_Node_Str"");
    args.add(String.valueOf(options.getWorkDir()));
  }
  args.add(""String_Node_Str"");
  args.add(options.getModuleBaseDir().getAbsolutePath());
  if (options.getLogLevel() != null) {
    args.add(""String_Node_Str"");
    args.add(String.valueOf(options.getLogLevel()));
  }
  if (options.getJsInteropMode() != OptionJsInteropMode.Mode.NONE) {
    args.add(""String_Node_Str"");
    args.add(options.getJsInteropMode().toString());
  }
  if (!options.isIncrementalCompileEnabled()) {
    args.add(""String_Node_Str"");
  }
  args.add(""String_Node_Str"");
  args.add(options.getMethodNameDisplayMode().toString());
  for (  String mod : options.getModuleNames()) {
    args.add(mod);
  }
  return args;
}","private static List<String> makeCodeServerArgs(HostedModeOptions options,int port){
  List<String> args=new ArrayList<String>();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(String.valueOf(port));
  args.add(""String_Node_Str"");
  args.add(String.valueOf(options.getSourceLevel()));
  if (options.getBindAddress() != null) {
    args.add(""String_Node_Str"");
    args.add(options.getBindAddress());
  }
  if (options.getWorkDir() != null) {
    args.add(""String_Node_Str"");
    args.add(String.valueOf(options.getWorkDir()));
  }
  args.add(""String_Node_Str"");
  args.add(options.getModuleBaseDir().getAbsolutePath());
  if (options.getLogLevel() != null) {
    args.add(""String_Node_Str"");
    args.add(String.valueOf(options.getLogLevel()));
  }
  if (options.getJsInteropMode() != OptionJsInteropMode.Mode.NONE) {
    args.add(""String_Node_Str"");
    args.add(options.getJsInteropMode().name());
  }
  if (!options.isIncrementalCompileEnabled()) {
    args.add(""String_Node_Str"");
  }
  if (options.getMethodNameDisplayMode() != OptionMethodNameDisplayMode.Mode.NONE) {
    args.add(""String_Node_Str"");
    args.add(options.getMethodNameDisplayMode().name());
  }
  for (  String mod : options.getModuleNames()) {
    args.add(mod);
  }
  return args;
}",0.9173053650665592
53496,"@Override public String createAssignment(TreeLogger logger,ResourceContext context,JMethod method) throws UnableToCompleteException {
  CssTreeResult cssTreeResult=cssTreeMap.get(method);
  RenamingResult renamingResult=doClassRenaming(cssTreeResult.tree,method,logger,context);
  ConstantDefinitions constantDefinitions=optimizeTree(cssTreeResult,context,true,true,logger);
  checkErrors();
  Set<String> externalClasses=revertRenamingOfExternalClasses(cssTreeResult.tree,renamingResult.mapping);
  checkErrors();
  validateExternalClasses(externalClasses,renamingResult.externalClassCandidate,method,logger);
  SourceWriter sw=new StringSourceWriter();
  sw.println(""String_Node_Str"" + method.getReturnType().getQualifiedSourceName() + ""String_Node_Str"");
  sw.indent();
  writeMethods(logger,context,method,sw,constantDefinitions,cssTreeResult.originalConstantNameMapping,renamingResult.mapping);
  sw.outdent();
  sw.println(""String_Node_Str"");
  return sw.toString();
}","@Override public String createAssignment(TreeLogger logger,ResourceContext context,JMethod method) throws UnableToCompleteException {
  CssTreeResult cssTreeResult=cssTreeMap.get(method);
  RenamingResult renamingResult=doClassRenaming(cssTreeResult.tree,method,logger,context);
  ConstantDefinitions constantDefinitions=optimizeTree(cssTreeResult,context,true,true,logger);
  checkErrors();
  Set<String> externalClasses=revertRenamingOfExternalClasses(cssTreeResult.tree,renamingResult);
  checkErrors();
  validateExternalClasses(externalClasses,renamingResult.externalClassCandidate,method,logger);
  SourceWriter sw=new StringSourceWriter();
  sw.println(""String_Node_Str"" + method.getReturnType().getQualifiedSourceName() + ""String_Node_Str"");
  sw.indent();
  writeMethods(logger,context,method,sw,constantDefinitions,cssTreeResult.originalConstantNameMapping,renamingResult.mapping);
  sw.outdent();
  sw.println(""String_Node_Str"");
  return sw.toString();
}",0.9958762886597938
53497,"/** 
 * When the tree is fully processed, we can now collect the external classes and revert the renaming for these classes. We cannot collect the external classes during the original renaming because some external at-rule could be located inside a conditional block and could be removed when these blocks are evaluated.
 */
private Set<String> revertRenamingOfExternalClasses(CssTree cssTree,Map<String,String> styleClassesMapping){
  ExternalClassesCollector externalClassesCollector=new ExternalClassesCollector(cssTree.getMutatingVisitController(),errorManager);
  externalClassesCollector.runPass();
  Set<String> styleClassSet=styleClassesMapping.keySet();
  Set<String> externalClasses=externalClassesCollector.getExternalClassNames(styleClassSet);
  final Map<String,String> revertMap=new HashMap<String,String>(externalClasses.size());
  for (  String external : externalClasses) {
    revertMap.put(styleClassesMapping.get(external),external);
    styleClassesMapping.put(external,external);
  }
  SubstitutionMap revertExternalClasses=new SubstitutionMap(){
    @Override public String get(    String key){
      return revertMap.get(key);
    }
  }
;
  new CssClassRenaming(cssTree.getMutatingVisitController(),revertExternalClasses,null).runPass();
  return externalClasses;
}","/** 
 * When the tree is fully processed, we can now collect the external classes and revert the renaming for these classes. We cannot collect the external classes during the original renaming because some external at-rule could be located inside a conditional block and could be removed when these blocks are evaluated.
 */
private Set<String> revertRenamingOfExternalClasses(CssTree cssTree,RenamingResult renamingResult){
  ExternalClassesCollector externalClassesCollector=new ExternalClassesCollector(cssTree.getMutatingVisitController(),errorManager);
  externalClassesCollector.runPass();
  Map<String,String> styleClassesMapping=renamingResult.mapping;
  Set<String> allStyleClassSet=Sets.newHashSet(styleClassesMapping.keySet());
  allStyleClassSet.addAll(renamingResult.externalClassCandidate);
  Set<String> externalClasses=externalClassesCollector.getExternalClassNames(allStyleClassSet);
  final Map<String,String> revertMap=new HashMap<String,String>(externalClasses.size());
  for (  String external : externalClasses) {
    revertMap.put(styleClassesMapping.get(external),external);
    styleClassesMapping.put(external,external);
  }
  SubstitutionMap revertExternalClasses=new SubstitutionMap(){
    @Override public String get(    String key){
      return revertMap.get(key);
    }
  }
;
  new CssClassRenaming(cssTree.getMutatingVisitController(),revertExternalClasses,null).runPass();
  return externalClasses;
}",0.7330150569225119
53498,"/** 
 * Test that style classes mentioned as external are not obfuscated.
 */
public void testExternalClasses(){
  ExternalClasses externalClasses=res().externalClasses();
  assertFalse(externalClasses.getText().contains(""String_Node_Str""));
  assertNotSame(""String_Node_Str"",externalClasses.obfuscatedClass());
  assertEquals(""String_Node_Str"",externalClasses.externalClass());
  assertEquals(""String_Node_Str"",externalClasses.externalClass2());
  assertEquals(""String_Node_Str"",externalClasses.unobfuscated());
  assertEquals(""String_Node_Str"",externalClasses.unobfuscated2());
}","/** 
 * Test that style classes mentioned as external are not obfuscated.
 */
public void testExternalClasses(){
  ExternalClasses externalClasses=res().externalClasses();
  assertNotSame(""String_Node_Str"",externalClasses.obfuscatedClass());
  assertEquals(""String_Node_Str"",externalClasses.externalClass());
  assertEquals(""String_Node_Str"",externalClasses.externalClass2());
  assertEquals(""String_Node_Str"",externalClasses.unobfuscated());
  assertEquals(""String_Node_Str"",externalClasses.unobfuscated2());
  String css=externalClasses.getText();
  assertFalse(css.contains(""String_Node_Str""));
  String expectedCss=""String_Node_Str"" + externalClasses.obfuscatedClass() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  assertEquals(expectedCss,css);
}",0.7379061371841156
53499,"/** 
 * Handle keyboard navigation.
 * @param keyCode the key code that was pressed
 */
private void handleKeyNavigation(int keyCode){
  CellTreeNodeView<?> parent=keyboardSelectedNode.getParentNode();
  int parentChildCount=(parent == null) ? 0 : parent.getChildCount();
  int index=keyboardSelectedNode.getIndex();
  int childCount=keyboardSelectedNode.getChildCount();
  boolean isRtl=LocaleInfo.getCurrentLocale().isRTL();
  keyCode=KeyCodes.maybeSwapArrowKeysForRtl(keyCode,isRtl);
switch (keyCode) {
case KeyCodes.KEY_DOWN:
    if (keyboardSelectedNode.isOpen() && childCount > 0) {
      keyboardSelect(keyboardSelectedNode.getChildNode(0),true);
    }
 else     if (index < parentChildCount - 1) {
      keyboardSelect(parent.getChildNode(index + 1),true);
    }
 else {
      CellTreeNodeView<?> curParent=parent;
      CellTreeNodeView<?> nextSibling=null;
      while (curParent != null && curParent != rootNode) {
        CellTreeNodeView<?> grandparent=curParent.getParentNode();
        if (grandparent == null) {
          break;
        }
        int curParentIndex=grandparent.indexOf(curParent);
        if (curParentIndex < grandparent.getChildCount() - 1) {
          nextSibling=grandparent.getChildNode(curParentIndex + 1);
          break;
        }
        curParent=grandparent;
      }
      if (nextSibling != null) {
        keyboardSelect(nextSibling,true);
      }
    }
  break;
case KeyCodes.KEY_UP:
if (index > 0) {
  CellTreeNodeView<?> prevSibling=parent.getChildNode(index - 1);
  if (prevSibling.isOpen() && prevSibling.getChildCount() > 0) {
    prevSibling=prevSibling.getChildNode(prevSibling.getChildCount() - 1);
  }
  keyboardSelect(prevSibling,true);
}
 else if (parent != null && parent != rootNode) {
  keyboardSelect(parent,true);
}
break;
case KeyCodes.KEY_RIGHT:
keyboardNavigateDeep();
break;
case KeyCodes.KEY_LEFT:
keyboardNavigateShallow();
break;
}
}","/** 
 * Handle keyboard navigation.
 * @param keyCode the key code that was pressed
 */
void handleKeyNavigation(int keyCode){
  CellTreeNodeView<?> parent=keyboardSelectedNode.getParentNode();
  int parentChildCount=(parent == null) ? 0 : parent.getChildCount();
  int index=keyboardSelectedNode.getIndex();
  int childCount=keyboardSelectedNode.getChildCount();
  boolean isRtl=LocaleInfo.getCurrentLocale().isRTL();
  keyCode=KeyCodes.maybeSwapArrowKeysForRtl(keyCode,isRtl);
switch (keyCode) {
case KeyCodes.KEY_DOWN:
    if (keyboardSelectedNode.isOpen() && childCount > 0) {
      keyboardSelect(keyboardSelectedNode.getChildNode(0),true);
    }
 else     if (index < parentChildCount - 1) {
      keyboardSelect(parent.getChildNode(index + 1),true);
    }
 else {
      CellTreeNodeView<?> curParent=parent;
      CellTreeNodeView<?> nextSibling=null;
      while (curParent != null && curParent != rootNode) {
        CellTreeNodeView<?> grandparent=curParent.getParentNode();
        if (grandparent == null) {
          break;
        }
        int curParentIndex=grandparent.indexOf(curParent);
        if (curParentIndex < grandparent.getChildCount() - 1) {
          nextSibling=grandparent.getChildNode(curParentIndex + 1);
          break;
        }
        curParent=grandparent;
      }
      if (nextSibling != null) {
        keyboardSelect(nextSibling,true);
      }
    }
  break;
case KeyCodes.KEY_UP:
if (index > 0) {
  CellTreeNodeView<?> prevSibling=parent.getChildNode(index - 1);
  while (prevSibling.isOpen() && prevSibling.getChildCount() > 0) {
    prevSibling=prevSibling.getChildNode(prevSibling.getChildCount() - 1);
  }
  keyboardSelect(prevSibling,true);
}
 else if (parent != null && parent != rootNode) {
  keyboardSelect(parent,true);
}
break;
case KeyCodes.KEY_RIGHT:
keyboardNavigateDeep();
break;
case KeyCodes.KEY_LEFT:
keyboardNavigateShallow();
break;
}
}",0.9960557454641072
53500,"public void clearPerTypeJsCache(){
  rootTypeNames.clear();
  preambleTypeNames.clear();
  deletedResourcePaths.clear();
  modifiedResourcePaths.clear();
  lastModifiedByResourcePath.clear();
  deletedDiskSourcePaths.clear();
  modifiedDiskSourcePaths.clear();
  lastModifiedByDiskSourcePath.clear();
  contentHashByGeneratedTypeName.clear();
  jsByTypeName.clear();
  referencedTypeNamesByTypeName.clear();
  sourceMapsByTypeName.clear();
  statementRangesByTypeName.clear();
  typeNamesByReferencingTypeName.clear();
}","public void clearPerTypeJsCache(){
  rootTypeNames.clear();
  preambleTypeNames.clear();
  deletedResourcePaths.clear();
  modifiedResourcePaths.clear();
  deletedDiskSourcePaths.clear();
  modifiedDiskSourcePaths.clear();
  contentHashByGeneratedTypeName.clear();
  jsByTypeName.clear();
  referencedTypeNamesByTypeName.clear();
  sourceMapsByTypeName.clear();
  statementRangesByTypeName.clear();
  typeNamesByReferencingTypeName.clear();
}",0.5155925155925156
53501,"private String compileToJs(CompilerOptions compilerOptions,File applicationDir,String moduleName,List<MockResource> applicationResources,MinimalRebuildCache minimalRebuildCache,Set<String> expectedProcessedStaleTypeNames,JsOutputOption output) throws IOException, UnableToCompleteException, InterruptedException {
  System.setProperty(UnitCacheSingleton.GWT_PERSISTENTUNITCACHE,""String_Node_Str"");
  Thread.sleep(1001);
  PrintWriterTreeLogger logger=new PrintWriterTreeLogger();
  logger.setMaxDetail(TreeLogger.ERROR);
  File outputDir=new File(applicationDir.getPath() + File.separator + moduleName);
  if (outputDir.exists()) {
    Util.recursiveDelete(outputDir,true);
  }
  ResourceLoader resourceLoader=ResourceLoaders.forClassLoader(Thread.currentThread());
  resourceLoader=ResourceLoaders.forPathAndFallback(ImmutableList.of(applicationDir),resourceLoader);
  compilerOptions.setIncrementalCompileEnabled(true);
  compilerOptions.setWarDir(applicationDir);
  compilerOptions.setModuleNames(ImmutableList.of(moduleName));
  compilerOptions.setOutput(output);
  CompilerContext compilerContext=new CompilerContext.Builder().options(compilerOptions).minimalRebuildCache(minimalRebuildCache).build();
  for (  MockResource applicationResource : applicationResources) {
    writeResourceTo(applicationResource,applicationDir);
  }
  ModuleDefLoader.clearModuleCache();
  ModuleDefLoader.loadFromResources(logger,compilerContext,moduleName,resourceLoader,true);
  Compiler compiler=new Compiler(compilerOptions,minimalRebuildCache);
  compiler.run(logger);
  File outputJsFile=null;
  outputDir=new File(applicationDir.getPath() + File.separator + moduleName);
  if (outputDir.exists()) {
    for (    File outputFile : outputDir.listFiles()) {
      if (outputFile.getPath().endsWith(""String_Node_Str"")) {
        outputJsFile=outputFile;
        break;
      }
    }
  }
  assertNotNull(outputJsFile);
  assertEquals(expectedProcessedStaleTypeNames,minimalRebuildCache.getProcessedStaleTypeNames());
  return Files.toString(outputJsFile,Charsets.UTF_8);
}","private String compileToJs(CompilerOptions compilerOptions,File applicationDir,String moduleName,List<MockResource> applicationResources,MinimalRebuildCache minimalRebuildCache,Set<String> expectedProcessedStaleTypeNames,JsOutputOption output) throws IOException, UnableToCompleteException, InterruptedException {
  System.setProperty(UnitCacheSingleton.GWT_PERSISTENTUNITCACHE,""String_Node_Str"");
  Thread.sleep(1001);
  PrintWriterTreeLogger logger=new PrintWriterTreeLogger();
  logger.setMaxDetail(TreeLogger.ERROR);
  File outputDir=new File(applicationDir.getPath() + File.separator + moduleName);
  if (outputDir.exists()) {
    Util.recursiveDelete(outputDir,true);
  }
  ResourceLoader resourceLoader=ResourceLoaders.forClassLoader(Thread.currentThread());
  resourceLoader=ResourceLoaders.forPathAndFallback(ImmutableList.of(applicationDir),resourceLoader);
  compilerOptions.setIncrementalCompileEnabled(true);
  compilerOptions.setWarDir(applicationDir);
  compilerOptions.setModuleNames(ImmutableList.of(moduleName));
  compilerOptions.setOutput(output);
  CompilerContext compilerContext=new CompilerContext.Builder().options(compilerOptions).minimalRebuildCache(minimalRebuildCache).build();
  for (  MockResource applicationResource : applicationResources) {
    writeResourceTo(applicationResource,applicationDir);
  }
  ModuleDefLoader.clearModuleCache();
  ModuleDefLoader.loadFromResources(logger,compilerContext,moduleName,resourceLoader,true);
  Compiler compiler=new Compiler(compilerOptions,minimalRebuildCache);
  compiler.run(logger);
  File outputJsFile=null;
  outputDir=new File(applicationDir.getPath() + File.separator + moduleName);
  if (outputDir.exists()) {
    for (    File outputFile : outputDir.listFiles()) {
      if (outputFile.getPath().endsWith(""String_Node_Str"")) {
        outputJsFile=outputFile;
        break;
      }
    }
  }
  assertNotNull(outputJsFile);
  if (expectedProcessedStaleTypeNames != null) {
    assertEquals(expectedProcessedStaleTypeNames,minimalRebuildCache.getProcessedStaleTypeNames());
  }
  return Files.toString(outputJsFile,Charsets.UTF_8);
}",0.9868326550155614
53502,"public native void set(int index,boolean bool);","public void set(int index,boolean bool){
  set(index,JsJsonBoolean.create(bool));
}",0.6153846153846154
53503,private native <T extends JsonValue>T parse0(String jsonString);,private static native <T extends JsonValue>T parse0(String jsonString);,0.9481481481481482
53504,"@SuppressWarnings({""String_Node_Str""}) public <T extends JsonValue>T parse(String jsonString) throws JsonException {
  try {
    return parse0(jsonString);
  }
 catch (  Exception e) {
    throw new JsonException(""String_Node_Str"" + jsonString);
  }
}","public <T extends JsonValue>T parse(String jsonString) throws JsonException {
  try {
    return parse0(jsonString);
  }
 catch (  Exception e) {
    throw new JsonException(""String_Node_Str"" + jsonString);
  }
}",0.9157667386609072
53505,public native JsonObject createObject();,"public JsonObject createObject(){
  return JsJsonObject.create();
}",0.616822429906542
53506,"public native void put(String key,boolean value);","public void put(String key,boolean value){
  put(key,JsJsonBoolean.create(value));
}",0.631578947368421
53507,"public native void put0(String key,JsonValue value);","/** 
 * @deprecated use {@link #put(String,elemental.json.JsonValue)} instead.
 */
@Deprecated public void put0(String key,JsonValue value){
  put(key,value);
}",0.4245283018867924
53508,"@SuppressWarnings(""String_Node_Str"") private Object resolveAnnotationValue(TreeLogger logger,Class<?> expectedType,Object value){
  if (expectedType.isArray()) {
    Class<?> componentType=expectedType.getComponentType();
    if (!value.getClass().isArray()) {
      logger.log(TreeLogger.WARN,""String_Node_Str"" + componentType.getCanonicalName() + ""String_Node_Str""+ value.getClass().getCanonicalName());
      return null;
    }
    if (componentType.isPrimitive()) {
      return value;
    }
    int n=Array.getLength(value);
    Object newArray=Array.newInstance(componentType,n);
    for (int i=0; i < n; ++i) {
      Object valueElement=Array.get(value,i);
      Object resolvedValue=resolveAnnotationValue(logger,componentType,valueElement);
      if (resolvedValue == null || !componentType.isAssignableFrom(resolvedValue.getClass())) {
        logger.log(TreeLogger.ERROR,""String_Node_Str"" + componentType + ""String_Node_Str""+ resolvedValue);
      }
 else {
        Array.set(newArray,i,resolvedValue);
      }
    }
    return newArray;
  }
 else   if (expectedType.isEnum()) {
    if (!(value instanceof AnnotationEnum)) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"" + ""String_Node_Str"" + value);
      return null;
    }
    AnnotationEnum annotEnum=(AnnotationEnum)value;
    Class<? extends Enum> enumType=expectedType.asSubclass(Enum.class);
    try {
      return Enum.valueOf(enumType,annotEnum.getValue());
    }
 catch (    IllegalArgumentException e) {
      logger.log(TreeLogger.WARN,""String_Node_Str"" + annotEnum.getValue() + ""String_Node_Str""+ enumType.getName()+ ""String_Node_Str"");
      return null;
    }
  }
 else   if (Annotation.class.isAssignableFrom(expectedType)) {
    if (!(value instanceof AnnotationData)) {
      logger.log(TreeLogger.WARN,""String_Node_Str"" + expectedType.getCanonicalName() + ""String_Node_Str""+ value.getClass().getCanonicalName());
      return null;
    }
    AnnotationData annotData=(AnnotationData)value;
    Class<? extends Annotation> annotationClass=getAnnotationClass(logger,annotData);
    if (!expectedType.isAssignableFrom(annotationClass)) {
      logger.log(TreeLogger.WARN,""String_Node_Str"" + expectedType.getCanonicalName() + ""String_Node_Str""+ annotationClass.getCanonicalName());
      return null;
    }
    return createAnnotation(logger,annotationClass,annotData);
  }
 else   if (expectedType.isPrimitive()) {
    Class<?> wrapper=getWrapperClass(expectedType);
    return wrapper.cast(value);
  }
 else {
    if (expectedType.isAssignableFrom(value.getClass())) {
      return value;
    }
    if (Class.class.equals(expectedType)) {
      if (!(value instanceof Type)) {
        logger.log(TreeLogger.WARN,""String_Node_Str"" + ""String_Node_Str"" + value);
        return null;
      }
      Type valueType=(Type)value;
      try {
        return forName(valueType.getClassName());
      }
 catch (      ClassNotFoundException e) {
        logger.log(TreeLogger.ERROR,""String_Node_Str"" + valueType.getClassName(),e);
        return null;
      }
    }
    return value;
  }
}","@SuppressWarnings(""String_Node_Str"") private Object resolveAnnotationValue(TreeLogger logger,Class<?> expectedType,Object value){
  if (expectedType.isArray()) {
    Class<?> componentType=expectedType.getComponentType();
    if (!value.getClass().isArray()) {
      logger.log(TreeLogger.WARN,""String_Node_Str"" + componentType.getCanonicalName() + ""String_Node_Str""+ value.getClass().getCanonicalName());
      return null;
    }
    if (componentType.isPrimitive()) {
      return value;
    }
    int n=Array.getLength(value);
    Object newArray=Array.newInstance(componentType,n);
    for (int i=0; i < n; ++i) {
      Object valueElement=Array.get(value,i);
      Object resolvedValue=resolveAnnotationValue(logger,componentType,valueElement);
      if (resolvedValue == null || !componentType.isAssignableFrom(resolvedValue.getClass())) {
        logger.log(TreeLogger.ERROR,""String_Node_Str"" + componentType + ""String_Node_Str""+ resolvedValue);
      }
 else {
        Array.set(newArray,i,resolvedValue);
      }
    }
    return newArray;
  }
 else   if (expectedType.isEnum()) {
    if (!(value instanceof AnnotationEnum)) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"" + ""String_Node_Str"" + value);
      return null;
    }
    AnnotationEnum annotEnum=(AnnotationEnum)value;
    Class<? extends Enum> enumType=expectedType.asSubclass(Enum.class);
    try {
      return Enum.valueOf(enumType,annotEnum.getValue());
    }
 catch (    IllegalArgumentException e) {
      logger.log(TreeLogger.WARN,""String_Node_Str"" + annotEnum.getValue() + ""String_Node_Str""+ enumType.getName()+ ""String_Node_Str"");
      return null;
    }
  }
 else   if (Annotation.class.isAssignableFrom(expectedType)) {
    if (!(value instanceof AnnotationData)) {
      logger.log(TreeLogger.WARN,""String_Node_Str"" + expectedType.getCanonicalName() + ""String_Node_Str""+ value.getClass().getCanonicalName());
      return null;
    }
    AnnotationData annotData=(AnnotationData)value;
    Class<? extends Annotation> annotationClass=getAnnotationClass(logger,annotData);
    if (!expectedType.isAssignableFrom(annotationClass)) {
      logger.log(TreeLogger.WARN,""String_Node_Str"" + expectedType.getCanonicalName() + ""String_Node_Str""+ annotationClass.getCanonicalName());
      return null;
    }
    return createAnnotation(logger,annotationClass,annotData);
  }
 else   if (expectedType.isPrimitive()) {
    Class<?> wrapper=getWrapperClass(expectedType);
    return wrapper.cast(value);
  }
 else {
    if (expectedType.isAssignableFrom(value.getClass())) {
      return value;
    }
    if (Class.class.equals(expectedType)) {
      if (!(value instanceof Type)) {
        logger.log(TreeLogger.WARN,""String_Node_Str"" + ""String_Node_Str"" + value);
        return null;
      }
      Type valueType=(Type)value;
      try {
        return forName(valueType.getClassName());
      }
 catch (      ClassNotFoundException e) {
        logger.log(TreeLogger.WARN,""String_Node_Str"" + valueType.getClassName());
        return null;
      }
    }
    return value;
  }
}",0.998530132288094
53509,"private Annotation createAnnotation(TreeLogger logger,Class<? extends Annotation> annotationClass,AnnotationData annotationData){
  Map<String,Object> values=Maps.newHashMap(annotationData.getValues());
  for (  Map.Entry<String,Object> entry : values.entrySet()) {
    Method method=null;
    Throwable caught=null;
    try {
      method=annotationClass.getMethod(entry.getKey());
      entry.setValue(resolveAnnotationValue(logger,method.getReturnType(),entry.getValue()));
    }
 catch (    SecurityException e) {
      caught=e;
    }
catch (    NoSuchMethodException e) {
      caught=e;
    }
    if (caught != null) {
      logger.log(TreeLogger.WARN,""String_Node_Str"" + annotationClass.getCanonicalName() + ""String_Node_Str""+ entry.getKey(),caught);
      return null;
    }
  }
  return AnnotationProxyFactory.create(annotationClass,values);
}","private Annotation createAnnotation(TreeLogger logger,Class<? extends Annotation> annotationClass,AnnotationData annotationData){
  Map<String,Object> values=Maps.newHashMap(annotationData.getValues());
  logger=logger.branch(TreeLogger.TRACE,""String_Node_Str"" + annotationClass.getName());
  for (  Map.Entry<String,Object> entry : values.entrySet()) {
    Method method=null;
    Throwable caught=null;
    try {
      method=annotationClass.getMethod(entry.getKey());
      entry.setValue(resolveAnnotationValue(logger,method.getReturnType(),entry.getValue()));
    }
 catch (    SecurityException e) {
      caught=e;
    }
catch (    NoSuchMethodException e) {
      caught=e;
    }
    if (caught != null) {
      logger.log(TreeLogger.WARN,""String_Node_Str"" + annotationClass.getCanonicalName() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ caught.getMessage());
      return null;
    }
  }
  return AnnotationProxyFactory.create(annotationClass,values);
}",0.9261083743842364
53510,"/** 
 * Transform a call to a pruned instance method (or static impl) into a call to the null method, which will be used to replace <code>x</code>.
 */
public static JMethodCall transformToNullMethodCall(JMethodCall x,JProgram program){
  JExpression instance=x.getInstance();
  List<JExpression> args=x.getArgs();
  if (program.isStaticImpl(x.getTarget())) {
    instance=args.get(0);
    args=args.subList(1,args.size());
  }
 else {
    if (x.getTarget().isStatic() && instance == null) {
      instance=program.getLiteralNull();
    }
  }
  assert(instance != null);
  if (!instance.hasSideEffects()) {
    instance=program.getLiteralNull();
  }
  JMethodCall newCall=new JMethodCall(x.getSourceInfo(),instance,program.getNullMethod(),primitiveTypeOrNullType(program,x.getType()));
  for (  JExpression arg : args) {
    if (arg.hasSideEffects()) {
      newCall.addArg(arg);
    }
  }
  return newCall;
}","/** 
 * Transform a call to a pruned instance method (or static impl) into a call to the null method, which will be used to replace <code>x</code>.
 */
public static JMethodCall transformToNullMethodCall(JMethodCall x,JProgram program){
  JExpression instance=x.getInstance();
  List<JExpression> args=x.getArgs();
  if (program.isStaticImpl(x.getTarget())) {
    instance=args.get(0);
    args=args.subList(1,args.size());
  }
 else {
    if (x.getTarget().isStatic() && instance == null) {
      instance=program.getLiteralNull();
    }
  }
  assert(instance != null);
  if (!instance.hasSideEffects()) {
    instance=program.getLiteralNull();
  }
  JMethodCall newCall=new JMethodCall(x.getSourceInfo(),instance,program.getNullMethod(),primitiveTypeOrNullTypeOrArray(program,x.getType()));
  for (  JExpression arg : args) {
    if (arg.hasSideEffects()) {
      newCall.addArg(arg);
    }
  }
  return newCall;
}",0.9961643835616438
53511,"public void testSmoke() throws Exception {
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetImport(""String_Node_Str"");
  addSnippetImport(""String_Node_Str"");
  addSnippetImport(""String_Node_Str"" + ""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetImport(""String_Node_Str"");
  addSnippetImport(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  Result result;
  (result=optimize(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).intoString(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertNotNull(result.findMethod(""String_Node_Str""));
  assertNotNull(result.findField(""String_Node_Str""));
  assertNotNull(result.findMethod(""String_Node_Str""));
  assertNotNull(result.findMethod(""String_Node_Str""));
  assertNotNull(result.findMethod(""String_Node_Str""));
  assertNotNull(result.findClass(""String_Node_Str""));
  assertNotNull(result.findClass(""String_Node_Str""));
  assertNull(result.findMethod(""String_Node_Str""));
  assertNull(result.findField(""String_Node_Str""));
  assertNull(result.findField(""String_Node_Str""));
  assertNull(result.findClass(""String_Node_Str""));
  assertNull(result.findMethod(""String_Node_Str""));
  assertNull(result.findField(""String_Node_Str""));
  assertNull(result.findClass(""String_Node_Str""));
  assertNull(result.findClass(""String_Node_Str""));
  assertEquals(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",result.findMethod(""String_Node_Str"").toSource());
  assertEquals(""String_Node_Str"" + ""String_Node_Str"",result.findMethod(""String_Node_Str"").toSource());
  assertEquals(""String_Node_Str"",((JsniMethodBody)result.findMethod(""String_Node_Str"").getBody()).getJsniFieldRefs().toString());
  assertEquals(""String_Node_Str"",((JsniMethodBody)result.findMethod(""String_Node_Str"").getBody()).getJsniMethodRefs().toString());
  assertEquals(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",result.findClass(""String_Node_Str"").toSource());
  assertEquals(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",findMethod(result.findClass(""String_Node_Str""),""String_Node_Str"").toSource());
  assertNull(result.findClass(""String_Node_Str""));
  assertNotNull(result.findClass(""String_Node_Str""));
}","public void testSmoke() throws Exception {
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"" + ""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetImport(""String_Node_Str"");
  addSnippetImport(""String_Node_Str"");
  addSnippetImport(""String_Node_Str"" + ""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetImport(""String_Node_Str"");
  addSnippetImport(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  Result result;
  (result=optimize(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).intoString(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertNotNull(result.findMethod(""String_Node_Str""));
  assertNotNull(result.findField(""String_Node_Str""));
  assertNotNull(result.findMethod(""String_Node_Str""));
  assertNotNull(result.findMethod(""String_Node_Str""));
  assertNotNull(result.findMethod(""String_Node_Str""));
  assertNotNull(result.findClass(""String_Node_Str""));
  assertNotNull(result.findClass(""String_Node_Str""));
  assertNull(result.findMethod(""String_Node_Str""));
  assertNull(result.findField(""String_Node_Str""));
  assertNull(result.findField(""String_Node_Str""));
  assertNull(result.findClass(""String_Node_Str""));
  assertNull(result.findMethod(""String_Node_Str""));
  assertNull(result.findField(""String_Node_Str""));
  assertNull(result.findClass(""String_Node_Str""));
  assertNull(result.findClass(""String_Node_Str""));
  assertEquals(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",result.findMethod(""String_Node_Str"").toSource());
  assertEquals(""String_Node_Str"" + ""String_Node_Str"",result.findMethod(""String_Node_Str"").toSource());
  assertEquals(""String_Node_Str"",((JsniMethodBody)result.findMethod(""String_Node_Str"").getBody()).getJsniFieldRefs().toString());
  assertEquals(""String_Node_Str"",((JsniMethodBody)result.findMethod(""String_Node_Str"").getBody()).getJsniMethodRefs().toString());
  assertEquals(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",result.findClass(""String_Node_Str"").toSource());
  assertEquals(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",findMethod(result.findClass(""String_Node_Str""),""String_Node_Str"").toSource());
  assertNull(result.findClass(""String_Node_Str""));
  assertNotNull(result.findClass(""String_Node_Str""));
}",0.9974580579562786
53512,"private void assumeAllClassesCanObserveUninitializedSubclassFields(JProgram program){
  canObserveSubclassFields.addAll(program.getModuleDeclaredTypes());
}","private void assumeAllClassesCanObserveUninitializedSubclassFields(JProgram program){
  canObserveSubclassFields.addAll(program.getDeclaredTypes());
}",0.9803921568627452
53513,"private void checkPerFileRecompile_noop(JsOutputOption output) throws UnableToCompleteException, IOException, InterruptedException {
  MinimalRebuildCache relinkMinimalRebuildCache=new MinimalRebuildCache();
  File relinkApplicationDir=Files.createTempDir();
  String originalJs=compileToJs(relinkApplicationDir,""String_Node_Str"",Lists.newArrayList(simpleModuleResource,simpleModelEntryPointResource,simpleModelResource),relinkMinimalRebuildCache,emptySet,output);
  String relinkedJs=compileToJs(relinkApplicationDir,""String_Node_Str"",Lists.<MockResource>newArrayList(),relinkMinimalRebuildCache,emptySet,output);
  assertTrue(originalJs.equals(relinkedJs));
}","private void checkPerFileRecompile_noop(JsOutputOption output) throws UnableToCompleteException, IOException, InterruptedException {
  MinimalRebuildCache relinkMinimalRebuildCache=new MinimalRebuildCache();
  File relinkApplicationDir=Files.createTempDir();
  String originalJs=compileToJs(relinkApplicationDir,""String_Node_Str"",Lists.newArrayList(simpleModuleResource,simpleModelEntryPointResource,simpleModelResource,constantsModelResource),relinkMinimalRebuildCache,emptySet,output);
  String relinkedJs=compileToJs(relinkApplicationDir,""String_Node_Str"",Lists.<MockResource>newArrayList(),relinkMinimalRebuildCache,emptySet,output);
  assertTrue(originalJs.equals(relinkedJs));
}",0.982899628252788
53514,"private void checkPerFileRecompile_dateStampChange(JsOutputOption output) throws UnableToCompleteException, IOException, InterruptedException {
  MinimalRebuildCache relinkMinimalRebuildCache=new MinimalRebuildCache();
  File relinkApplicationDir=Files.createTempDir();
  String originalJs=compileToJs(relinkApplicationDir,""String_Node_Str"",Lists.newArrayList(simpleModuleResource,simpleModelEntryPointResource,simpleModelResource),relinkMinimalRebuildCache,emptySet,output);
  String relinkedJs=compileToJs(relinkApplicationDir,""String_Node_Str"",Lists.<MockResource>newArrayList(simpleModelResource),relinkMinimalRebuildCache,stringSet(""String_Node_Str"",""String_Node_Str""),output);
  assertTrue(originalJs.equals(relinkedJs));
}","private void checkPerFileRecompile_dateStampChange(JsOutputOption output) throws UnableToCompleteException, IOException, InterruptedException {
  MinimalRebuildCache relinkMinimalRebuildCache=new MinimalRebuildCache();
  File relinkApplicationDir=Files.createTempDir();
  String originalJs=compileToJs(relinkApplicationDir,""String_Node_Str"",Lists.newArrayList(simpleModuleResource,simpleModelEntryPointResource,simpleModelResource,constantsModelResource),relinkMinimalRebuildCache,emptySet,output);
  String relinkedJs=compileToJs(relinkApplicationDir,""String_Node_Str"",Lists.<MockResource>newArrayList(simpleModelResource),relinkMinimalRebuildCache,stringSet(""String_Node_Str"",""String_Node_Str""),output);
  assertTrue(originalJs.equals(relinkedJs));
}",0.9844699527346388
53515,"private void checkPerFileRecompile_functionSignatureChange(JsOutputOption output) throws UnableToCompleteException, IOException, InterruptedException {
  checkRecompiledModifiedApp(""String_Node_Str"",Lists.newArrayList(simpleModuleResource,simpleModelEntryPointResource),simpleModelResource,modifiedFunctionSignatureSimpleModelResource,stringSet(""String_Node_Str"",""String_Node_Str""),output);
}","private void checkPerFileRecompile_functionSignatureChange(JsOutputOption output) throws UnableToCompleteException, IOException, InterruptedException {
  checkRecompiledModifiedApp(""String_Node_Str"",Lists.newArrayList(simpleModuleResource,simpleModelEntryPointResource,constantsModelResource),simpleModelResource,modifiedFunctionSignatureSimpleModelResource,stringSet(""String_Node_Str"",""String_Node_Str""),output);
}",0.9714993804213136
53516,"@Override public String get(String key){
  return null;
}","Object get(){
  if (counter >= 0) {
    counter++;
  }
  return ""String_Node_Str"";
}",0.3546099290780142
53517,"/** 
 * Called once for every inner class of this class.
 * @param internalName internal name of inner class (ie, com/google/Foo$1)
 * @param enclosingInternalName internal name of enclosing class (null if not a memberclass or anonymous)
 * @param innerName simple name of the inner class (null if anonymous)
 * @param access access flags (bitwise or of Opcodes.ACC_*) as declared in theenclosing class
 */
@Override public void visitInnerClass(String internalName,String enclosingInternalName,String innerName,int access){
  buildNestedSourceName(internalName,enclosingInternalName,innerName);
  if (this.internalName.equals(internalName)) {
    if (enclosingInternalName != null) {
      this.enclosingInternalName=enclosingInternalName;
    }
    int copyFlags=access & (Opcodes.ACC_STATIC | Opcodes.ACC_PRIVATE);
    this.access|=copyFlags;
    boolean isStatic=(access & Opcodes.ACC_STATIC) != 0;
switch (classType) {
case TopLevel:
      classType=isStatic ? ClassType.Nested : ClassType.Inner;
    break;
case Anonymous:
  if (innerName != null) {
    classType=ClassType.Local;
  }
break;
case Inner:
break;
default :
throw new IllegalStateException(""String_Node_Str"" + classType);
}
}
}","/** 
 * Called once for every inner class of this class.
 * @param internalName internal name of inner class (ie, com/google/Foo$1)
 * @param enclosingInternalName internal name of enclosing class (null if not a memberclass or anonymous)
 * @param innerName simple name of the inner class (null if anonymous)
 * @param access access flags (bitwise or of Opcodes.ACC_*) as declared in theenclosing class
 */
@Override public void visitInnerClass(String internalName,String enclosingInternalName,String innerName,int access){
  buildNestedSourceName(internalName,enclosingInternalName,innerName);
  if (this.internalName.equals(internalName)) {
    if (enclosingInternalName != null) {
      this.enclosingInternalName=enclosingInternalName;
    }
    this.access=access;
    boolean isStatic=(access & Opcodes.ACC_STATIC) != 0;
switch (classType) {
case TopLevel:
      classType=isStatic ? ClassType.Nested : ClassType.Inner;
    break;
case Anonymous:
  if (innerName != null) {
    classType=ClassType.Local;
  }
break;
case Inner:
break;
default :
throw new IllegalStateException(""String_Node_Str"" + classType);
}
}
}",0.6963282937365011
53518,"public void testTwo(){
  CollectClassData cd=collect(Two.class);
  assertEquals(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,cd.getAccess() & ~Opcodes.ACC_SUPER);
  assertEquals(ClassType.Nested,cd.getClassType());
  List<CollectFieldData> fields=cd.getFields();
  assertEquals(2,fields.size());
  CollectFieldData field=fields.get(0);
  assertEquals(""String_Node_Str"",field.getName());
  assertEquals(""String_Node_Str"",field.getDesc());
  List<CollectAnnotationData> annotations=field.getAnnotations();
  assertEquals(0,annotations.size());
  field=fields.get(1);
  assertEquals(""String_Node_Str"",field.getName());
  assertEquals(""String_Node_Str"",field.getDesc());
  annotations=field.getAnnotations();
  assertEquals(1,annotations.size());
  AnnotationData annotation=annotations.get(0).getAnnotation();
  assertEquals(""String_Node_Str"",annotation.getDesc());
  assertEquals(""String_Node_Str"",annotation.getValues().get(""String_Node_Str""));
  assertEquals(0,cd.getInterfaceInternalNames().length);
  annotations=cd.getAnnotations();
  assertEquals(1,annotations.size());
  annotation=annotations.get(0).getAnnotation();
  assertEquals(""String_Node_Str"",annotation.getDesc());
  assertEquals(Byte.valueOf((byte)42),annotation.getValues().get(""String_Node_Str""));
  assertEquals(42,annotation.getValues().get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",cd.getSuperInternalName());
  assertEquals(""String_Node_Str"",cd.getNestedSourceName());
  List<CollectMethodData> methods=cd.getMethods();
  assertEquals(3,methods.size());
  CollectMethodData method=methods.get(0);
  Type[] argTypes=method.getArgTypes();
  String[] argNames=method.getArgNames();
  assertEquals(""String_Node_Str"",method.getName());
  assertEquals(1,argTypes.length);
  assertEquals(1,argNames.length);
  assertEquals(1,method.getArgAnnotations().length);
  assertEquals(0,method.getAnnotations().size());
  assertEquals(0,method.getExceptions().length);
  method=methods.get(1);
  argTypes=method.getArgTypes();
  argNames=method.getArgNames();
  assertEquals(""String_Node_Str"",method.getName());
  assertEquals(1,argTypes.length);
  assertEquals(""String_Node_Str"",argTypes[0].getClassName());
  assertEquals(1,argNames.length);
  assertEquals(""String_Node_Str"",argNames[0]);
  assertEquals(1,method.getArgAnnotations().length);
  assertEquals(0,method.getArgAnnotations()[0].size());
  assertEquals(1,method.getAnnotations().size());
  assertEquals(1,method.getExceptions().length);
  method=methods.get(2);
  argTypes=method.getArgTypes();
  argNames=method.getArgNames();
  assertEquals(""String_Node_Str"",method.getName());
  assertEquals(2,argTypes.length);
  assertEquals(""String_Node_Str"",argTypes[0].getClassName());
  assertEquals(""String_Node_Str"",argTypes[1].getClassName());
  assertEquals(2,argNames.length);
  assertEquals(""String_Node_Str"",argNames[0]);
  assertEquals(""String_Node_Str"",argNames[1]);
  assertEquals(2,method.getArgAnnotations().length);
  assertEquals(0,method.getArgAnnotations()[0].size());
  assertEquals(0,method.getArgAnnotations()[1].size());
  assertEquals(0,method.getAnnotations().size());
  assertEquals(0,method.getExceptions().length);
}","public void testTwo(){
  CollectClassData cd=collect(Two.class);
  assertEquals(Opcodes.ACC_PROTECTED | Opcodes.ACC_STATIC,cd.getAccess() & ~Opcodes.ACC_SUPER);
  assertEquals(ClassType.Nested,cd.getClassType());
  List<CollectFieldData> fields=cd.getFields();
  assertEquals(2,fields.size());
  CollectFieldData field=fields.get(0);
  assertEquals(""String_Node_Str"",field.getName());
  assertEquals(""String_Node_Str"",field.getDesc());
  List<CollectAnnotationData> annotations=field.getAnnotations();
  assertEquals(0,annotations.size());
  field=fields.get(1);
  assertEquals(""String_Node_Str"",field.getName());
  assertEquals(""String_Node_Str"",field.getDesc());
  annotations=field.getAnnotations();
  assertEquals(1,annotations.size());
  AnnotationData annotation=annotations.get(0).getAnnotation();
  assertEquals(""String_Node_Str"",annotation.getDesc());
  assertEquals(""String_Node_Str"",annotation.getValues().get(""String_Node_Str""));
  assertEquals(0,cd.getInterfaceInternalNames().length);
  annotations=cd.getAnnotations();
  assertEquals(1,annotations.size());
  annotation=annotations.get(0).getAnnotation();
  assertEquals(""String_Node_Str"",annotation.getDesc());
  assertEquals(Byte.valueOf((byte)42),annotation.getValues().get(""String_Node_Str""));
  assertEquals(42,annotation.getValues().get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",cd.getSuperInternalName());
  assertEquals(""String_Node_Str"",cd.getNestedSourceName());
  List<CollectMethodData> methods=cd.getMethods();
  assertEquals(3,methods.size());
  CollectMethodData method=methods.get(0);
  Type[] argTypes=method.getArgTypes();
  String[] argNames=method.getArgNames();
  assertEquals(""String_Node_Str"",method.getName());
  assertEquals(1,argTypes.length);
  assertEquals(1,argNames.length);
  assertEquals(1,method.getArgAnnotations().length);
  assertEquals(0,method.getAnnotations().size());
  assertEquals(0,method.getExceptions().length);
  method=methods.get(1);
  argTypes=method.getArgTypes();
  argNames=method.getArgNames();
  assertEquals(""String_Node_Str"",method.getName());
  assertEquals(1,argTypes.length);
  assertEquals(""String_Node_Str"",argTypes[0].getClassName());
  assertEquals(1,argNames.length);
  assertEquals(""String_Node_Str"",argNames[0]);
  assertEquals(1,method.getArgAnnotations().length);
  assertEquals(0,method.getArgAnnotations()[0].size());
  assertEquals(1,method.getAnnotations().size());
  assertEquals(1,method.getExceptions().length);
  method=methods.get(2);
  argTypes=method.getArgTypes();
  argNames=method.getArgNames();
  assertEquals(""String_Node_Str"",method.getName());
  assertEquals(2,argTypes.length);
  assertEquals(""String_Node_Str"",argTypes[0].getClassName());
  assertEquals(""String_Node_Str"",argTypes[1].getClassName());
  assertEquals(2,argNames.length);
  assertEquals(""String_Node_Str"",argNames[0]);
  assertEquals(""String_Node_Str"",argNames[1]);
  assertEquals(2,method.getArgAnnotations().length);
  assertEquals(0,method.getArgAnnotations()[0].size());
  assertEquals(0,method.getArgAnnotations()[1].size());
  assertEquals(0,method.getAnnotations().size());
  assertEquals(0,method.getExceptions().length);
}",0.998258667088808
53519,"@Override protected void postNormalizationOptimizeJava(){
  RemoveSpecializations.exec(jprogram);
  Pruner.exec(jprogram,false);
  ReplaceGetClassOverrides.exec(jprogram);
}","@Override protected void postNormalizationOptimizeJava(){
  if (options.getOptimizationLevel() > OptionOptimize.OPTIMIZE_LEVEL_DRAFT) {
    RemoveSpecializations.exec(jprogram);
    Pruner.exec(jprogram,false);
  }
  ReplaceGetClassOverrides.exec(jprogram);
}",0.8009259259259259
53520,"private JField createSyntheticField(SyntheticArgumentBinding arg,JDeclaredType enclosingType,Disposition disposition){
  JType type=typeMap.get(arg.type);
  SourceInfo info=enclosingType.getSourceInfo();
  JField field=new JField(info,intern(arg.name),enclosingType,type,false,disposition);
  enclosingType.addField(field);
  curClass.syntheticFields.put(arg,field);
  if (arg.matchingField != null) {
    typeMap.setField(arg.matchingField,field);
  }
  return field;
}","private JField createSyntheticField(SyntheticArgumentBinding arg,JDeclaredType enclosingType,Disposition disposition){
  JType type=typeMap.get(arg.type);
  SourceInfo info=enclosingType.getSourceInfo();
  String fieldName=intern(intern(arg.name) + arg.resolvedPosition);
  JField field=new JField(info,fieldName,enclosingType,type,false,disposition);
  enclosingType.addField(field);
  curClass.syntheticFields.put(arg,field);
  if (arg.matchingField != null) {
    typeMap.setField(arg.matchingField,field);
  }
  return field;
}",0.913086913086913
53521,"private void pruneDeadFieldsAndMethods(){
  for (  JDeclaredType type : program.getDeclaredTypes()) {
    boolean isInstantiated=instantiatedTypes.contains(type);
    for (int fieldIndex=0; fieldIndex < type.getFields().size(); ++fieldIndex) {
      JField field=type.getFields().get(fieldIndex);
      if (!liveFieldsAndMethods.contains(field) || (!field.isStatic() && !isInstantiated)) {
        type.removeField(fieldIndex);
        --fieldIndex;
      }
    }
    JMethod clinit=type.getClinitMethod();
    if (!liveFieldsAndMethods.contains(clinit)) {
      clinit.setBody(new JMethodBody(SourceOrigin.UNKNOWN));
    }
    for (int methodIndex=1; methodIndex < type.getMethods().size(); ++methodIndex) {
      JMethod method=type.getMethods().get(methodIndex);
      if (!liveFieldsAndMethods.contains(method) || (!method.isStatic() && !isInstantiated)) {
        type.removeMethod(methodIndex);
        --methodIndex;
      }
    }
  }
}","private void pruneDeadFieldsAndMethods(){
  for (  JDeclaredType type : program.getDeclaredTypes()) {
    for (int fieldIndex=0; fieldIndex < type.getFields().size(); ++fieldIndex) {
      JField field=type.getFields().get(fieldIndex);
      if (!liveFieldsAndMethods.contains(field)) {
        type.removeField(fieldIndex);
        --fieldIndex;
      }
    }
    JMethod clinit=type.getClinitMethod();
    if (!liveFieldsAndMethods.contains(clinit)) {
      clinit.setBody(new JMethodBody(SourceOrigin.UNKNOWN));
    }
    for (int methodIndex=1; methodIndex < type.getMethods().size(); ++methodIndex) {
      JMethod method=type.getMethods().get(methodIndex);
      if (!liveFieldsAndMethods.contains(method)) {
        type.removeMethod(methodIndex);
        --methodIndex;
      }
    }
  }
}",0.9160919540229884
53522,"/** 
 * getElementById, getElementsByTagName.
 */
public void testGetElements(){
  Document doc=Document.get();
  DivElement div=doc.createDivElement();
  doc.getBody().appendChild(div);
  div.setInnerHTML(""String_Node_Str"");
  NodeList<Element> nodes=doc.getElementsByTagName(""String_Node_Str"");
  assertEquals(2,nodes.getLength());
  assertEquals(""String_Node_Str"",nodes.getItem(0).getInnerText());
  assertEquals(""String_Node_Str"",nodes.getItem(1).getInnerText());
  Element foo=doc.getElementById(""String_Node_Str"");
  assertEquals(""String_Node_Str"",foo.getId());
}","/** 
 * getElementById, getElementsByTagName.
 */
public void testGetElements(){
  Document doc=Document.get();
  DivElement div=doc.createDivElement();
  doc.getBody().removeAllChildren();
  doc.getBody().appendChild(div);
  div.setInnerHTML(""String_Node_Str"");
  NodeList<Element> nodes=doc.getElementsByTagName(""String_Node_Str"");
  assertEquals(2,nodes.getLength());
  assertEquals(""String_Node_Str"",nodes.getItem(0).getInnerText());
  assertEquals(""String_Node_Str"",nodes.getItem(1).getInnerText());
  Element foo=doc.getElementById(""String_Node_Str"");
  assertEquals(""String_Node_Str"",foo.getId());
}",0.9685106382978724
53523,"/** 
 * A method needs a JsInterop bridge if any of the following are true: 1) the method name conflicts with a method name of a non-JsType/JsExport method in a superclass 2) the method returns or accepts Single-Abstract-Method types 3) the method returns or accepts JsAware/JsConvert types.
 */
public boolean needsJsInteropBridgeMethod(JMethod x){
  if (!isInteropEnabled()) {
    return false;
  }
  if (x.needsVtable() && isJsTypeMethod(x)) {
    for (    JMethod override : getAllOverriddenMethods(x)) {
      if (!isJsTypeMethod(override)) {
        return true;
      }
    }
  }
  if (isJsTypeMethod(x) || isExportedMethod(x)) {
    if (x.getOriginalReturnType() == JPrimitiveType.LONG) {
      return true;
    }
    for (    JParameter p : x.getParams()) {
      if (p.getType() == JPrimitiveType.LONG) {
        return true;
      }
    }
  }
  return false;
}","/** 
 * A method needs a JsInterop bridge if any of the following are true: 1) the method name conflicts with a method name of a non-JsType/JsExport method in a superclass 2) the method returns or accepts Single-Abstract-Method types 3) the method returns or accepts JsAware/JsConvert types.
 */
public boolean needsJsInteropBridgeMethod(JMethod x){
  if (!isInteropEnabled()) {
    return false;
  }
  List<JParameter> xParams=x.getParams();
  if (isJsTypeMethod(x)) {
    for (    JMethod other : x.getEnclosingType().getMethods()) {
      if (other == x) {
        continue;
      }
      if (isJsTypeMethod(other) && x.getName().equals(other.getName())) {
        List<JParameter> otherParams=other.getParams();
        if (otherParams.size() == xParams.size()) {
          for (int i=0; i < otherParams.size(); i++) {
            if (otherParams.get(i).getType() != xParams.get(i).getType()) {
              break;
            }
          }
          return true;
        }
 else {
          break;
        }
      }
    }
  }
  if (x.needsVtable() && isJsTypeMethod(x)) {
    for (    JMethod override : getAllOverriddenMethods(x)) {
      if (!isJsTypeMethod(override)) {
        return true;
      }
    }
  }
  if (isJsTypeMethod(x) || isExportedMethod(x)) {
    if (x.getOriginalReturnType() == JPrimitiveType.LONG) {
      return true;
    }
    for (    JParameter p : xParams) {
      if (p.getType() == JPrimitiveType.LONG) {
        return true;
      }
    }
  }
  return false;
}",0.7308829742289819
53524,"private void maybeDispatchViaTrampolineToBridgeMethod(JMethodCall x,JMethod method,JsInvocation jsInvocation,JsExpression unnecessaryQualifier,JsExpression result,JsName polyName){
  JsName tempLocal=createTmpLocal();
  JsExpression tmp=createAssignment(tempLocal.makeRef(x.getSourceInfo()),((JsExpression)pop()));
  JsName trampMethName=indexedFunctions.get(""String_Node_Str"").getName();
  JsName bridgejsName=polyName.getEnclosing().findExistingName(method.getName());
  JsNameRef bridgeRef=bridgejsName != null ? bridgejsName.makeRef(x.getSourceInfo()) : new JsNameRef(x.getSourceInfo(),method.getName());
  bridgeRef.setQualifier(tempLocal.makeRef(x.getSourceInfo()));
  JsNameRef javaMethRef=polyName.makeRef(x.getSourceInfo());
  javaMethRef.setQualifier(tempLocal.makeRef(x.getSourceInfo()));
  JsInvocation callTramp=new JsInvocation(x.getSourceInfo(),trampMethName.makeRef(x.getSourceInfo()),tempLocal.makeRef(x.getSourceInfo()),bridgeRef,javaMethRef);
  JsNameRef bind=new JsNameRef(x.getSourceInfo(),""String_Node_Str"");
  JsInvocation callBind=new JsInvocation(x.getSourceInfo());
  callBind.setQualifier(bind);
  callBind.getArguments().add(tempLocal.makeRef(x.getSourceInfo()));
  bind.setQualifier(createCommaExpression(tmp,callTramp));
  jsInvocation.setQualifier(callBind);
  push(createCommaExpression(unnecessaryQualifier,result));
}","private void maybeDispatchViaTrampolineToBridgeMethod(JMethodCall x,JMethod method,JsInvocation jsInvocation,JsExpression unnecessaryQualifier,JsExpression result,JsName polyName){
  JsName tempLocal=createTmpLocal();
  JsExpression tmp=createAssignment(tempLocal.makeRef(x.getSourceInfo()),((JsExpression)pop()));
  JsName trampMethName=indexedFunctions.get(""String_Node_Str"").getName();
  JsName bridgejsName=polyName.getEnclosing().findExistingName(method.getName());
  JsNameRef bridgeRef=bridgejsName != null ? bridgejsName.makeRef(x.getSourceInfo()) : new JsNameRef(x.getSourceInfo(),method.getName());
  bridgeRef.setQualifier(tempLocal.makeRef(x.getSourceInfo()));
  JsNameRef javaMethRef=polyName.makeRef(x.getSourceInfo());
  javaMethRef.setQualifier(tempLocal.makeRef(x.getSourceInfo()));
  JsInvocation callTramp=new JsInvocation(x.getSourceInfo(),trampMethName.makeRef(x.getSourceInfo()),tempLocal.makeRef(x.getSourceInfo()),bridgeRef,javaMethRef);
  JsNameRef bind=new JsNameRef(x.getSourceInfo(),""String_Node_Str"");
  JsInvocation callBind=new JsInvocation(x.getSourceInfo());
  callBind.setQualifier(bind);
  callBind.getArguments().add(tempLocal.makeRef(x.getSourceInfo()));
  bind.setQualifier(callTramp);
  jsInvocation.setQualifier(callBind);
  result=createCommaExpression(tmp,jsInvocation);
  push(createCommaExpression(unnecessaryQualifier,result));
}",0.9644036697247708
53525,"private JDeclaredType internalFindType(String typeName,NameBasedTypeLocator nameBasedTypeLocator,boolean reportErrors){
  if (nameBasedTypeLocator.resolvedTypeIsAvailable(typeName)) {
    return nameBasedTypeLocator.getResolvedType(typeName);
  }
  if (nameBasedTypeLocator.sourceCompilationUnitIsAvailable(typeName)) {
    assimilateSourceUnit(nameBasedTypeLocator.getCompilationUnitFromSource(typeName),reportErrors);
    return nameBasedTypeLocator.getResolvedType(typeName);
  }
  if (compilerContext.shouldCompileMonolithic()) {
    if (reportErrors) {
      if (nameBasedTypeLocator.hasCompileErrors(typeName)) {
        TreeLogger branch=logger.branch(TreeLogger.ERROR,String.format(""String_Node_Str"" + ""String_Node_Str"",typeName));
        nameBasedTypeLocator.logErrorTrace(branch,TreeLogger.ERROR,typeName);
      }
 else {
        logger.log(TreeLogger.ERROR,String.format(""String_Node_Str"",typeName));
      }
      errorsFound=true;
    }
    return null;
  }
  if (nameBasedTypeLocator.libraryCompilationUnitIsAvailable(typeName)) {
    assimilateLibraryUnit(nameBasedTypeLocator.getCompilationUnitFromLibrary(typeName),reportErrors);
    return nameBasedTypeLocator.getResolvedType(typeName);
  }
  if (nameBasedTypeLocator.hasCompileErrors(typeName)) {
    if (reportErrors) {
      TreeLogger branch=logger.branch(TreeLogger.ERROR,String.format(""String_Node_Str"",typeName));
      nameBasedTypeLocator.logErrorTrace(branch,TreeLogger.ERROR,typeName);
    }
 else {
      logger.log(TreeLogger.ERROR,String.format(""String_Node_Str"" + ""String_Node_Str"",typeName));
    }
    errorsFound=true;
  }
  return null;
}","private JDeclaredType internalFindType(String typeName,NameBasedTypeLocator nameBasedTypeLocator,boolean reportErrors){
  if (nameBasedTypeLocator.resolvedTypeIsAvailable(typeName)) {
    return nameBasedTypeLocator.getResolvedType(typeName);
  }
  if (nameBasedTypeLocator.sourceCompilationUnitIsAvailable(typeName)) {
    assimilateSourceUnit(nameBasedTypeLocator.getCompilationUnitFromSource(typeName),reportErrors);
    return nameBasedTypeLocator.getResolvedType(typeName);
  }
  if (!compilerContext.shouldCompileMonolithic() && nameBasedTypeLocator.libraryCompilationUnitIsAvailable(typeName)) {
    assimilateLibraryUnit(nameBasedTypeLocator.getCompilationUnitFromLibrary(typeName),reportErrors);
    return nameBasedTypeLocator.getResolvedType(typeName);
  }
  if (reportErrors) {
    if (nameBasedTypeLocator.hasCompileErrors(typeName)) {
      TreeLogger branch=logger.branch(TreeLogger.ERROR,String.format(""String_Node_Str"" + ""String_Node_Str"",typeName));
      nameBasedTypeLocator.logErrorTrace(branch,TreeLogger.ERROR,typeName);
    }
 else     if (compilerContext.shouldCompileMonolithic()) {
      logger.log(TreeLogger.ERROR,String.format(""String_Node_Str"",typeName));
    }
 else {
      logger.log(TreeLogger.ERROR,String.format(""String_Node_Str"" + ""String_Node_Str"",typeName));
    }
    errorsFound=true;
  }
  return null;
}",0.6426890756302521
53526,"/** 
 * Determine whether a type is instantiated.
 */
public boolean isInstantiatedType(JReferenceType type){
  type=type.getUnderlyingType();
  if (instantiatedTypes == null || instantiatedTypes.contains(type)) {
    return true;
  }
  if (type.isExternal()) {
    return true;
  }
  if (type instanceof JNullType) {
    return true;
  }
 else   if (type instanceof JArrayType) {
    JArrayType arrayType=(JArrayType)type;
    if (arrayType.getLeafType() instanceof JNullType) {
      return true;
    }
  }
  return false;
}","/** 
 * Determine whether a type is instantiated.
 */
public boolean isInstantiatedType(JReferenceType type){
  type=type.getUnderlyingType();
  if (isJsType(type) || hasAnyExports(type)) {
    return true;
  }
  if (instantiatedTypes == null || instantiatedTypes.contains(type)) {
    return true;
  }
  if (type.isExternal()) {
    return true;
  }
  if (type instanceof JNullType) {
    return true;
  }
 else   if (type instanceof JArrayType) {
    JArrayType arrayType=(JArrayType)type;
    if (arrayType.getLeafType() instanceof JNullType) {
      return true;
    }
  }
  return false;
}",0.9392857142857144
53527,"/** 
 * A method needs a JsInterop bridge if any of the following are true: 1) the method name conflicts with a method name of a non-JsType/JsExport method in a superclass 2) the method returns or accepts Single-Abstract-Method types 3) the method returns or accepts JsAware/JsConvert types.
 */
public boolean needsJsInteropBridgeMethod(JMethod x){
  if (isInteropEnabled() && x.needsVtable() && isJsTypeMethod(x)) {
    for (    JMethod override : getAllOverriddenMethods(x)) {
      if (!isJsTypeMethod(override)) {
        return true;
      }
    }
  }
  return false;
}","/** 
 * A method needs a JsInterop bridge if any of the following are true: 1) the method name conflicts with a method name of a non-JsType/JsExport method in a superclass 2) the method returns or accepts Single-Abstract-Method types 3) the method returns or accepts JsAware/JsConvert types.
 */
public boolean needsJsInteropBridgeMethod(JMethod x){
  if (isInteropEnabled() && x.needsVtable() && isJsTypeMethod(x)) {
    for (    JMethod override : getAllOverriddenMethods(x)) {
      if (!isJsTypeMethod(override)) {
        return true;
      }
    }
  }
  if (isInteropEnabled() && isJsTypeMethod(x) || isExportedMethod(x)) {
    if (x.getOriginalReturnType() == JPrimitiveType.LONG) {
      return true;
    }
    for (    JParameter p : x.getParams()) {
      if (p.getType() == JPrimitiveType.LONG) {
        return true;
      }
    }
  }
  return false;
}",0.7838776928422516
53528,"public boolean isExportedMethod(JMethod method){
  return isInteropEnabled() && method.getExportName() != null;
}","public boolean isExportedMethod(JMethod method){
  return isInteropEnabled() && method.getExportName() != null && !method.isNoExport();
}",0.904
53529,"private JsExpression createJsInteropBridgeMethod(JMethod m,JsNameRef methodRef){
  if (m.isStatic() || m instanceof JConstructor) {
    return methodRef;
  }
 else {
    JsFunction makeBridgeMethod=indexedFunctions.get(""String_Node_Str"");
    JsNameRef makeBridgeMethodRef=makeBridgeMethod.getName().makeRef(methodRef.getSourceInfo());
    JsInvocation invokeBridge=new JsInvocation(methodRef.getSourceInfo());
    invokeBridge.setQualifier(makeBridgeMethodRef);
    invokeBridge.getArguments().add(methodRef);
    return invokeBridge;
  }
}","private JsExpression createJsInteropBridgeMethod(JMethod m,JsNameRef methodRef){
  if (m.isStatic() || m instanceof JConstructor) {
    return methodRef;
  }
 else {
    JsFunction makeBridgeMethod=indexedFunctions.get(""String_Node_Str"");
    JsNameRef makeBridgeMethodRef=makeBridgeMethod.getName().makeRef(methodRef.getSourceInfo());
    JsInvocation invokeBridge=new JsInvocation(methodRef.getSourceInfo());
    invokeBridge.setQualifier(makeBridgeMethodRef);
    invokeBridge.getArguments().add(methodRef);
    invokeBridge.getArguments().add(m.getType() == JPrimitiveType.LONG ? JsBooleanLiteral.TRUE : JsBooleanLiteral.FALSE);
    JsArrayLiteral arrayLiteral=new JsArrayLiteral(m.getSourceInfo());
    for (    JParameter p : m.getParams()) {
      if (p.getType() == JPrimitiveType.LONG) {
        arrayLiteral.getExpressions().add(JsBooleanLiteral.TRUE);
      }
 else {
        arrayLiteral.getExpressions().add(JsBooleanLiteral.FALSE);
      }
    }
    invokeBridge.getArguments().add(arrayLiteral);
    return invokeBridge;
  }
}",0.672566371681416
53530,"private void generateExports(JDeclaredType x,List<JsStatement> globalStmts){
  String lastProvidedNamespace=""String_Node_Str"";
  boolean createdClinit=false;
  for (  JMethod m : x.getMethods()) {
    if (m.isNoExport()) {
      continue;
    }
    if ((m.isStatic() || m instanceof JConstructor && !((JConstructor)m).isDefaultConstructor()) && program.typeOracle.isExportedMethod(m)) {
      createdClinit=maybeHoistClinit(exportStmts,createdClinit,maybeCreateClinitCall(m));
      JsExpression exportRhs=createJsInteropBridgeMethod(m,names.get(m).makeRef(m.getSourceInfo()));
      String exportName=m.getQualifiedExportName();
      lastProvidedNamespace=exportMember(x,globalStmts,lastProvidedNamespace,exportRhs,exportName);
    }
  }
  for (  JField f : x.getFields()) {
    if (f.isStatic() && f.getExportName() != null) {
      createdClinit=maybeHoistClinit(exportStmts,createdClinit,maybeCreateClinitCall(f,true));
      JsNameRef exportRhs=names.get(f).makeRef(f.getSourceInfo());
      String exportName=f.getQualifiedExportName();
      lastProvidedNamespace=exportMember(x,globalStmts,lastProvidedNamespace,exportRhs,exportName);
    }
  }
}","private void generateExports(JDeclaredType x,List<JsStatement> globalStmts){
  String lastProvidedNamespace=""String_Node_Str"";
  boolean createdClinit=false;
  JConstructor ctor=null;
  for (  JMethod m : x.getMethods()) {
    if (m instanceof JConstructor) {
      if (!((JConstructor)m).isDefaultConstructor() && program.typeOracle.isExportedMethod(m)) {
        ctor=(JConstructor)m;
        break;
      }
    }
  }
  for (  JMethod m : x.getMethods()) {
    if (m instanceof JConstructor && m != ctor) {
      continue;
    }
    if (m == ctor && !m.isPrivate() || (m.isStatic()) && program.typeOracle.isExportedMethod(m)) {
      createdClinit=maybeHoistClinit(exportStmts,createdClinit,maybeCreateClinitCall(m));
      JsExpression exportRhs=createJsInteropBridgeMethod(m,names.get(m).makeRef(m.getSourceInfo()));
      String exportName=m.getQualifiedExportName();
      lastProvidedNamespace=exportMember(x,globalStmts,lastProvidedNamespace,exportRhs,exportName);
    }
  }
  for (  JField f : x.getFields()) {
    if (f.isStatic() && f.getExportName() != null) {
      createdClinit=maybeHoistClinit(exportStmts,createdClinit,maybeCreateClinitCall(f,true));
      JsNameRef exportRhs=names.get(f).makeRef(f.getSourceInfo());
      String exportName=f.getQualifiedExportName();
      lastProvidedNamespace=exportMember(x,globalStmts,lastProvidedNamespace,exportRhs,exportName);
    }
  }
}",0.4206815511163337
53531,"protected void endVisit(TypeDeclaration x){
  JDeclaredType type=curClass.type;
  if (type.getSuperClass() != null) {
    JMethod myClinit=type.getClinitMethod();
    JMethod superClinit=type.getSuperClass().getClinitMethod();
    JMethodCall superClinitCall=new JMethodCall(myClinit.getSourceInfo(),null,superClinit);
    JMethodBody body=(JMethodBody)myClinit.getBody();
    body.getBlock().addStmt(0,superClinitCall.makeStatement());
  }
  if (isSyntheticGetClassNeeded(x,type)) {
    implementGetClass(type);
  }
  if (type instanceof JEnumType) {
    processEnumType((JEnumType)type);
  }
  if (type instanceof JClassType) {
    addBridgeMethods(x.binding);
  }
  Binding[] rescues=artificialRescues.get(x);
  if (rescues != null) {
    for (    Binding rescue : rescues) {
      if (rescue instanceof TypeBinding) {
        type.addArtificialRescue(typeMap.get((TypeBinding)rescue));
      }
 else       if (rescue instanceof FieldBinding) {
        type.addArtificialRescue(typeMap.get((FieldBinding)rescue));
      }
 else       if (rescue instanceof MethodBinding) {
        type.addArtificialRescue(typeMap.get((MethodBinding)rescue));
      }
 else {
        throw new InternalCompilerException(""String_Node_Str"");
      }
    }
  }
  if (JsInteropUtil.isClassWideJsExport(x)) {
    for (    JMethod m : type.getMethods()) {
      if (m.getExportName() != null) {
        continue;
      }
      if (m.getAccess() == AccessModifier.PUBLIC && (m.isStatic() || (m instanceof JConstructor && !((JConstructor)m).isDefaultConstructor()))) {
        m.setExportName(""String_Node_Str"");
      }
    }
    for (    JField f : type.getFields()) {
      if (f.getExportName() != null) {
        continue;
      }
      if (f.isStatic()) {
        f.setExportName(""String_Node_Str"");
      }
    }
  }
  JsInteropUtil.maybeSetJsNamespace(type,x);
  curClass=classStack.pop();
}","protected void endVisit(TypeDeclaration x){
  JDeclaredType type=curClass.type;
  if (type.getSuperClass() != null) {
    JMethod myClinit=type.getClinitMethod();
    JMethod superClinit=type.getSuperClass().getClinitMethod();
    JMethodCall superClinitCall=new JMethodCall(myClinit.getSourceInfo(),null,superClinit);
    JMethodBody body=(JMethodBody)myClinit.getBody();
    body.getBlock().addStmt(0,superClinitCall.makeStatement());
  }
  if (isSyntheticGetClassNeeded(x,type)) {
    implementGetClass(type);
  }
  if (type instanceof JEnumType) {
    processEnumType((JEnumType)type);
  }
  if (type instanceof JClassType) {
    addBridgeMethods(x.binding);
  }
  Binding[] rescues=artificialRescues.get(x);
  if (rescues != null) {
    for (    Binding rescue : rescues) {
      if (rescue instanceof TypeBinding) {
        type.addArtificialRescue(typeMap.get((TypeBinding)rescue));
      }
 else       if (rescue instanceof FieldBinding) {
        type.addArtificialRescue(typeMap.get((FieldBinding)rescue));
      }
 else       if (rescue instanceof MethodBinding) {
        type.addArtificialRescue(typeMap.get((MethodBinding)rescue));
      }
 else {
        throw new InternalCompilerException(""String_Node_Str"");
      }
    }
  }
  if (JsInteropUtil.isClassWideJsExport(x)) {
    for (    JMethod m : type.getMethods()) {
      if (m.getExportName() != null) {
        continue;
      }
      if (m.getAccess() == AccessModifier.PUBLIC && (m.isStatic() || (m instanceof JConstructor))) {
        m.setExportName(""String_Node_Str"");
      }
    }
    for (    JField f : type.getFields()) {
      if (f.getExportName() != null) {
        continue;
      }
      if (f.isStatic()) {
        f.setExportName(""String_Node_Str"");
      }
    }
  }
  JsInteropUtil.maybeSetJsNamespace(type,x);
  curClass=classStack.pop();
}",0.9878673496899434
53532,"@Override public boolean visit(JMethod x,Context ctx){
  Set<JMethod> overrides=program.typeOracle.getAllOverriddenMethods(x);
  if (!overrides.isEmpty()) {
    for (    JMethod m : overrides) {
      rescuedMethods.add(m);
    }
    rescuedMethods.add(x);
  }
  return true;
}","@Override public boolean visit(JMethod x,Context ctx){
  Set<JMethod> overrides=program.typeOracle.getAllOverriddenMethods(x);
  if (!overrides.isEmpty() || program.typeOracle.isJsTypeMethod(x) || program.typeOracle.isExportedMethod(x)) {
    for (    JMethod m : overrides) {
      rescuedMethods.add(m);
    }
    rescuedMethods.add(x);
  }
  return true;
}",0.8710691823899371
53533,"@Override public boolean visit(JMethod x,Context ctx){
  return !x.isNative();
}","@Override public boolean visit(JMethod x,Context ctx){
  return !x.isNative() || program.typeOracle.isJsTypeMethod(x) || program.typeOracle.isExportedMethod(x);
}",0.6611570247933884
53534,"/** 
 * Tighten based on assignment, and for parameters, callArgs as well.
 */
private void tighten(JVariable x){
  if (!(x.getType() instanceof JReferenceType)) {
    return;
  }
  JReferenceType refType=(JReferenceType)x.getType();
  if (refType == typeNull) {
    return;
  }
  if (!program.typeOracle.isInstantiatedType(refType)) {
    x.setType(typeNull);
    madeChanges();
    return;
  }
  JReferenceType leafType=getSingleConcreteType(refType);
  if (leafType != null) {
    x.setType(leafType);
    madeChanges();
    return;
  }
  List<JReferenceType> typeList=new ArrayList<JReferenceType>();
  if ((x instanceof JField) && !x.hasInitializer()) {
    typeList.add(typeNull);
  }
  Collection<JExpression> myAssignments=assignments.get(x);
  if (myAssignments != null) {
    for (    JExpression expr : myAssignments) {
      JType type=expr.getType();
      if (!(type instanceof JReferenceType)) {
        return;
      }
      typeList.add((JReferenceType)type);
    }
  }
  if (x instanceof JParameter) {
    Collection<JParameter> myParams=paramUpRefs.get(x);
    if (myParams != null) {
      for (      JParameter param : myParams) {
        typeList.add((JReferenceType)param.getType());
      }
    }
  }
  JReferenceType resultType;
  if (!typeList.isEmpty()) {
    resultType=program.generalizeTypes(typeList);
    resultType=program.strongerType(refType,resultType);
  }
 else {
    if (x instanceof JParameter) {
      resultType=refType;
    }
 else {
      resultType=typeNull;
    }
  }
  if (x.getType() != resultType) {
    x.setType(resultType);
    madeChanges();
  }
}","/** 
 * Tighten based on assignment, and for parameters, callArgs as well.
 */
private void tighten(JVariable x){
  if (!(x.getType() instanceof JReferenceType)) {
    return;
  }
  JReferenceType refType=(JReferenceType)x.getType();
  if (program.typeOracle.isJsType(refType)) {
    return;
  }
  if (refType == typeNull) {
    return;
  }
  if (!program.typeOracle.isInstantiatedType(refType)) {
    x.setType(typeNull);
    madeChanges();
    return;
  }
  JReferenceType leafType=getSingleConcreteType(refType);
  if (leafType != null) {
    x.setType(leafType);
    madeChanges();
    return;
  }
  List<JReferenceType> typeList=new ArrayList<JReferenceType>();
  if ((x instanceof JField) && !x.hasInitializer()) {
    typeList.add(typeNull);
  }
  Collection<JExpression> myAssignments=assignments.get(x);
  if (myAssignments != null) {
    for (    JExpression expr : myAssignments) {
      JType type=expr.getType();
      if (!(type instanceof JReferenceType)) {
        return;
      }
      typeList.add((JReferenceType)type);
    }
  }
  if (x instanceof JParameter) {
    Collection<JParameter> myParams=paramUpRefs.get(x);
    if (myParams != null) {
      for (      JParameter param : myParams) {
        typeList.add((JReferenceType)param.getType());
      }
    }
  }
  JReferenceType resultType;
  if (!typeList.isEmpty()) {
    resultType=program.generalizeTypes(typeList);
    resultType=program.strongerType(refType,resultType);
  }
 else {
    if (x instanceof JParameter) {
      resultType=refType;
    }
 else {
      resultType=typeNull;
    }
  }
  if (x.getType() != resultType) {
    x.setType(resultType);
    madeChanges();
  }
}",0.9809932556713672
53535,"/** 
 * Create a function that invokes the specified method reference.
 */
public static native JavaScriptObject makeBridgeMethod(JavaScriptObject methodRef);","/** 
 * Create a function that invokes the specified method reference.
 */
public static native JavaScriptObject makeBridgeMethod(JavaScriptObject methodRef,boolean returnsLong,boolean[] longParams);",0.8851540616246498
53536,"public ControlFlowAnalyzer(JProgram program){
  this.program=program;
  asyncFragmentOnLoad=program.getIndexedMethod(""String_Node_Str"");
  runAsyncOnsuccess=program.getIndexedMethod(""String_Node_Str"");
  baseArrayType=program.getIndexedType(""String_Node_Str"");
  getClassField=program.getIndexedField(""String_Node_Str"");
  getClassMethod=program.getIndexedMethod(""String_Node_Str"");
  rescuedViaCast.addAll(program.typeOracle.getInstantiatedJsoTypesViaCast());
  buildMethodsOverriding();
}","public ControlFlowAnalyzer(JProgram program){
  this.program=program;
  asyncFragmentOnLoad=program.getIndexedMethod(""String_Node_Str"");
  runAsyncOnsuccess=program.getIndexedMethod(""String_Node_Str"");
  baseArrayType=program.getIndexedType(""String_Node_Str"");
  getClassField=program.getIndexedField(""String_Node_Str"");
  getClassMethod=program.getIndexedMethod(""String_Node_Str"");
  rescuedViaCast.addAll(program.typeOracle.getInstantiatedJsoTypesViaCast());
  buildMethodsOverriding();
  rescuer=new RescueVisitor();
}",0.9693372898120672
53537,"private boolean hasAnyExports(JDeclaredType t){
  for (  JMethod method : t.getMethods()) {
    if (program.typeOracle.isExportedMethod(method)) {
      return true;
    }
  }
  for (  JField field : t.getFields()) {
    if (program.typeOracle.isExportedField(field)) {
      return true;
    }
  }
  return false;
}","private boolean hasAnyExports(JDeclaredType t){
  if (!program.typeOracle.isInteropEnabled()) {
    return false;
  }
  for (  JMethod method : t.getMethods()) {
    if (program.typeOracle.isExportedMethod(method)) {
      return true;
    }
  }
  for (  JField field : t.getFields()) {
    if (program.typeOracle.isExportedField(field)) {
      return true;
    }
  }
  return false;
}",0.9002849002849003
53538,"private boolean isJsType(JInterfaceType intf){
  if (intf.isJsType()) {
    return true;
  }
  for (  JInterfaceType subIntf : intf.getImplements()) {
    if (isJsType(subIntf)) {
      return true;
    }
  }
  return false;
}","private boolean isJsType(JDeclaredType intf){
  if (!program.typeOracle.isInteropEnabled()) {
    return false;
  }
  if (intf.isJsType()) {
    return true;
  }
  for (  JInterfaceType subIntf : intf.getImplements()) {
    if (isJsType(subIntf)) {
      return true;
    }
  }
  return false;
}",0.5527831094049904
53539,"/** 
 * Translates and stitches (unifies) type ASTs into one connected graph.<br /> For normal monolithic compiles only types reachable from entry points are traversed. This speeds, saves memory trims unreferenced elements.<br /> Library compiles traverse all types that were supplied as source in the compilation state and no elements are pruned.
 */
public void exec() throws UnableToCompleteException {
  for (  JMethod entryMethod : program.getEntryMethods()) {
    flowInto(entryMethod);
  }
  for (  JClassType type : program.codeGenTypes) {
    for (    JMethod method : type.getMethods()) {
      flowInto(method);
    }
  }
  if (!compilerContext.shouldCompileMonolithic()) {
    boolean errorStateBeforeForcedTraversal=errorsFound;
    Set<String> internalNames=ImmutableSet.copyOf(compiledClassesByInternalName.keySet());
    for (    String internalName : internalNames) {
      JDeclaredType type=internalFindType(internalName,internalNameBasedTypeLocator);
      if (type == null) {
        continue;
      }
      instantiate(type);
      for (      JField field : type.getFields()) {
        flowInto(field);
      }
      for (      JMethod method : type.getMethods()) {
        flowInto(method);
      }
    }
  }
 else {
    boolean savedErrorsFound=errorsFound;
    Set<String> internalNames=ImmutableSet.copyOf(compiledClassesByInternalName.keySet());
    for (    String internalName : internalNames) {
      JDeclaredType type=internalFindTypeViaLocator(internalName,internalNameBasedTypeLocator);
      if (type != null && (type.isJsType() || hasAnyExports(type))) {
        instantiate(type);
        for (        JField field : type.getFields()) {
          flowInto(field);
        }
        for (        JMethod method : type.getMethods()) {
          flowInto(method);
        }
      }
    }
    errorsFound=savedErrorsFound;
  }
  instantiate(program.getTypeJavaLangString());
  flowInto(program.getIndexedMethod(""String_Node_Str""));
  mapApi(program.getTypeJavaLangString());
  flowInto(methodMap.get(""String_Node_Str""));
  flowInto(program.getIndexedMethod(""String_Node_Str""));
  AutoboxUtils autoboxUtils=new AutoboxUtils(program);
  for (  JMethod method : autoboxUtils.getBoxMethods()) {
    flowInto(method);
  }
  for (  JMethod method : autoboxUtils.getUnboxMethods()) {
    flowInto(method);
  }
  if (compilerContext.getOptions().isRunAsyncEnabled()) {
    flowInto(program.getIndexedMethod(""String_Node_Str""));
    flowInto(program.getIndexedMethod(""String_Node_Str""));
  }
  staticInitialize(program.getTypeClassLiteralHolder());
  for (  JMethod method : program.getTypeJavaLangClass().getMethods()) {
    if (method.isStatic() && method.getName().startsWith(""String_Node_Str"")) {
      flowInto(method);
    }
  }
  mainLoop();
  if (compilerContext.shouldCompileMonolithic()) {
    pruneDeadFieldsAndMethods();
  }
  computeOverrides();
  if (errorsFound) {
    throw new UnableToCompleteException();
  }
}","/** 
 * Translates and stitches (unifies) type ASTs into one connected graph.<br /> For normal monolithic compiles only types reachable from entry points are traversed. This speeds, saves memory trims unreferenced elements.<br /> Library compiles traverse all types that were supplied as source in the compilation state and no elements are pruned.
 */
public void exec() throws UnableToCompleteException {
  for (  JMethod entryMethod : program.getEntryMethods()) {
    flowInto(entryMethod);
  }
  for (  JClassType type : program.codeGenTypes) {
    for (    JMethod method : type.getMethods()) {
      flowInto(method);
    }
  }
  if (!compilerContext.shouldCompileMonolithic()) {
    boolean errorStateBeforeForcedTraversal=errorsFound;
    Set<String> internalNames=ImmutableSet.copyOf(compiledClassesByInternalName.keySet());
    for (    String internalName : internalNames) {
      JDeclaredType type=internalFindType(internalName,internalNameBasedTypeLocator);
      if (type == null) {
        continue;
      }
      instantiate(type);
      for (      JField field : type.getFields()) {
        flowInto(field);
      }
      for (      JMethod method : type.getMethods()) {
        flowInto(method);
      }
    }
  }
 else   if (program.typeOracle.isInteropEnabled()) {
    boolean savedErrorsFound=errorsFound;
    Set<String> internalNames=ImmutableSet.copyOf(compiledClassesByInternalName.keySet());
    for (    String internalName : internalNames) {
      JDeclaredType type=internalFindTypeViaLocator(internalName,internalNameBasedTypeLocator);
      if (type != null && (isJsType(type) || hasAnyExports(type))) {
        instantiate(type);
        for (        JField field : type.getFields()) {
          flowInto(field);
        }
        for (        JMethod method : type.getMethods()) {
          flowInto(method);
        }
      }
    }
    errorsFound=savedErrorsFound;
  }
  instantiate(program.getTypeJavaLangString());
  flowInto(program.getIndexedMethod(""String_Node_Str""));
  mapApi(program.getTypeJavaLangString());
  flowInto(methodMap.get(""String_Node_Str""));
  flowInto(program.getIndexedMethod(""String_Node_Str""));
  AutoboxUtils autoboxUtils=new AutoboxUtils(program);
  for (  JMethod method : autoboxUtils.getBoxMethods()) {
    flowInto(method);
  }
  for (  JMethod method : autoboxUtils.getUnboxMethods()) {
    flowInto(method);
  }
  if (compilerContext.getOptions().isRunAsyncEnabled()) {
    flowInto(program.getIndexedMethod(""String_Node_Str""));
    flowInto(program.getIndexedMethod(""String_Node_Str""));
  }
  staticInitialize(program.getTypeClassLiteralHolder());
  for (  JMethod method : program.getTypeJavaLangClass().getMethods()) {
    if (method.isStatic() && method.getName().startsWith(""String_Node_Str"")) {
      flowInto(method);
    }
  }
  mainLoop();
  if (compilerContext.shouldCompileMonolithic()) {
    pruneDeadFieldsAndMethods();
  }
  computeOverrides();
  if (errorsFound) {
    throw new UnableToCompleteException();
  }
}",0.9909213180901144
53540,"private void assertTrace(final String[] expected,StackTraceElement[] trace,int offset){
  for (int i=0; i < expected.length; i++) {
    assertEquals(""String_Node_Str"" + i,expected[i],trace[i + offset].getMethodName());
  }
}","private void assertTrace(final String[] expected,StackTraceElement[] actual,int offset){
  for (int i=0; i < expected.length; i++) {
    StackTraceElement actualElement=actual[i + offset];
    String methodName=actualElement == null ? ""String_Node_Str"" : actualElement.getMethodName();
    assertEquals(""String_Node_Str"" + i,expected[i],methodName);
  }
}",0.6735751295336787
53541,"@DoNotRunWith(Platform.Devel) public void testTraceNative(){
  if (!StackTraceCreator.supportsErrorStack()) {
    return;
  }
  Throwable t=null;
  try {
    throwException1(true);
    fail(""String_Node_Str"");
  }
 catch (  Throwable e) {
    t=e;
  }
  String[] nativeMethodNames=throwNative(false);
  final String[] expected={nativeMethodNames[0],nativeMethodNames[1],Impl.getNameOf(""String_Node_Str""),Impl.getNameOf(""String_Node_Str""),Impl.getNameOf(""String_Node_Str""),Impl.getNameOf(""String_Node_Str""),Impl.getNameOf(""String_Node_Str"")};
  StackTraceElement[] trace=t.getStackTrace();
  int offset=getTraceOffset(trace,expected[0]);
  assertTrace(expected,trace,offset);
}","@DoNotRunWith(Platform.Devel) public void testTraceNative(){
  Throwable t=null;
  try {
    throwException1(true);
    fail(""String_Node_Str"");
  }
 catch (  Throwable e) {
    t=e;
  }
  String[] nativeMethodNames=throwNative(false);
  final String[] expectedModern={nativeMethodNames[0],nativeMethodNames[1],Impl.getNameOf(""String_Node_Str""),Impl.getNameOf(""String_Node_Str""),Impl.getNameOf(""String_Node_Str""),Impl.getNameOf(""String_Node_Str""),Impl.getNameOf(""String_Node_Str"")};
  final String[] expectedLegacy={Impl.getNameOf(""String_Node_Str"")};
  final String[] expected=supportsErrorStack() ? expectedModern : expectedLegacy;
  StackTraceElement[] trace=t.getStackTrace();
  int offset=getTraceOffset(trace,expected[0]);
  assertTrace(expected,trace,offset);
}",0.8462603878116344
53542,"public void testSubClassWithSuperCalls(){
  MyClassImpl mc=new MyClassImpl();
  assertEquals(150,mc.sum(1));
  ScriptInjector.fromString(""String_Node_Str"").setWindow(ScriptInjector.TOP_WINDOW).inject();
  assertTrue(MyClassImpl.calledFromJsHostPageWindow);
  ScriptInjector.fromString(""String_Node_Str"").inject();
  assertTrue(MyClassImpl.calledFromJsModuleWindow);
}","public void testSubClassWithSuperCalls(){
  MyClassImpl mc=new MyClassImpl();
  assertEquals(150,mc.sum(1));
}",0.4612159329140461
53543,"public void testJsExports(){
  ScriptInjector.fromString(""String_Node_Str"").setWindow(ScriptInjector.TOP_WINDOW).inject();
  assertTrue(MyClassImpl.calledFromJsHostPageWindow);
  ScriptInjector.fromString(""String_Node_Str"").inject();
  assertTrue(MyClassImpl.calledFromJsModuleWindow);
}","public void testJsExports(){
  ScriptInjector.fromString(""String_Node_Str"").setWindow(ScriptInjector.TOP_WINDOW).inject();
  assertTrue(MyClassImpl2.calledFromJsHostPageWindow);
  ScriptInjector.fromString(""String_Node_Str"").inject();
  assertTrue(MyClassImpl2.calledFromJsModuleWindow);
  ScriptInjector.fromString(""String_Node_Str"").inject();
  assertTrue(MyClassImpl3.calledFromJsModuleWindow);
}",0.8367346938775511
53544,"public AssertionFailedError(String message){
  super(message);
}","public AssertionFailedError(String message){
  super(message == null ? ""String_Node_Str"" : message);
}",0.7710843373493976
53545,"private void exec(){
  JsSymbolResolver.exec(program);
  List<JDeclaredType> types=ImmutableList.<JDeclaredType>of(comExampleFooClass);
  Map<JsStatement,JClassType> typeForStatement=ImmutableMap.of();
  Map<JsStatement,JMethod> vtableInitForMethod=ImmutableMap.of();
  JavaToJavaScriptMapImpl jjsmap=new JavaToJavaScriptMapImpl(types,javaToName,typeForStatement,vtableInitForMethod);
  JsNamespaceChooser.exec(program,jjsmap);
}","private void exec(){
  JsSymbolResolver.exec(program);
  List<JDeclaredType> types=ImmutableList.<JDeclaredType>of(comExampleFooClass,defaultPackageBarClass);
  Map<JsStatement,JClassType> typeForStatement=ImmutableMap.of();
  Map<JsStatement,JMethod> vtableInitForMethod=ImmutableMap.of();
  JavaToJavaScriptMapImpl jjsmap=new JavaToJavaScriptMapImpl(types,javaToName,typeForStatement,vtableInitForMethod);
  JsNamespaceChooser.exec(program,jjsmap);
}",0.9738933030646992
53546,"/** 
 * Detects if the requested time falls into a non-existent time range due to local time advancing into daylight savings time. If so, push the requested time forward out of the non-existent range.
 */
private void fixDaylightSavings(int hours){
  if ((jsdate.getHours() % 24) != (hours % 24)) {
    JsDate copy=JsDate.create(jsdate.getTime());
    copy.setDate(copy.getDate() + 1);
    int timeDiff=jsdate.getTimezoneOffset() - copy.getTimezoneOffset();
    if (timeDiff > 0) {
      int timeDiffHours=timeDiff / 60;
      int timeDiffMinutes=timeDiff % 60;
      int day=jsdate.getDate();
      int badHours=jsdate.getHours();
      if (badHours + timeDiffHours >= 24) {
        day++;
      }
      JsDate newTime=JsDate.create(jsdate.getFullYear(),jsdate.getMonth(),day,hours + timeDiffHours,jsdate.getMinutes() + timeDiffMinutes,jsdate.getSeconds(),jsdate.getMilliseconds());
      jsdate.setTime(newTime.getTime());
    }
  }
}","/** 
 * Detects if the requested time falls into a non-existent time range due to local time advancing into daylight savings time or is ambiguous due to going out of daylight savings. If so, adjust accordingly.
 */
private void fixDaylightSavings(int requestedHours){
  int hours=jsdate.getHours();
  if ((hours % 24) != (requestedHours % 24)) {
    JsDate copy=JsDate.create(jsdate.getTime());
    copy.setDate(copy.getDate() + 1);
    int timeDiff=jsdate.getTimezoneOffset() - copy.getTimezoneOffset();
    if (timeDiff > 0) {
      int timeDiffHours=timeDiff / 60;
      int timeDiffMinutes=timeDiff % 60;
      int day=jsdate.getDate();
      int badHours=jsdate.getHours();
      if (badHours + timeDiffHours >= 24) {
        day++;
      }
      JsDate newTime=JsDate.create(jsdate.getFullYear(),jsdate.getMonth(),day,requestedHours + timeDiffHours,jsdate.getMinutes() + timeDiffMinutes,jsdate.getSeconds(),jsdate.getMilliseconds());
      jsdate.setTime(newTime.getTime());
    }
    return;
  }
  double originalTimeInMillis=jsdate.getTime();
  jsdate.setTime(originalTimeInMillis + ONE_HOUR_IN_MILLISECONDS);
  if (hours != jsdate.getHours()) {
    jsdate.setTime(originalTimeInMillis);
  }
}",0.8076743097800655
53547,"private void execImpl(){
  Map<String,JsName> packageToNamespace=Maps.newHashMap();
  JsVars namespaceVars=new JsVars(SourceOrigin.UNKNOWN);
  ImmutableList<JsName> allNames=ImmutableList.copyOf(program.getScope().getAllNames());
  for (  JsName name : allNames) {
    if (name.getNamespace() != null || !name.isObfuscatable()) {
      continue;
    }
    String packageName=findPackage(name);
    if (packageName == null) {
      continue;
    }
    if (name.getStaticRef() instanceof JsFunction) {
      JsFunction func=(JsFunction)name.getStaticRef();
      if (program.isIndexedFunction(func)) {
        continue;
      }
    }
    JsName namespace=packageToNamespace.get(packageName);
    if (namespace == null) {
      namespace=program.getScope().declareName(chooseUnusedName(packageName));
      JsVar init=new JsVar(SourceOrigin.UNKNOWN,namespace);
      init.setInitExpr(new JsObjectLiteral(SourceOrigin.UNKNOWN));
      namespaceVars.add(init);
      packageToNamespace.put(packageName,namespace);
    }
    name.setNamespace(namespace);
  }
  fixGlobalFunctions(program);
  new NameFixer().accept(program);
  if (!namespaceVars.isEmpty()) {
    program.getGlobalBlock().getStatements().add(0,namespaceVars);
  }
}","private void execImpl(){
  List<JsStatement> globalStatements=program.getGlobalBlock().getStatements();
  List<JsStatement> after=Lists.newArrayList();
  for (  JsStatement before : globalStatements) {
    if (before instanceof JsExprStmt) {
      JsExpression exp=((JsExprStmt)before).getExpression();
      if (exp instanceof JsFunction) {
        after.add(visitGlobalFunction((JsFunction)exp));
      }
 else {
        after.add(before);
      }
    }
 else     if (before instanceof JsVars) {
      for (      JsVar var : ((JsVars)before)) {
        JsStatement replacement=visitGlobalVar(var);
        if (replacement != null) {
          after.add(replacement);
        }
      }
    }
 else {
      after.add(before);
    }
  }
  after.addAll(0,createNamespaceInitializers(packageToNamespace.values()));
  globalStatements.clear();
  globalStatements.addAll(after);
  new NameFixer().accept(program);
}",0.0955503512880562
53548,"/** 
 * Replace top-level ""var name = "" with ""namespace.name = "".
 */
@Override public void endVisit(JsVars x,JsContext ctx){
  if (!ctx.canInsert()) {
    return;
  }
  for (  JsVar var : x) {
    JsName name=var.getName();
    JsName namespace=var.getName().getNamespace();
    if (namespace == null) {
      JsVars vars=new JsVars(var.getSourceInfo());
      vars.add(var);
      ctx.insertBefore(vars);
    }
 else {
      JsNameRef newName=name.makeRef(x.getSourceInfo());
      JsExpression init=var.getInitExpr();
      if (init == null) {
        init=JsNullLiteral.INSTANCE;
      }
      JsBinaryOperation assign=new JsBinaryOperation(var.getSourceInfo(),JsBinaryOperator.ASG,newName,init);
      ctx.insertBefore(assign.makeStmt());
    }
  }
  ctx.removeMe();
}","@Override public void endVisit(JsNameRef x,JsContext ctx){
  if (!x.isLeaf() || x.getQualifier() != null || x.getName() == null) {
    return;
  }
  JsName namespace=x.getName().getNamespace();
  if (namespace == null) {
    return;
  }
  x.setQualifier(new JsNameRef(x.getSourceInfo(),namespace));
  didChange=true;
}",0.2089825847846012
53549,"public JsNamespaceChooser(JsProgram program,JavaToJavaScriptMap jjsmap){
  this.program=program;
  this.jjsmap=jjsmap;
}","private JsNamespaceChooser(JsProgram program,JavaToJavaScriptMap jjsmap){
  this.program=program;
  this.jjsmap=jjsmap;
}",0.9626556016597512
53550,"private void mapJavaField(String name){
  JField field=new JField(SourceOrigin.UNKNOWN,name,javaType,JPrimitiveType.INT,true,Disposition.NONE);
  javaType.addField(field);
  javaToName.put(field,program.getScope().findExistingName(name));
}","/** 
 * Adds a mapping from a JavaScript global to a Java field. 
 */
private void mapJavaField(String name){
  JField field=new JField(SourceOrigin.UNKNOWN,name,javaType,JPrimitiveType.INT,true,Disposition.NONE);
  javaType.addField(field);
  javaToName.put(field,program.getScope().findExistingName(name));
}",0.8727272727272727
53551,"private void mapJavaMethod(String name){
  JMethod method=new JMethod(SourceOrigin.UNKNOWN,name,javaType,JPrimitiveType.VOID,false,true,false,AccessModifier.DEFAULT);
  javaType.addMethod(method);
  javaToName.put(method,program.getScope().findExistingName(name));
}","/** 
 * Adds a mapping from a JavaScript global to a Java method. 
 */
private void mapJavaMethod(String name){
  JMethod method=new JMethod(SourceOrigin.UNKNOWN,name,javaType,JPrimitiveType.VOID,false,true,false,AccessModifier.DEFAULT);
  javaType.addMethod(method);
  javaToName.put(method,program.getScope().findExistingName(name));
}",0.8822553897180763
53552,"@Override public JWildcardType getWildcardType(com.google.gwt.core.ext.typeinfo.JWildcardType.BoundType boundType,com.google.gwt.core.ext.typeinfo.JClassType extTypeBound){
  JClassType typeBound=(JClassType)extTypeBound;
  if (typeBound == getJavaLangObject() && boundType == BoundType.UNBOUND) {
    if (unboundWildCardType == null) {
      unboundWildCardType=new JWildcardType(boundType,typeBound);
    }
    return unboundWildCardType;
  }
  WildCardKey key=new WildCardKey(boundType,typeBound);
  JWildcardType result=wildcardTypes.get(key);
  if (result != null) {
    return result;
  }
  result=new JWildcardType(boundType,typeBound);
  wildcardTypes.put(key,result);
  return result;
}","@Override public JWildcardType getWildcardType(com.google.gwt.core.ext.typeinfo.JWildcardType.BoundType boundType,com.google.gwt.core.ext.typeinfo.JClassType extTypeBound){
  JClassType typeBound=(JClassType)extTypeBound;
  if (typeBound == getJavaLangObject() && (boundType == BoundType.UNBOUND || boundType == BoundType.EXTENDS)) {
    if (unboundWildCardType == null) {
      unboundWildCardType=new JWildcardType(BoundType.UNBOUND,typeBound);
    }
    return unboundWildCardType;
  }
  WildCardKey key=new WildCardKey(boundType,typeBound);
  JWildcardType result=wildcardTypes.get(key);
  if (result != null) {
    return result;
  }
  result=new JWildcardType(boundType,typeBound);
  wildcardTypes.put(key,result);
  return result;
}",0.9567642956764296
53553,"@Override public Textifier visitField(final int access,final String name,final String desc,final String signature,final Object value){
  buf.setLength(0);
  buf.append('\n');
  if ((access & Opcodes.ACC_DEPRECATED) != 0) {
    buf.append(tab).append(""String_Node_Str"");
  }
  buf.append(tab).append(""String_Node_Str"").append(Integer.toHexString(access).toUpperCase()).append('\n');
  if (signature != null) {
    buf.append(tab);
    appendDescriptor(FIELD_SIGNATURE,signature);
    TraceSignatureVisitor sv=new TraceSignatureVisitor(0);
    SignatureReader r=new SignatureReader(signature);
    r.acceptType(sv);
    buf.append(tab).append(""String_Node_Str"").append(sv.getDeclaration()).append('\n');
  }
  buf.append(tab);
  appendAccess(access);
  appendDescriptor(FIELD_DESCRIPTOR,desc);
  buf.append(' ').append(name);
  if (value != null) {
    buf.append(""String_Node_Str"");
    if (value instanceof String) {
      buf.append('\""').append(value).append('\""');
    }
 else {
      buf.append(value);
    }
  }
  buf.append('\n');
  text.add(buf.toString());
  Textifier t=createTextifier();
  text.add(t.getText());
  return t;
}","@Override public Textifier visitField(final int access,final String name,final String desc,final String signature,final Object value){
  buf.setLength(0);
  buf.append('\n');
  if ((access & Opcodes.ACC_DEPRECATED) != 0) {
    buf.append(tab).append(""String_Node_Str"");
  }
  buf.append(tab).append(""String_Node_Str"").append(Integer.toHexString(access).toUpperCase(Locale.ENGLISH)).append('\n');
  if (signature != null) {
    buf.append(tab);
    appendDescriptor(FIELD_SIGNATURE,signature);
    TraceSignatureVisitor sv=new TraceSignatureVisitor(0);
    SignatureReader r=new SignatureReader(signature);
    r.acceptType(sv);
    buf.append(tab).append(""String_Node_Str"").append(sv.getDeclaration()).append('\n');
  }
  buf.append(tab);
  appendAccess(access);
  appendDescriptor(FIELD_DESCRIPTOR,desc);
  buf.append(' ').append(name);
  if (value != null) {
    buf.append(""String_Node_Str"");
    if (value instanceof String) {
      buf.append('\""').append(value).append('\""');
    }
 else {
      buf.append(value);
    }
  }
  buf.append('\n');
  text.add(buf.toString());
  Textifier t=createTextifier();
  text.add(t.getText());
  return t;
}",0.9938757655293088
53554,"@Override public void visitInnerClass(final String name,final String outerName,final String innerName,final int access){
  buf.setLength(0);
  buf.append(tab).append(""String_Node_Str"");
  buf.append(Integer.toHexString(access & ~Opcodes.ACC_SUPER).toUpperCase()).append('\n');
  buf.append(tab);
  appendAccess(access);
  buf.append(""String_Node_Str"");
  appendDescriptor(INTERNAL_NAME,name);
  buf.append(' ');
  appendDescriptor(INTERNAL_NAME,outerName);
  buf.append(' ');
  appendDescriptor(INTERNAL_NAME,innerName);
  buf.append('\n');
  text.add(buf.toString());
}","@Override public void visitInnerClass(final String name,final String outerName,final String innerName,final int access){
  buf.setLength(0);
  buf.append(tab).append(""String_Node_Str"");
  buf.append(Integer.toHexString(access & ~Opcodes.ACC_SUPER).toUpperCase(Locale.ENGLISH)).append('\n');
  buf.append(tab);
  appendAccess(access);
  buf.append(""String_Node_Str"");
  appendDescriptor(INTERNAL_NAME,name);
  buf.append(' ');
  appendDescriptor(INTERNAL_NAME,outerName);
  buf.append(' ');
  appendDescriptor(INTERNAL_NAME,innerName);
  buf.append('\n');
  text.add(buf.toString());
}",0.9878682842287696
53555,"@Override public Textifier visitMethod(final int access,final String name,final String desc,final String signature,final String[] exceptions){
  buf.setLength(0);
  buf.append('\n');
  if ((access & Opcodes.ACC_DEPRECATED) != 0) {
    buf.append(tab).append(""String_Node_Str"");
  }
  buf.append(tab).append(""String_Node_Str"").append(Integer.toHexString(access).toUpperCase()).append('\n');
  if (signature != null) {
    buf.append(tab);
    appendDescriptor(METHOD_SIGNATURE,signature);
    TraceSignatureVisitor v=new TraceSignatureVisitor(0);
    SignatureReader r=new SignatureReader(signature);
    r.accept(v);
    String genericDecl=v.getDeclaration();
    String genericReturn=v.getReturnType();
    String genericExceptions=v.getExceptions();
    buf.append(tab).append(""String_Node_Str"").append(genericReturn).append(' ').append(name).append(genericDecl);
    if (genericExceptions != null) {
      buf.append(""String_Node_Str"").append(genericExceptions);
    }
    buf.append('\n');
  }
  buf.append(tab);
  appendAccess(access);
  if ((access & Opcodes.ACC_NATIVE) != 0) {
    buf.append(""String_Node_Str"");
  }
  if ((access & Opcodes.ACC_VARARGS) != 0) {
    buf.append(""String_Node_Str"");
  }
  if ((access & Opcodes.ACC_BRIDGE) != 0) {
    buf.append(""String_Node_Str"");
  }
  buf.append(name);
  appendDescriptor(METHOD_DESCRIPTOR,desc);
  if (exceptions != null && exceptions.length > 0) {
    buf.append(""String_Node_Str"");
    for (int i=0; i < exceptions.length; ++i) {
      appendDescriptor(INTERNAL_NAME,exceptions[i]);
      buf.append(' ');
    }
  }
  buf.append('\n');
  text.add(buf.toString());
  Textifier t=createTextifier();
  text.add(t.getText());
  return t;
}","@Override public Textifier visitMethod(final int access,final String name,final String desc,final String signature,final String[] exceptions){
  buf.setLength(0);
  buf.append('\n');
  if ((access & Opcodes.ACC_DEPRECATED) != 0) {
    buf.append(tab).append(""String_Node_Str"");
  }
  buf.append(tab).append(""String_Node_Str"").append(Integer.toHexString(access).toUpperCase(Locale.ENGLISH)).append('\n');
  if (signature != null) {
    buf.append(tab);
    appendDescriptor(METHOD_SIGNATURE,signature);
    TraceSignatureVisitor v=new TraceSignatureVisitor(0);
    SignatureReader r=new SignatureReader(signature);
    r.accept(v);
    String genericDecl=v.getDeclaration();
    String genericReturn=v.getReturnType();
    String genericExceptions=v.getExceptions();
    buf.append(tab).append(""String_Node_Str"").append(genericReturn).append(' ').append(name).append(genericDecl);
    if (genericExceptions != null) {
      buf.append(""String_Node_Str"").append(genericExceptions);
    }
    buf.append('\n');
  }
  buf.append(tab);
  appendAccess(access);
  if ((access & Opcodes.ACC_NATIVE) != 0) {
    buf.append(""String_Node_Str"");
  }
  if ((access & Opcodes.ACC_VARARGS) != 0) {
    buf.append(""String_Node_Str"");
  }
  if ((access & Opcodes.ACC_BRIDGE) != 0) {
    buf.append(""String_Node_Str"");
  }
  buf.append(name);
  appendDescriptor(METHOD_DESCRIPTOR,desc);
  if (exceptions != null && exceptions.length > 0) {
    buf.append(""String_Node_Str"");
    for (int i=0; i < exceptions.length; ++i) {
      appendDescriptor(INTERNAL_NAME,exceptions[i]);
      buf.append(' ');
    }
  }
  buf.append('\n');
  text.add(buf.toString());
  Textifier t=createTextifier();
  text.add(t.getText());
  return t;
}",0.9958896065766296
53556,"@SuppressWarnings(""String_Node_Str"") protected Schema __module_begin(NullableName renameTo,String type){
  moduleDef.enterModule(ModuleType.valueOf(type.toUpperCase()),moduleName);
  return bodySchema;
}","@SuppressWarnings(""String_Node_Str"") protected Schema __module_begin(NullableName renameTo,String type){
  moduleDef.enterModule(ModuleType.valueOf(type.toUpperCase(Locale.ENGLISH)),moduleName);
  return bodySchema;
}",0.9666666666666668
53557,"final boolean isAvailable(String newIdent){
  if (!JsProtectedNames.isLegalName(newIdent)) {
    return false;
  }
  String lcIdent=newIdent.toLowerCase();
  for (  String suffix : blacklistedSuffixes) {
    if (lcIdent.endsWith(suffix.toLowerCase())) {
      return false;
    }
  }
  return !blacklistedIdents.contains(newIdent);
}","final boolean isAvailable(String newIdent){
  if (!JsProtectedNames.isLegalName(newIdent)) {
    return false;
  }
  String lcIdent=newIdent.toLowerCase(Locale.ENGLISH);
  for (  String suffix : blacklistedSuffixes) {
    if (lcIdent.endsWith(suffix.toLowerCase(Locale.ENGLISH))) {
      return false;
    }
  }
  return !blacklistedIdents.contains(newIdent);
}",0.9596541786743517
53558,"private SpeedTracerLogger(){
  fileLoggingEnabled=logFile != null;
  enabled=fileLoggingEnabled || DashboardNotifierFactory.areNotificationsEnabled();
  if (enabled) {
    if (fileLoggingEnabled) {
      Format format=Format.HTML;
      if (defaultFormatString != null) {
        for (        Format value : Format.values()) {
          if (value.name().toLowerCase().equals(defaultFormatString.toLowerCase())) {
            format=value;
            break;
          }
        }
      }
      outputFormat=format;
      eventsToWrite=openDefaultLogWriter();
      shutDownSentinel=new DummyEvent();
      flushSentinel=new DummyEvent();
      shutDownLatch=new CountDownLatch(1);
    }
    if (logGcTime) {
      gcMXBeans=ManagementFactory.getGarbageCollectorMXBeans();
      lastGcTimes=new ConcurrentHashMap<String,Long>();
    }
    pendingEvents=initPendingEvents();
  }
}","private SpeedTracerLogger(){
  fileLoggingEnabled=logFile != null;
  enabled=fileLoggingEnabled || DashboardNotifierFactory.areNotificationsEnabled();
  if (enabled) {
    if (fileLoggingEnabled) {
      Format format=Format.HTML;
      if (defaultFormatString != null) {
        for (        Format value : Format.values()) {
          if (value.name().equalsIgnoreCase(defaultFormatString)) {
            format=value;
            break;
          }
        }
      }
      outputFormat=format;
      eventsToWrite=openDefaultLogWriter();
      shutDownSentinel=new DummyEvent();
      flushSentinel=new DummyEvent();
      shutDownLatch=new CountDownLatch(1);
    }
    if (logGcTime) {
      gcMXBeans=ManagementFactory.getGarbageCollectorMXBeans();
      lastGcTimes=new ConcurrentHashMap<String,Long>();
    }
    pendingEvents=initPendingEvents();
  }
}",0.9758342922899884
53559,"private BufferedReader extractJsonFromWriter(Writer writer) throws IOException {
  String jsonString=writer.toString();
  assertTrue(jsonString.substring(0,5).toLowerCase().startsWith(""String_Node_Str""));
  BufferedReader jsonReader=new BufferedReader(new StringReader(jsonString));
  while (true) {
    jsonReader.mark(16 * 1024);
    String line=jsonReader.readLine();
    if (line == null) {
      fail(""String_Node_Str"");
    }
    if (line.startsWith(""String_Node_Str"")) {
      jsonReader.reset();
      break;
    }
  }
  return jsonReader;
}","private BufferedReader extractJsonFromWriter(Writer writer) throws IOException {
  String jsonString=writer.toString();
  assertTrue(jsonString.substring(0,5).toLowerCase(Locale.ENGLISH).startsWith(""String_Node_Str""));
  BufferedReader jsonReader=new BufferedReader(new StringReader(jsonString));
  while (true) {
    jsonReader.mark(16 * 1024);
    String line=jsonReader.readLine();
    if (line == null) {
      fail(""String_Node_Str"");
    }
    if (line.startsWith(""String_Node_Str"")) {
      jsonReader.reset();
      break;
    }
  }
  return jsonReader;
}",0.987410071942446
53560,"@Override public void onBrowserEvent(Event event){
  MenuItem item=findItem(DOM.eventGetTarget(event));
switch (DOM.eventGetType(event)) {
case Event.ONCLICK:
{
      FocusPanel.impl.focus(getElement());
      if (item != null) {
        doItemAction(item,true,true);
      }
      break;
    }
case Event.ONMOUSEOVER:
{
    if (item != null) {
      itemOver(item,true);
    }
    break;
  }
case Event.ONMOUSEOUT:
{
  if (item != null) {
    itemOver(null,true);
  }
  break;
}
case Event.ONFOCUS:
{
selectFirstItemIfNoneSelected();
break;
}
case Event.ONKEYDOWN:
{
int keyCode=event.getKeyCode();
boolean isRtl=LocaleInfo.getCurrentLocale().isRTL();
keyCode=KeyCodes.maybeSwapArrowKeysForRtl(keyCode,isRtl);
switch (keyCode) {
case KeyCodes.KEY_LEFT:
moveToPrevItem();
eatEvent(event);
break;
case KeyCodes.KEY_RIGHT:
moveToNextItem();
eatEvent(event);
break;
case KeyCodes.KEY_UP:
moveSelectionUp();
eatEvent(event);
break;
case KeyCodes.KEY_DOWN:
moveSelectionDown();
eatEvent(event);
break;
case KeyCodes.KEY_ESCAPE:
closeAllParentsAndChildren();
eatEvent(event);
break;
case KeyCodes.KEY_TAB:
closeAllParentsAndChildren();
break;
case KeyCodes.KEY_ENTER:
if (!selectFirstItemIfNoneSelected()) {
doItemAction(selectedItem,true,true);
eatEvent(event);
}
break;
}
break;
}
}
super.onBrowserEvent(event);
}","@Override public void onBrowserEvent(Event event){
  MenuItem item=findItem(DOM.eventGetTarget(event));
switch (DOM.eventGetType(event)) {
case Event.ONCLICK:
{
      FocusPanel.impl.focus(getElement());
      if (item != null) {
        doItemAction(item,true,true);
      }
      break;
    }
case Event.ONMOUSEOVER:
{
    if (item != null) {
      itemOver(item,true);
    }
    break;
  }
case Event.ONMOUSEOUT:
{
  if (item != null) {
    itemOver(null,false);
  }
  break;
}
case Event.ONFOCUS:
{
selectFirstItemIfNoneSelected();
break;
}
case Event.ONKEYDOWN:
{
int keyCode=event.getKeyCode();
boolean isRtl=LocaleInfo.getCurrentLocale().isRTL();
keyCode=KeyCodes.maybeSwapArrowKeysForRtl(keyCode,isRtl);
switch (keyCode) {
case KeyCodes.KEY_LEFT:
moveToPrevItem();
eatEvent(event);
break;
case KeyCodes.KEY_RIGHT:
moveToNextItem();
eatEvent(event);
break;
case KeyCodes.KEY_UP:
moveSelectionUp();
eatEvent(event);
break;
case KeyCodes.KEY_DOWN:
moveSelectionDown();
eatEvent(event);
break;
case KeyCodes.KEY_ESCAPE:
closeAllParentsAndChildren();
eatEvent(event);
break;
case KeyCodes.KEY_TAB:
closeAllParentsAndChildren();
break;
case KeyCodes.KEY_ENTER:
if (!selectFirstItemIfNoneSelected()) {
doItemAction(selectedItem,true,true);
eatEvent(event);
}
break;
}
break;
}
}
super.onBrowserEvent(event);
}",0.997327224131348
53561,"void itemOver(MenuItem item,boolean focus){
  if (item == null) {
    if ((selectedItem != null) && (shownChildMenu == selectedItem.getSubMenu())) {
      return;
    }
  }
  if (item != null && !item.isEnabled()) {
    return;
  }
  selectItem(item);
  if (focus && focusOnHover) {
    focus();
  }
  if (item != null) {
    if ((shownChildMenu != null) || (parentMenu != null) || autoOpen) {
      doItemAction(item,false,focusOnHover);
    }
  }
}","void itemOver(MenuItem item,boolean focus){
  if (item == null) {
    if ((selectedItem != null) && shownChildMenu != null && (shownChildMenu == selectedItem.getSubMenu())) {
      return;
    }
  }
  if (item != null && !item.isEnabled()) {
    return;
  }
  selectItem(item);
  if (focus && focusOnHover) {
    focus();
  }
  if (item != null) {
    if ((shownChildMenu != null) || (parentMenu != null) || autoOpen) {
      doItemAction(item,false,focusOnHover);
    }
  }
}",0.9719222462203024
53562,"void doItemAction(final MenuItem item,boolean fireCommand,boolean focus){
  if (!item.isEnabled()) {
    return;
  }
  selectItem(item);
  if (fireCommand && item.getScheduledCommand() != null) {
    closeAllParents();
    final ScheduledCommand cmd=item.getScheduledCommand();
    Scheduler.get().scheduleFinally(new Scheduler.ScheduledCommand(){
      @Override public void execute(){
        cmd.execute();
      }
    }
);
    if (shownChildMenu != null) {
      shownChildMenu.onHide(focus);
      popup.hide();
      shownChildMenu=null;
      selectItem(null);
    }
  }
 else   if (item.getSubMenu() != null) {
    if (shownChildMenu == null) {
      openPopup(item);
    }
 else     if (item.getSubMenu() != shownChildMenu) {
      shownChildMenu.onHide(focus);
      popup.hide();
      openPopup(item);
    }
 else     if (fireCommand && !autoOpen) {
      shownChildMenu.onHide(focus);
      popup.hide();
      shownChildMenu=null;
      selectItem(item);
    }
  }
 else   if (autoOpen && shownChildMenu != null) {
    shownChildMenu.onHide(focus);
    popup.hide();
    shownChildMenu=null;
  }
}","void doItemAction(final MenuItem item,boolean fireCommand,boolean focus){
  if (!item.isEnabled()) {
    return;
  }
  selectItem(item);
  if (fireCommand && item.getScheduledCommand() != null) {
    closeAllParents();
    FocusPanel.impl.blur(getElement());
    final ScheduledCommand cmd=item.getScheduledCommand();
    Scheduler.get().scheduleFinally(new Scheduler.ScheduledCommand(){
      @Override public void execute(){
        cmd.execute();
      }
    }
);
    if (shownChildMenu != null) {
      shownChildMenu.onHide(focus);
      popup.hide();
      shownChildMenu=null;
      selectItem(null);
    }
  }
 else   if (item.getSubMenu() != null) {
    if (shownChildMenu == null) {
      openPopup(item);
    }
 else     if (item.getSubMenu() != shownChildMenu) {
      shownChildMenu.onHide(focus);
      popup.hide();
      openPopup(item);
    }
 else     if (fireCommand && !autoOpen) {
      shownChildMenu.onHide(focus);
      popup.hide();
      shownChildMenu=null;
      selectItem(item);
    }
  }
 else   if (autoOpen && shownChildMenu != null) {
    shownChildMenu.onHide(focus);
    popup.hide();
    shownChildMenu=null;
  }
}",0.982316534040672
53563,"/** 
 * This is called to merge two permutations that either have identical rebind answers or were explicitly collapsed using <collapse-property>.
 */
public void mergeFrom(Permutation other,SortedSet<String> liveRebindRequests){
}","/** 
 * This is called to merge two permutations that either have identical rebind answers or were explicitly collapsed using <collapse-property>.
 */
public void mergeFrom(Permutation other,SortedSet<String> liveRebindRequests){
  if (getClass().desiredAssertionStatus()) {
    assertSameAnswers(liveRebindRequests,orderedRebindAnswers,other.orderedRebindAnswers);
  }
  mergeRebindsFromCollapsed(other);
}",0.7241379310344828
53564,"/** 
 * Converts one field of the input string into a numeric field value. Returns <code>false</code> if failed.
 * @param text the time text to be parsed
 * @param pos Parse position
 * @param part the pattern part for this field
 * @param digitCount when greater than 0, numeric parsing must obey the count
 * @param cal DateRecord object that will hold parsed value
 * @return <code>true</code> if parsing successful
 */
@SuppressWarnings(""String_Node_Str"") private boolean subParse(String text,int[] pos,PatternPart part,int digitCount,DateRecord cal){
  skipSpace(text,pos);
  int start=pos[0];
  char ch=part.text.charAt(0);
  int value=-1;
  if (isNumeric(part)) {
    if (digitCount > 0) {
      if ((start + digitCount) > text.length()) {
        return false;
      }
      value=parseInt(text.substring(0,start + digitCount),pos);
    }
 else {
      value=parseInt(text,pos);
    }
  }
switch (ch) {
case 'G':
    value=matchString(text,start,dateTimeFormatInfo.erasFull(),pos);
  cal.setEra(value);
return true;
case 'M':
return subParseMonth(text,pos,cal,value,start);
case 'L':
return subParseStandaloneMonth(text,pos,cal,value,start);
case 'E':
return subParseDayOfWeek(text,pos,start,cal);
case 'c':
return subParseStandaloneDay(text,pos,start,cal);
case 'a':
value=matchString(text,start,dateTimeFormatInfo.ampms(),pos);
cal.setAmpm(value);
return true;
case 'y':
return subParseYear(text,pos,start,value,part,cal);
case 'd':
if (value <= 0) {
return false;
}
cal.setDayOfMonth(value);
return true;
case 'S':
if (value < 0) {
return false;
}
return subParseFractionalSeconds(value,start,pos[0],cal);
case 'h':
if (value == 12) {
value=0;
}
case 'K':
case 'H':
if (value < 0) {
return false;
}
cal.setHours(value);
return true;
case 'k':
if (value < 0) {
return false;
}
cal.setHours(value);
return true;
case 'm':
if (value < 0) {
return false;
}
cal.setMinutes(value);
return true;
case 's':
if (value < 0) {
return false;
}
cal.setSeconds(value);
return true;
case 'Z':
if (start < text.length() && text.charAt(start) == 'Z') {
pos[0]++;
cal.setTzOffset(0);
return true;
}
case 'z':
case 'v':
return subParseTimeZoneInGMT(text,start,pos,cal);
default :
return false;
}
}","/** 
 * Converts one field of the input string into a numeric field value. Returns <code>false</code> if failed.
 * @param text the time text to be parsed
 * @param pos Parse position
 * @param part the pattern part for this field
 * @param digitCount when greater than 0, numeric parsing must obey the count
 * @param cal DateRecord object that will hold parsed value
 * @return <code>true</code> if parsing successful
 */
@SuppressWarnings(""String_Node_Str"") private boolean subParse(String text,int[] pos,PatternPart part,int digitCount,DateRecord cal){
  skipSpace(text,pos);
  int start=pos[0];
  char ch=part.text.charAt(0);
  int value=-1;
  if (isNumeric(part)) {
    if (digitCount > 0) {
      if ((start + digitCount) > text.length()) {
        return false;
      }
      value=parseInt(text.substring(0,start + digitCount),pos);
    }
 else {
      value=parseInt(text,pos);
    }
  }
switch (ch) {
case 'G':
    value=matchString(text,start,dateTimeFormatInfo.erasFull(),pos);
  cal.setEra(value);
return true;
case 'M':
return subParseMonth(text,pos,cal,value,start);
case 'L':
return subParseStandaloneMonth(text,pos,cal,value,start);
case 'E':
return subParseDayOfWeek(text,pos,start,cal);
case 'c':
return subParseStandaloneDay(text,pos,start,cal);
case 'a':
value=matchString(text,start,dateTimeFormatInfo.ampms(),pos);
cal.setAmpm(value);
return true;
case 'y':
return subParseYear(text,pos,start,value,part,cal);
case 'd':
if (value <= 0) {
return false;
}
cal.setDayOfMonth(value);
return true;
case 'S':
if (value < 0) {
return false;
}
return subParseFractionalSeconds(value,start,pos[0],cal);
case 'h':
if (value == 12) {
value=0;
}
case 'K':
case 'H':
if (value < 0) {
return false;
}
cal.setHours(value);
cal.setMidnightIs24(false);
return true;
case 'k':
if (value < 0) {
return false;
}
cal.setHours(value);
cal.setMidnightIs24(true);
return true;
case 'm':
if (value < 0) {
return false;
}
cal.setMinutes(value);
return true;
case 's':
if (value < 0) {
return false;
}
cal.setSeconds(value);
return true;
case 'Z':
if (start < text.length() && text.charAt(start) == 'Z') {
pos[0]++;
cal.setTzOffset(0);
return true;
}
case 'z':
case 'v':
return subParseTimeZoneInGMT(text,start,pos,cal);
default :
return false;
}
}",0.9875986471251408
53565,"/** 
 * Initialize DateExt object with default value. Here we use -1 for most of the field to indicate that field is not set.
 */
public DateRecord(){
  era=-1;
  ambiguousYear=false;
  year=Integer.MIN_VALUE;
  month=-1;
  dayOfMonth=-1;
  ampm=-1;
  hours=-1;
  minutes=-1;
  seconds=-1;
  milliseconds=-1;
  dayOfWeek=-1;
  tzOffset=Integer.MIN_VALUE;
}","/** 
 * Initialize DateExt object with default value. Here we use -1 for most of the field to indicate that field is not set.
 */
public DateRecord(){
  era=-1;
  ambiguousYear=false;
  year=Integer.MIN_VALUE;
  month=-1;
  dayOfMonth=-1;
  ampm=-1;
  midnightIs24=false;
  hours=-1;
  minutes=-1;
  seconds=-1;
  milliseconds=-1;
  dayOfWeek=-1;
  tzOffset=Integer.MIN_VALUE;
}",0.9700272479564032
53566,"/** 
 * calcDate uses all the field available so far to fill a Date object. For those information that is not provided, the existing value in 'date' will be kept. Ambiguous year will be resolved after the date/time values are resolved. If the strict option is set to true, calcDate will calculate certain invalid dates by wrapping around as needed. For example, February 30 will wrap to March 2.
 * @param date The Date object being filled. Its value should be set to anacceptable default before pass in to this method
 * @param strict true to be strict when parsing
 * @return true if successful, otherwise false.
 */
public boolean calcDate(Date date,boolean strict){
  if (this.era == 0 && this.year > 0) {
    this.year=-(this.year - 1);
  }
  if (this.year > Integer.MIN_VALUE) {
    date.setYear(this.year - JS_START_YEAR);
  }
  int orgDayOfMonth=date.getDate();
  date.setDate(1);
  if (this.month >= 0) {
    date.setMonth(this.month);
  }
  if (this.dayOfMonth >= 0) {
    date.setDate(this.dayOfMonth);
  }
 else   if (this.month >= 0) {
    Date tmp=new Date(date.getYear(),date.getMonth(),35);
    int daysInCurrentMonth=35 - tmp.getDate();
    date.setDate(Math.min(daysInCurrentMonth,orgDayOfMonth));
  }
 else {
    date.setDate(orgDayOfMonth);
  }
  if (this.hours < 0) {
    this.hours=date.getHours();
  }
  if (this.ampm > 0) {
    if (this.hours < 12) {
      this.hours+=12;
    }
  }
  date.setHours(this.hours);
  if (this.minutes >= 0) {
    date.setMinutes(this.minutes);
  }
  if (this.seconds >= 0) {
    date.setSeconds(this.seconds);
  }
  if (this.milliseconds >= 0) {
    date.setTime(date.getTime() / 1000 * 1000 + this.milliseconds);
  }
  if (strict) {
    if ((this.year > Integer.MIN_VALUE) && ((this.year - JS_START_YEAR) != date.getYear())) {
      return false;
    }
    if ((this.month >= 0) && (this.month != date.getMonth())) {
      return false;
    }
    if ((this.dayOfMonth >= 0) && (this.dayOfMonth != date.getDate())) {
      return false;
    }
    if (this.hours >= 24) {
      return false;
    }
    if (this.minutes >= 60) {
      return false;
    }
    if (this.seconds >= 60) {
      return false;
    }
    if (this.milliseconds >= 1000) {
      return false;
    }
  }
  if (this.ambiguousYear) {
    Date defaultCenturyStart=new Date();
    defaultCenturyStart.setYear(defaultCenturyStart.getYear() - 80);
    if (date.before(defaultCenturyStart)) {
      date.setYear(defaultCenturyStart.getYear() + 100);
    }
  }
  if (this.dayOfWeek >= 0) {
    if (this.dayOfMonth == -1) {
      int adjustment=(7 + this.dayOfWeek - date.getDay()) % 7;
      if (adjustment > 3) {
        adjustment-=7;
      }
      int orgMonth=date.getMonth();
      date.setDate(date.getDate() + adjustment);
      if (date.getMonth() != orgMonth) {
        date.setDate(date.getDate() + (adjustment > 0 ? -7 : 7));
      }
    }
 else {
      if (date.getDay() != this.dayOfWeek) {
        return false;
      }
    }
  }
  if (this.tzOffset > Integer.MIN_VALUE) {
    int offset=date.getTimezoneOffset();
    date.setTime(date.getTime() + (this.tzOffset - offset) * 60 * 1000);
  }
  return true;
}","/** 
 * calcDate uses all the field available so far to fill a Date object. For those information that is not provided, the existing value in 'date' will be kept. Ambiguous year will be resolved after the date/time values are resolved. If the strict option is set to true, calcDate will calculate certain invalid dates by wrapping around as needed. For example, February 30 will wrap to March 2.
 * @param date The Date object being filled. Its value should be set to anacceptable default before pass in to this method
 * @param strict true to be strict when parsing
 * @return true if successful, otherwise false.
 */
public boolean calcDate(Date date,boolean strict){
  if (this.era == 0 && this.year > 0) {
    this.year=-(this.year - 1);
  }
  if (this.year > Integer.MIN_VALUE) {
    date.setYear(this.year - JS_START_YEAR);
  }
  int orgDayOfMonth=date.getDate();
  date.setDate(1);
  if (this.month >= 0) {
    date.setMonth(this.month);
  }
  if (this.dayOfMonth >= 0) {
    date.setDate(this.dayOfMonth);
  }
 else   if (this.month >= 0) {
    Date tmp=new Date(date.getYear(),date.getMonth(),35);
    int daysInCurrentMonth=35 - tmp.getDate();
    date.setDate(Math.min(daysInCurrentMonth,orgDayOfMonth));
  }
 else {
    date.setDate(orgDayOfMonth);
  }
  if (this.hours < 0) {
    this.hours=date.getHours();
  }
  if (this.ampm > 0) {
    if (this.hours < 12) {
      this.hours+=12;
    }
  }
  date.setHours(this.hours == 24 && this.midnightIs24 ? 0 : this.hours);
  if (this.minutes >= 0) {
    date.setMinutes(this.minutes);
  }
  if (this.seconds >= 0) {
    date.setSeconds(this.seconds);
  }
  if (this.milliseconds >= 0) {
    date.setTime(date.getTime() / 1000 * 1000 + this.milliseconds);
  }
  if (strict) {
    if ((this.year > Integer.MIN_VALUE) && ((this.year - JS_START_YEAR) != date.getYear())) {
      return false;
    }
    if ((this.month >= 0) && (this.month != date.getMonth())) {
      return false;
    }
    if ((this.dayOfMonth >= 0) && (this.dayOfMonth != date.getDate())) {
      return false;
    }
    if (this.hours == 24 && this.midnightIs24) {
      if (this.ampm > 0) {
        return false;
      }
    }
 else     if (this.hours >= 24) {
      return false;
    }
 else     if (this.hours == 0 && this.midnightIs24) {
      return false;
    }
    if (this.minutes >= 60) {
      return false;
    }
    if (this.seconds >= 60) {
      return false;
    }
    if (this.milliseconds >= 1000) {
      return false;
    }
  }
  if (this.ambiguousYear) {
    Date defaultCenturyStart=new Date();
    defaultCenturyStart.setYear(defaultCenturyStart.getYear() - 80);
    if (date.before(defaultCenturyStart)) {
      date.setYear(defaultCenturyStart.getYear() + 100);
    }
  }
  if (this.dayOfWeek >= 0) {
    if (this.dayOfMonth == -1) {
      int adjustment=(7 + this.dayOfWeek - date.getDay()) % 7;
      if (adjustment > 3) {
        adjustment-=7;
      }
      int orgMonth=date.getMonth();
      date.setDate(date.getDate() + adjustment);
      if (date.getMonth() != orgMonth) {
        date.setDate(date.getDate() + (adjustment > 0 ? -7 : 7));
      }
    }
 else {
      if (date.getDay() != this.dayOfWeek) {
        return false;
      }
    }
  }
  if (this.tzOffset > Integer.MIN_VALUE) {
    int offset=date.getTimezoneOffset();
    date.setTime(date.getTime() + (this.tzOffset - offset) * 60 * 1000);
  }
  return true;
}",0.9622699386503069
53567,"public void testHourParsingFkk(){
  Date date=new Date();
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertTrue(date.getHours() == 00);
  assertTrue(date.getMinutes() == 22);
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertTrue(date.getHours() == 11);
  assertTrue(date.getMinutes() == 22);
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertTrue(date.getHours() == 12);
  assertTrue(date.getMinutes() == 22);
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertTrue(date.getHours() == 23);
  assertTrue(date.getMinutes() == 22);
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertTrue(date.getHours() == 0);
  assertTrue(date.getMinutes() == 22);
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertTrue(date.getHours() == 00);
  assertTrue(date.getMinutes() == 22);
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertTrue(date.getHours() == 11);
  assertTrue(date.getMinutes() == 22);
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertTrue(date.getHours() == 12);
  assertTrue(date.getMinutes() == 22);
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertTrue(date.getHours() == 23);
  assertTrue(date.getMinutes() == 22);
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertTrue(date.getHours() == 0);
  assertTrue(date.getMinutes() == 22);
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertTrue(date.getHours() == 12);
  assertTrue(date.getMinutes() == 22);
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertTrue(date.getHours() == 23);
  assertTrue(date.getMinutes() == 22);
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertTrue(date.getHours() == 12);
  assertTrue(date.getMinutes() == 22);
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertTrue(date.getHours() == 23);
  assertTrue(date.getMinutes() == 22);
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertTrue(date.getHours() == 0);
  assertTrue(date.getMinutes() == 22);
}","public void testHourParsingFkk(){
  Date date=new Date();
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertEquals(0,date.getHours());
  assertEquals(22,date.getMinutes());
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertEquals(11,date.getHours());
  assertEquals(22,date.getMinutes());
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertEquals(12,date.getHours());
  assertEquals(22,date.getMinutes());
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertEquals(23,date.getHours());
  assertEquals(22,date.getMinutes());
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertEquals(0,date.getHours());
  assertEquals(22,date.getMinutes());
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertEquals(0,date.getHours());
  assertEquals(22,date.getMinutes());
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertEquals(11,date.getHours());
  assertEquals(22,date.getMinutes());
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertEquals(12,date.getHours());
  assertEquals(22,date.getMinutes());
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertEquals(23,date.getHours());
  assertEquals(22,date.getMinutes());
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertEquals(0,date.getHours());
  assertEquals(22,date.getMinutes());
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertEquals(12,date.getHours());
  assertEquals(22,date.getMinutes());
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertEquals(23,date.getHours());
  assertEquals(22,date.getMinutes());
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertEquals(12,date.getHours());
  assertEquals(22,date.getMinutes());
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertEquals(23,date.getHours());
  assertEquals(22,date.getMinutes());
  assertTrue(parse(""String_Node_Str"",""String_Node_Str"",0,date) > 0);
  assertEquals(0,date.getHours());
  assertEquals(22,date.getMinutes());
  DateTimeFormat dtf=DateTimeFormat.getFormat(""String_Node_Str"");
  long time=Date.UTC(2013 - 1900,1 - 1,1,0,34,56);
  date=dtf.parse(""String_Node_Str"");
  assertEquals(time,date.getTime());
  date=dtf.parseStrict(""String_Node_Str"");
  assertEquals(time,date.getTime());
  try {
    dtf.parseStrict(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
}",0.2175714877745544
53568,"@Override public boolean equals(Object that){
  if (that == null && this.getClass() != that.getClass()) {
    return false;
  }
  JsArrayLiteral thatLiteral=(JsArrayLiteral)that;
  return internable == thatLiteral.internable && exprs.equals(thatLiteral.exprs);
}","@Override public boolean equals(Object that){
  if (that == null || this.getClass() != that.getClass()) {
    return false;
  }
  JsArrayLiteral thatLiteral=(JsArrayLiteral)that;
  return internable == thatLiteral.internable && exprs.equals(thatLiteral.exprs);
}",0.3893129770992366
53569,"@Override public boolean equals(Object that){
  if (that == null && this.getClass() != that.getClass()) {
    return false;
  }
  JsObjectLiteral thatLiteral=(JsObjectLiteral)that;
  return internable == thatLiteral.internable && properties.equals(thatLiteral.properties);
}","@Override public boolean equals(Object that){
  if (that == null || this.getClass() != that.getClass()) {
    return false;
  }
  JsObjectLiteral thatLiteral=(JsObjectLiteral)that;
  return internable == thatLiteral.internable && properties.equals(thatLiteral.properties);
}",0.2591240875912409
53570,"@Override public ConfigurationProperty getConfigurationProperty(String propertyName) throws BadPropertyValueException {
  Property property=properties.find(propertyName);
  if (property instanceof ConfigurationProperty) {
    ConfigurationProperty configurationProperty=(ConfigurationProperty)property;
    return new DefaultConfigurationProperty(configurationProperty.getName(),configurationProperty.getValues());
  }
  throw new BadPropertyValueException(propertyName);
}","@Override public ConfigurationProperty getConfigurationProperty(String propertyName) throws BadPropertyValueException {
  Property property=properties.find(propertyName);
  if (property instanceof com.google.gwt.dev.cfg.ConfigurationProperty) {
    com.google.gwt.dev.cfg.ConfigurationProperty configurationProperty=(com.google.gwt.dev.cfg.ConfigurationProperty)property;
    return new DefaultConfigurationProperty(configurationProperty.getName(),configurationProperty.getValues());
  }
  throw new BadPropertyValueException(propertyName);
}",0.9320197044334976
53571,"private void clearLocals(){
  tempLocals.clear();
  localIndex=0;
}","private void clearLocals(){
  catchVariableIndex=0;
}",0.75
53572,"@Override public boolean visit(JTryStatement x,Context ctx){
  if (!x.getCatchClauses().isEmpty()) {
    pushTempLocal(x.getSourceInfo());
  }
  return true;
}","@Override public boolean visit(JMethodBody x,Context ctx){
  currentMethodBody=x;
  clearLocals();
  return true;
}",0.6204379562043796
53573,"@Override public boolean visit(JThisRef x,Context ctx){
  return false;
}","@Override public boolean visit(JMethodBody body,Context ctx){
}",0.7352941176470589
53574,"private Pair<JavaToJavaScriptMap,Set<JsNode>> execImpl(){
  CanObserveSubclassUninitializedFieldsVisitor canObserve=new CanObserveSubclassUninitializedFieldsVisitor();
  canObserve.accept(program);
  SortVisitor sorter=new SortVisitor();
  sorter.accept(program);
  RecordCrossClassCallsAndJSInlinableMethods recorder=new RecordCrossClassCallsAndJSInlinableMethods();
  recorder.accept(program);
  CreateNamesAndScopesVisitor creator=new CreateNamesAndScopesVisitor();
  creator.accept(program);
  GenerateJavaScriptVisitor generator=new GenerateJavaScriptVisitor(recorder.methodsForJsInlining);
  generator.accept(program);
  final Map<JsName,JMethod> nameToMethodMap=new HashMap<JsName,JMethod>();
  final HashMap<JsName,JField> nameToFieldMap=new HashMap<JsName,JField>();
  final HashMap<JsName,JClassType> constructorNameToTypeMap=new HashMap<JsName,JClassType>();
  for (  JDeclaredType type : program.getDeclaredTypes()) {
    JsName typeName=names.get(type);
    if (type instanceof JClassType && typeName != null) {
      constructorNameToTypeMap.put(typeName,(JClassType)type);
    }
    for (    JField field : type.getFields()) {
      if (field.isStatic()) {
        JsName fieldName=names.get(field);
        if (fieldName != null) {
          nameToFieldMap.put(fieldName,field);
        }
      }
    }
    for (    JMethod method : type.getMethods()) {
      JsName methodName=names.get(method);
      if (methodName != null) {
        nameToMethodMap.put(methodName,method);
      }
    }
  }
  jsProgram.setIndexedFields(indexedFields);
  jsProgram.setIndexedFunctions(indexedFunctions);
  JavaToJavaScriptMap jjsMap=new JavaToJavaScriptMap(){
    @Override public JsName nameForMethod(    JMethod method){
      return names.get(method);
    }
    @Override public JsName nameForType(    JClassType type){
      return names.get(type);
    }
    @Override public JField nameToField(    JsName name){
      return nameToFieldMap.get(name);
    }
    @Override public JMethod nameToMethod(    JsName name){
      return nameToMethodMap.get(name);
    }
    @Override public JClassType nameToType(    JsName name){
      return constructorNameToTypeMap.get(name);
    }
    @Override public JClassType typeForStatement(    JsStatement stat){
      return typeForStatMap.get(stat);
    }
    @Override public JMethod vtableInitToMethod(    JsStatement stat){
      return vtableInitForMethodMap.get(stat);
    }
  }
;
  return Pair.create(jjsMap,generator.functionsForJsInlining);
}","private Pair<JavaToJavaScriptMap,Set<JsNode>> execImpl(){
  new FixNameClashesVisitor().accept(program);
  CanObserveSubclassUninitializedFieldsVisitor canObserve=new CanObserveSubclassUninitializedFieldsVisitor();
  canObserve.accept(program);
  SortVisitor sorter=new SortVisitor();
  sorter.accept(program);
  RecordCrossClassCallsAndJSInlinableMethods recorder=new RecordCrossClassCallsAndJSInlinableMethods();
  recorder.accept(program);
  CreateNamesAndScopesVisitor creator=new CreateNamesAndScopesVisitor();
  creator.accept(program);
  GenerateJavaScriptVisitor generator=new GenerateJavaScriptVisitor(recorder.methodsForJsInlining);
  generator.accept(program);
  final Map<JsName,JMethod> nameToMethodMap=new HashMap<JsName,JMethod>();
  final HashMap<JsName,JField> nameToFieldMap=new HashMap<JsName,JField>();
  final HashMap<JsName,JClassType> constructorNameToTypeMap=new HashMap<JsName,JClassType>();
  for (  JDeclaredType type : program.getDeclaredTypes()) {
    JsName typeName=names.get(type);
    if (type instanceof JClassType && typeName != null) {
      constructorNameToTypeMap.put(typeName,(JClassType)type);
    }
    for (    JField field : type.getFields()) {
      if (field.isStatic()) {
        JsName fieldName=names.get(field);
        if (fieldName != null) {
          nameToFieldMap.put(fieldName,field);
        }
      }
    }
    for (    JMethod method : type.getMethods()) {
      JsName methodName=names.get(method);
      if (methodName != null) {
        nameToMethodMap.put(methodName,method);
      }
    }
  }
  jsProgram.setIndexedFields(indexedFields);
  jsProgram.setIndexedFunctions(indexedFunctions);
  JavaToJavaScriptMap jjsMap=new JavaToJavaScriptMap(){
    @Override public JsName nameForMethod(    JMethod method){
      return names.get(method);
    }
    @Override public JsName nameForType(    JClassType type){
      return names.get(type);
    }
    @Override public JField nameToField(    JsName name){
      return nameToFieldMap.get(name);
    }
    @Override public JMethod nameToMethod(    JsName name){
      return nameToMethodMap.get(name);
    }
    @Override public JClassType nameToType(    JsName name){
      return constructorNameToTypeMap.get(name);
    }
    @Override public JClassType typeForStatement(    JsStatement stat){
      return typeForStatMap.get(stat);
    }
    @Override public JMethod vtableInitToMethod(    JsStatement stat){
      return vtableInitForMethodMap.get(stat);
    }
  }
;
  return Pair.create(jjsMap,generator.functionsForJsInlining);
}",0.990680150703946
53575,"/** 
 * Generates HTML for a tree item with an attached icon.
 * @param imageProto the image prototype to use
 * @param title the title of the item
 * @return the resultant HTML
 */
private String imageItemHTML(ImageResource imageProto,String title){
  return AbstractImagePrototype.create(imageProto).getHTML() + ""String_Node_Str"" + title;
}","/** 
 * Generates HTML for a tree item with an attached icon.
 * @param imageProto the image prototype to use
 * @param title the title of the item
 * @return the resultant HTML
 */
private SafeHtml imageItemHTML(ImageResource imageProto,String title){
  SafeHtmlBuilder builder=new SafeHtmlBuilder();
  builder.append(AbstractImagePrototype.create(imageProto).getSafeHtml());
  builder.appendHtmlConstant(""String_Node_Str"");
  builder.appendEscaped(title);
  return builder.toSafeHtml();
}",0.7524038461538461
53576,"@Source(""String_Node_Str"") ImageResource treeLeaf();","@Override @Source(""String_Node_Str"") ImageResource treeLeaf();",0.912280701754386
53577,"/** 
 * Constructs a new mailboxes widget with a bundle of images.
 * @param images a bundle that provides the images for this widget
 */
public Mailboxes(){
  Images images=GWT.create(Images.class);
  tree=new Tree(images);
  TreeItem root=new TreeItem(imageItemHTML(images.home(),""String_Node_Str""));
  tree.addItem(root);
  addImageItem(root,""String_Node_Str"",images.inbox());
  addImageItem(root,""String_Node_Str"",images.drafts());
  addImageItem(root,""String_Node_Str"",images.templates());
  addImageItem(root,""String_Node_Str"",images.sent());
  addImageItem(root,""String_Node_Str"",images.trash());
  root.setState(true);
  initWidget(tree);
}","/** 
 * Constructs a new mailboxes widget.
 */
public Mailboxes(){
  Images images=GWT.create(Images.class);
  tree=new Tree(images);
  TreeItem root=new TreeItem(imageItemHTML(images.home(),""String_Node_Str""));
  tree.addItem(root);
  addImageItem(root,""String_Node_Str"",images.inbox());
  addImageItem(root,""String_Node_Str"",images.drafts());
  addImageItem(root,""String_Node_Str"",images.templates());
  addImageItem(root,""String_Node_Str"",images.sent());
  addImageItem(root,""String_Node_Str"",images.trash());
  root.setState(true);
  initWidget(tree);
}",0.9228215767634856
53578,"@Override public void onCellPreview(CellPreviewEvent<T> event){
  NativeEvent nativeEvent=event.getNativeEvent();
  String eventType=event.getNativeEvent().getType();
  if (BrowserEvents.KEYDOWN.equals(eventType) && !event.isCellEditing()) {
switch (nativeEvent.getKeyCode()) {
case KeyCodes.KEY_DOWN:
      nextRow();
    handledEvent(event);
  return;
case KeyCodes.KEY_UP:
prevRow();
handledEvent(event);
return;
case KeyCodes.KEY_PAGEDOWN:
nextPage();
handledEvent(event);
return;
case KeyCodes.KEY_PAGEUP:
prevPage();
handledEvent(event);
return;
case KeyCodes.KEY_HOME:
home();
handledEvent(event);
return;
case KeyCodes.KEY_END:
end();
handledEvent(event);
return;
case 32:
handledEvent(event);
return;
}
}
 else if (BrowserEvents.CLICK.equals(eventType)) {
int relRow=event.getIndex() - display.getPageStart();
boolean isFocusable=false;
Element target=Element.as(event.getNativeEvent().getEventTarget());
isFocusable=CellBasedWidgetImpl.get().isFocusable(target);
display.setKeyboardSelectedRow(relRow,!isFocusable);
}
 else if (BrowserEvents.FOCUS.equals(eventType)) {
int relRow=event.getIndex() - display.getPageStart();
if (display.getKeyboardSelectedRow() != relRow) {
display.setKeyboardSelectedRow(event.getIndex(),false);
return;
}
}
}","@Override public void onCellPreview(CellPreviewEvent<T> event){
  NativeEvent nativeEvent=event.getNativeEvent();
  String eventType=event.getNativeEvent().getType();
  if (BrowserEvents.KEYDOWN.equals(eventType) && !event.isCellEditing()) {
switch (nativeEvent.getKeyCode()) {
case KeyCodes.KEY_DOWN:
      nextRow();
    handledEvent(event);
  return;
case KeyCodes.KEY_UP:
prevRow();
handledEvent(event);
return;
case KeyCodes.KEY_PAGEDOWN:
nextPage();
handledEvent(event);
return;
case KeyCodes.KEY_PAGEUP:
prevPage();
handledEvent(event);
return;
case KeyCodes.KEY_HOME:
home();
handledEvent(event);
return;
case KeyCodes.KEY_END:
end();
handledEvent(event);
return;
case 32:
handledEvent(event);
return;
}
}
 else if (BrowserEvents.CLICK.equals(eventType)) {
int relRow=event.getIndex() - display.getPageStart();
boolean isFocusable=false;
Element target=Element.as(event.getNativeEvent().getEventTarget());
isFocusable=CellBasedWidgetImpl.get().isFocusable(target);
display.setKeyboardSelectedRow(relRow,!isFocusable);
}
 else if (BrowserEvents.FOCUS.equals(eventType)) {
int relRow=event.getIndex() - display.getPageStart();
if (display.getKeyboardSelectedRow() != relRow) {
display.setKeyboardSelectedRow(relRow,false);
return;
}
}
}",0.9911788291900562
53579,"private void displayJSONObject(JSONValue jsonValue){
  jsonTree.removeItems();
  jsonTree.setVisible(true);
  TreeItem treeItem=jsonTree.addItem(""String_Node_Str"");
  addChildren(treeItem,jsonValue);
  treeItem.setStyleName(""String_Node_Str"");
  treeItem.setState(true);
}","private void displayJSONObject(JSONValue jsonValue){
  jsonTree.removeItems();
  jsonTree.setVisible(true);
  TreeItem treeItem=jsonTree.addItem(SafeHtmlUtils.fromString(""String_Node_Str""));
  addChildren(treeItem,jsonValue);
  treeItem.setStyleName(""String_Node_Str"");
  treeItem.setState(true);
}",0.9157894736842104
53580,"private void displayError(String errorType,String errorMessage){
  jsonTree.removeItems();
  jsonTree.setVisible(true);
  TreeItem treeItem=jsonTree.addItem(errorType);
  treeItem.addItem(errorMessage);
  treeItem.setStyleName(""String_Node_Str"");
  treeItem.setState(true);
}","private void displayError(String errorType,String errorMessage){
  jsonTree.removeItems();
  jsonTree.setVisible(true);
  TreeItem treeItem=jsonTree.addItem(SafeHtmlUtils.fromString(errorType));
  treeItem.addItem(SafeHtmlUtils.fromString(errorMessage));
  treeItem.setStyleName(""String_Node_Str"");
  treeItem.setState(true);
}",0.8471760797342193
53581,"private String getChildText(String text){
  return ""String_Node_Str"" + text + ""String_Node_Str"";
}","private SafeHtml getChildText(String text){
  return new SafeHtmlBuilder().appendHtmlConstant(""String_Node_Str"").appendEscaped(text).appendHtmlConstant(""String_Node_Str"").toSafeHtml();
}",0.6197183098591549
53582,"private void addChildren(TreeItem treeItem,JSONValue jsonValue){
  JSONArray jsonArray;
  JSONObject jsonObject;
  JSONString jsonString;
  if ((jsonArray=jsonValue.isArray()) != null) {
    for (int i=0; i < jsonArray.size(); ++i) {
      TreeItem child=treeItem.addItem(getChildText(""String_Node_Str"" + Integer.toString(i) + ""String_Node_Str""));
      addChildren(child,jsonArray.get(i));
    }
  }
 else   if ((jsonObject=jsonValue.isObject()) != null) {
    Set<String> keys=jsonObject.keySet();
    for (    String key : keys) {
      TreeItem child=treeItem.addItem(getChildText(key));
      addChildren(child,jsonObject.get(key));
    }
  }
 else   if ((jsonString=jsonValue.isString()) != null) {
    treeItem.addItem(jsonString.stringValue());
  }
 else {
    treeItem.addItem(getChildText(jsonValue.toString()));
  }
}","private void addChildren(TreeItem treeItem,JSONValue jsonValue){
  JSONArray jsonArray;
  JSONObject jsonObject;
  JSONString jsonString;
  if ((jsonArray=jsonValue.isArray()) != null) {
    for (int i=0; i < jsonArray.size(); ++i) {
      TreeItem child=treeItem.addItem(getChildText(""String_Node_Str"" + Integer.toString(i) + ""String_Node_Str""));
      addChildren(child,jsonArray.get(i));
    }
  }
 else   if ((jsonObject=jsonValue.isObject()) != null) {
    Set<String> keys=jsonObject.keySet();
    for (    String key : keys) {
      TreeItem child=treeItem.addItem(getChildText(key));
      addChildren(child,jsonObject.get(key));
    }
  }
 else   if ((jsonString=jsonValue.isString()) != null) {
    treeItem.addItem(SafeHtmlUtils.fromString(jsonString.stringValue()));
  }
 else {
    treeItem.addItem(getChildText(jsonValue.toString()));
  }
}",0.9845422116527944
53583,"/** 
 * Closes the menu bar.
 * @deprecated Use {@link #addCloseHandler(CloseHandler)} instead
 */
@Override @Deprecated public void onPopupClosed(PopupPanel sender,boolean autoClosed){
  if (autoClosed) {
    closeAllParents();
  }
  onHide(!autoClosed);
  CloseEvent.fire(MenuBar.this,sender);
  shownChildMenu=null;
  popup=null;
  if (parentMenu != null && parentMenu.popup != null) {
    parentMenu.popup.setPreviewingAllNativeEvents(true);
  }
}","/** 
 * Closes the menu bar.
 * @deprecated Use {@link #addCloseHandler(CloseHandler)} instead
 */
@Override @Deprecated public void onPopupClosed(PopupPanel sender,boolean autoClosed){
  if (autoClosed) {
    closeAllParents();
  }
  onHide(!autoClosed && focusOnHover);
  CloseEvent.fire(MenuBar.this,sender);
  shownChildMenu=null;
  popup=null;
  if (parentMenu != null && parentMenu.popup != null) {
    parentMenu.popup.setPreviewingAllNativeEvents(true);
  }
}",0.982570806100218
53584,"/** 
 * Compiles a particular permutation, based on a precompiled unified AST.
 * @param logger the logger to use
 * @param unifiedAst the result of a {@link #precompile(TreeLogger,ModuleDef,RebindPermutationOracle,String[],String[],JJSOptions,boolean,PrecompilationMetricsArtifact)}
 * @param permutation the permutation to compile
 * @return the output JavaScript
 * @throws UnableToCompleteException if an error other than {@link OutOfMemoryError} occurs
 */
public static PermutationResult compilePermutation(TreeLogger logger,UnifiedAst unifiedAst,Permutation permutation) throws UnableToCompleteException {
  JJSOptions options=unifiedAst.getOptions();
  long startTimeMilliseconds=System.currentTimeMillis();
  Event jjsCompilePermutationEvent=SpeedTracerLogger.start(CompilerEventType.JJS_COMPILE_PERMUTATION,""String_Node_Str"",permutation.prettyPrint());
  InternalCompilerException.preload();
  PropertyOracle[] propertyOracles=permutation.getPropertyOracles();
  int permutationId=permutation.getId();
  if (logger.isLoggable(TreeLogger.INFO)) {
    logger.log(TreeLogger.INFO,""String_Node_Str"" + permutationId + ""String_Node_Str"");
  }
  long permStart=System.currentTimeMillis();
  try {
    if (JProgram.isTracingEnabled()) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + permutation.prettyPrint());
    }
    AST ast=unifiedAst.getFreshAst();
    JProgram jprogram=ast.getJProgram();
    JsProgram jsProgram=ast.getJsProgram();
    Map<StandardSymbolData,JsName> symbolTable=new TreeMap<StandardSymbolData,JsName>(new SymbolData.ClassIdentComparator());
    ResolveRebinds.exec(jprogram,permutation.getOrderedRebindAnswers());
    Multimap<String,Integer> instrumentableLines=null;
    if (System.getProperty(""String_Node_Str"") != null) {
      instrumentableLines=BaselineCoverageGatherer.exec(jprogram);
    }
    int optimizationLevel=options.getOptimizationLevel();
    if (optimizationLevel == OptionOptimize.OPTIMIZE_LEVEL_DRAFT) {
      draftOptimize(jprogram);
    }
 else {
      optimize(options,jprogram);
    }
    RemoveEmptySuperCalls.exec(jprogram);
    JsoDevirtualizer.exec(jprogram);
    CatchBlockNormalizer.exec(jprogram);
    PostOptimizationCompoundAssignmentNormalizer.exec(jprogram);
    LongCastNormalizer.exec(jprogram);
    LongEmulationNormalizer.exec(jprogram);
    CastNormalizer.exec(jprogram,options.isCastCheckingDisabled());
    ArrayNormalizer.exec(jprogram);
    EqualityNormalizer.exec(jprogram);
    Pruner.exec(jprogram,false);
    ReplaceGetClassOverrides.exec(jprogram);
    jprogram.typeOracle.recomputeAfterOptimizations();
    Pair<? extends JavaToJavaScriptMap,Set<JsNode>> genAstResult=GenerateJavaScriptAST.exec(jprogram,jsProgram,options.getOutput(),symbolTable,propertyOracles);
    JavaToJavaScriptMap jjsmap=genAstResult.getLeft();
    JsNormalizer.exec(jsProgram);
    if (instrumentableLines != null) {
      CoverageInstrumentor.exec(jsProgram,instrumentableLines);
    }
    JsSymbolResolver.exec(jsProgram);
    EvalFunctionsAtTopScope.exec(jsProgram,jjsmap);
    if (optimizationLevel > OptionOptimize.OPTIMIZE_LEVEL_DRAFT) {
      optimizeJs(options,jsProgram,genAstResult.getRight());
      JsDuplicateCaseFolder.exec(jsProgram);
    }
    JsStackEmulator.exec(jprogram,jsProgram,propertyOracles,jjsmap);
    JsCoerceIntShift.exec(jsProgram,logger,propertyOracles);
    SyntheticArtifact dependencies=null;
    if (options.isRunAsyncEnabled()) {
      ByteArrayOutputStream baos=new ByteArrayOutputStream();
      int fragmentsMerge=0;
      int expectedFragmentCount=options.getFragmentCount();
      if (expectedFragmentCount > 0) {
        fragmentsMerge=jprogram.getRunAsyncs().size() + 2 - expectedFragmentCount;
      }
 else {
        fragmentsMerge=options.getFragmentsMerge();
      }
      if (fragmentsMerge > 0) {
        CodeSplitter2.exec(logger,jprogram,jsProgram,jjsmap,fragmentsMerge,chooseDependencyRecorder(options.isSoycEnabled(),baos),findIntegerConfigurationProperty(propertyOracles,logger,CodeSplitter2.LEFTOVERMERGE_SIZE,0));
      }
 else {
        CodeSplitter.exec(logger,jprogram,jsProgram,jjsmap,chooseDependencyRecorder(options.isSoycEnabled(),baos));
      }
      if (baos.size() == 0 && options.isSoycEnabled()) {
        recordNonSplitDependencies(jprogram,baos);
      }
      if (baos.size() > 0) {
        dependencies=new SyntheticArtifact(SoycReportLinker.class,""String_Node_Str"" + permutationId + ""String_Node_Str"",baos.toByteArray());
      }
    }
    boolean isIE6orUnknown=findBooleanProperty(propertyOracles,logger,""String_Node_Str"",""String_Node_Str"",true,false,true);
    boolean isSourceMapsEnabled=findBooleanProperty(propertyOracles,logger,""String_Node_Str"",""String_Node_Str"",true,false,false);
    Map<JsName,String> obfuscateMap=Maps.create();
switch (options.getOutput()) {
case OBFUSCATED:
      obfuscateMap=JsStringInterner.exec(jprogram,jsProgram,isIE6orUnknown);
    JsObfuscateNamer.exec(jsProgram,propertyOracles);
  if (options.shouldRemoveDuplicateFunctions()) {
    if (JsStackEmulator.getStackMode(propertyOracles) == JsStackEmulator.StackMode.STRIP) {
      boolean changed=false;
      for (int i=0; i < jsProgram.getFragmentCount(); i++) {
        JsBlock fragment=jsProgram.getFragmentBlock(i);
        changed=JsDuplicateFunctionRemover.exec(jsProgram,fragment) || changed;
      }
      if (changed) {
        JsUnusedFunctionRemover.exec(jsProgram);
        JsObfuscateNamer.exec(jsProgram,propertyOracles);
      }
    }
  }
break;
case PRETTY:
JsPrettyNamer.exec(jsProgram,propertyOracles);
break;
case DETAILED:
obfuscateMap=JsStringInterner.exec(jprogram,jsProgram,isIE6orUnknown);
JsVerboseNamer.exec(jsProgram,propertyOracles);
break;
default :
throw new InternalCompilerException(""String_Node_Str"");
}
HandleCrossFragmentReferences.exec(logger,jsProgram,propertyOracles);
VerifySymbolMap.exec(jsProgram,jjsmap,symbolTable);
boolean splitBlocks=isIE6orUnknown;
if (splitBlocks) {
JsIEBlockSizeVisitor.exec(jsProgram);
}
JsBreakUpLargeVarStatements.exec(jsProgram,propertyOracles);
String[] js=new String[jsProgram.getFragmentCount()];
StatementRanges[] ranges=new StatementRanges[js.length];
SizeBreakdown[] sizeBreakdowns=options.isSoycEnabled() || options.isCompilerMetricsEnabled() ? new SizeBreakdown[js.length] : null;
List<Map<Range,SourceInfo>> sourceInfoMaps=new ArrayList<Map<Range,SourceInfo>>();
generateJavaScriptCode(options,jprogram,jsProgram,jjsmap,js,ranges,sizeBreakdowns,sourceInfoMaps,splitBlocks,isSourceMapsEnabled);
PermutationResult toReturn=new PermutationResultImpl(js,permutation,makeSymbolMap(symbolTable,jsProgram),ranges);
CompilationMetricsArtifact compilationMetrics=null;
if (options.isCompilerMetricsEnabled()) {
if (options.isClosureCompilerEnabled()) {
logger.log(TreeLogger.WARN,""String_Node_Str"" + ""String_Node_Str"");
}
 else {
compilationMetrics=new CompilationMetricsArtifact(permutation.getId());
compilationMetrics.setCompileElapsedMilliseconds(System.currentTimeMillis() - startTimeMilliseconds);
compilationMetrics.setElapsedMilliseconds(System.currentTimeMillis() - ManagementFactory.getRuntimeMXBean().getStartTime());
compilationMetrics.setJsSize(sizeBreakdowns);
compilationMetrics.setPermutationDescription(permutation.prettyPrint());
toReturn.addArtifacts(Lists.create(unifiedAst.getModuleMetrics(),unifiedAst.getPrecompilationMetrics(),compilationMetrics));
}
}
if (options.isClosureCompilerEnabled()) {
if (options.isSoycEnabled()) {
logger.log(TreeLogger.WARN,""String_Node_Str"" + ""String_Node_Str"");
}
}
 else {
toReturn.addArtifacts(makeSoycArtifacts(logger,permutationId,jprogram,js,sizeBreakdowns,options.isSoycExtra() ? sourceInfoMaps : null,dependencies,jjsmap,obfuscateMap,unifiedAst.getModuleMetrics(),unifiedAst.getPrecompilationMetrics(),compilationMetrics,options.isSoycHtmlDisabled()));
}
if (isSourceMapsEnabled) {
if (options.isClosureCompilerEnabled()) {
logger.log(TreeLogger.WARN,""String_Node_Str"" + ""String_Node_Str"");
}
 else {
logger.log(TreeLogger.INFO,""String_Node_Str"");
toReturn.addArtifacts(SourceMapRecorder.makeSourceMapArtifacts(sourceInfoMaps,permutationId));
}
}
logTrackingStats(logger);
if (logger.isLoggable(TreeLogger.TRACE)) {
logger.log(TreeLogger.TRACE,""String_Node_Str"" + (System.currentTimeMillis() - permStart) + ""String_Node_Str"");
}
return toReturn;
}
 catch (Throwable e) {
throw CompilationProblemReporter.logAndTranslateException(logger,e);
}
 finally {
jjsCompilePermutationEvent.end();
}
}","/** 
 * Compiles a particular permutation, based on a precompiled unified AST.
 * @param logger the logger to use
 * @param unifiedAst the result of a {@link #precompile(TreeLogger,ModuleDef,RebindPermutationOracle,String[],String[],JJSOptions,boolean,PrecompilationMetricsArtifact)}
 * @param permutation the permutation to compile
 * @return the output JavaScript
 * @throws UnableToCompleteException if an error other than {@link OutOfMemoryError} occurs
 */
public static PermutationResult compilePermutation(TreeLogger logger,UnifiedAst unifiedAst,Permutation permutation) throws UnableToCompleteException {
  JJSOptions options=unifiedAst.getOptions();
  long startTimeMilliseconds=System.currentTimeMillis();
  Event jjsCompilePermutationEvent=SpeedTracerLogger.start(CompilerEventType.JJS_COMPILE_PERMUTATION,""String_Node_Str"",permutation.prettyPrint());
  InternalCompilerException.preload();
  PropertyOracle[] propertyOracles=permutation.getPropertyOracles();
  int permutationId=permutation.getId();
  if (logger.isLoggable(TreeLogger.INFO)) {
    logger.log(TreeLogger.INFO,""String_Node_Str"" + permutationId + ""String_Node_Str"");
  }
  long permStart=System.currentTimeMillis();
  try {
    if (JProgram.isTracingEnabled()) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + permutation.prettyPrint());
    }
    AST ast=unifiedAst.getFreshAst();
    JProgram jprogram=ast.getJProgram();
    JsProgram jsProgram=ast.getJsProgram();
    Map<StandardSymbolData,JsName> symbolTable=new TreeMap<StandardSymbolData,JsName>(new SymbolData.ClassIdentComparator());
    ResolveRebinds.exec(jprogram,permutation.getOrderedRebindAnswers());
    Multimap<String,Integer> instrumentableLines=null;
    if (System.getProperty(""String_Node_Str"") != null) {
      instrumentableLines=BaselineCoverageGatherer.exec(jprogram);
    }
    int optimizationLevel=options.getOptimizationLevel();
    if (optimizationLevel == OptionOptimize.OPTIMIZE_LEVEL_DRAFT) {
      draftOptimize(jprogram);
    }
 else {
      optimize(options,jprogram);
    }
    RemoveEmptySuperCalls.exec(jprogram);
    JsoDevirtualizer.exec(jprogram);
    CatchBlockNormalizer.exec(jprogram);
    PostOptimizationCompoundAssignmentNormalizer.exec(jprogram);
    LongCastNormalizer.exec(jprogram);
    LongEmulationNormalizer.exec(jprogram);
    CastNormalizer.exec(jprogram,options.isCastCheckingDisabled());
    ArrayNormalizer.exec(jprogram);
    EqualityNormalizer.exec(jprogram);
    Pruner.exec(jprogram,false);
    ReplaceGetClassOverrides.exec(jprogram);
    jprogram.typeOracle.recomputeAfterOptimizations();
    Pair<? extends JavaToJavaScriptMap,Set<JsNode>> genAstResult=GenerateJavaScriptAST.exec(jprogram,jsProgram,options.getOutput(),symbolTable,propertyOracles);
    JavaToJavaScriptMap jjsmap=genAstResult.getLeft();
    JsNormalizer.exec(jsProgram);
    if (instrumentableLines != null) {
      CoverageInstrumentor.exec(jsProgram,instrumentableLines);
    }
    JsSymbolResolver.exec(jsProgram);
    EvalFunctionsAtTopScope.exec(jsProgram,jjsmap);
    if (optimizationLevel > OptionOptimize.OPTIMIZE_LEVEL_DRAFT) {
      optimizeJs(options,jsProgram,genAstResult.getRight());
      JsDuplicateCaseFolder.exec(jsProgram);
    }
    JsStackEmulator.exec(jprogram,jsProgram,propertyOracles,jjsmap);
    JsCoerceIntShift.exec(jsProgram,logger,propertyOracles);
    SyntheticArtifact dependencies=null;
    if (options.isRunAsyncEnabled()) {
      ByteArrayOutputStream baos=new ByteArrayOutputStream();
      int fragmentsMerge=0;
      int expectedFragmentCount=options.getFragmentCount();
      if (expectedFragmentCount > 0) {
        fragmentsMerge=jprogram.getRunAsyncs().size() + 2 - expectedFragmentCount;
      }
 else {
        fragmentsMerge=options.getFragmentsMerge();
      }
      if (fragmentsMerge > 0) {
        CodeSplitter2.exec(logger,jprogram,jsProgram,jjsmap,fragmentsMerge,chooseDependencyRecorder(options.isSoycEnabled(),baos),findIntegerConfigurationProperty(propertyOracles,logger,CodeSplitter2.LEFTOVERMERGE_SIZE,0));
      }
 else {
        CodeSplitter.exec(logger,jprogram,jsProgram,jjsmap,chooseDependencyRecorder(options.isSoycEnabled(),baos));
      }
      if (baos.size() == 0 && options.isSoycEnabled()) {
        recordNonSplitDependencies(jprogram,baos);
      }
      if (baos.size() > 0) {
        dependencies=new SyntheticArtifact(SoycReportLinker.class,""String_Node_Str"" + permutationId + ""String_Node_Str"",baos.toByteArray());
      }
    }
    boolean isIE6orUnknown=findBooleanProperty(propertyOracles,logger,""String_Node_Str"",""String_Node_Str"",true,false,true);
    boolean isSourceMapsEnabled=findBooleanProperty(propertyOracles,logger,""String_Node_Str"",""String_Node_Str"",true,false,false);
    Map<JsName,String> obfuscateMap=Maps.create();
switch (options.getOutput()) {
case OBFUSCATED:
      obfuscateMap=JsStringInterner.exec(jprogram,jsProgram,isIE6orUnknown);
    FreshNameGenerator freshNameGenerator=JsObfuscateNamer.exec(jsProgram,propertyOracles);
  if (options.shouldRemoveDuplicateFunctions() && JsStackEmulator.getStackMode(propertyOracles) == JsStackEmulator.StackMode.STRIP) {
    JsDuplicateFunctionRemover.exec(jsProgram,freshNameGenerator);
  }
break;
case PRETTY:
JsPrettyNamer.exec(jsProgram,propertyOracles);
break;
case DETAILED:
obfuscateMap=JsStringInterner.exec(jprogram,jsProgram,isIE6orUnknown);
JsVerboseNamer.exec(jsProgram,propertyOracles);
break;
default :
throw new InternalCompilerException(""String_Node_Str"");
}
HandleCrossFragmentReferences.exec(logger,jsProgram,propertyOracles);
VerifySymbolMap.exec(jsProgram,jjsmap,symbolTable);
boolean splitBlocks=isIE6orUnknown;
if (splitBlocks) {
JsIEBlockSizeVisitor.exec(jsProgram);
}
JsBreakUpLargeVarStatements.exec(jsProgram,propertyOracles);
String[] js=new String[jsProgram.getFragmentCount()];
StatementRanges[] ranges=new StatementRanges[js.length];
SizeBreakdown[] sizeBreakdowns=options.isSoycEnabled() || options.isCompilerMetricsEnabled() ? new SizeBreakdown[js.length] : null;
List<Map<Range,SourceInfo>> sourceInfoMaps=new ArrayList<Map<Range,SourceInfo>>();
generateJavaScriptCode(options,jprogram,jsProgram,jjsmap,js,ranges,sizeBreakdowns,sourceInfoMaps,splitBlocks,isSourceMapsEnabled);
PermutationResult toReturn=new PermutationResultImpl(js,permutation,makeSymbolMap(symbolTable,jsProgram),ranges);
CompilationMetricsArtifact compilationMetrics=null;
if (options.isCompilerMetricsEnabled()) {
if (options.isClosureCompilerEnabled()) {
logger.log(TreeLogger.WARN,""String_Node_Str"" + ""String_Node_Str"");
}
 else {
compilationMetrics=new CompilationMetricsArtifact(permutation.getId());
compilationMetrics.setCompileElapsedMilliseconds(System.currentTimeMillis() - startTimeMilliseconds);
compilationMetrics.setElapsedMilliseconds(System.currentTimeMillis() - ManagementFactory.getRuntimeMXBean().getStartTime());
compilationMetrics.setJsSize(sizeBreakdowns);
compilationMetrics.setPermutationDescription(permutation.prettyPrint());
toReturn.addArtifacts(Lists.create(unifiedAst.getModuleMetrics(),unifiedAst.getPrecompilationMetrics(),compilationMetrics));
}
}
if (options.isClosureCompilerEnabled()) {
if (options.isSoycEnabled()) {
logger.log(TreeLogger.WARN,""String_Node_Str"" + ""String_Node_Str"");
}
}
 else {
toReturn.addArtifacts(makeSoycArtifacts(logger,permutationId,jprogram,js,sizeBreakdowns,options.isSoycExtra() ? sourceInfoMaps : null,dependencies,jjsmap,obfuscateMap,unifiedAst.getModuleMetrics(),unifiedAst.getPrecompilationMetrics(),compilationMetrics,options.isSoycHtmlDisabled()));
}
if (isSourceMapsEnabled) {
if (options.isClosureCompilerEnabled()) {
logger.log(TreeLogger.WARN,""String_Node_Str"" + ""String_Node_Str"");
}
 else {
logger.log(TreeLogger.INFO,""String_Node_Str"");
toReturn.addArtifacts(SourceMapRecorder.makeSourceMapArtifacts(sourceInfoMaps,permutationId));
}
}
logTrackingStats(logger);
if (logger.isLoggable(TreeLogger.TRACE)) {
logger.log(TreeLogger.TRACE,""String_Node_Str"" + (System.currentTimeMillis() - permStart) + ""String_Node_Str"");
}
return toReturn;
}
 catch (Throwable e) {
throw CompilationProblemReporter.logAndTranslateException(logger,e);
}
 finally {
jjsCompilePermutationEvent.end();
}
}",0.9717098629974498
53585,"private boolean execImpl(JsBlock fragment){
  DuplicateFunctionBodyRecorder dfbr=new DuplicateFunctionBodyRecorder();
  dfbr.accept(fragment);
  int count=0;
  Map<JsFunction,JsName> hoistMap=new HashMap<JsFunction,JsName>();
  Map<JsFunction,JsFunction> dupMethodMap=dfbr.getDuplicateMethodMap();
  for (  JsFunction x : dupMethodMap.values()) {
    if (!hoistMap.containsKey(x)) {
      JsName newName=program.getScope().declareName(""String_Node_Str"" + count++);
      JsFunction newFunc=new JsFunction(x.getSourceInfo(),program.getScope(),newName,x.isFromJava());
      newFunc.setBody(x.getBody());
      newFunc.getParameters().addAll(x.getParameters());
      fragment.getStatements().add(newFunc.makeStmt());
      hoistMap.put(x,newName);
    }
  }
  ReplaceDuplicateInvocationNameRefs rdup=new ReplaceDuplicateInvocationNameRefs(dfbr.getDuplicateMap(),dfbr.getBlacklist(),dupMethodMap,hoistMap);
  rdup.accept(fragment);
  return rdup.didChange();
}","private boolean execImpl(){
  boolean changed=false;
  for (int i=0; i < program.getFragmentCount(); i++) {
    JsBlock fragment=program.getFragmentBlock(i);
    DuplicateFunctionBodyRecorder dfbr=new DuplicateFunctionBodyRecorder();
    dfbr.accept(fragment);
    Map<JsFunction,JsName> newNamesByHoistedFunction=new HashMap<JsFunction,JsName>();
    Map<JsFunction,JsFunction> dupMethodMap=dfbr.getDuplicateMethodMap();
    for (    JsFunction dupMethod : dupMethodMap.values()) {
      if (newNamesByHoistedFunction.containsKey(dupMethod)) {
        continue;
      }
      JsName newName=program.getScope().declareName(freshNameGenerator.getFreshName());
      JsFunction newFunc=new JsFunction(dupMethod.getSourceInfo(),program.getScope(),newName,dupMethod.isFromJava());
      newFunc.setBody(dupMethod.getBody());
      newFunc.getParameters().addAll(dupMethod.getParameters());
      fragment.getStatements().add(newFunc.makeStmt());
      newNamesByHoistedFunction.put(dupMethod,newName);
    }
    ReplaceDuplicateInvocationNameRefs rdup=new ReplaceDuplicateInvocationNameRefs(dfbr.getDuplicateMap(),dfbr.getBlacklist(),dupMethodMap,newNamesByHoistedFunction);
    rdup.accept(fragment);
    changed=changed || rdup.didChange();
  }
  if (changed) {
    JsUnusedFunctionRemover.exec(program);
  }
  return changed;
}",0.2600700525394046
53586,"public JsDuplicateFunctionRemover(JsProgram program){
  this.program=program;
}","public JsDuplicateFunctionRemover(JsProgram program,FreshNameGenerator freshNameGenerator){
  this.program=program;
  this.freshNameGenerator=freshNameGenerator;
}",0.6528925619834711
53587,"public static boolean exec(JsProgram program,JsBlock fragment){
  return new JsDuplicateFunctionRemover(program).execImpl(fragment);
}","/** 
 * Entry point for the removeDuplicateFunctions optimization. This optimization will collapse functions whose JavaScript (output) code is identical. After collapsing duplicate functions it will remove functions that become unreferenced as a result. This pass is safe only for JavaScript functions generated from Java where references to local function variables can not be extruded by returning a function. E,g. in the next example function f1() {return a;} funcion f2() { var a; return function() {return a;}} f1() and the return of f2() are not duplicates even though the have a syntacticaly identical parameters and body. The reason is that a in f1() refers to some globally scoped variable a, whereas a in the return of f2() refers to the local variable a. It would be not correct to move the return of f2() to the global scope. This situation does NOT arise from functions that where generated from Java sources (non native) IMPORTANT NOTE: It is NOT safe to rename JsNames after this pass is performed. E.g. Consider an output  JavaScript for two unrelated classes: defineSeed(...) //class A _.a _.m1 = function() { return this.a; } defineSeed(...) // class B _.a _.m2 = function() { return this.a; } Here m1() in class A and m2 in class B have identical parameters and bodies; hence the result will be defineSeed(...) //class A _.a _.m1 = g1 defineSeed(...) // class B _.a _.m2 = g1 function g1() { return this.a; } The reference to this.a in g1 will be to either A.a or B.a and as long as those names remain the same the removal was correct. However if A.a gets renamed then A.m1() and B.m2() would no longer have been identical hence the dedup that is already done is incorrect.
 * @param program the program to optimize
 * @param nameGenerator a freshNameGenerator to assign fresh names to deduped functions that arelifted to the global scope
 * @return {@code true} if it made any changes; {@code false} otherwise.
 */
public static boolean exec(JsProgram program,FreshNameGenerator nameGenerator){
  return new JsDuplicateFunctionRemover(program,nameGenerator).execImpl();
}",0.0782022471910112
53588,"@Override protected void visit(JsScope scope){
  int mySiblingsMaxId=maxChildId;
  maxChildId=0;
  for (  JsScope child : scope.getChildren()) {
    visit(child);
  }
  int curId=maxChildId;
  for (Iterator<JsName> it=scope.getAllNames(); it.hasNext(); ) {
    JsName name=it.next();
    if (!referenced.contains(name)) {
      continue;
    }
    if (!name.isObfuscatable()) {
      name.setShortIdent(name.getIdent());
      continue;
    }
    String newIdent;
    while (true) {
      newIdent=makeObfuscatedIdent(curId++);
      if (isLegal(scope,newIdent)) {
        break;
      }
    }
    name.setShortIdent(newIdent);
  }
  maxChildId=Math.max(mySiblingsMaxId,curId);
}","@Override protected void visit(JsScope scope){
  int mySiblingsMaxId=maxChildId;
  maxChildId=0;
  for (  JsScope child : scope.getChildren()) {
    visit(child);
  }
  int curId=maxChildId;
  for (Iterator<JsName> it=scope.getAllNames(); it.hasNext(); ) {
    JsName name=it.next();
    if (!referenced.contains(name)) {
      continue;
    }
    if (!name.isObfuscatable()) {
      name.setShortIdent(name.getIdent());
      continue;
    }
    String newIdent;
    while (true) {
      newIdent=makeObfuscatedIdent(curId++);
      if (isLegal(scope,newIdent)) {
        break;
      }
    }
    name.setShortIdent(newIdent);
  }
  maxChildId=Math.max(mySiblingsMaxId,curId);
  maxId=Math.max(maxId,maxChildId);
}",0.9741750358680056
53589,"public static void exec(JsProgram program,PropertyOracle[] propertyOracles){
  new JsObfuscateNamer(program,propertyOracles).execImpl();
}","public static FreshNameGenerator exec(JsProgram program,PropertyOracle[] propertyOracles){
  JsObfuscateNamer namer=new JsObfuscateNamer(program,propertyOracles);
  namer.execImpl();
  return namer;
}",0.7692307692307693
53590,"public static void exec(TreeLogger logger,JProgram jprogram,JsProgram jsprogram,JavaToJavaScriptMap map,int fragmentsToMerge,MultipleDependencyGraphRecorder dependencyRecorder,int leftOverMergeLimit){
  if (jprogram.getRunAsyncs().size() == 0) {
    return;
  }
  Event codeSplitterEvent=SpeedTracerLogger.start(CompilerEventType.CODE_SPLITTER);
  dependencyRecorder.open();
  new CodeSplitter2(logger,jprogram,jsprogram,map,fragmentsToMerge,dependencyRecorder,leftOverMergeLimit).execImpl();
  codeSplitterEvent.end();
}","public static void exec(TreeLogger logger,JProgram jprogram,JsProgram jsprogram,JavaToJavaScriptMap map,int fragmentsToMerge,MultipleDependencyGraphRecorder dependencyRecorder,int leftOverMergeLimit){
  if (jprogram.getRunAsyncs().size() == 0) {
    return;
  }
  Event codeSplitterEvent=SpeedTracerLogger.start(CompilerEventType.CODE_SPLITTER);
  dependencyRecorder.open();
  new CodeSplitter2(logger,jprogram,jsprogram,map,fragmentsToMerge,dependencyRecorder,leftOverMergeLimit).execImpl();
  dependencyRecorder.close();
  codeSplitterEvent.end();
}",0.9720149253731344
53591,"private CodeSplitter2(TreeLogger logger,JProgram jprogram,JsProgram jsprogram,JavaToJavaScriptMap map,int splitPointsMerge,MultipleDependencyGraphRecorder dependencyRecorder,int leftOverMergeLimit){
  this.jprogram=jprogram;
  this.jsprogram=jsprogram;
  this.splitPointsMerge=splitPointsMerge;
  this.leftOverMergeLimit=leftOverMergeLimit;
  this.fragmentExtractor=new FragmentExtractor(jprogram,jsprogram,map);
  this.initialLoadSequence=new LinkedHashSet<Integer>(jprogram.getSplitPointInitialSequence());
  this.splitPointToFragmentMap=new int[jprogram.getRunAsyncs().size() + 1];
  for (int i=0; i < splitPointToFragmentMap.length; i++) {
    splitPointToFragmentMap[i]=i;
  }
  this.splitPointToCodeIndexMap=new int[jprogram.getRunAsyncs().size() + 1];
  for (int i=0; i < splitPointToCodeIndexMap.length; i++) {
    splitPointToCodeIndexMap[i]=0;
  }
  fieldToLiteralOfClass=buildFieldToClassLiteralMap(jprogram);
  fragmentExtractor=new FragmentExtractor(jprogram,jsprogram,map);
  methodsInJavaScript=fragmentExtractor.findAllMethodsInJavaScript();
}","private CodeSplitter2(TreeLogger logger,JProgram jprogram,JsProgram jsprogram,JavaToJavaScriptMap map,int splitPointsMerge,MultipleDependencyGraphRecorder dependencyRecorder,int leftOverMergeLimit){
  this.jprogram=jprogram;
  this.jsprogram=jsprogram;
  this.splitPointsMerge=splitPointsMerge;
  this.leftOverMergeLimit=leftOverMergeLimit;
  this.dependencyRecorder=dependencyRecorder;
  this.fragmentExtractor=new FragmentExtractor(jprogram,jsprogram,map);
  this.initialLoadSequence=new LinkedHashSet<Integer>(jprogram.getSplitPointInitialSequence());
  this.splitPointToFragmentMap=new int[jprogram.getRunAsyncs().size() + 1];
  for (int i=0; i < splitPointToFragmentMap.length; i++) {
    splitPointToFragmentMap[i]=i;
  }
  this.splitPointToCodeIndexMap=new int[jprogram.getRunAsyncs().size() + 1];
  for (int i=0; i < splitPointToCodeIndexMap.length; i++) {
    splitPointToCodeIndexMap[i]=0;
  }
  fieldToLiteralOfClass=buildFieldToClassLiteralMap(jprogram);
  fragmentExtractor=new FragmentExtractor(jprogram,jsprogram,map);
  methodsInJavaScript=fragmentExtractor.findAllMethodsInJavaScript();
}",0.9787430683918668
53592,"public static void exec(TreeLogger logger,JProgram jprogram,JsProgram jsprogram,JavaToJavaScriptMap map,int fragmentsToMerge,MultipleDependencyGraphRecorder dependencyRecorder,int leftOverMergeLimit){
  if (jprogram.getRunAsyncs().size() == 0) {
    return;
  }
  Event codeSplitterEvent=SpeedTracerLogger.start(CompilerEventType.CODE_SPLITTER);
  new CodeSplitter2(logger,jprogram,jsprogram,map,fragmentsToMerge,dependencyRecorder,leftOverMergeLimit).execImpl();
  codeSplitterEvent.end();
}","public static void exec(TreeLogger logger,JProgram jprogram,JsProgram jsprogram,JavaToJavaScriptMap map,int fragmentsToMerge,MultipleDependencyGraphRecorder dependencyRecorder,int leftOverMergeLimit){
  if (jprogram.getRunAsyncs().size() == 0) {
    return;
  }
  Event codeSplitterEvent=SpeedTracerLogger.start(CompilerEventType.CODE_SPLITTER);
  dependencyRecorder.open();
  new CodeSplitter2(logger,jprogram,jsprogram,map,fragmentsToMerge,dependencyRecorder,leftOverMergeLimit).execImpl();
  codeSplitterEvent.end();
}",0.8371174728529122
53593,"/** 
 * Given the set of code initially live, and a set of splitpoints grouped into fragments: The core algorithm to compute exclusive merged fragments is as follows: For each fragment (grouping of merged splitpoint numbers) 1) compute the set of live statements of every splitpoint EXCEPT those in the fragment 2) compute the set of live statements reachable from those in the fragment 3) calculate a set difference of everything live minus the results of step 1 4) filter results by checking for membership in the results of step 2 5) assign resulting live code to this fragment (recorded in a map) The results of these steps are then used to extract individual JavaScript chunks into blocks corresponding to fragments which are ultimately written to disk.
 * @param initiallyLive the CFA of code live from the entry point (initial fragments)
 */
private void extractStatements(ControlFlowAnalyzer initiallyLive){
  Map<Integer,List<JsStatement>> fragmentStats=new LinkedHashMap<Integer,List<JsStatement>>();
{
    LivenessPredicate alreadyLoaded=new NothingAlivePredicate();
    LivenessPredicate liveNow=new CfaLivenessPredicate(initiallyLive);
    List<JsStatement> noStats=new ArrayList<JsStatement>();
    addFragment(0,alreadyLoaded,liveNow,noStats,fragmentStats);
  }
  ControlFlowAnalyzer liveAfterInitialSequence=new ControlFlowAnalyzer(initiallyLive);
  int cacheIndex=1;
{
    for (    final int sp : initialLoadSequence) {
      splitPointToCodeIndexMap[sp]=cacheIndex;
      LivenessPredicate alreadyLoaded=new CfaLivenessPredicate(liveAfterInitialSequence);
      ControlFlowAnalyzer liveAfterSp=new ControlFlowAnalyzer(liveAfterInitialSequence);
      JRunAsync runAsync=jprogram.getRunAsyncs().get(sp - 1);
      liveAfterSp.traverseFromRunAsync(runAsync);
      LivenessPredicate liveNow=new CfaLivenessPredicate(liveAfterSp);
      List<JsStatement> statsToAppend=fragmentExtractor.createOnLoadedCall(cacheIndex);
      addFragment(sp,alreadyLoaded,liveNow,statsToAppend,fragmentStats);
      liveAfterInitialSequence=liveAfterSp;
      cacheIndex++;
    }
  }
  ControlFlowAnalyzer everything=computeCompleteCfa();
  Set<JField> allFields=new HashSet<JField>();
  Set<JMethod> allMethods=new HashSet<JMethod>();
  for (  JNode node : everything.getLiveFieldsAndMethods()) {
    if (node instanceof JField) {
      allFields.add((JField)node);
    }
    if (node instanceof JMethod) {
      allMethods.add((JMethod)node);
    }
  }
  allFields.addAll(everything.getFieldsWritten());
  ArrayList<JsStatement> leftOverMergeStats=new ArrayList<JsStatement>();
  for (int i=1; i < splitPointToFragmentMap.length; i++) {
    ArrayList<Integer> splitPoints=new ArrayList<Integer>();
    if (splitPointToFragmentMap[i] != i) {
      continue;
    }
    if (initialLoadSequence.contains(i)) {
      continue;
    }
    splitPoints.add(i);
    splitPointToCodeIndexMap[i]=cacheIndex;
    for (int j=i + 1; j < splitPointToFragmentMap.length; j++) {
      if (initialLoadSequence.contains(j)) {
        continue;
      }
      if (splitPointToFragmentMap[j] == i) {
        splitPointToCodeIndexMap[j]=cacheIndex;
        splitPoints.add(j);
      }
    }
    ControlFlowAnalyzer allButOne=computeAllButNCfas(liveAfterInitialSequence,splitPoints);
    ControlFlowAnalyzer allFromSplitPoints=computeAllLiveFromSplitPoints(liveAfterInitialSequence,splitPoints);
    Set<JNode> allLiveNodes=union(allButOne.getLiveFieldsAndMethods(),allButOne.getFieldsWritten());
    Set<JNode> allLiveFromSplitPoints=union(allFromSplitPoints.getLiveFieldsAndMethods(),allFromSplitPoints.getFieldsWritten());
    updateReverseMap(i,fragmentMap.fields,allLiveNodes,allFields,allLiveFromSplitPoints);
    updateReverseMap(i,fragmentMap.methods,allButOne.getLiveFieldsAndMethods(),allMethods,allFromSplitPoints.getLiveFieldsAndMethods());
    updateReverseMap(i,fragmentMap.strings,allButOne.getLiveStrings(),everything.getLiveStrings(),allFromSplitPoints.getLiveStrings());
    updateReverseMap(i,fragmentMap.types,declaredTypesIn(allButOne.getInstantiatedTypes()),declaredTypesIn(everything.getInstantiatedTypes()),declaredTypesIn(allFromSplitPoints.getInstantiatedTypes()));
    if (splitPointToFragmentMap[i] != i) {
      continue;
    }
    if (initialLoadSequence.contains(i)) {
      continue;
    }
    LivenessPredicate alreadyLoaded=new ExclusivityMapLivenessPredicate(fragmentMap,0);
    LivenessPredicate liveNow=new ExclusivityMapLivenessPredicate(fragmentMap,i);
    List<JsStatement> exclusiveStats=fragmentExtractor.extractStatements(liveNow,alreadyLoaded);
    if (fragmentSizeBelowMergeLimit(exclusiveStats,leftOverMergeLimit)) {
      leftOverMergeStats.addAll(exclusiveStats);
      splitPointToFragmentMap[i]=-1;
      continue;
    }
 else {
      List<JsStatement> statsToAppend=fragmentExtractor.createOnLoadedCall(cacheIndex);
      addFragment(i,alreadyLoaded,liveNow,statsToAppend,fragmentStats);
    }
    cacheIndex++;
  }
  for (int i=0; i < splitPointToFragmentMap.length; i++) {
    if (splitPointToFragmentMap[i] == -1) {
      splitPointToFragmentMap[i]=splitPointToFragmentMap.length;
    }
  }
{
    LivenessPredicate alreadyLoaded=new CfaLivenessPredicate(liveAfterInitialSequence);
    LivenessPredicate liveNow=new ExclusivityMapLivenessPredicate(fragmentMap,0);
    List<JsStatement> statsToAppend=fragmentExtractor.createOnLoadedCall(cacheIndex);
    leftOverMergeStats.addAll(statsToAppend);
    addFragment(splitPointToFragmentMap.length,alreadyLoaded,liveNow,leftOverMergeStats,fragmentStats);
  }
  jsprogram.setFragmentCount(fragmentStats.size());
  int count=0;
  for (  int i : fragmentStats.keySet()) {
    JsBlock fragBlock=jsprogram.getFragmentBlock(count++);
    fragBlock.getStatements().clear();
    fragBlock.getStatements().addAll(fragmentStats.get(i));
  }
  jprogram.setFragmentPartitioningResult(new FragmentPartitioningResult(splitPointToCodeIndexMap,fragmentStats.size()));
}","/** 
 * Given the set of code initially live, and a set of splitpoints grouped into fragments: The core algorithm to compute exclusive merged fragments is as follows: For each fragment (grouping of merged splitpoint numbers) 1) compute the set of live statements of every splitpoint EXCEPT those in the fragment 2) compute the set of live statements reachable from those in the fragment 3) calculate a set difference of everything live minus the results of step 1 4) filter results by checking for membership in the results of step 2 5) assign resulting live code to this fragment (recorded in a map) The results of these steps are then used to extract individual JavaScript chunks into blocks corresponding to fragments which are ultimately written to disk.
 * @param initiallyLive the CFA of code live from the entry point (initial fragments)
 */
private void extractStatements(ControlFlowAnalyzer initiallyLive){
  Map<Integer,List<JsStatement>> fragmentStats=new LinkedHashMap<Integer,List<JsStatement>>();
{
    LivenessPredicate alreadyLoaded=new NothingAlivePredicate();
    LivenessPredicate liveNow=new CfaLivenessPredicate(initiallyLive);
    List<JsStatement> noStats=new ArrayList<JsStatement>();
    addFragment(0,alreadyLoaded,liveNow,noStats,fragmentStats);
  }
  ControlFlowAnalyzer liveAfterInitialSequence=new ControlFlowAnalyzer(initiallyLive);
  String extendsCfa=""String_Node_Str"";
  int cacheIndex=1;
{
    for (    final int sp : initialLoadSequence) {
      splitPointToCodeIndexMap[sp]=cacheIndex;
      String depGraphName=""String_Node_Str"" + cacheIndex;
      dependencyRecorder.startDependencyGraph(depGraphName,extendsCfa);
      extendsCfa=depGraphName;
      LivenessPredicate alreadyLoaded=new CfaLivenessPredicate(liveAfterInitialSequence);
      ControlFlowAnalyzer liveAfterSp=new ControlFlowAnalyzer(liveAfterInitialSequence);
      JRunAsync runAsync=jprogram.getRunAsyncs().get(sp - 1);
      liveAfterSp.setDependencyRecorder(dependencyRecorder);
      liveAfterSp.traverseFromRunAsync(runAsync);
      dependencyRecorder.endDependencyGraph();
      LivenessPredicate liveNow=new CfaLivenessPredicate(liveAfterSp);
      List<JsStatement> statsToAppend=fragmentExtractor.createOnLoadedCall(cacheIndex);
      addFragment(sp,alreadyLoaded,liveNow,statsToAppend,fragmentStats);
      liveAfterInitialSequence=liveAfterSp;
      cacheIndex++;
    }
  }
  ControlFlowAnalyzer everything=computeCompleteCfa();
  Set<JField> allFields=new HashSet<JField>();
  Set<JMethod> allMethods=new HashSet<JMethod>();
  for (  JNode node : everything.getLiveFieldsAndMethods()) {
    if (node instanceof JField) {
      allFields.add((JField)node);
    }
    if (node instanceof JMethod) {
      allMethods.add((JMethod)node);
    }
  }
  allFields.addAll(everything.getFieldsWritten());
  ArrayList<JsStatement> leftOverMergeStats=new ArrayList<JsStatement>();
  for (int i=1; i < splitPointToFragmentMap.length; i++) {
    ArrayList<Integer> splitPoints=new ArrayList<Integer>();
    if (splitPointToFragmentMap[i] != i) {
      continue;
    }
    if (initialLoadSequence.contains(i)) {
      continue;
    }
    splitPoints.add(i);
    splitPointToCodeIndexMap[i]=cacheIndex;
    for (int j=i + 1; j < splitPointToFragmentMap.length; j++) {
      if (initialLoadSequence.contains(j)) {
        continue;
      }
      if (splitPointToFragmentMap[j] == i) {
        splitPointToCodeIndexMap[j]=cacheIndex;
        splitPoints.add(j);
      }
    }
    dependencyRecorder.startDependencyGraph(""String_Node_Str"" + cacheIndex,extendsCfa);
    ControlFlowAnalyzer allButOne=computeAllButNCfas(liveAfterInitialSequence,splitPoints,dependencyRecorder);
    dependencyRecorder.endDependencyGraph();
    ControlFlowAnalyzer allFromSplitPoints=computeAllLiveFromSplitPoints(liveAfterInitialSequence,splitPoints);
    Set<JNode> allLiveNodes=union(allButOne.getLiveFieldsAndMethods(),allButOne.getFieldsWritten());
    Set<JNode> allLiveFromSplitPoints=union(allFromSplitPoints.getLiveFieldsAndMethods(),allFromSplitPoints.getFieldsWritten());
    updateReverseMap(i,fragmentMap.fields,allLiveNodes,allFields,allLiveFromSplitPoints);
    updateReverseMap(i,fragmentMap.methods,allButOne.getLiveFieldsAndMethods(),allMethods,allFromSplitPoints.getLiveFieldsAndMethods());
    updateReverseMap(i,fragmentMap.strings,allButOne.getLiveStrings(),everything.getLiveStrings(),allFromSplitPoints.getLiveStrings());
    updateReverseMap(i,fragmentMap.types,declaredTypesIn(allButOne.getInstantiatedTypes()),declaredTypesIn(everything.getInstantiatedTypes()),declaredTypesIn(allFromSplitPoints.getInstantiatedTypes()));
    if (splitPointToFragmentMap[i] != i) {
      continue;
    }
    if (initialLoadSequence.contains(i)) {
      continue;
    }
    LivenessPredicate alreadyLoaded=new ExclusivityMapLivenessPredicate(fragmentMap,0);
    LivenessPredicate liveNow=new ExclusivityMapLivenessPredicate(fragmentMap,i);
    List<JsStatement> exclusiveStats=fragmentExtractor.extractStatements(liveNow,alreadyLoaded);
    if (fragmentSizeBelowMergeLimit(exclusiveStats,leftOverMergeLimit)) {
      leftOverMergeStats.addAll(exclusiveStats);
      splitPointToFragmentMap[i]=-1;
      continue;
    }
 else {
      List<JsStatement> statsToAppend=fragmentExtractor.createOnLoadedCall(cacheIndex);
      addFragment(i,alreadyLoaded,liveNow,statsToAppend,fragmentStats);
    }
    cacheIndex++;
  }
  for (int i=0; i < splitPointToFragmentMap.length; i++) {
    if (splitPointToFragmentMap[i] == -1) {
      splitPointToFragmentMap[i]=splitPointToFragmentMap.length;
    }
  }
{
    LivenessPredicate alreadyLoaded=new CfaLivenessPredicate(liveAfterInitialSequence);
    LivenessPredicate liveNow=new ExclusivityMapLivenessPredicate(fragmentMap,0);
    List<JsStatement> statsToAppend=fragmentExtractor.createOnLoadedCall(cacheIndex);
    leftOverMergeStats.addAll(statsToAppend);
    addFragment(splitPointToFragmentMap.length,alreadyLoaded,liveNow,leftOverMergeStats,fragmentStats);
  }
  jsprogram.setFragmentCount(fragmentStats.size());
  int count=0;
  for (  int i : fragmentStats.keySet()) {
    JsBlock fragBlock=jsprogram.getFragmentBlock(count++);
    fragBlock.getStatements().clear();
    fragBlock.getStatements().addAll(fragmentStats.get(i));
  }
  jprogram.setFragmentPartitioningResult(new FragmentPartitioningResult(splitPointToCodeIndexMap,fragmentStats.size()));
}",0.9626320064987814
53594,"/** 
 * Compute a CFA that covers the entire live code of the program.
 */
private ControlFlowAnalyzer computeCompleteCfa(){
  ControlFlowAnalyzer everything=new ControlFlowAnalyzer(jprogram);
  everything.traverseEverything();
  return everything;
}","/** 
 * Compute a CFA that covers the entire live code of the program.
 */
private ControlFlowAnalyzer computeCompleteCfa(){
  dependencyRecorder.startDependencyGraph(""String_Node_Str"",null);
  ControlFlowAnalyzer everything=new ControlFlowAnalyzer(jprogram);
  everything.setDependencyRecorder(dependencyRecorder);
  everything.traverseEverything();
  dependencyRecorder.endDependencyGraph();
  return everything;
}",0.7327327327327328
53595,"/** 
 * This is the high level algorithm of the pass.
 */
private void execImpl(){
  initiallyLive=computeInitiallyLive(jprogram,CodeSplitter.NULL_RECORDER);
  recordLiveSet(initiallyLive,liveness,0);
  for (  JRunAsync runAsync : jprogram.getRunAsyncs()) {
    if (initialLoadSequence.contains(runAsync.getSplitPoint())) {
      initiallyLive=computeLiveSet(initiallyLive,liveness,runAsync);
    }
  }
  for (  JRunAsync runAsync : jprogram.getRunAsyncs()) {
    if (!initialLoadSequence.contains(runAsync.getSplitPoint())) {
      computeLiveSet(initiallyLive,liveness,runAsync);
    }
  }
  fixUpLoadOrderDependencies(liveness,-1);
  partitionFragments();
  extractStatements(computeInitiallyLive(jprogram,CodeSplitter.NULL_RECORDER));
  replaceFragmentId();
}","/** 
 * This is the high level algorithm of the pass.
 */
private void execImpl(){
  initiallyLive=computeInitiallyLive(jprogram,CodeSplitter.NULL_RECORDER);
  recordLiveSet(initiallyLive,liveness,0);
  for (  JRunAsync runAsync : jprogram.getRunAsyncs()) {
    if (initialLoadSequence.contains(runAsync.getSplitPoint())) {
      initiallyLive=computeLiveSet(initiallyLive,liveness,runAsync);
    }
  }
  for (  JRunAsync runAsync : jprogram.getRunAsyncs()) {
    if (!initialLoadSequence.contains(runAsync.getSplitPoint())) {
      computeLiveSet(initiallyLive,liveness,runAsync);
    }
  }
  fixUpLoadOrderDependencies(liveness,-1);
  partitionFragments();
  extractStatements(computeInitiallyLive(jprogram,dependencyRecorder));
  replaceFragmentId();
}",0.9723320158102768
53596,"private ControlFlowAnalyzer computeAllButNCfas(ControlFlowAnalyzer liveAfterInitialSequence,List<Integer> sp){
  List<ControlFlowAnalyzer> allButOnes=new ArrayList<ControlFlowAnalyzer>();
  ControlFlowAnalyzer cfa=new ControlFlowAnalyzer(liveAfterInitialSequence);
  for (  JRunAsync otherRunAsync : jprogram.getRunAsyncs()) {
    if (isInitial(otherRunAsync.getSplitPoint())) {
      continue;
    }
    if (sp.contains(otherRunAsync.getSplitPoint())) {
      continue;
    }
    cfa.traverseFromRunAsync(otherRunAsync);
  }
  return cfa;
}","private ControlFlowAnalyzer computeAllButNCfas(ControlFlowAnalyzer liveAfterInitialSequence,List<Integer> sp,ControlFlowAnalyzer.DependencyRecorder dependencyRecorder){
  List<ControlFlowAnalyzer> allButOnes=new ArrayList<ControlFlowAnalyzer>();
  ControlFlowAnalyzer cfa=new ControlFlowAnalyzer(liveAfterInitialSequence);
  cfa.setDependencyRecorder(dependencyRecorder);
  for (  JRunAsync otherRunAsync : jprogram.getRunAsyncs()) {
    if (isInitial(otherRunAsync.getSplitPoint())) {
      continue;
    }
    if (sp.contains(otherRunAsync.getSplitPoint())) {
      continue;
    }
    cfa.traverseFromRunAsync(otherRunAsync);
  }
  return cfa;
}",0.910008410428932
53597,"private FragmentPartitioningResult(int[] splitPointToFragmentMap,int numFragments){
  this.splitPointToFragmentMap=splitPointToFragmentMap;
  fragmentToSplitPoint=new int[numFragments];
  for (int i=0, len=splitPointToFragmentMap.length - 1; i < len; i++) {
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ splitPointToFragmentMap[i]);
  }
  for (int i=1, len=splitPointToFragmentMap.length - 1; i < len; i++) {
    if (fragmentToSplitPoint[splitPointToFragmentMap[i]] == 0) {
      fragmentToSplitPoint[splitPointToFragmentMap[i]]=i;
    }
 else {
      fragmentToSplitPoint[splitPointToFragmentMap[i]]=-1;
    }
  }
}","private FragmentPartitioningResult(int[] splitPointToFragmentMap,int numFragments){
  this.splitPointToFragmentMap=splitPointToFragmentMap;
  fragmentToSplitPoint=new int[numFragments];
  for (int i=1, len=splitPointToFragmentMap.length - 1; i < len; i++) {
    if (fragmentToSplitPoint[splitPointToFragmentMap[i]] == 0) {
      fragmentToSplitPoint[splitPointToFragmentMap[i]]=i;
    }
 else {
      fragmentToSplitPoint[splitPointToFragmentMap[i]]=-1;
    }
  }
}",0.8428701180744778
53598,"/** 
 * Compiles a Java class <code>test.EntryPoint</code> and use the code splitter on it with leftover merge enabled.
 */
protected void compileSnippetWithLeftoverMerge(final String code,int mergeLimit) throws UnableToCompleteException {
  addMockIntrinsic();
  sourceOracle.addOrReplace(new MockJavaResource(""String_Node_Str""){
    @Override public CharSequence getContent(){
      return code;
    }
  }
);
  addBuiltinClasses(sourceOracle);
  CompilationState state=CompilationStateBuilder.buildFrom(logger,sourceOracle.getResources(),getAdditionalTypeProviderDelegate(),sourceLevel);
  jProgram=JavaAstConstructor.construct(logger,state,""String_Node_Str"",""String_Node_Str"");
  jProgram.addEntryMethod(findMethod(jProgram,""String_Node_Str""));
  CastNormalizer.exec(jProgram,false);
  ArrayNormalizer.exec(jProgram);
  Map<StandardSymbolData,JsName> symbolTable=new TreeMap<StandardSymbolData,JsName>(new SymbolData.ClassIdentComparator());
  JavaToJavaScriptMap map=GenerateJavaScriptAST.exec(jProgram,jsProgram,JsOutputOption.PRETTY,symbolTable,new PropertyOracle[]{new StaticPropertyOracle(orderedProps,orderedPropValues,configProps)}).getLeft();
  CodeSplitter2.exec(logger,jProgram,jsProgram,map,4,null,mergeLimit);
}","/** 
 * Compiles a Java class <code>test.EntryPoint</code> and use the code splitter on it with leftover merge enabled.
 */
protected void compileSnippetWithLeftoverMerge(final String code,int mergeLimit) throws UnableToCompleteException {
  addMockIntrinsic();
  sourceOracle.addOrReplace(new MockJavaResource(""String_Node_Str""){
    @Override public CharSequence getContent(){
      return code;
    }
  }
);
  addBuiltinClasses(sourceOracle);
  CompilationState state=CompilationStateBuilder.buildFrom(logger,sourceOracle.getResources(),getAdditionalTypeProviderDelegate(),sourceLevel);
  jProgram=JavaAstConstructor.construct(logger,state,""String_Node_Str"",""String_Node_Str"");
  jProgram.addEntryMethod(findMethod(jProgram,""String_Node_Str""));
  CastNormalizer.exec(jProgram,false);
  ArrayNormalizer.exec(jProgram);
  Map<StandardSymbolData,JsName> symbolTable=new TreeMap<StandardSymbolData,JsName>(new SymbolData.ClassIdentComparator());
  JavaToJavaScriptMap map=GenerateJavaScriptAST.exec(jProgram,jsProgram,JsOutputOption.PRETTY,symbolTable,new PropertyOracle[]{new StaticPropertyOracle(orderedProps,orderedPropValues,configProps)}).getLeft();
  CodeSplitter2.exec(logger,jProgram,jsProgram,map,4,NULL_RECORDER,mergeLimit);
}",0.988216172287688
53599,"/** 
 * Compiles a Java class <code>test.EntryPoint</code> and use the code splitter on it.
 */
protected void compileSnippet(final String code) throws UnableToCompleteException {
  addMockIntrinsic();
  sourceOracle.addOrReplace(new MockJavaResource(""String_Node_Str""){
    @Override public CharSequence getContent(){
      return code;
    }
  }
);
  addBuiltinClasses(sourceOracle);
  CompilationState state=CompilationStateBuilder.buildFrom(logger,sourceOracle.getResources(),getAdditionalTypeProviderDelegate(),sourceLevel);
  jProgram=JavaAstConstructor.construct(logger,state,""String_Node_Str"",""String_Node_Str"");
  jProgram.addEntryMethod(findMethod(jProgram,""String_Node_Str""));
  CastNormalizer.exec(jProgram,false);
  ArrayNormalizer.exec(jProgram);
  Map<StandardSymbolData,JsName> symbolTable=new TreeMap<StandardSymbolData,JsName>(new SymbolData.ClassIdentComparator());
  JavaToJavaScriptMap map=GenerateJavaScriptAST.exec(jProgram,jsProgram,JsOutputOption.PRETTY,symbolTable,new PropertyOracle[]{new StaticPropertyOracle(orderedProps,orderedPropValues,configProps)}).getLeft();
  CodeSplitter2.exec(logger,jProgram,jsProgram,map,4,null,0);
}","/** 
 * Compiles a Java class <code>test.EntryPoint</code> and use the code splitter on it.
 */
protected void compileSnippet(final String code) throws UnableToCompleteException {
  addMockIntrinsic();
  sourceOracle.addOrReplace(new MockJavaResource(""String_Node_Str""){
    @Override public CharSequence getContent(){
      return code;
    }
  }
);
  addBuiltinClasses(sourceOracle);
  CompilationState state=CompilationStateBuilder.buildFrom(logger,sourceOracle.getResources(),getAdditionalTypeProviderDelegate(),sourceLevel);
  jProgram=JavaAstConstructor.construct(logger,state,""String_Node_Str"",""String_Node_Str"");
  jProgram.addEntryMethod(findMethod(jProgram,""String_Node_Str""));
  CastNormalizer.exec(jProgram,false);
  ArrayNormalizer.exec(jProgram);
  Map<StandardSymbolData,JsName> symbolTable=new TreeMap<StandardSymbolData,JsName>(new SymbolData.ClassIdentComparator());
  JavaToJavaScriptMap map=GenerateJavaScriptAST.exec(jProgram,jsProgram,JsOutputOption.PRETTY,symbolTable,new PropertyOracle[]{new StaticPropertyOracle(orderedProps,orderedPropValues,configProps)}).getLeft();
  CodeSplitter2.exec(logger,jProgram,jsProgram,map,4,NULL_RECORDER,0);
}",0.9926818768833404
53600,"/** 
 * Compiles source using the JDT. The   {@link UnitProcessor#process} callback method will be calledonce for each compiled file. If the compiler aborts, logs a message and throws UnableToCompleteException.
 */
public void doCompile(TreeLogger logger,Collection<CompilationUnitBuilder> builders) throws UnableToCompleteException {
  if (builders.isEmpty()) {
    return;
  }
  List<ICompilationUnit> icus=new ArrayList<ICompilationUnit>();
  for (  CompilationUnitBuilder builder : builders) {
    addPackages(Shared.getPackageName(builder.getTypeName()).replace('.','/'));
    icus.add(new Adapter(builder));
  }
  compilerImpl=new CompilerImpl();
  try {
    compilerImpl.compile(icus.toArray(new ICompilationUnit[icus.size()]));
  }
 catch (  AbortCompilation e) {
    String filename=new String(e.problem.getOriginatingFileName());
    TreeLogger branch=logger.branch(TreeLogger.Type.ERROR,""String_Node_Str"" + filename + ""String_Node_Str""+ e.problem.getSourceLineNumber());
    branch.log(TreeLogger.Type.ERROR,""String_Node_Str"" + e.problem.getMessage());
    throw new UnableToCompleteException();
  }
 finally {
    compilerImpl=null;
  }
}","/** 
 * Compiles source using the JDT. The   {@link UnitProcessor#process} callback method will be calledonce for each compiled file. If the compiler aborts, logs a message and throws UnableToCompleteException.
 */
public void doCompile(TreeLogger logger,Collection<CompilationUnitBuilder> builders) throws UnableToCompleteException {
  if (builders.isEmpty()) {
    return;
  }
  List<ICompilationUnit> icus=new ArrayList<ICompilationUnit>();
  for (  CompilationUnitBuilder builder : builders) {
    addPackages(Shared.getPackageName(builder.getTypeName()).replace('.','/'));
    icus.add(new Adapter(builder));
  }
  compilerImpl=new CompilerImpl();
  try {
    compilerImpl.compile(icus.toArray(new ICompilationUnit[icus.size()]));
  }
 catch (  AbortCompilation e) {
    if (e.problem.getOriginatingFileName() != null) {
      String filename=new String(e.problem.getOriginatingFileName());
      TreeLogger branch=logger.branch(TreeLogger.Type.ERROR,""String_Node_Str"" + filename + ""String_Node_Str""+ e.problem.getSourceLineNumber());
      branch.log(TreeLogger.Type.ERROR,""String_Node_Str"" + e.problem.getMessage());
    }
 else {
      logger.log(TreeLogger.Type.ERROR,""String_Node_Str"" + e.problem.getMessage());
    }
    throw new UnableToCompleteException();
  }
 finally {
    compilerImpl=null;
  }
}",0.9334415584415584
53601,"/** 
 * @skip This function contains common logic for parsing a String in a given radix and validating the result.
 */
protected static int __parseAndValidateInt(String s,int radix,int lowerBound,int upperBound) throws NumberFormatException {
  if (s == null) {
    throw new NumberFormatException(""String_Node_Str"");
  }
  if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX) {
    throw new NumberFormatException(""String_Node_Str"" + radix + ""String_Node_Str"");
  }
  int length=s.length();
  int startIndex=(length > 0) && (s.charAt(0) == '-') ? 1 : 0;
  for (int i=startIndex; i < length; i++) {
    if (Character.digit(s.charAt(i),radix) == -1) {
      throw NumberFormatException.forInputString(s);
    }
  }
  int toReturn=__parseInt(s,radix);
  if (__isNaN(toReturn)) {
    throw NumberFormatException.forInputString(s);
  }
 else   if (toReturn < lowerBound || toReturn > upperBound) {
    throw NumberFormatException.forInputString(s);
  }
  return toReturn;
}","/** 
 * @skip This function contains common logic for parsing a String in a given radix and validating the result.
 */
protected static int __parseAndValidateInt(String s,int radix,int lowerBound,int upperBound) throws NumberFormatException {
  if (s == null) {
    throw new NumberFormatException(""String_Node_Str"");
  }
  if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX) {
    throw new NumberFormatException(""String_Node_Str"" + radix + ""String_Node_Str"");
  }
  int length=s.length();
  int startIndex=(length > 0) && (s.charAt(0) == '-') ? 1 : 0;
  for (int i=startIndex; i < length; i++) {
    if (Character.digit(s.charAt(i),radix) == -1) {
      throw NumberFormatException.forInputString(s);
    }
  }
  int toReturn=__parseInt(s,radix);
  boolean isTooLow=toReturn < lowerBound;
  if (__isNaN(toReturn)) {
    throw NumberFormatException.forInputString(s);
  }
 else   if (isTooLow || toReturn > upperBound) {
    throw NumberFormatException.forInputString(s);
  }
  return toReturn;
}",0.9643036701860233
53602,"public void testValueOf(){
  assertEquals(new Integer(12345),Integer.valueOf(""String_Node_Str""));
  assertEquals(new Integer(1865),Integer.valueOf(""String_Node_Str"",6));
  assertEquals(12345,Integer.parseInt(""String_Node_Str""));
  assertEquals(1865,Integer.parseInt(""String_Node_Str"",6));
}","public void testValueOf(){
  assertEquals(new Integer(12345),Integer.valueOf(""String_Node_Str""));
  assertEquals(new Integer(1865),Integer.valueOf(""String_Node_Str"",6));
}",0.7418655097613883
53603,"/** 
 * Construct an simple AST representing an entire   {@link CompilationState}. Does not support deferred binding. Implementation mostly copied from  {@link JavaToJavaScriptCompiler}.
 */
public static JProgram construct(TreeLogger logger,final CompilationState state,JJSOptions options) throws UnableToCompleteException {
  InternalCompilerException.preload();
  RebindPermutationOracle rpo=new RebindPermutationOracle(){
    @Override public void clear(){
    }
    @Override public String[] getAllPossibleRebindAnswers(    TreeLogger logger,    String sourceTypeName) throws UnableToCompleteException {
      return new String[0];
    }
    public CompilationState getCompilationState(){
      return state;
    }
    public StandardGeneratorContext getGeneratorContext(){
      return null;
    }
  }
;
  JProgram jprogram=new JProgram();
  JsProgram jsProgram=new JsProgram();
  UnifyAst unifyAst=new UnifyAst(jprogram,jsProgram,options,rpo);
  unifyAst.buildEverything(logger);
  jprogram.typeOracle.computeBeforeAST();
  FixAssignmentToUnbox.exec(jprogram);
  if (options.isEnableAssertions()) {
    AssertionNormalizer.exec(jprogram);
  }
 else {
    AssertionRemover.exec(jprogram);
  }
  if (options.isRunAsyncEnabled()) {
    ReplaceRunAsyncs.exec(logger,jprogram);
  }
  ImplementClassLiteralsAsFields.exec(jprogram);
  return jprogram;
}","/** 
 * Construct an simple AST representing an entire   {@link CompilationState}. Does not support deferred binding. Implementation mostly copied from  {@link JavaToJavaScriptCompiler}.
 */
public static JProgram construct(TreeLogger logger,final CompilationState state,JJSOptions options) throws UnableToCompleteException {
  InternalCompilerException.preload();
  RebindPermutationOracle rpo=new RebindPermutationOracle(){
    @Override public void clear(){
    }
    @Override public String[] getAllPossibleRebindAnswers(    TreeLogger logger,    String sourceTypeName) throws UnableToCompleteException {
      return new String[0];
    }
    public CompilationState getCompilationState(){
      return state;
    }
    public StandardGeneratorContext getGeneratorContext(){
      return null;
    }
  }
;
  JProgram jprogram=new JProgram();
  JsProgram jsProgram=new JsProgram();
  UnifyAst unifyAst=new UnifyAst(logger,jprogram,jsProgram,options,rpo);
  unifyAst.buildEverything();
  jprogram.typeOracle.computeBeforeAST();
  FixAssignmentToUnbox.exec(jprogram);
  if (options.isEnableAssertions()) {
    AssertionNormalizer.exec(jprogram);
  }
 else {
    AssertionRemover.exec(jprogram);
  }
  if (options.isRunAsyncEnabled()) {
    ReplaceRunAsyncs.exec(logger,jprogram);
  }
  ImplementClassLiteralsAsFields.exec(jprogram);
  return jprogram;
}",0.9892870336165496
53604,"/** 
 * Performs a precompilation, returning a unified AST.
 * @param logger the logger to use
 * @param module the module to compile
 * @param rpo the RebindPermutationOracle
 * @param declEntryPts the set of entry classes declared in a GWT module;these will be automatically rebound
 * @param additionalRootTypes additional classes that should serve as coderoots; will not be rebound; may be <code>null</code>
 * @param options the compiler options
 * @param singlePermutation if true, do not pre-optimize the resulting AST orallow serialization of the result
 * @param precompilationMetrics if not null, gather diagnostic informationfrom this build for a report.
 * @return the unified AST used to drive permutation compiles
 * @throws UnableToCompleteException if an error other than{@link OutOfMemoryError} occurs
 */
public static UnifiedAst precompile(TreeLogger logger,ModuleDef module,RebindPermutationOracle rpo,String[] declEntryPts,String[] additionalRootTypes,JJSOptions options,boolean singlePermutation,PrecompilationMetricsArtifact precompilationMetrics) throws UnableToCompleteException {
  InternalCompilerException.preload();
  if (additionalRootTypes == null) {
    additionalRootTypes=Empty.STRINGS;
  }
  if (declEntryPts.length + additionalRootTypes.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Set<String> allRootTypes=new TreeSet<String>();
  for (  String element : declEntryPts) {
    String[] all=rpo.getAllPossibleRebindAnswers(logger,element);
    Collections.addAll(allRootTypes,all);
  }
  rpo.getGeneratorContext().finish(logger);
  Collections.addAll(allRootTypes,additionalRootTypes);
  allRootTypes.addAll(JProgram.CODEGEN_TYPES_SET);
  allRootTypes.addAll(JProgram.INDEX_TYPES_SET);
  TypeOracle typeOracle=rpo.getCompilationState().getTypeOracle();
  for (  com.google.gwt.core.ext.typeinfo.JClassType singleJsoIntf : typeOracle.getSingleJsoImplInterfaces()) {
    allRootTypes.add(typeOracle.getSingleJsoImpl(singleJsoIntf).getQualifiedSourceName());
  }
  Memory.maybeDumpMemory(""String_Node_Str"");
  JProgram jprogram=new JProgram();
  JsProgram jsProgram=new JsProgram();
  try {
    UnifyAst unifyAst=new UnifyAst(jprogram,jsProgram,options,rpo);
    unifyAst.addRootTypes(allRootTypes);
    findEntryPoints(logger,rpo,declEntryPts,jprogram);
    unifyAst.exec(logger);
    List<String> finalTypeOracleTypes=Lists.create();
    if (precompilationMetrics != null) {
      for (      com.google.gwt.core.ext.typeinfo.JClassType type : typeOracle.getTypes()) {
        finalTypeOracleTypes=Lists.add(finalTypeOracleTypes,type.getPackage().getName() + ""String_Node_Str"" + type.getName());
      }
      precompilationMetrics.setFinalTypeOracleTypes(finalTypeOracleTypes);
    }
    rpo.clear();
    if (options.isSoycEnabled()) {
      SourceInfoCorrelator.exec(jprogram);
    }
    jprogram.typeOracle.computeBeforeAST();
    Memory.maybeDumpMemory(""String_Node_Str"");
    AstDumper.maybeDumpAST(jprogram);
    if (module != null) {
      ConfigurationProperty enumNameObfuscationProp=(ConfigurationProperty)module.getProperties().find(ENUM_NAME_OBFUSCATION_PROPERTY);
      if (enumNameObfuscationProp != null && Boolean.parseBoolean(enumNameObfuscationProp.getValue())) {
        EnumNameObfuscator.exec(jprogram,logger);
      }
    }
    FixAssignmentToUnbox.exec(jprogram);
    if (options.isEnableAssertions()) {
      AssertionNormalizer.exec(jprogram);
    }
 else {
      AssertionRemover.exec(jprogram);
    }
    if (module != null && options.isRunAsyncEnabled()) {
      ReplaceRunAsyncs.exec(logger,jprogram);
      CodeSplitter2.pickInitialLoadSequence(logger,jprogram,module.getProperties());
    }
    ImplementClassLiteralsAsFields.exec(jprogram);
    if (options.getOptimizationLevel() > OptionOptimize.OPTIMIZE_LEVEL_DRAFT && !singlePermutation) {
      if (options.isOptimizePrecompile()) {
        optimize(options,jprogram);
      }
 else {
        optimizeLoop(""String_Node_Str"",jprogram,false);
      }
    }
    Set<String> rebindRequests=new HashSet<String>();
    RecordRebinds.exec(jprogram,rebindRequests);
    if (options.isCompilerMetricsEnabled()) {
      precompilationMetrics.setAstTypes(getReferencedJavaClasses(jprogram));
    }
    logTrackingStats(logger);
    Event createUnifiedAstEvent=SpeedTracerLogger.start(CompilerEventType.CREATE_UNIFIED_AST);
    UnifiedAst result=new UnifiedAst(options,new AST(jprogram,jsProgram),singlePermutation,rebindRequests);
    createUnifiedAstEvent.end();
    return result;
  }
 catch (  Throwable e) {
    throw CompilationProblemReporter.logAndTranslateException(logger,e);
  }
 finally {
  }
}","/** 
 * Performs a precompilation, returning a unified AST.
 * @param logger the logger to use
 * @param module the module to compile
 * @param rpo the RebindPermutationOracle
 * @param declEntryPts the set of entry classes declared in a GWT module;these will be automatically rebound
 * @param additionalRootTypes additional classes that should serve as coderoots; will not be rebound; may be <code>null</code>
 * @param options the compiler options
 * @param singlePermutation if true, do not pre-optimize the resulting AST orallow serialization of the result
 * @param precompilationMetrics if not null, gather diagnostic informationfrom this build for a report.
 * @return the unified AST used to drive permutation compiles
 * @throws UnableToCompleteException if an error other than{@link OutOfMemoryError} occurs
 */
public static UnifiedAst precompile(TreeLogger logger,ModuleDef module,RebindPermutationOracle rpo,String[] declEntryPts,String[] additionalRootTypes,JJSOptions options,boolean singlePermutation,PrecompilationMetricsArtifact precompilationMetrics) throws UnableToCompleteException {
  InternalCompilerException.preload();
  if (additionalRootTypes == null) {
    additionalRootTypes=Empty.STRINGS;
  }
  if (declEntryPts.length + additionalRootTypes.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Set<String> allRootTypes=new TreeSet<String>();
  for (  String element : declEntryPts) {
    String[] all=rpo.getAllPossibleRebindAnswers(logger,element);
    Collections.addAll(allRootTypes,all);
  }
  rpo.getGeneratorContext().finish(logger);
  Collections.addAll(allRootTypes,additionalRootTypes);
  allRootTypes.addAll(JProgram.CODEGEN_TYPES_SET);
  allRootTypes.addAll(JProgram.INDEX_TYPES_SET);
  TypeOracle typeOracle=rpo.getCompilationState().getTypeOracle();
  for (  com.google.gwt.core.ext.typeinfo.JClassType singleJsoIntf : typeOracle.getSingleJsoImplInterfaces()) {
    allRootTypes.add(typeOracle.getSingleJsoImpl(singleJsoIntf).getQualifiedSourceName());
  }
  Memory.maybeDumpMemory(""String_Node_Str"");
  JProgram jprogram=new JProgram();
  JsProgram jsProgram=new JsProgram();
  try {
    UnifyAst unifyAst=new UnifyAst(logger,jprogram,jsProgram,options,rpo);
    unifyAst.addRootTypes(allRootTypes);
    findEntryPoints(logger,rpo,declEntryPts,jprogram);
    unifyAst.exec();
    List<String> finalTypeOracleTypes=Lists.create();
    if (precompilationMetrics != null) {
      for (      com.google.gwt.core.ext.typeinfo.JClassType type : typeOracle.getTypes()) {
        finalTypeOracleTypes=Lists.add(finalTypeOracleTypes,type.getPackage().getName() + ""String_Node_Str"" + type.getName());
      }
      precompilationMetrics.setFinalTypeOracleTypes(finalTypeOracleTypes);
    }
    rpo.clear();
    if (options.isSoycEnabled()) {
      SourceInfoCorrelator.exec(jprogram);
    }
    jprogram.typeOracle.computeBeforeAST();
    Memory.maybeDumpMemory(""String_Node_Str"");
    AstDumper.maybeDumpAST(jprogram);
    if (module != null) {
      ConfigurationProperty enumNameObfuscationProp=(ConfigurationProperty)module.getProperties().find(ENUM_NAME_OBFUSCATION_PROPERTY);
      if (enumNameObfuscationProp != null && Boolean.parseBoolean(enumNameObfuscationProp.getValue())) {
        EnumNameObfuscator.exec(jprogram,logger);
      }
    }
    FixAssignmentToUnbox.exec(jprogram);
    if (options.isEnableAssertions()) {
      AssertionNormalizer.exec(jprogram);
    }
 else {
      AssertionRemover.exec(jprogram);
    }
    if (module != null && options.isRunAsyncEnabled()) {
      ReplaceRunAsyncs.exec(logger,jprogram);
      CodeSplitter2.pickInitialLoadSequence(logger,jprogram,module.getProperties());
    }
    ImplementClassLiteralsAsFields.exec(jprogram);
    if (options.getOptimizationLevel() > OptionOptimize.OPTIMIZE_LEVEL_DRAFT && !singlePermutation) {
      if (options.isOptimizePrecompile()) {
        optimize(options,jprogram);
      }
 else {
        optimizeLoop(""String_Node_Str"",jprogram,false);
      }
    }
    Set<String> rebindRequests=new HashSet<String>();
    RecordRebinds.exec(jprogram,rebindRequests);
    if (options.isCompilerMetricsEnabled()) {
      precompilationMetrics.setAstTypes(getReferencedJavaClasses(jprogram));
    }
    logTrackingStats(logger);
    Event createUnifiedAstEvent=SpeedTracerLogger.start(CompilerEventType.CREATE_UNIFIED_AST);
    UnifiedAst result=new UnifiedAst(options,new AST(jprogram,jsProgram),singlePermutation,rebindRequests);
    createUnifiedAstEvent.end();
    return result;
  }
 catch (  Throwable e) {
    throw CompilationProblemReporter.logAndTranslateException(logger,e);
  }
 finally {
  }
}",0.97235072619688
53605,"/** 
 * Special AST construction, useful for tests. Everything is resolved, translated, and unified.
 */
public void buildEverything(TreeLogger logger) throws UnableToCompleteException {
  this.logger=logger;
  for (  String internalName : classFileMap.keySet()) {
    String typeName=InternalName.toBinaryName(internalName);
    searchForTypeByBinary(typeName);
  }
  for (  JDeclaredType type : program.getDeclaredTypes()) {
    instantiate(type);
    for (    JField field : type.getFields()) {
      flowInto(field);
    }
    for (    JMethod method : type.getMethods()) {
      flowInto(method);
    }
  }
  mainLoop();
  computeOverrides();
  if (errorsFound) {
    throw new UnableToCompleteException();
  }
}","/** 
 * Special AST construction, useful for tests. Everything is resolved, translated, and unified.
 */
public void buildEverything() throws UnableToCompleteException {
  for (  String internalName : classFileMap.keySet()) {
    String typeName=InternalName.toBinaryName(internalName);
    searchForTypeByBinary(typeName);
  }
  for (  JDeclaredType type : program.getDeclaredTypes()) {
    instantiate(type);
    for (    JField field : type.getFields()) {
      flowInto(field);
    }
    for (    JMethod method : type.getMethods()) {
      flowInto(method);
    }
  }
  mainLoop();
  computeOverrides();
  if (errorsFound) {
    throw new UnableToCompleteException();
  }
}",0.9720430107526882
53606,"public UnifyAst(JProgram program,JsProgram jsProgram,JJSOptions options,RebindPermutationOracle rpo){
  this.program=program;
  this.jsProgram=jsProgram;
  this.options=options;
  this.rpo=rpo;
  this.classFileMap=rpo.getCompilationState().getClassFileMap();
  this.classFileMapBySource=rpo.getCompilationState().getClassFileMapBySource();
}","public UnifyAst(TreeLogger logger,JProgram program,JsProgram jsProgram,JJSOptions options,RebindPermutationOracle rpo){
  this.logger=logger;
  this.program=program;
  this.jsProgram=jsProgram;
  this.options=options;
  this.rpo=rpo;
  this.classFileMap=rpo.getCompilationState().getClassFileMap();
  this.classFileMapBySource=rpo.getCompilationState().getClassFileMapBySource();
}",0.9445983379501384
53607,"/** 
 * For normal compilation, only translate and stitch types reachable from entry points. This reduces memory and improves compile speed. Any unreachable elements are pruned.
 */
public void exec(TreeLogger logger) throws UnableToCompleteException {
  this.logger=logger;
  for (  JMethod entryMethod : program.getEntryMethods()) {
    flowInto(entryMethod);
  }
  for (  JClassType type : program.codeGenTypes) {
    for (    JMethod method : type.getMethods()) {
      flowInto(method);
    }
  }
  instantiate(program.getTypeJavaLangString());
  flowInto(program.getIndexedMethod(""String_Node_Str""));
  mapApi(program.getTypeJavaLangString());
  flowInto(methodMap.get(""String_Node_Str""));
  flowInto(program.getIndexedMethod(""String_Node_Str""));
  AutoboxUtils autoboxUtils=new AutoboxUtils(program);
  for (  JMethod method : autoboxUtils.getBoxMethods()) {
    flowInto(method);
  }
  for (  JMethod method : autoboxUtils.getUnboxMethods()) {
    flowInto(method);
  }
  if (options.isRunAsyncEnabled()) {
    flowInto(program.getIndexedMethod(""String_Node_Str""));
    flowInto(program.getIndexedMethod(""String_Node_Str""));
  }
  staticInitialize(program.getTypeClassLiteralHolder());
  for (  JMethod method : program.getTypeJavaLangClass().getMethods()) {
    if (method.isStatic() && method.getName().startsWith(""String_Node_Str"")) {
      flowInto(method);
    }
  }
  mainLoop();
  for (Iterator<JDeclaredType> it=program.getDeclaredTypes().iterator(); it.hasNext(); ) {
    JDeclaredType type=it.next();
    boolean isInstantiated=instantiatedTypes.contains(type);
    for (int i=0; i < type.getFields().size(); ++i) {
      JField field=type.getFields().get(i);
      if (!liveFieldsAndMethods.contains(field) || (!field.isStatic() && !isInstantiated)) {
        type.removeField(i);
        --i;
      }
    }
    JMethod clinit=type.getClinitMethod();
    if (!liveFieldsAndMethods.contains(clinit)) {
      clinit.setBody(new JMethodBody(SourceOrigin.UNKNOWN));
    }
    for (int i=1; i < type.getMethods().size(); ++i) {
      JMethod method=type.getMethods().get(i);
      if (!liveFieldsAndMethods.contains(method) || (!method.isStatic() && !isInstantiated)) {
        type.removeMethod(i);
        --i;
      }
    }
  }
  computeOverrides();
  if (errorsFound) {
    throw new UnableToCompleteException();
  }
}","/** 
 * For normal compilation, only translate and stitch types reachable from entry points. This reduces memory and improves compile speed. Any unreachable elements are pruned.
 */
public void exec() throws UnableToCompleteException {
  for (  JMethod entryMethod : program.getEntryMethods()) {
    flowInto(entryMethod);
  }
  for (  JClassType type : program.codeGenTypes) {
    for (    JMethod method : type.getMethods()) {
      flowInto(method);
    }
  }
  instantiate(program.getTypeJavaLangString());
  flowInto(program.getIndexedMethod(""String_Node_Str""));
  mapApi(program.getTypeJavaLangString());
  flowInto(methodMap.get(""String_Node_Str""));
  flowInto(program.getIndexedMethod(""String_Node_Str""));
  AutoboxUtils autoboxUtils=new AutoboxUtils(program);
  for (  JMethod method : autoboxUtils.getBoxMethods()) {
    flowInto(method);
  }
  for (  JMethod method : autoboxUtils.getUnboxMethods()) {
    flowInto(method);
  }
  if (options.isRunAsyncEnabled()) {
    flowInto(program.getIndexedMethod(""String_Node_Str""));
    flowInto(program.getIndexedMethod(""String_Node_Str""));
  }
  staticInitialize(program.getTypeClassLiteralHolder());
  for (  JMethod method : program.getTypeJavaLangClass().getMethods()) {
    if (method.isStatic() && method.getName().startsWith(""String_Node_Str"")) {
      flowInto(method);
    }
  }
  mainLoop();
  for (Iterator<JDeclaredType> it=program.getDeclaredTypes().iterator(); it.hasNext(); ) {
    JDeclaredType type=it.next();
    boolean isInstantiated=instantiatedTypes.contains(type);
    for (int i=0; i < type.getFields().size(); ++i) {
      JField field=type.getFields().get(i);
      if (!liveFieldsAndMethods.contains(field) || (!field.isStatic() && !isInstantiated)) {
        type.removeField(i);
        --i;
      }
    }
    JMethod clinit=type.getClinitMethod();
    if (!liveFieldsAndMethods.contains(clinit)) {
      clinit.setBody(new JMethodBody(SourceOrigin.UNKNOWN));
    }
    for (int i=1; i < type.getMethods().size(); ++i) {
      JMethod method=type.getMethods().get(i);
      if (!liveFieldsAndMethods.contains(method) || (!method.isStatic() && !isInstantiated)) {
        type.removeMethod(i);
        --i;
      }
    }
  }
  computeOverrides();
  if (errorsFound) {
    throw new UnableToCompleteException();
  }
}",0.9915821282106626
53608,"private Entry<K,V> implFindEntry(Object key,boolean remove){
  for (Iterator<Entry<K,V>> iter=entrySet().iterator(); iter.hasNext(); ) {
    Entry<K,V> entry=iter.next();
    K k=entry.getKey();
    if (key == null ? k == null : key.equals(k)) {
      if (remove) {
        iter.remove();
      }
      return entry;
    }
  }
  return null;
}","private Entry<K,V> implFindEntry(Object key,boolean remove){
  for (Iterator<Entry<K,V>> iter=entrySet().iterator(); iter.hasNext(); ) {
    Entry<K,V> entry=iter.next();
    K k=entry.getKey();
    if (key == null ? k == null : key.equals(k)) {
      if (remove) {
        entry=new MapEntryImpl<K,V>(entry.getKey(),entry.getValue());
        iter.remove();
      }
      return entry;
    }
  }
  return null;
}",0.8888888888888888
53609,"@Override public boolean hasSideEffects(){
  return false;
}","@Override public boolean hasSideEffects(){
  return expr.hasSideEffects();
}",0.8382352941176471
53610,"@Override protected boolean optimizeMethod(JProgram program,JMethod method){
  MethodCallTightener.exec(program);
  OptimizerStats result=DeadCodeElimination.exec(program,method);
  if (result.didChange()) {
    assertFalse(DeadCodeElimination.exec(program,method).didChange());
  }
  return result.didChange();
}","@Override protected boolean optimizeMethod(JProgram program,JMethod method){
  MethodCallTightener.exec(program);
  if (runMethodInliner) {
    MethodInliner.exec(program);
  }
  OptimizerStats result=DeadCodeElimination.exec(program,method);
  if (result.didChange()) {
    assertFalse(DeadCodeElimination.exec(program,method).didChange());
  }
  return result.didChange();
}",0.9085631349782292
53611,"@Override public void setUp() throws Exception {
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
}","@Override public void setUp() throws Exception {
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  addSnippetClassDecl(""String_Node_Str"");
  runMethodInliner=false;
}",0.9674185463659148
53612,"/** 
 * Returns <code>true</code> if this type or one of its subtypes is instantiable relative to a known base type.
 */
private boolean checkSubtypes(TreeLogger logger,JClassType originalType,Set<JClassType> instSubtypes,TypePath path,ProblemReport problems){
  JClassType baseType=getBaseType(originalType);
  TreeLogger computationLogger=logger.branch(TreeLogger.DEBUG,""String_Node_Str"");
  List<JClassType> candidates=getPossiblyInstantiableSubtypes(computationLogger,baseType,problems);
  boolean anySubtypes=false;
  TreeLogger verificationLogger=logger.branch(TreeLogger.DEBUG,""String_Node_Str"");
  for (  JClassType candidate : candidates) {
    if (getBaseType(candidate) == baseType && originalType.isRawType() == null) {
      candidate=originalType;
    }
 else {
      candidate=constrainTypeBy(candidate,originalType);
      if (candidate == null) {
        continue;
      }
    }
    if (!isAllowedByFilter(candidate,problems)) {
      continue;
    }
    TypePath subtypePath=TypePaths.createSubtypePath(path,candidate,originalType);
    TypeInfoComputed tic=ensureTypeInfoComputed(candidate,subtypePath);
    if (tic.isDone()) {
      if (tic.isInstantiable()) {
        anySubtypes=true;
        instSubtypes.add(candidate);
      }
      continue;
    }
 else     if (tic.isPendingInstantiable()) {
      anySubtypes=true;
      instSubtypes.add(candidate);
      continue;
    }
    tic.setPendingInstantiable();
    TreeLogger subtypeLogger=verificationLogger.branch(TreeLogger.DEBUG,candidate.getParameterizedQualifiedSourceName());
    boolean instantiable=checkSubtype(subtypeLogger,candidate,originalType,subtypePath,problems);
    anySubtypes|=instantiable;
    tic.setInstantiable(instantiable);
    if (instantiable) {
      subtypeLogger.branch(TreeLogger.DEBUG,""String_Node_Str"");
    }
    if (instantiable) {
      instSubtypes.add(candidate);
    }
  }
  return anySubtypes;
}","/** 
 * Returns <code>true</code> if this type or one of its subtypes is instantiable relative to a known base type.
 */
private boolean checkSubtypes(TreeLogger logger,JClassType originalType,Set<JClassType> instSubtypes,TypePath path,ProblemReport problems){
  JRealClassType baseType=getBaseType(originalType);
  TreeLogger computationLogger=logger.branch(TreeLogger.DEBUG,""String_Node_Str"");
  List<JClassType> candidates=getPossiblyInstantiableSubtypes(computationLogger,baseType,problems);
  boolean anySubtypes=false;
  TreeLogger verificationLogger=logger.branch(TreeLogger.DEBUG,""String_Node_Str"");
  for (  JClassType candidate : candidates) {
    if (getBaseType(candidate) == baseType && originalType.isRawType() == null) {
      candidate=originalType;
    }
 else {
      candidate=constrainTypeBy(candidate,originalType);
      if (candidate == null) {
        continue;
      }
    }
    if (!isAllowedByFilter(candidate,problems)) {
      continue;
    }
    TypePath subtypePath=TypePaths.createSubtypePath(path,candidate,originalType);
    TypeInfoComputed tic=ensureTypeInfoComputed(candidate,subtypePath);
    if (tic.isDone()) {
      if (tic.isInstantiable()) {
        anySubtypes=true;
        instSubtypes.add(candidate);
      }
      continue;
    }
 else     if (tic.isPendingInstantiable()) {
      anySubtypes=true;
      instSubtypes.add(candidate);
      continue;
    }
    tic.setPendingInstantiable();
    TreeLogger subtypeLogger=verificationLogger.branch(TreeLogger.DEBUG,candidate.getParameterizedQualifiedSourceName());
    boolean instantiable=checkSubtype(subtypeLogger,candidate,originalType,subtypePath,problems);
    anySubtypes|=instantiable;
    tic.setInstantiable(instantiable);
    if (instantiable) {
      subtypeLogger.branch(TreeLogger.DEBUG,""String_Node_Str"");
    }
    if (instantiable) {
      instSubtypes.add(candidate);
    }
  }
  return anySubtypes;
}",0.9989539748953976
53613,"/** 
 * Returns the subtypes of a given base type as parameterized by wildcards.
 */
private List<JClassType> getPossiblyInstantiableSubtypes(TreeLogger logger,JClassType baseType,ProblemReport problems){
  assert(baseType == getBaseType(baseType));
  List<JClassType> possiblyInstantiableTypes=new ArrayList<JClassType>();
  if (baseType == typeOracle.getJavaLangObject()) {
    return possiblyInstantiableTypes;
  }
  List<JClassType> candidates=new ArrayList<JClassType>();
  candidates.add(baseType);
  List<JClassType> subtypes=Arrays.asList(baseType.getSubtypes());
  candidates.addAll(subtypes);
  for (  JClassType subtype : candidates) {
    JClassType subtypeBase=getBaseType(subtype);
    if (maybeInstantiable(logger,subtypeBase,problems)) {
      JGenericType isGeneric=subtype.isGenericType();
      if (isGeneric != null) {
        subtype=isGeneric.asParameterizedByWildcards();
      }
 else {
        assert(subtype instanceof JRealClassType);
      }
      possiblyInstantiableTypes.add(subtype);
    }
  }
  if (possiblyInstantiableTypes.size() == 0) {
    String possibilities[]=new String[candidates.size()];
    for (int i=0; i < possibilities.length; i++) {
      JClassType subtype=candidates.get(i);
      String worstMessage=problems.getWorstMessageForType(subtype);
      if (worstMessage == null) {
        possibilities[i]=""String_Node_Str"" + subtype.getParameterizedQualifiedSourceName() + ""String_Node_Str"";
      }
 else {
        possibilities[i]=""String_Node_Str"" + worstMessage;
      }
    }
    problems.add(baseType,baseType.getParameterizedQualifiedSourceName() + ""String_Node_Str"",Priority.DEFAULT,possibilities);
  }
  return possiblyInstantiableTypes;
}","/** 
 * Returns the subtypes of a given base type as parameterized by wildcards.
 */
private List<JClassType> getPossiblyInstantiableSubtypes(TreeLogger logger,JRealClassType baseType,ProblemReport problems){
  assert(baseType == getBaseType(baseType));
  List<JClassType> possiblyInstantiableTypes=new ArrayList<JClassType>();
  if (baseType == typeOracle.getJavaLangObject()) {
    return possiblyInstantiableTypes;
  }
  List<JClassType> candidates=new ArrayList<JClassType>();
  candidates.add(baseType);
  List<JClassType> subtypes=Arrays.asList(baseType.getSubtypes());
  candidates.addAll(subtypes);
  for (  JClassType subtype : candidates) {
    JClassType subtypeBase=getBaseType(subtype);
    if (maybeInstantiable(logger,subtypeBase,problems)) {
      JGenericType isGeneric=subtype.isGenericType();
      if (isGeneric != null) {
        subtype=isGeneric.asParameterizedByWildcards();
      }
 else {
        assert(subtype instanceof JRealClassType);
      }
      possiblyInstantiableTypes.add(subtype);
    }
  }
  if (possiblyInstantiableTypes.size() == 0) {
    String possibilities[]=new String[candidates.size()];
    for (int i=0; i < possibilities.length; i++) {
      JClassType subtype=candidates.get(i);
      String worstMessage=problems.getWorstMessageForType(subtype);
      if (worstMessage == null) {
        possibilities[i]=""String_Node_Str"" + subtype.getParameterizedQualifiedSourceName() + ""String_Node_Str"";
      }
 else {
        possibilities[i]=""String_Node_Str"" + worstMessage;
      }
    }
    problems.add(baseType,baseType.getParameterizedQualifiedSourceName() + ""String_Node_Str"",Priority.DEFAULT,possibilities);
  }
  return possiblyInstantiableTypes;
}",0.9988221436984688
53614,"private TypeInfoComputed checkArrayInstantiable(TreeLogger logger,JArrayType array,TypePath path,ProblemReport problems){
}","private TypeInfoComputed checkArrayInstantiable(TreeLogger logger,JArrayType array,TypePath path,ProblemReport problems){
  JType leafType=array.getLeafType();
  JWildcardType leafWild=leafType.isWildcard();
  if (leafWild != null) {
    JArrayType arrayType=getArrayType(typeOracle,array.getRank(),leafWild.getUpperBound());
    return checkArrayInstantiable(logger,arrayType,path,problems);
  }
  TypeInfoComputed tic=ensureTypeInfoComputed(array,path);
  if (tic.isDone() || tic.isPendingInstantiable()) {
    return tic;
  }
  tic.setPendingInstantiable();
  JTypeParameter isLeafTypeParameter=leafType.isTypeParameter();
  if (isLeafTypeParameter != null && !typeParametersInRootTypes.contains(isLeafTypeParameter)) {
    tic.setInstantiableSubtypes(true);
    tic.setInstantiable(false);
    return tic;
  }
  if (!isAllowedByFilter(array,problems)) {
    tic.setInstantiable(false);
    return tic;
  }
  TreeLogger branch=logger.branch(TreeLogger.DEBUG,""String_Node_Str"",null);
  TypeInfoComputed leafTic=computeTypeInstantiability(branch,leafType,TypePaths.createArrayComponentPath(array,path),problems);
  boolean succeeded=leafTic.hasInstantiableSubtypes();
  tic.setInstantiable(succeeded);
  return tic;
}",0.1834451901565995
53615,"/** 
 * Builds a   {@link SerializableTypeOracle} for a given set of root types.
 * @param logger
 * @return a {@link SerializableTypeOracle} for the specified set of roottypes
 * @throws UnableToCompleteException if there was not at least oneinstantiable type assignable to each of the specified root types
 */
public SerializableTypeOracle build(TreeLogger logger) throws UnableToCompleteException {
  alreadyCheckedObject=false;
  boolean allSucceeded=true;
  for (  Entry<JClassType,TreeLogger> entry : rootTypes.entrySet()) {
    ProblemReport problems=new ProblemReport();
    problems.setContextType(entry.getKey());
    boolean entrySucceeded=computeTypeInstantiability(entry.getValue(),entry.getKey(),TypePaths.createRootPath(entry.getKey()),problems).hasInstantiableSubtypes();
    if (!entrySucceeded) {
      problems.report(logger,TreeLogger.ERROR,TreeLogger.INFO);
    }
 else {
      if (problems.hasFatalProblems()) {
        entrySucceeded=false;
        problems.reportFatalProblems(logger,TreeLogger.ERROR);
      }
      problems.report(logger,TreeLogger.DEBUG,TreeLogger.DEBUG);
    }
    allSucceeded&=entrySucceeded;
  }
  if (!allSucceeded) {
    throw new UnableToCompleteException();
  }
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    assert(!tic.isPendingInstantiable());
  }
  pruneUnreachableTypes();
  logReachableTypes(logger);
  Set<JClassType> possiblyInstantiatedTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  Set<JClassType> fieldSerializableTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    if (!(tic.getType() instanceof JClassType)) {
      continue;
    }
    JClassType type=(JClassType)tic.getType();
    type=type.getErasedType();
    if (tic.isInstantiable()) {
      assert(!type.isAbstract() || type.isEnum() != null);
      possiblyInstantiatedTypes.add(type);
    }
    if (tic.isFieldSerializable()) {
      assert(type.isInterface() == null);
      fieldSerializableTypes.add(type);
    }
    if (tic.maybeEnhanced() || (enhancedClasses != null && enhancedClasses.contains(type.getQualifiedSourceName()))) {
      type.setEnhanced();
    }
  }
  logSerializableTypes(logger,fieldSerializableTypes);
  return new SerializableTypeOracleImpl(fieldSerializableTypes,possiblyInstantiatedTypes);
}","/** 
 * Builds a   {@link SerializableTypeOracle} for a given set of root types.
 * @param logger
 * @return a {@link SerializableTypeOracle} for the specified set of roottypes
 * @throws UnableToCompleteException if there was not at least oneinstantiable type assignable to each of the specified root types
 */
public SerializableTypeOracle build(TreeLogger logger) throws UnableToCompleteException {
  alreadyCheckedObject=false;
  boolean allSucceeded=true;
  for (  Entry<JClassType,TreeLogger> entry : rootTypes.entrySet()) {
    ProblemReport problems=new ProblemReport();
    problems.setContextType(entry.getKey());
    boolean entrySucceeded=computeTypeInstantiability(entry.getValue(),entry.getKey(),TypePaths.createRootPath(entry.getKey()),problems).hasInstantiableSubtypes();
    if (!entrySucceeded) {
      problems.report(logger,TreeLogger.ERROR,TreeLogger.INFO);
    }
 else {
      maybeReport(logger,problems);
    }
    allSucceeded&=entrySucceeded & !problems.hasFatalProblems();
  }
  if (!allSucceeded) {
    throw new UnableToCompleteException();
  }
  assertNothingPending();
  List<TypeInfoComputed> ticsToCheck=new ArrayList<TypeInfoComputed>();
  ticsToCheck.addAll(typeToTypeInfoComputed.values());
  for (  TypeInfoComputed tic : ticsToCheck) {
    JArrayType type=tic.getType().isArray();
    if (type != null && tic.instantiable) {
      ProblemReport problems=new ProblemReport();
      problems.setContextType(type);
      markArrayTypes(logger,type,tic.getPath(),problems);
      maybeReport(logger,problems);
      allSucceeded&=!problems.hasFatalProblems();
    }
  }
  if (!allSucceeded) {
    throw new UnableToCompleteException();
  }
  assertNothingPending();
  pruneUnreachableTypes();
  logReachableTypes(logger);
  Set<JClassType> possiblyInstantiatedTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  Set<JClassType> fieldSerializableTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    if (!(tic.getType() instanceof JClassType)) {
      continue;
    }
    JClassType type=(JClassType)tic.getType();
    type=type.getErasedType();
    if (tic.isInstantiable()) {
      assert(!type.isAbstract() || type.isEnum() != null);
      possiblyInstantiatedTypes.add(type);
    }
    if (tic.isFieldSerializable()) {
      assert(type.isInterface() == null);
      fieldSerializableTypes.add(type);
    }
    if (tic.maybeEnhanced() || (enhancedClasses != null && enhancedClasses.contains(type.getQualifiedSourceName()))) {
      type.setEnhanced();
    }
  }
  logSerializableTypes(logger,fieldSerializableTypes);
  return new SerializableTypeOracleImpl(fieldSerializableTypes,possiblyInstantiatedTypes);
}",0.8227371756783521
53616,"public CfgOptionalThrowNode(CfgNode<?> parent,JMethodCall node){
  super(parent,node);
}","public CfgOptionalThrowNode(CfgNode<?> parent,JExpression node){
  super(parent,node);
}",0.9090909090909092
53617,"@Override public String toDebugString(){
  return ""String_Node_Str"" + getJNode().getTarget().getName() + ""String_Node_Str"";
}","@Override public String toDebugString(){
  if (getJNode() instanceof JMethodCall) {
    return ""String_Node_Str"" + ((JMethodCall)getJNode()).getTarget().getName() + ""String_Node_Str"";
  }
  return ""String_Node_Str"" + getJNode().toSource() + ""String_Node_Str"";
}",0.4611398963730569
53618,"@Override public void onBrowserEvent(Event event){
  CellBasedWidgetImpl.get().onBrowserEvent(this,event);
  if (isRefreshing) {
    return;
  }
  super.onBrowserEvent(event);
  String eventType=event.getType();
  if (BrowserEvents.FOCUS.equals(eventType)) {
    isFocused=true;
    onFocus();
  }
 else   if (BrowserEvents.BLUR.equals(eventType)) {
    isFocused=false;
    onBlur();
  }
 else   if (BrowserEvents.KEYDOWN.equals(eventType) && !cellIsEditing) {
    int keyCode=event.getKeyCode();
switch (keyCode) {
case KeyCodes.KEY_DOWN:
case KeyCodes.KEY_UP:
case KeyCodes.KEY_RIGHT:
case KeyCodes.KEY_LEFT:
      handleKeyNavigation(keyCode);
    event.preventDefault();
  return;
case 32:
event.preventDefault();
}
}
final Element target=event.getEventTarget().cast();
ArrayList<Element> chain=new ArrayList<Element>();
collectElementChain(chain,getElement(),target);
final boolean isMouseDown=BrowserEvents.MOUSEDOWN.equals(eventType);
final boolean isClick=BrowserEvents.CLICK.equals(eventType);
final CellTreeNodeView<?> nodeView=findItemByChain(chain,0,rootNode);
if (nodeView != null) {
if (isMouseDown) {
Element showMoreElem=nodeView.getShowMoreElement();
if (nodeView.getImageElement().isOrHasChild(target)) {
nodeView.setOpen(!nodeView.isOpen(),true);
return;
}
 else if (showMoreElem != null && showMoreElem.isOrHasChild(target)) {
nodeView.showMore();
return;
}
}
if (nodeView != rootNode && nodeView.getSelectionElement().isOrHasChild(target)) {
if (isClick) {
boolean isFocusable=CellBasedWidgetImpl.get().isFocusable(target);
isFocused=isFocused || isFocusable;
keyboardSelect(nodeView,!isFocusable);
}
nodeView.fireEventToCell(event);
}
}
}","@Override public void onBrowserEvent(Event event){
  CellBasedWidgetImpl.get().onBrowserEvent(this,event);
  if (isRefreshing) {
    return;
  }
  super.onBrowserEvent(event);
  String eventType=event.getType();
  if (BrowserEvents.FOCUS.equals(eventType)) {
    isFocused=true;
    onFocus();
  }
 else   if (BrowserEvents.BLUR.equals(eventType)) {
    isFocused=false;
    onBlur();
  }
 else   if (BrowserEvents.KEYDOWN.equals(eventType) && !cellIsEditing) {
    int keyCode=event.getKeyCode();
switch (keyCode) {
case KeyCodes.KEY_DOWN:
case KeyCodes.KEY_UP:
case KeyCodes.KEY_RIGHT:
case KeyCodes.KEY_LEFT:
      handleKeyNavigation(keyCode);
    event.preventDefault();
  return;
case 32:
event.preventDefault();
}
}
final Element target=event.getEventTarget().cast();
ArrayList<Element> chain=new ArrayList<Element>();
collectElementChain(chain,getElement(),target);
final boolean isMouseDown=BrowserEvents.MOUSEDOWN.equals(eventType);
final boolean isClick=BrowserEvents.CLICK.equals(eventType);
final CellTreeNodeView<?> nodeView=findItemByChain(chain,0,rootNode);
if (nodeView != null) {
if (isMouseDown) {
Element showMoreElem=nodeView.getShowMoreElement();
if (!nodeView.isRootNode() && nodeView.getImageElement().isOrHasChild(target)) {
nodeView.setOpen(!nodeView.isOpen(),true);
return;
}
 else if (showMoreElem != null && showMoreElem.isOrHasChild(target)) {
nodeView.showMore();
return;
}
}
if (nodeView != rootNode && nodeView.getSelectionElement().isOrHasChild(target)) {
if (isClick) {
boolean isFocusable=CellBasedWidgetImpl.get().isFocusable(target);
isFocused=isFocused || isFocusable;
keyboardSelect(nodeView,!isFocusable);
}
nodeView.fireEventToCell(event);
}
}
}",0.9922341696535244
53619,"/** 
 * Preview the   {@link NativePreviewEvent}.
 * @param event the {@link NativePreviewEvent}
 */
private void previewNativeEvent(NativePreviewEvent event){
  if (event.isCanceled() || (!previewAllNativeEvents && event.isConsumed())) {
    if (modal) {
      event.cancel();
    }
    return;
  }
  onPreviewNativeEvent(event);
  if (event.isCanceled()) {
    return;
  }
  Event nativeEvent=Event.as(event.getNativeEvent());
  boolean eventTargetsPopupOrPartner=eventTargetsPopup(nativeEvent) || eventTargetsPartner(nativeEvent);
  if (eventTargetsPopupOrPartner) {
    event.consume();
  }
  if (modal) {
    event.cancel();
  }
  int type=nativeEvent.getTypeInt();
switch (type) {
case Event.ONKEYDOWN:
{
      if (!onKeyDownPreview((char)nativeEvent.getKeyCode(),KeyboardListenerCollection.getKeyboardModifiers(nativeEvent))) {
        event.cancel();
      }
      return;
    }
case Event.ONKEYUP:
{
    if (!onKeyUpPreview((char)nativeEvent.getKeyCode(),KeyboardListenerCollection.getKeyboardModifiers(nativeEvent))) {
      event.cancel();
    }
    return;
  }
case Event.ONKEYPRESS:
{
  if (!onKeyPressPreview((char)nativeEvent.getKeyCode(),KeyboardListenerCollection.getKeyboardModifiers(nativeEvent))) {
    event.cancel();
  }
  return;
}
case Event.ONMOUSEDOWN:
if (DOM.getCaptureElement() != null) {
event.consume();
return;
}
if (!eventTargetsPopupOrPartner && autoHide) {
hide(true);
return;
}
break;
case Event.ONMOUSEUP:
case Event.ONMOUSEMOVE:
case Event.ONCLICK:
case Event.ONDBLCLICK:
{
if (DOM.getCaptureElement() != null) {
event.consume();
return;
}
break;
}
case Event.ONFOCUS:
{
Element target=nativeEvent.getTarget();
if (modal && !eventTargetsPopupOrPartner && (target != null)) {
blur(target);
event.cancel();
return;
}
break;
}
}
}","/** 
 * Preview the   {@link NativePreviewEvent}.
 * @param event the {@link NativePreviewEvent}
 */
private void previewNativeEvent(NativePreviewEvent event){
  if (event.isCanceled() || (!previewAllNativeEvents && event.isConsumed())) {
    if (modal) {
      event.cancel();
    }
    return;
  }
  onPreviewNativeEvent(event);
  if (event.isCanceled()) {
    return;
  }
  Event nativeEvent=Event.as(event.getNativeEvent());
  boolean eventTargetsPopupOrPartner=eventTargetsPopup(nativeEvent) || eventTargetsPartner(nativeEvent);
  if (eventTargetsPopupOrPartner) {
    event.consume();
  }
  if (modal) {
    event.cancel();
  }
  int type=nativeEvent.getTypeInt();
switch (type) {
case Event.ONKEYDOWN:
{
      if (!onKeyDownPreview((char)nativeEvent.getKeyCode(),KeyboardListenerCollection.getKeyboardModifiers(nativeEvent))) {
        event.cancel();
      }
      return;
    }
case Event.ONKEYUP:
{
    if (!onKeyUpPreview((char)nativeEvent.getKeyCode(),KeyboardListenerCollection.getKeyboardModifiers(nativeEvent))) {
      event.cancel();
    }
    return;
  }
case Event.ONKEYPRESS:
{
  if (!onKeyPressPreview((char)nativeEvent.getKeyCode(),KeyboardListenerCollection.getKeyboardModifiers(nativeEvent))) {
    event.cancel();
  }
  return;
}
case Event.ONMOUSEDOWN:
case Event.ONTOUCHSTART:
if (DOM.getCaptureElement() != null) {
event.consume();
return;
}
if (!eventTargetsPopupOrPartner && autoHide) {
hide(true);
return;
}
break;
case Event.ONMOUSEUP:
case Event.ONMOUSEMOVE:
case Event.ONCLICK:
case Event.ONDBLCLICK:
case Event.ONTOUCHEND:
{
if (DOM.getCaptureElement() != null) {
event.consume();
return;
}
break;
}
case Event.ONFOCUS:
{
Element target=nativeEvent.getTarget();
if (modal && !eventTargetsPopupOrPartner && (target != null)) {
blur(target);
event.cancel();
return;
}
break;
}
}
}",0.9865846841811068
53620,"static String extractNameFromToString(String fnToString){
  String toReturn=""String_Node_Str"";
  fnToString=fnToString.trim();
  int index=fnToString.indexOf(""String_Node_Str"");
  if (index != -1) {
    int start=fnToString.startsWith(""String_Node_Str"") ? 8 : 0;
    toReturn=fnToString.substring(start,index).trim();
  }
  return toReturn.length() > 0 ? toReturn : ""String_Node_Str"";
}","static String extractNameFromToString(String fnToString){
  String toReturn=""String_Node_Str"";
  fnToString=fnToString.trim();
  int index=fnToString.indexOf(""String_Node_Str"");
  int start=fnToString.startsWith(""String_Node_Str"") ? 8 : 0;
  if (index == -1) {
    index=fnToString.indexOf('@');
    start=fnToString.startsWith(""String_Node_Str"") ? 9 : 0;
  }
  if (index != -1) {
    toReturn=fnToString.substring(start,index).trim();
  }
  return toReturn.length() > 0 ? toReturn : ""String_Node_Str"";
}",0.8404494382022472
53621,"/** 
 * Returns a map of properties that differ (via   {@link Object#equals(Object)}) between two AutoBeans. The keys are property names and the values are the value of the property in <code>b</code>. Properties present in <code>a</code> but missing in <code>b</code> will be represented by <code>null</code> values. This implementation will compare AutoBeans of different parameterizations, although the diff produced is likely meaningless. <p> This will work for both simple and wrapper AutoBeans.
 * @param a an {@link AutoBean}
 * @param b an {@link AutoBean}
 * @return a {@link Map} of differing properties
 */
public static Map<String,Object> diff(AutoBean<?> a,AutoBean<?> b){
  if (a.equals(b)) {
    return Collections.emptyMap();
  }
  final Map<String,Object> toReturn=getAllProperties(b);
  a.accept(new AutoBeanVisitor(){
    @Override public boolean visitReferenceProperty(    String propertyName,    AutoBean<?> previousValue,    PropertyContext ctx){
      if (toReturn.containsKey(propertyName)) {
        if (equal(propertyName,previousValue)) {
          toReturn.remove(propertyName);
        }
      }
 else {
        toReturn.put(propertyName,null);
      }
      return false;
    }
    @Override public boolean visitValueProperty(    String propertyName,    Object previousValue,    PropertyContext ctx){
      if (toReturn.containsKey(propertyName)) {
        if (equal(propertyName,previousValue)) {
          toReturn.remove(propertyName);
        }
      }
 else {
        toReturn.put(propertyName,null);
      }
      return false;
    }
    private boolean equal(    String propertyName,    AutoBean<?> previousValue){
      return previousValue == null && toReturn.get(propertyName) == null || previousValue != null && equal(propertyName,previousValue.as());
    }
    private boolean equal(    String propertyName,    Object previousValue){
      Object currentValue=toReturn.get(propertyName);
      return previousValue == null && currentValue == null || previousValue != null && previousValue.equals(currentValue);
    }
  }
);
  return toReturn;
}","/** 
 * Returns a map of properties that differ (via   {@link Object#equals(Object)}) between two AutoBeans. The keys are property names and the values are the value of the property in <code>b</code>. Properties present in <code>a</code> but missing in <code>b</code> will be represented by <code>null</code> values. This implementation will compare AutoBeans of different parameterizations, although the diff produced is likely meaningless. <p> This will work for both simple and wrapper AutoBeans.
 * @param a an {@link AutoBean}
 * @param b an {@link AutoBean}
 * @return a {@link Map} of differing properties
 */
public static Map<String,Object> diff(AutoBean<?> a,AutoBean<?> b){
  if (a == b) {
    return Collections.emptyMap();
  }
  final Map<String,Object> toReturn=getAllProperties(b);
  a.accept(new AutoBeanVisitor(){
    @Override public boolean visitReferenceProperty(    String propertyName,    AutoBean<?> previousValue,    PropertyContext ctx){
      if (toReturn.containsKey(propertyName)) {
        if (equal(propertyName,previousValue)) {
          toReturn.remove(propertyName);
        }
      }
 else {
        toReturn.put(propertyName,null);
      }
      return false;
    }
    @Override public boolean visitValueProperty(    String propertyName,    Object previousValue,    PropertyContext ctx){
      if (toReturn.containsKey(propertyName)) {
        if (equal(propertyName,previousValue)) {
          toReturn.remove(propertyName);
        }
      }
 else {
        toReturn.put(propertyName,null);
      }
      return false;
    }
    private boolean equal(    String propertyName,    AutoBean<?> previousValue){
      return previousValue == null && toReturn.get(propertyName) == null || previousValue != null && equal(propertyName,previousValue.as());
    }
    private boolean equal(    String propertyName,    Object previousValue){
      Object currentValue=toReturn.get(propertyName);
      return previousValue == null && currentValue == null || previousValue != null && previousValue.equals(currentValue);
    }
  }
);
  return toReturn;
}",0.9963985594237696
53622,"/** 
 * Compute deltas for each entity seen by the context.
 */
private List<OperationMessage> makePayloadOperations(){
  List<OperationMessage> operations=new ArrayList<OperationMessage>();
  for (  AutoBean<? extends BaseProxy> currentView : state.editedProxies.values()) {
    OperationMessage operation=makeOperationMessage(BaseProxyCategory.stableId(currentView),currentView,true).as();
    operations.add(operation);
  }
  return operations;
}","/** 
 * Compute deltas for each entity seen by the context. <p> TODO(t.broyer): reduce payload size by only sending proxies that are directly referenced by invocation arguments or by other proxies. For backwards-compatibility with no-op requests and operation-only requests, only do so when there's at least one invocation (or we can choose to break backwards compatibility for those edge-cases).
 */
private List<OperationMessage> makePayloadOperations(){
}",0.2668136714443219
53623,"public boolean isChanged(){
  for (  AutoBean<? extends BaseProxy> bean : state.editedProxies.values()) {
    AutoBean<?> previous=bean.getTag(Constants.PARENT_OBJECT);
    if (previous == null) {
      Class<?> proxyClass=stableId(bean).getProxyClass();
      previous=getAutoBeanFactory().create(proxyClass);
    }
    if (!AutoBeanUtils.diff(previous,bean).isEmpty()) {
      return true;
    }
  }
  return false;
}","public boolean isChanged(){
}",0.1294642857142857
53624,"/** 
 * Sniff all return values and ensure that if the current bean is a mutable EntityProxy, that its return values are mutable.
 */
public static <T>T __intercept(AutoBean<?> bean,T returnValue){
  AbstractRequestContext context=requestContext(bean);
  if (context == null || context.isLocked()) {
    return returnValue;
  }
  if (returnValue instanceof BaseProxy) {
    @SuppressWarnings(""String_Node_Str"") T toReturn=(T)context.editProxy((BaseProxy)returnValue);
    return toReturn;
  }
  if (returnValue instanceof Poser<?>) {
    ((Poser<?>)returnValue).setFrozen(false);
  }
  AutoBean<T> otherBean=AutoBeanUtils.getAutoBean(returnValue);
  if (otherBean != null) {
    otherBean.setTag(REQUEST_CONTEXT_STATE,bean.getTag(REQUEST_CONTEXT_STATE));
  }
  return returnValue;
}","/** 
 * Sniff all return values and ensure that if the current bean is a mutable EntityProxy, that its return values are mutable.
 */
public static <T>T __intercept(AutoBean<?> bean,T returnValue){
  AbstractRequestContext context=requestContext(bean);
  if (context == null || context.isLocked() || context.isDiffing()) {
    return returnValue;
  }
  if (returnValue instanceof BaseProxy) {
    @SuppressWarnings(""String_Node_Str"") T toReturn=(T)context.editProxy((BaseProxy)returnValue);
    return toReturn;
  }
  if (returnValue instanceof Poser<?>) {
    ((Poser<?>)returnValue).setFrozen(false);
  }
  AutoBean<T> otherBean=AutoBeanUtils.getAutoBean(returnValue);
  if (otherBean != null) {
    otherBean.setTag(REQUEST_CONTEXT_STATE,bean.getTag(REQUEST_CONTEXT_STATE));
  }
  return returnValue;
}",0.9855072463768116
53625,"/** 
 * EntityProxies are equal if they are from the same RequestContext and their stableIds are equal.
 */
public static boolean equals(AutoBean<? extends EntityProxy> bean,Object o){
  if (!(o instanceof EntityProxy)) {
    return false;
  }
  AutoBean<EntityProxy> other=AutoBeanUtils.getAutoBean((EntityProxy)o);
  if (other == null) {
    return false;
  }
  return stableId(bean).equals(stableId(other)) && requestContext(bean) == requestContext(other);
}","/** 
 * EntityProxies are equal if they are from the same RequestContext and their stableIds are equal.
 */
public static boolean equals(AutoBean<? extends EntityProxy> bean,Object o){
  if (!(o instanceof EntityProxy)) {
    return false;
  }
  AutoBean<EntityProxy> other=AutoBeanUtils.getAutoBean((EntityProxy)o);
  if (other == null) {
    return false;
  }
  return stableId(bean).equals(stableId(other)) && nonDiffingRequestContext(bean) == nonDiffingRequestContext(other);
}",0.9745222929936306
53626,"public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(RequestBatcherTest.class);
  suite.addTestSuite(BoxesAndPrimitivesTest.class);
  suite.addTestSuite(ComplexKeysTest.class);
  suite.addTestSuite(EditorTest.class);
  suite.addTestSuite(FanoutReceiverTest.class);
  suite.addTestSuite(FindServiceTest.class);
  suite.addTestSuite(LocatorTest.class);
  suite.addTestSuite(RequestFactoryTest.class);
  suite.addTestSuite(RequestFactoryChainedContextTest.class);
  suite.addTestSuite(RequestFactoryExceptionHandlerTest.class);
  suite.addTestSuite(RequestFactoryExceptionPropagationTest.class);
  suite.addTestSuite(RequestFactoryPolymorphicTest.class);
  suite.addTestSuite(RequestFactoryUnicodeEscapingTest.class);
  suite.addTestSuite(ServiceInheritanceTest.class);
  return suite;
}","public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(RequestBatcherTest.class);
  suite.addTestSuite(BoxesAndPrimitivesTest.class);
  suite.addTestSuite(ComplexKeysTest.class);
  suite.addTestSuite(EditorTest.class);
  suite.addTestSuite(FanoutReceiverTest.class);
  suite.addTestSuite(FindServiceTest.class);
  suite.addTestSuite(LocatorTest.class);
  suite.addTestSuite(RequestFactoryTest.class);
  suite.addTestSuite(RequestFactoryChainedContextTest.class);
  suite.addTestSuite(RequestFactoryExceptionHandlerTest.class);
  suite.addTestSuite(RequestFactoryExceptionPropagationTest.class);
  suite.addTestSuite(RequestFactoryPolymorphicTest.class);
  suite.addTestSuite(RequestFactoryUnicodeEscapingTest.class);
  suite.addTestSuite(RequestPayloadTest.class);
  suite.addTestSuite(ServiceInheritanceTest.class);
  return suite;
}",0.9721577726218096
53627,"public List<SimpleValue> getSimpleValues(){
  return Arrays.asList(simpleValueField);
}","public List<SimpleValue> getSimpleValues(){
  return simpleValueField;
}",0.9056603773584906
53628,"public SimpleValue getSimpleValue(){
  return simpleValueField;
}","public SimpleValue getSimpleValue(){
  return simpleValueField != null && simpleValueField.size() > 0 ? simpleValueField.get(0) : null;
}",0.6435643564356436
53629,"public void setSimpleValue(SimpleValue simpleValueField){
  this.simpleValueField=simpleValueField;
}","public void setSimpleValue(SimpleValue simpleValueField){
  this.simpleValueField=Collections.singletonList(simpleValueField);
}",0.8820960698689956
53630,"public void setSimpleValues(List<SimpleValue> simpleValueField){
  this.simpleValueField=simpleValueField.get(0);
}","public void setSimpleValues(List<SimpleValue> simpleValueField){
  this.simpleValueField=simpleValueField;
}",0.968609865470852
53631,"private ModuleDef loadModule(TreeLogger logger,Map<String,String> bindingProperties) throws UnableToCompleteException {
  ZipFileClassPathEntry.clearCache();
  ResourceOracleImpl.clearCache();
  ModuleDefLoader.clearModuleCache();
  ResourceLoader resources=ResourceLoaders.forClassLoader(Thread.currentThread());
  resources=ResourceLoaders.forPathAndFallback(sourcePath,resources);
  this.resourceLoader.set(resources);
  ModuleDef moduleDef=ModuleDefLoader.loadFromResources(logger,originalModuleName,resources,true);
  if (IFrameLinker.class.isAssignableFrom(moduleDef.getActivePrimaryLinker())) {
    moduleDef.addLinker(""String_Node_Str"");
  }
  Class<? extends Linker> linker=moduleDef.getActivePrimaryLinker();
  if (!CrossSiteIframeLinker.class.isAssignableFrom(linker)) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"" + linker.getName());
    throw new UnableToCompleteException();
  }
  if (moduleDef.getProperties().find(""String_Node_Str"") == null) {
    throw new RuntimeException(""String_Node_Str"" + moduleDef.getName());
  }
  overrideConfig(moduleDef,""String_Node_Str"",""String_Node_Str"");
  overrideConfig(moduleDef,""String_Node_Str"",""String_Node_Str"");
  overrideConfig(moduleDef,""String_Node_Str"",""String_Node_Str"");
  maybeOverrideConfig(moduleDef,""String_Node_Str"",""String_Node_Str"");
  maybeOverrideConfig(moduleDef,""String_Node_Str"",""String_Node_Str"");
  maybeOverrideConfig(moduleDef,""String_Node_Str"",""String_Node_Str"");
  maybeOverrideConfig(moduleDef,""String_Node_Str"",""String_Node_Str"");
  for (  Map.Entry<String,String> entry : bindingProperties.entrySet()) {
    String propName=entry.getKey();
    String propValue=entry.getValue();
    logger.log(TreeLogger.Type.INFO,""String_Node_Str"" + propName + ""String_Node_Str""+ propValue);
    overrideBinding(moduleDef,propName,propValue);
  }
  overrideBinding(moduleDef,""String_Node_Str"",""String_Node_Str"");
  return moduleDef;
}","private ModuleDef loadModule(TreeLogger logger,Map<String,String> bindingProperties) throws UnableToCompleteException {
  ZipFileClassPathEntry.clearCache();
  ResourceOracleImpl.clearCache();
  ModuleDefLoader.clearModuleCache();
  ResourceLoader resources=ResourceLoaders.forClassLoader(Thread.currentThread());
  resources=ResourceLoaders.forPathAndFallback(sourcePath,resources);
  this.resourceLoader.set(resources);
  ModuleDef moduleDef=ModuleDefLoader.loadFromResources(logger,originalModuleName,resources,true);
  if (IFrameLinker.class.isAssignableFrom(moduleDef.getActivePrimaryLinker())) {
    moduleDef.addLinker(""String_Node_Str"");
  }
  Class<? extends Linker> linker=moduleDef.getActivePrimaryLinker();
  if (!CrossSiteIframeLinker.class.isAssignableFrom(linker)) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"" + linker.getName());
    throw new UnableToCompleteException();
  }
  if (moduleDef.getProperties().find(""String_Node_Str"") == null) {
    throw new RuntimeException(""String_Node_Str"" + moduleDef.getName());
  }
  overrideConfig(moduleDef,""String_Node_Str"",""String_Node_Str"");
  overrideConfig(moduleDef,""String_Node_Str"",""String_Node_Str"");
  overrideConfig(moduleDef,""String_Node_Str"",""String_Node_Str"");
  overrideConfig(moduleDef,""String_Node_Str"",""String_Node_Str"");
  maybeOverrideConfig(moduleDef,""String_Node_Str"",""String_Node_Str"");
  maybeOverrideConfig(moduleDef,""String_Node_Str"",""String_Node_Str"");
  maybeOverrideConfig(moduleDef,""String_Node_Str"",""String_Node_Str"");
  for (  Map.Entry<String,String> entry : bindingProperties.entrySet()) {
    String propName=entry.getKey();
    String propValue=entry.getValue();
    logger.log(TreeLogger.Type.INFO,""String_Node_Str"" + propName + ""String_Node_Str""+ propValue);
    overrideBinding(moduleDef,propName,propValue);
  }
  overrideBinding(moduleDef,""String_Node_Str"",""String_Node_Str"");
  return moduleDef;
}",0.964576226712149
53632,"/** 
 * Returns the name of the   {@code ComputeScriptBase} script.  By default,returns  {@code ""com/google/gwt/core/ext/linker/impl/computeScriptBase.js""}.
 * @param context a LinkerContext
 */
protected String getJsComputeScriptBase(LinkerContext context){
  return ""String_Node_Str"";
}","/** 
 * Returns the name of the   {@code ComputeScriptBase} script.  By default,returns  {@code ""com/google/gwt/core/ext/linker/impl/computeScriptBase.js""}.
 * @param context a LinkerContext
 */
protected String getJsComputeScriptBase(LinkerContext context){
  return getStringConfigurationProperty(context,""String_Node_Str"",""String_Node_Str"");
}",0.9085173501577288
53633,"/** 
 * Returns true if the given object should be selected by default. Subclasses implement this method in order to define the default selection behavior.
 * @param object an object of this {@link SelectionModel}'s type
 * @return true if the object should be selected by default
 */
public abstract boolean isDefaultSelected(T object);","/** 
 * Returns true if the given item should be selected by default. Subclasses implement this method in order to define the default selection behavior.
 * @param item an object of this {@link SelectionModel}'s type
 * @return true if the item should be selected by default
 */
public abstract boolean isDefaultSelected(T item);",0.93993993993994
53634,"/** 
 * Sets an object's selection state. If the object is currently marked as an exception, and the new selected state differs from the previous selected state, the object is removed from the list of exceptions. Otherwise, the object is added to the list of exceptions with the given selected state.
 */
public void setSelected(T object,boolean selected){
  selectionChanges.put(object,selected);
  scheduleSelectionChangeEvent();
}","/** 
 * Sets an item's selection state. If the item is currently marked as an exception, and the new selected state differs from the previous selected state, the object is removed from the list of exceptions. Otherwise, the object is added to the list of exceptions with the given selected state.
 */
@Override public void setSelected(T item,boolean selected){
  selectionChanges.put(getKey(item),new SelectionChange<T>(item,selected));
  scheduleSelectionChangeEvent();
}",0.4707182320441989
53635,"/** 
 * If the given object is marked as an exception, return the exception value. Otherwise, return the value of isDefaultSelected for the given object.
 */
public boolean isSelected(T object){
  resolveChanges();
  Object key=getKey(object);
  Boolean exception=exceptions.get(key);
  if (exception != null) {
    return exception.booleanValue();
  }
  return isDefaultSelected(object);
}","/** 
 * If the given item is marked as an exception, return the exception value. Otherwise, return the value of isDefaultSelected for the given item.
 */
@Override public boolean isSelected(T item){
  resolveChanges();
  Object key=getKey(item);
  Boolean exception=exceptions.get(key);
  if (exception != null) {
    return exception.booleanValue();
  }
  return isDefaultSelected(item);
}",0.9230769230769232
53636,"private void resolveChanges(){
  boolean changed=false;
  for (  Map.Entry<T,Boolean> entry : selectionChanges.entrySet()) {
    T object=entry.getKey();
    boolean selected=entry.getValue();
    boolean defaultSelected=isDefaultSelected(object);
    Object key=getKey(object);
    Boolean previousException=exceptions.get(key);
    if (defaultSelected == selected) {
      if (previousException != null) {
        exceptions.remove(key);
        changed=true;
      }
    }
 else {
      if (previousException != Boolean.valueOf(selected)) {
        exceptions.put(key,selected);
        changed=true;
      }
    }
  }
  selectionChanges.clear();
  if (changed) {
    SelectionChangeEvent.fire(this);
  }
}","private void resolveChanges(){
  boolean changed=false;
  for (  Map.Entry<Object,SelectionChange<T>> entry : selectionChanges.entrySet()) {
    Object key=entry.getKey();
    SelectionChange<T> value=entry.getValue();
    T item=value.getItem();
    boolean selected=value.isSelected();
    boolean defaultSelected=isDefaultSelected(item);
    Boolean previousException=exceptions.get(key);
    if (defaultSelected == selected) {
      if (previousException != null) {
        exceptions.remove(key);
        changed=true;
      }
    }
 else {
      if (previousException != Boolean.valueOf(selected)) {
        exceptions.put(key,selected);
        changed=true;
      }
    }
  }
  selectionChanges.clear();
  if (changed) {
    SelectionChangeEvent.fire(this);
  }
}",0.7013513513513514
53637,"/** 
 * Constructs a DefaultSelectionModel with the given key provider.
 * @param keyProvider an instance of ProvidesKey<T>, or null if the recordobject should act as its own key
 */
public DefaultSelectionModel(ProvidesKey<T> keyProvider){
  super(keyProvider);
}","/** 
 * Constructs a DefaultSelectionModel with the given key provider.
 * @param keyProvider an instance of ProvidesKey<T>, or null if the itemshould act as its own key
 */
public DefaultSelectionModel(ProvidesKey<T> keyProvider){
  super(keyProvider);
}",0.9672447013487476
53638,"@Override public void setSelected(T object,boolean selected){
  selectionChanges.put(object,selected);
  scheduleSelectionChangeEvent();
}","@Override public void setSelected(T item,boolean selected){
  selectionChanges.put(getKey(item),new SelectionChange<T>(item,selected));
  scheduleSelectionChangeEvent();
}",0.8414239482200647
53639,"/** 
 * Construct a MultiSelectionModel with the given key provider and implementations of selectedSet and selectionChanges. Different implementations allow for enforcing order on selection.
 * @param keyProvider an instance of ProvidesKey<T>, or null if the recordobject should act as its own key
 * @param selectedSet an instance of Map
 * @param selectionChanges an instance of Map
 */
MultiSelectionModel(ProvidesKey<T> keyProvider,Map<Object,T> selectedSet,Map<T,Boolean> selectionChanges){
  super(keyProvider);
  this.selectedSet=selectedSet;
  this.selectionChanges=selectionChanges;
}","/** 
 * Construct a MultiSelectionModel with the given key provider and implementations of selectedSet and selectionChanges. Different implementations allow for enforcing order on selection.
 * @param keyProvider an instance of ProvidesKey<T>, or null if the itemshould act as its own key
 * @param selectedSet an instance of Map
 * @param selectionChanges an instance of Map
 */
MultiSelectionModel(ProvidesKey<T> keyProvider,Map<Object,T> selectedSet,Map<Object,SelectionChange<T>> selectionChanges){
  super(keyProvider);
  this.selectedSet=selectedSet;
  this.selectionChanges=selectionChanges;
}",0.958927074601844
53640,"/** 
 * Deselect all selected values.
 */
public void clear(){
  selectionChanges.clear();
  for (  T value : selectedSet.values()) {
    selectionChanges.put(value,false);
  }
  scheduleSelectionChangeEvent();
}","/** 
 * Deselect all selected values.
 */
public void clear(){
  selectionChanges.clear();
  for (  T value : selectedSet.values()) {
    selectionChanges.put(getKey(value),new SelectionChange<T>(value,false));
  }
  scheduleSelectionChangeEvent();
}",0.9177489177489178
53641,"@Override public boolean isSelected(T object){
  resolveChanges();
  return selectedSet.containsKey(getKey(object));
}","@Override public boolean isSelected(T item){
  resolveChanges();
  return selectedSet.containsKey(getKey(item));
}",0.9310344827586208
53642,"void resolveChanges(){
  if (selectionChanges.isEmpty()) {
    return;
  }
  boolean changed=false;
  for (  Map.Entry<T,Boolean> entry : selectionChanges.entrySet()) {
    T object=entry.getKey();
    boolean selected=entry.getValue();
    Object key=getKey(object);
    T oldValue=selectedSet.get(key);
    if (selected) {
      selectedSet.put(key,object);
      Object oldKey=getKey(oldValue);
      if (!changed) {
        changed=(oldKey == null) ? (key != null) : !oldKey.equals(key);
      }
    }
 else {
      if (oldValue != null) {
        selectedSet.remove(key);
        changed=true;
      }
    }
  }
  selectionChanges.clear();
  if (changed) {
    SelectionChangeEvent.fire(this);
  }
}","void resolveChanges(){
  if (selectionChanges.isEmpty()) {
    return;
  }
  boolean changed=false;
  for (  Map.Entry<Object,SelectionChange<T>> entry : selectionChanges.entrySet()) {
    Object key=entry.getKey();
    SelectionChange<T> value=entry.getValue();
    boolean selected=value.isSelected;
    T oldValue=selectedSet.get(key);
    if (selected) {
      selectedSet.put(key,value.item);
      Object oldKey=getKey(oldValue);
      if (!changed) {
        changed=(oldKey == null) ? (key != null) : !oldKey.equals(key);
      }
    }
 else {
      if (oldValue != null) {
        selectedSet.remove(key);
        changed=true;
      }
    }
  }
  selectionChanges.clear();
  if (changed) {
    SelectionChangeEvent.fire(this);
  }
}",0.656984785615491
53643,"/** 
 * Get the set of selected items as a copy.
 * @return the set of selected items
 */
public Set<T> getSelectedSet(){
  resolveChanges();
  return new HashSet<T>(selectedSet.values());
}","/** 
 * Get the set of selected items as a copy. If multiple selected items share the same key, only the last selected item is included in the set.
 * @return the set of selected items
 */
public Set<T> getSelectedSet(){
  resolveChanges();
  return new HashSet<T>(selectedSet.values());
}",0.7933194154488518
53644,"/** 
 * Gets the object that was last selected.
 * @return the last selected object
 */
public T getLastSelectedObject(){
  return lastSelection;
}","/** 
 * Gets the item that was last selected.
 * @return the last selected item
 */
public T getLastSelectedObject(){
  return lastSelection;
}",0.9448275862068966
53645,"public void setSelected(T object,boolean selected){
  Object key=getKey(object);
  if (selected) {
    lastSelection=object;
    lastKey=key;
  }
 else   if (lastKey != null && lastKey.equals(key)) {
    lastSelection=null;
    lastKey=null;
  }
  scheduleSelectionChangeEvent();
}","@Override public void setSelected(T item,boolean selected){
  Object key=getKey(item);
  if (selected) {
    lastSelection=item;
    lastKey=key;
  }
 else   if (lastKey != null && lastKey.equals(key)) {
    lastSelection=null;
    lastKey=null;
  }
  scheduleSelectionChangeEvent();
}",0.9293286219081272
53646,"/** 
 * Constructs a NoSelectionModel with the given key provider.
 * @param keyProvider an instance of ProvidesKey<T>, or null if the recordobject should act as its own key
 */
public NoSelectionModel(ProvidesKey<T> keyProvider){
  super(keyProvider);
}","/** 
 * Constructs a NoSelectionModel with the given key provider.
 * @param keyProvider an instance of ProvidesKey<T>, or null if the itemshould act as its own key
 */
public NoSelectionModel(ProvidesKey<T> keyProvider){
  super(keyProvider);
}",0.9659318637274548
53647,"public boolean isSelected(T object){
  return false;
}","@Override public boolean isSelected(T item){
  return false;
}",0.8448275862068966
53648,"public native void selectRemoveOption(SelectElement select,int index);","@Override public native void selectRemoveOption(SelectElement select,int index);",0.9333333333333332
53649,"public int getScrollLeft(Element elem){
  int left=getScrollLeftImpl(elem);
  if (isRTL(elem)) {
    left=-left;
  }
  return left;
}","@Override public int getScrollLeft(Element elem){
  int left=getScrollLeftImpl(elem);
  if (isRTL(elem)) {
    left=-left;
  }
  return left;
}",0.9637681159420288
53650,"/** 
 * Get the z-index css property.
 */
public final String getZIndex(){
  return getProperty(STYLE_Z_INDEX);
}","/** 
 * Get the z-index css property.
 */
public final String getZIndex(){
  return DOMImpl.impl.getNumericStyleProperty(this,STYLE_Z_INDEX);
}",0.8828125
53651,"/** 
 * Gets the value of a named property.
 */
private native String getPropertyImpl(String name);","/** 
 * Gets the value of a named property.
 */
private String getPropertyImpl(String name){
  return DOMImpl.impl.getStyleProperty(this,name);
}",0.7540983606557377
53652,"/** 
 * Does all of the work necessary to do the dispatch to the appropriate variant of   {@link JavaScriptHost#invokeNativeVoid JavaScriptHost.invokeNative*}. And example output: <pre> return JavaScriptHost.invokeNativeInt( ""@com.google.gwt.sample.hello.client.Hello::echo(I)"", null, new Class[] {int.class,}, new Object[] {x,}); </pre>
 */
@Override public void visitCode(){
  super.visitCode();
  String jsniTarget=getJsniSignature(name,descriptor);
  visitLdcInsn(jsniTarget);
  if (isStatic) {
    visitInsn(Opcodes.ACONST_NULL);
  }
 else {
    loadThis();
    visitMethodInsn(Opcodes.INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  loadClassArray();
  loadArgArray();
  Type returnType=Type.getReturnType(descriptor);
  JavaScriptHostInfo info=JavaScriptHostInfo.get(returnType.getSort());
  invokeStatic(JavaScriptHostInfo.TYPE,info.getMethod());
  if (info.requiresCast()) {
    checkCast(returnType);
  }
  returnValue();
}","/** 
 * Does all of the work necessary to do the dispatch to the appropriate variant of   {@link JavaScriptHost#invokeNativeVoid JavaScriptHost.invokeNative*}. And example output: <pre> return JavaScriptHost.invokeNativeInt( ""@com.google.gwt.sample.hello.client.Hello::echo(I)"", null, new Class[] {int.class,}, new Object[] {x,}); </pre>
 */
@Override public void visitCode(){
  super.visitCode();
  String jsniTarget=getJsniSignature(name,descriptor);
  visitLdcInsn(jsniTarget);
  if (isStatic) {
    visitInsn(Opcodes.ACONST_NULL);
  }
 else {
    loadThis();
  }
  loadClassArray();
  loadArgArray();
  Type returnType=Type.getReturnType(descriptor);
  JavaScriptHostInfo info=JavaScriptHostInfo.get(returnType.getSort());
  invokeStatic(JavaScriptHostInfo.TYPE,info.getMethod());
  if (info.requiresCast()) {
    checkCast(returnType);
  }
  returnValue();
}",0.9467910038398244
53653,"/** 
 * Verify that the given widget is not statically positioned on the page (relative to the document window), unless the widget is in fact directly attached to the document BODY. Note that the current use of this method is not comprehensive, since we can only verify the offsetParent if both parent (AbsolutePanel) and child widget are both visible and attached to the DOM when this test is executed.
 * @param child the widget whose position and placement should be tested
 */
private void verifyPositionNotStatic(Widget child){
  if (GWT.isProdMode()) {
    return;
  }
  if (child.getElement().getOffsetParent() == null) {
    return;
  }
  if (child.getElement().getOffsetParent() == getElement()) {
    return;
  }
  if (""String_Node_Str"".equals(getElement().getNodeName().toLowerCase())) {
    return;
  }
  String className=getClass().getName();
  GWT.log(""String_Node_Str"" + className + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",new IllegalStateException(className + ""String_Node_Str""));
}","/** 
 * Verify that the given widget is not statically positioned on the page (relative to the document window), unless the widget is in fact directly attached to the document BODY. Note that the current use of this method is not comprehensive, since we can only verify the offsetParent if both parent (AbsolutePanel) and child widget are both visible and attached to the DOM when this test is executed.
 * @param child the widget whose position and placement should be tested
 */
private void verifyPositionNotStatic(Widget child){
  if (GWT.isProdMode()) {
    return;
  }
  if (!isAttached()) {
    return;
  }
  if (child.getElement().getOffsetParent() == null) {
    return;
  }
  if (child.getElement().getOffsetParent() == getElement()) {
    return;
  }
  if (""String_Node_Str"".equals(getElement().getNodeName().toLowerCase())) {
    return;
  }
  String className=getClass().getName();
  GWT.log(""String_Node_Str"" + className + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",new IllegalStateException(className + ""String_Node_Str""));
}",0.9818012132524498
53654,"/** 
 * Does all of the work necessary to do the dispatch to the appropriate variant of   {@link JavaScriptHost#invokeNativeVoid JavaScriptHost.invokeNative*}. And example output: <pre> return JavaScriptHost.invokeNativeInt( ""@com.google.gwt.sample.hello.client.Hello::echo(I)"", null, new Class[] {int.class,}, new Object[] {x,}); </pre>
 */
@Override public void visitCode(){
  super.visitCode();
  String jsniTarget=getJsniSignature(name,descriptor);
  visitLdcInsn(jsniTarget);
  if (isStatic) {
    visitInsn(Opcodes.ACONST_NULL);
  }
 else {
    loadThis();
  }
  loadClassArray();
  loadArgArray();
  Type returnType=Type.getReturnType(descriptor);
  JavaScriptHostInfo info=JavaScriptHostInfo.get(returnType.getSort());
  invokeStatic(JavaScriptHostInfo.TYPE,info.getMethod());
  if (info.requiresCast()) {
    checkCast(returnType);
  }
  returnValue();
}","/** 
 * Does all of the work necessary to do the dispatch to the appropriate variant of   {@link JavaScriptHost#invokeNativeVoid JavaScriptHost.invokeNative*}. And example output: <pre> return JavaScriptHost.invokeNativeInt( ""@com.google.gwt.sample.hello.client.Hello::echo(I)"", null, new Class[] {int.class,}, new Object[] {x,}); </pre>
 */
@Override public void visitCode(){
  super.visitCode();
  String jsniTarget=getJsniSignature(name,descriptor);
  visitLdcInsn(jsniTarget);
  if (isStatic) {
    visitInsn(Opcodes.ACONST_NULL);
  }
 else {
    loadThis();
    visitMethodInsn(Opcodes.INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  loadClassArray();
  loadArgArray();
  Type returnType=Type.getReturnType(descriptor);
  JavaScriptHostInfo info=JavaScriptHostInfo.get(returnType.getSort());
  invokeStatic(JavaScriptHostInfo.TYPE,info.getMethod());
  if (info.requiresCast()) {
    checkCast(returnType);
  }
  returnValue();
}",0.9467910038398244
53655,"/** 
 * Creates a   {@link CellWidget} with the specified cell, initial value, keyprovider, using the specified element as the wrapper around the cell.
 * @param cell the cell to wrap
 * @param initialValue the initial value of the Cell
 * @param keyProvider the key provider used to get keys from values
 * @param elem the browser element to use
 */
protected CellWidget(Cell<C> cell,C initialValue,ProvidesKey<C> keyProvider,Element elem){
  this.cell=cell;
  this.keyProvider=keyProvider;
  setElement(elem);
  CellBasedWidgetImpl.get().sinkEvents(this,cell.getConsumedEvents());
  setValue(initialValue);
}","/** 
 * Creates a   {@link CellWidget} with the specified cell, initial value, keyprovider, using the specified element as the wrapper around the cell.
 * @param cell the cell to wrap
 * @param initialValue the initial value of the Cell
 * @param keyProvider the key provider used to get keys from values
 * @param elem the browser element to use
 */
protected CellWidget(Cell<C> cell,C initialValue,ProvidesKey<C> keyProvider,Element elem){
  this.cell=cell;
  this.keyProvider=keyProvider;
  setElement(elem);
  CellBasedWidgetImpl.get().sinkEvents(this,cell.getConsumedEvents());
  this.value=initialValue;
  redraw();
}",0.9651257096512572
53656,"public ProvidesKey<C> getKeyProvider(){
  return keyProvider;
}","@Override public ProvidesKey<C> getKeyProvider(){
  return keyProvider;
}",0.9264705882352942
53657,"public void update(C value){
  setValue(value,true,false);
}","@Override public void update(C value){
  setValue(value,true,false);
}",0.9230769230769232
53658,"public LeafValueEditor<C> asEditor(){
  if (editor == null) {
    editor=TakesValueEditor.of(this);
  }
  return editor;
}","@Override public LeafValueEditor<C> asEditor(){
  if (editor == null) {
    editor=TakesValueEditor.of(this);
  }
  return editor;
}",0.9606299212598424
53659,"public HandlerRegistration addValueChangeHandler(ValueChangeHandler<C> handler){
  return addHandler(handler,ValueChangeEvent.getType());
}","@Override public HandlerRegistration addValueChangeHandler(ValueChangeHandler<C> handler){
  return addHandler(handler,ValueChangeEvent.getType());
}",0.9652777777777778
53660,"public C getValue(){
  return value;
}","@Override public C getValue(){
  return value;
}",0.8837209302325582
53661,"public Object getKey(String item){
  return (item == null) ? null : item.substring(0,1);
}","@Override public Object getKey(String item){
  return (item == null) ? null : item.substring(0,1);
}",0.9473684210526316
53662,"public void onValueChange(ValueChangeEvent<C> event){
  assertFalse(""String_Node_Str"",onValueChangeCalled);
  onValueChangeCalled=true;
  lastValue=event.getValue();
}","@Override public void onValueChange(ValueChangeEvent<C> event){
  assertFalse(""String_Node_Str"",onValueChangeCalled);
  onValueChangeCalled=true;
  lastValue=event.getValue();
}",0.9709302325581396
53663,"public void testOnBrowserEventWithKeyProvider(){
  ProvidesKey<String> keyProvider=new ProvidesKey<String>(){
    public Object getKey(    String item){
      return (item == null) ? null : item.substring(0,1);
    }
  }
;
  CustomCell cell=new CustomCell();
  final CellWidget<String> cw=new CellWidget<String>(cell,""String_Node_Str"",keyProvider);
  assertEquals(""String_Node_Str"",cw.getValue());
  assertEquals(keyProvider,cw.getKeyProvider());
  Event event=Document.get().createChangeEvent().cast();
  cw.onBrowserEvent(event);
  cell.assertLastEventKey(""String_Node_Str"");
  cell.assertLastEventValue(""String_Node_Str"");
  assertEquals(""String_Node_Str"",cw.getValue());
}","public void testOnBrowserEventWithKeyProvider(){
  ProvidesKey<String> keyProvider=new ProvidesKey<String>(){
    @Override public Object getKey(    String item){
      return (item == null) ? null : item.substring(0,1);
    }
  }
;
  CustomCell cell=new CustomCell();
  final CellWidget<String> cw=new CellWidget<String>(cell,""String_Node_Str"",keyProvider);
  assertEquals(""String_Node_Str"",cw.getValue());
  assertEquals(keyProvider,cw.getKeyProvider());
  Event event=Document.get().createChangeEvent().cast();
  cw.onBrowserEvent(event);
  cell.assertLastEventKey(""String_Node_Str"");
  cell.assertLastEventValue(""String_Node_Str"");
  assertEquals(""String_Node_Str"",cw.getValue());
}",0.9926578560939796
53664,"public void testSetValue(){
  CustomCell cell=new CustomCell();
  CellWidget<String> cw=new CellWidget<String>(cell,""String_Node_Str"");
  MockValueChangeHandler<String> handler=new MockValueChangeHandler<String>();
  cw.addValueChangeHandler(handler);
  assertEquals(""String_Node_Str"",cw.getValue());
  assertEquals(""String_Node_Str"",cw.getElement().getInnerText());
  cw.setValue(""String_Node_Str"");
  assertEquals(""String_Node_Str"",cw.getValue());
  assertEquals(""String_Node_Str"",cw.getElement().getInnerText());
  handler.assertOnValueChangeNotCalled();
  cw.setValue(""String_Node_Str"",true);
  handler.assertOnValueChangeNotCalled();
  cw.setValue(""String_Node_Str"",true);
  assertEquals(""String_Node_Str"",cw.getValue());
  assertEquals(""String_Node_Str"",cw.getElement().getInnerText());
  handler.assertLastValue(""String_Node_Str"");
  cw.setValue(""String_Node_Str"",true,false);
  assertEquals(""String_Node_Str"",cw.getValue());
  assertEquals(""String_Node_Str"",cw.getElement().getInnerText());
  handler.assertLastValue(""String_Node_Str"");
}","public void testSetValue(){
  CustomCell cell=new CustomCell();
  CellWidget<String> cw=new CellWidget<String>(cell,""String_Node_Str"");
  MockValueChangeHandler<String> handler=new MockValueChangeHandler<String>();
  cw.addValueChangeHandler(handler);
  assertEquals(""String_Node_Str"",cw.getValue());
  assertEquals(""String_Node_Str"",cw.getElement().getInnerText());
  cell.assertLastRenderedValue(""String_Node_Str"");
  cw.setValue(""String_Node_Str"");
  assertEquals(""String_Node_Str"",cw.getValue());
  assertEquals(""String_Node_Str"",cw.getElement().getInnerText());
  cell.assertLastRenderedValue(""String_Node_Str"");
  handler.assertOnValueChangeNotCalled();
  cw.setValue(""String_Node_Str"",true);
  handler.assertOnValueChangeNotCalled();
  cw.setValue(""String_Node_Str"",true);
  assertEquals(""String_Node_Str"",cw.getValue());
  assertEquals(""String_Node_Str"",cw.getElement().getInnerText());
  cell.assertLastRenderedValue(""String_Node_Str"");
  handler.assertLastValue(""String_Node_Str"");
  cw.setValue(""String_Node_Str"",true,false);
  assertEquals(""String_Node_Str"",cw.getValue());
  assertEquals(""String_Node_Str"",cw.getElement().getInnerText());
  handler.assertLastValue(""String_Node_Str"");
}",0.93184855233853
53665,"@Override public void render(com.google.gwt.cell.client.Cell.Context context,String value,SafeHtmlBuilder sb){
  sb.appendHtmlConstant(""String_Node_Str"").appendEscaped(value).appendHtmlConstant(""String_Node_Str"");
  sb.appendHtmlConstant(""String_Node_Str"");
}","@Override public void render(com.google.gwt.cell.client.Cell.Context context,String value,SafeHtmlBuilder sb){
  if (value != null) {
    sb.appendHtmlConstant(""String_Node_Str"").appendEscaped(value).appendHtmlConstant(""String_Node_Str"");
    sb.appendHtmlConstant(""String_Node_Str"");
  }
}",0.9435336976320584
53666,"/** 
 * Test that a cell that defines an HTML elment can be rendered.
 */
public void testRedrawWithMultipleInnerChildren(){
  Cell<String> cell=new AbstractCell<String>(){
    @Override public void render(    com.google.gwt.cell.client.Cell.Context context,    String value,    SafeHtmlBuilder sb){
      sb.appendHtmlConstant(""String_Node_Str"").appendEscaped(value).appendHtmlConstant(""String_Node_Str"");
      sb.appendHtmlConstant(""String_Node_Str"");
    }
  }
;
  CellWidget<String> cw=new CellWidget<String>(cell);
  cw.setValue(""String_Node_Str"",false,false);
  assertEquals(""String_Node_Str"",cw.getElement().getInnerText());
  cw.redraw();
  assertTrue(cw.getElement().getInnerText().contains(""String_Node_Str""));
  Style firstChildStyle=cw.getElement().getFirstChildElement().getStyle();
  assertFalse(firstChildStyle.getHeight().matches(""String_Node_Str""));
  assertFalse(firstChildStyle.getWidth().matches(""String_Node_Str""));
}","/** 
 * Test that a cell that defines an HTML elment can be rendered.
 */
public void testRedrawWithMultipleInnerChildren(){
  Cell<String> cell=new AbstractCell<String>(){
    @Override public void render(    com.google.gwt.cell.client.Cell.Context context,    String value,    SafeHtmlBuilder sb){
      if (value != null) {
        sb.appendHtmlConstant(""String_Node_Str"").appendEscaped(value).appendHtmlConstant(""String_Node_Str"");
        sb.appendHtmlConstant(""String_Node_Str"");
      }
    }
  }
;
  CellWidget<String> cw=new CellWidget<String>(cell);
  cw.setValue(""String_Node_Str"",false,false);
  assertEquals(""String_Node_Str"",cw.getElement().getInnerText());
  cw.redraw();
  assertTrue(cw.getElement().getInnerText().contains(""String_Node_Str""));
  Style firstChildStyle=cw.getElement().getFirstChildElement().getStyle();
  assertFalse(firstChildStyle.getHeight().matches(""String_Node_Str""));
  assertFalse(firstChildStyle.getWidth().matches(""String_Node_Str""));
}",0.9796557120500784
53667,"public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AuthorTest.class);
  return suite;
}","public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AuthorTest.class);
  suite.addTestSuite(BookTest.class);
  return suite;
}",0.8827160493827161
53668,"private SourceMapping loadSourceMap(String permutationStrongName,int fragmentId){
  SourceMapping toReturn=sourceMaps.get(permutationStrongName + fragmentId);
  if (toReturn == null) {
    try {
      SourceMapConsumerV3 consumer=new SourceMapConsumerV3();
      String sourceMapString=loadStreamAsString(getSourceMapInputStream(permutationStrongName,fragmentId));
      JSONObject obj=new JSONObject(sourceMapString);
      toReturn=SourceMapConsumerFactory.parse(sourceMapString);
      sourceMaps.put(permutationStrongName + fragmentId,toReturn);
    }
 catch (    Exception e) {
    }
  }
  return toReturn;
}","private SourceMapping loadSourceMap(String permutationStrongName,int fragmentId){
  SourceMapping toReturn=sourceMaps.get(permutationStrongName + fragmentId);
  if (toReturn == null) {
    try {
      String sourceMapString=loadStreamAsString(getSourceMapInputStream(permutationStrongName,fragmentId));
      toReturn=SourceMapConsumerFactory.parse(sourceMapString);
      sourceMaps.put(permutationStrongName + fragmentId,toReturn);
    }
 catch (    Exception e) {
    }
  }
  return toReturn;
}",0.8954954954954955
53669,"/** 
 * Best effort resymbolization of a a single stack trace element.
 * @param ste        the stack trace element to resymbolize
 * @param strongName the GWT permutation strong name
 * @return the best effort resymbolized stack trace element
 */
public StackTraceElement resymbolize(StackTraceElement ste,String strongName){
  String declaringClass=null;
  String methodName=null;
  String filename=null;
  int lineNumber=-1;
  int fragmentId=-1;
  String steFilename=ste.getFileName();
  SymbolMap map=loadSymbolMap(strongName);
  String symbolData=map == null ? null : map.get(ste.getMethodName());
  if (symbolData != null) {
    String[] parts=symbolData.split(""String_Node_Str"");
    if (parts.length == 6) {
      String[] ref=parse(parts[0].substring(0,parts[0].lastIndexOf(')') + 1));
      if (ref != null) {
        declaringClass=ref[0];
        methodName=ref[1];
      }
 else {
        declaringClass=ste.getClassName();
        methodName=ste.getMethodName();
      }
      filename=""String_Node_Str"".equals(parts[3]) ? null : parts[3].substring(parts[3].lastIndexOf('/') + 1);
      lineNumber=ste.getLineNumber();
      if (lineNumber == LINE_NUMBER_UNKNOWN) {
        lineNumber=Integer.parseInt(parts[4]);
      }
      fragmentId=Integer.parseInt(parts[5]);
    }
  }
  int column=1;
  if (steFilename != null) {
    int columnMarkerIndex=steFilename.indexOf(""String_Node_Str"");
    if (columnMarkerIndex != -1) {
      try {
        column=Integer.parseInt(steFilename.substring(columnMarkerIndex + 1));
      }
 catch (      NumberFormatException nfe) {
      }
      steFilename=steFilename.substring(0,columnMarkerIndex);
    }
  }
  if (fragmentId == -1 && steFilename != null) {
    Matcher matcher=fragmentIdPattern.matcher(steFilename);
    if (matcher.matches()) {
      String fragment=matcher.group(1);
      try {
        fragmentId=Integer.parseInt(fragment);
      }
 catch (      Exception e) {
      }
    }
 else     if (steFilename.contains(strongName)) {
      fragmentId=0;
    }
  }
  int jsLineNumber=ste.getLineNumber();
  if (fragmentId != -1) {
    SourceMapping sourceMapping=loadSourceMap(strongName,fragmentId);
    if (sourceMapping != null && ste.getLineNumber() > -1) {
      Mapping.OriginalMapping mappingForLine=sourceMapping.getMappingForLine(jsLineNumber,column);
      if (mappingForLine != null) {
        if (declaringClass == null || declaringClass.equals(ste.getClassName())) {
          declaringClass=mappingForLine.getOriginalFile();
          methodName=mappingForLine.getIdentifier();
        }
        filename=mappingForLine.getOriginalFile();
        lineNumber=mappingForLine.getLineNumber() - 1;
      }
    }
  }
  if (declaringClass != null) {
    return new StackTraceElement(declaringClass,methodName,filename,lineNumber);
  }
  return ste;
}","/** 
 * Best effort resymbolization of a a single stack trace element.
 * @param ste        the stack trace element to resymbolize
 * @param strongName the GWT permutation strong name
 * @return the best effort resymbolized stack trace element
 */
public StackTraceElement resymbolize(StackTraceElement ste,String strongName){
  String declaringClass=null;
  String methodName=null;
  String filename=null;
  int lineNumber=-1;
  int fragmentId=-1;
  String steFilename=ste.getFileName();
  SymbolMap map=loadSymbolMap(strongName);
  String symbolData=map == null ? null : map.get(ste.getMethodName());
  if (symbolData != null) {
    String[] parts=symbolData.split(""String_Node_Str"");
    if (parts.length == 6) {
      String[] ref=parse(parts[0].substring(0,parts[0].lastIndexOf(')') + 1));
      if (ref != null) {
        declaringClass=ref[0];
        methodName=ref[1];
      }
 else {
        declaringClass=ste.getClassName();
        methodName=ste.getMethodName();
      }
      filename=""String_Node_Str"".equals(parts[3]) ? null : parts[3].substring(parts[3].lastIndexOf('/') + 1);
      lineNumber=ste.getLineNumber();
      if (lineNumber == LINE_NUMBER_UNKNOWN) {
        lineNumber=Integer.parseInt(parts[4]);
      }
      fragmentId=Integer.parseInt(parts[5]);
    }
  }
  int column=1;
  if (steFilename != null) {
    int columnMarkerIndex=steFilename.indexOf(""String_Node_Str"");
    if (columnMarkerIndex != -1) {
      try {
        column=Integer.parseInt(steFilename.substring(columnMarkerIndex + 1));
      }
 catch (      NumberFormatException nfe) {
      }
      steFilename=steFilename.substring(0,columnMarkerIndex);
    }
  }
  if (fragmentId == -1 && steFilename != null) {
    Matcher matcher=fragmentIdPattern.matcher(steFilename);
    if (matcher.matches()) {
      String fragment=matcher.group(1);
      try {
        fragmentId=Integer.parseInt(fragment);
      }
 catch (      Exception e) {
      }
    }
 else     if (steFilename.contains(strongName)) {
      fragmentId=0;
    }
  }
  int jsLineNumber=ste.getLineNumber();
  if (fragmentId != -1) {
    SourceMapping sourceMapping=loadSourceMap(strongName,fragmentId);
    if (sourceMapping != null && ste.getLineNumber() > -1) {
      Mapping.OriginalMapping mappingForLine=sourceMapping.getMappingForLine(jsLineNumber,column);
      if (mappingForLine != null) {
        if (declaringClass == null || declaringClass.equals(ste.getClassName())) {
          declaringClass=mappingForLine.getOriginalFile();
          methodName=mappingForLine.getIdentifier();
        }
        filename=mappingForLine.getOriginalFile();
        lineNumber=mappingForLine.getLineNumber();
      }
    }
  }
  if (declaringClass != null) {
    return new StackTraceElement(declaringClass,methodName,filename,lineNumber);
  }
  return ste;
}",0.9992900248491304
53670,"public static void recordSourceMap(List<Map<Range,SourceInfo>> sourceInfoMaps,List<SyntheticArtifact> artifacts,int permutationId){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  SourceMapGenerator generator=SourceMapGeneratorFactory.getInstance(SourceMapFormat.V3);
  OutputStreamWriter out=new OutputStreamWriter(baos);
  int fragment=0;
  if (!sourceInfoMaps.isEmpty()) {
    for (    Map<Range,SourceInfo> sourceMap : sourceInfoMaps) {
      generator.reset();
      Set<Range> rangeSet=sourceMap.keySet();
      Range[] ranges=rangeSet.toArray(new Range[rangeSet.size()]);
      Arrays.sort(ranges,Range.DEPENDENCY_ORDER_COMPARATOR);
      for (      Range r : ranges) {
        SourceInfo si=sourceMap.get(r);
        if (si.getFileName() == null || si.getStartLine() < 0) {
          continue;
        }
        if (r.getStartLine() == 0 || r.getEndLine() == 0) {
          continue;
        }
        generator.addMapping(si.getFileName(),null,new FilePosition(si.getStartLine(),0),new FilePosition(r.getStartLine(),r.getStartColumn()),new FilePosition(r.getEndLine(),r.getEndColumn()));
      }
      try {
        baos.reset();
        generator.appendTo(out,""String_Node_Str"" + fragment);
        out.flush();
        artifacts.add(new SymbolMapsLinker.SourceMapArtifact(permutationId,fragment,baos.toByteArray()));
        fragment++;
      }
 catch (      IOException e) {
        throw new InternalCompilerException(e.toString(),e);
      }
    }
  }
}","public static void recordSourceMap(List<Map<Range,SourceInfo>> sourceInfoMaps,List<SyntheticArtifact> artifacts,int permutationId){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  SourceMapGenerator generator=SourceMapGeneratorFactory.getInstance(SourceMapFormat.V3);
  OutputStreamWriter out=new OutputStreamWriter(baos);
  int fragment=0;
  if (!sourceInfoMaps.isEmpty()) {
    for (    Map<Range,SourceInfo> sourceMap : sourceInfoMaps) {
      generator.reset();
      Set<Range> rangeSet=sourceMap.keySet();
      Range[] ranges=rangeSet.toArray(new Range[rangeSet.size()]);
      Arrays.sort(ranges,Range.DEPENDENCY_ORDER_COMPARATOR);
      for (      Range r : ranges) {
        SourceInfo si=sourceMap.get(r);
        if (si.getFileName() == null || si.getStartLine() < 0) {
          continue;
        }
        if (r.getStartLine() == 0 || r.getEndLine() == 0) {
          continue;
        }
        generator.addMapping(si.getFileName(),null,new FilePosition(si.getStartLine() - 1,0),new FilePosition(r.getStartLine(),r.getStartColumn()),new FilePosition(r.getEndLine(),r.getEndColumn()));
      }
      try {
        baos.reset();
        generator.appendTo(out,""String_Node_Str"" + fragment);
        out.flush();
        artifacts.add(new SymbolMapsLinker.SourceMapArtifact(permutationId,fragment,baos.toByteArray()));
        fragment++;
      }
 catch (      IOException e) {
        throw new InternalCompilerException(e.toString(),e);
      }
    }
  }
}",0.99864956110736
53671,"public ImageResource cellListSelectedBackground(){
  return delegate.cellBrowserSelectedBackground();
}","@Override public ImageResource cellListSelectedBackground(){
  return delegate.cellBrowserSelectedBackground();
}",0.9537037037037036
53672,"public String getName(){
  return delegate.getName();
}","@Override public String getName(){
  return delegate.getName();
}",0.9166666666666666
53673,"public void onValueChange(ValueChangeEvent<List<C>> event){
  Object focusedKey=display.focusedKey;
  if (focusedKey != null) {
    boolean stillExists=false;
    List<C> displayValues=event.getValue();
    for (    C displayValue : displayValues) {
      if (focusedKey.equals(display.getValueKey(displayValue))) {
        stillExists=true;
        break;
      }
    }
    if (!stillExists) {
      trimToLevel(display.level);
    }
  }
}","@Override public void onValueChange(ValueChangeEvent<List<C>> event){
  Object focusedKey=display.focusedKey;
  if (focusedKey != null) {
    boolean stillExists=false;
    List<C> displayValues=event.getValue();
    for (    C displayValue : displayValues) {
      if (focusedKey.equals(display.getValueKey(displayValue))) {
        stillExists=true;
        break;
      }
    }
    if (!stillExists) {
      trimToLevel(display.level);
    }
  }
}",0.9887640449438202
53674,"public int getIndex(){
  assertNotDestroyed();
  TreeNodeImpl<?> parent=getParent();
  return (parent == null) ? 0 : parent.getOpenIndex();
}","@Override public int getIndex(){
  assertNotDestroyed();
  TreeNodeImpl<?> parent=getParent();
  return (parent == null) ? 0 : parent.getOpenIndex();
}",0.9657534246575342
53675,"public String cellListSelectedItem(){
  return delegate.cellBrowserSelectedItem();
}","@Override public String cellListSelectedItem(){
  return delegate.cellBrowserSelectedItem();
}",0.9438202247191012
53676,"public String cellListOddItem(){
  return delegate.cellBrowserOddItem();
}","@Override public String cellListOddItem(){
  return delegate.cellBrowserOddItem();
}",0.9367088607594936
53677,"public boolean isAnimationEnabled(){
  return isAnimationEnabled;
}","@Override public boolean isAnimationEnabled(){
  return isAnimationEnabled;
}",0.9305555555555556
53678,"public boolean isChildLeaf(int index){
  assertNotDestroyed();
  checkChildBounds(index);
  return isLeaf(getChildValue(index));
}","@Override public boolean isChildLeaf(int index){
  assertNotDestroyed();
  checkChildBounds(index);
  return isLeaf(getChildValue(index));
}",0.9629629629629628
53679,"public String cellListKeyboardSelectedItem(){
  return delegate.cellBrowserKeyboardSelectedItem();
}","@Override public String cellListKeyboardSelectedItem(){
  return delegate.cellBrowserKeyboardSelectedItem();
}",0.9523809523809524
53680,"public String getText(){
  return delegate.getText();
}","@Override public String getText(){
  return delegate.getText();
}",0.9166666666666666
53681,"public boolean isDestroyed(){
  if (nodeInfo != null) {
    TreeNodeImpl<?> parent=getParentImpl();
    if (parent != null && !parent.isDestroyed()) {
      parent.display.getPresenter().flush();
    }
  }
  return nodeInfo == null;
}","@Override public boolean isDestroyed(){
  if (nodeInfo != null) {
    TreeNodeImpl<?> parent=getParentImpl();
    if (parent != null && !parent.isDestroyed()) {
      parent.display.getPresenter().flush();
    }
  }
  return nodeInfo == null;
}",0.9790794979079498
53682,"/** 
 * Unregister the list view and remove it from the widget.
 */
private void destroy(){
  display.isDestroyed=true;
  valueChangeHandler.removeHandler();
  display.setSelectionModel(null);
  nodeInfo.unsetDataDisplay();
  getSplitLayoutPanel().remove(widget);
  nodeInfo=null;
}","/** 
 * Unregister the list view and remove it from the widget.
 */
private void destroy(){
  display.isDestroyed=true;
  valueChangeHandler.removeHandler();
  display.deselectValue();
  display.setSelectionModel(null);
  nodeInfo.unsetDataDisplay();
  getSplitLayoutPanel().remove(widget);
  nodeInfo=null;
}",0.9543147208121828
53683,"/** 
 * Create a   {@link HasData} that will display items. The {@link HasData} mustextend  {@link Widget}.
 * @param < C > the item type in the list view
 * @param nodeInfo the node info with child data
 * @param level the level of the list
 * @return the {@link HasData}
 */
private <C>BrowserCellList<C> createDisplay(NodeInfo<C> nodeInfo,int level){
  BrowserCellList<C> display=new BrowserCellList<C>(nodeInfo.getCell(),level,nodeInfo.getProvidesKey());
  display.setValueUpdater(nodeInfo.getValueUpdater());
  KeyboardSelectionPolicy keyboardPolicy=getKeyboardSelectionPolicyForLists();
  display.setKeyboardSelectionPolicy(keyboardPolicy);
  return display;
}","/** 
 * Create a   {@link HasData} that will display items. The {@link HasData} mustextend  {@link Widget}.
 * @param < C > the item type in the list view
 * @param nodeInfo the node info with child data
 * @param level the level of the list
 * @return the {@link HasData}
 */
private <C>BrowserCellList<C> createDisplay(NodeInfo<C> nodeInfo,int level){
  BrowserCellList<C> display=new BrowserCellList<C>(nodeInfo.getCell(),level,nodeInfo.getProvidesKey());
  display.setValueUpdater(nodeInfo.getValueUpdater());
  display.setKeyboardSelectionPolicy(KeyboardSelectionPolicy.ENABLED);
  return display;
}",0.8834645669291339
53684,"public String cellListWidget(){
  return null;
}","@Override public String cellListWidget(){
  return null;
}",0.9056603773584906
53685,"public int getChildCount(){
  assertNotDestroyed();
  return display.getPresenter().getVisibleItemCount();
}","@Override public int getChildCount(){
  assertNotDestroyed();
  return display.getPresenter().getVisibleItemCount();
}",0.9557522123893806
53686,"public void onResize(){
  getSplitLayoutPanel().onResize();
}","@Override public void onResize(){
  getSplitLayoutPanel().onResize();
}",0.9242424242424242
53687,"public String cellListEvenItem(){
  return delegate.cellBrowserEvenItem();
}","@Override public String cellListEvenItem(){
  return delegate.cellBrowserEvenItem();
}",0.9382716049382716
53688,"/** 
 * Construct a new   {@link TreeNodeImpl}.
 * @param nodeInfo the nodeInfo for the children nodes
 * @param value the value of the node
 * @param display the display associated with the node
 * @param widget the widget that wraps the display
 */
public TreeNodeImpl(final NodeInfo<C> nodeInfo,Object value,final BrowserCellList<C> display,Widget widget){
  this.display=display;
  this.nodeInfo=nodeInfo;
  this.value=value;
  this.widget=widget;
  valueChangeHandler=display.addValueChangeHandler(new ValueChangeHandler<List<C>>(){
    public void onValueChange(    ValueChangeEvent<List<C>> event){
      Object focusedKey=display.focusedKey;
      if (focusedKey != null) {
        boolean stillExists=false;
        List<C> displayValues=event.getValue();
        for (        C displayValue : displayValues) {
          if (focusedKey.equals(display.getValueKey(displayValue))) {
            stillExists=true;
            break;
          }
        }
        if (!stillExists) {
          trimToLevel(display.level);
        }
      }
    }
  }
);
}","/** 
 * Construct a new   {@link TreeNodeImpl}.
 * @param nodeInfo the nodeInfo for the children nodes
 * @param value the value of the node
 * @param display the display associated with the node
 * @param widget the widget that wraps the display
 */
public TreeNodeImpl(final NodeInfo<C> nodeInfo,Object value,final BrowserCellList<C> display,Widget widget){
  this.display=display;
  this.nodeInfo=nodeInfo;
  this.value=value;
  this.widget=widget;
  valueChangeHandler=display.addValueChangeHandler(new ValueChangeHandler<List<C>>(){
    @Override public void onValueChange(    ValueChangeEvent<List<C>> event){
      Object focusedKey=display.focusedKey;
      if (focusedKey != null) {
        boolean stillExists=false;
        List<C> displayValues=event.getValue();
        for (        C displayValue : displayValues) {
          if (focusedKey.equals(display.getValueKey(displayValue))) {
            stillExists=true;
            break;
          }
        }
        if (!stillExists) {
          trimToLevel(display.level);
        }
      }
    }
  }
);
}",0.9953007518796992
53689,"public C getChildValue(int index){
  assertNotDestroyed();
  checkChildBounds(index);
  return display.getVisibleItem(index);
}","@Override public C getChildValue(int index){
  assertNotDestroyed();
  checkChildBounds(index);
  return display.getVisibleItem(index);
}",0.9621212121212122
53690,"public TreeNode setChildOpen(int index,boolean open,boolean fireEvents){
  assertNotDestroyed();
  checkChildBounds(index);
  if (open) {
    display.getPresenter().setKeyboardSelectedRow(index,false,true);
    return updateChildState(display,fireEvents);
  }
 else {
    if (index == display.getKeyboardSelectedRow()) {
      display.getPresenter().clearKeyboardSelectedRowValue();
      updateChildState(display,fireEvents);
    }
    return null;
  }
}","@Override public TreeNode setChildOpen(int index,boolean open,boolean fireEvents){
  assertNotDestroyed();
  checkChildBounds(index);
  if (open) {
    display.getPresenter().setKeyboardSelectedRow(index,false,true);
    return updateChildState(display,fireEvents);
  }
 else {
    if (index == display.getKeyboardSelectedRow()) {
      display.getPresenter().clearKeyboardSelectedRowValue();
      updateChildState(display,fireEvents);
    }
    return null;
  }
}",0.9891304347826086
53691,"public boolean ensureInjected(){
  return delegate.ensureInjected();
}","@Override public boolean ensureInjected(){
  return delegate.ensureInjected();
}",0.9333333333333332
53692,"public TreeNodeImpl<?> getParent(){
  assertNotDestroyed();
  return getParentImpl();
}","@Override public TreeNodeImpl<?> getParent(){
  assertNotDestroyed();
  return getParentImpl();
}",0.9456521739130436
53693,"/** 
 * Update the state of a child node based on the keyboard selection of the specified   {@link BrowserCellList}. This method will open/close child  {@link TreeNode}s as needed.
 * @param cellList the CellList that changed state.
 * @param value the value to open
 * @param open true to open, false to close
 * @param fireEvents true to fireEvents
 * @return the open {@link TreeNode}, or null if not opened
 */
private <C>TreeNode updateChildState(BrowserCellList<C> cellList,boolean fireEvents){
  if (cellList.isDestroyed) {
    return null;
  }
  C newValue=cellList.getPresenter().getKeyboardSelectedRowValue();
  Object newKey=cellList.getValueKey(newValue);
  TreeNode closedNode=null;
  if (cellList.focusedKey != null && cellList.isFocusedOpen && !cellList.focusedKey.equals(newKey)) {
    closedNode=(treeNodes.size() > cellList.level + 1) ? treeNodes.get(cellList.level + 1) : null;
    trimToLevel(cellList.level);
  }
  TreeNode openNode=null;
  boolean justOpenedNode=false;
  if (newKey != null) {
    if (newKey.equals(cellList.focusedKey)) {
      openNode=cellList.isFocusedOpen ? treeNodes.get(cellList.level + 1) : null;
    }
 else {
      cellList.focusedKey=newKey;
      NodeInfo<?> childNodeInfo=isLeaf(newValue) ? null : getNodeInfo(newValue);
      if (childNodeInfo != null) {
        cellList.isFocusedOpen=true;
        justOpenedNode=true;
        openNode=appendTreeNode(childNodeInfo,newValue);
      }
    }
  }
  if (fireEvents) {
    if (closedNode != null) {
      CloseEvent.fire(this,closedNode);
    }
    if (openNode != null && justOpenedNode) {
      OpenEvent.fire(this,openNode);
    }
  }
  return (openNode == null || openNode.isDestroyed()) ? null : openNode;
}","/** 
 * Update the state of a child node based on the keyboard selection of the specified   {@link BrowserCellList}. This method will open/close child  {@link TreeNode}s as needed.
 * @param cellList the CellList that changed state.
 * @param fireEvents true to fireEvents
 * @return the open {@link TreeNode}, or null if not opened
 */
private <C>TreeNode updateChildState(BrowserCellList<C> cellList,boolean fireEvents){
  if (cellList.isDestroyed) {
    return null;
  }
  C newValue=cellList.getPresenter().getKeyboardSelectedRowValue();
  Object newKey=cellList.getValueKey(newValue);
  TreeNode closedNode=null;
  if (cellList.focusedKey != null && cellList.isFocusedOpen && !cellList.focusedKey.equals(newKey)) {
    closedNode=(treeNodes.size() > cellList.level + 1) ? treeNodes.get(cellList.level + 1) : null;
    trimToLevel(cellList.level);
  }
  TreeNode openNode=null;
  boolean justOpenedNode=false;
  if (newKey != null) {
    if (newKey.equals(cellList.focusedKey)) {
      openNode=cellList.isFocusedOpen ? treeNodes.get(cellList.level + 1) : null;
    }
 else {
      if (KeyboardSelectionPolicy.BOUND_TO_SELECTION == getKeyboardSelectionPolicy()) {
        cellList.setSelectedValue(newValue);
      }
      cellList.focusedKey=newKey;
      NodeInfo<?> childNodeInfo=isLeaf(newValue) ? null : getNodeInfo(newValue);
      if (childNodeInfo != null) {
        cellList.isFocusedOpen=true;
        justOpenedNode=true;
        openNode=appendTreeNode(childNodeInfo,newValue);
      }
    }
  }
  if (fireEvents) {
    if (closedNode != null) {
      CloseEvent.fire(this,closedNode);
    }
    if (openNode != null && justOpenedNode) {
      OpenEvent.fire(this,openNode);
    }
  }
  return (openNode == null || openNode.isDestroyed()) ? null : openNode;
}",0.937195296816748
53694,"public Object getValue(){
  return value;
}","@Override public Object getValue(){
  return value;
}",0.8958333333333334
53695,"public boolean isChildOpen(int index){
  assertNotDestroyed();
  checkChildBounds(index);
  return (display.focusedKey == null || !display.isFocusedOpen) ? false : display.focusedKey.equals(display.getValueKey(getChildValue(index)));
}","@Override public boolean isChildOpen(int index){
  assertNotDestroyed();
  checkChildBounds(index);
  return (display.focusedKey == null || !display.isFocusedOpen) ? false : display.focusedKey.equals(display.getValueKey(getChildValue(index)));
}",0.9791666666666666
53696,"public void setAnimationEnabled(boolean enable){
  this.isAnimationEnabled=enable;
}","@Override public void setAnimationEnabled(boolean enable){
  this.isAnimationEnabled=enable;
}",0.9438202247191012
53697,"public CellList.Style cellListStyle(){
  return style;
}","@Override public CellList.Style cellListStyle(){
  return style;
}",0.918032786885246
53698,"/** 
 * Resolve the pending state and push updates to the view.
 * @param modifiedRows the modified rows that need to be updated, or null ifnone. The modified rows may be mutated.
 * @return true if the state changed, false if not
 */
private boolean resolvePendingState(JsArrayInteger modifiedRows){
  pendingStateCommand=null;
  if (isResolvingState) {
    return false;
  }
  isResolvingState=true;
  if (pendingState == null) {
    isResolvingState=false;
    pendingStateLoop=0;
    return false;
  }
  pendingStateLoop++;
  if (pendingStateLoop > LOOP_MAXIMUM) {
    isResolvingState=false;
    pendingStateLoop=0;
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
  State<T> oldState=state;
  PendingState<T> pending=pendingState;
  state=pendingState;
  pendingState=null;
  if (modifiedRows == null) {
    modifiedRows=JavaScriptObject.createArray().cast();
  }
  int pageStart=pending.getPageStart();
  int pageSize=pending.getPageSize();
  int pageEnd=pageStart + pageSize;
  int rowDataCount=pending.getRowDataSize();
  pending.keyboardSelectedRow=Math.max(0,Math.min(pending.keyboardSelectedRow,rowDataCount - 1));
  if (KeyboardSelectionPolicy.DISABLED == keyboardSelectionPolicy) {
    pending.keyboardSelectedRow=0;
    pending.keyboardSelectedRowValue=null;
  }
 else   if (pending.keyboardSelectedRowChanged) {
    pending.keyboardSelectedRowValue=rowDataCount > 0 ? pending.getRowDataValue(pending.keyboardSelectedRow) : null;
  }
 else   if (pending.keyboardSelectedRowValue != null) {
    int bestMatchIndex=findIndexOfBestMatch(pending,pending.keyboardSelectedRowValue,pending.keyboardSelectedRow);
    if (bestMatchIndex >= 0) {
      pending.keyboardSelectedRow=bestMatchIndex;
      pending.keyboardSelectedRowValue=rowDataCount > 0 ? pending.getRowDataValue(pending.keyboardSelectedRow) : null;
    }
 else {
      pending.keyboardSelectedRow=0;
      pending.keyboardSelectedRowValue=null;
    }
  }
  try {
    if (KeyboardSelectionPolicy.BOUND_TO_SELECTION == keyboardSelectionPolicy && selectionModel != null && pending.viewTouched) {
      T oldValue=oldState.getSelectedValue();
      Object oldKey=getRowValueKey(oldValue);
      T newValue=rowDataCount > 0 ? pending.getRowDataValue(pending.getKeyboardSelectedRow()) : null;
      Object newKey=getRowValueKey(newValue);
      if (newKey != null) {
        boolean oldValueWasSelected=(oldValue == null) ? false : selectionModel.isSelected(oldValue);
        boolean newValueWasSelected=(newValue == null) ? false : selectionModel.isSelected(newValue);
        if (!newKey.equals(oldKey)) {
          if (oldValueWasSelected) {
            selectionModel.setSelected(oldValue,false);
          }
          pending.selectedValue=newValue;
          if (newValue != null && !newValueWasSelected) {
            selectionModel.setSelected(newValue,true);
          }
        }
 else         if (!newValueWasSelected) {
          pending.selectedValue=null;
        }
      }
      if (pendingState != null) {
        pendingState.selectedValue=pending.selectedValue;
      }
    }
  }
 catch (  RuntimeException e) {
    isResolvingState=false;
    pendingStateLoop=0;
    throw e;
  }
  boolean keyboardRowChanged=pending.keyboardSelectedRowChanged || (oldState.getKeyboardSelectedRow() != pending.keyboardSelectedRow) || (oldState.getKeyboardSelectedRowValue() == null && pending.keyboardSelectedRowValue != null);
  try {
    for (int i=pageStart; i < pageStart + rowDataCount; i++) {
      T rowValue=pending.getRowDataValue(i - pageStart);
      boolean isSelected=(rowValue != null && selectionModel != null && selectionModel.isSelected(rowValue));
      boolean wasSelected=oldState.isRowSelected(i);
      if (isSelected) {
        pending.selectedRows.add(i);
        if (pendingState != null) {
          pendingState.selectedRows.add(i);
        }
        if (!wasSelected) {
          modifiedRows.push(i);
        }
      }
 else       if (wasSelected) {
        modifiedRows.push(i);
      }
    }
  }
 catch (  RuntimeException e) {
    isResolvingState=false;
    pendingStateLoop=0;
    throw e;
  }
  if (pendingState != null) {
    isResolvingState=false;
    if (resolvePendingState(modifiedRows)) {
      return true;
    }
  }
  boolean replacedEmptyRange=false;
  for (  Range replacedRange : pending.replacedRanges) {
    int start=replacedRange.getStart();
    int length=replacedRange.getLength();
    if (length == 0) {
      replacedEmptyRange=true;
    }
    for (int i=start; i < start + length; i++) {
      modifiedRows.push(i);
    }
  }
  if (modifiedRows.length() > 0 && keyboardRowChanged) {
    modifiedRows.push(oldState.getKeyboardSelectedRow());
    modifiedRows.push(pending.keyboardSelectedRow);
  }
  List<Range> modifiedRanges=calculateModifiedRanges(modifiedRows,pageStart,pageEnd);
  Range range0=modifiedRanges.size() > 0 ? modifiedRanges.get(0) : null;
  Range range1=modifiedRanges.size() > 1 ? modifiedRanges.get(1) : null;
  int replaceDiff=0;
  for (  Range range : modifiedRanges) {
    replaceDiff+=range.getLength();
  }
  int oldPageStart=oldState.getPageStart();
  int oldPageSize=oldState.getPageSize();
  int oldRowDataCount=oldState.getRowDataSize();
  boolean redrawRequired=pending.redrawRequired;
  if (pageStart != oldPageStart) {
    redrawRequired=true;
  }
 else   if (rowDataCount < oldRowDataCount) {
    redrawRequired=true;
  }
 else   if (range1 == null && range0 != null && range0.getStart() == pageStart && (replaceDiff >= oldRowDataCount || replaceDiff > oldPageSize)) {
    redrawRequired=true;
  }
 else   if (replaceDiff >= REDRAW_MINIMUM && replaceDiff > REDRAW_THRESHOLD * oldRowDataCount) {
    redrawRequired=true;
  }
 else   if (replacedEmptyRange && oldRowDataCount == 0) {
    redrawRequired=true;
  }
  updateLoadingState();
  try {
    if (redrawRequired) {
      SafeHtmlBuilder sb=new SafeHtmlBuilder();
      view.replaceAllChildren(pending.rowData,selectionModel,pending.keyboardStealFocus);
      view.resetFocus();
    }
 else     if (range0 != null) {
{
        int absStart=range0.getStart();
        int relStart=absStart - pageStart;
        SafeHtmlBuilder sb=new SafeHtmlBuilder();
        List<T> replaceValues=pending.rowData.subList(relStart,relStart + range0.getLength());
        view.replaceChildren(replaceValues,relStart,selectionModel,pending.keyboardStealFocus);
      }
      if (range1 != null) {
        int absStart=range1.getStart();
        int relStart=absStart - pageStart;
        SafeHtmlBuilder sb=new SafeHtmlBuilder();
        List<T> replaceValues=pending.rowData.subList(relStart,relStart + range1.getLength());
        view.replaceChildren(replaceValues,relStart,selectionModel,pending.keyboardStealFocus);
      }
      view.resetFocus();
    }
 else     if (keyboardRowChanged) {
      int oldSelectedRow=oldState.getKeyboardSelectedRow();
      if (oldSelectedRow >= 0 && oldSelectedRow < rowDataCount) {
        view.setKeyboardSelected(oldSelectedRow,false,false);
      }
      int newSelectedRow=pending.getKeyboardSelectedRow();
      if (newSelectedRow >= 0 && newSelectedRow < rowDataCount) {
        view.setKeyboardSelected(newSelectedRow,true,pending.keyboardStealFocus);
      }
    }
  }
 catch (  Error e) {
    throw new RuntimeException(e);
  }
 finally {
    isResolvingState=false;
  }
  resolvePendingState(null);
  return true;
}","/** 
 * Resolve the pending state and push updates to the view.
 * @param modifiedRows the modified rows that need to be updated, or null ifnone. The modified rows may be mutated.
 * @return true if the state changed, false if not
 */
private boolean resolvePendingState(JsArrayInteger modifiedRows){
  pendingStateCommand=null;
  if (isResolvingState) {
    return false;
  }
  isResolvingState=true;
  if (pendingState == null) {
    isResolvingState=false;
    pendingStateLoop=0;
    return false;
  }
  pendingStateLoop++;
  if (pendingStateLoop > LOOP_MAXIMUM) {
    isResolvingState=false;
    pendingStateLoop=0;
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
  State<T> oldState=state;
  PendingState<T> pending=pendingState;
  state=pendingState;
  pendingState=null;
  if (modifiedRows == null) {
    modifiedRows=JavaScriptObject.createArray().cast();
  }
  int pageStart=pending.getPageStart();
  int pageSize=pending.getPageSize();
  int pageEnd=pageStart + pageSize;
  int rowDataCount=pending.getRowDataSize();
  pending.keyboardSelectedRow=Math.max(0,Math.min(pending.keyboardSelectedRow,rowDataCount - 1));
  if (KeyboardSelectionPolicy.DISABLED == keyboardSelectionPolicy) {
    pending.keyboardSelectedRow=0;
    pending.keyboardSelectedRowValue=null;
  }
 else   if (pending.keyboardSelectedRowChanged) {
    pending.keyboardSelectedRowValue=rowDataCount > 0 ? pending.getRowDataValue(pending.keyboardSelectedRow) : null;
  }
 else   if (pending.keyboardSelectedRowValue != null) {
    int bestMatchIndex=findIndexOfBestMatch(pending,pending.keyboardSelectedRowValue,pending.keyboardSelectedRow);
    if (bestMatchIndex >= 0) {
      pending.keyboardSelectedRow=bestMatchIndex;
      pending.keyboardSelectedRowValue=rowDataCount > 0 ? pending.getRowDataValue(pending.keyboardSelectedRow) : null;
    }
 else {
      pending.keyboardSelectedRow=0;
      pending.keyboardSelectedRowValue=null;
    }
  }
  try {
    if (KeyboardSelectionPolicy.BOUND_TO_SELECTION == keyboardSelectionPolicy && selectionModel != null && pending.viewTouched) {
      T oldValue=oldState.getSelectedValue();
      Object oldKey=getRowValueKey(oldValue);
      T newValue=rowDataCount > 0 ? pending.getRowDataValue(pending.getKeyboardSelectedRow()) : null;
      Object newKey=getRowValueKey(newValue);
      if (newKey != null) {
        boolean oldValueWasSelected=(oldValue == null) ? false : selectionModel.isSelected(oldValue);
        boolean newValueWasSelected=(newValue == null) ? false : selectionModel.isSelected(newValue);
        if (!newKey.equals(oldKey)) {
          if (oldValueWasSelected) {
            selectionModel.setSelected(oldValue,false);
          }
          pending.selectedValue=newValue;
          if (newValue != null && !newValueWasSelected) {
            selectionModel.setSelected(newValue,true);
          }
        }
 else         if (!newValueWasSelected) {
          pending.selectedValue=null;
        }
      }
      if (pendingState != null) {
        pendingState.selectedValue=pending.selectedValue;
      }
    }
  }
 catch (  RuntimeException e) {
    isResolvingState=false;
    pendingStateLoop=0;
    throw e;
  }
  boolean keyboardRowChanged=pending.keyboardSelectedRowChanged || (oldState.getKeyboardSelectedRow() != pending.keyboardSelectedRow) || (oldState.getKeyboardSelectedRowValue() == null && pending.keyboardSelectedRowValue != null);
  try {
    for (int i=pageStart; i < pageStart + rowDataCount; i++) {
      T rowValue=pending.getRowDataValue(i - pageStart);
      boolean isSelected=(rowValue != null && selectionModel != null && selectionModel.isSelected(rowValue));
      boolean wasSelected=oldState.isRowSelected(i);
      if (isSelected) {
        pending.selectedRows.add(i);
        if (pendingState != null) {
          pendingState.selectedRows.add(i);
        }
        if (!wasSelected) {
          modifiedRows.push(i);
        }
      }
 else       if (wasSelected) {
        modifiedRows.push(i);
      }
    }
  }
 catch (  RuntimeException e) {
    isResolvingState=false;
    pendingStateLoop=0;
    throw e;
  }
  boolean replacedEmptyRange=false;
  for (  Range replacedRange : pending.replacedRanges) {
    int start=replacedRange.getStart();
    int length=replacedRange.getLength();
    if (length == 0) {
      replacedEmptyRange=true;
    }
    for (int i=start; i < start + length; i++) {
      modifiedRows.push(i);
    }
  }
  if (modifiedRows.length() > 0 && keyboardRowChanged) {
    modifiedRows.push(oldState.getKeyboardSelectedRow());
    modifiedRows.push(pending.keyboardSelectedRow);
  }
  if (pendingState != null) {
    isResolvingState=false;
    modifiedRows.push(oldState.getKeyboardSelectedRow());
    modifiedRows.push(pending.keyboardSelectedRow);
    if (resolvePendingState(modifiedRows)) {
      return true;
    }
  }
  List<Range> modifiedRanges=calculateModifiedRanges(modifiedRows,pageStart,pageEnd);
  Range range0=modifiedRanges.size() > 0 ? modifiedRanges.get(0) : null;
  Range range1=modifiedRanges.size() > 1 ? modifiedRanges.get(1) : null;
  int replaceDiff=0;
  for (  Range range : modifiedRanges) {
    replaceDiff+=range.getLength();
  }
  int oldPageStart=oldState.getPageStart();
  int oldPageSize=oldState.getPageSize();
  int oldRowDataCount=oldState.getRowDataSize();
  boolean redrawRequired=pending.redrawRequired;
  if (pageStart != oldPageStart) {
    redrawRequired=true;
  }
 else   if (rowDataCount < oldRowDataCount) {
    redrawRequired=true;
  }
 else   if (range1 == null && range0 != null && range0.getStart() == pageStart && (replaceDiff >= oldRowDataCount || replaceDiff > oldPageSize)) {
    redrawRequired=true;
  }
 else   if (replaceDiff >= REDRAW_MINIMUM && replaceDiff > REDRAW_THRESHOLD * oldRowDataCount) {
    redrawRequired=true;
  }
 else   if (replacedEmptyRange && oldRowDataCount == 0) {
    redrawRequired=true;
  }
  updateLoadingState();
  try {
    if (redrawRequired) {
      SafeHtmlBuilder sb=new SafeHtmlBuilder();
      view.replaceAllChildren(pending.rowData,selectionModel,pending.keyboardStealFocus);
      view.resetFocus();
    }
 else     if (range0 != null) {
{
        int absStart=range0.getStart();
        int relStart=absStart - pageStart;
        SafeHtmlBuilder sb=new SafeHtmlBuilder();
        List<T> replaceValues=pending.rowData.subList(relStart,relStart + range0.getLength());
        view.replaceChildren(replaceValues,relStart,selectionModel,pending.keyboardStealFocus);
      }
      if (range1 != null) {
        int absStart=range1.getStart();
        int relStart=absStart - pageStart;
        SafeHtmlBuilder sb=new SafeHtmlBuilder();
        List<T> replaceValues=pending.rowData.subList(relStart,relStart + range1.getLength());
        view.replaceChildren(replaceValues,relStart,selectionModel,pending.keyboardStealFocus);
      }
      view.resetFocus();
    }
 else     if (keyboardRowChanged) {
      int oldSelectedRow=oldState.getKeyboardSelectedRow();
      if (oldSelectedRow >= 0 && oldSelectedRow < rowDataCount) {
        view.setKeyboardSelected(oldSelectedRow,false,false);
      }
      int newSelectedRow=pending.getKeyboardSelectedRow();
      if (newSelectedRow >= 0 && newSelectedRow < rowDataCount) {
        view.setKeyboardSelected(newSelectedRow,true,pending.keyboardStealFocus);
      }
    }
  }
 catch (  Error e) {
    throw new RuntimeException(e);
  }
 finally {
    isResolvingState=false;
  }
  resolvePendingState(null);
  return true;
}",0.9750033417992248
53699,"public void onSuggestionsReady(Request request,Response response){
  display.setMoreSuggestions(response.hasMoreSuggestions(),response.getMoreSuggestionsCount());
  display.showSuggestions(SuggestBox.this,response.getSuggestions(),oracle.isDisplayStringHTML(),isAutoSelectEnabled(),suggestionCallback);
}","public void onSuggestionsReady(Request request,Response response){
  if (!isEnabled()) {
    return;
  }
  display.setMoreSuggestions(response.hasMoreSuggestions(),response.getMoreSuggestionsCount());
  display.showSuggestions(SuggestBox.this,response.getSuggestions(),oracle.isDisplayStringHTML(),isAutoSelectEnabled(),suggestionCallback);
}",0.9411764705882352
53700,"/** 
 * Resolve the pending state and push updates to the view.
 */
private void resolvePendingState(){
  pendingStateCommand=null;
  if (pendingState == null) {
    pendingStateLoop=0;
    return;
  }
  pendingStateLoop++;
  if (pendingStateLoop > LOOP_MAXIMUM) {
    pendingStateLoop=0;
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
  if (isResolvingState) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
  isResolvingState=true;
  JsArrayInteger modifiedRows=JavaScriptObject.createArray().cast();
  State<T> oldState=state;
  PendingState<T> pending=pendingState;
  int pageStart=pending.getPageStart();
  int pageSize=pending.getPageSize();
  int pageEnd=pageStart + pageSize;
  int rowDataCount=pending.getRowDataSize();
  pending.keyboardSelectedRow=Math.max(0,Math.min(pending.keyboardSelectedRow,rowDataCount - 1));
  if (KeyboardSelectionPolicy.DISABLED == keyboardSelectionPolicy) {
    pending.keyboardSelectedRow=0;
    pending.keyboardSelectedRowValue=null;
  }
 else   if (pending.keyboardSelectedRowChanged) {
    pending.keyboardSelectedRowValue=rowDataCount > 0 ? pending.getRowDataValue(pending.keyboardSelectedRow) : null;
  }
 else   if (pending.keyboardSelectedRowValue != null) {
    int bestMatchIndex=findIndexOfBestMatch(pending,pending.keyboardSelectedRowValue,pending.keyboardSelectedRow);
    if (bestMatchIndex >= 0) {
      pending.keyboardSelectedRow=bestMatchIndex;
      pending.keyboardSelectedRowValue=rowDataCount > 0 ? pending.getRowDataValue(pending.keyboardSelectedRow) : null;
    }
 else {
      pending.keyboardSelectedRow=0;
      pending.keyboardSelectedRowValue=null;
    }
  }
  try {
    if (KeyboardSelectionPolicy.BOUND_TO_SELECTION == keyboardSelectionPolicy && selectionModel != null && pending.viewTouched) {
      T oldValue=oldState.getSelectedValue();
      Object oldKey=getRowValueKey(oldValue);
      T newValue=rowDataCount > 0 ? pending.getRowDataValue(pending.getKeyboardSelectedRow()) : null;
      Object newKey=getRowValueKey(newValue);
      if (newKey != null && !newKey.equals(oldKey)) {
        boolean oldValueWasSelected=(oldValue == null) ? false : selectionModel.isSelected(oldValue);
        boolean newValueWasSelected=(newValue == null) ? false : selectionModel.isSelected(newValue);
        if (oldValueWasSelected) {
          selectionModel.setSelected(oldValue,false);
        }
        pending.selectedValue=newValue;
        if (newValue != null && !newValueWasSelected) {
          selectionModel.setSelected(newValue,true);
        }
      }
    }
  }
 catch (  RuntimeException e) {
    isResolvingState=false;
    throw e;
  }
  boolean keyboardRowChanged=pending.keyboardSelectedRowChanged || (oldState.getKeyboardSelectedRow() != pending.keyboardSelectedRow) || (oldState.getKeyboardSelectedRowValue() == null && pending.keyboardSelectedRowValue != null);
  for (int i=pageStart; i < pageStart + rowDataCount; i++) {
    T rowValue=pending.getRowDataValue(i - pageStart);
    boolean isSelected=(rowValue != null && selectionModel != null && selectionModel.isSelected(rowValue));
    boolean wasSelected=oldState.isRowSelected(i);
    if (isSelected) {
      pending.selectedRows.add(i);
      if (!wasSelected) {
        modifiedRows.push(i);
      }
    }
 else     if (wasSelected) {
      modifiedRows.push(i);
    }
  }
  if (pendingStateCommand != null) {
    isResolvingState=false;
    return;
  }
  pendingStateLoop=0;
  state=pendingState;
  pendingState=null;
  boolean replacedEmptyRange=false;
  for (  Range replacedRange : pending.replacedRanges) {
    int start=replacedRange.getStart();
    int length=replacedRange.getLength();
    if (length == 0) {
      replacedEmptyRange=true;
    }
    for (int i=start; i < start + length; i++) {
      modifiedRows.push(i);
    }
  }
  if (modifiedRows.length() > 0 && keyboardRowChanged) {
    modifiedRows.push(oldState.getKeyboardSelectedRow());
    modifiedRows.push(pending.keyboardSelectedRow);
  }
  List<Range> modifiedRanges=calculateModifiedRanges(modifiedRows,pageStart,pageEnd);
  Range range0=modifiedRanges.size() > 0 ? modifiedRanges.get(0) : null;
  Range range1=modifiedRanges.size() > 1 ? modifiedRanges.get(1) : null;
  int replaceDiff=0;
  for (  Range range : modifiedRanges) {
    replaceDiff+=range.getLength();
  }
  int oldPageStart=oldState.getPageStart();
  int oldPageSize=oldState.getPageSize();
  int oldRowDataCount=oldState.getRowDataSize();
  boolean redrawRequired=pending.redrawRequired;
  if (pageStart != oldPageStart) {
    redrawRequired=true;
  }
 else   if (rowDataCount < oldRowDataCount) {
    redrawRequired=true;
  }
 else   if (range1 == null && range0 != null && range0.getStart() == pageStart && (replaceDiff >= oldRowDataCount || replaceDiff > oldPageSize)) {
    redrawRequired=true;
  }
 else   if (replaceDiff >= REDRAW_MINIMUM && replaceDiff > REDRAW_THRESHOLD * oldRowDataCount) {
    redrawRequired=true;
  }
 else   if (replacedEmptyRange && oldRowDataCount == 0) {
    redrawRequired=true;
  }
  updateLoadingState();
  try {
    if (redrawRequired) {
      SafeHtmlBuilder sb=new SafeHtmlBuilder();
      view.replaceAllChildren(pending.rowData,selectionModel,pending.keyboardStealFocus);
      view.resetFocus();
    }
 else     if (range0 != null) {
{
        int absStart=range0.getStart();
        int relStart=absStart - pageStart;
        SafeHtmlBuilder sb=new SafeHtmlBuilder();
        List<T> replaceValues=pending.rowData.subList(relStart,relStart + range0.getLength());
        view.replaceChildren(replaceValues,relStart,selectionModel,pending.keyboardStealFocus);
      }
      if (range1 != null) {
        int absStart=range1.getStart();
        int relStart=absStart - pageStart;
        SafeHtmlBuilder sb=new SafeHtmlBuilder();
        List<T> replaceValues=pending.rowData.subList(relStart,relStart + range1.getLength());
        view.replaceChildren(replaceValues,relStart,selectionModel,pending.keyboardStealFocus);
      }
      view.resetFocus();
    }
 else     if (keyboardRowChanged) {
      int oldSelectedRow=oldState.getKeyboardSelectedRow();
      if (oldSelectedRow >= 0 && oldSelectedRow < rowDataCount) {
        view.setKeyboardSelected(oldSelectedRow,false,false);
      }
      int newSelectedRow=pending.getKeyboardSelectedRow();
      if (newSelectedRow >= 0 && newSelectedRow < rowDataCount) {
        view.setKeyboardSelected(newSelectedRow,true,pending.keyboardStealFocus);
      }
    }
  }
 catch (  Error e) {
    throw new RuntimeException(e);
  }
 finally {
    isResolvingState=false;
  }
}","/** 
 * Resolve the pending state and push updates to the view.
 */
private void resolvePendingState(){
  pendingStateCommand=null;
  if (pendingState == null) {
    pendingStateLoop=0;
    return;
  }
  pendingStateLoop++;
  if (pendingStateLoop > LOOP_MAXIMUM) {
    pendingStateLoop=0;
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
  if (isResolvingState) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
  isResolvingState=true;
  JsArrayInteger modifiedRows=JavaScriptObject.createArray().cast();
  State<T> oldState=state;
  PendingState<T> pending=pendingState;
  int pageStart=pending.getPageStart();
  int pageSize=pending.getPageSize();
  int pageEnd=pageStart + pageSize;
  int rowDataCount=pending.getRowDataSize();
  pending.keyboardSelectedRow=Math.max(0,Math.min(pending.keyboardSelectedRow,rowDataCount - 1));
  if (KeyboardSelectionPolicy.DISABLED == keyboardSelectionPolicy) {
    pending.keyboardSelectedRow=0;
    pending.keyboardSelectedRowValue=null;
  }
 else   if (pending.keyboardSelectedRowChanged) {
    pending.keyboardSelectedRowValue=rowDataCount > 0 ? pending.getRowDataValue(pending.keyboardSelectedRow) : null;
  }
 else   if (pending.keyboardSelectedRowValue != null) {
    int bestMatchIndex=findIndexOfBestMatch(pending,pending.keyboardSelectedRowValue,pending.keyboardSelectedRow);
    if (bestMatchIndex >= 0) {
      pending.keyboardSelectedRow=bestMatchIndex;
      pending.keyboardSelectedRowValue=rowDataCount > 0 ? pending.getRowDataValue(pending.keyboardSelectedRow) : null;
    }
 else {
      pending.keyboardSelectedRow=0;
      pending.keyboardSelectedRowValue=null;
    }
  }
  try {
    if (KeyboardSelectionPolicy.BOUND_TO_SELECTION == keyboardSelectionPolicy && selectionModel != null && pending.viewTouched) {
      T oldValue=oldState.getSelectedValue();
      Object oldKey=getRowValueKey(oldValue);
      T newValue=rowDataCount > 0 ? pending.getRowDataValue(pending.getKeyboardSelectedRow()) : null;
      Object newKey=getRowValueKey(newValue);
      if (newKey != null) {
        boolean oldValueWasSelected=(oldValue == null) ? false : selectionModel.isSelected(oldValue);
        boolean newValueWasSelected=(newValue == null) ? false : selectionModel.isSelected(newValue);
        if (!newKey.equals(oldKey)) {
          if (oldValueWasSelected) {
            selectionModel.setSelected(oldValue,false);
          }
          pending.selectedValue=newValue;
          if (newValue != null && !newValueWasSelected) {
            selectionModel.setSelected(newValue,true);
          }
        }
 else         if (!newValueWasSelected) {
          pending.selectedValue=null;
        }
      }
    }
  }
 catch (  RuntimeException e) {
    isResolvingState=false;
    throw e;
  }
  boolean keyboardRowChanged=pending.keyboardSelectedRowChanged || (oldState.getKeyboardSelectedRow() != pending.keyboardSelectedRow) || (oldState.getKeyboardSelectedRowValue() == null && pending.keyboardSelectedRowValue != null);
  for (int i=pageStart; i < pageStart + rowDataCount; i++) {
    T rowValue=pending.getRowDataValue(i - pageStart);
    boolean isSelected=(rowValue != null && selectionModel != null && selectionModel.isSelected(rowValue));
    boolean wasSelected=oldState.isRowSelected(i);
    if (isSelected) {
      pending.selectedRows.add(i);
      if (!wasSelected) {
        modifiedRows.push(i);
      }
    }
 else     if (wasSelected) {
      modifiedRows.push(i);
    }
  }
  if (pendingStateCommand != null) {
    isResolvingState=false;
    return;
  }
  pendingStateLoop=0;
  state=pendingState;
  pendingState=null;
  boolean replacedEmptyRange=false;
  for (  Range replacedRange : pending.replacedRanges) {
    int start=replacedRange.getStart();
    int length=replacedRange.getLength();
    if (length == 0) {
      replacedEmptyRange=true;
    }
    for (int i=start; i < start + length; i++) {
      modifiedRows.push(i);
    }
  }
  if (modifiedRows.length() > 0 && keyboardRowChanged) {
    modifiedRows.push(oldState.getKeyboardSelectedRow());
    modifiedRows.push(pending.keyboardSelectedRow);
  }
  List<Range> modifiedRanges=calculateModifiedRanges(modifiedRows,pageStart,pageEnd);
  Range range0=modifiedRanges.size() > 0 ? modifiedRanges.get(0) : null;
  Range range1=modifiedRanges.size() > 1 ? modifiedRanges.get(1) : null;
  int replaceDiff=0;
  for (  Range range : modifiedRanges) {
    replaceDiff+=range.getLength();
  }
  int oldPageStart=oldState.getPageStart();
  int oldPageSize=oldState.getPageSize();
  int oldRowDataCount=oldState.getRowDataSize();
  boolean redrawRequired=pending.redrawRequired;
  if (pageStart != oldPageStart) {
    redrawRequired=true;
  }
 else   if (rowDataCount < oldRowDataCount) {
    redrawRequired=true;
  }
 else   if (range1 == null && range0 != null && range0.getStart() == pageStart && (replaceDiff >= oldRowDataCount || replaceDiff > oldPageSize)) {
    redrawRequired=true;
  }
 else   if (replaceDiff >= REDRAW_MINIMUM && replaceDiff > REDRAW_THRESHOLD * oldRowDataCount) {
    redrawRequired=true;
  }
 else   if (replacedEmptyRange && oldRowDataCount == 0) {
    redrawRequired=true;
  }
  updateLoadingState();
  try {
    if (redrawRequired) {
      SafeHtmlBuilder sb=new SafeHtmlBuilder();
      view.replaceAllChildren(pending.rowData,selectionModel,pending.keyboardStealFocus);
      view.resetFocus();
    }
 else     if (range0 != null) {
{
        int absStart=range0.getStart();
        int relStart=absStart - pageStart;
        SafeHtmlBuilder sb=new SafeHtmlBuilder();
        List<T> replaceValues=pending.rowData.subList(relStart,relStart + range0.getLength());
        view.replaceChildren(replaceValues,relStart,selectionModel,pending.keyboardStealFocus);
      }
      if (range1 != null) {
        int absStart=range1.getStart();
        int relStart=absStart - pageStart;
        SafeHtmlBuilder sb=new SafeHtmlBuilder();
        List<T> replaceValues=pending.rowData.subList(relStart,relStart + range1.getLength());
        view.replaceChildren(replaceValues,relStart,selectionModel,pending.keyboardStealFocus);
      }
      view.resetFocus();
    }
 else     if (keyboardRowChanged) {
      int oldSelectedRow=oldState.getKeyboardSelectedRow();
      if (oldSelectedRow >= 0 && oldSelectedRow < rowDataCount) {
        view.setKeyboardSelected(oldSelectedRow,false,false);
      }
      int newSelectedRow=pending.getKeyboardSelectedRow();
      if (newSelectedRow >= 0 && newSelectedRow < rowDataCount) {
        view.setKeyboardSelected(newSelectedRow,true,pending.keyboardStealFocus);
      }
    }
  }
 catch (  Error e) {
    throw new RuntimeException(e);
  }
 finally {
    isResolvingState=false;
  }
}",0.9257997630331752
53701,"/** 
 * Builds a CSV file mapping obfuscated CSS class names to their qualified source name and outputs it as a private build artifact.
 */
protected void outputCssMapArtifact(TreeLogger logger,ResourceContext context,Map<JMethod,String> actualReplacements,String outputFileName){
  String mappingFileName=""String_Node_Str"" + outputFileName + ""String_Node_Str"";
  OutputStream os=null;
  try {
    os=context.getGeneratorContext().tryCreateResource(logger,mappingFileName);
  }
 catch (  UnableToCompleteException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"" + mappingFileName);
    return;
  }
  if (os == null) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"" + mappingFileName);
    return;
  }
  BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(os));
  try {
    for (    Map.Entry<JMethod,String> replacement : actualReplacements.entrySet()) {
      String qualifiedName=replacement.getKey().getEnclosingType().getQualifiedSourceName();
      String baseName=replacement.getKey().getName();
      writer.write(qualifiedName.replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"" + baseName);
      writer.write(""String_Node_Str"");
      writer.write(replacement.getValue());
      writer.newLine();
    }
    writer.flush();
    writer.close();
  }
 catch (  IOException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"" + mappingFileName);
  }
  try {
    context.getGeneratorContext().commitResource(logger,os).setVisibility(Visibility.Private);
  }
 catch (  UnableToCompleteException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"" + mappingFileName);
  }
}","/** 
 * Builds a CSV file mapping obfuscated CSS class names to their qualified source name and outputs it as a private build artifact.
 */
protected void outputCssMapArtifact(TreeLogger logger,ResourceContext context,JMethod method,Map<JMethod,String> actualReplacements){
  JClassType bundleType=method.getEnclosingType();
  String qualifiedMethodName=bundleType.getQualifiedSourceName() + ""String_Node_Str"" + method.getName();
  String mappingFileName=""String_Node_Str"" + qualifiedMethodName + ""String_Node_Str"";
  OutputStream os=null;
  try {
    os=context.getGeneratorContext().tryCreateResource(logger,mappingFileName);
  }
 catch (  UnableToCompleteException e) {
    logger.log(TreeLogger.WARN,""String_Node_Str"" + mappingFileName);
    return;
  }
  if (os == null) {
    logger.log(TreeLogger.WARN,""String_Node_Str"" + mappingFileName);
    return;
  }
  BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(os));
  try {
    for (    Map.Entry<JMethod,String> replacement : actualReplacements.entrySet()) {
      String qualifiedName=replacement.getKey().getEnclosingType().getQualifiedSourceName();
      String baseName=replacement.getKey().getName();
      writer.write(qualifiedName.replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"" + baseName);
      writer.write(""String_Node_Str"");
      writer.write(replacement.getValue());
      writer.newLine();
    }
    writer.flush();
    writer.close();
  }
 catch (  IOException e) {
    logger.log(TreeLogger.WARN,""String_Node_Str"" + mappingFileName);
  }
  try {
    context.getGeneratorContext().commitResource(logger,os).setVisibility(Visibility.Private);
  }
 catch (  UnableToCompleteException e) {
    logger.log(TreeLogger.WARN,""String_Node_Str"" + mappingFileName);
  }
}",0.9161747343565524
53702,"public void testOutputCssMapArtifactReturnNullOutputString() throws UnableToCompleteException {
  UnitTestTreeLogger.Builder builder=new UnitTestTreeLogger.Builder();
  builder.expectError(""String_Node_Str"",null);
  UnitTestTreeLogger testLogger=builder.createLogger();
  ResourceContext mockResourceContext=EasyMock.createMock(ResourceContext.class);
  Map<JMethod,String> testMap=new HashMap<JMethod,String>();
  OutputStream mockOutputStream=EasyMock.createMock(OutputStream.class);
  GeneratorContext mockGeneratorContext=EasyMock.createMock(GeneratorContext.class);
  GeneratedResource mockGeneratedResource=EasyMock.createMock(GeneratedResource.class);
  EasyMock.expect(mockResourceContext.getGeneratorContext()).andReturn(mockGeneratorContext);
  EasyMock.expect(mockGeneratorContext.tryCreateResource(testLogger,""String_Node_Str"")).andReturn(null);
  EasyMock.replay(mockResourceContext);
  EasyMock.replay(mockGeneratorContext);
  CssResourceGenerator crg=new CssResourceGenerator();
  crg.outputCssMapArtifact(testLogger,mockResourceContext,testMap,""String_Node_Str"");
  testLogger.assertCorrectLogEntries();
  EasyMock.verify(mockResourceContext);
  EasyMock.verify(mockGeneratorContext);
}","public void testOutputCssMapArtifactReturnNullOutputString() throws UnableToCompleteException {
  UnitTestTreeLogger.Builder builder=new UnitTestTreeLogger.Builder();
  builder.expectWarn(""String_Node_Str"",null);
  UnitTestTreeLogger testLogger=builder.createLogger();
  ResourceContext mockResourceContext=EasyMock.createMock(ResourceContext.class);
  Map<JMethod,String> testMap=new HashMap<JMethod,String>();
  OutputStream mockOutputStream=EasyMock.createMock(OutputStream.class);
  GeneratorContext mockGeneratorContext=EasyMock.createMock(GeneratorContext.class);
  GeneratedResource mockGeneratedResource=EasyMock.createMock(GeneratedResource.class);
  EasyMock.expect(mockResourceContext.getGeneratorContext()).andReturn(mockGeneratorContext);
  EasyMock.expect(mockGeneratorContext.tryCreateResource(testLogger,""String_Node_Str"")).andReturn(null);
  JMethod method=EasyMock.createMock(JMethod.class);
  JClassType bundleType=EasyMock.createMock(JClassType.class);
  EasyMock.expect(method.getEnclosingType()).andReturn(bundleType);
  EasyMock.expect(bundleType.getQualifiedSourceName()).andReturn(""String_Node_Str"");
  EasyMock.expect(method.getName()).andReturn(""String_Node_Str"");
  EasyMock.replay(mockResourceContext);
  EasyMock.replay(mockGeneratorContext);
  EasyMock.replay(method);
  EasyMock.replay(bundleType);
  CssResourceGenerator crg=new CssResourceGenerator();
  crg.outputCssMapArtifact(testLogger,mockResourceContext,method,testMap);
  testLogger.assertCorrectLogEntries();
  EasyMock.verify(mockResourceContext);
  EasyMock.verify(mockGeneratorContext);
  EasyMock.verify(method);
  EasyMock.verify(bundleType);
}",0.6943369679915582
53703,"public void testOutputCssMapArtifactWithTestData() throws UnableToCompleteException {
  UnitTestTreeLogger testLogger=new UnitTestTreeLogger.Builder().createLogger();
  ResourceContext mockResourceContext=EasyMock.createMock(ResourceContext.class);
  JMethod mockJMethod1=EasyMock.createMock(JMethod.class);
  JMethod mockJMethod2=EasyMock.createMock(JMethod.class);
  JMethod mockJMethod3=EasyMock.createMock(JMethod.class);
  JClassType mockJClassType1=EasyMock.createMock(JClassType.class);
  JClassType mockJClassType2=EasyMock.createMock(JClassType.class);
  JClassType mockJClassType3=EasyMock.createMock(JClassType.class);
  Map<JMethod,String> testMap=new LinkedHashMap<JMethod,String>();
  testMap.put(mockJMethod1,""String_Node_Str"");
  testMap.put(mockJMethod2,""String_Node_Str"");
  testMap.put(mockJMethod3,""String_Node_Str"");
  ByteArrayOutputStream testOutputStream=new ByteArrayOutputStream();
  GeneratorContext mockGeneratorContext=EasyMock.createMock(GeneratorContext.class);
  GeneratedResource mockGeneratedResource=EasyMock.createMock(GeneratedResource.class);
  EasyMock.expect(mockResourceContext.getGeneratorContext()).andReturn(mockGeneratorContext);
  EasyMock.expectLastCall().times(2);
  EasyMock.expect(mockGeneratorContext.tryCreateResource(testLogger,""String_Node_Str"")).andReturn(testOutputStream);
  EasyMock.expect(mockJMethod1.getEnclosingType()).andReturn(mockJClassType1);
  EasyMock.expect(mockJClassType1.getQualifiedSourceName()).andReturn(""String_Node_Str"");
  EasyMock.expect(mockJMethod1.getName()).andReturn(""String_Node_Str"");
  EasyMock.expect(mockJMethod2.getEnclosingType()).andReturn(mockJClassType2);
  EasyMock.expect(mockJClassType2.getQualifiedSourceName()).andReturn(""String_Node_Str"");
  EasyMock.expect(mockJMethod2.getName()).andReturn(""String_Node_Str"");
  EasyMock.expect(mockJMethod3.getEnclosingType()).andReturn(mockJClassType3);
  EasyMock.expect(mockJClassType3.getQualifiedSourceName()).andReturn(""String_Node_Str"");
  EasyMock.expect(mockJMethod3.getName()).andReturn(""String_Node_Str"");
  EasyMock.expect(mockGeneratorContext.commitResource(testLogger,testOutputStream)).andReturn(mockGeneratedResource);
  EasyMock.replay(mockResourceContext);
  EasyMock.replay(mockGeneratorContext);
  EasyMock.replay(mockJMethod1);
  EasyMock.replay(mockJMethod2);
  EasyMock.replay(mockJMethod3);
  EasyMock.replay(mockJClassType1);
  EasyMock.replay(mockJClassType2);
  EasyMock.replay(mockJClassType3);
  CssResourceGenerator crg=new CssResourceGenerator();
  crg.outputCssMapArtifact(testLogger,mockResourceContext,testMap,""String_Node_Str"");
  String expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  assertEquals(expectedOutput,testOutputStream.toString());
  testLogger.assertCorrectLogEntries();
  EasyMock.verify(mockResourceContext);
  EasyMock.verify(mockGeneratorContext);
  EasyMock.verify(mockJMethod1);
  EasyMock.verify(mockJMethod2);
  EasyMock.verify(mockJMethod3);
  EasyMock.verify(mockJClassType1);
  EasyMock.verify(mockJClassType2);
  EasyMock.verify(mockJClassType3);
}","public void testOutputCssMapArtifactWithTestData() throws UnableToCompleteException {
  UnitTestTreeLogger testLogger=new UnitTestTreeLogger.Builder().createLogger();
  ResourceContext mockResourceContext=EasyMock.createMock(ResourceContext.class);
  JMethod mockJMethod1=EasyMock.createMock(JMethod.class);
  JMethod mockJMethod2=EasyMock.createMock(JMethod.class);
  JMethod mockJMethod3=EasyMock.createMock(JMethod.class);
  JClassType mockJClassType1=EasyMock.createMock(JClassType.class);
  JClassType mockJClassType2=EasyMock.createMock(JClassType.class);
  JClassType mockJClassType3=EasyMock.createMock(JClassType.class);
  Map<JMethod,String> testMap=new LinkedHashMap<JMethod,String>();
  testMap.put(mockJMethod1,""String_Node_Str"");
  testMap.put(mockJMethod2,""String_Node_Str"");
  testMap.put(mockJMethod3,""String_Node_Str"");
  ByteArrayOutputStream testOutputStream=new ByteArrayOutputStream();
  GeneratorContext mockGeneratorContext=EasyMock.createMock(GeneratorContext.class);
  GeneratedResource mockGeneratedResource=EasyMock.createMock(GeneratedResource.class);
  EasyMock.expect(mockResourceContext.getGeneratorContext()).andReturn(mockGeneratorContext);
  EasyMock.expectLastCall().times(2);
  EasyMock.expect(mockGeneratorContext.tryCreateResource(testLogger,""String_Node_Str"")).andReturn(testOutputStream);
  EasyMock.expect(mockJMethod1.getEnclosingType()).andReturn(mockJClassType1);
  EasyMock.expect(mockJClassType1.getQualifiedSourceName()).andReturn(""String_Node_Str"");
  EasyMock.expect(mockJMethod1.getName()).andReturn(""String_Node_Str"");
  EasyMock.expect(mockJMethod2.getEnclosingType()).andReturn(mockJClassType2);
  EasyMock.expect(mockJClassType2.getQualifiedSourceName()).andReturn(""String_Node_Str"");
  EasyMock.expect(mockJMethod2.getName()).andReturn(""String_Node_Str"");
  EasyMock.expect(mockJMethod3.getEnclosingType()).andReturn(mockJClassType3);
  EasyMock.expect(mockJClassType3.getQualifiedSourceName()).andReturn(""String_Node_Str"");
  EasyMock.expect(mockJMethod3.getName()).andReturn(""String_Node_Str"");
  EasyMock.expect(mockGeneratorContext.commitResource(testLogger,testOutputStream)).andReturn(mockGeneratedResource);
  JMethod method=EasyMock.createMock(JMethod.class);
  JClassType bundleType=EasyMock.createMock(JClassType.class);
  EasyMock.expect(method.getEnclosingType()).andReturn(bundleType);
  EasyMock.expect(bundleType.getQualifiedSourceName()).andReturn(""String_Node_Str"");
  EasyMock.expect(method.getName()).andReturn(""String_Node_Str"");
  EasyMock.replay(mockResourceContext);
  EasyMock.replay(mockGeneratorContext);
  EasyMock.replay(mockJMethod1);
  EasyMock.replay(mockJMethod2);
  EasyMock.replay(mockJMethod3);
  EasyMock.replay(mockJClassType1);
  EasyMock.replay(mockJClassType2);
  EasyMock.replay(mockJClassType3);
  EasyMock.replay(method);
  EasyMock.replay(bundleType);
  CssResourceGenerator crg=new CssResourceGenerator();
  crg.outputCssMapArtifact(testLogger,mockResourceContext,method,testMap);
  String expectedOutput=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  assertEquals(expectedOutput,testOutputStream.toString());
  testLogger.assertCorrectLogEntries();
  EasyMock.verify(mockResourceContext);
  EasyMock.verify(mockGeneratorContext);
  EasyMock.verify(mockJMethod1);
  EasyMock.verify(mockJMethod2);
  EasyMock.verify(mockJMethod3);
  EasyMock.verify(mockJClassType1);
  EasyMock.verify(mockJClassType2);
  EasyMock.verify(mockJClassType3);
  EasyMock.verify(method);
  EasyMock.verify(bundleType);
}",0.8113608748481167
53704,"public void testOutputCssMapArtifact() throws UnableToCompleteException {
  UnitTestTreeLogger testLogger=new UnitTestTreeLogger.Builder().createLogger();
  ResourceContext mockResourceContext=EasyMock.createMock(ResourceContext.class);
  Map<JMethod,String> testMap=new HashMap<JMethod,String>();
  OutputStream mockOutputStream=EasyMock.createMock(OutputStream.class);
  GeneratorContext mockGeneratorContext=EasyMock.createMock(GeneratorContext.class);
  GeneratedResource mockGeneratedResource=EasyMock.createMock(GeneratedResource.class);
  EasyMock.expect(mockResourceContext.getGeneratorContext()).andReturn(mockGeneratorContext);
  EasyMock.expectLastCall().times(2);
  EasyMock.expect(mockGeneratorContext.tryCreateResource(testLogger,""String_Node_Str"")).andReturn(mockOutputStream);
  EasyMock.expect(mockGeneratorContext.commitResource(testLogger,mockOutputStream)).andReturn(mockGeneratedResource);
  EasyMock.replay(mockResourceContext);
  EasyMock.replay(mockGeneratorContext);
  CssResourceGenerator crg=new CssResourceGenerator();
  crg.outputCssMapArtifact(testLogger,mockResourceContext,testMap,""String_Node_Str"");
  testLogger.assertCorrectLogEntries();
  EasyMock.verify(mockResourceContext);
  EasyMock.verify(mockGeneratorContext);
}","public void testOutputCssMapArtifact() throws UnableToCompleteException {
  UnitTestTreeLogger testLogger=new UnitTestTreeLogger.Builder().createLogger();
  ResourceContext mockResourceContext=EasyMock.createMock(ResourceContext.class);
  Map<JMethod,String> testMap=new HashMap<JMethod,String>();
  OutputStream mockOutputStream=EasyMock.createMock(OutputStream.class);
  GeneratorContext mockGeneratorContext=EasyMock.createMock(GeneratorContext.class);
  GeneratedResource mockGeneratedResource=EasyMock.createMock(GeneratedResource.class);
  EasyMock.expect(mockResourceContext.getGeneratorContext()).andReturn(mockGeneratorContext);
  EasyMock.expectLastCall().times(2);
  EasyMock.expect(mockGeneratorContext.tryCreateResource(testLogger,""String_Node_Str"")).andReturn(mockOutputStream);
  EasyMock.expect(mockGeneratorContext.commitResource(testLogger,mockOutputStream)).andReturn(mockGeneratedResource);
  JMethod method=EasyMock.createMock(JMethod.class);
  JClassType bundleType=EasyMock.createMock(JClassType.class);
  EasyMock.expect(method.getEnclosingType()).andReturn(bundleType);
  EasyMock.expect(bundleType.getQualifiedSourceName()).andReturn(""String_Node_Str"");
  EasyMock.expect(method.getName()).andReturn(""String_Node_Str"");
  EasyMock.replay(mockResourceContext);
  EasyMock.replay(mockGeneratorContext);
  EasyMock.replay(method);
  EasyMock.replay(bundleType);
  CssResourceGenerator crg=new CssResourceGenerator();
  crg.outputCssMapArtifact(testLogger,mockResourceContext,method,testMap);
  testLogger.assertCorrectLogEntries();
  EasyMock.verify(mockResourceContext);
  EasyMock.verify(mockGeneratorContext);
  EasyMock.verify(method);
  EasyMock.verify(bundleType);
}",0.7084745762711865
53705,"public void testOutputCssMapArtifactThrowOnTryCreateResource() throws UnableToCompleteException {
  UnitTestTreeLogger.Builder builder=new UnitTestTreeLogger.Builder();
  builder.expectError(""String_Node_Str"",null);
  UnitTestTreeLogger testLogger=builder.createLogger();
  ResourceContext mockResourceContext=EasyMock.createMock(ResourceContext.class);
  Map<JMethod,String> testMap=new HashMap<JMethod,String>();
  OutputStream mockOutputStream=EasyMock.createMock(OutputStream.class);
  GeneratorContext mockGeneratorContext=EasyMock.createMock(GeneratorContext.class);
  GeneratedResource mockGeneratedResource=EasyMock.createMock(GeneratedResource.class);
  EasyMock.expect(mockResourceContext.getGeneratorContext()).andReturn(mockGeneratorContext);
  EasyMock.expect(mockGeneratorContext.tryCreateResource(testLogger,""String_Node_Str"")).andThrow(new UnableToCompleteException());
  EasyMock.replay(mockResourceContext);
  EasyMock.replay(mockGeneratorContext);
  CssResourceGenerator crg=new CssResourceGenerator();
  crg.outputCssMapArtifact(testLogger,mockResourceContext,testMap,""String_Node_Str"");
  testLogger.assertCorrectLogEntries();
  EasyMock.verify(mockResourceContext);
  EasyMock.verify(mockGeneratorContext);
}","public void testOutputCssMapArtifactThrowOnTryCreateResource() throws UnableToCompleteException {
  UnitTestTreeLogger.Builder builder=new UnitTestTreeLogger.Builder();
  builder.expectWarn(""String_Node_Str"",null);
  UnitTestTreeLogger testLogger=builder.createLogger();
  ResourceContext mockResourceContext=EasyMock.createMock(ResourceContext.class);
  Map<JMethod,String> testMap=new HashMap<JMethod,String>();
  OutputStream mockOutputStream=EasyMock.createMock(OutputStream.class);
  GeneratorContext mockGeneratorContext=EasyMock.createMock(GeneratorContext.class);
  GeneratedResource mockGeneratedResource=EasyMock.createMock(GeneratedResource.class);
  EasyMock.expect(mockResourceContext.getGeneratorContext()).andReturn(mockGeneratorContext);
  EasyMock.expect(mockGeneratorContext.tryCreateResource(testLogger,""String_Node_Str"")).andThrow(new UnableToCompleteException());
  JMethod method=EasyMock.createMock(JMethod.class);
  JClassType bundleType=EasyMock.createMock(JClassType.class);
  EasyMock.expect(method.getEnclosingType()).andReturn(bundleType);
  EasyMock.expect(bundleType.getQualifiedSourceName()).andReturn(""String_Node_Str"");
  EasyMock.expect(method.getName()).andReturn(""String_Node_Str"");
  EasyMock.replay(mockResourceContext);
  EasyMock.replay(mockGeneratorContext);
  EasyMock.replay(method);
  EasyMock.replay(bundleType);
  CssResourceGenerator crg=new CssResourceGenerator();
  crg.outputCssMapArtifact(testLogger,mockResourceContext,method,testMap);
  testLogger.assertCorrectLogEntries();
  EasyMock.verify(mockResourceContext);
  EasyMock.verify(mockGeneratorContext);
  EasyMock.verify(method);
  EasyMock.verify(bundleType);
}",0.7002414625733011
53706,"public void testOutputCssMapArtifactThrowOnCommitResource() throws UnableToCompleteException {
  UnitTestTreeLogger.Builder builder=new UnitTestTreeLogger.Builder();
  builder.expectError(""String_Node_Str"",null);
  UnitTestTreeLogger testLogger=builder.createLogger();
  ResourceContext mockResourceContext=EasyMock.createMock(ResourceContext.class);
  Map<JMethod,String> testMap=new HashMap<JMethod,String>();
  OutputStream mockOutputStream=EasyMock.createMock(OutputStream.class);
  GeneratorContext mockGeneratorContext=EasyMock.createMock(GeneratorContext.class);
  GeneratedResource mockGeneratedResource=EasyMock.createMock(GeneratedResource.class);
  EasyMock.expect(mockResourceContext.getGeneratorContext()).andReturn(mockGeneratorContext);
  EasyMock.expectLastCall().times(2);
  EasyMock.expect(mockGeneratorContext.tryCreateResource(testLogger,""String_Node_Str"")).andReturn(mockOutputStream);
  EasyMock.expect(mockGeneratorContext.commitResource(testLogger,mockOutputStream)).andThrow(new UnableToCompleteException());
  EasyMock.replay(mockResourceContext);
  EasyMock.replay(mockGeneratorContext);
  CssResourceGenerator crg=new CssResourceGenerator();
  crg.outputCssMapArtifact(testLogger,mockResourceContext,testMap,""String_Node_Str"");
  testLogger.assertCorrectLogEntries();
  EasyMock.verify(mockResourceContext);
  EasyMock.verify(mockGeneratorContext);
}","public void testOutputCssMapArtifactThrowOnCommitResource() throws UnableToCompleteException {
  UnitTestTreeLogger.Builder builder=new UnitTestTreeLogger.Builder();
  builder.expectWarn(""String_Node_Str"",null);
  UnitTestTreeLogger testLogger=builder.createLogger();
  ResourceContext mockResourceContext=EasyMock.createMock(ResourceContext.class);
  Map<JMethod,String> testMap=new HashMap<JMethod,String>();
  OutputStream mockOutputStream=EasyMock.createMock(OutputStream.class);
  GeneratorContext mockGeneratorContext=EasyMock.createMock(GeneratorContext.class);
  GeneratedResource mockGeneratedResource=EasyMock.createMock(GeneratedResource.class);
  EasyMock.expect(mockResourceContext.getGeneratorContext()).andReturn(mockGeneratorContext);
  EasyMock.expectLastCall().times(2);
  EasyMock.expect(mockGeneratorContext.tryCreateResource(testLogger,""String_Node_Str"")).andReturn(mockOutputStream);
  EasyMock.expect(mockGeneratorContext.commitResource(testLogger,mockOutputStream)).andThrow(new UnableToCompleteException());
  JMethod method=EasyMock.createMock(JMethod.class);
  JClassType bundleType=EasyMock.createMock(JClassType.class);
  EasyMock.expect(method.getEnclosingType()).andReturn(bundleType);
  EasyMock.expect(bundleType.getQualifiedSourceName()).andReturn(""String_Node_Str"");
  EasyMock.expect(method.getName()).andReturn(""String_Node_Str"");
  EasyMock.replay(mockResourceContext);
  EasyMock.replay(mockGeneratorContext);
  EasyMock.replay(method);
  EasyMock.replay(bundleType);
  CssResourceGenerator crg=new CssResourceGenerator();
  crg.outputCssMapArtifact(testLogger,mockResourceContext,method,testMap);
  testLogger.assertCorrectLogEntries();
  EasyMock.verify(mockResourceContext);
  EasyMock.verify(mockGeneratorContext);
  EasyMock.verify(method);
  EasyMock.verify(bundleType);
}",0.7280125195618153
53707,"@SuppressWarnings(""String_Node_Str"") @Override protected void onBrowserEvent2(Event event){
  EventTarget eventTarget=event.getEventTarget();
  if (!Element.is(eventTarget)) {
    return;
  }
  final Element target=event.getEventTarget().cast();
  TableSectionElement tbody=getTableBodyElement();
  TableSectionElement tfoot=getTableFootElement();
  TableSectionElement thead=getTableHeadElement();
  TableSectionElement targetTableSection=null;
  TableCellElement targetTableCell=null;
  Element cellParent=null;
  Element headerParent=null;
  Element headerColumnParent=null;
  Element footerParent=null;
  Element footerColumnParent=null;
{
    Element maybeTableCell=null;
    Element cur=target;
    while (cur != null && targetTableSection == null) {
      if (cur == tbody || cur == tfoot || cur == thead) {
        targetTableSection=cur.cast();
        if (maybeTableCell != null) {
          targetTableCell=maybeTableCell.cast();
          break;
        }
      }
      String tagName=cur.getTagName();
      if (TableCellElement.TAG_TD.equalsIgnoreCase(tagName) || TableCellElement.TAG_TH.equalsIgnoreCase(tagName)) {
        maybeTableCell=cur;
      }
      if (cellParent == null && tableBuilder.isColumn(cur)) {
        cellParent=cur;
      }
      if (headerParent == null && headerBuilder.isHeader(cur)) {
        headerParent=cur;
      }
      if (footerParent == null && footerBuilder.isHeader(cur)) {
        footerParent=cur;
      }
      if (headerColumnParent == null && headerBuilder.isColumn(cur)) {
        headerColumnParent=cur;
      }
      if (footerColumnParent == null && footerBuilder.isColumn(cur)) {
        footerColumnParent=cur;
      }
      cur=cur.getParentElement();
    }
  }
  if (targetTableCell == null) {
    return;
  }
  if (legacyRenderRowValues) {
    cellParent=targetTableCell.getFirstChildElement();
  }
  TableRowElement targetTableRow=targetTableCell.getParentElement().cast();
  String eventType=event.getType();
  boolean isClick=""String_Node_Str"".equals(eventType);
  int col=targetTableCell.getCellIndex();
  if (targetTableSection == thead || targetTableSection == tfoot) {
    boolean isHeader=(targetTableSection == thead);
    headerParent=isHeader ? headerParent : footerParent;
    Element columnParent=isHeader ? headerColumnParent : footerColumnParent;
    if (headerParent != null) {
      Header<?> header=isHeader ? headerBuilder.getHeader(headerParent) : footerBuilder.getHeader(footerParent);
      if (header != null && cellConsumesEventType(header.getCell(),eventType)) {
        Context context=new Context(0,col,header.getKey());
        header.onBrowserEvent(context,cellParent,event);
      }
    }
    if (isClick && columnParent != null) {
      Column<T,?> column=isHeader ? headerBuilder.getColumn(columnParent) : footerBuilder.getColumn(columnParent);
      if (column != null && column.isSortable()) {
        headersDirty=true;
        updatingSortList=true;
        sortList.push(column);
        updatingSortList=false;
        ColumnSortEvent.fire(this,sortList);
      }
    }
  }
 else   if (targetTableSection == tbody) {
    int absRow=tableBuilder.getRowValueIndex(targetTableRow);
    int relRow=absRow - getPageStart();
    int subrow=tableBuilder.getSubrowValueIndex(targetTableRow);
    if (""String_Node_Str"".equals(eventType)) {
      if (hoveringRow != null && getTableBodyElement().isOrHasChild(hoveringRow)) {
        setRowHover(hoveringRow,false);
      }
      hoveringRow=targetTableRow;
      setRowHover(hoveringRow,true);
    }
 else     if (""String_Node_Str"".equals(eventType) && hoveringRow != null) {
      setRowHover(hoveringRow,false);
      hoveringRow=null;
    }
    if (!isRowWithinBounds(relRow)) {
      return;
    }
    boolean isSelectionHandled=handlesSelection || KeyboardSelectionPolicy.BOUND_TO_SELECTION == getKeyboardSelectionPolicy();
    T value=getVisibleItem(relRow);
    Context context=new Context(absRow,col,getValueKey(value),subrow);
    CellPreviewEvent<T> previewEvent=CellPreviewEvent.fire(this,event,this,context,value,cellIsEditing,isSelectionHandled);
    if (cellParent != null && !previewEvent.isCanceled()) {
      HasCell<T,?> column;
      if (legacyRenderRowValues) {
        column=columns.get(col);
      }
 else {
        column=tableBuilder.getColumn(context,value,cellParent);
      }
      if (column != null) {
        fireEventToCell(event,eventType,cellParent,value,context,column);
      }
    }
  }
}","@SuppressWarnings(""String_Node_Str"") @Override protected void onBrowserEvent2(Event event){
  EventTarget eventTarget=event.getEventTarget();
  if (!Element.is(eventTarget)) {
    return;
  }
  final Element target=event.getEventTarget().cast();
  TableSectionElement tbody=getTableBodyElement();
  TableSectionElement tfoot=getTableFootElement();
  TableSectionElement thead=getTableHeadElement();
  TableSectionElement targetTableSection=null;
  TableCellElement targetTableCell=null;
  Element cellParent=null;
  Element headerParent=null;
  Element headerColumnParent=null;
  Element footerParent=null;
  Element footerColumnParent=null;
{
    Element maybeTableCell=null;
    Element cur=target;
    while (cur != null && targetTableSection == null) {
      if (cur == tbody || cur == tfoot || cur == thead) {
        targetTableSection=cur.cast();
        if (maybeTableCell != null) {
          targetTableCell=maybeTableCell.cast();
          break;
        }
      }
      String tagName=cur.getTagName();
      if (TableCellElement.TAG_TD.equalsIgnoreCase(tagName) || TableCellElement.TAG_TH.equalsIgnoreCase(tagName)) {
        maybeTableCell=cur;
      }
      if (cellParent == null && tableBuilder.isColumn(cur)) {
        cellParent=cur;
      }
      if (headerParent == null && headerBuilder.isHeader(cur)) {
        headerParent=cur;
      }
      if (footerParent == null && footerBuilder.isHeader(cur)) {
        footerParent=cur;
      }
      if (headerColumnParent == null && headerBuilder.isColumn(cur)) {
        headerColumnParent=cur;
      }
      if (footerColumnParent == null && footerBuilder.isColumn(cur)) {
        footerColumnParent=cur;
      }
      cur=cur.getParentElement();
    }
  }
  if (targetTableCell == null) {
    return;
  }
  if (legacyRenderRowValues) {
    cellParent=targetTableCell.getFirstChildElement();
  }
  TableRowElement targetTableRow=targetTableCell.getParentElement().cast();
  String eventType=event.getType();
  boolean isClick=""String_Node_Str"".equals(eventType);
  int col=targetTableCell.getCellIndex();
  if (targetTableSection == thead || targetTableSection == tfoot) {
    boolean isHeader=(targetTableSection == thead);
    headerParent=isHeader ? headerParent : footerParent;
    Element columnParent=isHeader ? headerColumnParent : footerColumnParent;
    if (headerParent != null) {
      Header<?> header=isHeader ? headerBuilder.getHeader(headerParent) : footerBuilder.getHeader(footerParent);
      if (header != null && cellConsumesEventType(header.getCell(),eventType)) {
        Context context=new Context(0,col,header.getKey());
        header.onBrowserEvent(context,headerParent,event);
      }
    }
    if (isClick && columnParent != null) {
      Column<T,?> column=isHeader ? headerBuilder.getColumn(columnParent) : footerBuilder.getColumn(columnParent);
      if (column != null && column.isSortable()) {
        headersDirty=true;
        updatingSortList=true;
        sortList.push(column);
        updatingSortList=false;
        ColumnSortEvent.fire(this,sortList);
      }
    }
  }
 else   if (targetTableSection == tbody) {
    int absRow=tableBuilder.getRowValueIndex(targetTableRow);
    int relRow=absRow - getPageStart();
    int subrow=tableBuilder.getSubrowValueIndex(targetTableRow);
    if (""String_Node_Str"".equals(eventType)) {
      if (hoveringRow != null && getTableBodyElement().isOrHasChild(hoveringRow)) {
        setRowHover(hoveringRow,false);
      }
      hoveringRow=targetTableRow;
      setRowHover(hoveringRow,true);
    }
 else     if (""String_Node_Str"".equals(eventType) && hoveringRow != null) {
      setRowHover(hoveringRow,false);
      hoveringRow=null;
    }
    if (!isRowWithinBounds(relRow)) {
      return;
    }
    boolean isSelectionHandled=handlesSelection || KeyboardSelectionPolicy.BOUND_TO_SELECTION == getKeyboardSelectionPolicy();
    T value=getVisibleItem(relRow);
    Context context=new Context(absRow,col,getValueKey(value),subrow);
    CellPreviewEvent<T> previewEvent=CellPreviewEvent.fire(this,event,this,context,value,cellIsEditing,isSelectionHandled);
    if (cellParent != null && !previewEvent.isCanceled()) {
      HasCell<T,?> column;
      if (legacyRenderRowValues) {
        column=columns.get(col);
      }
 else {
        column=tableBuilder.getColumn(context,value,cellParent);
      }
      if (column != null) {
        fireEventToCell(event,eventType,cellParent,value,context,column);
      }
    }
  }
}",0.9988811814723652
53708,"/** 
 * Set a row's hovering style and fire a   {@link RowHoverEvent}
 * @param tr the row element
 * @param isHovering false if this is an unhover event
 */
private void setRowHover(TableRowElement tr,boolean isHovering){
  setRowStyleName(tr,style.hoveredRow(),style.hoveredRowCell(),isHovering);
  RowHoverEvent.fire(this,tr,isHovering);
}","/** 
 * Set a row's hovering style and fire a   {@link RowHoverEvent}
 * @param tr the row element
 * @param isHovering false if this is an unhover event
 */
private void setRowHover(TableRowElement tr,boolean isHovering){
  setRowStyleName(tr,style.hoveredRow(),style.hoveredRowCell(),isHovering);
  RowHoverEvent.fire(this,tr,!isHovering);
}",0.9985401459854014
53709,"/** 
 * Set the row index of the keyboard selected element.
 * @param index the row index
 * @param stealFocus true to steal focus
 * @param forceUpdate force the update even if the row didn't change
 */
public void setKeyboardSelectedRow(int index,boolean stealFocus,boolean forceUpdate){
  if (KeyboardSelectionPolicy.DISABLED == keyboardSelectionPolicy) {
    return;
  }
  if (keyboardPagingPolicy.isLimitedToRange()) {
    index=Math.max(0,Math.min(index,getVisibleItemCount() - 1));
  }
  ensurePendingState().viewTouched=true;
  if (!forceUpdate && getKeyboardSelectedRow() == index && getKeyboardSelectedRowValue() != null) {
    return;
  }
  int pageStart=getPageStart();
  int pageSize=getPageSize();
  int rowCount=getRowCount();
  int absIndex=pageStart + index;
  if (absIndex >= rowCount && isRowCountExact()) {
    absIndex=rowCount - 1;
  }
  index=Math.max(0,absIndex) - pageStart;
  if (keyboardPagingPolicy.isLimitedToRange()) {
    index=Math.max(0,Math.min(index,pageSize - 1));
  }
  int newPageStart=pageStart;
  int newPageSize=pageSize;
  PendingState<T> pending=ensurePendingState();
  pending.keyboardSelectedRow=0;
  pending.keyboardSelectedRowValue=null;
  pending.keyboardSelectedRowChanged=true;
  if (index >= 0 && index < pageSize) {
    pending.keyboardSelectedRow=index;
    pending.keyboardSelectedRowValue=index < pending.getRowDataSize() ? ensurePendingState().getRowDataValue(index) : null;
    pending.keyboardStealFocus=stealFocus;
    return;
  }
 else   if (KeyboardPagingPolicy.CHANGE_PAGE == keyboardPagingPolicy) {
    while (index < 0) {
      newPageStart-=pageSize;
      index+=pageSize;
    }
    while (index >= pageSize) {
      newPageStart+=pageSize;
      index-=pageSize;
    }
  }
 else   if (KeyboardPagingPolicy.INCREASE_RANGE == keyboardPagingPolicy) {
    while (index < 0) {
      newPageSize+=PAGE_INCREMENT;
      newPageStart-=PAGE_INCREMENT;
      index+=PAGE_INCREMENT;
    }
    if (newPageStart < 0) {
      index+=newPageStart;
      newPageSize+=newPageStart;
      newPageStart=0;
    }
    while (index >= newPageSize) {
      newPageSize+=PAGE_INCREMENT;
    }
    if (isRowCountExact()) {
      newPageSize=Math.min(newPageSize,rowCount - newPageStart);
      if (index >= rowCount) {
        index=rowCount - 1;
      }
    }
  }
  if (newPageStart != pageStart || newPageSize != pageSize) {
    pending.keyboardSelectedRow=index;
    setVisibleRange(new Range(newPageStart,newPageSize),false,false);
  }
}","/** 
 * Set the row index of the keyboard selected element.
 * @param index the row index
 * @param stealFocus true to steal focus
 * @param forceUpdate force the update even if the row didn't change
 */
public void setKeyboardSelectedRow(int index,boolean stealFocus,boolean forceUpdate){
  if (KeyboardSelectionPolicy.DISABLED == keyboardSelectionPolicy) {
    return;
  }
  if (keyboardPagingPolicy.isLimitedToRange()) {
    index=Math.max(0,Math.min(index,getVisibleItemCount() - 1));
  }
  ensurePendingState().viewTouched=true;
  if (!forceUpdate && getKeyboardSelectedRow() == index && getKeyboardSelectedRowValue() != null) {
    return;
  }
  int pageStart=getPageStart();
  int pageSize=getPageSize();
  int rowCount=getRowCount();
  int absIndex=pageStart + index;
  if (absIndex >= rowCount && isRowCountExact()) {
    absIndex=rowCount - 1;
  }
  index=Math.max(0,absIndex) - pageStart;
  if (keyboardPagingPolicy.isLimitedToRange()) {
    index=Math.max(0,Math.min(index,pageSize - 1));
  }
  int newPageStart=pageStart;
  int newPageSize=pageSize;
  PendingState<T> pending=ensurePendingState();
  pending.keyboardSelectedRow=0;
  pending.keyboardSelectedRowValue=null;
  pending.keyboardSelectedRowChanged=true;
  if (index >= 0 && index < pageSize) {
    pending.keyboardSelectedRow=index;
    pending.keyboardSelectedRowValue=index < pending.getRowDataSize() ? ensurePendingState().getRowDataValue(index) : null;
    pending.keyboardStealFocus=stealFocus;
    return;
  }
 else   if (KeyboardPagingPolicy.CHANGE_PAGE == keyboardPagingPolicy) {
    while (index < 0) {
      int shift=Math.min(pageSize,newPageStart);
      newPageStart-=shift;
      index+=shift;
    }
    while (index >= pageSize) {
      newPageStart+=pageSize;
      index-=pageSize;
    }
  }
 else   if (KeyboardPagingPolicy.INCREASE_RANGE == keyboardPagingPolicy) {
    while (index < 0) {
      int shift=Math.min(PAGE_INCREMENT,newPageStart);
      newPageSize+=shift;
      newPageStart-=shift;
      index+=shift;
    }
    if (newPageStart < 0) {
      index+=newPageStart;
      newPageSize+=newPageStart;
      newPageStart=0;
    }
    while (index >= newPageSize) {
      newPageSize+=PAGE_INCREMENT;
    }
    if (isRowCountExact()) {
      newPageSize=Math.min(newPageSize,rowCount - newPageStart);
      if (index >= rowCount) {
        index=rowCount - 1;
      }
    }
  }
  if (newPageStart != pageStart || newPageSize != pageSize) {
    pending.keyboardSelectedRow=index;
    setVisibleRange(new Range(newPageStart,newPageSize),false,false);
  }
}",0.8866838658463981
53710,"public void testSetKeyboardSelectedRowChangePage(){
  HasData<String> listView=new MockHasData<String>();
  MockView<String> view=new MockView<String>();
  HasDataPresenter<String> presenter=new HasDataPresenter<String>(listView,view,10,null);
  presenter.setVisibleRange(new Range(10,10));
  populatePresenter(presenter);
  presenter.flush();
  assertEquals(KeyboardPagingPolicy.CHANGE_PAGE,presenter.getKeyboardPagingPolicy());
  assertEquals(0,presenter.getKeyboardSelectedRow());
  view.assertKeyboardSelectedRowEmpty();
  presenter.setKeyboardSelectedRow(1,false,false);
  assertEquals(""String_Node_Str"",presenter.getKeyboardSelectedRowValue());
  presenter.flush();
  assertEquals(1,presenter.getKeyboardSelectedRow());
  assertEquals(""String_Node_Str"",presenter.getKeyboardSelectedRowValue());
  view.assertKeyboardSelectedRow(0,false);
  view.assertKeyboardSelectedRow(1,true);
  presenter.setKeyboardSelectedRow(1,false,true);
  assertEquals(""String_Node_Str"",presenter.getKeyboardSelectedRowValue());
  presenter.flush();
  assertEquals(1,presenter.getKeyboardSelectedRow());
  assertEquals(""String_Node_Str"",presenter.getKeyboardSelectedRowValue());
  view.assertKeyboardSelectedRow(1,false);
  view.assertKeyboardSelectedRow(1,true);
  presenter.setKeyboardSelectedRow(9,false,false);
  assertEquals(""String_Node_Str"",presenter.getKeyboardSelectedRowValue());
  presenter.flush();
  assertEquals(9,presenter.getKeyboardSelectedRow());
  assertEquals(""String_Node_Str"",presenter.getKeyboardSelectedRowValue());
  view.assertKeyboardSelectedRow(1,false);
  view.assertKeyboardSelectedRow(9,true);
  assertEquals(10,presenter.getVisibleRange().getStart());
  assertEquals(10,presenter.getVisibleRange().getLength());
  presenter.setKeyboardSelectedRow(10,false,false);
  populatePresenter(presenter);
  assertNull(presenter.getKeyboardSelectedRowValue());
  presenter.flush();
  assertEquals(0,presenter.getKeyboardSelectedRow());
  assertEquals(""String_Node_Str"",presenter.getKeyboardSelectedRowValue());
  view.assertReplaceAllChildrenCalled(10);
  view.assertKeyboardSelectedRowEmpty();
  assertEquals(20,presenter.getVisibleRange().getStart());
  assertEquals(10,presenter.getVisibleRange().getLength());
  presenter.setKeyboardSelectedRow(-1,false,false);
  populatePresenter(presenter);
  assertNull(presenter.getKeyboardSelectedRowValue());
  presenter.flush();
  assertEquals(9,presenter.getKeyboardSelectedRow());
  assertEquals(""String_Node_Str"",presenter.getKeyboardSelectedRowValue());
  view.assertReplaceAllChildrenCalled(10);
  view.assertKeyboardSelectedRowEmpty();
  assertEquals(10,presenter.getVisibleRange().getStart());
  assertEquals(10,presenter.getVisibleRange().getLength());
}","public void testSetKeyboardSelectedRowChangePage(){
  HasData<String> listView=new MockHasData<String>();
  MockView<String> view=new MockView<String>();
  HasDataPresenter<String> presenter=new HasDataPresenter<String>(listView,view,10,null);
  presenter.setVisibleRange(new Range(10,10));
  populatePresenter(presenter);
  presenter.flush();
  assertEquals(KeyboardPagingPolicy.CHANGE_PAGE,presenter.getKeyboardPagingPolicy());
  assertEquals(0,presenter.getKeyboardSelectedRow());
  view.assertKeyboardSelectedRowEmpty();
  presenter.setKeyboardSelectedRow(1,false,false);
  assertEquals(""String_Node_Str"",presenter.getKeyboardSelectedRowValue());
  presenter.flush();
  assertEquals(1,presenter.getKeyboardSelectedRow());
  assertEquals(""String_Node_Str"",presenter.getKeyboardSelectedRowValue());
  view.assertKeyboardSelectedRow(0,false);
  view.assertKeyboardSelectedRow(1,true);
  presenter.setKeyboardSelectedRow(1,false,true);
  assertEquals(""String_Node_Str"",presenter.getKeyboardSelectedRowValue());
  presenter.flush();
  assertEquals(1,presenter.getKeyboardSelectedRow());
  assertEquals(""String_Node_Str"",presenter.getKeyboardSelectedRowValue());
  view.assertKeyboardSelectedRow(1,false);
  view.assertKeyboardSelectedRow(1,true);
  presenter.setKeyboardSelectedRow(9,false,false);
  assertEquals(""String_Node_Str"",presenter.getKeyboardSelectedRowValue());
  presenter.flush();
  assertEquals(9,presenter.getKeyboardSelectedRow());
  assertEquals(""String_Node_Str"",presenter.getKeyboardSelectedRowValue());
  view.assertKeyboardSelectedRow(1,false);
  view.assertKeyboardSelectedRow(9,true);
  assertEquals(10,presenter.getVisibleRange().getStart());
  assertEquals(10,presenter.getVisibleRange().getLength());
  presenter.setKeyboardSelectedRow(10,false,false);
  populatePresenter(presenter);
  assertNull(presenter.getKeyboardSelectedRowValue());
  presenter.flush();
  assertEquals(0,presenter.getKeyboardSelectedRow());
  assertEquals(""String_Node_Str"",presenter.getKeyboardSelectedRowValue());
  view.assertReplaceAllChildrenCalled(10);
  view.assertKeyboardSelectedRowEmpty();
  assertEquals(20,presenter.getVisibleRange().getStart());
  assertEquals(10,presenter.getVisibleRange().getLength());
  presenter.setKeyboardSelectedRow(-1,false,false);
  populatePresenter(presenter);
  assertNull(presenter.getKeyboardSelectedRowValue());
  presenter.flush();
  assertEquals(9,presenter.getKeyboardSelectedRow());
  assertEquals(""String_Node_Str"",presenter.getKeyboardSelectedRowValue());
  view.assertReplaceAllChildrenCalled(10);
  view.assertKeyboardSelectedRowEmpty();
  assertEquals(10,presenter.getVisibleRange().getStart());
  assertEquals(10,presenter.getVisibleRange().getLength());
  presenter.setVisibleRange(new Range(3,10));
  presenter.setKeyboardSelectedRow(3,false,false);
  populatePresenter(presenter);
  presenter.flush();
  presenter.setKeyboardSelectedRow(-4,false,false);
  populatePresenter(presenter);
  presenter.flush();
  assertEquals(0,presenter.getKeyboardSelectedRow());
  assertEquals(0,presenter.getVisibleRange().getStart());
  assertEquals(10,presenter.getVisibleRange().getLength());
}",0.926996067703881
53711,"public void testSetKeyboardSelectedRowIncreaseRange(){
  HasData<String> listView=new MockHasData<String>();
  MockView<String> view=new MockView<String>();
  HasDataPresenter<String> presenter=new HasDataPresenter<String>(listView,view,10,null);
  presenter.setVisibleRange(new Range(10,10));
  populatePresenter(presenter);
  presenter.flush();
  presenter.setKeyboardPagingPolicy(KeyboardPagingPolicy.INCREASE_RANGE);
  int pageSize=presenter.getVisibleRange().getLength();
  assertEquals(0,presenter.getKeyboardSelectedRow());
  view.assertKeyboardSelectedRowEmpty();
  presenter.setKeyboardSelectedRow(1,false,false);
  presenter.flush();
  assertEquals(1,presenter.getKeyboardSelectedRow());
  view.assertKeyboardSelectedRow(0,false);
  view.assertKeyboardSelectedRow(1,true);
  presenter.setKeyboardSelectedRow(1,false,true);
  presenter.flush();
  assertEquals(1,presenter.getKeyboardSelectedRow());
  view.assertKeyboardSelectedRow(1,false);
  view.assertKeyboardSelectedRow(1,true);
  presenter.setKeyboardSelectedRow(9,false,false);
  presenter.flush();
  assertEquals(9,presenter.getKeyboardSelectedRow());
  view.assertKeyboardSelectedRow(1,false);
  view.assertKeyboardSelectedRow(9,true);
  assertEquals(10,presenter.getVisibleRange().getStart());
  assertEquals(pageSize,presenter.getVisibleRange().getLength());
  presenter.setKeyboardSelectedRow(10,false,false);
  populatePresenter(presenter);
  presenter.flush();
  assertEquals(10,presenter.getKeyboardSelectedRow());
  view.assertReplaceAllChildrenCalled(pageSize);
  view.assertKeyboardSelectedRowEmpty();
  assertEquals(10,presenter.getVisibleRange().getStart());
  pageSize+=HasDataPresenter.PAGE_INCREMENT;
  assertEquals(pageSize,presenter.getVisibleRange().getLength());
  presenter.setKeyboardSelectedRow(-1,false,false);
  populatePresenter(presenter);
  presenter.flush();
  assertEquals(9,presenter.getKeyboardSelectedRow());
  view.assertReplaceAllChildrenCalled(pageSize);
  view.assertKeyboardSelectedRowEmpty();
  assertEquals(0,presenter.getVisibleRange().getStart());
  pageSize+=10;
  assertEquals(pageSize,presenter.getVisibleRange().getLength());
}","public void testSetKeyboardSelectedRowIncreaseRange(){
  HasData<String> listView=new MockHasData<String>();
  MockView<String> view=new MockView<String>();
  HasDataPresenter<String> presenter=new HasDataPresenter<String>(listView,view,10,null);
  presenter.setVisibleRange(new Range(10,10));
  populatePresenter(presenter);
  presenter.flush();
  presenter.setKeyboardPagingPolicy(KeyboardPagingPolicy.INCREASE_RANGE);
  int pageSize=presenter.getVisibleRange().getLength();
  assertEquals(0,presenter.getKeyboardSelectedRow());
  view.assertKeyboardSelectedRowEmpty();
  presenter.setKeyboardSelectedRow(1,false,false);
  presenter.flush();
  assertEquals(1,presenter.getKeyboardSelectedRow());
  view.assertKeyboardSelectedRow(0,false);
  view.assertKeyboardSelectedRow(1,true);
  presenter.setKeyboardSelectedRow(1,false,true);
  presenter.flush();
  assertEquals(1,presenter.getKeyboardSelectedRow());
  view.assertKeyboardSelectedRow(1,false);
  view.assertKeyboardSelectedRow(1,true);
  presenter.setKeyboardSelectedRow(9,false,false);
  presenter.flush();
  assertEquals(9,presenter.getKeyboardSelectedRow());
  view.assertKeyboardSelectedRow(1,false);
  view.assertKeyboardSelectedRow(9,true);
  assertEquals(10,presenter.getVisibleRange().getStart());
  assertEquals(pageSize,presenter.getVisibleRange().getLength());
  presenter.setKeyboardSelectedRow(10,false,false);
  populatePresenter(presenter);
  presenter.flush();
  assertEquals(10,presenter.getKeyboardSelectedRow());
  view.assertReplaceAllChildrenCalled(pageSize);
  view.assertKeyboardSelectedRowEmpty();
  assertEquals(10,presenter.getVisibleRange().getStart());
  pageSize+=HasDataPresenter.PAGE_INCREMENT;
  assertEquals(pageSize,presenter.getVisibleRange().getLength());
  presenter.setKeyboardSelectedRow(-1,false,false);
  populatePresenter(presenter);
  presenter.flush();
  assertEquals(9,presenter.getKeyboardSelectedRow());
  view.assertReplaceAllChildrenCalled(pageSize);
  view.assertKeyboardSelectedRowEmpty();
  assertEquals(0,presenter.getVisibleRange().getStart());
  pageSize+=10;
  assertEquals(pageSize,presenter.getVisibleRange().getLength());
  presenter.setVisibleRange(new Range(3,10));
  presenter.setKeyboardSelectedRow(3,false,false);
  populatePresenter(presenter);
  presenter.flush();
  presenter.setKeyboardSelectedRow(-4,false,false);
  populatePresenter(presenter);
  presenter.flush();
  assertEquals(0,presenter.getKeyboardSelectedRow());
  assertEquals(0,presenter.getVisibleRange().getStart());
  assertEquals(13,presenter.getVisibleRange().getLength());
}",0.9092454835281616
53712,"@Override public LogRecord instantiateInstance(ServerSerializationStreamReader reader) throws SerializationException {
  return LogRecord_CustomFieldSerializer.instantiate(reader);
}","@Override public LogRecord instantiateInstance(ServerSerializationStreamReader reader,Class<?> instanceClass,DequeMap<Type,Type> resolvedTypes) throws SerializationException {
  return LogRecord_CustomFieldSerializer.instantiate(reader);
}",0.8646080760095012
53713,"@SuppressWarnings(""String_Node_Str"") public static void deserialize(ServerSerializationStreamReader streamReader,LogRecord instance,Class<?> instanceClass,DequeMap<Type,Type> resolvedTypes) throws SerializationException {
  String loggerName=streamReader.readString();
  Long millis=streamReader.readLong();
  Object throwable=streamReader.readObject(Throwable.class,resolvedTypes);
  instance.setLoggerName(loggerName);
  instance.setMillis(millis);
  if (throwable != null && throwable instanceof SerializableThrowable) {
    instance.setThrown(((SerializableThrowable)throwable).getThrowable());
  }
}","@SuppressWarnings(""String_Node_Str"") public static void deserialize(ServerSerializationStreamReader streamReader,LogRecord instance,Class<?> instanceClass,DequeMap<Type,Type> resolvedTypes) throws SerializationException {
  String loggerName=streamReader.readString();
  Long millis=streamReader.readLong();
  Object throwable=streamReader.readObject(SerializableThrowable.class,resolvedTypes);
  instance.setLoggerName(loggerName);
  instance.setMillis(millis);
  if (throwable != null && throwable instanceof SerializableThrowable) {
    instance.setThrown(((SerializableThrowable)throwable).getThrowable());
  }
}",0.9901639344262296
53714,"public void onFailure(Throwable caught){
  TestSetValidator.rethrowException(caught);
}","public void onFailure(Throwable caught){
  TestSetValidator.rethrowException(caught);
  fail(caught.getMessage());
}",0.8571428571428571
53715,"public void testLogRecord(){
  LoggingRPCTestServiceAsync service=getServiceAsync();
  delayTestFinish(15000);
  service.echoLogRecord(expectedLogRecord,new AsyncCallback<LogRecord>(){
    public void onFailure(    Throwable caught){
      TestSetValidator.rethrowException(caught);
    }
    public void onSuccess(    LogRecord result){
      assertNotNull(result);
      assertTrue(isValid(result));
      finishTest();
    }
  }
);
  finishTest();
}","public void testLogRecord(){
  LoggingRPCTestServiceAsync service=getServiceAsync();
  delayTestFinish(15000);
  service.echoLogRecord(expectedLogRecord,new AsyncCallback<LogRecord>(){
    public void onFailure(    Throwable caught){
      TestSetValidator.rethrowException(caught);
      fail(caught.getMessage());
    }
    public void onSuccess(    LogRecord result){
      assertNotNull(result);
      assertTrue(isValid(result));
      finishTest();
    }
  }
);
}",0.9467969598262758
53716,"@Override public void onCellPreview(CellPreviewEvent<T> event){
  NativeEvent nativeEvent=event.getNativeEvent();
  String eventType=event.getNativeEvent().getType();
  if (""String_Node_Str"".equals(eventType) && !event.isCellEditing()) {
switch (nativeEvent.getKeyCode()) {
case KeyCodes.KEY_DOWN:
      nextRow();
    handledEvent(event);
  return;
case KeyCodes.KEY_UP:
prevRow();
handledEvent(event);
return;
case KeyCodes.KEY_PAGEDOWN:
nextPage();
handledEvent(event);
return;
case KeyCodes.KEY_PAGEUP:
prevPage();
handledEvent(event);
return;
case KeyCodes.KEY_HOME:
home();
handledEvent(event);
return;
case KeyCodes.KEY_END:
end();
handledEvent(event);
return;
case 32:
handledEvent(event);
return;
}
}
 else if (""String_Node_Str"".equals(eventType)) {
int relRow=event.getIndex() - display.getPageStart();
if (display.getKeyboardSelectedRow() != relRow) {
boolean isFocusable=false;
Element target=Element.as(event.getNativeEvent().getEventTarget());
isFocusable=CellBasedWidgetImpl.get().isFocusable(target);
display.setKeyboardSelectedRow(relRow,!isFocusable);
}
}
 else if (""String_Node_Str"".equals(eventType)) {
int relRow=event.getIndex() - display.getPageStart();
if (display.getKeyboardSelectedRow() != relRow) {
display.setKeyboardSelectedRow(event.getIndex(),false);
return;
}
}
}","@Override public void onCellPreview(CellPreviewEvent<T> event){
  NativeEvent nativeEvent=event.getNativeEvent();
  String eventType=event.getNativeEvent().getType();
  if (""String_Node_Str"".equals(eventType) && !event.isCellEditing()) {
switch (nativeEvent.getKeyCode()) {
case KeyCodes.KEY_DOWN:
      nextRow();
    handledEvent(event);
  return;
case KeyCodes.KEY_UP:
prevRow();
handledEvent(event);
return;
case KeyCodes.KEY_PAGEDOWN:
nextPage();
handledEvent(event);
return;
case KeyCodes.KEY_PAGEUP:
prevPage();
handledEvent(event);
return;
case KeyCodes.KEY_HOME:
home();
handledEvent(event);
return;
case KeyCodes.KEY_END:
end();
handledEvent(event);
return;
case 32:
handledEvent(event);
return;
}
}
 else if (""String_Node_Str"".equals(eventType)) {
int relRow=event.getIndex() - display.getPageStart();
boolean isFocusable=false;
Element target=Element.as(event.getNativeEvent().getEventTarget());
isFocusable=CellBasedWidgetImpl.get().isFocusable(target);
display.setKeyboardSelectedRow(relRow,!isFocusable);
}
 else if (""String_Node_Str"".equals(eventType)) {
int relRow=event.getIndex() - display.getPageStart();
if (display.getKeyboardSelectedRow() != relRow) {
display.setKeyboardSelectedRow(event.getIndex(),false);
return;
}
}
}",0.979527559055118
53717,"public Object getKey(String item){
  return Integer.parseInt(item.substring(5));
}","@Override public Object getKey(String item){
  return Integer.parseInt(item.substring(5));
}",0.942528735632184
53718,"/** 
 * Test that the correct values are sent to the Cell to be rendered.
 */
public void testRenderWithKeyProvider(){
  final List<String> rendered=new ArrayList<String>();
  final Cell<String> cell=new TextCell(){
    @Override public void render(    Context context,    SafeHtml data,    SafeHtmlBuilder sb){
      int call=rendered.size();
      rendered.add(data.asString());
      assertTrue(""String_Node_Str"",rendered.size() < 11);
      Object key=context.getKey();
      assertEquals(""String_Node_Str"" + call,data.asString());
      assertTrue(key instanceof Integer);
      assertEquals(call,key);
    }
  }
;
  ProvidesKey<String> keyProvider=new ProvidesKey<String>(){
    public Object getKey(    String item){
      return Integer.parseInt(item.substring(5));
    }
  }
;
  CellList<String> cellList=new CellList<String>(cell,keyProvider);
  cellList.setRowData(createData(0,10));
  cellList.getPresenter().flush();
  assertEquals(10,rendered.size());
}","/** 
 * Test that the correct values are sent to the Cell to be rendered.
 */
public void testRenderWithKeyProvider(){
  final List<String> rendered=new ArrayList<String>();
  final Cell<String> cell=new TextCell(){
    @Override public void render(    Context context,    SafeHtml data,    SafeHtmlBuilder sb){
      int call=rendered.size();
      rendered.add(data.asString());
      assertTrue(""String_Node_Str"",rendered.size() < 11);
      Object key=context.getKey();
      assertEquals(""String_Node_Str"" + call,data.asString());
      assertTrue(key instanceof Integer);
      assertEquals(call,key);
    }
  }
;
  ProvidesKey<String> keyProvider=new ProvidesKey<String>(){
    @Override public Object getKey(    String item){
      return Integer.parseInt(item.substring(5));
    }
  }
;
  CellList<String> cellList=new CellList<String>(cell,keyProvider);
  cellList.setRowData(createData(0,10));
  cellList.getPresenter().flush();
  assertEquals(10,rendered.size());
}",0.9948559670781894
53719,"private void createResourceUiRenderer(XMLElement elem,String resourceName,JClassType resourceType,JClassType matchingResourceType) throws UnableToCompleteException {
  FieldWriter fieldWriter;
  if (resourceType != null && !resourceType.getErasedType().isAssignableFrom(matchingResourceType.getErasedType())) {
    writer.die(elem,""String_Node_Str"",resourceName,writer.getBaseClass().getQualifiedSourceName());
  }
  fieldWriter=fieldManager.registerField(FieldWriterType.IMPORTED,matchingResourceType.getErasedType(),resourceName);
  fieldWriter.setInitializer(""String_Node_Str"" + resourceName);
}","private void createResourceUiRenderer(XMLElement elem,String resourceName,JClassType resourceType,JClassType matchingResourceType) throws UnableToCompleteException {
  FieldWriter fieldWriter;
  if (resourceType != null && !resourceType.getErasedType().isAssignableFrom(matchingResourceType.getErasedType())) {
    writer.die(elem,""String_Node_Str"",resourceName,writer.getBaseClass().getQualifiedSourceName());
  }
  fieldWriter=fieldManager.registerField(FieldWriterType.IMPORTED,matchingResourceType.getErasedType(),resourceName);
  fieldWriter.setInitializer(UiBinderWriter.RENDER_PARAM_HOLDER_PREFIX + resourceName);
}",0.9557377049180328
53720,"private void writeRenderParameterDefinitions(IndentedWriter w,JParameter[] renderParameters){
  for (int i=0; i < renderParameters.length; i++) {
    JParameter parameter=renderParameters[i];
    w.write(""String_Node_Str"",parameter.getType().getQualifiedSourceName(),parameter.getName());
    w.newline();
  }
}","private void writeRenderParameterDefinitions(IndentedWriter w,JParameter[] renderParameters){
  for (int i=0; i < renderParameters.length; i++) {
    JParameter parameter=renderParameters[i];
    w.write(""String_Node_Str"",parameter.getType().getQualifiedSourceName(),RENDER_PARAM_HOLDER_PREFIX,parameter.getName());
    w.newline();
  }
}",0.9183359013867488
53721,"private void writeRenderParameterInitializers(IndentedWriter w,JParameter[] renderParameters){
  for (int i=0; i < renderParameters.length; i++) {
    JParameter parameter=renderParameters[i];
    w.write(""String_Node_Str"",parameter.getName(),parameter.getName());
    w.newline();
  }
}","private void writeRenderParameterInitializers(IndentedWriter w,JParameter[] renderParameters){
  for (int i=0; i < renderParameters.length; i++) {
    JParameter parameter=renderParameters[i];
    w.write(""String_Node_Str"",RENDER_PARAM_HOLDER_PREFIX,parameter.getName(),parameter.getName());
    w.newline();
  }
}",0.8951747088186356
53722,"public void testFieldGetters(){
  assertTrue(renderer.isParentOrRenderer(docDiv));
  DivElement root=renderer.getRoot(docDiv);
  assertTrue(renderer.isParentOrRenderer(root));
  assertNotNull(root);
  assertSpanContainsRenderedValue(root);
  SpanElement nameSpan=renderer.getNameSpan(docDiv);
  assertSpanContainsRenderedValueText(nameSpan.getFirstChild());
  DivElement root2=renderer.getRoot(root);
  assertTrue(renderer.isParentOrRenderer(root2));
  assertNotNull(root2);
  assertSpanContainsRenderedValue(root2);
  nameSpan=renderer.getNameSpan(root);
  assertSpanContainsRenderedValueText(nameSpan.getFirstChild());
}","public void testFieldGetters(){
  assertTrue(renderer.isParentOrRenderer(docDiv));
  DivElement root=renderer.getRoot(docDiv);
  assertTrue(renderer.isParentOrRenderer(root));
  assertNotNull(root);
  assertSpanContainsRenderedValue(root);
  SpanElement nameSpan=renderer.getNameSpan(docDiv);
  assertSpanContainsRenderedValueText(RENDERED_VALUE,nameSpan.getFirstChild());
  DivElement root2=renderer.getRoot(root);
  assertTrue(renderer.isParentOrRenderer(root2));
  assertNotNull(root2);
  assertSpanContainsRenderedValue(root2);
  nameSpan=renderer.getNameSpan(root);
  assertSpanContainsRenderedValueText(RENDERED_VALUE,nameSpan.getFirstChild());
}",0.976452119309262
53723,"private void assertSpanContainsRenderedValue(Node root){
  Node firstFieldNode=root.getChild(2);
  assertEquals(Node.ELEMENT_NODE,firstFieldNode.getNodeType());
  assertEquals(""String_Node_Str"",firstFieldNode.getNodeName().toLowerCase());
  assertTrue(firstFieldNode.hasChildNodes());
  Node renderedValue=firstFieldNode.getFirstChild();
  assertSpanContainsRenderedValueText(renderedValue);
}","private void assertSpanContainsRenderedValue(Node root){
  Node firstFieldNode=root.getChild(2);
  assertEquals(Node.ELEMENT_NODE,firstFieldNode.getNodeType());
  assertEquals(""String_Node_Str"",firstFieldNode.getNodeName().toLowerCase());
  assertTrue(firstFieldNode.hasChildNodes());
  Node renderedValue=firstFieldNode.getFirstChild();
  assertSpanContainsRenderedValueText(RENDERED_VALUE,renderedValue);
}",0.961298377028714
53724,"public void testFieldGettersNotOnlyChild(){
  DivElement root=renderer.getRoot(docDiv);
  docDiv.appendChild(Document.get().createSpanElement());
  DivElement rootAgain=renderer.getRoot(docDiv);
  assertEquals(root,rootAgain);
  if (GWT.isProdMode()) {
    assertTrue(renderer.isParentOrRenderer(docDiv));
    SpanElement nameSpan=renderer.getNameSpan(docDiv);
    assertSpanContainsRenderedValueText(nameSpan.getFirstChild());
  }
 else {
    assertFalse(renderer.isParentOrRenderer(docDiv));
    try {
      renderer.getNameSpan(docDiv);
      fail(""String_Node_Str"");
    }
 catch (    IllegalArgumentException e) {
    }
  }
}","public void testFieldGettersNotOnlyChild(){
  DivElement root=renderer.getRoot(docDiv);
  docDiv.appendChild(Document.get().createSpanElement());
  DivElement rootAgain=renderer.getRoot(docDiv);
  assertEquals(root,rootAgain);
  if (GWT.isProdMode()) {
    assertTrue(renderer.isParentOrRenderer(docDiv));
    SpanElement nameSpan=renderer.getNameSpan(docDiv);
    assertSpanContainsRenderedValueText(RENDERED_VALUE,nameSpan.getFirstChild());
  }
 else {
    assertFalse(renderer.isParentOrRenderer(docDiv));
    try {
      renderer.getNameSpan(docDiv);
      fail(""String_Node_Str"");
    }
 catch (    IllegalArgumentException e) {
    }
  }
}",0.9882352941176472
53725,"public void testSafeHtmlRendererText(){
  Node innerDiv=docDiv.getFirstChild();
  Node spanWithConstantTextNode=innerDiv.getChild(0);
  assertEquals(""String_Node_Str"",spanWithConstantTextNode.getNodeName().toLowerCase());
  assertEquals(Node.TEXT_NODE,spanWithConstantTextNode.getFirstChild().getNodeType());
  assertEquals(""String_Node_Str"",spanWithConstantTextNode.getFirstChild().getNodeValue());
  Node firstRawTextNode=innerDiv.getChild(1);
  assertEquals(Node.TEXT_NODE,firstRawTextNode.getNodeType());
  assertEquals(""String_Node_Str"",firstRawTextNode.getNodeValue());
  assertSpanContainsRenderedValue(innerDiv);
  Node secondRawTextNode=innerDiv.getChild(3);
  assertEquals(Node.TEXT_NODE,secondRawTextNode.getNodeType());
  assertEquals(""String_Node_Str"",secondRawTextNode.getNodeValue());
  Node spanNode=innerDiv.getChild(4);
  assertEquals(Node.ELEMENT_NODE,spanNode.getNodeType());
  assertEquals(""String_Node_Str"",spanNode.getNodeName().toLowerCase());
  assertFalse(spanNode.hasChildNodes());
}","public void testSafeHtmlRendererText(){
  Node innerDiv=docDiv.getFirstChild();
  Node spanWithConstantTextNode=innerDiv.getChild(0);
  assertEquals(""String_Node_Str"",spanWithConstantTextNode.getNodeName().toLowerCase());
  assertEquals(Node.TEXT_NODE,spanWithConstantTextNode.getFirstChild().getNodeType());
  assertEquals(""String_Node_Str"",spanWithConstantTextNode.getFirstChild().getNodeValue());
  Node firstRawTextNode=innerDiv.getChild(1);
  assertEquals(Node.TEXT_NODE,firstRawTextNode.getNodeType());
  assertEquals(""String_Node_Str"",firstRawTextNode.getNodeValue());
  assertSpanContainsRenderedValue(innerDiv);
  Node secondRawTextNode=innerDiv.getChild(3);
  assertEquals(Node.TEXT_NODE,secondRawTextNode.getNodeType());
  assertEquals(""String_Node_Str"",secondRawTextNode.getNodeValue());
  Node spanNode=innerDiv.getChild(4);
  assertEquals(Node.ELEMENT_NODE,spanNode.getNodeType());
  assertEquals(""String_Node_Str"",spanNode.getNodeName().toLowerCase());
  assertFalse(spanNode.hasChildNodes());
  Node spanNode2=innerDiv.getChild(5);
  assertEquals(Node.ELEMENT_NODE,spanNode2.getNodeType());
  assertEquals(""String_Node_Str"",spanNode2.getNodeName().toLowerCase());
  assertTrue(spanNode2.hasChildNodes());
  assertSpanContainsRenderedValueText(RENDERED_VALUE_TWICE + RENDERED_VALUE_TWICE,spanNode2.getFirstChild());
}",0.8625106746370623
53726,"@Override public void gwtSetUp() throws Exception {
  super.gwtSetUp();
  UiRendererTestApp app=UiRendererTestApp.getInstance();
  safeHtmlUi=app.getSafeHtmlUi();
  renderedHtml=safeHtmlUi.render(RENDERED_VALUE);
  renderer=safeHtmlUi.getRenderer();
  docDiv=Document.get().createDivElement();
  docDiv.setInnerHTML(renderedHtml.asString());
  Document.get().getBody().appendChild(docDiv);
}","@Override public void gwtSetUp() throws Exception {
  super.gwtSetUp();
  UiRendererTestApp app=UiRendererTestApp.getInstance();
  safeHtmlUi=app.getSafeHtmlUi();
  renderedHtml=safeHtmlUi.render(RENDERED_VALUE,RENDERED_VALUE_TWICE);
  renderer=safeHtmlUi.getRenderer();
  docDiv=Document.get().createDivElement();
  docDiv.setInnerHTML(renderedHtml.asString());
  Document.get().getBody().appendChild(docDiv);
}",0.9738480697384808
53727,"private void assertSpanContainsRenderedValueText(Node renderedValue){
  assertEquals(Node.TEXT_NODE,renderedValue.getNodeType());
  assertEquals(RENDERED_VALUE,renderedValue.getNodeValue());
}","private void assertSpanContainsRenderedValueText(String expectedValue,Node renderedValue){
  assertEquals(Node.TEXT_NODE,renderedValue.getNodeType());
  assertEquals(expectedValue,renderedValue.getNodeValue());
}",0.8811881188118812
53728,"public SafeHtml render(String value){
  SafeHtmlBuilder sb=new SafeHtmlBuilder();
  getRenderer().render(sb,new Foo(value));
  return sb.toSafeHtml();
}","public SafeHtml render(String value,String valueTwice){
  SafeHtmlBuilder sb=new SafeHtmlBuilder();
  getRenderer().render(sb,new Foo(value),new Foo(valueTwice));
  return sb.toSafeHtml();
}",0.8888888888888888
53729,"public void onRowCountChange(RowCountChangeEvent event){
  if (AbstractPager.this.display != null) {
    handleRowCountChange(event.getNewRowCount(),event.isNewRowCountExact());
  }
}","@Override public void onRowCountChange(RowCountChangeEvent event){
  if (AbstractPager.this.display != null) {
    handleRowCountChange(event.getNewRowCount(),event.isNewRowCountExact());
  }
}",0.973404255319149
53730,"public void onRangeChange(RangeChangeEvent event){
  if (AbstractPager.this.display != null) {
    onRangeOrRowCountChanged();
  }
}","@Override public void onRangeChange(RangeChangeEvent event){
  if (AbstractPager.this.display != null) {
    onRangeOrRowCountChanged();
  }
}",0.9635036496350364
53731,"/** 
 * Set the   {@link HasRows} to be paged.
 * @param display the {@link HasRows}
 * @see #getDisplay()
 */
public void setDisplay(HasRows display){
  if (rangeChangeHandler != null) {
    rangeChangeHandler.removeHandler();
    rangeChangeHandler=null;
  }
  if (rowCountChangeHandler != null) {
    rowCountChangeHandler.removeHandler();
    rangeChangeHandler=null;
  }
  this.display=display;
  if (display != null) {
    rangeChangeHandler=display.addRangeChangeHandler(new RangeChangeEvent.Handler(){
      public void onRangeChange(      RangeChangeEvent event){
        if (AbstractPager.this.display != null) {
          onRangeOrRowCountChanged();
        }
      }
    }
);
    rowCountChangeHandler=display.addRowCountChangeHandler(new RowCountChangeEvent.Handler(){
      public void onRowCountChange(      RowCountChangeEvent event){
        if (AbstractPager.this.display != null) {
          handleRowCountChange(event.getNewRowCount(),event.isNewRowCountExact());
        }
      }
    }
);
    onRangeOrRowCountChanged();
  }
}","/** 
 * Set the   {@link HasRows} to be paged.
 * @param display the {@link HasRows}
 * @see #getDisplay()
 */
public void setDisplay(HasRows display){
  if (rangeChangeHandler != null) {
    rangeChangeHandler.removeHandler();
    rangeChangeHandler=null;
  }
  if (rowCountChangeHandler != null) {
    rowCountChangeHandler.removeHandler();
    rowCountChangeHandler=null;
  }
  this.display=display;
  if (display != null) {
    rangeChangeHandler=display.addRangeChangeHandler(new RangeChangeEvent.Handler(){
      @Override public void onRangeChange(      RangeChangeEvent event){
        if (AbstractPager.this.display != null) {
          onRangeOrRowCountChanged();
        }
      }
    }
);
    rowCountChangeHandler=display.addRowCountChangeHandler(new RowCountChangeEvent.Handler(){
      @Override public void onRowCountChange(      RowCountChangeEvent event){
        if (AbstractPager.this.display != null) {
          handleRowCountChange(event.getNewRowCount(),event.isNewRowCountExact());
        }
      }
    }
);
    onRangeOrRowCountChanged();
  }
}",0.9853704577630958
53732,"/** 
 * Performs a   {@link DOM#getElementById(String)} after attaching the panel'selement into a hidden DIV in the document's body. Attachment is necessary to be able to use the native getElementById. The panel's element will be re-attached to its original parent (if any) after the method returns.
 * @param id the id whose associated element is to be retrieved
 * @return the associated element, or <code>null</code> if none is found
 */
private Element attachToDomAndGetElement(String id){
  if (hiddenDiv == null) {
    hiddenDiv=Document.get().createDivElement();
    UIObject.setVisible(hiddenDiv,false);
    RootPanel.getBodyElement().appendChild(hiddenDiv);
  }
  Element origParent=getElement().getParentElement();
  Element origSibling=getElement().getNextSiblingElement();
  hiddenDiv.appendChild(getElement());
  Element child=Document.get().getElementById(id);
  if (origParent != null) {
    origParent.insertBefore(getElement(),origSibling);
  }
 else {
    hiddenDiv.removeChild(getElement());
  }
  return child;
}","/** 
 * Performs a   {@link Document#getElementById(String)} after attaching the panel'selement into a hidden DIV in the document's body. Attachment is necessary to be able to use the native getElementById. The panel's element will be re-attached to its original parent (if any) after the method returns.
 * @param id the id whose associated element is to be retrieved
 * @return the associated element, or <code>null</code> if none is found
 */
private Element attachToDomAndGetElement(String id){
  if (hiddenDiv == null) {
    hiddenDiv=Document.get().createDivElement();
    UIObject.setVisible(hiddenDiv,false);
    RootPanel.getBodyElement().appendChild(hiddenDiv);
  }
  Element origParent=getElement().getParentElement();
  Element origSibling=getElement().getNextSiblingElement();
  hiddenDiv.appendChild(getElement());
  Element child=Document.get().getElementById(id);
  if (origParent != null) {
    origParent.insertBefore(getElement(),origSibling);
  }
 else {
    hiddenDiv.removeChild(getElement());
  }
  return child;
}",0.9956500724987916
53733,"/** 
 * Ensures that   {@link HTMLPanel#addAndReplaceChild(Widget,String)} puts thewidget in exactly the right place in the DOM.
 */
public void testAddAndReplaceElement(){
  HTMLPanel hp=new HTMLPanel(""String_Node_Str"");
  Button button=new Button(""String_Node_Str"");
  hp.addAndReplaceElement(button,""String_Node_Str"");
  assertParentId(button,""String_Node_Str"");
  assertIsBetweenSiblings(button,""String_Node_Str"",""String_Node_Str"");
}","/** 
 * Ensures that   {@link HTMLPanel#addAndReplaceElement(Widget,String)} putsthe widget in exactly the right place in the DOM.
 */
public void testAddAndReplaceElement(){
  HTMLPanel hp=new HTMLPanel(""String_Node_Str"");
  Button button=new Button(""String_Node_Str"");
  hp.addAndReplaceElement(button,""String_Node_Str"");
  assertParentId(button,""String_Node_Str"");
  assertIsBetweenSiblings(button,""String_Node_Str"",""String_Node_Str"");
}",0.9772209567198178
53734,"/** 
 * Ensures that  {@link HTMLPanel#addAndReplaceElement(Widget,com.google.gwt.user.client.Element)}puts the widget in exactly the right place in the DOM.
 */
@SuppressWarnings(""String_Node_Str"") public void testAddAndReplaceElementForUserElement(){
  HTMLPanel hp=new HTMLPanel(""String_Node_Str"");
  RootPanel.get().add(hp);
  com.google.gwt.user.client.Element placeholder=hp.getElementById(""String_Node_Str"");
  Button button=new Button(""String_Node_Str"");
  hp.addAndReplaceElement(button,placeholder);
  assertParentId(button,""String_Node_Str"");
  assertIsBetweenSiblings(button,""String_Node_Str"",""String_Node_Str"");
}","/** 
 * Ensures that   {@link HTMLPanel#addAndReplaceElement(Widget,Element)} putsthe widget in exactly the right place in the DOM.
 */
@SuppressWarnings(""String_Node_Str"") public void testAddAndReplaceElementForUserElement(){
  HTMLPanel hp=new HTMLPanel(""String_Node_Str"");
  RootPanel.get().add(hp);
  com.google.gwt.user.client.Element placeholder=hp.getElementById(""String_Node_Str"");
  Button button=new Button(""String_Node_Str"");
  hp.addAndReplaceElement(button,placeholder);
  assertParentId(button,""String_Node_Str"");
  assertIsBetweenSiblings(button,""String_Node_Str"",""String_Node_Str"");
}",0.9690048939641108
53735,"public String getModuleName(){
  return ""String_Node_Str"";
}","@Override public String getModuleName(){
  return ""String_Node_Str"";
}",0.9230769230769232
53736,"public void addChild(HasWidgets container,Widget child){
  ((HTMLPanel)container).add(child,""String_Node_Str"");
}","@Override public void addChild(HasWidgets container,Widget child){
  ((HTMLPanel)container).add(child,""String_Node_Str"");
}",0.9576271186440678
53737,"public boolean isRowCountExact(){
  return presenter.isRowCountExact();
}","@Override public boolean isRowCountExact(){
  return presenter.isRowCountExact();
}",0.935897435897436
53738,"public ProvidesKey<T> getKeyProvider(){
  return presenter.getKeyProvider();
}","@Override public ProvidesKey<T> getKeyProvider(){
  return presenter.getKeyProvider();
}",0.9397590361445785
53739,"public void setLoadingState(LoadingState state){
  hasData.isRefreshing=true;
  hasData.onLoadingStateChanged(state);
  hasData.isRefreshing=false;
}","@Override public void setLoadingState(LoadingState state){
  hasData.isRefreshing=true;
  hasData.onLoadingStateChanged(state);
  hasData.isRefreshing=false;
}",0.9675324675324676
53740,"public HandlerRegistration addCellPreviewHandler(CellPreviewEvent.Handler<T> handler){
  return presenter.addCellPreviewHandler(handler);
}","@Override public HandlerRegistration addCellPreviewHandler(CellPreviewEvent.Handler<T> handler){
  return presenter.addCellPreviewHandler(handler);
}",0.9652777777777778
53741,"public int getTabIndex(){
  return tabIndex;
}","@Override public int getTabIndex(){
  return tabIndex;
}",0.9019607843137256
53742,"public int getRowCount(){
  return presenter.getRowCount();
}","@Override public int getRowCount(){
  return presenter.getRowCount();
}",0.9242424242424242
53743,"public SelectionModel<? super T> getSelectionModel(){
  return presenter.getSelectionModel();
}","@Override public SelectionModel<? super T> getSelectionModel(){
  return presenter.getSelectionModel();
}",0.95
53744,"public KeyboardPagingPolicy getKeyboardPagingPolicy(){
  return presenter.getKeyboardPagingPolicy();
}","@Override public KeyboardPagingPolicy getKeyboardPagingPolicy(){
  return presenter.getKeyboardPagingPolicy();
}",0.9532710280373832
53745,"public void execute(){
  if (!hasData.resetFocusOnCell()) {
    Element elem=hasData.getKeyboardSelectedElement();
    if (elem != null) {
      elem.focus();
    }
  }
}","@Override public void execute(){
  if (!hasData.resetFocusOnCell()) {
    Element elem=hasData.getKeyboardSelectedElement();
    if (elem != null) {
      elem.focus();
    }
  }
}",0.9714285714285714
53746,"public void setKeyboardPagingPolicy(KeyboardPagingPolicy policy){
  presenter.setKeyboardPagingPolicy(policy);
}","@Override public void setKeyboardPagingPolicy(KeyboardPagingPolicy policy){
  presenter.setKeyboardPagingPolicy(policy);
}",0.9572649572649572
53747,"public void setVisibleRange(Range range){
  presenter.setVisibleRange(range);
}","@Override public void setVisibleRange(Range range){
  presenter.setVisibleRange(range);
}",0.9404761904761904
53748,"public void setVisibleRangeAndClearData(Range range,boolean forceRangeChangeEvent){
  presenter.setVisibleRangeAndClearData(range,forceRangeChangeEvent);
}","@Override public void setVisibleRangeAndClearData(Range range,boolean forceRangeChangeEvent){
  presenter.setVisibleRangeAndClearData(range,forceRangeChangeEvent);
}",0.96875
53749,"/** 
 * {@inheritDoc}
 * @see #getAccessKey()
 */
public void setAccessKey(char key){
  this.accessKey=key;
  setKeyboardSelected(getKeyboardSelectedRow(),true,false);
}","/** 
 * {@inheritDoc}
 * @see #getAccessKey()
 */
@Override public void setAccessKey(char key){
  this.accessKey=key;
  setKeyboardSelected(getKeyboardSelectedRow(),true,false);
}",0.971264367816092
53750,"public void setRowData(int start,List<? extends T> values){
  presenter.setRowData(start,values);
}","@Override public void setRowData(int start,List<? extends T> values){
  presenter.setRowData(start,values);
}",0.9519230769230768
53751,"public int getVisibleItemCount(){
  return presenter.getVisibleItemCount();
}","@Override public int getVisibleItemCount(){
  return presenter.getVisibleItemCount();
}",0.9390243902439024
53752,"public void setKeyboardSelectionPolicy(KeyboardSelectionPolicy policy){
  presenter.setKeyboardSelectionPolicy(policy);
}","@Override public void setKeyboardSelectionPolicy(KeyboardSelectionPolicy policy){
  presenter.setKeyboardSelectionPolicy(policy);
}",0.9603174603174603
53753,"public void render(SafeHtmlBuilder sb,List<T> values,int start,SelectionModel<? super T> selectionModel){
  hasData.renderRowValues(sb,values,start,selectionModel);
}","@Override public void render(SafeHtmlBuilder sb,List<T> values,int start,SelectionModel<? super T> selectionModel){
  hasData.renderRowValues(sb,values,start,selectionModel);
}",0.9707602339181286
53754,"public <H extends EventHandler>HandlerRegistration addHandler(H handler,Type<H> type){
  return hasData.addHandler(handler,type);
}","@Override public <H extends EventHandler>HandlerRegistration addHandler(H handler,Type<H> type){
  return hasData.addHandler(handler,type);
}",0.9632352941176472
53755,"public HandlerRegistration addRangeChangeHandler(RangeChangeEvent.Handler handler){
  return presenter.addRangeChangeHandler(handler);
}","@Override public HandlerRegistration addRangeChangeHandler(RangeChangeEvent.Handler handler){
  return presenter.addRangeChangeHandler(handler);
}",0.9645390070921984
53756,"public void setFocus(boolean focused){
  Element elem=getKeyboardSelectedElement();
  if (elem != null) {
    if (focused) {
      elem.focus();
    }
 else {
      elem.blur();
    }
  }
}","@Override public void setFocus(boolean focused){
  Element elem=getKeyboardSelectedElement();
  if (elem != null) {
    if (focused) {
      elem.focus();
    }
 else {
      elem.blur();
    }
  }
}",0.9742268041237112
53757,"public HandlerRegistration addRowCountChangeHandler(RowCountChangeEvent.Handler handler){
  return presenter.addRowCountChangeHandler(handler);
}","@Override public HandlerRegistration addRowCountChangeHandler(RowCountChangeEvent.Handler handler){
  return presenter.addRowCountChangeHandler(handler);
}",0.9666666666666668
53758,"public Range getVisibleRange(){
  return presenter.getVisibleRange();
}","@Override public Range getVisibleRange(){
  return presenter.getVisibleRange();
}",0.9342105263157896
53759,"public KeyboardSelectionPolicy getKeyboardSelectionPolicy(){
  return presenter.getKeyboardSelectionPolicy();
}","@Override public KeyboardSelectionPolicy getKeyboardSelectionPolicy(){
  return presenter.getKeyboardSelectionPolicy();
}",0.956896551724138
53760,"public void setTabIndex(int index){
  this.tabIndex=index;
  setKeyboardSelected(getKeyboardSelectedRow(),true,false);
}","@Override public void setTabIndex(int index){
  this.tabIndex=index;
  setKeyboardSelected(getKeyboardSelectedRow(),true,false);
}",0.96
53761,"public T getVisibleItem(int indexOnPage){
  checkRowBounds(indexOnPage);
  return presenter.getVisibleItem(indexOnPage);
}","@Override public T getVisibleItem(int indexOnPage){
  checkRowBounds(indexOnPage);
  return presenter.getVisibleItem(indexOnPage);
}",0.9606299212598424
53762,"public void setRowCount(int size,boolean isExact){
  presenter.setRowCount(size,isExact);
}","@Override public void setRowCount(int size,boolean isExact){
  presenter.setRowCount(size,isExact);
}",0.9479166666666666
53763,"public void resetFocus(){
  if (wasFocused) {
    CellBasedWidgetImpl.get().resetFocus(new Scheduler.ScheduledCommand(){
      public void execute(){
        if (!hasData.resetFocusOnCell()) {
          Element elem=hasData.getKeyboardSelectedElement();
          if (elem != null) {
            elem.focus();
          }
        }
      }
    }
);
  }
}","@Override public void resetFocus(){
  if (wasFocused) {
    CellBasedWidgetImpl.get().resetFocus(new Scheduler.ScheduledCommand(){
      @Override public void execute(){
        if (!hasData.resetFocusOnCell()) {
          Element elem=hasData.getKeyboardSelectedElement();
          if (elem != null) {
            elem.focus();
          }
        }
      }
    }
);
  }
}",0.9725274725274724
53764,"/** 
 * Return the row values that the widget is currently displaying as an immutable list.
 * @return a List of displayed items
 */
public List<T> getVisibleItems(){
  return presenter.getVisibleItems();
}","/** 
 * Return the row values that the widget is currently displaying as an immutable list.
 * @return a List of displayed items
 */
@Override public List<T> getVisibleItems(){
  return presenter.getVisibleItems();
}",0.976303317535545
53765,"@Override public void replaceAllChildren(List<C> values,SafeHtml html,boolean stealFocus){
  if (nodeView.tree.isAnimationEnabled()) {
    nodeView.ensureAnimationFrame().getStyle().setDisplay(Display.NONE);
  }
  nodeView.tree.isRefreshing=true;
  Map<Object,CellTreeNodeView<?>> savedViews=saveChildState(values,0);
  AbstractHasData.replaceAllChildren(nodeView.tree,childContainer,html);
  nodeView.tree.isRefreshing=false;
  int size=values.size();
  int childCount=nodeView.children.size();
  while (childCount > size) {
    childCount--;
    nodeView.children.remove(childCount);
  }
  loadChildState(values,0,savedViews);
  if (nodeView.isRootNode() && nodeView.tree.getKeyboardSelectedNode() == nodeView && values.size() > 0) {
    nodeView.tree.keyboardSelect(nodeView.children.get(0),false);
  }
  if (nodeView.tree.isAnimationEnabled()) {
    nodeView.tree.maybeAnimateTreeNode(nodeView);
  }
}","@Override public void replaceAllChildren(List<C> values,SafeHtml html,boolean stealFocus,boolean contentChanged){
  if (nodeView.tree.isAnimationEnabled()) {
    nodeView.ensureAnimationFrame().getStyle().setDisplay(Display.NONE);
  }
  nodeView.tree.isRefreshing=true;
  Map<Object,CellTreeNodeView<?>> savedViews=saveChildState(values,0);
  if (contentChanged) {
    AbstractHasData.replaceAllChildren(nodeView.tree,childContainer,html);
  }
  nodeView.tree.isRefreshing=false;
  int size=values.size();
  int childCount=nodeView.children.size();
  while (childCount > size) {
    childCount--;
    nodeView.children.remove(childCount);
  }
  loadChildState(values,0,savedViews);
  if (nodeView.isRootNode() && nodeView.tree.getKeyboardSelectedNode() == nodeView && values.size() > 0) {
    nodeView.tree.keyboardSelect(nodeView.children.get(0),false);
  }
  if (nodeView.tree.isAnimationEnabled()) {
    nodeView.tree.maybeAnimateTreeNode(nodeView);
  }
}",0.971551261406334
53766,"public boolean isRowCountExact(){
  return presenter.isRowCountExact();
}","@Override public boolean isRowCountExact(){
  return presenter.isRowCountExact();
}",0.935897435897436
53767,"public void fireEvent(GwtEvent<?> event){
  handlerManger.fireEvent(event);
}","@Override public void fireEvent(GwtEvent<?> event){
  handlerManger.fireEvent(event);
}",0.9390243902439024
53768,"public void setLoadingState(LoadingState state){
  nodeView.updateImage(state == LoadingState.LOADING);
  showOrHide(nodeView.emptyMessageElem,state == LoadingState.LOADED && presenter.isEmpty());
}","@Override public void setLoadingState(LoadingState state){
  nodeView.updateImage(state == LoadingState.LOADING);
  showOrHide(nodeView.emptyMessageElem,state == LoadingState.LOADED && presenter.isEmpty());
}",0.9753694581280788
53769,"public void onRowCountChange(RowCountChangeEvent event){
  int rowCount=event.getNewRowCount();
  boolean isExact=event.isNewRowCountExact();
  int pageSize=getVisibleRange().getLength();
  showOrHide(nodeView.showMoreElem,isExact && rowCount > pageSize);
}","@Override public void onRowCountChange(RowCountChangeEvent event){
  int rowCount=event.getNewRowCount();
  boolean isExact=event.isNewRowCountExact();
  int pageSize=getVisibleRange().getLength();
  showOrHide(nodeView.showMoreElem,isExact && rowCount > pageSize);
}",0.9809160305343512
53770,"public HandlerRegistration addCellPreviewHandler(Handler<C> handler){
  return presenter.addCellPreviewHandler(handler);
}","@Override public HandlerRegistration addCellPreviewHandler(Handler<C> handler){
  return presenter.addCellPreviewHandler(handler);
}",0.9606299212598424
53771,"public boolean isChildLeaf(int index){
  assertNotDestroyed();
  checkChildBounds(index);
  flush();
  return nodeView.getChildNode(index).isLeaf();
}","@Override public boolean isChildLeaf(int index){
  assertNotDestroyed();
  checkChildBounds(index);
  flush();
  return nodeView.getChildNode(index).isLeaf();
}",0.967741935483871
53772,"public void replaceChildren(List<C> values,int start,SafeHtml html,boolean stealFocus){
  Map<Object,CellTreeNodeView<?>> savedViews=saveChildState(values,start);
  nodeView.tree.isRefreshing=true;
  Element newChildren=AbstractHasData.convertToElements(nodeView.tree,getTmpElem(),html);
  AbstractHasData.replaceChildren(nodeView.tree,childContainer,newChildren,start,html);
  nodeView.tree.isRefreshing=false;
  loadChildState(values,start,savedViews);
}","@Override public void replaceChildren(List<C> values,int start,SafeHtml html,boolean stealFocus){
  Map<Object,CellTreeNodeView<?>> savedViews=saveChildState(values,start);
  nodeView.tree.isRefreshing=true;
  Element newChildren=AbstractHasData.convertToElements(nodeView.tree,getTmpElem(),html);
  AbstractHasData.replaceChildren(nodeView.tree,childContainer,newChildren,start,html);
  nodeView.tree.isRefreshing=false;
  loadChildState(values,start,savedViews);
}",0.9891540130151844
53773,"public int getRowCount(){
  return presenter.getRowCount();
}","@Override public int getRowCount(){
  return presenter.getRowCount();
}",0.9242424242424242
53774,"public SelectionModel<? super C> getSelectionModel(){
  return presenter.getSelectionModel();
}","@Override public SelectionModel<? super C> getSelectionModel(){
  return presenter.getSelectionModel();
}",0.95
53775,"public void execute(){
  tree.setFocus(true);
}","@Override public void execute(){
  tree.setFocus(true);
}",0.903846153846154
53776,"/** 
 * Reload the open children after rendering new items in this node.
 * @param values the values being replaced
 * @param start the start index
 * @param savedViews the open nodes
 */
private void loadChildState(List<C> values,int start,Map<Object,CellTreeNodeView<?>> savedViews){
  int len=values.size();
  int end=start + len;
  int childCount=nodeView.getChildCount();
  ProvidesKey<C> keyProvider=nodeInfo.getProvidesKey();
  Element container=nodeView.ensureChildContainer();
  Element childElem=container.getChild(start).cast();
  CellTreeNodeView<?> keyboardSelected=nodeView.tree.getKeyboardSelectedNode();
  for (int i=start; i < end; i++) {
    C childValue=values.get(i - start);
    CellTreeNodeView<C> child=nodeView.createTreeNodeView(nodeInfo,childElem,childValue,null);
    CellTreeNodeView<?> savedChild=savedViews.remove(keyProvider.getKey(childValue));
    if (savedChild != null) {
      child.animationFrame=savedChild.animationFrame;
      child.contentContainer=savedChild.contentContainer;
      child.childContainer=savedChild.childContainer;
      child.children=savedChild.children;
      child.emptyMessageElem=savedChild.emptyMessageElem;
      child.nodeInfo=savedChild.nodeInfo;
      child.nodeInfoLoaded=savedChild.nodeInfoLoaded;
      child.open=savedChild.open;
      child.showMoreElem=savedChild.showMoreElem;
      child.treeNode=savedChild.treeNode;
      if (child.treeNode != null) {
        child.treeNode.nodeView=child;
      }
      child.listView=savedChild.listView;
      if (child.listView != null) {
        child.listView.nodeView=child;
      }
      if (child.children != null) {
        for (        CellTreeNodeView<?> grandchild : child.children) {
          grandchild.parentNode=child;
        }
      }
      if (keyboardSelected == savedChild) {
        keyboardSelected=child;
      }
      child.getElement().appendChild(savedChild.ensureAnimationFrame());
      savedChild.isDestroyed=true;
    }
    if (childCount > i) {
      nodeView.children.set(i,child);
    }
 else {
      nodeView.children.add(child);
    }
    childElem=childElem.getNextSiblingElement();
  }
  CellTreeNodeView<?> curNode=keyboardSelected;
  while (curNode != null) {
    if (curNode == nodeView) {
      nodeView.tree.keyboardSelect(keyboardSelected,false);
      break;
    }
    curNode=curNode.parentNode;
  }
}","/** 
 * Reload the open children after rendering new items in this node.
 * @param values the values being replaced
 * @param start the start index
 * @param savedViews the open nodes
 */
private void loadChildState(List<C> values,int start,Map<Object,CellTreeNodeView<?>> savedViews){
  int len=values.size();
  int end=start + len;
  int childCount=nodeView.getChildCount();
  ProvidesKey<C> keyProvider=nodeInfo.getProvidesKey();
  Element container=nodeView.ensureChildContainer();
  Element childElem=(values.size() == 0) ? null : Element.as(container.getChild(start));
  CellTreeNodeView<?> keyboardSelected=nodeView.tree.getKeyboardSelectedNode();
  for (int i=start; i < end; i++) {
    C childValue=values.get(i - start);
    CellTreeNodeView<C> child=nodeView.createTreeNodeView(nodeInfo,childElem,childValue,null);
    CellTreeNodeView<?> savedChild=savedViews.remove(keyProvider.getKey(childValue));
    if (savedChild != null) {
      child.animationFrame=savedChild.animationFrame;
      child.contentContainer=savedChild.contentContainer;
      child.childContainer=savedChild.childContainer;
      child.children=savedChild.children;
      child.emptyMessageElem=savedChild.emptyMessageElem;
      child.nodeInfo=savedChild.nodeInfo;
      child.nodeInfoLoaded=savedChild.nodeInfoLoaded;
      child.open=savedChild.open;
      child.showMoreElem=savedChild.showMoreElem;
      child.treeNode=savedChild.treeNode;
      if (child.treeNode != null) {
        child.treeNode.nodeView=child;
      }
      child.listView=savedChild.listView;
      if (child.listView != null) {
        child.listView.nodeView=child;
      }
      if (child.children != null) {
        for (        CellTreeNodeView<?> grandchild : child.children) {
          grandchild.parentNode=child;
        }
      }
      if (keyboardSelected == savedChild) {
        keyboardSelected=child;
      }
      child.getElement().appendChild(savedChild.ensureAnimationFrame());
      savedChild.isDestroyed=true;
    }
    if (childCount > i) {
      nodeView.children.set(i,child);
    }
 else {
      nodeView.children.add(child);
    }
    childElem=childElem.getNextSiblingElement();
  }
  CellTreeNodeView<?> curNode=keyboardSelected;
  while (curNode != null) {
    if (curNode == nodeView) {
      nodeView.tree.keyboardSelect(keyboardSelected,false);
      break;
    }
    curNode=curNode.parentNode;
  }
}",0.9901239756251312
53777,"public void setSelectionModel(final SelectionModel<? super C> selectionModel){
  presenter.setSelectionModel(selectionModel);
}","@Override public void setSelectionModel(final SelectionModel<? super C> selectionModel){
  presenter.setSelectionModel(selectionModel);
}",0.9621212121212122
53778,"public void setVisibleRange(Range range){
  presenter.setVisibleRange(range);
}","@Override public void setVisibleRange(Range range){
  presenter.setVisibleRange(range);
}",0.9404761904761904
53779,"public void setVisibleRangeAndClearData(Range range,boolean forceRangeChangeEvent){
  presenter.setVisibleRangeAndClearData(range,forceRangeChangeEvent);
}","@Override public void setVisibleRangeAndClearData(Range range,boolean forceRangeChangeEvent){
  presenter.setVisibleRangeAndClearData(range,forceRangeChangeEvent);
}",0.96875
53780,"public void replaceAllChildren(List<C> values,SafeHtml html,boolean stealFocus){
  if (nodeView.tree.isAnimationEnabled()) {
    nodeView.ensureAnimationFrame().getStyle().setDisplay(Display.NONE);
  }
  nodeView.tree.isRefreshing=true;
  Map<Object,CellTreeNodeView<?>> savedViews=saveChildState(values,0);
  AbstractHasData.replaceAllChildren(nodeView.tree,childContainer,html);
  nodeView.tree.isRefreshing=false;
  int size=values.size();
  int childCount=nodeView.children.size();
  while (childCount > size) {
    childCount--;
    nodeView.children.remove(childCount);
  }
  loadChildState(values,0,savedViews);
  if (nodeView.isRootNode() && nodeView.tree.getKeyboardSelectedNode() == nodeView && values.size() > 0) {
    nodeView.tree.keyboardSelect(nodeView.children.get(0),false);
  }
  if (nodeView.tree.isAnimationEnabled()) {
    nodeView.tree.maybeAnimateTreeNode(nodeView);
  }
}","@Override public void replaceAllChildren(List<C> values,SafeHtml html,boolean stealFocus){
  if (nodeView.tree.isAnimationEnabled()) {
    nodeView.ensureAnimationFrame().getStyle().setDisplay(Display.NONE);
  }
  nodeView.tree.isRefreshing=true;
  Map<Object,CellTreeNodeView<?>> savedViews=saveChildState(values,0);
  AbstractHasData.replaceAllChildren(nodeView.tree,childContainer,html);
  nodeView.tree.isRefreshing=false;
  int size=values.size();
  int childCount=nodeView.children.size();
  while (childCount > size) {
    childCount--;
    nodeView.children.remove(childCount);
  }
  loadChildState(values,0,savedViews);
  if (nodeView.isRootNode() && nodeView.tree.getKeyboardSelectedNode() == nodeView && values.size() > 0) {
    nodeView.tree.keyboardSelect(nodeView.children.get(0),false);
  }
  if (nodeView.tree.isAnimationEnabled()) {
    nodeView.tree.maybeAnimateTreeNode(nodeView);
  }
}",0.9944444444444444
53781,"public void setRowData(int start,List<? extends C> values){
  presenter.setRowData(start,values);
}","@Override public void setRowData(int start,List<? extends C> values){
  presenter.setRowData(start,values);
}",0.9519230769230768
53782,"public int getVisibleItemCount(){
  return presenter.getVisibleItemCount();
}","@Override public int getVisibleItemCount(){
  return presenter.getVisibleItemCount();
}",0.9390243902439024
53783,"public Object getChildValue(int index){
  assertNotDestroyed();
  checkChildBounds(index);
  flush();
  return nodeView.getChildNode(index).value;
}","@Override public Object getChildValue(int index){
  assertNotDestroyed();
  checkChildBounds(index);
  flush();
  return nodeView.getChildNode(index).value;
}",0.9673202614379084
53784,"public TreeNode setChildOpen(int index,boolean open,boolean fireEvents){
  assertNotDestroyed();
  checkChildBounds(index);
  CellTreeNodeView<?> child=nodeView.getChildNode(index);
  return child.setOpen(open,fireEvents) ? child.treeNode : null;
}","@Override public TreeNode setChildOpen(int index,boolean open,boolean fireEvents){
  assertNotDestroyed();
  checkChildBounds(index);
  CellTreeNodeView<?> child=nodeView.getChildNode(index);
  return child.setOpen(open,fireEvents) ? child.treeNode : null;
}",0.9802371541501976
53785,"/** 
 * Fire an event to the   {@link com.google.gwt.cell.client.AbstractCell}.
 * @param event the native event
 */
@SuppressWarnings(""String_Node_Str"") protected void fireEventToCell(NativeEvent event){
  if (parentNodeInfo == null) {
    return;
  }
  Cell<T> parentCell=parentNodeInfo.getCell();
  String eventType=event.getType();
  Element cellParent=getCellParent();
  Object key=getValueKey();
  Context context=new Context(getIndex(),0,key);
  boolean cellWasEditing=parentCell.isEditing(context,cellParent,value);
  boolean isSelectionHandled=parentCell.handlesSelection() || KeyboardSelectionPolicy.BOUND_TO_SELECTION == tree.getKeyboardSelectionPolicy();
  HasData<T> display=(HasData<T>)parentNode.listView;
  CellPreviewEvent<T> previewEvent=CellPreviewEvent.fire(display,event,display,context,value,cellWasEditing,isSelectionHandled);
  if (previewEvent.isCanceled() || !cellParent.isOrHasChild(Element.as(event.getEventTarget()))) {
    return;
  }
  Set<String> consumedEvents=parentCell.getConsumedEvents();
  if (consumedEvents != null && consumedEvents.contains(eventType)) {
    parentCell.onBrowserEvent(context,cellParent,value,event,parentNodeInfo.getValueUpdater());
    tree.cellIsEditing=parentCell.isEditing(context,cellParent,value);
    if (cellWasEditing && !tree.cellIsEditing) {
      CellBasedWidgetImpl.get().resetFocus(new Scheduler.ScheduledCommand(){
        public void execute(){
          tree.setFocus(true);
        }
      }
);
    }
  }
}","/** 
 * Fire an event to the   {@link com.google.gwt.cell.client.AbstractCell}.
 * @param event the native event
 */
@SuppressWarnings(""String_Node_Str"") protected void fireEventToCell(NativeEvent event){
  if (parentNodeInfo == null) {
    return;
  }
  Cell<T> parentCell=parentNodeInfo.getCell();
  String eventType=event.getType();
  Element cellParent=getCellParent();
  Object key=getValueKey();
  Context context=new Context(getIndex(),0,key);
  boolean cellWasEditing=parentCell.isEditing(context,cellParent,value);
  boolean isSelectionHandled=parentCell.handlesSelection() || KeyboardSelectionPolicy.BOUND_TO_SELECTION == tree.getKeyboardSelectionPolicy();
  HasData<T> display=(HasData<T>)parentNode.listView;
  CellPreviewEvent<T> previewEvent=CellPreviewEvent.fire(display,event,display,context,value,cellWasEditing,isSelectionHandled);
  if (previewEvent.isCanceled() || !cellParent.isOrHasChild(Element.as(event.getEventTarget()))) {
    return;
  }
  Set<String> consumedEvents=parentCell.getConsumedEvents();
  if (consumedEvents != null && consumedEvents.contains(eventType)) {
    parentCell.onBrowserEvent(context,cellParent,value,event,parentNodeInfo.getValueUpdater());
    tree.cellIsEditing=parentCell.isEditing(context,cellParent,value);
    if (cellWasEditing && !tree.cellIsEditing) {
      CellBasedWidgetImpl.get().resetFocus(new Scheduler.ScheduledCommand(){
        @Override public void execute(){
          tree.setFocus(true);
        }
      }
);
    }
  }
}",0.9966397849462364
53786,"public void render(SafeHtmlBuilder sb,List<C> values,int start,SelectionModel<? super C> selectionModel){
  CellTree.Style style=nodeView.tree.getStyle();
  String itemValueStyle=style.cellTreeItemValue();
  String selectedStyle=""String_Node_Str"" + style.cellTreeSelectedItem();
  String itemStyle=style.cellTreeItem();
  String itemImageValueStyle=""String_Node_Str"" + style.cellTreeItemImageValue();
  String openStyle=""String_Node_Str"" + style.cellTreeOpenItem();
  String topStyle=""String_Node_Str"" + style.cellTreeTopItem();
  String topImageValueStyle=""String_Node_Str"" + style.cellTreeTopItemImageValue();
  boolean isRootNode=nodeView.isRootNode();
  SafeHtml openImage=nodeView.tree.getOpenImageHtml(isRootNode);
  SafeHtml closedImage=nodeView.tree.getClosedImageHtml(isRootNode);
  int imageWidth=nodeView.tree.getImageWidth();
  String paddingDirection=LocaleInfo.getCurrentLocale().isRTL() ? ""String_Node_Str"" : ""String_Node_Str"";
  int paddingAmount=imageWidth * nodeView.depth;
  Set<Object> openNodes=new HashSet<Object>();
  int childCount=nodeView.getChildCount();
  int end=start + values.size();
  for (int i=start; i < end && i < childCount; i++) {
    CellTreeNodeView<?> child=nodeView.getChildNode(i);
    if (child.isOpen()) {
      openNodes.add(child.getValueKey());
    }
  }
  ProvidesKey<C> keyProvider=nodeInfo.getProvidesKey();
  TreeViewModel model=nodeView.tree.getTreeViewModel();
  for (int i=start; i < end; i++) {
    C value=values.get(i - start);
    Object key=keyProvider.getKey(value);
    boolean isOpen=openNodes.contains(key);
    StringBuilder outerClasses=new StringBuilder(itemStyle);
    if (isOpen) {
      outerClasses.append(openStyle);
    }
    if (isRootNode) {
      outerClasses.append(topStyle);
    }
    if (selectionModel != null && selectionModel.isSelected(value)) {
      outerClasses.append(selectedStyle);
    }
    StringBuilder innerClasses=new StringBuilder(itemStyle);
    innerClasses.append(itemImageValueStyle);
    if (isRootNode) {
      innerClasses.append(topImageValueStyle);
    }
    SafeHtml image;
    if (isOpen) {
      image=openImage;
    }
 else     if (model.isLeaf(value)) {
      image=LEAF_IMAGE;
    }
 else {
      image=closedImage;
    }
    SafeHtmlBuilder cellBuilder=new SafeHtmlBuilder();
    Context context=new Context(i,0,key);
    cell.render(context,value,cellBuilder);
    SafeStyles innerPadding=SafeStylesUtils.fromTrustedString(""String_Node_Str"" + paddingDirection + ""String_Node_Str""+ imageWidth+ ""String_Node_Str"");
    SafeHtml innerDiv=template.innerDiv(innerPadding,innerClasses.toString(),image,itemValueStyle,cellBuilder.toSafeHtml());
    SafeStyles outerPadding=SafeStylesUtils.fromTrustedString(""String_Node_Str"" + paddingDirection + ""String_Node_Str""+ paddingAmount+ ""String_Node_Str"");
    sb.append(template.outerDiv(outerPadding,outerClasses.toString(),innerDiv));
  }
}","@Override public void render(SafeHtmlBuilder sb,List<C> values,int start,SelectionModel<? super C> selectionModel){
  CellTree.Style style=nodeView.tree.getStyle();
  String itemValueStyle=style.cellTreeItemValue();
  String selectedStyle=""String_Node_Str"" + style.cellTreeSelectedItem();
  String itemStyle=style.cellTreeItem();
  String itemImageValueStyle=""String_Node_Str"" + style.cellTreeItemImageValue();
  String openStyle=""String_Node_Str"" + style.cellTreeOpenItem();
  String topStyle=""String_Node_Str"" + style.cellTreeTopItem();
  String topImageValueStyle=""String_Node_Str"" + style.cellTreeTopItemImageValue();
  boolean isRootNode=nodeView.isRootNode();
  SafeHtml openImage=nodeView.tree.getOpenImageHtml(isRootNode);
  SafeHtml closedImage=nodeView.tree.getClosedImageHtml(isRootNode);
  int imageWidth=nodeView.tree.getImageWidth();
  String paddingDirection=LocaleInfo.getCurrentLocale().isRTL() ? ""String_Node_Str"" : ""String_Node_Str"";
  int paddingAmount=imageWidth * nodeView.depth;
  Set<Object> openNodes=new HashSet<Object>();
  int childCount=nodeView.getChildCount();
  int end=start + values.size();
  for (int i=start; i < end && i < childCount; i++) {
    CellTreeNodeView<?> child=nodeView.getChildNode(i);
    if (child.isOpen()) {
      openNodes.add(child.getValueKey());
    }
  }
  ProvidesKey<C> keyProvider=nodeInfo.getProvidesKey();
  TreeViewModel model=nodeView.tree.getTreeViewModel();
  for (int i=start; i < end; i++) {
    C value=values.get(i - start);
    Object key=keyProvider.getKey(value);
    boolean isOpen=openNodes.contains(key);
    StringBuilder outerClasses=new StringBuilder(itemStyle);
    if (isOpen) {
      outerClasses.append(openStyle);
    }
    if (isRootNode) {
      outerClasses.append(topStyle);
    }
    if (selectionModel != null && selectionModel.isSelected(value)) {
      outerClasses.append(selectedStyle);
    }
    StringBuilder innerClasses=new StringBuilder(itemStyle);
    innerClasses.append(itemImageValueStyle);
    if (isRootNode) {
      innerClasses.append(topImageValueStyle);
    }
    SafeHtml image;
    if (isOpen) {
      image=openImage;
    }
 else     if (model.isLeaf(value)) {
      image=LEAF_IMAGE;
    }
 else {
      image=closedImage;
    }
    SafeHtmlBuilder cellBuilder=new SafeHtmlBuilder();
    Context context=new Context(i,0,key);
    cell.render(context,value,cellBuilder);
    SafeStyles innerPadding=SafeStylesUtils.fromTrustedString(""String_Node_Str"" + paddingDirection + ""String_Node_Str""+ imageWidth+ ""String_Node_Str"");
    SafeHtml innerDiv=template.innerDiv(innerPadding,innerClasses.toString(),image,itemValueStyle,cellBuilder.toSafeHtml());
    SafeStyles outerPadding=SafeStylesUtils.fromTrustedString(""String_Node_Str"" + paddingDirection + ""String_Node_Str""+ paddingAmount+ ""String_Node_Str"");
    sb.append(template.outerDiv(outerPadding,outerClasses.toString(),innerDiv));
  }
}",0.9982740766309977
53787,"public <H extends EventHandler>HandlerRegistration addHandler(H handler,Type<H> type){
  return handlerManger.addHandler(type,handler);
}","@Override public <H extends EventHandler>HandlerRegistration addHandler(H handler,Type<H> type){
  return handlerManger.addHandler(type,handler);
}",0.9647887323943662
53788,"public TreeNode getParent(){
  assertNotDestroyed();
  return getParentImpl();
}","@Override public TreeNode getParent(){
  assertNotDestroyed();
  return getParentImpl();
}",0.9411764705882352
53789,"public HandlerRegistration addRangeChangeHandler(RangeChangeEvent.Handler handler){
  return presenter.addRangeChangeHandler(handler);
}","@Override public HandlerRegistration addRangeChangeHandler(RangeChangeEvent.Handler handler){
  return presenter.addRangeChangeHandler(handler);
}",0.9645390070921984
53790,"public HandlerRegistration addRowCountChangeHandler(RowCountChangeEvent.Handler handler){
  return presenter.addRowCountChangeHandler(handler);
}","@Override public HandlerRegistration addRowCountChangeHandler(RowCountChangeEvent.Handler handler){
  return presenter.addRowCountChangeHandler(handler);
}",0.9666666666666668
53791,"public Range getVisibleRange(){
  return presenter.getVisibleRange();
}","@Override public Range getVisibleRange(){
  return presenter.getVisibleRange();
}",0.9342105263157896
53792,"public Object getValue(){
  return nodeView.value;
}","@Override public Object getValue(){
  return nodeView.value;
}",0.912280701754386
53793,"public boolean isChildOpen(int index){
  assertNotDestroyed();
  checkChildBounds(index);
  flush();
  return nodeView.getChildNode(index).isOpen();
}","@Override public boolean isChildOpen(int index){
  assertNotDestroyed();
  checkChildBounds(index);
  flush();
  return nodeView.getChildNode(index).isOpen();
}",0.967741935483871
53794,"public C getVisibleItem(int indexOnPage){
  return presenter.getVisibleItem(indexOnPage);
}","@Override public C getVisibleItem(int indexOnPage){
  return presenter.getVisibleItem(indexOnPage);
}",0.9479166666666666
53795,"public void setRowCount(int size,boolean isExact){
  presenter.setRowCount(size,isExact);
}","@Override public void setRowCount(int size,boolean isExact){
  presenter.setRowCount(size,isExact);
}",0.9479166666666666
53796,"public void resetFocus(){
  nodeView.tree.resetFocus();
}","@Override public void resetFocus(){
  nodeView.tree.resetFocus();
}",0.9193548387096774
53797,"public NodeCellList(final NodeInfo<C> nodeInfo,final CellTreeNodeView<?> nodeView,int pageSize){
  this.defaultPageSize=pageSize;
  this.nodeInfo=nodeInfo;
  this.nodeView=nodeView;
  cell=nodeInfo.getCell();
  presenter=new HasDataPresenter<C>(this,new View(nodeView.ensureChildContainer()),pageSize,nodeInfo.getProvidesKey());
  presenter.setKeyboardSelectionPolicy(KeyboardSelectionPolicy.DISABLED);
  presenter.addRowCountChangeHandler(new RowCountChangeEvent.Handler(){
    public void onRowCountChange(    RowCountChangeEvent event){
      int rowCount=event.getNewRowCount();
      boolean isExact=event.isNewRowCountExact();
      int pageSize=getVisibleRange().getLength();
      showOrHide(nodeView.showMoreElem,isExact && rowCount > pageSize);
    }
  }
);
}","public NodeCellList(final NodeInfo<C> nodeInfo,final CellTreeNodeView<?> nodeView,int pageSize){
  this.defaultPageSize=pageSize;
  this.nodeInfo=nodeInfo;
  this.nodeView=nodeView;
  cell=nodeInfo.getCell();
  presenter=new HasDataPresenter<C>(this,new View(nodeView.ensureChildContainer()),pageSize,nodeInfo.getProvidesKey());
  presenter.setKeyboardSelectionPolicy(KeyboardSelectionPolicy.DISABLED);
  presenter.addRowCountChangeHandler(new RowCountChangeEvent.Handler(){
    @Override public void onRowCountChange(    RowCountChangeEvent event){
      int rowCount=event.getNewRowCount();
      boolean isExact=event.isNewRowCountExact();
      int pageSize=getVisibleRange().getLength();
      showOrHide(nodeView.showMoreElem,isExact && rowCount > pageSize);
    }
  }
);
}",0.9935400516795866
53798,"public List<C> getVisibleItems(){
  return presenter.getVisibleItems();
}","@Override public List<C> getVisibleItems(){
  return presenter.getVisibleItems();
}",0.935897435897436
53799,"/** 
 * Best effort resymbolization of a a single stack trace element.
 * @param ste the stack trace element to resymbolize
 * @param strongName the GWT permutation strong name
 * @return the best effort resymbolized stack trace element
 */
public StackTraceElement resymbolize(StackTraceElement ste,String strongName){
  SymbolMap map=loadSymbolMap(strongName);
  String symbolData=map == null ? null : map.get(ste.getMethodName());
  if (symbolData != null) {
    String[] parts=symbolData.split(""String_Node_Str"");
    if (parts.length == 5) {
      String[] ref=parse(parts[0].substring(0,parts[0].lastIndexOf(')') + 1));
      String declaringClass;
      String methodName;
      if (ref != null) {
        declaringClass=ref[0];
        methodName=ref[1];
      }
 else {
        declaringClass=ste.getClassName();
        methodName=ste.getMethodName();
      }
      String filename=""String_Node_Str"".equals(parts[3]) ? null : parts[3].substring(parts[3].lastIndexOf('/') + 1);
      int lineNumber=ste.getLineNumber();
      if (lineNumber == 0) {
        lineNumber=Integer.parseInt(parts[4]);
      }
      return new StackTraceElement(declaringClass,methodName,filename,lineNumber);
    }
  }
  return ste;
}","/** 
 * Best effort resymbolization of a a single stack trace element.
 * @param ste the stack trace element to resymbolize
 * @param strongName the GWT permutation strong name
 * @return the best effort resymbolized stack trace element
 */
public StackTraceElement resymbolize(StackTraceElement ste,String strongName){
  SymbolMap map=loadSymbolMap(strongName);
  String symbolData=map == null ? null : map.get(ste.getMethodName());
  if (symbolData != null) {
    String[] parts=symbolData.split(""String_Node_Str"");
    if (parts.length == 5) {
      String[] ref=parse(parts[0].substring(0,parts[0].lastIndexOf(')') + 1));
      String declaringClass;
      String methodName;
      if (ref != null) {
        declaringClass=ref[0];
        methodName=ref[1];
      }
 else {
        declaringClass=ste.getClassName();
        methodName=ste.getMethodName();
      }
      String filename=""String_Node_Str"".equals(parts[3]) ? null : parts[3].substring(parts[3].lastIndexOf('/') + 1);
      int lineNumber=ste.getLineNumber();
      if (lineNumber == LINE_NUMBER_UNKNOWN) {
        lineNumber=Integer.parseInt(parts[4]);
      }
      return new StackTraceElement(declaringClass,methodName,filename,lineNumber);
    }
  }
  return ste;
}",0.991869918699187
53800,"@Override public String getReadableDeclaration(){
  String[] names=TypeOracle.modifierBitsToNames(getModifierBits());
  StringBuilder sb=new StringBuilder();
  for (  String name : names) {
    sb.append(name);
    sb.append(""String_Node_Str"");
  }
  if (getTypeParameters().length > 0) {
    toStringTypeParams(sb);
    sb.append(""String_Node_Str"");
  }
  sb.append(getName());
  toStringParamsAndThrows(sb);
  return sb.toString();
}","@Override public String getReadableDeclaration(){
  String[] names=TypeOracle.modifierBitsToNamesForMethod(getModifierBits());
  StringBuilder sb=new StringBuilder();
  for (  String name : names) {
    sb.append(name);
    sb.append(""String_Node_Str"");
  }
  if (getTypeParameters().length > 0) {
    toStringTypeParams(sb);
    sb.append(""String_Node_Str"");
  }
  sb.append(getName());
  toStringParamsAndThrows(sb);
  return sb.toString();
}",0.9897610921501706
53801,"@Override public String toString(){
  String[] names=TypeOracle.modifierBitsToNames(modifierBits);
  StringBuffer sb=new StringBuffer();
  for (int i=0; i < names.length; i++) {
    if (i > 0) {
      sb.append(""String_Node_Str"");
    }
    sb.append(names[i]);
  }
  if (names.length > 0) {
    sb.append(""String_Node_Str"");
  }
  sb.append(type.getParameterizedQualifiedSourceName());
  sb.append(""String_Node_Str"");
  sb.append(getName());
  return sb.toString();
}","@Override public String toString(){
  String[] names=TypeOracle.modifierBitsToNamesForField(modifierBits);
  StringBuffer sb=new StringBuffer();
  for (int i=0; i < names.length; i++) {
    if (i > 0) {
      sb.append(""String_Node_Str"");
    }
    sb.append(names[i]);
  }
  if (names.length > 0) {
    sb.append(""String_Node_Str"");
  }
  sb.append(type.getParameterizedQualifiedSourceName());
  sb.append(""String_Node_Str"");
  sb.append(getName());
  return sb.toString();
}",0.9915254237288136
53802,"String getReadableDeclaration(int modifierBits){
  String[] names=TypeOracle.modifierBitsToNames(modifierBits);
  StringBuilder sb=new StringBuilder();
  for (  String name : names) {
    sb.append(name);
    sb.append(""String_Node_Str"");
  }
  if (getTypeParameters().length > 0) {
    toStringTypeParams(sb);
    sb.append(""String_Node_Str"");
  }
  sb.append(returnType.getParameterizedQualifiedSourceName());
  sb.append(""String_Node_Str"");
  sb.append(getName());
  toStringParamsAndThrows(sb);
  return sb.toString();
}","String getReadableDeclaration(int modifierBits){
  String[] names=TypeOracle.modifierBitsToNamesForMethod(modifierBits);
  StringBuilder sb=new StringBuilder();
  for (  String name : names) {
    sb.append(name);
    sb.append(""String_Node_Str"");
  }
  if (getTypeParameters().length > 0) {
    toStringTypeParams(sb);
    sb.append(""String_Node_Str"");
  }
  sb.append(returnType.getParameterizedQualifiedSourceName());
  sb.append(""String_Node_Str"");
  sb.append(getName());
  toStringParamsAndThrows(sb);
  return sb.toString();
}",0.9914853358561968
53803,"public JClassType(SourceInfo info,String name,boolean isAbstract,boolean isFinal){
  super(info,name);
  this.isAbstract=isAbstract;
  this.isFinal=isFinal;
}","/** 
 * Construct a bare-bones deserialized external class.
 */
private JClassType(String name){
  super(SourceOrigin.UNKNOWN,name);
  isAbstract=false;
  setExternal(true);
}",0.3363363363363363
53804,"private Object readResolve(){
  JClassType result=new JClassType(SourceOrigin.UNKNOWN,name,false,false);
  result.setExternal(true);
  return result;
}","private Object readResolve(){
  return new JClassType(name);
}",0.5446009389671361
53805,"@Override protected Object writeReplace(){
  if (getEnclosingType() != null && getEnclosingType().isExternal()) {
    return new ExternalSerializedForm(this);
  }
 else {
    return this;
  }
}","@Override protected Object writeReplace(){
  if (isExternal()) {
    return new ExternalSerializedForm(this);
  }
 else {
    return this;
  }
}",0.8545994065281899
53806,"protected Object writeReplace(){
  if (enclosingType != null && enclosingType.isExternal()) {
    return new ExternalSerializedForm(this);
  }
 else   if (this == NULL_FIELD) {
    return ExternalSerializedNullField.INSTANCE;
  }
 else {
    return this;
  }
}","protected Object writeReplace(){
  if (isExternal()) {
    return new ExternalSerializedForm(this);
  }
 else   if (this == NULL_FIELD) {
    return ExternalSerializedNullField.INSTANCE;
  }
 else {
    return this;
  }
}",0.918918918918919
53807,"public boolean hasClinit(){
  if (!field.isStatic()) {
    return false;
  }
  if (field.isFinal() && field.isCompileTimeConstant()) {
    return false;
  }
  return getEnclosingType().checkClinitTo(field.getEnclosingType());
}","public boolean hasClinit(){
  JField field=getField();
  if (!field.isStatic()) {
    return false;
  }
  if (field.isFinal() && field.isCompileTimeConstant()) {
    return false;
  }
  return getEnclosingType().checkClinitTo(field.getEnclosingType());
}",0.943866943866944
53808,"public JFieldRef(SourceInfo info,JExpression instance,JField field,JDeclaredType enclosingType,JType overriddenType){
  super(info,field);
  assert(instance != null || field.isStatic());
  assert(enclosingType != null);
  this.instance=instance;
  this.field=field;
  this.enclosingType=enclosingType;
  this.overriddenType=overriddenType;
}","public JFieldRef(SourceInfo info,JExpression instance,JField field,JDeclaredType enclosingType,JType overriddenType){
  super(info,field);
  assert(instance != null || field.isStatic());
  assert(enclosingType != null);
  this.instance=instance;
  this.enclosingType=enclosingType;
  this.overriddenType=overriddenType;
}",0.8882175226586103
53809,"public JField getField(){
  return field;
}","public JField getField(){
  return (JField)getTarget();
}",0.84
53810,"public static JExpression createInstantiationExpression(SourceInfo info,JClassType classType,JDeclaredType enclosingType){
  JConstructor noArgCtor=null;
  for (  JMethod ctor : classType.getMethods()) {
    if (ctor instanceof JConstructor) {
      if (ctor.getParams().size() == 0) {
        noArgCtor=(JConstructor)ctor;
        break;
      }
    }
  }
  if (noArgCtor == null) {
    return null;
  }
  return new JNewInstance(info,noArgCtor,enclosingType);
}","public static JExpression createInstantiationExpression(SourceInfo info,JClassType classType,JDeclaredType enclosingType){
  JConstructor noArgCtor=null;
  for (  JMethod ctor : classType.getMethods()) {
    if (ctor instanceof JConstructor) {
      if (ctor.getOriginalParamTypes().size() == 0) {
        noArgCtor=(JConstructor)ctor;
        break;
      }
    }
  }
  if (noArgCtor == null) {
    return null;
  }
  return new JNewInstance(info,noArgCtor,enclosingType);
}",0.9872068230277186
53811,"private Object readResolve(){
  JInterfaceType result=new JInterfaceType(SourceOrigin.UNKNOWN,name);
  result.setExternal(true);
  return result;
}","private Object readResolve(){
  return new JInterfaceType(name);
}",0.5821596244131455
53812,"public JInterfaceType(SourceInfo info,String name){
  super(info,name);
}","/** 
 * Construct a bare-bones deserialized external interface.
 */
private JInterfaceType(String name){
  super(SourceOrigin.UNKNOWN,name);
  setExternal(true);
}",0.4576271186440678
53813,"protected Object writeReplace(){
  if (enclosingType != null && enclosingType.isExternal()) {
    return new ExternalSerializedForm(this);
  }
 else   if (this == NULL_METHOD) {
    return ExternalSerializedNullMethod.INSTANCE;
  }
 else {
    return this;
  }
}","protected Object writeReplace(){
  if (isExternal()) {
    return new ExternalSerializedForm(this);
  }
 else   if (this == NULL_METHOD) {
    return ExternalSerializedNullMethod.INSTANCE;
  }
 else {
    return this;
  }
}",0.9195876288659792
53814,"/** 
 * These are only supposed to be constructed by JProgram.
 */
public JMethod(SourceInfo info,String name,JDeclaredType enclosingType,JType returnType,boolean isAbstract,boolean isStatic,boolean isFinal,boolean isPrivate){
  super(info);
  this.name=StringInterner.get().intern(name);
  this.enclosingType=enclosingType;
  this.returnType=returnType;
  this.isAbstract=isAbstract;
  this.isStatic=isStatic;
  this.isFinal=isFinal;
  this.isPrivate=isPrivate;
}","/** 
 * Construct a bare-bones deserialized external method.
 */
private JMethod(String signature,JDeclaredType enclosingType){
  super(SourceOrigin.UNKNOWN);
  this.name=signature.substring(0,signature.indexOf('('));
  this.enclosingType=enclosingType;
  this.signature=signature;
  this.isAbstract=false;
  this.isStatic=false;
  this.isPrivate=false;
}",0.2417582417582417
53815,"public JStringLiteral(SourceInfo sourceInfo,String value,JClassType stringType){
  super(sourceInfo);
  this.value=value;
  this.stringType=stringType;
}","public JStringLiteral(SourceInfo sourceInfo,String value,JClassType stringType){
}",0.6978723404255319
53816,"private ImplementClassLiteralsAsFields(JProgram program){
  this.program=program;
  this.typeClassLiteralHolder=program.getTypeClassLiteralHolder();
  this.classLiteralHolderClinitBody=(JMethodBody)typeClassLiteralHolder.getMethods().get(0).getBody();
}","private ImplementClassLiteralsAsFields(JProgram program){
}",0.3782051282051282
53817,"public void testUiTextWithSafeHtml(){
  assertEquals(widgetUi.htmlWithComputedSafeHtml.getHTML().toLowerCase(),""String_Node_Str"");
  assertEquals(widgetUi.htmlWithComputedText.getHTML().toLowerCase(),""String_Node_Str"");
  assertEquals(widgetUi.labelWithComputedText.getText().toLowerCase(),""String_Node_Str"");
}","public void testUiTextWithSafeHtml(){
  assertEquals(widgetUi.htmlWithComputedSafeHtml.getHTML().toLowerCase(),""String_Node_Str"");
  assertEquals(widgetUi.htmlWithComputedText.getHTML().toLowerCase().replaceAll(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertEquals(widgetUi.labelWithComputedText.getText().toLowerCase(),""String_Node_Str"");
}",0.928358208955224
53818,"private void checkName(JsName name){
  if (!toEvaluate.contains(name)) {
    return;
  }
  if (unevaluated.size() == 0 || !unevaluated.remove(0).equals(name)) {
    maintainsOrder=false;
  }
}","/** 
 * Check to see if the evaluation of this JsName will break program order assumptions given the parameters left to be substituted. The cases are as follows: 1) JsName is a function parameter name which has side effects or is affected by side effects (hereafter called 'volatile'), so it will be in 'toEvaluate' 2) JsName is a function parameter which is not volatile (not in toEvaluate) 3) JsName is a reference to a global variable 4) JsName is a reference to a local variable A reference to a global while there are still parameters left to evaluate / substitute implies an order violation. A reference to a volatile parameter is ok if it is the next parameter in sequence to be evaluated (beginning of unevaluated list). Else, it is either being evaluated out of order with respect to other parameters, or it is being evaluated more than once.
 */
private void checkName(JsName name){
  if (!toEvaluate.contains(name)) {
    if (!paramsOrLocals.contains(name) && unevaluated.size() > 0) {
      maintainsOrder=false;
    }
    return;
  }
  if (unevaluated.size() == 0 || !unevaluated.remove(0).equals(name)) {
    maintainsOrder=false;
  }
}",0.2861400894187779
53819,"public EvaluationOrderVisitor(List<JsName> toEvaluate){
  this.toEvaluate=toEvaluate;
  this.unevaluated=new ArrayList<JsName>(toEvaluate);
}","public EvaluationOrderVisitor(List<JsName> toEvaluate,JsFunction callee){
  this.toEvaluate=toEvaluate;
  this.unevaluated=new ArrayList<JsName>(toEvaluate);
  new JsVisitor(){
    @Override public void endVisit(    JsParameter x,    JsContext ctx){
      paramsOrLocals.add(x.getName());
    }
    @Override public boolean visit(    JsVar x,    JsContext ctx){
      paramsOrLocals.add(x.getName());
      return true;
    }
  }
.accept(callee);
}",0.4787775891341256
53820,"@Override public void wrapElement(Element element){
  if (!isFullyInitialized()) {
    element.getParentNode().replaceChild(getElement(),element);
  }
 else {
    setElement(element);
    html=null;
  }
  if (wrapInitializationCallback != null) {
    wrapInitializationCallback.execute();
    wrapInitializationCallback=null;
  }
}","@Override public void wrapElement(Element element){
  if (isFullyInitialized()) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  setElement(element);
  html=null;
  if (wrapInitializationCallback != null) {
    wrapInitializationCallback.execute();
    wrapInitializationCallback=null;
  }
}",0.6794682422451994
53821,"@Override public boolean visit(JMethod x,Context ctx){
  currentMethod=x;
  return true;
}","@Override public boolean visit(JMethod x,Context ctx){
  currentMethod=x;
  if (program.getStaticImpl(x) != null) {
    return false;
  }
  return true;
}",0.7377049180327869
53822,"@Override public boolean visit(JMethod x,Context ctx){
  Set<JMethod> overrides=program.typeOracle.getAllOverrides(x);
  if (!overrides.isEmpty()) {
    for (    JMethod m : overrides) {
      rescuedMethods.add(m);
    }
    rescuedMethods.add(x);
  }
 else {
    JMethod staticImpl=program.staticImplFor(x);
    if (staticImpl != null && staticImpl.getEnclosingType().getMethods().contains(staticImpl)) {
      rescuedMethods.add(x);
    }
  }
  return true;
}","@Override public boolean visit(JMethod x,Context ctx){
  Set<JMethod> overrides=program.typeOracle.getAllOverrides(x);
  if (!overrides.isEmpty()) {
    for (    JMethod m : overrides) {
      rescuedMethods.add(m);
    }
    rescuedMethods.add(x);
  }
  return true;
}",0.7004103967168263
53823,"/** 
 * Synchronize the scroll positions of the scrollbars with the actual scroll position of the content.
 */
private void maybeUpdateScrollbarPositions(){
  if (!isAttached()) {
    return;
  }
  if (hScrollbar != null) {
    int hPos=getHorizontalScrollPosition();
    if (hScrollbar.getHorizontalScrollPosition() != hPos) {
      hScrollbar.setHorizontalScrollPosition(hPos);
    }
  }
  if (vScrollbar != null) {
    int vPos=getVerticalScrollPosition();
    if (vScrollbar.getVerticalScrollPosition() != vPos) {
      vScrollbar.setVerticalScrollPosition(vPos);
    }
  }
  getElement().setScrollLeft(0);
  getElement().setScrollTop(0);
}","/** 
 * Synchronize the scroll positions of the scrollbars with the actual scroll position of the content.
 */
private void maybeUpdateScrollbarPositions(){
  if (!isAttached()) {
    return;
  }
  if (hScrollbar != null) {
    int hPos=getHorizontalScrollPosition();
    if (hScrollbar.getHorizontalScrollPosition() != hPos) {
      hScrollbar.setHorizontalScrollPosition(hPos);
    }
  }
  if (vScrollbar != null) {
    int vPos=getVerticalScrollPosition();
    if (vScrollbar.getVerticalScrollPosition() != vPos) {
      vScrollbar.setVerticalScrollPosition(vPos);
    }
  }
  if (getElement().getScrollLeft() != 0) {
    getElement().setScrollLeft(0);
  }
  if (getElement().getScrollTop() != 0) {
    getElement().setScrollTop(0);
  }
}",0.9270758122743682
53824,"/** 
 * Declare a field that will hold an Element instance. Returns a token that the caller must set as the id attribute of that element in whatever innerHTML expression will reproduce it at runtime. <P> In the generated code, this token will be replaced by an expression to generate a unique dom id at runtime. Further code will be generated to be run after widgets are instantiated, to use that dom id in a getElementById call and assign the Element instance to its field.
 * @param fieldName The name of the field being declared
 * @param ancestorField The name of fieldName parent
 */
public String declareDomField(String fieldName,String ancestorField) throws UnableToCompleteException {
  ensureAttached();
  String name=declareDomIdHolder();
  if (useLazyWidgetBuilders) {
    FieldWriter field=fieldManager.require(fieldName);
    field.setInitializer(formatCode(""String_Node_Str"",fieldManager.convertFieldToGetter(name)));
    field.addStatement(""String_Node_Str"",fieldName);
    fieldManager.require(ancestorField).addAttachStatement(fieldManager.convertFieldToGetter(fieldName) + ""String_Node_Str"");
  }
 else {
    setFieldInitializer(fieldName,""String_Node_Str"");
    addInitStatement(""String_Node_Str"",fieldName,name);
    addInitStatement(""String_Node_Str"",fieldName);
  }
  return tokenForStringExpression(fieldManager.convertFieldToGetter(name));
}","/** 
 * Declare a field that will hold an Element instance. Returns a token that the caller must set as the id attribute of that element in whatever innerHTML expression will reproduce it at runtime. <P> In the generated code, this token will be replaced by an expression to generate a unique dom id at runtime. Further code will be generated to be run after widgets are instantiated, to use that dom id in a getElementById call and assign the Element instance to its field.
 * @param fieldName The name of the field being declared
 * @param ancestorField The name of fieldName parent
 */
public String declareDomField(String fieldName,String ancestorField) throws UnableToCompleteException {
  ensureAttached();
  String name=declareDomIdHolder();
  if (useLazyWidgetBuilders) {
    FieldWriter field=fieldManager.require(fieldName);
    field.setInitializer(formatCode(""String_Node_Str"",LazyDomElement.class.getCanonicalName(),fieldManager.convertFieldToGetter(name)));
    fieldManager.require(ancestorField).addAttachStatement(fieldManager.convertFieldToGetter(fieldName) + ""String_Node_Str"");
  }
 else {
    setFieldInitializer(fieldName,""String_Node_Str"");
    addInitStatement(""String_Node_Str"",fieldName,name);
    addInitStatement(""String_Node_Str"",fieldName);
  }
  return tokenForStringExpression(fieldManager.convertFieldToGetter(name));
}",0.9657710710342288
53825,"@Override public void onBrowserEvent(Event event){
  CellBasedWidgetImpl.get().onBrowserEvent(this,event);
  if (isRefreshing) {
    return;
  }
  super.onBrowserEvent(event);
  String eventType=event.getType();
  if (""String_Node_Str"".equals(eventType)) {
    isFocused=true;
    onFocus();
  }
 else   if (""String_Node_Str"".equals(eventType)) {
    isFocused=false;
    onBlur();
  }
 else   if (""String_Node_Str"".equals(eventType) && !cellIsEditing) {
    int keyCode=event.getKeyCode();
switch (keyCode) {
case KeyCodes.KEY_DOWN:
case KeyCodes.KEY_UP:
case KeyCodes.KEY_RIGHT:
case KeyCodes.KEY_LEFT:
      handleKeyNavigation(keyCode);
    event.preventDefault();
  return;
case 32:
event.preventDefault();
}
}
final Element target=event.getEventTarget().cast();
ArrayList<Element> chain=new ArrayList<Element>();
collectElementChain(chain,getElement(),target);
final boolean isMouseDown=""String_Node_Str"".equals(eventType);
final boolean isClick=""String_Node_Str"".equals(eventType);
final CellTreeNodeView<?> nodeView=findItemByChain(chain,0,rootNode);
if (nodeView != null && nodeView != rootNode) {
if (isMouseDown) {
Element showMoreElem=nodeView.getShowMoreElement();
if (nodeView.getImageElement().isOrHasChild(target)) {
nodeView.setOpen(!nodeView.isOpen(),true);
return;
}
 else if (showMoreElem != null && showMoreElem.isOrHasChild(target)) {
nodeView.showMore();
return;
}
}
if (nodeView.getSelectionElement().isOrHasChild(target)) {
if (isClick) {
boolean isFocusable=CellBasedWidgetImpl.get().isFocusable(target);
isFocused=isFocused || isFocusable;
keyboardSelect(nodeView,!isFocusable);
}
nodeView.fireEventToCell(event);
}
}
}","@Override public void onBrowserEvent(Event event){
  CellBasedWidgetImpl.get().onBrowserEvent(this,event);
  if (isRefreshing) {
    return;
  }
  super.onBrowserEvent(event);
  String eventType=event.getType();
  if (""String_Node_Str"".equals(eventType)) {
    isFocused=true;
    onFocus();
  }
 else   if (""String_Node_Str"".equals(eventType)) {
    isFocused=false;
    onBlur();
  }
 else   if (""String_Node_Str"".equals(eventType) && !cellIsEditing) {
    int keyCode=event.getKeyCode();
switch (keyCode) {
case KeyCodes.KEY_DOWN:
case KeyCodes.KEY_UP:
case KeyCodes.KEY_RIGHT:
case KeyCodes.KEY_LEFT:
      handleKeyNavigation(keyCode);
    event.preventDefault();
  return;
case 32:
event.preventDefault();
}
}
final Element target=event.getEventTarget().cast();
ArrayList<Element> chain=new ArrayList<Element>();
collectElementChain(chain,getElement(),target);
final boolean isMouseDown=""String_Node_Str"".equals(eventType);
final boolean isClick=""String_Node_Str"".equals(eventType);
final CellTreeNodeView<?> nodeView=findItemByChain(chain,0,rootNode);
if (nodeView != null) {
if (isMouseDown) {
Element showMoreElem=nodeView.getShowMoreElement();
if (nodeView.getImageElement().isOrHasChild(target)) {
nodeView.setOpen(!nodeView.isOpen(),true);
return;
}
 else if (showMoreElem != null && showMoreElem.isOrHasChild(target)) {
nodeView.showMore();
return;
}
}
if (nodeView != rootNode && nodeView.getSelectionElement().isOrHasChild(target)) {
if (isClick) {
boolean isFocusable=CellBasedWidgetImpl.get().isFocusable(target);
isFocused=isFocused || isFocusable;
keyboardSelect(nodeView,!isFocusable);
}
nodeView.fireEventToCell(event);
}
}
}",0.8256379100850547
53826,"@Override public void onBrowserEvent(Event event){
  if (event.getTypeInt() == Event.ONLOAD) {
    clearUnhandledEvent();
  }
  super.onBrowserEvent(event);
}","@Override public void onBrowserEvent(Event event){
  if (event.getTypeInt() == Event.ONLOAD) {
    clearUnhandledEvent();
    state.onLoadEvent(this);
  }
  super.onBrowserEvent(event);
}",0.9159420289855073
53827,"public void execute(){
  NativeEvent evt=Document.get().createLoadEvent();
  getImageElement(image).dispatchEvent(evt);
}","public void execute(){
  if (image.state != State.this || this != syntheticEventCommand) {
    return;
  }
  syntheticEventCommand=null;
  if (!image.isAttached()) {
    getImageElement(image).setPropertyString(UNHANDLED_EVENT_ATTR,""String_Node_Str"");
    return;
  }
  NativeEvent evt=Document.get().createLoadEvent();
  getImageElement(image).dispatchEvent(evt);
}",0.4969199178644763
53828,"/** 
 * We need to synthesize a load event in case the image loads synchronously, before our handlers can be attached.
 * @param image the image on which to dispatch the event
 */
protected void fireSyntheticLoadEvent(final Image image){
  DeferredCommand.addCommand(new Command(){
    public void execute(){
      NativeEvent evt=Document.get().createLoadEvent();
      getImageElement(image).dispatchEvent(evt);
    }
  }
);
}","/** 
 * We need to synthesize a load event in case the image loads synchronously, before our handlers can be attached.
 * @param image the image on which to dispatch the event
 */
protected void fireSyntheticLoadEvent(final Image image){
  syntheticEventCommand=new ScheduledCommand(){
    public void execute(){
      if (image.state != State.this || this != syntheticEventCommand) {
        return;
      }
      syntheticEventCommand=null;
      if (!image.isAttached()) {
        getImageElement(image).setPropertyString(UNHANDLED_EVENT_ATTR,""String_Node_Str"");
        return;
      }
      NativeEvent evt=Document.get().createLoadEvent();
      getImageElement(image).dispatchEvent(evt);
    }
  }
;
  Scheduler.get().scheduleDeferred(syntheticEventCommand);
}",0.602510460251046
53829,"@Override public int getAbsoluteLeft(Element elem){
  Document doc=elem.getOwnerDocument();
  return getBoundingClientRectLeft(elem) + doc.getScrollLeft();
}","@Override public int getAbsoluteLeft(Element elem){
  int left=getBoundingClientRectLeft(elem) + getDocumentScrollLeftImpl();
  if (isRTL(elem)) {
    left+=getParentOffsetDelta(elem);
  }
  return left;
}",0.4088397790055249
53830,"@Override public int getAbsoluteTop(Element elem){
  Document doc=elem.getOwnerDocument();
  return getBoundingClientRectTop(elem) + doc.getScrollTop();
}","@Override public int getAbsoluteTop(Element elem){
  return getBoundingClientRectTop(elem) + getDocumentScrollTopImpl();
}",0.8043478260869565
53831,private native boolean isRTL(Element elem);,protected native boolean isRTL(Element elem);,0.9090909090909092
53832,"/** 
 * Creates an &lt;input type='checkbox'&gt; element.
 * @return the newly created element
 */
public final InputElement createCheckInputElement(){
  return DOMImpl.impl.createInputElement(this,""String_Node_Str"");
}","/** 
 * Creates an &lt;input type='checkbox'&gt; element.
 * @return the newly created element
 */
public final InputElement createCheckInputElement(){
  return DOMImpl.impl.createCheckInputElement(this);
}",0.9458823529411764
53833,"public Map<String,String> getReplacements(String installPath,String theModuleName){
  String gwtUserPath=installPath + '/' + ""String_Node_Str"";
  String gwtDevPath=installPath + '/' + ""String_Node_Str"";
  String gwtValidationPath=installPath + '/' + ""String_Node_Str"";
  String gwtValidationSourcesPath=installPath + '/' + ""String_Node_Str"";
  String gwtModuleDtd=""String_Node_Str"";
  GwtVersion gwtVersion=About.getGwtVersionObject();
  if (gwtVersion.isNoNagVersion()) {
    gwtModuleDtd=""String_Node_Str"" + About.getGwtVersionNum() + ""String_Node_Str""+ About.getGwtVersionNum()+ ""String_Node_Str"";
  }
  int pos=theModuleName.lastIndexOf('.');
  String modulePackageName=theModuleName.substring(0,pos);
  String moduleShortName=theModuleName.substring(pos + 1);
  Map<String,String> replacements=new HashMap<String,String>();
  String srcFolder=templates.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
  String testFolder=templates.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
  String warFolder=templates.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
{
    if (junitPath == null) {
      System.err.println(""String_Node_Str"");
    }
    String testTargetsBegin=""String_Node_Str"";
    String testTargetsEnd=""String_Node_Str"";
    String junitJarPath=junitPath;
    String eclipseTestDir=""String_Node_Str"";
    if (junitPath != null) {
      eclipseTestDir=""String_Node_Str"" + testFolder + ""String_Node_Str"";
    }
    if (junitPath == null) {
      testTargetsBegin=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
      testTargetsEnd=""String_Node_Str"";
      junitJarPath=""String_Node_Str"";
    }
    replacements.put(""String_Node_Str"",testTargetsBegin);
    replacements.put(""String_Node_Str"",testTargetsEnd);
    replacements.put(""String_Node_Str"",junitJarPath);
    replacements.put(""String_Node_Str"",eclipseTestDir);
  }
  replacements.put(""String_Node_Str"",srcFolder);
  replacements.put(""String_Node_Str"",testFolder);
  replacements.put(""String_Node_Str"",warFolder);
  replacements.put(""String_Node_Str"",moduleShortName);
  replacements.put(""String_Node_Str"",modulePackageName);
  replacements.put(""String_Node_Str"",modulePackageName.replace('.','/'));
  replacements.put(""String_Node_Str"",theModuleName);
  replacements.put(""String_Node_Str"",modulePackageName + ""String_Node_Str"");
  replacements.put(""String_Node_Str"",modulePackageName + ""String_Node_Str"");
  replacements.put(""String_Node_Str"",modulePackageName + ""String_Node_Str"");
  replacements.put(""String_Node_Str"",installPath);
  replacements.put(""String_Node_Str"",gwtUserPath);
  replacements.put(""String_Node_Str"",gwtDevPath);
  replacements.put(""String_Node_Str"",gwtValidationPath);
  replacements.put(""String_Node_Str"",gwtValidationSourcesPath);
  replacements.put(""String_Node_Str"",About.getGwtVersionNum());
  replacements.put(""String_Node_Str"",gwtModuleDtd);
  replacements.put(""String_Node_Str"",DevMode.class.getName());
  replacements.put(""String_Node_Str"",Compiler.class.getName());
  replacements.put(""String_Node_Str"",moduleShortName + ""String_Node_Str"");
  replacements.put(""String_Node_Str"",moduleShortName.toLowerCase());
  replacements.put(""String_Node_Str"",theModuleName + ""String_Node_Str"");
  String copyServletDeps=""String_Node_Str"";
  copyServletDeps=""String_Node_Str"" + warFolder + ""String_Node_Str""+ ""String_Node_Str"";
  replacements.put(""String_Node_Str"",copyServletDeps);
  File libDirectory=new File(outDir + warFolder + ""String_Node_Str"");
  StringBuilder serverLibs=new StringBuilder();
  if (libDirectory.exists()) {
    for (    File file : libDirectory.listFiles()) {
      if (file.getName().toLowerCase().endsWith(""String_Node_Str"")) {
        serverLibs.append(""String_Node_Str"");
        serverLibs.append(file.getName());
        serverLibs.append(""String_Node_Str"");
      }
    }
  }
  replacements.put(""String_Node_Str"",serverLibs.toString());
  String antEclipseRule=""String_Node_Str"";
  if (!templates.contains(""String_Node_Str"")) {
    antEclipseRule=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ theModuleName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  }
 else {
    antEclipseRule=""String_Node_Str"";
  }
  replacements.put(""String_Node_Str"",antEclipseRule);
  return replacements;
}","public Map<String,String> getReplacements(String installPath,String theModuleName){
  String gwtUserPath=installPath + '/' + ""String_Node_Str"";
  String gwtDevPath=installPath + '/' + ""String_Node_Str"";
  String gwtValidationPath=installPath + '/' + ""String_Node_Str"";
  String gwtValidationSourcesPath=installPath + '/' + ""String_Node_Str"";
  String gwtModuleDtd=""String_Node_Str"";
  GwtVersion gwtVersion=About.getGwtVersionObject();
  if (gwtVersion.isNoNagVersion()) {
    gwtModuleDtd=""String_Node_Str"" + About.getGwtVersionNum() + ""String_Node_Str""+ About.getGwtVersionNum()+ ""String_Node_Str"";
  }
  int pos=theModuleName.lastIndexOf('.');
  String modulePackageName=theModuleName.substring(0,pos);
  String moduleShortName=theModuleName.substring(pos + 1);
  Map<String,String> replacements=new HashMap<String,String>();
  String srcFolder=templates.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
  String testFolder=templates.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
  String warFolder=templates.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
{
    if (junitPath == null) {
      System.err.println(""String_Node_Str"");
    }
    String testTargetsBegin=""String_Node_Str"";
    String testTargetsEnd=""String_Node_Str"";
    String junitJarPath=junitPath;
    String eclipseTestDir=""String_Node_Str"";
    if (junitPath != null) {
      eclipseTestDir=""String_Node_Str"" + testFolder + ""String_Node_Str"";
    }
    if (junitPath == null) {
      testTargetsBegin=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
      testTargetsEnd=""String_Node_Str"";
      junitJarPath=""String_Node_Str"";
    }
    replacements.put(""String_Node_Str"",testTargetsBegin);
    replacements.put(""String_Node_Str"",testTargetsEnd);
    replacements.put(""String_Node_Str"",junitJarPath);
    replacements.put(""String_Node_Str"",eclipseTestDir);
  }
  replacements.put(""String_Node_Str"",srcFolder);
  replacements.put(""String_Node_Str"",testFolder);
  replacements.put(""String_Node_Str"",warFolder);
  replacements.put(""String_Node_Str"",moduleShortName);
  replacements.put(""String_Node_Str"",modulePackageName);
  replacements.put(""String_Node_Str"",modulePackageName.replace('.','/'));
  replacements.put(""String_Node_Str"",theModuleName);
  replacements.put(""String_Node_Str"",modulePackageName + ""String_Node_Str"");
  replacements.put(""String_Node_Str"",modulePackageName + ""String_Node_Str"");
  replacements.put(""String_Node_Str"",modulePackageName + ""String_Node_Str"");
  replacements.put(""String_Node_Str"",installPath);
  replacements.put(""String_Node_Str"",gwtUserPath);
  replacements.put(""String_Node_Str"",gwtDevPath);
  replacements.put(""String_Node_Str"",gwtValidationPath);
  replacements.put(""String_Node_Str"",gwtValidationSourcesPath);
  replacements.put(""String_Node_Str"",About.getGwtVersionNum());
  replacements.put(""String_Node_Str"",gwtModuleDtd);
  replacements.put(""String_Node_Str"",DevMode.class.getName());
  replacements.put(""String_Node_Str"",Compiler.class.getName());
  replacements.put(""String_Node_Str"",moduleShortName + ""String_Node_Str"");
  replacements.put(""String_Node_Str"",moduleShortName.toLowerCase());
  replacements.put(""String_Node_Str"",theModuleName + ""String_Node_Str"");
  String copyServletDeps=""String_Node_Str"";
  copyServletDeps=""String_Node_Str"" + warFolder + ""String_Node_Str""+ ""String_Node_Str"";
  replacements.put(""String_Node_Str"",copyServletDeps);
  File libDirectory=new File(outDir + ""String_Node_Str"" + warFolder+ ""String_Node_Str"");
  StringBuilder serverLibs=new StringBuilder();
  if (libDirectory.exists()) {
    for (    File file : libDirectory.listFiles()) {
      if (file.getName().toLowerCase().endsWith(""String_Node_Str"")) {
        serverLibs.append(""String_Node_Str"");
        serverLibs.append(file.getName());
        serverLibs.append(""String_Node_Str"");
      }
    }
  }
  replacements.put(""String_Node_Str"",serverLibs.toString());
  String antEclipseRule=""String_Node_Str"";
  if (!templates.contains(""String_Node_Str"")) {
    antEclipseRule=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ theModuleName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  }
 else {
    antEclipseRule=""String_Node_Str"";
  }
  replacements.put(""String_Node_Str"",antEclipseRule);
  return replacements;
}",0.9976746761156018
53834,"@Override public Object createServiceInstance(Method contextMethod,Method domainMethod){
  Class<? extends ServiceLocator> locatorType=getTop().resolveServiceLocator(contextMethod,domainMethod);
  ServiceLocator locator=newInstance(locatorType,ServiceLocator.class);
  return locator.getInstance(domainMethod.getDeclaringClass());
}","@Override public Object createServiceInstance(Method contextMethod,Method domainMethod){
  Class<? extends ServiceLocator> locatorType=getTop().resolveServiceLocator(contextMethod,domainMethod);
  ServiceLocator locator=newInstance(locatorType,ServiceLocator.class);
  Class<?> declaringClass=contextMethod.getDeclaringClass();
  Class<?> serviceClass=getTop().resolveServiceClass(declaringClass.asSubclass(RequestContext.class));
  return locator.getInstance(serviceClass);
}",0.7351485148514851
53835,"@Override public Method resolveDomainMethod(Method requestContextMethod){
  Class<?> enclosing=requestContextMethod.getDeclaringClass();
  Class<?> searchIn=null;
  Service s=enclosing.getAnnotation(Service.class);
  if (s != null) {
    searchIn=s.value();
  }
  ServiceName sn=enclosing.getAnnotation(ServiceName.class);
  if (sn != null) {
    searchIn=forName(sn.value());
  }
  if (searchIn == null) {
    die(null,""String_Node_Str"",RequestContext.class.getSimpleName(),enclosing.getCanonicalName());
  }
  Class<?>[] parameterTypes=requestContextMethod.getParameterTypes();
  Class<?>[] domainArgs=new Class<?>[parameterTypes.length];
  for (int i=0, j=domainArgs.length; i < j; i++) {
    if (BaseProxy.class.isAssignableFrom(parameterTypes[i])) {
      domainArgs[i]=getTop().resolveDomainClass(parameterTypes[i].asSubclass(BaseProxy.class));
    }
 else     if (EntityProxyId.class.isAssignableFrom(parameterTypes[i])) {
      domainArgs[i]=TypeUtils.ensureBaseType(TypeUtils.getSingleParameterization(EntityProxyId.class,requestContextMethod.getGenericParameterTypes()[i]));
    }
 else {
      domainArgs[i]=parameterTypes[i];
    }
  }
  Throwable ex;
  try {
    return searchIn.getMethod(requestContextMethod.getName(),domainArgs);
  }
 catch (  SecurityException e) {
    ex=e;
  }
catch (  NoSuchMethodException e) {
    return report(""String_Node_Str"",requestContextMethod.getName());
  }
  return die(ex,""String_Node_Str"",requestContextMethod.getName(),searchIn.getCanonicalName());
}","@Override public Method resolveDomainMethod(Method requestContextMethod){
  Class<?> declaringClass=requestContextMethod.getDeclaringClass();
  Class<?> searchIn=getTop().resolveServiceClass(declaringClass.asSubclass(RequestContext.class));
  Class<?>[] parameterTypes=requestContextMethod.getParameterTypes();
  Class<?>[] domainArgs=new Class<?>[parameterTypes.length];
  for (int i=0, j=domainArgs.length; i < j; i++) {
    if (BaseProxy.class.isAssignableFrom(parameterTypes[i])) {
      domainArgs[i]=getTop().resolveDomainClass(parameterTypes[i].asSubclass(BaseProxy.class));
    }
 else     if (EntityProxyId.class.isAssignableFrom(parameterTypes[i])) {
      domainArgs[i]=TypeUtils.ensureBaseType(TypeUtils.getSingleParameterization(EntityProxyId.class,requestContextMethod.getGenericParameterTypes()[i]));
    }
 else {
      domainArgs[i]=parameterTypes[i];
    }
  }
  Throwable ex;
  try {
    return searchIn.getMethod(requestContextMethod.getName(),domainArgs);
  }
 catch (  SecurityException e) {
    ex=e;
  }
catch (  NoSuchMethodException e) {
    return report(""String_Node_Str"",requestContextMethod.getName());
  }
  return die(ex,""String_Node_Str"",requestContextMethod.getName(),searchIn.getCanonicalName());
}",0.8548446069469835
53836,"public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTestSuite(BoxesAndPrimitivesJreTest.class);
  suite.addTestSuite(ComplexKeysJreTest.class);
  suite.addTestSuite(FindServiceJreTest.class);
  suite.addTestSuite(LocatorJreTest.class);
  suite.addTestSuite(RequestFactoryExceptionPropagationJreTest.class);
  suite.addTestSuite(RequestFactoryInterfaceValidatorTest.class);
  suite.addTestSuite(RequestFactoryJreTest.class);
  suite.addTestSuite(RequestFactoryModelTest.class);
  suite.addTestSuite(RequestFactoryUnicodeEscapingJreTest.class);
  suite.addTestSuite(SimpleEntityProxyIdTest.class);
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTestSuite(BoxesAndPrimitivesJreTest.class);
  suite.addTestSuite(ComplexKeysJreTest.class);
  suite.addTestSuite(FindServiceJreTest.class);
  suite.addTestSuite(LocatorJreTest.class);
  suite.addTestSuite(RequestFactoryExceptionPropagationJreTest.class);
  suite.addTestSuite(RequestFactoryInterfaceValidatorTest.class);
  suite.addTestSuite(RequestFactoryJreTest.class);
  suite.addTestSuite(RequestFactoryModelTest.class);
  suite.addTestSuite(RequestFactoryUnicodeEscapingJreTest.class);
  suite.addTestSuite(ServiceInheritanceJreTest.class);
  suite.addTestSuite(SimpleEntityProxyIdTest.class);
  return suite;
}",0.9595290654893304
53837,"public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(BoxesAndPrimitivesTest.class);
  suite.addTestSuite(ComplexKeysTest.class);
  suite.addTestSuite(EditorTest.class);
  suite.addTestSuite(FindServiceTest.class);
  suite.addTestSuite(LocatorTest.class);
  suite.addTestSuite(RequestFactoryTest.class);
  suite.addTestSuite(RequestFactoryExceptionHandlerTest.class);
  suite.addTestSuite(RequestFactoryExceptionPropagationTest.class);
  suite.addTestSuite(RequestFactoryPolymorphicTest.class);
  suite.addTestSuite(RequestFactoryUnicodeEscapingTest.class);
  return suite;
}","public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(BoxesAndPrimitivesTest.class);
  suite.addTestSuite(ComplexKeysTest.class);
  suite.addTestSuite(EditorTest.class);
  suite.addTestSuite(FindServiceTest.class);
  suite.addTestSuite(LocatorTest.class);
  suite.addTestSuite(RequestFactoryTest.class);
  suite.addTestSuite(RequestFactoryExceptionHandlerTest.class);
  suite.addTestSuite(RequestFactoryExceptionPropagationTest.class);
  suite.addTestSuite(RequestFactoryPolymorphicTest.class);
  suite.addTestSuite(RequestFactoryUnicodeEscapingTest.class);
  suite.addTestSuite(ServiceInheritanceTest.class);
  return suite;
}",0.9602446483180428
53838,"public Map<String,String> getReplacements(String installPath,String theModuleName){
  String gwtUserPath=installPath + '/' + ""String_Node_Str"";
  String gwtDevPath=installPath + '/' + ""String_Node_Str"";
  String gwtValidationPath=installPath + '/' + ""String_Node_Str"";
  String gwtValidationSourcesPath=installPath + '/' + ""String_Node_Str"";
  String gwtModuleDtd=""String_Node_Str"";
  GwtVersion gwtVersion=About.getGwtVersionObject();
  if (gwtVersion.isNoNagVersion()) {
    gwtModuleDtd=""String_Node_Str"" + About.getGwtVersionNum() + ""String_Node_Str""+ About.getGwtVersionNum()+ ""String_Node_Str"";
  }
  int pos=theModuleName.lastIndexOf('.');
  String modulePackageName=theModuleName.substring(0,pos);
  String moduleShortName=theModuleName.substring(pos + 1);
  Map<String,String> replacements=new HashMap<String,String>();
  String srcFolder=templates.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
  String testFolder=templates.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
  String warFolder=templates.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
{
    if (junitPath == null) {
      System.err.println(""String_Node_Str"");
    }
    String testTargetsBegin=""String_Node_Str"";
    String testTargetsEnd=""String_Node_Str"";
    String junitJarPath=junitPath;
    String eclipseTestDir=""String_Node_Str"";
    if (junitPath != null) {
      eclipseTestDir=""String_Node_Str"" + testFolder + ""String_Node_Str"";
    }
    if (junitPath == null) {
      testTargetsBegin=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
      testTargetsEnd=""String_Node_Str"";
      junitJarPath=""String_Node_Str"";
    }
    replacements.put(""String_Node_Str"",testTargetsBegin);
    replacements.put(""String_Node_Str"",testTargetsEnd);
    replacements.put(""String_Node_Str"",junitJarPath);
    replacements.put(""String_Node_Str"",eclipseTestDir);
  }
  replacements.put(""String_Node_Str"",srcFolder);
  replacements.put(""String_Node_Str"",testFolder);
  replacements.put(""String_Node_Str"",warFolder);
  replacements.put(""String_Node_Str"",moduleShortName);
  replacements.put(""String_Node_Str"",modulePackageName);
  replacements.put(""String_Node_Str"",modulePackageName.replace('.','/'));
  replacements.put(""String_Node_Str"",theModuleName);
  replacements.put(""String_Node_Str"",modulePackageName + ""String_Node_Str"");
  replacements.put(""String_Node_Str"",modulePackageName + ""String_Node_Str"");
  replacements.put(""String_Node_Str"",modulePackageName + ""String_Node_Str"");
  replacements.put(""String_Node_Str"",installPath);
  replacements.put(""String_Node_Str"",gwtUserPath);
  replacements.put(""String_Node_Str"",gwtDevPath);
  replacements.put(""String_Node_Str"",gwtValidationPath);
  replacements.put(""String_Node_Str"",gwtValidationSourcesPath);
  replacements.put(""String_Node_Str"",About.getGwtVersionNum());
  replacements.put(""String_Node_Str"",gwtModuleDtd);
  replacements.put(""String_Node_Str"",DevMode.class.getName());
  replacements.put(""String_Node_Str"",Compiler.class.getName());
  replacements.put(""String_Node_Str"",moduleShortName + ""String_Node_Str"");
  replacements.put(""String_Node_Str"",moduleShortName.toLowerCase());
  replacements.put(""String_Node_Str"",theModuleName + ""String_Node_Str"");
  String copyServletDeps=""String_Node_Str"";
  copyServletDeps=""String_Node_Str"" + warFolder + ""String_Node_Str""+ ""String_Node_Str"";
  replacements.put(""String_Node_Str"",copyServletDeps);
  File libDirectory=new File(outDir + warFolder + ""String_Node_Str"");
  StringBuilder serverLibs=new StringBuilder();
  if (libDirectory.exists()) {
    for (    File file : libDirectory.listFiles()) {
      if (file.getName().toLowerCase().endsWith(""String_Node_Str"")) {
        serverLibs.append(""String_Node_Str"");
        serverLibs.append(file.getName());
        serverLibs.append(""String_Node_Str"");
      }
    }
  }
  replacements.put(""String_Node_Str"",serverLibs.toString());
  String antEclipseRule=""String_Node_Str"";
  if (!templates.contains(""String_Node_Str"")) {
    antEclipseRule=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ theModuleName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  }
 else {
    antEclipseRule=""String_Node_Str"";
  }
  replacements.put(""String_Node_Str"",antEclipseRule);
  return replacements;
}","public Map<String,String> getReplacements(String installPath,String theModuleName){
  String gwtUserPath=installPath + '/' + ""String_Node_Str"";
  String gwtDevPath=installPath + '/' + ""String_Node_Str"";
  String gwtValidationPath=installPath + '/' + ""String_Node_Str"";
  String gwtValidationSourcesPath=installPath + '/' + ""String_Node_Str"";
  String gwtModuleDtd=""String_Node_Str"";
  GwtVersion gwtVersion=About.getGwtVersionObject();
  if (gwtVersion.isNoNagVersion()) {
    gwtModuleDtd=""String_Node_Str"" + About.getGwtVersionNum() + ""String_Node_Str""+ About.getGwtVersionNum()+ ""String_Node_Str"";
  }
  int pos=theModuleName.lastIndexOf('.');
  String modulePackageName=theModuleName.substring(0,pos);
  String moduleShortName=theModuleName.substring(pos + 1);
  Map<String,String> replacements=new HashMap<String,String>();
  String srcFolder=templates.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
  String testFolder=templates.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
  String warFolder=templates.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
{
    if (junitPath == null) {
      System.err.println(""String_Node_Str"");
    }
    String testTargetsBegin=""String_Node_Str"";
    String testTargetsEnd=""String_Node_Str"";
    String junitJarPath=junitPath;
    String eclipseTestDir=""String_Node_Str"";
    if (junitPath != null) {
      eclipseTestDir=""String_Node_Str"" + testFolder + ""String_Node_Str"";
    }
    if (junitPath == null) {
      testTargetsBegin=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
      testTargetsEnd=""String_Node_Str"";
      junitJarPath=""String_Node_Str"";
    }
    replacements.put(""String_Node_Str"",testTargetsBegin);
    replacements.put(""String_Node_Str"",testTargetsEnd);
    replacements.put(""String_Node_Str"",junitJarPath);
    replacements.put(""String_Node_Str"",eclipseTestDir);
  }
  replacements.put(""String_Node_Str"",srcFolder);
  replacements.put(""String_Node_Str"",testFolder);
  replacements.put(""String_Node_Str"",warFolder);
  replacements.put(""String_Node_Str"",moduleShortName);
  replacements.put(""String_Node_Str"",modulePackageName);
  replacements.put(""String_Node_Str"",modulePackageName.replace('.','/'));
  replacements.put(""String_Node_Str"",theModuleName);
  replacements.put(""String_Node_Str"",modulePackageName + ""String_Node_Str"");
  replacements.put(""String_Node_Str"",modulePackageName + ""String_Node_Str"");
  replacements.put(""String_Node_Str"",modulePackageName + ""String_Node_Str"");
  replacements.put(""String_Node_Str"",installPath);
  replacements.put(""String_Node_Str"",gwtUserPath);
  replacements.put(""String_Node_Str"",gwtDevPath);
  replacements.put(""String_Node_Str"",gwtValidationPath);
  replacements.put(""String_Node_Str"",gwtValidationSourcesPath);
  replacements.put(""String_Node_Str"",About.getGwtVersionNum());
  replacements.put(""String_Node_Str"",gwtModuleDtd);
  replacements.put(""String_Node_Str"",DevMode.class.getName());
  replacements.put(""String_Node_Str"",Compiler.class.getName());
  replacements.put(""String_Node_Str"",moduleShortName + ""String_Node_Str"");
  replacements.put(""String_Node_Str"",moduleShortName.toLowerCase());
  replacements.put(""String_Node_Str"",theModuleName + ""String_Node_Str"");
  String copyServletDeps=""String_Node_Str"";
  copyServletDeps=""String_Node_Str"" + warFolder + ""String_Node_Str""+ ""String_Node_Str"";
  replacements.put(""String_Node_Str"",copyServletDeps);
  File libDirectory=new File(outDir + ""String_Node_Str"" + warFolder+ ""String_Node_Str"");
  StringBuilder serverLibs=new StringBuilder();
  if (libDirectory.exists()) {
    for (    File file : libDirectory.listFiles()) {
      if (file.getName().toLowerCase().endsWith(""String_Node_Str"")) {
        serverLibs.append(""String_Node_Str"");
        serverLibs.append(file.getName());
        serverLibs.append(""String_Node_Str"");
      }
    }
  }
  replacements.put(""String_Node_Str"",serverLibs.toString());
  String antEclipseRule=""String_Node_Str"";
  if (!templates.contains(""String_Node_Str"")) {
    antEclipseRule=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ theModuleName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  }
 else {
    antEclipseRule=""String_Node_Str"";
  }
  replacements.put(""String_Node_Str"",antEclipseRule);
  return replacements;
}",0.9976746761156018
53839,"@Override public void generateSelectMatchStart(SourceWriter out,TreeLogger logger,String value) throws UnableToCompleteException {
  missingPluralForms.remove(value);
  if (value.startsWith(""String_Node_Str"")) {
    try {
      long val=Long.parseLong(value.substring(1));
      out.println(""String_Node_Str"" + val + ""String_Node_Str""+ value);
    }
 catch (    NumberFormatException e) {
      throw error(logger,""String_Node_Str"" + value + ""String_Node_Str"",e);
    }
    out.indent();
    return;
  }
  if (inExactMatches) {
    inExactMatches=false;
    out.println(""String_Node_Str"");
    out.indent();
    out.println(""String_Node_Str"" + argNumber + ""String_Node_Str"");
    out.indent();
  }
  if (""String_Node_Str"".equals(value)) {
    out.println(""String_Node_Str"");
    out.indent();
    return;
  }
  PluralForm[] pluralForms=pluralRule.pluralForms();
  for (int i=0; i < pluralForms.length; ++i) {
    if (pluralForms[i].getName().equals(value)) {
      out.println(""String_Node_Str"" + i + ""String_Node_Str""+ value);
      out.indent();
      return;
    }
  }
  logger.log(TreeLogger.WARN,""String_Node_Str"" + value + ""String_Node_Str""+ pluralRule.getClass().getCanonicalName()+ ""String_Node_Str"");
  out.println(""String_Node_Str"" + (bogusCaseValue++) + ""String_Node_Str""+ value+ ""String_Node_Str"");
  out.indent();
}","@Override public void generateSelectMatchStart(SourceWriter out,TreeLogger logger,String value) throws UnableToCompleteException {
  missingPluralForms.remove(value);
  if (value.startsWith(""String_Node_Str"")) {
    try {
      long val=Long.parseLong(value.substring(1));
      out.println(""String_Node_Str"" + val + ""String_Node_Str""+ value);
    }
 catch (    NumberFormatException e) {
      throw error(logger,""String_Node_Str"" + value + ""String_Node_Str"",e);
    }
    out.indent();
    return;
  }
  if (inExactMatches) {
    inExactMatches=false;
    out.println(""String_Node_Str"");
    out.indent();
    out.println(""String_Node_Str"" + argNumber + ""String_Node_Str"");
    out.indent();
  }
  if (AlternateMessageSelector.OTHER_FORM_NAME.equals(value)) {
    out.println(""String_Node_Str"");
    out.indent();
    return;
  }
  PluralForm[] pluralForms=pluralRule.pluralForms();
  for (int i=0; i < pluralForms.length; ++i) {
    if (pluralForms[i].getName().equals(value)) {
      out.println(""String_Node_Str"" + i + ""String_Node_Str""+ value);
      out.indent();
      return;
    }
  }
  logger.log(TreeLogger.WARN,""String_Node_Str"" + value + ""String_Node_Str""+ pluralRule.getClass().getCanonicalName()+ ""String_Node_Str"");
  out.println(""String_Node_Str"" + (bogusCaseValue++) + ""String_Node_Str""+ value+ ""String_Node_Str"");
  out.indent();
}",0.9787234042553192
53840,"/** 
 * Generate code for one list pattern.
 * @param logger logger to use for error/warning messages
 * @param locale locale we are generating code for
 * @param listArg the {n,list,...} argument in the original format pattern
 * @param val0 the expression defining the {0} argument in the list pattern
 * @param val1 the expression defining the {1} argument in the list pattern
 * @param elemType the element type of the list/array being rendered as a list* @param isSafeHtml true if the resulting string is SafeHtml
 * @param listPattern the list pattern to generate code for, ie ""{0}, {1}""
 * @param formatSecond true if the {1} parameter needs to be formatted
 * @param params parameters passed to the Messages method call
 * @return a constructed string containing the code to implement the givenlist pattern
 * @throws UnableToCompleteException
 */
private CharSequence formatListPattern(final TreeLogger logger,final GwtLocale locale,final ArgumentChunk listArg,final String val0,final String val1,final JType elemType,final boolean isSafeHtml,String listPattern,final boolean formatSecond,final Parameters params) throws UnableToCompleteException {
  final StringBuffer buf=new StringBuffer();
  final StringGenerator gen=new StringGenerator(buf,isSafeHtml);
  try {
    List<TemplateChunk> chunks=MessageFormatParser.parse(listPattern);
    for (    TemplateChunk chunk : chunks) {
      chunk.accept(new DefaultTemplateChunkVisitor(){
        @Override public void visit(        ArgumentChunk argChunk) throws UnableToCompleteException {
          if (argChunk.getArgumentNumber() == 0 || formatSecond) {
            formatArg(logger,locale,gen,listArg,argChunk.getArgumentNumber() == 0 ? val0 : val1,elemType,params);
          }
 else {
            gen.appendExpression(val1,isSafeHtml,false,false);
          }
        }
        @Override public void visit(        StringChunk stringChunk) throws UnableToCompleteException {
          gen.appendStringLiteral(stringChunk.getString());
        }
      }
);
    }
  }
 catch (  ParseException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"" + listPattern + ""String_Node_Str""+ locale,e);
    throw new UnableToCompleteException();
  }
  gen.completeString();
  return buf;
}","/** 
 * Generate code for one list pattern.
 * @param logger logger to use for error/warning messages
 * @param locale locale we are generating code for
 * @param listArg the {n,list,...} argument in the original format pattern
 * @param val0 the expression defining the {0} argument in the list pattern
 * @param val1 the expression defining the {1} argument in the list pattern
 * @param elemType the element type of the list/array being rendered as a list* @param isSafeHtml true if the resulting string is SafeHtml
 * @param listPattern the list pattern to generate code for, ie ""{0}, {1}""
 * @param formatSecond true if the {1} parameter needs to be formatted
 * @param params parameters passed to the Messages method call
 * @return a constructed string containing the code to implement the givenlist pattern
 * @throws UnableToCompleteException
 */
private CharSequence formatListPattern(final TreeLogger logger,final GwtLocale locale,final ArgumentChunk listArg,final String val0,final String val1,final JType elemType,final boolean isSafeHtml,String listPattern,final boolean formatSecond,final Parameters params) throws UnableToCompleteException {
  final StringBuffer buf=new StringBuffer();
  final StringGenerator gen=new StringGenerator(buf,isSafeHtml);
  try {
    List<TemplateChunk> chunks=MessageFormatParser.parse(listPattern);
    for (    TemplateChunk chunk : chunks) {
      chunk.accept(new DefaultTemplateChunkVisitor(){
        @Override public void visit(        ArgumentChunk argChunk) throws UnableToCompleteException {
          if (argChunk.getArgumentNumber() == 0 || formatSecond) {
            formatArg(logger,locale,gen,listArg,argChunk.getArgumentNumber() == 0 ? val0 : val1,elemType,params);
          }
 else {
            gen.appendExpression(val1,isSafeHtml,false,false);
          }
        }
        @Override public void visit(        StringChunk stringChunk){
          gen.appendStringLiteral(stringChunk.getString());
        }
      }
);
    }
  }
 catch (  ParseException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"" + listPattern + ""String_Node_Str""+ locale,e);
    throw new UnableToCompleteException();
  }
  gen.completeString();
  return buf;
}",0.9923595505617976
53841,"/** 
 * Generate a Java string for a given MessageFormat string.
 * @param logger
 * @param template
 * @param paramsAccessor
 * @param writer
 * @throws UnableToCompleteException
 */
private void generateString(final TreeLogger logger,final GwtLocale locale,final String template,final Parameters paramsAccessor,SourceWriter writer,final boolean isSafeHtml) throws UnableToCompleteException {
  StringBuffer outputBuf=new StringBuffer();
  final StringGenerator buf=new StringGenerator(outputBuf,isSafeHtml);
  final int n=paramsAccessor.getCount();
  try {
    for (    TemplateChunk chunk : MessageFormatParser.parse(template)) {
      chunk.accept(new DefaultTemplateChunkVisitor(){
        @Override public void visit(        ArgumentChunk argChunk) throws UnableToCompleteException {
          int argNumber=argChunk.getArgumentNumber();
          if (argNumber >= n) {
            throw error(logger,""String_Node_Str"" + argNumber + ""String_Node_Str""+ template);
          }
          JParameter param=paramsAccessor.getParameter(argNumber);
          String arg=""String_Node_Str"" + argNumber;
          if (argChunk.isList()) {
            buf.appendExpression(arg + ""String_Node_Str"",isSafeHtml,false,false);
          }
 else {
            JType paramType=param.getType();
            formatArg(logger,locale,buf,argChunk,paramsAccessor.getParameterExpression(argNumber),paramType,paramsAccessor);
          }
        }
        @Override public void visit(        StaticArgChunk staticArgChunk) throws UnableToCompleteException {
          buf.appendStringLiteral(staticArgChunk.getReplacement());
        }
        @Override public void visit(        StringChunk stringChunk){
          buf.appendStringLiteral(stringChunk.getString());
        }
      }
);
    }
  }
 catch (  ParseException e) {
    throw error(logger,e);
  }
  buf.completeString();
  writer.print(outputBuf.toString());
}","/** 
 * Generate a Java string for a given MessageFormat string.
 * @param logger
 * @param template
 * @param paramsAccessor
 * @param writer
 * @throws UnableToCompleteException
 */
private void generateString(final TreeLogger logger,final GwtLocale locale,final String template,final Parameters paramsAccessor,SourceWriter writer,final boolean isSafeHtml) throws UnableToCompleteException {
  StringBuffer outputBuf=new StringBuffer();
  final StringGenerator buf=new StringGenerator(outputBuf,isSafeHtml);
  final int n=paramsAccessor.getCount();
  try {
    for (    TemplateChunk chunk : MessageFormatParser.parse(template)) {
      chunk.accept(new DefaultTemplateChunkVisitor(){
        @Override public void visit(        ArgumentChunk argChunk) throws UnableToCompleteException {
          int argNumber=argChunk.getArgumentNumber();
          if (argNumber >= n) {
            throw error(logger,""String_Node_Str"" + argNumber + ""String_Node_Str""+ template);
          }
          JParameter param=paramsAccessor.getParameter(argNumber);
          String arg=""String_Node_Str"" + argNumber;
          if (argChunk.isList()) {
            buf.appendExpression(arg + ""String_Node_Str"",isSafeHtml,false,false);
          }
 else {
            JType paramType=param.getType();
            formatArg(logger,locale,buf,argChunk,paramsAccessor.getParameterExpression(argNumber),paramType,paramsAccessor);
          }
        }
        @Override public void visit(        StaticArgChunk staticArgChunk){
          buf.appendStringLiteral(staticArgChunk.getReplacement());
        }
        @Override public void visit(        StringChunk stringChunk){
          buf.appendStringLiteral(stringChunk.getString());
        }
      }
);
    }
  }
 catch (  ParseException e) {
    throw error(logger,e);
  }
  buf.completeString();
  writer.print(outputBuf.toString());
}",0.9909814323607428
53842,"public PluralFormSelector(TreeLogger logger,JMethod method,int argNumber,JParameter[] params,GwtLocale locale) throws UnableToCompleteException {
  super(logger,argNumber,params);
  PluralCount pluralCount=params[argNumber].getAnnotation(PluralCount.class);
  Class<? extends PluralRule> ruleClass=pluralCount.value();
  if (ruleClass == PluralRule.class) {
    ruleClass=DefaultRule.class;
  }
  pluralRule=createLocalizedPluralRule(logger,method.getEnclosingType().getOracle(),ruleClass,locale);
  missingPluralForms=new HashSet<String>();
  for (  PluralForm form : pluralRule.pluralForms()) {
    if (form.getWarnIfMissing() && !""String_Node_Str"".equals(form.getName())) {
      missingPluralForms.add(form.getName());
    }
  }
  Offset offsetAnnot=params[argNumber].getAnnotation(Offset.class);
  int offset=0;
  if (offsetAnnot != null) {
    offset=offsetAnnot.value();
  }
  this.pluralOffset=offset;
  boolean isArray=false;
  boolean isList=false;
  JPrimitiveType primType=argType.isPrimitive();
  JClassType classType=argType.isInterface();
  if (classType != null) {
    classType=classType.getErasedType();
    if (""String_Node_Str"".equals(classType.getQualifiedSourceName())) {
      isList=true;
    }
 else {
      classType=null;
    }
  }
  JArrayType arrayType=argType.isArray();
  if (arrayType != null) {
    isArray=true;
  }
  if (!isList && !isArray && (primType == null || (primType != JPrimitiveType.INT && primType != JPrimitiveType.SHORT))) {
    throw error(logger,method.getName() + ""String_Node_Str"");
  }
  String tempListSuffix=""String_Node_Str"";
  if (isList) {
    tempListSuffix=""String_Node_Str"";
  }
 else   if (isArray) {
    tempListSuffix=""String_Node_Str"";
  }
  String tempCountSuffix=tempListSuffix;
  if (isList || isArray || offset != 0) {
    tempCountSuffix=""String_Node_Str"";
  }
  listSuffix=tempListSuffix;
  countSuffix=tempCountSuffix;
}","public PluralFormSelector(TreeLogger logger,JMethod method,int argNumber,JParameter[] params,GwtLocale locale) throws UnableToCompleteException {
  super(logger,argNumber,params);
  PluralCount pluralCount=params[argNumber].getAnnotation(PluralCount.class);
  Class<? extends PluralRule> ruleClass=pluralCount.value();
  if (ruleClass == PluralRule.class) {
    ruleClass=DefaultRule.class;
  }
  pluralRule=createLocalizedPluralRule(logger,method.getEnclosingType().getOracle(),ruleClass,locale);
  missingPluralForms=new HashSet<String>();
  for (  PluralForm form : pluralRule.pluralForms()) {
    if (form.getWarnIfMissing() && !AlternateMessageSelector.OTHER_FORM_NAME.equals(form.getName())) {
      missingPluralForms.add(form.getName());
    }
  }
  Offset offsetAnnot=params[argNumber].getAnnotation(Offset.class);
  int offset=0;
  if (offsetAnnot != null) {
    offset=offsetAnnot.value();
  }
  this.pluralOffset=offset;
  boolean isArray=false;
  boolean isList=false;
  JPrimitiveType primType=argType.isPrimitive();
  JClassType classType=argType.isInterface();
  if (classType != null) {
    classType=classType.getErasedType();
    if (""String_Node_Str"".equals(classType.getQualifiedSourceName())) {
      isList=true;
    }
 else {
      classType=null;
    }
  }
  JArrayType arrayType=argType.isArray();
  if (arrayType != null) {
    isArray=true;
  }
  if (!isList && !isArray && (primType == null || (primType != JPrimitiveType.INT && primType != JPrimitiveType.SHORT))) {
    throw error(logger,method.getName() + ""String_Node_Str"");
  }
  String tempListSuffix=""String_Node_Str"";
  if (isList) {
    tempListSuffix=""String_Node_Str"";
  }
 else   if (isArray) {
    tempListSuffix=""String_Node_Str"";
  }
  String tempCountSuffix=tempListSuffix;
  if (isList || isArray || offset != 0) {
    tempCountSuffix=""String_Node_Str"";
  }
  listSuffix=tempListSuffix;
  countSuffix=tempCountSuffix;
}",0.9860782768584188
53843,"/** 
 * @param logger
 * @param m
 * @param locale
 * @param resourceEntry
 * @param selectors
 * @param paramsAccessor
 * @param isSafeHtml
 * @param forms
 * @throws UnableToCompleteException
 */
private void generateMessageSelectors(TreeLogger logger,JMethod m,GwtLocale locale,ResourceEntry resourceEntry,List<AlternateFormSelector> selectors,Parameters paramsAccessor,boolean isSafeHtml,String[] forms) throws UnableToCompleteException {
  int numSelectors=selectors.size();
  String[] lastForm=new String[numSelectors];
  for (  String form : forms) {
    String[] splitForms=form.split(""String_Node_Str"");
    if (splitForms.length != numSelectors) {
      throw error(logger,""String_Node_Str"" + m.getName() + ""String_Node_Str""+ form+ ""String_Node_Str"");
    }
    boolean allOther=true;
    for (    String splitForm : splitForms) {
      if (splitForm.startsWith(""String_Node_Str"")) {
        allOther=false;
      }
 else       if (!""String_Node_Str"".equals(splitForm)) {
        allOther=false;
      }
    }
    if (allOther) {
      logger.log(TreeLogger.WARN,""String_Node_Str"" + ""String_Node_Str"");
      continue;
    }
    int firstDifferent=0;
    while (firstDifferent < numSelectors && splitForms[firstDifferent].equals(lastForm[firstDifferent])) {
      firstDifferent++;
    }
    for (int i=numSelectors; i-- > firstDifferent; ) {
      if (lastForm[i] != null) {
        selectors.get(i).generateSelectMatchEnd(writer,lastForm[i]);
        if (i > firstDifferent) {
          selectors.get(i).generateSelectEnd(writer);
        }
      }
    }
    for (int i=firstDifferent; i < numSelectors; ++i) {
      if (i > firstDifferent || lastForm[i] == null) {
        selectors.get(i).generateSelectStart(writer,splitForms[i].startsWith(""String_Node_Str""));
      }
      selectors.get(i).generateSelectMatchStart(writer,logger,splitForms[i]);
      lastForm[i]=splitForms[i];
    }
    writer.print(""String_Node_Str"");
    generateString(logger,locale,resourceEntry.getForm(form),paramsAccessor,writer,isSafeHtml);
    writer.println(""String_Node_Str"");
  }
  for (int i=numSelectors; i-- > 0; ) {
    if (lastForm[i] != null) {
      selectors.get(i).generateSelectMatchEnd(writer,lastForm[i]);
      selectors.get(i).generateSelectEnd(writer);
    }
  }
}","/** 
 * @param logger
 * @param m
 * @param locale
 * @param resourceEntry
 * @param selectors
 * @param paramsAccessor
 * @param isSafeHtml
 * @param forms
 * @throws UnableToCompleteException
 */
private void generateMessageSelectors(TreeLogger logger,JMethod m,GwtLocale locale,ResourceEntry resourceEntry,List<AlternateFormSelector> selectors,Parameters paramsAccessor,boolean isSafeHtml,String[] forms) throws UnableToCompleteException {
  int numSelectors=selectors.size();
  String[] lastForm=new String[numSelectors];
  for (  String form : forms) {
    String[] splitForms=form.split(""String_Node_Str"");
    if (splitForms.length != numSelectors) {
      throw error(logger,""String_Node_Str"" + m.getName() + ""String_Node_Str""+ form+ ""String_Node_Str"");
    }
    boolean allOther=true;
    for (    String splitForm : splitForms) {
      if (splitForm.startsWith(""String_Node_Str"")) {
        allOther=false;
      }
 else       if (!AlternateMessageSelector.OTHER_FORM_NAME.equals(splitForm)) {
        allOther=false;
      }
    }
    if (allOther) {
      logger.log(TreeLogger.WARN,""String_Node_Str"" + ""String_Node_Str"");
      continue;
    }
    int firstDifferent=0;
    while (firstDifferent < numSelectors && splitForms[firstDifferent].equals(lastForm[firstDifferent])) {
      firstDifferent++;
    }
    for (int i=numSelectors; i-- > firstDifferent; ) {
      if (lastForm[i] != null) {
        selectors.get(i).generateSelectMatchEnd(writer,lastForm[i]);
        if (i > firstDifferent) {
          selectors.get(i).generateSelectEnd(writer);
        }
      }
    }
    for (int i=firstDifferent; i < numSelectors; ++i) {
      if (i > firstDifferent || lastForm[i] == null) {
        selectors.get(i).generateSelectStart(writer,splitForms[i].startsWith(""String_Node_Str""));
      }
      selectors.get(i).generateSelectMatchStart(writer,logger,splitForms[i]);
      lastForm[i]=splitForms[i];
    }
    writer.print(""String_Node_Str"");
    generateString(logger,locale,resourceEntry.getForm(form),paramsAccessor,writer,isSafeHtml);
    writer.println(""String_Node_Str"");
  }
  for (int i=numSelectors; i-- > 0; ) {
    if (lastForm[i] != null) {
      selectors.get(i).generateSelectMatchEnd(writer,lastForm[i]);
      selectors.get(i).generateSelectEnd(writer);
    }
  }
}",0.988415300546448
53844,"protected void addMapping(List<AlternateFormMapping> mapping,int numSelectors,String joinedForms,String msg){
  String[] formNames=joinedForms.split(""String_Node_Str"");
  if (formNames.length != numSelectors) {
    return;
  }
  List<AlternateForm> forms=new ArrayList<AlternateForm>();
  boolean nonOther=false;
  for (int selIdx=0; selIdx < numSelectors; ++selIdx) {
    String formName=formNames[selIdx];
    if (!selectors[selIdx].isFormAcceptable(formName)) {
      nonOther=false;
      break;
    }
    if (isStringMap || !""String_Node_Str"".equals(formName)) {
      nonOther=true;
    }
    forms.add(new AlternateForm(formName,formName));
  }
  if (!nonOther) {
  }
 else {
    mapping.add(new AlternateFormMapping(forms,msg));
  }
}","protected void addMapping(List<AlternateFormMapping> mapping,int numSelectors,String joinedForms,String msg){
  String[] formNames=joinedForms.split(""String_Node_Str"");
  if (formNames.length != numSelectors) {
    return;
  }
  List<AlternateForm> forms=new ArrayList<AlternateForm>();
  boolean nonOther=false;
  for (int selIdx=0; selIdx < numSelectors; ++selIdx) {
    String formName=formNames[selIdx];
    if (!selectors[selIdx].isFormAcceptable(formName)) {
      nonOther=false;
      break;
    }
    if (isStringMap || !AlternateMessageSelector.OTHER_FORM_NAME.equals(formName)) {
      nonOther=true;
    }
    forms.add(new AlternateForm(formName,formName));
  }
  if (!nonOther) {
  }
 else {
    mapping.add(new AlternateFormMapping(forms,msg));
  }
}",0.964830789648308
53845,"/** 
 * Called by subclasses to complete initialization, after ensuring that calls to   {@link #getAnnotation(Class)} will function properly.
 */
protected void init(){
  matchedLocale=getDefaultLocale();
  if (isAnnotationPresent(DefaultMessage.class)) {
    messageStyle=MessageStyle.MESSAGE_FORMAT;
    DefaultMessage defMsgAnnot=getAnnotation(DefaultMessage.class);
    defaultMessage=defMsgAnnot.value();
  }
 else   if (isAnnotationPresent(DefaultStringMapValue.class)) {
    messageStyle=MessageStyle.PLAIN;
    processStringMap(getAnnotation(DefaultStringMapValue.class));
    isStringMap=true;
  }
 else {
    messageStyle=MessageStyle.PLAIN;
    defaultMessage=MessageUtils.getConstantsDefaultValue(this);
  }
  Meaning meaningAnnot=getAnnotation(Meaning.class);
  if (meaningAnnot != null) {
    meaning=meaningAnnot.value();
  }
 else {
    meaning=null;
  }
  if (overrideDefault == null) {
    overrideDefault=getTranslation(localeFactory.getDefault());
    if (overrideDefault == this) {
      overrideDefault=null;
    }
  }
  List<Parameter> params=getParameters();
  int[] selectorIndices=getSelectorParameterIndices();
  int numSelectors=selectorIndices.length;
  defaultForms=new ArrayList<AlternateForm>();
  selectors=new AlternateMessageSelector[numSelectors];
  for (int i=0; i < numSelectors; ++i) {
    int selIdx=selectorIndices[i];
    if (selIdx < 0) {
      selectors[i]=new AlternateMessageSelector(){
        public boolean isFormAcceptable(        String form){
          return true;
        }
      }
;
    }
 else {
      selectors[i]=params.get(selIdx).getAlternateMessageSelector();
      defaultForms.add(AlternateMessageSelector.OTHER);
    }
  }
}","/** 
 * Called by subclasses to complete initialization, after ensuring that calls to   {@link #getAnnotation(Class)} will function properly.
 */
protected void init(){
  matchedLocale=getDefaultLocale();
  if (isAnnotationPresent(DefaultMessage.class)) {
    messageStyle=MessageStyle.MESSAGE_FORMAT;
    DefaultMessage defMsgAnnot=getAnnotation(DefaultMessage.class);
    defaultMessage=defMsgAnnot.value();
  }
 else   if (isAnnotationPresent(DefaultStringMapValue.class)) {
    messageStyle=MessageStyle.PLAIN;
    processStringMap(getAnnotation(DefaultStringMapValue.class));
    isStringMap=true;
  }
 else {
    messageStyle=MessageStyle.PLAIN;
    defaultMessage=MessageUtils.getConstantsDefaultValue(this);
  }
  Meaning meaningAnnot=getAnnotation(Meaning.class);
  if (meaningAnnot != null) {
    meaning=meaningAnnot.value();
  }
 else {
    meaning=null;
  }
  if (overrideDefault == null) {
    overrideDefault=getTranslation(localeFactory.getDefault());
    if (overrideDefault == this) {
      overrideDefault=null;
    }
  }
  List<Parameter> params=getParameters();
  int[] selectorIndices=getSelectorParameterIndices();
  int numSelectors=selectorIndices.length;
  defaultForms=new ArrayList<AlternateForm>();
  selectors=new AlternateMessageSelector[numSelectors];
  for (int i=0; i < numSelectors; ++i) {
    int selIdx=selectorIndices[i];
    if (selIdx < 0) {
      selectors[i]=new AlternateMessageSelector(){
        public boolean isFormAcceptable(        String form){
          return true;
        }
      }
;
    }
 else {
      selectors[i]=params.get(selIdx).getAlternateMessageSelector();
      defaultForms.add(AlternateMessageSelector.OTHER_FORM);
    }
  }
}",0.9985211475894704
53846,"public void accept(MessageVisitor mv,GwtLocale locale) throws MessageProcessingException {
  ensureSelectorParams();
  List<Parameter> params=getParameters();
  int numSelectors=selectorParams.length;
  String[] lastForm=new String[numSelectors];
  MessageTranslation trans=null;
  if (locale != null) {
    for (    GwtLocale search : locale.getCompleteSearchList()) {
      trans=getTranslation(search);
      if (trans != null) {
        break;
      }
    }
  }
  if (trans == null) {
    trans=this;
  }
  for (  AlternateFormMapping mapping : trans.getAllMessageForms()) {
    List<AlternateForm> forms=mapping.getForms();
    boolean allOther=true;
    for (int i=0; i < forms.size(); ++i) {
      lastForm[i]=forms.get(i).getName();
      if (!""String_Node_Str"".equals(lastForm[i])) {
        allOther=false;
      }
    }
    mv.visitTranslation(lastForm,allOther,messageStyle,mapping.getMessage());
  }
  mv.endMessage(this,trans);
}","public void accept(MessageVisitor mv,GwtLocale locale) throws MessageProcessingException {
  ensureSelectorParams();
  List<Parameter> params=getParameters();
  int numSelectors=selectorParams.length;
  String[] lastForm=new String[numSelectors];
  MessageTranslation trans=null;
  if (locale != null) {
    for (    GwtLocale search : locale.getCompleteSearchList()) {
      trans=getTranslation(search);
      if (trans != null) {
        break;
      }
    }
  }
  if (trans == null) {
    trans=this;
  }
  for (  AlternateFormMapping mapping : trans.getAllMessageForms()) {
    List<AlternateForm> forms=mapping.getForms();
    boolean allOther=true;
    for (int i=0; i < forms.size(); ++i) {
      lastForm[i]=forms.get(i).getName();
      if (!AlternateMessageSelector.OTHER_FORM_NAME.equals(lastForm[i])) {
        allOther=false;
      }
    }
    mv.visitTranslation(lastForm,allOther,messageStyle,mapping.getMessage());
  }
  mv.endMessage(this,trans);
}",0.9732844421162912
53847,"private AlternateMessageSelector computeAlternateMessageSelector(){
  PluralCount pluralAnnot=getAnnotation(PluralCount.class);
  if (pluralAnnot != null) {
    Class<? extends PluralRule> pluralClass=pluralAnnot.value();
    DefaultLocale defLocaleAnnot=getAnnotation(DefaultLocale.class);
    String defaultLocale=null;
    if (defLocaleAnnot != null) {
      defaultLocale=defLocaleAnnot.value();
    }
 else {
      defaultLocale=DefaultLocale.DEFAULT_LOCALE;
    }
    PluralRule pluralRule=getLocalizedPluralRule(pluralClass,localeFactory.fromString(defaultLocale));
    return new PluralRuleAdapter(pluralRule);
  }
  Select selectAnnot=getAnnotation(Select.class);
  if (selectAnnot != null) {
    final String[] validValues=type.getEnumValues();
    return new AlternateMessageSelector(){
      public boolean isFormAcceptable(      String form){
        if (validValues == null) {
          return true;
        }
        for (        String value : validValues) {
          if (value.equals(form)) {
            return true;
          }
        }
        return false;
      }
    }
;
  }
  return null;
}","private AlternateMessageSelector computeAlternateMessageSelector(){
  PluralCount pluralAnnot=getAnnotation(PluralCount.class);
  if (pluralAnnot != null) {
    Class<? extends PluralRule> pluralClass=pluralAnnot.value();
    DefaultLocale defLocaleAnnot=getAnnotation(DefaultLocale.class);
    String defaultLocale=null;
    if (defLocaleAnnot != null) {
      defaultLocale=defLocaleAnnot.value();
    }
 else {
      defaultLocale=DefaultLocale.DEFAULT_LOCALE;
    }
    PluralRule pluralRule=getLocalizedPluralRule(pluralClass,localeFactory.fromString(defaultLocale));
    return new PluralRuleAdapter(pluralRule);
  }
  Select selectAnnot=getAnnotation(Select.class);
  if (selectAnnot != null) {
    final String[] validValues=type.getEnumValues();
    return new AlternateMessageSelector(){
      public boolean isFormAcceptable(      String form){
        if (validValues == null || AlternateMessageSelector.OTHER_FORM_NAME.equals(form)) {
          return true;
        }
        for (        String value : validValues) {
          if (value.equals(form)) {
            return true;
          }
        }
        return false;
      }
    }
;
  }
  return null;
}",0.9750982961992136
53848,"public boolean isFormAcceptable(String form){
  if (validValues == null) {
    return true;
  }
  for (  String value : validValues) {
    if (value.equals(form)) {
      return true;
    }
  }
  return false;
}","public boolean isFormAcceptable(String form){
  if (validValues == null || AlternateMessageSelector.OTHER_FORM_NAME.equals(form)) {
    return true;
  }
  for (  String value : validValues) {
    if (value.equals(form)) {
      return true;
    }
  }
  return false;
}",0.8810020876826722
53849,"public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(DocumentTest.class);
  suite.addTestSuite(NodeTest.class);
  suite.addTestSuite(ElementTest.class);
  suite.addTestSuite(FormTests.class);
  suite.addTestSuite(MapTests.class);
  suite.addTestSuite(SelectTests.class);
  suite.addTestSuite(StyleInjectorTest.class);
  suite.addTestSuite(TableTests.class);
  suite.addTestSuite(TextTest.class);
  return suite;
}","public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(DocumentTest.class);
  suite.addTestSuite(NodeTest.class);
  suite.addTestSuite(ElementTest.class);
  suite.addTestSuite(FormTests.class);
  suite.addTestSuite(FrameTests.class);
  suite.addTestSuite(MapTests.class);
  suite.addTestSuite(SelectTests.class);
  suite.addTestSuite(StyleInjectorTest.class);
  suite.addTestSuite(TableTests.class);
  suite.addTestSuite(TextTest.class);
  return suite;
}",0.9589322381930184
53850,"@Override public Object createServiceInstance(Method contextMethod,Method domainMethod){
  Class<? extends ServiceLocator> locatorType=getTop().resolveServiceLocator(contextMethod,domainMethod);
  ServiceLocator locator=newInstance(locatorType,ServiceLocator.class);
  return locator.getInstance(domainMethod.getDeclaringClass());
}","@Override public Object createServiceInstance(Method contextMethod,Method domainMethod){
  Class<? extends ServiceLocator> locatorType=getTop().resolveServiceLocator(contextMethod,domainMethod);
  ServiceLocator locator=newInstance(locatorType,ServiceLocator.class);
  Class<?> declaringClass=contextMethod.getDeclaringClass();
  Class<?> serviceClass=getTop().resolveServiceClass((Class<? extends RequestContext>)declaringClass);
  return locator.getInstance(serviceClass);
}",0.7351485148514851
53851,"@Override public Method resolveDomainMethod(Method requestContextMethod){
  Class<?> enclosing=requestContextMethod.getDeclaringClass();
  Class<?> searchIn=null;
  Service s=enclosing.getAnnotation(Service.class);
  if (s != null) {
    searchIn=s.value();
  }
  ServiceName sn=enclosing.getAnnotation(ServiceName.class);
  if (sn != null) {
    searchIn=forName(sn.value());
  }
  if (searchIn == null) {
    die(null,""String_Node_Str"",RequestContext.class.getSimpleName(),enclosing.getCanonicalName());
  }
  Class<?>[] parameterTypes=requestContextMethod.getParameterTypes();
  Class<?>[] domainArgs=new Class<?>[parameterTypes.length];
  for (int i=0, j=domainArgs.length; i < j; i++) {
    if (BaseProxy.class.isAssignableFrom(parameterTypes[i])) {
      domainArgs[i]=getTop().resolveDomainClass(parameterTypes[i].asSubclass(BaseProxy.class));
    }
 else     if (EntityProxyId.class.isAssignableFrom(parameterTypes[i])) {
      domainArgs[i]=TypeUtils.ensureBaseType(TypeUtils.getSingleParameterization(EntityProxyId.class,requestContextMethod.getGenericParameterTypes()[i]));
    }
 else {
      domainArgs[i]=parameterTypes[i];
    }
  }
  Throwable ex;
  try {
    return searchIn.getMethod(requestContextMethod.getName(),domainArgs);
  }
 catch (  SecurityException e) {
    ex=e;
  }
catch (  NoSuchMethodException e) {
    return report(""String_Node_Str"",requestContextMethod.getName());
  }
  return die(ex,""String_Node_Str"",requestContextMethod.getName(),searchIn.getCanonicalName());
}","@Override public Method resolveDomainMethod(Method requestContextMethod){
  Class<?> declaringClass=requestContextMethod.getDeclaringClass();
  Class<?> searchIn=getTop().resolveServiceClass((Class<? extends RequestContext>)declaringClass);
  Class<?>[] parameterTypes=requestContextMethod.getParameterTypes();
  Class<?>[] domainArgs=new Class<?>[parameterTypes.length];
  for (int i=0, j=domainArgs.length; i < j; i++) {
    if (BaseProxy.class.isAssignableFrom(parameterTypes[i])) {
      domainArgs[i]=getTop().resolveDomainClass(parameterTypes[i].asSubclass(BaseProxy.class));
    }
 else     if (EntityProxyId.class.isAssignableFrom(parameterTypes[i])) {
      domainArgs[i]=TypeUtils.ensureBaseType(TypeUtils.getSingleParameterization(EntityProxyId.class,requestContextMethod.getGenericParameterTypes()[i]));
    }
 else {
      domainArgs[i]=parameterTypes[i];
    }
  }
  Throwable ex;
  try {
    return searchIn.getMethod(requestContextMethod.getName(),domainArgs);
  }
 catch (  SecurityException e) {
    ex=e;
  }
catch (  NoSuchMethodException e) {
    return report(""String_Node_Str"",requestContextMethod.getName());
  }
  return die(ex,""String_Node_Str"",requestContextMethod.getName(),searchIn.getCanonicalName());
}",0.8497257769652651
53852,"public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTestSuite(BoxesAndPrimitivesJreTest.class);
  suite.addTestSuite(ComplexKeysJreTest.class);
  suite.addTestSuite(FindServiceJreTest.class);
  suite.addTestSuite(LocatorJreTest.class);
  suite.addTestSuite(RequestFactoryExceptionPropagationJreTest.class);
  suite.addTestSuite(RequestFactoryInterfaceValidatorTest.class);
  suite.addTestSuite(RequestFactoryJreTest.class);
  suite.addTestSuite(RequestFactoryModelTest.class);
  suite.addTestSuite(RequestFactoryUnicodeEscapingJreTest.class);
  suite.addTestSuite(SimpleEntityProxyIdTest.class);
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTestSuite(BoxesAndPrimitivesJreTest.class);
  suite.addTestSuite(ComplexKeysJreTest.class);
  suite.addTestSuite(FindServiceJreTest.class);
  suite.addTestSuite(LocatorJreTest.class);
  suite.addTestSuite(RequestFactoryExceptionPropagationJreTest.class);
  suite.addTestSuite(RequestFactoryInterfaceValidatorTest.class);
  suite.addTestSuite(RequestFactoryJreTest.class);
  suite.addTestSuite(RequestFactoryModelTest.class);
  suite.addTestSuite(RequestFactoryUnicodeEscapingJreTest.class);
  suite.addTestSuite(ServiceInheritanceJreTest.class);
  suite.addTestSuite(SimpleEntityProxyIdTest.class);
  return suite;
}",0.9595290654893304
53853,"@SuppressWarnings(""String_Node_Str"") public V next(){
  if (!hasNext()) {
    throw new NoSuchElementException();
  }
  last=index;
  Object toReturn=values[index++];
  advanceToItem();
  return (V)toReturn;
}","public E next(){
  if (!hasNext()) {
    throw new NoSuchElementException();
  }
  last=index;
  return iteratorItem(index++);
}",0.6765578635014837
53854,"public HashMap(Map<? extends K,? extends V> m){
  int newCapacity=INITIAL_TABLE_SIZE;
  int expectedSize=m.size();
  while (newCapacity * 3 < expectedSize * 4) {
    newCapacity<<=1;
  }
  initTable(newCapacity);
  internalPutAll(m);
}","public HashMap(Map<? extends K,? extends V> m){
  int newCapacity=INITIAL_TABLE_SIZE;
  int expectedSize=m.size();
  while (newCapacity * 3 < expectedSize * 4) {
    newCapacity<<=1;
  }
  initTable(newCapacity);
  putAll(m);
}",0.9783549783549784
53855,"@SuppressWarnings(""String_Node_Str"") public V put(K key,V value){
  ensureSizeFor(size + 1);
  int index=findKeyOrEmpty(key);
  if (keys[index] == null) {
    ++size;
    keys[index]=maskNullKey(key);
    values[index]=value;
    return null;
  }
 else {
    Object previousValue=values[index];
    values[index]=value;
    return (V)previousValue;
  }
}","@SuppressWarnings(""String_Node_Str"") public V put(K key,V value){
  int index=findKeyOrEmpty(key);
  if (keys[index] == null) {
    if (ensureSizeFor(++size)) {
      index=findKeyOrEmpty(key);
    }
    keys[index]=maskNullKey(key);
    values[index]=value;
    return null;
  }
 else {
    Object previousValue=values[index];
    values[index]=value;
    return (V)previousValue;
  }
}",0.8205128205128205
53856,"public void putAll(Map<? extends K,? extends V> m){
  ensureSizeFor(size + m.size());
  internalPutAll(m);
}","public void putAll(Map<? extends K,? extends V> m){
  resizeForJoin(m.size());
  for (  Entry<? extends K,? extends V> entry : m.entrySet()) {
    put(entry.getKey(),entry.getValue());
  }
}",0.5973154362416108
53857,"public boolean hasNext(){
  return index < keys.length;
}","public boolean hasNext(){
  if (coModCheckKeys != keys) {
    throw new ConcurrentModificationException();
  }
  advanceToItem();
  return index < keys.length;
}",0.5229357798165137
53858,"@Override public boolean addAll(Collection<? extends Entry<K,V>> c){
  HashMap.this.ensureSizeFor(size() + c.size());
  return super.addAll(c);
}","@Override public boolean addAll(Collection<? extends Entry<K,V>> c){
  HashMap.this.resizeForJoin(c.size());
  return super.addAll(c);
}",0.9323843416370108
53859,"/** 
 * Ensures the map is large enough to contain the specified number of entries. Default access to avoid synthetic accessors from inner classes.
 */
void ensureSizeFor(int expectedSize){
  if (keys.length * 3 >= expectedSize * 4) {
    return;
  }
  int newCapacity=keys.length << 1;
  while (newCapacity * 3 < expectedSize * 4) {
    newCapacity<<=1;
  }
  Object[] oldKeys=keys;
  Object[] oldValues=values;
  initTable(newCapacity);
  for (int i=0; i < oldKeys.length; ++i) {
    Object k=oldKeys[i];
    if (k != null) {
      int newIndex=getKeyIndex(unmaskNullKey(k));
      while (keys[newIndex] != null) {
        if (++newIndex == keys.length) {
          newIndex=0;
        }
      }
      keys[newIndex]=k;
      values[newIndex]=oldValues[i];
    }
  }
}","/** 
 * Ensures the map is large enough to contain the specified number of entries. Default access to avoid synthetic accessors from inner classes.
 */
boolean ensureSizeFor(int expectedSize){
  if (keys.length * 3 >= expectedSize * 4) {
    return false;
  }
  int newCapacity=keys.length << 1;
  while (newCapacity * 3 < expectedSize * 4) {
    newCapacity<<=1;
  }
  Object[] oldKeys=keys;
  Object[] oldValues=values;
  initTable(newCapacity);
  for (int i=0; i < oldKeys.length; ++i) {
    Object k=oldKeys[i];
    if (k != null) {
      int newIndex=getKeyIndex(unmaskNullKey(k));
      while (keys[newIndex] != null) {
        if (++newIndex == keys.length) {
          newIndex=0;
        }
      }
      keys[newIndex]=k;
      values[newIndex]=oldValues[i];
    }
  }
  return true;
}",0.979539641943734
53860,"/** 
 * Determines whether the given class fully implements an interface (either directly or via inherited methods).
 */
private boolean classFullyImplements(JClassType cls,JClassType intf){
  if (!intf.isAssignableFrom(cls)) {
    return false;
  }
  for (  JMethod meth : intf.getInheritableMethods()) {
    if (!classImplementsMethod(cls,meth)) {
      return false;
    }
  }
  return true;
}","/** 
 * Determines whether the given class fully implements an interface (either directly or via inherited methods).
 */
private boolean classFullyImplements(JClassType cls,JClassType intf){
  if ((intf.getMethods().length > 0) && !intf.isAssignableFrom(cls)) {
    return false;
  }
  for (  JMethod meth : intf.getInheritableMethods()) {
    if (!classImplementsMethod(cls,meth)) {
      return false;
    }
  }
  return true;
}",0.9588377723970944
53861,"/** 
 * This constructor may be used by subclasses to explicitly use an existing element. This element must be an &lt;img&gt; element.
 * @param element the element to be used
 */
protected Image(Element element){
  ImageElement.as(element);
  setElement(element);
}","/** 
 * This constructor may be used by subclasses to explicitly use an existing element. This element must be an &lt;img&gt; element.
 * @param element the element to be used
 */
protected Image(Element element){
  ImageElement.as(element);
  setElement(element);
  changeState(new UnclippedState(element));
}",0.9236111111111112
53862,"/** 
 * Determines whether the given   {@link JavaScriptObject} is a DOM node. A<code>null</code> object will cause this method to return <code>false</code>.
 */
public static native boolean is(JavaScriptObject o);","/** 
 * Determines whether the given   {@link JavaScriptObject} is a DOM node. A<code>null</code> object will cause this method to return <code>false</code>. The try catch is needed for the firefox permission error: ""Permission denied to access property 'nodeType'""
 */
public static native boolean is(JavaScriptObject o);",0.7985074626865671
53863,"public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(DocumentTest.class);
  suite.addTestSuite(NodeTest.class);
  suite.addTestSuite(ElementTest.class);
  suite.addTestSuite(FormTests.class);
  suite.addTestSuite(MapTests.class);
  suite.addTestSuite(SelectTests.class);
  suite.addTestSuite(StyleInjectorTest.class);
  suite.addTestSuite(TableTests.class);
  suite.addTestSuite(TextTest.class);
  return suite;
}","public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(DocumentTest.class);
  suite.addTestSuite(NodeTest.class);
  suite.addTestSuite(ElementTest.class);
  suite.addTestSuite(FormTests.class);
  suite.addTestSuite(FrameTests.class);
  suite.addTestSuite(MapTests.class);
  suite.addTestSuite(SelectTests.class);
  suite.addTestSuite(StyleInjectorTest.class);
  suite.addTestSuite(TableTests.class);
  suite.addTestSuite(TextTest.class);
  return suite;
}",0.9589322381930184
53864,"public boolean isChanged(){
  for (  AutoBean<?> bean : editedProxies.values()) {
    AutoBean<?> previous=bean.getTag(Constants.PARENT_OBJECT);
    if (previous == null) {
      Class<?> proxyClass=((EntityProxy)bean.as()).stableId().getProxyClass();
      previous=getRequestFactory().getAutoBeanFactory().create(proxyClass);
    }
    if (!AutoBeanUtils.diff(previous,bean).isEmpty()) {
      return true;
    }
  }
  return false;
}","public boolean isChanged(){
  for (  AutoBean<? extends BaseProxy> bean : editedProxies.values()) {
    AutoBean<?> previous=bean.getTag(Constants.PARENT_OBJECT);
    if (previous == null) {
      Class<?> proxyClass=stableId(bean).getProxyClass();
      previous=getRequestFactory().getAutoBeanFactory().create(proxyClass);
    }
    if (!AutoBeanUtils.diff(previous,bean).isEmpty()) {
      return true;
    }
  }
  return false;
}",0.945914844649022
53865,"private void animate(int duration){
  if (layoutData.size() == 0) {
    return;
  }
  double top=0, bottom=0;
  int i=0;
  for (; i < layoutData.size(); ++i) {
    LayoutData data=layoutData.get(i);
    layoutPanel.setWidgetTopHeight(data.header,top,unit,data.headerSize,unit);
    top+=data.headerSize;
    layoutPanel.setWidgetTopHeight(data.widget,top,unit,0,unit);
    if (i == selectedIndex) {
      break;
    }
  }
  for (int j=layoutData.size() - 1; j > i; --j) {
    LayoutData data=layoutData.get(j);
    layoutPanel.setWidgetBottomHeight(data.header,bottom,unit,data.headerSize,unit);
    layoutPanel.setWidgetBottomHeight(data.widget,bottom,unit,0,unit);
    bottom+=data.headerSize;
  }
  LayoutData data=layoutData.get(selectedIndex);
  layoutPanel.setWidgetTopBottom(data.widget,top,unit,bottom,unit);
  layoutPanel.animate(duration);
}","public void animate(int duration,AnimationCallback callback){
  if (layoutData.size() == 0) {
    if (callback != null) {
      callback.onAnimationComplete();
    }
    return;
  }
  double top=0, bottom=0;
  int i=0;
  for (; i < layoutData.size(); ++i) {
    LayoutData data=layoutData.get(i);
    layoutPanel.setWidgetTopHeight(data.header,top,unit,data.headerSize,unit);
    top+=data.headerSize;
    layoutPanel.setWidgetTopHeight(data.widget,top,unit,0,unit);
    if (i == selectedIndex) {
      break;
    }
  }
  for (int j=layoutData.size() - 1; j > i; --j) {
    LayoutData data=layoutData.get(j);
    layoutPanel.setWidgetBottomHeight(data.header,bottom,unit,data.headerSize,unit);
    layoutPanel.setWidgetBottomHeight(data.widget,bottom,unit,0,unit);
    bottom+=data.headerSize;
  }
  LayoutData data=layoutData.get(selectedIndex);
  layoutPanel.setWidgetTopBottom(data.widget,top,unit,bottom,unit);
  layoutPanel.animate(duration,callback);
}",0.9065782200110558
53866,"public boolean remove(Widget child){
  if (child.getParent() != layoutPanel) {
    return false;
  }
  for (int i=0; i < layoutData.size(); ++i) {
    LayoutData data=layoutData.get(i);
    if (data.widget == child) {
      layoutPanel.remove(data.header);
      layoutPanel.remove(data.widget);
      data.header.removeStyleName(HEADER_STYLE);
      data.widget.removeStyleName(CONTENT_STYLE);
      layoutData.remove(i);
      if (selectedIndex == i) {
        selectedIndex=-1;
        if (layoutData.size() > 0) {
          showWidget(layoutData.get(0).widget);
        }
      }
      return true;
    }
  }
  return false;
}","public boolean remove(Widget child){
  if (child.getParent() != layoutPanel) {
    return false;
  }
  for (int i=0; i < layoutData.size(); ++i) {
    LayoutData data=layoutData.get(i);
    if (data.widget == child) {
      layoutPanel.remove(data.header);
      layoutPanel.remove(data.widget);
      data.header.removeStyleName(HEADER_STYLE);
      data.widget.removeStyleName(CONTENT_STYLE);
      layoutData.remove(i);
      if (selectedIndex == i) {
        selectedIndex=-1;
        if (layoutData.size() > 0) {
          showWidget(layoutData.get(0).widget);
        }
      }
 else {
        if (i <= selectedIndex) {
          selectedIndex--;
        }
        animate(animationDuration);
      }
      return true;
    }
  }
  return false;
}",0.8850325379609545
53867,"/** 
 * Tests to ensure that arbitrary widgets can be added/inserted effectively.
 */
public void testInsertWithWidgets(){
  StackLayoutPanel p=new StackLayoutPanel(Unit.EM);
  TextBox wa=new TextBox();
  CheckBox wb=new CheckBox();
  VerticalPanel wc=new VerticalPanel();
  wc.add(new Label(""String_Node_Str""));
  wc.add(new Label(""String_Node_Str""));
  p.add(new Label(""String_Node_Str""),wc,1);
  p.insert(new Label(""String_Node_Str""),wb,1,0);
  p.insert(new Label(""String_Node_Str""),wa,1,0);
  assertNotNull(p.getHeaderWidget(0));
  assertNotNull(p.getHeaderWidget(1));
  assertNotNull(p.getHeaderWidget(2));
  assertEquals(3,p.getWidgetCount());
}","/** 
 * Tests to ensure that arbitrary widgets can be added/inserted effectively.
 */
public void testInsertWithWidgets(){
  StackLayoutPanel p=new StackLayoutPanel(Unit.EM);
  TextBox wa=new TextBox();
  CheckBox wb=new CheckBox();
  VerticalPanel wc=new VerticalPanel();
  wc.add(new Label(""String_Node_Str""));
  wc.add(new Label(""String_Node_Str""));
  Label contentA=new Label(""String_Node_Str"");
  Label contentB=new Label(""String_Node_Str"");
  Label contentC=new Label(""String_Node_Str"");
  p.add(contentC,wc,1);
  p.insert(contentB,wb,1,0);
  p.showWidget(1);
  p.insert(contentA,wa,1,0);
  assertEquals(2,p.getVisibleIndex());
  assertEquals(wa,p.getHeaderWidget(0));
  assertEquals(wb,p.getHeaderWidget(1));
  assertEquals(wc,p.getHeaderWidget(2));
  assertEquals(contentA,p.getWidget(0));
  assertEquals(contentB,p.getWidget(1));
  assertEquals(contentC,p.getWidget(2));
  assertEquals(3,p.getWidgetCount());
}",0.6343949044585987
53868,"/** 
 * Returns a hash code on the byte code of the class. TODO(zundel): should be a hash on only the public API for this class. 
 */
public String getSignatureHash(){
  if (signatureHash == null) {
    signatureHash=Util.computeStrongName(getBytes());
  }
  return signatureHash;
}","/** 
 * Returns a hash code on the byte code of the class.
 */
public String getSignatureHash(){
  if (signatureHash == null) {
    signatureHash=BytecodeSignatureMaker.getCompileDependencySignature(getBytes());
  }
  return signatureHash;
}",0.7418738049713193
53869,"private Object writeReplace(){
  return new SerializedRef(target.getInternalName(),getSignatureHash());
}","protected Object writeReplace(){
  return new SerializedRef(target.getInternalName(),getSignatureHash());
}",0.9622641509433962
53870,"public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(DocumentTest.class);
  suite.addTestSuite(NodeTest.class);
  suite.addTestSuite(ElementTest.class);
  suite.addTestSuite(FormTests.class);
  suite.addTestSuite(FrameTests.class);
  suite.addTestSuite(MapTests.class);
  suite.addTestSuite(SelectTests.class);
  suite.addTestSuite(StyleInjectorTest.class);
  suite.addTestSuite(TableTests.class);
  suite.addTestSuite(TextTest.class);
  return suite;
}","public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(DocumentTest.class);
  suite.addTestSuite(NodeTest.class);
  suite.addTestSuite(ElementTest.class);
  suite.addTestSuite(FormTests.class);
  suite.addTestSuite(MapTests.class);
  suite.addTestSuite(SelectTests.class);
  suite.addTestSuite(StyleInjectorTest.class);
  suite.addTestSuite(TableTests.class);
  suite.addTestSuite(TextTest.class);
  return suite;
}",0.9589322381930184
53871,"Splittable encode(Object obj){
  Splittable value;
  if (obj == null) {
    return LazySplittable.NULL;
  }
 else   if (obj.getClass().isEnum() && getRequestFactory() instanceof EnumMap) {
    value=ValueCodex.encode(((EnumMap)getRequestFactory()).getToken((Enum<?>)obj));
  }
 else   if (ValueCodex.canDecode(obj.getClass())) {
    value=ValueCodex.encode(obj);
  }
 else {
    value=AutoBeanCodex.encode(AutoBeanUtils.getAutoBean(obj));
  }
  return value;
}","Splittable encode(Object obj){
  Splittable value;
  if (obj == null) {
    return LazySplittable.NULL;
  }
 else   if (obj.getClass().isEnum() && getRequestFactory().getAutoBeanFactory() instanceof EnumMap) {
    value=ValueCodex.encode(((EnumMap)getRequestFactory().getAutoBeanFactory()).getToken((Enum<?>)obj));
  }
 else   if (ValueCodex.canDecode(obj.getClass())) {
    value=ValueCodex.encode(obj);
  }
 else {
    value=AutoBeanCodex.encode(AutoBeanUtils.getAutoBean(obj));
  }
  return value;
}",0.9563409563409564
53872,"/** 
 * Initialize the location of the widget that will slide into view.
 */
private void doBeforeLayout(){
  Layer oldLayer=(lastVisibleWidget == null) ? null : (Layer)lastVisibleWidget.getLayoutData();
  Layer newLayer=(visibleWidget == null) ? null : (Layer)visibleWidget.getLayoutData();
  int oldIndex=getWidgetIndex(lastVisibleWidget);
  int newIndex=getWidgetIndex(visibleWidget);
  double direction=(oldIndex < newIndex) ? 100.0 : -100.0;
  double vDirection=isAnimationVertical ? direction : 0.0;
  double hDirection=isAnimationVertical ? 0.0 : LocaleInfo.getCurrentLocale().isRTL() ? -direction : direction;
  if (oldLayer != null) {
    oldLayer.setTopHeight(0.0,Unit.PCT,100.0,Unit.PCT);
    oldLayer.setLeftWidth(0.0,Unit.PCT,100.0,Unit.PCT);
    setWidgetVisible(lastVisibleWidget,oldLayer,true);
  }
  if (newLayer != null) {
    newLayer.setTopHeight(vDirection,Unit.PCT,100.0,Unit.PCT);
    newLayer.setLeftWidth(hDirection,Unit.PCT,100.0,Unit.PCT);
    setWidgetVisible(visibleWidget,newLayer,true);
  }
  layout.layout();
  if (oldLayer != null) {
    oldLayer.setTopHeight(-vDirection,Unit.PCT,100.0,Unit.PCT);
    oldLayer.setLeftWidth(-hDirection,Unit.PCT,100.0,Unit.PCT);
    setWidgetVisible(lastVisibleWidget,oldLayer,true);
  }
  if (newLayer != null) {
    newLayer.setTopHeight(0.0,Unit.PCT,100.0,Unit.PCT);
    newLayer.setLeftWidth(0.0,Unit.PCT,100.0,Unit.PCT);
    setWidgetVisible(visibleWidget,newLayer,true);
  }
  hidingWidget=lastVisibleWidget;
  lastVisibleWidget=visibleWidget;
}","/** 
 * Initialize the location of the widget that will slide into view.
 */
private void doBeforeLayout(){
  Layer oldLayer=(lastVisibleWidget == null) ? null : (Layer)lastVisibleWidget.getLayoutData();
  Layer newLayer=(visibleWidget == null) ? null : (Layer)visibleWidget.getLayoutData();
  int oldIndex=getWidgetIndex(lastVisibleWidget);
  int newIndex=getWidgetIndex(visibleWidget);
  double direction=(oldIndex < newIndex) ? 100.0 : -100.0;
  double vDirection=isAnimationVertical ? direction : 0.0;
  double hDirection=isAnimationVertical ? 0.0 : LocaleInfo.getCurrentLocale().isRTL() ? -direction : direction;
  hidingWidget=null;
  if (visibleWidget != lastVisibleWidget) {
    if (oldLayer != null) {
      oldLayer.setTopHeight(0.0,Unit.PCT,100.0,Unit.PCT);
      oldLayer.setLeftWidth(0.0,Unit.PCT,100.0,Unit.PCT);
      setWidgetVisible(lastVisibleWidget,oldLayer,true);
    }
    if (newLayer != null) {
      newLayer.setTopHeight(vDirection,Unit.PCT,100.0,Unit.PCT);
      newLayer.setLeftWidth(hDirection,Unit.PCT,100.0,Unit.PCT);
      setWidgetVisible(visibleWidget,newLayer,true);
    }
    layout.layout();
    hidingWidget=lastVisibleWidget;
  }
  if (oldLayer != null) {
    oldLayer.setTopHeight(-vDirection,Unit.PCT,100.0,Unit.PCT);
    oldLayer.setLeftWidth(-hDirection,Unit.PCT,100.0,Unit.PCT);
    setWidgetVisible(lastVisibleWidget,oldLayer,true);
  }
  if (newLayer != null) {
    newLayer.setTopHeight(0.0,Unit.PCT,100.0,Unit.PCT);
    newLayer.setLeftWidth(0.0,Unit.PCT,100.0,Unit.PCT);
    setWidgetVisible(visibleWidget,newLayer,true);
  }
  lastVisibleWidget=visibleWidget;
}",0.9306044131755676
53873,"private boolean process(ReferenceBinding binding){
  JDeclaredType type=(JDeclaredType)getType(binding);
  try {
    if (type instanceof JClassType && type != program.getTypeJavaLangObject()) {
      JMethod getClassMethod=program.createMethod(type.getSourceInfo().makeChild(BuildDeclMapVisitor.class,""String_Node_Str""),""String_Node_Str"",type,program.getTypeJavaLangClass(),false,false,false,false,false);
      assert(type.getMethods().get(2) == getClassMethod);
      getClassMethod.freezeParamTypes();
      getClassMethod.setSynthetic();
    }
    if (binding.isNestedType() && !binding.isStatic() && !(binding instanceof BinaryTypeBinding)) {
      assert(type instanceof JClassType);
      NestedTypeBinding nestedBinding=(NestedTypeBinding)binding;
      if (nestedBinding.enclosingInstances != null) {
        for (int i=0; i < nestedBinding.enclosingInstances.length; ++i) {
          SyntheticArgumentBinding arg=nestedBinding.enclosingInstances[i];
          if (arg.matchingField != null) {
            createField(arg,type,Disposition.THIS_REF);
          }
        }
      }
      if (nestedBinding.outerLocalVariables != null) {
        for (int i=0; i < nestedBinding.outerLocalVariables.length; ++i) {
          SyntheticArgumentBinding arg=nestedBinding.outerLocalVariables[i];
          boolean isReallyThisRef=false;
          if (arg.actualOuterLocalVariable instanceof SyntheticArgumentBinding) {
            SyntheticArgumentBinding outer=(SyntheticArgumentBinding)arg.actualOuterLocalVariable;
            if (outer.matchingField != null) {
              JField field=(JField)typeMap.get(outer.matchingField);
              if (field.isThisRef()) {
                isReallyThisRef=true;
              }
            }
          }
          createField(arg,type,isReallyThisRef ? Disposition.THIS_REF : Disposition.FINAL);
        }
      }
    }
    ReferenceBinding superClassBinding=binding.superclass();
    if (type instanceof JClassType && superClassBinding != null) {
      assert(binding.superclass().isClass() || binding.superclass().isEnum());
      JClassType superClass=(JClassType)getType(superClassBinding);
      ((JClassType)type).setSuperClass(superClass);
    }
    ReferenceBinding[] superInterfaces=binding.superInterfaces();
    for (    ReferenceBinding superInterfaceBinding : superInterfaces) {
      assert(superInterfaceBinding.isInterface());
      JInterfaceType superInterface=(JInterfaceType)getType(superInterfaceBinding);
      type.addImplements(superInterface);
    }
    ReferenceBinding enclosingBinding=binding.enclosingType();
    if (enclosingBinding != null) {
      type.setEnclosingType((JDeclaredType)getType(enclosingBinding));
    }
    if (type instanceof JEnumType) {
      processEnumType(binding,(JEnumType)type);
    }
    return true;
  }
 catch (  VirtualMachineError e) {
    throw e;
  }
catch (  InternalCompilerException ice) {
    ice.addNode(type);
    throw ice;
  }
catch (  Throwable e) {
    throw new InternalCompilerException(type,""String_Node_Str"",e);
  }
}","private boolean process(ReferenceBinding binding){
  JDeclaredType type=(JDeclaredType)getType(binding);
  try {
    if (type instanceof JClassType && type != program.getTypeJavaLangObject()) {
      JMethod getClassMethod=program.createMethod(type.getSourceInfo().makeChild(BuildDeclMapVisitor.class,""String_Node_Str""),""String_Node_Str"",type,program.getTypeJavaLangClass(),false,false,false,false,false);
      assert(type.getMethods().get(2) == getClassMethod);
      getClassMethod.freezeParamTypes();
      getClassMethod.setSynthetic();
    }
    if (binding.isNestedType() && !binding.isStatic() && !(binding instanceof BinaryTypeBinding)) {
      assert(type instanceof JClassType);
      NestedTypeBinding nestedBinding=(NestedTypeBinding)binding;
      if (nestedBinding.enclosingInstances != null) {
        for (int i=0; i < nestedBinding.enclosingInstances.length; ++i) {
          SyntheticArgumentBinding arg=nestedBinding.enclosingInstances[i];
          createField(arg,type,Disposition.THIS_REF);
        }
      }
      if (nestedBinding.outerLocalVariables != null) {
        for (int i=0; i < nestedBinding.outerLocalVariables.length; ++i) {
          SyntheticArgumentBinding arg=nestedBinding.outerLocalVariables[i];
          boolean isReallyThisRef=false;
          if (arg.actualOuterLocalVariable instanceof SyntheticArgumentBinding) {
            SyntheticArgumentBinding outer=(SyntheticArgumentBinding)arg.actualOuterLocalVariable;
            if (outer.matchingField != null) {
              JField field=(JField)typeMap.get(outer.matchingField);
              if (field.isThisRef()) {
                isReallyThisRef=true;
              }
            }
          }
          createField(arg,type,isReallyThisRef ? Disposition.THIS_REF : Disposition.FINAL);
        }
      }
    }
    ReferenceBinding superClassBinding=binding.superclass();
    if (type instanceof JClassType && superClassBinding != null) {
      assert(binding.superclass().isClass() || binding.superclass().isEnum());
      JClassType superClass=(JClassType)getType(superClassBinding);
      ((JClassType)type).setSuperClass(superClass);
    }
    ReferenceBinding[] superInterfaces=binding.superInterfaces();
    for (    ReferenceBinding superInterfaceBinding : superInterfaces) {
      assert(superInterfaceBinding.isInterface());
      JInterfaceType superInterface=(JInterfaceType)getType(superInterfaceBinding);
      type.addImplements(superInterface);
    }
    ReferenceBinding enclosingBinding=binding.enclosingType();
    if (enclosingBinding != null) {
      type.setEnclosingType((JDeclaredType)getType(enclosingBinding));
    }
    if (type instanceof JEnumType) {
      processEnumType(binding,(JEnumType)type);
    }
    return true;
  }
 catch (  VirtualMachineError e) {
    throw e;
  }
catch (  InternalCompilerException ice) {
    ice.addNode(type);
    throw ice;
  }
catch (  Throwable e) {
    throw new InternalCompilerException(type,""String_Node_Str"",e);
  }
}",0.9905488310396284
53874,"/** 
 * Sometimes a variable reference can be to a local or parameter in an an enclosing method. This is a tricky situation to detect. There's no obvious way to tell, but the clue we can get from JDT is that the local's containing method won't be the same as the method we're currently processing. Once we have this clue, we can use getEmulationPath to compute the current class's binding for that field.
 */
private JVariable possiblyReferenceOuterLocal(JVariable variable,Binding binding){
  if (variable instanceof JLocal || variable instanceof JParameter) {
    LocalVariableBinding localBinding=(LocalVariableBinding)binding;
    if (localBinding.declaringScope.methodScope() != currentMethodScope) {
      variable=null;
      VariableBinding[] vars=currentMethodScope.getEmulationPath(localBinding);
      if (vars == null) {
        return null;
      }
      assert(vars.length == 1);
      VariableBinding varBinding=vars[0];
      if (varBinding instanceof SyntheticArgumentBinding) {
        JType type=(JType)typeMap.get(varBinding.type);
        String name=String.valueOf(varBinding.name);
        for (int i=0; i < currentMethod.getParams().size(); ++i) {
          JParameter param=currentMethod.getParams().get(i);
          if (type == param.getType() && name.equals(param.getName())) {
            variable=param;
            break;
          }
        }
      }
      if (variable == null) {
        variable=(JField)typeMap.get(varBinding);
      }
    }
  }
  return variable;
}","/** 
 * Sometimes a variable reference can be to a local or parameter in an an enclosing method. This is a tricky situation to detect. There's no obvious way to tell, but the clue we can get from JDT is that the local's containing method won't be the same as the method we're currently processing. Once we have this clue, we can use getEmulationPath to compute the current class's binding for that field.
 */
private JVariable possiblyReferenceOuterLocal(JVariable variable,Binding binding){
}",0.4944834503510532
53875,"/** 
 * This is slightly different from the normal Java language. Specifically, we explicitly handle synthetic fields that are part of nested/local classes. It boils down to the fact that we really HAVE to assign synthetic arguments to synthetic fields BEFORE calling the superclass constructor (because it might call you back polymorphically). In straight Java that glue code is a semantic error, because a this/super call must be the first statement of your constructor. On the upside, optimizations work the same on our synthetic fields as with any user fields. The order of emulation is: - assign all synthetic fields from synthetic args - call our super constructor emulation method - call our instance initializer emulation method - run user code
 */
void processConstructor(ConstructorDeclaration x){
  JConstructor ctor=(JConstructor)typeMap.get(x.binding);
  try {
    processHasAnnotations(ctor,x.annotations);
    SourceInfo info=ctor.getSourceInfo();
    currentMethod=ctor;
    currentMethodBody=ctor.getBody();
    currentMethodScope=x.scope;
    boolean hasExplicitThis=(x.constructorCall != null) && !x.constructorCall.isSuperAccess();
    JClassType enclosingType=ctor.getEnclosingType();
    JBlock block=currentMethodBody.getBlock();
    currentOuterThisRefParams=Maps.create();
    if (!hasExplicitThis) {
      ReferenceBinding declaringClass=x.binding.declaringClass;
      if (declaringClass instanceof NestedTypeBinding) {
        Iterator<JParameter> paramIt=currentMethod.getParams().iterator();
        NestedTypeBinding nestedBinding=(NestedTypeBinding)declaringClass;
        if (nestedBinding.enclosingInstances != null) {
          for (          SyntheticArgumentBinding arg : nestedBinding.enclosingInstances) {
            JParameter param=paramIt.next();
            if (arg.matchingField != null) {
              JField field=(JField)typeMap.get(arg);
              block.addStmt(JProgram.createAssignmentStmt(info,createVariableRef(info,field),createVariableRef(info,param)));
              currentOuterThisRefParams=Maps.put(currentOuterThisRefParams,field,param);
            }
          }
        }
        paramIt=getSyntheticLocalsIterator();
        if (nestedBinding.outerLocalVariables != null) {
          for (          SyntheticArgumentBinding arg : nestedBinding.outerLocalVariables) {
            JParameter param=paramIt.next();
            JField field=(JField)typeMap.get(arg);
            block.addStmt(JProgram.createAssignmentStmt(info,createVariableRef(info,field),createVariableRef(info,param)));
          }
        }
      }
    }
    if (x.constructorCall != null) {
      JMethodCall superOrThisCall=(JMethodCall)dispatch(""String_Node_Str"",x.constructorCall);
      if (enclosingType.isEnumOrSubclass() != null) {
        JVariableRef enumNameRef=createVariableRef(superOrThisCall.getSourceInfo(),ctor.getParams().get(0));
        superOrThisCall.addArg(0,enumNameRef);
        JVariableRef enumOrdinalRef=createVariableRef(superOrThisCall.getSourceInfo(),ctor.getParams().get(1));
        superOrThisCall.addArg(1,enumOrdinalRef);
      }
      superOrThisCall.setStaticDispatchOnly();
      block.addStmt(superOrThisCall.makeStatement());
    }
    JExpression thisRef=createThisRef(info,enclosingType);
    if (!hasExplicitThis) {
      JMethod initMethod=enclosingType.getMethods().get(1);
      JMethodCall initCall=new JMethodCall(info,thisRef,initMethod);
      block.addStmt(initCall.makeStatement());
    }
    block.addStmts(processStatements(x.statements));
    currentOuterThisRefParams=null;
    currentMethodScope=null;
    currentMethod=null;
  }
 catch (  Throwable e) {
    throw translateException(ctor,e);
  }
}","/** 
 * This is slightly different from the normal Java language. Specifically, we explicitly handle synthetic fields that are part of nested/local classes. It boils down to the fact that we really HAVE to assign synthetic arguments to synthetic fields BEFORE calling the superclass constructor (because it might call you back polymorphically). In straight Java that glue code is a semantic error, because a this/super call must be the first statement of your constructor. On the upside, optimizations work the same on our synthetic fields as with any user fields. The order of emulation is: - assign all synthetic fields from synthetic args - call our super constructor emulation method - call our instance initializer emulation method - run user code
 */
void processConstructor(ConstructorDeclaration x){
  JConstructor ctor=(JConstructor)typeMap.get(x.binding);
  try {
    processHasAnnotations(ctor,x.annotations);
    SourceInfo info=ctor.getSourceInfo();
    currentMethod=ctor;
    currentMethodBody=ctor.getBody();
    currentMethodScope=x.scope;
    boolean hasExplicitThis=(x.constructorCall != null) && !x.constructorCall.isSuperAccess();
    JClassType enclosingType=ctor.getEnclosingType();
    JBlock block=currentMethodBody.getBlock();
    currentOuterThisRefParams=Maps.create();
    ReferenceBinding declaringClass=x.binding.declaringClass;
    if (declaringClass instanceof NestedTypeBinding) {
      Iterator<JParameter> paramIt=currentMethod.getParams().iterator();
      NestedTypeBinding nestedBinding=(NestedTypeBinding)declaringClass;
      if (nestedBinding.enclosingInstances != null) {
        for (        SyntheticArgumentBinding arg : nestedBinding.enclosingInstances) {
          JParameter param=paramIt.next();
          JField field=(JField)typeMap.get(arg);
          if (!hasExplicitThis) {
            block.addStmt(JProgram.createAssignmentStmt(info,createVariableRef(info,field),createVariableRef(info,param)));
          }
          currentOuterThisRefParams=Maps.put(currentOuterThisRefParams,field,param);
        }
      }
      if (!hasExplicitThis) {
        paramIt=getSyntheticLocalsIterator();
        if (nestedBinding.outerLocalVariables != null) {
          for (          SyntheticArgumentBinding arg : nestedBinding.outerLocalVariables) {
            JParameter param=paramIt.next();
            JField field=(JField)typeMap.get(arg);
            block.addStmt(JProgram.createAssignmentStmt(info,createVariableRef(info,field),createVariableRef(info,param)));
          }
        }
      }
    }
    if (x.constructorCall != null) {
      JMethodCall superOrThisCall=(JMethodCall)dispatch(""String_Node_Str"",x.constructorCall);
      if (enclosingType.isEnumOrSubclass() != null) {
        JVariableRef enumNameRef=createVariableRef(superOrThisCall.getSourceInfo(),ctor.getParams().get(0));
        superOrThisCall.addArg(0,enumNameRef);
        JVariableRef enumOrdinalRef=createVariableRef(superOrThisCall.getSourceInfo(),ctor.getParams().get(1));
        superOrThisCall.addArg(1,enumOrdinalRef);
      }
      superOrThisCall.setStaticDispatchOnly();
      block.addStmt(superOrThisCall.makeStatement());
    }
    JExpression thisRef=createThisRef(info,enclosingType);
    if (!hasExplicitThis) {
      JMethod initMethod=enclosingType.getMethods().get(1);
      JMethodCall initCall=new JMethodCall(info,thisRef,initMethod);
      block.addStmt(initCall.makeStatement());
    }
    block.addStmts(processStatements(x.statements));
    currentOuterThisRefParams=null;
    currentMethodScope=null;
    currentMethod=null;
  }
 catch (  Throwable e) {
    throw translateException(ctor,e);
  }
}",0.9758954105951246
53876,"private void fetch(final int start){
  lastFetch=start;
  requestFactory.schoolCalendarRequest().getPeople(start,numRows,filter).fire(new Receiver<List<PersonProxy>>(){
    @Override public void onSuccess(    List<PersonProxy> response){
      int responses=response.size();
      table.setRowData(start,response);
      pager.setPageStart(start);
      if (start == 0 || !table.isRowCountExact()) {
        table.setRowCount(start + responses,responses < numRows);
      }
    }
  }
);
}","private void fetch(final int start){
  lastFetch=start;
  requestFactory.schoolCalendarRequest().getPeople(start,numRows,filter).fire(new Receiver<List<PersonProxy>>(){
    @Override public void onSuccess(    List<PersonProxy> response){
      if (lastFetch != start) {
        return;
      }
      int responses=response.size();
      table.setRowData(start,response);
      pager.setPageStart(start);
      if (start == 0 || !table.isRowCountExact()) {
        table.setRowCount(start + responses,responses < numRows);
      }
    }
  }
);
}",0.9457364341085271
53877,"@Override public void onSuccess(List<PersonProxy> response){
  int responses=response.size();
  table.setRowData(start,response);
  pager.setPageStart(start);
  if (start == 0 || !table.isRowCountExact()) {
    table.setRowCount(start + responses,responses < numRows);
  }
}","@Override public void onSuccess(List<PersonProxy> response){
  if (lastFetch != start) {
    return;
  }
  int responses=response.size();
  table.setRowData(start,response);
  pager.setPageStart(start);
  if (start == 0 || !table.isRowCountExact()) {
    table.setRowCount(start + responses,responses < numRows);
  }
}",0.9256756756756755
53878,"/** 
 * Enable or disable the previous page buttons.
 * @param disabled true to disable, false to enable
 */
private void setPrevPageButtonsDisabled(boolean disabled){
  if (disabled == prevDisabled) {
    return;
  }
  prevDisabled=disabled;
  if (disabled) {
    firstPage.setResource(resources.simplePagerFirstPageDisabled());
    firstPage.getElement().getParentElement().addClassName(style.disabledButton());
    prevPage.setResource(resources.simplePagerPreviousPageDisabled());
    prevPage.getElement().getParentElement().addClassName(style.disabledButton());
  }
 else {
    firstPage.setResource(resources.simplePagerFirstPage());
    firstPage.getElement().getParentElement().removeClassName(style.disabledButton());
    prevPage.setResource(resources.simplePagerPreviousPage());
    prevPage.getElement().getParentElement().removeClassName(style.disabledButton());
  }
}","/** 
 * Enable or disable the previous page buttons.
 * @param disabled true to disable, false to enable
 */
private void setPrevPageButtonsDisabled(boolean disabled){
  firstPage.setDisabled(disabled);
  prevPage.setDisabled(disabled);
}",0.3482142857142857
53879,"/** 
 * Enable or disable the next page buttons.
 * @param disabled true to disable, false to enable
 */
private void setNextPageButtonsDisabled(boolean disabled){
  if (disabled == nextDisabled) {
    return;
  }
  nextDisabled=disabled;
  if (disabled) {
    nextPage.setResource(resources.simplePagerNextPageDisabled());
    nextPage.getElement().getParentElement().addClassName(style.disabledButton());
    if (lastPage != null) {
      lastPage.setResource(resources.simplePagerLastPageDisabled());
      lastPage.getElement().getParentElement().addClassName(style.disabledButton());
    }
  }
 else {
    nextPage.setResource(resources.simplePagerNextPage());
    nextPage.getElement().getParentElement().removeClassName(style.disabledButton());
    if (lastPage != null) {
      lastPage.setResource(resources.simplePagerLastPage());
      lastPage.getElement().getParentElement().removeClassName(style.disabledButton());
    }
  }
}","/** 
 * Enable or disable the next page buttons.
 * @param disabled true to disable, false to enable
 */
private void setNextPageButtonsDisabled(boolean disabled){
  nextPage.setDisabled(disabled);
  if (lastPage != null) {
    lastPage.setDisabled(disabled);
  }
}",0.3966804979253112
53880,"/** 
 * Construct a   {@link SimplePager} with the specified resources.
 * @param location the location of the text relative to the buttons
 * @param resources the {@link Resources} to use
 * @param showFastForwardButton if true, show a fast-forward button thatadvances by a larger increment than a single page
 * @param fastForwardRows the number of rows to jump when fast forwarding
 * @param showLastPageButton if true, show a button to go the the last page
 */
public SimplePager(TextLocation location,Resources resources,boolean showFastForwardButton,final int fastForwardRows,boolean showLastPageButton){
  this.resources=resources;
  this.fastForwardRows=fastForwardRows;
  this.style=resources.simplePagerStyle();
  this.style.ensureInjected();
  firstPage=new Image(resources.simplePagerFirstPage());
  firstPage.addClickHandler(new ClickHandler(){
    public void onClick(    ClickEvent event){
      firstPage();
    }
  }
);
  nextPage=new Image(resources.simplePagerNextPage());
  nextPage.addClickHandler(new ClickHandler(){
    public void onClick(    ClickEvent event){
      nextPage();
    }
  }
);
  prevPage=new Image(resources.simplePagerPreviousPage());
  prevPage.addClickHandler(new ClickHandler(){
    public void onClick(    ClickEvent event){
      previousPage();
    }
  }
);
  if (showLastPageButton) {
    lastPage=new Image(resources.simplePagerLastPage());
    lastPage.addClickHandler(new ClickHandler(){
      public void onClick(      ClickEvent event){
        lastPage();
      }
    }
);
  }
 else {
    lastPage=null;
  }
  if (showFastForwardButton) {
    fastForward=new Image(resources.simplePagerFastForward());
    fastForward.addClickHandler(new ClickHandler(){
      public void onClick(      ClickEvent event){
        setPage(getPage() + getFastForwardPages());
      }
    }
);
  }
 else {
    fastForward=null;
  }
  HorizontalPanel layout=new HorizontalPanel();
  layout.setVerticalAlignment(HasVerticalAlignment.ALIGN_MIDDLE);
  initWidget(layout);
  if (location == TextLocation.RIGHT) {
    layout.add(label);
  }
  layout.add(firstPage);
  layout.add(prevPage);
  if (location == TextLocation.CENTER) {
    layout.add(label);
  }
  layout.add(nextPage);
  if (showFastForwardButton) {
    layout.add(fastForward);
  }
  if (showLastPageButton) {
    layout.add(lastPage);
  }
  if (location == TextLocation.LEFT) {
    layout.add(label);
  }
  firstPage.getElement().getParentElement().addClassName(style.button());
  prevPage.getElement().getParentElement().addClassName(style.button());
  label.getElement().getParentElement().addClassName(style.pageDetails());
  nextPage.getElement().getParentElement().addClassName(style.button());
  if (showFastForwardButton) {
    fastForward.getElement().getParentElement().addClassName(style.button());
  }
  if (showLastPageButton) {
    lastPage.getElement().getParentElement().addClassName(style.button());
  }
  setDisplay(null);
}","/** 
 * Construct a   {@link SimplePager} with the specified resources.
 * @param location the location of the text relative to the buttons
 * @param resources the {@link Resources} to use
 * @param showFastForwardButton if true, show a fast-forward button thatadvances by a larger increment than a single page
 * @param fastForwardRows the number of rows to jump when fast forwarding
 * @param showLastPageButton if true, show a button to go the the last page
 */
public SimplePager(TextLocation location,Resources resources,boolean showFastForwardButton,final int fastForwardRows,boolean showLastPageButton){
  this.resources=resources;
  this.fastForwardRows=fastForwardRows;
  this.style=resources.simplePagerStyle();
  this.style.ensureInjected();
  String disabledStyle=style.disabledButton();
  firstPage=new ImageButton(resources.simplePagerFirstPage(),resources.simplePagerFirstPageDisabled(),disabledStyle);
  firstPage.addClickHandler(new ClickHandler(){
    public void onClick(    ClickEvent event){
      firstPage();
    }
  }
);
  nextPage=new ImageButton(resources.simplePagerNextPage(),resources.simplePagerNextPageDisabled(),disabledStyle);
  nextPage.addClickHandler(new ClickHandler(){
    public void onClick(    ClickEvent event){
      nextPage();
    }
  }
);
  prevPage=new ImageButton(resources.simplePagerPreviousPage(),resources.simplePagerPreviousPageDisabled(),disabledStyle);
  prevPage.addClickHandler(new ClickHandler(){
    public void onClick(    ClickEvent event){
      previousPage();
    }
  }
);
  if (showLastPageButton) {
    lastPage=new ImageButton(resources.simplePagerLastPage(),resources.simplePagerLastPageDisabled(),disabledStyle);
    lastPage.addClickHandler(new ClickHandler(){
      public void onClick(      ClickEvent event){
        lastPage();
      }
    }
);
  }
 else {
    lastPage=null;
  }
  if (showFastForwardButton) {
    fastForward=new ImageButton(resources.simplePagerFastForward(),resources.simplePagerFastForwardDisabled(),disabledStyle);
    fastForward.addClickHandler(new ClickHandler(){
      public void onClick(      ClickEvent event){
        setPage(getPage() + getFastForwardPages());
      }
    }
);
  }
 else {
    fastForward=null;
  }
  HorizontalPanel layout=new HorizontalPanel();
  layout.setVerticalAlignment(HasVerticalAlignment.ALIGN_MIDDLE);
  initWidget(layout);
  if (location == TextLocation.RIGHT) {
    layout.add(label);
  }
  layout.add(firstPage);
  layout.add(prevPage);
  if (location == TextLocation.CENTER) {
    layout.add(label);
  }
  layout.add(nextPage);
  if (showFastForwardButton) {
    layout.add(fastForward);
  }
  if (showLastPageButton) {
    layout.add(lastPage);
  }
  if (location == TextLocation.LEFT) {
    layout.add(label);
  }
  firstPage.getElement().getParentElement().addClassName(style.button());
  prevPage.getElement().getParentElement().addClassName(style.button());
  label.getElement().getParentElement().addClassName(style.pageDetails());
  nextPage.getElement().getParentElement().addClassName(style.button());
  if (showFastForwardButton) {
    fastForward.getElement().getParentElement().addClassName(style.button());
  }
  if (showLastPageButton) {
    lastPage.getElement().getParentElement().addClassName(style.button());
  }
  setDisplay(null);
}",0.9429535593765064
53881,"/** 
 * Check if the previous button is disabled. Visible for testing.
 */
boolean isPreviousButtonDisabled(){
  return prevDisabled;
}","/** 
 * Check if the previous button is disabled. Visible for testing.
 */
boolean isPreviousButtonDisabled(){
  return prevPage.isDisabled();
}",0.967741935483871
53882,"/** 
 * Check if the next button is disabled. Visible for testing.
 */
boolean isNextButtonDisabled(){
  return nextDisabled;
}","/** 
 * Check if the next button is disabled. Visible for testing.
 */
boolean isNextButtonDisabled(){
  return nextPage.isDisabled();
}",0.9657794676806084
53883,"/** 
 * Reset the positions of the scrollable elements.
 * @return true if the size changed, false if not
 */
private boolean resetScrollables(){
  int offsetHeight=parent.getOffsetHeight();
  int offsetWidth=parent.getOffsetWidth();
  int height=offsetHeight + 100;
  int width=offsetWidth + 100;
  expandableInner.getStyle().setHeight(height,Unit.PX);
  expandableInner.getStyle().setWidth(width,Unit.PX);
  expandable.setScrollTop(height);
  expandable.setScrollLeft(width);
  collapsible.setScrollTop(collapsible.getScrollHeight() + 100);
  collapsible.setScrollLeft(collapsible.getScrollWidth() + 100);
  if (lastOffsetHeight != offsetHeight || lastOffsetWidth != offsetWidth) {
    lastOffsetHeight=offsetHeight;
    lastOffsetWidth=offsetWidth;
    return true;
  }
  return false;
}","/** 
 * Reset the positions of the scrollable elements.
 * @return true if the size changed, false if not
 */
private boolean resetScrollables(){
  if (resettingScrollables) {
    return false;
  }
  resettingScrollables=true;
  int offsetHeight=parent.getOffsetHeight();
  int offsetWidth=parent.getOffsetWidth();
  int height=offsetHeight + 100;
  int width=offsetWidth + 100;
  expandableInner.getStyle().setHeight(height,Unit.PX);
  expandableInner.getStyle().setWidth(width,Unit.PX);
  expandable.setScrollTop(height);
  expandable.setScrollLeft(width);
  collapsible.setScrollTop(collapsible.getScrollHeight() + 100);
  collapsible.setScrollLeft(collapsible.getScrollWidth() + 100);
  if (lastOffsetHeight != offsetHeight || lastOffsetWidth != offsetWidth) {
    lastOffsetHeight=offsetHeight;
    lastOffsetWidth=offsetWidth;
    resettingScrollables=false;
    return true;
  }
  resettingScrollables=false;
  return false;
}",0.9170052234474754
53884,"public void onBrowserEvent(Event event){
  if (Event.ONSCROLL == event.getTypeInt()) {
    EventTarget eventTarget=event.getEventTarget();
    if (!Element.is(eventTarget)) {
      return;
    }
    Element target=eventTarget.cast();
    if (target == collapsible || target == expandable) {
      handleResize();
    }
  }
}","public void onBrowserEvent(Event event){
  if (!resettingScrollables && Event.ONSCROLL == event.getTypeInt()) {
    EventTarget eventTarget=event.getEventTarget();
    if (!Element.is(eventTarget)) {
      return;
    }
    Element target=eventTarget.cast();
    if (target == collapsible || target == expandable) {
      handleResize();
    }
  }
}",0.962852897473997
53885,"/** 
 * Run the given proxy through a ProxySerializer and verify that the before-and-after values match.
 */
protected <T extends BaseProxy>T checkSerialization(T proxy){
  AutoBean<T> originalBean=AutoBeanUtils.getAutoBean(proxy);
  SimpleProxyId<T> id=BaseProxyCategory.stableId(originalBean);
  DefaultProxyStore store=new DefaultProxyStore();
  ProxySerializer s=req.getSerializer(store);
  String key=s.serialize(proxy);
  assertNotNull(key);
  store=new DefaultProxyStore(store.encode());
  s=req.getSerializer(store);
  T restored=s.deserialize(id.getProxyClass(),key);
  AutoBean<BaseProxy> restoredBean=AutoBeanUtils.getAutoBean(restored);
  assertNotSame(proxy,restored);
  assertTrue(AutoBeanUtils.deepEquals(originalBean,restoredBean));
  if (proxy instanceof EntityProxy && !id.isEphemeral()) {
    assertEquals(((EntityProxy)proxy).stableId(),((EntityProxy)restored).stableId());
  }
  restoredBean.setTag(Constants.STABLE_ID,originalBean.getTag(Constants.STABLE_ID));
  return restored;
}","/** 
 * Run the given proxy through a ProxySerializer and verify that the before-and-after values match.
 */
protected <T extends BaseProxy>T checkSerialization(T proxy){
  AutoBean<T> originalBean=AutoBeanUtils.getAutoBean(proxy);
  SimpleProxyId<T> id=BaseProxyCategory.stableId(originalBean);
  DefaultProxyStore store=new DefaultProxyStore();
  ProxySerializer s=req.getSerializer(store);
  String key=s.serialize(proxy);
  assertNotNull(key);
  store=new DefaultProxyStore(store.encode());
  s=req.getSerializer(store);
  T restored=s.deserialize(id.getProxyClass(),key);
  AutoBean<? extends BaseProxy> restoredBean=AutoBeanUtils.getAutoBean(restored);
  assertNotSame(proxy,restored);
  assertTrue(AutoBeanUtils.deepEquals(originalBean,restoredBean));
  if (proxy instanceof EntityProxy && !id.isEphemeral()) {
    assertEquals(((EntityProxy)proxy).stableId(),((EntityProxy)restored).stableId());
  }
  restoredBean.setTag(Constants.STABLE_ID,originalBean.getTag(Constants.STABLE_ID));
  return restored;
}",0.9950396825396826
53886,"private void writeEmptyMethod(String mangledMethodName,Method method){
}","private void writeEmptyMethod(String mangledMethodName,Method declMethod){
  MethodVisitor mv=super.visitMethod(Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,mangledMethodName,declMethod.getDescriptor(),null,null);
  mv.visitEnd();
}",0.4717607973421927
53887,"@Override public void visitEnd(){
  if (inSingleJsoImplInterfaceType) {
    for (    Map.Entry<String,List<Method>> entry : toImplement(currentTypeName).entrySet()) {
      for (      Method method : entry.getValue()) {
        writeEmptyMethod(entry.getKey(),method);
      }
    }
  }
  super.visitEnd();
}","@Override public void visitEnd(){
  if (inSingleJsoImplInterfaceType) {
    for (    String mangledName : toImplement(currentTypeName)) {
      for (      Method method : jsoData.getDeclarations(mangledName)) {
        writeEmptyMethod(mangledName,method);
      }
    }
  }
  super.visitEnd();
}",0.5198675496688742
53888,"/** 
 * Given a resource name of a class, find all mangled method names that must be implemented.
 */
private SortedMap<String,List<Method>> toImplement(String typeName){
  String name=typeName.replace('/','_');
  String prefix=name + ""String_Node_Str"";
  String suffix=name + ""String_Node_Str"";
  SortedMap<String,List<Method>> toReturn=new TreeMap<String,List<Method>>();
  for (  String mangledName : jsoData.getMangledNames().subSet(prefix,suffix)) {
    toReturn.put(mangledName,jsoData.getImplementations(mangledName));
  }
  toReturn.keySet().removeAll(implementedMethods);
  return toReturn;
}","/** 
 * Given a resource name of a class, find all mangled method names that must be implemented.
 */
private SortedSet<String> toImplement(String typeName){
  String name=typeName.replace('/','_');
  String prefix=name + ""String_Node_Str"";
  String suffix=name + ""String_Node_Str"";
  SortedSet<String> toReturn=new TreeSet<String>();
  for (  String mangledName : jsoData.getMangledNames().subSet(prefix,suffix)) {
    if (!implementedMethods.contains(mangledName)) {
      toReturn.add(mangledName);
    }
  }
  return toReturn;
}",0.7343336275375111
53889,"/** 
 * For regular Java objects that implement a SingleJsoImpl interface, write instance trampoline dispatchers for mangled method names to the implementing method.
 */
private void writeTrampoline(String stubIntr){
  for (  Map.Entry<String,List<Method>> entry : toImplement(stubIntr).entrySet()) {
    for (    Method method : entry.getValue()) {
      String mangledName=entry.getKey();
      String descriptor=""String_Node_Str"" + method.getDescriptor().substring(1 + method.getArgumentTypes()[0].getDescriptor().length());
      String localName=method.getName().substring(0,method.getName().length() - 1);
      Method toCall=new Method(localName,descriptor);
      MethodVisitor mv=super.visitMethod(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,mangledName,descriptor,null,null);
      if (mv != null) {
        mv.visitCode();
        int var=1;
        int size=1;
        mv.visitVarInsn(Opcodes.ALOAD,0);
        for (        Type t : toCall.getArgumentTypes()) {
          size+=t.getSize();
          mv.visitVarInsn(t.getOpcode(Opcodes.ILOAD),var);
          var+=t.getSize();
        }
        size=Math.max(size,toCall.getReturnType().getSize());
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,currentTypeName,toCall.getName(),toCall.getDescriptor());
        mv.visitInsn(toCall.getReturnType().getOpcode(Opcodes.IRETURN));
        mv.visitMaxs(size,var);
        mv.visitEnd();
      }
    }
  }
}","/** 
 * For regular Java objects that implement a SingleJsoImpl interface, write instance trampoline dispatchers for mangled method names to the implementing method.
 */
private void writeTrampoline(String stubIntr){
  for (  String mangledName : toImplement(stubIntr)) {
    for (    Method method : jsoData.getDeclarations(mangledName)) {
      Method toCall=new Method(method.getName(),method.getDescriptor());
      MethodVisitor mv=super.visitMethod(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,mangledName,method.getDescriptor(),null,null);
      if (mv != null) {
        mv.visitCode();
        int var=1;
        int size=1;
        mv.visitVarInsn(Opcodes.ALOAD,0);
        for (        Type t : toCall.getArgumentTypes()) {
          size+=t.getSize();
          mv.visitVarInsn(t.getOpcode(Opcodes.ILOAD),var);
          var+=t.getSize();
        }
        size=Math.max(size,toCall.getReturnType().getSize());
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,currentTypeName,toCall.getName(),toCall.getDescriptor());
        mv.visitInsn(toCall.getReturnType().getOpcode(Opcodes.IRETURN));
        mv.visitMaxs(size,var);
        mv.visitEnd();
      }
    }
  }
}",0.8247104247104247
53890,"public static PlainJsoWithInterface create(){
  return JavaScriptObject.createArray().cast();
}","static Element create(){
  return (Element)JavaScriptObject.createObject();
}",0.6976744186046512
53891,"public int compareTo(Timestamp o){
  int delta=(int)(getTime() - o.getTime());
  return delta == 0 ? getNanos() - o.getNanos() : delta;
}","public int compareTo(Timestamp o){
  int sign=Long.signum(getTime() - o.getTime());
  return sign == 0 ? getNanos() - o.getNanos() : sign;
}",0.8592057761732852
53892,"public int compareTo(Date other){
  long thisTime=getTime();
  long otherTime=other.getTime();
  if (thisTime < otherTime) {
    return -1;
  }
 else   if (thisTime > otherTime) {
    return 1;
  }
 else {
    return 0;
  }
}","public int compareTo(Date other){
  return Long.signum(getTime() - other.getTime());
}",0.45016077170418
53893,"@Override protected Element getKeyboardSelectedElement(){
  int rowIndex=getKeyboardSelectedRow();
  if (childContainer.getChildCount() > rowIndex) {
    return childContainer.getChild(rowIndex).cast();
  }
  return null;
}","@Override protected Element getKeyboardSelectedElement(){
  int rowIndex=getKeyboardSelectedRow();
  if (rowIndex >= 0 && childContainer.getChildCount() > rowIndex) {
    return childContainer.getChild(rowIndex).cast();
  }
  return null;
}",0.9632829373650108
53894,"@Override protected Element getKeyboardSelectedElement(){
  int rowIndex=getKeyboardSelectedRow();
  NodeList<TableRowElement> rows=tbody.getRows();
  if (rowIndex < rows.getLength() && columns.size() > 0) {
    TableRowElement tr=rows.getItem(rowIndex);
    TableCellElement td=tr.getCells().getItem(keyboardSelectedColumn);
    return getCellParent(td);
  }
  return null;
}","@Override protected Element getKeyboardSelectedElement(){
  int rowIndex=getKeyboardSelectedRow();
  NodeList<TableRowElement> rows=tbody.getRows();
  if (rowIndex >= 0 && rowIndex < rows.getLength() && columns.size() > 0) {
    TableRowElement tr=rows.getItem(rowIndex);
    TableCellElement td=tr.getCells().getItem(keyboardSelectedColumn);
    return getCellParent(td);
  }
  return null;
}",0.9310793237971392
53895,"public Double parse(CharSequence object) throws ParseException {
  if (""String_Node_Str"".equals(object.toString())) {
    return null;
  }
  try {
    return Math.rint(NumberFormat.getDecimalFormat().parse(object.toString()));
  }
 catch (  NumberFormatException e) {
    throw new ParseException(e.getMessage(),0);
  }
}","public Double parse(CharSequence object) throws ParseException {
  if (""String_Node_Str"".equals(object.toString())) {
    return null;
  }
  try {
    return NumberFormat.getDecimalFormat().parse(object.toString());
  }
 catch (  NumberFormatException e) {
    throw new ParseException(e.getMessage(),0);
  }
}",0.98256735340729
53896,"/** 
 * Returns the content of an   {@link HttpServletRequest} by decoding it using<code>expectedCharSet</code>, or <code>UTF-8</code> if <code>expectedCharSet</code> is <code>null</null>.
 * @param request the servlet request whose content we want to read
 * @param expectedContentType the expected content (i.e. 'type/subtype' only)in the Content-Type request header, or <code>null</code> if no validation is to be performed, and you are willing to allow for some types of cross type security attacks
 * @param expectedCharSet the expected request charset, or <code>null</code>if no charset validation is to be performed and <code>UTF-8</code> should be assumed
 * @return the content of an {@link HttpServletRequest} by decoding it using<code>expectedCharSet</code>, or <code>UTF-8</code> if <code>expectedCharSet</code> is <code>null</null>
 * @throws IOException if the request's input stream cannot be accessed, readfrom or closed
 * @throws ServletException if the request's content type does notequal the supplied <code>expectedContentType</code> or <code>expectedCharSet</code>
 */
public static String readContent(HttpServletRequest request,String expectedContentType,String expectedCharSet) throws IOException, ServletException {
  if (expectedContentType != null) {
    checkContentTypeIgnoreCase(request,expectedContentType);
  }
  if (expectedCharSet != null) {
    checkCharacterEncodingIgnoreCase(request,expectedCharSet);
  }
  InputStream in=request.getInputStream();
  byte[] buffer=new byte[BUFFER_SIZE];
  ByteArrayOutputStream out=new ByteArrayOutputStream(BUFFER_SIZE);
  try {
    while (true) {
      int byteCount=in.read(buffer);
      if (byteCount == -1) {
        break;
      }
      out.write(buffer,0,byteCount);
    }
    String contentCharSet=expectedCharSet != null ? expectedCharSet : CHARSET_UTF8;
    return out.toString(contentCharSet);
  }
  finally {
    if (in != null) {
      in.close();
    }
  }
}","/** 
 * Returns the content of an   {@link HttpServletRequest} by decoding it using<code>expectedCharSet</code>, or <code>UTF-8</code> if <code>expectedCharSet</code> is <code>null</null>.
 * @param request the servlet request whose content we want to read
 * @param expectedContentType the expected content (i.e. 'type/subtype' only)in the Content-Type request header, or <code>null</code> if no validation is to be performed, and you are willing to allow for some types of cross type security attacks
 * @param expectedCharSet the expected request charset, or <code>null</code>if no charset validation is to be performed and <code>UTF-8</code> should be assumed
 * @return the content of an {@link HttpServletRequest} by decoding it using<code>expectedCharSet</code>, or <code>UTF-8</code> if <code>expectedCharSet</code> is <code>null</code>
 * @throws IOException if the request's input stream cannot be accessed, readfrom or closed
 * @throws ServletException if the request's content type does notequal the supplied <code>expectedContentType</code> or <code>expectedCharSet</code>
 */
public static String readContent(HttpServletRequest request,String expectedContentType,String expectedCharSet) throws IOException, ServletException {
  if (expectedContentType != null) {
    checkContentTypeIgnoreCase(request,expectedContentType);
  }
  if (expectedCharSet != null) {
    checkCharacterEncodingIgnoreCase(request,expectedCharSet);
  }
  InputStream in=request.getInputStream();
  byte[] buffer=new byte[BUFFER_SIZE];
  ByteArrayOutputStream out=new ByteArrayOutputStream(BUFFER_SIZE);
  try {
    while (true) {
      int byteCount=in.read(buffer);
      if (byteCount == -1) {
        break;
      }
      out.write(buffer,0,byteCount);
    }
    String contentCharSet=expectedCharSet != null ? expectedCharSet : CHARSET_UTF8;
    return out.toString(contentCharSet);
  }
  finally {
    if (in != null) {
      in.close();
    }
  }
}",0.9979423868312756
53897,"private void registerParsers(){
  addElementParser(""String_Node_Str"",""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
}","private void registerParsers(){
  addElementParser(""String_Node_Str"",""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
}",0.97989417989418
53898,"/** 
 * Logs a message.
 * @param logRecordJson a log record in JSON format.
 * @throws RemoteLoggingException if logging fails
 */
public static void logMessage(String logRecordJson) throws RemoteLoggingException {
  String strongName=RequestFactoryServlet.getThreadLocalRequest().getHeader(RpcRequestBuilder.STRONG_NAME_HEADER);
  RemoteLoggingServiceUtil.logOnServer(logRecordJson,strongName,deobfuscator,null);
}","/** 
 * Logs a message.
 * @param serializedLogRecordString a json serialized LogRecord, as provided by{@link com.google.gwt.logging.client.JsonLogRecordClientUtil.logRecordAsJsonObject(LogRecord)}
 * @throws RemoteLoggingException if logging fails
 */
public static void logMessage(String logRecordJson) throws RemoteLoggingException {
  HttpServletRequest threadLocalRequest=RequestFactoryServlet.getThreadLocalRequest();
  String strongName=null;
  if (threadLocalRequest != null) {
    threadLocalRequest.getHeader(RpcRequestBuilder.STRONG_NAME_HEADER);
  }
  RemoteLoggingServiceUtil.logOnServer(logRecordJson,strongName,deobfuscator,null);
}",0.6829727187206021
53899,"/** 
 * Given the binary name of a domain type, return the BaseProxy type that is assignable to   {@code clientType}. This method allows multiple proxy types to be assigned to a domain type for use in different contexts (e.g. API slices). If there are multiple client types mapped to  {@code domainTypeBinaryName} and assignable to {@code clientTypeBinaryName}, the first matching type will be returned.
 */
String getEntityProxyTypeName(String domainTypeBinaryName,String clientTypeBinaryName){
  Type key=Type.getObjectType(BinaryName.toInternalName(domainTypeBinaryName));
  List<Type> found=domainToClientType.get(key);
  if (found == null || found.isEmpty()) {
    return null;
  }
  if (found.size() == 1) {
    return found.get(0).getClassName();
  }
  Type assignableTo=Type.getObjectType(BinaryName.toInternalName(clientTypeBinaryName));
  for (  Type t : found) {
    if (isAssignable(parentLogger,assignableTo,t)) {
      return t.getClassName();
    }
  }
  return null;
}","/** 
 * Given the binary name of a domain type, return the BaseProxy type that is assignable to   {@code clientType}. This method allows multiple proxy types to be assigned to a domain type for use in different contexts (e.g. API slices). If there are multiple client types mapped to  {@code domainTypeBinaryName} and assignable to {@code clientTypeBinaryName}, the first matching type will be returned.
 */
String getEntityProxyTypeName(String domainTypeBinaryName,String clientTypeBinaryName){
  Type key=Type.getObjectType(BinaryName.toInternalName(domainTypeBinaryName));
  List<Type> found=domainToClientType.get(key);
  if (found == null || found.isEmpty()) {
    List<Type> types=getSupertypes(parentLogger,key);
    for (    Type type : types) {
      if (objectType.equals(type)) {
        break;
      }
      found=domainToClientType.get(type);
      if (found != null && !found.isEmpty()) {
        break;
      }
    }
  }
  if (found == null || found.isEmpty()) {
    return null;
  }
  Type typeToReturn=null;
  if (found.size() == 1) {
    typeToReturn=found.get(0);
  }
 else {
    Type assignableTo=Type.getObjectType(BinaryName.toInternalName(clientTypeBinaryName));
    for (    Type t : found) {
      if (isAssignable(parentLogger,assignableTo,t)) {
        typeToReturn=t;
        break;
      }
    }
  }
  return typeToReturn == null ? null : typeToReturn.getClassName();
}",0.7665827036104114
53900,"public List<Type> exec(Type type){
  RequestFactoryInterfaceValidator.this.visit(logger,type.getInternalName(),this);
  return supertypes;
}","public List<Type> exec(Type type){
  RequestFactoryInterfaceValidator.this.visit(logger,type.getInternalName(),this);
  return supers;
}",0.9855072463768116
53901,"/** 
 * Examines a generic RequestContext method declaration and determines the expected domain return type. This implementation is limited in that it will not attempt to resolve type bounds since that would essentially require implementing TypeOracle. In the case where the type bound cannot be resolved, this method will return Object's type.
 */
private Type getReturnType(ErrorContext logger,RFMethod method){
  logger=logger.setMethod(method);
  final String[] returnType={""String_Node_Str""};
  String signature=method.getSignature();
  final int expectedCount;
  if (method.getReturnType().equals(instanceRequestIntf)) {
    expectedCount=2;
  }
 else   if (method.getReturnType().equals(requestIntf)) {
    expectedCount=1;
  }
 else {
    logger.spam(""String_Node_Str"" + signature);
    return Type.getObjectType(returnType[0]);
  }
  new SignatureReader(signature).accept(new SignatureAdapter(){
    @Override public SignatureVisitor visitReturnType(){
      return new SignatureAdapter(){
        int count;
        @Override public SignatureVisitor visitTypeArgument(        char wildcard){
          if (++count == expectedCount) {
            return new SignatureAdapter(){
              @Override public void visitClassType(              String name){
                returnType[0]=name;
              }
            }
;
          }
          return super.visitTypeArgument(wildcard);
        }
      }
;
    }
  }
);
  logger.spam(""String_Node_Str"" + returnType[0]);
  return Type.getObjectType(returnType[0]);
}","/** 
 * Examines a generic RequestContext method declaration and determines the expected domain return type. This implementation is limited in that it will not attempt to resolve type bounds since that would essentially require implementing TypeOracle. In the case where the type bound cannot be resolved, this method will return Object's type.
 */
private Type getReturnType(ErrorContext logger,RFMethod method){
  logger=logger.setMethod(method);
  final String[] returnType={objectType.getInternalName()};
  String signature=method.getSignature();
  final int expectedCount;
  if (method.getReturnType().equals(instanceRequestIntf)) {
    expectedCount=2;
  }
 else   if (method.getReturnType().equals(requestIntf)) {
    expectedCount=1;
  }
 else {
    logger.spam(""String_Node_Str"" + signature);
    return Type.getObjectType(returnType[0]);
  }
  new SignatureReader(signature).accept(new SignatureAdapter(){
    @Override public SignatureVisitor visitReturnType(){
      return new SignatureAdapter(){
        int count;
        @Override public SignatureVisitor visitTypeArgument(        char wildcard){
          if (++count == expectedCount) {
            return new SignatureAdapter(){
              @Override public void visitClassType(              String name){
                returnType[0]=name;
              }
            }
;
          }
          return super.visitTypeArgument(wildcard);
        }
      }
;
    }
  }
);
  logger.spam(""String_Node_Str"" + returnType[0]);
  return Type.getObjectType(returnType[0]);
}",0.9859614756774404
53902,"/** 
 * Returns the current user information for a given redirect URL. If  {@link #setUserInformationImplClass(String)} has been called with a classname, that class is used to gather the information by calling a (String) constructor. If the impl class name is """", or if the class cannont be instantiated, dummy user info is returned.
 * @param redirectUrl the redirect URL as a String
 * @return a {@link UserInformation} instance
 */
public static UserInformation getCurrentUserInformation(String redirectUrl){
  UserInformation userInfo=null;
  if (!""String_Node_Str"".equals(userInformationImplClass)) {
    try {
      userInfo=(UserInformation)Class.forName(userInformationImplClass).getConstructor(String.class).newInstance(redirectUrl);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  if (userInfo == null) {
    userInfo=new UserInformationSimpleImpl(redirectUrl);
  }
  return userInfo;
}","/** 
 * Called by   {@link RequestFactoryServlet#doPost} at the start of each requestreceived. Establishes the current user information for this request, and notes a redirect url to be provided back to the client if the user's bona fides cannot be established. All succeeding calls to {@link #findUserInformation(Long)} made from the same thread will returnthe same UserInfo instance. <p> If  {@link #setUserInformationImplClass(String)} has been called with aclass name, that class is used to gather the information by calling a (String) constructor. If the impl class name is """", or if the class cannont be instantiated, dummy user info is returned.
 * @param redirectUrl the redirect URL as a String
 * @return a {@link UserInformation} instance
 */
public static UserInformation getCurrentUserInformation(String redirectUrl){
  currentUser.remove();
  if (!""String_Node_Str"".equals(userInformationImplClass)) {
    try {
      currentUser.set((UserInformation)Class.forName(userInformationImplClass).getConstructor(String.class).newInstance(redirectUrl));
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  if (currentUser.get() == null) {
    currentUser.set(new UserInformationSimpleImpl(redirectUrl));
  }
  return currentUser.get();
}",0.7017865322950069
53903,"/** 
 * Log a message on the server.
 * @param serializedLogRecordString a String
 * @return a Void {@link Request}
 */
Request<Void> logMessage(String serializedLogRecordString);","/** 
 * Log a message on the server.
 * @param serializedLogRecordString a json serialized LogRecord, as provided by{@link com.google.gwt.logging.client.JsonLogRecordClientUtil.logRecordAsJsonObject(LogRecord)}
 * @return a Void {@link Request}
 */
Request<Void> logMessage(String serializedLogRecordString);",0.6324435318275154
53904,"/** 
 * Commit the current value.
 * @param parent the parent element
 * @param viewData the {@link ViewData} object
 * @param valueUpdater the {@link ValueUpdater}
 */
private void commit(Element parent,ViewData viewData,ValueUpdater<String> valueUpdater){
  String value=updateViewData(parent,viewData,false);
  clearInput(getInputElement(parent));
  setValue(parent,value,viewData);
  valueUpdater.update(value);
}","/** 
 * Commit the current value.
 * @param parent the parent element
 * @param viewData the {@link ViewData} object
 * @param valueUpdater the {@link ValueUpdater}
 */
private void commit(Element parent,ViewData viewData,ValueUpdater<String> valueUpdater){
  String value=updateViewData(parent,viewData,false);
  clearInput(getInputElement(parent));
  setValue(parent,value,viewData);
  if (valueUpdater != null) {
    valueUpdater.update(value);
  }
}",0.9586206896551724
53905,"/** 
 * Navigate to a deeper node.
 */
private void keyboardNavigateDeep(){
  if (isKeyboardSelectionDisabled()) {
    return;
  }
  if (level < treeNodes.size() - 1) {
    TreeNodeImpl<?> treeNode=treeNodes.get(level + 1);
    treeNode.display.getPresenter().setKeyboardSelectedRow(treeNode.display.getKeyboardSelectedRow(),true);
  }
}","/** 
 * Navigate to a deeper node.
 */
private void keyboardNavigateDeep(){
  if (isKeyboardSelectionDisabled()) {
    return;
  }
  if (level < treeNodes.size() - 1) {
    TreeNodeImpl<?> treeNode=treeNodes.get(level + 1);
    treeNode.display.getPresenter().setKeyboardSelectedRow(treeNode.display.getKeyboardSelectedRow(),true,true);
  }
}",0.9926362297496318
53906,"public TreeNode setChildOpen(int index,boolean open,boolean fireEvents){
  assertNotDestroyed();
  checkChildBounds(index);
  if (open) {
    display.getPresenter().setKeyboardSelectedRow(index,false);
    return updateChildState(display,fireEvents);
  }
 else {
    if (index == display.getKeyboardSelectedRow()) {
      display.getPresenter().clearKeyboardSelectedRowValue();
      updateChildState(display,fireEvents);
    }
    return null;
  }
}","public TreeNode setChildOpen(int index,boolean open,boolean fireEvents){
  assertNotDestroyed();
  checkChildBounds(index);
  if (open) {
    display.getPresenter().setKeyboardSelectedRow(index,false,true);
    return updateChildState(display,fireEvents);
  }
 else {
    if (index == display.getKeyboardSelectedRow()) {
      display.getPresenter().clearKeyboardSelectedRowValue();
      updateChildState(display,fireEvents);
    }
    return null;
  }
}",0.994475138121547
53907,"@Override protected void renderRowValues(SafeHtmlBuilder sb,List<T> values,int start,SelectionModel<? super T> selectionModel){
  String keyboardSelectedItem=""String_Node_Str"" + style.cellListKeyboardSelectedItem();
  String selectedItem=""String_Node_Str"" + style.cellListSelectedItem();
  String evenItem=style.cellListEvenItem();
  String oddItem=style.cellListOddItem();
  int keyboardSelectedRow=getKeyboardSelectedRow() + getPageStart();
  int length=values.size();
  int end=start + length;
  for (int i=start; i < end; i++) {
    T value=values.get(i - start);
    boolean isSelected=selectionModel == null ? false : selectionModel.isSelected(value);
    StringBuilder classesBuilder=new StringBuilder();
    classesBuilder.append(i % 2 == 0 ? evenItem : oddItem);
    if (isSelected) {
      classesBuilder.append(selectedItem);
    }
    SafeHtmlBuilder cellBuilder=new SafeHtmlBuilder();
    cell.render(value,null,cellBuilder);
    if (i == keyboardSelectedRow) {
      if (isFocused) {
        classesBuilder.append(keyboardSelectedItem);
      }
      char accessKey=getAccessKey();
      if (accessKey != 0) {
        sb.append(TEMPLATE.divFocusableWithKey(i,classesBuilder.toString(),getTabIndex(),accessKey,cellBuilder.toSafeHtml()));
      }
 else {
        sb.append(TEMPLATE.divFocusable(i,classesBuilder.toString(),getTabIndex(),cellBuilder.toSafeHtml()));
      }
    }
 else {
      sb.append(TEMPLATE.div(i,classesBuilder.toString(),cellBuilder.toSafeHtml()));
    }
  }
}","@Override protected void renderRowValues(SafeHtmlBuilder sb,List<T> values,int start,SelectionModel<? super T> selectionModel){
  String keyboardSelectedItem=""String_Node_Str"" + style.cellListKeyboardSelectedItem();
  String selectedItem=""String_Node_Str"" + style.cellListSelectedItem();
  String evenItem=style.cellListEvenItem();
  String oddItem=style.cellListOddItem();
  int keyboardSelectedRow=getKeyboardSelectedRow() + getPageStart();
  int length=values.size();
  int end=start + length;
  for (int i=start; i < end; i++) {
    T value=values.get(i - start);
    boolean isSelected=selectionModel == null ? false : selectionModel.isSelected(value);
    StringBuilder classesBuilder=new StringBuilder();
    classesBuilder.append(i % 2 == 0 ? evenItem : oddItem);
    if (isSelected) {
      classesBuilder.append(selectedItem);
    }
    SafeHtmlBuilder cellBuilder=new SafeHtmlBuilder();
    cell.render(value,getValueKey(value),cellBuilder);
    if (i == keyboardSelectedRow) {
      if (isFocused) {
        classesBuilder.append(keyboardSelectedItem);
      }
      char accessKey=getAccessKey();
      if (accessKey != 0) {
        sb.append(TEMPLATE.divFocusableWithKey(i,classesBuilder.toString(),getTabIndex(),accessKey,cellBuilder.toSafeHtml()));
      }
 else {
        sb.append(TEMPLATE.divFocusable(i,classesBuilder.toString(),getTabIndex(),cellBuilder.toSafeHtml()));
      }
    }
 else {
      sb.append(TEMPLATE.div(i,classesBuilder.toString(),cellBuilder.toSafeHtml()));
    }
  }
}",0.992676431424767
53908,"@SuppressWarnings(""String_Node_Str"") @Override protected void onBrowserEvent2(Event event){
  EventTarget eventTarget=event.getEventTarget();
  if (!Element.is(eventTarget)) {
    return;
  }
  final Element target=event.getEventTarget().cast();
  String idxString=""String_Node_Str"";
  Element cellTarget=target;
  while ((cellTarget != null) && ((idxString=cellTarget.getAttribute(""String_Node_Str"")).length() == 0)) {
    cellTarget=cellTarget.getParentElement();
  }
  if (idxString.length() > 0) {
    String eventType=event.getType();
    boolean isClick=""String_Node_Str"".equals(eventType);
    int idx=Integer.parseInt(idxString);
    int indexOnPage=idx - getPageStart();
    if (!isRowWithinBounds(indexOnPage)) {
      return;
    }
    boolean isSelectionHandled=cell.handlesSelection() || KeyboardSelectionPolicy.BOUND_TO_SELECTION == getKeyboardSelectionPolicy();
    Element cellParent=getCellParent(cellTarget);
    T value=getVisibleItem(indexOnPage);
    CellPreviewEvent<T> previewEvent=CellPreviewEvent.fire(this,event,this,indexOnPage,value,cellIsEditing,isSelectionHandled);
    if (isClick && !cellIsEditing && !isSelectionHandled) {
      doSelection(event,value,indexOnPage);
    }
    if (isClick && getPresenter().getKeyboardSelectedRowInView() != indexOnPage) {
      boolean isFocusable=CellBasedWidgetImpl.get().isFocusable(target);
      isFocused=isFocused || isFocusable;
      getPresenter().setKeyboardSelectedRow(indexOnPage,!isFocusable);
    }
    if (!previewEvent.isCanceled()) {
      fireEventToCell(event,cellParent,value);
    }
  }
}","@SuppressWarnings(""String_Node_Str"") @Override protected void onBrowserEvent2(Event event){
  EventTarget eventTarget=event.getEventTarget();
  if (!Element.is(eventTarget)) {
    return;
  }
  final Element target=event.getEventTarget().cast();
  String idxString=""String_Node_Str"";
  Element cellTarget=target;
  while ((cellTarget != null) && ((idxString=cellTarget.getAttribute(""String_Node_Str"")).length() == 0)) {
    cellTarget=cellTarget.getParentElement();
  }
  if (idxString.length() > 0) {
    String eventType=event.getType();
    boolean isClick=""String_Node_Str"".equals(eventType);
    int idx=Integer.parseInt(idxString);
    int indexOnPage=idx - getPageStart();
    if (!isRowWithinBounds(indexOnPage)) {
      return;
    }
    boolean isSelectionHandled=cell.handlesSelection() || KeyboardSelectionPolicy.BOUND_TO_SELECTION == getKeyboardSelectionPolicy();
    Element cellParent=getCellParent(cellTarget);
    T value=getVisibleItem(indexOnPage);
    CellPreviewEvent<T> previewEvent=CellPreviewEvent.fire(this,event,this,indexOnPage,value,cellIsEditing,isSelectionHandled);
    if (isClick && !cellIsEditing && !isSelectionHandled) {
      doSelection(event,value,indexOnPage);
    }
    if (isClick) {
      boolean isFocusable=CellBasedWidgetImpl.get().isFocusable(target);
      isFocused=isFocused || isFocusable;
      getPresenter().setKeyboardSelectedRow(indexOnPage,!isFocusable,false);
    }
    if (!previewEvent.isCanceled()) {
      fireEventToCell(event,cellParent,value);
    }
  }
}",0.977390180878553
53909,"@Override protected void setKeyboardSelected(int index,boolean selected,boolean stealFocus){
  if (!isRowWithinBounds(index)) {
    return;
  }
  Element elem=getRowElement(index);
  if (!selected || isFocused || stealFocus) {
    setStyleName(elem,style.cellListKeyboardSelectedItem(),selected);
  }
  setFocusable(elem,selected);
  if (selected && stealFocus) {
    elem.focus();
    onFocus();
  }
}","@Override protected void setKeyboardSelected(int index,boolean selected,boolean stealFocus){
  if (!isRowWithinBounds(index)) {
    return;
  }
  Element elem=getRowElement(index);
  if (!selected || isFocused || stealFocus) {
    setStyleName(elem,style.cellListKeyboardSelectedItem(),selected);
  }
  setFocusable(elem,selected);
  if (selected && stealFocus && !cellIsEditing) {
    elem.focus();
    onFocus();
  }
}",0.978102189781022
53910,"@SuppressWarnings(""String_Node_Str"") @Override protected void onBrowserEvent2(Event event){
  EventTarget eventTarget=event.getEventTarget();
  if (!Element.is(eventTarget)) {
    return;
  }
  final Element target=event.getEventTarget().cast();
  String eventType=event.getType();
  if (""String_Node_Str"".equals(eventType) && !isKeyboardNavigationSuppressed() && KeyboardSelectionPolicy.DISABLED != getKeyboardSelectionPolicy()) {
    if (handleKey(event)) {
      return;
    }
  }
  TableCellElement tableCell=findNearestParentCell(target);
  if (tableCell == null) {
    return;
  }
  Element trElem=tableCell.getParentElement();
  if (trElem == null) {
    return;
  }
  TableRowElement tr=TableRowElement.as(trElem);
  Element sectionElem=tr.getParentElement();
  if (sectionElem == null) {
    return;
  }
  TableSectionElement section=TableSectionElement.as(sectionElem);
  int col=tableCell.getCellIndex();
  if (section == thead) {
    Header<?> header=headers.get(col);
    if (header != null && cellConsumesEventType(header.getCell(),eventType)) {
      header.onBrowserEvent(tableCell,event);
    }
  }
 else   if (section == tfoot) {
    Header<?> footer=footers.get(col);
    if (footer != null && cellConsumesEventType(footer.getCell(),eventType)) {
      footer.onBrowserEvent(tableCell,event);
    }
  }
 else   if (section == tbody) {
    boolean isClick=""String_Node_Str"".equals(eventType);
    int row=tr.getSectionRowIndex();
    if (""String_Node_Str"".equals(eventType)) {
      if (hoveringRow != null && tbody.isOrHasChild(hoveringRow)) {
        setRowStyleName(hoveringRow,style.cellTableHoveredRow(),style.cellTableHoveredRowCell(),false);
      }
      hoveringRow=tr;
      setRowStyleName(hoveringRow,style.cellTableHoveredRow(),style.cellTableHoveredRowCell(),true);
    }
 else     if (""String_Node_Str"".equals(eventType) && hoveringRow != null) {
      setRowStyleName(hoveringRow,style.cellTableHoveredRow(),style.cellTableHoveredRowCell(),false);
      hoveringRow=null;
    }
 else     if (isClick && ((getPresenter().getKeyboardSelectedRowInView() != row) || (keyboardSelectedColumn != col))) {
      boolean isFocusable=CellBasedWidgetImpl.get().isFocusable(target);
      isFocused=isFocused || isFocusable;
      keyboardSelectedColumn=col;
      getPresenter().setKeyboardSelectedRow(row,!isFocusable);
    }
    if (!isRowWithinBounds(row)) {
      return;
    }
    boolean isSelectionHandled=handlesSelection || KeyboardSelectionPolicy.BOUND_TO_SELECTION == getKeyboardSelectionPolicy();
    T value=getVisibleItem(row);
    CellPreviewEvent<T> previewEvent=CellPreviewEvent.fire(this,event,this,row,col,value,cellIsEditing,isSelectionHandled);
    if (isClick && !cellIsEditing && !isSelectionHandled) {
      doSelection(event,value,row,col);
    }
    if (!previewEvent.isCanceled()) {
      fireEventToCell(event,eventType,tableCell,value,row,columns.get(col));
    }
  }
}","@SuppressWarnings(""String_Node_Str"") @Override protected void onBrowserEvent2(Event event){
  EventTarget eventTarget=event.getEventTarget();
  if (!Element.is(eventTarget)) {
    return;
  }
  final Element target=event.getEventTarget().cast();
  String eventType=event.getType();
  if (""String_Node_Str"".equals(eventType) && !isKeyboardNavigationSuppressed() && KeyboardSelectionPolicy.DISABLED != getKeyboardSelectionPolicy()) {
    if (handleKey(event)) {
      return;
    }
  }
  TableCellElement tableCell=findNearestParentCell(target);
  if (tableCell == null) {
    return;
  }
  Element trElem=tableCell.getParentElement();
  if (trElem == null) {
    return;
  }
  TableRowElement tr=TableRowElement.as(trElem);
  Element sectionElem=tr.getParentElement();
  if (sectionElem == null) {
    return;
  }
  TableSectionElement section=TableSectionElement.as(sectionElem);
  int col=tableCell.getCellIndex();
  if (section == thead) {
    Header<?> header=headers.get(col);
    if (header != null && cellConsumesEventType(header.getCell(),eventType)) {
      header.onBrowserEvent(tableCell,event);
    }
  }
 else   if (section == tfoot) {
    Header<?> footer=footers.get(col);
    if (footer != null && cellConsumesEventType(footer.getCell(),eventType)) {
      footer.onBrowserEvent(tableCell,event);
    }
  }
 else   if (section == tbody) {
    boolean isClick=""String_Node_Str"".equals(eventType);
    int row=tr.getSectionRowIndex();
    if (""String_Node_Str"".equals(eventType)) {
      if (hoveringRow != null && tbody.isOrHasChild(hoveringRow)) {
        setRowStyleName(hoveringRow,style.cellTableHoveredRow(),style.cellTableHoveredRowCell(),false);
      }
      hoveringRow=tr;
      setRowStyleName(hoveringRow,style.cellTableHoveredRow(),style.cellTableHoveredRowCell(),true);
    }
 else     if (""String_Node_Str"".equals(eventType) && hoveringRow != null) {
      setRowStyleName(hoveringRow,style.cellTableHoveredRow(),style.cellTableHoveredRowCell(),false);
      hoveringRow=null;
    }
 else     if (isClick && ((getPresenter().getKeyboardSelectedRowInView() != row) || (keyboardSelectedColumn != col))) {
      boolean isFocusable=CellBasedWidgetImpl.get().isFocusable(target);
      isFocused=isFocused || isFocusable;
      keyboardSelectedColumn=col;
      getPresenter().setKeyboardSelectedRow(row,!isFocusable,true);
    }
    if (!isRowWithinBounds(row)) {
      return;
    }
    boolean isSelectionHandled=handlesSelection || KeyboardSelectionPolicy.BOUND_TO_SELECTION == getKeyboardSelectionPolicy();
    T value=getVisibleItem(row);
    CellPreviewEvent<T> previewEvent=CellPreviewEvent.fire(this,event,this,row,col,value,cellIsEditing,isSelectionHandled);
    if (isClick && !cellIsEditing && !isSelectionHandled) {
      doSelection(event,value,row,col);
    }
    if (!previewEvent.isCanceled()) {
      fireEventToCell(event,eventType,tableCell,value,row,columns.get(col));
    }
  }
}",0.9991448606122798
53911,"private boolean handleKey(Event event){
  HasDataPresenter<T> presenter=getPresenter();
  int oldRow=getKeyboardSelectedRow();
  boolean isRtl=LocaleInfo.getCurrentLocale().isRTL();
  int keyCodeLineEnd=isRtl ? KeyCodes.KEY_LEFT : KeyCodes.KEY_RIGHT;
  int keyCodeLineStart=isRtl ? KeyCodes.KEY_RIGHT : KeyCodes.KEY_LEFT;
  int keyCode=event.getKeyCode();
  if (keyCode == keyCodeLineEnd) {
    int nextColumn=findInteractiveColumn(keyboardSelectedColumn,false);
    if (nextColumn <= keyboardSelectedColumn) {
      if (presenter.hasKeyboardNext()) {
        keyboardSelectedColumn=nextColumn;
        presenter.keyboardNext();
        event.preventDefault();
        return true;
      }
    }
 else {
      keyboardSelectedColumn=nextColumn;
      getPresenter().setKeyboardSelectedRow(oldRow,true);
      event.preventDefault();
      return true;
    }
  }
 else   if (keyCode == keyCodeLineStart) {
    int prevColumn=findInteractiveColumn(keyboardSelectedColumn,true);
    if (prevColumn >= keyboardSelectedColumn) {
      if (presenter.hasKeyboardPrev()) {
        keyboardSelectedColumn=prevColumn;
        presenter.keyboardPrev();
        event.preventDefault();
        return true;
      }
    }
 else {
      keyboardSelectedColumn=prevColumn;
      getPresenter().setKeyboardSelectedRow(oldRow,true);
      event.preventDefault();
      return true;
    }
  }
  return false;
}","private boolean handleKey(Event event){
  HasDataPresenter<T> presenter=getPresenter();
  int oldRow=getKeyboardSelectedRow();
  boolean isRtl=LocaleInfo.getCurrentLocale().isRTL();
  int keyCodeLineEnd=isRtl ? KeyCodes.KEY_LEFT : KeyCodes.KEY_RIGHT;
  int keyCodeLineStart=isRtl ? KeyCodes.KEY_RIGHT : KeyCodes.KEY_LEFT;
  int keyCode=event.getKeyCode();
  if (keyCode == keyCodeLineEnd) {
    int nextColumn=findInteractiveColumn(keyboardSelectedColumn,false);
    if (nextColumn <= keyboardSelectedColumn) {
      if (presenter.hasKeyboardNext()) {
        keyboardSelectedColumn=nextColumn;
        presenter.keyboardNext();
        event.preventDefault();
        return true;
      }
    }
 else {
      keyboardSelectedColumn=nextColumn;
      getPresenter().setKeyboardSelectedRow(oldRow,true,true);
      event.preventDefault();
      return true;
    }
  }
 else   if (keyCode == keyCodeLineStart) {
    int prevColumn=findInteractiveColumn(keyboardSelectedColumn,true);
    if (prevColumn >= keyboardSelectedColumn) {
      if (presenter.hasKeyboardPrev()) {
        keyboardSelectedColumn=prevColumn;
        presenter.keyboardPrev();
        event.preventDefault();
        return true;
      }
    }
 else {
      keyboardSelectedColumn=prevColumn;
      getPresenter().setKeyboardSelectedRow(oldRow,true,true);
      event.preventDefault();
      return true;
    }
  }
  return false;
}",0.9964209019327128
53912,"@Override protected void setKeyboardSelected(int index,boolean selected,boolean stealFocus){
  if (KeyboardSelectionPolicy.DISABLED == getKeyboardSelectionPolicy() || !isRowWithinBounds(index) || columns.size() == 0) {
    return;
  }
  TableRowElement tr=getRowElement(index);
  String cellStyle=style.cellTableKeyboardSelectedCell();
  boolean updatedSelection=!selected || isFocused || stealFocus;
  setRowStyleName(tr,style.cellTableKeyboardSelectedRow(),style.cellTableKeyboardSelectedRowCell(),selected);
  NodeList<TableCellElement> cells=tr.getCells();
  for (int i=0; i < cells.getLength(); i++) {
    TableCellElement td=cells.getItem(i);
    setStyleName(td,cellStyle,updatedSelection && selected && i == keyboardSelectedColumn);
    final com.google.gwt.user.client.Element cellParent=getCellParent(td).cast();
    setFocusable(cellParent,selected && i == keyboardSelectedColumn);
  }
  if (selected && stealFocus) {
    TableCellElement td=tr.getCells().getItem(keyboardSelectedColumn);
    final com.google.gwt.user.client.Element cellParent=getCellParent(td).cast();
    CellBasedWidgetImpl.get().resetFocus(new Scheduler.ScheduledCommand(){
      public void execute(){
        cellParent.focus();
      }
    }
);
  }
}","@Override protected void setKeyboardSelected(int index,boolean selected,boolean stealFocus){
  if (KeyboardSelectionPolicy.DISABLED == getKeyboardSelectionPolicy() || !isRowWithinBounds(index) || columns.size() == 0) {
    return;
  }
  TableRowElement tr=getRowElement(index);
  String cellStyle=style.cellTableKeyboardSelectedCell();
  boolean updatedSelection=!selected || isFocused || stealFocus;
  setRowStyleName(tr,style.cellTableKeyboardSelectedRow(),style.cellTableKeyboardSelectedRowCell(),selected);
  NodeList<TableCellElement> cells=tr.getCells();
  for (int i=0; i < cells.getLength(); i++) {
    TableCellElement td=cells.getItem(i);
    setStyleName(td,cellStyle,updatedSelection && selected && i == keyboardSelectedColumn);
    final com.google.gwt.user.client.Element cellParent=getCellParent(td).cast();
    setFocusable(cellParent,selected && i == keyboardSelectedColumn);
  }
  if (selected && stealFocus && !cellIsEditing) {
    TableCellElement td=tr.getCells().getItem(keyboardSelectedColumn);
    final com.google.gwt.user.client.Element cellParent=getCellParent(td).cast();
    CellBasedWidgetImpl.get().resetFocus(new Scheduler.ScheduledCommand(){
      public void execute(){
        cellParent.focus();
      }
    }
);
  }
}",0.9927710843373494
53913,"/** 
 * Select or deselect this node with the keyboard.
 * @param selected true if selected, false if not
 * @param stealFocus true to steal focus
 */
void setKeyboardSelected(boolean selected,boolean stealFocus){
  if (tree.isKeyboardSelectionDisabled()) {
    return;
  }
  if (!selected || tree.isFocused || stealFocus) {
    setKeyboardSelectedStyle(selected);
  }
  Element cellParent=getCellParent();
  if (!selected) {
    cellParent.setTabIndex(-1);
    cellParent.removeAttribute(""String_Node_Str"");
    cellParent.removeAttribute(""String_Node_Str"");
  }
 else {
    FocusImpl focusImpl=FocusImpl.getFocusImplForWidget();
    com.google.gwt.user.client.Element cellElem=cellParent.cast();
    focusImpl.setTabIndex(cellElem,tree.getTabIndex());
    char accessKey=tree.getAccessKey();
    if (accessKey != 0) {
      focusImpl.setAccessKey(cellElem,accessKey);
    }
    if (stealFocus) {
      cellElem.focus();
    }
  }
  if (KeyboardSelectionPolicy.BOUND_TO_SELECTION == tree.getKeyboardSelectionPolicy()) {
    setSelected(selected);
  }
}","/** 
 * Select or deselect this node with the keyboard.
 * @param selected true if selected, false if not
 * @param stealFocus true to steal focus
 */
void setKeyboardSelected(boolean selected,boolean stealFocus){
  if (tree.isKeyboardSelectionDisabled()) {
    return;
  }
  if (!selected || tree.isFocused || stealFocus) {
    setKeyboardSelectedStyle(selected);
  }
  Element cellParent=getCellParent();
  if (!selected) {
    cellParent.setTabIndex(-1);
    cellParent.removeAttribute(""String_Node_Str"");
    cellParent.removeAttribute(""String_Node_Str"");
  }
 else {
    FocusImpl focusImpl=FocusImpl.getFocusImplForWidget();
    com.google.gwt.user.client.Element cellElem=cellParent.cast();
    focusImpl.setTabIndex(cellElem,tree.getTabIndex());
    char accessKey=tree.getAccessKey();
    if (accessKey != 0) {
      focusImpl.setAccessKey(cellElem,accessKey);
    }
    if (stealFocus && !tree.cellIsEditing) {
      cellElem.focus();
    }
  }
  if (KeyboardSelectionPolicy.BOUND_TO_SELECTION == tree.getKeyboardSelectionPolicy()) {
    setSelected(selected);
  }
}",0.9891968060122124
53914,"/** 
 * Move keyboard selection to the absolute 0th row.
 */
public void keyboardHome(){
  if (!keyboardPagingPolicy.isLimitedToRange()) {
    setKeyboardSelectedRow(-getPageStart(),true);
  }
}","/** 
 * Move keyboard selection to the absolute 0th row.
 */
public void keyboardHome(){
  if (!keyboardPagingPolicy.isLimitedToRange()) {
    setKeyboardSelectedRow(-getPageStart(),true,false);
  }
}",0.9847715736040608
53915,"/** 
 * Move keyboard selection to the next row.
 */
public void keyboardNext(){
  if (hasKeyboardNext()) {
    setKeyboardSelectedRow(getKeyboardSelectedRow() + 1,true);
  }
}","/** 
 * Move keyboard selection to the next row.
 */
public void keyboardNext(){
  if (hasKeyboardNext()) {
    setKeyboardSelectedRow(getKeyboardSelectedRow() + 1,true,false);
  }
}",0.9832402234636872
53916,"/** 
 * Move keyboard selection to the last row.
 */
public void keyboardEnd(){
  if (!keyboardPagingPolicy.isLimitedToRange()) {
    setKeyboardSelectedRow(getRowCount() - 1,true);
  }
}","/** 
 * Move keyboard selection to the last row.
 */
public void keyboardEnd(){
  if (!keyboardPagingPolicy.isLimitedToRange()) {
    setKeyboardSelectedRow(getRowCount() - 1,true,false);
  }
}",0.9842105263157894
53917,"/** 
 * Set the row index of the keyboard selected element.
 * @param index the row index
 * @param stealFocus true to steal focus
 */
public void setKeyboardSelectedRow(int index,boolean stealFocus){
  if (KeyboardSelectionPolicy.DISABLED == keyboardSelectionPolicy) {
    return;
  }
  int pageStart=getPageStart();
  int pageSize=getPageSize();
  int rowCount=getRowCount();
  int absIndex=pageStart + index;
  if (absIndex >= rowCount && isRowCountExact()) {
    absIndex=rowCount - 1;
  }
  index=Math.max(0,absIndex) - pageStart;
  if (keyboardPagingPolicy.isLimitedToRange()) {
    index=Math.max(0,Math.min(index,pageSize - 1));
  }
  int newPageStart=pageStart;
  int newPageSize=pageSize;
  PendingState<T> pending=ensurePendingState();
  pending.keyboardSelectedRow=0;
  pending.keyboardSelectedRowValue=null;
  pending.keyboardSelectedRowChanged=true;
  if (index >= 0 && index < pageSize) {
    pending.keyboardSelectedRow=index;
    pending.keyboardSelectedRowValue=index < pending.getRowDataSize() ? ensurePendingState().getRowDataValue(index) : null;
    pending.keyboardStealFocus=stealFocus;
    return;
  }
 else   if (KeyboardPagingPolicy.CHANGE_PAGE == keyboardPagingPolicy) {
    while (index < 0) {
      newPageStart-=pageSize;
      index+=pageSize;
    }
    while (index >= pageSize) {
      newPageStart+=pageSize;
      index-=pageSize;
    }
  }
 else   if (KeyboardPagingPolicy.INCREASE_RANGE == keyboardPagingPolicy) {
    while (index < 0) {
      newPageSize+=PAGE_INCREMENT;
      newPageStart-=PAGE_INCREMENT;
      index+=PAGE_INCREMENT;
    }
    if (newPageStart < 0) {
      index+=newPageStart;
      newPageSize+=newPageStart;
      newPageStart=0;
    }
    while (index >= newPageSize) {
      newPageSize+=PAGE_INCREMENT;
    }
    if (isRowCountExact()) {
      newPageSize=Math.min(newPageSize,rowCount - newPageStart);
      if (index >= rowCount) {
        index=rowCount - 1;
      }
    }
  }
  if (newPageStart != pageStart || newPageSize != pageSize) {
    pending.keyboardSelectedRow=index;
    setVisibleRange(new Range(newPageStart,newPageSize),false,false);
  }
}","/** 
 * Set the row index of the keyboard selected element.
 * @param index the row index
 * @param stealFocus true to steal focus
 * @param forceUpdate force the update even if the row didn't change
 */
public void setKeyboardSelectedRow(int index,boolean stealFocus,boolean forceUpdate){
  if (KeyboardSelectionPolicy.DISABLED == keyboardSelectionPolicy) {
    return;
  }
  if (!forceUpdate && getKeyboardSelectedRow() == index && getKeyboardSelectedRowValue() != null) {
    return;
  }
  int pageStart=getPageStart();
  int pageSize=getPageSize();
  int rowCount=getRowCount();
  int absIndex=pageStart + index;
  if (absIndex >= rowCount && isRowCountExact()) {
    absIndex=rowCount - 1;
  }
  index=Math.max(0,absIndex) - pageStart;
  if (keyboardPagingPolicy.isLimitedToRange()) {
    index=Math.max(0,Math.min(index,pageSize - 1));
  }
  int newPageStart=pageStart;
  int newPageSize=pageSize;
  PendingState<T> pending=ensurePendingState();
  pending.keyboardSelectedRow=0;
  pending.keyboardSelectedRowValue=null;
  pending.keyboardSelectedRowChanged=true;
  if (index >= 0 && index < pageSize) {
    pending.keyboardSelectedRow=index;
    pending.keyboardSelectedRowValue=index < pending.getRowDataSize() ? ensurePendingState().getRowDataValue(index) : null;
    pending.keyboardStealFocus=stealFocus;
    return;
  }
 else   if (KeyboardPagingPolicy.CHANGE_PAGE == keyboardPagingPolicy) {
    while (index < 0) {
      newPageStart-=pageSize;
      index+=pageSize;
    }
    while (index >= pageSize) {
      newPageStart+=pageSize;
      index-=pageSize;
    }
  }
 else   if (KeyboardPagingPolicy.INCREASE_RANGE == keyboardPagingPolicy) {
    while (index < 0) {
      newPageSize+=PAGE_INCREMENT;
      newPageStart-=PAGE_INCREMENT;
      index+=PAGE_INCREMENT;
    }
    if (newPageStart < 0) {
      index+=newPageStart;
      newPageSize+=newPageStart;
      newPageStart=0;
    }
    while (index >= newPageSize) {
      newPageSize+=PAGE_INCREMENT;
    }
    if (isRowCountExact()) {
      newPageSize=Math.min(newPageSize,rowCount - newPageStart);
      if (index >= rowCount) {
        index=rowCount - 1;
      }
    }
  }
  if (newPageStart != pageStart || newPageSize != pageSize) {
    pending.keyboardSelectedRow=index;
    setVisibleRange(new Range(newPageStart,newPageSize),false,false);
  }
}",0.953880764904387
53918,"/** 
 * Move keyboard selection to the previous row.
 */
public void keyboardPrev(){
  if (hasKeyboardPrev()) {
    setKeyboardSelectedRow(getKeyboardSelectedRow() - 1,true);
  }
}","/** 
 * Move keyboard selection to the previous row.
 */
public void keyboardPrev(){
  if (hasKeyboardPrev()) {
    setKeyboardSelectedRow(getKeyboardSelectedRow() - 1,true,false);
  }
}",0.9836065573770492
53919,"/** 
 * Move keyboard selection to the next page.
 */
public void keyboardNextPage(){
  if (KeyboardPagingPolicy.CHANGE_PAGE == keyboardPagingPolicy) {
    setKeyboardSelectedRow(getPageSize(),true);
  }
 else   if (KeyboardPagingPolicy.INCREASE_RANGE == keyboardPagingPolicy) {
    setKeyboardSelectedRow(getKeyboardSelectedRow() + PAGE_INCREMENT,true);
  }
}","/** 
 * Move keyboard selection to the next page.
 */
public void keyboardNextPage(){
  if (KeyboardPagingPolicy.CHANGE_PAGE == keyboardPagingPolicy) {
    setKeyboardSelectedRow(getPageSize(),true,false);
  }
 else   if (KeyboardPagingPolicy.INCREASE_RANGE == keyboardPagingPolicy) {
    setKeyboardSelectedRow(getKeyboardSelectedRow() + PAGE_INCREMENT,true,false);
  }
}",0.9836065573770492
53920,"/** 
 * Move keyboard selection to the previous page.
 */
public void keyboardPrevPage(){
  if (KeyboardPagingPolicy.CHANGE_PAGE == keyboardPagingPolicy) {
    setKeyboardSelectedRow(-getPageSize(),true);
  }
 else   if (KeyboardPagingPolicy.INCREASE_RANGE == keyboardPagingPolicy) {
    setKeyboardSelectedRow(getKeyboardSelectedRow() - PAGE_INCREMENT,true);
  }
}","/** 
 * Move keyboard selection to the previous page.
 */
public void keyboardPrevPage(){
  if (KeyboardPagingPolicy.CHANGE_PAGE == keyboardPagingPolicy) {
    setKeyboardSelectedRow(-getPageSize(),true,false);
  }
 else   if (KeyboardPagingPolicy.INCREASE_RANGE == keyboardPagingPolicy) {
    setKeyboardSelectedRow(getKeyboardSelectedRow() - PAGE_INCREMENT,true,false);
  }
}",0.9838274932614556
53921,"private boolean classImplementsMethod(JClassType cls,JMethod meth){
  while (cls != null) {
    JMethod found=cls.findMethod(meth.getName(),methodParamTypes(meth));
    if ((found != null) && !found.isAbstract()) {
      return true;
    }
    cls=cls.getSuperclass();
  }
  return false;
}","private boolean classImplementsMethod(JClassType cls,JMethod meth){
  while (cls != null) {
    JMethod found=cls.findMethod(meth.getName(),meth.getParameterTypes());
    if ((found != null) && !found.isAbstract()) {
      return true;
    }
    cls=cls.getSuperclass();
  }
  return false;
}",0.9759450171821306
53922,"/** 
 * Updates the list of jsoSingleImpl types from recently-added types.
 */
private void computeSingleJsoImplData(JClassType... newTypes){
  JClassType jsoType=findType(JSO_CLASS);
  if (jsoType == null) {
    return;
  }
  for (  JClassType type : newTypes) {
    if (!jsoType.isAssignableFrom(type)) {
      continue;
    }
    for (    JClassType intf : JClassType.getFlattenedSuperTypeHierarchy(type)) {
      if (intf.isInterface() == null) {
        continue;
      }
      if (intf.getOverridableMethods().length == 0) {
        jsoSingleImpls.put(intf,jsoType);
        continue;
      }
      JClassType previousType=jsoSingleImpls.get(intf);
      if (previousType == null) {
        jsoSingleImpls.put(intf,type);
      }
 else       if (type.isAssignableFrom(previousType)) {
        jsoSingleImpls.put(intf,type);
      }
 else       if (type.isAssignableTo(previousType)) {
      }
 else {
        JClassType impl=findFullyImplementingBase(intf,type,previousType);
        if (impl != null) {
          jsoSingleImpls.put(intf,impl);
        }
 else {
          throw new InternalCompilerException(""String_Node_Str"" + previousType.getName() + ""String_Node_Str""+ intf.getName()+ ""String_Node_Str""+ type.getName()+ ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
    }
  }
}","/** 
 * Updates the list of jsoSingleImpl types from recently-added types.
 */
private void computeSingleJsoImplData(JClassType... newTypes){
  JClassType jsoType=findType(JSO_CLASS);
  if (jsoType == null) {
    return;
  }
  for (  JClassType type : newTypes) {
    if (!jsoType.isAssignableFrom(type)) {
      continue;
    }
    for (    JClassType intf : JClassType.getFlattenedSuperTypeHierarchy(type)) {
      if (intf instanceof JParameterizedType) {
        intf=((JParameterizedType)intf).getBaseType();
      }
      if (intf.isInterface() == null) {
        continue;
      }
      if (intf.getOverridableMethods().length == 0) {
        jsoSingleImpls.put(intf,jsoType);
        continue;
      }
      JClassType previousType=jsoSingleImpls.get(intf);
      if (previousType == null) {
        jsoSingleImpls.put(intf,type);
      }
 else       if (type.isAssignableFrom(previousType)) {
        jsoSingleImpls.put(intf,type);
      }
 else       if (type.isAssignableTo(previousType)) {
      }
 else {
        JClassType impl=findFullyImplementingBase(intf,type,previousType);
        if (impl != null) {
          jsoSingleImpls.put(intf,impl);
        }
 else {
          throw new InternalCompilerException(""String_Node_Str"" + previousType.getName() + ""String_Node_Str""+ intf.getName()+ ""String_Node_Str""+ type.getName()+ ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
    }
  }
}",0.9589951976357592
53923,"public Object getKey(T item){
  return keyProvider == null ? item : keyProvider.getKey(item);
}","public Object getKey(T item){
  return (keyProvider == null || item == null) ? item : keyProvider.getKey(item);
}",0.9134615384615384
53924,"public void setSelected(T object,boolean selected){
  newSelectedObject=object;
  newSelected=selected;
  newSelectedPending=true;
  scheduleSelectionChangeEvent();
}","public void setSelected(T object,boolean selected){
  if (!selected) {
    Object oldKey=newSelectedPending ? getKey(newSelectedObject) : curKey;
    Object newKey=getKey(object);
    if (!equalsOrBothNull(oldKey,newKey)) {
      return;
    }
  }
  newSelectedObject=object;
  newSelected=selected;
  newSelectedPending=true;
  scheduleSelectionChangeEvent();
}",0.6287878787878788
53925,"private void resolveChanges(){
  if (!newSelectedPending) {
    return;
  }
  Object key=(newSelectedObject == null) ? null : getKey(newSelectedObject);
  boolean sameKey=curKey == null ? key == null : curKey.equals(key);
  boolean changed=false;
  if (newSelected) {
    changed=!sameKey;
    curSelection=newSelectedObject;
    curKey=key;
  }
 else   if (sameKey) {
    changed=true;
    curSelection=null;
    curKey=null;
  }
  newSelectedObject=null;
  newSelectedPending=false;
  if (changed) {
    SelectionChangeEvent.fire(this);
  }
}","private void resolveChanges(){
  if (!newSelectedPending) {
    return;
  }
  Object key=getKey(newSelectedObject);
  boolean sameKey=equalsOrBothNull(curKey,key);
  boolean changed=false;
  if (newSelected) {
    changed=!sameKey;
    curSelection=newSelectedObject;
    curKey=key;
  }
 else   if (sameKey) {
    changed=true;
    curSelection=null;
    curKey=null;
  }
  newSelectedObject=null;
  newSelectedPending=false;
  if (changed) {
    SelectionChangeEvent.fire(this);
  }
}",0.8466019417475729
53926,"private void registerParsers(){
  addElementParser(""String_Node_Str"",""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
}","private void registerParsers(){
  addElementParser(""String_Node_Str"",""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
}",0.97989417989418
53927,"public void render(SafeHtmlBuilder sb,List<C> values,int start,SelectionModel<? super C> selectionModel){
  CellTree.Style style=nodeView.tree.getStyle();
  String itemValueStyle=style.cellTreeItemValue();
  String selectedStyle=""String_Node_Str"" + style.cellTreeSelectedItem();
  String itemStyle=style.cellTreeItem();
  String itemImageValueStyle=""String_Node_Str"" + style.cellTreeItemImageValue();
  String openStyle=""String_Node_Str"" + style.cellTreeOpenItem();
  String topStyle=""String_Node_Str"" + style.cellTreeTopItem();
  String topImageValueStyle=""String_Node_Str"" + style.cellTreeTopItemImageValue();
  boolean isRootNode=nodeView.isRootNode();
  SafeHtml openImage=nodeView.tree.getOpenImageHtml(isRootNode);
  SafeHtml closedImage=nodeView.tree.getClosedImageHtml(isRootNode);
  int imageWidth=nodeView.tree.getImageWidth();
  String paddingDirection=LocaleInfo.getCurrentLocale().isRTL() ? ""String_Node_Str"" : ""String_Node_Str"";
  int paddingAmount=imageWidth * nodeView.depth;
  Set<Object> openNodes=new HashSet<Object>();
  int childCount=nodeView.getChildCount();
  int end=start + values.size();
  for (int i=start; i < end && i < childCount; i++) {
    CellTreeNodeView<?> child=nodeView.getChildNode(i);
    if (child.isOpen()) {
      openNodes.add(child.getValueKey());
    }
  }
  ProvidesKey<C> keyProvider=nodeInfo.getProvidesKey();
  TreeViewModel model=nodeView.tree.getTreeViewModel();
  for (  C value : values) {
    Object key=keyProvider.getKey(value);
    boolean isOpen=openNodes.contains(key);
    StringBuilder outerClasses=new StringBuilder(itemStyle);
    if (isOpen) {
      outerClasses.append(openStyle);
    }
    if (isRootNode) {
      outerClasses.append(topStyle);
    }
    if (selectionModel != null && selectionModel.isSelected(value)) {
      outerClasses.append(selectedStyle);
    }
    StringBuilder innerClasses=new StringBuilder(itemStyle);
    innerClasses.append(itemImageValueStyle);
    if (isRootNode) {
      innerClasses.append(topImageValueStyle);
    }
    SafeHtml image;
    if (isOpen) {
      image=openImage;
    }
 else     if (model.isLeaf(value)) {
      image=LEAF_IMAGE;
    }
 else {
      image=closedImage;
    }
    SafeHtmlBuilder cellBuilder=new SafeHtmlBuilder();
    cell.render(value,null,cellBuilder);
    SafeHtml innerDiv=template.innerDiv(paddingDirection,imageWidth,innerClasses.toString(),image,itemValueStyle,cellBuilder.toSafeHtml());
    sb.append(template.outerDiv(paddingDirection,paddingAmount,outerClasses.toString(),innerDiv));
  }
}","public void render(SafeHtmlBuilder sb,List<C> values,int start,SelectionModel<? super C> selectionModel){
  CellTree.Style style=nodeView.tree.getStyle();
  String itemValueStyle=style.cellTreeItemValue();
  String selectedStyle=""String_Node_Str"" + style.cellTreeSelectedItem();
  String itemStyle=style.cellTreeItem();
  String itemImageValueStyle=""String_Node_Str"" + style.cellTreeItemImageValue();
  String openStyle=""String_Node_Str"" + style.cellTreeOpenItem();
  String topStyle=""String_Node_Str"" + style.cellTreeTopItem();
  String topImageValueStyle=""String_Node_Str"" + style.cellTreeTopItemImageValue();
  boolean isRootNode=nodeView.isRootNode();
  SafeHtml openImage=nodeView.tree.getOpenImageHtml(isRootNode);
  SafeHtml closedImage=nodeView.tree.getClosedImageHtml(isRootNode);
  int imageWidth=nodeView.tree.getImageWidth();
  String paddingDirection=LocaleInfo.getCurrentLocale().isRTL() ? ""String_Node_Str"" : ""String_Node_Str"";
  int paddingAmount=imageWidth * nodeView.depth;
  Set<Object> openNodes=new HashSet<Object>();
  int childCount=nodeView.getChildCount();
  int end=start + values.size();
  for (int i=start; i < end && i < childCount; i++) {
    CellTreeNodeView<?> child=nodeView.getChildNode(i);
    if (child.isOpen()) {
      openNodes.add(child.getValueKey());
    }
  }
  ProvidesKey<C> keyProvider=nodeInfo.getProvidesKey();
  TreeViewModel model=nodeView.tree.getTreeViewModel();
  for (  C value : values) {
    Object key=keyProvider.getKey(value);
    boolean isOpen=openNodes.contains(key);
    StringBuilder outerClasses=new StringBuilder(itemStyle);
    if (isOpen) {
      outerClasses.append(openStyle);
    }
    if (isRootNode) {
      outerClasses.append(topStyle);
    }
    if (selectionModel != null && selectionModel.isSelected(value)) {
      outerClasses.append(selectedStyle);
    }
    StringBuilder innerClasses=new StringBuilder(itemStyle);
    innerClasses.append(itemImageValueStyle);
    if (isRootNode) {
      innerClasses.append(topImageValueStyle);
    }
    SafeHtml image;
    if (isOpen) {
      image=openImage;
    }
 else     if (model.isLeaf(value)) {
      image=LEAF_IMAGE;
    }
 else {
      image=closedImage;
    }
    SafeHtmlBuilder cellBuilder=new SafeHtmlBuilder();
    cell.render(value,key,cellBuilder);
    SafeHtml innerDiv=template.innerDiv(paddingDirection,imageWidth,innerClasses.toString(),image,itemValueStyle,cellBuilder.toSafeHtml());
    sb.append(template.outerDiv(paddingDirection,paddingAmount,outerClasses.toString(),innerDiv));
  }
}",0.9986168741355465
53928,"public <T>NodeInfo<?> getNodeInfo(T value){
  if (value == ROOT_VALUE) {
    return new DefaultNodeInfo<String>(rootDataProvider,cell);
  }
 else   if (value instanceof String) {
    String prefix=(String)value;
    if (prefix.length() > 3) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    return new DefaultNodeInfo<String>(createDataProvider(prefix),cell);
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}","public NodeInfo<?> getNodeInfo(Object value){
  ProvidesKey<String> keyProvider=new ProvidesKey<String>(){
    public Object getKey(    String item){
      return Integer.parseInt(item.substring(0,1));
    }
  }
;
  ListDataProvider<String> dataProvider=new ListDataProvider<String>(keyProvider);
  dataProvider.getList().add(""String_Node_Str"");
  dataProvider.getList().add(""String_Node_Str"");
  dataProvider.getList().add(""String_Node_Str"");
  return new DefaultNodeInfo<String>(dataProvider,cell);
}",0.1588983050847457
53929,"public boolean isLeaf(Object value){
  if (value == ROOT_VALUE) {
    return false;
  }
 else   if (value instanceof String) {
    String s=(String)value;
    if (s.length() > 4) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    return ((String)value).length() == 4;
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}","public boolean isLeaf(Object value){
  return value != null;
}",0.291970802919708
53930,"public static StringBuffer injectResources(StringBuffer selectionScript,ArtifactSet artifacts){
  int startPos=selectionScript.indexOf(""String_Node_Str"");
  if (startPos != -1) {
    for (    StylesheetReference resource : artifacts.find(StylesheetReference.class)) {
      String text=generateStylesheetInjector(resource.getSrc());
      selectionScript.insert(startPos,text);
      startPos+=text.length();
    }
  }
  startPos=selectionScript.indexOf(""String_Node_Str"");
  if (startPos != -1) {
    for (    ScriptReference resource : artifacts.find(ScriptReference.class)) {
      String text=generateScriptInjector(resource.getSrc());
      selectionScript.insert(startPos,text);
      startPos+=text.length();
    }
  }
  return selectionScript;
}","/** 
 * Installs stylesheets and scripts
 */
public static StringBuffer injectResources(StringBuffer selectionScript,ArtifactSet artifacts){
  int startPos=selectionScript.indexOf(""String_Node_Str"");
  if (startPos != -1) {
    for (    StylesheetReference resource : artifacts.find(StylesheetReference.class)) {
      String text=generateStylesheetInjector(resource.getSrc());
      selectionScript.insert(startPos,text);
      startPos+=text.length();
    }
  }
  startPos=selectionScript.indexOf(""String_Node_Str"");
  if (startPos != -1) {
    for (    ScriptReference resource : artifacts.find(ScriptReference.class)) {
      String text=generateScriptInjector(resource.getSrc());
      selectionScript.insert(startPos,text);
      startPos+=text.length();
    }
  }
  return selectionScript;
}",0.9709864603481624
53931,"/** 
 * Generate the primary fragment. The default implementation is based on  {@link #getModulePrefix(TreeLogger,LinkerContext,String,int)} and{@link #getModuleSuffix(TreeLogger,LinkerContext)}.
 */
protected byte[] generatePrimaryFragment(TreeLogger logger,LinkerContext context,CompilationResult result,String[] js) throws UnableToCompleteException {
  TextOutput to=new DefaultTextOutput(context.isOutputCompact());
  to.print(generatePrimaryFragmentString(logger,context,result.getStrongName(),js[0],js.length));
  return Util.getBytes(to.toString());
}","/** 
 * Generate the primary fragment. The default implementation is based on  {@link #getModulePrefix(TreeLogger,LinkerContext,String,int)} and{@link #getModuleSuffix(TreeLogger,LinkerContext)}.
 */
protected byte[] generatePrimaryFragment(TreeLogger logger,LinkerContext context,CompilationResult result,String[] js,ArtifactSet artifacts) throws UnableToCompleteException {
  TextOutput to=new DefaultTextOutput(context.isOutputCompact());
  to.print(generatePrimaryFragmentString(logger,context,result.getStrongName(),js[0],js.length,artifacts));
  return Util.getBytes(to.toString());
}",0.9721254355400696
53932,"protected String generatePrimaryFragmentString(TreeLogger logger,LinkerContext context,String strongName,String js,int length) throws UnableToCompleteException {
  StringBuffer b=new StringBuffer();
  b.append(getModulePrefix(logger,context,strongName,length));
  b.append(js);
  b.append(getModuleSuffix(logger,context));
  return wrapPrimaryFragment(logger,context,b.toString());
}","protected String generatePrimaryFragmentString(TreeLogger logger,LinkerContext context,String strongName,String js,int length,ArtifactSet artifacts) throws UnableToCompleteException {
  StringBuffer b=new StringBuffer();
  b.append(getModulePrefix(logger,context,strongName,length));
  b.append(js);
  b.append(getModuleSuffix(logger,context));
  return wrapPrimaryFragment(logger,context,b.toString(),artifacts);
}",0.9598997493734336
53933,"@Override public ArtifactSet link(TreeLogger logger,LinkerContext context,ArtifactSet artifacts,boolean onePermutation) throws UnableToCompleteException {
  if (onePermutation) {
    ArtifactSet toReturn=new ArtifactSet(artifacts);
    for (    CompilationResult compilation : toReturn.find(CompilationResult.class)) {
      toReturn.addAll(doEmitCompilation(logger,context,compilation));
    }
    return toReturn;
  }
 else {
    permutationsUtil.setupPermutationsMap(artifacts);
    ArtifactSet toReturn=new ArtifactSet(artifacts);
    EmittedArtifact art=emitSelectionScript(logger,context,artifacts);
    if (art != null) {
      toReturn.add(art);
    }
    maybeOutputPropertyMap(logger,context,toReturn);
    maybeAddHostedModeFile(logger,context,toReturn);
    return toReturn;
  }
}","@Override public ArtifactSet link(TreeLogger logger,LinkerContext context,ArtifactSet artifacts,boolean onePermutation) throws UnableToCompleteException {
  if (onePermutation) {
    ArtifactSet toReturn=new ArtifactSet(artifacts);
    for (    CompilationResult compilation : toReturn.find(CompilationResult.class)) {
      toReturn.addAll(doEmitCompilation(logger,context,compilation,artifacts));
    }
    return toReturn;
  }
 else {
    permutationsUtil.setupPermutationsMap(artifacts);
    ArtifactSet toReturn=new ArtifactSet(artifacts);
    EmittedArtifact art=emitSelectionScript(logger,context,artifacts);
    if (art != null) {
      toReturn.add(art);
    }
    maybeOutputPropertyMap(logger,context,toReturn);
    maybeAddHostedModeFile(logger,context,toReturn);
    return toReturn;
  }
}",0.9937264742785444
53934,"protected String wrapPrimaryFragment(TreeLogger logger,LinkerContext context,String script){
  return script;
}","protected String wrapPrimaryFragment(TreeLogger logger,LinkerContext context,String script,ArtifactSet artifacts){
  return script;
}",0.9098360655737704
53935,"protected Collection<Artifact<?>> doEmitCompilation(TreeLogger logger,LinkerContext context,CompilationResult result) throws UnableToCompleteException {
  String[] js=result.getJavaScript();
  byte[][] bytes=new byte[js.length][];
  bytes[0]=generatePrimaryFragment(logger,context,result,js);
  for (int i=1; i < js.length; i++) {
    bytes[i]=Util.getBytes(generateDeferredFragment(logger,context,i,js[i]));
  }
  Collection<Artifact<?>> toReturn=new ArrayList<Artifact<?>>();
  toReturn.add(emitBytes(logger,bytes[0],result.getStrongName() + getCompilationExtension(logger,context)));
  for (int i=1; i < js.length; i++) {
    toReturn.add(emitBytes(logger,bytes[i],FRAGMENT_SUBDIR + File.separator + result.getStrongName()+ File.separator+ i+ FRAGMENT_EXTENSION));
  }
  toReturn.addAll(emitSelectionInformation(result.getStrongName(),result));
  return toReturn;
}","protected Collection<Artifact<?>> doEmitCompilation(TreeLogger logger,LinkerContext context,CompilationResult result,ArtifactSet artifacts) throws UnableToCompleteException {
  String[] js=result.getJavaScript();
  byte[][] bytes=new byte[js.length][];
  bytes[0]=generatePrimaryFragment(logger,context,result,js,artifacts);
  for (int i=1; i < js.length; i++) {
    bytes[i]=Util.getBytes(generateDeferredFragment(logger,context,i,js[i]));
  }
  Collection<Artifact<?>> toReturn=new ArrayList<Artifact<?>>();
  toReturn.add(emitBytes(logger,bytes[0],result.getStrongName() + getCompilationExtension(logger,context)));
  for (int i=1; i < js.length; i++) {
    toReturn.add(emitBytes(logger,bytes[i],FRAGMENT_SUBDIR + File.separator + result.getStrongName()+ File.separator+ i+ FRAGMENT_EXTENSION));
  }
  toReturn.addAll(emitSelectionInformation(result.getStrongName(),result));
  return toReturn;
}",0.9819004524886876
53936,"@Override protected String wrapPrimaryFragment(TreeLogger logger,LinkerContext context,String script){
  StringBuffer out=new StringBuffer();
  if (shouldIncludeBootstrapInPrimaryFragment(context)) {
    try {
      out.append(generateSelectionScript(logger,context,null));
    }
 catch (    UnableToCompleteException e) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
      e.printStackTrace();
    }
  }
  if (shouldInstallCode(context)) {
    out.append(context.getModuleFunctionName());
    out.append(""String_Node_Str"");
    out.append(JsToStringGenerationVisitor.javaScriptString(script.toString()));
    out.append(""String_Node_Str"");
  }
 else {
    out.append(script.toString());
  }
  return out.toString();
}","@Override protected String wrapPrimaryFragment(TreeLogger logger,LinkerContext context,String script,ArtifactSet artifacts){
  StringBuffer out=new StringBuffer();
  if (shouldIncludeBootstrapInPrimaryFragment(context)) {
    try {
      out.append(generateSelectionScript(logger,context,artifacts));
    }
 catch (    UnableToCompleteException e) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
      e.printStackTrace();
    }
  }
  if (shouldInstallCode(context)) {
    out.append(context.getModuleFunctionName());
    out.append(""String_Node_Str"");
    out.append(JsToStringGenerationVisitor.javaScriptString(script.toString()));
    out.append(""String_Node_Str"");
  }
 else {
    out.append(script.toString());
  }
  return out.toString();
}",0.9764309764309764
53937,"@Override protected void maybeAddHostedModeFile(TreeLogger logger,LinkerContext context,ArtifactSet artifacts) throws UnableToCompleteException {
  String filename=getHostedFilename();
  if (""String_Node_Str"".equals(filename)) {
    return;
  }
  long lastModified=System.currentTimeMillis();
  StringBuffer buffer=readFileToStringBuffer(""String_Node_Str"" + filename,logger);
  String script=generatePrimaryFragmentString(logger,context,""String_Node_Str"",buffer.toString(),1);
  EmittedArtifact devArtifact=emitString(logger,script,filename,lastModified);
  artifacts.add(devArtifact);
}","@Override protected void maybeAddHostedModeFile(TreeLogger logger,LinkerContext context,ArtifactSet artifacts) throws UnableToCompleteException {
  String filename=getHostedFilename();
  if (""String_Node_Str"".equals(filename)) {
    return;
  }
  long lastModified=System.currentTimeMillis();
  StringBuffer buffer=readFileToStringBuffer(""String_Node_Str"" + filename,logger);
  String script=generatePrimaryFragmentString(logger,context,""String_Node_Str"",buffer.toString(),1,artifacts);
  EmittedArtifact devArtifact=emitString(logger,script,filename,lastModified);
  artifacts.add(devArtifact);
}",0.991554054054054
53938,"@Override protected byte[] generatePrimaryFragment(TreeLogger logger,LinkerContext context,CompilationResult result,String[] js) throws UnableToCompleteException {
  StringBuffer b=new StringBuffer();
  b.append(getModulePrefix(logger,context,result.getStrongName(),js.length));
  b.append(splitPrimaryJavaScript(result.getStatementRanges()[0],js[0],charsPerChunk(context,logger)));
  b.append(getModuleSuffix(logger,context));
  return Util.getBytes(b.toString());
}","@Override protected byte[] generatePrimaryFragment(TreeLogger logger,LinkerContext context,CompilationResult result,String[] js,ArtifactSet artifacts) throws UnableToCompleteException {
  StringBuffer b=new StringBuffer();
  b.append(getModulePrefix(logger,context,result.getStrongName(),js.length));
  b.append(splitPrimaryJavaScript(result.getStatementRanges()[0],js[0],charsPerChunk(context,logger)));
  b.append(getModuleSuffix(logger,context));
  return Util.getBytes(b.toString());
}",0.9769874476987448
53939,"@Override protected Collection<Artifact<?>> doEmitCompilation(TreeLogger logger,LinkerContext context,CompilationResult result) throws UnableToCompleteException {
  if (result.getJavaScript().length != 1) {
    logger.branch(TreeLogger.ERROR,""String_Node_Str"" + getDescription() + ""String_Node_Str"",null);
    throw new UnableToCompleteException();
  }
  return super.doEmitCompilation(logger,context,result);
}","@Override protected Collection<Artifact<?>> doEmitCompilation(TreeLogger logger,LinkerContext context,CompilationResult result,ArtifactSet artifacts) throws UnableToCompleteException {
  if (result.getJavaScript().length != 1) {
    logger.branch(TreeLogger.ERROR,""String_Node_Str"" + getDescription() + ""String_Node_Str"",null);
    throw new UnableToCompleteException();
  }
  return super.doEmitCompilation(logger,context,result,artifacts);
}",0.9625292740046838
53940,"private PersonEditorWorkflow(DynaTableRequestFactory requestFactory,FavoritesManager manager,PersonProxy person){
  this.requestFactory=requestFactory;
  this.manager=manager;
  this.person=person;
  personEditor=new PersonEditor(requestFactory);
  Binder.BINDER.createAndBindUi(this);
  contents.addDomHandler(new KeyUpHandler(){
    public void onKeyUp(    KeyUpEvent event){
      if (event.getNativeKeyCode() == KeyCodes.KEY_ESCAPE) {
        onCancel(null);
      }
    }
  }
,KeyUpEvent.getType());
}","private PersonEditorWorkflow(DynaTableRequestFactory requestFactory,FavoritesManager manager,PersonProxy person){
  this.requestFactory=requestFactory;
  this.manager=manager;
  this.person=person;
  personEditor=new PersonEditor(requestFactory);
  Binder.BINDER.createAndBindUi(this);
  contents.addDomHandler(new KeyUpHandler(){
    public void onKeyUp(    KeyUpEvent event){
      if (event.getNativeKeyCode() == KeyCodes.KEY_ESCAPE) {
        onCancel(null);
      }
    }
  }
,KeyUpEvent.getType());
  this.favorite.setVisible(false);
}",0.9665711556829036
53941,"/** 
 * Construct and display the UI that will be used to edit the current PersonProxy, using the given RequestContext to accumulate the edits.
 */
private void edit(RequestContext requestContext){
  editorDriver=GWT.create(Driver.class);
  editorDriver.initialize(requestFactory,personEditor);
  if (requestContext == null) {
    fetchAndEdit();
    return;
  }
  editorDriver.edit(person,requestContext);
  personEditor.focus();
  favorite.setValue(manager.isFavorite(person),false);
  dialog.center();
}","/** 
 * Construct and display the UI that will be used to edit the current PersonProxy, using the given RequestContext to accumulate the edits.
 */
private void edit(RequestContext requestContext){
  editorDriver=GWT.create(Driver.class);
  editorDriver.initialize(requestFactory,personEditor);
  if (requestContext == null) {
    this.favorite.setVisible(true);
    fetchAndEdit();
    return;
  }
  editorDriver.edit(person,requestContext);
  personEditor.focus();
  favorite.setValue(manager.isFavorite(person),false);
  dialog.center();
}",0.965648854961832
53942,"/** 
 * Set the open state of a tree node.
 * @param cellList the CellList that changed state.
 * @param value the value to open
 * @param open true to open, false to close
 * @param fireEvents true to fireEvents
 * @return the open {@link TreeNode}, or null if not opened
 */
private <C>TreeNode setChildState(BrowserCellList<C> cellList,C value,boolean open,boolean fireEvents,boolean redraw){
  Object newKey=cellList.getValueKey(value);
  if (open) {
    if (newKey == null) {
      return null;
    }
 else     if (newKey.equals(cellList.focusedKey)) {
      return cellList.isFocusedOpen ? treeNodes.get(cellList.level + 1) : null;
    }
    if (cellList.focusedKey != null) {
      setChildState(cellList,cellList.focusedValue,false,fireEvents,false);
    }
    cellList.focusedValue=value;
    cellList.focusedKey=cellList.getValueKey(value);
    NodeInfo<?> childNodeInfo=isLeaf(value) ? null : getNodeInfo(value);
    if (childNodeInfo != null) {
      cellList.isFocusedOpen=true;
      appendTreeNode(childNodeInfo,value);
    }
 else {
      cellList.isFocusedOpen=false;
    }
    if (redraw) {
      treeNodes.get(cellList.level).display.redraw();
    }
    if (cellList.isFocusedOpen) {
      TreeNodeImpl<?> node=treeNodes.get(cellList.level + 1);
      if (fireEvents) {
        OpenEvent.fire(this,node);
      }
      return node.isDestroyed() ? null : node;
    }
    return null;
  }
 else {
    if (cellList.focusedKey == null || !cellList.focusedKey.equals(newKey)) {
      return null;
    }
    TreeNode closedNode=cellList.isFocusedOpen ? treeNodes.get(cellList.level + 1) : null;
    trimToLevel(cellList.level);
    cellList.focusedKey=null;
    cellList.focusedValue=null;
    cellList.isFocusedOpen=false;
    if (redraw) {
      treeNodes.get(cellList.level).display.redraw();
    }
    if (fireEvents && closedNode != null) {
      CloseEvent.fire(this,closedNode);
    }
  }
  return null;
}","/** 
 * Set the open state of a tree node.
 * @param cellList the CellList that changed state.
 * @param value the value to open
 * @param open true to open, false to close
 * @param fireEvents true to fireEvents
 * @return the open {@link TreeNode}, or null if not opened
 */
private <C>TreeNode setChildState(BrowserCellList<C> cellList,C value,boolean open,boolean fireEvents,boolean redraw){
  Object newKey=cellList.getValueKey(value);
  if (open) {
    if (newKey == null) {
      return null;
    }
 else     if (newKey.equals(cellList.focusedKey)) {
      return cellList.isFocusedOpen ? treeNodes.get(cellList.level + 1) : null;
    }
    if (cellList.focusedKey != null) {
      setChildState(cellList,cellList.focusedValue,false,fireEvents,false);
    }
    cellList.focusedValue=value;
    cellList.focusedKey=cellList.getValueKey(value);
    NodeInfo<?> childNodeInfo=isLeaf(value) ? null : getNodeInfo(value);
    if (childNodeInfo != null) {
      cellList.isFocusedOpen=true;
      appendTreeNode(childNodeInfo,value);
    }
 else {
      cellList.isFocusedOpen=false;
    }
    if (redraw) {
      treeNodes.get(cellList.level).display.redraw();
    }
    if (cellList.isFocusedOpen) {
      TreeNodeImpl<?> node=treeNodes.get(cellList.level + 1);
      if (fireEvents) {
        OpenEvent.fire(this,node);
      }
      return node.isDestroyed() ? null : node;
    }
    return null;
  }
 else {
    if (cellList.focusedKey == null || !cellList.focusedKey.equals(newKey)) {
      return null;
    }
    TreeNode closedNode=(cellList.isFocusedOpen && (treeNodes.size() > cellList.level + 1)) ? treeNodes.get(cellList.level + 1) : null;
    trimToLevel(cellList.level);
    if (redraw) {
      treeNodes.get(cellList.level).display.redraw();
    }
    if (fireEvents && closedNode != null) {
      CloseEvent.fire(this,closedNode);
    }
  }
  return null;
}",0.962884969728876
53943,"/** 
 * Reduce the number of   {@link HasData}s down to the specified level.
 * @param level the level to trim to
 */
private void trimToLevel(int level){
  adjustScrollLock();
  int curLevel=treeNodes.size() - 1;
  while (curLevel > level) {
    TreeNodeImpl<?> removed=treeNodes.remove(curLevel);
    removed.destroy();
    curLevel--;
  }
}","/** 
 * Reduce the number of   {@link HasData}s down to the specified level.
 * @param level the level to trim to
 */
private void trimToLevel(int level){
  adjustScrollLock();
  int curLevel=treeNodes.size() - 1;
  while (curLevel > level) {
    TreeNodeImpl<?> removed=treeNodes.remove(curLevel);
    removed.destroy();
    curLevel--;
  }
  if (level < treeNodes.size()) {
    TreeNodeImpl<?> node=treeNodes.get(level);
    node.display.focusedKey=null;
    node.display.focusedValue=null;
    node.display.isFocusedOpen=false;
  }
}",0.7804323094425484
53944,"/** 
 * Test that a tree node is destroyed if its associated data is lost when new data is provided to the node.
 */
public void testTreeNodeDataLost(){
  MockOpenHandler openHandler=new MockOpenHandler();
  MockCloseHandler closeHandler=new MockCloseHandler();
  tree.addOpenHandler(openHandler);
  tree.addCloseHandler(closeHandler);
  TreeNode root=tree.getRootTreeNode();
  TreeNode b=root.setChildOpen(1,true);
  assertEquals(b,openHandler.getLastEventAndClear().getTarget());
  List<String> list=new ArrayList<String>();
  list.add(""String_Node_Str"");
  list.add(""String_Node_Str"");
  list.add(""String_Node_Str"");
  model.rootDataProvider.setList(list);
  assertTrue(b.isDestroyed());
}","/** 
 * Test that a tree node is destroyed if its associated data is lost when new data is provided to the node.
 */
public void testTreeNodeDataLost(){
  MockOpenHandler openHandler=new MockOpenHandler();
  MockCloseHandler closeHandler=new MockCloseHandler();
  tree.addOpenHandler(openHandler);
  tree.addCloseHandler(closeHandler);
  TreeNode root=tree.getRootTreeNode();
  TreeNode b=root.setChildOpen(1,true);
  assertEquals(b,openHandler.getLastEventAndClear().getTarget());
  List<String> list=new ArrayList<String>();
  list.add(""String_Node_Str"");
  list.add(""String_Node_Str"");
  list.add(""String_Node_Str"");
  model.rootDataProvider.setList(list);
  assertTrue(b.isDestroyed());
  assertNotNull(root.setChildOpen(0,true));
}",0.969187675070028
53945,"private void createHeadersAndFooters(){
  if (headersStale) {
    headersStale=false;
    createHeaders(false);
    createHeaders(true);
  }
}","private void createHeadersAndFooters(){
  createHeaders(false);
  createHeaders(true);
}",0.7652173913043478
53946,"/** 
 * Render the header or footer.
 * @param isFooter true if this is the footer table, false if the header table
 */
private void createHeaders(boolean isFooter){
  List<Header<?>> theHeaders=isFooter ? footers : headers;
  TableSectionElement section=isFooter ? tfoot : thead;
  String className=isFooter ? style.cellTableFooter() : style.cellTableHeader();
  boolean hasHeader=false;
  SafeHtmlBuilder sb=new SafeHtmlBuilder();
  sb.appendHtmlConstant(""String_Node_Str"");
  int columnCount=columns.size();
  int curColumn=0;
  for (  Header<?> header : theHeaders) {
    StringBuilder classesBuilder=new StringBuilder(className);
    if (curColumn == 0) {
      classesBuilder.append(""String_Node_Str"");
      classesBuilder.append(isFooter ? style.cellTableFirstColumnFooter() : style.cellTableFirstColumnHeader());
    }
    if (curColumn == columnCount - 1) {
      classesBuilder.append(""String_Node_Str"");
      classesBuilder.append(isFooter ? style.cellTableLastColumnFooter() : style.cellTableLastColumnHeader());
    }
    SafeHtmlBuilder headerBuilder=new SafeHtmlBuilder();
    if (header != null) {
      hasHeader=true;
      header.render(headerBuilder);
    }
    sb.append(template.th(classesBuilder.toString(),headerBuilder.toSafeHtml()));
    curColumn++;
  }
  sb.appendHtmlConstant(""String_Node_Str"");
  TABLE_IMPL.replaceAllRows(this,section,sb.toSafeHtml());
  setVisible(section,hasHeader);
}","/** 
 * Render the header or footer.
 * @param isFooter true if this is the footer table, false if the header table
 */
private void createHeaders(boolean isFooter){
  List<Header<?>> theHeaders=isFooter ? footers : headers;
  TableSectionElement section=isFooter ? tfoot : thead;
  String className=isFooter ? style.cellTableFooter() : style.cellTableHeader();
  boolean hasHeader=false;
  SafeHtmlBuilder sb=new SafeHtmlBuilder();
  sb.appendHtmlConstant(""String_Node_Str"");
  int columnCount=columns.size();
  if (columnCount > 0) {
    Header<?> prevHeader=theHeaders.get(0);
    int prevColspan=1;
    StringBuilder classesBuilder=new StringBuilder(className);
    classesBuilder.append(""String_Node_Str"");
    classesBuilder.append(isFooter ? style.cellTableFirstColumnFooter() : style.cellTableFirstColumnHeader());
    for (int curColumn=1; curColumn < columnCount; curColumn++) {
      Header<?> header=theHeaders.get(curColumn);
      if (header != prevHeader) {
        SafeHtmlBuilder headerBuilder=new SafeHtmlBuilder();
        if (prevHeader != null) {
          hasHeader=true;
          prevHeader.render(headerBuilder);
        }
        sb.append(template.th(prevColspan,classesBuilder.toString(),headerBuilder.toSafeHtml()));
        prevHeader=header;
        prevColspan=1;
        classesBuilder=new StringBuilder(className);
      }
 else {
        prevColspan++;
      }
    }
    SafeHtmlBuilder headerBuilder=new SafeHtmlBuilder();
    if (prevHeader != null) {
      hasHeader=true;
      prevHeader.render(headerBuilder);
    }
    classesBuilder.append(""String_Node_Str"");
    classesBuilder.append(isFooter ? style.cellTableLastColumnFooter() : style.cellTableLastColumnHeader());
    sb.append(template.th(prevColspan,classesBuilder.toString(),headerBuilder.toSafeHtml()));
  }
  sb.appendHtmlConstant(""String_Node_Str"");
  TABLE_IMPL.replaceAllRows(this,section,sb.toSafeHtml());
  setVisible(section,hasHeader);
}",0.6765666765666766
53947,"/** 
 * Remove a column.
 * @param index the column index
 */
public void removeColumn(int index){
  if (index < 0 || index >= columns.size()) {
    throw new IndexOutOfBoundsException(""String_Node_Str"");
  }
  columns.remove(index);
  headers.remove(index);
  footers.remove(index);
  updateDependsOnSelection();
  headersStale=true;
  if (index <= keyboardSelectedColumn) {
    keyboardSelectedColumn=0;
    if (isInteractive) {
      for (int i=0; i < columns.size(); i++) {
        if (isColumnInteractive(columns.get(i))) {
          keyboardSelectedColumn=i;
          break;
        }
      }
    }
  }
  scheduleRedraw();
}","/** 
 * Remove a column.
 * @param index the column index
 */
public void removeColumn(int index){
  if (index < 0 || index >= columns.size()) {
    throw new IndexOutOfBoundsException(""String_Node_Str"");
  }
  columns.remove(index);
  headers.remove(index);
  footers.remove(index);
  updateDependsOnSelection();
  if (index <= keyboardSelectedColumn) {
    keyboardSelectedColumn=0;
    if (isInteractive) {
      for (int i=0; i < columns.size(); i++) {
        if (isColumnInteractive(columns.get(i))) {
          keyboardSelectedColumn=i;
          break;
        }
      }
    }
  }
  scheduleRedraw();
}",0.983078162771958
53948,"@Template(""String_Node_Str"") SafeHtml th(String classes,SafeHtml contents);","@Template(""String_Node_Str"") SafeHtml th(int colspan,String classes,SafeHtml contents);",0.925925925925926
53949,"/** 
 * Constructs a new DatePickerCell that uses the given date/time format and  {@link SafeHtmlRenderer}.
 */
public DatePickerCell(DateTimeFormat format,SafeHtmlRenderer<String> renderer){
  super(""String_Node_Str"",""String_Node_Str"");
  if (format == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (renderer == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.format=format;
  this.renderer=renderer;
  this.datePicker=new DatePicker();
  this.panel=new PopupPanel(true,true){
    @Override protected void onPreviewNativeEvent(    NativePreviewEvent event){
      if (Event.ONKEYUP == event.getTypeInt()) {
        if (event.getNativeEvent().getKeyCode() == ESCAPE) {
          panel.hide();
        }
      }
    }
  }
;
  panel.addCloseHandler(new CloseHandler<PopupPanel>(){
    public void onClose(    CloseEvent<PopupPanel> event){
      lastKey=null;
      lastValue=null;
      if (lastParent != null && !event.isAutoClosed()) {
        lastParent.focus();
      }
      lastParent=null;
    }
  }
);
  panel.add(datePicker);
  datePicker.addValueChangeHandler(new ValueChangeHandler<Date>(){
    public void onValueChange(    ValueChangeEvent<Date> event){
      panel.hide();
      Date date=event.getValue();
      setViewData(lastKey,date);
      setValue(lastParent,lastValue,lastKey);
      if (valueUpdater != null) {
        valueUpdater.update(date);
      }
    }
  }
);
}","/** 
 * Constructs a new DatePickerCell that uses the given date/time format and  {@link SafeHtmlRenderer}.
 */
public DatePickerCell(DateTimeFormat format,SafeHtmlRenderer<String> renderer){
  super(""String_Node_Str"",""String_Node_Str"");
  if (format == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (renderer == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.format=format;
  this.renderer=renderer;
  this.datePicker=new DatePicker();
  this.panel=new PopupPanel(true,true){
    @Override protected void onPreviewNativeEvent(    NativePreviewEvent event){
      if (Event.ONKEYUP == event.getTypeInt()) {
        if (event.getNativeEvent().getKeyCode() == ESCAPE) {
          panel.hide();
        }
      }
    }
  }
;
  panel.addCloseHandler(new CloseHandler<PopupPanel>(){
    public void onClose(    CloseEvent<PopupPanel> event){
      lastKey=null;
      lastValue=null;
      if (lastParent != null && !event.isAutoClosed()) {
        lastParent.focus();
      }
      lastParent=null;
    }
  }
);
  panel.add(datePicker);
  datePicker.addValueChangeHandler(new ValueChangeHandler<Date>(){
    public void onValueChange(    ValueChangeEvent<Date> event){
      Element cellParent=lastParent;
      Date oldValue=lastValue;
      Object key=lastKey;
      panel.hide();
      Date date=event.getValue();
      setViewData(key,date);
      setValue(cellParent,oldValue,key);
      if (valueUpdater != null) {
        valueUpdater.update(date);
      }
    }
  }
);
}",0.959463986599665
53950,"public void onValueChange(ValueChangeEvent<Date> event){
  panel.hide();
  Date date=event.getValue();
  setViewData(lastKey,date);
  setValue(lastParent,lastValue,lastKey);
  if (valueUpdater != null) {
    valueUpdater.update(date);
  }
}","public void onValueChange(ValueChangeEvent<Date> event){
  Element cellParent=lastParent;
  Date oldValue=lastValue;
  Object key=lastKey;
  panel.hide();
  Date date=event.getValue();
  setViewData(key,date);
  setValue(cellParent,oldValue,key);
  if (valueUpdater != null) {
    valueUpdater.update(date);
  }
}",0.8028933092224232
53951,"/** 
 * Create the shim instance of the AutoBean's peer type that lets us hijack the method calls. Using a shim type, as opposed to making the AutoBean implement the peer type directly, means that there can't be any conflicts between methods in the peer type and methods declared in the AutoBean implementation.
 */
private void writeShim(SourceWriter sw,AutoBeanType type) throws UnableToCompleteException {
  sw.println(""String_Node_Str"",type.getPeerType().getQualifiedSourceName());
  sw.indent();
  for (  AutoBeanMethod method : type.getMethods()) {
    JMethod jmethod=method.getMethod();
    String methodName=jmethod.getName();
    JParameter[] parameters=jmethod.getParameters();
    if (isObjectMethodImplementedByShim(jmethod)) {
      continue;
    }
    StringBuilder arguments=new StringBuilder();
{
      for (      JParameter param : parameters) {
        arguments.append(""String_Node_Str"").append(param.getName());
      }
      if (arguments.length() > 0) {
        arguments=arguments.deleteCharAt(0);
      }
    }
    sw.println(""String_Node_Str"",getBaseMethodDeclaration(jmethod));
    sw.indent();
    sw.println(""String_Node_Str"",type.getSimpleSourceName());
switch (method.getAction()) {
case GET:
      sw.println(""String_Node_Str"",AutoBeanFactoryModel.ensureBaseType(jmethod.getReturnType()).getQualifiedSourceName(),methodName,type.getSimpleSourceName());
    writeReturnWrapper(sw,type,method);
  sw.println(""String_Node_Str"");
break;
case SET:
sw.println(""String_Node_Str"",type.getSimpleSourceName());
sw.println(""String_Node_Str"",type.getSimpleSourceName(),methodName,parameters[0].getName());
sw.println(""String_Node_Str"",type.getSimpleSourceName(),methodName,parameters[0].getName());
break;
case CALL:
if (JPrimitiveType.VOID.equals(jmethod.getReturnType())) {
sw.println(""String_Node_Str"",type.getSimpleSourceName(),methodName,arguments);
sw.println(""String_Node_Str"",type.getSimpleSourceName(),methodName,arguments.length() > 0 ? ""String_Node_Str"" : ""String_Node_Str"",arguments);
}
 else {
sw.println(""String_Node_Str"",AutoBeanFactoryModel.ensureBaseType(jmethod.getReturnType()).getQualifiedSourceName(),type.getSimpleSourceName(),methodName,arguments);
writeReturnWrapper(sw,type,method);
sw.println(""String_Node_Str"",type.getSimpleSourceName(),methodName,arguments.length() > 0 ? ""String_Node_Str"" : ""String_Node_Str"",arguments);
sw.println(""String_Node_Str"");
}
break;
default :
throw new RuntimeException();
}
sw.outdent();
sw.println(""String_Node_Str"");
}
sw.println(""String_Node_Str"");
sw.indentln(""String_Node_Str"");
sw.println(""String_Node_Str"");
sw.println(""String_Node_Str"");
sw.indentln(""String_Node_Str"");
sw.println(""String_Node_Str"");
sw.println(""String_Node_Str"");
sw.indentln(""String_Node_Str"");
sw.println(""String_Node_Str"");
sw.outdent();
sw.println(""String_Node_Str"");
}","/** 
 * Create the shim instance of the AutoBean's peer type that lets us hijack the method calls. Using a shim type, as opposed to making the AutoBean implement the peer type directly, means that there can't be any conflicts between methods in the peer type and methods declared in the AutoBean implementation.
 */
private void writeShim(SourceWriter sw,AutoBeanType type) throws UnableToCompleteException {
  sw.println(""String_Node_Str"",type.getPeerType().getQualifiedSourceName());
  sw.indent();
  for (  AutoBeanMethod method : type.getMethods()) {
    JMethod jmethod=method.getMethod();
    String methodName=jmethod.getName();
    JParameter[] parameters=jmethod.getParameters();
    if (isObjectMethodImplementedByShim(jmethod)) {
      continue;
    }
    StringBuilder arguments=new StringBuilder();
{
      for (      JParameter param : parameters) {
        arguments.append(""String_Node_Str"").append(param.getName());
      }
      if (arguments.length() > 0) {
        arguments=arguments.deleteCharAt(0);
      }
    }
    sw.println(""String_Node_Str"",getBaseMethodDeclaration(jmethod));
    sw.indent();
    sw.println(""String_Node_Str"",type.getSimpleSourceName());
switch (method.getAction()) {
case GET:
      sw.println(""String_Node_Str"",ModelUtils.getQualifiedBaseName(jmethod.getReturnType()),methodName,type.getSimpleSourceName());
    writeReturnWrapper(sw,type,method);
  sw.println(""String_Node_Str"");
break;
case SET:
sw.println(""String_Node_Str"",type.getSimpleSourceName());
sw.println(""String_Node_Str"",type.getSimpleSourceName(),methodName,parameters[0].getName());
sw.println(""String_Node_Str"",type.getSimpleSourceName(),methodName,parameters[0].getName());
break;
case CALL:
if (JPrimitiveType.VOID.equals(jmethod.getReturnType())) {
sw.println(""String_Node_Str"",type.getSimpleSourceName(),methodName,arguments);
sw.println(""String_Node_Str"",type.getSimpleSourceName(),methodName,arguments.length() > 0 ? ""String_Node_Str"" : ""String_Node_Str"",arguments);
}
 else {
sw.println(""String_Node_Str"",ModelUtils.ensureBaseType(jmethod.getReturnType()).getQualifiedSourceName(),type.getSimpleSourceName(),methodName,arguments);
writeReturnWrapper(sw,type,method);
sw.println(""String_Node_Str"",type.getSimpleSourceName(),methodName,arguments.length() > 0 ? ""String_Node_Str"" : ""String_Node_Str"",arguments);
sw.println(""String_Node_Str"");
}
break;
default :
throw new RuntimeException();
}
sw.outdent();
sw.println(""String_Node_Str"");
}
sw.println(""String_Node_Str"");
sw.indentln(""String_Node_Str"");
sw.println(""String_Node_Str"");
sw.println(""String_Node_Str"");
sw.indentln(""String_Node_Str"");
sw.println(""String_Node_Str"");
sw.println(""String_Node_Str"");
sw.indentln(""String_Node_Str"");
sw.println(""String_Node_Str"");
sw.outdent();
sw.println(""String_Node_Str"");
}",0.973820124666073
53952,"/** 
 * For interfaces that consist of nothing more than getters and setters, create a map-based implementation that will allow the AutoBean's internal state to be easily consumed.
 */
private void writeCreateSimpleBean(SourceWriter sw,AutoBeanType type){
  sw.println(""String_Node_Str"",type.getPeerType().getQualifiedSourceName());
  sw.indent();
  sw.println(""String_Node_Str"",type.getPeerType().getQualifiedSourceName());
  sw.indent();
  for (  AutoBeanMethod method : type.getMethods()) {
    JMethod jmethod=method.getMethod();
    sw.println(""String_Node_Str"",getBaseMethodDeclaration(jmethod));
    sw.indent();
switch (method.getAction()) {
case GET:
{
        JPrimitiveType primitive=jmethod.getReturnType().isPrimitive();
        if (primitive != null) {
          sw.println(""String_Node_Str"",method.getPropertyName());
          sw.println(""String_Node_Str"");
          sw.indentln(""String_Node_Str"",primitive.getUninitializedFieldExpression());
          sw.println(""String_Node_Str"");
          sw.indentln(""String_Node_Str"",primitive.getQualifiedBoxedSourceName());
          sw.println(""String_Node_Str"");
        }
 else {
          sw.println(""String_Node_Str"",AutoBeanFactoryModel.ensureBaseType(jmethod.getReturnType()).getQualifiedSourceName(),method.getPropertyName());
        }
      }
    break;
case SET:
  sw.println(""String_Node_Str"",method.getPropertyName(),jmethod.getParameters()[0].getName());
break;
case CALL:
JMethod staticImpl=method.getStaticImpl();
if (!jmethod.getReturnType().equals(JPrimitiveType.VOID)) {
sw.print(""String_Node_Str"");
}
sw.print(""String_Node_Str"",staticImpl.getEnclosingType().getQualifiedSourceName(),staticImpl.getName(),type.getSimpleSourceName());
for (JParameter param : jmethod.getParameters()) {
sw.print(""String_Node_Str"",param.getName());
}
sw.println(""String_Node_Str"");
break;
default :
throw new RuntimeException();
}
sw.outdent();
sw.println(""String_Node_Str"");
}
sw.outdent();
sw.println(""String_Node_Str"");
sw.outdent();
sw.println(""String_Node_Str"");
}","/** 
 * For interfaces that consist of nothing more than getters and setters, create a map-based implementation that will allow the AutoBean's internal state to be easily consumed.
 */
private void writeCreateSimpleBean(SourceWriter sw,AutoBeanType type){
  sw.println(""String_Node_Str"",type.getPeerType().getQualifiedSourceName());
  sw.indent();
  sw.println(""String_Node_Str"",type.getPeerType().getQualifiedSourceName());
  sw.indent();
  for (  AutoBeanMethod method : type.getMethods()) {
    JMethod jmethod=method.getMethod();
    sw.println(""String_Node_Str"",getBaseMethodDeclaration(jmethod));
    sw.indent();
switch (method.getAction()) {
case GET:
{
        JPrimitiveType primitive=jmethod.getReturnType().isPrimitive();
        if (primitive != null) {
          sw.println(""String_Node_Str"",method.getPropertyName());
          sw.println(""String_Node_Str"");
          sw.indentln(""String_Node_Str"",primitive.getUninitializedFieldExpression());
          sw.println(""String_Node_Str"");
          sw.indentln(""String_Node_Str"",primitive.getQualifiedBoxedSourceName());
          sw.println(""String_Node_Str"");
        }
 else {
          sw.println(""String_Node_Str"",ModelUtils.getQualifiedBaseName(jmethod.getReturnType()),method.getPropertyName());
        }
      }
    break;
case SET:
  sw.println(""String_Node_Str"",method.getPropertyName(),jmethod.getParameters()[0].getName());
break;
case CALL:
JMethod staticImpl=method.getStaticImpl();
if (!jmethod.getReturnType().equals(JPrimitiveType.VOID)) {
sw.print(""String_Node_Str"");
}
sw.print(""String_Node_Str"",staticImpl.getEnclosingType().getQualifiedSourceName(),staticImpl.getName(),type.getSimpleSourceName());
for (JParameter param : jmethod.getParameters()) {
sw.print(""String_Node_Str"",param.getName());
}
sw.println(""String_Node_Str"");
break;
default :
throw new RuntimeException();
}
sw.outdent();
sw.println(""String_Node_Str"");
}
sw.outdent();
sw.println(""String_Node_Str"");
sw.outdent();
sw.println(""String_Node_Str"");
}",0.9684628755897692
53953,"private AutoBeanType getAutoBeanType(JClassType beanType){
  beanType=ensureBaseType(beanType);
  AutoBeanType toReturn=peers.get(beanType);
  if (toReturn == null) {
    AutoBeanType.Builder builder=new AutoBeanType.Builder();
    builder.setPeerType(beanType);
    builder.setMethods(computeMethods(beanType));
    builder.setInterceptor(findInterceptor(beanType));
    if (noWrapTypes != null) {
      for (      JClassType noWrap : noWrapTypes) {
        if (noWrap.isAssignableFrom(beanType)) {
          builder.setNoWrap(true);
          break;
        }
      }
    }
    toReturn=builder.build();
    peers.put(beanType,toReturn);
  }
  return toReturn;
}","private AutoBeanType getAutoBeanType(JClassType beanType){
  beanType=ModelUtils.ensureBaseType(beanType);
  AutoBeanType toReturn=peers.get(beanType);
  if (toReturn == null) {
    AutoBeanType.Builder builder=new AutoBeanType.Builder();
    builder.setPeerType(beanType);
    builder.setMethods(computeMethods(beanType));
    builder.setInterceptor(findInterceptor(beanType));
    if (noWrapTypes != null) {
      for (      JClassType noWrap : noWrapTypes) {
        if (noWrap.isAssignableFrom(beanType)) {
          builder.setNoWrap(true);
          break;
        }
      }
    }
    toReturn=builder.build();
    peers.put(beanType,toReturn);
  }
  return toReturn;
}",0.9917849141150112
53954,"private boolean methodAcceptsAutoBeanAsFirstParam(JClassType beanType,JMethod method){
  JParameter[] params=method.getParameters();
  if (params.length == 0) {
    return false;
  }
  JClassType paramAsClass=params[0].getType().isClassOrInterface();
  if (paramAsClass == null) {
    return false;
  }
  JParameterizedType expectedFirst=oracle.getParameterizedType(autoBeanInterface,new JClassType[]{ensureBaseType(beanType)});
  return expectedFirst.isAssignableTo(paramAsClass);
}","private boolean methodAcceptsAutoBeanAsFirstParam(JClassType beanType,JMethod method){
  JParameter[] params=method.getParameters();
  if (params.length == 0) {
    return false;
  }
  JClassType paramAsClass=params[0].getType().isClassOrInterface();
  if (paramAsClass == null) {
    return false;
  }
  JParameterizedType expectedFirst=oracle.getParameterizedType(autoBeanInterface,new JClassType[]{ModelUtils.ensureBaseType(beanType)});
  return expectedFirst.isAssignableTo(paramAsClass);
}",0.9887410440122824
53955,"public AutoBeanType getPeer(JClassType beanType){
  beanType=ensureBaseType(beanType);
  return peers.get(beanType);
}","public AutoBeanType getPeer(JClassType beanType){
  beanType=ModelUtils.ensureBaseType(beanType);
  return peers.get(beanType);
}",0.9554655870445344
53956,"private void writeContextImplementations(){
  for (  ContextMethod method : model.getMethods()) {
    PrintWriter pw=context.tryCreate(logger,method.getPackageName(),method.getSimpleSourceName());
    if (pw == null) {
      continue;
    }
    ClassSourceFileComposerFactory factory=new ClassSourceFileComposerFactory(method.getPackageName(),method.getSimpleSourceName());
    factory.setSuperclass(AbstractRequestContext.class.getCanonicalName());
    factory.addImplementedInterface(method.getImplementedInterfaceQualifiedSourceName());
    SourceWriter sw=factory.createSourceWriter(context,pw);
    sw.println(""String_Node_Str"",method.getSimpleSourceName(),AbstractRequestFactory.class.getCanonicalName());
    for (    RequestMethod request : method.getRequestMethods()) {
      JMethod jmethod=request.getDeclarationMethod();
      String operation=jmethod.getEnclosingType().getQualifiedBinaryName() + ""String_Node_Str"" + jmethod.getName();
      StringBuilder parameterArray=new StringBuilder();
      StringBuilder parameterDeclaration=new StringBuilder();
      if (request.isInstance()) {
        parameterArray.append(""String_Node_Str"");
      }
      for (      JParameter param : jmethod.getParameters()) {
        parameterArray.append(""String_Node_Str"").append(param.getName());
        parameterDeclaration.append(""String_Node_Str"").append(param.getType().getParameterizedQualifiedSourceName()).append(""String_Node_Str"").append(param.getName());
      }
      if (parameterArray.length() > 0) {
        parameterArray.deleteCharAt(0);
      }
      if (parameterDeclaration.length() > 0) {
        parameterDeclaration.deleteCharAt(0);
      }
      sw.println(""String_Node_Str"",jmethod.getReturnType().getParameterizedQualifiedSourceName(),jmethod.getName(),parameterDeclaration);
      sw.indent();
      sw.println(""String_Node_Str"",AbstractRequest.class.getCanonicalName(),request.getDataType().getParameterizedQualifiedSourceName(),jmethod.getReturnType().getParameterizedQualifiedSourceName());
      sw.indent();
      sw.println(""String_Node_Str"",method.getSimpleSourceName());
      sw.println(""String_Node_Str"");
      sw.println(""String_Node_Str"",RequestData.class.getCanonicalName());
      sw.indentln(""String_Node_Str"",RequestData.class.getCanonicalName(),operation,parameterArray);
      sw.println(""String_Node_Str"");
      sw.println(""String_Node_Str"");
      sw.indent();
      sw.println(""String_Node_Str"");
      if (request.isCollectionType()) {
        Class<?> collectionType=request.getCollectionType().equals(CollectionType.LIST) ? ArrayList.class : HashSet.class;
        sw.println(""String_Node_Str"",collectionType.getCanonicalName());
        String decodeMethod=request.isValueType() ? ""String_Node_Str"" : ""String_Node_Str"";
        sw.println(""String_Node_Str"",decodeMethod,request.getCollectionElementType().getQualifiedSourceName(),collectionType.getCanonicalName());
      }
 else       if (request.isValueType()) {
        sw.println(""String_Node_Str"",ValueCodex.class.getCanonicalName(),request.getDataType().getQualifiedSourceName());
      }
 else       if (request.isEntityType()) {
        sw.println(""String_Node_Str"",request.getEntityType().getQualifiedSourceName());
      }
 else {
        sw.println(""String_Node_Str"");
      }
      sw.println(""String_Node_Str"",request.getDataType().getParameterizedQualifiedSourceName());
      sw.outdent();
      sw.println(""String_Node_Str"");
      sw.outdent();
      sw.println(""String_Node_Str"");
      sw.println(""String_Node_Str"");
      if (!request.isInstance()) {
        sw.println(""String_Node_Str"");
      }
      sw.println(""String_Node_Str"");
      sw.outdent();
      sw.println(""String_Node_Str"");
    }
    sw.commit(logger);
  }
}","private void writeContextImplementations(){
  for (  ContextMethod method : model.getMethods()) {
    PrintWriter pw=context.tryCreate(logger,method.getPackageName(),method.getSimpleSourceName());
    if (pw == null) {
      continue;
    }
    ClassSourceFileComposerFactory factory=new ClassSourceFileComposerFactory(method.getPackageName(),method.getSimpleSourceName());
    factory.setSuperclass(AbstractRequestContext.class.getCanonicalName());
    factory.addImplementedInterface(method.getImplementedInterfaceQualifiedSourceName());
    SourceWriter sw=factory.createSourceWriter(context,pw);
    sw.println(""String_Node_Str"",method.getSimpleSourceName(),AbstractRequestFactory.class.getCanonicalName());
    for (    RequestMethod request : method.getRequestMethods()) {
      JMethod jmethod=request.getDeclarationMethod();
      String operation=jmethod.getEnclosingType().getQualifiedBinaryName() + ""String_Node_Str"" + jmethod.getName();
      StringBuilder parameterArray=new StringBuilder();
      StringBuilder parameterDeclaration=new StringBuilder();
      StringBuilder typeParameterDeclaration=new StringBuilder();
      if (request.isInstance()) {
        parameterArray.append(""String_Node_Str"");
      }
      for (      JTypeParameter param : jmethod.getTypeParameters()) {
        typeParameterDeclaration.append(""String_Node_Str"").append(param.getQualifiedSourceName());
      }
      for (      JParameter param : jmethod.getParameters()) {
        parameterArray.append(""String_Node_Str"").append(param.getName());
        parameterDeclaration.append(""String_Node_Str"").append(param.getType().getParameterizedQualifiedSourceName()).append(""String_Node_Str"").append(param.getName());
      }
      if (parameterArray.length() > 0) {
        parameterArray.deleteCharAt(0);
      }
      if (parameterDeclaration.length() > 0) {
        parameterDeclaration.deleteCharAt(0);
      }
      if (typeParameterDeclaration.length() > 0) {
        typeParameterDeclaration.deleteCharAt(0).insert(0,""String_Node_Str"").append(""String_Node_Str"");
      }
      sw.println(""String_Node_Str"",typeParameterDeclaration,jmethod.getReturnType().getParameterizedQualifiedSourceName(),jmethod.getName(),parameterDeclaration);
      sw.indent();
      sw.println(""String_Node_Str"",AbstractRequest.class.getCanonicalName(),request.getDataType().getParameterizedQualifiedSourceName(),jmethod.getReturnType().getParameterizedQualifiedSourceName());
      sw.indent();
      sw.println(""String_Node_Str"",method.getSimpleSourceName());
      sw.println(""String_Node_Str"");
      sw.println(""String_Node_Str"",RequestData.class.getCanonicalName());
      sw.indentln(""String_Node_Str"",RequestData.class.getCanonicalName(),operation,parameterArray);
      sw.println(""String_Node_Str"");
      sw.println(""String_Node_Str"");
      sw.indent();
      sw.println(""String_Node_Str"");
      if (request.isCollectionType()) {
        Class<?> collectionType=request.getCollectionType().equals(CollectionType.LIST) ? ArrayList.class : HashSet.class;
        sw.println(""String_Node_Str"",collectionType.getCanonicalName());
        String decodeMethod=request.isValueType() ? ""String_Node_Str"" : ""String_Node_Str"";
        sw.println(""String_Node_Str"",decodeMethod,ModelUtils.getQualifiedBaseName(request.getCollectionElementType()),collectionType.getCanonicalName());
      }
 else       if (request.isValueType()) {
        sw.println(""String_Node_Str"",ValueCodex.class.getCanonicalName(),ModelUtils.getQualifiedBaseName(request.getDataType()));
      }
 else       if (request.isEntityType()) {
        sw.println(""String_Node_Str"",request.getEntityType().getQualifiedSourceName());
      }
 else {
        sw.println(""String_Node_Str"");
      }
      sw.println(""String_Node_Str"",request.getDataType().getParameterizedQualifiedSourceName());
      sw.outdent();
      sw.println(""String_Node_Str"");
      sw.outdent();
      sw.println(""String_Node_Str"");
      sw.println(""String_Node_Str"");
      if (!request.isInstance()) {
        sw.println(""String_Node_Str"");
      }
      sw.println(""String_Node_Str"");
      sw.outdent();
      sw.println(""String_Node_Str"");
    }
    sw.commit(logger);
  }
}",0.8061430010070494
53957,"public void setQualifiedSourceName(String name){
  toReturn.qualifiedSourceName=name;
}","public void setQualifiedSourceName(String name){
}",0.7299270072992701
53958,"/** 
 * Find the entity in the server data store, apply its setters, capture any violations, and return a  {@link com.google.gwt.requestfactory.server.JsonRequestProcessor.EntityData EntityData} encapsulating the results.<p> If a <i>set</i> method has side-effects, we will not notice.
 */
public EntityData getEntityDataForRecordWithSettersApplied(EntityKey entityKey,JSONObject recordObject,WriteOperation writeOperation) throws JSONException, SecurityException, IllegalAccessException, InvocationTargetException, NoSuchMethodException, InstantiationException {
  Class<?> entityType=getEntityTypeForProxyType(entityKey.proxyType);
  Map<String,Property<?>> propertiesInProxy=getPropertiesFromRecordProxyType(entityKey.proxyType);
  Map<String,Class<?>> propertiesInDomain=updatePropertyTypes(propertiesInProxy,entityType);
  validateKeys(recordObject,propertiesInDomain.keySet());
  Object entityInstance=getEntityInstance(writeOperation,entityType,entityKey.decodedId(propertiesInProxy.get(Constants.ENTITY_ID_PROPERTY).getType()),propertiesInProxy.get(Constants.ENTITY_ID_PROPERTY).getType());
  cachedEntityLookup.put(entityKey,entityInstance);
  Iterator<?> keys=recordObject.keys();
  while (keys.hasNext()) {
    String key=(String)keys.next();
    Class<?> propertyType=propertiesInDomain.get(key);
    Property<?> dtoProperty=propertiesInProxy.get(key);
    if (writeOperation == WriteOperation.PERSIST && (Constants.ENTITY_ID_PROPERTY.equals(key))) {
      String id=generateIdForCreate(key);
      if (id != null) {
        entityType.getMethod(getMethodNameFromPropertyName(key,""String_Node_Str""),propertyType).invoke(entityInstance,id);
      }
    }
 else {
      Object propertyValue=null;
      if (recordObject.isNull(key)) {
      }
 else       if (dtoProperty instanceof CollectionProperty<?,?>) {
        Class<?> cType=dtoProperty.getType();
        Class<?> leafType=((CollectionProperty<?,?>)dtoProperty).getLeafType();
        Collection<Object> col=createCollection(cType);
        if (col != null) {
          JSONArray array=recordObject.getJSONArray(key);
          for (int i=0; i < array.length(); i++) {
            if (EntityProxy.class.isAssignableFrom(leafType)) {
              propertyValue=getPropertyValueFromRequestCached(array,i,dtoProperty);
            }
 else {
              propertyValue=decodeParameterValue(leafType,array.getString(i));
            }
            col.add(propertyValue);
          }
          propertyValue=col;
        }
      }
 else {
        propertyValue=getPropertyValueFromRequestCached(recordObject,propertiesInProxy,key,dtoProperty);
      }
      entityType.getMethod(getMethodNameFromPropertyName(key,""String_Node_Str""),propertiesInDomain.get(key)).invoke(entityInstance,propertyValue);
    }
  }
  Set<ConstraintViolation<Object>> violations=Collections.emptySet();
  Validator validator=null;
  try {
    ValidatorFactory validatorFactory=Validation.buildDefaultValidatorFactory();
    validator=validatorFactory.getValidator();
  }
 catch (  Exception e) {
    log.info(String.format(""String_Node_Str"" + ""String_Node_Str"",e.getClass().getName(),e.getLocalizedMessage()));
  }
  if (validator != null) {
    violations=validator.validate(entityInstance);
  }
  return new EntityData(entityInstance,(violations.isEmpty() ? null : getViolationsAsJson(violations)));
}","/** 
 * Find the entity in the server data store, apply its setters, capture any violations, and return a  {@link com.google.gwt.requestfactory.server.JsonRequestProcessor.EntityData EntityData} encapsulating the results.<p> If a <i>set</i> method has side-effects, we will not notice.
 */
public EntityData getEntityDataForRecordWithSettersApplied(EntityKey entityKey,JSONObject recordObject,WriteOperation writeOperation) throws JSONException, SecurityException, IllegalAccessException, InvocationTargetException, NoSuchMethodException, InstantiationException {
  Class<?> entityType=getEntityTypeForProxyType(entityKey.proxyType);
  Map<String,Property<?>> propertiesInProxy=getPropertiesFromRecordProxyType(entityKey.proxyType);
  Map<String,Class<?>> propertiesInDomain=updatePropertyTypes(propertiesInProxy,entityType);
  validateKeys(recordObject,propertiesInDomain.keySet());
  Class<?> idType=getIdMethodForEntity(entityType).getReturnType();
  Object entityInstance=getEntityInstance(writeOperation,entityType,entityKey.decodedId(idType),idType);
  cachedEntityLookup.put(entityKey,entityInstance);
  Iterator<?> keys=recordObject.keys();
  while (keys.hasNext()) {
    String key=(String)keys.next();
    Property<?> dtoProperty=propertiesInProxy.get(key);
    if (writeOperation == WriteOperation.PERSIST && (Constants.ENTITY_ID_PROPERTY.equals(key))) {
      continue;
    }
 else {
      Object propertyValue=null;
      if (recordObject.isNull(key)) {
      }
 else       if (dtoProperty instanceof CollectionProperty<?,?>) {
        Class<?> cType=dtoProperty.getType();
        Class<?> leafType=((CollectionProperty<?,?>)dtoProperty).getLeafType();
        Collection<Object> col=createCollection(cType);
        if (col != null) {
          JSONArray array=recordObject.getJSONArray(key);
          for (int i=0; i < array.length(); i++) {
            if (EntityProxy.class.isAssignableFrom(leafType)) {
              propertyValue=getPropertyValueFromRequestCached(array,i,dtoProperty);
            }
 else {
              propertyValue=decodeParameterValue(leafType,array.getString(i));
            }
            col.add(propertyValue);
          }
          propertyValue=col;
        }
      }
 else {
        propertyValue=getPropertyValueFromRequestCached(recordObject,propertiesInProxy,key,dtoProperty);
      }
      entityType.getMethod(getMethodNameFromPropertyName(key,""String_Node_Str""),propertiesInDomain.get(key)).invoke(entityInstance,propertyValue);
    }
  }
  Set<ConstraintViolation<Object>> violations=Collections.emptySet();
  Validator validator=null;
  try {
    ValidatorFactory validatorFactory=Validation.buildDefaultValidatorFactory();
    validator=validatorFactory.getValidator();
  }
 catch (  Exception e) {
    log.info(String.format(""String_Node_Str"" + ""String_Node_Str"",e.getClass().getName(),e.getLocalizedMessage()));
  }
  if (validator != null) {
    violations=validator.validate(entityInstance);
  }
  return new EntityData(entityInstance,(violations.isEmpty() ? null : getViolationsAsJson(violations)));
}",0.8417602996254682
53959,"public void testFetchEntityWithStringId(){
  delayTestFinish(TEST_DELAY);
  req.simpleBarRequest().findSimpleBarById(""String_Node_Str"").fire(new Receiver<SimpleBarProxy>(){
    @Override public void onSuccess(    SimpleBarProxy response){
      final EntityProxyId<SimpleBarProxy> stableId=response.stableId();
      req.find(stableId).fire(new Receiver<SimpleBarProxy>(){
        @Override public void onSuccess(        SimpleBarProxy returnedProxy){
          assertEquals(stableId,returnedProxy.stableId());
          assertEquals(""String_Node_Str"",returnedProxy.getId());
          finishTestAndReset();
        }
      }
);
    }
  }
);
}","public void testFetchEntityWithStringId(){
  delayTestFinish(TEST_DELAY);
  req.simpleBarRequest().findSimpleBarById(""String_Node_Str"").fire(new Receiver<SimpleBarProxy>(){
    @Override public void onSuccess(    SimpleBarProxy response){
      final EntityProxyId<SimpleBarProxy> stableId=response.stableId();
      req.find(stableId).fire(new Receiver<SimpleBarProxy>(){
        @Override public void onSuccess(        SimpleBarProxy returnedProxy){
          assertEquals(stableId,returnedProxy.stableId());
          finishTestAndReset();
        }
      }
);
    }
  }
);
}",0.9467649467649468
53960,"public void testDummyCreateBar(){
  delayTestFinish(5000);
  SimpleBarRequest context=req.simpleBarRequest();
  final SimpleBarProxy foo=context.create(SimpleBarProxy.class);
  Object futureId=foo.getId();
  assertEquals(futureId,foo.getId());
  Request<SimpleBarProxy> fooReq=context.persistAndReturnSelf().using(foo);
  fooReq.fire(new Receiver<SimpleBarProxy>(){
    @Override public void onSuccess(    final SimpleBarProxy returned){
      Object futureId=foo.getId();
      assertEquals(futureId,foo.getId());
      checkStableIdEquals(foo,returned);
      finishTestAndReset();
    }
  }
);
}","public void testDummyCreateBar(){
  delayTestFinish(5000);
  SimpleBarRequest context=req.simpleBarRequest();
  final SimpleBarProxy foo=context.create(SimpleBarProxy.class);
  Request<SimpleBarProxy> fooReq=context.persistAndReturnSelf().using(foo);
  fooReq.fire(new Receiver<SimpleBarProxy>(){
    @Override public void onSuccess(    final SimpleBarProxy returned){
      checkStableIdEquals(foo,returned);
      finishTestAndReset();
    }
  }
);
}",0.8609523809523809
53961,"public void testDummyCreateList(){
  delayTestFinish(DELAY_TEST_FINISH);
  SimpleBarRequest context=simpleBarRequest();
  final SimpleBarProxy bar=context.create(SimpleBarProxy.class);
  Object futureId=bar.getId();
  assertEquals(futureId,bar.getId());
  assertTrue(((SimpleEntityProxyId<?>)bar.stableId()).isEphemeral());
  Request<SimpleBarProxy> fooReq=context.returnFirst(Collections.singletonList(bar));
  fooReq.fire(new Receiver<SimpleBarProxy>(){
    @Override public void onSuccess(    final SimpleBarProxy returned){
      Object futureId=bar.getId();
      assertEquals(futureId,bar.getId());
      assertFalse(((SimpleEntityProxyId<?>)bar.stableId()).isEphemeral());
      assertFalse(((SimpleEntityProxyId<?>)returned.stableId()).isEphemeral());
      checkStableIdEquals(bar,returned);
      finishTestAndReset();
    }
  }
);
}","public void testDummyCreateList(){
  delayTestFinish(DELAY_TEST_FINISH);
  SimpleBarRequest context=simpleBarRequest();
  final SimpleBarProxy bar=context.create(SimpleBarProxy.class);
  assertTrue(((SimpleEntityProxyId<?>)bar.stableId()).isEphemeral());
  Request<SimpleBarProxy> fooReq=context.returnFirst(Collections.singletonList(bar));
  fooReq.fire(new Receiver<SimpleBarProxy>(){
    @Override public void onSuccess(    final SimpleBarProxy returned){
      assertFalse(((SimpleEntityProxyId<?>)bar.stableId()).isEphemeral());
      assertFalse(((SimpleEntityProxyId<?>)returned.stableId()).isEphemeral());
      checkStableIdEquals(bar,returned);
      finishTestAndReset();
    }
  }
);
}",0.9051948051948052
53962,"public void testDummyCreateBar(){
  delayTestFinish(DELAY_TEST_FINISH);
  SimpleBarRequest context=simpleBarRequest();
  final SimpleBarProxy foo=context.create(SimpleBarProxy.class);
  Object futureId=foo.getId();
  assertEquals(futureId,foo.getId());
  assertTrue(((SimpleEntityProxyId<?>)foo.stableId()).isEphemeral());
  Request<SimpleBarProxy> fooReq=context.persistAndReturnSelf().using(foo);
  fooReq.fire(new Receiver<SimpleBarProxy>(){
    @Override public void onSuccess(    final SimpleBarProxy returned){
      Object futureId=foo.getId();
      assertEquals(futureId,foo.getId());
      assertFalse(((SimpleEntityProxyId<?>)foo.stableId()).isEphemeral());
      checkStableIdEquals(foo,returned);
      finishTestAndReset();
    }
  }
);
}","public void testDummyCreateBar(){
  delayTestFinish(DELAY_TEST_FINISH);
  SimpleBarRequest context=simpleBarRequest();
  final SimpleBarProxy foo=context.create(SimpleBarProxy.class);
  assertTrue(((SimpleEntityProxyId<?>)foo.stableId()).isEphemeral());
  Request<SimpleBarProxy> fooReq=context.persistAndReturnSelf().using(foo);
  fooReq.fire(new Receiver<SimpleBarProxy>(){
    @Override public void onSuccess(    final SimpleBarProxy returned){
      assertFalse(((SimpleEntityProxyId<?>)foo.stableId()).isEphemeral());
      checkStableIdEquals(foo,returned);
      finishTestAndReset();
    }
  }
);
}",0.8924889543446245
53963,"public String getSchedule(boolean[] daysFilter){
  return classSchedule.getDescription(daysFilter);
}","public String getSchedule(){
  return getScheduleWithFilter(daysFilters);
}",0.7159090909090909
53964,"private Object getPropertyValueFromRequestCached(JSONArray recordArray,int index,Property<?> dtoProperty) throws JSONException, IllegalAccessException, InvocationTargetException, NoSuchMethodException, InstantiationException {
  Object propertyValue;
  Class<?> leafType=dtoProperty instanceof CollectionProperty<?,?> ? ((CollectionProperty<?,?>)dtoProperty).getLeafType() : dtoProperty.getType();
  if (EntityProxy.class.isAssignableFrom(leafType)) {
    EntityKey propKey=getEntityKey(recordArray.getString(index));
    Object cacheValue=cachedEntityLookup.get(propKey);
    if (cachedEntityLookup.containsKey(propKey)) {
      propertyValue=cacheValue;
    }
 else {
      propertyValue=getPropertyValueFromRequest(recordArray,index,leafType);
    }
  }
 else {
    propertyValue=getPropertyValueFromRequest(recordArray,index,leafType);
  }
  return propertyValue;
}","private Object getPropertyValueFromRequestCached(JSONObject recordObject,Map<String,Property<?>> propertiesInProxy,String key,Property<?> dtoProperty) throws JSONException, IllegalAccessException, InvocationTargetException, NoSuchMethodException, InstantiationException {
  Object propertyValue;
  if (!recordObject.isNull(key) && EntityProxy.class.isAssignableFrom(dtoProperty.getType())) {
    EntityKey propKey=getEntityKey(recordObject.getString(key));
    Object cacheValue=cachedEntityLookup.get(propKey);
    if (cachedEntityLookup.containsKey(propKey)) {
      propertyValue=cacheValue;
    }
 else {
      propertyValue=getPropertyValueFromRequest(recordObject,key,propertiesInProxy.get(key).getType());
    }
  }
 else {
    propertyValue=getPropertyValueFromRequest(recordObject,key,propertiesInProxy.get(key).getType());
  }
  return propertyValue;
}",0.486424032351242
53965,"/** 
 * Returns a JSONObject with at most three keys: CREATE, UPDATE, DELETE. Each value is a JSONArray of JSONObjects.
 */
private JSONObject getSideEffects() throws SecurityException, JSONException, IllegalAccessException, InvocationTargetException, NoSuchMethodException, IllegalArgumentException, InstantiationException {
  JSONObject sideEffects=new JSONObject();
  JSONArray createArray=new JSONArray();
  JSONArray deleteArray=new JSONArray();
  JSONArray updateArray=new JSONArray();
  for (  EntityKey entityKey : involvedKeys) {
    EntityData entityData=afterDvsDataMap.get(entityKey);
    if (entityData == null) {
      continue;
    }
    if (entityKey.isFuture) {
      JSONObject createRecord=getCreateReturnRecord(entityKey,entityData);
      if (createRecord != null) {
        createArray.put(createRecord);
      }
      continue;
    }
    WriteOperation writeOperation=detectDeleteOrUpdate(entityKey,entityData);
    if (writeOperation == WriteOperation.DELETE) {
      JSONObject deleteRecord=new JSONObject();
      deleteRecord.put(Constants.ENCODED_ID_PROPERTY,getSchemaAndId(entityKey.proxyType,entityKey.encodedId));
      deleteArray.put(deleteRecord);
    }
    if (writeOperation == WriteOperation.UPDATE) {
      JSONObject updateRecord=new JSONObject();
      updateRecord.put(Constants.ENCODED_ID_PROPERTY,getSchemaAndId(entityKey.proxyType,entityKey.encodedId));
      updateArray.put(updateRecord);
    }
  }
  if (createArray.length() > 0) {
    sideEffects.put(WriteOperation.PERSIST.name(),createArray);
  }
  if (deleteArray.length() > 0) {
    sideEffects.put(WriteOperation.DELETE.name(),deleteArray);
  }
  if (updateArray.length() > 0) {
    sideEffects.put(WriteOperation.UPDATE.name(),updateArray);
  }
  return sideEffects;
}","/** 
 * Returns a JSONObject with at most three keys: CREATE, UPDATE, DELETE. Each value is a JSONArray of JSONObjects.
 */
private JSONObject getSideEffects() throws SecurityException, JSONException, IllegalAccessException, InvocationTargetException, NoSuchMethodException, IllegalArgumentException, InstantiationException {
}",0.311576941400667
53966,"public Object getJsonObject(Object entityElement,Class<? extends EntityProxy> entityKeyClass,RequestProperty propertyContext) throws JSONException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
  JSONObject jsonObject=new JSONObject();
  if (entityElement == null || !EntityProxy.class.isAssignableFrom(entityKeyClass)) {
    return JSONObject.NULL;
  }
  jsonObject.put(Constants.ENCODED_ID_PROPERTY,isEntityReference(entityElement,entityKeyClass));
  jsonObject.put(Constants.ENCODED_VERSION_PROPERTY,encodePropertyValueFromDataStore(entityElement,Constants.ENTITY_VERSION_PROPERTY,Constants.ENTITY_VERSION_PROPERTY.getName(),propertyContext));
  for (  Property<?> p : allProperties(entityKeyClass)) {
    if (requestedProperty(p,propertyContext)) {
      String propertyName=p.getName();
      jsonObject.put(propertyName,encodePropertyValueFromDataStore(entityElement,p,propertyName,propertyContext));
    }
  }
  return jsonObject;
}","public Object getJsonObject(Object entityElement,Class<? extends EntityProxy> entityKeyClass,RequestProperty propertyContext) throws JSONException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
  if (entityElement == null || !EntityProxy.class.isAssignableFrom(entityKeyClass)) {
    return JSONObject.NULL;
  }
  JSONObject jsonObject=getJsonObjectWithIdAndVersion(isEntityReference(entityElement,entityKeyClass),entityElement,propertyContext);
  for (  Property<?> p : allProperties(entityKeyClass)) {
    if (requestedProperty(p,propertyContext)) {
      String propertyName=p.getName();
      jsonObject.put(propertyName,encodePropertyValueFromDataStore(entityElement,p,propertyName,propertyContext));
    }
  }
  return jsonObject;
}",0.7815561959654179
53967,"public void testMethodWithSideEffects(){
  delayTestFinish(5000);
  final SimpleFooEventHandler<SimpleFooStringProxy> handler=new SimpleFooEventHandler<SimpleFooStringProxy>();
  EntityProxyChange.registerForProxyType(req.getEventBus(),SimpleFooStringProxy.class,handler);
  req.simpleFooStringRequest().findSimpleFooStringById(""String_Node_Str"").fire(new Receiver<SimpleFooStringProxy>(){
    @Override public void onSuccess(    SimpleFooStringProxy newFoo){
      assertEquals(1,handler.updateEventCount);
      assertEquals(1,handler.totalEventCount);
      SimpleFooStringRequest context=req.simpleFooStringRequest();
      final Request<Long> mutateRequest=context.countSimpleFooWithUserNameSideEffect().using(newFoo);
      newFoo=context.edit(newFoo);
      newFoo.setUserName(""String_Node_Str"");
      mutateRequest.fire(new Receiver<Long>(){
        @Override public void onSuccess(        Long response){
          assertCannotFire(mutateRequest);
          assertEquals(new Long(1L),response);
          assertEquals(2,handler.updateEventCount);
          assertEquals(2,handler.totalEventCount);
          req.simpleFooStringRequest().findSimpleFooStringById(""String_Node_Str"").fire(new Receiver<SimpleFooStringProxy>(){
            @Override public void onSuccess(            SimpleFooStringProxy finalFoo){
              assertEquals(""String_Node_Str"",finalFoo.getUserName());
              assertEquals(3,handler.updateEventCount);
              assertEquals(3,handler.totalEventCount);
              finishTestAndReset();
            }
          }
);
        }
      }
);
      try {
        newFoo.setUserName(""String_Node_Str"");
        fail();
      }
 catch (      IllegalStateException e) {
      }
    }
  }
);
}","public void testMethodWithSideEffects(){
  delayTestFinish(5000);
  final SimpleFooEventHandler<SimpleFooStringProxy> handler=new SimpleFooEventHandler<SimpleFooStringProxy>();
  EntityProxyChange.registerForProxyType(req.getEventBus(),SimpleFooStringProxy.class,handler);
  req.simpleFooStringRequest().findSimpleFooStringById(""String_Node_Str"").fire(new Receiver<SimpleFooStringProxy>(){
    @Override public void onSuccess(    SimpleFooStringProxy newFoo){
      assertEquals(1,handler.updateEventCount);
      assertEquals(1,handler.totalEventCount);
      SimpleFooStringRequest context=req.simpleFooStringRequest();
      final Request<Long> mutateRequest=context.countSimpleFooWithUserNameSideEffect().using(newFoo);
      newFoo=context.edit(newFoo);
      newFoo.setUserName(""String_Node_Str"");
      mutateRequest.fire(new Receiver<Long>(){
        @Override public void onSuccess(        Long response){
          assertCannotFire(mutateRequest);
          assertEquals(new Long(1L),response);
          assertEquals(2,handler.updateEventCount);
          assertEquals(2,handler.totalEventCount);
          req.simpleFooStringRequest().findSimpleFooStringById(""String_Node_Str"").fire(new Receiver<SimpleFooStringProxy>(){
            @Override public void onSuccess(            SimpleFooStringProxy finalFoo){
              assertEquals(""String_Node_Str"",finalFoo.getUserName());
              assertEquals(2,handler.updateEventCount);
              assertEquals(2,handler.totalEventCount);
              finishTestAndReset();
            }
          }
);
        }
      }
);
      try {
        newFoo.setUserName(""String_Node_Str"");
        fail();
      }
 catch (      IllegalStateException e) {
      }
    }
  }
);
}",0.9988465974625144
53968,"public void testMethodWithSideEffects(){
  delayTestFinish(DELAY_TEST_FINISH);
  final SimpleFooEventHandler<SimpleFooProxy> handler=new SimpleFooEventHandler<SimpleFooProxy>();
  EntityProxyChange.registerForProxyType(req.getEventBus(),SimpleFooProxy.class,handler);
  simpleFooRequest().findSimpleFooById(999L).fire(new Receiver<SimpleFooProxy>(){
    @Override public void onSuccess(    SimpleFooProxy newFoo){
      assertEquals(1,handler.updateEventCount);
      assertEquals(1,handler.totalEventCount);
      SimpleFooRequest context=simpleFooRequest();
      final Request<Long> mutateRequest=context.countSimpleFooWithUserNameSideEffect().using(newFoo);
      newFoo=context.edit(newFoo);
      newFoo.setUserName(""String_Node_Str"");
      mutateRequest.fire(new Receiver<Long>(){
        @Override public void onSuccess(        Long response){
          assertCannotFire(mutateRequest);
          assertEquals(new Long(2L),response);
          assertEquals(2,handler.updateEventCount);
          assertEquals(2,handler.totalEventCount);
          simpleFooRequest().findSimpleFooById(999L).fire(new Receiver<SimpleFooProxy>(){
            @Override public void onSuccess(            SimpleFooProxy finalFoo){
              assertEquals(""String_Node_Str"",finalFoo.getUserName());
              assertEquals(3,handler.updateEventCount);
              assertEquals(3,handler.totalEventCount);
              finishTestAndReset();
            }
          }
);
        }
      }
);
      try {
        newFoo.setUserName(""String_Node_Str"");
        fail();
      }
 catch (      IllegalStateException e) {
      }
    }
  }
);
}","public void testMethodWithSideEffects(){
  delayTestFinish(DELAY_TEST_FINISH);
  final SimpleFooEventHandler<SimpleFooProxy> handler=new SimpleFooEventHandler<SimpleFooProxy>();
  EntityProxyChange.registerForProxyType(req.getEventBus(),SimpleFooProxy.class,handler);
  simpleFooRequest().findSimpleFooById(999L).fire(new Receiver<SimpleFooProxy>(){
    @Override public void onSuccess(    SimpleFooProxy newFoo){
      assertEquals(1,handler.updateEventCount);
      assertEquals(1,handler.totalEventCount);
      SimpleFooRequest context=simpleFooRequest();
      final Request<Long> mutateRequest=context.countSimpleFooWithUserNameSideEffect().using(newFoo);
      newFoo=context.edit(newFoo);
      newFoo.setUserName(""String_Node_Str"");
      mutateRequest.fire(new Receiver<Long>(){
        @Override public void onSuccess(        Long response){
          assertCannotFire(mutateRequest);
          assertEquals(new Long(2L),response);
          assertEquals(2,handler.updateEventCount);
          assertEquals(2,handler.totalEventCount);
          simpleFooRequest().findSimpleFooById(999L).fire(new Receiver<SimpleFooProxy>(){
            @Override public void onSuccess(            SimpleFooProxy finalFoo){
              assertEquals(""String_Node_Str"",finalFoo.getUserName());
              assertEquals(2,handler.updateEventCount);
              assertEquals(2,handler.totalEventCount);
              finishTestAndReset();
            }
          }
);
        }
      }
);
      try {
        newFoo.setUserName(""String_Node_Str"");
        fail();
      }
 catch (      IllegalStateException e) {
      }
    }
  }
);
}",0.9987737584304108
53969,"public void testEndToEnd() throws Exception {
  com.google.gwt.requestfactory.server.SimpleFoo.reset();
  JSONObject foo=fetchVerifyAndGetInitialObject();
  foo.put(""String_Node_Str"",45);
  foo.put(""String_Node_Str"",""String_Node_Str"");
  foo.put(""String_Node_Str"",""String_Node_Str"" + 9L);
  foo.put(""String_Node_Str"",SimpleEnum.BAR.ordinal());
  foo.put(""String_Node_Str"",false);
  Date now=new Date();
  foo.put(""String_Node_Str"",""String_Node_Str"" + now.getTime());
  JSONObject result=getResultFromServer(foo);
  SimpleFoo fooResult=SimpleFoo.findSimpleFooById(999L);
  JSONArray updateArray=result.getJSONObject(""String_Node_Str"").getJSONArray(""String_Node_Str"");
  assertEquals(1,updateArray.length());
  assertEquals(1,updateArray.getJSONObject(0).length());
  assertTrue(updateArray.getJSONObject(0).has(Constants.ENCODED_ID_PROPERTY));
  assertFalse(updateArray.getJSONObject(0).has(""String_Node_Str""));
  assertEquals(45,(int)fooResult.getIntId());
  assertEquals(""String_Node_Str"",fooResult.getUserName());
  assertEquals(now,fooResult.getCreated());
  assertEquals(9L,(long)fooResult.getLongField());
  assertEquals(com.google.gwt.requestfactory.shared.SimpleEnum.BAR,fooResult.getEnumField());
  assertEquals(false,(boolean)fooResult.getBoolField());
}","public void testEndToEnd() throws Exception {
  com.google.gwt.requestfactory.server.SimpleFoo.reset();
  JSONObject foo=fetchVerifyAndGetInitialObject();
  foo.put(""String_Node_Str"",45);
  foo.put(""String_Node_Str"",""String_Node_Str"");
  foo.put(""String_Node_Str"",""String_Node_Str"" + 9L);
  foo.put(""String_Node_Str"",SimpleEnum.BAR.ordinal());
  foo.put(""String_Node_Str"",false);
  Date now=new Date();
  foo.put(""String_Node_Str"",""String_Node_Str"" + now.getTime());
  JSONObject result=getResultFromServer(foo);
  SimpleFoo fooResult=SimpleFoo.findSimpleFooById(999L);
  JSONArray updateArray=result.getJSONObject(""String_Node_Str"").getJSONArray(""String_Node_Str"");
  assertEquals(1,updateArray.length());
  assertEquals(2,updateArray.getJSONObject(0).length());
  assertTrue(updateArray.getJSONObject(0).has(Constants.ENCODED_ID_PROPERTY));
  assertTrue(updateArray.getJSONObject(0).has(Constants.ENCODED_VERSION_PROPERTY));
  assertFalse(updateArray.getJSONObject(0).has(""String_Node_Str""));
  assertEquals(45,(int)fooResult.getIntId());
  assertEquals(""String_Node_Str"",fooResult.getUserName());
  assertEquals(now,fooResult.getCreated());
  assertEquals(9L,(long)fooResult.getLongField());
  assertEquals(com.google.gwt.requestfactory.shared.SimpleEnum.BAR,fooResult.getEnumField());
  assertEquals(false,(boolean)fooResult.getBoolField());
}",0.9670498084291188
53970,"public void persist(){
  if (isNew) {
    setId(Long.toString(nextId++));
    isNew=false;
    get().put(getId(),this);
  }
}","public void persist(){
  if (isNew) {
    setId(Long.toString(nextId++));
    isNew=false;
    get().put(getId(),this);
  }
  version++;
}",0.9505703422053232
53971,"public Long countSimpleFooWithUserNameSideEffect(){
  findSimpleFoo(1L).setUserName(userName);
  return countSimpleFoo();
}","public Long countSimpleFooWithUserNameSideEffect(){
  findSimpleFoo(1L).setUserName(userName);
  version++;
  return countSimpleFoo();
}",0.9498069498069498
53972,"public void persist(){
  if (isNew) {
    setId(nextId++);
    isNew=false;
    get().put(getId(),this);
  }
}","public void persist(){
  if (isNew) {
    setId(nextId++);
    isNew=false;
    get().put(getId(),this);
  }
  version++;
}",0.944206008583691
53973,"public Long countSimpleFooWithUserNameSideEffect(){
  get().setUserName(userName);
  return 1L;
}","public Long countSimpleFooWithUserNameSideEffect(){
  get().setUserName(userName);
  version++;
  return 1L;
}",0.9371980676328504
53974,"public void persist(){
  setId(nextId++ + ""String_Node_Str"");
}","public void persist(){
  setId(nextId++ + ""String_Node_Str"");
  version++;
}",0.9064748201438848
53975,"/** 
 * Get the HTML representation of an image. Visible for testing.
 * @param res the {@link ImageResource} to render as HTML
 * @param valign the vertical alignment
 * @param isPlaceholder if true, do not include the background image
 * @return the rendered HTML
 */
SafeHtml getImageHtml(ImageResource res,VerticalAlignmentConstant valign,boolean isPlaceholder){
  if (isPlaceholder) {
    return template.imagePlaceholder(direction,res.getWidth());
  }
 else {
    String vert=valign == HasVerticalAlignment.ALIGN_MIDDLE ? ""String_Node_Str"" : valign.getVerticalAlignString();
    return SafeHtmlUtils.fromTrustedString(""String_Node_Str"" + direction + ""String_Node_Str""+ res.getWidth()+ ""String_Node_Str""+ res.getURL()+ ""String_Node_Str""+ SafeHtmlUtils.htmlEscape(vert)+ ""String_Node_Str"");
  }
}","/** 
 * Get the HTML representation of an image. Visible for testing.
 * @param res the {@link ImageResource} to render as HTML
 * @param valign the vertical alignment
 * @param isPlaceholder if true, do not include the background image
 * @return the rendered HTML
 */
SafeHtml getImageHtml(ImageResource res,VerticalAlignmentConstant valign,boolean isPlaceholder){
  SafeHtml image;
  if (isPlaceholder) {
    image=SafeHtmlUtils.fromTrustedString(""String_Node_Str"");
  }
 else {
    AbstractImagePrototype proto=AbstractImagePrototype.create(res);
    image=SafeHtmlUtils.fromTrustedString(proto.getHTML());
  }
  if (HasVerticalAlignment.ALIGN_TOP == valign) {
    return template.imageWrapperTop(direction,image);
  }
 else   if (HasVerticalAlignment.ALIGN_BOTTOM == valign) {
    return template.imageWrapperBottom(direction,image);
  }
 else {
    int halfHeight=1 + (int)Math.round(res.getHeight() / 2.0);
    return template.imageWrapperMiddle(direction,halfHeight,image);
  }
}",0.5137101287073307
53976,"/** 
 * Construct a new   {@link IconCellDecorator}.
 * @param icon the icon to use
 * @param cell the cell to decorate
 * @param valign the vertical alignment attribute of the contents
 * @param spacing the pixel space between the icon and the cell
 */
public IconCellDecorator(ImageResource icon,Cell<C> cell,VerticalAlignmentConstant valign,int spacing){
  if (template == null) {
    template=GWT.create(Template.class);
  }
  this.cell=cell;
  this.iconHtml=getImageHtml(icon,valign,false);
  this.imageWidth=icon.getWidth() + 6;
  this.placeHolderHtml=getImageHtml(icon,valign,true);
}","/** 
 * Construct a new   {@link IconCellDecorator}.
 * @param icon the icon to use
 * @param cell the cell to decorate
 * @param valign the vertical alignment attribute of the contents
 * @param spacing the pixel space between the icon and the cell
 */
public IconCellDecorator(ImageResource icon,Cell<C> cell,VerticalAlignmentConstant valign,int spacing){
  if (template == null) {
    template=GWT.create(Template.class);
  }
  this.cell=cell;
  this.iconHtml=getImageHtml(icon,valign,false);
  this.imageWidth=icon.getWidth() + spacing;
  this.placeHolderHtml=getImageHtml(icon,valign,true);
}",0.9932659932659932
53977,"/** 
 * Get the HTML representation of an image.
 * @param res the {@link ImageResource} to render as HTML
 * @return the rendered HTML
 */
private SafeHtml getImageHtml(ImageResource res){
  return SafeHtmlUtils.fromTrustedString(""String_Node_Str"" + (LocaleInfo.getCurrentLocale().isRTL() ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ res.getWidth()+ ""String_Node_Str""+ res.getURL()+ ""String_Node_Str"");
}","/** 
 * Get the HTML representation of an image.
 * @param res the {@link ImageResource} to render as HTML
 * @return the rendered HTML
 */
private SafeHtml getImageHtml(ImageResource res){
  AbstractImagePrototype proto=AbstractImagePrototype.create(res);
  SafeHtml image=SafeHtmlUtils.fromTrustedString(proto.getHTML());
  return template.imageWrapper((LocaleInfo.getCurrentLocale().isRTL() ? ""String_Node_Str"" : ""String_Node_Str""),res.getWidth(),res.getHeight(),image);
}",0.6198439241917503
53978,"/** 
 * Get the HTML representation of an image.
 * @param res the {@link ImageResource} to render as HTML
 * @param isTop true if the image is for a top level element.
 * @return the rendered HTML
 */
private SafeHtml getImageHtml(ImageResource res,boolean isTop){
  StringBuilder classesBuilder=new StringBuilder(style.cellTreeItemImage());
  if (isTop) {
    classesBuilder.append(""String_Node_Str"").append(style.cellTreeTopItemImage());
  }
  String direction;
  if (LocaleInfo.getCurrentLocale().isRTL()) {
    direction=""String_Node_Str"";
  }
 else {
    direction=""String_Node_Str"";
  }
  return template.image(classesBuilder.toString(),direction,res.getHeight(),res.getWidth(),res.getURL());
}","/** 
 * Get the HTML representation of an image.
 * @param res the {@link ImageResource} to render as HTML
 * @param isTop true if the image is for a top level element.
 * @return the rendered HTML
 */
private SafeHtml getImageHtml(ImageResource res,boolean isTop){
  StringBuilder classesBuilder=new StringBuilder(style.cellTreeItemImage());
  if (isTop) {
    classesBuilder.append(""String_Node_Str"").append(style.cellTreeTopItemImage());
  }
  String direction;
  if (LocaleInfo.getCurrentLocale().isRTL()) {
    direction=""String_Node_Str"";
  }
 else {
    direction=""String_Node_Str"";
  }
  AbstractImagePrototype proto=AbstractImagePrototype.create(res);
  SafeHtml image=SafeHtmlUtils.fromTrustedString(proto.getHTML());
  return template.imageWrapper(classesBuilder.toString(),direction,res.getWidth(),res.getHeight(),image);
}",0.8502604166666666
53979,"protected List<PropertyColumn<EmployeeProxy,?>> getColumns(){
  List<PropertyColumn<EmployeeProxy,?>> columns=new ArrayList<PropertyColumn<EmployeeProxy,?>>();
  columns.add(PropertyColumn.<EmployeeProxy>getStringPropertyColumn(""String_Node_Str"",""String_Node_Str""));
  columns.add(PropertyColumn.<EmployeeProxy>getStringPropertyColumn(""String_Node_Str"",""String_Node_Str""));
  columns.add(PropertyColumn.<EmployeeProxy>getStringPropertyColumn(""String_Node_Str"",""String_Node_Str""));
  columns.add(new PropertyColumn<EmployeeProxy,EmployeeProxy>(""String_Node_Str"",""String_Node_Str"",EmployeeRenderer.instance()));
  return columns;
}","protected List<PropertyColumn<EmployeeProxy,?>> getColumns(){
  List<PropertyColumn<EmployeeProxy,?>> columns=new ArrayList<PropertyColumn<EmployeeProxy,?>>();
  columns.add(PropertyColumn.<EmployeeProxy>getStringPropertyColumn(""String_Node_Str"",""String_Node_Str""));
  columns.add(PropertyColumn.<EmployeeProxy>getStringPropertyColumn(""String_Node_Str"",""String_Node_Str""));
  columns.add(PropertyColumn.<EmployeeProxy>getStringPropertyColumn(""String_Node_Str"",""String_Node_Str""));
  columns.add(new PropertyColumn<EmployeeProxy,EmployeeProxy>(""String_Node_Str"",""String_Node_Str"",EmployeeProxy.class,EmployeeRenderer.instance()));
  return columns;
}",0.9843505477308294
53980,"protected List<PropertyColumn<ReportProxy,?>> getColumns(){
  List<PropertyColumn<ReportProxy,?>> columns=new ArrayList<PropertyColumn<ReportProxy,?>>();
  columns.add(new PropertyColumn<ReportProxy,Date>(""String_Node_Str"",""String_Node_Str"",new DateTimeFormatRenderer(DateTimeFormat.getShortDateFormat())));
  columns.add(PropertyColumn.<ReportProxy>getStringPropertyColumn(""String_Node_Str"",""String_Node_Str""));
  columns.add(new PropertyColumn<ReportProxy,EmployeeProxy>(""String_Node_Str"",""String_Node_Str"",EmployeeRenderer.instance()));
  columns.add(new PropertyColumn<ReportProxy,EmployeeProxy>(""String_Node_Str"",""String_Node_Str"",EmployeeRenderer.instance()));
  return columns;
}","protected List<PropertyColumn<ReportProxy,?>> getColumns(){
  List<PropertyColumn<ReportProxy,?>> columns=new ArrayList<PropertyColumn<ReportProxy,?>>();
  columns.add(new PropertyColumn<ReportProxy,Date>(""String_Node_Str"",""String_Node_Str"",Date.class,new DateTimeFormatRenderer(DateTimeFormat.getShortDateFormat())));
  columns.add(PropertyColumn.<ReportProxy>getStringPropertyColumn(""String_Node_Str"",""String_Node_Str""));
  columns.add(new PropertyColumn<ReportProxy,EmployeeProxy>(""String_Node_Str"",""String_Node_Str"",EmployeeProxy.class,EmployeeRenderer.instance()));
  columns.add(new PropertyColumn<ReportProxy,EmployeeProxy>(""String_Node_Str"",""String_Node_Str"",EmployeeProxy.class,EmployeeRenderer.instance()));
  return columns;
}",0.9641602248770204
53981,"@Override public String getValue(R object){
  ProxyImpl proxyImpl=(ProxyImpl)object;
  return renderer.render(proxyImpl.<T>get(property,String.class));
}","@Override public String getValue(R object){
  ProxyImpl proxyImpl=(ProxyImpl)object;
  return renderer.render(proxyImpl.<T>get(property,clazz));
}",0.9632107023411371
53982,"public PropertyColumn(String property,String displayName,Renderer<T> renderer){
  this.displayName=displayName;
  this.property=property;
  this.renderer=renderer;
  this.paths=new String[]{property};
}","public PropertyColumn(String property,String displayName,Class<T> clazz,Renderer<T> renderer){
  this.displayName=displayName;
  this.property=property;
  this.clazz=clazz;
  this.renderer=renderer;
  this.paths=new String[]{property};
}",0.8838268792710706
53983,"public static <R extends EntityProxy>PropertyColumn<R,String> getStringPropertyColumn(String property,String displayName){
  return new PropertyColumn<R,String>(property,displayName,PassthroughRenderer.instance());
}","public static <R extends EntityProxy>PropertyColumn<R,String> getStringPropertyColumn(String property,String displayName){
  return new PropertyColumn<R,String>(property,displayName,String.class,PassthroughRenderer.instance());
}",0.9707865168539326
53984,"private void generateRequestSelectorImplementation(TreeLogger logger,GeneratorContext generatorContext,PrintWriter out,JMethod selectorMethod,JClassType mainType,String packageName,String implName) throws UnableToCompleteException {
  JClassType selectorInterface=selectorMethod.getReturnType().isInterface();
  logger=logger.branch(TreeLogger.DEBUG,String.format(""String_Node_Str"",selectorInterface.getName()));
  ClassSourceFileComposerFactory f=new ClassSourceFileComposerFactory(packageName,implName);
  f.addImport(RequestData.class.getName());
  f.addImport(mainType.getQualifiedSourceName() + ""String_Node_Str"");
  f.addImplementedInterface(selectorInterface.getQualifiedSourceName());
  SourceWriter sw=f.createSourceWriter(generatorContext,out);
  sw.println();
  sw.println(""String_Node_Str"" + mainType.getName() + ""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"" + implName + ""String_Node_Str""+ mainType.getName()+ ""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  for (  JMethod method : selectorInterface.getOverridableMethods()) {
    JClassType returnType=method.getReturnType().isParameterized().getTypeArgs()[0];
    ensureProxyType(logger,generatorContext,returnType.getPackage().getName(),returnType);
    String operationName=selectorInterface.getQualifiedBinaryName() + ReflectionBasedOperationRegistry.SCOPE_SEPARATOR + method.getName();
    JClassType requestType=method.getReturnType().isClassOrInterface();
    String requestClassName=null;
    TypeOracle typeOracle=generatorContext.getTypeOracle();
    String enumArgument=""String_Node_Str"";
    if (isProxyListRequest(typeOracle,requestType)) {
      requestClassName=asInnerImplClass(""String_Node_Str"",returnType);
    }
 else     if (isProxyRequest(typeOracle,requestType)) {
      requestClassName=asInnerImplClass(""String_Node_Str"",returnType);
    }
 else     if (isStringRequest(typeOracle,requestType)) {
      requestClassName=AbstractStringRequest.class.getName();
    }
 else     if (isLongRequest(typeOracle,requestType)) {
      requestClassName=AbstractLongRequest.class.getName();
    }
 else     if (isIntegerRequest(typeOracle,requestType)) {
      requestClassName=AbstractIntegerRequest.class.getName();
    }
 else     if (isDoubleRequest(typeOracle,requestType)) {
      requestClassName=AbstractDoubleRequest.class.getName();
    }
 else     if (isByteRequest(typeOracle,requestType)) {
      requestClassName=AbstractByteRequest.class.getName();
    }
 else     if (isBooleanRequest(typeOracle,requestType)) {
      requestClassName=AbstractBooleanRequest.class.getName();
    }
 else     if (isShortRequest(typeOracle,requestType)) {
      requestClassName=AbstractShortRequest.class.getName();
    }
 else     if (isFloatRequest(typeOracle,requestType)) {
      requestClassName=AbstractFloatRequest.class.getName();
    }
 else     if (isCharacterRequest(typeOracle,requestType)) {
      requestClassName=AbstractCharacterRequest.class.getName();
    }
 else     if (isDateRequest(typeOracle,requestType)) {
      requestClassName=AbstractDateRequest.class.getName();
    }
 else     if (isBigDecimalRequest(typeOracle,requestType)) {
      requestClassName=AbstractBigDecimalRequest.class.getName();
    }
 else     if (isBigIntegerRequest(typeOracle,requestType)) {
      requestClassName=AbstractBigIntegerRequest.class.getName();
    }
 else     if (isEnumRequest(typeOracle,requestType)) {
      requestClassName=AbstractEnumRequest.class.getName();
      enumArgument=""String_Node_Str"" + requestType.isParameterized().getTypeArgs()[0] + ""String_Node_Str"";
    }
 else     if (isVoidRequest(typeOracle,requestType)) {
      requestClassName=AbstractVoidRequest.class.getName();
    }
 else {
      logger.log(TreeLogger.ERROR,""String_Node_Str"" + requestType + ""String_Node_Str"");
      throw new UnableToCompleteException();
    }
    sw.println(getMethodDeclaration(method) + ""String_Node_Str"");
    sw.indent();
    sw.println(""String_Node_Str"" + requestClassName + ""String_Node_Str""+ enumArgument+ ""String_Node_Str"");
    sw.indent();
    String requestDataName=RequestData.class.getSimpleName();
    sw.println(""String_Node_Str"" + requestDataName + ""String_Node_Str"");
    sw.indent();
    sw.println(""String_Node_Str"" + requestDataName + ""String_Node_Str""+ operationName+ ""String_Node_Str""+ getParametersAsString(method,typeOracle)+ ""String_Node_Str""+ ""String_Node_Str"");
    sw.outdent();
    sw.println(""String_Node_Str"");
    sw.outdent();
    sw.println(""String_Node_Str"");
    sw.outdent();
    sw.println(""String_Node_Str"");
  }
  sw.outdent();
  sw.println(""String_Node_Str"");
  generatorContext.commit(logger,out);
}","private void generateRequestSelectorImplementation(TreeLogger logger,GeneratorContext generatorContext,PrintWriter out,JMethod selectorMethod,JClassType mainType,String packageName,String implName) throws UnableToCompleteException {
  JClassType selectorInterface=selectorMethod.getReturnType().isInterface();
  logger=logger.branch(TreeLogger.DEBUG,String.format(""String_Node_Str"",selectorInterface.getName()));
  ClassSourceFileComposerFactory f=new ClassSourceFileComposerFactory(packageName,implName);
  f.addImport(RequestData.class.getName());
  f.addImport(mainType.getQualifiedSourceName() + ""String_Node_Str"");
  f.addImplementedInterface(selectorInterface.getQualifiedSourceName());
  SourceWriter sw=f.createSourceWriter(generatorContext,out);
  sw.println();
  sw.println(""String_Node_Str"" + mainType.getName() + ""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"" + implName + ""String_Node_Str""+ mainType.getName()+ ""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  for (  JMethod method : selectorInterface.getOverridableMethods()) {
    JClassType returnType=method.getReturnType().isParameterized().getTypeArgs()[0];
    ensureProxyType(logger,generatorContext,returnType.getPackage().getName(),returnType);
    String operationName=selectorInterface.getQualifiedBinaryName() + ReflectionBasedOperationRegistry.SCOPE_SEPARATOR + method.getName();
    JClassType requestType=method.getReturnType().isClassOrInterface();
    String requestClassName=null;
    TypeOracle typeOracle=generatorContext.getTypeOracle();
    String enumOrFindArgument=""String_Node_Str"";
    if (isProxyListRequest(typeOracle,requestType)) {
      requestClassName=asInnerImplClass(""String_Node_Str"",returnType);
    }
 else     if (isProxyRequest(typeOracle,requestType)) {
      if (selectorInterface.isAssignableTo(typeOracle.findType(FindRequest.class.getName()))) {
        enumOrFindArgument=""String_Node_Str"";
        requestClassName=FindRequestObjectImpl.class.getName();
      }
 else {
        requestClassName=asInnerImplClass(""String_Node_Str"",returnType);
      }
    }
 else     if (isStringRequest(typeOracle,requestType)) {
      requestClassName=AbstractStringRequest.class.getName();
    }
 else     if (isLongRequest(typeOracle,requestType)) {
      requestClassName=AbstractLongRequest.class.getName();
    }
 else     if (isIntegerRequest(typeOracle,requestType)) {
      requestClassName=AbstractIntegerRequest.class.getName();
    }
 else     if (isDoubleRequest(typeOracle,requestType)) {
      requestClassName=AbstractDoubleRequest.class.getName();
    }
 else     if (isByteRequest(typeOracle,requestType)) {
      requestClassName=AbstractByteRequest.class.getName();
    }
 else     if (isBooleanRequest(typeOracle,requestType)) {
      requestClassName=AbstractBooleanRequest.class.getName();
    }
 else     if (isShortRequest(typeOracle,requestType)) {
      requestClassName=AbstractShortRequest.class.getName();
    }
 else     if (isFloatRequest(typeOracle,requestType)) {
      requestClassName=AbstractFloatRequest.class.getName();
    }
 else     if (isCharacterRequest(typeOracle,requestType)) {
      requestClassName=AbstractCharacterRequest.class.getName();
    }
 else     if (isDateRequest(typeOracle,requestType)) {
      requestClassName=AbstractDateRequest.class.getName();
    }
 else     if (isBigDecimalRequest(typeOracle,requestType)) {
      requestClassName=AbstractBigDecimalRequest.class.getName();
    }
 else     if (isBigIntegerRequest(typeOracle,requestType)) {
      requestClassName=AbstractBigIntegerRequest.class.getName();
    }
 else     if (isEnumRequest(typeOracle,requestType)) {
      requestClassName=AbstractEnumRequest.class.getName();
      enumOrFindArgument=""String_Node_Str"" + requestType.isParameterized().getTypeArgs()[0] + ""String_Node_Str"";
    }
 else     if (isVoidRequest(typeOracle,requestType)) {
      requestClassName=AbstractVoidRequest.class.getName();
    }
 else {
      logger.log(TreeLogger.ERROR,""String_Node_Str"" + requestType + ""String_Node_Str"");
      throw new UnableToCompleteException();
    }
    sw.println(getMethodDeclaration(method) + ""String_Node_Str"");
    sw.indent();
    sw.println(""String_Node_Str"" + requestClassName + ""String_Node_Str""+ enumOrFindArgument+ ""String_Node_Str"");
    sw.indent();
    String requestDataName=RequestData.class.getSimpleName();
    sw.println(""String_Node_Str"" + requestDataName + ""String_Node_Str"");
    sw.indent();
    sw.println(""String_Node_Str"" + requestDataName + ""String_Node_Str""+ operationName+ ""String_Node_Str""+ getParametersAsString(method,typeOracle)+ ""String_Node_Str""+ ""String_Node_Str"");
    sw.outdent();
    sw.println(""String_Node_Str"");
    sw.outdent();
    sw.println(""String_Node_Str"");
    sw.outdent();
    sw.println(""String_Node_Str"");
  }
  sw.outdent();
  sw.println(""String_Node_Str"");
  generatorContext.commit(logger,out);
}",0.9730729701952724
53985,"/** 
 * Returns the string representation of the parameters to be passed to the server side method.
 */
private String getParametersAsString(JMethod method,TypeOracle typeOracle){
  StringBuilder sb=new StringBuilder();
  for (  JParameter parameter : method.getParameters()) {
    if (sb.length() > 0) {
      sb.append(""String_Node_Str"");
    }
    JClassType classType=parameter.getType().isClassOrInterface();
    JType paramType=parameter.getType();
    JParameterizedType params=paramType.isParameterized();
    if (params != null) {
      classType=params.getTypeArgs()[0];
    }
    if (classType != null && classType.isAssignableTo(typeOracle.findType(EntityProxy.class.getName()))) {
      sb.append(""String_Node_Str"" + classType.getQualifiedBinaryName() + ""String_Node_Str""+ ""String_Node_Str"");
    }
    sb.append(parameter.getName());
    if (classType != null && classType.isAssignableTo(typeOracle.findType(EntityProxy.class.getName()))) {
      sb.append(""String_Node_Str"");
    }
  }
  return ""String_Node_Str"" + sb.toString() + ""String_Node_Str"";
}","/** 
 * Returns the string representation of the parameters to be passed to the server side method.
 */
private String getParametersAsString(JMethod method,TypeOracle typeOracle){
  StringBuilder sb=new StringBuilder();
  for (  JParameter parameter : method.getParameters()) {
    if (sb.length() > 0) {
      sb.append(""String_Node_Str"");
    }
    JClassType classType=parameter.getType().isClassOrInterface();
    JType paramType=parameter.getType();
    if (paramType.getQualifiedSourceName().equals(EntityProxyId.class.getName())) {
      sb.append(""String_Node_Str"" + parameter.getName() + ""String_Node_Str"");
      continue;
    }
    JParameterizedType params=paramType.isParameterized();
    if (params != null) {
      classType=params.getTypeArgs()[0];
    }
    if (classType != null && classType.isAssignableTo(typeOracle.findType(EntityProxy.class.getName()))) {
      sb.append(""String_Node_Str"" + classType.getQualifiedBinaryName() + ""String_Node_Str""+ ""String_Node_Str"");
    }
    sb.append(parameter.getName());
    if (classType != null && classType.isAssignableTo(typeOracle.findType(EntityProxy.class.getName()))) {
      sb.append(""String_Node_Str"");
    }
  }
  return ""String_Node_Str"" + sb.toString() + ""String_Node_Str"";
}",0.9205526770293608
53986,"private void ensureProxyType(TreeLogger logger,GeneratorContext generatorContext,String packageName,JClassType publicProxyType) throws UnableToCompleteException {
  TypeOracle typeOracle=generatorContext.getTypeOracle();
  if (!publicProxyType.isAssignableTo(typeOracle.findType(EntityProxy.class.getName()))) {
    return;
  }
  if (generatedProxyTypes.contains(publicProxyType)) {
    return;
  }
  String proxyImplTypeName=publicProxyType.getName() + ""String_Node_Str"";
  PrintWriter pw=generatorContext.tryCreate(logger,packageName,proxyImplTypeName);
  Set<JClassType> transitiveDeps=new LinkedHashSet<JClassType>();
  if (pw != null) {
    logger=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + publicProxyType.getName());
    ClassSourceFileComposerFactory f=new ClassSourceFileComposerFactory(packageName,proxyImplTypeName);
    f.addImport(AbstractJsonListRequest.class.getName());
    f.addImport(AbstractJsonObjectRequest.class.getName());
    f.addImport(RequestFactoryJsonImpl.class.getName());
    f.addImport(Property.class.getName());
    f.addImport(EnumProperty.class.getName());
    f.addImport(EntityProxy.class.getName());
    f.addImport(ProxyImpl.class.getName());
    f.addImport(ProxyJsoImpl.class.getName());
    f.addImport(ProxySchema.class.getName());
    f.addImport(WriteOperation.class.getName().replace(""String_Node_Str"",""String_Node_Str""));
    f.addImport(Collections.class.getName());
    f.addImport(HashSet.class.getName());
    f.addImport(Set.class.getName());
    f.setSuperclass(ProxyImpl.class.getSimpleName());
    f.addImplementedInterface(publicProxyType.getName());
    List<EntityProperty> entityProperties=computeEntityPropertiesFromProxyType(publicProxyType);
    for (    EntityProperty entityProperty : entityProperties) {
      JType type=entityProperty.getType();
      if (type.isPrimitive() == null) {
        f.addImport(type.getErasedType().getQualifiedSourceName());
      }
    }
    SourceWriter sw=f.createSourceWriter(generatorContext,pw);
    sw.println();
    for (    EntityProperty entityProperty : entityProperties) {
      sw.println();
      String name=entityProperty.getName();
      if (entityProperty.getType().isEnum() != null) {
        sw.println(String.format(""String_Node_Str"",entityProperty.getType().getSimpleSourceName(),name));
      }
 else {
        sw.println(String.format(""String_Node_Str"",entityProperty.getType().getSimpleSourceName(),name,capitalize(name)));
      }
    }
    printSchema(typeOracle,publicProxyType,proxyImplTypeName,sw);
    sw.println();
    String simpleImplName=publicProxyType.getSimpleSourceName() + ""String_Node_Str"";
    printRequestImplClass(sw,publicProxyType,simpleImplName,true);
    printRequestImplClass(sw,publicProxyType,simpleImplName,false);
    sw.println();
    sw.println(String.format(""String_Node_Str"",proxyImplTypeName));
    sw.println();
    sw.println(String.format(""String_Node_Str"",proxyImplTypeName));
    sw.indent();
    sw.println(""String_Node_Str"");
    sw.outdent();
    sw.println(""String_Node_Str"");
    for (    EntityProperty entityProperty : entityProperties) {
      JClassType returnType=entityProperty.getType().isClassOrInterface();
      sw.println();
      sw.println(String.format(""String_Node_Str"",returnType.getQualifiedSourceName(),capitalize(entityProperty.getName())));
      sw.indent();
      sw.println(String.format(""String_Node_Str"",entityProperty.getName()));
      sw.outdent();
      sw.println(""String_Node_Str"");
      if (isProxyType(typeOracle,returnType)) {
        transitiveDeps.add(returnType);
      }
    }
    for (    EntityProperty entityProperty : entityProperties) {
      JClassType returnType=entityProperty.getType().isClassOrInterface();
      sw.println();
      String varName=entityProperty.getName();
      sw.println(String.format(""String_Node_Str"",capitalize(varName),returnType.getQualifiedSourceName(),varName));
      sw.indent();
      sw.println(String.format(""String_Node_Str"",varName,varName));
      sw.outdent();
      sw.println(""String_Node_Str"");
    }
    sw.outdent();
    sw.println(""String_Node_Str"");
    generatorContext.commit(logger,pw);
  }
  generatedProxyTypes.add(publicProxyType);
  for (  JClassType type : transitiveDeps) {
    ensureProxyType(logger,generatorContext,type.getPackage().getName(),type);
  }
}","private void ensureProxyType(TreeLogger logger,GeneratorContext generatorContext,String packageName,JClassType publicProxyType) throws UnableToCompleteException {
  TypeOracle typeOracle=generatorContext.getTypeOracle();
  JClassType entityProxyClass=typeOracle.findType(EntityProxy.class.getName());
  if (!publicProxyType.isAssignableTo(entityProxyClass)) {
    return;
  }
  if (publicProxyType.equals(entityProxyClass)) {
    return;
  }
  if (generatedProxyTypes.contains(publicProxyType)) {
    return;
  }
  String proxyImplTypeName=publicProxyType.getName() + ""String_Node_Str"";
  PrintWriter pw=generatorContext.tryCreate(logger,packageName,proxyImplTypeName);
  Set<JClassType> transitiveDeps=new LinkedHashSet<JClassType>();
  if (pw != null) {
    logger=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + publicProxyType.getName());
    ClassSourceFileComposerFactory f=new ClassSourceFileComposerFactory(packageName,proxyImplTypeName);
    f.addImport(AbstractJsonListRequest.class.getName());
    f.addImport(AbstractJsonObjectRequest.class.getName());
    f.addImport(RequestFactoryJsonImpl.class.getName());
    f.addImport(Property.class.getName());
    f.addImport(EnumProperty.class.getName());
    f.addImport(EntityProxy.class.getName());
    f.addImport(ProxyImpl.class.getName());
    f.addImport(ProxyJsoImpl.class.getName());
    f.addImport(ProxySchema.class.getName());
    f.addImport(WriteOperation.class.getName().replace(""String_Node_Str"",""String_Node_Str""));
    f.addImport(Collections.class.getName());
    f.addImport(HashSet.class.getName());
    f.addImport(Set.class.getName());
    f.setSuperclass(ProxyImpl.class.getSimpleName());
    f.addImplementedInterface(publicProxyType.getName());
    List<EntityProperty> entityProperties=computeEntityPropertiesFromProxyType(publicProxyType);
    for (    EntityProperty entityProperty : entityProperties) {
      JType type=entityProperty.getType();
      if (type.isPrimitive() == null) {
        f.addImport(type.getErasedType().getQualifiedSourceName());
      }
    }
    SourceWriter sw=f.createSourceWriter(generatorContext,pw);
    sw.println();
    for (    EntityProperty entityProperty : entityProperties) {
      sw.println();
      String name=entityProperty.getName();
      if (entityProperty.getType().isEnum() != null) {
        sw.println(String.format(""String_Node_Str"",entityProperty.getType().getSimpleSourceName(),name));
      }
 else {
        sw.println(String.format(""String_Node_Str"",entityProperty.getType().getSimpleSourceName(),name,capitalize(name)));
      }
    }
    printSchema(typeOracle,publicProxyType,proxyImplTypeName,sw);
    sw.println();
    String simpleImplName=publicProxyType.getSimpleSourceName() + ""String_Node_Str"";
    printRequestImplClass(sw,publicProxyType,simpleImplName,true);
    printRequestImplClass(sw,publicProxyType,simpleImplName,false);
    sw.println();
    sw.println(String.format(""String_Node_Str"",proxyImplTypeName));
    sw.println();
    sw.println(String.format(""String_Node_Str"",proxyImplTypeName));
    sw.indent();
    sw.println(""String_Node_Str"");
    sw.outdent();
    sw.println(""String_Node_Str"");
    for (    EntityProperty entityProperty : entityProperties) {
      JClassType returnType=entityProperty.getType().isClassOrInterface();
      sw.println();
      sw.println(String.format(""String_Node_Str"",returnType.getQualifiedSourceName(),capitalize(entityProperty.getName())));
      sw.indent();
      sw.println(String.format(""String_Node_Str"",entityProperty.getName()));
      sw.outdent();
      sw.println(""String_Node_Str"");
      if (isProxyType(typeOracle,returnType)) {
        transitiveDeps.add(returnType);
      }
    }
    for (    EntityProperty entityProperty : entityProperties) {
      JClassType returnType=entityProperty.getType().isClassOrInterface();
      sw.println();
      String varName=entityProperty.getName();
      sw.println(String.format(""String_Node_Str"",capitalize(varName),returnType.getQualifiedSourceName(),varName));
      sw.indent();
      sw.println(String.format(""String_Node_Str"",varName,varName));
      sw.outdent();
      sw.println(""String_Node_Str"");
    }
    sw.outdent();
    sw.println(""String_Node_Str"");
    generatorContext.commit(logger,pw);
  }
  generatedProxyTypes.add(publicProxyType);
  for (  JClassType type : transitiveDeps) {
    ensureProxyType(logger,generatorContext,type.getPackage().getName(),type);
  }
}",0.9783500455788514
53987,"private void generateOnce(JClassType requestFactoryType,TreeLogger logger,GeneratorContext generatorContext,PrintWriter out,JClassType interfaceType,String packageName,String implName) throws UnableToCompleteException {
  logger=logger.branch(TreeLogger.DEBUG,String.format(""String_Node_Str"",interfaceType.getName()));
  ClassSourceFileComposerFactory f=new ClassSourceFileComposerFactory(packageName,implName);
  f.addImport(HandlerManager.class.getName());
  f.addImport(RequestFactoryJsonImpl.class.getName());
  f.addImport(interfaceType.getQualifiedSourceName());
  f.addImport(ProxyToTypeMap.class.getName());
  f.addImport(EntityProxy.class.getName());
  f.addImport(ProxySchema.class.getName());
  f.addImplementedInterface(interfaceType.getName());
  f.setSuperclass(RequestFactoryJsonImpl.class.getSimpleName());
  SourceWriter sw=f.createSourceWriter(generatorContext,out);
  sw.println();
  Set<JMethod> requestSelectors=new LinkedHashSet<JMethod>();
  for (  JMethod method : interfaceType.getOverridableMethods()) {
    if (method.getEnclosingType().equals(requestFactoryType)) {
      continue;
    }
    JType returnType=method.getReturnType();
    if (null == returnType) {
      logger.log(TreeLogger.ERROR,String.format(""String_Node_Str"",method.getName(),interfaceType.getName()));
      throw new UnableToCompleteException();
    }
    JClassType asInterface=returnType.isInterface();
    if (null == asInterface) {
      logger.log(TreeLogger.ERROR,String.format(""String_Node_Str"",method.getName(),interfaceType.getName()));
      throw new UnableToCompleteException();
    }
    requestSelectors.add(method);
  }
  JClassType proxyToTypeInterface=generatorContext.getTypeOracle().findType(ProxyToTypeMap.class.getName());
  String proxyToTypeMapName=proxyToTypeInterface.getName() + ""String_Node_Str"";
  sw.println(""String_Node_Str"" + EntityProxy.class.getName() + ""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"" + EntityProxy.class.getName() + ""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"" + EntityProxy.class.getName() + ""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"" + EntityProxyId.class.getName() + ""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  for (  JMethod requestSelector : requestSelectors) {
    String returnTypeName=requestSelector.getReturnType().getQualifiedSourceName();
    String nestedImplName=capitalize(requestSelector.getName().replace('.','_')) + ""String_Node_Str"";
    String nestedImplPackage=generatorContext.getTypeOracle().findType(returnTypeName).getPackage().getName();
    sw.println(""String_Node_Str"" + returnTypeName + ""String_Node_Str""+ requestSelector.getName()+ ""String_Node_Str"");
    sw.indent();
    sw.println(""String_Node_Str"" + nestedImplPackage + ""String_Node_Str""+ nestedImplName+ ""String_Node_Str"");
    sw.outdent();
    sw.println(""String_Node_Str"");
    sw.println();
    PrintWriter pw=generatorContext.tryCreate(logger,nestedImplPackage,nestedImplName);
    if (pw != null) {
      generateRequestSelectorImplementation(logger,generatorContext,pw,requestSelector,interfaceType,nestedImplPackage,nestedImplName);
    }
  }
  sw.outdent();
  sw.println(""String_Node_Str"");
  PrintWriter pw=generatorContext.tryCreate(logger,packageName,proxyToTypeMapName);
  if (pw != null) {
    generateProxyToTypeMap(logger,generatorContext,pw,proxyToTypeInterface,packageName,proxyToTypeMapName);
  }
  generatorContext.commit(logger,out);
}","private void generateOnce(JClassType requestFactoryType,TreeLogger logger,GeneratorContext generatorContext,PrintWriter out,JClassType interfaceType,String packageName,String implName) throws UnableToCompleteException {
  logger=logger.branch(TreeLogger.DEBUG,String.format(""String_Node_Str"",interfaceType.getName()));
  ClassSourceFileComposerFactory f=new ClassSourceFileComposerFactory(packageName,implName);
  f.addImport(HandlerManager.class.getName());
  f.addImport(RequestFactoryJsonImpl.class.getName());
  f.addImport(interfaceType.getQualifiedSourceName());
  f.addImport(ProxyToTypeMap.class.getName());
  f.addImport(EntityProxy.class.getName());
  f.addImport(ProxySchema.class.getName());
  f.addImplementedInterface(interfaceType.getName());
  f.setSuperclass(RequestFactoryJsonImpl.class.getSimpleName());
  SourceWriter sw=f.createSourceWriter(generatorContext,out);
  sw.println();
  Set<JMethod> requestSelectors=new LinkedHashSet<JMethod>();
  for (  JMethod method : interfaceType.getOverridableMethods()) {
    if (method.getEnclosingType().equals(requestFactoryType)) {
      continue;
    }
    JType returnType=method.getReturnType();
    if (null == returnType) {
      logger.log(TreeLogger.ERROR,String.format(""String_Node_Str"",method.getName(),interfaceType.getName()));
      throw new UnableToCompleteException();
    }
    JClassType asInterface=returnType.isInterface();
    if (null == asInterface) {
      logger.log(TreeLogger.ERROR,String.format(""String_Node_Str"",method.getName(),interfaceType.getName()));
      throw new UnableToCompleteException();
    }
    requestSelectors.add(method);
  }
  JClassType t=generatorContext.getTypeOracle().findType(RequestFactoryJsonImpl.class.getName());
  try {
    requestSelectors.add(t.getMethod(""String_Node_Str"",new JType[0]));
  }
 catch (  NotFoundException e) {
    e.printStackTrace();
  }
  JClassType proxyToTypeInterface=generatorContext.getTypeOracle().findType(ProxyToTypeMap.class.getName());
  String proxyToTypeMapName=proxyToTypeInterface.getName() + ""String_Node_Str"";
  sw.println(""String_Node_Str"" + EntityProxy.class.getName() + ""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"" + EntityProxy.class.getName() + ""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"" + EntityProxy.class.getName() + ""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"" + EntityProxyId.class.getName() + ""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  for (  JMethod requestSelector : requestSelectors) {
    String returnTypeName=requestSelector.getReturnType().getQualifiedSourceName();
    String nestedImplName=capitalize(requestSelector.getName().replace('.','_')) + ""String_Node_Str"";
    String nestedImplPackage=generatorContext.getTypeOracle().findType(returnTypeName).getPackage().getName();
    sw.println(""String_Node_Str"" + returnTypeName + ""String_Node_Str""+ requestSelector.getName()+ ""String_Node_Str"");
    sw.indent();
    sw.println(""String_Node_Str"" + nestedImplPackage + ""String_Node_Str""+ nestedImplName+ ""String_Node_Str"");
    sw.outdent();
    sw.println(""String_Node_Str"");
    sw.println();
    PrintWriter pw=generatorContext.tryCreate(logger,nestedImplPackage,nestedImplName);
    if (pw != null) {
      generateRequestSelectorImplementation(logger,generatorContext,pw,requestSelector,interfaceType,nestedImplPackage,nestedImplName);
    }
  }
  sw.outdent();
  sw.println(""String_Node_Str"");
  PrintWriter pw=generatorContext.tryCreate(logger,packageName,proxyToTypeMapName);
  if (pw != null) {
    generateProxyToTypeMap(logger,generatorContext,pw,proxyToTypeInterface,packageName,proxyToTypeMapName);
  }
  generatorContext.commit(logger,out);
}",0.9739800835207196
53988,"public void onModuleLoad(){
  GWT.setUncaughtExceptionHandler(new GWT.UncaughtExceptionHandler(){
    public void onUncaughtException(    Throwable e){
      Window.alert(""String_Node_Str"" + e.getMessage());
    }
  }
);
  final EventBus eventBus=new SimpleEventBus();
  requestFactory=GWT.create(ExpensesRequestFactory.class);
  requestFactory.init(eventBus);
  RootLayoutPanel root=RootLayoutPanel.get();
  shell=new ExpensesShell();
  final ExpenseTree expenseTree=shell.getExpenseTree();
  final ExpenseList expenseList=shell.getExpenseList();
  final ExpenseDetails expenseDetails=shell.getExpenseDetails();
  root.add(shell);
  RequestEvent.register(eventBus,new AuthenticationFailureHandler());
  final LoginWidget login=shell.getLoginWidget();
  Receiver<UserInformationProxy> receiver=new Receiver<UserInformationProxy>(){
    public void onSuccess(    UserInformationProxy userInformationRecord,    Set<SyncResult> syncResults){
      login.setUserInformation(userInformationRecord);
    }
  }
;
  requestFactory.userInformationRequest().getCurrentUserInformation(Location.getHref()).fire(receiver);
  expenseTree.setListener(new ExpenseTree.Listener(){
    public void onSelection(    String department,    EmployeeProxy employee){
      lastDepartment=department;
      lastEmployee=employee;
      expenseList.setEmployee(department,employee);
      shell.showExpenseDetails(false);
    }
  }
);
  expenseTree.setRequestFactory(requestFactory);
  expenseList.setListener(new ExpenseList.Listener(){
    public void onReportSelected(    ReportProxy report){
      expenseDetails.setExpensesRequestFactory(requestFactory);
      expenseDetails.setReportRecord(report,lastDepartment,lastEmployee);
      shell.showExpenseDetails(true);
    }
  }
);
  expenseList.init(requestFactory,eventBus);
  expenseDetails.init(eventBus);
}","public void onModuleLoad(){
  GWT.setUncaughtExceptionHandler(new GWT.UncaughtExceptionHandler(){
    public void onUncaughtException(    Throwable e){
      Window.alert(""String_Node_Str"" + e.getMessage());
    }
  }
);
  final EventBus eventBus=new SimpleEventBus();
  requestFactory=GWT.create(ExpensesRequestFactory.class);
  requestFactory.init(eventBus);
  RootLayoutPanel root=RootLayoutPanel.get();
  shell=new ExpensesShell();
  final ExpenseTree expenseTree=shell.getExpenseTree();
  final ExpenseList expenseList=shell.getExpenseList();
  final ExpenseDetails expenseDetails=shell.getExpenseDetails();
  root.add(shell);
  RequestEvent.register(eventBus,new AuthenticationFailureHandler());
  final LoginWidget login=shell.getLoginWidget();
  Receiver<UserInformationProxy> receiver=new Receiver<UserInformationProxy>(){
    @Override public void onSuccess(    UserInformationProxy userInformationRecord,    Set<SyncResult> syncResults){
      login.setUserInformation(userInformationRecord);
    }
  }
;
  requestFactory.userInformationRequest().getCurrentUserInformation(Location.getHref()).fire(receiver);
  expenseTree.setListener(new ExpenseTree.Listener(){
    public void onSelection(    String department,    EmployeeProxy employee){
      lastDepartment=department;
      lastEmployee=employee;
      expenseList.setEmployee(department,employee);
      shell.showExpenseDetails(false);
    }
  }
);
  expenseTree.setRequestFactory(requestFactory);
  expenseList.setListener(new ExpenseList.Listener(){
    public void onReportSelected(    ReportProxy report){
      expenseDetails.setExpensesRequestFactory(requestFactory);
      expenseDetails.setReportRecord(report,lastDepartment,lastEmployee);
      shell.showExpenseDetails(true);
    }
  }
);
  expenseList.init(requestFactory,eventBus);
  expenseDetails.init(eventBus);
}",0.9972870320130224
53989,"public void onSuccess(UserInformationProxy userInformationRecord,Set<SyncResult> syncResults){
  login.setUserInformation(userInformationRecord);
}","@Override public void onSuccess(UserInformationProxy userInformationRecord,Set<SyncResult> syncResults){
  login.setUserInformation(userInformationRecord);
}",0.9671052631578948
53990,"/** 
 * This is the entry point method.
 */
public void onModuleLoad(){
  GWT.setUncaughtExceptionHandler(new GWT.UncaughtExceptionHandler(){
    public void onUncaughtException(    Throwable e){
      Window.alert(""String_Node_Str"" + e.getMessage());
    }
  }
);
  long employeeId=1;
  try {
    String value=Window.Location.getParameter(EMPLOYEE_ID_PARAM);
    if (value != null && value.length() > 0) {
      employeeId=Long.parseLong(value);
    }
  }
 catch (  NumberFormatException e) {
    RootPanel.get().add(new Label(""String_Node_Str""));
    return;
  }
  final EventBus eventBus=new SimpleEventBus();
  final ExpensesRequestFactory requestFactory=GWT.create(ExpensesRequestFactory.class);
  requestFactory.init(eventBus);
  requestFactory.employeeRequest().findEmployee(employeeId).fire(new Receiver<EmployeeProxy>(){
    public void onSuccess(    EmployeeProxy employee,    Set<SyncResult> syncResults){
      final ExpensesMobileShell shell=new ExpensesMobileShell(eventBus,requestFactory,employee);
      RootPanel.get().add(shell);
      RequestEvent.register(eventBus,new AuthenticationFailureHandler());
      final LoginWidget login=shell.getLoginWidget();
      Receiver<UserInformationProxy> receiver=new Receiver<UserInformationProxy>(){
        public void onSuccess(        UserInformationProxy userInformationRecord,        Set<SyncResult> syncResults){
          login.setUserInformation(userInformationRecord);
        }
      }
;
      requestFactory.userInformationRequest().getCurrentUserInformation(Location.getHref()).fire(receiver);
    }
  }
);
}","/** 
 * This is the entry point method.
 */
public void onModuleLoad(){
  GWT.setUncaughtExceptionHandler(new GWT.UncaughtExceptionHandler(){
    public void onUncaughtException(    Throwable e){
      Window.alert(""String_Node_Str"" + e.getMessage());
    }
  }
);
  long employeeId=1;
  try {
    String value=Window.Location.getParameter(EMPLOYEE_ID_PARAM);
    if (value != null && value.length() > 0) {
      employeeId=Long.parseLong(value);
    }
  }
 catch (  NumberFormatException e) {
    RootPanel.get().add(new Label(""String_Node_Str""));
    return;
  }
  final EventBus eventBus=new SimpleEventBus();
  final ExpensesRequestFactory requestFactory=GWT.create(ExpensesRequestFactory.class);
  requestFactory.init(eventBus);
  requestFactory.employeeRequest().findEmployee(employeeId).fire(new Receiver<EmployeeProxy>(){
    @Override public void onSuccess(    EmployeeProxy employee,    Set<SyncResult> syncResults){
      final ExpensesMobileShell shell=new ExpensesMobileShell(eventBus,requestFactory,employee);
      RootPanel.get().add(shell);
      RequestEvent.register(eventBus,new AuthenticationFailureHandler());
      final LoginWidget login=shell.getLoginWidget();
      Receiver<UserInformationProxy> receiver=new Receiver<UserInformationProxy>(){
        @Override public void onSuccess(        UserInformationProxy userInformationRecord,        Set<SyncResult> syncResults){
          login.setUserInformation(userInformationRecord);
        }
      }
;
      requestFactory.userInformationRequest().getCurrentUserInformation(Location.getHref()).fire(receiver);
    }
  }
);
}",0.9937106918238994
53991,"public void onSuccess(UserInformationProxy userInformationRecord,Set<SyncResult> syncResults){
  login.setUserInformation(userInformationRecord);
}","@Override public void onSuccess(UserInformationProxy userInformationRecord,Set<SyncResult> syncResults){
  login.setUserInformation(userInformationRecord);
}",0.9671052631578948
53992,"public Widget asWidget(){
  return this;
}","@Override public Widget asWidget(){
  return this;
}",0.8936170212765957
53993,"@SuppressWarnings(""String_Node_Str"") public void onCustom(){
  ExpenseProxy editableExpense=requestObject.edit(expense);
  editableExpense.setDescription(nameText.getText());
  editableExpense.setCategory(categoryText.getText());
  String amountText=priceText.getText();
  double amount=Double.parseDouble(amountText);
  editableExpense.setAmount(amount);
  Date date=new Date(dateYear.getSelectedIndex() + 100,dateMonth.getSelectedIndex(),dateDay.getSelectedIndex() + 1);
  editableExpense.setCreated(date);
  requestObject.fire(new Receiver<Void>(){
    public void onSuccess(    Void ignore,    Set<SyncResult> response){
      String errorMessage=""String_Node_Str"";
      if (errorMessage.length() > 0) {
        errorText.setInnerText(errorMessage);
      }
 else {
        listener.onExpenseUpdated();
      }
    }
  }
);
}","@SuppressWarnings(""String_Node_Str"") public void onCustom(){
  ExpenseProxy editableExpense=requestObject.edit(expense);
  editableExpense.setDescription(nameText.getText());
  editableExpense.setCategory(categoryText.getText());
  String amountText=priceText.getText();
  double amount=Double.parseDouble(amountText);
  editableExpense.setAmount(amount);
  Date date=new Date(dateYear.getSelectedIndex() + 100,dateMonth.getSelectedIndex(),dateDay.getSelectedIndex() + 1);
  editableExpense.setCreated(date);
  requestObject.fire(new Receiver<Void>(){
    @Override public void onSuccess(    Void ignore,    Set<SyncResult> response){
      String errorMessage=""String_Node_Str"";
      if (errorMessage.length() > 0) {
        errorText.setInnerText(errorMessage);
      }
 else {
        listener.onExpenseUpdated();
      }
    }
  }
);
}",0.994011976047904
53994,"public Widget asWidget(){
  return this;
}","@Override public Widget asWidget(){
  return this;
}",0.8936170212765957
53995,"public void onSuccess(Void ignore,Set<SyncResult> response){
  String errorMessage=""String_Node_Str"";
  if (errorMessage.length() > 0) {
    errorText.setInnerText(errorMessage);
  }
 else {
    listener.onExpenseUpdated();
  }
}","@Override public void onSuccess(Void ignore,Set<SyncResult> response){
  String errorMessage=""String_Node_Str"";
  if (errorMessage.length() > 0) {
    errorText.setInnerText(errorMessage);
  }
 else {
    listener.onExpenseUpdated();
  }
}",0.9786324786324786
53996,"@SuppressWarnings(""String_Node_Str"") public void onCustom(){
  ReportProxy editableReport=requestObject.edit(report);
  editableReport.setPurpose(purposeText.getText());
  editableReport.setNotes(notesText.getText());
  editableReport.setDepartment(departmentList.getValue(departmentList.getSelectedIndex()));
  Date date=new Date(dateYear.getSelectedIndex() + 100,dateMonth.getSelectedIndex(),dateDay.getSelectedIndex() + 1);
  editableReport.setCreated(date);
  requestObject.fire(new Receiver<Void>(){
    public void onSuccess(    Void ignore,    Set<SyncResult> response){
      String errorMessage=""String_Node_Str"";
      if (errorMessage.length() > 0) {
        errorText.setInnerText(errorMessage);
      }
 else {
        listener.onReportUpdated();
      }
    }
  }
);
}","@SuppressWarnings(""String_Node_Str"") public void onCustom(){
  ReportProxy editableReport=requestObject.edit(report);
  editableReport.setPurpose(purposeText.getText());
  editableReport.setNotes(notesText.getText());
  editableReport.setDepartment(departmentList.getValue(departmentList.getSelectedIndex()));
  Date date=new Date(dateYear.getSelectedIndex() + 100,dateMonth.getSelectedIndex(),dateDay.getSelectedIndex() + 1);
  editableReport.setCreated(date);
  requestObject.fire(new Receiver<Void>(){
    @Override public void onSuccess(    Void ignore,    Set<SyncResult> response){
      String errorMessage=""String_Node_Str"";
      if (errorMessage.length() > 0) {
        errorText.setInnerText(errorMessage);
      }
 else {
        listener.onReportUpdated();
      }
    }
  }
);
}",0.9936467598475224
53997,"public Widget asWidget(){
  return this;
}","@Override public Widget asWidget(){
  return this;
}",0.8936170212765957
53998,"public void onSuccess(Void ignore,Set<SyncResult> response){
  String errorMessage=""String_Node_Str"";
  if (errorMessage.length() > 0) {
    errorText.setInnerText(errorMessage);
  }
 else {
    listener.onReportUpdated();
  }
}","@Override public void onSuccess(Void ignore,Set<SyncResult> response){
  String errorMessage=""String_Node_Str"";
  if (errorMessage.length() > 0) {
    errorText.setInnerText(errorMessage);
  }
 else {
    listener.onReportUpdated();
  }
}",0.9785407725321889
53999,"public Widget asWidget(){
  return this;
}","@Override public Widget asWidget(){
  return this;
}",0.8936170212765957
54000,"public EmployeeEditView asWidget(){
  return this;
}","@Override public EmployeeEditView asWidget(){
  return this;
}",0.912280701754386
