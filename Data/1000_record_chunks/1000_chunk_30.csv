record_number,buggy_code,fixed_code,code_similarity
29001,"/** 
 * Called when deleting an event chunk from event table
 * @param deletingEventChunk Event list for deletion
 * @param operator           Operator that perform RDBMS related operations
 */
@Override public void delete(ComplexEventChunk deletingEventChunk,Operator operator){
  operator.delete(deletingEventChunk,null);
  if (isCachingEnabled) {
    ((RDBMSOperator)operator).getInMemoryEventTableOperator().delete(deletingEventChunk,cachedTable.getCacheList());
  }
}","/** 
 * Called when deleting an event chunk from event table
 * @param deletingEventChunk Event list for deletion
 * @param operator           Operator that perform RDBMS related operations
 */
@Override public synchronized void delete(ComplexEventChunk deletingEventChunk,Operator operator){
  operator.delete(deletingEventChunk,null);
  if (isCachingEnabled) {
    ((RDBMSOperator)operator).getInMemoryEventTableOperator().delete(deletingEventChunk,cachedTable.getCacheList());
  }
}",0.9864158829676072
29002,"@Override public void overwriteOrAdd(ComplexEventChunk overwritingOrAddingEventChunk,Operator operator,int[] mappingPosition){
  if (indexAttribute != null) {
    operator.overwriteOrAdd(overwritingOrAddingEventChunk,eventsMap,mappingPosition);
  }
 else {
    operator.overwriteOrAdd(overwritingOrAddingEventChunk,eventsList,mappingPosition);
  }
}","@Override public void overwriteOrAdd(ComplexEventChunk overwritingOrAddingEventChunk,Operator operator,int[] mappingPosition){
  try {
    readWriteLock.writeLock().lock();
    if (indexAttribute != null) {
      operator.overwriteOrAdd(overwritingOrAddingEventChunk,eventsMap,mappingPosition);
    }
 else {
      operator.overwriteOrAdd(overwritingOrAddingEventChunk,eventsList,mappingPosition);
    }
  }
  finally {
    readWriteLock.writeLock().unlock();
  }
}",0.8574938574938575
29003,"/** 
 * Called when insert or overwriting the event table entries.
 * @param overwritingOrAddingEventChunk Event list that needs to be inserted or updated.
 * @param operator                      Operator that perform Hazelcast related operations.
 */
@Override public void overwriteOrAdd(ComplexEventChunk overwritingOrAddingEventChunk,Operator operator,int[] mappingPosition){
  if (indexAttribute != null) {
    operator.overwriteOrAdd(overwritingOrAddingEventChunk,eventsMap,mappingPosition);
  }
 else {
    operator.overwriteOrAdd(overwritingOrAddingEventChunk,eventsList,mappingPosition);
  }
}","/** 
 * Called when insert or overwriting the event table entries.
 * @param overwritingOrAddingEventChunk Event list that needs to be inserted or updated.
 * @param operator                      Operator that perform Hazelcast related operations.
 */
@Override public synchronized void overwriteOrAdd(ComplexEventChunk overwritingOrAddingEventChunk,Operator operator,int[] mappingPosition){
  if (indexAttribute != null) {
    operator.overwriteOrAdd(overwritingOrAddingEventChunk,eventsMap,mappingPosition);
  }
 else {
    operator.overwriteOrAdd(overwritingOrAddingEventChunk,eventsList,mappingPosition);
  }
}",0.9893004115226336
29004,"/** 
 * Called when having ""in"" condition, to check the existence of the event
 * @param matchingEvent Event that need to be check for existence
 * @param finder        Operator that perform RDBMS related search
 */
@Override public boolean contains(ComplexEvent matchingEvent,Finder finder){
  if (isCachingEnabled) {
    return ((RDBMSOperator)finder).getInMemoryEventTableOperator().contains(matchingEvent,cachedTable.getCacheList()) || finder.contains(matchingEvent,null);
  }
  return finder.contains(matchingEvent,null);
}","/** 
 * Called when having ""in"" condition, to check the existence of the event
 * @param matchingEvent Event that need to be check for existence
 * @param finder        Operator that perform RDBMS related search
 */
@Override public synchronized boolean contains(ComplexEvent matchingEvent,Finder finder){
  if (isCachingEnabled) {
    return ((RDBMSOperator)finder).getInMemoryEventTableOperator().contains(matchingEvent,cachedTable.getCacheList()) || finder.contains(matchingEvent,null);
  }
  return finder.contains(matchingEvent,null);
}",0.9878391019644528
29005,"@Override public void overwriteOrAdd(ComplexEventChunk overwritingOrAddingEventChunk,Operator operator,int[] mappingPosition){
  operator.overwriteOrAdd(overwritingOrAddingEventChunk,null,null);
  if (isCachingEnabled) {
    ((RDBMSOperator)operator).getInMemoryEventTableOperator().overwriteOrAdd(overwritingOrAddingEventChunk,cachedTable.getCacheList(),mappingPosition);
  }
}","@Override public synchronized void overwriteOrAdd(ComplexEventChunk overwritingOrAddingEventChunk,Operator operator,int[] mappingPosition){
  operator.overwriteOrAdd(overwritingOrAddingEventChunk,null,null);
  if (isCachingEnabled) {
    ((RDBMSOperator)operator).getInMemoryEventTableOperator().overwriteOrAdd(overwritingOrAddingEventChunk,cachedTable.getCacheList(),mappingPosition);
  }
}",0.9830949284785436
29006,"/** 
 * Called to find a event from event table
 */
@Override public StreamEvent find(ComplexEvent matchingEvent,Finder finder){
  return finder.find(matchingEvent,null,null);
}","/** 
 * Called to find a event from event table
 */
@Override public synchronized StreamEvent find(ComplexEvent matchingEvent,Finder finder){
  return finder.find(matchingEvent,null,null);
}",0.9645776566757494
29007,"/** 
 * Called when updating the event table entries
 * @param updatingEventChunk Event list that needs to be updated
 * @param operator           Operator that perform RDBMS related operations
 */
@Override public void update(ComplexEventChunk updatingEventChunk,Operator operator,int[] mappingPosition){
  operator.update(updatingEventChunk,null,null);
  if (isCachingEnabled) {
    ((RDBMSOperator)operator).getInMemoryEventTableOperator().update(updatingEventChunk,cachedTable.getCacheList(),mappingPosition);
  }
}","/** 
 * Called when updating the event table entries
 * @param updatingEventChunk Event list that needs to be updated
 * @param operator           Operator that perform RDBMS related operations
 */
@Override public synchronized void update(ComplexEventChunk updatingEventChunk,Operator operator,int[] mappingPosition){
  operator.update(updatingEventChunk,null,null);
  if (isCachingEnabled) {
    ((RDBMSOperator)operator).getInMemoryEventTableOperator().update(updatingEventChunk,cachedTable.getCacheList(),mappingPosition);
  }
}",0.9876308277830638
29008,"/** 
 * Called when deleting an event chunk from event table
 * @param deletingEventChunk Event list for deletion
 * @param operator           Operator that perform RDBMS related operations
 */
@Override public void delete(ComplexEventChunk deletingEventChunk,Operator operator){
  operator.delete(deletingEventChunk,null);
  if (isCachingEnabled) {
    ((RDBMSOperator)operator).getInMemoryEventTableOperator().delete(deletingEventChunk,cachedTable.getCacheList());
  }
}","/** 
 * Called when deleting an event chunk from event table
 * @param deletingEventChunk Event list for deletion
 * @param operator           Operator that perform RDBMS related operations
 */
@Override public synchronized void delete(ComplexEventChunk deletingEventChunk,Operator operator){
  operator.delete(deletingEventChunk,null);
  if (isCachingEnabled) {
    ((RDBMSOperator)operator).getInMemoryEventTableOperator().delete(deletingEventChunk,cachedTable.getCacheList());
  }
}",0.9864158829676072
29009,"@Override public void receive(long timeStamp,Object[] data){
synchronized (lockKey) {
    stabilizeStates();
    for (    int anEventSequence : eventSequence) {
      StreamEventConverter aStreamEventConverter=streamEventConverters[anEventSequence];
      StreamEventPool aStreamEventPool=streamEventPools[anEventSequence];
      StreamEvent borrowedEvent=aStreamEventPool.borrowEvent();
      aStreamEventConverter.convertData(timeStamp,data,borrowedEvent);
      process(anEventSequence,borrowedEvent);
    }
  }
}","@Override public void receive(long timeStamp,Object[] data){
synchronized (this) {
    stabilizeStates();
    for (    int anEventSequence : eventSequence) {
      StreamEventConverter aStreamEventConverter=streamEventConverters[anEventSequence];
      StreamEventPool aStreamEventPool=streamEventPools[anEventSequence];
      StreamEvent borrowedEvent=aStreamEventPool.borrowEvent();
      aStreamEventConverter.convertData(timeStamp,data,borrowedEvent);
      process(anEventSequence,borrowedEvent);
    }
  }
}",0.989310009718173
29010,"public MultiProcessStreamReceiver clone(String key){
  return new MultiProcessStreamReceiver(streamId + key,key,processCount,latencyTracker);
}","public MultiProcessStreamReceiver clone(String key){
  return new MultiProcessStreamReceiver(streamId + key,processCount,latencyTracker);
}",0.9858156028368794
29011,"public MultiProcessStreamReceiver(String streamId,String lockKey,int processCount,LatencyTracker latencyTracker){
  super(streamId,latencyTracker);
  this.lockKey=lockKey;
  this.processCount=processCount;
  nextProcessors=new Processor[processCount];
  metaStreamEvents=new MetaStreamEvent[processCount];
  streamEventPools=new StreamEventPool[processCount];
  streamEventConverters=new StreamEventConverter[processCount];
  eventSequence=new int[processCount];
  for (int i=0; i < eventSequence.length; i++) {
    eventSequence[i]=i;
  }
}","public MultiProcessStreamReceiver(String streamId,int processCount,LatencyTracker latencyTracker){
  super(streamId,latencyTracker);
  this.processCount=processCount;
  nextProcessors=new Processor[processCount];
  metaStreamEvents=new MetaStreamEvent[processCount];
  streamEventPools=new StreamEventPool[processCount];
  streamEventConverters=new StreamEventConverter[processCount];
  eventSequence=new int[processCount];
  for (int i=0; i < eventSequence.length; i++) {
    eventSequence[i]=i;
  }
}",0.962607861936721
29012,"public StateMultiProcessStreamReceiver clone(String key){
  return new StateMultiProcessStreamReceiver(streamId + key,processCount,key,latencyTracker);
}","public StateMultiProcessStreamReceiver clone(String key){
  return new StateMultiProcessStreamReceiver(streamId + key,processCount,latencyTracker);
}",0.9867549668874172
29013,"public StateMultiProcessStreamReceiver(String streamId,int processCount,String lockKey,LatencyTracker latencyTracker){
  super(streamId,lockKey,processCount,latencyTracker);
}","public StateMultiProcessStreamReceiver(String streamId,int processCount,LatencyTracker latencyTracker){
  super(streamId,processCount,latencyTracker);
}",0.9296636085626911
29014,"public PatternMultiProcessStreamReceiver(String streamId,int processCount,String lockKey,LatencyTracker latencyTracker){
  super(streamId,processCount,lockKey,latencyTracker);
  eventSequence=new int[processCount];
  int count=0;
  for (int i=eventSequence.length - 1; i >= 0; i--) {
    eventSequence[count]=i;
    count++;
  }
}","public PatternMultiProcessStreamReceiver(String streamId,int processCount,LatencyTracker latencyTracker){
  super(streamId,processCount,latencyTracker);
  eventSequence=new int[processCount];
  int count=0;
  for (int i=eventSequence.length - 1; i >= 0; i--) {
    eventSequence[count]=i;
    count++;
  }
}",0.9638932496075352
29015,"public PatternMultiProcessStreamReceiver clone(String key){
  return new PatternMultiProcessStreamReceiver(streamId + key,processCount,key,latencyTracker);
}","public PatternMultiProcessStreamReceiver clone(String key){
  return new PatternMultiProcessStreamReceiver(streamId + key,processCount,latencyTracker);
}",0.9870967741935484
29016,"public SequenceMultiProcessStreamReceiver clone(String key){
  return new SequenceMultiProcessStreamReceiver(streamId + key,processCount,null,key,latencyTracker);
}","public SequenceMultiProcessStreamReceiver clone(String key){
  return new SequenceMultiProcessStreamReceiver(streamId + key,processCount,null,latencyTracker);
}",0.9876543209876544
29017,"public SequenceMultiProcessStreamReceiver(String streamId,int processCount,StateStreamRuntime stateStreamRuntime,String lockKey,LatencyTracker latencyTracker){
  super(streamId,processCount,lockKey,latencyTracker);
  this.stateStreamRuntime=stateStreamRuntime;
  eventSequence=new int[processCount];
  int count=0;
  for (int i=eventSequence.length - 1; i >= 0; i--) {
    eventSequence[count]=i;
    count++;
  }
}","public SequenceMultiProcessStreamReceiver(String streamId,int processCount,StateStreamRuntime stateStreamRuntime,LatencyTracker latencyTracker){
  super(streamId,processCount,latencyTracker);
  this.stateStreamRuntime=stateStreamRuntime;
  eventSequence=new int[processCount];
  int count=0;
  for (int i=eventSequence.length - 1; i >= 0; i--) {
    eventSequence[count]=i;
    count++;
  }
}",0.9714993804213136
29018,"public static StreamRuntime parseInputStream(JoinInputStream joinInputStream,ExecutionPlanContext executionPlanContext,Map<String,AbstractDefinition> streamDefinitionMap,Map<String,AbstractDefinition> tableDefinitionMap,Map<String,EventTable> eventTableMap,List<VariableExpressionExecutor> executors,LatencyTracker latencyTracker,boolean outputExpectsExpiredEvents){
  ProcessStreamReceiver leftProcessStreamReceiver;
  ProcessStreamReceiver rightProcessStreamReceiver;
  MetaStreamEvent leftMetaStreamEvent=new MetaStreamEvent();
  MetaStreamEvent rightMetaStreamEvent=new MetaStreamEvent();
  String leftInputStreamId=((SingleInputStream)joinInputStream.getLeftInputStream()).getStreamId();
  String rightInputStreamId=((SingleInputStream)joinInputStream.getRightInputStream()).getStreamId();
  boolean leftOuterJoinProcessor=false;
  boolean rightOuterJoinProcessor=false;
  if (joinInputStream.getAllStreamIds().size() == 2) {
    if (!streamDefinitionMap.containsKey(leftInputStreamId)) {
      leftMetaStreamEvent.setTableEvent(true);
    }
    if (!streamDefinitionMap.containsKey(rightInputStreamId)) {
      rightMetaStreamEvent.setTableEvent(true);
    }
    leftProcessStreamReceiver=new ProcessStreamReceiver(leftInputStreamId,latencyTracker);
    rightProcessStreamReceiver=new ProcessStreamReceiver(rightInputStreamId,latencyTracker);
    if (leftMetaStreamEvent.isTableEvent() && rightMetaStreamEvent.isTableEvent()) {
      throw new ExecutionPlanCreationException(""String_Node_Str"" + leftInputStreamId + ""String_Node_Str""+ rightInputStreamId);
    }
  }
 else {
    if (streamDefinitionMap.containsKey(joinInputStream.getAllStreamIds().get(0))) {
      String defaultLockKey=""String_Node_Str"";
      rightProcessStreamReceiver=new MultiProcessStreamReceiver(joinInputStream.getAllStreamIds().get(0),defaultLockKey,2,latencyTracker);
      leftProcessStreamReceiver=rightProcessStreamReceiver;
    }
 else {
      throw new ExecutionPlanCreationException(""String_Node_Str"" + leftInputStreamId + ""String_Node_Str""+ rightInputStreamId);
    }
  }
  SingleStreamRuntime leftStreamRuntime=SingleInputStreamParser.parseInputStream((SingleInputStream)joinInputStream.getLeftInputStream(),executionPlanContext,executors,streamDefinitionMap,!leftMetaStreamEvent.isTableEvent() ? null : tableDefinitionMap,eventTableMap,leftMetaStreamEvent,leftProcessStreamReceiver,true,latencyTracker,outputExpectsExpiredEvents);
  for (  VariableExpressionExecutor variableExpressionExecutor : executors) {
    variableExpressionExecutor.getPosition()[SiddhiConstants.STREAM_EVENT_CHAIN_INDEX]=0;
  }
  int size=executors.size();
  SingleStreamRuntime rightStreamRuntime=SingleInputStreamParser.parseInputStream((SingleInputStream)joinInputStream.getRightInputStream(),executionPlanContext,executors,streamDefinitionMap,!rightMetaStreamEvent.isTableEvent() ? null : tableDefinitionMap,eventTableMap,rightMetaStreamEvent,rightProcessStreamReceiver,true,latencyTracker,outputExpectsExpiredEvents);
  for (int i=size; i < executors.size(); i++) {
    VariableExpressionExecutor variableExpressionExecutor=executors.get(i);
    variableExpressionExecutor.getPosition()[SiddhiConstants.STREAM_EVENT_CHAIN_INDEX]=1;
  }
  if (leftMetaStreamEvent.isTableEvent()) {
    TableWindowProcessor tableWindowProcessor=new TableWindowProcessor(eventTableMap.get(leftInputStreamId));
    tableWindowProcessor.initProcessor(leftMetaStreamEvent.getLastInputDefinition(),new ExpressionExecutor[0],executionPlanContext,outputExpectsExpiredEvents);
    leftStreamRuntime.setProcessorChain(tableWindowProcessor);
  }
  if (rightMetaStreamEvent.isTableEvent()) {
    TableWindowProcessor tableWindowProcessor=new TableWindowProcessor(eventTableMap.get(rightInputStreamId));
    tableWindowProcessor.initProcessor(rightMetaStreamEvent.getLastInputDefinition(),new ExpressionExecutor[0],executionPlanContext,outputExpectsExpiredEvents);
    rightStreamRuntime.setProcessorChain(tableWindowProcessor);
  }
  MetaStateEvent metaStateEvent=new MetaStateEvent(2);
  metaStateEvent.addEvent(leftMetaStreamEvent);
  metaStateEvent.addEvent(rightMetaStreamEvent);
switch (joinInputStream.getType()) {
case FULL_OUTER_JOIN:
    leftOuterJoinProcessor=true;
case RIGHT_OUTER_JOIN:
  rightOuterJoinProcessor=true;
break;
case LEFT_OUTER_JOIN:
leftOuterJoinProcessor=true;
break;
}
Lock joinLock=new ReentrantLock();
JoinProcessor leftPreJoinProcessor=new JoinProcessor(true,true,leftOuterJoinProcessor);
JoinProcessor leftPostJoinProcessor=new JoinProcessor(true,false,leftOuterJoinProcessor);
FindableProcessor leftFindableProcessor=insertJoinProcessorsAndGetFindable(leftPreJoinProcessor,leftPostJoinProcessor,leftStreamRuntime,executionPlanContext,outputExpectsExpiredEvents);
JoinProcessor rightPreJoinProcessor=new JoinProcessor(false,true,rightOuterJoinProcessor);
JoinProcessor rightPostJoinProcessor=new JoinProcessor(false,false,rightOuterJoinProcessor);
FindableProcessor rightFindableProcessor=insertJoinProcessorsAndGetFindable(rightPreJoinProcessor,rightPostJoinProcessor,rightStreamRuntime,executionPlanContext,outputExpectsExpiredEvents);
leftPreJoinProcessor.setFindableProcessor(rightFindableProcessor);
leftPreJoinProcessor.setJoinLock(joinLock);
leftPostJoinProcessor.setFindableProcessor(rightFindableProcessor);
leftPostJoinProcessor.setJoinLock(joinLock);
rightPreJoinProcessor.setFindableProcessor(leftFindableProcessor);
rightPreJoinProcessor.setJoinLock(joinLock);
rightPostJoinProcessor.setFindableProcessor(leftFindableProcessor);
rightPostJoinProcessor.setJoinLock(joinLock);
Expression compareCondition=joinInputStream.getOnCompare();
if (compareCondition == null) {
compareCondition=Expression.value(true);
}
long withinTime=SiddhiConstants.ANY;
if (joinInputStream.getWithin() != null) {
withinTime=((TimeConstant)joinInputStream.getWithin()).getValue();
}
Finder leftFinder=rightFindableProcessor.constructFinder(compareCondition,metaStateEvent,executionPlanContext,executors,eventTableMap,0,withinTime);
Finder rightFinder=leftFindableProcessor.constructFinder(compareCondition,metaStateEvent,executionPlanContext,executors,eventTableMap,1,withinTime);
if (joinInputStream.getTrigger() != JoinInputStream.EventTrigger.LEFT) {
rightPreJoinProcessor.setTrigger(true);
rightPreJoinProcessor.setFinder(rightFinder);
rightPostJoinProcessor.setTrigger(true);
rightPostJoinProcessor.setFinder(rightFinder);
}
if (joinInputStream.getTrigger() != JoinInputStream.EventTrigger.RIGHT) {
leftPreJoinProcessor.setTrigger(true);
leftPreJoinProcessor.setFinder(leftFinder);
leftPostJoinProcessor.setTrigger(true);
leftPostJoinProcessor.setFinder(leftFinder);
}
JoinStreamRuntime joinStreamRuntime=new JoinStreamRuntime(executionPlanContext,metaStateEvent);
joinStreamRuntime.addRuntime(leftStreamRuntime);
joinStreamRuntime.addRuntime(rightStreamRuntime);
return joinStreamRuntime;
}","public static StreamRuntime parseInputStream(JoinInputStream joinInputStream,ExecutionPlanContext executionPlanContext,Map<String,AbstractDefinition> streamDefinitionMap,Map<String,AbstractDefinition> tableDefinitionMap,Map<String,EventTable> eventTableMap,List<VariableExpressionExecutor> executors,LatencyTracker latencyTracker,boolean outputExpectsExpiredEvents){
  ProcessStreamReceiver leftProcessStreamReceiver;
  ProcessStreamReceiver rightProcessStreamReceiver;
  MetaStreamEvent leftMetaStreamEvent=new MetaStreamEvent();
  MetaStreamEvent rightMetaStreamEvent=new MetaStreamEvent();
  String leftInputStreamId=((SingleInputStream)joinInputStream.getLeftInputStream()).getStreamId();
  String rightInputStreamId=((SingleInputStream)joinInputStream.getRightInputStream()).getStreamId();
  boolean leftOuterJoinProcessor=false;
  boolean rightOuterJoinProcessor=false;
  if (joinInputStream.getAllStreamIds().size() == 2) {
    if (!streamDefinitionMap.containsKey(leftInputStreamId)) {
      leftMetaStreamEvent.setTableEvent(true);
    }
    if (!streamDefinitionMap.containsKey(rightInputStreamId)) {
      rightMetaStreamEvent.setTableEvent(true);
    }
    leftProcessStreamReceiver=new ProcessStreamReceiver(leftInputStreamId,latencyTracker);
    rightProcessStreamReceiver=new ProcessStreamReceiver(rightInputStreamId,latencyTracker);
    if (leftMetaStreamEvent.isTableEvent() && rightMetaStreamEvent.isTableEvent()) {
      throw new ExecutionPlanCreationException(""String_Node_Str"" + leftInputStreamId + ""String_Node_Str""+ rightInputStreamId);
    }
  }
 else {
    if (streamDefinitionMap.containsKey(joinInputStream.getAllStreamIds().get(0))) {
      rightProcessStreamReceiver=new MultiProcessStreamReceiver(joinInputStream.getAllStreamIds().get(0),2,latencyTracker);
      leftProcessStreamReceiver=rightProcessStreamReceiver;
    }
 else {
      throw new ExecutionPlanCreationException(""String_Node_Str"" + leftInputStreamId + ""String_Node_Str""+ rightInputStreamId);
    }
  }
  SingleStreamRuntime leftStreamRuntime=SingleInputStreamParser.parseInputStream((SingleInputStream)joinInputStream.getLeftInputStream(),executionPlanContext,executors,streamDefinitionMap,!leftMetaStreamEvent.isTableEvent() ? null : tableDefinitionMap,eventTableMap,leftMetaStreamEvent,leftProcessStreamReceiver,true,latencyTracker,outputExpectsExpiredEvents);
  for (  VariableExpressionExecutor variableExpressionExecutor : executors) {
    variableExpressionExecutor.getPosition()[SiddhiConstants.STREAM_EVENT_CHAIN_INDEX]=0;
  }
  int size=executors.size();
  SingleStreamRuntime rightStreamRuntime=SingleInputStreamParser.parseInputStream((SingleInputStream)joinInputStream.getRightInputStream(),executionPlanContext,executors,streamDefinitionMap,!rightMetaStreamEvent.isTableEvent() ? null : tableDefinitionMap,eventTableMap,rightMetaStreamEvent,rightProcessStreamReceiver,true,latencyTracker,outputExpectsExpiredEvents);
  for (int i=size; i < executors.size(); i++) {
    VariableExpressionExecutor variableExpressionExecutor=executors.get(i);
    variableExpressionExecutor.getPosition()[SiddhiConstants.STREAM_EVENT_CHAIN_INDEX]=1;
  }
  if (leftMetaStreamEvent.isTableEvent()) {
    TableWindowProcessor tableWindowProcessor=new TableWindowProcessor(eventTableMap.get(leftInputStreamId));
    tableWindowProcessor.initProcessor(leftMetaStreamEvent.getLastInputDefinition(),new ExpressionExecutor[0],executionPlanContext,outputExpectsExpiredEvents);
    leftStreamRuntime.setProcessorChain(tableWindowProcessor);
  }
  if (rightMetaStreamEvent.isTableEvent()) {
    TableWindowProcessor tableWindowProcessor=new TableWindowProcessor(eventTableMap.get(rightInputStreamId));
    tableWindowProcessor.initProcessor(rightMetaStreamEvent.getLastInputDefinition(),new ExpressionExecutor[0],executionPlanContext,outputExpectsExpiredEvents);
    rightStreamRuntime.setProcessorChain(tableWindowProcessor);
  }
  MetaStateEvent metaStateEvent=new MetaStateEvent(2);
  metaStateEvent.addEvent(leftMetaStreamEvent);
  metaStateEvent.addEvent(rightMetaStreamEvent);
switch (joinInputStream.getType()) {
case FULL_OUTER_JOIN:
    leftOuterJoinProcessor=true;
case RIGHT_OUTER_JOIN:
  rightOuterJoinProcessor=true;
break;
case LEFT_OUTER_JOIN:
leftOuterJoinProcessor=true;
break;
}
Lock joinLock=new ReentrantLock();
JoinProcessor leftPreJoinProcessor=new JoinProcessor(true,true,leftOuterJoinProcessor);
JoinProcessor leftPostJoinProcessor=new JoinProcessor(true,false,leftOuterJoinProcessor);
FindableProcessor leftFindableProcessor=insertJoinProcessorsAndGetFindable(leftPreJoinProcessor,leftPostJoinProcessor,leftStreamRuntime,executionPlanContext,outputExpectsExpiredEvents);
JoinProcessor rightPreJoinProcessor=new JoinProcessor(false,true,rightOuterJoinProcessor);
JoinProcessor rightPostJoinProcessor=new JoinProcessor(false,false,rightOuterJoinProcessor);
FindableProcessor rightFindableProcessor=insertJoinProcessorsAndGetFindable(rightPreJoinProcessor,rightPostJoinProcessor,rightStreamRuntime,executionPlanContext,outputExpectsExpiredEvents);
leftPreJoinProcessor.setFindableProcessor(rightFindableProcessor);
leftPreJoinProcessor.setJoinLock(joinLock);
leftPostJoinProcessor.setFindableProcessor(rightFindableProcessor);
leftPostJoinProcessor.setJoinLock(joinLock);
rightPreJoinProcessor.setFindableProcessor(leftFindableProcessor);
rightPreJoinProcessor.setJoinLock(joinLock);
rightPostJoinProcessor.setFindableProcessor(leftFindableProcessor);
rightPostJoinProcessor.setJoinLock(joinLock);
Expression compareCondition=joinInputStream.getOnCompare();
if (compareCondition == null) {
compareCondition=Expression.value(true);
}
long withinTime=SiddhiConstants.ANY;
if (joinInputStream.getWithin() != null) {
withinTime=((TimeConstant)joinInputStream.getWithin()).getValue();
}
Finder leftFinder=rightFindableProcessor.constructFinder(compareCondition,metaStateEvent,executionPlanContext,executors,eventTableMap,0,withinTime);
Finder rightFinder=leftFindableProcessor.constructFinder(compareCondition,metaStateEvent,executionPlanContext,executors,eventTableMap,1,withinTime);
if (joinInputStream.getTrigger() != JoinInputStream.EventTrigger.LEFT) {
rightPreJoinProcessor.setTrigger(true);
rightPreJoinProcessor.setFinder(rightFinder);
rightPostJoinProcessor.setTrigger(true);
rightPostJoinProcessor.setFinder(rightFinder);
}
if (joinInputStream.getTrigger() != JoinInputStream.EventTrigger.RIGHT) {
leftPreJoinProcessor.setTrigger(true);
leftPreJoinProcessor.setFinder(leftFinder);
leftPostJoinProcessor.setTrigger(true);
leftPostJoinProcessor.setFinder(leftFinder);
}
JoinStreamRuntime joinStreamRuntime=new JoinStreamRuntime(executionPlanContext,metaStateEvent);
joinStreamRuntime.addRuntime(leftStreamRuntime);
joinStreamRuntime.addRuntime(rightStreamRuntime);
return joinStreamRuntime;
}",0.9903339191564148
29019,"public static StateStreamRuntime parseInputStream(StateInputStream stateInputStream,ExecutionPlanContext executionPlanContext,MetaStateEvent metaStateEvent,Map<String,AbstractDefinition> streamDefinitionMap,Map<String,AbstractDefinition> tableDefinitionMap,Map<String,EventTable> eventTableMap,List<VariableExpressionExecutor> variableExpressionExecutors,LatencyTracker latencyTracker){
  Map<String,ProcessStreamReceiver> processStreamReceiverMap=new HashMap<String,ProcessStreamReceiver>();
  StateStreamRuntime stateStreamRuntime=new StateStreamRuntime(executionPlanContext,metaStateEvent);
  String defaultLockKey=""String_Node_Str"";
  for (  String streamId : stateInputStream.getAllStreamIds()) {
    int streamCount=stateInputStream.getStreamCount(streamId);
    if (streamCount == 1) {
      if (stateInputStream.getStateType() == StateInputStream.Type.SEQUENCE) {
        processStreamReceiverMap.put(streamId,new SequenceSingleProcessStreamReceiver(streamId,stateStreamRuntime,defaultLockKey,latencyTracker));
      }
 else {
        processStreamReceiverMap.put(streamId,new PatternSingleProcessStreamReceiver(streamId,defaultLockKey,latencyTracker));
      }
    }
 else {
      if (stateInputStream.getStateType() == StateInputStream.Type.SEQUENCE) {
        processStreamReceiverMap.put(streamId,new SequenceMultiProcessStreamReceiver(streamId,streamCount,stateStreamRuntime,defaultLockKey,latencyTracker));
      }
 else {
        processStreamReceiverMap.put(streamId,new PatternMultiProcessStreamReceiver(streamId,streamCount,defaultLockKey,latencyTracker));
      }
    }
  }
  StateElement stateElement=stateInputStream.getStateElement();
  InnerStateRuntime innerStateRuntime=parse(stateElement,streamDefinitionMap,tableDefinitionMap,eventTableMap,metaStateEvent,executionPlanContext,variableExpressionExecutors,processStreamReceiverMap,null,null,stateInputStream.getStateType(),new ArrayList<Map.Entry<Long,Set<Integer>>>(),latencyTracker);
  stateStreamRuntime.setInnerStateRuntime(innerStateRuntime);
  ((StreamPreStateProcessor)innerStateRuntime.getFirstProcessor()).setThisLastProcessor((StreamPostStateProcessor)innerStateRuntime.getLastProcessor());
  return stateStreamRuntime;
}","public static StateStreamRuntime parseInputStream(StateInputStream stateInputStream,ExecutionPlanContext executionPlanContext,MetaStateEvent metaStateEvent,Map<String,AbstractDefinition> streamDefinitionMap,Map<String,AbstractDefinition> tableDefinitionMap,Map<String,EventTable> eventTableMap,List<VariableExpressionExecutor> variableExpressionExecutors,LatencyTracker latencyTracker){
  Map<String,ProcessStreamReceiver> processStreamReceiverMap=new HashMap<String,ProcessStreamReceiver>();
  StateStreamRuntime stateStreamRuntime=new StateStreamRuntime(executionPlanContext,metaStateEvent);
  String defaultLockKey=""String_Node_Str"";
  for (  String streamId : stateInputStream.getAllStreamIds()) {
    int streamCount=stateInputStream.getStreamCount(streamId);
    if (streamCount == 1) {
      if (stateInputStream.getStateType() == StateInputStream.Type.SEQUENCE) {
        processStreamReceiverMap.put(streamId,new SequenceSingleProcessStreamReceiver(streamId,stateStreamRuntime,defaultLockKey,latencyTracker));
      }
 else {
        processStreamReceiverMap.put(streamId,new PatternSingleProcessStreamReceiver(streamId,defaultLockKey,latencyTracker));
      }
    }
 else {
      if (stateInputStream.getStateType() == StateInputStream.Type.SEQUENCE) {
        processStreamReceiverMap.put(streamId,new SequenceMultiProcessStreamReceiver(streamId,streamCount,stateStreamRuntime,latencyTracker));
      }
 else {
        processStreamReceiverMap.put(streamId,new PatternMultiProcessStreamReceiver(streamId,streamCount,latencyTracker));
      }
    }
  }
  StateElement stateElement=stateInputStream.getStateElement();
  InnerStateRuntime innerStateRuntime=parse(stateElement,streamDefinitionMap,tableDefinitionMap,eventTableMap,metaStateEvent,executionPlanContext,variableExpressionExecutors,processStreamReceiverMap,null,null,stateInputStream.getStateType(),new ArrayList<Map.Entry<Long,Set<Integer>>>(),latencyTracker);
  stateStreamRuntime.setInnerStateRuntime(innerStateRuntime);
  ((StreamPreStateProcessor)innerStateRuntime.getFirstProcessor()).setThisLastProcessor((StreamPostStateProcessor)innerStateRuntime.getLastProcessor());
  return stateStreamRuntime;
}",0.9931538110451849
29020,"/** 
 * Process the handed StreamEvent
 * @param complexEventChunk event chunk to be processed
 */
@Override public void process(ComplexEventChunk complexEventChunk){
  if (trigger) {
    ComplexEventChunk<StateEvent> returnEventChunk=new ComplexEventChunk<StateEvent>(true);
    StreamEvent nextEvent=(StreamEvent)complexEventChunk.getFirst();
    complexEventChunk.clear();
    while (nextEvent != null) {
      StreamEvent streamEvent=nextEvent;
      nextEvent=streamEvent.getNext();
      streamEvent.setNext(null);
      joinLock.lock();
      try {
        if (streamEvent.getType() == ComplexEvent.Type.TIMER) {
          if (preJoinProcessor) {
            complexEventChunk.add(streamEvent);
            nextProcessor.process(complexEventChunk);
            complexEventChunk.clear();
          }
          continue;
        }
 else         if (streamEvent.getType() == ComplexEvent.Type.CURRENT) {
          if (!preJoinProcessor) {
            continue;
          }
        }
 else         if (streamEvent.getType() == ComplexEvent.Type.EXPIRED) {
          if (preJoinProcessor) {
            continue;
          }
        }
        StreamEvent foundStreamEvent=findableProcessor.find(streamEvent,finder);
        if (foundStreamEvent == null) {
          if (outerJoinProcessor && !leftJoinProcessor) {
            returnEventChunk.add(joinEventBuilder(foundStreamEvent,streamEvent));
          }
 else           if (outerJoinProcessor && leftJoinProcessor) {
            returnEventChunk.add(joinEventBuilder(streamEvent,foundStreamEvent));
          }
        }
 else {
          while (foundStreamEvent != null) {
            if (!leftJoinProcessor) {
              returnEventChunk.add(joinEventBuilder(foundStreamEvent,streamEvent));
            }
 else {
              returnEventChunk.add(joinEventBuilder(streamEvent,foundStreamEvent));
            }
            foundStreamEvent=foundStreamEvent.getNext();
          }
        }
        if (preJoinProcessor) {
          complexEventChunk.add(streamEvent);
          nextProcessor.process(complexEventChunk);
          complexEventChunk.clear();
        }
      }
  finally {
        joinLock.unlock();
      }
      if (returnEventChunk.getFirst() != null) {
        selector.process(returnEventChunk);
        returnEventChunk.clear();
      }
    }
  }
 else {
    if (preJoinProcessor) {
      joinLock.lock();
      try {
        nextProcessor.process(complexEventChunk);
      }
  finally {
        joinLock.unlock();
      }
    }
  }
}","/** 
 * Process the handed StreamEvent
 * @param complexEventChunk event chunk to be processed
 */
@Override public void process(ComplexEventChunk complexEventChunk){
  if (trigger) {
    ComplexEventChunk<StateEvent> returnEventChunk=new ComplexEventChunk<StateEvent>(true);
    StreamEvent nextEvent=(StreamEvent)complexEventChunk.getFirst();
    complexEventChunk.clear();
    while (nextEvent != null) {
      StreamEvent streamEvent=nextEvent;
      nextEvent=streamEvent.getNext();
      streamEvent.setNext(null);
      joinLock.lock();
      try {
        if (streamEvent.getType() == ComplexEvent.Type.TIMER) {
          if (preJoinProcessor) {
            complexEventChunk.add(streamEvent);
            nextProcessor.process(complexEventChunk);
            complexEventChunk.clear();
          }
          continue;
        }
 else         if (streamEvent.getType() == ComplexEvent.Type.CURRENT) {
          if (!preJoinProcessor) {
            continue;
          }
        }
 else         if (streamEvent.getType() == ComplexEvent.Type.EXPIRED) {
          if (preJoinProcessor) {
            continue;
          }
        }
 else         if (streamEvent.getType() == ComplexEvent.Type.RESET) {
          continue;
        }
        StreamEvent foundStreamEvent=findableProcessor.find(streamEvent,finder);
        if (foundStreamEvent == null) {
          if (outerJoinProcessor && !leftJoinProcessor) {
            returnEventChunk.add(joinEventBuilder(foundStreamEvent,streamEvent));
          }
 else           if (outerJoinProcessor && leftJoinProcessor) {
            returnEventChunk.add(joinEventBuilder(streamEvent,foundStreamEvent));
          }
        }
 else {
          while (foundStreamEvent != null) {
            if (!leftJoinProcessor) {
              returnEventChunk.add(joinEventBuilder(foundStreamEvent,streamEvent));
            }
 else {
              returnEventChunk.add(joinEventBuilder(streamEvent,foundStreamEvent));
            }
            foundStreamEvent=foundStreamEvent.getNext();
          }
        }
        if (preJoinProcessor) {
          complexEventChunk.add(streamEvent);
          nextProcessor.process(complexEventChunk);
          complexEventChunk.clear();
        }
      }
  finally {
        joinLock.unlock();
      }
      if (returnEventChunk.getFirst() != null) {
        selector.process(returnEventChunk);
        returnEventChunk.clear();
      }
    }
  }
 else {
    if (preJoinProcessor) {
      joinLock.lock();
      try {
        nextProcessor.process(complexEventChunk);
      }
  finally {
        joinLock.unlock();
      }
    }
  }
}",0.9384255650818394
29021,"@Override protected void init(ExpressionExecutor[] attributeExpressionExecutors,ExecutionPlanContext executionPlanContext,boolean outputExpectsExpiredEvents){
  this.outputExpectsExpiredEvents=outputExpectsExpiredEvents;
  if (outputExpectsExpiredEvents) {
    this.expiredEventChunk=new ComplexEventChunk<StreamEvent>(false);
  }
  if (attributeExpressionExecutors.length >= 2 && attributeExpressionExecutors.length <= 4) {
    if ((attributeExpressionExecutors[0] instanceof ConstantExpressionExecutor)) {
      throw new ExecutionPlanValidationException(""String_Node_Str"");
    }
    if (attributeExpressionExecutors[0].getReturnType() != Attribute.Type.LONG) {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors[0].getReturnType());
    }
    timestampExpressionExecutor=attributeExpressionExecutors[0];
    if (attributeExpressionExecutors[1].getReturnType() == Attribute.Type.INT) {
      timeToKeep=(Integer)((ConstantExpressionExecutor)attributeExpressionExecutors[1]).getValue();
    }
 else     if (attributeExpressionExecutors[1].getReturnType() == Attribute.Type.LONG) {
      timeToKeep=(Long)((ConstantExpressionExecutor)attributeExpressionExecutors[1]).getValue();
    }
 else {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors[1].getReturnType());
    }
    if (attributeExpressionExecutors.length >= 3) {
      isStartTimeEnabled=true;
      if (attributeExpressionExecutors[2].getReturnType() == Attribute.Type.INT) {
        startTime=Integer.parseInt(String.valueOf(((ConstantExpressionExecutor)attributeExpressionExecutors[2]).getValue()));
      }
 else       if (attributeExpressionExecutors[2].getReturnType() == Attribute.Type.LONG) {
        startTime=Long.parseLong(String.valueOf(((ConstantExpressionExecutor)attributeExpressionExecutors[2]).getValue()));
      }
 else {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors[2].getReturnType());
      }
    }
    if (attributeExpressionExecutors.length == 4) {
      if (attributeExpressionExecutors[3].getReturnType() == Attribute.Type.INT) {
        schedulerTimeout=Integer.parseInt(String.valueOf(((ConstantExpressionExecutor)attributeExpressionExecutors[3]).getValue()));
      }
 else       if (attributeExpressionExecutors[3].getReturnType() == Attribute.Type.LONG) {
        schedulerTimeout=Long.parseLong(String.valueOf(((ConstantExpressionExecutor)attributeExpressionExecutors[3]).getValue()));
      }
 else {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors[3].getReturnType());
      }
    }
  }
 else {
    throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors.length + ""String_Node_Str"");
  }
  if (schedulerTimeout > 0) {
    if (expiredEventChunk == null) {
      this.expiredEventChunk=new ComplexEventChunk<StreamEvent>(false);
    }
  }
}","@Override protected void init(ExpressionExecutor[] attributeExpressionExecutors,ExecutionPlanContext executionPlanContext,boolean outputExpectsExpiredEvents){
  this.outputExpectsExpiredEvents=outputExpectsExpiredEvents;
  if (outputExpectsExpiredEvents) {
    this.expiredEventChunk=new ComplexEventChunk<StreamEvent>(false);
    this.storeExpiredEvents=true;
  }
  if (attributeExpressionExecutors.length >= 2 && attributeExpressionExecutors.length <= 4) {
    if ((attributeExpressionExecutors[0] instanceof ConstantExpressionExecutor)) {
      throw new ExecutionPlanValidationException(""String_Node_Str"");
    }
    if (attributeExpressionExecutors[0].getReturnType() != Attribute.Type.LONG) {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors[0].getReturnType());
    }
    timestampExpressionExecutor=attributeExpressionExecutors[0];
    if (attributeExpressionExecutors[1].getReturnType() == Attribute.Type.INT) {
      timeToKeep=(Integer)((ConstantExpressionExecutor)attributeExpressionExecutors[1]).getValue();
    }
 else     if (attributeExpressionExecutors[1].getReturnType() == Attribute.Type.LONG) {
      timeToKeep=(Long)((ConstantExpressionExecutor)attributeExpressionExecutors[1]).getValue();
    }
 else {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors[1].getReturnType());
    }
    if (attributeExpressionExecutors.length >= 3) {
      isStartTimeEnabled=true;
      if (attributeExpressionExecutors[2].getReturnType() == Attribute.Type.INT) {
        startTime=Integer.parseInt(String.valueOf(((ConstantExpressionExecutor)attributeExpressionExecutors[2]).getValue()));
      }
 else       if (attributeExpressionExecutors[2].getReturnType() == Attribute.Type.LONG) {
        startTime=Long.parseLong(String.valueOf(((ConstantExpressionExecutor)attributeExpressionExecutors[2]).getValue()));
      }
 else {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors[2].getReturnType());
      }
    }
    if (attributeExpressionExecutors.length == 4) {
      if (attributeExpressionExecutors[3].getReturnType() == Attribute.Type.INT) {
        schedulerTimeout=Integer.parseInt(String.valueOf(((ConstantExpressionExecutor)attributeExpressionExecutors[3]).getValue()));
      }
 else       if (attributeExpressionExecutors[3].getReturnType() == Attribute.Type.LONG) {
        schedulerTimeout=Long.parseLong(String.valueOf(((ConstantExpressionExecutor)attributeExpressionExecutors[3]).getValue()));
      }
 else {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors[3].getReturnType());
      }
    }
  }
 else {
    throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors.length + ""String_Node_Str"");
  }
  if (schedulerTimeout > 0) {
    if (expiredEventChunk == null) {
      this.expiredEventChunk=new ComplexEventChunk<StreamEvent>(false);
    }
  }
}",0.9943086709072648
29022,"/** 
 * Here an assumption is taken: Parameter: timestamp: The time which the window determines as current time and will act upon, the value of this parameter should be monotonically increasing. from https://docs.wso2.com/display/CEP400/Inbuilt+Windows#InbuiltWindows-externalTime
 */
@Override protected void process(ComplexEventChunk<StreamEvent> streamEventChunk,Processor nextProcessor,StreamEventCloner streamEventCloner){
  if (streamEventChunk.getFirst() == null) {
    return;
  }
  List<ComplexEventChunk<StreamEvent>> complexEventChunks=new ArrayList<ComplexEventChunk<StreamEvent>>();
synchronized (this) {
    initTiming(streamEventChunk.getFirst());
    StreamEvent nextStreamEvent=streamEventChunk.getFirst();
    while (nextStreamEvent != null) {
      StreamEvent currStreamEvent=nextStreamEvent;
      nextStreamEvent=nextStreamEvent.getNext();
      if (currStreamEvent.getType() == ComplexEvent.Type.TIMER) {
        if (lastScheduledTime <= currStreamEvent.getTimestamp()) {
          if (!flushed) {
            flushToOutputChunk(streamEventCloner,complexEventChunks,lastCurrentEventTime);
            flushed=true;
          }
 else {
            if (currentEventChunk.getFirst() != null) {
              appendToOutputChunk(streamEventCloner,complexEventChunks,lastCurrentEventTime);
            }
          }
          lastScheduledTime=executionPlanContext.getTimestampGenerator().currentTime() + schedulerTimeout;
          scheduler.notifyAt(lastScheduledTime);
        }
        continue;
      }
 else       if (currStreamEvent.getType() != ComplexEvent.Type.CURRENT) {
        continue;
      }
      long currentEventTime=(Long)timestampExpressionExecutor.execute(currStreamEvent);
      if (lastCurrentEventTime < currentEventTime) {
        lastCurrentEventTime=currentEventTime;
      }
      if (currentEventTime < endTime) {
        cloneAppend(streamEventCloner,currStreamEvent);
      }
 else {
        if (flushed) {
          appendToOutputChunk(streamEventCloner,complexEventChunks,lastCurrentEventTime);
          flushed=false;
        }
 else {
          flushToOutputChunk(streamEventCloner,complexEventChunks,lastCurrentEventTime);
        }
        endTime=findEndTime(lastCurrentEventTime,startTime,timeToKeep);
        cloneAppend(streamEventCloner,currStreamEvent);
        if (schedulerTimeout > 0) {
          lastScheduledTime=executionPlanContext.getTimestampGenerator().currentTime() + schedulerTimeout;
          scheduler.notifyAt(lastScheduledTime);
        }
      }
    }
  }
  for (  ComplexEventChunk<StreamEvent> complexEventChunk : complexEventChunks) {
    nextProcessor.process(complexEventChunk);
  }
}","/** 
 * Here an assumption is taken: Parameter: timestamp: The time which the window determines as current time and will act upon, the value of this parameter should be monotonically increasing. from https://docs.wso2.com/display/CEP400/Inbuilt+Windows#InbuiltWindows-externalTime
 */
@Override protected void process(ComplexEventChunk<StreamEvent> streamEventChunk,Processor nextProcessor,StreamEventCloner streamEventCloner){
  if (streamEventChunk.getFirst() == null) {
    return;
  }
  List<ComplexEventChunk<StreamEvent>> complexEventChunks=new ArrayList<ComplexEventChunk<StreamEvent>>();
synchronized (this) {
    initTiming(streamEventChunk.getFirst());
    StreamEvent nextStreamEvent=streamEventChunk.getFirst();
    while (nextStreamEvent != null) {
      StreamEvent currStreamEvent=nextStreamEvent;
      nextStreamEvent=nextStreamEvent.getNext();
      if (currStreamEvent.getType() == ComplexEvent.Type.TIMER) {
        if (lastScheduledTime <= currStreamEvent.getTimestamp()) {
          if (!flushed) {
            flushToOutputChunk(streamEventCloner,complexEventChunks,lastCurrentEventTime,true);
            flushed=true;
          }
 else {
            if (currentEventChunk.getFirst() != null) {
              appendToOutputChunk(streamEventCloner,complexEventChunks,lastCurrentEventTime,true);
            }
          }
          lastScheduledTime=executionPlanContext.getTimestampGenerator().currentTime() + schedulerTimeout;
          scheduler.notifyAt(lastScheduledTime);
        }
        continue;
      }
 else       if (currStreamEvent.getType() != ComplexEvent.Type.CURRENT) {
        continue;
      }
      long currentEventTime=(Long)timestampExpressionExecutor.execute(currStreamEvent);
      if (lastCurrentEventTime < currentEventTime) {
        lastCurrentEventTime=currentEventTime;
      }
      if (currentEventTime < endTime) {
        cloneAppend(streamEventCloner,currStreamEvent);
      }
 else {
        if (flushed) {
          appendToOutputChunk(streamEventCloner,complexEventChunks,lastCurrentEventTime,false);
          flushed=false;
        }
 else {
          flushToOutputChunk(streamEventCloner,complexEventChunks,lastCurrentEventTime,false);
        }
        endTime=findEndTime(lastCurrentEventTime,startTime,timeToKeep);
        cloneAppend(streamEventCloner,currStreamEvent);
        if (schedulerTimeout > 0) {
          lastScheduledTime=executionPlanContext.getTimestampGenerator().currentTime() + schedulerTimeout;
          scheduler.notifyAt(lastScheduledTime);
        }
      }
    }
  }
  for (  ComplexEventChunk<StreamEvent> complexEventChunk : complexEventChunks) {
    nextProcessor.process(complexEventChunk);
  }
}",0.9958970533383066
29023,"public void restoreState(Object[] state){
  currentEventChunk.clear();
  currentEventChunk.add((StreamEvent)state[0]);
  resetEvent=(StreamEvent)state[1];
  endTime=(Long)state[2];
  startTime=(Long)state[3];
  isStartTimeEnabled=(Boolean)state[4];
  schedulerTimeout=(Long)state[5];
  if (state.length > 6) {
    expiredEventChunk.clear();
    expiredEventChunk.add((StreamEvent)state[6]);
  }
}","public void restoreState(Object[] state){
  currentEventChunk.clear();
  currentEventChunk.add((StreamEvent)state[0]);
  if (state[1] != null) {
    expiredEventChunk.clear();
    expiredEventChunk.add((StreamEvent)state[1]);
  }
 else {
    expiredEventChunk=null;
  }
  resetEvent=(StreamEvent)state[2];
  endTime=(Long)state[3];
  startTime=(Long)state[4];
  lastScheduledTime=(Long)state[5];
  lastCurrentEventTime=(Long)state[6];
  flushed=(Boolean)state[7];
}",0.4924506387921022
29024,"public Finder constructFinder(Expression expression,MetaComplexEvent matchingMetaComplexEvent,ExecutionPlanContext executionPlanContext,List<VariableExpressionExecutor> variableExpressionExecutors,Map<String,EventTable> eventTableMap,int matchingStreamIndex,long withinTime){
  if (expiredEventChunk == null) {
    expiredEventChunk=new ComplexEventChunk<StreamEvent>(false);
  }
  return CollectionOperatorParser.parse(expression,matchingMetaComplexEvent,executionPlanContext,variableExpressionExecutors,eventTableMap,matchingStreamIndex,inputDefinition,withinTime);
}","public Finder constructFinder(Expression expression,MetaComplexEvent matchingMetaComplexEvent,ExecutionPlanContext executionPlanContext,List<VariableExpressionExecutor> variableExpressionExecutors,Map<String,EventTable> eventTableMap,int matchingStreamIndex,long withinTime){
  if (expiredEventChunk == null) {
    expiredEventChunk=new ComplexEventChunk<StreamEvent>(false);
    storeExpiredEvents=true;
  }
  return CollectionOperatorParser.parse(expression,matchingMetaComplexEvent,executionPlanContext,variableExpressionExecutors,eventTableMap,matchingStreamIndex,inputDefinition,withinTime);
}",0.9751499571550986
29025,"private void appendToOutputChunk(StreamEventCloner streamEventCloner,List<ComplexEventChunk<StreamEvent>> complexEventChunks,long currentTime){
  ComplexEventChunk<StreamEvent> newEventChunk=new ComplexEventChunk<StreamEvent>(true);
  ComplexEventChunk<StreamEvent> sentEventChunk=new ComplexEventChunk<StreamEvent>(true);
  if (currentEventChunk.getFirst() != null) {
    if (expiredEventChunk.getFirst() != null) {
      expiredEventChunk.reset();
      while (expiredEventChunk.hasNext()) {
        StreamEvent expiredEvent=expiredEventChunk.next();
        if (outputExpectsExpiredEvents) {
          StreamEvent toExpireEvent=streamEventCloner.copyStreamEvent(expiredEvent);
          toExpireEvent.setTimestamp(currentTime);
          newEventChunk.add(toExpireEvent);
        }
        StreamEvent toSendEvent=streamEventCloner.copyStreamEvent(expiredEvent);
        toSendEvent.setType(ComplexEvent.Type.CURRENT);
        sentEventChunk.add(toSendEvent);
      }
    }
    StreamEvent toResetEvent=streamEventCloner.copyStreamEvent(resetEvent);
    toResetEvent.setTimestamp(currentTime);
    newEventChunk.add(toResetEvent);
    newEventChunk.add(sentEventChunk.getFirst());
    if (expiredEventChunk != null) {
      currentEventChunk.reset();
      while (currentEventChunk.hasNext()) {
        StreamEvent currentEvent=currentEventChunk.next();
        StreamEvent toExpireEvent=streamEventCloner.copyStreamEvent(currentEvent);
        toExpireEvent.setType(StreamEvent.Type.EXPIRED);
        expiredEventChunk.add(toExpireEvent);
      }
    }
    newEventChunk.add(currentEventChunk.getFirst());
  }
  currentEventChunk.clear();
  if (newEventChunk.getFirst() != null) {
    complexEventChunks.add(newEventChunk);
  }
}","private void appendToOutputChunk(StreamEventCloner streamEventCloner,List<ComplexEventChunk<StreamEvent>> complexEventChunks,long currentTime,boolean preserveCurrentEvents){
  ComplexEventChunk<StreamEvent> newEventChunk=new ComplexEventChunk<StreamEvent>(true);
  ComplexEventChunk<StreamEvent> sentEventChunk=new ComplexEventChunk<StreamEvent>(true);
  if (currentEventChunk.getFirst() != null) {
    if (expiredEventChunk.getFirst() != null) {
      expiredEventChunk.reset();
      while (expiredEventChunk.hasNext()) {
        StreamEvent expiredEvent=expiredEventChunk.next();
        if (outputExpectsExpiredEvents) {
          StreamEvent toExpireEvent=streamEventCloner.copyStreamEvent(expiredEvent);
          toExpireEvent.setTimestamp(currentTime);
          newEventChunk.add(toExpireEvent);
        }
        StreamEvent toSendEvent=streamEventCloner.copyStreamEvent(expiredEvent);
        toSendEvent.setType(ComplexEvent.Type.CURRENT);
        sentEventChunk.add(toSendEvent);
      }
    }
    StreamEvent toResetEvent=streamEventCloner.copyStreamEvent(resetEvent);
    toResetEvent.setTimestamp(currentTime);
    newEventChunk.add(toResetEvent);
    newEventChunk.add(sentEventChunk.getFirst());
    if (preserveCurrentEvents || storeExpiredEvents) {
      currentEventChunk.reset();
      while (currentEventChunk.hasNext()) {
        StreamEvent currentEvent=currentEventChunk.next();
        StreamEvent toExpireEvent=streamEventCloner.copyStreamEvent(currentEvent);
        toExpireEvent.setType(StreamEvent.Type.EXPIRED);
        expiredEventChunk.add(toExpireEvent);
      }
    }
    newEventChunk.add(currentEventChunk.getFirst());
  }
  currentEventChunk.clear();
  if (newEventChunk.getFirst() != null) {
    complexEventChunks.add(newEventChunk);
  }
}",0.9721115537848606
29026,"private void flushToOutputChunk(StreamEventCloner streamEventCloner,List<ComplexEventChunk<StreamEvent>> complexEventChunks,long currentTime){
  ComplexEventChunk<StreamEvent> newEventChunk=new ComplexEventChunk<StreamEvent>(true);
  if (outputExpectsExpiredEvents) {
    if (expiredEventChunk.getFirst() != null) {
      expiredEventChunk.reset();
      while (expiredEventChunk.hasNext()) {
        StreamEvent expiredEvent=expiredEventChunk.next();
        expiredEvent.setTimestamp(currentTime);
      }
      newEventChunk.add(expiredEventChunk.getFirst());
    }
  }
  if (expiredEventChunk != null) {
    expiredEventChunk.clear();
  }
  if (currentEventChunk.getFirst() != null) {
    resetEvent.setTimestamp(currentTime);
    newEventChunk.add(resetEvent);
    resetEvent=null;
    if (expiredEventChunk != null) {
      currentEventChunk.reset();
      while (currentEventChunk.hasNext()) {
        StreamEvent currentEvent=currentEventChunk.next();
        StreamEvent toExpireEvent=streamEventCloner.copyStreamEvent(currentEvent);
        toExpireEvent.setType(StreamEvent.Type.EXPIRED);
        expiredEventChunk.add(toExpireEvent);
      }
    }
    newEventChunk.add(currentEventChunk.getFirst());
  }
  currentEventChunk.clear();
  if (newEventChunk.getFirst() != null) {
    complexEventChunks.add(newEventChunk);
  }
}","private void flushToOutputChunk(StreamEventCloner streamEventCloner,List<ComplexEventChunk<StreamEvent>> complexEventChunks,long currentTime,boolean preserveCurrentEvents){
  ComplexEventChunk<StreamEvent> newEventChunk=new ComplexEventChunk<StreamEvent>(true);
  if (outputExpectsExpiredEvents) {
    if (expiredEventChunk.getFirst() != null) {
      expiredEventChunk.reset();
      while (expiredEventChunk.hasNext()) {
        StreamEvent expiredEvent=expiredEventChunk.next();
        expiredEvent.setTimestamp(currentTime);
      }
      newEventChunk.add(expiredEventChunk.getFirst());
    }
  }
  if (expiredEventChunk != null) {
    expiredEventChunk.clear();
  }
  if (currentEventChunk.getFirst() != null) {
    resetEvent.setTimestamp(currentTime);
    newEventChunk.add(resetEvent);
    resetEvent=null;
    if (preserveCurrentEvents || storeExpiredEvents) {
      currentEventChunk.reset();
      while (currentEventChunk.hasNext()) {
        StreamEvent currentEvent=currentEventChunk.next();
        StreamEvent toExpireEvent=streamEventCloner.copyStreamEvent(currentEvent);
        toExpireEvent.setType(StreamEvent.Type.EXPIRED);
        expiredEventChunk.add(toExpireEvent);
      }
    }
    newEventChunk.add(currentEventChunk.getFirst());
  }
  currentEventChunk.clear();
  if (newEventChunk.getFirst() != null) {
    complexEventChunks.add(newEventChunk);
  }
}",0.963970588235294
29027,"public Object[] currentState(){
  if (expiredEventChunk != null) {
    return new Object[]{currentEventChunk.getFirst(),endTime,startTime,isStartTimeEnabled,schedulerTimeout,resetEvent,expiredEventChunk.getFirst()};
  }
 else {
    return new Object[]{currentEventChunk.getFirst(),endTime,startTime,isStartTimeEnabled,schedulerTimeout,resetEvent};
  }
}","public Object[] currentState(){
  return new Object[]{currentEventChunk.getFirst(),expiredEventChunk != null ? expiredEventChunk.getFirst() : null,resetEvent,endTime,startTime,lastScheduledTime,lastCurrentEventTime,flushed};
}",0.4006908462867012
29028,"@Override public void receive(long timeStamp,Object[] data){
  stabilizeStates();
  for (  int anEventSequence : eventSequence) {
    StreamEventConverter aStreamEventConverter=streamEventConverters[anEventSequence];
    StreamEventPool aStreamEventPool=streamEventPools[anEventSequence];
    StreamEvent borrowedEvent=aStreamEventPool.borrowEvent();
    aStreamEventConverter.convertData(timeStamp,data,borrowedEvent);
    process(anEventSequence,borrowedEvent);
  }
}","@Override public void receive(long timeStamp,Object[] data){
synchronized (lockKey) {
    stabilizeStates();
    for (    int anEventSequence : eventSequence) {
      StreamEventConverter aStreamEventConverter=streamEventConverters[anEventSequence];
      StreamEventPool aStreamEventPool=streamEventPools[anEventSequence];
      StreamEvent borrowedEvent=aStreamEventPool.borrowEvent();
      aStreamEventConverter.convertData(timeStamp,data,borrowedEvent);
      process(anEventSequence,borrowedEvent);
    }
  }
}",0.936040609137056
29029,"public MultiProcessStreamReceiver clone(String key){
  return new MultiProcessStreamReceiver(streamId + key,processCount,latencyTracker);
}","public MultiProcessStreamReceiver clone(String key){
  return new MultiProcessStreamReceiver(streamId + key,key,processCount,latencyTracker);
}",0.9858156028368794
29030,"public MultiProcessStreamReceiver(String streamId,int processCount,LatencyTracker latencyTracker){
  super(streamId,latencyTracker);
  this.processCount=processCount;
  nextProcessors=new Processor[processCount];
  metaStreamEvents=new MetaStreamEvent[processCount];
  streamEventPools=new StreamEventPool[processCount];
  streamEventConverters=new StreamEventConverter[processCount];
  eventSequence=new int[processCount];
  for (int i=0; i < eventSequence.length; i++) {
    eventSequence[i]=i;
  }
}","public MultiProcessStreamReceiver(String streamId,String lockKey,int processCount,LatencyTracker latencyTracker){
  super(streamId,latencyTracker);
  this.lockKey=lockKey;
  this.processCount=processCount;
  nextProcessors=new Processor[processCount];
  metaStreamEvents=new MetaStreamEvent[processCount];
  streamEventPools=new StreamEventPool[processCount];
  streamEventConverters=new StreamEventConverter[processCount];
  eventSequence=new int[processCount];
  for (int i=0; i < eventSequence.length; i++) {
    eventSequence[i]=i;
  }
}",0.962607861936721
29031,"protected void processAndClear(int processIndex,StreamEvent streamEvent){
  ComplexEventChunk<StateEvent> retEventChunk=new ComplexEventChunk<StateEvent>(false);
  ComplexEventChunk<StreamEvent> currentStreamEventChunk=new ComplexEventChunk<StreamEvent>(streamEvent,streamEvent,false);
synchronized (lockKey) {
    ComplexEventChunk<StateEvent> eventChunk=((StreamPreStateProcessor)nextProcessors[processIndex]).processAndReturn(currentStreamEventChunk);
    if (eventChunk.getFirst() != null) {
      retEventChunk.add(eventChunk.getFirst());
    }
    eventChunk.clear();
  }
  if (querySelector != null) {
    while (retEventChunk.hasNext()) {
      StateEvent stateEvent=retEventChunk.next();
      retEventChunk.remove();
      querySelector.process(new ComplexEventChunk<StateEvent>(stateEvent,stateEvent,false));
    }
  }
}","protected void processAndClear(int processIndex,StreamEvent streamEvent){
  ComplexEventChunk<StateEvent> retEventChunk=new ComplexEventChunk<StateEvent>(false);
  ComplexEventChunk<StreamEvent> currentStreamEventChunk=new ComplexEventChunk<StreamEvent>(streamEvent,streamEvent,false);
  ComplexEventChunk<StateEvent> eventChunk=((StreamPreStateProcessor)nextProcessors[processIndex]).processAndReturn(currentStreamEventChunk);
  if (eventChunk.getFirst() != null) {
    retEventChunk.add(eventChunk.getFirst());
  }
  eventChunk.clear();
  if (querySelector != null) {
    while (retEventChunk.hasNext()) {
      StateEvent stateEvent=retEventChunk.next();
      retEventChunk.remove();
      querySelector.process(new ComplexEventChunk<StateEvent>(stateEvent,stateEvent,false));
    }
  }
}",0.9759704251386322
29032,"public StateMultiProcessStreamReceiver(String streamId,int processCount,String lockKey,LatencyTracker latencyTracker){
  super(streamId,processCount,latencyTracker);
  this.lockKey=lockKey;
}","public StateMultiProcessStreamReceiver(String streamId,int processCount,String lockKey,LatencyTracker latencyTracker){
  super(streamId,lockKey,processCount,latencyTracker);
}",0.912568306010929
29033,"@Override public void restoreState(Object[] state){
  currentStateEventChunk=(ComplexEventChunk<StateEvent>)state[0];
  pendingStateEventList=(ConcurrentLinkedQueue<StateEvent>)state[1];
  newAndEveryStateEventList=(LinkedList<StateEvent>)state[2];
}","@Override public void restoreState(Object[] state){
  currentStateEventChunk=(ComplexEventChunk<StateEvent>)state[0];
  pendingStateEventList=(LinkedList<StateEvent>)state[1];
  newAndEveryStateEventList=(LinkedList<StateEvent>)state[2];
}",0.9366053169734152
29034,"@Override public void restoreState(Object[] state){
  eventsList=(LinkedList<StreamEvent>)state[0];
  eventsMap=(TreeMap<Object,StreamEvent>)state[1];
}","@Override public void restoreState(Object[] state){
  eventsList=(ConcurrentLinkedQueue<StreamEvent>)state[0];
  eventsMap=(ConcurrentSkipListMap<Object,StreamEvent>)state[1];
}",0.8875379939209727
29035,"public InMemoryEventTable(TableDefinition tableDefinition,ExecutionPlanContext executionPlanContext){
  this.tableDefinition=tableDefinition;
  this.executionPlanContext=executionPlanContext;
  MetaStreamEvent metaStreamEvent=new MetaStreamEvent();
  metaStreamEvent.addInputDefinition(tableDefinition);
  for (  Attribute attribute : tableDefinition.getAttributeList()) {
    metaStreamEvent.addOutputData(attribute);
  }
  Annotation annotation=AnnotationHelper.getAnnotation(SiddhiConstants.ANNOTATION_INDEX_BY,tableDefinition.getAnnotations());
  if (annotation != null) {
    if (annotation.getElements().size() > 1) {
      throw new OperationNotSupportedException(SiddhiConstants.ANNOTATION_INDEX_BY + ""String_Node_Str"" + annotation.getElements().size()+ ""String_Node_Str"");
    }
    if (annotation.getElements().size() == 0) {
      throw new ExecutionPlanValidationException(SiddhiConstants.ANNOTATION_INDEX_BY + ""String_Node_Str"" + annotation.getElements().size()+ ""String_Node_Str"");
    }
    indexAttribute=annotation.getElements().get(0).getValue();
    indexPosition=tableDefinition.getAttributePosition(indexAttribute);
    eventsMap=new TreeMap<Object,StreamEvent>();
  }
 else {
    eventsList=new LinkedList<StreamEvent>();
  }
  streamEventPool=new StreamEventPool(metaStreamEvent,10);
  streamEventCloner=new StreamEventCloner(metaStreamEvent,streamEventPool);
}","public InMemoryEventTable(TableDefinition tableDefinition,ExecutionPlanContext executionPlanContext){
  this.tableDefinition=tableDefinition;
  this.executionPlanContext=executionPlanContext;
  MetaStreamEvent metaStreamEvent=new MetaStreamEvent();
  metaStreamEvent.addInputDefinition(tableDefinition);
  for (  Attribute attribute : tableDefinition.getAttributeList()) {
    metaStreamEvent.addOutputData(attribute);
  }
  Annotation annotation=AnnotationHelper.getAnnotation(SiddhiConstants.ANNOTATION_INDEX_BY,tableDefinition.getAnnotations());
  if (annotation != null) {
    if (annotation.getElements().size() > 1) {
      throw new OperationNotSupportedException(SiddhiConstants.ANNOTATION_INDEX_BY + ""String_Node_Str"" + annotation.getElements().size()+ ""String_Node_Str"");
    }
    if (annotation.getElements().size() == 0) {
      throw new ExecutionPlanValidationException(SiddhiConstants.ANNOTATION_INDEX_BY + ""String_Node_Str"" + annotation.getElements().size()+ ""String_Node_Str"");
    }
    indexAttribute=annotation.getElements().get(0).getValue();
    indexPosition=tableDefinition.getAttributePosition(indexAttribute);
    eventsMap=new ConcurrentSkipListMap<Object,StreamEvent>();
  }
 else {
    eventsList=new ConcurrentLinkedQueue<StreamEvent>();
  }
  streamEventPool=new StreamEventPool(metaStreamEvent,10);
  streamEventCloner=new StreamEventCloner(metaStreamEvent,streamEventPool);
}",0.9853204439670604
29036,"public static StreamRuntime parseInputStream(JoinInputStream joinInputStream,ExecutionPlanContext executionPlanContext,Map<String,AbstractDefinition> streamDefinitionMap,Map<String,AbstractDefinition> tableDefinitionMap,Map<String,EventTable> eventTableMap,List<VariableExpressionExecutor> executors,LatencyTracker latencyTracker,boolean outputExpectsExpiredEvents){
  ProcessStreamReceiver leftProcessStreamReceiver;
  ProcessStreamReceiver rightProcessStreamReceiver;
  MetaStreamEvent leftMetaStreamEvent=new MetaStreamEvent();
  MetaStreamEvent rightMetaStreamEvent=new MetaStreamEvent();
  String leftInputStreamId=((SingleInputStream)joinInputStream.getLeftInputStream()).getStreamId();
  String rightInputStreamId=((SingleInputStream)joinInputStream.getRightInputStream()).getStreamId();
  boolean leftOuterJoinProcessor=false;
  boolean rightOuterJoinProcessor=false;
  if (joinInputStream.getAllStreamIds().size() == 2) {
    if (!streamDefinitionMap.containsKey(leftInputStreamId)) {
      leftMetaStreamEvent.setTableEvent(true);
    }
    if (!streamDefinitionMap.containsKey(rightInputStreamId)) {
      rightMetaStreamEvent.setTableEvent(true);
    }
    leftProcessStreamReceiver=new ProcessStreamReceiver(leftInputStreamId,latencyTracker);
    rightProcessStreamReceiver=new ProcessStreamReceiver(rightInputStreamId,latencyTracker);
    if (leftMetaStreamEvent.isTableEvent() && rightMetaStreamEvent.isTableEvent()) {
      throw new ExecutionPlanCreationException(""String_Node_Str"" + leftInputStreamId + ""String_Node_Str""+ rightInputStreamId);
    }
  }
 else {
    if (streamDefinitionMap.containsKey(joinInputStream.getAllStreamIds().get(0))) {
      rightProcessStreamReceiver=new MultiProcessStreamReceiver(joinInputStream.getAllStreamIds().get(0),2,latencyTracker);
      leftProcessStreamReceiver=rightProcessStreamReceiver;
    }
 else {
      throw new ExecutionPlanCreationException(""String_Node_Str"" + leftInputStreamId + ""String_Node_Str""+ rightInputStreamId);
    }
  }
  SingleStreamRuntime leftStreamRuntime=SingleInputStreamParser.parseInputStream((SingleInputStream)joinInputStream.getLeftInputStream(),executionPlanContext,executors,streamDefinitionMap,!leftMetaStreamEvent.isTableEvent() ? null : tableDefinitionMap,eventTableMap,leftMetaStreamEvent,leftProcessStreamReceiver,true,latencyTracker,outputExpectsExpiredEvents);
  for (  VariableExpressionExecutor variableExpressionExecutor : executors) {
    variableExpressionExecutor.getPosition()[SiddhiConstants.STREAM_EVENT_CHAIN_INDEX]=0;
  }
  int size=executors.size();
  SingleStreamRuntime rightStreamRuntime=SingleInputStreamParser.parseInputStream((SingleInputStream)joinInputStream.getRightInputStream(),executionPlanContext,executors,streamDefinitionMap,!rightMetaStreamEvent.isTableEvent() ? null : tableDefinitionMap,eventTableMap,rightMetaStreamEvent,rightProcessStreamReceiver,true,latencyTracker,outputExpectsExpiredEvents);
  for (int i=size; i < executors.size(); i++) {
    VariableExpressionExecutor variableExpressionExecutor=executors.get(i);
    variableExpressionExecutor.getPosition()[SiddhiConstants.STREAM_EVENT_CHAIN_INDEX]=1;
  }
  if (leftMetaStreamEvent.isTableEvent()) {
    TableWindowProcessor tableWindowProcessor=new TableWindowProcessor(eventTableMap.get(leftInputStreamId));
    tableWindowProcessor.initProcessor(leftMetaStreamEvent.getLastInputDefinition(),new ExpressionExecutor[0],executionPlanContext,outputExpectsExpiredEvents);
    leftStreamRuntime.setProcessorChain(tableWindowProcessor);
  }
  if (rightMetaStreamEvent.isTableEvent()) {
    TableWindowProcessor tableWindowProcessor=new TableWindowProcessor(eventTableMap.get(rightInputStreamId));
    tableWindowProcessor.initProcessor(rightMetaStreamEvent.getLastInputDefinition(),new ExpressionExecutor[0],executionPlanContext,outputExpectsExpiredEvents);
    rightStreamRuntime.setProcessorChain(tableWindowProcessor);
  }
  MetaStateEvent metaStateEvent=new MetaStateEvent(2);
  metaStateEvent.addEvent(leftMetaStreamEvent);
  metaStateEvent.addEvent(rightMetaStreamEvent);
switch (joinInputStream.getType()) {
case FULL_OUTER_JOIN:
    leftOuterJoinProcessor=true;
case RIGHT_OUTER_JOIN:
  rightOuterJoinProcessor=true;
break;
case LEFT_OUTER_JOIN:
leftOuterJoinProcessor=true;
break;
}
Lock joinLock=new ReentrantLock();
JoinProcessor leftPreJoinProcessor=new JoinProcessor(true,true,leftOuterJoinProcessor);
JoinProcessor leftPostJoinProcessor=new JoinProcessor(true,false,leftOuterJoinProcessor);
FindableProcessor leftFindableProcessor=insertJoinProcessorsAndGetFindable(leftPreJoinProcessor,leftPostJoinProcessor,leftStreamRuntime,executionPlanContext,outputExpectsExpiredEvents);
JoinProcessor rightPreJoinProcessor=new JoinProcessor(false,true,rightOuterJoinProcessor);
JoinProcessor rightPostJoinProcessor=new JoinProcessor(false,false,rightOuterJoinProcessor);
FindableProcessor rightFindableProcessor=insertJoinProcessorsAndGetFindable(rightPreJoinProcessor,rightPostJoinProcessor,rightStreamRuntime,executionPlanContext,outputExpectsExpiredEvents);
leftPreJoinProcessor.setFindableProcessor(rightFindableProcessor);
leftPreJoinProcessor.setJoinLock(joinLock);
leftPostJoinProcessor.setFindableProcessor(rightFindableProcessor);
leftPostJoinProcessor.setJoinLock(joinLock);
rightPreJoinProcessor.setFindableProcessor(leftFindableProcessor);
rightPreJoinProcessor.setJoinLock(joinLock);
rightPostJoinProcessor.setFindableProcessor(leftFindableProcessor);
rightPostJoinProcessor.setJoinLock(joinLock);
Expression compareCondition=joinInputStream.getOnCompare();
if (compareCondition == null) {
compareCondition=Expression.value(true);
}
long withinTime=SiddhiConstants.ANY;
if (joinInputStream.getWithin() != null) {
withinTime=((TimeConstant)joinInputStream.getWithin()).getValue();
}
Finder leftFinder=rightFindableProcessor.constructFinder(compareCondition,metaStateEvent,executionPlanContext,executors,eventTableMap,0,withinTime);
Finder rightFinder=leftFindableProcessor.constructFinder(compareCondition,metaStateEvent,executionPlanContext,executors,eventTableMap,1,withinTime);
if (joinInputStream.getTrigger() != JoinInputStream.EventTrigger.LEFT) {
rightPreJoinProcessor.setTrigger(true);
rightPreJoinProcessor.setFinder(rightFinder);
rightPostJoinProcessor.setTrigger(true);
rightPostJoinProcessor.setFinder(rightFinder);
}
if (joinInputStream.getTrigger() != JoinInputStream.EventTrigger.RIGHT) {
leftPreJoinProcessor.setTrigger(true);
leftPreJoinProcessor.setFinder(leftFinder);
leftPostJoinProcessor.setTrigger(true);
leftPostJoinProcessor.setFinder(leftFinder);
}
JoinStreamRuntime joinStreamRuntime=new JoinStreamRuntime(executionPlanContext,metaStateEvent);
joinStreamRuntime.addRuntime(leftStreamRuntime);
joinStreamRuntime.addRuntime(rightStreamRuntime);
return joinStreamRuntime;
}","public static StreamRuntime parseInputStream(JoinInputStream joinInputStream,ExecutionPlanContext executionPlanContext,Map<String,AbstractDefinition> streamDefinitionMap,Map<String,AbstractDefinition> tableDefinitionMap,Map<String,EventTable> eventTableMap,List<VariableExpressionExecutor> executors,LatencyTracker latencyTracker,boolean outputExpectsExpiredEvents){
  ProcessStreamReceiver leftProcessStreamReceiver;
  ProcessStreamReceiver rightProcessStreamReceiver;
  MetaStreamEvent leftMetaStreamEvent=new MetaStreamEvent();
  MetaStreamEvent rightMetaStreamEvent=new MetaStreamEvent();
  String leftInputStreamId=((SingleInputStream)joinInputStream.getLeftInputStream()).getStreamId();
  String rightInputStreamId=((SingleInputStream)joinInputStream.getRightInputStream()).getStreamId();
  boolean leftOuterJoinProcessor=false;
  boolean rightOuterJoinProcessor=false;
  if (joinInputStream.getAllStreamIds().size() == 2) {
    if (!streamDefinitionMap.containsKey(leftInputStreamId)) {
      leftMetaStreamEvent.setTableEvent(true);
    }
    if (!streamDefinitionMap.containsKey(rightInputStreamId)) {
      rightMetaStreamEvent.setTableEvent(true);
    }
    leftProcessStreamReceiver=new ProcessStreamReceiver(leftInputStreamId,latencyTracker);
    rightProcessStreamReceiver=new ProcessStreamReceiver(rightInputStreamId,latencyTracker);
    if (leftMetaStreamEvent.isTableEvent() && rightMetaStreamEvent.isTableEvent()) {
      throw new ExecutionPlanCreationException(""String_Node_Str"" + leftInputStreamId + ""String_Node_Str""+ rightInputStreamId);
    }
  }
 else {
    if (streamDefinitionMap.containsKey(joinInputStream.getAllStreamIds().get(0))) {
      String defaultLockKey=""String_Node_Str"";
      rightProcessStreamReceiver=new MultiProcessStreamReceiver(joinInputStream.getAllStreamIds().get(0),defaultLockKey,2,latencyTracker);
      leftProcessStreamReceiver=rightProcessStreamReceiver;
    }
 else {
      throw new ExecutionPlanCreationException(""String_Node_Str"" + leftInputStreamId + ""String_Node_Str""+ rightInputStreamId);
    }
  }
  SingleStreamRuntime leftStreamRuntime=SingleInputStreamParser.parseInputStream((SingleInputStream)joinInputStream.getLeftInputStream(),executionPlanContext,executors,streamDefinitionMap,!leftMetaStreamEvent.isTableEvent() ? null : tableDefinitionMap,eventTableMap,leftMetaStreamEvent,leftProcessStreamReceiver,true,latencyTracker,outputExpectsExpiredEvents);
  for (  VariableExpressionExecutor variableExpressionExecutor : executors) {
    variableExpressionExecutor.getPosition()[SiddhiConstants.STREAM_EVENT_CHAIN_INDEX]=0;
  }
  int size=executors.size();
  SingleStreamRuntime rightStreamRuntime=SingleInputStreamParser.parseInputStream((SingleInputStream)joinInputStream.getRightInputStream(),executionPlanContext,executors,streamDefinitionMap,!rightMetaStreamEvent.isTableEvent() ? null : tableDefinitionMap,eventTableMap,rightMetaStreamEvent,rightProcessStreamReceiver,true,latencyTracker,outputExpectsExpiredEvents);
  for (int i=size; i < executors.size(); i++) {
    VariableExpressionExecutor variableExpressionExecutor=executors.get(i);
    variableExpressionExecutor.getPosition()[SiddhiConstants.STREAM_EVENT_CHAIN_INDEX]=1;
  }
  if (leftMetaStreamEvent.isTableEvent()) {
    TableWindowProcessor tableWindowProcessor=new TableWindowProcessor(eventTableMap.get(leftInputStreamId));
    tableWindowProcessor.initProcessor(leftMetaStreamEvent.getLastInputDefinition(),new ExpressionExecutor[0],executionPlanContext,outputExpectsExpiredEvents);
    leftStreamRuntime.setProcessorChain(tableWindowProcessor);
  }
  if (rightMetaStreamEvent.isTableEvent()) {
    TableWindowProcessor tableWindowProcessor=new TableWindowProcessor(eventTableMap.get(rightInputStreamId));
    tableWindowProcessor.initProcessor(rightMetaStreamEvent.getLastInputDefinition(),new ExpressionExecutor[0],executionPlanContext,outputExpectsExpiredEvents);
    rightStreamRuntime.setProcessorChain(tableWindowProcessor);
  }
  MetaStateEvent metaStateEvent=new MetaStateEvent(2);
  metaStateEvent.addEvent(leftMetaStreamEvent);
  metaStateEvent.addEvent(rightMetaStreamEvent);
switch (joinInputStream.getType()) {
case FULL_OUTER_JOIN:
    leftOuterJoinProcessor=true;
case RIGHT_OUTER_JOIN:
  rightOuterJoinProcessor=true;
break;
case LEFT_OUTER_JOIN:
leftOuterJoinProcessor=true;
break;
}
Lock joinLock=new ReentrantLock();
JoinProcessor leftPreJoinProcessor=new JoinProcessor(true,true,leftOuterJoinProcessor);
JoinProcessor leftPostJoinProcessor=new JoinProcessor(true,false,leftOuterJoinProcessor);
FindableProcessor leftFindableProcessor=insertJoinProcessorsAndGetFindable(leftPreJoinProcessor,leftPostJoinProcessor,leftStreamRuntime,executionPlanContext,outputExpectsExpiredEvents);
JoinProcessor rightPreJoinProcessor=new JoinProcessor(false,true,rightOuterJoinProcessor);
JoinProcessor rightPostJoinProcessor=new JoinProcessor(false,false,rightOuterJoinProcessor);
FindableProcessor rightFindableProcessor=insertJoinProcessorsAndGetFindable(rightPreJoinProcessor,rightPostJoinProcessor,rightStreamRuntime,executionPlanContext,outputExpectsExpiredEvents);
leftPreJoinProcessor.setFindableProcessor(rightFindableProcessor);
leftPreJoinProcessor.setJoinLock(joinLock);
leftPostJoinProcessor.setFindableProcessor(rightFindableProcessor);
leftPostJoinProcessor.setJoinLock(joinLock);
rightPreJoinProcessor.setFindableProcessor(leftFindableProcessor);
rightPreJoinProcessor.setJoinLock(joinLock);
rightPostJoinProcessor.setFindableProcessor(leftFindableProcessor);
rightPostJoinProcessor.setJoinLock(joinLock);
Expression compareCondition=joinInputStream.getOnCompare();
if (compareCondition == null) {
compareCondition=Expression.value(true);
}
long withinTime=SiddhiConstants.ANY;
if (joinInputStream.getWithin() != null) {
withinTime=((TimeConstant)joinInputStream.getWithin()).getValue();
}
Finder leftFinder=rightFindableProcessor.constructFinder(compareCondition,metaStateEvent,executionPlanContext,executors,eventTableMap,0,withinTime);
Finder rightFinder=leftFindableProcessor.constructFinder(compareCondition,metaStateEvent,executionPlanContext,executors,eventTableMap,1,withinTime);
if (joinInputStream.getTrigger() != JoinInputStream.EventTrigger.LEFT) {
rightPreJoinProcessor.setTrigger(true);
rightPreJoinProcessor.setFinder(rightFinder);
rightPostJoinProcessor.setTrigger(true);
rightPostJoinProcessor.setFinder(rightFinder);
}
if (joinInputStream.getTrigger() != JoinInputStream.EventTrigger.RIGHT) {
leftPreJoinProcessor.setTrigger(true);
leftPreJoinProcessor.setFinder(leftFinder);
leftPostJoinProcessor.setTrigger(true);
leftPostJoinProcessor.setFinder(leftFinder);
}
JoinStreamRuntime joinStreamRuntime=new JoinStreamRuntime(executionPlanContext,metaStateEvent);
joinStreamRuntime.addRuntime(leftStreamRuntime);
joinStreamRuntime.addRuntime(rightStreamRuntime);
return joinStreamRuntime;
}",0.995459871118922
29037,"@Override public synchronized Object processAdd(Object data){
  Long value=(Long)data;
  for (Iterator<Long> iterator=maxDeque.descendingIterator(); iterator.hasNext(); ) {
    if (iterator.next() < value) {
      iterator.remove();
    }
 else {
      break;
    }
  }
  maxDeque.addLast(value);
  if (maxValue == null) {
    maxValue=value;
  }
 else   if (maxValue < value) {
    maxValue=value;
  }
  return maxValue;
}","@Override public synchronized Object processAdd(Object data){
  Long value=(Long)data;
  for (Iterator<Long> iterator=maxDeque.descendingIterator(); iterator.hasNext(); ) {
    if (iterator.next() < value) {
      iterator.remove();
    }
 else {
      break;
    }
  }
  maxDeque.addLast(value);
  if (maxValue == null || maxValue < value) {
    maxValue=value;
  }
  return maxValue;
}",0.8518518518518519
29038,"@Override public synchronized Object processAdd(Object data){
  Long value=(Long)data;
  for (Iterator<Long> iterator=minDeque.descendingIterator(); iterator.hasNext(); ) {
    if (iterator.next() > value) {
      iterator.remove();
    }
  }
  minDeque.addLast(value);
  if (minValue == null) {
    minValue=value;
  }
 else   if (minValue > value) {
    minValue=value;
  }
  return minValue;
}","@Override public synchronized Object processAdd(Object data){
  Long value=(Long)data;
  for (Iterator<Long> iterator=minDeque.descendingIterator(); iterator.hasNext(); ) {
    if (iterator.next() > value) {
      iterator.remove();
    }
 else {
      break;
    }
  }
  minDeque.addLast(value);
  if (minValue == null || minValue > value) {
    minValue=value;
  }
  return minValue;
}",0.8122605363984674
29039,"public Object process(ComplexEvent event){
  if (attributeSize > 1) {
    Object[] data=new Object[attributeSize];
    for (int i=0; i < attributeSize; i++) {
      data[i]=attributeExpressionExecutors[i].execute(event);
    }
switch (event.getType()) {
case CURRENT:
      return processAdd(data);
case EXPIRED:
    return processRemove(data);
case RESET:
  return reset();
}
}
 else if (attributeSize == 1) {
switch (event.getType()) {
case CURRENT:
return processAdd(attributeExpressionExecutors[0].execute(event));
case EXPIRED:
return processRemove(attributeExpressionExecutors[0].execute(event));
case RESET:
return reset();
}
}
 else {
switch (event.getType()) {
case CURRENT:
return processAdd(null);
case EXPIRED:
return processRemove(null);
case RESET:
return reset();
}
}
return null;
}","public synchronized Object process(ComplexEvent event){
  if (attributeSize > 1) {
    Object[] data=new Object[attributeSize];
    for (int i=0; i < attributeSize; i++) {
      data[i]=attributeExpressionExecutors[i].execute(event);
    }
switch (event.getType()) {
case CURRENT:
      return processAdd(data);
case EXPIRED:
    return processRemove(data);
case RESET:
  return reset();
}
}
 else if (attributeSize == 1) {
switch (event.getType()) {
case CURRENT:
return processAdd(attributeExpressionExecutors[0].execute(event));
case EXPIRED:
return processRemove(attributeExpressionExecutors[0].execute(event));
case RESET:
return reset();
}
}
 else {
switch (event.getType()) {
case CURRENT:
return processAdd(null);
case EXPIRED:
return processRemove(null);
case RESET:
return reset();
}
}
return null;
}",0.9919103920348477
29040,"private void initializeConnection(){
  Statement stmt=null;
  Boolean tableExists=true;
  Connection con=null;
  try {
    con=dataSource.getConnection();
    stmt=con.createStatement();
    stmt.executeQuery(executionInfo.getPreparedTableExistenceCheckStatement());
  }
 catch (  SQLException e) {
    tableExists=false;
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + tableName + ""String_Node_Str"");
    }
  }
  try {
    if (!tableExists && stmt != null) {
      stmt.executeUpdate(executionInfo.getPreparedCreateTableStatement());
    }
  }
 catch (  SQLException e) {
    throw new ExecutionPlanRuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
 finally {
    cleanUpConnections(stmt,con);
  }
}","private void initializeConnection(){
  Statement stmt=null;
  Boolean tableExists=true;
  Connection con=null;
  try {
    con=dataSource.getConnection();
    stmt=con.createStatement();
    stmt.executeQuery(executionInfo.getPreparedTableExistenceCheckStatement());
  }
 catch (  SQLException e) {
    tableExists=false;
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + tableName + ""String_Node_Str"");
    }
  }
 finally {
    cleanUpConnections(stmt,con);
  }
  try {
    if (!tableExists) {
      con=dataSource.getConnection();
      stmt=con.createStatement();
      stmt.executeUpdate(executionInfo.getPreparedCreateTableStatement());
      if (con != null && !con.getAutoCommit()) {
        con.commit();
      }
    }
  }
 catch (  SQLException e) {
    try {
      if (con != null && !con.getAutoCommit()) {
        con.rollback();
      }
    }
 catch (    Exception ex) {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + tableName + ""String_Node_Str"",ex);
      }
    }
    throw new ExecutionPlanRuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
 finally {
    cleanUpConnections(stmt,con);
  }
}",0.6761904761904762
29041,"/** 
 * When an object implementing interface <code>Runnable</code> is used to create a thread, starting the thread causes the object's <code>run</code> method to be called in that separately executing thread. <p> The general contract of the method <code>run</code> is that it may take any action whatsoever.
 * @see Thread#run()
 */
@Override public void run(){
  Long toNotifyTime=toNotifyQueue.peek();
  long currentTime=System.currentTimeMillis();
  while (toNotifyTime != null && toNotifyTime - currentTime <= 0) {
    toNotifyQueue.poll();
    StreamEvent timerEvent=streamEventPool.borrowEvent();
    timerEvent.setType(StreamEvent.Type.TIMER);
    timerEvent.setTimestamp(currentTime);
    streamEventChunk.add(timerEvent);
    if (latencyTracker != null) {
      try {
        latencyTracker.markIn();
        singleThreadEntryValve.process(streamEventChunk);
      }
  finally {
        latencyTracker.markOut();
      }
    }
 else {
      singleThreadEntryValve.process(streamEventChunk);
    }
    streamEventChunk.clear();
    toNotifyTime=toNotifyQueue.peek();
    currentTime=System.currentTimeMillis();
  }
  if (toNotifyTime != null) {
    scheduledExecutorService.schedule(eventCaller,toNotifyTime - currentTime,TimeUnit.MILLISECONDS);
  }
 else {
synchronized (toNotifyQueue) {
      running=false;
      if (toNotifyQueue.peek() != null) {
        running=true;
        scheduledExecutorService.schedule(eventCaller,0,TimeUnit.MILLISECONDS);
      }
    }
  }
}","/** 
 * When an object implementing interface <code>Runnable</code> is used to create a thread, starting the thread causes the object's <code>run</code> method to be called in that separately executing thread. <p/> The general contract of the method <code>run</code> is that it may take any action whatsoever.
 * @see Thread#run()
 */
@Override public void run(){
  try {
    Long toNotifyTime=toNotifyQueue.peek();
    long currentTime=System.currentTimeMillis();
    while (toNotifyTime != null && toNotifyTime - currentTime <= 0) {
      toNotifyQueue.poll();
      StreamEvent timerEvent=streamEventPool.borrowEvent();
      timerEvent.setType(StreamEvent.Type.TIMER);
      timerEvent.setTimestamp(currentTime);
      streamEventChunk.add(timerEvent);
      if (latencyTracker != null) {
        try {
          latencyTracker.markIn();
          singleThreadEntryValve.process(streamEventChunk);
        }
  finally {
          latencyTracker.markOut();
        }
      }
 else {
        singleThreadEntryValve.process(streamEventChunk);
      }
      streamEventChunk.clear();
      toNotifyTime=toNotifyQueue.peek();
      currentTime=System.currentTimeMillis();
    }
    if (toNotifyTime != null) {
      scheduledExecutorService.schedule(eventCaller,toNotifyTime - currentTime,TimeUnit.MILLISECONDS);
    }
 else {
synchronized (toNotifyQueue) {
        running=false;
        if (toNotifyQueue.peek() != null) {
          running=true;
          scheduledExecutorService.schedule(eventCaller,0,TimeUnit.MILLISECONDS);
        }
      }
    }
  }
 catch (  Throwable t) {
    log.error(t);
  }
}",0.9598445595854922
29042,"public void handleExceptionWith(ExceptionHandler<Object> exceptionHandler){
  executionPlanContext.setExceptionHandler(exceptionHandler);
}","public void handleExceptionWith(ExceptionHandler<Object> exceptionHandler){
  executionPlanContext.setDisruptorExceptionHandler(exceptionHandler);
}",0.9686411149825784
29043,"public SiddhiContext(){
  setSiddhiExtensions(SiddhiExtensionLoader.loadSiddhiExtensions());
  eventBufferSize=SiddhiConstants.DEFAULT_EVENT_BUFFER_SIZE;
  siddhiDataSources=new ConcurrentHashMap<String,DataSource>();
  statisticsConfiguration=new StatisticsConfiguration(new SiddhiMetricsFactory());
  extensionHolderMap=new ConcurrentHashMap<Class,AbstractExtensionHolder>();
  exceptionHandler=new ExceptionHandler<Object>(){
    @Override public void handleEventException(    Throwable throwable,    long l,    Object event){
      log.error(""String_Node_Str"" + ""String_Node_Str"" + l + ""String_Node_Str""+ event.toString()+ ""String_Node_Str"",throwable);
    }
    @Override public void handleOnStartException(    Throwable throwable){
      log.error(""String_Node_Str"",throwable);
    }
    @Override public void handleOnShutdownException(    Throwable throwable){
      log.error(""String_Node_Str"",throwable);
    }
  }
;
}","public SiddhiContext(){
  setSiddhiExtensions(SiddhiExtensionLoader.loadSiddhiExtensions());
  eventBufferSize=SiddhiConstants.DEFAULT_EVENT_BUFFER_SIZE;
  siddhiDataSources=new ConcurrentHashMap<String,DataSource>();
  statisticsConfiguration=new StatisticsConfiguration(new SiddhiMetricsFactory());
  extensionHolderMap=new ConcurrentHashMap<Class,AbstractExtensionHolder>();
  defaultDisrupterExceptionHandler=new ExceptionHandler<Object>(){
    @Override public void handleEventException(    Throwable throwable,    long l,    Object event){
      log.error(""String_Node_Str"" + ""String_Node_Str"" + l + ""String_Node_Str""+ event.toString()+ ""String_Node_Str"",throwable);
    }
    @Override public void handleOnStartException(    Throwable throwable){
      log.error(""String_Node_Str"",throwable);
    }
    @Override public void handleOnShutdownException(    Throwable throwable){
      log.error(""String_Node_Str"",throwable);
    }
  }
;
}",0.990374331550802
29044,"public synchronized void startProcessing(){
  Boolean asyncEnabled=null;
  if (asyncEnabled != null && asyncEnabled || asyncEnabled == null) {
    for (    Constructor constructor : Disruptor.class.getConstructors()) {
      if (constructor.getParameterTypes().length == 5) {
        disruptor=new Disruptor<EventHolder>(new EventHolderFactory(),executionPlanContext.getSiddhiContext().getEventBufferSize(),executionPlanContext.getExecutorService(),ProducerType.SINGLE,PhasedBackoffWaitStrategy.withLiteLock(1,4,TimeUnit.SECONDS));
        break;
      }
    }
    if (disruptor == null) {
      disruptor=new Disruptor<EventHolder>(new EventHolderFactory(),executionPlanContext.getSiddhiContext().getEventBufferSize(),executionPlanContext.getExecutorService());
    }
    asyncEventHandler=new AsyncEventHandler(this);
    disruptor.handleExceptionsWith(executionPlanContext.getSiddhiContext().getExceptionHandler());
    disruptor.handleEventsWith(asyncEventHandler);
    ringBuffer=disruptor.start();
  }
}","public synchronized void startProcessing(){
  Boolean asyncEnabled=null;
  if (asyncEnabled != null && asyncEnabled || asyncEnabled == null) {
    for (    Constructor constructor : Disruptor.class.getConstructors()) {
      if (constructor.getParameterTypes().length == 5) {
        disruptor=new Disruptor<EventHolder>(new EventHolderFactory(),executionPlanContext.getSiddhiContext().getEventBufferSize(),executionPlanContext.getExecutorService(),ProducerType.SINGLE,PhasedBackoffWaitStrategy.withLiteLock(1,4,TimeUnit.SECONDS));
        break;
      }
    }
    if (disruptor == null) {
      disruptor=new Disruptor<EventHolder>(new EventHolderFactory(),executionPlanContext.getSiddhiContext().getEventBufferSize(),executionPlanContext.getExecutorService());
    }
    asyncEventHandler=new AsyncEventHandler(this);
    disruptor.handleExceptionsWith(executionPlanContext.getDisruptorExceptionHandler());
    disruptor.handleEventsWith(asyncEventHandler);
    ringBuffer=disruptor.start();
  }
}",0.9860557768924304
29045,"@Override protected void init(ExpressionExecutor[] attributeExpressionExecutors,ExecutionPlanContext executionPlanContext){
  this.expiredEventChunk=new ComplexEventChunk<StreamEvent>();
  if (attributeExpressionExecutors.length <= 2 && attributeExpressionExecutors.length <= 4) {
    if ((attributeExpressionExecutors[0] instanceof ConstantExpressionExecutor)) {
      throw new ExecutionPlanValidationException(""String_Node_Str"");
    }
    if (attributeExpressionExecutors[0].getReturnType() != Attribute.Type.LONG) {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors[0].getReturnType());
    }
    timestampExpressionExecutor=attributeExpressionExecutors[0];
    if (attributeExpressionExecutors[1].getReturnType() == Attribute.Type.INT) {
      timeToKeep=(Integer)((ConstantExpressionExecutor)attributeExpressionExecutors[1]).getValue();
    }
 else     if (attributeExpressionExecutors[1].getReturnType() == Attribute.Type.LONG) {
      timeToKeep=(Long)((ConstantExpressionExecutor)attributeExpressionExecutors[1]).getValue();
    }
 else {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors[1].getReturnType());
    }
    if (attributeExpressionExecutors.length <= 3) {
      isStartTimeEnabled=true;
      if (attributeExpressionExecutors[2].getReturnType() == Attribute.Type.INT) {
        startTime=Integer.parseInt(String.valueOf(((ConstantExpressionExecutor)attributeExpressionExecutors[2]).getValue()));
      }
 else       if (attributeExpressionExecutors[2].getReturnType() == Attribute.Type.LONG) {
        startTime=Long.parseLong(String.valueOf(((ConstantExpressionExecutor)attributeExpressionExecutors[2]).getValue()));
      }
 else {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors[2].getReturnType());
      }
    }
    if (attributeExpressionExecutors.length == 4) {
      if (attributeExpressionExecutors[3].getReturnType() == Attribute.Type.INT) {
        schedulerTimeout=Integer.parseInt(String.valueOf(((ConstantExpressionExecutor)attributeExpressionExecutors[3]).getValue()));
      }
 else       if (attributeExpressionExecutors[3].getReturnType() == Attribute.Type.LONG) {
        schedulerTimeout=Long.parseLong(String.valueOf(((ConstantExpressionExecutor)attributeExpressionExecutors[3]).getValue()));
      }
 else {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors[3].getReturnType());
      }
    }
  }
 else {
    throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors.length + ""String_Node_Str"");
  }
}","@Override protected void init(ExpressionExecutor[] attributeExpressionExecutors,ExecutionPlanContext executionPlanContext){
  this.expiredEventChunk=new ComplexEventChunk<StreamEvent>();
  if (attributeExpressionExecutors.length >= 2 && attributeExpressionExecutors.length <= 4) {
    if ((attributeExpressionExecutors[0] instanceof ConstantExpressionExecutor)) {
      throw new ExecutionPlanValidationException(""String_Node_Str"");
    }
    if (attributeExpressionExecutors[0].getReturnType() != Attribute.Type.LONG) {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors[0].getReturnType());
    }
    timestampExpressionExecutor=attributeExpressionExecutors[0];
    if (attributeExpressionExecutors[1].getReturnType() == Attribute.Type.INT) {
      timeToKeep=(Integer)((ConstantExpressionExecutor)attributeExpressionExecutors[1]).getValue();
    }
 else     if (attributeExpressionExecutors[1].getReturnType() == Attribute.Type.LONG) {
      timeToKeep=(Long)((ConstantExpressionExecutor)attributeExpressionExecutors[1]).getValue();
    }
 else {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors[1].getReturnType());
    }
    if (attributeExpressionExecutors.length == 3) {
      isStartTimeEnabled=true;
      if (attributeExpressionExecutors[2].getReturnType() == Attribute.Type.INT) {
        startTime=Integer.parseInt(String.valueOf(((ConstantExpressionExecutor)attributeExpressionExecutors[2]).getValue()));
      }
 else       if (attributeExpressionExecutors[2].getReturnType() == Attribute.Type.LONG) {
        startTime=Long.parseLong(String.valueOf(((ConstantExpressionExecutor)attributeExpressionExecutors[2]).getValue()));
      }
 else {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors[2].getReturnType());
      }
    }
    if (attributeExpressionExecutors.length == 4) {
      if (attributeExpressionExecutors[3].getReturnType() == Attribute.Type.INT) {
        schedulerTimeout=Integer.parseInt(String.valueOf(((ConstantExpressionExecutor)attributeExpressionExecutors[3]).getValue()));
      }
 else       if (attributeExpressionExecutors[3].getReturnType() == Attribute.Type.LONG) {
        schedulerTimeout=Long.parseLong(String.valueOf(((ConstantExpressionExecutor)attributeExpressionExecutors[3]).getValue()));
      }
 else {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors[3].getReturnType());
      }
    }
  }
 else {
    throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors.length + ""String_Node_Str"");
  }
}",0.999252895031752
29046,"@Override protected void process(ComplexEventChunk<StreamEvent> streamEventChunk,Processor nextProcessor,StreamEventCloner streamEventCloner){
synchronized (this) {
    if (nextEmitTime == -1) {
      long currentTime=executionPlanContext.getTimestampGenerator().currentTime();
      if (isStartTimeEnabled) {
        nextEmitTime=getNextEmitTime(currentTime) + timeInMilliSeconds;
      }
 else {
        nextEmitTime=executionPlanContext.getTimestampGenerator().currentTime();
      }
      scheduler.notifyAt(nextEmitTime);
    }
    long currentTime=executionPlanContext.getTimestampGenerator().currentTime();
    boolean sendEvents;
    if (currentTime >= nextEmitTime) {
      nextEmitTime+=timeInMilliSeconds;
      if (currentEventChunk.getFirst() != null || expiredEventChunk.getFirst() != null) {
        scheduler.notifyAt(nextEmitTime);
      }
      sendEvents=true;
    }
 else {
      sendEvents=false;
    }
    while (streamEventChunk.hasNext()) {
      StreamEvent streamEvent=streamEventChunk.next();
      if (streamEvent.getType() != ComplexEvent.Type.CURRENT) {
        continue;
      }
      StreamEvent clonedStreamEvent=streamEventCloner.copyStreamEvent(streamEvent);
      currentEventChunk.add(clonedStreamEvent);
    }
    streamEventChunk.clear();
    if (sendEvents) {
      currentEventChunk.reset();
      while (expiredEventChunk.hasNext()) {
        StreamEvent expiredEvent=expiredEventChunk.next();
        expiredEvent.setTimestamp(currentTime);
      }
      if (expiredEventChunk.getFirst() != null) {
        streamEventChunk.add(expiredEventChunk.getFirst());
      }
      expiredEventChunk.clear();
      while (currentEventChunk.hasNext()) {
        StreamEvent currentEvent=currentEventChunk.next();
        StreamEvent toExpireEvent=streamEventCloner.copyStreamEvent(currentEvent);
        toExpireEvent.setType(StreamEvent.Type.EXPIRED);
        expiredEventChunk.add(toExpireEvent);
      }
      if (currentEventChunk.getFirst() != null) {
        streamEventChunk.add(currentEventChunk.getFirst());
      }
      currentEventChunk.clear();
    }
  }
  if (streamEventChunk.getFirst() != null) {
    nextProcessor.process(streamEventChunk);
  }
}","@Override protected void process(ComplexEventChunk<StreamEvent> streamEventChunk,Processor nextProcessor,StreamEventCloner streamEventCloner){
synchronized (this) {
    if (nextEmitTime == -1) {
      long currentTime=executionPlanContext.getTimestampGenerator().currentTime();
      if (isStartTimeEnabled) {
        nextEmitTime=getNextEmitTime(currentTime);
      }
 else {
        nextEmitTime=executionPlanContext.getTimestampGenerator().currentTime() + timeInMilliSeconds;
      }
      scheduler.notifyAt(nextEmitTime);
    }
    long currentTime=executionPlanContext.getTimestampGenerator().currentTime();
    boolean sendEvents;
    if (currentTime >= nextEmitTime) {
      nextEmitTime+=timeInMilliSeconds;
      if (currentEventChunk.getFirst() != null || expiredEventChunk.getFirst() != null) {
        scheduler.notifyAt(nextEmitTime);
      }
      sendEvents=true;
    }
 else {
      sendEvents=false;
    }
    while (streamEventChunk.hasNext()) {
      StreamEvent streamEvent=streamEventChunk.next();
      if (streamEvent.getType() != ComplexEvent.Type.CURRENT) {
        continue;
      }
      StreamEvent clonedStreamEvent=streamEventCloner.copyStreamEvent(streamEvent);
      currentEventChunk.add(clonedStreamEvent);
    }
    streamEventChunk.clear();
    if (sendEvents) {
      currentEventChunk.reset();
      while (expiredEventChunk.hasNext()) {
        StreamEvent expiredEvent=expiredEventChunk.next();
        expiredEvent.setTimestamp(currentTime);
      }
      if (expiredEventChunk.getFirst() != null) {
        streamEventChunk.add(expiredEventChunk.getFirst());
      }
      expiredEventChunk.clear();
      while (currentEventChunk.hasNext()) {
        StreamEvent currentEvent=currentEventChunk.next();
        StreamEvent toExpireEvent=streamEventCloner.copyStreamEvent(currentEvent);
        toExpireEvent.setType(StreamEvent.Type.EXPIRED);
        expiredEventChunk.add(toExpireEvent);
      }
      if (currentEventChunk.getFirst() != null) {
        streamEventChunk.add(currentEventChunk.getFirst());
      }
      currentEventChunk.clear();
    }
  }
  if (streamEventChunk.getFirst() != null) {
    nextProcessor.process(streamEventChunk);
  }
}",0.9558287795992714
29047,"/** 
 * Create and start disruptor based on annotations given in the streamDefinition.
 */
public synchronized void startProcessing(){
  if (!receivers.isEmpty()) {
    if (parallel == null) {
      parallel=executionPlanContext.isParallel();
    }
    if (parallel) {
      for (      Constructor constructor : Disruptor.class.getConstructors()) {
        if (constructor.getParameterTypes().length == 5) {
          ProducerType producerType=ProducerType.SINGLE;
          if (publishers.size() > 1) {
            producerType=ProducerType.MULTI;
          }
          disruptor=new Disruptor<Event>(new EventFactory(streamDefinition.getAttributeList().size()),bufferSize,executorService,producerType,PhasedBackoffWaitStrategy.withLiteLock(1,4,TimeUnit.SECONDS));
          disruptor.handleExceptionsWith(executionPlanContext.getSiddhiContext().getExceptionHandler());
          break;
        }
      }
      if (disruptor == null) {
        disruptor=new Disruptor<Event>(new EventFactory(streamDefinition.getAttributeList().size()),bufferSize,executorService);
        disruptor.handleExceptionsWith(executionPlanContext.getSiddhiContext().getExceptionHandler());
      }
      for (      Receiver receiver : receivers) {
        disruptor.handleEventsWith(new StreamHandler(receiver));
      }
      ringBuffer=disruptor.start();
    }
 else {
      for (      Receiver receiver : receivers) {
        if (receiver instanceof StreamCallback) {
          ((StreamCallback)receiver).startProcessing();
        }
      }
    }
  }
}","/** 
 * Create and start disruptor based on annotations given in the streamDefinition.
 */
public synchronized void startProcessing(){
  if (!receivers.isEmpty()) {
    if (parallel == null) {
      parallel=executionPlanContext.isParallel();
    }
    if (parallel) {
      for (      Constructor constructor : Disruptor.class.getConstructors()) {
        if (constructor.getParameterTypes().length == 5) {
          ProducerType producerType=ProducerType.SINGLE;
          if (publishers.size() > 1) {
            producerType=ProducerType.MULTI;
          }
          disruptor=new Disruptor<Event>(new EventFactory(streamDefinition.getAttributeList().size()),bufferSize,executorService,producerType,PhasedBackoffWaitStrategy.withLiteLock(1,4,TimeUnit.SECONDS));
          disruptor.handleExceptionsWith(executionPlanContext.getDisruptorExceptionHandler());
          break;
        }
      }
      if (disruptor == null) {
        disruptor=new Disruptor<Event>(new EventFactory(streamDefinition.getAttributeList().size()),bufferSize,executorService);
        disruptor.handleExceptionsWith(executionPlanContext.getDisruptorExceptionHandler());
      }
      for (      Receiver receiver : receivers) {
        disruptor.handleEventsWith(new StreamHandler(receiver));
      }
      ringBuffer=disruptor.start();
    }
 else {
      for (      Receiver receiver : receivers) {
        if (receiver instanceof StreamCallback) {
          ((StreamCallback)receiver).startProcessing();
        }
      }
    }
  }
}",0.981639344262295
29048,"@Test public void FilterTest117() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String cseEventStream=""String_Node_Str"";
  String query=""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(cseEventStream + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      count=count + inEvents.length;
      eventArrived=true;
      if (count == 1) {
        Assert.assertEquals(1465.5f,inEvents[0].getData()[1]);
      }
    }
  }
);
  InputHandler inputHandler=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  inputHandler.send(new Object[]{""String_Node_Str"",700f,100l});
  inputHandler.send(new Object[]{""String_Node_Str"",60.5f,200l});
  inputHandler.send(new Object[]{""String_Node_Str"",700f,100l});
  Thread.sleep(1000);
  Assert.assertEquals(1,count);
  Assert.assertTrue(eventArrived);
  executionPlanRuntime.shutdown();
}","@Test public void FilterTest117() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String cseEventStream=""String_Node_Str"";
  String query=""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(cseEventStream + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      count=count + inEvents.length;
      eventArrived=true;
      if (count == 1) {
        Assert.assertEquals(1465.5,inEvents[0].getData()[1]);
      }
    }
  }
);
  InputHandler inputHandler=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  inputHandler.send(new Object[]{""String_Node_Str"",700f,100l});
  inputHandler.send(new Object[]{""String_Node_Str"",60.5f,200l});
  inputHandler.send(new Object[]{""String_Node_Str"",700f,100l});
  Thread.sleep(1000);
  Assert.assertEquals(1,count);
  Assert.assertTrue(eventArrived);
  executionPlanRuntime.shutdown();
}",0.9995731967562952
29049,"@Test public void testWindowPartitionQuery4() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String executionPlan=""String_Node_Str"" + ""String_Node_Str"";
  ExecutionPlanRuntime executionRuntime=siddhiManager.createExecutionPlanRuntime(executionPlan);
  executionRuntime.addCallback(""String_Node_Str"",new StreamCallback(){
    @Override public void receive(    Event[] events){
      EventPrinter.print(events);
      for (      Event event : events) {
        if (event.isExpired()) {
          removeEventCount++;
        }
 else {
          inEventCount++;
          if (inEventCount == 1) {
            Assert.assertEquals(70.0,event.getData()[1]);
          }
 else           if (inEventCount == 2) {
            Assert.assertEquals(700.0,event.getData()[1]);
          }
 else           if (inEventCount == 3) {
            Assert.assertEquals(300.0,event.getData()[1]);
          }
 else           if (inEventCount == 4) {
            Assert.assertEquals(75.5999984741211,event.getData()[1]);
          }
 else           if (inEventCount == 5) {
            Assert.assertEquals(1500.0,event.getData()[1]);
          }
        }
        eventArrived=true;
      }
    }
  }
);
  InputHandler inputHandler=executionRuntime.getInputHandler(""String_Node_Str"");
  executionRuntime.start();
  inputHandler.send(new Object[]{""String_Node_Str"",70f,100});
  inputHandler.send(new Object[]{""String_Node_Str"",700f,100});
  inputHandler.send(new Object[]{""String_Node_Str"",100f,100});
  inputHandler.send(new Object[]{""String_Node_Str"",200f,100});
  inputHandler.send(new Object[]{""String_Node_Str"",75.6f,100});
  inputHandler.send(new Object[]{""String_Node_Str"",1000f,100});
  inputHandler.send(new Object[]{""String_Node_Str"",500f,100});
  Thread.sleep(1000);
  Assert.assertTrue(eventArrived);
  Assert.assertTrue(7 >= inEventCount);
  Assert.assertEquals(0,removeEventCount);
  executionRuntime.shutdown();
}","@Test public void testWindowPartitionQuery4() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String executionPlan=""String_Node_Str"" + ""String_Node_Str"";
  ExecutionPlanRuntime executionRuntime=siddhiManager.createExecutionPlanRuntime(executionPlan);
  executionRuntime.addCallback(""String_Node_Str"",new StreamCallback(){
    @Override public void receive(    Event[] events){
      EventPrinter.print(events);
      for (      Event event : events) {
        if (event.isExpired()) {
          removeEventCount++;
        }
 else {
          inEventCount++;
          if (inEventCount == 1) {
            Assert.assertEquals(70.0,event.getData()[1]);
          }
 else           if (inEventCount == 2) {
            Assert.assertEquals(700.0,event.getData()[1]);
          }
 else           if (inEventCount == 3) {
            Assert.assertEquals(170.0,event.getData()[1]);
          }
 else           if (inEventCount == 4) {
            Assert.assertEquals(300.0,event.getData()[1]);
          }
 else           if (inEventCount == 5) {
            Assert.assertEquals(75.5999984741211,event.getData()[1]);
          }
 else           if (inEventCount == 6) {
            Assert.assertEquals(1700.0,event.getData()[1]);
          }
 else           if (inEventCount == 7) {
            Assert.assertEquals(1500.0,event.getData()[1]);
          }
        }
        eventArrived=true;
      }
    }
  }
);
  InputHandler inputHandler=executionRuntime.getInputHandler(""String_Node_Str"");
  executionRuntime.start();
  inputHandler.send(new Object[]{""String_Node_Str"",70f,100});
  inputHandler.send(new Object[]{""String_Node_Str"",700f,100});
  inputHandler.send(new Object[]{""String_Node_Str"",100f,100});
  inputHandler.send(new Object[]{""String_Node_Str"",200f,100});
  inputHandler.send(new Object[]{""String_Node_Str"",75.6f,100});
  inputHandler.send(new Object[]{""String_Node_Str"",1000f,100});
  inputHandler.send(new Object[]{""String_Node_Str"",500f,100});
  Thread.sleep(1000);
  Assert.assertTrue(eventArrived);
  Assert.assertTrue(7 >= inEventCount);
  Assert.assertEquals(0,removeEventCount);
  executionRuntime.shutdown();
}",0.9445644348452124
29050,"@Override protected synchronized void process(ComplexEventChunk<StreamEvent> streamEventChunk,Processor nextProcessor,StreamEventCloner streamEventCloner){
  while (streamEventChunk.hasNext()) {
    long currentTime=executionPlanContext.getTimestampGenerator().currentTime();
    while (streamEventChunk.hasNext()) {
      StreamEvent streamEvent=streamEventChunk.next();
      expiredEventChunk.reset();
      while (expiredEventChunk.hasNext()) {
        StreamEvent expiredEvent=expiredEventChunk.next();
        long timeDiff=expiredEvent.getTimestamp() - currentTime + timeInMilliSeconds;
        if (timeDiff <= 0) {
          expiredEventChunk.remove();
          expiredEvent.setTimestamp(currentTime);
          streamEventChunk.insertBeforeCurrent(expiredEvent);
        }
 else {
          break;
        }
      }
      if (streamEvent.getType() == StreamEvent.Type.CURRENT) {
        StreamEvent clonedEvent=streamEventCloner.copyStreamEvent(streamEvent);
        clonedEvent.setType(StreamEvent.Type.EXPIRED);
        this.expiredEventChunk.add(clonedEvent);
        if (lastTimestamp < clonedEvent.getTimestamp()) {
          scheduler.notifyAt(clonedEvent.getTimestamp() + timeInMilliSeconds);
          lastTimestamp=clonedEvent.getTimestamp();
        }
      }
    }
    expiredEventChunk.reset();
  }
  nextProcessor.process(streamEventChunk);
}","@Override protected synchronized void process(ComplexEventChunk<StreamEvent> streamEventChunk,Processor nextProcessor,StreamEventCloner streamEventCloner){
  while (streamEventChunk.hasNext()) {
    long currentTime=executionPlanContext.getTimestampGenerator().currentTime();
    StreamEvent streamEvent=streamEventChunk.next();
    expiredEventChunk.reset();
    while (expiredEventChunk.hasNext()) {
      StreamEvent expiredEvent=expiredEventChunk.next();
      long timeDiff=expiredEvent.getTimestamp() - currentTime + timeInMilliSeconds;
      if (timeDiff <= 0) {
        expiredEventChunk.remove();
        expiredEvent.setTimestamp(currentTime);
        streamEventChunk.insertBeforeCurrent(expiredEvent);
      }
 else {
        break;
      }
    }
    if (streamEvent.getType() == StreamEvent.Type.CURRENT) {
      StreamEvent clonedEvent=streamEventCloner.copyStreamEvent(streamEvent);
      clonedEvent.setType(StreamEvent.Type.EXPIRED);
      this.expiredEventChunk.add(clonedEvent);
      if (lastTimestamp < clonedEvent.getTimestamp()) {
        scheduler.notifyAt(clonedEvent.getTimestamp() + timeInMilliSeconds);
        lastTimestamp=clonedEvent.getTimestamp();
      }
    }
    expiredEventChunk.reset();
  }
  nextProcessor.process(streamEventChunk);
}",0.8101553618794998
29051,"@Override protected synchronized void process(ComplexEventChunk<StreamEvent> streamEventChunk,Processor nextProcessor,StreamEventCloner streamEventCloner){
  long currentTime=executionPlanContext.getTimestampGenerator().currentTime();
  while (streamEventChunk.hasNext()) {
    StreamEvent streamEvent=streamEventChunk.next();
    StreamEvent clonedEvent=streamEventCloner.copyStreamEvent(streamEvent);
    clonedEvent.setType(StreamEvent.Type.EXPIRED);
    boolean eventScheduled=false;
    while (expiredEventChunk.hasNext()) {
      StreamEvent expiredEvent=expiredEventChunk.next();
      long timeDiff=expiredEvent.getTimestamp() - currentTime + timeInMilliSeconds;
      if (timeDiff <= 0) {
        expiredEventChunk.remove();
        expiredEvent.setTimestamp(currentTime);
        streamEventChunk.insertBeforeCurrent(expiredEvent);
      }
 else {
        scheduler.notifyAt(expiredEvent.getTimestamp() + timeInMilliSeconds);
        expiredEventChunk.reset();
        eventScheduled=true;
        break;
      }
    }
    if (streamEvent.getType() == StreamEvent.Type.CURRENT) {
      this.expiredEventChunk.add(clonedEvent);
      if (!eventScheduled) {
        scheduler.notifyAt(clonedEvent.getTimestamp() + timeInMilliSeconds);
      }
    }
    expiredEventChunk.reset();
  }
  nextProcessor.process(streamEventChunk);
}","@Override protected synchronized void process(ComplexEventChunk<StreamEvent> streamEventChunk,Processor nextProcessor,StreamEventCloner streamEventCloner){
  long currentTime=executionPlanContext.getTimestampGenerator().currentTime();
  while (streamEventChunk.hasNext()) {
    StreamEvent streamEvent=streamEventChunk.next();
    StreamEvent clonedEvent=streamEventCloner.copyStreamEvent(streamEvent);
    clonedEvent.setType(StreamEvent.Type.EXPIRED);
    while (expiredEventChunk.hasNext()) {
      StreamEvent expiredEvent=expiredEventChunk.next();
      long timeDiff=expiredEvent.getTimestamp() - currentTime + timeInMilliSeconds;
      if (timeDiff <= 0) {
        expiredEventChunk.remove();
        expiredEvent.setTimestamp(currentTime);
        streamEventChunk.insertBeforeCurrent(expiredEvent);
      }
 else {
        scheduler.notifyAt(expiredEvent.getTimestamp() + timeInMilliSeconds);
        expiredEventChunk.reset();
        break;
      }
    }
    if (streamEvent.getType() == StreamEvent.Type.CURRENT) {
      this.expiredEventChunk.add(clonedEvent);
      if (lastTimestamp < clonedEvent.getTimestamp()) {
        scheduler.notifyAt(clonedEvent.getTimestamp() + timeInMilliSeconds);
      }
      scheduler.notifyAt(clonedEvent.getTimestamp());
      lastTimestamp=clonedEvent.getTimestamp();
    }
    expiredEventChunk.reset();
  }
  nextProcessor.process(streamEventChunk);
}",0.918918918918919
29052,"@Override public void stop(){
  try {
    scheduler.deleteJob(new JobKey(jobName,jobGroup));
  }
 catch (  SchedulerException e) {
    log.error(""String_Node_Str"" + e.getMessage(),e);
  }
}","@Override public void stop(){
  try {
    if (scheduler != null) {
      scheduler.deleteJob(new JobKey(jobName,jobGroup));
    }
  }
 catch (  SchedulerException e) {
    log.error(""String_Node_Str"" + e.getMessage(),e);
  }
}",0.910843373493976
29053,"private void scheduleCronJob(String cronString,String elementId){
  try {
    SchedulerFactory schedulerFactory=new StdSchedulerFactory();
    scheduler=schedulerFactory.getScheduler();
    scheduler.start();
    JobDataMap dataMap=new JobDataMap();
    dataMap.put(""String_Node_Str"",this);
    jobName=""String_Node_Str"" + elementId;
    JobDetail job=org.quartz.JobBuilder.newJob(CronEventTrigger.class).withIdentity(jobName,jobGroup).usingJobData(dataMap).build();
    Trigger trigger=org.quartz.TriggerBuilder.newTrigger().withIdentity(""String_Node_Str"" + elementId,jobGroup).withSchedule(CronScheduleBuilder.cronSchedule(cronString)).build();
    scheduler.scheduleJob(job,trigger);
  }
 catch (  SchedulerException e) {
    log.error(""String_Node_Str"" + triggerDefinition.getId() + ""String_Node_Str""+ e.getMessage(),e);
  }
}","private void scheduleCronJob(String cronString,String elementId){
  try {
    SchedulerFactory schedulerFactory=new StdSchedulerFactory();
    scheduler=schedulerFactory.getScheduler();
    jobName=""String_Node_Str"" + elementId;
    JobKey jobKey=new JobKey(jobName,jobGroup);
    if (scheduler.checkExists(jobKey)) {
      scheduler.deleteJob(jobKey);
    }
    scheduler.start();
    JobDataMap dataMap=new JobDataMap();
    dataMap.put(""String_Node_Str"",this);
    JobDetail job=org.quartz.JobBuilder.newJob(CronEventTrigger.class).withIdentity(jobName,jobGroup).usingJobData(dataMap).build();
    Trigger trigger=org.quartz.TriggerBuilder.newTrigger().withIdentity(""String_Node_Str"" + elementId,jobGroup).withSchedule(CronScheduleBuilder.cronSchedule(cronString)).build();
    scheduler.scheduleJob(job,trigger);
  }
 catch (  SchedulerException e) {
    log.error(""String_Node_Str"" + triggerDefinition.getId() + ""String_Node_Str""+ e.getMessage(),e);
  }
}",0.8100558659217877
29054,"/** 
 * Event Table initialization method, it checks the annotation and do necessary pre configuration tasks.
 * @param tableDefinition      Definition of event table
 * @param executionPlanContext ExecutionPlan related meta information
 */
public void init(TableDefinition tableDefinition,ExecutionPlanContext executionPlanContext){
  this.tableDefinition=tableDefinition;
  Connection con=null;
  int bloomFilterSize=RDBMSEventTableConstants.BLOOM_FILTER_SIZE;
  int bloomFilterHashFunctions=RDBMSEventTableConstants.BLOOM_FILTER_HASH_FUNCTIONS;
  Annotation fromAnnotation=AnnotationHelper.getAnnotation(SiddhiConstants.ANNOTATION_FROM,tableDefinition.getAnnotations());
  String dataSourceName=fromAnnotation.getElement(RDBMSEventTableConstants.ANNOTATION_ELEMENT_DATASOURCE_NAME);
  String tableName=fromAnnotation.getElement(RDBMSEventTableConstants.ANNOTATION_ELEMENT_TABLE_NAME);
  DataSource dataSource=executionPlanContext.getSiddhiContext().getSiddhiDataSource(dataSourceName);
  List<Attribute> attributeList=tableDefinition.getAttributeList();
  if (dataSource == null) {
    String jdbcConnectionUrl=fromAnnotation.getElement(RDBMSEventTableConstants.EVENT_TABLE_RDBMS_TABLE_JDBC_URL);
    String username=fromAnnotation.getElement(RDBMSEventTableConstants.EVENT_TABLE_RDBMS_TABLE_USERNAME);
    String password=fromAnnotation.getElement(RDBMSEventTableConstants.EVENT_TABLE_RDBMS_TABLE_PASSWORD);
    String driverName=fromAnnotation.getElement(RDBMSEventTableConstants.EVENT_TABLE_RDBMS_TABLE_DRIVER_NAME);
    List<Element> connectionPropertyElements=null;
    Annotation connectionAnnotation=AnnotationHelper.getAnnotation(RDBMSEventTableConstants.ANNOTATION_CONNECTION,tableDefinition.getAnnotations());
    if (connectionAnnotation != null) {
      connectionPropertyElements=connectionAnnotation.getElements();
    }
    dataSource=PooledDataSource.getPoolDataSource(driverName,jdbcConnectionUrl,username,password,connectionPropertyElements);
  }
  if (dataSource == null || tableName == null) {
    throw new ExecutionPlanCreationException(""String_Node_Str"");
  }
  String cacheType=fromAnnotation.getElement(RDBMSEventTableConstants.ANNOTATION_ELEMENT_CACHE);
  cacheSizeInString=fromAnnotation.getElement(RDBMSEventTableConstants.ANNOTATION_ELEMENT_CACHE_SIZE);
  String cacheLoadingType=fromAnnotation.getElement(RDBMSEventTableConstants.ANNOTATION_ELEMENT_CACHE_LOADING);
  String cacheValidityInterval=fromAnnotation.getElement(RDBMSEventTableConstants.ANNOTATION_ELEMENT_CACHE_VALIDITY_PERIOD);
  String bloomsEnabled=fromAnnotation.getElement(RDBMSEventTableConstants.ANNOTATION_ELEMENT_BLOOM_FILTERS);
  String bloomFilterValidityInterval=fromAnnotation.getElement(RDBMSEventTableConstants.ANNOTATION_ELEMENT_BLOOM_VALIDITY_PERIOD);
  try {
    this.dbHandler=new DBHandler(dataSource,tableName,attributeList,tableDefinition);
    if ((con=dataSource.getConnection()) == null) {
      throw new ExecutionPlanCreationException(""String_Node_Str"");
    }
    if (cacheType != null) {
      cachedTable=new CachingTable(cacheType,cacheSizeInString,executionPlanContext,tableDefinition);
      isCachingEnabled=true;
      if (cacheLoadingType != null && cacheLoadingType.equalsIgnoreCase(RDBMSEventTableConstants.EAGER_CACHE_LOADING_ELEMENT)) {
        dbHandler.loadDBCache(cachedTable,cacheSizeInString);
      }
      if (cacheValidityInterval != null) {
        Long cacheTimeInterval=Long.parseLong(cacheValidityInterval);
        Timer timer=new Timer();
        CacheUpdateTask cacheUpdateTask=new CacheUpdateTask();
        timer.schedule(cacheUpdateTask,cacheTimeInterval);
      }
    }
 else     if (bloomsEnabled != null && bloomsEnabled.equalsIgnoreCase(""String_Node_Str"")) {
      String bloomsFilterSize=fromAnnotation.getElement(RDBMSEventTableConstants.ANNOTATION_ELEMENT_BLOOM_FILTERS_SIZE);
      String bloomsFilterHash=fromAnnotation.getElement(RDBMSEventTableConstants.ANNOTATION_ELEMENT_BLOOM_FILTERS_HASH);
      if (bloomsFilterSize != null) {
        bloomFilterSize=Integer.parseInt(bloomsFilterSize);
      }
      if (bloomsFilterHash != null) {
        bloomFilterHashFunctions=Integer.parseInt(bloomsFilterHash);
      }
      dbHandler.setBloomFilterProperties(bloomFilterSize,bloomFilterHashFunctions);
      dbHandler.buildBloomFilters();
      if (bloomFilterValidityInterval != null) {
        Long bloomTimeInterval=Long.parseLong(bloomFilterValidityInterval);
        Timer timer=new Timer();
        BloomsUpdateTask bloomsUpdateTask=new BloomsUpdateTask();
        timer.schedule(bloomsUpdateTask,bloomTimeInterval);
      }
    }
  }
 catch (  SQLException e) {
    throw new ExecutionPlanCreationException(""String_Node_Str"",e);
  }
 finally {
    if (con != null) {
      try {
        con.close();
      }
 catch (      SQLException e) {
        log.error(""String_Node_Str"",e);
      }
    }
  }
}","/** 
 * Event Table initialization method, it checks the annotation and do necessary pre configuration tasks.
 * @param tableDefinition      Definition of event table
 * @param executionPlanContext ExecutionPlan related meta information
 */
public void init(TableDefinition tableDefinition,ExecutionPlanContext executionPlanContext){
  this.tableDefinition=tableDefinition;
  Connection con=null;
  int bloomFilterSize=RDBMSEventTableConstants.BLOOM_FILTER_SIZE;
  int bloomFilterHashFunctions=RDBMSEventTableConstants.BLOOM_FILTER_HASH_FUNCTIONS;
  Annotation fromAnnotation=AnnotationHelper.getAnnotation(SiddhiConstants.ANNOTATION_FROM,tableDefinition.getAnnotations());
  String dataSourceName=fromAnnotation.getElement(RDBMSEventTableConstants.ANNOTATION_ELEMENT_DATASOURCE_NAME);
  String tableName=fromAnnotation.getElement(RDBMSEventTableConstants.ANNOTATION_ELEMENT_TABLE_NAME);
  DataSource dataSource=executionPlanContext.getSiddhiContext().getSiddhiDataSource(dataSourceName);
  List<Attribute> attributeList=tableDefinition.getAttributeList();
  if (dataSource == null) {
    String jdbcConnectionUrl=fromAnnotation.getElement(RDBMSEventTableConstants.EVENT_TABLE_RDBMS_TABLE_JDBC_URL);
    String username=fromAnnotation.getElement(RDBMSEventTableConstants.EVENT_TABLE_RDBMS_TABLE_USERNAME);
    String password=fromAnnotation.getElement(RDBMSEventTableConstants.EVENT_TABLE_RDBMS_TABLE_PASSWORD);
    String driverName=fromAnnotation.getElement(RDBMSEventTableConstants.EVENT_TABLE_RDBMS_TABLE_DRIVER_NAME);
    List<Element> connectionPropertyElements=null;
    Annotation connectionAnnotation=AnnotationHelper.getAnnotation(RDBMSEventTableConstants.ANNOTATION_CONNECTION,tableDefinition.getAnnotations());
    if (connectionAnnotation != null) {
      connectionPropertyElements=connectionAnnotation.getElements();
    }
    dataSource=PooledDataSource.getPoolDataSource(driverName,jdbcConnectionUrl,username,password,connectionPropertyElements);
  }
  if (dataSource == null || tableName == null) {
    throw new ExecutionPlanCreationException(""String_Node_Str"");
  }
  String cacheType=fromAnnotation.getElement(RDBMSEventTableConstants.ANNOTATION_ELEMENT_CACHE);
  cacheSizeInString=fromAnnotation.getElement(RDBMSEventTableConstants.ANNOTATION_ELEMENT_CACHE_SIZE);
  String cacheLoadingType=fromAnnotation.getElement(RDBMSEventTableConstants.ANNOTATION_ELEMENT_CACHE_LOADING);
  String cacheValidityInterval=fromAnnotation.getElement(RDBMSEventTableConstants.ANNOTATION_ELEMENT_CACHE_VALIDITY_PERIOD);
  String bloomsEnabled=fromAnnotation.getElement(RDBMSEventTableConstants.ANNOTATION_ELEMENT_BLOOM_FILTERS);
  String bloomFilterValidityInterval=fromAnnotation.getElement(RDBMSEventTableConstants.ANNOTATION_ELEMENT_BLOOM_VALIDITY_PERIOD);
  try {
    this.dbHandler=new DBHandler(dataSource,tableName,attributeList,tableDefinition);
    if ((con=dataSource.getConnection()) == null) {
      throw new ExecutionPlanCreationException(""String_Node_Str"");
    }
    if (cacheType != null) {
      cachedTable=new CachingTable(cacheType,cacheSizeInString,executionPlanContext,tableDefinition);
      isCachingEnabled=true;
      if (cacheLoadingType != null && cacheLoadingType.equalsIgnoreCase(RDBMSEventTableConstants.EAGER_CACHE_LOADING_ELEMENT)) {
        dbHandler.loadDBCache(cachedTable,cacheSizeInString);
      }
      if (cacheValidityInterval != null) {
        Long cacheTimeInterval=Long.parseLong(cacheValidityInterval);
        Timer timer=new Timer();
        CacheUpdateTask cacheUpdateTask=new CacheUpdateTask();
        timer.schedule(cacheUpdateTask,cacheTimeInterval);
      }
    }
 else     if (bloomsEnabled != null && bloomsEnabled.equalsIgnoreCase(""String_Node_Str"")) {
      String bloomsFilterSize=fromAnnotation.getElement(RDBMSEventTableConstants.ANNOTATION_ELEMENT_BLOOM_FILTERS_SIZE);
      String bloomsFilterHash=fromAnnotation.getElement(RDBMSEventTableConstants.ANNOTATION_ELEMENT_BLOOM_FILTERS_HASH);
      if (bloomsFilterSize != null) {
        bloomFilterSize=Integer.parseInt(bloomsFilterSize);
      }
      if (bloomsFilterHash != null) {
        bloomFilterHashFunctions=Integer.parseInt(bloomsFilterHash);
      }
      dbHandler.setBloomFilterProperties(bloomFilterSize,bloomFilterHashFunctions);
      dbHandler.buildBloomFilters();
      if (bloomFilterValidityInterval != null) {
        Long bloomTimeInterval=Long.parseLong(bloomFilterValidityInterval);
        Timer timer=new Timer();
        BloomsUpdateTask bloomsUpdateTask=new BloomsUpdateTask();
        timer.schedule(bloomsUpdateTask,bloomTimeInterval,bloomTimeInterval);
      }
    }
  }
 catch (  SQLException e) {
    throw new ExecutionPlanCreationException(""String_Node_Str"",e);
  }
 finally {
    if (con != null) {
      try {
        con.close();
      }
 catch (      SQLException e) {
        log.error(""String_Node_Str"",e);
      }
    }
  }
}",0.9981538461538462
29055,"public void buildBloomFilters(){
  this.bloomFilters=new CountingBloomFilter[tableDefinition.getAttributeList().size()];
  this.isBloomFilterEnabled=true;
  for (int i=0; i < bloomFilters.length; i++) {
    bloomFilters[i]=new CountingBloomFilter(bloomFilterSize,bloomFilterHashFunction,Hash.MURMUR_HASH);
  }
  Connection con=null;
  Statement stmt=null;
  try {
    con=dataSource.getConnection();
    stmt=con.createStatement();
    String selectTableRowQuery=constructQuery(tableName,elementMappings.get(RDBMSEventTableConstants.EVENT_TABLE_GENERIC_RDBMS_SELECT_TABLE),null,null,null,null,null);
    ResultSet results=stmt.executeQuery(selectTableRowQuery);
    while (results.next()) {
      for (int i=0; i < bloomFilters.length; i++) {
switch (tableDefinition.getAttributeList().get(i).getType()) {
case INT:
          bloomFilters[i].add(new Key(Integer.toString(results.getInt(i + 1)).getBytes()));
        break;
case LONG:
      bloomFilters[i].add(new Key(Long.toString(results.getLong(i + 1)).getBytes()));
    break;
case FLOAT:
  bloomFilters[i].add(new Key(Float.toString(results.getFloat(i + 1)).getBytes()));
break;
case DOUBLE:
bloomFilters[i].add(new Key(Double.toString(results.getDouble(i + 1)).getBytes()));
break;
case STRING:
bloomFilters[i].add(new Key(results.getString(i + 1).getBytes()));
break;
case BOOL:
bloomFilters[i].add(new Key(Boolean.toString(results.getBoolean(i + 1)).getBytes()));
break;
}
}
}
results.close();
}
 catch (SQLException ex) {
throw new ExecutionPlanRuntimeException(""String_Node_Str"" + ex.getMessage(),ex);
}
 finally {
cleanUpConnections(stmt,con);
}
}","public void buildBloomFilters(){
  CountingBloomFilter[] bloomFilters=new CountingBloomFilter[tableDefinition.getAttributeList().size()];
  for (int i=0; i < bloomFilters.length; i++) {
    bloomFilters[i]=new CountingBloomFilter(bloomFilterSize,bloomFilterHashFunction,Hash.MURMUR_HASH);
  }
  Connection con=null;
  Statement stmt=null;
  try {
    con=dataSource.getConnection();
    stmt=con.createStatement();
    String selectTableRowQuery=constructQuery(tableName,elementMappings.get(RDBMSEventTableConstants.EVENT_TABLE_GENERIC_RDBMS_SELECT_TABLE),null,null,null,null,null);
    ResultSet results=stmt.executeQuery(selectTableRowQuery);
    while (results.next()) {
      for (int i=0; i < bloomFilters.length; i++) {
switch (tableDefinition.getAttributeList().get(i).getType()) {
case INT:
          bloomFilters[i].add(new Key(Integer.toString(results.getInt(i + 1)).getBytes()));
        break;
case LONG:
      bloomFilters[i].add(new Key(Long.toString(results.getLong(i + 1)).getBytes()));
    break;
case FLOAT:
  bloomFilters[i].add(new Key(Float.toString(results.getFloat(i + 1)).getBytes()));
break;
case DOUBLE:
bloomFilters[i].add(new Key(Double.toString(results.getDouble(i + 1)).getBytes()));
break;
case STRING:
bloomFilters[i].add(new Key(results.getString(i + 1).getBytes()));
break;
case BOOL:
bloomFilters[i].add(new Key(Boolean.toString(results.getBoolean(i + 1)).getBytes()));
break;
}
}
}
results.close();
this.bloomFilters=bloomFilters;
this.isBloomFilterEnabled=true;
}
 catch (SQLException ex) {
throw new ExecutionPlanRuntimeException(""String_Node_Str"" + ex.getMessage(),ex);
}
 finally {
cleanUpConnections(stmt,con);
}
}",0.9616916947594238
29056,"@Test public void testQuery1() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  TableDefinition tableDefinition=TableDefinition.id(""String_Node_Str"").annotation(Annotation.annotation(""String_Node_Str"").element(""String_Node_Str"",""String_Node_Str"")).attribute(""String_Node_Str"",Attribute.Type.STRING).attribute(""String_Node_Str"",Attribute.Type.INT);
  ExecutionPlan executionPlan=new ExecutionPlan(""String_Node_Str"");
  executionPlan.defineTable(tableDefinition);
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(executionPlan);
  List<String> hciNames=new ArrayList<String>();
  for (  HazelcastInstance hci : Hazelcast.getAllHazelcastInstances()) {
    hciNames.add(hci.getName());
  }
  Assert.assertTrue(hciNames.contains(HazelcastEventTableConstants.HAZELCAST_INSTANCE_PREFIX + executionPlanRuntime.getName()));
  executionPlanRuntime.shutdown();
}","@Test public void testQuery1() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  TableDefinition tableDefinition=TableDefinition.id(""String_Node_Str"").annotation(Annotation.annotation(""String_Node_Str"").element(""String_Node_Str"",""String_Node_Str"")).attribute(""String_Node_Str"",Attribute.Type.STRING).attribute(""String_Node_Str"",Attribute.Type.INT);
  ExecutionPlan executionPlan=new ExecutionPlan(""String_Node_Str"");
  executionPlan.defineTable(tableDefinition);
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(executionPlan);
  try {
    List<String> hciNames=new ArrayList<String>();
    for (    HazelcastInstance hci : Hazelcast.getAllHazelcastInstances()) {
      hciNames.add(hci.getName());
    }
    Assert.assertTrue(hciNames.contains(HazelcastEventTableConstants.HAZELCAST_INSTANCE_PREFIX + executionPlanRuntime.getName()));
  }
  finally {
    executionPlanRuntime.shutdown();
  }
}",0.9784172661870504
29057,"@Test public void testQuery3() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String tables=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(tables);
  List<String> hciNames=new ArrayList<String>();
  for (  HazelcastInstance hci : Hazelcast.getAllHazelcastInstances()) {
    hciNames.add(hci.getName());
  }
  Assert.assertTrue(hciNames.contains(HazelcastEventTableConstants.HAZELCAST_INSTANCE_PREFIX + executionPlanRuntime.getName()));
  executionPlanRuntime.shutdown();
}","@Test public void testQuery3() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String tables=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(tables);
  try {
    List<String> hciNames=new ArrayList<String>();
    for (    HazelcastInstance hci : Hazelcast.getAllHazelcastInstances()) {
      hciNames.add(hci.getName());
    }
    Assert.assertTrue(hciNames.contains(HazelcastEventTableConstants.HAZELCAST_INSTANCE_PREFIX + executionPlanRuntime.getName()));
  }
  finally {
    executionPlanRuntime.shutdown();
  }
}",0.923896499238965
29058,"@Test public void testQuery2() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  StreamDefinition streamDefinition=StreamDefinition.id(""String_Node_Str"").attribute(""String_Node_Str"",Attribute.Type.STRING).attribute(""String_Node_Str"",Attribute.Type.INT);
  TableDefinition tableDefinition=TableDefinition.id(""String_Node_Str"").annotation(Annotation.annotation(""String_Node_Str"").element(""String_Node_Str"",""String_Node_Str"")).attribute(""String_Node_Str"",Attribute.Type.STRING).attribute(""String_Node_Str"",Attribute.Type.INT);
  Query query=Query.query();
  query.from(InputStream.stream(""String_Node_Str""));
  query.insertInto(""String_Node_Str"");
  ExecutionPlan executionPlan=new ExecutionPlan(""String_Node_Str"");
  executionPlan.addQuery(query);
  executionPlan.defineStream(streamDefinition);
  executionPlan.defineTable(tableDefinition);
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(executionPlan);
  InputHandler stockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  stockStream.send(new Object[]{""String_Node_Str"",55.6f});
  stockStream.send(new Object[]{""String_Node_Str"",75.6f});
  Thread.sleep(500);
  Map<String,HazelcastInstance> instanceMap=new HashMap<String,HazelcastInstance>();
  for (  HazelcastInstance hci : Hazelcast.getAllHazelcastInstances()) {
    instanceMap.put(hci.getName(),hci);
  }
  Assert.assertTrue(instanceMap.containsKey(HazelcastEventTableConstants.HAZELCAST_INSTANCE_PREFIX + executionPlanRuntime.getName()));
  HazelcastInstance instance=instanceMap.get(HazelcastEventTableConstants.HAZELCAST_INSTANCE_PREFIX + executionPlanRuntime.getName());
  List<StreamEvent> streamEvents=instance.getList(HazelcastEventTableConstants.HAZELCAST_LIST_INSTANCE_PREFIX + executionPlanRuntime.getName() + '_'+ tableDefinition.getId());
  Assert.assertEquals(2,streamEvents.size());
  executionPlanRuntime.shutdown();
}","@Test public void testQuery2() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  StreamDefinition streamDefinition=StreamDefinition.id(""String_Node_Str"").attribute(""String_Node_Str"",Attribute.Type.STRING).attribute(""String_Node_Str"",Attribute.Type.INT);
  TableDefinition tableDefinition=TableDefinition.id(""String_Node_Str"").annotation(Annotation.annotation(""String_Node_Str"").element(""String_Node_Str"",""String_Node_Str"")).attribute(""String_Node_Str"",Attribute.Type.STRING).attribute(""String_Node_Str"",Attribute.Type.INT);
  Query query=Query.query();
  query.from(InputStream.stream(""String_Node_Str""));
  query.insertInto(""String_Node_Str"");
  ExecutionPlan executionPlan=new ExecutionPlan(""String_Node_Str"");
  executionPlan.addQuery(query);
  executionPlan.defineStream(streamDefinition);
  executionPlan.defineTable(tableDefinition);
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(executionPlan);
  try {
    InputHandler stockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
    executionPlanRuntime.start();
    stockStream.send(new Object[]{""String_Node_Str"",55.6f});
    stockStream.send(new Object[]{""String_Node_Str"",75.6f});
    Map<String,HazelcastInstance> instanceMap=new HashMap<String,HazelcastInstance>();
    for (    HazelcastInstance hci : Hazelcast.getAllHazelcastInstances()) {
      instanceMap.put(hci.getName(),hci);
    }
    Assert.assertTrue(instanceMap.containsKey(HazelcastEventTableConstants.HAZELCAST_INSTANCE_PREFIX + executionPlanRuntime.getName()));
    HazelcastInstance instance=instanceMap.get(HazelcastEventTableConstants.HAZELCAST_INSTANCE_PREFIX + executionPlanRuntime.getName());
    List<StreamEvent> streamEvents=instance.getList(HazelcastEventTableConstants.HAZELCAST_LIST_INSTANCE_PREFIX + executionPlanRuntime.getName() + '_'+ tableDefinition.getId());
    SiddhiTestHelper.waitForEvents(100,2,streamEvents,60000);
    List<Object[]> expected=Arrays.asList(new Object[]{""String_Node_Str"",55.6f},new Object[]{""String_Node_Str"",75.6f});
    List<Object[]> actual=new ArrayList<Object[]>();
    for (    StreamEvent event : streamEvents) {
      actual.add(event.getOutputData());
    }
    Assert.assertEquals(2,streamEvents.size());
    Assert.assertEquals(""String_Node_Str"",true,SiddhiTestHelper.isEventsMatch(actual,expected));
  }
  finally {
    executionPlanRuntime.shutdown();
  }
}",0.878235426513617
29059,"@Test public void testQuery20() throws InterruptedException {
  log.info(""String_Node_Str"");
  String instanceName=""String_Node_Str"";
  SiddhiManager siddhiManager=new SiddhiManager();
  StreamDefinition streamDefinition=StreamDefinition.id(""String_Node_Str"").attribute(""String_Node_Str"",Attribute.Type.STRING).attribute(""String_Node_Str"",Attribute.Type.INT);
  TableDefinition tableDefinition=TableDefinition.id(""String_Node_Str"").annotation(Annotation.annotation(""String_Node_Str"").element(""String_Node_Str"",""String_Node_Str"").element(""String_Node_Str"",instanceName)).attribute(""String_Node_Str"",Attribute.Type.STRING).attribute(""String_Node_Str"",Attribute.Type.INT);
  Query query=Query.query();
  query.from(InputStream.stream(""String_Node_Str""));
  query.insertInto(""String_Node_Str"");
  ExecutionPlan executionPlan=new ExecutionPlan(""String_Node_Str"");
  executionPlan.addQuery(query);
  executionPlan.defineStream(streamDefinition);
  executionPlan.defineTable(tableDefinition);
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(executionPlan);
  InputHandler stockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  stockStream.send(new Object[]{""String_Node_Str"",55.6f});
  stockStream.send(new Object[]{""String_Node_Str"",75.6f});
  Thread.sleep(RESULT_WAIT * 4);
  Config cfg=new Config(instanceName);
  cfg.setProperty(""String_Node_Str"",""String_Node_Str"");
  HazelcastInstance hci=Hazelcast.getOrCreateHazelcastInstance(cfg);
  List<StreamEvent> streamEvents=hci.getList(HazelcastEventTableConstants.HAZELCAST_LIST_INSTANCE_PREFIX + executionPlanRuntime.getName() + '_'+ tableDefinition.getId());
  Assert.assertEquals(2,streamEvents.size());
  executionPlanRuntime.shutdown();
}","@Test public void testQuery20() throws InterruptedException {
  log.info(""String_Node_Str"");
  String instanceName=""String_Node_Str"";
  SiddhiManager siddhiManager=new SiddhiManager();
  StreamDefinition streamDefinition=StreamDefinition.id(""String_Node_Str"").attribute(""String_Node_Str"",Attribute.Type.STRING).attribute(""String_Node_Str"",Attribute.Type.INT);
  TableDefinition tableDefinition=TableDefinition.id(""String_Node_Str"").annotation(Annotation.annotation(""String_Node_Str"").element(""String_Node_Str"",""String_Node_Str"").element(""String_Node_Str"",instanceName)).attribute(""String_Node_Str"",Attribute.Type.STRING).attribute(""String_Node_Str"",Attribute.Type.INT);
  Query query=Query.query();
  query.from(InputStream.stream(""String_Node_Str""));
  query.insertInto(""String_Node_Str"");
  ExecutionPlan executionPlan=new ExecutionPlan(""String_Node_Str"");
  executionPlan.addQuery(query);
  executionPlan.defineStream(streamDefinition);
  executionPlan.defineTable(tableDefinition);
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(executionPlan);
  try {
    InputHandler stockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
    executionPlanRuntime.start();
    stockStream.send(new Object[]{""String_Node_Str"",55.6f});
    stockStream.send(new Object[]{""String_Node_Str"",75.6f});
    Config cfg=new Config(instanceName);
    cfg.setProperty(""String_Node_Str"",""String_Node_Str"");
    HazelcastInstance hci=Hazelcast.getOrCreateHazelcastInstance(cfg);
    List<StreamEvent> streamEvents=hci.getList(HazelcastEventTableConstants.HAZELCAST_LIST_INSTANCE_PREFIX + executionPlanRuntime.getName() + '_'+ tableDefinition.getId());
    SiddhiTestHelper.waitForEvents(100,2,streamEvents,60000);
    List<Object[]> expected=Arrays.asList(new Object[]{""String_Node_Str"",55.6f},new Object[]{""String_Node_Str"",75.6f});
    List<Object[]> actual=new ArrayList<Object[]>();
    for (    StreamEvent event : streamEvents) {
      actual.add(event.getOutputData());
    }
    Assert.assertEquals(2,streamEvents.size());
    Assert.assertEquals(""String_Node_Str"",true,SiddhiTestHelper.isEventsMatch(actual,expected));
  }
  finally {
    executionPlanRuntime.shutdown();
  }
}",0.8476787954830615
29060,"@Test public void testQuery18() throws InterruptedException {
  log.info(""String_Node_Str"");
  String clusterName=""String_Node_Str"";
  String clusterPassword=""String_Node_Str"";
  SiddhiManager siddhiManager=new SiddhiManager();
  String tables=""String_Node_Str"" + ""String_Node_Str"" + clusterName + ""String_Node_Str""+ clusterPassword+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(tables);
  Map<String,HazelcastInstance> instanceMap=new HashMap<String,HazelcastInstance>();
  for (  HazelcastInstance hci : Hazelcast.getAllHazelcastInstances()) {
    instanceMap.put(hci.getName(),hci);
  }
  Assert.assertTrue(instanceMap.containsKey(HazelcastEventTableConstants.HAZELCAST_INSTANCE_PREFIX + executionPlanRuntime.getName()));
  HazelcastInstance instance=instanceMap.get(HazelcastEventTableConstants.HAZELCAST_INSTANCE_PREFIX + executionPlanRuntime.getName());
  Assert.assertEquals(clusterName,instance.getConfig().getGroupConfig().getName());
  Assert.assertEquals(clusterPassword,instance.getConfig().getGroupConfig().getPassword());
  executionPlanRuntime.shutdown();
}","@Test public void testQuery18() throws InterruptedException {
  log.info(""String_Node_Str"");
  String clusterName=""String_Node_Str"";
  String clusterPassword=""String_Node_Str"";
  SiddhiManager siddhiManager=new SiddhiManager();
  String tables=""String_Node_Str"" + ""String_Node_Str"" + clusterName + ""String_Node_Str""+ clusterPassword+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(tables);
  try {
    Map<String,HazelcastInstance> instanceMap=new HashMap<String,HazelcastInstance>();
    for (    HazelcastInstance hci : Hazelcast.getAllHazelcastInstances()) {
      instanceMap.put(hci.getName(),hci);
    }
    Assert.assertTrue(instanceMap.containsKey(HazelcastEventTableConstants.HAZELCAST_INSTANCE_PREFIX + executionPlanRuntime.getName()));
    HazelcastInstance instance=instanceMap.get(HazelcastEventTableConstants.HAZELCAST_INSTANCE_PREFIX + executionPlanRuntime.getName());
    Assert.assertEquals(clusterName,instance.getConfig().getGroupConfig().getName());
    Assert.assertEquals(clusterPassword,instance.getConfig().getGroupConfig().getPassword());
  }
  finally {
    executionPlanRuntime.shutdown();
  }
}",0.979557069846678
29061,"@Test public void testQuery6() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String tables=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(tables);
  List<String> hciNames=new ArrayList<String>();
  for (  HazelcastInstance hci : Hazelcast.getAllHazelcastInstances()) {
    hciNames.add(hci.getName());
  }
  Assert.assertTrue(hciNames.contains(HazelcastEventTableConstants.HAZELCAST_INSTANCE_PREFIX + executionPlanRuntime.getName()));
  executionPlanRuntime.shutdown();
}","@Test public void testQuery6() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String tables=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(tables);
  try {
    List<String> hciNames=new ArrayList<String>();
    for (    HazelcastInstance hci : Hazelcast.getAllHazelcastInstances()) {
      hciNames.add(hci.getName());
    }
    Assert.assertTrue(hciNames.contains(HazelcastEventTableConstants.HAZELCAST_INSTANCE_PREFIX + executionPlanRuntime.getName()));
  }
  finally {
    executionPlanRuntime.shutdown();
  }
}",0.9697841726618706
29062,"@Test public void testQuery17() throws InterruptedException {
  log.info(""String_Node_Str"");
  String clusterName=""String_Node_Str"";
  SiddhiManager siddhiManager=new SiddhiManager();
  String tables=""String_Node_Str"" + ""String_Node_Str"" + clusterName + ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(tables);
  Map<String,HazelcastInstance> instanceMap=new HashMap<String,HazelcastInstance>();
  for (  HazelcastInstance hci : Hazelcast.getAllHazelcastInstances()) {
    instanceMap.put(hci.getName(),hci);
  }
  Assert.assertTrue(instanceMap.containsKey(HazelcastEventTableConstants.HAZELCAST_INSTANCE_PREFIX + executionPlanRuntime.getName()));
  HazelcastInstance instance=instanceMap.get(HazelcastEventTableConstants.HAZELCAST_INSTANCE_PREFIX + executionPlanRuntime.getName());
  Assert.assertEquals(clusterName,instance.getConfig().getGroupConfig().getName());
  executionPlanRuntime.shutdown();
}","@Test public void testQuery17() throws InterruptedException {
  log.info(""String_Node_Str"");
  String clusterName=""String_Node_Str"";
  SiddhiManager siddhiManager=new SiddhiManager();
  String tables=""String_Node_Str"" + ""String_Node_Str"" + clusterName + ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(tables);
  try {
    Map<String,HazelcastInstance> instanceMap=new HashMap<String,HazelcastInstance>();
    for (    HazelcastInstance hci : Hazelcast.getAllHazelcastInstances()) {
      instanceMap.put(hci.getName(),hci);
    }
    Assert.assertTrue(instanceMap.containsKey(HazelcastEventTableConstants.HAZELCAST_INSTANCE_PREFIX + executionPlanRuntime.getName()));
    HazelcastInstance instance=instanceMap.get(HazelcastEventTableConstants.HAZELCAST_INSTANCE_PREFIX + executionPlanRuntime.getName());
    Assert.assertEquals(clusterName,instance.getConfig().getGroupConfig().getName());
  }
  finally {
    executionPlanRuntime.shutdown();
  }
}",0.977022977022977
29063,"@Test public void testQuery19() throws InterruptedException {
  log.info(""String_Node_Str"");
  String clusterName=""String_Node_Str"";
  String clusterPassword=""String_Node_Str"";
  Config cfg_1=new Config();
  cfg_1.getGroupConfig().setName(clusterName).setPassword(clusterPassword);
  cfg_1.setProperty(""String_Node_Str"",""String_Node_Str"");
  HazelcastInstance instance_1=Hazelcast.newHazelcastInstance(cfg_1);
  Config cfg_2=new Config();
  cfg_2.getGroupConfig().setName(clusterName).setPassword(clusterPassword);
  cfg_2.setProperty(""String_Node_Str"",""String_Node_Str"");
  HazelcastInstance instance_2=Hazelcast.newHazelcastInstance(cfg_2);
  StringBuilder sb=new StringBuilder();
  for (  Member member : instance_2.getCluster().getMembers()) {
    sb.append(member.getSocketAddress()).append(',');
  }
  String addresses=StringUtils.replace(sb.toString(),""String_Node_Str"",""String_Node_Str"");
  addresses=StringUtils.removeEnd(addresses,""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  StreamDefinition streamDefinition=StreamDefinition.id(""String_Node_Str"").attribute(""String_Node_Str"",Attribute.Type.STRING).attribute(""String_Node_Str"",Attribute.Type.INT);
  TableDefinition tableDefinition=TableDefinition.id(""String_Node_Str"").annotation(Annotation.annotation(""String_Node_Str"").element(""String_Node_Str"",""String_Node_Str"").element(""String_Node_Str"",clusterName).element(""String_Node_Str"",clusterPassword).element(""String_Node_Str"",addresses)).attribute(""String_Node_Str"",Attribute.Type.STRING).attribute(""String_Node_Str"",Attribute.Type.INT);
  Query query=Query.query();
  query.from(InputStream.stream(""String_Node_Str""));
  query.insertInto(""String_Node_Str"");
  ExecutionPlan executionPlan=new ExecutionPlan(""String_Node_Str"");
  executionPlan.addQuery(query);
  executionPlan.defineStream(streamDefinition);
  executionPlan.defineTable(tableDefinition);
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(executionPlan);
  InputHandler stockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  stockStream.send(new Object[]{""String_Node_Str"",55.6f});
  stockStream.send(new Object[]{""String_Node_Str"",75.6f});
  Thread.sleep(RESULT_WAIT * 4);
  List<StreamEvent> streamEvents=instance_2.getList(HazelcastEventTableConstants.HAZELCAST_LIST_INSTANCE_PREFIX + executionPlanRuntime.getName() + '_'+ tableDefinition.getId());
  Assert.assertEquals(2,streamEvents.size());
  executionPlanRuntime.shutdown();
}","@Test public void testQuery19() throws InterruptedException {
  log.info(""String_Node_Str"");
  String clusterName=""String_Node_Str"";
  String clusterPassword=""String_Node_Str"";
  Config cfg_1=new Config();
  cfg_1.getGroupConfig().setName(clusterName).setPassword(clusterPassword);
  cfg_1.setProperty(""String_Node_Str"",""String_Node_Str"");
  HazelcastInstance instance_1=Hazelcast.newHazelcastInstance(cfg_1);
  Config cfg_2=new Config();
  cfg_2.getGroupConfig().setName(clusterName).setPassword(clusterPassword);
  cfg_2.setProperty(""String_Node_Str"",""String_Node_Str"");
  HazelcastInstance instance_2=Hazelcast.newHazelcastInstance(cfg_2);
  StringBuilder sb=new StringBuilder();
  for (  Member member : instance_2.getCluster().getMembers()) {
    sb.append(member.getSocketAddress()).append(',');
  }
  String addresses=StringUtils.replace(sb.toString(),""String_Node_Str"",""String_Node_Str"");
  addresses=StringUtils.removeEnd(addresses,""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  StreamDefinition streamDefinition=StreamDefinition.id(""String_Node_Str"").attribute(""String_Node_Str"",Attribute.Type.STRING).attribute(""String_Node_Str"",Attribute.Type.INT);
  TableDefinition tableDefinition=TableDefinition.id(""String_Node_Str"").annotation(Annotation.annotation(""String_Node_Str"").element(""String_Node_Str"",""String_Node_Str"").element(""String_Node_Str"",clusterName).element(""String_Node_Str"",clusterPassword).element(""String_Node_Str"",addresses)).attribute(""String_Node_Str"",Attribute.Type.STRING).attribute(""String_Node_Str"",Attribute.Type.INT);
  Query query=Query.query();
  query.from(InputStream.stream(""String_Node_Str""));
  query.insertInto(""String_Node_Str"");
  ExecutionPlan executionPlan=new ExecutionPlan(""String_Node_Str"");
  executionPlan.addQuery(query);
  executionPlan.defineStream(streamDefinition);
  executionPlan.defineTable(tableDefinition);
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(executionPlan);
  try {
    InputHandler stockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
    executionPlanRuntime.start();
    stockStream.send(new Object[]{""String_Node_Str"",55.6f});
    stockStream.send(new Object[]{""String_Node_Str"",75.6f});
    List<StreamEvent> streamEvents=instance_2.getList(HazelcastEventTableConstants.HAZELCAST_LIST_INSTANCE_PREFIX + executionPlanRuntime.getName() + '_'+ tableDefinition.getId());
    SiddhiTestHelper.waitForEvents(100,2,streamEvents,60000);
    List<Object[]> expected=Arrays.asList(new Object[]{""String_Node_Str"",55.6f},new Object[]{""String_Node_Str"",75.6f});
    List<Object[]> actual=new ArrayList<Object[]>();
    for (    StreamEvent event : streamEvents) {
      actual.add(event.getOutputData());
    }
    Assert.assertEquals(2,streamEvents.size());
    Assert.assertEquals(""String_Node_Str"",true,SiddhiTestHelper.isEventsMatch(actual,expected));
  }
  finally {
    executionPlanRuntime.shutdown();
  }
}",0.9088917290487492
29064,"@Test public void deleteFromTableTest1() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String streams=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String query=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(streams + query);
  InputHandler stockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  InputHandler deleteStockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  stockStream.send(new Object[]{""String_Node_Str"",55.6f,100l});
  stockStream.send(new Object[]{""String_Node_Str"",75.6f,100l});
  stockStream.send(new Object[]{""String_Node_Str"",57.6f,100l});
  deleteStockStream.send(new Object[]{""String_Node_Str"",57.6f,100l});
  Thread.sleep(RESULT_WAIT);
  executionPlanRuntime.shutdown();
}","@Test public void deleteFromTableTest1() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String streams=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String query=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(streams + query);
  try {
    InputHandler stockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
    InputHandler deleteStockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
    executionPlanRuntime.start();
    stockStream.send(new Object[]{""String_Node_Str"",55.6f,100l});
    stockStream.send(new Object[]{""String_Node_Str"",75.6f,100l});
    stockStream.send(new Object[]{""String_Node_Str"",57.6f,100l});
    deleteStockStream.send(new Object[]{""String_Node_Str"",57.6f,100l});
    Thread.sleep(RESULT_WAIT);
  }
  finally {
    executionPlanRuntime.shutdown();
  }
}",0.9793536804308796
29065,"@Test public void deleteFromTableTest2() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String streams=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String query=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(streams + query);
  InputHandler stockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  InputHandler deleteStockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  stockStream.send(new Object[]{""String_Node_Str"",55.6f,100l});
  stockStream.send(new Object[]{""String_Node_Str"",75.6f,100l});
  stockStream.send(new Object[]{""String_Node_Str"",57.6f,100l});
  deleteStockStream.send(new Object[]{""String_Node_Str"",57.6f,100l});
  Thread.sleep(RESULT_WAIT);
  executionPlanRuntime.shutdown();
}","@Test public void deleteFromTableTest2() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String streams=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String query=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(streams + query);
  try {
    InputHandler stockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
    InputHandler deleteStockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
    executionPlanRuntime.start();
    stockStream.send(new Object[]{""String_Node_Str"",55.6f,100l});
    stockStream.send(new Object[]{""String_Node_Str"",75.6f,100l});
    stockStream.send(new Object[]{""String_Node_Str"",57.6f,100l});
    deleteStockStream.send(new Object[]{""String_Node_Str"",57.6f,100l});
    Thread.sleep(RESULT_WAIT);
  }
  finally {
    executionPlanRuntime.shutdown();
  }
}",0.9793536804308796
29066,"@Test public void deleteFromTableTest5() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String streams=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String query=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(streams + query);
  InputHandler stockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  InputHandler deleteStockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  InputHandler countStockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.addCallback(""String_Node_Str"",new StreamCallback(){
    @Override public void receive(    Event[] events){
      EventPrinter.print(events);
      inEventCount.addAndGet(events.length);
    }
  }
);
  executionPlanRuntime.start();
  stockStream.send(new Object[]{""String_Node_Str"",55.6f,100l});
  stockStream.send(new Object[]{""String_Node_Str"",75.6f,100l});
  stockStream.send(new Object[]{""String_Node_Str"",57.6f,100l});
  deleteStockStream.send(new Object[]{""String_Node_Str"",57.6f,100l});
  countStockStream.send(new Object[]{""String_Node_Str""});
  SiddhiTestHelper.waitForEvents(100,2,inEventCount,60000);
  Assert.assertEquals(2,inEventCount.get());
  executionPlanRuntime.shutdown();
}","@Test public void deleteFromTableTest5() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String streams=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String query=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(streams + query);
  try {
    InputHandler stockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
    InputHandler deleteStockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
    InputHandler countStockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
    executionPlanRuntime.addCallback(""String_Node_Str"",new StreamCallback(){
      @Override public void receive(      Event[] events){
        EventPrinter.print(events);
        inEventCount.addAndGet(events.length);
      }
    }
);
    executionPlanRuntime.start();
    stockStream.send(new Object[]{""String_Node_Str"",55.6f,100l});
    stockStream.send(new Object[]{""String_Node_Str"",75.6f,100l});
    stockStream.send(new Object[]{""String_Node_Str"",57.6f,100l});
    deleteStockStream.send(new Object[]{""String_Node_Str"",57.6f,100l});
    countStockStream.send(new Object[]{""String_Node_Str""});
    SiddhiTestHelper.waitForEvents(100,2,inEventCount,60000);
    Assert.assertEquals(2,inEventCount.get());
  }
  finally {
    executionPlanRuntime.shutdown();
  }
}",0.9808251016850668
29067,"@Test public void deleteFromTableTest3() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String streams=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String query=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(streams + query);
  InputHandler stockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  InputHandler deleteStockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  stockStream.send(new Object[]{""String_Node_Str"",55.6f,100l});
  stockStream.send(new Object[]{""String_Node_Str"",75.6f,100l});
  stockStream.send(new Object[]{""String_Node_Str"",57.6f,100l});
  deleteStockStream.send(new Object[]{""String_Node_Str"",57.6f,100l});
  Thread.sleep(RESULT_WAIT);
  executionPlanRuntime.shutdown();
}","@Test public void deleteFromTableTest3() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String streams=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String query=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(streams + query);
  try {
    InputHandler stockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
    InputHandler deleteStockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
    executionPlanRuntime.start();
    stockStream.send(new Object[]{""String_Node_Str"",55.6f,100l});
    stockStream.send(new Object[]{""String_Node_Str"",75.6f,100l});
    stockStream.send(new Object[]{""String_Node_Str"",57.6f,100l});
    deleteStockStream.send(new Object[]{""String_Node_Str"",57.6f,100l});
    Thread.sleep(RESULT_WAIT);
  }
  finally {
    executionPlanRuntime.shutdown();
  }
}",0.9793536804308796
29068,"@Test public void deleteFromTableTest4() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String streams=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String query=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(streams + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      if (inEvents != null) {
        for (        Event event : inEvents) {
          inEventsList.add(event.getData());
          inEventCount.incrementAndGet();
        }
        eventArrived=true;
      }
      if (removeEvents != null) {
        removeEventCount=removeEventCount + removeEvents.length;
      }
      eventArrived=true;
    }
  }
);
  InputHandler stockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  InputHandler checkStockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  InputHandler deleteStockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  stockStream.send(new Object[]{""String_Node_Str"",55.6f,100l});
  stockStream.send(new Object[]{""String_Node_Str"",55.6f,100l});
  checkStockStream.send(new Object[]{""String_Node_Str""});
  checkStockStream.send(new Object[]{""String_Node_Str""});
  deleteStockStream.send(new Object[]{""String_Node_Str"",57.6f,100l});
  checkStockStream.send(new Object[]{""String_Node_Str""});
  checkStockStream.send(new Object[]{""String_Node_Str""});
  List<Object[]> expected=Arrays.asList(new Object[]{""String_Node_Str""},new Object[]{""String_Node_Str""},new Object[]{""String_Node_Str""});
  SiddhiTestHelper.waitForEvents(100,3,inEventCount,60000);
  Assert.assertEquals(""String_Node_Str"",true,SiddhiTestHelper.isEventsMatch(inEventsList,expected));
  Assert.assertEquals(""String_Node_Str"",3,inEventCount.get());
  Assert.assertEquals(""String_Node_Str"",0,removeEventCount);
  Assert.assertEquals(""String_Node_Str"",true,eventArrived);
  executionPlanRuntime.shutdown();
}","@Test public void deleteFromTableTest4() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String streams=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String query=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(streams + query);
  try {
    executionPlanRuntime.addCallback(""String_Node_Str"",new QueryCallback(){
      @Override public void receive(      long timeStamp,      Event[] inEvents,      Event[] removeEvents){
        EventPrinter.print(timeStamp,inEvents,removeEvents);
        if (inEvents != null) {
          for (          Event event : inEvents) {
            inEventsList.add(event.getData());
            inEventCount.incrementAndGet();
          }
          eventArrived=true;
        }
        if (removeEvents != null) {
          removeEventCount=removeEventCount + removeEvents.length;
        }
        eventArrived=true;
      }
    }
);
    InputHandler stockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
    InputHandler checkStockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
    InputHandler deleteStockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
    executionPlanRuntime.start();
    stockStream.send(new Object[]{""String_Node_Str"",55.6f,100l});
    stockStream.send(new Object[]{""String_Node_Str"",55.6f,100l});
    checkStockStream.send(new Object[]{""String_Node_Str""});
    checkStockStream.send(new Object[]{""String_Node_Str""});
    deleteStockStream.send(new Object[]{""String_Node_Str"",57.6f,100l});
    checkStockStream.send(new Object[]{""String_Node_Str""});
    checkStockStream.send(new Object[]{""String_Node_Str""});
    List<Object[]> expected=Arrays.asList(new Object[]{""String_Node_Str""},new Object[]{""String_Node_Str""},new Object[]{""String_Node_Str""});
    SiddhiTestHelper.waitForEvents(100,3,inEventCount,60000);
    Assert.assertEquals(""String_Node_Str"",true,SiddhiTestHelper.isEventsMatch(inEventsList,expected));
    Assert.assertEquals(""String_Node_Str"",3,inEventCount.get());
    Assert.assertEquals(""String_Node_Str"",0,removeEventCount);
    Assert.assertEquals(""String_Node_Str"",true,eventArrived);
  }
  finally {
    executionPlanRuntime.shutdown();
  }
}",0.9795033504138748
29069,"public PatternMultiProcessStreamReceiver(String streamId,int processCount,LatencyTracker latencyTracker){
  super(streamId,processCount,latencyTracker);
  eventSequence=new int[processCount];
  int count=0;
  for (int i=eventSequence.length - 1; i >= 0; i--) {
    eventSequence[count]=i;
    count++;
  }
}","public PatternMultiProcessStreamReceiver(String streamId,int processCount,String lockKey,LatencyTracker latencyTracker){
  super(streamId,processCount,latencyTracker);
  this.lockKey=lockKey;
  eventSequence=new int[processCount];
  int count=0;
  for (int i=eventSequence.length - 1; i >= 0; i--) {
    eventSequence[count]=i;
    count++;
  }
}",0.9402756508422664
29070,"public PatternMultiProcessStreamReceiver clone(String key){
  return new PatternMultiProcessStreamReceiver(streamId + key,processCount,latencyTracker);
}","public PatternMultiProcessStreamReceiver clone(String key){
  return new PatternMultiProcessStreamReceiver(streamId + key,processCount,key,latencyTracker);
}",0.9870967741935484
29071,"public PatternSingleProcessStreamReceiver(String streamId,LatencyTracker latencyTracker){
  super(streamId,latencyTracker);
}","public PatternSingleProcessStreamReceiver(String streamId,String lockKey,LatencyTracker latencyTracker){
  super(streamId,latencyTracker);
  this.lockKey=lockKey;
}",0.8650519031141869
29072,"public PatternSingleProcessStreamReceiver clone(String key){
  return new PatternSingleProcessStreamReceiver(streamId + key,latencyTracker);
}","public PatternSingleProcessStreamReceiver clone(String key){
  return new PatternSingleProcessStreamReceiver(streamId + key,key,latencyTracker);
}",0.9861111111111112
29073,"public SequenceMultiProcessStreamReceiver clone(String key){
  return new SequenceMultiProcessStreamReceiver(streamId + key,processCount,null,latencyTracker);
}","public SequenceMultiProcessStreamReceiver clone(String key){
  return new SequenceMultiProcessStreamReceiver(streamId + key,processCount,null,key,latencyTracker);
}",0.9876543209876544
29074,"public SequenceMultiProcessStreamReceiver(String streamId,int processCount,StateStreamRuntime stateStreamRuntime,LatencyTracker latencyTracker){
  super(streamId,processCount,latencyTracker);
  this.stateStreamRuntime=stateStreamRuntime;
  eventSequence=new int[processCount];
  int count=0;
  for (int i=eventSequence.length - 1; i >= 0; i--) {
    eventSequence[count]=i;
    count++;
  }
}","public SequenceMultiProcessStreamReceiver(String streamId,int processCount,StateStreamRuntime stateStreamRuntime,String lockKey,LatencyTracker latencyTracker){
  super(streamId,processCount,latencyTracker);
  this.stateStreamRuntime=stateStreamRuntime;
  this.lockKey=lockKey;
  eventSequence=new int[processCount];
  int count=0;
  for (int i=eventSequence.length - 1; i >= 0; i--) {
    eventSequence[count]=i;
    count++;
  }
}",0.9526123936816524
29075,"public SequenceSingleProcessStreamReceiver clone(String key){
  return new SequenceSingleProcessStreamReceiver(streamId + key,null,latencyTracker);
}","public SequenceSingleProcessStreamReceiver clone(String key){
  return new SequenceSingleProcessStreamReceiver(streamId + key,null,key,latencyTracker);
}",0.9867549668874172
29076,"public SequenceSingleProcessStreamReceiver(String streamId,StateStreamRuntime stateStreamRuntime,LatencyTracker latencyTracker){
  super(streamId,latencyTracker);
  this.stateStreamRuntime=stateStreamRuntime;
}","public SequenceSingleProcessStreamReceiver(String streamId,StateStreamRuntime stateStreamRuntime,String lockKey,LatencyTracker latencyTracker){
  super(streamId,latencyTracker);
  this.stateStreamRuntime=stateStreamRuntime;
  this.lockKey=lockKey;
}",0.915032679738562
29077,"public static StateStreamRuntime parseInputStream(StateInputStream stateInputStream,ExecutionPlanContext executionPlanContext,MetaStateEvent metaStateEvent,Map<String,AbstractDefinition> streamDefinitionMap,Map<String,AbstractDefinition> tableDefinitionMap,Map<String,EventTable> eventTableMap,List<VariableExpressionExecutor> variableExpressionExecutors,LatencyTracker latencyTracker){
  Map<String,ProcessStreamReceiver> processStreamReceiverMap=new HashMap<String,ProcessStreamReceiver>();
  StateStreamRuntime stateStreamRuntime=new StateStreamRuntime(executionPlanContext,metaStateEvent);
  for (  String streamId : stateInputStream.getAllStreamIds()) {
    int streamCount=stateInputStream.getStreamCount(streamId);
    if (streamCount == 1) {
      if (stateInputStream.getStateType() == StateInputStream.Type.SEQUENCE) {
        processStreamReceiverMap.put(streamId,new SequenceSingleProcessStreamReceiver(streamId,stateStreamRuntime,latencyTracker));
      }
 else {
        processStreamReceiverMap.put(streamId,new PatternSingleProcessStreamReceiver(streamId,latencyTracker));
      }
    }
 else {
      if (stateInputStream.getStateType() == StateInputStream.Type.SEQUENCE) {
        processStreamReceiverMap.put(streamId,new SequenceMultiProcessStreamReceiver(streamId,streamCount,stateStreamRuntime,latencyTracker));
      }
 else {
        processStreamReceiverMap.put(streamId,new PatternMultiProcessStreamReceiver(streamId,streamCount,latencyTracker));
      }
    }
  }
  StateElement stateElement=stateInputStream.getStateElement();
  InnerStateRuntime innerStateRuntime=parse(stateElement,streamDefinitionMap,tableDefinitionMap,eventTableMap,metaStateEvent,executionPlanContext,variableExpressionExecutors,processStreamReceiverMap,null,null,stateInputStream.getStateType(),new ArrayList<Map.Entry<Long,Set<Integer>>>(),latencyTracker);
  stateStreamRuntime.setInnerStateRuntime(innerStateRuntime);
  return stateStreamRuntime;
}","public static StateStreamRuntime parseInputStream(StateInputStream stateInputStream,ExecutionPlanContext executionPlanContext,MetaStateEvent metaStateEvent,Map<String,AbstractDefinition> streamDefinitionMap,Map<String,AbstractDefinition> tableDefinitionMap,Map<String,EventTable> eventTableMap,List<VariableExpressionExecutor> variableExpressionExecutors,LatencyTracker latencyTracker){
  Map<String,ProcessStreamReceiver> processStreamReceiverMap=new HashMap<String,ProcessStreamReceiver>();
  StateStreamRuntime stateStreamRuntime=new StateStreamRuntime(executionPlanContext,metaStateEvent);
  String defaultLockKey=""String_Node_Str"";
  for (  String streamId : stateInputStream.getAllStreamIds()) {
    int streamCount=stateInputStream.getStreamCount(streamId);
    if (streamCount == 1) {
      if (stateInputStream.getStateType() == StateInputStream.Type.SEQUENCE) {
        processStreamReceiverMap.put(streamId,new SequenceSingleProcessStreamReceiver(streamId,stateStreamRuntime,defaultLockKey,latencyTracker));
      }
 else {
        processStreamReceiverMap.put(streamId,new PatternSingleProcessStreamReceiver(streamId,defaultLockKey,latencyTracker));
      }
    }
 else {
      if (stateInputStream.getStateType() == StateInputStream.Type.SEQUENCE) {
        processStreamReceiverMap.put(streamId,new SequenceMultiProcessStreamReceiver(streamId,streamCount,stateStreamRuntime,defaultLockKey,latencyTracker));
      }
 else {
        processStreamReceiverMap.put(streamId,new PatternMultiProcessStreamReceiver(streamId,streamCount,defaultLockKey,latencyTracker));
      }
    }
  }
  StateElement stateElement=stateInputStream.getStateElement();
  InnerStateRuntime innerStateRuntime=parse(stateElement,streamDefinitionMap,tableDefinitionMap,eventTableMap,metaStateEvent,executionPlanContext,variableExpressionExecutors,processStreamReceiverMap,null,null,stateInputStream.getStateType(),new ArrayList<Map.Entry<Long,Set<Integer>>>(),latencyTracker);
  stateStreamRuntime.setInnerStateRuntime(innerStateRuntime);
  return stateStreamRuntime;
}",0.97426929802648
29078,"/** 
 * Parse Selector portion of a query and return corresponding QuerySelector
 * @param selector             selector to be parsed
 * @param outputStream         output stream
 * @param executionPlanContext query to be parsed
 * @param metaComplexEvent     Meta event used to collect execution info of stream associated with query
 * @param eventTableMap        EventTable Map
 * @return QuerySelector
 */
public static QuerySelector parse(Selector selector,OutputStream outputStream,ExecutionPlanContext executionPlanContext,MetaComplexEvent metaComplexEvent,Map<String,EventTable> eventTableMap,List<VariableExpressionExecutor> variableExpressionExecutors){
  boolean currentOn=false;
  boolean expiredOn=false;
  String id=null;
  if (outputStream.getOutputEventType() == OutputStream.OutputEventType.CURRENT_EVENTS || outputStream.getOutputEventType() == OutputStream.OutputEventType.ALL_EVENTS) {
    currentOn=true;
  }
  if (outputStream.getOutputEventType() == OutputStream.OutputEventType.EXPIRED_EVENTS || outputStream.getOutputEventType() == OutputStream.OutputEventType.ALL_EVENTS) {
    expiredOn=true;
  }
  id=outputStream.getId();
  QuerySelector querySelector=new QuerySelector(id,selector,currentOn,expiredOn,executionPlanContext);
  List<AttributeProcessor> attributeProcessors=getAttributeProcessors(selector,id,executionPlanContext,metaComplexEvent,eventTableMap,variableExpressionExecutors);
  querySelector.setAttributeProcessorList(attributeProcessors,""String_Node_Str"".equals(containsAggregatorThreadLocal.get()));
  containsAggregatorThreadLocal.remove();
  ConditionExpressionExecutor havingCondition=generateHavingExecutor(selector.getHavingExpression(),metaComplexEvent,executionPlanContext,eventTableMap,variableExpressionExecutors);
  querySelector.setHavingConditionExecutor(havingCondition);
  if (!selector.getGroupByList().isEmpty()) {
    querySelector.setGroupByKeyGenerator(new GroupByKeyGenerator(selector.getGroupByList(),metaComplexEvent,null,variableExpressionExecutors,executionPlanContext));
  }
  return querySelector;
}","/** 
 * Parse Selector portion of a query and return corresponding QuerySelector
 * @param selector                    selector to be parsed
 * @param outputStream                output stream
 * @param executionPlanContext        query to be parsed
 * @param metaComplexEvent            Meta event used to collect execution info of stream associated with query
 * @param eventTableMap               EventTable Map
 * @param variableExpressionExecutors variable expression executors
 * @return QuerySelector
 */
public static QuerySelector parse(Selector selector,OutputStream outputStream,ExecutionPlanContext executionPlanContext,MetaComplexEvent metaComplexEvent,Map<String,EventTable> eventTableMap,List<VariableExpressionExecutor> variableExpressionExecutors){
  boolean currentOn=false;
  boolean expiredOn=false;
  String id=null;
  if (outputStream.getOutputEventType() == OutputStream.OutputEventType.CURRENT_EVENTS || outputStream.getOutputEventType() == OutputStream.OutputEventType.ALL_EVENTS) {
    currentOn=true;
  }
  if (outputStream.getOutputEventType() == OutputStream.OutputEventType.EXPIRED_EVENTS || outputStream.getOutputEventType() == OutputStream.OutputEventType.ALL_EVENTS) {
    expiredOn=true;
  }
  id=outputStream.getId();
  QuerySelector querySelector=new QuerySelector(id,selector,currentOn,expiredOn,executionPlanContext);
  List<AttributeProcessor> attributeProcessors=getAttributeProcessors(selector,id,executionPlanContext,metaComplexEvent,eventTableMap,variableExpressionExecutors);
  querySelector.setAttributeProcessorList(attributeProcessors,""String_Node_Str"".equals(containsAggregatorThreadLocal.get()));
  containsAggregatorThreadLocal.remove();
  ConditionExpressionExecutor havingCondition=generateHavingExecutor(selector.getHavingExpression(),metaComplexEvent,executionPlanContext,eventTableMap,variableExpressionExecutors);
  querySelector.setHavingConditionExecutor(havingCondition);
  if (!selector.getGroupByList().isEmpty()) {
    querySelector.setGroupByKeyGenerator(new GroupByKeyGenerator(selector.getGroupByList(),metaComplexEvent,null,variableExpressionExecutors,executionPlanContext));
  }
  return querySelector;
}",0.9757018164661476
29079,"/** 
 * Parse single InputStream and return SingleStreamRuntime
 * @param inputStream                 single input stream to be parsed
 * @param executionPlanContext        query to be parsed
 * @param variableExpressionExecutors List to hold VariableExpressionExecutors to update after query parsing
 * @param streamDefinitionMap         Stream Definition Map
 * @param tableDefinitionMap          Table Definition Map
 * @param eventTableMap               EventTable Map
 * @param metaComplexEvent            MetaComplexEvent
 * @param processStreamReceiver       ProcessStreamReceiver
 * @return SingleStreamRuntime
 */
public static SingleStreamRuntime parseInputStream(SingleInputStream inputStream,ExecutionPlanContext executionPlanContext,List<VariableExpressionExecutor> variableExpressionExecutors,Map<String,AbstractDefinition> streamDefinitionMap,Map<String,AbstractDefinition> tableDefinitionMap,Map<String,EventTable> eventTableMap,MetaComplexEvent metaComplexEvent,ProcessStreamReceiver processStreamReceiver,boolean supportsBatchProcessing,LatencyTracker latencyTracker){
  Processor processor=null;
  SingleThreadEntryValveProcessor singleThreadValve=null;
  boolean first=true;
  MetaStreamEvent metaStreamEvent;
  if (metaComplexEvent instanceof MetaStateEvent) {
    metaStreamEvent=new MetaStreamEvent();
    ((MetaStateEvent)metaComplexEvent).addEvent(metaStreamEvent);
    initMetaStreamEvent(inputStream,streamDefinitionMap,tableDefinitionMap,metaStreamEvent);
  }
 else {
    metaStreamEvent=(MetaStreamEvent)metaComplexEvent;
    initMetaStreamEvent(inputStream,streamDefinitionMap,tableDefinitionMap,metaStreamEvent);
  }
  if (!inputStream.getStreamHandlers().isEmpty()) {
    for (    StreamHandler handler : inputStream.getStreamHandlers()) {
      Processor currentProcessor=generateProcessor(handler,metaComplexEvent,variableExpressionExecutors,executionPlanContext,eventTableMap,supportsBatchProcessing);
      if (currentProcessor instanceof SchedulingProcessor) {
        if (singleThreadValve == null) {
          singleThreadValve=new SingleThreadEntryValveProcessor(executionPlanContext);
          if (first) {
            processor=singleThreadValve;
            first=false;
          }
 else {
            processor.setToLast(singleThreadValve);
          }
        }
        Scheduler scheduler=new Scheduler(executionPlanContext.getScheduledExecutorService(),singleThreadValve);
        scheduler.init(executionPlanContext,latencyTracker);
        ((SchedulingProcessor)currentProcessor).setScheduler(scheduler);
      }
      if (first) {
        processor=currentProcessor;
        first=false;
      }
 else {
        processor.setToLast(currentProcessor);
      }
    }
  }
  metaStreamEvent.initializeAfterWindowData();
  return new SingleStreamRuntime(processStreamReceiver,processor,metaComplexEvent);
}","/** 
 * Parse single InputStream and return SingleStreamRuntime
 * @param inputStream                 single input stream to be parsed
 * @param executionPlanContext        query to be parsed
 * @param variableExpressionExecutors List to hold VariableExpressionExecutors to update after query parsing
 * @param streamDefinitionMap         Stream Definition Map
 * @param tableDefinitionMap          Table Definition Map
 * @param eventTableMap               EventTable Map
 * @param metaComplexEvent            MetaComplexEvent
 * @param processStreamReceiver       ProcessStreamReceiver
 * @param latencyTracker              latency tracker
 * @return SingleStreamRuntime
 */
public static SingleStreamRuntime parseInputStream(SingleInputStream inputStream,ExecutionPlanContext executionPlanContext,List<VariableExpressionExecutor> variableExpressionExecutors,Map<String,AbstractDefinition> streamDefinitionMap,Map<String,AbstractDefinition> tableDefinitionMap,Map<String,EventTable> eventTableMap,MetaComplexEvent metaComplexEvent,ProcessStreamReceiver processStreamReceiver,boolean supportsBatchProcessing,LatencyTracker latencyTracker){
  Processor processor=null;
  SingleThreadEntryValveProcessor singleThreadValve=null;
  boolean first=true;
  MetaStreamEvent metaStreamEvent;
  if (metaComplexEvent instanceof MetaStateEvent) {
    metaStreamEvent=new MetaStreamEvent();
    ((MetaStateEvent)metaComplexEvent).addEvent(metaStreamEvent);
    initMetaStreamEvent(inputStream,streamDefinitionMap,tableDefinitionMap,metaStreamEvent);
  }
 else {
    metaStreamEvent=(MetaStreamEvent)metaComplexEvent;
    initMetaStreamEvent(inputStream,streamDefinitionMap,tableDefinitionMap,metaStreamEvent);
  }
  if (!inputStream.getStreamHandlers().isEmpty()) {
    for (    StreamHandler handler : inputStream.getStreamHandlers()) {
      Processor currentProcessor=generateProcessor(handler,metaComplexEvent,variableExpressionExecutors,executionPlanContext,eventTableMap,supportsBatchProcessing);
      if (currentProcessor instanceof SchedulingProcessor) {
        if (singleThreadValve == null) {
          singleThreadValve=new SingleThreadEntryValveProcessor(executionPlanContext);
          if (first) {
            processor=singleThreadValve;
            first=false;
          }
 else {
            processor.setToLast(singleThreadValve);
          }
        }
        Scheduler scheduler=new Scheduler(executionPlanContext.getScheduledExecutorService(),singleThreadValve);
        scheduler.init(executionPlanContext,latencyTracker);
        ((SchedulingProcessor)currentProcessor).setScheduler(scheduler);
      }
      if (first) {
        processor=currentProcessor;
        first=false;
      }
 else {
        processor.setToLast(currentProcessor);
      }
    }
  }
  metaStreamEvent.initializeAfterWindowData();
  return new SingleStreamRuntime(processStreamReceiver,processor,metaComplexEvent);
}",0.990625
29080,"/** 
 * @return Name of the mem tracker
 */
String getName(Object object);","/** 
 * @param object Object
 * @return Name of the mem tracker
 */
String getName(Object object);",0.8604651162790697
29081,"/** 
 * Register the object that needs to be measured the memory usage
 * @param object Object
 * @param name An unique value to identify the object.
 */
void registerObject(Object object,String name);","/** 
 * Register the object that needs to be measured the memory usage
 * @param object Object
 * @param name   An unique value to identify the object.
 */
void registerObject(Object object,String name);",0.995049504950495
29082,"/** 
 * This method is to notify receive of multiple events to calculate the throughput
 */
void eventsIn(int eventCount);","/** 
 * This method is to notify receive of multiple events to calculate the throughput
 * @param eventCount number of events passing through
 */
void eventsIn(int eventCount);",0.8187919463087249
29083,"/** 
 * Returns the parent chain, from which this chain was created.
 * @throws IllegalStateException if {@code !hasParent()}, then an
 */
public Chain getParent(){
  Preconditions.checkState(parent != null,""String_Node_Str"");
  return parent;
}","/** 
 * @return the parent chain, from which this chain was created.
 * @throws IllegalStateException if {@code !hasParent()}, then an
 */
public Chain getParent(){
  Preconditions.checkState(parent != null,""String_Node_Str"");
  return parent;
}",0.9714285714285714
29084,"/** 
 * Returns the value that this chain leads to. If the value is a primitive, a wrapper object is returned instead.
 */
public Object getValue(){
  return value;
}","/** 
 * @return the value that this chain leads to. If the value is a primitive,a wrapper object is returned instead.
 */
public Object getValue(){
  return value;
}",0.9848942598187312
29085,"/** 
 * Returns the root object of this chain.
 */
public Object getRoot(){
  Chain current=this;
  while (current.hasParent()) {
    current=current.getParent();
  }
  return current.getValue();
}","/** 
 * @return the root object of this chain.
 */
public Object getRoot(){
  Chain current=this;
  while (current.hasParent()) {
    current=current.getParent();
  }
  return current.getValue();
}",0.9898477157360406
29086,"/** 
 * Returns whether the value of this chain represents a primitive.
 */
public boolean isPrimitive(){
  return getValueType().isPrimitive();
}","/** 
 * @return whether the value of this chain represents a primitive.
 */
public boolean isPrimitive(){
  return getValueType().isPrimitive();
}",0.9863013698630136
29087,"/** 
 * Returns whether this chain has a parent. This returns false only when this chain represents the root object itself.
 */
public boolean hasParent(){
  return parent != null;
}","/** 
 * @return whether this chain has a parent. This returns false only whenthis chain represents the root object itself.
 */
public boolean hasParent(){
  return parent != null;
}",0.9862258953168044
29088,"/** 
 * Constructs a Footprint, by specifying the number of objects, references, and primitives (represented as a   {@link Multiset}).
 * @param objects the number of objects
 * @param references the number of references
 * @param primitives the number of primitives (represented by therespective primitive classes, e.g.  {@code int.class} etc)
 */
public Footprint(int objects,int references,Multiset<Class<?>> primitives){
  Preconditions.checkArgument(objects >= 0,""String_Node_Str"");
  Preconditions.checkArgument(references >= 0,""String_Node_Str"");
  Preconditions.checkArgument(primitiveTypes.containsAll(primitives.elementSet()),""String_Node_Str"");
  this.objects=objects;
  this.references=references;
  this.primitives=ImmutableMultiset.copyOf(primitives);
}","/** 
 * Constructs a Footprint, by specifying the number of objects, references, and primitives (represented as a   {@link Multiset}).
 * @param objects    the number of objects
 * @param references the number of references
 * @param primitives the number of primitives (represented by therespective primitive classes, e.g.  {@code int.class} etc)
 */
public Footprint(int objects,int references,Multiset<Class<?>> primitives){
  Preconditions.checkArgument(objects >= 0,""String_Node_Str"");
  Preconditions.checkArgument(references >= 0,""String_Node_Str"");
  Preconditions.checkArgument(primitiveTypes.containsAll(primitives.elementSet()),""String_Node_Str"");
  this.objects=objects;
  this.references=references;
  this.primitives=ImmutableMultiset.copyOf(primitives);
}",0.9980481457384516
29089,"/** 
 * Returns the number of references of this footprint.
 */
public int getReferences(){
  return references;
}","/** 
 * @return the number of references of this footprint.
 */
public int getReferences(){
  return references;
}",0.9824561403508772
29090,"/** 
 * Measures the footprint of the specified object graph. The object graph is defined by a root object and whatever object can be reached through that, excluding static fields,   {@code Class} objects,and fields defined in  {@code enum}s (all these are considered shared values, which should not contribute to the cost of any single object graph), and any object for which the user-provided predicate returns  {@code false}.
 * @param rootObject the root object of the object graph
 * @param objectAcceptor a predicate that returns {@code true} for objectsto be explored (and treated as part of the footprint), or  {@code false}to forbid the traversal to traverse the given object
 * @return the footprint of the object graph
 */
public static Footprint measure(Object rootObject,Predicate<Object> objectAcceptor){
  Preconditions.checkNotNull(objectAcceptor,""String_Node_Str"");
  Predicate<Chain> completePredicate=Predicates.and(ImmutableList.of(ObjectExplorer.notEnumFieldsOrClasses,Predicates.compose(objectAcceptor,ObjectExplorer.chainToObject),new ObjectExplorer.AtMostOncePredicate()));
  return ObjectExplorer.exploreObject(rootObject,new ObjectGraphVisitor(completePredicate),EnumSet.of(ObjectExplorer.Feature.VISIT_PRIMITIVES,ObjectExplorer.Feature.VISIT_NULL));
}","/** 
 * Measures the footprint of the specified object graph. The object graph is defined by a root object and whatever object can be reached through that, excluding static fields,   {@code Class} objects,and fields defined in  {@code enum}s (all these are considered shared values, which should not contribute to the cost of any single object graph), and any object for which the user-provided predicate returns  {@code false}.
 * @param rootObject     the root object of the object graph
 * @param objectAcceptor a predicate that returns {@code true} for objectsto be explored (and treated as part of the footprint), or  {@code false}to forbid the traversal to traverse the given object
 * @return the footprint of the object graph
 */
public static Footprint measure(Object rootObject,Predicate<Object> objectAcceptor){
  Preconditions.checkNotNull(objectAcceptor,""String_Node_Str"");
  Predicate<Chain> completePredicate=Predicates.and(ImmutableList.of(ObjectExplorer.notEnumFieldsOrClasses,Predicates.compose(objectAcceptor,ObjectExplorer.chainToObject),new ObjectExplorer.AtMostOncePredicate()));
  return ObjectExplorer.exploreObject(rootObject,new ObjectGraphVisitor(completePredicate),EnumSet.of(ObjectExplorer.Feature.VISIT_PRIMITIVES,ObjectExplorer.Feature.VISIT_NULL));
}",0.9984375
29091,"/** 
 * Returns the number of primitives of this footprint (represented by the respective primitive classes,  {@literal e.g.} {@code int.class} etc).
 */
public ImmutableMultiset<Class<?>> getPrimitives(){
  return primitives;
}","/** 
 * @return the number of primitives of this footprint(represented by the respective primitive classes, {@literal e.g.} {@code int.class} etc).
 */
public ImmutableMultiset<Class<?>> getPrimitives(){
  return primitives;
}",0.9647577092511012
29092,"/** 
 * Returns the number of objects of this footprint.
 */
public int getObjects(){
  return objects;
}","/** 
 * @return the number of objects of this footprint.
 */
public int getObjects(){
  return objects;
}",0.9809523809523808
29093,"/** 
 * Returns an arbitrary value (presumably constructed during the object graph traversal).
 */
T result();","/** 
 * @return  an arbitrary value (presumably constructed during the objectgraph traversal).
 */
T result();",0.9727272727272728
29094,"public SiddhiContext(){
  setSiddhiExtensions(SiddhiExtensionLoader.loadSiddhiExtensions());
  eventBufferSize=SiddhiConstants.DEFAULT_EVENT_BUFFER_SIZE;
  this.siddhiDataSources=new ConcurrentHashMap<String,DataSource>();
}","public SiddhiContext(){
  setSiddhiExtensions(SiddhiExtensionLoader.loadSiddhiExtensions());
  eventBufferSize=SiddhiConstants.DEFAULT_EVENT_BUFFER_SIZE;
  siddhiDataSources=new ConcurrentHashMap<String,DataSource>();
  extensionHolderMap=new ConcurrentHashMap<Class,AbstractExtensionHolder>();
}",0.8423076923076923
29095,"@Override public void receive(long timeStamp,Event[] inEvents,Event[] removeEvents){
  EventPrinter.print(timeStamp,inEvents,removeEvents);
  for (  Event event : inEvents) {
    count.incrementAndGet();
    if (count.get() == 1) {
      Assert.assertEquals(100.3d,event.getData(2));
      eventArrived=true;
    }
    if (count.get() == 2) {
      Assert.assertEquals(null,event.getData(2));
      eventArrived=true;
    }
    if (count.get() == 3) {
      Assert.assertEquals(300d,event.getData(2));
      eventArrived=true;
    }
  }
}","@Override public void receive(long timeStamp,Event[] inEvents,Event[] removeEvents){
  EventPrinter.print(timeStamp,inEvents,removeEvents);
  for (  Event event : inEvents) {
    count.incrementAndGet();
    if (count.get() == 1) {
      Assert.assertEquals(100.3d,event.getData(2));
      eventArrived=true;
    }
    if (count.get() == 2) {
      Assert.assertEquals(true,event.getData(2));
      eventArrived=true;
    }
    if (count.get() == 3) {
      Assert.assertEquals(300d,event.getData(2));
      eventArrived=true;
    }
  }
}",0.9925650557620818
29096,"@Test public void testCastFunctionExtension() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String inStreamDefinition=""String_Node_Str"";
  String query=(""String_Node_Str"" + ""String_Node_Str"");
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(inStreamDefinition + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      for (      Event event : inEvents) {
        count.incrementAndGet();
        if (count.get() == 1) {
          Assert.assertEquals(100.3d,event.getData(2));
          eventArrived=true;
        }
        if (count.get() == 2) {
          Assert.assertEquals(null,event.getData(2));
          eventArrived=true;
        }
        if (count.get() == 3) {
          Assert.assertEquals(300d,event.getData(2));
          eventArrived=true;
        }
      }
    }
  }
);
  InputHandler inputHandler=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  inputHandler.send(new Object[]{""String_Node_Str"",100.3,100l});
  inputHandler.send(new Object[]{""String_Node_Str"",true,200l});
  inputHandler.send(new Object[]{""String_Node_Str"",300d,200l});
  SiddhiTestHelper.waitForEvents(100,3,count,60000);
  Assert.assertEquals(3,count.get());
  Assert.assertTrue(eventArrived);
  executionPlanRuntime.shutdown();
}","@Test public void testCastFunctionExtension() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String inStreamDefinition=""String_Node_Str"";
  String query=(""String_Node_Str"" + ""String_Node_Str"");
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(inStreamDefinition + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      for (      Event event : inEvents) {
        count.incrementAndGet();
        if (count.get() == 1) {
          Assert.assertEquals(100.3d,event.getData(2));
          eventArrived=true;
        }
        if (count.get() == 2) {
          Assert.assertEquals(true,event.getData(2));
          eventArrived=true;
        }
        if (count.get() == 3) {
          Assert.assertEquals(300d,event.getData(2));
          eventArrived=true;
        }
      }
    }
  }
);
  InputHandler inputHandler=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  inputHandler.send(new Object[]{""String_Node_Str"",100.3,100l});
  inputHandler.send(new Object[]{""String_Node_Str"",true,200l});
  inputHandler.send(new Object[]{""String_Node_Str"",300d,200l});
  SiddhiTestHelper.waitForEvents(100,3,count,60000);
  Assert.assertEquals(3,count.get());
  Assert.assertTrue(eventArrived);
  executionPlanRuntime.shutdown();
}",0.997427652733119
29097,"private Object getMapFromXML(String data) throws XMLStreamException {
  Map<Object,Object> topLevelMap=new LinkedHashMap<Object,Object>();
  Map<Object,Object> map=new LinkedHashMap<Object,Object>();
  OMElement parentElement=AXIOMUtil.stringToOM(data);
  Iterator iterator=parentElement.getChildElements();
  while (iterator.hasNext()) {
    OMElement streamAttributeElement=(OMElement)iterator.next();
    String key=streamAttributeElement.getQName().toString();
    Object value;
    if (streamAttributeElement.getFirstElement() != null) {
      value=getMapFromXML(streamAttributeElement.toString());
    }
 else {
      String elementText=streamAttributeElement.getText();
      if (elementText.equals(""String_Node_Str"") || elementText.equals(""String_Node_Str"")) {
        value=Boolean.parseBoolean(elementText);
      }
 else {
        try {
          value=nf.parse(elementText);
        }
 catch (        ParseException e) {
          value=elementText;
        }
      }
    }
    map.put(key,value);
  }
  topLevelMap.put(parentElement.getQName().toString(),map);
  return topLevelMap;
}","private Object getMapFromXML(OMElement parentElement) throws XMLStreamException {
  Map<Object,Object> map=new HashMap<Object,Object>();
  Iterator iterator=parentElement.getChildElements();
  while (iterator.hasNext()) {
    OMElement streamAttributeElement=(OMElement)iterator.next();
    String key=streamAttributeElement.getQName().toString();
    Object value;
    if (streamAttributeElement.getFirstElement() != null) {
      value=getMapFromXML(streamAttributeElement);
    }
 else {
      String elementText=streamAttributeElement.getText();
      if (elementText.equals(""String_Node_Str"") || elementText.equals(""String_Node_Str"")) {
        value=Boolean.parseBoolean(elementText);
      }
 else {
        try {
          value=numberFormat.parse(elementText);
        }
 catch (        ParseException e) {
          value=elementText;
        }
      }
    }
    map.put(key,value);
  }
  return map;
}",0.8646766169154229
29098,"@Override protected Object execute(Object data){
  if (data instanceof String) {
    try {
      return getMapFromXML(data.toString());
    }
 catch (    XMLStreamException e) {
      throw new ExecutionPlanRuntimeException(""String_Node_Str"" + e.getMessage(),e);
    }
  }
 else {
    throw new ExecutionPlanRuntimeException(""String_Node_Str"");
  }
}","@Override protected Object execute(Object data){
  if (data instanceof String) {
    try {
      Map<Object,Object> topLevelMap=new HashMap<Object,Object>();
      OMElement parentElement=AXIOMUtil.stringToOM(data.toString());
      topLevelMap.put(parentElement.getQName().toString(),getMapFromXML(parentElement));
      return topLevelMap;
    }
 catch (    XMLStreamException e) {
      throw new ExecutionPlanRuntimeException(""String_Node_Str"" + e.getMessage(),e);
    }
  }
 else {
    throw new ExecutionPlanRuntimeException(""String_Node_Str"");
  }
}",0.7218543046357616
29099,"@Override public void receive(Event[] inEvents){
  EventPrinter.print(inEvents);
  for (  Event event : inEvents) {
    count.incrementAndGet();
    if (count.get() == 1) {
      JSONAssert.assertEquals(new JSONObject(""String_Node_Str""),new JSONObject(event.getData(0)),false);
      eventArrived=true;
    }
    if (count.get() == 2) {
      JSONAssert.assertEquals(new JSONObject(""String_Node_Str""),new JSONObject(event.getData(0)),false);
      eventArrived=true;
    }
    if (count.get() == 3) {
      JSONAssert.assertEquals(new JSONObject(""String_Node_Str""),new JSONObject(event.getData(0)),false);
      eventArrived=true;
    }
  }
}","@Override public void receive(Event[] inEvents){
  EventPrinter.print(inEvents);
  for (  Event event : inEvents) {
    count.incrementAndGet();
    if (count.get() == 1) {
      Assert.assertEquals(event.getData(0) instanceof String,true);
      JSONAssert.assertEquals(new JSONObject(""String_Node_Str""),new JSONObject((String)event.getData(0)),false);
      eventArrived=true;
    }
    if (count.get() == 2) {
      Assert.assertEquals(event.getData(0) instanceof String,true);
      JSONAssert.assertEquals(new JSONObject(""String_Node_Str""),new JSONObject((String)event.getData(0)),false);
      eventArrived=true;
    }
    if (count.get() == 3) {
      Assert.assertEquals(event.getData(0) instanceof String,true);
      JSONAssert.assertEquals(new JSONObject(""String_Node_Str""),new JSONObject((String)event.getData(0)),false);
      eventArrived=true;
    }
  }
}",0.8492063492063492
29100,"@Test public void testToJSONFunctionExtension2() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  siddhiManager.setExtension(""String_Node_Str"",ConcatFunctionExtension.class);
  String inStreamDefinition=""String_Node_Str"";
  String query=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(inStreamDefinition + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new StreamCallback(){
    @Override public void receive(    Event[] inEvents){
      EventPrinter.print(inEvents);
      for (      Event event : inEvents) {
        count.incrementAndGet();
        if (count.get() == 1) {
          JSONAssert.assertEquals(new JSONObject(""String_Node_Str""),new JSONObject(event.getData(0)),false);
          eventArrived=true;
        }
        if (count.get() == 2) {
          JSONAssert.assertEquals(new JSONObject(""String_Node_Str""),new JSONObject(event.getData(0)),false);
          eventArrived=true;
        }
        if (count.get() == 3) {
          JSONAssert.assertEquals(new JSONObject(""String_Node_Str""),new JSONObject(event.getData(0)),false);
          eventArrived=true;
        }
      }
    }
  }
);
  InputHandler inputHandler=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  inputHandler.send(new Object[]{""String_Node_Str"",100,100l});
  inputHandler.send(new Object[]{""String_Node_Str"",200,200l});
  inputHandler.send(new Object[]{""String_Node_Str"",300,200l});
  SiddhiTestHelper.waitForEvents(100,3,count,60000);
  Assert.assertEquals(3,count.get());
  Assert.assertTrue(eventArrived);
  executionPlanRuntime.shutdown();
}","@Test public void testToJSONFunctionExtension2() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  siddhiManager.setExtension(""String_Node_Str"",ConcatFunctionExtension.class);
  String inStreamDefinition=""String_Node_Str"";
  String query=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(inStreamDefinition + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new StreamCallback(){
    @Override public void receive(    Event[] inEvents){
      EventPrinter.print(inEvents);
      for (      Event event : inEvents) {
        count.incrementAndGet();
        if (count.get() == 1) {
          Assert.assertEquals(event.getData(0) instanceof String,true);
          JSONAssert.assertEquals(new JSONObject(""String_Node_Str""),new JSONObject((String)event.getData(0)),false);
          eventArrived=true;
        }
        if (count.get() == 2) {
          Assert.assertEquals(event.getData(0) instanceof String,true);
          JSONAssert.assertEquals(new JSONObject(""String_Node_Str""),new JSONObject((String)event.getData(0)),false);
          eventArrived=true;
        }
        if (count.get() == 3) {
          Assert.assertEquals(event.getData(0) instanceof String,true);
          JSONAssert.assertEquals(new JSONObject(""String_Node_Str""),new JSONObject((String)event.getData(0)),false);
          eventArrived=true;
        }
      }
    }
  }
);
  InputHandler inputHandler=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  inputHandler.send(new Object[]{""String_Node_Str"",100,100l});
  inputHandler.send(new Object[]{""String_Node_Str"",200,200l});
  inputHandler.send(new Object[]{""String_Node_Str"",300,200l});
  SiddhiTestHelper.waitForEvents(100,3,count,60000);
  Assert.assertEquals(3,count.get());
  Assert.assertTrue(eventArrived);
  executionPlanRuntime.shutdown();
}",0.9371069182389936
29101,"@Override public void receive(Event[] inEvents){
  EventPrinter.print(inEvents);
  for (  Event event : inEvents) {
    count.incrementAndGet();
    if (count.get() == 1) {
      Assert.assertEquals(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",event.getData(0));
      eventArrived=true;
    }
    if (count.get() == 2) {
      Assert.assertEquals(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",event.getData(0));
      eventArrived=true;
    }
    if (count.get() == 3) {
      Assert.assertEquals(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",event.getData(0));
      eventArrived=true;
    }
  }
}","@Override public void receive(Event[] inEvents){
  EventPrinter.print(inEvents);
  for (  Event event : inEvents) {
    count.incrementAndGet();
    if (count.get() == 1) {
      try {
        Assert.assertEquals(true,new XMLComparator().compare(AXIOMUtil.stringToOM(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),AXIOMUtil.stringToOM((String)event.getData(0))));
      }
 catch (      XMLComparisonException e) {
        log.error(""String_Node_Str"" + e.getMessage(),e);
      }
catch (      XMLStreamException e) {
        log.error(""String_Node_Str"" + e.getMessage(),e);
      }
      eventArrived=true;
    }
    if (count.get() == 2) {
      try {
        Assert.assertEquals(true,new XMLComparator().compare(AXIOMUtil.stringToOM(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),AXIOMUtil.stringToOM((String)event.getData(0))));
      }
 catch (      XMLComparisonException e) {
        log.error(""String_Node_Str"" + e.getMessage(),e);
      }
catch (      XMLStreamException e) {
        log.error(""String_Node_Str"" + e.getMessage(),e);
      }
      eventArrived=true;
    }
    if (count.get() == 3) {
      try {
        Assert.assertEquals(true,new XMLComparator().compare(AXIOMUtil.stringToOM(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),AXIOMUtil.stringToOM((String)event.getData(0))));
      }
 catch (      XMLComparisonException e) {
        log.error(""String_Node_Str"" + e.getMessage(),e);
      }
catch (      XMLStreamException e) {
        log.error(""String_Node_Str"" + e.getMessage(),e);
      }
      eventArrived=true;
    }
  }
}",0.3625730994152046
29102,"@Test public void testToXMLFunctionExtension() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  siddhiManager.setExtension(""String_Node_Str"",ConcatFunctionExtension.class);
  String inStreamDefinition=""String_Node_Str"";
  String query=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(inStreamDefinition + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new StreamCallback(){
    @Override public void receive(    Event[] inEvents){
      EventPrinter.print(inEvents);
      for (      Event event : inEvents) {
        count.incrementAndGet();
        if (count.get() == 1) {
          Assert.assertEquals(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",event.getData(0));
          eventArrived=true;
        }
      }
    }
  }
);
  InputHandler inputHandler=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  inputHandler.send(new Object[]{""String_Node_Str"",100,100l});
  inputHandler.send(new Object[]{""String_Node_Str"",200,200l});
  inputHandler.send(new Object[]{""String_Node_Str"",300,200l});
  SiddhiTestHelper.waitForEvents(100,3,count,60000);
  Assert.assertEquals(3,count.get());
  Assert.assertTrue(eventArrived);
  executionPlanRuntime.shutdown();
}","@Test public void testToXMLFunctionExtension() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  siddhiManager.setExtension(""String_Node_Str"",ConcatFunctionExtension.class);
  String inStreamDefinition=""String_Node_Str"";
  String query=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(inStreamDefinition + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new StreamCallback(){
    @Override public void receive(    Event[] inEvents){
      EventPrinter.print(inEvents);
      for (      Event event : inEvents) {
        count.incrementAndGet();
        if (count.get() == 1) {
          try {
            Assert.assertEquals(true,new XMLComparator().compare(AXIOMUtil.stringToOM(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),AXIOMUtil.stringToOM((String)event.getData(0))));
          }
 catch (          XMLStreamException e) {
            log.error(""String_Node_Str"" + e.getMessage(),e);
          }
catch (          XMLComparisonException e) {
            log.error(""String_Node_Str"" + e.getMessage(),e);
          }
          eventArrived=true;
        }
      }
    }
  }
);
  InputHandler inputHandler=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  inputHandler.send(new Object[]{""String_Node_Str"",100,100l});
  inputHandler.send(new Object[]{""String_Node_Str"",200,200l});
  inputHandler.send(new Object[]{""String_Node_Str"",300,200l});
  SiddhiTestHelper.waitForEvents(100,3,count,60000);
  Assert.assertEquals(3,count.get());
  Assert.assertTrue(eventArrived);
  executionPlanRuntime.shutdown();
}",0.8328366296396641
29103,"@Test public void testCreateFromXMLFunctionExtension2() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  siddhiManager.setExtension(""String_Node_Str"",ConcatFunctionExtension.class);
  String inStreamDefinition=""String_Node_Str"";
  String query=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(inStreamDefinition + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new StreamCallback(){
    @Override public void receive(    Event[] inEvents){
      EventPrinter.print(inEvents);
      for (      Event event : inEvents) {
        count.incrementAndGet();
        if (count.get() == 1) {
          Assert.assertEquals(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",event.getData(0));
          eventArrived=true;
        }
        if (count.get() == 2) {
          Assert.assertEquals(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",event.getData(0));
          eventArrived=true;
        }
        if (count.get() == 3) {
          Assert.assertEquals(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",event.getData(0));
          eventArrived=true;
        }
      }
    }
  }
);
  InputHandler inputHandler=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  inputHandler.send(new Object[]{25,100.1,true,""String_Node_Str""});
  inputHandler.send(new Object[]{35,100.11,false,""String_Node_Str""});
  inputHandler.send(new Object[]{45,100.13456,true,""String_Node_Str""});
  SiddhiTestHelper.waitForEvents(100,3,count,60000);
  Assert.assertEquals(3,count.get());
  Assert.assertTrue(eventArrived);
  executionPlanRuntime.shutdown();
}","@Test public void testCreateFromXMLFunctionExtension2() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  siddhiManager.setExtension(""String_Node_Str"",ConcatFunctionExtension.class);
  String inStreamDefinition=""String_Node_Str"";
  String query=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(inStreamDefinition + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new StreamCallback(){
    @Override public void receive(    Event[] inEvents){
      EventPrinter.print(inEvents);
      for (      Event event : inEvents) {
        count.incrementAndGet();
        if (count.get() == 1) {
          try {
            Assert.assertEquals(true,new XMLComparator().compare(AXIOMUtil.stringToOM(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),AXIOMUtil.stringToOM((String)event.getData(0))));
          }
 catch (          XMLComparisonException e) {
            log.error(""String_Node_Str"" + e.getMessage(),e);
          }
catch (          XMLStreamException e) {
            log.error(""String_Node_Str"" + e.getMessage(),e);
          }
          eventArrived=true;
        }
        if (count.get() == 2) {
          try {
            Assert.assertEquals(true,new XMLComparator().compare(AXIOMUtil.stringToOM(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),AXIOMUtil.stringToOM((String)event.getData(0))));
          }
 catch (          XMLComparisonException e) {
            log.error(""String_Node_Str"" + e.getMessage(),e);
          }
catch (          XMLStreamException e) {
            log.error(""String_Node_Str"" + e.getMessage(),e);
          }
          eventArrived=true;
        }
        if (count.get() == 3) {
          try {
            Assert.assertEquals(true,new XMLComparator().compare(AXIOMUtil.stringToOM(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),AXIOMUtil.stringToOM((String)event.getData(0))));
          }
 catch (          XMLComparisonException e) {
            log.error(""String_Node_Str"" + e.getMessage(),e);
          }
catch (          XMLStreamException e) {
            log.error(""String_Node_Str"" + e.getMessage(),e);
          }
          eventArrived=true;
        }
      }
    }
  }
);
  InputHandler inputHandler=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  inputHandler.send(new Object[]{25,100.1,true,""String_Node_Str""});
  inputHandler.send(new Object[]{35,100.11,false,""String_Node_Str""});
  inputHandler.send(new Object[]{45,100.13456,true,""String_Node_Str""});
  SiddhiTestHelper.waitForEvents(100,3,count,60000);
  Assert.assertEquals(3,count.get());
  Assert.assertTrue(eventArrived);
  executionPlanRuntime.shutdown();
}",0.7941002949852507
29104,"private AttributeAggregatorExtensionHolder(ExecutionPlanContext executionPlanContext){
  super(AttributeAggregator.class,executionPlanContext);
}","private AttributeAggregatorExtensionHolder(ExecutionPlanContext executionPlanContext){
  super(clazz,executionPlanContext);
}",0.9111111111111112
29105,"public static AttributeAggregatorExtensionHolder getInstance(ExecutionPlanContext executionPlanContext){
  if (instance == null) {
    instance=new AttributeAggregatorExtensionHolder(executionPlanContext);
  }
  return instance;
}","public static AttributeAggregatorExtensionHolder getInstance(ExecutionPlanContext executionPlanContext){
  ConcurrentHashMap<Class,AbstractExtensionHolder> extensionHolderMap=executionPlanContext.getSiddhiContext().getExtensionHolderMap();
  AbstractExtensionHolder abstractExtensionHolder=extensionHolderMap.get(clazz);
  if (abstractExtensionHolder == null) {
    abstractExtensionHolder=new AttributeAggregatorExtensionHolder(executionPlanContext);
    extensionHolderMap.putIfAbsent(clazz,abstractExtensionHolder);
  }
  return (AttributeAggregatorExtensionHolder)extensionHolderMap.get(clazz);
}",0.4963855421686747
29106,"protected EvalScriptExtensionHolder(ExecutionPlanContext executionPlanContext){
  super(EvalScript.class,executionPlanContext);
}","protected EvalScriptExtensionHolder(ExecutionPlanContext executionPlanContext){
  super(clazz,executionPlanContext);
}",0.9392712550607288
29107,"public static EvalScriptExtensionHolder getInstance(ExecutionPlanContext executionPlanContext){
  if (instance == null) {
    instance=new EvalScriptExtensionHolder(executionPlanContext);
  }
  return instance;
}","public static EvalScriptExtensionHolder getInstance(ExecutionPlanContext executionPlanContext){
  ConcurrentHashMap<Class,AbstractExtensionHolder> extensionHolderMap=executionPlanContext.getSiddhiContext().getExtensionHolderMap();
  AbstractExtensionHolder abstractExtensionHolder=extensionHolderMap.get(clazz);
  if (abstractExtensionHolder == null) {
    abstractExtensionHolder=new EvalScriptExtensionHolder(executionPlanContext);
    extensionHolderMap.putIfAbsent(clazz,abstractExtensionHolder);
  }
  return (EvalScriptExtensionHolder)extensionHolderMap.get(clazz);
}",0.4789808917197452
29108,"public static EventTableExtensionHolder getInstance(ExecutionPlanContext executionPlanContext){
  if (instance == null) {
    instance=new EventTableExtensionHolder(executionPlanContext);
  }
  return instance;
}","public static EventTableExtensionHolder getInstance(ExecutionPlanContext executionPlanContext){
  ConcurrentHashMap<Class,AbstractExtensionHolder> extensionHolderMap=executionPlanContext.getSiddhiContext().getExtensionHolderMap();
  AbstractExtensionHolder abstractExtensionHolder=extensionHolderMap.get(clazz);
  if (abstractExtensionHolder == null) {
    abstractExtensionHolder=new EventTableExtensionHolder(executionPlanContext);
    extensionHolderMap.putIfAbsent(clazz,abstractExtensionHolder);
  }
  return (EventTableExtensionHolder)extensionHolderMap.get(clazz);
}",0.4789808917197452
29109,"protected EventTableExtensionHolder(ExecutionPlanContext executionPlanContext){
  super(EventTable.class,executionPlanContext);
}","protected EventTableExtensionHolder(ExecutionPlanContext executionPlanContext){
  super(clazz,executionPlanContext);
}",0.9392712550607288
29110,"private FunctionExecutorExtensionHolder(ExecutionPlanContext executionPlanContext){
  super(FunctionExecutor.class,executionPlanContext);
}","private FunctionExecutorExtensionHolder(ExecutionPlanContext executionPlanContext){
  super(clazz,executionPlanContext);
}",0.9195402298850576
29111,"public static FunctionExecutorExtensionHolder getInstance(ExecutionPlanContext executionPlanContext){
  if (instance == null) {
    instance=new FunctionExecutorExtensionHolder(executionPlanContext);
  }
  return instance;
}","public static FunctionExecutorExtensionHolder getInstance(ExecutionPlanContext executionPlanContext){
  ConcurrentHashMap<Class,AbstractExtensionHolder> extensionHolderMap=executionPlanContext.getSiddhiContext().getExtensionHolderMap();
  AbstractExtensionHolder abstractExtensionHolder=extensionHolderMap.get(clazz);
  if (abstractExtensionHolder == null) {
    abstractExtensionHolder=new FunctionExecutorExtensionHolder(executionPlanContext);
    extensionHolderMap.putIfAbsent(clazz,abstractExtensionHolder);
  }
  return (FunctionExecutorExtensionHolder)extensionHolderMap.get(clazz);
}",0.4907975460122699
29112,"private StreamFunctionProcessorExtensionHolder(ExecutionPlanContext executionPlanContext){
  super(StreamFunctionProcessor.class,executionPlanContext);
}","private StreamFunctionProcessorExtensionHolder(ExecutionPlanContext executionPlanContext){
  super(clazz,executionPlanContext);
}",0.900709219858156
29113,"public static StreamFunctionProcessorExtensionHolder getInstance(ExecutionPlanContext executionPlanContext){
  if (instance == null) {
    instance=new StreamFunctionProcessorExtensionHolder(executionPlanContext);
  }
  return instance;
}","public static StreamFunctionProcessorExtensionHolder getInstance(ExecutionPlanContext executionPlanContext){
  ConcurrentHashMap<Class,AbstractExtensionHolder> extensionHolderMap=executionPlanContext.getSiddhiContext().getExtensionHolderMap();
  AbstractExtensionHolder abstractExtensionHolder=extensionHolderMap.get(clazz);
  if (abstractExtensionHolder == null) {
    abstractExtensionHolder=new StreamFunctionProcessorExtensionHolder(executionPlanContext);
    extensionHolderMap.putIfAbsent(clazz,abstractExtensionHolder);
  }
  return (StreamFunctionProcessorExtensionHolder)extensionHolderMap.get(clazz);
}",0.5035294117647059
29114,"public static StreamProcessorExtensionHolder getInstance(ExecutionPlanContext executionPlanContext){
  if (instance == null) {
    instance=new StreamProcessorExtensionHolder(executionPlanContext);
  }
  return instance;
}","public static StreamProcessorExtensionHolder getInstance(ExecutionPlanContext executionPlanContext){
  ConcurrentHashMap<Class,AbstractExtensionHolder> extensionHolderMap=executionPlanContext.getSiddhiContext().getExtensionHolderMap();
  AbstractExtensionHolder abstractExtensionHolder=extensionHolderMap.get(clazz);
  if (abstractExtensionHolder == null) {
    abstractExtensionHolder=new StreamProcessorExtensionHolder(executionPlanContext);
    extensionHolderMap.putIfAbsent(clazz,abstractExtensionHolder);
  }
  return (StreamProcessorExtensionHolder)extensionHolderMap.get(clazz);
}",0.4888888888888889
29115,"private StreamProcessorExtensionHolder(ExecutionPlanContext executionPlanContext){
  super(StreamProcessor.class,executionPlanContext);
}","private StreamProcessorExtensionHolder(ExecutionPlanContext executionPlanContext){
  super(clazz,executionPlanContext);
}",0.9224806201550388
29116,"private WindowProcessorExtensionHolder(ExecutionPlanContext executionPlanContext){
  super(WindowProcessor.class,executionPlanContext);
}","private WindowProcessorExtensionHolder(ExecutionPlanContext executionPlanContext){
  super(clazz,executionPlanContext);
}",0.9224806201550388
29117,"public static WindowProcessorExtensionHolder getInstance(ExecutionPlanContext executionPlanContext){
  if (instance == null) {
    instance=new WindowProcessorExtensionHolder(executionPlanContext);
  }
  return instance;
}","public static WindowProcessorExtensionHolder getInstance(ExecutionPlanContext executionPlanContext){
  ConcurrentHashMap<Class,AbstractExtensionHolder> extensionHolderMap=executionPlanContext.getSiddhiContext().getExtensionHolderMap();
  AbstractExtensionHolder abstractExtensionHolder=extensionHolderMap.get(clazz);
  if (abstractExtensionHolder == null) {
    abstractExtensionHolder=new WindowProcessorExtensionHolder(executionPlanContext);
    extensionHolderMap.putIfAbsent(clazz,abstractExtensionHolder);
  }
  return (WindowProcessorExtensionHolder)extensionHolderMap.get(clazz);
}",0.4888888888888889
29118,"@Test(expected=ExecutionPlanValidationException.class) public void extensionTest3() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  siddhiManager.setExtension(""String_Node_Str"",CustomFunctionExtension.class);
  siddhiManager.setExtension(""String_Node_Str"",StringConcatAggregatorString.class);
  String cseEventStream=""String_Node_Str"";
  String query=(""String_Node_Str"" + ""String_Node_Str"");
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(cseEventStream + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      count=count + inEvents.length;
      if (count == 3) {
        Assert.assertEquals(""String_Node_Str"",inEvents[inEvents.length - 1].getData(1));
      }
      eventArrived=true;
    }
  }
);
  InputHandler inputHandler=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  inputHandler.send(new Object[]{""String_Node_Str"",700f,100l});
  Thread.sleep(100);
  inputHandler.send(new Object[]{""String_Node_Str"",60.5f,200l});
  Thread.sleep(100);
  inputHandler.send(new Object[]{""String_Node_Str"",60.5f,200l});
  Thread.sleep(100);
  Assert.assertEquals(3,count);
  Assert.assertTrue(eventArrived);
  executionPlanRuntime.shutdown();
}","@Test public void extensionTest3() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  siddhiManager.setExtension(""String_Node_Str"",CustomFunctionExtension.class);
  siddhiManager.setExtension(""String_Node_Str"",StringConcatAggregatorString.class);
  String cseEventStream=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  String query=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(cseEventStream + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      count=count + inEvents.length;
      if (count == 3) {
        Assert.assertEquals(""String_Node_Str"",inEvents[inEvents.length - 1].getData(1));
      }
      eventArrived=true;
    }
  }
);
  InputHandler inputHandler=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  inputHandler.send(new Object[]{""String_Node_Str"",700f,100l});
  Thread.sleep(100);
  inputHandler.send(new Object[]{""String_Node_Str"",60.5f,200l});
  Thread.sleep(100);
  inputHandler.send(new Object[]{""String_Node_Str"",60.5f,200l});
  Thread.sleep(100);
  Assert.assertEquals(3,count);
  Assert.assertTrue(eventArrived);
  executionPlanRuntime.shutdown();
}",0.9449966865473824
29119,"@Override public void restoreState(Object[] state){
  currentEventChunk=(ComplexEventChunk<StreamEvent>)state[0];
  expiredEventChunk=(ComplexEventChunk<StreamEvent>)state[1];
}","@Override public void restoreState(Object[] state){
  currentEventChunk.clear();
  currentEventChunk.add((StreamEvent)state[0]);
  expiredEventChunk.clear();
  expiredEventChunk.add((StreamEvent)state[1]);
}",0.5989583333333334
29120,"@Override public Object[] currentState(){
  return new Object[]{currentEventChunk,expiredEventChunk};
}","@Override public Object[] currentState(){
  return new Object[]{currentEventChunk.getFirst(),expiredEventChunk.getFirst()};
}",0.9035087719298246
29121,"@Override public void restoreState(Object[] state){
  currentEventChunk=(ComplexEventChunk<StreamEvent>)state[0];
  expiredEventChunk=(ComplexEventChunk<StreamEvent>)state[1];
  count=(Integer)state[2];
}","@Override public void restoreState(Object[] state){
  currentEventChunk.clear();
  currentEventChunk.add((StreamEvent)state[0]);
  expiredEventChunk.clear();
  expiredEventChunk.add((StreamEvent)state[1]);
  count=(Integer)state[2];
}",0.5616438356164384
29122,"@Override public Object[] currentState(){
  return new Object[]{currentEventChunk,expiredEventChunk,count};
}","@Override public Object[] currentState(){
  return new Object[]{currentEventChunk.getFirst(),expiredEventChunk.getFirst(),count};
}",0.9083333333333332
29123,"@Override public void restoreState(Object[] state){
  expiredEventChunk=(ComplexEventChunk<StreamEvent>)state[0];
  count=(Integer)state[1];
}","@Override public void restoreState(Object[] state){
  expiredEventChunk.clear();
  expiredEventChunk.add((StreamEvent)state[0]);
  count=(Integer)state[1];
}",0.8963210702341137
29124,"@Override public Object[] currentState(){
  return new Object[]{expiredEventChunk,count};
}","@Override public Object[] currentState(){
  return new Object[]{expiredEventChunk.getFirst(),count};
}",0.9430051813471504
29125,"@Override public void restoreState(Object[] state){
  expiredEventChunk=(ComplexEventChunk<StreamEvent>)state[0];
}","@Override public void restoreState(Object[] state){
  expiredEventChunk.clear();
  expiredEventChunk.add((StreamEvent)state[0]);
}",0.8734693877551021
29126,"@Override public Object[] currentState(){
  return new Object[]{expiredEventChunk};
}","@Override public Object[] currentState(){
  return new Object[]{expiredEventChunk.getFirst()};
}",0.9392265193370166
29127,"@Override public void restoreState(Object[] state){
  expiredEventChunk=(ComplexEventChunk<StreamEvent>)state[0];
}","@Override public void restoreState(Object[] state){
  expiredEventChunk.clear();
  expiredEventChunk.add((StreamEvent)state[0]);
}",0.8734693877551021
29128,"@Override public Object[] currentState(){
  return new Object[]{expiredEventChunk};
}","@Override public Object[] currentState(){
  return new Object[]{expiredEventChunk.getFirst()};
}",0.9392265193370166
29129,"protected ComplexEvent createSendEvent(ComplexEvent originalEvent,Map<Integer,Object> aggregateAttributeValueMap){
  ComplexEvent copiedEvent=null;
  if (originalEvent instanceof StreamEvent) {
    copiedEvent=streamEventCloner.copyStreamEvent((StreamEvent)originalEvent);
  }
 else   if (originalEvent instanceof StateEvent) {
    copiedEvent=stateEventCloner.copyStateEvent((StateEvent)originalEvent);
  }
  for (  Integer position : aggregateAttributePositionList) {
    copiedEvent.getOutputData()[position]=aggregateAttributeValueMap.get(position);
  }
  return copiedEvent;
}","protected ComplexEvent createSendEvent(ComplexEvent originalEvent,Map<Integer,Object> aggregateAttributeValueMap){
  ComplexEvent copiedEvent=cloneComplexEvent(originalEvent);
  for (  Integer position : aggregateAttributePositionList) {
    copiedEvent.getOutputData()[position]=aggregateAttributeValueMap.get(position);
  }
  return copiedEvent;
}",0.6817204301075269
29130,"@Override public void add(ComplexEvent complexEvent){
  try {
    lock.lock();
    if (complexEvent.getType() == ComplexEvent.Type.CURRENT) {
      String groupByKey=QuerySelector.getThreadLocalGroupByKey();
      if (tempGroupByKeyEvents.containsKey(groupByKey)) {
        tempGroupByKeyEvents.get(groupByKey).add(complexEvent);
      }
 else {
        List<ComplexEvent> newEventChunk=new ArrayList<ComplexEvent>();
        newEventChunk.add(complexEvent);
        tempGroupByKeyEvents.put(groupByKey,newEventChunk);
      }
    }
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Stores the given complex event to send upon notification of the scheduler. If there is already an event with same group by key it will be replaced leaving most recent event per group by key.
 * @param complexEvent {@link org.wso2.siddhi.core.event.ComplexEvent} to be added.
 */
@Override public void add(ComplexEvent complexEvent){
  try {
    lock.lock();
    if (complexEvent.getType() == ComplexEvent.Type.CURRENT) {
      String groupByKey=QuerySelector.getThreadLocalGroupByKey();
      groupByKeyEvents.put(groupByKey,complexEvent);
    }
  }
  finally {
    lock.unlock();
  }
}",0.3941730934018851
29131,"@Override public void process(ComplexEventChunk complexEventChunk){
  ComplexEvent firstEvent=complexEventChunk.getFirst();
  try {
    lock.lock();
    if (firstEvent != null && firstEvent.getType() == ComplexEvent.Type.TIMER) {
      if (firstEvent.getTimestamp() >= scheduledTime) {
        sendEvents();
        scheduledTime=scheduledTime + value;
        scheduler.notifyAt(scheduledTime);
      }
    }
 else {
      for (      String key : tempGroupByKeyEvents.keySet()) {
        groupByKeyEvents.put(key,tempGroupByKeyEvents.get(key));
      }
      tempGroupByKeyEvents.clear();
    }
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Sends the collected unique outputs per group by key upon arrival of timer event from scheduler.
 * @param complexEventChunk Incoming {@link org.wso2.siddhi.core.event.ComplexEventChunk}
 */
@Override public void process(ComplexEventChunk complexEventChunk){
  ComplexEvent firstEvent=complexEventChunk.getFirst();
  try {
    lock.lock();
    if (firstEvent != null && firstEvent.getType() == ComplexEvent.Type.TIMER) {
      if (firstEvent.getTimestamp() >= scheduledTime) {
        sendEvents();
        scheduledTime=scheduledTime + value;
        scheduler.notifyAt(scheduledTime);
      }
    }
  }
  finally {
    lock.unlock();
  }
}",0.6635514018691588
29132,"@Override public void restoreState(Object[] state){
  tempGroupByKeyEvents=(Map<String,List<ComplexEvent>>)state[0];
  groupByKeyEvents=(Map<String,List<ComplexEvent>>)state[1];
}","@Override public void restoreState(Object[] state){
  groupByKeyEvents=(Map<String,ComplexEvent>)state[0];
}",0.7456445993031359
29133,"public synchronized void sendEvents(){
  ComplexEvent firstEvent=null;
  ComplexEvent lastEvent=null;
  for (  List<ComplexEvent> complexEventList : groupByKeyEvents.values()) {
    for (    ComplexEvent complexEvent : complexEventList) {
      if (firstEvent == null) {
        firstEvent=complexEvent;
      }
 else {
        lastEvent.setNext(complexEvent);
      }
      lastEvent=complexEvent;
    }
  }
  ComplexEventChunk<ComplexEvent> complexEventChunk=new ComplexEventChunk<ComplexEvent>();
  if (firstEvent != null) {
    complexEventChunk.add(firstEvent);
  }
  sendToCallBacks(complexEventChunk);
}","public synchronized void sendEvents(){
  ComplexEventChunk<ComplexEvent> complexEventChunk=new ComplexEventChunk<ComplexEvent>();
  for (  ComplexEvent complexEvent : groupByKeyEvents.values()) {
    complexEventChunk.add(cloneComplexEvent(complexEvent));
  }
  sendToCallBacks(complexEventChunk);
}",0.2288228822882288
29134,"@Override public Object[] currentState(){
  return new Object[]{tempGroupByKeyEvents,groupByKeyEvents};
}","@Override public Object[] currentState(){
  return new Object[]{groupByKeyEvents};
}",0.8888888888888888
29135,"@Override public void add(ComplexEvent complexEvent){
  try {
    lock.lock();
    if (endOfChunk) {
      eventChunk.clear();
      endOfChunk=false;
    }
    if (complexEvent.getType() == ComplexEvent.Type.CURRENT) {
      eventChunk.add(complexEvent);
    }
  }
  finally {
    lock.unlock();
  }
}","@Override public void add(ComplexEvent complexEvent){
  try {
    lock.lock();
    if (complexEvent.getType() == ComplexEvent.Type.CURRENT) {
      lastEvent=complexEvent;
    }
  }
  finally {
    lock.unlock();
  }
}",0.5961538461538461
29136,"@Override public void process(ComplexEventChunk complexEventChunk){
  ComplexEvent firstEvent=complexEventChunk.getFirst();
  try {
    lock.lock();
    if (firstEvent != null && firstEvent.getType() == ComplexEvent.Type.TIMER) {
      if (firstEvent.getTimestamp() >= scheduledTime) {
        sendEvents();
        scheduledTime=scheduledTime + value;
        scheduler.notifyAt(scheduledTime);
      }
    }
 else {
      endOfChunk=true;
    }
  }
  finally {
    lock.unlock();
  }
}","@Override public void process(ComplexEventChunk complexEventChunk){
  ComplexEvent firstEvent=complexEventChunk.getFirst();
  try {
    lock.lock();
    if (firstEvent != null && firstEvent.getType() == ComplexEvent.Type.TIMER) {
      if (firstEvent.getTimestamp() >= scheduledTime) {
        sendEvents();
        scheduledTime=scheduledTime + value;
        scheduler.notifyAt(scheduledTime);
      }
    }
  }
  finally {
    lock.unlock();
  }
}",0.9028815368196372
29137,"@Override public void restoreState(Object[] state){
  eventChunk=(ComplexEventChunk<ComplexEvent>)state[0];
  endOfChunk=(Boolean)state[1];
}","@Override public void restoreState(Object[] state){
  eventChunk=(ComplexEventChunk<ComplexEvent>)state[0];
}",0.872
29138,"public synchronized void sendEvents(){
  eventChunk.reset();
  sendToCallBacks(eventChunk);
}","public synchronized void sendEvents(){
  if (lastEvent != null) {
    ComplexEventChunk<ComplexEvent> snapshotChunk=new ComplexEventChunk<ComplexEvent>();
    snapshotChunk.add(cloneComplexEvent(lastEvent));
    sendToCallBacks(snapshotChunk);
  }
}",0.4619883040935672
29139,"@Override public Object[] currentState(){
  return new Object[]{eventChunk,endOfChunk};
}","@Override public Object[] currentState(){
  return new Object[]{eventChunk};
}",0.934131736526946
29140,"public void setStreamEventCloner(StreamEventCloner streamEventCloner){
  this.streamEventCloner=streamEventCloner;
}","public void setStreamEventCloner(StreamEventCloner streamEventCloner){
  this.streamEventCloner=streamEventCloner;
  this.receiveStreamEvent=true;
}",0.8787878787878788
29141,"public void setStateEventCloner(StateEventCloner stateEventCloner){
  this.stateEventCloner=stateEventCloner;
}","public void setStateEventCloner(StateEventCloner stateEventCloner){
  this.stateEventCloner=stateEventCloner;
  this.receiveStreamEvent=false;
}",0.8705882352941177
29142,"@Override protected void init(ExpressionExecutor[] attributeExpressionExecutors,ExecutionPlanContext executionPlanContext){
  if (attributeExpressionExecutors[0].getReturnType() != Attribute.Type.LONG && attributeExpressionExecutors.length == 3) {
    useDefaultDateFormat=true;
    dateFormat=TimeExtensionConstants.EXTENSION_TIME_DEFAULT_DATE_FORMAT;
  }
  if (attributeExpressionExecutors.length == 4) {
    if (attributeExpressionExecutors[0].getReturnType() != Attribute.Type.STRING) {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[0].getReturnType().toString());
    }
    if (attributeExpressionExecutors[1].getReturnType() != Attribute.Type.LONG) {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.LONG + ""String_Node_Str""+ attributeExpressionExecutors[1].getReturnType().toString());
    }
    if (attributeExpressionExecutors[2].getReturnType() != Attribute.Type.STRING) {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[2].getReturnType().toString());
    }
    if (attributeExpressionExecutors[3].getReturnType() != Attribute.Type.STRING) {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[3].getReturnType().toString());
    }
  }
 else   if (attributeExpressionExecutors.length == 3) {
    if (useDefaultDateFormat) {
      if (attributeExpressionExecutors[0].getReturnType() != Attribute.Type.STRING) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[0].getReturnType().toString());
      }
      if (attributeExpressionExecutors[1].getReturnType() != Attribute.Type.LONG) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.LONG + ""String_Node_Str""+ attributeExpressionExecutors[1].getReturnType().toString());
      }
      if (attributeExpressionExecutors[2].getReturnType() != Attribute.Type.STRING) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[2].getReturnType().toString());
      }
    }
 else {
      if (attributeExpressionExecutors[0].getReturnType() != Attribute.Type.LONG) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.LONG + ""String_Node_Str""+ attributeExpressionExecutors[0].getReturnType().toString());
      }
      if (attributeExpressionExecutors[1].getReturnType() != Attribute.Type.LONG) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.LONG + ""String_Node_Str""+ attributeExpressionExecutors[1].getReturnType().toString());
      }
      if (attributeExpressionExecutors[2].getReturnType() != Attribute.Type.STRING) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[2].getReturnType().toString());
      }
    }
  }
 else {
    throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + attributeExpressionExecutors.length);
  }
}","@Override protected void init(ExpressionExecutor[] attributeExpressionExecutors,ExecutionPlanContext executionPlanContext){
  if (attributeExpressionExecutors[0].getReturnType() != Attribute.Type.LONG && attributeExpressionExecutors.length == 3) {
    useDefaultDateFormat=true;
    dateFormat=TimeExtensionConstants.EXTENSION_TIME_DEFAULT_DATE_FORMAT;
  }
  if (attributeExpressionExecutors.length == 4) {
    if (attributeExpressionExecutors[0].getReturnType() != Attribute.Type.STRING) {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[0].getReturnType().toString());
    }
    if (attributeExpressionExecutors[1].getReturnType() != Attribute.Type.INT) {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.INT + ""String_Node_Str""+ attributeExpressionExecutors[1].getReturnType().toString());
    }
    if (attributeExpressionExecutors[2].getReturnType() != Attribute.Type.STRING) {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[2].getReturnType().toString());
    }
    if (attributeExpressionExecutors[3].getReturnType() != Attribute.Type.STRING) {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[3].getReturnType().toString());
    }
  }
 else   if (attributeExpressionExecutors.length == 3) {
    if (useDefaultDateFormat) {
      if (attributeExpressionExecutors[0].getReturnType() != Attribute.Type.STRING) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[0].getReturnType().toString());
      }
      if (attributeExpressionExecutors[1].getReturnType() != Attribute.Type.INT) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.INT + ""String_Node_Str""+ attributeExpressionExecutors[1].getReturnType().toString());
      }
      if (attributeExpressionExecutors[2].getReturnType() != Attribute.Type.STRING) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[2].getReturnType().toString());
      }
    }
 else {
      if (attributeExpressionExecutors[0].getReturnType() != Attribute.Type.LONG) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.LONG + ""String_Node_Str""+ attributeExpressionExecutors[0].getReturnType().toString());
      }
      if (attributeExpressionExecutors[1].getReturnType() != Attribute.Type.INT) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.INT + ""String_Node_Str""+ attributeExpressionExecutors[1].getReturnType().toString());
      }
      if (attributeExpressionExecutors[2].getReturnType() != Attribute.Type.STRING) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[2].getReturnType().toString());
      }
    }
  }
 else {
    throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + attributeExpressionExecutors.length);
  }
}",0.994336569579288
29143,"@Override protected void init(ExpressionExecutor[] attributeExpressionExecutors,ExecutionPlanContext executionPlanContext){
  if (attributeExpressionExecutors[0].getReturnType() != Attribute.Type.LONG && attributeExpressionExecutors.length == 3) {
    useDefaultDateFormat=true;
    dateFormat=TimeExtensionConstants.EXTENSION_TIME_DEFAULT_DATE_FORMAT;
  }
  if (attributeExpressionExecutors.length == 4) {
    if (attributeExpressionExecutors[0].getReturnType() != Attribute.Type.STRING) {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[0].getReturnType().toString());
    }
    if (attributeExpressionExecutors[1].getReturnType() != Attribute.Type.LONG) {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.LONG + ""String_Node_Str""+ attributeExpressionExecutors[1].getReturnType().toString());
    }
    if (attributeExpressionExecutors[2].getReturnType() != Attribute.Type.STRING) {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[2].getReturnType().toString());
    }
    if (attributeExpressionExecutors[3].getReturnType() != Attribute.Type.STRING) {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[3].getReturnType().toString());
    }
  }
 else   if (attributeExpressionExecutors.length == 3) {
    if (useDefaultDateFormat) {
      if (attributeExpressionExecutors[0].getReturnType() != Attribute.Type.STRING) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[0].getReturnType().toString());
      }
      if (attributeExpressionExecutors[1].getReturnType() != Attribute.Type.LONG) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.LONG + ""String_Node_Str""+ attributeExpressionExecutors[1].getReturnType().toString());
      }
      if (attributeExpressionExecutors[2].getReturnType() != Attribute.Type.STRING) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[2].getReturnType().toString());
      }
    }
 else {
      if (attributeExpressionExecutors[0].getReturnType() != Attribute.Type.LONG) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.LONG + ""String_Node_Str""+ attributeExpressionExecutors[0].getReturnType().toString());
      }
      if (attributeExpressionExecutors[1].getReturnType() != Attribute.Type.LONG) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.LONG + ""String_Node_Str""+ attributeExpressionExecutors[1].getReturnType().toString());
      }
      if (attributeExpressionExecutors[2].getReturnType() != Attribute.Type.STRING) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[2].getReturnType().toString());
      }
    }
  }
 else {
    throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + attributeExpressionExecutors.length);
  }
}","@Override protected void init(ExpressionExecutor[] attributeExpressionExecutors,ExecutionPlanContext executionPlanContext){
  if (attributeExpressionExecutors[0].getReturnType() != Attribute.Type.LONG && attributeExpressionExecutors.length == 3) {
    useDefaultDateFormat=true;
    dateFormat=TimeExtensionConstants.EXTENSION_TIME_DEFAULT_DATE_FORMAT;
  }
  if (attributeExpressionExecutors.length == 4) {
    if (attributeExpressionExecutors[0].getReturnType() != Attribute.Type.STRING) {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[0].getReturnType().toString());
    }
    if (attributeExpressionExecutors[1].getReturnType() != Attribute.Type.INT) {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.INT + ""String_Node_Str""+ attributeExpressionExecutors[1].getReturnType().toString());
    }
    if (attributeExpressionExecutors[2].getReturnType() != Attribute.Type.STRING) {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[2].getReturnType().toString());
    }
    if (attributeExpressionExecutors[3].getReturnType() != Attribute.Type.STRING) {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[3].getReturnType().toString());
    }
  }
 else   if (attributeExpressionExecutors.length == 3) {
    if (useDefaultDateFormat) {
      if (attributeExpressionExecutors[0].getReturnType() != Attribute.Type.STRING) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[0].getReturnType().toString());
      }
      if (attributeExpressionExecutors[1].getReturnType() != Attribute.Type.INT) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.INT + ""String_Node_Str""+ attributeExpressionExecutors[1].getReturnType().toString());
      }
      if (attributeExpressionExecutors[2].getReturnType() != Attribute.Type.STRING) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[2].getReturnType().toString());
      }
    }
 else {
      if (attributeExpressionExecutors[0].getReturnType() != Attribute.Type.LONG) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.LONG + ""String_Node_Str""+ attributeExpressionExecutors[0].getReturnType().toString());
      }
      if (attributeExpressionExecutors[1].getReturnType() != Attribute.Type.INT) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.INT + ""String_Node_Str""+ attributeExpressionExecutors[1].getReturnType().toString());
      }
      if (attributeExpressionExecutors[2].getReturnType() != Attribute.Type.STRING) {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Attribute.Type.STRING + ""String_Node_Str""+ attributeExpressionExecutors[2].getReturnType().toString());
      }
    }
  }
 else {
    throw new ExecutionPlanValidationException(""String_Node_Str"" + ""String_Node_Str"" + attributeExpressionExecutors.length);
  }
}",0.994336569579288
29144,"/** 
 * Predict the value using the feature values
 * @param data  feature values array
 * @return      predicted value
 * @throws MLModelBuilderException
 */
public double predict(double[] data) throws MLModelBuilderException {
  Predictor predictor=new Predictor(modelId,mlModel,Arrays.asList(data));
  List<?> predictions=predictor.predict();
  return (Double)predictions.get(0);
}","/** 
 * Predict the value using the feature values
 * @param data  feature values array
 * @return      predicted value
 * @throws MLModelBuilderException
 */
public String predict(String[] data) throws MLModelHandlerException {
  ArrayList<String[]> list=new ArrayList<String[]>();
  list.add(data);
  Predictor predictor=new Predictor(modelId,mlModel,list);
  List<?> predictions=predictor.predict();
  return predictions.get(0).toString();
}",0.7995169082125604
29145,"/** 
 * Retrieve the MLModel from the storage location
 * @param modelStorageLocation model storage location (file path or registry path)file: -> file path registry: -> registry path
 * @return
 * @throws URISyntaxException
 * @throws MLInputAdapterException
 * @throws IOException
 * @throws ClassNotFoundException
 */
private static MLModel retrieveModel(String modelStorageLocation) throws URISyntaxException, MLInputAdapterException, IOException, ClassNotFoundException {
  String[] modelStorage=modelStorageLocation.trim().split(""String_Node_Str"");
  String storageType=modelStorage[0];
  if (storageType.equals(REGISTRY_STORAGE_PREFIX)) {
    if (modelStorage[1].startsWith(PATH_TO_GOVERNANCE_REGISTRY)) {
      modelStorageLocation=modelStorage[1].substring(PATH_TO_GOVERNANCE_REGISTRY.length());
    }
 else {
      modelStorageLocation=modelStorage[1];
    }
  }
  MLIOFactory ioFactory=new MLIOFactory(MLCoreServiceValueHolder.getInstance().getMlProperties());
  MLInputAdapter inputAdapter=ioFactory.getInputAdapter(storageType + MLConstants.IN_SUFFIX);
  InputStream in=inputAdapter.readDataset(new URI(modelStorageLocation));
  ObjectInputStream ois=new ObjectInputStream(in);
  MLModel mlModel=(MLModel)ois.readObject();
  ois.close();
  return mlModel;
}","/** 
 * Retrieve the MLModel from the storage location
 * @param modelStorageLocation model storage location (file path or registry path)file: -> file path registry: -> registry path
 * @return
 * @throws URISyntaxException
 * @throws MLInputAdapterException
 * @throws IOException
 * @throws ClassNotFoundException
 */
private static MLModel retrieveModel(String modelStorageLocation) throws URISyntaxException, MLInputAdapterException, IOException, ClassNotFoundException {
  String[] modelStorage=modelStorageLocation.trim().split(""String_Node_Str"");
  String storageType=modelStorage[0];
  if (storageType.equals(REGISTRY_STORAGE_PREFIX)) {
    if (modelStorage[1].startsWith(PATH_TO_GOVERNANCE_REGISTRY)) {
      modelStorageLocation=modelStorage[1].substring(PATH_TO_GOVERNANCE_REGISTRY.length());
    }
 else {
      modelStorageLocation=modelStorage[1];
    }
  }
 else {
    storageType=MLConstants.DATASET_SOURCE_TYPE_FILE;
  }
  MLIOFactory ioFactory=new MLIOFactory(MLCoreServiceValueHolder.getInstance().getMlProperties());
  MLInputAdapter inputAdapter=ioFactory.getInputAdapter(storageType + MLConstants.IN_SUFFIX);
  InputStream in=inputAdapter.read(modelStorageLocation);
  ObjectInputStream ois=new ObjectInputStream(in);
  MLModel mlModel=(MLModel)ois.readObject();
  ois.close();
  return mlModel;
}",0.9520865533230294
29146,"@Override protected List<Attribute> init(AbstractDefinition inputDefinition,ExpressionExecutor[] attributeExpressionExecutors,ExecutionPlanContext executionPlanContext){
  if (attributeExpressionExecutors.length == 0) {
    throw new ExecutionPlanValidationException(""String_Node_Str"");
  }
 else   if (attributeExpressionExecutors.length == 1) {
    attributeSelectionAvailable=false;
  }
 else {
    attributeSelectionAvailable=true;
  }
  if (attributeExpressionExecutors[0] instanceof ConstantExpressionExecutor) {
    Object constantObj=((ConstantExpressionExecutor)attributeExpressionExecutors[0]).getValue();
    modelStorageLocation=(String)constantObj;
  }
 else {
    throw new ExecutionPlanValidationException(""String_Node_Str"");
  }
  return Arrays.asList(new Attribute(PREDICTION,Attribute.Type.DOUBLE));
}","@Override protected List<Attribute> init(AbstractDefinition inputDefinition,ExpressionExecutor[] attributeExpressionExecutors,ExecutionPlanContext executionPlanContext){
  if (attributeExpressionExecutors.length == 0) {
    throw new ExecutionPlanValidationException(""String_Node_Str"");
  }
 else   if (attributeExpressionExecutors.length == 1) {
    attributeSelectionAvailable=false;
  }
 else {
    attributeSelectionAvailable=true;
    selectedAttributesSize=attributeExpressionExecutors.length - 1;
  }
  if (attributeExpressionExecutors[0] instanceof ConstantExpressionExecutor) {
    Object constantObj=((ConstantExpressionExecutor)attributeExpressionExecutors[0]).getValue();
    modelStorageLocation=(String)constantObj;
  }
 else {
    throw new ExecutionPlanValidationException(""String_Node_Str"");
  }
  return Arrays.asList(new Attribute(PREDICTION,Attribute.Type.DOUBLE));
}",0.9601406799531068
29147,"@Override protected void process(ComplexEventChunk<StreamEvent> streamEventChunk,Processor nextProcessor,StreamEventCloner streamEventCloner,ComplexEventPopulater complexEventPopulater){
  StreamEvent event=streamEventChunk.getFirst();
  Object[] data;
  double[] featureValues;
  if (attributeSelectionAvailable) {
    data=event.getBeforeWindowData();
    featureValues=new double[data.length];
  }
 else {
    data=event.getOutputData();
    featureValues=new double[data.length - 1];
  }
  for (  Map.Entry<Integer,Integer> entry : attributeIndexMap.entrySet()) {
    int featureIndex=entry.getKey();
    int attributeIndex=entry.getValue();
    featureValues[featureIndex]=Double.parseDouble(String.valueOf(data[attributeIndex]));
  }
  if (featureValues != null) {
    try {
      double predictionResult=modelHandler.predict(featureValues);
      Object[] output=new Object[]{predictionResult};
      complexEventPopulater.populateComplexEvent(event,output);
      nextProcessor.process(streamEventChunk);
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"",e);
      throw new ExecutionPlanRuntimeException(""String_Node_Str"",e);
    }
  }
}","@Override protected void process(ComplexEventChunk<StreamEvent> streamEventChunk,Processor nextProcessor,StreamEventCloner streamEventCloner,ComplexEventPopulater complexEventPopulater){
  while (streamEventChunk.hasNext()) {
    StreamEvent event=streamEventChunk.next();
    Object[] data;
    String[] featureValues;
    data=event.getOutputData();
    if (attributeSelectionAvailable) {
      featureValues=new String[selectedAttributesSize];
    }
 else {
      featureValues=new String[data.length - 1];
    }
    for (    Map.Entry<Integer,Integer> entry : attributeIndexMap.entrySet()) {
      int featureIndex=entry.getKey();
      int attributeIndex=entry.getValue();
      featureValues[featureIndex]=String.valueOf(data[attributeIndex]);
    }
    if (featureValues != null) {
      try {
        String predictionResult=modelHandler.predict(featureValues);
        Object[] output=new Object[]{predictionResult};
        complexEventPopulater.populateComplexEvent(event,output);
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"",e);
        throw new ExecutionPlanRuntimeException(""String_Node_Str"",e);
      }
    }
  }
  nextProcessor.process(streamEventChunk);
}",0.6802030456852792
29148,"/** 
 * Match the attribute index values of stream with feature index value of the model
 * @throws Exception
 */
private void populateFeatureAttributeMapping() throws Exception {
  attributeIndexMap=new HashMap<Integer,Integer>();
  Map<String,Integer> featureIndexMap=modelHandler.getFeatures();
  if (attributeSelectionAvailable) {
    int index=0;
    for (    ExpressionExecutor expressionExecutor : attributeExpressionExecutors) {
      if (expressionExecutor instanceof VariableExpressionExecutor) {
        VariableExpressionExecutor variable=(VariableExpressionExecutor)expressionExecutor;
        String variableName=variable.getAttribute().getName();
        if (featureIndexMap.get(variableName) != null) {
          int featureIndex=featureIndexMap.get(variableName);
          int attributeIndex=index;
          attributeIndexMap.put(featureIndex,attributeIndex);
        }
 else {
          throw new ExecutionPlanCreationException(""String_Node_Str"" + ""String_Node_Str"" + variableName);
        }
        index++;
      }
    }
  }
 else {
    String[] attributeNames=inputDefinition.getAttributeNameArray();
    for (    String attributeName : attributeNames) {
      if (featureIndexMap.get(attributeName) != null) {
        int featureIndex=featureIndexMap.get(attributeName);
        int attributeIndex=inputDefinition.getAttributePosition(attributeName);
        attributeIndexMap.put(featureIndex,attributeIndex);
      }
 else {
        throw new ExecutionPlanCreationException(""String_Node_Str"" + ""String_Node_Str"" + attributeName);
      }
    }
  }
}","/** 
 * Match the attribute index values of stream with feature index value of the model
 * @throws Exception
 */
private void populateFeatureAttributeMapping() throws Exception {
  attributeIndexMap=new HashMap<Integer,Integer>();
  Map<String,Integer> featureIndexMap=modelHandler.getFeatures();
  List<Integer> newToOldIndicesList=modelHandler.getNewToOldIndicesList();
  if (attributeSelectionAvailable) {
    for (    ExpressionExecutor expressionExecutor : attributeExpressionExecutors) {
      if (expressionExecutor instanceof VariableExpressionExecutor) {
        VariableExpressionExecutor variable=(VariableExpressionExecutor)expressionExecutor;
        String variableName=variable.getAttribute().getName();
        if (featureIndexMap.get(variableName) != null) {
          int featureIndex=featureIndexMap.get(variableName);
          int newFeatureIndex=newToOldIndicesList.indexOf(featureIndex);
          int attributeIndex=inputDefinition.getAttributePosition(variableName);
          attributeIndexMap.put(newFeatureIndex,attributeIndex);
        }
 else {
          throw new ExecutionPlanCreationException(""String_Node_Str"" + ""String_Node_Str"" + variableName);
        }
      }
    }
  }
 else {
    String[] attributeNames=inputDefinition.getAttributeNameArray();
    for (    String attributeName : attributeNames) {
      if (featureIndexMap.get(attributeName) != null) {
        int featureIndex=featureIndexMap.get(attributeName);
        int newFeatureIndex=newToOldIndicesList.indexOf(featureIndex);
        int attributeIndex=inputDefinition.getAttributePosition(attributeName);
        attributeIndexMap.put(newFeatureIndex,attributeIndex);
      }
 else {
        throw new ExecutionPlanCreationException(""String_Node_Str"" + ""String_Node_Str"" + attributeName);
      }
    }
  }
}",0.8966942148760331
29149,"@Override public void receive(long timeStamp,Event[] inEvents,Event[] removeEvents){
  EventPrinter.print(timeStamp,inEvents,removeEvents);
  eventArrived=true;
  if (inEvents != null) {
    Assert.assertEquals(0.9176214029655854,inEvents[0].getData(0));
  }
}","@Override public void receive(long timeStamp,Event[] inEvents,Event[] removeEvents){
  EventPrinter.print(timeStamp,inEvents,removeEvents);
  eventArrived=true;
  if (inEvents != null) {
    Assert.assertEquals(""String_Node_Str"",inEvents[0].getData(8));
  }
}",0.928709055876686
29150,"@Test public void predictFunctionWithSelectedAttributesTest() throws InterruptedException, URISyntaxException {
  URL resource=PredictStreamProcessorTestCase.class.getResource(""String_Node_Str"");
  String modelStorageLocation=new File(resource.toURI()).getAbsolutePath();
  SiddhiManager siddhiManager=new SiddhiManager();
  String inputStream=""String_Node_Str"" + ""String_Node_Str"";
  String query=""String_Node_Str"" + ""String_Node_Str"" + modelStorageLocation + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(inputStream + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      eventArrived=true;
      if (inEvents != null) {
        Assert.assertEquals(0.9176214029655854,inEvents[0].getData(0));
      }
    }
  }
);
  InputHandler inputHandler=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  inputHandler.send(new Object[]{6,148,72,35,0,33.6,0.627,50});
  Thread.sleep(1000);
  junit.framework.Assert.assertTrue(eventArrived);
  executionPlanRuntime.shutdown();
}","@Test public void predictFunctionWithSelectedAttributesTest() throws InterruptedException, URISyntaxException {
  URI resource=new URI(""String_Node_Str"" + System.getProperty(""String_Node_Str"") + ""String_Node_Str"");
  String modelStorageLocation=new File(resource).getAbsolutePath();
  SiddhiManager siddhiManager=new SiddhiManager();
  String inputStream=""String_Node_Str"" + ""String_Node_Str"";
  String query=""String_Node_Str"" + ""String_Node_Str"" + modelStorageLocation + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(inputStream + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      eventArrived=true;
      if (inEvents != null) {
        Assert.assertEquals(""String_Node_Str"",inEvents[0].getData(8));
      }
    }
  }
);
  InputHandler inputHandler=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  inputHandler.send(new Object[]{6,148,72,35,0,33.6,0.627,50});
  Thread.sleep(1000);
  junit.framework.Assert.assertTrue(eventArrived);
  executionPlanRuntime.shutdown();
}",0.8917050691244239
29151,"@Test public void predictFunctionTest() throws InterruptedException, URISyntaxException {
  URL resource=PredictStreamProcessorTestCase.class.getResource(""String_Node_Str"");
  String modelStorageLocation=new File(resource.toURI()).getAbsolutePath();
  SiddhiManager siddhiManager=new SiddhiManager();
  String inputStream=""String_Node_Str"" + ""String_Node_Str"";
  String query=""String_Node_Str"" + ""String_Node_Str"" + modelStorageLocation + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(inputStream + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      eventArrived=true;
      if (inEvents != null) {
        Assert.assertEquals(0.9176214029655854,inEvents[0].getData(8));
      }
    }
  }
);
  InputHandler inputHandler=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  inputHandler.send(new Object[]{6,148,72,35,0,33.6,0.627,50});
  Thread.sleep(1000);
  junit.framework.Assert.assertTrue(eventArrived);
  executionPlanRuntime.shutdown();
}","@Test public void predictFunctionTest() throws InterruptedException, URISyntaxException {
  URI resource=new URI(""String_Node_Str"" + System.getProperty(""String_Node_Str"") + ""String_Node_Str"");
  String modelStorageLocation=new File(resource).getAbsolutePath();
  SiddhiManager siddhiManager=new SiddhiManager();
  String inputStream=""String_Node_Str"" + ""String_Node_Str"";
  String query=""String_Node_Str"" + ""String_Node_Str"" + modelStorageLocation + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(inputStream + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      eventArrived=true;
      if (inEvents != null) {
        Assert.assertEquals(""String_Node_Str"",String.valueOf(inEvents[0].getData(8)));
      }
    }
  }
);
  InputHandler inputHandler=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  inputHandler.send(new Object[]{6,148,72,35,0,33.6,0.627,50});
  Thread.sleep(1000);
  junit.framework.Assert.assertTrue(eventArrived);
  executionPlanRuntime.shutdown();
  siddhiManager.shutdown();
}",0.8755760368663594
29152,"/** 
 * Populate xml values to Jaxb mapping classes
 */
private void populateJaxbMappings() throws CannotLoadConfigurationException {
  JAXBContext jaxbContext;
  dbTypeMappings=new HashMap<String,Map<String,String>>();
  try {
    jaxbContext=JAXBContext.newInstance(Mappings.class);
    Unmarshaller unmarshaller=jaxbContext.createUnmarshaller();
    ClassLoader classLoader=getClass().getClassLoader();
    File configFile=new File(classLoader.getResource(RDBMSEventTableConstants.RDBMS_TABLE_CONFIG_FILE).getFile());
    if (!configFile.exists()) {
      log.error(RDBMSEventTableConstants.RDBMS_TABLE_CONFIG_FILE + ""String_Node_Str"");
    }
    Mappings mappings=(Mappings)unmarshaller.unmarshal(configFile);
    Map<String,Mapping> dbMap=new HashMap<String,Mapping>();
    List<Mapping> mappingList=mappings.getMapping();
    for (    Mapping mapping : mappingList) {
      dbMap.put(mapping.getDb(),mapping);
    }
    for (    Mapping mapping : mappingList) {
      if (mapping.getDb() != null) {
        Mapping defaultMapping=dbMap.get(null);
        Mapping specificMapping=dbMap.get(mapping.getDb());
        List<Element> defaultElementList=defaultMapping.getElements().getElementList();
        Map<String,String> elementMappings=new HashMap<String,String>();
        for (        Element element : defaultElementList) {
          Element elementDetails=null;
          if (specificMapping.getElements().getElementList() != null) {
            elementDetails=specificMapping.getElements().getType(element.getKey());
          }
          if (elementDetails == null) {
            elementDetails=defaultMapping.getElements().getType(element.getKey());
          }
          elementMappings.put(elementDetails.getKey(),elementDetails.getValue());
        }
        dbTypeMappings.put(mapping.getDb(),elementMappings);
      }
    }
  }
 catch (  JAXBException e) {
    throw new CannotLoadConfigurationException(""String_Node_Str"" + RDBMSEventTableConstants.RDBMS_TABLE_CONFIG_FILE + e.getMessage(),e);
  }
}","/** 
 * Populate xml values to Jaxb mapping classes
 */
private void populateJaxbMappings() throws CannotLoadConfigurationException {
  JAXBContext jaxbContext;
  dbTypeMappings=new HashMap<String,Map<String,String>>();
  try {
    jaxbContext=JAXBContext.newInstance(Mappings.class);
    Unmarshaller unmarshaller=jaxbContext.createUnmarshaller();
    ClassLoader classLoader=getClass().getClassLoader();
    InputStream inputStream=classLoader.getResourceAsStream(RDBMSEventTableConstants.RDBMS_TABLE_CONFIG_FILE);
    if (inputStream == null) {
      throw new CannotLoadConfigurationException(RDBMSEventTableConstants.RDBMS_TABLE_CONFIG_FILE + ""String_Node_Str"");
    }
    Mappings mappings=(Mappings)unmarshaller.unmarshal(inputStream);
    Map<String,Mapping> dbMap=new HashMap<String,Mapping>();
    List<Mapping> mappingList=mappings.getMapping();
    for (    Mapping mapping : mappingList) {
      dbMap.put(mapping.getDb(),mapping);
    }
    for (    Mapping mapping : mappingList) {
      if (mapping.getDb() != null) {
        Mapping defaultMapping=dbMap.get(null);
        Mapping specificMapping=dbMap.get(mapping.getDb());
        List<Element> defaultElementList=defaultMapping.getElements().getElementList();
        Map<String,String> elementMappings=new HashMap<String,String>();
        for (        Element element : defaultElementList) {
          Element elementDetails=null;
          if (specificMapping.getElements().getElementList() != null) {
            elementDetails=specificMapping.getElements().getType(element.getKey());
          }
          if (elementDetails == null) {
            elementDetails=defaultMapping.getElements().getType(element.getKey());
          }
          elementMappings.put(elementDetails.getKey(),elementDetails.getValue());
        }
        dbTypeMappings.put(mapping.getDb(),elementMappings);
      }
    }
  }
 catch (  JAXBException e) {
    throw new CannotLoadConfigurationException(""String_Node_Str"" + RDBMSEventTableConstants.RDBMS_TABLE_CONFIG_FILE + e.getMessage(),e);
  }
}",0.9412343250553232
29153,"/** 
 * Helper method to load the siddhi extensions
 */
public static Map<String,Class> loadSiddhiExtensions(){
  String classPath=System.getProperty(CLASS_PATH,""String_Node_Str"");
  if (classPath == null) {
    classPath=""String_Node_Str"";
  }
 else {
    classPath+=""String_Node_Str"";
  }
  String[] classPathElements=classPath.split(""String_Node_Str"");
  Pattern pattern=Pattern.compile(SIDDHI_EXT);
  Collection<String> extensionsList=new ArrayList<String>();
  for (  String element : classPathElements) {
    extensionsList.addAll(getResources(element,pattern));
  }
  Map<String,Class> classMap=new HashMap<String,Class>();
  for (  String extension : extensionsList) {
    if (extension.matches(CLASS_EXT)) {
      String[] info=extension.split(""String_Node_Str"");
      try {
        classMap.put(info[0].trim(),Class.forName(info[1].trim()));
      }
 catch (      ClassNotFoundException e) {
        log.error(""String_Node_Str"" + info[1].trim(),e);
      }
    }
  }
  return classMap;
}","/** 
 * Helper method to load the siddhi extensions
 */
public static Map<String,Class> loadSiddhiExtensions(){
  String classPath=System.getProperty(CLASS_PATH);
  if (classPath == null) {
    classPath=""String_Node_Str"";
  }
 else {
    classPath+=""String_Node_Str"";
  }
  String[] classPathElements=classPath.split(""String_Node_Str"");
  Pattern pattern=Pattern.compile(SIDDHI_EXT);
  Collection<String> extensionsList=new ArrayList<String>();
  for (  String element : classPathElements) {
    extensionsList.addAll(getResources(element,pattern));
  }
  Map<String,Class> classMap=new HashMap<String,Class>();
  for (  String extension : extensionsList) {
    if (extension.matches(CLASS_EXT)) {
      String[] info=extension.split(""String_Node_Str"");
      try {
        classMap.put(info[0].trim(),Class.forName(info[1].trim()));
      }
 catch (      ClassNotFoundException e) {
        log.debug(""String_Node_Str"" + extension);
      }
    }
  }
  return classMap;
}",0.9731100963977676
29154,"/** 
 * Helper method to load the siddhi extensions
 */
public static Map<String,Class> loadSiddhiExtensions(){
  String classPath=System.getProperty(CLASS_PATH,""String_Node_Str"");
  String[] classPathElements=classPath.split(""String_Node_Str"");
  Pattern pattern=Pattern.compile(SIDDHI_EXT);
  Collection<String> extensionsList=new ArrayList<String>();
  for (  String element : classPathElements) {
    extensionsList.addAll(getResources(element,pattern));
  }
  Map<String,Class> classMap=new HashMap<String,Class>();
  for (  String extension : extensionsList) {
    if (extension.matches(CLASS_EXT)) {
      String[] info=extension.split(""String_Node_Str"");
      try {
        classMap.put(info[0].trim(),Class.forName(info[1].trim()));
      }
 catch (      ClassNotFoundException e) {
        log.error(""String_Node_Str"" + info[1].trim(),e);
      }
    }
  }
  return classMap;
}","/** 
 * Helper method to load the siddhi extensions
 */
public static Map<String,Class> loadSiddhiExtensions(){
  String classPath=System.getProperty(CLASS_PATH,""String_Node_Str"");
  if (classPath == null) {
    classPath=""String_Node_Str"";
  }
 else {
    classPath+=""String_Node_Str"";
  }
  String[] classPathElements=classPath.split(""String_Node_Str"");
  Pattern pattern=Pattern.compile(SIDDHI_EXT);
  Collection<String> extensionsList=new ArrayList<String>();
  for (  String element : classPathElements) {
    extensionsList.addAll(getResources(element,pattern));
  }
  Map<String,Class> classMap=new HashMap<String,Class>();
  for (  String extension : extensionsList) {
    if (extension.matches(CLASS_EXT)) {
      String[] info=extension.split(""String_Node_Str"");
      try {
        classMap.put(info[0].trim(),Class.forName(info[1].trim()));
      }
 catch (      ClassNotFoundException e) {
        log.error(""String_Node_Str"" + info[1].trim(),e);
      }
    }
  }
  return classMap;
}",0.9416755037115588
29155,"@Test public void dateDifferenceFunctionExtension() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String inStreamDefinition=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  String query=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(inStreamDefinition + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      eventArrived=true;
      for (int cnt=0; cnt < inEvents.length; cnt++) {
        count++;
        log.info(""String_Node_Str"" + count + ""String_Node_Str""+ inEvents[cnt].getData(1)+ ""String_Node_Str""+ ""String_Node_Str""+ inEvents[cnt].getData(2));
      }
    }
  }
);
  InputHandler inputHandler=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  inputHandler.send(new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1415692424000L,1415519624000L});
  inputHandler.send(new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1415692424000L,1412841224000L});
  inputHandler.send(new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1415692424000L,1384156424000L});
  Thread.sleep(100);
  Assert.assertEquals(3,count);
  Assert.assertTrue(eventArrived);
  executionPlanRuntime.shutdown();
}","@Test public void dateDifferenceFunctionExtension() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String inStreamDefinition=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  String query=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(inStreamDefinition + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      eventArrived=true;
      for (int cnt=0; cnt < inEvents.length; cnt++) {
        count++;
        log.info(""String_Node_Str"" + count + ""String_Node_Str""+ inEvents[cnt].getData(1)+ ""String_Node_Str""+ ""String_Node_Str""+ inEvents[cnt].getData(2));
      }
    }
  }
);
  InputHandler inputHandler=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  inputHandler.send(new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1415692424000L,1415519624000L});
  inputHandler.send(new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1415692424000L,1412841224000L});
  inputHandler.send(new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1415692424000L,1384156424000L});
  Thread.sleep(1000);
  Assert.assertEquals(3,count);
  Assert.assertTrue(eventArrived);
  executionPlanRuntime.shutdown();
}",0.9997049277072882
29156,"@Override public void receive(Event[] events){
  EventPrinter.print(events);
  for (  Event event : events) {
    if (event.isExpired()) {
      removeEventCount++;
      Assert.assertEquals(""String_Node_Str"",removeEventCount,event.getData(2));
      if (removeEventCount == 1) {
        Assert.assertEquals(""String_Node_Str"",length,inEventCount);
      }
    }
 else {
      inEventCount++;
      Assert.assertEquals(""String_Node_Str"",inEventCount,event.getData(2));
    }
  }
  Assert.assertEquals(""String_Node_Str"",inEventCount - length,removeEventCount);
  eventArrived=true;
}","@Override public void receive(Event[] events){
  EventPrinter.print(events);
  for (  Event event : events) {
    if (event.isExpired()) {
      removeEventCount++;
      Assert.assertEquals(""String_Node_Str"",removeEventCount,event.getData(2));
    }
 else {
      inEventCount++;
      Assert.fail(""String_Node_Str"");
    }
  }
  eventArrived=true;
}",0.6051502145922747
29157,"/** 
 * {@inheritDoc}<p/> <p>The default implementation returns the result of calling  {@link #visitChildren} on {@code ctx}.</p>
 * @param ctx
 */
@Override public OutputStream.OutputEventType visitOutput_event_type(@NotNull SiddhiQLParser.Output_event_typeContext ctx){
  if (ctx.ALL() != null) {
    if (ctx.RAW() != null) {
      return OutputStream.OutputEventType.ALL_RAW_EVENTS;
    }
 else {
      return OutputStream.OutputEventType.ALL_EVENTS;
    }
  }
 else   if (ctx.EXPIRED() != null) {
    if (ctx.RAW() != null) {
      return OutputStream.OutputEventType.EXPIRED_EVENTS;
    }
 else {
      return OutputStream.OutputEventType.EXPIRED_RAW_EVENTS;
    }
  }
 else {
    return OutputStream.OutputEventType.CURRENT_EVENTS;
  }
}","/** 
 * {@inheritDoc}<p/> <p>The default implementation returns the result of calling  {@link #visitChildren} on {@code ctx}.</p>
 * @param ctx
 */
@Override public OutputStream.OutputEventType visitOutput_event_type(@NotNull SiddhiQLParser.Output_event_typeContext ctx){
  if (ctx.ALL() != null) {
    if (ctx.RAW() != null) {
      return OutputStream.OutputEventType.ALL_RAW_EVENTS;
    }
 else {
      return OutputStream.OutputEventType.ALL_EVENTS;
    }
  }
 else   if (ctx.EXPIRED() != null) {
    if (ctx.RAW() != null) {
      return OutputStream.OutputEventType.EXPIRED_RAW_EVENTS;
    }
 else {
      return OutputStream.OutputEventType.EXPIRED_EVENTS;
    }
  }
 else {
    return OutputStream.OutputEventType.CURRENT_EVENTS;
  }
}",0.9946164199192464
29158,"private void send(long timeStamp,Event[] currentEvents,Event[] expiredEvents){
  receive(timeStamp,currentEvents,expiredEvents);
}","private void send(long timeStamp,Event[] currentEvents,Event[] expiredEvents){
  try {
    receive(timeStamp,currentEvents,expiredEvents);
  }
 catch (  RuntimeException e) {
    log.error(""String_Node_Str"" + Arrays.deepToString(currentEvents) + ""String_Node_Str""+ Arrays.deepToString(expiredEvents),e);
  }
}",0.592255125284738
29159,"@Override protected void init(ExpressionExecutor[] attributeExpressionExecutors,ExecutionPlanContext executionPlanContext){
  this.executionPlanContext=executionPlanContext;
  expiredEventChunk=new ComplexEventChunk<StreamEvent>();
  if (attributeExpressionExecutors != null) {
    timeInMilliSeconds=(Long)((ConstantExpressionExecutor)attributeExpressionExecutors[0]).getValue();
  }
}","@Override protected void init(ExpressionExecutor[] attributeExpressionExecutors,ExecutionPlanContext executionPlanContext){
  this.executionPlanContext=executionPlanContext;
  this.expiredEventChunk=new ComplexEventChunk<StreamEvent>();
  if (attributeExpressionExecutors.length == 1) {
    if (attributeExpressionExecutors[0] instanceof ConstantExpressionExecutor) {
      if (attributeExpressionExecutors[0].getReturnType() == Attribute.Type.INT) {
        timeInMilliSeconds=(Integer)((ConstantExpressionExecutor)attributeExpressionExecutors[0]).getValue();
      }
 else       if (attributeExpressionExecutors[0].getReturnType() == Attribute.Type.LONG) {
        timeInMilliSeconds=(Long)((ConstantExpressionExecutor)attributeExpressionExecutors[0]).getValue();
      }
 else {
        throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors[0].getReturnType());
      }
    }
 else {
      throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors[0].getClass().getCanonicalName());
    }
  }
 else {
    throw new ExecutionPlanValidationException(""String_Node_Str"" + attributeExpressionExecutors.length + ""String_Node_Str"");
  }
}",0.4082914572864322
29160,"@Override protected void process(ComplexEventChunk<StreamEvent> streamEventChunk,Processor nextProcessor,StreamEventCloner streamEventCloner){
  while (streamEventChunk.hasNext()) {
    StreamEvent streamEvent=streamEventChunk.next();
    long currentTime=executionPlanContext.getTimestampGenerator().currentTime();
    StreamEvent clonedEvent=null;
    if (streamEvent.getType() == StreamEvent.Type.CURRENT) {
      clonedEvent=streamEventCloner.copyStreamEvent(streamEvent);
      clonedEvent.setType(StreamEvent.Type.EXPIRED);
      clonedEvent.setTimestamp(currentTime + timeInMilliSeconds);
    }
    while (expiredEventChunk.hasNext()) {
      StreamEvent expiredEvent=expiredEventChunk.next();
      long timeDiff=expiredEvent.getTimestamp() - currentTime;
      if (timeDiff <= 0) {
        expiredEventChunk.remove();
        streamEventChunk.insertBeforeCurrent(expiredEvent);
      }
 else {
        scheduler.notifyAt(expiredEvent.getTimestamp());
        expiredEventChunk.reset();
        break;
      }
    }
    if (streamEvent.getType() == StreamEvent.Type.CURRENT) {
      this.expiredEventChunk.add(clonedEvent);
    }
    expiredEventChunk.reset();
  }
  nextProcessor.process(streamEventChunk);
}","@Override protected void process(ComplexEventChunk<StreamEvent> streamEventChunk,Processor nextProcessor,StreamEventCloner streamEventCloner){
  while (streamEventChunk.hasNext()) {
    StreamEvent streamEvent=streamEventChunk.next();
    long currentTime=executionPlanContext.getTimestampGenerator().currentTime();
    StreamEvent clonedEvent=null;
    if (streamEvent.getType() == StreamEvent.Type.CURRENT) {
      clonedEvent=streamEventCloner.copyStreamEvent(streamEvent);
      clonedEvent.setType(StreamEvent.Type.EXPIRED);
      clonedEvent.setTimestamp(currentTime + timeInMilliSeconds);
    }
    boolean eventScheduled=false;
    while (expiredEventChunk.hasNext()) {
      StreamEvent expiredEvent=expiredEventChunk.next();
      long timeDiff=expiredEvent.getTimestamp() - currentTime;
      if (timeDiff <= 0) {
        expiredEventChunk.remove();
        streamEventChunk.insertBeforeCurrent(expiredEvent);
      }
 else {
        scheduler.notifyAt(expiredEvent.getTimestamp());
        expiredEventChunk.reset();
        eventScheduled=true;
        break;
      }
    }
    if (streamEvent.getType() == StreamEvent.Type.CURRENT) {
      this.expiredEventChunk.add(clonedEvent);
      if (!eventScheduled) {
        scheduler.notifyAt(clonedEvent.getTimestamp());
      }
    }
    expiredEventChunk.reset();
  }
  nextProcessor.process(streamEventChunk);
}",0.9397683397683396
29161,"@Override public void process(ComplexEventChunk complexEventChunk){
  complexEventChunk.reset();
  if (log.isTraceEnabled()) {
    log.trace(""String_Node_Str"" + id + this);
  }
  while (complexEventChunk.hasNext()) {
    ComplexEvent event=complexEventChunk.next();
    eventPopulator.populateStateEvent(event);
    if (event.getType() == StreamEvent.Type.CURRENT || event.getType() == StreamEvent.Type.EXPIRED) {
      if (isGroupBy) {
        keyThreadLocal.set(groupByKeyGenerator.constructEventKey(event));
      }
      for (      AttributeProcessor attributeProcessor : attributeProcessorList) {
        attributeProcessor.process(event);
      }
      if (isGroupBy) {
        keyThreadLocal.remove();
      }
      if (havingConditionExecutor != null && !havingConditionExecutor.execute(event)) {
        complexEventChunk.remove();
      }
    }
 else {
      complexEventChunk.remove();
    }
  }
  if (complexEventChunk.getFirst() != null) {
    outputRateLimiter.process(complexEventChunk);
  }
}","@Override public void process(ComplexEventChunk complexEventChunk){
  complexEventChunk.reset();
  if (log.isTraceEnabled()) {
    log.trace(""String_Node_Str"" + id + this);
  }
  while (complexEventChunk.hasNext()) {
    ComplexEvent event=complexEventChunk.next();
    if (event.getType() == StreamEvent.Type.CURRENT || event.getType() == StreamEvent.Type.EXPIRED) {
      eventPopulator.populateStateEvent(event);
      if (isGroupBy) {
        keyThreadLocal.set(groupByKeyGenerator.constructEventKey(event));
      }
      for (      AttributeProcessor attributeProcessor : attributeProcessorList) {
        attributeProcessor.process(event);
      }
      if (isGroupBy) {
        keyThreadLocal.remove();
      }
      if (havingConditionExecutor != null && !havingConditionExecutor.execute(event)) {
        complexEventChunk.remove();
      }
    }
 else {
      complexEventChunk.remove();
    }
  }
  if (complexEventChunk.getFirst() != null) {
    outputRateLimiter.process(complexEventChunk);
  }
}",0.9534192269573836
29162,"@Before public void init(){
  inEventCount=0;
  removeEventCount=0;
  eventArrived=false;
}","@Before public void init(){
  inEventCount=0;
  removeEventCount=0;
  eventArrived=false;
  firstEvent=true;
}",0.9054726368159204
29163,"@Override public void receive(Event[] events){
  EventPrinter.print(events);
  for (  Event event : events) {
    if (event.isExpired()) {
      removeEventCount++;
      if (removeEventCount == 1) {
        Assert.assertEquals(100.0,event.getData()[1]);
      }
 else       if (removeEventCount == 2 || removeEventCount == 3) {
        Assert.assertEquals(0.0,event.getData()[1]);
      }
    }
 else {
      inEventCount++;
      if (inEventCount == 1) {
        Assert.assertEquals(70.0,event.getData()[1]);
      }
 else       if (inEventCount == 2) {
        Assert.assertEquals(700.0,event.getData()[1]);
      }
 else       if (inEventCount == 3) {
        Assert.assertEquals(170.0,event.getData()[1]);
      }
 else       if (inEventCount == 4) {
        Assert.assertEquals(200.0,event.getData()[1]);
      }
 else       if (inEventCount == 5) {
        Assert.assertEquals(1000.0,event.getData()[1]);
      }
    }
    eventArrived=true;
  }
}","@Override public void receive(Event[] events){
  EventPrinter.print(events);
  for (  Event event : events) {
    if (event.isExpired()) {
      removeEventCount++;
      if (""String_Node_Str"".equals(event.getData()[0]) && firstEvent) {
        firstEvent=false;
        Assert.assertEquals(100.0,event.getData()[1]);
      }
 else {
        Assert.assertEquals(0.0,event.getData()[1]);
      }
    }
 else {
      inEventCount++;
      if (inEventCount == 1) {
        Assert.assertEquals(70.0,event.getData()[1]);
      }
 else       if (inEventCount == 2) {
        Assert.assertEquals(700.0,event.getData()[1]);
      }
 else       if (inEventCount == 3) {
        Assert.assertEquals(170.0,event.getData()[1]);
      }
 else       if (inEventCount == 4) {
        Assert.assertEquals(200.0,event.getData()[1]);
      }
 else       if (inEventCount == 5) {
        Assert.assertEquals(1000.0,event.getData()[1]);
      }
    }
    eventArrived=true;
  }
}",0.9116570831155254
29164,"@Test public void testWindowPartitionQuery3() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String executionPlan=""String_Node_Str"" + ""String_Node_Str"";
  ExecutionPlanRuntime executionRuntime=siddhiManager.createExecutionPlanRuntime(executionPlan);
  executionRuntime.addCallback(""String_Node_Str"",new StreamCallback(){
    @Override public void receive(    Event[] events){
      EventPrinter.print(events);
      for (      Event event : events) {
        if (event.isExpired()) {
          removeEventCount++;
          if (removeEventCount == 1) {
            Assert.assertEquals(100.0,event.getData()[1]);
          }
 else           if (removeEventCount == 2 || removeEventCount == 3) {
            Assert.assertEquals(0.0,event.getData()[1]);
          }
        }
 else {
          inEventCount++;
          if (inEventCount == 1) {
            Assert.assertEquals(70.0,event.getData()[1]);
          }
 else           if (inEventCount == 2) {
            Assert.assertEquals(700.0,event.getData()[1]);
          }
 else           if (inEventCount == 3) {
            Assert.assertEquals(170.0,event.getData()[1]);
          }
 else           if (inEventCount == 4) {
            Assert.assertEquals(200.0,event.getData()[1]);
          }
 else           if (inEventCount == 5) {
            Assert.assertEquals(1000.0,event.getData()[1]);
          }
        }
        eventArrived=true;
      }
    }
  }
);
  InputHandler inputHandler=executionRuntime.getInputHandler(""String_Node_Str"");
  executionRuntime.start();
  inputHandler.send(new Object[]{""String_Node_Str"",70f,100});
  inputHandler.send(new Object[]{""String_Node_Str"",700f,100});
  inputHandler.send(new Object[]{""String_Node_Str"",100f,200});
  Thread.sleep(5000);
  inputHandler.send(new Object[]{""String_Node_Str"",200f,300});
  inputHandler.send(new Object[]{""String_Node_Str"",1000f,100});
  Thread.sleep(2000);
  Assert.assertEquals(5,inEventCount);
  Assert.assertEquals(3,removeEventCount);
  executionRuntime.shutdown();
}","@Test public void testWindowPartitionQuery3() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String executionPlan=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionRuntime=siddhiManager.createExecutionPlanRuntime(executionPlan);
  executionRuntime.addCallback(""String_Node_Str"",new StreamCallback(){
    @Override public void receive(    Event[] events){
      EventPrinter.print(events);
      for (      Event event : events) {
        if (event.isExpired()) {
          removeEventCount++;
          if (""String_Node_Str"".equals(event.getData()[0]) && firstEvent) {
            firstEvent=false;
            Assert.assertEquals(100.0,event.getData()[1]);
          }
 else {
            Assert.assertEquals(0.0,event.getData()[1]);
          }
        }
 else {
          inEventCount++;
          if (inEventCount == 1) {
            Assert.assertEquals(70.0,event.getData()[1]);
          }
 else           if (inEventCount == 2) {
            Assert.assertEquals(700.0,event.getData()[1]);
          }
 else           if (inEventCount == 3) {
            Assert.assertEquals(170.0,event.getData()[1]);
          }
 else           if (inEventCount == 4) {
            Assert.assertEquals(200.0,event.getData()[1]);
          }
 else           if (inEventCount == 5) {
            Assert.assertEquals(1000.0,event.getData()[1]);
          }
        }
        eventArrived=true;
      }
    }
  }
);
  InputHandler inputHandler=executionRuntime.getInputHandler(""String_Node_Str"");
  executionRuntime.start();
  inputHandler.send(new Object[]{""String_Node_Str"",70f,100});
  inputHandler.send(new Object[]{""String_Node_Str"",700f,100});
  inputHandler.send(new Object[]{""String_Node_Str"",100f,200});
  Thread.sleep(5000);
  inputHandler.send(new Object[]{""String_Node_Str"",200f,300});
  inputHandler.send(new Object[]{""String_Node_Str"",1000f,100});
  Thread.sleep(2000);
  Assert.assertEquals(5,inEventCount);
  Assert.assertEquals(5,removeEventCount);
  executionRuntime.shutdown();
}",0.9150507848568792
29165,"@Override public void receive(long timeStamp,Event[] inEvents,Event[] removeEvents){
  EventPrinter.print(timeStamp,inEvents,removeEvents);
  if (inEvents != null) {
    for (    Event event : inEvents) {
      inEventCount++;
switch (inEventCount) {
case 1:
        Assert.assertArrayEquals(new Object[]{""String_Node_Str"",""String_Node_Str"",75.6f},event.getData());
      break;
default :
    Assert.assertSame(1,inEventCount);
}
}
eventArrived=true;
}
if (removeEvents != null) {
removeEventCount=removeEventCount + removeEvents.length;
}
eventArrived=true;
}","@Override public void receive(long timeStamp,Event[] inEvents,Event[] removeEvents){
  EventPrinter.print(timeStamp,inEvents,removeEvents);
  if (inEvents != null) {
    for (    Event event : inEvents) {
      inEventCount++;
switch (inEventCount) {
case 1:
        Assert.assertArrayEquals(new Object[]{""String_Node_Str"",""String_Node_Str"",75.6f},event.getData());
      break;
default :
    Assert.assertSame(1,inEventCount);
}
}
}
if (removeEvents != null) {
for (Event event : removeEvents) {
removeEventCount++;
switch (removeEventCount) {
case 1:
  Assert.assertArrayEquals(new Object[]{""String_Node_Str"",""String_Node_Str"",75.6f},event.getData());
break;
default :
Assert.assertSame(1,removeEventCount);
}
}
}
eventArrived=true;
}",0.7391975308641975
29166,"@Test public void testTableJoinQuery4() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String streams=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  String query=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(streams + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      if (inEvents != null) {
        for (        Event event : inEvents) {
          inEventCount++;
switch (inEventCount) {
case 1:
            Assert.assertArrayEquals(new Object[]{""String_Node_Str"",""String_Node_Str"",75.6f},event.getData());
          break;
default :
        Assert.assertSame(1,inEventCount);
    }
  }
  eventArrived=true;
}
if (removeEvents != null) {
  removeEventCount=removeEventCount + removeEvents.length;
}
eventArrived=true;
}
}
);
InputHandler stockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
InputHandler checkStockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
executionPlanRuntime.start();
stockStream.send(new Object[]{""String_Node_Str"",55.6f,100l});
stockStream.send(new Object[]{""String_Node_Str"",75.6f,100l});
checkStockStream.send(new Object[]{""String_Node_Str""});
Thread.sleep(500);
Assert.assertEquals(""String_Node_Str"",1,inEventCount);
Assert.assertEquals(""String_Node_Str"",0,removeEventCount);
Assert.assertEquals(""String_Node_Str"",true,eventArrived);
executionPlanRuntime.shutdown();
}","@Test public void testTableJoinQuery4() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  String streams=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  String query=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(streams + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      if (inEvents != null) {
        for (        Event event : inEvents) {
          inEventCount++;
switch (inEventCount) {
case 1:
            Assert.assertArrayEquals(new Object[]{""String_Node_Str"",""String_Node_Str"",75.6f},event.getData());
          break;
default :
        Assert.assertSame(1,inEventCount);
    }
  }
}
if (removeEvents != null) {
  for (  Event event : removeEvents) {
    removeEventCount++;
switch (removeEventCount) {
case 1:
      Assert.assertArrayEquals(new Object[]{""String_Node_Str"",""String_Node_Str"",75.6f},event.getData());
    break;
default :
  Assert.assertSame(1,removeEventCount);
}
}
}
eventArrived=true;
}
}
);
InputHandler stockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
InputHandler checkStockStream=executionPlanRuntime.getInputHandler(""String_Node_Str"");
executionPlanRuntime.start();
stockStream.send(new Object[]{""String_Node_Str"",55.6f,100l});
stockStream.send(new Object[]{""String_Node_Str"",75.6f,100l});
checkStockStream.send(new Object[]{""String_Node_Str""});
Thread.sleep(1500);
Assert.assertEquals(""String_Node_Str"",1,inEventCount);
Assert.assertEquals(""String_Node_Str"",1,removeEventCount);
Assert.assertEquals(""String_Node_Str"",true,eventArrived);
executionPlanRuntime.shutdown();
}",0.803274494755692
29167,"private void sendEvents(){
  try {
    int size=eventBuffer.size();
switch (size) {
case 0:
{
        return;
      }
case 1:
{
      inputProcessor.send(eventBuffer.get(0),currentIndex);
      eventBuffer.clear();
      return;
    }
default :
{
    inputProcessor.send(eventBuffer.toArray(new Event[size]),currentIndex);
    eventBuffer.clear();
  }
}
}
 catch (Throwable t) {
t.printStackTrace();
}
}","private void sendEvents(){
  int size=eventBuffer.size();
switch (size) {
case 0:
{
      return;
    }
case 1:
{
    inputProcessor.send(eventBuffer.get(0),currentIndex);
    eventBuffer.clear();
    return;
  }
default :
{
  inputProcessor.send(eventBuffer.toArray(new Event[size]),currentIndex);
  eventBuffer.clear();
}
}
}",0.8383561643835616
29168,"public SiddhiManager(){
  siddhiContext=new SiddhiContext();
  siddhiContext.setEventBufferSize(SiddhiConstants.DEFAULT_EVENT_BUFFER_SIZE);
}","public SiddhiManager(){
  siddhiContext=new SiddhiContext();
}",0.6108374384236454
29169,"public SiddhiContext(){
  setSiddhiExtensions(SiddhiExtensionLoader.loadSiddhiExtensions());
}","public SiddhiContext(){
  setSiddhiExtensions(SiddhiExtensionLoader.loadSiddhiExtensions());
  eventBufferSize=SiddhiConstants.DEFAULT_EVENT_BUFFER_SIZE;
}",0.7550200803212851
29170,"/** 
 * Parse an ExecutionPlan returning ExecutionPlanRuntime
 * @param executionPlan plan to be parsed
 * @return ExecutionPlanRuntime
 */
public static ExecutionPlanRuntime parse(ExecutionPlan executionPlan,SiddhiContext siddhiContext){
  ExecutionPlanContext executionPlanContext=new ExecutionPlanContext();
  executionPlanContext.setSiddhiContext(siddhiContext);
  try {
    Element element=AnnotationHelper.getAnnotationElement(SiddhiConstants.ANNOTATION_NAME,null,executionPlan.getAnnotations());
    if (element != null) {
      executionPlanContext.setName(element.getValue());
    }
 else {
      executionPlanContext.setName(UUID.randomUUID().toString());
    }
    Annotation annotation=AnnotationHelper.getAnnotation(SiddhiConstants.ANNOTATION_PLAYBACK,executionPlan.getAnnotations());
    if (annotation != null) {
      executionPlanContext.setPlayback(true);
    }
    annotation=AnnotationHelper.getAnnotation(SiddhiConstants.ANNOTATION_ENFORCE_ORDER,executionPlan.getAnnotations());
    if (annotation != null) {
      executionPlanContext.setEnforceOrder(true);
    }
    annotation=AnnotationHelper.getAnnotation(SiddhiConstants.ANNOTATION_PARALLEL,executionPlan.getAnnotations());
    if (annotation != null) {
      executionPlanContext.setParallel(true);
    }
    if (!executionPlanContext.isPlayback() && !executionPlanContext.isEnforceOrder() && !executionPlanContext.isParallel()) {
      executionPlanContext.setSharedLock(new ReentrantLock());
    }
    executionPlanContext.setExecutorService(new ThreadPoolExecutor(5,Integer.MAX_VALUE,60L,TimeUnit.SECONDS,new LinkedBlockingDeque<Runnable>()));
    executionPlanContext.setScheduledExecutorService(Executors.newScheduledThreadPool(5));
    executionPlanContext.setTimestampGenerator(new SystemCurrentTimeMillisTimestampGenerator());
  }
 catch (  DuplicateAnnotationException e) {
    throw new DuplicateAnnotationException(e.getMessage() + ""String_Node_Str"" + executionPlan.toString());
  }
  ExecutionPlanRuntime executionPlanRuntime=new ExecutionPlanRuntime(executionPlanContext);
  defineStreamDefinitions(executionPlanRuntime,executionPlan.getStreamDefinitionMap());
  defineTableDefinitions(executionPlanRuntime,executionPlan.getTableDefinitionMap());
  try {
    for (    ExecutionElement executionElement : executionPlan.getExecutionElementList()) {
      if (executionElement instanceof Query) {
        QueryRuntime queryRuntime=QueryParser.parse((Query)executionElement,executionPlanContext,executionPlanRuntime.getStreamDefinitionMap(),executionPlanRuntime.getTableDefinitionMap(),executionPlanRuntime.getEventTableMap());
        executionPlanRuntime.addQuery(queryRuntime);
      }
 else {
        PartitionRuntime partitionRuntime=PartitionParser.parse(executionPlanRuntime,(Partition)executionElement,executionPlanContext,executionPlanRuntime.getStreamDefinitionMap());
        executionPlanRuntime.addPartition(partitionRuntime);
      }
    }
  }
 catch (  ExecutionPlanCreationException e) {
    throw new ExecutionPlanValidationException(e.getMessage() + ""String_Node_Str"" + executionPlanRuntime.getName()+ ""String_Node_Str"",e);
  }
catch (  DuplicateDefinitionException e) {
    throw new DuplicateDefinitionException(e.getMessage() + ""String_Node_Str"" + executionPlanRuntime.getName()+ ""String_Node_Str"",e);
  }
  return executionPlanRuntime;
}","/** 
 * Parse an ExecutionPlan returning ExecutionPlanRuntime
 * @param executionPlan plan to be parsed
 * @return ExecutionPlanRuntime
 */
public static ExecutionPlanRuntime parse(ExecutionPlan executionPlan,SiddhiContext siddhiContext){
  ExecutionPlanContext executionPlanContext=new ExecutionPlanContext();
  executionPlanContext.setSiddhiContext(siddhiContext);
  try {
    Element element=AnnotationHelper.getAnnotationElement(SiddhiConstants.ANNOTATION_NAME,null,executionPlan.getAnnotations());
    if (element != null) {
      executionPlanContext.setName(element.getValue());
    }
 else {
      executionPlanContext.setName(UUID.randomUUID().toString());
    }
    Annotation annotation=AnnotationHelper.getAnnotation(SiddhiConstants.ANNOTATION_PLAYBACK,executionPlan.getAnnotations());
    if (annotation != null) {
      executionPlanContext.setPlayback(true);
    }
    annotation=AnnotationHelper.getAnnotation(SiddhiConstants.ANNOTATION_ENFORCE_ORDER,executionPlan.getAnnotations());
    if (annotation != null) {
      executionPlanContext.setEnforceOrder(true);
    }
    annotation=AnnotationHelper.getAnnotation(SiddhiConstants.ANNOTATION_PARALLEL,executionPlan.getAnnotations());
    if (annotation != null) {
      executionPlanContext.setParallel(true);
    }
    if (!executionPlanContext.isPlayback() && !executionPlanContext.isEnforceOrder() && !executionPlanContext.isParallel()) {
      executionPlanContext.setSharedLock(new ReentrantLock());
    }
    executionPlanContext.setExecutorService(new ThreadPoolExecutor(5,Integer.MAX_VALUE,60L,TimeUnit.SECONDS,new LinkedBlockingDeque<Runnable>()));
    executionPlanContext.setScheduledExecutorService(Executors.newScheduledThreadPool(5));
    executionPlanContext.setTimestampGenerator(new SystemCurrentTimeMillisTimestampGenerator());
    executionPlanContext.setSnapshotService(new SnapshotService(executionPlanContext));
    executionPlanContext.setPersistenceService(new PersistenceService(executionPlanContext));
  }
 catch (  DuplicateAnnotationException e) {
    throw new DuplicateAnnotationException(e.getMessage() + ""String_Node_Str"" + executionPlan.toString());
  }
  ExecutionPlanRuntime executionPlanRuntime=new ExecutionPlanRuntime(executionPlanContext);
  defineStreamDefinitions(executionPlanRuntime,executionPlan.getStreamDefinitionMap());
  defineTableDefinitions(executionPlanRuntime,executionPlan.getTableDefinitionMap());
  try {
    for (    ExecutionElement executionElement : executionPlan.getExecutionElementList()) {
      if (executionElement instanceof Query) {
        QueryRuntime queryRuntime=QueryParser.parse((Query)executionElement,executionPlanContext,executionPlanRuntime.getStreamDefinitionMap(),executionPlanRuntime.getTableDefinitionMap(),executionPlanRuntime.getEventTableMap());
        executionPlanRuntime.addQuery(queryRuntime);
      }
 else {
        PartitionRuntime partitionRuntime=PartitionParser.parse(executionPlanRuntime,(Partition)executionElement,executionPlanContext,executionPlanRuntime.getStreamDefinitionMap());
        executionPlanRuntime.addPartition(partitionRuntime);
      }
    }
  }
 catch (  ExecutionPlanCreationException e) {
    throw new ExecutionPlanValidationException(e.getMessage() + ""String_Node_Str"" + executionPlanRuntime.getName()+ ""String_Node_Str"",e);
  }
catch (  DuplicateDefinitionException e) {
    throw new DuplicateDefinitionException(e.getMessage() + ""String_Node_Str"" + executionPlanRuntime.getName()+ ""String_Node_Str"",e);
  }
  return executionPlanRuntime;
}",0.9735234215885948
29171,"public PersistenceService(SiddhiContext siddhiContext){
  this.queryPlanIdentifier=siddhiContext.getQueryPlanIdentifier();
  this.siddhiContext=siddhiContext;
}","public PersistenceService(ExecutionPlanContext executionPlanContext){
  this.snapshotService=executionPlanContext.getSnapshotService();
  this.persistenceStore=executionPlanContext.getSiddhiContext().getPersistenceStore();
  this.executionPlanName=executionPlanContext.getName();
  this.sharedLock=executionPlanContext.getSharedLock();
}",0.1851106639839034
29172,"public void restoreRevision(String revision){
  if (persistenceStore != null) {
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + revision + ""String_Node_Str"");
    }
    byte[] snapshot=persistenceStore.load(queryPlanIdentifier,revision);
    siddhiContext.getSnapshotService().restore(snapshot);
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + revision);
    }
  }
 else {
    throw new NoPersistenceStoreAssignedException(""String_Node_Str"" + queryPlanIdentifier);
  }
}","public void restoreRevision(String revision){
  if (persistenceStore != null) {
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + revision + ""String_Node_Str"");
    }
    byte[] snapshot=persistenceStore.load(executionPlanName,revision);
    snapshotService.restore(snapshot);
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + revision);
    }
  }
 else {
    throw new NoPersistenceStoreException(""String_Node_Str"" + executionPlanName);
  }
}",0.641051567239636
29173,"public String persist(){
  if (persistenceStore != null) {
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"");
    }
    byte[] snapshot=siddhiContext.getSnapshotService().snapshot();
    String revision=System.currentTimeMillis() + ""String_Node_Str"" + queryPlanIdentifier;
    persistenceStore.save(queryPlanIdentifier,revision,snapshot);
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"");
    }
    return revision;
  }
 else {
    throw new NoPersistenceStoreAssignedException(""String_Node_Str"" + queryPlanIdentifier);
  }
}","public String persist(){
  if (persistenceStore != null) {
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"");
    }
    byte[] snapshot=snapshotService.snapshot();
    String revision=System.currentTimeMillis() + ""String_Node_Str"" + executionPlanName;
    persistenceStore.save(executionPlanName,revision,snapshot);
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"");
    }
    return revision;
  }
 else {
    throw new NoPersistenceStoreException(""String_Node_Str"" + executionPlanName);
  }
}",0.3863845446182152
29174,"public void restoreLastRevision(){
  try {
    this.siddhiContext.getThreadBarrier().close();
    if (persistenceStore != null) {
      String revision=persistenceStore.getLastRevision(queryPlanIdentifier);
      if (revision != null) {
        restoreRevision(revision);
      }
    }
 else {
      throw new NoPersistenceStoreAssignedException(""String_Node_Str"" + queryPlanIdentifier);
    }
  }
  finally {
    siddhiContext.getThreadBarrier().open();
  }
}","public void restoreLastRevision(){
  try {
    this.sharedLock.lock();
    if (persistenceStore != null) {
      String revision=persistenceStore.getLastRevision(executionPlanName);
      if (revision != null) {
        restoreRevision(revision);
      }
    }
 else {
      throw new NoPersistenceStoreException(""String_Node_Str"" + executionPlanName);
    }
  }
  finally {
    sharedLock.unlock();
  }
}",0.3098265895953757
29175,"public SnapshotService(SiddhiContext siddhiContext){
  this.siddhiContext=siddhiContext;
}","public SnapshotService(ExecutionPlanContext executionPlanContext){
  this.executionPlanContext=executionPlanContext;
}",0.6730769230769231
29176,"public void restore(byte[] snapshot){
  HashMap<String,SnapshotObject> snapshots=(HashMap<String,SnapshotObject>)ByteSerializer.BToO(snapshot);
  try {
    this.siddhiContext.getThreadBarrier().close();
    for (    Snapshotable snapshotable : snapshotableList) {
      snapshotable.restore(snapshots.get(snapshotable.getElementId()));
    }
  }
  finally {
    siddhiContext.getThreadBarrier().open();
  }
}","public void restore(byte[] snapshot){
  HashMap<String,SnapshotObject> snapshots=(HashMap<String,SnapshotObject>)ByteSerializer.BToO(snapshot);
  try {
    this.executionPlanContext.getSharedLock().lock();
    for (    Snapshotable snapshotable : snapshotableList) {
      snapshotable.restore(snapshots.get(snapshotable.getElementId()));
    }
  }
  finally {
    executionPlanContext.getSharedLock().unlock();
  }
}",0.8121212121212121
29177,"public byte[] snapshot(){
  HashMap<String,SnapshotObject> snapshots=new HashMap<String,SnapshotObject>(snapshotableList.size());
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"");
  }
  try {
    siddhiContext.getThreadBarrier().close();
    for (    Snapshotable snapshotable : snapshotableList) {
      snapshots.put(snapshotable.getElementId(),snapshotable.snapshot());
    }
  }
  finally {
    siddhiContext.getThreadBarrier().open();
  }
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"");
  }
  return ByteSerializer.OToB(snapshots);
}","public byte[] snapshot(){
  HashMap<String,SnapshotObject> snapshots=new HashMap<String,SnapshotObject>(snapshotableList.size());
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"");
  }
  try {
    executionPlanContext.getSharedLock().lock();
    for (    Snapshotable snapshotable : snapshotableList) {
      snapshots.put(snapshotable.getElementId(),snapshotable.snapshot());
    }
  }
  finally {
    executionPlanContext.getSharedLock().unlock();
  }
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"");
  }
  return ByteSerializer.OToB(snapshots);
}",0.8995633187772926
29178,"@Test public void timeWindowTest1() throws InterruptedException {
  SiddhiManager siddhiManager=new SiddhiManager();
  String cseEventStream=""String_Node_Str"";
  String query=""String_Node_Str"" + ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(cseEventStream + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      if (inEvents != null) {
        inEventCount=inEventCount + inEvents.length;
      }
      if (removeEvents != null) {
        Assert.assertEquals(""String_Node_Str"",inEventCount - 2,removeEventCount);
        removeEventCount=removeEventCount + removeEvents.length;
      }
      eventArrived=true;
    }
  }
);
  InputHandler inputHandler=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  inputHandler.send(new Object[]{""String_Node_Str"",700f,0});
  inputHandler.send(new Object[]{""String_Node_Str"",60.5f,1});
  Thread.sleep(5000);
  Assert.assertEquals(2,inEventCount);
  Assert.assertEquals(2,removeEventCount);
  Assert.assertTrue(eventArrived);
  executionPlanRuntime.shutdown();
}","@Test public void timeWindowTest1() throws InterruptedException {
  SiddhiManager siddhiManager=new SiddhiManager();
  String cseEventStream=""String_Node_Str"" + ""String_Node_Str"";
  String query=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExecutionPlanRuntime executionPlanRuntime=siddhiManager.createExecutionPlanRuntime(cseEventStream + query);
  executionPlanRuntime.addCallback(""String_Node_Str"",new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      if (inEvents != null) {
        inEventCount=inEventCount + inEvents.length;
      }
      if (removeEvents != null) {
        Assert.assertEquals(""String_Node_Str"",inEventCount - 2,removeEventCount);
        removeEventCount=removeEventCount + removeEvents.length;
      }
      eventArrived=true;
    }
  }
);
  InputHandler inputHandler=executionPlanRuntime.getInputHandler(""String_Node_Str"");
  executionPlanRuntime.start();
  inputHandler.send(new Object[]{""String_Node_Str"",700f,0});
  inputHandler.send(new Object[]{""String_Node_Str"",60.5f,1});
  Thread.sleep(5000);
  Assert.assertEquals(2,inEventCount);
  Assert.assertEquals(2,removeEventCount);
  Assert.assertTrue(eventArrived);
  executionPlanRuntime.shutdown();
}",0.9706766917293234
29179,"@Override public ExpressionExecutor cloneExecutor(){
  return this;
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return this;
}",0.9324324324324323
29180,public ExpressionExecutor cloneExecutor();,public ExpressionExecutor cloneExecutor(String key);,0.8936170212765957
29181,"@Override public ExpressionExecutor cloneExecutor(){
  return this;
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return this;
}",0.9324324324324323
29182,"@Override public ExpressionExecutor cloneExecutor(){
  return new AndConditionExpressionExecutor(leftConditionExecutor.cloneExecutor(),rightConditionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new AndConditionExpressionExecutor(leftConditionExecutor.cloneExecutor(key),rightConditionExecutor.cloneExecutor(key));
}",0.9567567567567568
29183,"@Override public ExpressionExecutor cloneExecutor(){
  return new InConditionExpressionExecutor(eventTable,finder.cloneFinder());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new InConditionExpressionExecutor(eventTable,finder.cloneFinder());
}",0.9632352941176472
29184,"@Override public ExpressionExecutor cloneExecutor(){
  return new NotConditionExpressionExecutor(conditionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new NotConditionExpressionExecutor(conditionExecutor.cloneExecutor(key));
}",0.9537366548042704
29185,"@Override public ExpressionExecutor cloneExecutor(){
  return new OrConditionExpressionExecutor(leftConditionExecutor.cloneExecutor(),rightConditionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new OrConditionExpressionExecutor(leftConditionExecutor.cloneExecutor(key),rightConditionExecutor.cloneExecutor(key));
}",0.9565217391304348
29186,"@Override public ExpressionExecutor cloneExecutor(){
  return new ContainsCompareConditionExpressionExecutor(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new ContainsCompareConditionExpressionExecutor(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9597989949748744
29187,"@Override public ExpressionExecutor cloneExecutor(){
  return new EqualCompareConditionExecutorDoubleFloat(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new EqualCompareConditionExecutorDoubleFloat(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9593908629441624
29188,"@Override public ExpressionExecutor cloneExecutor(){
  return new EqualCompareConditionExecutorIntFloat(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new EqualCompareConditionExecutorIntFloat(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9587628865979382
29189,"@Override public ExpressionExecutor cloneExecutor(){
  return new EqualCompareConditionExpressionExecutorBoolBool(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new EqualCompareConditionExpressionExecutorBoolBool(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9607843137254902
29190,"@Override public ExpressionExecutor cloneExecutor(){
  return new EqualCompareConditionExpressionExecutorDoubleDouble(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new EqualCompareConditionExpressionExecutorDoubleDouble(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9615384615384616
29191,"@Override public ExpressionExecutor cloneExecutor(){
  return new EqualCompareConditionExpressionExecutorDoubleInt(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new EqualCompareConditionExpressionExecutorDoubleInt(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9609756097560976
29192,"@Override public ExpressionExecutor cloneExecutor(){
  return new EqualCompareConditionExpressionExecutorDoubleLong(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new EqualCompareConditionExpressionExecutorDoubleLong(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9611650485436892
29193,"@Override public ExpressionExecutor cloneExecutor(){
  return new EqualCompareConditionExpressionExecutorFloatDouble(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new EqualCompareConditionExpressionExecutorFloatDouble(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.961352657004831
29194,"@Override public ExpressionExecutor cloneExecutor(){
  return new EqualCompareConditionExpressionExecutorFloatFloat(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new EqualCompareConditionExpressionExecutorFloatFloat(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9611650485436892
29195,"@Override public ExpressionExecutor cloneExecutor(){
  return new EqualCompareConditionExpressionExecutorFloatInt(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new EqualCompareConditionExpressionExecutorFloatInt(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9607843137254902
29196,"@Override public ExpressionExecutor cloneExecutor(){
  return new EqualCompareConditionExpressionExecutorFloatLong(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new EqualCompareConditionExpressionExecutorFloatLong(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9609756097560976
29197,"@Override public ExpressionExecutor cloneExecutor(){
  return new EqualCompareConditionExpressionExecutorIntDouble(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new EqualCompareConditionExpressionExecutorIntDouble(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9609756097560976
29198,"@Override public ExpressionExecutor cloneExecutor(){
  return new EqualCompareConditionExpressionExecutorIntInt(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new EqualCompareConditionExpressionExecutorIntInt(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9603960396039604
29199,"@Override public ExpressionExecutor cloneExecutor(){
  return new EqualCompareConditionExpressionExecutorIntLong(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new EqualCompareConditionExpressionExecutorIntLong(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9605911330049262
29200,"@Override public ExpressionExecutor cloneExecutor(){
  return new EqualCompareConditionExpressionExecutorLongDouble(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new EqualCompareConditionExpressionExecutorLongDouble(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9611650485436892
29201,"@Override public ExpressionExecutor cloneExecutor(){
  return new EqualCompareConditionExpressionExecutorLongFloat(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new EqualCompareConditionExpressionExecutorLongFloat(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9609756097560976
29202,"@Override public ExpressionExecutor cloneExecutor(){
  return new EqualCompareConditionExpressionExecutorLongInt(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new EqualCompareConditionExpressionExecutorLongInt(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9605911330049262
29203,"@Override public ExpressionExecutor cloneExecutor(){
  return new EqualCompareConditionExpressionExecutorLongLong(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new EqualCompareConditionExpressionExecutorLongLong(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9607843137254902
29204,"@Override public ExpressionExecutor cloneExecutor(){
  return new EqualCompareConditionExpressionExecutorStringString(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new EqualCompareConditionExpressionExecutorStringString(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9615384615384616
29205,"@Override public ExpressionExecutor cloneExecutor(){
  return new GreaterThanCompareConditionExpressionExecutorDoubleDouble(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new GreaterThanCompareConditionExpressionExecutorDoubleDouble(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9626168224299064
29206,"@Override public ExpressionExecutor cloneExecutor(){
  return new GreaterThanCompareConditionExpressionExecutorDoubleFloat(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new GreaterThanCompareConditionExpressionExecutorDoubleFloat(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9624413145539906
29207,"@Override public ExpressionExecutor cloneExecutor(){
  return new GreaterThanCompareConditionExpressionExecutorDoubleInt(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new GreaterThanCompareConditionExpressionExecutorDoubleInt(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.962085308056872
29208,"@Override public ExpressionExecutor cloneExecutor(){
  return new GreaterThanCompareConditionExpressionExecutorDoubleLong(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new GreaterThanCompareConditionExpressionExecutorDoubleLong(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9622641509433962
29209,"@Override public ExpressionExecutor cloneExecutor(){
  return new GreaterThanCompareConditionExpressionExecutorFloatDouble(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new GreaterThanCompareConditionExpressionExecutorFloatDouble(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9624413145539906
29210,"@Override public ExpressionExecutor cloneExecutor(){
  return new GreaterThanCompareConditionExpressionExecutorFloatFloat(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new GreaterThanCompareConditionExpressionExecutorFloatFloat(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9622641509433962
29211,"@Override public ExpressionExecutor cloneExecutor(){
  return new GreaterThanCompareConditionExpressionExecutorFloatInt(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new GreaterThanCompareConditionExpressionExecutorFloatInt(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.961904761904762
29212,"@Override public ExpressionExecutor cloneExecutor(){
  return new GreaterThanCompareConditionExpressionExecutorFloatLong(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new GreaterThanCompareConditionExpressionExecutorFloatLong(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.962085308056872
29213,"@Override public ExpressionExecutor cloneExecutor(){
  return new GreaterThanCompareConditionExpressionExecutorIntDouble(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new GreaterThanCompareConditionExpressionExecutorIntDouble(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.962085308056872
29214,"@Override public ExpressionExecutor cloneExecutor(){
  return new GreaterThanCompareConditionExpressionExecutorIntFloat(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new GreaterThanCompareConditionExpressionExecutorIntFloat(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.961904761904762
29215,"@Override public ExpressionExecutor cloneExecutor(){
  return new GreaterThanCompareConditionExpressionExecutorIntInt(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new GreaterThanCompareConditionExpressionExecutorIntInt(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9615384615384616
29216,"@Override public ExpressionExecutor cloneExecutor(){
  return new GreaterThanCompareConditionExpressionExecutorIntLong(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new GreaterThanCompareConditionExpressionExecutorIntLong(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9617224880382776
29217,"@Override public ExpressionExecutor cloneExecutor(){
  return new GreaterThanCompareConditionExpressionExecutorLongDouble(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new GreaterThanCompareConditionExpressionExecutorLongDouble(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.9622641509433962
29218,"@Override public ExpressionExecutor cloneExecutor(){
  return new GreaterThanCompareConditionExpressionExecutorLongFloat(leftExpressionExecutor.cloneExecutor(),rightExpressionExecutor.cloneExecutor());
}","@Override public ExpressionExecutor cloneExecutor(String key){
  return new GreaterThanCompareConditionExpressionExecutorLongFloat(leftExpressionExecutor.cloneExecutor(key),rightExpressionExecutor.cloneExecutor(key));
}",0.962085308056872
29219,"/** 
 * Universal method to add data to MetaStream event. Will make sure event will be added to corresponding array by initializing them accordingly.
 * @param attribute
 */
public void addData(Attribute attribute){
  if (onAfterWindowData != null) {
    if (!onAfterWindowData.contains(attribute)) {
      onAfterWindowData.add(attribute);
    }
  }
 else {
    if (!beforeWindowData.contains(attribute)) {
      beforeWindowData.add(attribute);
    }
  }
}","/** 
 * Universal method to add data to MetaStream event. Will make sure event will be added to corresponding array by initializing them accordingly.
 * @param attribute
 */
public int addData(Attribute attribute){
  if (onAfterWindowData != null) {
    if (!onAfterWindowData.contains(attribute)) {
      onAfterWindowData.add(attribute);
      return SiddhiConstants.ON_AFTER_WINDOW_DATA_INDEX;
    }
  }
 else {
    if (!beforeWindowData.contains(attribute)) {
      beforeWindowData.add(attribute);
      return SiddhiConstants.BEFORE_WINDOW_DATA_INDEX;
    }
  }
  return SiddhiConstants.UNKNOWN_STATE;
}",0.8509840674789129
29220,"public SimpleFinder(ExpressionExecutor expressionExecutor,int candidateEventPosition,int matchingEventPosition,int size){
  this.size=size;
  this.event=new StateEvent(size,0);
  this.expressionExecutor=expressionExecutor;
  this.candidateEventPosition=candidateEventPosition;
  this.matchingEventPosition=matchingEventPosition;
}","public SimpleFinder(ExpressionExecutor expressionExecutor,int candidateEventPosition,int matchingEventPosition,int size){
  this.size=size;
  this.event=new FinderStateEvent(size,0);
  this.expressionExecutor=expressionExecutor;
  this.candidateEventPosition=candidateEventPosition;
  this.matchingEventPosition=matchingEventPosition;
}",0.990990990990991
29221,"@Override public void setMatchingEvent(ComplexEvent matchingEvent){
  if (matchingEvent == null) {
    Arrays.fill(event.getStreamEvents(),null);
  }
 else {
    if (matchingEvent instanceof StreamEvent) {
      this.event.setEvent(matchingEventPosition,((StreamEvent)matchingEvent));
    }
 else {
      System.arraycopy(((StateEvent)matchingEvent).getStreamEvents(),0,event.getStreamEvents(),0,size - 1);
    }
  }
}","@Override public void setMatchingEvent(ComplexEvent matchingEvent){
  if (matchingEvent instanceof StreamEvent) {
    this.event.setEvent(matchingEventPosition,((StreamEvent)matchingEvent));
  }
 else {
    this.event.setEvent(((StateEvent)matchingEvent));
  }
}",0.3117647058823529
29222,"/** 
 * Parse and validate the given Siddhi variable and return a VariableExpressionExecutor
 * @param variable     Variable to be parsed
 * @param metaEvent    Meta event used to collect execution info of stream associated with query
 * @param currentState
 * @param executorList List to hold VariableExpressionExecutors to update after query parsing  @return VariableExpressionExecutor representing given variable
 */
private static ExpressionExecutor parseVariable(Variable variable,MetaComplexEvent metaEvent,int currentState,List<VariableExpressionExecutor> executorList,int defaultStreamEventIndex){
  String attributeName=variable.getAttributeName();
  int[] eventPosition=new int[2];
  if (variable.getStreamIndex() != null) {
    eventPosition[STREAM_EVENT_INDEX]=variable.getStreamIndex();
  }
 else {
    eventPosition[STREAM_EVENT_INDEX]=defaultStreamEventIndex;
  }
  if (metaEvent instanceof MetaStreamEvent) {
    MetaStreamEvent metaStreamEvent=(MetaStreamEvent)metaEvent;
    AbstractDefinition abstractDefinition;
    Attribute.Type type;
    if (currentState == HAVING_STATE) {
      abstractDefinition=metaStreamEvent.getOutputStreamDefinition();
      type=abstractDefinition.getAttributeType(attributeName);
      eventPosition[STREAM_EVENT_CHAIN_INDEX]=HAVING_STATE;
    }
 else {
      abstractDefinition=metaStreamEvent.getInputDefinition();
      eventPosition[STREAM_EVENT_CHAIN_INDEX]=UNKNOWN_STATE;
      type=abstractDefinition.getAttributeType(attributeName);
      ((MetaStreamEvent)metaEvent).addData(new Attribute(attributeName,type));
    }
    VariableExpressionExecutor variableExpressionExecutor=new VariableExpressionExecutor(new Attribute(attributeName,type),eventPosition[STREAM_EVENT_CHAIN_INDEX],eventPosition[STREAM_EVENT_INDEX]);
    if (executorList != null) {
      executorList.add(variableExpressionExecutor);
    }
    return variableExpressionExecutor;
  }
 else {
    MetaStateEvent metaStateEvent=(MetaStateEvent)metaEvent;
    Attribute.Type type=null;
    AbstractDefinition definition=null;
    String firstInput=null;
    if (variable.getStreamId() == null) {
      MetaStreamEvent[] metaStreamEvents=metaStateEvent.getMetaStreamEvents();
      if (currentState == HAVING_STATE) {
        definition=metaStateEvent.getOutputStreamDefinition();
        try {
          type=definition.getAttributeType(attributeName);
          eventPosition[STREAM_EVENT_CHAIN_INDEX]=HAVING_STATE;
        }
 catch (        AttributeNotExistException e) {
          currentState=UNKNOWN_STATE;
        }
      }
      if (currentState == UNKNOWN_STATE) {
        for (int i=0; i < metaStreamEvents.length; i++) {
          MetaStreamEvent metaStreamEvent=metaStreamEvents[i];
          definition=metaStreamEvent.getInputDefinition();
          if (type == null) {
            try {
              type=definition.getAttributeType(attributeName);
              firstInput=""String_Node_Str"" + definition.getId() + ""String_Node_Str""+ ""String_Node_Str""+ metaStreamEvent.getInputReferenceId();
              eventPosition[STREAM_EVENT_CHAIN_INDEX]=i;
            }
 catch (            AttributeNotExistException e) {
            }
          }
 else {
            try {
              definition.getAttributeType(attributeName);
              throw new ExecutionPlanValidationException(firstInput + ""String_Node_Str"" + definition.getId()+ ""String_Node_Str""+ ""String_Node_Str""+ metaStreamEvent.getInputReferenceId()+ ""String_Node_Str""+ ""String_Node_Str"");
            }
 catch (            AttributeNotExistException e) {
            }
          }
        }
      }
 else       if (currentState >= 0) {
        MetaStreamEvent metaStreamEvent=metaStreamEvents[currentState];
        definition=metaStreamEvent.getInputDefinition();
        try {
          type=definition.getAttributeType(attributeName);
          eventPosition[STREAM_EVENT_CHAIN_INDEX]=currentState;
        }
 catch (        AttributeNotExistException e) {
          throw new ExecutionPlanValidationException(e.getMessage() + ""String_Node_Str"" + definition.getId()+ ""String_Node_Str""+ ""String_Node_Str""+ metaStreamEvent.getInputReferenceId());
        }
      }
    }
 else {
      MetaStreamEvent[] metaStreamEvents=metaStateEvent.getMetaStreamEvents();
      for (int i=0, metaStreamEventsLength=metaStreamEvents.length; i < metaStreamEventsLength; i++) {
        MetaStreamEvent metaStreamEvent=metaStreamEvents[i];
        definition=metaStreamEvent.getInputDefinition();
        if (metaStreamEvent.getInputReferenceId() == null) {
          if (definition.getId().equals(variable.getStreamId())) {
            type=definition.getAttributeType(attributeName);
            eventPosition[STREAM_EVENT_CHAIN_INDEX]=i;
            break;
          }
        }
 else {
          if (metaStreamEvent.getInputReferenceId().equals(variable.getStreamId())) {
            type=definition.getAttributeType(attributeName);
            eventPosition[STREAM_EVENT_CHAIN_INDEX]=i;
            break;
          }
        }
      }
    }
    VariableExpressionExecutor variableExpressionExecutor=new VariableExpressionExecutor(new Attribute(attributeName,type),eventPosition[STREAM_EVENT_CHAIN_INDEX],eventPosition[STREAM_EVENT_INDEX]);
    if (currentState != HAVING_STATE) {
      ((MetaStateEvent)metaEvent).getMetaStreamEvent(eventPosition[STREAM_EVENT_CHAIN_INDEX]).addData(new Attribute(attributeName,type));
    }
    if (executorList != null) {
      executorList.add(variableExpressionExecutor);
    }
    return variableExpressionExecutor;
  }
}","/** 
 * Parse and validate the given Siddhi variable and return a VariableExpressionExecutor
 * @param variable     Variable to be parsed
 * @param metaEvent    Meta event used to collect execution info of stream associated with query
 * @param currentState
 * @param executorList List to hold VariableExpressionExecutors to update after query parsing  @return VariableExpressionExecutor representing given variable
 */
private static ExpressionExecutor parseVariable(Variable variable,MetaComplexEvent metaEvent,int currentState,List<VariableExpressionExecutor> executorList,int defaultStreamEventIndex){
  String attributeName=variable.getAttributeName();
  int[] eventPosition=new int[2];
  if (variable.getStreamIndex() != null) {
    eventPosition[STREAM_EVENT_INDEX]=variable.getStreamIndex();
  }
 else {
    eventPosition[STREAM_EVENT_INDEX]=defaultStreamEventIndex;
  }
  if (metaEvent instanceof MetaStreamEvent) {
    MetaStreamEvent metaStreamEvent=(MetaStreamEvent)metaEvent;
    AbstractDefinition abstractDefinition;
    Attribute.Type type;
    if (currentState == HAVING_STATE) {
      abstractDefinition=metaStreamEvent.getOutputStreamDefinition();
      type=abstractDefinition.getAttributeType(attributeName);
      eventPosition[STREAM_EVENT_CHAIN_INDEX]=HAVING_STATE;
    }
 else {
      abstractDefinition=metaStreamEvent.getInputDefinition();
      eventPosition[STREAM_EVENT_CHAIN_INDEX]=UNKNOWN_STATE;
      type=abstractDefinition.getAttributeType(attributeName);
      ((MetaStreamEvent)metaEvent).addData(new Attribute(attributeName,type));
    }
    VariableExpressionExecutor variableExpressionExecutor=new VariableExpressionExecutor(new Attribute(attributeName,type),eventPosition[STREAM_EVENT_CHAIN_INDEX],eventPosition[STREAM_EVENT_INDEX]);
    if (((MetaStreamEvent)metaEvent).isTableEvent()) {
      variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_TYPE_INDEX]=OUTPUT_DATA_INDEX;
      variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_INDEX]=abstractDefinition.getAttributePosition(variableExpressionExecutor.getAttribute().getName());
    }
    if (executorList != null) {
      executorList.add(variableExpressionExecutor);
    }
    return variableExpressionExecutor;
  }
 else {
    MetaStateEvent metaStateEvent=(MetaStateEvent)metaEvent;
    Attribute.Type type=null;
    AbstractDefinition definition=null;
    String firstInput=null;
    if (variable.getStreamId() == null) {
      MetaStreamEvent[] metaStreamEvents=metaStateEvent.getMetaStreamEvents();
      if (currentState == HAVING_STATE) {
        definition=metaStateEvent.getOutputStreamDefinition();
        try {
          type=definition.getAttributeType(attributeName);
          eventPosition[STREAM_EVENT_CHAIN_INDEX]=HAVING_STATE;
        }
 catch (        AttributeNotExistException e) {
          currentState=UNKNOWN_STATE;
        }
      }
      if (currentState == UNKNOWN_STATE) {
        for (int i=0; i < metaStreamEvents.length; i++) {
          MetaStreamEvent metaStreamEvent=metaStreamEvents[i];
          definition=metaStreamEvent.getInputDefinition();
          if (type == null) {
            try {
              type=definition.getAttributeType(attributeName);
              firstInput=""String_Node_Str"" + definition.getId() + ""String_Node_Str""+ ""String_Node_Str""+ metaStreamEvent.getInputReferenceId();
              eventPosition[STREAM_EVENT_CHAIN_INDEX]=i;
            }
 catch (            AttributeNotExistException e) {
            }
          }
 else {
            try {
              definition.getAttributeType(attributeName);
              throw new ExecutionPlanValidationException(firstInput + ""String_Node_Str"" + definition.getId()+ ""String_Node_Str""+ ""String_Node_Str""+ metaStreamEvent.getInputReferenceId()+ ""String_Node_Str""+ ""String_Node_Str"");
            }
 catch (            AttributeNotExistException e) {
            }
          }
        }
      }
 else       if (currentState >= 0) {
        MetaStreamEvent metaStreamEvent=metaStreamEvents[currentState];
        definition=metaStreamEvent.getInputDefinition();
        try {
          type=definition.getAttributeType(attributeName);
          eventPosition[STREAM_EVENT_CHAIN_INDEX]=currentState;
        }
 catch (        AttributeNotExistException e) {
          throw new ExecutionPlanValidationException(e.getMessage() + ""String_Node_Str"" + definition.getId()+ ""String_Node_Str""+ ""String_Node_Str""+ metaStreamEvent.getInputReferenceId());
        }
      }
    }
 else {
      MetaStreamEvent[] metaStreamEvents=metaStateEvent.getMetaStreamEvents();
      for (int i=0, metaStreamEventsLength=metaStreamEvents.length; i < metaStreamEventsLength; i++) {
        MetaStreamEvent metaStreamEvent=metaStreamEvents[i];
        definition=metaStreamEvent.getInputDefinition();
        if (metaStreamEvent.getInputReferenceId() == null) {
          if (definition.getId().equals(variable.getStreamId())) {
            type=definition.getAttributeType(attributeName);
            eventPosition[STREAM_EVENT_CHAIN_INDEX]=i;
            break;
          }
        }
 else {
          if (metaStreamEvent.getInputReferenceId().equals(variable.getStreamId())) {
            type=definition.getAttributeType(attributeName);
            eventPosition[STREAM_EVENT_CHAIN_INDEX]=i;
            break;
          }
        }
      }
    }
    VariableExpressionExecutor variableExpressionExecutor=new VariableExpressionExecutor(new Attribute(attributeName,type),eventPosition[STREAM_EVENT_CHAIN_INDEX],eventPosition[STREAM_EVENT_INDEX]);
    MetaStreamEvent metaStreamEvent=((MetaStateEvent)metaEvent).getMetaStreamEvent(eventPosition[STREAM_EVENT_CHAIN_INDEX]);
    if (metaStreamEvent.isTableEvent()) {
      variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_TYPE_INDEX]=OUTPUT_DATA_INDEX;
      variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_INDEX]=metaStreamEvent.getInputDefinition().getAttributePosition(variableExpressionExecutor.getAttribute().getName());
    }
    if (currentState != HAVING_STATE) {
      ((MetaStateEvent)metaEvent).getMetaStreamEvent(eventPosition[STREAM_EVENT_CHAIN_INDEX]).addData(new Attribute(attributeName,type));
    }
    if (executorList != null) {
      executorList.add(variableExpressionExecutor);
    }
    return variableExpressionExecutor;
  }
}",0.9349291975724882
29223,"public static Finder parse(Expression expression,MetaComplexEvent metaComplexEvent,ExecutionPlanContext executionPlanContext,List<VariableExpressionExecutor> executorList,int matchingStreamIndex,AbstractDefinition candidateDefinition){
  int candidateEventPosition=0;
  int size=0;
  MetaStreamEvent eventTableStreamEvent=new MetaStreamEvent();
  eventTableStreamEvent.setInputDefinition(candidateDefinition);
  for (  Attribute attribute : candidateDefinition.getAttributeList()) {
    eventTableStreamEvent.addOutputData(attribute);
  }
  MetaStateEvent metaStateEvent=null;
  if (metaComplexEvent instanceof MetaStreamEvent) {
    metaStateEvent=new MetaStateEvent(2);
    metaStateEvent.addEvent(((MetaStreamEvent)metaComplexEvent));
    metaStateEvent.addEvent(eventTableStreamEvent);
    candidateEventPosition=1;
    matchingStreamIndex=0;
    size=2;
  }
 else {
    MetaStreamEvent[] metaStreamEvents=((MetaStateEvent)metaComplexEvent).getMetaStreamEvents();
    for (; candidateEventPosition < metaStreamEvents.length; candidateEventPosition++) {
      MetaStreamEvent metaStreamEvent=metaStreamEvents[candidateEventPosition];
      if (metaStreamEvent.getInputDefinition().equalsIgnoreAnnotations(candidateDefinition)) {
        metaStateEvent=((MetaStateEvent)metaComplexEvent);
        size=metaStreamEvents.length;
        break;
      }
    }
    if (metaStateEvent == null) {
      metaStateEvent=new MetaStateEvent(metaStreamEvents.length + 1);
      for (      MetaStreamEvent metaStreamEvent : metaStreamEvents) {
        metaStateEvent.addEvent(metaStreamEvent);
      }
      metaStateEvent.addEvent(eventTableStreamEvent);
      candidateEventPosition=metaStreamEvents.length;
      size=metaStreamEvents.length + 1;
    }
  }
  ExpressionExecutor expressionExecutor=ExpressionParser.parseExpression(expression,metaStateEvent,matchingStreamIndex,executorList,executionPlanContext,false,0);
  return new SimpleFinder(expressionExecutor,candidateEventPosition,matchingStreamIndex,size);
}","public static Finder parse(Expression expression,MetaComplexEvent metaComplexEvent,ExecutionPlanContext executionPlanContext,List<VariableExpressionExecutor> executorList,int matchingStreamIndex,AbstractDefinition candidateDefinition){
  int candidateEventPosition=0;
  int size=0;
  MetaStreamEvent eventTableStreamEvent=new MetaStreamEvent();
  eventTableStreamEvent.setTableEvent(true);
  eventTableStreamEvent.setInputDefinition(candidateDefinition);
  for (  Attribute attribute : candidateDefinition.getAttributeList()) {
    eventTableStreamEvent.addOutputData(attribute);
  }
  MetaStateEvent metaStateEvent=null;
  if (metaComplexEvent instanceof MetaStreamEvent) {
    metaStateEvent=new MetaStateEvent(2);
    metaStateEvent.addEvent(((MetaStreamEvent)metaComplexEvent));
    metaStateEvent.addEvent(eventTableStreamEvent);
    candidateEventPosition=1;
    matchingStreamIndex=0;
    size=2;
  }
 else {
    MetaStreamEvent[] metaStreamEvents=((MetaStateEvent)metaComplexEvent).getMetaStreamEvents();
    for (; candidateEventPosition < metaStreamEvents.length; candidateEventPosition++) {
      MetaStreamEvent metaStreamEvent=metaStreamEvents[candidateEventPosition];
      if (metaStreamEvent.getInputDefinition().equalsIgnoreAnnotations(candidateDefinition)) {
        metaStateEvent=((MetaStateEvent)metaComplexEvent);
        size=metaStreamEvents.length;
        break;
      }
    }
    if (metaStateEvent == null) {
      metaStateEvent=new MetaStateEvent(metaStreamEvents.length + 1);
      for (      MetaStreamEvent metaStreamEvent : metaStreamEvents) {
        metaStateEvent.addEvent(metaStreamEvent);
      }
      metaStateEvent.addEvent(eventTableStreamEvent);
      candidateEventPosition=metaStreamEvents.length;
      size=metaStreamEvents.length + 1;
    }
  }
  ExpressionExecutor expressionExecutor=ExpressionParser.parseExpression(expression,metaStateEvent,matchingStreamIndex,executorList,executionPlanContext,false,0);
  return new SimpleFinder(expressionExecutor,candidateEventPosition,matchingStreamIndex,size);
}",0.9889189854715588
29224,"public static void updateVariablePosition(MetaComplexEvent metaComplexEvent,List<VariableExpressionExecutor> variableExpressionExecutorList){
  for (  VariableExpressionExecutor variableExpressionExecutor : variableExpressionExecutorList) {
    int streamEventChainIndex=variableExpressionExecutor.getPosition()[STREAM_EVENT_CHAIN_INDEX];
    if (streamEventChainIndex == HAVING_STATE) {
      if (metaComplexEvent instanceof MetaStreamEvent) {
        variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_TYPE_INDEX]=OUTPUT_DATA_INDEX;
      }
 else {
        variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_TYPE_INDEX]=STATE_OUTPUT_DATA_INDEX;
      }
      variableExpressionExecutor.getPosition()[STREAM_EVENT_CHAIN_INDEX]=UNKNOWN_STATE;
      variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_INDEX]=metaComplexEvent.getOutputStreamDefinition().getAttributeList().indexOf(variableExpressionExecutor.getAttribute());
      continue;
    }
    MetaStreamEvent metaStreamEvent;
    if (metaComplexEvent instanceof MetaStreamEvent) {
      metaStreamEvent=(MetaStreamEvent)metaComplexEvent;
    }
 else {
      metaStreamEvent=((MetaStateEvent)metaComplexEvent).getMetaStreamEvent(streamEventChainIndex);
    }
    if (metaStreamEvent.getOutputData().contains(variableExpressionExecutor.getAttribute())) {
      variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_TYPE_INDEX]=OUTPUT_DATA_INDEX;
      variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_INDEX]=metaStreamEvent.getOutputData().indexOf(variableExpressionExecutor.getAttribute());
    }
 else     if (metaStreamEvent.getOnAfterWindowData().contains(variableExpressionExecutor.getAttribute())) {
      variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_TYPE_INDEX]=ON_AFTER_WINDOW_DATA_INDEX;
      variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_INDEX]=metaStreamEvent.getOnAfterWindowData().indexOf(variableExpressionExecutor.getAttribute());
    }
 else     if (metaStreamEvent.getBeforeWindowData().contains(variableExpressionExecutor.getAttribute())) {
      variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_TYPE_INDEX]=BEFORE_WINDOW_DATA_INDEX;
      variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_INDEX]=metaStreamEvent.getBeforeWindowData().indexOf(variableExpressionExecutor.getAttribute());
    }
  }
}","public static void updateVariablePosition(MetaComplexEvent metaComplexEvent,List<VariableExpressionExecutor> variableExpressionExecutorList){
  for (  VariableExpressionExecutor variableExpressionExecutor : variableExpressionExecutorList) {
    int streamEventChainIndex=variableExpressionExecutor.getPosition()[STREAM_EVENT_CHAIN_INDEX];
    if (streamEventChainIndex == HAVING_STATE) {
      if (metaComplexEvent instanceof MetaStreamEvent) {
        variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_TYPE_INDEX]=OUTPUT_DATA_INDEX;
      }
 else {
        variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_TYPE_INDEX]=STATE_OUTPUT_DATA_INDEX;
      }
      variableExpressionExecutor.getPosition()[STREAM_EVENT_CHAIN_INDEX]=UNKNOWN_STATE;
      variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_INDEX]=metaComplexEvent.getOutputStreamDefinition().getAttributeList().indexOf(variableExpressionExecutor.getAttribute());
      continue;
    }
 else     if (metaComplexEvent instanceof MetaStreamEvent && streamEventChainIndex >= 1) {
      continue;
    }
 else     if (metaComplexEvent instanceof MetaStateEvent && streamEventChainIndex >= ((MetaStateEvent)metaComplexEvent).getMetaStreamEvents().length) {
      continue;
    }
    MetaStreamEvent metaStreamEvent;
    if (metaComplexEvent instanceof MetaStreamEvent) {
      metaStreamEvent=(MetaStreamEvent)metaComplexEvent;
    }
 else {
      metaStreamEvent=((MetaStateEvent)metaComplexEvent).getMetaStreamEvent(streamEventChainIndex);
    }
    if (metaStreamEvent.getOutputData().contains(variableExpressionExecutor.getAttribute())) {
      variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_TYPE_INDEX]=OUTPUT_DATA_INDEX;
      variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_INDEX]=metaStreamEvent.getOutputData().indexOf(variableExpressionExecutor.getAttribute());
    }
 else     if (metaStreamEvent.getOnAfterWindowData().contains(variableExpressionExecutor.getAttribute())) {
      variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_TYPE_INDEX]=ON_AFTER_WINDOW_DATA_INDEX;
      variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_INDEX]=metaStreamEvent.getOnAfterWindowData().indexOf(variableExpressionExecutor.getAttribute());
    }
 else     if (metaStreamEvent.getBeforeWindowData().contains(variableExpressionExecutor.getAttribute())) {
      variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_TYPE_INDEX]=BEFORE_WINDOW_DATA_INDEX;
      variableExpressionExecutor.getPosition()[STREAM_ATTRIBUTE_INDEX]=metaStreamEvent.getBeforeWindowData().indexOf(variableExpressionExecutor.getAttribute());
    }
  }
}",0.9423810479823328
29225,"@Test public void testSnapshotOutputRateLimitQuery11() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  siddhiManager.defineStream(""String_Node_Str"");
  String queryReference=siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  siddhiManager.addCallback(queryReference,new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      count++;
      if (count == 2) {
        Assert.assertTrue((Long)inEvents[0].getData0() == 9l);
      }
 else       if (count == 3) {
        Assert.assertTrue((Long)inEvents[0].getData0() == 9l);
      }
 else       if (count == 4) {
        Assert.assertTrue((Long)inEvents[0].getData0() == 21l);
      }
      eventArrived=true;
    }
  }
);
  InputHandler loginSucceedEvents=siddhiManager.getInputHandler(""String_Node_Str"");
  Thread.sleep(1100);
  loginSucceedEvents.send(new Object[]{System.currentTimeMillis(),""String_Node_Str"",3});
  loginSucceedEvents.send(new Object[]{System.currentTimeMillis(),""String_Node_Str"",6});
  Thread.sleep(2200);
  loginSucceedEvents.send(new Object[]{System.currentTimeMillis(),""String_Node_Str"",2});
  loginSucceedEvents.send(new Object[]{System.currentTimeMillis(),""String_Node_Str"",10});
  Thread.sleep(1200);
  Assert.assertEquals(""String_Node_Str"",true,eventArrived);
  Assert.assertEquals(""String_Node_Str"",4,count);
  siddhiManager.shutdown();
}","@Test public void testSnapshotOutputRateLimitQuery11() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiManager siddhiManager=new SiddhiManager();
  siddhiManager.defineStream(""String_Node_Str"");
  String queryReference=siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  siddhiManager.addCallback(queryReference,new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      if (inEvents != null) {
        count++;
        if (count == 1) {
          Assert.assertTrue((Long)inEvents[0].getData0() == 9l);
        }
 else         if (count == 2) {
          Assert.assertTrue((Long)inEvents[0].getData0() == 9l);
        }
 else         if (count == 3) {
          Assert.assertTrue((Long)inEvents[0].getData0() == 21l);
        }
      }
      value++;
      eventArrived=true;
    }
  }
);
  InputHandler loginSucceedEvents=siddhiManager.getInputHandler(""String_Node_Str"");
  Thread.sleep(1100);
  loginSucceedEvents.send(new Object[]{System.currentTimeMillis(),""String_Node_Str"",3});
  loginSucceedEvents.send(new Object[]{System.currentTimeMillis(),""String_Node_Str"",6});
  Thread.sleep(2200);
  loginSucceedEvents.send(new Object[]{System.currentTimeMillis(),""String_Node_Str"",2});
  loginSucceedEvents.send(new Object[]{System.currentTimeMillis(),""String_Node_Str"",10});
  Thread.sleep(1200);
  Assert.assertEquals(""String_Node_Str"",true,eventArrived);
  Assert.assertEquals(""String_Node_Str"",3,count);
  Assert.assertEquals(""String_Node_Str"",true,value > 3);
  siddhiManager.shutdown();
}",0.953931203931204
29226,"/** 
 * {@inheritDoc}<p/> <p>The default implementation returns the result of calling  {@link #visitChildren} on {@code ctx}.</p>
 * @param ctx
 */
@Override public Object visitAttribute_type(@NotNull SiddhiQLParser.Attribute_typeContext ctx){
  if (ctx.STRING() != null) {
    return Attribute.Type.STRING;
  }
 else   if (ctx.INT() != null) {
    return Attribute.Type.INT;
  }
 else   if (ctx.LONG() != null) {
    return Attribute.Type.LONG;
  }
 else   if (ctx.FLOAT() != null) {
    return Attribute.Type.FLOAT;
  }
 else   if (ctx.BOOL() != null) {
    return Attribute.Type.BOOL;
  }
 else   if (ctx.OBJECT() != null) {
    return Attribute.Type.OBJECT;
  }
 else {
    throw newSiddhiParserException(ctx);
  }
}","/** 
 * {@inheritDoc}<p/> <p>The default implementation returns the result of calling  {@link #visitChildren} on {@code ctx}.</p>
 * @param ctx
 */
@Override public Object visitAttribute_type(@NotNull SiddhiQLParser.Attribute_typeContext ctx){
  if (ctx.STRING() != null) {
    return Attribute.Type.STRING;
  }
 else   if (ctx.INT() != null) {
    return Attribute.Type.INT;
  }
 else   if (ctx.LONG() != null) {
    return Attribute.Type.LONG;
  }
 else   if (ctx.FLOAT() != null) {
    return Attribute.Type.FLOAT;
  }
 else   if (ctx.DOUBLE() != null) {
    return Attribute.Type.DOUBLE;
  }
 else   if (ctx.BOOL() != null) {
    return Attribute.Type.BOOL;
  }
 else   if (ctx.OBJECT() != null) {
    return Attribute.Type.OBJECT;
  }
 else {
    throw newSiddhiParserException(ctx);
  }
}",0.95112285336856
29227,"@Test public void testCreatingStreamDefinition2(){
  StreamDefinition streamDefinition=SiddhiCompiler.parseStreamDefinition(""String_Node_Str"");
  StreamDefinition api=StreamDefinition.id(""String_Node_Str"").attribute(""String_Node_Str"",Attribute.Type.STRING).attribute(""String_Node_Str"",Attribute.Type.INT).attribute(""String_Node_Str"",Attribute.Type.FLOAT).attribute(""String_Node_Str"",Attribute.Type.OBJECT);
  Assert.assertEquals(api,streamDefinition);
}","@Test public void testCreatingStreamDefinition2(){
  StreamDefinition streamDefinition=SiddhiCompiler.parseStreamDefinition(""String_Node_Str"");
  StreamDefinition api=StreamDefinition.id(""String_Node_Str"").attribute(""String_Node_Str"",Attribute.Type.STRING).attribute(""String_Node_Str"",Attribute.Type.INT).attribute(""String_Node_Str"",Attribute.Type.DOUBLE).attribute(""String_Node_Str"",Attribute.Type.OBJECT);
  Assert.assertEquals(api,streamDefinition);
}",0.9900771775082692
29228,"@Test public void testRegression() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiConfiguration siddhiConfiguration=new SiddhiConfiguration();
  List<Class> list=new ArrayList<Class>();
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionTransformProcessor.class);
  siddhiConfiguration.setSiddhiExtensions(list);
  SiddhiManager siddhiManager=new SiddhiManager(siddhiConfiguration);
  InputHandler inputHandler=siddhiManager.defineStream(""String_Node_Str"");
  siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  String queryReference=siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  siddhiManager.addCallback(queryReference,new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(inEvents);
      count++;
      if (inEvents[0].getData1() != null) {
        betaZero=(Double)inEvents[0].getData1();
      }
    }
  }
);
  double ci=0.95;
  inputHandler.send(new Object[]{5.49,0.00});
  inputHandler.send(new Object[]{6.79,1.00});
  inputHandler.send(new Object[]{6.46,2.00});
  inputHandler.send(new Object[]{6.24,3.00});
  inputHandler.send(new Object[]{5.05,4.00});
  inputHandler.send(new Object[]{4.92,5.00});
  inputHandler.send(new Object[]{5.64,6.00});
  inputHandler.send(new Object[]{7.33,7.00});
  inputHandler.send(new Object[]{7.55,8.00});
  inputHandler.send(new Object[]{6.87,9.00});
  inputHandler.send(new Object[]{6.20,10.00});
  inputHandler.send(new Object[]{5.79,11.00});
  inputHandler.send(new Object[]{6.56,12.00});
  inputHandler.send(new Object[]{6.71,13.00});
  inputHandler.send(new Object[]{7.41,14.00});
  inputHandler.send(new Object[]{7.97,15.00});
  inputHandler.send(new Object[]{6.51,16.00});
  inputHandler.send(new Object[]{5.95,17.00});
  inputHandler.send(new Object[]{6.40,18.00});
  inputHandler.send(new Object[]{7.88,19.00});
  inputHandler.send(new Object[]{7.92,20.00});
  Thread.sleep(1000);
  siddhiManager.shutdown();
  Assert.assertEquals(""String_Node_Str"",21,count);
  Assert.assertEquals(""String_Node_Str"",5.661764084669217,betaZero);
}","@Test public void testRegression() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiConfiguration siddhiConfiguration=new SiddhiConfiguration();
  List<Class> list=new ArrayList<Class>();
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionTransformProcessor.class);
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionForecastTransformProcessor.class);
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionOutlierTransformProcessor.class);
  siddhiConfiguration.setSiddhiExtensions(list);
  SiddhiManager siddhiManager=new SiddhiManager(siddhiConfiguration);
  InputHandler inputHandler=siddhiManager.defineStream(""String_Node_Str"");
  siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  String queryReference=siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  siddhiManager.addCallback(queryReference,new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(inEvents);
      count++;
      if (inEvents[0].getData1() != null) {
        betaZero=(Double)inEvents[0].getData1();
      }
    }
  }
);
  double ci=0.95;
  inputHandler.send(new Object[]{5.49,0.00});
  inputHandler.send(new Object[]{6.79,1.00});
  inputHandler.send(new Object[]{6.46,2.00});
  inputHandler.send(new Object[]{6.24,3.00});
  inputHandler.send(new Object[]{5.05,4.00});
  inputHandler.send(new Object[]{4.92,5.00});
  inputHandler.send(new Object[]{5.64,6.00});
  inputHandler.send(new Object[]{7.33,7.00});
  inputHandler.send(new Object[]{7.55,8.00});
  inputHandler.send(new Object[]{6.87,9.00});
  inputHandler.send(new Object[]{6.20,10.00});
  inputHandler.send(new Object[]{5.79,11.00});
  inputHandler.send(new Object[]{6.56,12.00});
  inputHandler.send(new Object[]{6.71,13.00});
  inputHandler.send(new Object[]{7.41,14.00});
  inputHandler.send(new Object[]{7.97,15.00});
  inputHandler.send(new Object[]{6.51,16.00});
  inputHandler.send(new Object[]{5.95,17.00});
  inputHandler.send(new Object[]{6.40,18.00});
  inputHandler.send(new Object[]{7.88,19.00});
  inputHandler.send(new Object[]{7.92,20.00});
  Thread.sleep(1000);
  siddhiManager.shutdown();
  Assert.assertEquals(""String_Node_Str"",21,count);
  Assert.assertEquals(""String_Node_Str"",5.661764084669217,betaZero);
}",0.9567887694669884
29229,"@Test public void testRegression() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiConfiguration siddhiConfiguration=new SiddhiConfiguration();
  List<Class> list=new ArrayList<Class>();
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionTransformProcessor.class);
  siddhiConfiguration.setSiddhiExtensions(list);
  SiddhiManager siddhiManager=new SiddhiManager(siddhiConfiguration);
  InputHandler inputHandler=siddhiManager.defineStream(""String_Node_Str"");
  siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  String queryReference=siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  siddhiManager.addCallback(queryReference,new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(inEvents);
      if (inEvents[0].getData1() != null) {
        betaZero=(Double)inEvents[0].getData1();
      }
      count++;
    }
  }
);
  double ci=0.95;
  inputHandler.send(new Object[]{3439,694224000});
  inputHandler.send(new Object[]{3264,696902400});
  inputHandler.send(new Object[]{3437,699408000});
  inputHandler.send(new Object[]{3523,702086400});
  inputHandler.send(new Object[]{3545,704678400});
  inputHandler.send(new Object[]{3611,707356800});
  inputHandler.send(new Object[]{3637,709948800});
  inputHandler.send(new Object[]{3986,712627200});
  inputHandler.send(new Object[]{3797,715305600});
  inputHandler.send(new Object[]{3758,717897600});
  inputHandler.send(new Object[]{4428,720576000});
  inputHandler.send(new Object[]{8566,723168000});
  inputHandler.send(new Object[]{3801,725846400});
  inputHandler.send(new Object[]{3204,728524800});
  inputHandler.send(new Object[]{3686,730944000});
  inputHandler.send(new Object[]{3827,733622400});
  inputHandler.send(new Object[]{3770,736214400});
  inputHandler.send(new Object[]{3923,738892800});
  inputHandler.send(new Object[]{3839,741484800});
  inputHandler.send(new Object[]{4270,744163200});
  inputHandler.send(new Object[]{3988,746841600});
  inputHandler.send(new Object[]{3920,749433600});
  inputHandler.send(new Object[]{4853,752112000});
  inputHandler.send(new Object[]{9010,754704000});
  Thread.sleep(1000);
  siddhiManager.shutdown();
  Assert.assertEquals(""String_Node_Str"",24,count);
  Assert.assertEquals(""String_Node_Str"",3795.7272727272725,betaZero);
}","@Test public void testRegression() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiConfiguration siddhiConfiguration=new SiddhiConfiguration();
  List<Class> list=new ArrayList<Class>();
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionTransformProcessor.class);
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionForecastTransformProcessor.class);
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionOutlierTransformProcessor.class);
  siddhiConfiguration.setSiddhiExtensions(list);
  SiddhiManager siddhiManager=new SiddhiManager(siddhiConfiguration);
  InputHandler inputHandler=siddhiManager.defineStream(""String_Node_Str"");
  siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  String queryReference=siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  siddhiManager.addCallback(queryReference,new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(inEvents);
      if (inEvents[0].getData1() != null) {
        betaZero=(Double)inEvents[0].getData1();
      }
      count++;
    }
  }
);
  double ci=0.95;
  inputHandler.send(new Object[]{3439,694224000});
  inputHandler.send(new Object[]{3264,696902400});
  inputHandler.send(new Object[]{3437,699408000});
  inputHandler.send(new Object[]{3523,702086400});
  inputHandler.send(new Object[]{3545,704678400});
  inputHandler.send(new Object[]{3611,707356800});
  inputHandler.send(new Object[]{3637,709948800});
  inputHandler.send(new Object[]{3986,712627200});
  inputHandler.send(new Object[]{3797,715305600});
  inputHandler.send(new Object[]{3758,717897600});
  inputHandler.send(new Object[]{4428,720576000});
  inputHandler.send(new Object[]{8566,723168000});
  inputHandler.send(new Object[]{3801,725846400});
  inputHandler.send(new Object[]{3204,728524800});
  inputHandler.send(new Object[]{3686,730944000});
  inputHandler.send(new Object[]{3827,733622400});
  inputHandler.send(new Object[]{3770,736214400});
  inputHandler.send(new Object[]{3923,738892800});
  inputHandler.send(new Object[]{3839,741484800});
  inputHandler.send(new Object[]{4270,744163200});
  inputHandler.send(new Object[]{3988,746841600});
  inputHandler.send(new Object[]{3920,749433600});
  inputHandler.send(new Object[]{4853,752112000});
  inputHandler.send(new Object[]{9010,754704000});
  Thread.sleep(1000);
  siddhiManager.shutdown();
  Assert.assertEquals(""String_Node_Str"",24,count);
  Assert.assertEquals(""String_Node_Str"",3795.7272727272725,betaZero);
}",0.9646001796945192
29230,"@Override public void receive(long timeStamp,Event[] inEvents,Event[] removeEvents){
  EventPrinter.print(timeStamp,inEvents,removeEvents);
  if (inEvents[0].getData1() != null) {
    betaZero=(Double)inEvents[0].getData2();
  }
  count++;
}","@Override public void receive(long timeStamp,Event[] inEvents,Event[] removeEvents){
  EventPrinter.print(timeStamp,inEvents,removeEvents);
  if (inEvents[0].getData1() != null) {
    betaZero=(Double)inEvents[0].getData2();
    System.out.println(""String_Node_Str"" + betaZero);
  }
  count++;
}",0.8992537313432836
29231,"@Test public void testRegression() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiConfiguration siddhiConfiguration=new SiddhiConfiguration();
  List<Class> list=new ArrayList<Class>();
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionForecastTransformProcessor.class);
  siddhiConfiguration.setSiddhiExtensions(list);
  SiddhiManager siddhiManager=new SiddhiManager(siddhiConfiguration);
  InputHandler inputHandler=siddhiManager.defineStream(""String_Node_Str"");
  String queryReference=siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  siddhiManager.addCallback(queryReference,new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      if (inEvents[0].getData1() != null) {
        betaZero=(Double)inEvents[0].getData2();
      }
      count++;
    }
  }
);
  System.out.println(System.currentTimeMillis());
  inputHandler.send(new Object[]{3300,""String_Node_Str"",31});
  inputHandler.send(new Object[]{2600,""String_Node_Str"",18});
  inputHandler.send(new Object[]{2500,""String_Node_Str"",17});
  inputHandler.send(new Object[]{2475,""String_Node_Str"",12});
  inputHandler.send(new Object[]{2313,""String_Node_Str"",8});
  inputHandler.send(new Object[]{2175,""String_Node_Str"",26});
  inputHandler.send(new Object[]{600,""String_Node_Str"",14});
  inputHandler.send(new Object[]{460,""String_Node_Str"",3});
  inputHandler.send(new Object[]{240,""String_Node_Str"",1});
  inputHandler.send(new Object[]{200,""String_Node_Str"",10});
  inputHandler.send(new Object[]{177,""String_Node_Str"",0});
  inputHandler.send(new Object[]{140,""String_Node_Str"",6});
  inputHandler.send(new Object[]{117,""String_Node_Str"",1});
  inputHandler.send(new Object[]{115,""String_Node_Str"",0});
  inputHandler.send(new Object[]{2600,""String_Node_Str"",19});
  inputHandler.send(new Object[]{1907,""String_Node_Str"",13});
  inputHandler.send(new Object[]{1190,""String_Node_Str"",3});
  inputHandler.send(new Object[]{990,""String_Node_Str"",16});
  inputHandler.send(new Object[]{925,""String_Node_Str"",6});
  inputHandler.send(new Object[]{365,""String_Node_Str"",0});
  inputHandler.send(new Object[]{302,""String_Node_Str"",10});
  inputHandler.send(new Object[]{300,""String_Node_Str"",6});
  inputHandler.send(new Object[]{129,""String_Node_Str"",2});
  inputHandler.send(new Object[]{111,""String_Node_Str"",1});
  inputHandler.send(new Object[]{6100,""String_Node_Str"",18});
  inputHandler.send(new Object[]{4125,""String_Node_Str"",19});
  inputHandler.send(new Object[]{3213,""String_Node_Str"",1});
  inputHandler.send(new Object[]{2319,""String_Node_Str"",38});
  inputHandler.send(new Object[]{2000,""String_Node_Str"",10});
  inputHandler.send(new Object[]{1600,""String_Node_Str"",0});
  inputHandler.send(new Object[]{1394,""String_Node_Str"",4});
  inputHandler.send(new Object[]{935,""String_Node_Str"",4});
  inputHandler.send(new Object[]{850,""String_Node_Str"",0});
  inputHandler.send(new Object[]{775,""String_Node_Str"",5});
  inputHandler.send(new Object[]{760,""String_Node_Str"",6});
  inputHandler.send(new Object[]{629,""String_Node_Str"",1});
  inputHandler.send(new Object[]{275,""String_Node_Str"",6});
  inputHandler.send(new Object[]{120,""String_Node_Str"",0});
  inputHandler.send(new Object[]{2567,""String_Node_Str"",12});
  inputHandler.send(new Object[]{2500,""String_Node_Str"",28});
  inputHandler.send(new Object[]{2350,""String_Node_Str"",21});
  inputHandler.send(new Object[]{2317,""String_Node_Str"",3});
  inputHandler.send(new Object[]{2000,""String_Node_Str"",12});
  inputHandler.send(new Object[]{715,""String_Node_Str"",1});
  inputHandler.send(new Object[]{660,""String_Node_Str"",9});
  inputHandler.send(new Object[]{650,""String_Node_Str"",0});
  inputHandler.send(new Object[]{260,""String_Node_Str"",0});
  inputHandler.send(new Object[]{250,""String_Node_Str"",1});
  inputHandler.send(new Object[]{200,""String_Node_Str"",13});
  inputHandler.send(new Object[]{180,""String_Node_Str"",6});
  Thread.sleep(1000);
  siddhiManager.shutdown();
  Assert.assertEquals(""String_Node_Str"",50,count);
}","@Test public void testRegression() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiConfiguration siddhiConfiguration=new SiddhiConfiguration();
  List<Class> list=new ArrayList<Class>();
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionTransformProcessor.class);
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionForecastTransformProcessor.class);
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionOutlierTransformProcessor.class);
  siddhiConfiguration.setSiddhiExtensions(list);
  SiddhiManager siddhiManager=new SiddhiManager(siddhiConfiguration);
  InputHandler inputHandler=siddhiManager.defineStream(""String_Node_Str"");
  String queryReference=siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  siddhiManager.addCallback(queryReference,new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      if (inEvents[0].getData1() != null) {
        betaZero=(Double)inEvents[0].getData2();
        System.out.println(""String_Node_Str"" + betaZero);
      }
      count++;
    }
  }
);
  System.out.println(System.currentTimeMillis());
  inputHandler.send(new Object[]{3300,""String_Node_Str"",31});
  inputHandler.send(new Object[]{2600,""String_Node_Str"",18});
  inputHandler.send(new Object[]{2500,""String_Node_Str"",17});
  inputHandler.send(new Object[]{2475,""String_Node_Str"",12});
  inputHandler.send(new Object[]{2313,""String_Node_Str"",8});
  inputHandler.send(new Object[]{2175,""String_Node_Str"",26});
  inputHandler.send(new Object[]{600,""String_Node_Str"",14});
  inputHandler.send(new Object[]{460,""String_Node_Str"",3});
  inputHandler.send(new Object[]{240,""String_Node_Str"",1});
  inputHandler.send(new Object[]{200,""String_Node_Str"",10});
  inputHandler.send(new Object[]{177,""String_Node_Str"",0});
  inputHandler.send(new Object[]{140,""String_Node_Str"",6});
  inputHandler.send(new Object[]{117,""String_Node_Str"",1});
  inputHandler.send(new Object[]{115,""String_Node_Str"",0});
  inputHandler.send(new Object[]{2600,""String_Node_Str"",19});
  inputHandler.send(new Object[]{1907,""String_Node_Str"",13});
  inputHandler.send(new Object[]{1190,""String_Node_Str"",3});
  inputHandler.send(new Object[]{990,""String_Node_Str"",16});
  inputHandler.send(new Object[]{925,""String_Node_Str"",6});
  inputHandler.send(new Object[]{365,""String_Node_Str"",0});
  inputHandler.send(new Object[]{302,""String_Node_Str"",10});
  inputHandler.send(new Object[]{300,""String_Node_Str"",6});
  inputHandler.send(new Object[]{129,""String_Node_Str"",2});
  inputHandler.send(new Object[]{111,""String_Node_Str"",1});
  inputHandler.send(new Object[]{6100,""String_Node_Str"",18});
  inputHandler.send(new Object[]{4125,""String_Node_Str"",19});
  inputHandler.send(new Object[]{3213,""String_Node_Str"",1});
  inputHandler.send(new Object[]{2319,""String_Node_Str"",38});
  inputHandler.send(new Object[]{2000,""String_Node_Str"",10});
  inputHandler.send(new Object[]{1600,""String_Node_Str"",0});
  inputHandler.send(new Object[]{1394,""String_Node_Str"",4});
  inputHandler.send(new Object[]{935,""String_Node_Str"",4});
  inputHandler.send(new Object[]{850,""String_Node_Str"",0});
  inputHandler.send(new Object[]{775,""String_Node_Str"",5});
  inputHandler.send(new Object[]{760,""String_Node_Str"",6});
  inputHandler.send(new Object[]{629,""String_Node_Str"",1});
  inputHandler.send(new Object[]{275,""String_Node_Str"",6});
  inputHandler.send(new Object[]{120,""String_Node_Str"",0});
  inputHandler.send(new Object[]{2567,""String_Node_Str"",12});
  inputHandler.send(new Object[]{2500,""String_Node_Str"",28});
  inputHandler.send(new Object[]{2350,""String_Node_Str"",21});
  inputHandler.send(new Object[]{2317,""String_Node_Str"",3});
  inputHandler.send(new Object[]{2000,""String_Node_Str"",12});
  inputHandler.send(new Object[]{715,""String_Node_Str"",1});
  inputHandler.send(new Object[]{660,""String_Node_Str"",9});
  inputHandler.send(new Object[]{650,""String_Node_Str"",0});
  inputHandler.send(new Object[]{260,""String_Node_Str"",0});
  inputHandler.send(new Object[]{250,""String_Node_Str"",1});
  inputHandler.send(new Object[]{200,""String_Node_Str"",13});
  inputHandler.send(new Object[]{180,""String_Node_Str"",6});
  Thread.sleep(1000);
  siddhiManager.shutdown();
  double delta=0;
  Assert.assertEquals(""String_Node_Str"",50,count);
  Assert.assertEquals(573.1418421169493,betaZero,delta);
}",0.9606025492468134
29232,"@Override public void receive(long timeStamp,Event[] inEvents,Event[] removeEvents){
  EventPrinter.print(timeStamp,inEvents,removeEvents);
}","@Override public void receive(long timeStamp,Event[] inEvents,Event[] removeEvents){
  EventPrinter.print(timeStamp,inEvents,removeEvents);
  count++;
  if (inEvents[0].getData1() != null) {
    betaZero=(Double)inEvents[0].getData2();
  }
}",0.7382198952879581
29233,"@Test public void testRegression() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiConfiguration siddhiConfiguration=new SiddhiConfiguration();
  List<Class> list=new ArrayList<Class>();
  list.add(LinearRegressionOutlierTransformProcessor.class);
  siddhiConfiguration.setSiddhiExtensions(list);
  SiddhiManager siddhiManager=new SiddhiManager(siddhiConfiguration);
  InputHandler inputHandler=siddhiManager.defineStream(""String_Node_Str"");
  String queryReference=siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  siddhiManager.addCallback(queryReference,new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
    }
  }
);
  System.out.println(System.currentTimeMillis());
  inputHandler.send(new Object[]{3300.00,31.00});
  inputHandler.send(new Object[]{2600.00,18.00});
  inputHandler.send(new Object[]{2500.00,17.00});
  inputHandler.send(new Object[]{2475.00,12.00});
  inputHandler.send(new Object[]{2313.00,8.00});
  inputHandler.send(new Object[]{2175.00,26.00});
  inputHandler.send(new Object[]{600.00,14.00});
  inputHandler.send(new Object[]{460.00,3.00});
  inputHandler.send(new Object[]{240.00,1.00});
  inputHandler.send(new Object[]{200.00,10.00});
  inputHandler.send(new Object[]{177.00,0.00});
  inputHandler.send(new Object[]{140.00,6.00});
  inputHandler.send(new Object[]{117.00,1.00});
  inputHandler.send(new Object[]{115.00,0.00});
  inputHandler.send(new Object[]{2600.00,19.00});
  inputHandler.send(new Object[]{1907.00,13.00});
  inputHandler.send(new Object[]{1190.00,3.00});
  inputHandler.send(new Object[]{990.00,16.00});
  inputHandler.send(new Object[]{925.00,6.00});
  inputHandler.send(new Object[]{365.00,0.00});
  inputHandler.send(new Object[]{302.00,10.00});
  inputHandler.send(new Object[]{300.00,6.00});
  inputHandler.send(new Object[]{129.00,2.00});
  inputHandler.send(new Object[]{111.00,1.00});
  inputHandler.send(new Object[]{6100.00,18.00});
  inputHandler.send(new Object[]{4125.00,19.00});
  inputHandler.send(new Object[]{3213.00,1.00});
  inputHandler.send(new Object[]{2319.00,38.00});
  inputHandler.send(new Object[]{2000.00,10.00});
  inputHandler.send(new Object[]{1600.00,0.00});
  inputHandler.send(new Object[]{1394.00,4.00});
  inputHandler.send(new Object[]{935.00,4.00});
  inputHandler.send(new Object[]{850.00,0.00});
  inputHandler.send(new Object[]{775.00,5.00});
  inputHandler.send(new Object[]{760.00,6.00});
  inputHandler.send(new Object[]{629.00,1.00});
  inputHandler.send(new Object[]{275.00,6.00});
  inputHandler.send(new Object[]{120.00,0.00});
  inputHandler.send(new Object[]{2567.00,12.00});
  inputHandler.send(new Object[]{2500.00,28.00});
  inputHandler.send(new Object[]{2350.00,21.00});
  inputHandler.send(new Object[]{2317.00,3.00});
  inputHandler.send(new Object[]{2000.00,12.00});
  inputHandler.send(new Object[]{715.00,1.00});
  inputHandler.send(new Object[]{660.00,9.00});
  inputHandler.send(new Object[]{650.00,0.00});
  inputHandler.send(new Object[]{260.00,0.00});
  inputHandler.send(new Object[]{250.00,1.00});
  inputHandler.send(new Object[]{200.00,13.00});
  inputHandler.send(new Object[]{180.00,6.00});
  Thread.sleep(1000);
  siddhiManager.shutdown();
}","@Test public void testRegression() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiConfiguration siddhiConfiguration=new SiddhiConfiguration();
  List<Class> list=new ArrayList<Class>();
  list.add(LinearRegressionOutlierTransformProcessor.class);
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionForecastTransformProcessor.class);
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionOutlierTransformProcessor.class);
  siddhiConfiguration.setSiddhiExtensions(list);
  SiddhiManager siddhiManager=new SiddhiManager(siddhiConfiguration);
  InputHandler inputHandler=siddhiManager.defineStream(""String_Node_Str"");
  String queryReference=siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  siddhiManager.addCallback(queryReference,new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      count++;
      if (inEvents[0].getData1() != null) {
        betaZero=(Double)inEvents[0].getData2();
      }
    }
  }
);
  System.out.println(System.currentTimeMillis());
  inputHandler.send(new Object[]{3300.00,31.00});
  inputHandler.send(new Object[]{2600.00,18.00});
  inputHandler.send(new Object[]{2500.00,17.00});
  inputHandler.send(new Object[]{2475.00,12.00});
  inputHandler.send(new Object[]{2313.00,8.00});
  inputHandler.send(new Object[]{2175.00,26.00});
  inputHandler.send(new Object[]{600.00,14.00});
  inputHandler.send(new Object[]{460.00,3.00});
  inputHandler.send(new Object[]{240.00,1.00});
  inputHandler.send(new Object[]{200.00,10.00});
  inputHandler.send(new Object[]{177.00,0.00});
  inputHandler.send(new Object[]{140.00,6.00});
  inputHandler.send(new Object[]{117.00,1.00});
  inputHandler.send(new Object[]{115.00,0.00});
  inputHandler.send(new Object[]{2600.00,19.00});
  inputHandler.send(new Object[]{1907.00,13.00});
  inputHandler.send(new Object[]{1190.00,3.00});
  inputHandler.send(new Object[]{990.00,16.00});
  inputHandler.send(new Object[]{925.00,6.00});
  inputHandler.send(new Object[]{365.00,0.00});
  inputHandler.send(new Object[]{302.00,10.00});
  inputHandler.send(new Object[]{300.00,6.00});
  inputHandler.send(new Object[]{129.00,2.00});
  inputHandler.send(new Object[]{111.00,1.00});
  inputHandler.send(new Object[]{6100.00,18.00});
  inputHandler.send(new Object[]{4125.00,19.00});
  inputHandler.send(new Object[]{3213.00,1.00});
  inputHandler.send(new Object[]{2319.00,38.00});
  inputHandler.send(new Object[]{2000.00,10.00});
  inputHandler.send(new Object[]{1600.00,0.00});
  inputHandler.send(new Object[]{1394.00,4.00});
  inputHandler.send(new Object[]{935.00,4.00});
  inputHandler.send(new Object[]{850.00,0.00});
  inputHandler.send(new Object[]{775.00,5.00});
  inputHandler.send(new Object[]{760.00,6.00});
  inputHandler.send(new Object[]{629.00,1.00});
  inputHandler.send(new Object[]{275.00,6.00});
  inputHandler.send(new Object[]{120.00,0.00});
  inputHandler.send(new Object[]{2567.00,12.00});
  inputHandler.send(new Object[]{2500.00,28.00});
  inputHandler.send(new Object[]{2350.00,21.00});
  inputHandler.send(new Object[]{2317.00,3.00});
  inputHandler.send(new Object[]{2000.00,12.00});
  inputHandler.send(new Object[]{715.00,1.00});
  inputHandler.send(new Object[]{660.00,9.00});
  inputHandler.send(new Object[]{650.00,0.00});
  inputHandler.send(new Object[]{260.00,0.00});
  inputHandler.send(new Object[]{250.00,1.00});
  inputHandler.send(new Object[]{200.00,13.00});
  inputHandler.send(new Object[]{180.00,6.00});
  Thread.sleep(1000);
  siddhiManager.shutdown();
  double delta=0.0;
  Assert.assertEquals(""String_Node_Str"",50,count);
  Assert.assertEquals(573.1418421169493,betaZero,delta);
}",0.9379464911051968
29234,"@Test public void testRegression() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiConfiguration siddhiConfiguration=new SiddhiConfiguration();
  List<Class> list=new ArrayList<Class>();
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionTransformProcessor.class);
  siddhiConfiguration.setSiddhiExtensions(list);
  SiddhiManager siddhiManager=new SiddhiManager(siddhiConfiguration);
  InputHandler inputHandler=siddhiManager.defineStream(""String_Node_Str"");
  String queryReference=siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  siddhiManager.addCallback(queryReference,new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      if (inEvents[0].getData1() != null) {
        betaZero=(Double)inEvents[0].getData1();
      }
      count++;
    }
  }
);
  System.out.println(System.currentTimeMillis());
  inputHandler.send(new Object[]{3300.00,31.00});
  inputHandler.send(new Object[]{2600.00,18.00});
  inputHandler.send(new Object[]{2500.00,17.00});
  inputHandler.send(new Object[]{2475.00,12.00});
  inputHandler.send(new Object[]{2313.00,8.00});
  inputHandler.send(new Object[]{2175.00,26.00});
  inputHandler.send(new Object[]{600.00,14.00});
  inputHandler.send(new Object[]{460.00,3.00});
  inputHandler.send(new Object[]{240.00,1.00});
  inputHandler.send(new Object[]{200.00,10.00});
  inputHandler.send(new Object[]{177.00,0.00});
  inputHandler.send(new Object[]{140.00,6.00});
  inputHandler.send(new Object[]{117.00,1.00});
  inputHandler.send(new Object[]{115.00,0.00});
  inputHandler.send(new Object[]{2600.00,19.00});
  inputHandler.send(new Object[]{1907.00,13.00});
  inputHandler.send(new Object[]{1190.00,3.00});
  inputHandler.send(new Object[]{990.00,16.00});
  inputHandler.send(new Object[]{925.00,6.00});
  inputHandler.send(new Object[]{365.00,0.00});
  inputHandler.send(new Object[]{302.00,10.00});
  inputHandler.send(new Object[]{300.00,6.00});
  inputHandler.send(new Object[]{129.00,2.00});
  inputHandler.send(new Object[]{111.00,1.00});
  inputHandler.send(new Object[]{6100.00,18.00});
  inputHandler.send(new Object[]{4125.00,19.00});
  inputHandler.send(new Object[]{3213.00,1.00});
  inputHandler.send(new Object[]{2319.00,38.00});
  inputHandler.send(new Object[]{2000.00,10.00});
  inputHandler.send(new Object[]{1600.00,0.00});
  inputHandler.send(new Object[]{1394.00,4.00});
  inputHandler.send(new Object[]{935.00,4.00});
  inputHandler.send(new Object[]{850.00,0.00});
  inputHandler.send(new Object[]{775.00,5.00});
  inputHandler.send(new Object[]{760.00,6.00});
  inputHandler.send(new Object[]{629.00,1.00});
  inputHandler.send(new Object[]{275.00,6.00});
  inputHandler.send(new Object[]{120.00,0.00});
  inputHandler.send(new Object[]{2567.00,12.00});
  inputHandler.send(new Object[]{2500.00,28.00});
  inputHandler.send(new Object[]{2350.00,21.00});
  inputHandler.send(new Object[]{2317.00,3.00});
  inputHandler.send(new Object[]{2000.00,12.00});
  inputHandler.send(new Object[]{715.00,1.00});
  inputHandler.send(new Object[]{660.00,9.00});
  inputHandler.send(new Object[]{650.00,0.00});
  inputHandler.send(new Object[]{260.00,0.00});
  inputHandler.send(new Object[]{250.00,1.00});
  inputHandler.send(new Object[]{200.00,13.00});
  inputHandler.send(new Object[]{180.00,6.00});
  Thread.sleep(1000);
  siddhiManager.shutdown();
}","@Test public void testRegression() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiConfiguration siddhiConfiguration=new SiddhiConfiguration();
  List<Class> list=new ArrayList<Class>();
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionTransformProcessor.class);
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionForecastTransformProcessor.class);
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionOutlierTransformProcessor.class);
  siddhiConfiguration.setSiddhiExtensions(list);
  SiddhiManager siddhiManager=new SiddhiManager(siddhiConfiguration);
  InputHandler inputHandler=siddhiManager.defineStream(""String_Node_Str"");
  String queryReference=siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  siddhiManager.addCallback(queryReference,new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      if (inEvents[0].getData1() != null) {
        betaZero=(Double)inEvents[0].getData1();
      }
      count++;
    }
  }
);
  System.out.println(System.currentTimeMillis());
  inputHandler.send(new Object[]{3300.00,31.00});
  inputHandler.send(new Object[]{2600.00,18.00});
  inputHandler.send(new Object[]{2500.00,17.00});
  inputHandler.send(new Object[]{2475.00,12.00});
  inputHandler.send(new Object[]{2313.00,8.00});
  inputHandler.send(new Object[]{2175.00,26.00});
  inputHandler.send(new Object[]{600.00,14.00});
  inputHandler.send(new Object[]{460.00,3.00});
  inputHandler.send(new Object[]{240.00,1.00});
  inputHandler.send(new Object[]{200.00,10.00});
  inputHandler.send(new Object[]{177.00,0.00});
  inputHandler.send(new Object[]{140.00,6.00});
  inputHandler.send(new Object[]{117.00,1.00});
  inputHandler.send(new Object[]{115.00,0.00});
  inputHandler.send(new Object[]{2600.00,19.00});
  inputHandler.send(new Object[]{1907.00,13.00});
  inputHandler.send(new Object[]{1190.00,3.00});
  inputHandler.send(new Object[]{990.00,16.00});
  inputHandler.send(new Object[]{925.00,6.00});
  inputHandler.send(new Object[]{365.00,0.00});
  inputHandler.send(new Object[]{302.00,10.00});
  inputHandler.send(new Object[]{300.00,6.00});
  inputHandler.send(new Object[]{129.00,2.00});
  inputHandler.send(new Object[]{111.00,1.00});
  inputHandler.send(new Object[]{6100.00,18.00});
  inputHandler.send(new Object[]{4125.00,19.00});
  inputHandler.send(new Object[]{3213.00,1.00});
  inputHandler.send(new Object[]{2319.00,38.00});
  inputHandler.send(new Object[]{2000.00,10.00});
  inputHandler.send(new Object[]{1600.00,0.00});
  inputHandler.send(new Object[]{1394.00,4.00});
  inputHandler.send(new Object[]{935.00,4.00});
  inputHandler.send(new Object[]{850.00,0.00});
  inputHandler.send(new Object[]{775.00,5.00});
  inputHandler.send(new Object[]{760.00,6.00});
  inputHandler.send(new Object[]{629.00,1.00});
  inputHandler.send(new Object[]{275.00,6.00});
  inputHandler.send(new Object[]{120.00,0.00});
  inputHandler.send(new Object[]{2567.00,12.00});
  inputHandler.send(new Object[]{2500.00,28.00});
  inputHandler.send(new Object[]{2350.00,21.00});
  inputHandler.send(new Object[]{2317.00,3.00});
  inputHandler.send(new Object[]{2000.00,12.00});
  inputHandler.send(new Object[]{715.00,1.00});
  inputHandler.send(new Object[]{660.00,9.00});
  inputHandler.send(new Object[]{650.00,0.00});
  inputHandler.send(new Object[]{260.00,0.00});
  inputHandler.send(new Object[]{250.00,1.00});
  inputHandler.send(new Object[]{200.00,13.00});
  inputHandler.send(new Object[]{180.00,6.00});
  Thread.sleep(1000);
  siddhiManager.shutdown();
}",0.972589397523306
29235,"@Override protected void init(Expression[] parameters,List<ExpressionExecutor> expressionExecutors,StreamDefinition inStreamDefinition,StreamDefinition outStreamDefinition,String elementId,SiddhiContext siddhiContext){
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + inStreamDefinition.toString());
  }
  if (parameters[0] instanceof IntConstant) {
    try {
      calcInterval=((IntConstant)parameters[0]).getValue();
      batchSize=((IntConstant)parameters[1]).getValue();
    }
 catch (    ClassCastException c) {
      throw new QueryCreationException(""String_Node_Str"");
    }
    try {
      ci=((DoubleConstant)parameters[2]).getValue();
    }
 catch (    ClassCastException c) {
      throw new QueryCreationException(""String_Node_Str"");
    }
    exp=expressionExecutors.get(3);
    for (int i=4; i < parameters.length; i++) {
      if (parameters[i] instanceof Variable) {
        Variable var=(Variable)parameters[i];
        String attributeName=var.getAttributeName();
        paramPositions.put(inStreamDefinition.getAttributePosition(attributeName),attributeName);
        paramCount++;
      }
    }
  }
 else {
    exp=expressionExecutors.get(0);
    for (int i=1; i < parameters.length; i++) {
      if (parameters[i] instanceof Variable) {
        Variable var=(Variable)parameters[i];
        String attributeName=var.getAttributeName();
        paramPositions.put(inStreamDefinition.getAttributePosition(attributeName),attributeName);
        paramCount++;
      }
    }
  }
  if (paramCount > SIMPLE_LINREG_INPUT_PARAM_COUNT) {
    throw new QueryCreationException(""String_Node_Str"");
  }
 else {
    regressionCalculator=new SimpleLinearRegressionCalculator(paramCount,calcInterval,batchSize,ci);
  }
  if (outStreamDefinition == null) {
    this.outStreamDefinition=new StreamDefinition().name(""String_Node_Str"");
    this.outStreamDefinition.attribute(""String_Node_Str"",Attribute.Type.DOUBLE);
    this.outStreamDefinition.attribute(""String_Node_Str"",Attribute.Type.DOUBLE);
    this.outStreamDefinition.attribute(""String_Node_Str"",Attribute.Type.DOUBLE);
    this.outStreamDefinition.attribute(""String_Node_Str"",Attribute.Type.DOUBLE);
    for (    Attribute strDef : inStreamDefinition.getAttributeList()) {
      this.outStreamDefinition.attribute(strDef.getName(),strDef.getType());
    }
  }
}","@Override protected void init(Expression[] parameters,List<ExpressionExecutor> expressionExecutors,StreamDefinition inStreamDefinition,StreamDefinition outStreamDefinition,String elementId,SiddhiContext siddhiContext){
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + inStreamDefinition.toString());
  }
  if (parameters[1] instanceof IntConstant) {
    try {
      calcInterval=((IntConstant)parameters[0]).getValue();
      batchSize=((IntConstant)parameters[1]).getValue();
    }
 catch (    ClassCastException c) {
      throw new QueryCreationException(""String_Node_Str"");
    }
    try {
      ci=((DoubleConstant)parameters[2]).getValue();
    }
 catch (    ClassCastException c) {
      throw new QueryCreationException(""String_Node_Str"");
    }
    exp=expressionExecutors.get(3);
    for (int i=4; i < parameters.length; i++) {
      if (parameters[i] instanceof Variable) {
        Variable var=(Variable)parameters[i];
        String attributeName=var.getAttributeName();
        paramPositions.put(inStreamDefinition.getAttributePosition(attributeName),attributeName);
        paramCount++;
      }
    }
  }
 else {
    exp=expressionExecutors.get(0);
    for (int i=1; i < parameters.length; i++) {
      if (parameters[i] instanceof Variable) {
        Variable var=(Variable)parameters[i];
        String attributeName=var.getAttributeName();
        paramPositions.put(inStreamDefinition.getAttributePosition(attributeName),attributeName);
        paramCount++;
      }
    }
  }
  if (paramCount > SIMPLE_LINREG_INPUT_PARAM_COUNT) {
    throw new QueryCreationException(""String_Node_Str"");
  }
 else {
    regressionCalculator=new SimpleLinearRegressionCalculator(paramCount,calcInterval,batchSize,ci);
  }
  if (outStreamDefinition == null) {
    this.outStreamDefinition=new StreamDefinition().name(""String_Node_Str"");
    this.outStreamDefinition.attribute(""String_Node_Str"",Attribute.Type.DOUBLE);
    this.outStreamDefinition.attribute(""String_Node_Str"",Attribute.Type.DOUBLE);
    this.outStreamDefinition.attribute(""String_Node_Str"",Attribute.Type.DOUBLE);
    this.outStreamDefinition.attribute(""String_Node_Str"",Attribute.Type.DOUBLE);
    for (    Attribute strDef : inStreamDefinition.getAttributeList()) {
      this.outStreamDefinition.attribute(strDef.getName(),strDef.getType());
    }
  }
}",0.9995726495726496
29236,"@Test public void testRegression() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiConfiguration siddhiConfiguration=new SiddhiConfiguration();
  List<Class> list=new ArrayList<Class>();
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionTransformProcessor.class);
  siddhiConfiguration.setSiddhiExtensions(list);
  SiddhiManager siddhiManager=new SiddhiManager(siddhiConfiguration);
  InputHandler inputHandler=siddhiManager.defineStream(""String_Node_Str"");
  String queryReference=siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  siddhiManager.addCallback(queryReference,new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(inEvents);
      if (inEvents[0].getData2() != null) {
        betaOne=(Double)inEvents[0].getData2();
      }
      count++;
    }
  }
);
  System.out.println(System.currentTimeMillis());
  inputHandler.send(new Object[]{3300,104,22,80,3});
  inputHandler.send(new Object[]{2600,66,39,69,3});
  inputHandler.send(new Object[]{2500,73,63,116,5});
  inputHandler.send(new Object[]{2475,50,23,64,21});
  inputHandler.send(new Object[]{2313,58,70,53,8});
  inputHandler.send(new Object[]{2175,100,87,89,4});
  inputHandler.send(new Object[]{600,38,15,45,10});
  inputHandler.send(new Object[]{460,21,11,32,3});
  inputHandler.send(new Object[]{240,18,24,26,2});
  inputHandler.send(new Object[]{200,33,14,96,6});
  inputHandler.send(new Object[]{177,10,5,18,7});
  inputHandler.send(new Object[]{140,22,19,56,3});
  inputHandler.send(new Object[]{117,3,2,1,0});
  inputHandler.send(new Object[]{115,2,4,3,0});
  inputHandler.send(new Object[]{2600,75,53,64,7});
  inputHandler.send(new Object[]{1907,73,50,100,14});
  inputHandler.send(new Object[]{1190,26,42,61,8});
  inputHandler.send(new Object[]{990,64,42,102,6});
  inputHandler.send(new Object[]{925,26,22,26,5});
  inputHandler.send(new Object[]{365,15,14,30,6});
  inputHandler.send(new Object[]{302,51,95,151,27});
  inputHandler.send(new Object[]{300,39,34,89,6});
  inputHandler.send(new Object[]{129,18,20,22,5});
  inputHandler.send(new Object[]{111,8,1,18,0});
  inputHandler.send(new Object[]{6100,100,90,67,15});
  inputHandler.send(new Object[]{4125,96,55,74,7});
  inputHandler.send(new Object[]{3213,17,39,47,3});
  inputHandler.send(new Object[]{2319,117,78,120,31});
  inputHandler.send(new Object[]{2000,40,36,56,4});
  inputHandler.send(new Object[]{1600,31,50,69,15});
  inputHandler.send(new Object[]{1394,51,83,50,5});
  inputHandler.send(new Object[]{935,21,30,42,3});
  inputHandler.send(new Object[]{850,54,75,38,20});
  inputHandler.send(new Object[]{775,35,9,19,3});
  inputHandler.send(new Object[]{760,36,40,53,14});
  inputHandler.send(new Object[]{629,30,24,43,0});
  inputHandler.send(new Object[]{275,34,33,57,8});
  inputHandler.send(new Object[]{120,5,14,19,2});
  inputHandler.send(new Object[]{2567,42,41,66,8});
  inputHandler.send(new Object[]{2500,81,48,93,5});
  inputHandler.send(new Object[]{2350,92,67,100,3});
  inputHandler.send(new Object[]{2317,12,37,20,4});
  inputHandler.send(new Object[]{2000,40,12,57,9});
  inputHandler.send(new Object[]{715,11,16,36,3});
  inputHandler.send(new Object[]{660,49,14,49,9});
  inputHandler.send(new Object[]{650,15,30,30,4});
  inputHandler.send(new Object[]{260,12,13,14,0});
  inputHandler.send(new Object[]{250,11,2,26,2});
  inputHandler.send(new Object[]{200,50,31,73,3});
  inputHandler.send(new Object[]{180,21,17,26,8});
  Thread.sleep(1000);
  siddhiManager.shutdown();
  Assert.assertEquals(""String_Node_Str"",50,count);
  Assert.assertEquals(""String_Node_Str"",34.31099818995623,betaOne);
}","@Test public void testRegression() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiConfiguration siddhiConfiguration=new SiddhiConfiguration();
  List<Class> list=new ArrayList<Class>();
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionTransformProcessor.class);
  siddhiConfiguration.setSiddhiExtensions(list);
  SiddhiManager siddhiManager=new SiddhiManager(siddhiConfiguration);
  InputHandler inputHandler=siddhiManager.defineStream(""String_Node_Str"");
  String queryReference=siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  siddhiManager.addCallback(queryReference,new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(inEvents);
      if (inEvents[0].getData2() != null) {
        betaOne=(Double)inEvents[0].getData2();
      }
      count++;
    }
  }
);
  System.out.println(System.currentTimeMillis());
  inputHandler.send(new Object[]{3300,104,22,80,3});
  inputHandler.send(new Object[]{2600,66,39,69,3});
  inputHandler.send(new Object[]{2500,73,63,116,5});
  inputHandler.send(new Object[]{2475,50,23,64,21});
  inputHandler.send(new Object[]{2313,58,70,53,8});
  inputHandler.send(new Object[]{2175,100,87,89,4});
  inputHandler.send(new Object[]{600,38,15,45,10});
  inputHandler.send(new Object[]{460,21,11,32,3});
  inputHandler.send(new Object[]{240,18,24,26,2});
  inputHandler.send(new Object[]{200,33,14,96,6});
  inputHandler.send(new Object[]{177,10,5,18,7});
  inputHandler.send(new Object[]{140,22,19,56,3});
  inputHandler.send(new Object[]{117,3,2,1,0});
  inputHandler.send(new Object[]{115,2,4,3,0});
  inputHandler.send(new Object[]{2600,75,53,64,7});
  inputHandler.send(new Object[]{1907,73,50,100,14});
  inputHandler.send(new Object[]{1190,26,42,61,8});
  inputHandler.send(new Object[]{990,64,42,102,6});
  inputHandler.send(new Object[]{925,26,22,26,5});
  inputHandler.send(new Object[]{365,15,14,30,6});
  inputHandler.send(new Object[]{302,51,95,151,27});
  inputHandler.send(new Object[]{300,39,34,89,6});
  inputHandler.send(new Object[]{129,18,20,22,5});
  inputHandler.send(new Object[]{111,8,1,18,0});
  inputHandler.send(new Object[]{6100,100,90,67,15});
  inputHandler.send(new Object[]{4125,96,55,74,7});
  inputHandler.send(new Object[]{3213,17,39,47,3});
  inputHandler.send(new Object[]{2319,117,78,120,31});
  inputHandler.send(new Object[]{2000,40,36,56,4});
  inputHandler.send(new Object[]{1600,31,50,69,15});
  inputHandler.send(new Object[]{1394,51,83,50,5});
  inputHandler.send(new Object[]{935,21,30,42,3});
  inputHandler.send(new Object[]{850,54,75,38,20});
  inputHandler.send(new Object[]{775,35,9,19,3});
  inputHandler.send(new Object[]{760,36,40,53,14});
  inputHandler.send(new Object[]{629,30,24,43,0});
  inputHandler.send(new Object[]{275,34,33,57,8});
  inputHandler.send(new Object[]{120,5,14,19,2});
  inputHandler.send(new Object[]{2567,42,41,66,8});
  inputHandler.send(new Object[]{2500,81,48,93,5});
  inputHandler.send(new Object[]{2350,92,67,100,3});
  inputHandler.send(new Object[]{2317,12,37,20,4});
  inputHandler.send(new Object[]{2000,40,12,57,9});
  inputHandler.send(new Object[]{715,11,16,36,3});
  inputHandler.send(new Object[]{660,49,14,49,9});
  inputHandler.send(new Object[]{650,15,30,30,4});
  inputHandler.send(new Object[]{260,12,13,14,0});
  inputHandler.send(new Object[]{250,11,2,26,2});
  inputHandler.send(new Object[]{200,50,31,73,3});
  inputHandler.send(new Object[]{180,21,17,26,8});
  Thread.sleep(1000);
  siddhiManager.shutdown();
  Assert.assertEquals(""String_Node_Str"",50,count);
  Assert.assertEquals(""String_Node_Str"",34.42398117538763,betaOne);
}",0.9940971290582238
29237,"@Override public void receive(long timeStamp,Event[] inEvents,Event[] removeEvents){
  EventPrinter.print(timeStamp,inEvents,removeEvents);
}","@Override public void receive(long timeStamp,Event[] inEvents,Event[] removeEvents){
  EventPrinter.print(timeStamp,inEvents,removeEvents);
  if (inEvents[0].getData1() != null) {
    betaZero=(Double)inEvents[0].getData2();
  }
  count++;
}",0.7382198952879581
29238,"@Test public void testRegression() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiConfiguration siddhiConfiguration=new SiddhiConfiguration();
  List<Class> list=new ArrayList<Class>();
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionForecastTransformProcessor.class);
  siddhiConfiguration.setSiddhiExtensions(list);
  SiddhiManager siddhiManager=new SiddhiManager(siddhiConfiguration);
  InputHandler inputHandler=siddhiManager.defineStream(""String_Node_Str"");
  String queryReference=siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  siddhiManager.addCallback(queryReference,new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
    }
  }
);
  System.out.println(System.currentTimeMillis());
  inputHandler.send(new Object[]{3300,""String_Node_Str"",31});
  inputHandler.send(new Object[]{2600,""String_Node_Str"",18});
  inputHandler.send(new Object[]{2500,""String_Node_Str"",17});
  inputHandler.send(new Object[]{2475,""String_Node_Str"",12});
  inputHandler.send(new Object[]{2313,""String_Node_Str"",8});
  inputHandler.send(new Object[]{2175,""String_Node_Str"",26});
  inputHandler.send(new Object[]{600,""String_Node_Str"",14});
  inputHandler.send(new Object[]{460,""String_Node_Str"",3});
  inputHandler.send(new Object[]{240,""String_Node_Str"",1});
  inputHandler.send(new Object[]{200,""String_Node_Str"",10});
  inputHandler.send(new Object[]{177,""String_Node_Str"",0});
  inputHandler.send(new Object[]{140,""String_Node_Str"",6});
  inputHandler.send(new Object[]{117,""String_Node_Str"",1});
  inputHandler.send(new Object[]{115,""String_Node_Str"",0});
  inputHandler.send(new Object[]{2600,""String_Node_Str"",19});
  inputHandler.send(new Object[]{1907,""String_Node_Str"",13});
  inputHandler.send(new Object[]{1190,""String_Node_Str"",3});
  inputHandler.send(new Object[]{990,""String_Node_Str"",16});
  inputHandler.send(new Object[]{925,""String_Node_Str"",6});
  inputHandler.send(new Object[]{365,""String_Node_Str"",0});
  inputHandler.send(new Object[]{302,""String_Node_Str"",10});
  inputHandler.send(new Object[]{300,""String_Node_Str"",6});
  inputHandler.send(new Object[]{129,""String_Node_Str"",2});
  inputHandler.send(new Object[]{111,""String_Node_Str"",1});
  inputHandler.send(new Object[]{6100,""String_Node_Str"",18});
  inputHandler.send(new Object[]{4125,""String_Node_Str"",19});
  inputHandler.send(new Object[]{3213,""String_Node_Str"",1});
  inputHandler.send(new Object[]{2319,""String_Node_Str"",38});
  inputHandler.send(new Object[]{2000,""String_Node_Str"",10});
  inputHandler.send(new Object[]{1600,""String_Node_Str"",0});
  inputHandler.send(new Object[]{1394,""String_Node_Str"",4});
  inputHandler.send(new Object[]{935,""String_Node_Str"",4});
  inputHandler.send(new Object[]{850,""String_Node_Str"",0});
  inputHandler.send(new Object[]{775,""String_Node_Str"",5});
  inputHandler.send(new Object[]{760,""String_Node_Str"",6});
  inputHandler.send(new Object[]{629,""String_Node_Str"",1});
  inputHandler.send(new Object[]{275,""String_Node_Str"",6});
  inputHandler.send(new Object[]{120,""String_Node_Str"",0});
  inputHandler.send(new Object[]{2567,""String_Node_Str"",12});
  inputHandler.send(new Object[]{2500,""String_Node_Str"",28});
  inputHandler.send(new Object[]{2350,""String_Node_Str"",21});
  inputHandler.send(new Object[]{2317,""String_Node_Str"",3});
  inputHandler.send(new Object[]{2000,""String_Node_Str"",12});
  inputHandler.send(new Object[]{715,""String_Node_Str"",1});
  inputHandler.send(new Object[]{660,""String_Node_Str"",9});
  inputHandler.send(new Object[]{650,""String_Node_Str"",0});
  inputHandler.send(new Object[]{260,""String_Node_Str"",0});
  inputHandler.send(new Object[]{250,""String_Node_Str"",1});
  inputHandler.send(new Object[]{200,""String_Node_Str"",13});
  inputHandler.send(new Object[]{180,""String_Node_Str"",6});
  Thread.sleep(1000);
  siddhiManager.shutdown();
}","@Test public void testRegression() throws InterruptedException {
  log.info(""String_Node_Str"");
  SiddhiConfiguration siddhiConfiguration=new SiddhiConfiguration();
  List<Class> list=new ArrayList<Class>();
  list.add(org.wso2.siddhi.extension.timeseries.LinearRegressionForecastTransformProcessor.class);
  siddhiConfiguration.setSiddhiExtensions(list);
  SiddhiManager siddhiManager=new SiddhiManager(siddhiConfiguration);
  InputHandler inputHandler=siddhiManager.defineStream(""String_Node_Str"");
  String queryReference=siddhiManager.addQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  siddhiManager.addCallback(queryReference,new QueryCallback(){
    @Override public void receive(    long timeStamp,    Event[] inEvents,    Event[] removeEvents){
      EventPrinter.print(timeStamp,inEvents,removeEvents);
      if (inEvents[0].getData1() != null) {
        betaZero=(Double)inEvents[0].getData2();
      }
      count++;
    }
  }
);
  System.out.println(System.currentTimeMillis());
  inputHandler.send(new Object[]{3300,""String_Node_Str"",31});
  inputHandler.send(new Object[]{2600,""String_Node_Str"",18});
  inputHandler.send(new Object[]{2500,""String_Node_Str"",17});
  inputHandler.send(new Object[]{2475,""String_Node_Str"",12});
  inputHandler.send(new Object[]{2313,""String_Node_Str"",8});
  inputHandler.send(new Object[]{2175,""String_Node_Str"",26});
  inputHandler.send(new Object[]{600,""String_Node_Str"",14});
  inputHandler.send(new Object[]{460,""String_Node_Str"",3});
  inputHandler.send(new Object[]{240,""String_Node_Str"",1});
  inputHandler.send(new Object[]{200,""String_Node_Str"",10});
  inputHandler.send(new Object[]{177,""String_Node_Str"",0});
  inputHandler.send(new Object[]{140,""String_Node_Str"",6});
  inputHandler.send(new Object[]{117,""String_Node_Str"",1});
  inputHandler.send(new Object[]{115,""String_Node_Str"",0});
  inputHandler.send(new Object[]{2600,""String_Node_Str"",19});
  inputHandler.send(new Object[]{1907,""String_Node_Str"",13});
  inputHandler.send(new Object[]{1190,""String_Node_Str"",3});
  inputHandler.send(new Object[]{990,""String_Node_Str"",16});
  inputHandler.send(new Object[]{925,""String_Node_Str"",6});
  inputHandler.send(new Object[]{365,""String_Node_Str"",0});
  inputHandler.send(new Object[]{302,""String_Node_Str"",10});
  inputHandler.send(new Object[]{300,""String_Node_Str"",6});
  inputHandler.send(new Object[]{129,""String_Node_Str"",2});
  inputHandler.send(new Object[]{111,""String_Node_Str"",1});
  inputHandler.send(new Object[]{6100,""String_Node_Str"",18});
  inputHandler.send(new Object[]{4125,""String_Node_Str"",19});
  inputHandler.send(new Object[]{3213,""String_Node_Str"",1});
  inputHandler.send(new Object[]{2319,""String_Node_Str"",38});
  inputHandler.send(new Object[]{2000,""String_Node_Str"",10});
  inputHandler.send(new Object[]{1600,""String_Node_Str"",0});
  inputHandler.send(new Object[]{1394,""String_Node_Str"",4});
  inputHandler.send(new Object[]{935,""String_Node_Str"",4});
  inputHandler.send(new Object[]{850,""String_Node_Str"",0});
  inputHandler.send(new Object[]{775,""String_Node_Str"",5});
  inputHandler.send(new Object[]{760,""String_Node_Str"",6});
  inputHandler.send(new Object[]{629,""String_Node_Str"",1});
  inputHandler.send(new Object[]{275,""String_Node_Str"",6});
  inputHandler.send(new Object[]{120,""String_Node_Str"",0});
  inputHandler.send(new Object[]{2567,""String_Node_Str"",12});
  inputHandler.send(new Object[]{2500,""String_Node_Str"",28});
  inputHandler.send(new Object[]{2350,""String_Node_Str"",21});
  inputHandler.send(new Object[]{2317,""String_Node_Str"",3});
  inputHandler.send(new Object[]{2000,""String_Node_Str"",12});
  inputHandler.send(new Object[]{715,""String_Node_Str"",1});
  inputHandler.send(new Object[]{660,""String_Node_Str"",9});
  inputHandler.send(new Object[]{650,""String_Node_Str"",0});
  inputHandler.send(new Object[]{260,""String_Node_Str"",0});
  inputHandler.send(new Object[]{250,""String_Node_Str"",1});
  inputHandler.send(new Object[]{200,""String_Node_Str"",13});
  inputHandler.send(new Object[]{180,""String_Node_Str"",6});
  Thread.sleep(1000);
  siddhiManager.shutdown();
  Assert.assertEquals(""String_Node_Str"",50,count);
}",0.9792408794988332
29239,"@Override public boolean contains(AtomicEvent atomicEvent,ConditionExecutor conditionExecutor){
  PredicateTreeNode predicate=null;
  if (bloomFiltersEnabled) {
    predicate=conditionExecutor.constructPredicate(atomicEvent,tableDefinition,new SQLPredicateBuilder());
    ArrayList tokenList=new ArrayList();
    predicate.populateTokens(tokenList);
    for (int ops=1; ops < tokenList.size() - 1; ops++) {
      if (tokenList.get(ops).toString().startsWith(""String_Node_Str"") && tokenList.get(ops).toString().replaceFirst(""String_Node_Str"",""String_Node_Str"").trim().equals(""String_Node_Str"")) {
        String param=tokenList.get(ops - 1).toString();
        String value=tokenList.get(ops + 1).toString();
        if (!param.startsWith(""String_Node_Str"")) {
          param=value.replaceFirst(""String_Node_Str"",""String_Node_Str"").trim();
          value=tokenList.get(ops - 1).toString().replaceFirst(""String_Node_Str"",""String_Node_Str"").trim();
        }
 else {
          param=param.replaceFirst(""String_Node_Str"",""String_Node_Str"").trim();
          value=value.replaceFirst(""String_Node_Str"",""String_Node_Str"").trim();
        }
        for (int i=0; i < attributeList.size(); i++) {
          if (attributeList.get(i).getName().equals(param)) {
            boolean mightContain=bloomFilters[i].mightContain(value.getBytes());
            if (!mightContain) {
              return false;
            }
          }
        }
      }
    }
  }
  if ((cachedTable != null) && cachedTable.contains(atomicEvent,conditionExecutor)) {
    return true;
  }
 else {
    Connection con=null;
    PreparedStatement statement=null;
    try {
      if (predicate == null) {
        predicate=conditionExecutor.constructPredicate(atomicEvent,tableDefinition,new SQLPredicateBuilder());
      }
      con=dataSource.getConnection();
      statement=con.prepareStatement(""String_Node_Str"" + fullTableName + ""String_Node_Str""+ predicate.buildPredicateString()+ ""String_Node_Str"");
      ArrayList paramList=new ArrayList();
      predicate.populateParameters(paramList);
      for (int i=0; i < paramList.size(); i++) {
        populateStatement(statement,i + 1,paramList.get(i));
      }
      ResultSet resultSet=statement.executeQuery();
      boolean contains=false;
      long timestamp=System.currentTimeMillis();
      while (resultSet.next()) {
        contains=true;
        if (cachedTable != null) {
          Object[] data=new Object[attributeList.size()];
          for (int i=0; i < attributeList.size(); i++) {
switch (attributeList.get(i).getType()) {
case BOOL:
              data[i]=resultSet.getBoolean(attributeList.get(i).getName());
            break;
case DOUBLE:
          data[i]=resultSet.getDouble(attributeList.get(i).getName());
        break;
case FLOAT:
      data[i]=resultSet.getFloat(attributeList.get(i).getName());
    break;
case INT:
  data[i]=resultSet.getInt(attributeList.get(i).getName());
break;
case LONG:
data[i]=resultSet.getLong(attributeList.get(i).getName());
break;
case STRING:
data[i]=resultSet.getString(attributeList.get(i).getName());
break;
default :
data[i]=resultSet.getObject(attributeList.get(i).getName());
}
}
Event event=new InEvent(tableDefinition.getExternalTable().getParameter(PARAM_TABLE_NAME),timestamp,data);
cachedTable.add(event);
}
 else {
break;
}
}
resultSet.close();
return contains;
}
 catch (SQLException e) {
log.error(""String_Node_Str"" + tableDefinition.getExternalTable().getParameter(PARAM_TABLE_NAME),e);
}
 finally {
cleanUpConnections(statement,con);
}
return false;
}
}","@Override public boolean contains(AtomicEvent atomicEvent,ConditionExecutor conditionExecutor){
  PredicateTreeNode predicate=null;
  if (bloomFiltersEnabled) {
    predicate=conditionExecutor.constructPredicate(atomicEvent,tableDefinition,new SQLPredicateBuilder());
    ArrayList tokenList=new ArrayList();
    predicate.populateTokens(tokenList);
    for (int ops=1; ops < tokenList.size() - 1; ops++) {
      if (tokenList.get(ops).toString().startsWith(""String_Node_Str"") && tokenList.get(ops).toString().replaceFirst(""String_Node_Str"",""String_Node_Str"").trim().equals(""String_Node_Str"")) {
        String param=tokenList.get(ops - 1).toString();
        String value=tokenList.get(ops + 1).toString();
        if (!param.startsWith(""String_Node_Str"")) {
          param=value.replaceFirst(""String_Node_Str"",""String_Node_Str"").trim();
          value=tokenList.get(ops - 1).toString().replaceFirst(""String_Node_Str"",""String_Node_Str"").trim();
        }
 else {
          param=param.replaceFirst(""String_Node_Str"",""String_Node_Str"").trim();
          value=value.replaceFirst(""String_Node_Str"",""String_Node_Str"").trim();
        }
        for (int i=0; i < attributeList.size(); i++) {
          if (attributeList.get(i).getName().equals(param)) {
            boolean mightContain=bloomFilters[i].mightContain(value.getBytes());
            if (!mightContain) {
              return false;
            }
          }
        }
      }
    }
  }
  if ((cachedTable != null) && cachedTable.contains(atomicEvent,conditionExecutor)) {
    return true;
  }
 else {
    Connection con=null;
    PreparedStatement statement=null;
    try {
      if (predicate == null) {
        predicate=conditionExecutor.constructPredicate(atomicEvent,tableDefinition,new SQLPredicateBuilder());
      }
      if (dataSource != null) {
        con=dataSource.getConnection();
        statement=con.prepareStatement(""String_Node_Str"" + fullTableName + ""String_Node_Str""+ predicate.buildPredicateString()+ ""String_Node_Str"");
        ArrayList paramList=new ArrayList();
        predicate.populateParameters(paramList);
        for (int i=0; i < paramList.size(); i++) {
          populateStatement(statement,i + 1,paramList.get(i));
        }
        ResultSet resultSet=statement.executeQuery();
        boolean contains=false;
        long timestamp=System.currentTimeMillis();
        while (resultSet.next()) {
          contains=true;
          if (cachedTable != null) {
            Object[] data=new Object[attributeList.size()];
            for (int i=0; i < attributeList.size(); i++) {
switch (attributeList.get(i).getType()) {
case BOOL:
                data[i]=resultSet.getBoolean(attributeList.get(i).getName());
              break;
case DOUBLE:
            data[i]=resultSet.getDouble(attributeList.get(i).getName());
          break;
case FLOAT:
        data[i]=resultSet.getFloat(attributeList.get(i).getName());
      break;
case INT:
    data[i]=resultSet.getInt(attributeList.get(i).getName());
  break;
case LONG:
data[i]=resultSet.getLong(attributeList.get(i).getName());
break;
case STRING:
data[i]=resultSet.getString(attributeList.get(i).getName());
break;
default :
data[i]=resultSet.getObject(attributeList.get(i).getName());
}
}
Event event=new InEvent(tableDefinition.getExternalTable().getParameter(PARAM_TABLE_NAME),timestamp,data);
cachedTable.add(event);
}
 else {
break;
}
}
resultSet.close();
return contains;
}
 else {
log.error(""String_Node_Str"");
return false;
}
}
 catch (SQLException e) {
log.error(""String_Node_Str"" + tableDefinition.getExternalTable().getParameter(PARAM_TABLE_NAME),e);
}
 finally {
cleanUpConnections(statement,con);
}
return false;
}
}",0.9772978959025472
29240,"public static String getWrongAddressErrorMessage(final long address,final long fileSize){
  final long fileAddress=address - (address % (fileSize * 1024L));
  return ""String_Node_Str"" + address + ""String_Node_Str""+ getLogFilename(fileAddress);
}","public static String getWrongAddressErrorMessage(final long address,final long fileLengthBound){
  final long fileAddress=address - (address % fileLengthBound);
  return ""String_Node_Str"" + address + ""String_Node_Str""+ getLogFilename(fileAddress);
}",0.9068825910931174
29241,"public void setHighAddress(long highAddress){
  allocLastPage(log.getHighPageAddress(highAddress));
  this.highAddress=highAddress;
}","public void setHighAddress(long highAddress){
  allocLastPage(highAddress - (((int)highAddress) & (log.getCachePageSize() - 1)));
  this.highAddress=highAddress;
}",0.7432432432432432
29242,"@NotNull protected byte[] readFullPage(Log log,long pageAddress){
  final byte[] page=allocPage();
  final int bytesRead=log.readBytes(page,pageAddress);
  if (bytesRead != pageSize) {
    throw new ExodusException(""String_Node_Str"" + log.getLocation() + ""String_Node_Str""+ pageAddress+ ""String_Node_Str""+ bytesRead);
  }
  return page;
}","@NotNull protected byte[] readFullPage(Log log,long pageAddress){
  final byte[] page=allocPage();
  final int bytesRead=log.readBytes(page,pageAddress);
  if (bytesRead != pageSize) {
    throw new ExodusException(""String_Node_Str"" + log.getLocation() + ""String_Node_Str""+ pageAddress+ ""String_Node_Str""+ LogUtil.getLogFilename(log.getFileAddress(pageAddress))+ ""String_Node_Str""+ (pageAddress % log.getFileLengthBound())+ ""String_Node_Str""+ bytesRead);
  }
  return page;
}",0.8314883148831488
29243,"/** 
 * @return nothing since unconditionally throws {@link UnsupportedOperationException}.
 * @throws UnsupportedOperationException
 */
@Override public byte[] getBytesUnsafe(){
  throw new UnsupportedOperationException();
}","/** 
 * @return nothing since unconditionally throws {@link UnsupportedOperationException}.
 * @throws UnsupportedOperationException always since this operation is unsupported
 */
@Override public byte[] getBytesUnsafe(){
  throw new UnsupportedOperationException();
}",0.9127789046653144
29244,"/** 
 * @return nothing since unconditionally throws {@link UnsupportedOperationException}.
 * @throws UnsupportedOperationException
 */
@Override public byte[] getBytesUnsafe(){
  throw new UnsupportedOperationException();
}","/** 
 * @return nothing since unconditionally throws {@link UnsupportedOperationException}.
 * @throws UnsupportedOperationException always since this operation is unsupported
 */
@Override public byte[] getBytesUnsafe(){
  throw new UnsupportedOperationException();
}",0.9127789046653144
29245,"/** 
 * Backup postprocessing procedure. E.g.,   {@link jetbrains.exodus.env.Environment} turns database GC on after backup.
 * @throws Exception
 */
public void afterBackup() throws Exception {
}","/** 
 * Backup postprocessing procedure. E.g.,   {@link jetbrains.exodus.env.Environment} turns database GC on after backup.
 * @throws Exception if something went wrong
 */
public void afterBackup() throws Exception {
}",0.9423076923076924
29246,"/** 
 * Backup pre-processing procedure. E.g.,   {@link jetbrains.exodus.env.Environment} turns database GC off before backup.
 * @throws Exception
 */
public void beforeBackup() throws Exception {
}","/** 
 * Backup pre-processing procedure. E.g.,   {@link jetbrains.exodus.env.Environment} turns database GC off before backup.
 * @throws Exception if something went wrong
 */
public void beforeBackup() throws Exception {
}",0.943127962085308
29247,"/** 
 * Returns string content of blob identified by specified blob handle. String contents cache is used.
 * @param blobHandle blob handle
 * @param txn        {@linkplain Transaction} instance
 * @return string content of blob identified by specified blob handle
 * @throws IOException
 */
@Nullable public final String getStringContent(final long blobHandle,@NotNull final Transaction txn) throws IOException {
  String result;
  result=stringContentCache.tryKey(this,blobHandle);
  if (result == null) {
    final InputStream content=getContent(blobHandle,txn);
    result=content == null ? null : UTFUtil.readUTF(content);
    if (result != null && result.length() <= config.getBlobStringsCacheMaxValueSize()) {
      if (stringContentCache.getObject(this,blobHandle) == null) {
        stringContentCache.cacheObject(this,blobHandle,result);
      }
    }
  }
  return result;
}","/** 
 * Returns string content of blob identified by specified blob handle. String contents cache is used.
 * @param blobHandle blob handle
 * @param txn        {@linkplain Transaction} instance
 * @return string content of blob identified by specified blob handle
 * @throws IOException if something went wrong
 */
@Nullable public final String getStringContent(final long blobHandle,@NotNull final Transaction txn) throws IOException {
  String result;
  result=stringContentCache.tryKey(this,blobHandle);
  if (result == null) {
    final InputStream content=getContent(blobHandle,txn);
    result=content == null ? null : UTFUtil.readUTF(content);
    if (result != null && result.length() <= config.getBlobStringsCacheMaxValueSize()) {
      if (stringContentCache.getObject(this,blobHandle) == null) {
        stringContentCache.cacheObject(this,blobHandle,result);
      }
    }
  }
  return result;
}",0.9866071428571428
29248,"/** 
 * Target cascade delete association target entity
 * @return
 */
boolean getTargetCascadeDelete();",boolean getTargetCascadeDelete();,0.4817518248175182
29249,"/** 
 * Target remove association with target on entity delete
 * @return
 */
boolean getTargetClearOnDelete();",boolean getTargetClearOnDelete();,0.4583333333333333
29250,"/** 
 * Cascade delete association target entity
 * @return
 */
boolean getCascadeDelete();",boolean getCascadeDelete();,0.4576271186440678
29251,"/** 
 * Remove association with target on entity delete
 * @return
 */
boolean getClearOnDelete();",boolean getClearOnDelete();,0.432
29252,"/** 
 * Own indexes only
 * @return
 */
@NotNull Set<Index> getOwnIndexes();","/** 
 * Own indexes only
 * @return set of own indices
 */
@NotNull Set<Index> getOwnIndexes();",0.8888888888888888
29253,"/** 
 * Indexes for given field, including inheritors
 * @return
 */
@NotNull Set<Index> getIndexes(String field);","/** 
 * Indexes for given field, including inheritors
 * @return set of indices for given field
 */
@NotNull Set<Index> getIndexes(String field);",0.8803088803088803
29254,"/** 
 * For backward compatibility
 * @param ends
 */
public void setAssociationEnds(@NotNull Collection<AssociationEndMetaData> ends){
  externalAssociationEnds=new HashSet<>();
  externalAssociationEnds.addAll(ends);
}","public void setAssociationEnds(@NotNull Collection<AssociationEndMetaData> ends){
  externalAssociationEnds=new HashSet<>();
  externalAssociationEnds.addAll(ends);
}",0.8601036269430051
29255,"public void setEntityMetaDatas(@NotNull Set<EntityMetaData> entityMetaDatas){
  this.entityMetaDatas=entityMetaDatas;
  for (  EntityMetaData emd : entityMetaDatas) {
    ((EntityMetaDataImpl)emd).setModelMetaData(this);
  }
}","public void setEntityMetaDatas(@NotNull Set<EntityMetaData> entityMetaDatas){
  this.entityMetaDatas.clear();
  this.entityMetaDatas.addAll(entityMetaDatas);
  for (  EntityMetaData emd : entityMetaDatas) {
    ((EntityMetaDataImpl)emd).setModelMetaData(this);
  }
}",0.8536585365853658
29256,"private static void reclaim(@NotNull final PatriciaReclaimSourceTraverser source,@NotNull final PatriciaReclaimActualTraverser actual){
  final NodeBase actualNode=actual.currentNode;
  final NodeBase sourceNode=source.currentNode;
  if (actualNode.getAddress() == sourceNode.getAddress()) {
    actual.currentNode=actualNode.getMutableCopy(actual.mainTree);
    actual.getItr();
    actual.wasReclaim=true;
    reclaimActualChildren(source,actual);
  }
 else {
    @NotNull ByteIterator srcItr=sourceNode.keySequence.iterator();
    @NotNull ByteIterator actItr=actualNode.keySequence.iterator();
    int srcPushes=0;
    int actPushes=0;
    while (true) {
      if (srcItr.hasNext()) {
        if (actItr.hasNext()) {
          if (srcItr.next() != actItr.next()) {
            break;
          }
        }
 else {
          final NodeChildrenIterator children=actual.currentNode.getChildren(srcItr.next());
          final ChildReference child=children.getNode();
          if (child == null) {
            break;
          }
          actual.currentChild=child;
          actual.currentIterator=children;
          actual.moveDown();
          ++actPushes;
          actItr=actual.currentNode.keySequence.iterator();
        }
      }
 else       if (actItr.hasNext()) {
        final NodeChildrenIterator children=sourceNode.getChildren(actItr.next());
        final ChildReference child=children.getNode();
        if (child == null || !source.isAddressReclaimable(child.suffixAddress)) {
          break;
        }
        source.currentChild=child;
        source.currentIterator=children;
        source.moveDown();
        ++srcPushes;
        srcItr=sourceNode.keySequence.iterator();
      }
 else {
        reclaimChildren(source,actual);
        break;
      }
    }
    for (int i=0; i < srcPushes; ++i) {
      source.moveUp();
    }
    for (int i=0; i < actPushes; ++i) {
      actual.popAndMutate();
    }
  }
}","private static void reclaim(@NotNull final PatriciaReclaimSourceTraverser source,@NotNull final PatriciaReclaimActualTraverser actual){
  final NodeBase actualNode=actual.currentNode;
  final NodeBase sourceNode=source.currentNode;
  if (actualNode.getAddress() == sourceNode.getAddress()) {
    actual.currentNode=actualNode.getMutableCopy(actual.mainTree);
    actual.getItr();
    actual.wasReclaim=true;
    reclaimActualChildren(source,actual);
  }
 else {
    @NotNull ByteIterator srcItr=sourceNode.keySequence.iterator();
    @NotNull ByteIterator actItr=actualNode.keySequence.iterator();
    int srcPushes=0;
    int actPushes=0;
    while (true) {
      if (srcItr.hasNext()) {
        if (actItr.hasNext()) {
          if (srcItr.next() != actItr.next()) {
            break;
          }
        }
 else {
          final NodeChildrenIterator children=actual.currentNode.getChildren(srcItr.next());
          final ChildReference child=children.getNode();
          if (child == null) {
            break;
          }
          actual.currentChild=child;
          actual.currentIterator=children;
          actual.moveDown();
          ++actPushes;
          actItr=actual.currentNode.keySequence.iterator();
        }
      }
 else       if (actItr.hasNext()) {
        final NodeChildrenIterator children=source.currentNode.getChildren(actItr.next());
        final ChildReference child=children.getNode();
        if (child == null || !source.isAddressReclaimable(child.suffixAddress)) {
          break;
        }
        source.currentChild=child;
        source.currentIterator=children;
        source.moveDown();
        ++srcPushes;
        srcItr=source.currentNode.keySequence.iterator();
      }
 else {
        reclaimChildren(source,actual);
        break;
      }
    }
    for (int i=0; i < srcPushes; ++i) {
      source.moveUp();
    }
    for (int i=0; i < actPushes; ++i) {
      actual.popAndMutate();
    }
  }
}",0.995874161939144
29257,"private static <V>ObjectCacheBase<PropertyId,V> createObjectCache(final int size){
  return size == 0 ? new FakeObjectCache<PropertyId,V>() : new ObjectCacheDecorator<PropertyId,V>(size){
    @Override protected ObjectCacheBase<PropertyId,V> createdDecorated(){
      return new ObjectCache<PropertyId,V>(size());
    }
  }
;
}","private static <V>ObjectCacheBase<PropertyId,V> createObjectCache(final int size){
  return size == 0 ? new FakeObjectCache<PropertyId,V>() : new TransactionObjectCache<V>(size);
}",0.6824457593688363
29258,"@Override protected ObjectCacheBase<PropertyId,V> createdDecorated(){
  return new ObjectCache<PropertyId,V>(size());
}","@Override protected ObjectCacheBase<PropertyId,V> createdDecorated(){
  return new ObjectCache<>(size());
}",0.9469026548672568
29259,"public final void close(){
  if (cacheAdjuster != null) {
    SharedTimer.unregisterPeriodicTask(cacheAdjuster);
  }
}","public void close(){
  if (cacheAdjuster != null) {
    SharedTimer.unregisterPeriodicTask(cacheAdjuster);
  }
}",0.9739130434782608
29260,"@NotNull public static File backup(@NotNull final Backupable target,@NotNull final File backupRoot,@Nullable final String backupNamePrefix,final boolean zip) throws Exception {
  final BackupStrategy strategy=target.getBackupStrategy();
  if (!backupRoot.exists() && !backupRoot.mkdirs()) {
    throw new IOException(""String_Node_Str"" + backupRoot.getAbsolutePath());
  }
  final File backupFile;
  try {
    strategy.beforeBackup();
    final ArchiveOutputStream archive;
    if (zip) {
      final String fileName=getTimeStampedZipFileName();
      backupFile=new File(backupRoot,backupNamePrefix == null ? fileName : backupNamePrefix + fileName);
      final ZipArchiveOutputStream zipArchive=new ZipArchiveOutputStream(new BufferedOutputStream(new FileOutputStream(backupFile)));
      zipArchive.setLevel(Deflater.BEST_COMPRESSION);
      archive=zipArchive;
    }
 else {
      final String fileName=getTimeStampedTarGzFileName();
      backupFile=new File(backupRoot,backupNamePrefix == null ? fileName : backupNamePrefix + fileName);
      archive=new TarArchiveOutputStream(new GZIPOutputStream(new BufferedOutputStream(new FileOutputStream(backupFile)),0x1000));
    }
    for (    final BackupStrategy.FileDescriptor fd : strategy.listFiles()) {
      final File file=fd.getFile();
      if (file.isFile()) {
        final long fileSize=Math.min(file.length(),strategy.acceptFile(file));
        if (fileSize > 0L) {
          archiveFile(archive,fd.getPath(),file,fileSize);
        }
      }
    }
    archive.close();
    log.info(""String_Node_Str"" + backupFile.getName() + ""String_Node_Str"");
  }
  finally {
    strategy.afterBackup();
  }
  return backupFile;
}","@NotNull public static File backup(@NotNull final Backupable target,@NotNull final File backupRoot,@Nullable final String backupNamePrefix,final boolean zip) throws Exception {
  final BackupStrategy strategy=target.getBackupStrategy();
  if (!backupRoot.exists() && !backupRoot.mkdirs()) {
    throw new IOException(""String_Node_Str"" + backupRoot.getAbsolutePath());
  }
  final File backupFile;
  strategy.beforeBackup();
  try {
    final ArchiveOutputStream archive;
    if (zip) {
      final String fileName=getTimeStampedZipFileName();
      backupFile=new File(backupRoot,backupNamePrefix == null ? fileName : backupNamePrefix + fileName);
      final ZipArchiveOutputStream zipArchive=new ZipArchiveOutputStream(new BufferedOutputStream(new FileOutputStream(backupFile)));
      zipArchive.setLevel(Deflater.BEST_COMPRESSION);
      archive=zipArchive;
    }
 else {
      final String fileName=getTimeStampedTarGzFileName();
      backupFile=new File(backupRoot,backupNamePrefix == null ? fileName : backupNamePrefix + fileName);
      archive=new TarArchiveOutputStream(new GZIPOutputStream(new BufferedOutputStream(new FileOutputStream(backupFile)),0x1000));
    }
    for (    final BackupStrategy.FileDescriptor fd : strategy.listFiles()) {
      final File file=fd.getFile();
      if (file.isFile()) {
        final long fileSize=Math.min(file.length(),strategy.acceptFile(file));
        if (fileSize > 0L) {
          archiveFile(archive,fd.getPath(),file,fileSize);
        }
      }
    }
    archive.close();
    log.info(""String_Node_Str"" + backupFile.getName() + ""String_Node_Str"");
  }
 catch (  Throwable t) {
    strategy.onError(t);
    throw ExodusException.toExodusException(t,""String_Node_Str"");
  }
 finally {
    strategy.afterBackup();
  }
  return backupFile;
}",0.9444284480276418
29261,"private static String consistentShuffle(String alphabet,String salt){
  if (salt.length() <= 0)   return alphabet;
  int asc_val, j;
  char tmp;
  for (int i=alphabet.length() - 1, v=0, p=0; i > 0; i--, v++) {
    v%=salt.length();
    asc_val=(int)salt.charAt(v);
    p+=asc_val;
    j=(asc_val + v + p) % i;
    tmp=alphabet.charAt(j);
    alphabet=alphabet.substring(0,j) + alphabet.charAt(i) + alphabet.substring(j + 1);
    alphabet=alphabet.substring(0,i) + tmp + alphabet.substring(i + 1);
  }
  return alphabet;
}","private static String consistentShuffle(String alphabet,String salt){
  if (salt.length() <= 0)   return alphabet;
  int asc_val, j;
  char[] tmp_arr=alphabet.toCharArray();
  for (int i=tmp_arr.length - 1, v=0, p=0; i > 0; i--, v++) {
    v%=salt.length();
    asc_val=(int)salt.charAt(v);
    p+=asc_val;
    j=(asc_val + v + p) % i;
    char tmp=tmp_arr[j];
    tmp_arr[j]=tmp_arr[i];
    tmp_arr[i]=tmp;
  }
  return new String(tmp_arr);
}",0.6286307053941909
29262,"/** 
 * Encrypt numbers to string
 * @param numbers the numbers to encrypt
 * @return the encrypt string
 */
public String encode(long... numbers){
  for (  long number : numbers) {
    if (number > MAX_NUMBER) {
      throw new IllegalArgumentException(""String_Node_Str"" + MAX_NUMBER + ""String_Node_Str"");
    }
  }
  if (numbers.length == 0) {
    return ""String_Node_Str"";
  }
  return this._encode(numbers);
}","/** 
 * Encrypt numbers to string
 * @param numbers the numbers to encrypt
 * @return the encrypt string
 */
public String encode(long... numbers){
  if (numbers.length == 0) {
    return ""String_Node_Str"";
  }
  for (  long number : numbers) {
    if (number < 0) {
      return ""String_Node_Str"";
    }
    if (number > MAX_NUMBER) {
      throw new IllegalArgumentException(""String_Node_Str"" + MAX_NUMBER + ""String_Node_Str"");
    }
  }
  return this._encode(numbers);
}",0.7313769751693002
29263,"/** 
 * Encrypt hexa to string
 * @param hexa the hexa to encrypt
 * @return the encrypt string
 */
public String encodeHex(String hexa){
  if (!hexa.matches(""String_Node_Str"")) {
    return ""String_Node_Str"";
  }
  final List<Long> matched=new ArrayList<Long>();
  final Matcher matcher=Pattern.compile(""String_Node_Str"").matcher(hexa);
  while (matcher.find()) {
    matched.add(Long.parseLong(""String_Node_Str"" + matcher.group(),16));
  }
  final long[] result=new long[matched.size()];
  for (int i=0; i < matched.size(); i++) {
    result[i]=matched.get(i);
  }
  return this._encode(result);
}","/** 
 * Encrypt hexa to string
 * @param hexa the hexa to encrypt
 * @return the encrypt string
 */
public String encodeHex(String hexa){
  if (!hexa.matches(""String_Node_Str"")) {
    return ""String_Node_Str"";
  }
  final List<Long> matched=new ArrayList<Long>();
  final Matcher matcher=Pattern.compile(""String_Node_Str"").matcher(hexa);
  while (matcher.find()) {
    matched.add(Long.parseLong(""String_Node_Str"" + matcher.group(),16));
  }
  final long[] result=new long[matched.size()];
  for (int i=0; i < matched.size(); i++) {
    result[i]=matched.get(i);
  }
  return this.encode(result);
}",0.9991645781119464
29264,"/** 
 * Decrypt string to numbers
 * @param hash the encrypt string
 * @return decryped numbers
 */
public long[] decode(String hash){
  if (hash.isEmpty()) {
    return new long[0];
  }
  return this._decode(hash,this.alphabet);
}","/** 
 * Decrypt string to numbers
 * @param hash the encrypt string
 * @return decryped numbers
 */
public long[] decode(String hash){
  if (hash.isEmpty()) {
    return new long[0];
  }
  String validChars=this.alphabet + this.guards + this.seps;
  for (int i=0; i < hash.length(); i++) {
    if (validChars.indexOf(hash.charAt(i)) == -1) {
      return new long[0];
    }
  }
  return this._decode(hash,this.alphabet);
}",0.7075038284839203
29265,"private long[] _decode(String hash,String alphabet){
  final ArrayList<Long> ret=new ArrayList<Long>();
  int i=0;
  final String regexp=""String_Node_Str"" + this.guards + ""String_Node_Str"";
  String hashBreakdown=hash.replaceAll(regexp,""String_Node_Str"");
  String[] hashArray=hashBreakdown.split(""String_Node_Str"");
  if (hashArray.length == 3 || hashArray.length == 2) {
    i=1;
  }
  if (hashArray.length > 0) {
    hashBreakdown=hashArray[i];
    if (!hashBreakdown.isEmpty()) {
      final char lottery=hashBreakdown.charAt(0);
      hashBreakdown=hashBreakdown.substring(1);
      hashBreakdown=hashBreakdown.replaceAll(""String_Node_Str"" + this.seps + ""String_Node_Str"",""String_Node_Str"");
      hashArray=hashBreakdown.split(""String_Node_Str"");
      String subHash, buffer;
      for (      final String aHashArray : hashArray) {
        subHash=aHashArray;
        buffer=lottery + this.salt + alphabet;
        alphabet=Hashids.consistentShuffle(alphabet,buffer.substring(0,alphabet.length()));
        ret.add(Hashids.unhash(subHash,alphabet));
      }
    }
  }
  long[] arr=new long[ret.size()];
  for (int k=0; k < arr.length; k++) {
    arr[k]=ret.get(k);
  }
  if (!this._encode(arr).equals(hash)) {
    arr=new long[0];
  }
  return arr;
}","private long[] _decode(String hash,String alphabet){
  final ArrayList<Long> ret=new ArrayList<Long>();
  int i=0;
  final String regexp=""String_Node_Str"" + this.guards + ""String_Node_Str"";
  String hashBreakdown=hash.replaceAll(regexp,""String_Node_Str"");
  String[] hashArray=hashBreakdown.split(""String_Node_Str"");
  if (hashArray.length == 3 || hashArray.length == 2) {
    i=1;
  }
  if (hashArray.length > 0) {
    hashBreakdown=hashArray[i];
    if (!hashBreakdown.isEmpty()) {
      final char lottery=hashBreakdown.charAt(0);
      hashBreakdown=hashBreakdown.substring(1);
      hashBreakdown=hashBreakdown.replaceAll(""String_Node_Str"" + this.seps + ""String_Node_Str"",""String_Node_Str"");
      hashArray=hashBreakdown.split(""String_Node_Str"");
      String subHash, buffer;
      for (      final String aHashArray : hashArray) {
        subHash=aHashArray;
        buffer=lottery + this.salt + alphabet;
        alphabet=Hashids.consistentShuffle(alphabet,buffer.substring(0,alphabet.length()));
        ret.add(Hashids.unhash(subHash,alphabet));
      }
    }
  }
  long[] arr=new long[ret.size()];
  for (int k=0; k < arr.length; k++) {
    arr[k]=ret.get(k);
  }
  if (!this.encode(arr).equals(hash)) {
    arr=new long[0];
  }
  return arr;
}",0.9996020692399522
29266,"private String _encode(long... numbers){
  long numberHashInt=0;
  for (int i=0; i < numbers.length; i++) {
    numberHashInt+=(numbers[i] % (i + 100));
  }
  String alphabet=this.alphabet;
  char ret=alphabet.charAt((int)(numberHashInt % alphabet.length()));
  long num;
  long sepsIndex, guardIndex;
  String buffer;
  StringBuilder ret_strB=new StringBuilder(minHashLength);
  ret_strB.append(ret);
  char guard;
  for (int i=0; i < numbers.length; i++) {
    num=numbers[i];
    buffer=ret + this.salt + alphabet;
    alphabet=Hashids.consistentShuffle(alphabet,buffer.substring(0,alphabet.length()));
    String last=Hashids.hash(num,alphabet);
    ret_strB.append(last);
    if (i + 1 < numbers.length) {
      num%=((int)last.charAt(0) + i);
      sepsIndex=(int)(num % this.seps.length());
      ret_strB.append(this.seps.charAt((int)sepsIndex));
    }
  }
  String ret_str=ret_strB.toString();
  if (ret_str.length() < this.minHashLength) {
    guardIndex=(numberHashInt + (int)(ret_str.charAt(0))) % this.guards.length();
    guard=this.guards.charAt((int)guardIndex);
    ret_str=guard + ret_str;
    if (ret_str.length() < this.minHashLength) {
      guardIndex=(numberHashInt + (int)(ret_str.charAt(2))) % this.guards.length();
      guard=this.guards.charAt((int)guardIndex);
      ret_str+=guard;
    }
  }
  int halfLen=alphabet.length() / 2;
  while (ret_str.length() < this.minHashLength) {
    alphabet=Hashids.consistentShuffle(alphabet,alphabet);
    ret_str=alphabet.substring(halfLen) + ret_str + alphabet.substring(0,halfLen);
    int excess=ret_str.length() - this.minHashLength;
    if (excess > 0) {
      int start_pos=excess / 2;
      ret_str=ret_str.substring(start_pos,start_pos + this.minHashLength);
    }
  }
  return ret_str;
}","private String _encode(long... numbers){
  long numberHashInt=0;
  for (int i=0; i < numbers.length; i++) {
    numberHashInt+=(numbers[i] % (i + 100));
  }
  String alphabet=this.alphabet;
  char ret=alphabet.charAt((int)(numberHashInt % alphabet.length()));
  long num;
  long sepsIndex, guardIndex;
  String buffer;
  StringBuilder ret_strB=new StringBuilder(minHashLength);
  ret_strB.append(ret);
  char guard;
  for (int i=0; i < numbers.length; i++) {
    num=numbers[i];
    buffer=ret + this.salt + alphabet;
    alphabet=Hashids.consistentShuffle(alphabet,buffer.substring(0,alphabet.length()));
    String last=Hashids.hash(num,alphabet);
    ret_strB.append(last);
    if (i + 1 < numbers.length) {
      if (last.length() > 0) {
        num%=((int)last.charAt(0) + i);
        sepsIndex=(int)(num % this.seps.length());
      }
 else {
        sepsIndex=0;
      }
      ret_strB.append(this.seps.charAt((int)sepsIndex));
    }
  }
  String ret_str=ret_strB.toString();
  if (ret_str.length() < this.minHashLength) {
    guardIndex=(numberHashInt + (int)(ret_str.charAt(0))) % this.guards.length();
    guard=this.guards.charAt((int)guardIndex);
    ret_str=guard + ret_str;
    if (ret_str.length() < this.minHashLength) {
      guardIndex=(numberHashInt + (int)(ret_str.charAt(2))) % this.guards.length();
      guard=this.guards.charAt((int)guardIndex);
      ret_str+=guard;
    }
  }
  int halfLen=alphabet.length() / 2;
  while (ret_str.length() < this.minHashLength) {
    alphabet=Hashids.consistentShuffle(alphabet,alphabet);
    ret_str=alphabet.substring(halfLen) + ret_str + alphabet.substring(0,halfLen);
    int excess=ret_str.length() - this.minHashLength;
    if (excess > 0) {
      int start_pos=excess / 2;
      ret_str=ret_str.substring(start_pos,start_pos + this.minHashLength);
    }
  }
  return ret_str;
}",0.9778147531891292
29267,"private static String hash(long input,String alphabet){
  String hash=""String_Node_Str"";
  int alphabetLen=alphabet.length();
  do {
    hash=alphabet.charAt((int)(input % alphabetLen)) + hash;
    input/=alphabetLen;
  }
 while (input > 0);
  return hash;
}","private static String hash(long input,String alphabet){
  String hash=""String_Node_Str"";
  int alphabetLen=alphabet.length();
  do {
    int index=(int)(input % alphabetLen);
    if (index >= 0 && index < alphabet.length()) {
      hash=alphabet.charAt(index) + hash;
    }
    input/=alphabetLen;
  }
 while (input > 0);
  return hash;
}",0.7080536912751678
29268,"private long[] _decode(String hash,String alphabet){
  ArrayList<Long> ret=new ArrayList<Long>();
  int i=0;
  String regexp=""String_Node_Str"" + this.guards + ""String_Node_Str"";
  String hashBreakdown=hash.replaceAll(regexp,""String_Node_Str"");
  String[] hashArray=hashBreakdown.split(""String_Node_Str"");
  if (hashArray.length == 3 || hashArray.length == 2) {
    i=1;
  }
  hashBreakdown=hashArray[i];
  if (!hashBreakdown.isEmpty()) {
    char lottery=hashBreakdown.charAt(0);
    hashBreakdown=hashBreakdown.substring(1);
    hashBreakdown=hashBreakdown.replaceAll(""String_Node_Str"" + this.seps + ""String_Node_Str"",""String_Node_Str"");
    hashArray=hashBreakdown.split(""String_Node_Str"");
    String subHash, buffer;
    for (    String aHashArray : hashArray) {
      subHash=aHashArray;
      buffer=lottery + this.salt + alphabet;
      alphabet=Hashids.consistentShuffle(alphabet,buffer.substring(0,alphabet.length()));
      ret.add(Hashids.unhash(subHash,alphabet));
    }
  }
  long[] arr=new long[ret.size()];
  for (int k=0; k < arr.length; k++) {
    arr[k]=ret.get(k);
  }
  if (!this._encode(arr).equals(hash)) {
    arr=new long[0];
  }
  return arr;
}","private long[] _decode(String hash,String alphabet){
  ArrayList<Long> ret=new ArrayList<Long>();
  int i=0;
  String regexp=""String_Node_Str"" + this.guards + ""String_Node_Str"";
  String hashBreakdown=hash.replaceAll(regexp,""String_Node_Str"");
  String[] hashArray=hashBreakdown.split(""String_Node_Str"");
  if (hashArray.length == 3 || hashArray.length == 2) {
    i=1;
  }
  if (hashArray.length > 0) {
    hashBreakdown=hashArray[i];
    if (!hashBreakdown.isEmpty()) {
      char lottery=hashBreakdown.charAt(0);
      hashBreakdown=hashBreakdown.substring(1);
      hashBreakdown=hashBreakdown.replaceAll(""String_Node_Str"" + this.seps + ""String_Node_Str"",""String_Node_Str"");
      hashArray=hashBreakdown.split(""String_Node_Str"");
      String subHash, buffer;
      for (      String aHashArray : hashArray) {
        subHash=aHashArray;
        buffer=lottery + this.salt + alphabet;
        alphabet=Hashids.consistentShuffle(alphabet,buffer.substring(0,alphabet.length()));
        ret.add(Hashids.unhash(subHash,alphabet));
      }
    }
  }
  long[] arr=new long[ret.size()];
  for (int k=0; k < arr.length; k++) {
    arr[k]=ret.get(k);
  }
  if (!this._encode(arr).equals(hash)) {
    arr=new long[0];
  }
  return arr;
}",0.9691923397169026
29269,"/** 
 * Encrypt numbers to string
 * @param numbers the numbers to encrypt
 * @return the encrypt string
 */
public String encode(long... numbers){
  if (numbers.length == 0) {
    return ""String_Node_Str"";
  }
  for (  long number : numbers) {
    if (number < 0) {
      return ""String_Node_Str"";
    }
    if (number > MAX_NUMBER) {
      throw new IllegalArgumentException(""String_Node_Str"" + MAX_NUMBER + ""String_Node_Str"");
    }
  }
  return this._encode(numbers);
}","/** 
 * Encrypt numbers to string
 * @param numbers the numbers to encrypt
 * @return the encrypt string
 */
public String encode(long... numbers){
  if (numbers.length == 0) {
    return ""String_Node_Str"";
  }
  for (  long number : numbers) {
    if (number < 0) {
      return ""String_Node_Str"";
    }
    if (number > MAX_NUMBER) {
      throw new IllegalArgumentException(""String_Node_Str"" + MAX_NUMBER + ""String_Node_Str"");
    }
    if (number < 0) {
      return ""String_Node_Str"";
    }
  }
  return this._encode(numbers);
}",0.9403578528827038
29270,"@Test public void test_issue30(){
  String expected=""String_Node_Str"", res;
  long num_to_hash=-1L;
  Hashids a=new Hashids(""String_Node_Str"");
  res=a.encode(num_to_hash);
  Assert.assertEquals(expected,res);
}","@Test public void test_issue30(){
}",0.2845528455284553
29271,"private String _encode(long... numbers){
  int numberHashInt=0;
  for (int i=0; i < numbers.length; i++) {
    numberHashInt+=(numbers[i] % (i + 100));
  }
  String alphabet=this.alphabet;
  char ret=alphabet.charAt(numberHashInt % alphabet.length());
  long num;
  int sepsIndex, guardIndex;
  String buffer;
  StringBuilder ret_strB=new StringBuilder(minHashLength);
  ret_strB.append(ret);
  char guard;
  for (int i=0; i < numbers.length; i++) {
    num=numbers[i];
    buffer=ret + this.salt + alphabet;
    alphabet=Hashids.consistentShuffle(alphabet,buffer.substring(0,alphabet.length()));
    String last=Hashids.hash(num,alphabet);
    ret_strB.append(last);
    if (i + 1 < numbers.length) {
      num%=((int)last.charAt(0) + i);
      sepsIndex=(int)(num % this.seps.length());
      ret_strB.append(this.seps.charAt(sepsIndex));
    }
  }
  String ret_str=ret_strB.toString();
  if (ret_str.length() < this.minHashLength) {
    guardIndex=(numberHashInt + (int)(ret_str.charAt(0))) % this.guards.length();
    guard=this.guards.charAt(guardIndex);
    ret_str=guard + ret_str;
    if (ret_str.length() < this.minHashLength) {
      guardIndex=(numberHashInt + (int)(ret_str.charAt(2))) % this.guards.length();
      guard=this.guards.charAt(guardIndex);
      ret_str+=guard;
    }
  }
  int halfLen=alphabet.length() / 2;
  while (ret_str.length() < this.minHashLength) {
    alphabet=Hashids.consistentShuffle(alphabet,alphabet);
    ret_str=alphabet.substring(halfLen) + ret_str + alphabet.substring(0,halfLen);
    int excess=ret_str.length() - this.minHashLength;
    if (excess > 0) {
      int start_pos=excess / 2;
      ret_str=ret_str.substring(start_pos,start_pos + this.minHashLength);
    }
  }
  return ret_str;
}","private String _encode(long... numbers){
  long numberHashInt=0;
  for (int i=0; i < numbers.length; i++) {
    numberHashInt+=(numbers[i] % (i + 100));
  }
  String alphabet=this.alphabet;
  char ret=alphabet.charAt((int)(numberHashInt % alphabet.length()));
  long num;
  long sepsIndex, guardIndex;
  String buffer;
  StringBuilder ret_strB=new StringBuilder(minHashLength);
  ret_strB.append(ret);
  char guard;
  for (int i=0; i < numbers.length; i++) {
    num=numbers[i];
    buffer=ret + this.salt + alphabet;
    alphabet=Hashids.consistentShuffle(alphabet,buffer.substring(0,alphabet.length()));
    String last=Hashids.hash(num,alphabet);
    ret_strB.append(last);
    if (i + 1 < numbers.length) {
      num%=((int)last.charAt(0) + i);
      sepsIndex=(int)(num % this.seps.length());
      ret_strB.append(this.seps.charAt((int)sepsIndex));
    }
  }
  String ret_str=ret_strB.toString();
  if (ret_str.length() < this.minHashLength) {
    guardIndex=(numberHashInt + (int)(ret_str.charAt(0))) % this.guards.length();
    guard=this.guards.charAt((int)guardIndex);
    ret_str=guard + ret_str;
    if (ret_str.length() < this.minHashLength) {
      guardIndex=(numberHashInt + (int)(ret_str.charAt(2))) % this.guards.length();
      guard=this.guards.charAt((int)guardIndex);
      ret_str+=guard;
    }
  }
  int halfLen=alphabet.length() / 2;
  while (ret_str.length() < this.minHashLength) {
    alphabet=Hashids.consistentShuffle(alphabet,alphabet);
    ret_str=alphabet.substring(halfLen) + ret_str + alphabet.substring(0,halfLen);
    int excess=ret_str.length() - this.minHashLength;
    if (excess > 0) {
      int start_pos=excess / 2;
      ret_str=ret_str.substring(start_pos,start_pos + this.minHashLength);
    }
  }
  return ret_str;
}",0.9897201599086236
29272,"/** 
 * @deprecated should use encodeHex() since v1.0
 */
@Deprecated public String encryptHex(String hexa){
  return encodeHex(hexa);
}","/** 
 * @deprecated should use encodeHex() since v1.0
 */
@Deprecated @SuppressWarnings(""String_Node_Str"") public String encryptHex(String hexa){
  return encodeHex(hexa);
}",0.8802588996763754
29273,"/** 
 * Encrypt numbers to string
 * @param numbers the numbers to encrypt
 * @return the encrypt string
 */
public String encode(long... numbers){
  for (int i=0; i < numbers.length; i++) {
    if (numbers[i] > 9007199254740992L) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  String retval=""String_Node_Str"";
  if (numbers.length == 0) {
    return retval;
  }
  return this._encode(numbers);
}","/** 
 * Encrypt numbers to string
 * @param numbers the numbers to encrypt
 * @return the encrypt string
 */
public String encode(long... numbers){
  for (  long number : numbers) {
    if (number > 9007199254740992L) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  String retval=""String_Node_Str"";
  if (numbers.length == 0) {
    return retval;
  }
  return this._encode(numbers);
}",0.9293413173652696
29274,"/** 
 * Get version
 * @return version
 */
public String getVersion(){
  return ""String_Node_Str"";
}","/** 
 * Get version
 * @return version
 */
@SuppressWarnings(""String_Node_Str"") public String getVersion(){
  return ""String_Node_Str"";
}",0.8438818565400844
29275,"public Hashids(String salt,int minHashLength,String alphabet){
  this.salt=salt;
  if (minHashLength < 0)   this.minHashLength=0;
 else   this.minHashLength=minHashLength;
  this.alphabet=alphabet;
  String uniqueAlphabet=""String_Node_Str"";
  for (int i=0; i < this.alphabet.length(); i++) {
    if (!uniqueAlphabet.contains(""String_Node_Str"" + this.alphabet.charAt(i))) {
      uniqueAlphabet+=""String_Node_Str"" + this.alphabet.charAt(i);
    }
  }
  this.alphabet=uniqueAlphabet;
  if (this.alphabet.length() < this.minAlphabetLength) {
    throw new IllegalArgumentException(""String_Node_Str"" + this.minAlphabetLength + ""String_Node_Str"");
  }
  if (this.alphabet.contains(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (int i=0; i < this.seps.length(); i++) {
    int j=this.alphabet.indexOf(this.seps.charAt(i));
    if (j == -1) {
      this.seps=this.seps.substring(0,i) + ""String_Node_Str"" + this.seps.substring(i + 1);
    }
 else {
      this.alphabet=this.alphabet.substring(0,j) + ""String_Node_Str"" + this.alphabet.substring(j + 1);
    }
  }
  this.alphabet=this.alphabet.replaceAll(""String_Node_Str"",""String_Node_Str"");
  this.seps=this.seps.replaceAll(""String_Node_Str"",""String_Node_Str"");
  this.seps=this.consistentShuffle(this.seps,this.salt);
  if ((this.seps.equals(""String_Node_Str"")) || ((this.alphabet.length() / this.seps.length()) > this.sepDiv)) {
    int seps_len=(int)Math.ceil(this.alphabet.length() / this.sepDiv);
    if (seps_len == 1) {
      seps_len++;
    }
    if (seps_len > this.seps.length()) {
      int diff=seps_len - this.seps.length();
      this.seps+=this.alphabet.substring(0,diff);
      this.alphabet=this.alphabet.substring(diff);
    }
 else {
      this.seps=this.seps.substring(0,seps_len);
    }
  }
  this.alphabet=this.consistentShuffle(this.alphabet,this.salt);
  int guardCount=(int)Math.ceil((double)this.alphabet.length() / this.guardDiv);
  if (this.alphabet.length() < 3) {
    this.guards=this.seps.substring(0,guardCount);
    this.seps=this.seps.substring(guardCount);
  }
 else {
    this.guards=this.alphabet.substring(0,guardCount);
    this.alphabet=this.alphabet.substring(guardCount);
  }
}","public Hashids(String salt,int minHashLength,String alphabet){
  this.salt=salt;
  if (minHashLength < 0)   this.minHashLength=0;
 else   this.minHashLength=minHashLength;
  this.alphabet=alphabet;
  String uniqueAlphabet=""String_Node_Str"";
  for (int i=0; i < this.alphabet.length(); i++) {
    if (!uniqueAlphabet.contains(""String_Node_Str"" + this.alphabet.charAt(i))) {
      uniqueAlphabet+=""String_Node_Str"" + this.alphabet.charAt(i);
    }
  }
  this.alphabet=uniqueAlphabet;
  int minAlphabetLength=16;
  if (this.alphabet.length() < minAlphabetLength) {
    throw new IllegalArgumentException(""String_Node_Str"" + minAlphabetLength + ""String_Node_Str"");
  }
  if (this.alphabet.contains(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (int i=0; i < this.seps.length(); i++) {
    int j=this.alphabet.indexOf(this.seps.charAt(i));
    if (j == -1) {
      this.seps=this.seps.substring(0,i) + ""String_Node_Str"" + this.seps.substring(i + 1);
    }
 else {
      this.alphabet=this.alphabet.substring(0,j) + ""String_Node_Str"" + this.alphabet.substring(j + 1);
    }
  }
  this.alphabet=this.alphabet.replaceAll(""String_Node_Str"",""String_Node_Str"");
  this.seps=this.seps.replaceAll(""String_Node_Str"",""String_Node_Str"");
  this.seps=this.consistentShuffle(this.seps,this.salt);
  double sepDiv=3.5;
  if ((this.seps.equals(""String_Node_Str"")) || ((this.alphabet.length() / this.seps.length()) > sepDiv)) {
    int seps_len=(int)Math.ceil(this.alphabet.length() / sepDiv);
    if (seps_len == 1) {
      seps_len++;
    }
    if (seps_len > this.seps.length()) {
      int diff=seps_len - this.seps.length();
      this.seps+=this.alphabet.substring(0,diff);
      this.alphabet=this.alphabet.substring(diff);
    }
 else {
      this.seps=this.seps.substring(0,seps_len);
    }
  }
  this.alphabet=this.consistentShuffle(this.alphabet,this.salt);
  int guardDiv=12;
  int guardCount=(int)Math.ceil((double)this.alphabet.length() / guardDiv);
  if (this.alphabet.length() < 3) {
    this.guards=this.seps.substring(0,guardCount);
    this.seps=this.seps.substring(guardCount);
  }
 else {
    this.guards=this.alphabet.substring(0,guardCount);
    this.alphabet=this.alphabet.substring(guardCount);
  }
}",0.9791245791245792
29276,"/** 
 * @deprecated should use decodeHex() since v1.0
 */
@Deprecated public String decryptHex(String hash){
  return decodeHex(hash);
}","/** 
 * @deprecated should use decodeHex() since v1.0
 */
@Deprecated @SuppressWarnings(""String_Node_Str"") public String decryptHex(String hash){
  return decodeHex(hash);
}",0.8802588996763754
29277,"private String _encode(long... numbers){
  int numberHashInt=0;
  for (int i=0; i < numbers.length; i++) {
    numberHashInt+=(numbers[i] % (i + 100));
  }
  String alphabet=this.alphabet;
  char ret=alphabet.toCharArray()[numberHashInt % alphabet.length()];
  char lottery=ret;
  long num;
  int sepsIndex, guardIndex;
  String buffer, ret_str=ret + ""String_Node_Str"";
  char guard;
  for (int i=0; i < numbers.length; i++) {
    num=numbers[i];
    buffer=lottery + this.salt + alphabet;
    alphabet=this.consistentShuffle(alphabet,buffer.substring(0,alphabet.length()));
    String last=this.hash(num,alphabet);
    ret_str+=last;
    if (i + 1 < numbers.length) {
      num%=((int)last.toCharArray()[0] + i);
      sepsIndex=(int)(num % this.seps.length());
      ret_str+=this.seps.toCharArray()[sepsIndex];
    }
  }
  if (ret_str.length() < this.minHashLength) {
    guardIndex=(numberHashInt + (int)(ret_str.toCharArray()[0])) % this.guards.length();
    guard=this.guards.toCharArray()[guardIndex];
    ret_str=guard + ret_str;
    if (ret_str.length() < this.minHashLength) {
      guardIndex=(numberHashInt + (int)(ret_str.toCharArray()[2])) % this.guards.length();
      guard=this.guards.toCharArray()[guardIndex];
      ret_str+=guard;
    }
  }
  int halfLen=alphabet.length() / 2;
  while (ret_str.length() < this.minHashLength) {
    alphabet=this.consistentShuffle(alphabet,alphabet);
    ret_str=alphabet.substring(halfLen) + ret_str + alphabet.substring(0,halfLen);
    int excess=ret_str.length() - this.minHashLength;
    if (excess > 0) {
      int start_pos=excess / 2;
      ret_str=ret_str.substring(start_pos,start_pos + this.minHashLength);
    }
  }
  return ret_str;
}","private String _encode(long... numbers){
  int numberHashInt=0;
  for (int i=0; i < numbers.length; i++) {
    numberHashInt+=(numbers[i] % (i + 100));
  }
  String alphabet=this.alphabet;
  char ret=alphabet.toCharArray()[numberHashInt % alphabet.length()];
  long num;
  int sepsIndex, guardIndex;
  String buffer, ret_str=ret + ""String_Node_Str"";
  char guard;
  for (int i=0; i < numbers.length; i++) {
    num=numbers[i];
    buffer=ret + this.salt + alphabet;
    alphabet=this.consistentShuffle(alphabet,buffer.substring(0,alphabet.length()));
    String last=this.hash(num,alphabet);
    ret_str+=last;
    if (i + 1 < numbers.length) {
      num%=((int)last.toCharArray()[0] + i);
      sepsIndex=(int)(num % this.seps.length());
      ret_str+=this.seps.toCharArray()[sepsIndex];
    }
  }
  if (ret_str.length() < this.minHashLength) {
    guardIndex=(numberHashInt + (int)(ret_str.toCharArray()[0])) % this.guards.length();
    guard=this.guards.toCharArray()[guardIndex];
    ret_str=guard + ret_str;
    if (ret_str.length() < this.minHashLength) {
      guardIndex=(numberHashInt + (int)(ret_str.toCharArray()[2])) % this.guards.length();
      guard=this.guards.toCharArray()[guardIndex];
      ret_str+=guard;
    }
  }
  int halfLen=alphabet.length() / 2;
  while (ret_str.length() < this.minHashLength) {
    alphabet=this.consistentShuffle(alphabet,alphabet);
    ret_str=alphabet.substring(halfLen) + ret_str + alphabet.substring(0,halfLen);
    int excess=ret_str.length() - this.minHashLength;
    if (excess > 0) {
      int start_pos=excess / 2;
      ret_str=ret_str.substring(start_pos,start_pos + this.minHashLength);
    }
  }
  return ret_str;
}",0.991108476585655
29278,"/** 
 * @deprecated should use encode() since v1.0
 */
@Deprecated public String encrypt(long... numbers){
  return encode(numbers);
}","/** 
 * @deprecated should use encode() since v1.0
 */
@Deprecated @SuppressWarnings(""String_Node_Str"") public String encrypt(long... numbers){
  return encode(numbers);
}",0.8786885245901639
29279,"public static int checkedCast(long value){
  int result=(int)value;
  if (result != value) {
    throw new IllegalArgumentException(""String_Node_Str"" + value);
  }
  return result;
}","@SuppressWarnings(""String_Node_Str"") public static int checkedCast(long value){
  int result=(int)value;
  if (result != value) {
    throw new IllegalArgumentException(""String_Node_Str"" + value);
  }
  return result;
}",0.9077306733167082
29280,"/** 
 * Decrypt string to numbers
 * @param hash the encrypt string
 * @return decryped numbers
 */
public String decodeHex(String hash){
  String result=""String_Node_Str"";
  long[] numbers=this.decrypt(hash);
  for (  long number : numbers) {
    result+=Long.toHexString(number).substring(1);
  }
  return result;
}","/** 
 * Decrypt string to numbers
 * @param hash the encrypt string
 * @return decryped numbers
 */
public String decodeHex(String hash){
  String result=""String_Node_Str"";
  long[] numbers=this.decode(hash);
  for (  long number : numbers) {
    result+=Long.toHexString(number).substring(1);
  }
  return result;
}",0.9889415481832544
29281,"/** 
 * @deprecated should use decode() since v1.0
 */
@Deprecated public long[] decrypt(String hash){
  return decode(hash);
}","/** 
 * @deprecated should use decode() since v1.0
 */
@Deprecated @SuppressWarnings(""String_Node_Str"") public long[] decrypt(String hash){
  return decode(hash);
}",0.872852233676976
29282,"private long[] _decode(String hash,String alphabet){
  ArrayList<Long> ret=new ArrayList<Long>();
  int i=0;
  String regexp=""String_Node_Str"" + this.guards + ""String_Node_Str"";
  String hashBreakdown=hash.replaceAll(regexp,""String_Node_Str"");
  String[] hashArray=hashBreakdown.split(""String_Node_Str"");
  if (hashArray.length == 3 || hashArray.length == 2) {
    i=1;
  }
  hashBreakdown=hashArray[i];
  char lottery=hashBreakdown.toCharArray()[0];
  hashBreakdown=hashBreakdown.substring(1);
  hashBreakdown=hashBreakdown.replaceAll(""String_Node_Str"" + this.seps + ""String_Node_Str"",""String_Node_Str"");
  hashArray=hashBreakdown.split(""String_Node_Str"");
  String subHash, buffer;
  for (  String aHashArray : hashArray) {
    subHash=aHashArray;
    buffer=lottery + this.salt + alphabet;
    alphabet=this.consistentShuffle(alphabet,buffer.substring(0,alphabet.length()));
    ret.add(this.unhash(subHash,alphabet));
  }
  long[] arr=new long[ret.size()];
  for (int k=0; k < arr.length; k++) {
    arr[k]=ret.get(k);
  }
  return arr;
}","private long[] _decode(String hash,String alphabet){
  ArrayList<Long> ret=new ArrayList<Long>();
  int i=0;
  String regexp=""String_Node_Str"" + this.guards + ""String_Node_Str"";
  String hashBreakdown=hash.replaceAll(regexp,""String_Node_Str"");
  String[] hashArray=hashBreakdown.split(""String_Node_Str"");
  if (hashArray.length == 3 || hashArray.length == 2) {
    i=1;
  }
  hashBreakdown=hashArray[i];
  char lottery=hashBreakdown.toCharArray()[0];
  hashBreakdown=hashBreakdown.substring(1);
  hashBreakdown=hashBreakdown.replaceAll(""String_Node_Str"" + this.seps + ""String_Node_Str"",""String_Node_Str"");
  hashArray=hashBreakdown.split(""String_Node_Str"");
  String subHash, buffer;
  for (  String aHashArray : hashArray) {
    subHash=aHashArray;
    buffer=lottery + this.salt + alphabet;
    alphabet=this.consistentShuffle(alphabet,buffer.substring(0,alphabet.length()));
    ret.add(this.unhash(subHash,alphabet));
  }
  long[] arr=new long[ret.size()];
  for (int k=0; k < arr.length; k++) {
    arr[k]=ret.get(k);
  }
  if (!this._encode(arr).equals(hash)) {
    arr=new long[0];
  }
  return arr;
}",0.958139534883721
29283,"@Test public void test_large_nummber(){
  String res;
  long num_to_hash=9007199254740992L;
  Hashids a=new Hashids(""String_Node_Str"");
  res=a.encode(num_to_hash);
  long[] b=a.decode(res);
  Assert.assertEquals(num_to_hash,b[0]);
}","@Test public void test_large_nummber(){
  long num_to_hash=9007199254740992L;
  Hashids a=new Hashids(""String_Node_Str"");
  String res=a.encode(num_to_hash);
  long[] b=a.decode(res);
  Assert.assertEquals(num_to_hash,b[0]);
}",0.954248366013072
29284,"private long[] _decode(String hash,String alphabet){
  ArrayList<Long> ret=new ArrayList<Long>();
  int i=0;
  String regexp=""String_Node_Str"" + this.guards + ""String_Node_Str"";
  String hashBreakdown=hash.replaceAll(regexp,""String_Node_Str"");
  String[] hashArray=hashBreakdown.split(""String_Node_Str"");
  if (hashArray.length == 3 || hashArray.length == 2) {
    i=1;
  }
  hashBreakdown=hashArray[i];
  char lottery=hashBreakdown.toCharArray()[0];
  hashBreakdown=hashBreakdown.substring(1);
  hashBreakdown=hashBreakdown.replaceAll(""String_Node_Str"" + this.seps + ""String_Node_Str"",""String_Node_Str"");
  hashArray=hashBreakdown.split(""String_Node_Str"");
  String subHash, buffer;
  for (  String aHashArray : hashArray) {
    subHash=aHashArray;
    buffer=lottery + this.salt + alphabet;
    alphabet=Hashids.consistentShuffle(alphabet,buffer.substring(0,alphabet.length()));
    ret.add(Hashids.unhash(subHash,alphabet));
  }
  long[] arr=new long[ret.size()];
  for (int k=0; k < arr.length; k++) {
    arr[k]=ret.get(k);
  }
  if (!this._encode(arr).equals(hash)) {
    arr=new long[0];
  }
  return arr;
}","private long[] _decode(String hash,String alphabet){
  ArrayList<Long> ret=new ArrayList<Long>();
  int i=0;
  String regexp=""String_Node_Str"" + this.guards + ""String_Node_Str"";
  String hashBreakdown=hash.replaceAll(regexp,""String_Node_Str"");
  String[] hashArray=hashBreakdown.split(""String_Node_Str"");
  if (hashArray.length == 3 || hashArray.length == 2) {
    i=1;
  }
  hashBreakdown=hashArray[i];
  if (!hashBreakdown.isEmpty()) {
    char lottery=hashBreakdown.toCharArray()[0];
    hashBreakdown=hashBreakdown.substring(1);
    hashBreakdown=hashBreakdown.replaceAll(""String_Node_Str"" + this.seps + ""String_Node_Str"",""String_Node_Str"");
    hashArray=hashBreakdown.split(""String_Node_Str"");
    String subHash, buffer;
    for (    String aHashArray : hashArray) {
      subHash=aHashArray;
      buffer=lottery + this.salt + alphabet;
      alphabet=Hashids.consistentShuffle(alphabet,buffer.substring(0,alphabet.length()));
      ret.add(Hashids.unhash(subHash,alphabet));
    }
  }
  long[] arr=new long[ret.size()];
  for (int k=0; k < arr.length; k++) {
    arr[k]=ret.get(k);
  }
  if (!this._encode(arr).equals(hash)) {
    arr=new long[0];
  }
  return arr;
}",0.9685589519650656
29285,"public Hashids(String salt,int minHashLength,String alphabet){
  this.salt=salt;
  if (minHashLength < 0)   this.minHashLength=0;
 else   this.minHashLength=minHashLength;
  this.alphabet=alphabet;
  String uniqueAlphabet=""String_Node_Str"";
  for (int i=0; i < this.alphabet.length(); i++) {
    if (!uniqueAlphabet.contains(""String_Node_Str"" + this.alphabet.charAt(i))) {
      uniqueAlphabet+=""String_Node_Str"" + this.alphabet.charAt(i);
    }
  }
  this.alphabet=uniqueAlphabet;
  int minAlphabetLength=16;
  if (this.alphabet.length() < minAlphabetLength) {
    throw new IllegalArgumentException(""String_Node_Str"" + minAlphabetLength + ""String_Node_Str"");
  }
  if (this.alphabet.contains(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (int i=0; i < this.seps.length(); i++) {
    int j=this.alphabet.indexOf(this.seps.charAt(i));
    if (j == -1) {
      this.seps=this.seps.substring(0,i) + ""String_Node_Str"" + this.seps.substring(i + 1);
    }
 else {
      this.alphabet=this.alphabet.substring(0,j) + ""String_Node_Str"" + this.alphabet.substring(j + 1);
    }
  }
  this.alphabet=this.alphabet.replaceAll(""String_Node_Str"",""String_Node_Str"");
  this.seps=this.seps.replaceAll(""String_Node_Str"",""String_Node_Str"");
  this.seps=this.consistentShuffle(this.seps,this.salt);
  double sepDiv=3.5;
  if ((this.seps.equals(""String_Node_Str"")) || ((this.alphabet.length() / this.seps.length()) > sepDiv)) {
    int seps_len=(int)Math.ceil(this.alphabet.length() / sepDiv);
    if (seps_len == 1) {
      seps_len++;
    }
    if (seps_len > this.seps.length()) {
      int diff=seps_len - this.seps.length();
      this.seps+=this.alphabet.substring(0,diff);
      this.alphabet=this.alphabet.substring(diff);
    }
 else {
      this.seps=this.seps.substring(0,seps_len);
    }
  }
  this.alphabet=this.consistentShuffle(this.alphabet,this.salt);
  int guardDiv=12;
  int guardCount=(int)Math.ceil((double)this.alphabet.length() / guardDiv);
  if (this.alphabet.length() < 3) {
    this.guards=this.seps.substring(0,guardCount);
    this.seps=this.seps.substring(guardCount);
  }
 else {
    this.guards=this.alphabet.substring(0,guardCount);
    this.alphabet=this.alphabet.substring(guardCount);
  }
}","public Hashids(String salt,int minHashLength,String alphabet){
  this.salt=salt;
  if (minHashLength < 0)   this.minHashLength=0;
 else   this.minHashLength=minHashLength;
  this.alphabet=alphabet;
  String uniqueAlphabet=""String_Node_Str"";
  for (int i=0; i < this.alphabet.length(); i++) {
    if (!uniqueAlphabet.contains(""String_Node_Str"" + this.alphabet.charAt(i))) {
      uniqueAlphabet+=""String_Node_Str"" + this.alphabet.charAt(i);
    }
  }
  this.alphabet=uniqueAlphabet;
  int minAlphabetLength=16;
  if (this.alphabet.length() < minAlphabetLength) {
    throw new IllegalArgumentException(""String_Node_Str"" + minAlphabetLength + ""String_Node_Str"");
  }
  if (this.alphabet.contains(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (int i=0; i < this.seps.length(); i++) {
    int j=this.alphabet.indexOf(this.seps.charAt(i));
    if (j == -1) {
      this.seps=this.seps.substring(0,i) + ""String_Node_Str"" + this.seps.substring(i + 1);
    }
 else {
      this.alphabet=this.alphabet.substring(0,j) + ""String_Node_Str"" + this.alphabet.substring(j + 1);
    }
  }
  this.alphabet=this.alphabet.replaceAll(""String_Node_Str"",""String_Node_Str"");
  this.seps=this.seps.replaceAll(""String_Node_Str"",""String_Node_Str"");
  this.seps=this.consistentShuffle(this.seps,this.salt);
  double sepDiv=3.5;
  if ((this.seps.equals(""String_Node_Str"")) || (((float)this.alphabet.length() / this.seps.length()) > sepDiv)) {
    int seps_len=(int)Math.ceil(this.alphabet.length() / sepDiv);
    if (seps_len == 1) {
      seps_len++;
    }
    if (seps_len > this.seps.length()) {
      int diff=seps_len - this.seps.length();
      this.seps+=this.alphabet.substring(0,diff);
      this.alphabet=this.alphabet.substring(diff);
    }
 else {
      this.seps=this.seps.substring(0,seps_len);
    }
  }
  this.alphabet=this.consistentShuffle(this.alphabet,this.salt);
  int guardDiv=12;
  int guardCount=(int)Math.ceil((double)this.alphabet.length() / guardDiv);
  if (this.alphabet.length() < 3) {
    this.guards=this.seps.substring(0,guardCount);
    this.seps=this.seps.substring(guardCount);
  }
 else {
    this.guards=this.alphabet.substring(0,guardCount);
    this.alphabet=this.alphabet.substring(guardCount);
  }
}",0.9984461709211988
29286,"/** 
 * @deprecated should use encodeHex() since v1.0
 */
@Deprecated @SuppressWarnings(""String_Node_Str"") public String encryptHex(String hexa){
  return encodeHex(hexa);
}","/** 
 * @param hexa the hexa to encrypt
 * @return the encrypt string
 * @deprecated should use encodeHex() since v1.0
 */
@Deprecated @SuppressWarnings(""String_Node_Str"") public String encryptHex(String hexa){
  return encodeHex(hexa);
}",0.8418491484184915
29287,"/** 
 * @deprecated should use decodeHex() since v1.0
 */
@Deprecated @SuppressWarnings(""String_Node_Str"") public String decryptHex(String hash){
  return decodeHex(hash);
}","/** 
 * @param hash the encrypt string
 * @return decryped numbers
 * @deprecated should use decodeHex() since v1.0
 */
@Deprecated @SuppressWarnings(""String_Node_Str"") public String decryptHex(String hash){
  return decodeHex(hash);
}",0.8480392156862745
29288,"/** 
 * @deprecated should use encode() since v1.0
 */
@Deprecated @SuppressWarnings(""String_Node_Str"") public String encrypt(long... numbers){
  return encode(numbers);
}","/** 
 * @param numbers the numbers to encrypt
 * @return the encrypt string
 * @deprecated should use encode() since v1.0
 */
@Deprecated @SuppressWarnings(""String_Node_Str"") public String encrypt(long... numbers){
  return encode(numbers);
}",0.8280871670702179
29289,"/** 
 * @deprecated should use decode() since v1.0
 */
@Deprecated @SuppressWarnings(""String_Node_Str"") public long[] decrypt(String hash){
  return decode(hash);
}","/** 
 * @param hash the encrypt string
 * @return decryped numbers 
 * @deprecated should use decode() since v1.0
 */
@Deprecated @SuppressWarnings(""String_Node_Str"") public long[] decrypt(String hash){
  return decode(hash);
}",0.8388746803069054
29290,"private String encode(long... numbers){
  int numberHashInt=0;
  for (int i=0; i < numbers.length; i++) {
    numberHashInt+=(numbers[i] % (i + 100));
  }
  String alphabet=this.alphabet;
  char ret=alphabet.toCharArray()[numberHashInt % alphabet.length()];
  char lottery=ret;
  long num;
  int sepsIndex, guardIndex;
  String buffer=""String_Node_Str"", ret_str=ret + ""String_Node_Str"";
  char guard;
  for (int i=0; i < numbers.length; i++) {
    num=numbers[i];
    buffer=lottery + this.salt + alphabet;
    alphabet=this.consistentShuffle(alphabet,buffer.substring(0,alphabet.length()));
    String last=this.hash((int)num,alphabet);
    ret_str+=last;
    if (i + 1 < numbers.length) {
      num%=((int)last.toCharArray()[0] + i);
      sepsIndex=(int)(num % this.seps.length());
      ret_str+=this.seps.toCharArray()[sepsIndex];
    }
  }
  if (ret_str.length() < this.minHashLength) {
    guardIndex=(numberHashInt + (int)(ret_str.toCharArray()[0])) % this.guards.length();
    guard=this.guards.toCharArray()[guardIndex];
    ret_str=guard + ret_str;
    if (ret_str.length() < this.minHashLength) {
      guardIndex=(numberHashInt + (int)(ret_str.toCharArray()[2])) % this.guards.length();
      guard=this.guards.toCharArray()[guardIndex];
      ret_str+=guard;
    }
  }
  int halfLen=(int)(this.alphabet.length() / 2);
  while (ret_str.length() < this.minHashLength) {
    this.alphabet=this.consistentShuffle(this.alphabet,this.alphabet);
    ret_str=this.alphabet.substring(halfLen) + ret_str + this.alphabet.substring(0,halfLen);
    int excess=ret_str.length() - this.minHashLength;
    if (excess > 0) {
      ret_str=ret_str.substring(excess / 2,this.minHashLength);
    }
  }
  return ret_str;
}","private String encode(long... numbers){
  int numberHashInt=0;
  for (int i=0; i < numbers.length; i++) {
    numberHashInt+=(numbers[i] % (i + 100));
  }
  String alphabet=this.alphabet;
  char ret=alphabet.toCharArray()[numberHashInt % alphabet.length()];
  char lottery=ret;
  long num;
  int sepsIndex, guardIndex;
  String buffer=""String_Node_Str"", ret_str=ret + ""String_Node_Str"";
  char guard;
  for (int i=0; i < numbers.length; i++) {
    num=numbers[i];
    buffer=lottery + this.salt + alphabet;
    alphabet=this.consistentShuffle(alphabet,buffer.substring(0,alphabet.length()));
    String last=this.hash((int)num,alphabet);
    ret_str+=last;
    if (i + 1 < numbers.length) {
      num%=((int)last.toCharArray()[0] + i);
      sepsIndex=(int)(num % this.seps.length());
      ret_str+=this.seps.toCharArray()[sepsIndex];
    }
  }
  if (ret_str.length() < this.minHashLength) {
    guardIndex=(numberHashInt + (int)(ret_str.toCharArray()[0])) % this.guards.length();
    guard=this.guards.toCharArray()[guardIndex];
    ret_str=guard + ret_str;
    if (ret_str.length() < this.minHashLength) {
      guardIndex=(numberHashInt + (int)(ret_str.toCharArray()[2])) % this.guards.length();
      guard=this.guards.toCharArray()[guardIndex];
      ret_str+=guard;
    }
  }
  int halfLen=(int)(alphabet.length() / 2);
  while (ret_str.length() < this.minHashLength) {
    alphabet=this.consistentShuffle(alphabet,alphabet);
    ret_str=alphabet.substring(halfLen) + ret_str + alphabet.substring(0,halfLen);
    int excess=ret_str.length() - this.minHashLength;
    if (excess > 0) {
      int start_pos=excess / 2;
      ret_str=ret_str.substring(start_pos,start_pos + this.minHashLength);
    }
  }
  return ret_str;
}",0.9503340110368864
29291,"@Test public void test_one_number(){
  Hashids a=null;
  String expected=""String_Node_Str"", res=""String_Node_Str"";
  long num_to_hash=1983L;
  try {
    a=new Hashids(""String_Node_Str"");
    res=a.encrypt(num_to_hash);
    Assert.assertEquals(res,expected);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","@Test public void test_one_number(){
  Hashids a=null;
  String expected=""String_Node_Str"", res=""String_Node_Str"";
  long num_to_hash=12345L;
  long[] res2;
  try {
    a=new Hashids(""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  res=a.encrypt(num_to_hash);
  Assert.assertEquals(res,expected);
  res2=a.decrypt(expected);
  Assert.assertEquals(res2.length,1);
  Assert.assertEquals(res2[0],num_to_hash);
}",0.6798941798941799
29292,"@Test public void test_serveral_numbers(){
  Hashids a=null;
  String expected=""String_Node_Str"", res=""String_Node_Str"";
  long[] num_to_hash={1983L,1984L,2005L};
  try {
    a=new Hashids(""String_Node_Str"");
    res=a.encrypt(num_to_hash);
    Assert.assertEquals(res,expected);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","@Test public void test_serveral_numbers(){
  Hashids a=null;
  String expected=""String_Node_Str"", res=""String_Node_Str"";
  long[] num_to_hash={683L,94108L,123L,5L}, res2;
  try {
    a=new Hashids(""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  res=a.encrypt(num_to_hash);
  Assert.assertEquals(res,expected);
  res2=a.decrypt(expected);
  Assert.assertEquals(res2.length,num_to_hash.length);
  Assert.assertTrue(Arrays.equals(res2,num_to_hash));
}",0.6715506715506715
29293,"protected final Long insertOrUpdate(T entity,SQLiteDatabase db,ContentValues values){
  if (entity.id == null) {
    entity.id=db.insert(getTableName(),null,values);
  }
 else {
    db.update(getTableName(),values,""String_Node_Str"" + BaseColumns._ID + ""String_Node_Str"",new String[]{entity.id.toString()});
  }
  return entity.id;
}","protected final Long insertOrUpdate(T entity,SQLiteDatabase db,ContentValues values){
  if (entity.id == null) {
    entity.id=db.insert(getTableName(),null,values);
  }
 else {
    db.update(getTableName(),values,BaseColumns._ID + ""String_Node_Str"",new String[]{entity.id.toString()});
  }
  return entity.id;
}",0.968944099378882
29294,protected abstract String[] getPartArgs();,"protected String[] getPartArgs(){
  return null;
}",0.717391304347826
29295,protected abstract String getPartSql();,"protected String getPartSql(){
  return null;
}",0.6976744186046512
29296,"@Override public final String[] getArgs(){
  if (mParent != null) {
    return ArrayUtils.addAll(mParent.getArgs(),getPartArgs());
  }
  return getPartArgs();
}","@Override public final String[] getArgs(){
  if (mParent != null) {
    return join(mParent.getArgs(),getPartArgs());
  }
  return getPartArgs();
}",0.9381107491856676
29297,"@Override public <T extends Model>T fetchSingle(){
  return (T)Ollie.rawQuery(mTable,getSql(),getArgs());
}","@Override public <T extends Model>T fetchSingle(){
  List<T> results=(List<T>)Ollie.rawQuery(mTable,getSql(),getArgs());
  if (!results.isEmpty()) {
    return results.get(0);
  }
  return null;
}",0.6798679867986799
29298,"/** 
 * Tries to format the contents of the last contents appropriately based on the type of cell and the discovered numeric format.
 * @return
 */
Supplier formattedContents(){
switch (currentCell.getType()) {
case ""String_Node_Str"":
    if (!lastContents.isEmpty()) {
      int idx=Integer.parseInt(lastContents);
      return new StringSupplier(new XSSFRichTextString(sst.getEntryAt(idx)).toString());
    }
  return new StringSupplier(lastContents);
case ""String_Node_Str"":
return new StringSupplier(new XSSFRichTextString(lastContents).toString());
case ""String_Node_Str"":
return new StringSupplier('""' + lastContents + '""');
case ""String_Node_Str"":
return new StringSupplier(""String_Node_Str"" + lastContents);
case ""String_Node_Str"":
if (currentCell.getNumericFormat() != null && lastContents.length() > 0) {
final String currentLastContents=lastContents;
final int currentNumericFormatIndex=currentCell.getNumericFormatIndex();
final String currentNumericFormat=currentCell.getNumericFormat();
return new Supplier(){
String cachedContent;
@Override public Object getContent(){
if (cachedContent == null) {
  cachedContent=dataFormatter.formatRawCellContents(Double.parseDouble(currentLastContents),currentNumericFormatIndex,currentNumericFormat);
}
return cachedContent;
}
}
;
}
 else {
return new StringSupplier(lastContents);
}
default :
return new StringSupplier(lastContents);
}
}","/** 
 * Tries to format the contents of the last contents appropriately based on the type of cell and the discovered numeric format.
 * @return
 */
Supplier formattedContents(){
  return getFormatterForType(currentCell.getType());
}",0.2513863216266174
29299,"@Test public void testFormulaCells() throws Exception {
  try (InputStream is=new FileInputStream(new File(""String_Node_Str""));Workbook workbook=StreamingReader.builder().open(is)){
    assertEquals(1,workbook.getNumberOfSheets());
    Sheet sheet=workbook.getSheetAt(0);
    Iterator<Row> rowIterator=sheet.rowIterator();
    rowIterator.next();
    rowIterator.next();
    Row row3=rowIterator.next();
    Cell A3=row3.getCell(0);
    assertEquals(""String_Node_Str"",CellType.FORMULA,A3.getCellTypeEnum());
    assertEquals(""String_Node_Str"",CellType.NUMERIC,A3.getCachedFormulaResultTypeEnum());
    assertEquals(""String_Node_Str"",""String_Node_Str"",A3.getCellFormula());
  }
 }","@Test public void testFormulaCells() throws Exception {
  try (Workbook workbook=openWorkbook(""String_Node_Str"")){
    assertEquals(1,workbook.getNumberOfSheets());
    Sheet sheet=workbook.getSheetAt(0);
    Iterator<Row> rowIterator=sheet.rowIterator();
    Cell A1=getCellFromNextRow(rowIterator,0);
    Cell A2=getCellFromNextRow(rowIterator,0);
    Cell A3=getCellFromNextRow(rowIterator,0);
    expectType(A3,FORMULA);
    expectCachedType(A3,NUMERIC);
    expectFormula(A3,""String_Node_Str"");
    expectStringContent(A1,""String_Node_Str"");
    expectStringContent(A2,""String_Node_Str"");
    expectStringContent(A3,""String_Node_Str"");
  }
 }",0.526395173453997
29300,"/** 
 * Handles a SAX event.
 * @param event
 * @throws SAXException
 */
private void handleEvent(XMLEvent event) throws SAXException {
  if (event.getEventType() == XMLStreamConstants.CHARACTERS) {
    Characters c=event.asCharacters();
    lastContents+=c.getData();
  }
 else   if (event.getEventType() == XMLStreamConstants.START_ELEMENT && isSpreadsheetTag(event.asStartElement().getName())) {
    StartElement startElement=event.asStartElement();
    String tagLocalName=startElement.getName().getLocalPart();
    if (""String_Node_Str"".equals(tagLocalName)) {
      Attribute rowNumAttr=startElement.getAttributeByName(new QName(""String_Node_Str""));
      Attribute isHiddenAttr=startElement.getAttributeByName(new QName(""String_Node_Str""));
      int rowIndex=Integer.parseInt(rowNumAttr.getValue()) - 1;
      boolean isHidden=isHiddenAttr != null && (""String_Node_Str"".equals(isHiddenAttr.getValue()) || ""String_Node_Str"".equals(isHiddenAttr.getValue()));
      currentRow=new StreamingRow(rowIndex,isHidden);
    }
 else     if (""String_Node_Str"".equals(tagLocalName)) {
      Attribute isHiddenAttr=startElement.getAttributeByName(new QName(""String_Node_Str""));
      boolean isHidden=isHiddenAttr != null && (""String_Node_Str"".equals(isHiddenAttr.getValue()) || ""String_Node_Str"".equals(isHiddenAttr.getValue()));
      if (isHidden) {
        Attribute minAttr=startElement.getAttributeByName(new QName(""String_Node_Str""));
        Attribute maxAttr=startElement.getAttributeByName(new QName(""String_Node_Str""));
        int min=Integer.parseInt(minAttr.getValue()) - 1;
        int max=Integer.parseInt(maxAttr.getValue()) - 1;
        for (int columnIndex=min; columnIndex <= max; columnIndex++)         hiddenColumns.add(columnIndex);
      }
    }
 else     if (""String_Node_Str"".equals(tagLocalName)) {
      Attribute ref=startElement.getAttributeByName(new QName(""String_Node_Str""));
      String[] coord=ref.getValue().split(""String_Node_Str"");
      currentCell=new StreamingCell(CellReference.convertColStringToIndex(coord[0]),Integer.parseInt(coord[1]) - 1,use1904Dates);
      setFormatString(startElement,currentCell);
      Attribute type=startElement.getAttributeByName(new QName(""String_Node_Str""));
      if (type != null) {
        currentCell.setType(type.getValue());
      }
 else {
        currentCell.setType(""String_Node_Str"");
      }
      Attribute style=startElement.getAttributeByName(new QName(""String_Node_Str""));
      if (style != null) {
        String indexStr=style.getValue();
        try {
          int index=Integer.parseInt(indexStr);
          currentCell.setCellStyle(stylesTable.getStyleAt(index));
        }
 catch (        NumberFormatException nfe) {
          log.warn(""String_Node_Str"",indexStr);
        }
      }
    }
 else     if (""String_Node_Str"".equals(tagLocalName)) {
      Attribute refAttr=startElement.getAttributeByName(new QName(""String_Node_Str""));
      String ref=refAttr != null ? refAttr.getValue() : null;
      if (ref != null) {
        for (int i=ref.length() - 1; i >= 0; i--) {
          if (!Character.isDigit(ref.charAt(i))) {
            try {
              lastRowNum=Integer.parseInt(ref.substring(i + 1)) - 1;
            }
 catch (            NumberFormatException ignore) {
            }
            break;
          }
        }
      }
    }
 else     if (""String_Node_Str"".equals(tagLocalName)) {
      currentCell.setType(""String_Node_Str"");
    }
    lastContents=""String_Node_Str"";
  }
 else   if (event.getEventType() == XMLStreamConstants.END_ELEMENT && isSpreadsheetTag(event.asEndElement().getName())) {
    EndElement endElement=event.asEndElement();
    String tagLocalName=endElement.getName().getLocalPart();
    if (""String_Node_Str"".equals(tagLocalName) || ""String_Node_Str"".equals(tagLocalName)) {
      currentCell.setRawContents(unformattedContents());
      currentCell.setContents(formattedContents());
    }
 else     if (""String_Node_Str"".equals(tagLocalName) && currentRow != null) {
      rowCache.add(currentRow);
    }
 else     if (""String_Node_Str"".equals(tagLocalName)) {
      currentRow.getCellMap().put(currentCell.getColumnIndex(),currentCell);
    }
 else     if (""String_Node_Str"".equals(tagLocalName)) {
      currentCell.setFormula(lastContents);
    }
  }
}","/** 
 * Handles a SAX event.
 * @param event
 * @throws SAXException
 */
private void handleEvent(XMLEvent event) throws SAXException {
  if (event.getEventType() == XMLStreamConstants.CHARACTERS) {
    Characters c=event.asCharacters();
    lastContents+=c.getData();
  }
 else   if (event.getEventType() == XMLStreamConstants.START_ELEMENT && isSpreadsheetTag(event.asStartElement().getName())) {
    StartElement startElement=event.asStartElement();
    String tagLocalName=startElement.getName().getLocalPart();
    if (""String_Node_Str"".equals(tagLocalName)) {
      Attribute rowNumAttr=startElement.getAttributeByName(new QName(""String_Node_Str""));
      int rowIndex=currentRowNum;
      if (rowNumAttr != null) {
        rowIndex=Integer.parseInt(rowNumAttr.getValue()) - 1;
        currentRowNum=rowIndex;
      }
      Attribute isHiddenAttr=startElement.getAttributeByName(new QName(""String_Node_Str""));
      boolean isHidden=isHiddenAttr != null && (""String_Node_Str"".equals(isHiddenAttr.getValue()) || ""String_Node_Str"".equals(isHiddenAttr.getValue()));
      currentRow=new StreamingRow(rowIndex,isHidden);
      currentColNum=firstColNum;
    }
 else     if (""String_Node_Str"".equals(tagLocalName)) {
      Attribute isHiddenAttr=startElement.getAttributeByName(new QName(""String_Node_Str""));
      boolean isHidden=isHiddenAttr != null && (""String_Node_Str"".equals(isHiddenAttr.getValue()) || ""String_Node_Str"".equals(isHiddenAttr.getValue()));
      if (isHidden) {
        Attribute minAttr=startElement.getAttributeByName(new QName(""String_Node_Str""));
        Attribute maxAttr=startElement.getAttributeByName(new QName(""String_Node_Str""));
        int min=Integer.parseInt(minAttr.getValue()) - 1;
        int max=Integer.parseInt(maxAttr.getValue()) - 1;
        for (int columnIndex=min; columnIndex <= max; columnIndex++)         hiddenColumns.add(columnIndex);
      }
    }
 else     if (""String_Node_Str"".equals(tagLocalName)) {
      Attribute ref=startElement.getAttributeByName(new QName(""String_Node_Str""));
      if (ref != null) {
        String[] coord=ref.getValue().split(""String_Node_Str"");
        currentCell=new StreamingCell(CellReference.convertColStringToIndex(coord[0]),Integer.parseInt(coord[1]) - 1,use1904Dates);
      }
 else {
        currentCell=new StreamingCell(currentColNum,currentRowNum,use1904Dates);
      }
      setFormatString(startElement,currentCell);
      Attribute type=startElement.getAttributeByName(new QName(""String_Node_Str""));
      if (type != null) {
        currentCell.setType(type.getValue());
      }
 else {
        currentCell.setType(""String_Node_Str"");
      }
      Attribute style=startElement.getAttributeByName(new QName(""String_Node_Str""));
      if (style != null) {
        String indexStr=style.getValue();
        try {
          int index=Integer.parseInt(indexStr);
          currentCell.setCellStyle(stylesTable.getStyleAt(index));
        }
 catch (        NumberFormatException nfe) {
          log.warn(""String_Node_Str"",indexStr);
        }
      }
    }
 else     if (""String_Node_Str"".equals(tagLocalName)) {
      Attribute refAttr=startElement.getAttributeByName(new QName(""String_Node_Str""));
      String ref=refAttr != null ? refAttr.getValue() : null;
      if (ref != null) {
        for (int i=ref.length() - 1; i >= 0; i--) {
          if (!Character.isDigit(ref.charAt(i))) {
            try {
              lastRowNum=Integer.parseInt(ref.substring(i + 1)) - 1;
            }
 catch (            NumberFormatException ignore) {
            }
            break;
          }
        }
        for (int i=0; i < ref.length(); i++) {
          if (!Character.isAlphabetic(ref.charAt(i))) {
            firstColNum=CellReference.convertColStringToIndex(ref.substring(0,i));
            break;
          }
        }
      }
    }
 else     if (""String_Node_Str"".equals(tagLocalName)) {
      currentCell.setType(""String_Node_Str"");
    }
    lastContents=""String_Node_Str"";
  }
 else   if (event.getEventType() == XMLStreamConstants.END_ELEMENT && isSpreadsheetTag(event.asEndElement().getName())) {
    EndElement endElement=event.asEndElement();
    String tagLocalName=endElement.getName().getLocalPart();
    if (""String_Node_Str"".equals(tagLocalName) || ""String_Node_Str"".equals(tagLocalName)) {
      currentCell.setRawContents(unformattedContents());
      currentCell.setContents(formattedContents());
    }
 else     if (""String_Node_Str"".equals(tagLocalName) && currentRow != null) {
      rowCache.add(currentRow);
      currentRowNum++;
    }
 else     if (""String_Node_Str"".equals(tagLocalName)) {
      currentRow.getCellMap().put(currentCell.getColumnIndex(),currentCell);
      currentColNum++;
    }
 else     if (""String_Node_Str"".equals(tagLocalName)) {
      currentCell.setFormula(lastContents);
    }
  }
}",0.8862341078474353
29301,"/** 
 * Closes the streaming resource, attempting to clean up any temporary files created.
 */
@Override public void close(){
  if (tmp != null) {
    log.debug(""String_Node_Str"" + tmp.getAbsolutePath() + ""String_Node_Str"");
    tmp.delete();
  }
}","/** 
 * Closes the streaming resource, attempting to clean up any temporary files created.
 */
@Override public void close(){
  try {
    parser.close();
  }
 catch (  XMLStreamException e) {
    throw new CloseException(e);
  }
  if (tmp != null) {
    log.debug(""String_Node_Str"" + tmp.getAbsolutePath() + ""String_Node_Str"");
    tmp.delete();
  }
}",0.8280467445742905
29302,"@Override public final void handleWindow(Window window,int eventID){
  LoginManager.loginManager().setLoginFrame((JFrame)window);
  try {
    if (!initialise(window,eventID))     return;
    if (!setFields(window,eventID))     return;
    if (!preLogin(window,eventID))     return;
    doLogin(window);
  }
 catch (  IBControllerException e) {
    Utils.logError(""String_Node_Str"" + e.getMessage());
  }
}","@Override public final void handleWindow(Window window,int eventID){
  LoginManager.loginManager().setLoginFrame((JFrame)window);
  try {
    if (!initialise(window,eventID))     return;
    if (!setFields(window,eventID))     return;
    if (!preLogin(window,eventID))     return;
    doLogin(window);
  }
 catch (  IBControllerException e) {
    Utils.logError(""String_Node_Str"" + e.getMessage());
    System.exit(1);
  }
}",0.9759036144578314
29303,"private static void startTws(){
  if (Settings.settings().getBoolean(""String_Node_Str"",false)) {
    Utils.showTradesLogWindow();
  }
  String[] twsArgs=new String[1];
  twsArgs[0]=getTWSSettingsDirectory();
  try {
    jclient.LoginFrame.main(twsArgs);
  }
 catch (  Throwable t) {
    Utils.logError(""String_Node_Str"");
    t.printStackTrace(Utils.getErrStream());
    System.exit(1);
  }
}","private static void startTws(){
  ensureJtsIniExists();
  if (Settings.settings().getBoolean(""String_Node_Str"",false)) {
    Utils.showTradesLogWindow();
  }
  String[] twsArgs=new String[1];
  twsArgs[0]=getTWSSettingsDirectory();
  Utils.logToConsole(""String_Node_Str"" + twsArgs[0]);
  try {
    jclient.LoginFrame.main(twsArgs);
  }
 catch (  Throwable t) {
    Utils.logError(""String_Node_Str"");
    t.printStackTrace(Utils.getErrStream());
    System.exit(1);
  }
}",0.9095127610208816
29304,"private static void startGateway(){
  String[] twsArgs=new String[1];
  twsArgs[0]=getTWSSettingsDirectory();
  try {
    ibgateway.GWClient.main(twsArgs);
  }
 catch (  Throwable t) {
    Utils.logError(""String_Node_Str"");
    t.printStackTrace(Utils.getErrStream());
    System.exit(1);
  }
}","private static void startGateway(){
  String[] twsArgs=new String[1];
  twsArgs[0]=getTWSSettingsDirectory();
  Utils.logToConsole(""String_Node_Str"" + twsArgs[0]);
  try {
    ibgateway.GWClient.main(twsArgs);
  }
 catch (  Throwable t) {
    Utils.logError(""String_Node_Str"");
    t.printStackTrace(Utils.getErrStream());
    System.exit(1);
  }
}",0.9158878504672896
29305,"private static String getTWSSettingsDirectory(){
  String dir=Settings.settings().getString(""String_Node_Str"",System.getProperty(""String_Node_Str""));
  Utils.logToConsole(""String_Node_Str"" + dir);
  return dir;
}","private static String getTWSSettingsDirectory(){
  return Settings.settings().getString(""String_Node_Str"",System.getProperty(""String_Node_Str""));
}",0.8022284122562674
29306,"private static void rewriteExistingFile(){
  Utils.logToConsole(""String_Node_Str"" + jtsIniFile.getPath());
  boolean foundLogon=false;
  boolean foundIBGateway=false;
  try (BufferedWriter w=new BufferedWriter(new FileWriter(jtsIniFile))){
    ListIterator<String> it=lines.listIterator();
    int index=0;
    while (it.hasNext()) {
      index++;
      String l=it.next();
      if (l.compareTo(LogonSectionHeader) == 0) {
        foundLogon=true;
        index=processSection(lines,index,new String[]{S3storeTrueSetting,S3storeFalseSetting},w);
        it=lines.listIterator(index);
      }
 else       if (l.compareTo(IBGatewaySectionHeader) == 0) {
        foundIBGateway=true;
        index=processSection(lines,index,new String[]{ApiOnlyTrueSetting},w);
        it=lines.listIterator(index);
      }
 else {
        w.write(l);
        w.newLine();
      }
    }
    if (!foundLogon) {
      writeLogonSectionHeader(w);
      writeS3store(w);
    }
    if (!foundIBGateway) {
      writeIBGatewaySectionHeader(w);
      writeApiOnly(w);
    }
  }
 catch (  IOException e) {
    Utils.logError(""String_Node_Str"" + jtsIniFile.getPath() + ""String_Node_Str""+ e.getMessage());
    System.exit(1);
  }
}","private static void rewriteExistingFile(){
  Utils.logToConsole(""String_Node_Str"" + jtsIniFile.getPath());
  boolean foundLogon=false;
  boolean foundIBGateway=false;
  try (BufferedWriter w=new BufferedWriter(new FileWriter(jtsIniFile))){
    ListIterator<String> it=lines.listIterator();
    int index=0;
    while (it.hasNext()) {
      index++;
      String l=it.next();
      if (l.compareTo(LogonSectionHeader) == 0) {
        writeIniFileLine(l,w);
        foundLogon=true;
        index=processSection(lines,index,new String[]{S3storeTrueSetting,S3storeFalseSetting},w);
        it=lines.listIterator(index);
      }
 else       if (l.compareTo(IBGatewaySectionHeader) == 0) {
        writeIniFileLine(l,w);
        foundIBGateway=true;
        index=processSection(lines,index,new String[]{ApiOnlyTrueSetting},w);
        it=lines.listIterator(index);
      }
 else {
        writeIniFileLine(l,w);
      }
    }
    if (!foundLogon) {
      writeLogonSectionHeader(w);
      writeS3store(w);
    }
    if (!foundIBGateway) {
      writeIBGatewaySectionHeader(w);
      writeApiOnly(w);
    }
  }
 catch (  IOException e) {
    Utils.logError(""String_Node_Str"" + jtsIniFile.getPath() + ""String_Node_Str""+ e.getMessage());
    System.exit(1);
  }
}",0.959349593495935
29307,"private static void writeApiOnly(BufferedWriter w) throws IOException {
  w.write(ApiOnlySetting);
  w.newLine();
}","private static void writeApiOnly(BufferedWriter w) throws IOException {
  writeIniFileLine(ApiOnlyTrueSetting,w);
}",0.8608695652173913
29308,"private static int processSection(List<String> lines,int startIndex,String[] settings,BufferedWriter w) throws IOException {
  int index=startIndex;
  boolean found=false;
  ListIterator<String> it=lines.listIterator(index);
  while (it.hasNext()) {
    index++;
    String l=it.next();
    for (    String s : settings) {
      if (l.compareTo(s) == 0) {
        found=true;
        break;
      }
    }
    if (l.startsWith(""String_Node_Str"")) {
      if (!found)       w.write(settings[0]);
      break;
    }
 else {
      w.write(l);
      w.newLine();
    }
  }
  return index;
}","private static int processSection(List<String> lines,int startIndex,String[] settings,BufferedWriter w) throws IOException {
  int index=startIndex;
  boolean found=false;
  ListIterator<String> it=lines.listIterator(index);
  while (it.hasNext()) {
    String l=it.next();
    for (    String s : settings) {
      if (l.compareTo(s) == 0) {
        found=true;
        break;
      }
    }
    if (l.isEmpty()) {
      index++;
    }
 else     if (l.startsWith(""String_Node_Str"")) {
      break;
    }
 else {
      writeIniFileLine(l,w);
      index++;
    }
  }
  if (!found)   writeIniFileLine(settings[0],w);
  writeIniFileLine(""String_Node_Str"",w);
  return index;
}",0.5516693163751988
29309,"private static boolean existingFileOk(){
  return (findSettingInSection(LogonSectionHeader,S3storeFalseSetting) || findSettingInSection(LogonSectionHeader,S3storeTrueSetting)) && findSettingInSection(IBGatewaySectionHeader,ApiOnlyTrueSetting);
}","private static boolean existingFileOk(){
  return (findSettingInSection(LogonSectionHeader,S3storeFalseSetting) || findSettingInSection(LogonSectionHeader,S3storeTrueSetting)) & findSettingInSection(IBGatewaySectionHeader,ApiOnlyTrueSetting);
}",0.9979550102249488
29310,"private static void writeLogonSectionHeader(BufferedWriter w) throws IOException {
  w.write(LogonSectionHeader);
  w.newLine();
}","private static void writeLogonSectionHeader(BufferedWriter w) throws IOException {
  writeIniFileLine(LogonSectionHeader,w);
}",0.890625
29311,"private static boolean findSettingInSection(String section,String setting){
  ListIterator<String> it=lines.listIterator();
  boolean error=false;
  while (it.hasNext() && !error) {
    String l=it.next();
    if (l.compareTo(section) == 0) {
      Utils.logToConsole(""String_Node_Str"" + section);
      while (it.hasNext() && !error) {
        l=it.next();
        if (l.startsWith(""String_Node_Str"")) {
          error=true;
        }
 else         if (l.compareTo(setting) == 0) {
          Utils.logToConsole(""String_Node_Str"" + setting);
          return true;
        }
      }
    }
  }
  return false;
}","private static boolean findSettingInSection(String section,String setting){
  ListIterator<String> it=lines.listIterator();
  while (it.hasNext()) {
    String l=it.next();
    if (l.compareTo(section) == 0) {
      Utils.logToConsole(""String_Node_Str"" + section);
      while (it.hasNext()) {
        l=it.next();
        if (l.startsWith(""String_Node_Str"")) {
          break;
        }
 else         if (l.compareTo(setting) == 0) {
          Utils.logToConsole(""String_Node_Str"" + setting);
          return true;
        }
      }
      Utils.logToConsole(""String_Node_Str"" + setting);
      return false;
    }
  }
  Utils.logToConsole(""String_Node_Str"" + section);
  return false;
}",0.8584615384615385
29312,"private static void writeS3store(BufferedWriter w) throws IOException {
  w.write(S3storeTrueSetting);
  w.newLine();
}","private static void writeS3store(BufferedWriter w) throws IOException {
  writeIniFileLine(S3storeTrueSetting,w);
}",0.8803418803418803
29313,"private static void writeIBGatewaySectionHeader(BufferedWriter w) throws IOException {
  w.write(IBGatewaySectionHeader);
  w.newLine();
}","private static void writeIBGatewaySectionHeader(BufferedWriter w) throws IOException {
  writeIniFileLine(IBGatewaySectionHeader,w);
}",0.8970588235294118
29314,"protected final void setTradingModeCombo(final Window window){
  if (SwingUtils.findLabel(window,""String_Node_Str"") != null) {
    JComboBox<?> tradingModeCombo=SwingUtils.findComboBox(window,0);
    if (tradingModeCombo != null) {
      String tradingMode=TradingModeManager.tradingModeManager().getTradingMode();
      Utils.logToConsole(""String_Node_Str"" + tradingMode);
      if (tradingMode.equalsIgnoreCase(TradingModeManager.TRADING_MODE_LIVE)) {
        tradingModeCombo.setSelectedItem(""String_Node_Str"");
      }
 else {
        tradingModeCombo.setSelectedItem(""String_Node_Str"");
      }
    }
  }
}","protected final void setTradingModeCombo(final Window window){
  if (SwingUtils.findLabel(window,""String_Node_Str"") != null) {
    JComboBox<?> tradingModeCombo;
    if (Settings.settings().getBoolean(""String_Node_Str"",false)) {
      tradingModeCombo=SwingUtils.findComboBox(window,1);
    }
 else {
      tradingModeCombo=SwingUtils.findComboBox(window,0);
    }
    if (tradingModeCombo != null) {
      String tradingMode=TradingModeManager.tradingModeManager().getTradingMode();
      Utils.logToConsole(""String_Node_Str"" + tradingMode);
      if (tradingMode.equalsIgnoreCase(TradingModeManager.TRADING_MODE_LIVE)) {
        tradingModeCombo.setSelectedItem(""String_Node_Str"");
      }
 else {
        tradingModeCombo.setSelectedItem(""String_Node_Str"");
      }
    }
  }
}",0.8785046728971962
29315,"static void setupDefaultEnvironment(final String[] args,final boolean isGateway) throws Exception {
  Environment.load(new Callable<Settings>(){
    @Override public Settings call(){
      return new DefaultSettings(getSettingsPath(args));
    }
  }
,new Callable<LoginManager>(){
    @Override public LoginManager call(){
      return new DefaultLoginManager(args);
    }
  }
,new Callable<MainWindowManager>(){
    @Override public MainWindowManager call(){
      return new DefaultMainWindowManager(isGateway);
    }
  }
,new Callable<ConfigDialogManager>(){
    @Override public ConfigDialogManager call(){
      return new DefaultConfigDialogManager(isGateway);
    }
  }
,new Callable<TradingModeManager>(){
    @Override public TradingModeManager call(){
      return new DefaultTradingModeManager(args);
    }
  }
);
}","static void setupDefaultEnvironment(final String[] args,final boolean isGateway) throws Exception {
  Environment.load(new Callable<Settings>(){
    @Override public Settings call(){
      return new DefaultSettings(getSettingsPath(args));
    }
  }
,new Callable<LoginManager>(){
    @Override public LoginManager call(){
      return new DefaultLoginManager(args);
    }
  }
,new Callable<MainWindowManager>(){
    @Override public MainWindowManager call(){
      return new DefaultMainWindowManager(isGateway);
    }
  }
,new Callable<ConfigDialogManager>(){
    @Override public ConfigDialogManager call(){
      return new DefaultConfigDialogManager();
    }
  }
,new Callable<TradingModeManager>(){
    @Override public TradingModeManager call(){
      return new DefaultTradingModeManager(args);
    }
  }
);
}",0.9945222154595252
29316,"/** 
 * starts up the TWS app.
 * @param args -If length == 1, then args[0] is the path to the ini file. If length == 0, we assume that the ini file is located in the current user directory in a file called ""IBController.ini"". If length == 2 and args[0] is ""encrypt"", we print out the encryption of args[1].
 * @throws java.lang.Exception
 */
public static void main(final String[] args) throws Exception {
  checkArguments(args);
  setupDefaultEnvironment(args,false);
  load(false);
}","public static void main(final String[] args) throws Exception {
  checkArguments(args);
  setupDefaultEnvironment(args,false);
  load();
}",0.4423076923076923
29317,"public static void load(boolean isGateway){
  printProperties();
  Environment.verify();
  startIBControllerServer(isGateway);
  startShutdownTimerIfRequired(isGateway);
  createToolkitListener();
  startSavingTwsSettingsAutomatically();
  startTwsOrGateway(isGateway);
}","public static void load(){
  printProperties();
  Environment.verify();
  boolean isGateway=Environment.mainWindowManager().isGateway();
  startIBControllerServer(isGateway);
  startShutdownTimerIfRequired(isGateway);
  createToolkitListener();
  startSavingTwsSettingsAutomatically();
  startTwsOrGateway(isGateway);
}",0.8135593220338984
29318,"public IBController(){
  super();
}","/** 
 * starts up the TWS app.
 * @param args -If length == 1, then args[0] is the path to the ini file. If length == 0, we assume that the ini file is located in the current user directory in a file called ""IBController.ini"". If length == 2 and args[0] is ""encrypt"", we print out the encryption of args[1].
 * @throws java.lang.Exception
 */
private IBController(){
}",0.0893300248138957
29319,"public static void main(String[] args) throws Exception {
  checkArguments(args);
  setupDefaultEnvironment(args,true);
  IBController.load(true);
}","public static void main(String[] args) throws Exception {
  checkArguments(args);
  setupDefaultEnvironment(args,true);
  IBController.load();
}",0.9863013698630136
29320,"@Override protected Statement visitVeLogNode(VeLogNode node){
  final Label restartPoint=new Label();
  final Expression hasLogger=parameterLookup.getRenderContext().hasLogger();
  final boolean hasLogonlyExpression=node.getLogonlyExpression() != null;
  final Expression logonlyExpression=hasLogonlyExpression ? exprCompiler.compile(node.getLogonlyExpression(),restartPoint).unboxAs(boolean.class) : BytecodeUtils.constant(false);
  final Statement enterStatement=appendableExpression.enterLoggableElement(MethodRef.LOG_STATEMENT_CREATE.invoke(BytecodeUtils.constant(node.getLoggingId()),node.getConfigExpression() == null ? BytecodeUtils.constantNull(BytecodeUtils.MESSAGE_TYPE) : exprCompiler.compile(node.getConfigExpression(),restartPoint).unboxAs(Message.class),logonlyExpression)).toStatement();
  final Statement body=Statement.concat(visitChildren(node));
  final Statement exitStatement=appendableExpression.exitLoggableElement().toStatement();
  return new Statement(){
    @Override protected void doGen(    CodeBuilder cb){
      Label noLogger=new Label();
      hasLogger.gen(cb);
      cb.ifZCmp(EQ,noLogger);
      enterStatement.gen(cb);
      if (hasLogonlyExpression) {
        Label bodyLabel=new Label();
        cb.goTo(bodyLabel);
        cb.mark(noLogger);
        logonlyExpression.gen(cb);
        cb.ifZCmp(EQ,bodyLabel);
        cb.throwException(BytecodeUtils.ILLEGAL_STATE_EXCEPTION_TYPE,""String_Node_Str"");
        cb.mark(bodyLabel);
      }
 else {
        cb.mark(noLogger);
      }
      body.gen(cb);
      Label end=new Label();
      hasLogger.gen(cb);
      cb.ifZCmp(EQ,end);
      exitStatement.gen(cb);
      cb.mark(end);
    }
  }
.labelStart(restartPoint);
}","@Override protected Statement visitVeLogNode(final VeLogNode node){
  final Label restartPoint=new Label();
  final Expression configExpression=node.getConfigExpression() == null ? BytecodeUtils.constantNull(BytecodeUtils.MESSAGE_TYPE) : exprCompiler.compile(node.getConfigExpression(),restartPoint).unboxAs(Message.class);
  final Expression hasLogger=parameterLookup.getRenderContext().hasLogger();
  final Statement body=Statement.concat(visitChildren(node));
  final Statement exitStatement=ControlFlow.IfBlock.create(hasLogger,appendableExpression.exitLoggableElement().toStatement()).asStatement();
  if (node.getLogonlyExpression() != null) {
    final Expression logonlyExpression=exprCompiler.compile(node.getLogonlyExpression(),restartPoint).unboxAs(boolean.class);
    final Expression appendable=appendableExpression;
    return new Statement(){
      @Override protected void doGen(      CodeBuilder cb){
        cb.mark(restartPoint);
        logonlyExpression.gen(cb);
        Label noLogger=new Label();
        hasLogger.gen(cb);
        cb.ifZCmp(EQ,noLogger);
        cb.pushLong(node.getLoggingId());
        cb.dup2X1();
        cb.pop2();
        configExpression.gen(cb);
        cb.swap();
        MethodRef.LOG_STATEMENT_CREATE.invokeUnchecked(cb);
        appendable.gen(cb);
        cb.swap();
        AppendableExpression.ENTER_LOGGABLE_STATEMENT.invokeUnchecked(cb);
        cb.pop();
        Label bodyLabel=new Label();
        cb.goTo(bodyLabel);
        cb.mark(noLogger);
        cb.ifZCmp(EQ,bodyLabel);
        cb.throwException(BytecodeUtils.ILLEGAL_STATE_EXCEPTION_TYPE,""String_Node_Str"");
        cb.mark(bodyLabel);
        body.gen(cb);
        exitStatement.gen(cb);
      }
    }
;
  }
 else {
    final Statement enterStatement=ControlFlow.IfBlock.create(hasLogger,appendableExpression.enterLoggableElement(MethodRef.LOG_STATEMENT_CREATE.invoke(BytecodeUtils.constant(node.getLoggingId()),configExpression,BytecodeUtils.constant(false))).toStatement().labelStart(restartPoint)).asStatement();
    ;
    return Statement.concat(enterStatement,body,exitStatement);
  }
}",0.2741090146750524
29321,"@Override protected void doGen(CodeBuilder cb){
  Label noLogger=new Label();
  hasLogger.gen(cb);
  cb.ifZCmp(EQ,noLogger);
  enterStatement.gen(cb);
  if (hasLogonlyExpression) {
    Label bodyLabel=new Label();
    cb.goTo(bodyLabel);
    cb.mark(noLogger);
    logonlyExpression.gen(cb);
    cb.ifZCmp(EQ,bodyLabel);
    cb.throwException(BytecodeUtils.ILLEGAL_STATE_EXCEPTION_TYPE,""String_Node_Str"");
    cb.mark(bodyLabel);
  }
 else {
    cb.mark(noLogger);
  }
  body.gen(cb);
  Label end=new Label();
  hasLogger.gen(cb);
  cb.ifZCmp(EQ,end);
  exitStatement.gen(cb);
  cb.mark(end);
}","@Override protected void doGen(CodeBuilder cb){
  cb.mark(restartPoint);
  logonlyExpression.gen(cb);
  Label noLogger=new Label();
  hasLogger.gen(cb);
  cb.ifZCmp(EQ,noLogger);
  cb.pushLong(node.getLoggingId());
  cb.dup2X1();
  cb.pop2();
  configExpression.gen(cb);
  cb.swap();
  MethodRef.LOG_STATEMENT_CREATE.invokeUnchecked(cb);
  appendable.gen(cb);
  cb.swap();
  AppendableExpression.ENTER_LOGGABLE_STATEMENT.invokeUnchecked(cb);
  cb.pop();
  Label bodyLabel=new Label();
  cb.goTo(bodyLabel);
  cb.mark(noLogger);
  cb.ifZCmp(EQ,bodyLabel);
  cb.throwException(BytecodeUtils.ILLEGAL_STATE_EXCEPTION_TYPE,""String_Node_Str"");
  cb.mark(bodyLabel);
  body.gen(cb);
  exitStatement.gen(cb);
}",0.4305555555555556
29322,"/** 
 * Return whether the given root node is a constant expression or not. Pure functions are considered constant iff their parameter is a constant expression.
 * @param rootSoyNode the root of the expression tree.
 * @return {@code true} if the expression is constant in evaluation, {@code false} otherwise.
 */
public static boolean isConstantExpr(ExprNode rootSoyNode){
class ConstantNodeVisitor implements NodeVisitor<Node,VisitDirective> {
    boolean isConstant=true;
    @Override public VisitDirective exec(    Node node){
switch (((ExprNode)node).getKind()) {
case VAR_REF_NODE:
        isConstant=false;
      return VisitDirective.ABORT;
case FUNCTION_NODE:
    FunctionNode fn=(FunctionNode)node;
  if (fn.getSoyFunction() != null && fn.getSoyFunction().getClass().isAnnotationPresent(SoyPureFunction.class)) {
    return VisitDirective.CONTINUE;
  }
 else {
    return VisitDirective.ABORT;
  }
default :
return VisitDirective.CONTINUE;
}
}
}
ConstantNodeVisitor visitor=new ConstantNodeVisitor();
visitAllNodes(rootSoyNode,visitor);
return visitor.isConstant;
}","/** 
 * Return whether the given root node is a constant expression or not. Pure functions are considered constant iff their parameter is a constant expression.
 * @param rootSoyNode the root of the expression tree.
 * @return {@code true} if the expression is constant in evaluation, {@code false} otherwise.
 */
public static boolean isConstantExpr(ExprNode rootSoyNode){
class ConstantNodeVisitor implements NodeVisitor<Node,VisitDirective> {
    boolean isConstant=true;
    @Override public VisitDirective exec(    Node node){
switch (((ExprNode)node).getKind()) {
case VAR_REF_NODE:
        isConstant=false;
      return VisitDirective.ABORT;
case FUNCTION_NODE:
    FunctionNode fn=(FunctionNode)node;
  if (fn.getSoyFunction() != null && fn.getSoyFunction().getClass().isAnnotationPresent(SoyPureFunction.class)) {
    return VisitDirective.CONTINUE;
  }
 else {
    isConstant=false;
    return VisitDirective.ABORT;
  }
default :
return VisitDirective.CONTINUE;
}
}
}
ConstantNodeVisitor visitor=new ConstantNodeVisitor();
visitAllNodes(rootSoyNode,visitor);
return visitor.isConstant;
}",0.9898804047838088
29323,"@Override public VisitDirective exec(Node node){
switch (((ExprNode)node).getKind()) {
case VAR_REF_NODE:
    isConstant=false;
  return VisitDirective.ABORT;
case FUNCTION_NODE:
FunctionNode fn=(FunctionNode)node;
if (fn.getSoyFunction() != null && fn.getSoyFunction().getClass().isAnnotationPresent(SoyPureFunction.class)) {
return VisitDirective.CONTINUE;
}
 else {
return VisitDirective.ABORT;
}
default :
return VisitDirective.CONTINUE;
}
}","@Override public VisitDirective exec(Node node){
switch (((ExprNode)node).getKind()) {
case VAR_REF_NODE:
    isConstant=false;
  return VisitDirective.ABORT;
case FUNCTION_NODE:
FunctionNode fn=(FunctionNode)node;
if (fn.getSoyFunction() != null && fn.getSoyFunction().getClass().isAnnotationPresent(SoyPureFunction.class)) {
return VisitDirective.CONTINUE;
}
 else {
isConstant=false;
return VisitDirective.ABORT;
}
default :
return VisitDirective.CONTINUE;
}
}",0.9801762114537445
29324,"@Test public final void testIsNonConstantExpr() throws Exception {
  String testFileContent=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  SoyFileSetNode soyTree=SoyFileSetParserBuilder.forFileContents(testFileContent).addSoyFunction(ASSERT_IS_NONCONST_FUNCTION).parse().fileSet();
  assertIsConsts(soyTree);
}","@Test public final void testIsNonConstantExpr() throws Exception {
  String testFileContent=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  SoyFileSetNode soyTree=SoyFileSetParserBuilder.forFileContents(testFileContent).addSoyFunction(ASSERT_IS_NONCONST_FUNCTION).addSoyFunction(NONPURE_FUNCTION).parse().fileSet();
  assertIsConsts(soyTree);
}",0.9439655172413792
29325,"/** 
 * Converts the parameter to a   {@link SoyMap}. 
 */
public static SoyMap legacyObjectMapToMap(SoyLegacyObjectMap map){
  ImmutableMap.Builder<SoyValue,SoyValueProvider> builder=ImmutableMap.builder();
  for (  SoyValue key : map.getItemKeys()) {
    builder.put(key,map.getItemProvider(key));
  }
  return SoyMapImpl.forProviderMap(builder.build());
}","/** 
 * Converts the parameter to a   {@link SoyMap}. 
 */
public static SoyMap legacyObjectMapToMap(SoyLegacyObjectMap map){
  Map<SoyValue,SoyValueProvider> newMap=new LinkedHashMap<>();
  for (  SoyValue key : map.getItemKeys()) {
    newMap.put(key,map.getItemProvider(key));
  }
  return SoyMapImpl.forProviderMap(newMap);
}",0.4192139737991266
29326,"private SoyMapImpl(Map<? extends SoyValue,? extends SoyValueProvider> providerMap){
  this.providerMap=ImmutableMap.copyOf(checkNotNull(providerMap));
}","private SoyMapImpl(Map<? extends SoyValue,? extends SoyValueProvider> providerMap){
  checkNotNull(providerMap);
  if (providerMap.containsKey(null)) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",providerMap.get(null)));
  }
  this.providerMap=Collections.unmodifiableMap(providerMap);
}",0.4892703862660944
29327,"@Override public int hashCode(){
  return getValue().hashCode();
}","@Override public int hashCode(){
  return stringValue().hashCode();
}",0.9481481481481482
29328,"private SoyValue visitLegacyObjectMapLiteralOrMapLiteralNode(AbstractParentExprNode node){
  checkState(node.getKind() == ExprNode.Kind.LEGACY_OBJECT_MAP_LITERAL_NODE || node.getKind() == ExprNode.Kind.MAP_LITERAL_NODE);
  int numItems=node.numChildren() / 2;
  boolean isStringKeyed=true;
  ExprNode firstNonstringKeyNode=null;
  List<SoyValue> keys=Lists.newArrayListWithCapacity(numItems);
  List<SoyValue> values=Lists.newArrayListWithCapacity(numItems);
  for (int i=0; i < numItems; i++) {
    SoyValue key=visit(node.getChild(2 * i));
    if (isStringKeyed && !(key instanceof StringData)) {
      isStringKeyed=false;
      firstNonstringKeyNode=node.getChild(2 * i);
    }
    keys.add(key);
    values.add(visit(node.getChild(2 * i + 1)));
  }
  if (node.getKind() == ExprNode.Kind.LEGACY_OBJECT_MAP_LITERAL_NODE) {
    if (!isStringKeyed) {
      throw RenderException.create(String.format(""String_Node_Str"" + ""String_Node_Str"",firstNonstringKeyNode.toSourceString(),node.toSourceString()));
    }
    Map<String,SoyValue> map=new LinkedHashMap<>();
    for (int i=0; i < numItems; i++) {
      map.put(keys.get(i).stringValue(),values.get(i));
    }
    return DictImpl.forProviderMap(map,RuntimeMapTypeTracker.Type.LEGACY_OBJECT_MAP_OR_RECORD);
  }
 else {
    ImmutableMap.Builder<SoyValue,SoyValue> builder=ImmutableMap.builder();
    for (int i=0; i < numItems; ++i) {
      SoyValue key=keys.get(i);
      SoyValue value=values.get(i);
      if (isNullOrUndefinedBase(key)) {
        throw RenderException.create(String.format(""String_Node_Str"",value));
      }
      builder.put(key,value);
    }
    return SoyMapImpl.forProviderMap(builder.build());
  }
}","private SoyValue visitLegacyObjectMapLiteralOrMapLiteralNode(AbstractParentExprNode node){
  checkState(node.getKind() == ExprNode.Kind.LEGACY_OBJECT_MAP_LITERAL_NODE || node.getKind() == ExprNode.Kind.MAP_LITERAL_NODE);
  int numItems=node.numChildren() / 2;
  boolean isStringKeyed=true;
  ExprNode firstNonstringKeyNode=null;
  List<SoyValue> keys=Lists.newArrayListWithCapacity(numItems);
  List<SoyValue> values=Lists.newArrayListWithCapacity(numItems);
  for (int i=0; i < numItems; i++) {
    SoyValue key=visit(node.getChild(2 * i));
    if (isStringKeyed && !(key instanceof StringData)) {
      isStringKeyed=false;
      firstNonstringKeyNode=node.getChild(2 * i);
    }
    keys.add(key);
    values.add(visit(node.getChild(2 * i + 1)));
  }
  if (node.getKind() == ExprNode.Kind.LEGACY_OBJECT_MAP_LITERAL_NODE) {
    if (!isStringKeyed) {
      throw RenderException.create(String.format(""String_Node_Str"" + ""String_Node_Str"",firstNonstringKeyNode.toSourceString(),node.toSourceString()));
    }
    Map<String,SoyValue> map=new LinkedHashMap<>();
    for (int i=0; i < numItems; i++) {
      map.put(keys.get(i).stringValue(),values.get(i));
    }
    return DictImpl.forProviderMap(map,RuntimeMapTypeTracker.Type.LEGACY_OBJECT_MAP_OR_RECORD);
  }
 else {
    Map<SoyValue,SoyValue> map=new LinkedHashMap<>();
    for (int i=0; i < numItems; ++i) {
      SoyValue key=keys.get(i);
      SoyValue value=values.get(i);
      if (isNullOrUndefinedBase(key)) {
        throw RenderException.create(String.format(""String_Node_Str"",value));
      }
      map.put(key,value);
    }
    return SoyMapImpl.forProviderMap(map);
  }
}",0.9728260869565216
29329,"@Test public void testUnsanitizedText(){
  assertThat(SanitizedContents.unsanitizedText(""String_Node_Str"")).isEqualTo(SanitizedContent.create(""String_Node_Str"",ContentKind.TEXT,null));
}","@Test public void testUnsanitizedText(){
  SanitizedContent unsanitized=SanitizedContents.unsanitizedText(""String_Node_Str"");
  assertThat(unsanitized.getContent()).isEqualTo(""String_Node_Str"");
  assertThat(unsanitized.getContentKind()).isEqualTo(ContentKind.TEXT);
  assertThat(unsanitized.getContentDirection()).isEqualTo(null);
}",0.5549132947976878
29330,"@Test public void testOrdainAsSafeWithDir(){
  assertThat(UnsafeSanitizedContentOrdainer.ordainAsSafe(""String_Node_Str"",ContentKind.TEXT,Dir.LTR)).isEqualTo(SanitizedContent.create(""String_Node_Str"",ContentKind.TEXT,Dir.LTR));
  assertThat(UnsafeSanitizedContentOrdainer.ordainAsSafe(""String_Node_Str"",ContentKind.TEXT,Dir.RTL)).isEqualTo(SanitizedContent.create(""String_Node_Str"",ContentKind.TEXT,Dir.RTL));
  assertThat(UnsafeSanitizedContentOrdainer.ordainAsSafe(""String_Node_Str"",ContentKind.TEXT,Dir.NEUTRAL)).isEqualTo(SanitizedContent.create(""String_Node_Str"",ContentKind.TEXT,Dir.NEUTRAL));
}","@Test public void testOrdainAsSafeWithDir(){
  assertThat(UnsafeSanitizedContentOrdainer.ordainAsSafe(""String_Node_Str"",ContentKind.TEXT,Dir.LTR)).isEqualTo(SanitizedContents.unsanitizedText(""String_Node_Str"",Dir.LTR));
  assertThat(UnsafeSanitizedContentOrdainer.ordainAsSafe(""String_Node_Str"",ContentKind.TEXT,Dir.RTL)).isEqualTo(SanitizedContents.unsanitizedText(""String_Node_Str"",Dir.RTL));
  assertThat(UnsafeSanitizedContentOrdainer.ordainAsSafe(""String_Node_Str"",ContentKind.TEXT,Dir.NEUTRAL)).isEqualTo(SanitizedContents.unsanitizedText(""String_Node_Str"",Dir.NEUTRAL));
}",0.8956743002544529
29331,"@Test public void testOrdainAsSafe(){
  assertThat(UnsafeSanitizedContentOrdainer.ordainAsSafe(""String_Node_Str"",ContentKind.TEXT)).isEqualTo(SanitizedContent.create(""String_Node_Str"",ContentKind.TEXT,null));
  assertThat(UnsafeSanitizedContentOrdainer.ordainAsSafe(""String_Node_Str"",ContentKind.HTML)).isEqualTo(SanitizedContent.create(""String_Node_Str"",ContentKind.HTML,null));
  assertThat(UnsafeSanitizedContentOrdainer.ordainAsSafe(""String_Node_Str"",ContentKind.JS)).isEqualTo(SanitizedContent.create(""String_Node_Str"",ContentKind.JS,Dir.LTR));
  assertThat(UnsafeSanitizedContentOrdainer.ordainAsSafe(""String_Node_Str"",ContentKind.CSS)).isEqualTo(SanitizedContent.create(""String_Node_Str"",ContentKind.CSS,Dir.LTR));
  assertThat(UnsafeSanitizedContentOrdainer.ordainAsSafe(""String_Node_Str"",ContentKind.URI)).isEqualTo(SanitizedContent.create(""String_Node_Str"",ContentKind.URI,Dir.LTR));
  assertThat(UnsafeSanitizedContentOrdainer.ordainAsSafe(""String_Node_Str"",ContentKind.ATTRIBUTES)).isEqualTo(SanitizedContent.create(""String_Node_Str"",ContentKind.ATTRIBUTES,Dir.LTR));
}","@Test public void testOrdainAsSafe(){
  assertThat(UnsafeSanitizedContentOrdainer.ordainAsSafe(""String_Node_Str"",ContentKind.TEXT)).isEqualTo(SanitizedContents.unsanitizedText(""String_Node_Str"",null));
  assertThat(UnsafeSanitizedContentOrdainer.ordainAsSafe(""String_Node_Str"",ContentKind.HTML)).isEqualTo(SanitizedContent.create(""String_Node_Str"",ContentKind.HTML,null));
  assertThat(UnsafeSanitizedContentOrdainer.ordainAsSafe(""String_Node_Str"",ContentKind.JS)).isEqualTo(SanitizedContent.create(""String_Node_Str"",ContentKind.JS,Dir.LTR));
  assertThat(UnsafeSanitizedContentOrdainer.ordainAsSafe(""String_Node_Str"",ContentKind.CSS)).isEqualTo(SanitizedContent.create(""String_Node_Str"",ContentKind.CSS,Dir.LTR));
  assertThat(UnsafeSanitizedContentOrdainer.ordainAsSafe(""String_Node_Str"",ContentKind.URI)).isEqualTo(SanitizedContent.create(""String_Node_Str"",ContentKind.URI,Dir.LTR));
  assertThat(UnsafeSanitizedContentOrdainer.ordainAsSafe(""String_Node_Str"",ContentKind.ATTRIBUTES)).isEqualTo(SanitizedContent.create(""String_Node_Str"",ContentKind.ATTRIBUTES,Dir.LTR));
}",0.9642691415313224
29332,"/** 
 * Helper for   {@code setSoyDoc()} and {@code setHeaderDecls()}. This method is intended to be called at most once for SoyDoc params and at most once for header params.
 * @param params The params to add.
 */
public TemplateNodeBuilder addParams(Iterable<? extends TemplateParam> newParams){
  Set<String> seenParamKeys=new HashSet<>();
  boolean hasTemplateHeaderParams=false;
  if (this.params == null) {
    this.params=ImmutableList.copyOf(newParams);
  }
 else {
    for (    TemplateParam oldParam : this.params) {
      seenParamKeys.add(oldParam.name());
      hasTemplateHeaderParams|=oldParam.declLoc() == TemplateParam.DeclLoc.HEADER;
    }
    this.params=ImmutableList.<TemplateParam>builder().addAll(this.params).addAll(newParams).build();
  }
  for (  TemplateParam param : newParams) {
    hasTemplateHeaderParams|=param.declLoc() == TemplateParam.DeclLoc.HEADER;
    if (param.name().equals(""String_Node_Str"")) {
      errorReporter.report(param.nameLocation(),INVALID_PARAM_NAMED_IJ);
    }
    if (!seenParamKeys.add(param.name())) {
      errorReporter.report(param.nameLocation(),PARAM_ALREADY_DECLARED,param.name());
    }
  }
  if (hasTemplateHeaderParams) {
    for (    TemplateParam param : this.params) {
      if (param.declLoc() == TemplateParam.DeclLoc.SOY_DOC) {
        errorReporter.report(param.nameLocation(),MIXED_PARAM_STYLES);
      }
    }
  }
  return this;
}","/** 
 * Helper for   {@code setSoyDoc()} and {@code setHeaderDecls()}. This method is intended to be called at most once for SoyDoc params and at most once for header params.
 * @param params The params to add.
 */
public TemplateNodeBuilder addParams(Iterable<? extends TemplateParam> newParams){
  Set<String> seenParamKeys=new HashSet<>();
  boolean hasTemplateHeaderParams=false;
  if (this.params == null) {
    this.params=ImmutableList.copyOf(newParams);
  }
 else {
    for (    TemplateParam oldParam : this.params) {
      seenParamKeys.add(oldParam.name());
      hasTemplateHeaderParams|=oldParam.declLoc() == TemplateParam.DeclLoc.HEADER;
    }
    this.params=ImmutableList.<TemplateParam>builder().addAll(this.params).addAll(newParams).build();
  }
  for (  TemplateParam param : newParams) {
    hasTemplateHeaderParams|=param.declLoc() == TemplateParam.DeclLoc.HEADER;
    if (param.name().equals(""String_Node_Str"")) {
      errorReporter.report(param.nameLocation(),INVALID_PARAM_NAMED_IJ);
    }
    if (!seenParamKeys.add(param.name())) {
      errorReporter.report(param.nameLocation(),PARAM_ALREADY_DECLARED,param.name());
    }
  }
  if (hasTemplateHeaderParams) {
    for (    TemplateParam param : this.params) {
      if (param.declLoc() == TemplateParam.DeclLoc.SOY_DOC && !DISABLE_MIXED_PARAMS_ERROR_FOR_MIGRATION) {
        errorReporter.report(param.nameLocation(),MIXED_PARAM_STYLES,param.nameLocation().getFilePath());
      }
    }
  }
  return this;
}",0.972318339100346
29333,"/** 
 * Sets the internal state to   {@link Type#MAP}. If the state has already been set, throws an exception.
 */
public void maybeSetMapType(){
  if (type == Type.UNKNOWN) {
    type=Type.MAP;
  }
 else   if (type == Type.LEGACY_OBJECT_MAP_OR_RECORD) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
}","/** 
 * Sets the internal state to   {@link Type#MAP}. If the state has already been set, throws an exception.
 */
public void maybeSetMapType(){
  if (type == Type.UNKNOWN) {
    type=Type.MAP;
  }
 else   if (type == Type.LEGACY_OBJECT_MAP_OR_RECORD) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
}",0.9740082079343364
29334,"/** 
 * Sets the internal state to   {@link Type#LEGACY_OBJECT_MAP_OR_RECORD}. If the state has already been set, throws an exception.
 */
public void maybeSetLegacyObjectMapOrRecordType(){
  if (type == Type.UNKNOWN) {
    type=Type.LEGACY_OBJECT_MAP_OR_RECORD;
  }
 else   if (type == Type.MAP) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
}","/** 
 * Sets the internal state to   {@link Type#LEGACY_OBJECT_MAP_OR_RECORD}. If the state has already been set, throws an exception.
 */
public void maybeSetLegacyObjectMapOrRecordType(){
  if (type == Type.UNKNOWN) {
    type=Type.LEGACY_OBJECT_MAP_OR_RECORD;
  }
 else   if (type == Type.MAP) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
}",0.9768009768009768
29335,"@Test public void testMapInteroperability(){
  Map<String,SoyValueProvider> providerMap=new HashMap<>();
  DictImpl dict=DictImpl.forProviderMap(providerMap,RuntimeMapTypeTracker.Type.UNKNOWN);
  assertThat(dict.size()).isEqualTo(0);
  try {
    dict.getItemCnt();
    fail();
  }
 catch (  IllegalStateException e) {
    assertThat(e).hasMessageThat().isEqualTo(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
  dict=DictImpl.forProviderMap(providerMap,RuntimeMapTypeTracker.Type.UNKNOWN);
  assertThat(dict.getItemCnt()).isEqualTo(0);
  try {
    dict.keys();
    fail();
  }
 catch (  IllegalStateException e) {
    assertThat(e).hasMessageThat().isEqualTo(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
}","@Test public void testMapInteroperability(){
  Map<String,SoyValueProvider> providerMap=new HashMap<>();
  DictImpl dict=DictImpl.forProviderMap(providerMap,RuntimeMapTypeTracker.Type.UNKNOWN);
  assertThat(dict.size()).isEqualTo(0);
  try {
    dict.getItemCnt();
    fail();
  }
 catch (  IllegalStateException e) {
    assertThat(e).hasMessageThat().isEqualTo(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  dict=DictImpl.forProviderMap(providerMap,RuntimeMapTypeTracker.Type.UNKNOWN);
  assertThat(dict.getItemCnt()).isEqualTo(0);
  try {
    dict.keys();
    fail();
  }
 catch (  IllegalStateException e) {
    assertThat(e).hasMessageThat().isEqualTo(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
}",0.975
29336,"/** 
 * Returns what kind of type this is. 
 */
Kind getKind();","/** 
 * Returns what kind of type this is. 
 */
public abstract Kind getKind();",0.8873239436619719
29337,"/** 
 * Returns true if a parameter or field of this type can be assigned from a value of   {@code srcType}.
 * @param srcType The type of the incoming value.
 * @return True if the assignment is valid.
 */
boolean isAssignableFrom(SoyType srcType);","/** 
 * Returns true if a parameter or field of this type can be assigned from a value of   {@code srcType}.
 * @param srcType The type of the incoming value.
 * @return True if the assignment is valid.
 */
public final boolean isAssignableFrom(SoyType srcType){
  if (srcType instanceof UnionType) {
    UnionType asUnion=(UnionType)srcType;
    for (    SoyType member : asUnion.getMembers()) {
      if (!doIsAssignableFromNonUnionType(member)) {
        return false;
      }
    }
    return true;
  }
 else {
    return doIsAssignableFromNonUnionType(srcType);
  }
}",0.6065773447015834
29338,"/** 
 * Ensures that the directories in the given path exist, creating them if necessary. <p>Note: If the path does not end with the separator char (slash in Linux), then the name at the end is assumed to be the file name, so directories are only created down to its parent.
 * @param path The path for which to ensure directories exist.
 */
public static void ensureDirsExistInPath(String path){
  if (path == null || path.length() == 0) {
    throw new AssertionError(""String_Node_Str"");
  }
  String dirPath=(path.charAt(path.length() - 1) == File.separatorChar) ? path.substring(0,path.length() - 1) : (new File(path)).getParent();
  if (dirPath == null || KNOWN_EXISTING_DIRS.contains(dirPath)) {
    return;
  }
 else {
    (new File(dirPath)).mkdirs();
    KNOWN_EXISTING_DIRS.add(dirPath);
  }
}","/** 
 * Ensures that the directories in the given path exist, creating them if necessary. <p>Note: If the path does not end with the separator char (slash in Linux), then the name at the end is assumed to be the file name, so directories are only created down to its parent.
 * @param path The path for which to ensure directories exist.
 */
public static void ensureDirsExistInPath(String path){
  if (path == null || path.length() == 0) {
    throw new AssertionError(""String_Node_Str"");
  }
  String dirPath=(path.charAt(path.length() - 1) == File.separatorChar) ? path.substring(0,path.length() - 1) : (new File(path)).getParent();
  if (dirPath == null || knownExistingDirs.contains(dirPath)) {
    return;
  }
 else {
    (new File(dirPath)).mkdirs();
    knownExistingDirs.add(dirPath);
  }
}",0.9600499375780276
29339,"private SoyValue visitNullSafeFieldAccessNode(FieldAccessNode fieldAccess){
  SoyValue base=visitNullSafeNodeRecurse(fieldAccess.getBaseExprChild());
  if (!(base instanceof SoyRecord) && !(base instanceof SoyProtoValue)) {
    if (base == NullSafetySentinel.INSTANCE) {
      return NullSafetySentinel.INSTANCE;
    }
    if (fieldAccess.isNullSafe()) {
      if (isNullOrUndefinedBase(base)) {
        return NullSafetySentinel.INSTANCE;
      }
 else {
        throw RenderException.create(String.format(""String_Node_Str"",fieldAccess.toSourceString(),fieldAccess.getSourceStringSuffix()));
      }
    }
    return UndefinedData.INSTANCE;
  }
  if (fieldAccess.getBaseExprChild().getType().getKind() == Kind.PROTO) {
    return ((SoyProtoValue)base).getProtoField(fieldAccess.getFieldName());
  }
  maybeMarkBadProtoAccess(fieldAccess,base);
  SoyValue value=((SoyRecord)base).getField(fieldAccess.getFieldName());
  if (value != null && !TofuTypeChecks.isInstance(fieldAccess.getType(),value)) {
    throw RenderException.create(String.format(""String_Node_Str"",fieldAccess.getType(),value.getClass().getSimpleName()));
  }
  return (value != null) ? value : UndefinedData.INSTANCE;
}","private SoyValue visitNullSafeFieldAccessNode(FieldAccessNode fieldAccess){
  SoyValue base=visitNullSafeNodeRecurse(fieldAccess.getBaseExprChild());
  if (!(base instanceof SoyRecord) && !(base instanceof SoyProtoValue)) {
    if (base == NullSafetySentinel.INSTANCE) {
      return NullSafetySentinel.INSTANCE;
    }
    if (fieldAccess.isNullSafe()) {
      if (isNullOrUndefinedBase(base)) {
        return NullSafetySentinel.INSTANCE;
      }
 else {
        throw RenderException.create(String.format(""String_Node_Str"",fieldAccess.toSourceString(),fieldAccess.getSourceStringSuffix()));
      }
    }
    return UndefinedData.INSTANCE;
  }
  if (SoyTypes.tryRemoveNull(fieldAccess.getBaseExprChild().getType()).getKind() == Kind.PROTO) {
    return ((SoyProtoValue)base).getProtoField(fieldAccess.getFieldName());
  }
  maybeMarkBadProtoAccess(fieldAccess,base);
  SoyValue value=((SoyRecord)base).getField(fieldAccess.getFieldName());
  if (value != null && !TofuTypeChecks.isInstance(fieldAccess.getType(),value)) {
    throw RenderException.create(String.format(""String_Node_Str"",fieldAccess.getType(),value.getClass().getSimpleName()));
  }
  return (value != null) ? value : UndefinedData.INSTANCE;
}",0.9899916597164304
29340,"@VisibleForTesting SoyMsgBundleWithFullLocale(SoyMsgBundle delegate,ULocale locale,String localeString){
  this.delegate=delegate;
  this.locale=locale;
  this.localeString=localeString;
  this.isRtl=BidiGlobalDir.forStaticLocale(localeString) == BidiGlobalDir.RTL;
}","@VisibleForTesting SoyMsgBundleWithFullLocale(SoyMsgBundle delegate,ULocale locale,String localeString){
  while (delegate instanceof SoyMsgBundleWithFullLocale) {
    delegate=((SoyMsgBundleWithFullLocale)delegate).delegate;
  }
  this.delegate=delegate;
  this.locale=locale;
  this.localeString=localeString;
  this.isRtl=BidiGlobalDir.forStaticLocale(localeString) == BidiGlobalDir.RTL;
}",0.8103186646433991
29341,"/** 
 * Applies all the streaming print directives to the appendable.
 * @param directives The directives. All are required to be {@link com.google.template.soy.jbcsrc.restricted.SoyJbcSrcPrintDirective.Streamable streamable}
 * @param appendable The appendable to wrap
 * @param basic The expression compiler to use for compiling the arguments
 * @param renderContext The render context for the plugins
 * @return The wrapped appendable
 */
static Expression applyStreamingPrintDirectives(List<PrintDirectiveNode> directives,Expression appendable,BasicExpressionCompiler basic,JbcSrcPluginContext renderContext){
  for (  PrintDirectiveNode directive : directives) {
    appendable=((SoyJbcSrcPrintDirective.Streamable)directive.getPrintDirective()).applyForJbcSrcStreaming(renderContext,appendable,basic.compileToList(directive.getArgs()));
  }
  return appendable;
}","/** 
 * Applies all the streaming print directives to the appendable.
 * @param directives The directives. All are required to be {@link com.google.template.soy.jbcsrc.restricted.SoyJbcSrcPrintDirective.Streamable streamable}
 * @param appendable The appendable to wrap
 * @param basic The expression compiler to use for compiling the arguments
 * @param renderContext The render context for the plugins
 * @return The wrapped appendable
 */
static Expression applyStreamingPrintDirectives(List<PrintDirectiveNode> directives,Expression appendable,BasicExpressionCompiler basic,JbcSrcPluginContext renderContext){
  for (  PrintDirectiveNode directive : Lists.reverse(directives)) {
    appendable=((SoyJbcSrcPrintDirective.Streamable)directive.getPrintDirective()).applyForJbcSrcStreaming(renderContext,appendable,basic.compileToList(directive.getArgs()));
  }
  return appendable;
}",0.980034227039361
29342,"/** 
 * Applies all the streaming print directives to the appendable.
 * @param directives The directives. All are required to be {@link com.google.template.soy.jbcsrc.restricted.SoyJbcSrcPrintDirective.Streamable streamable}
 * @param appendable The appendable to wrap
 * @param context The render context for the plugins
 * @return The wrapped appendable
 */
static Expression applyStreamingEscapingDirectives(List<SoyPrintDirective> directives,Expression appendable,JbcSrcPluginContext context){
  for (  SoyPrintDirective directive : directives) {
    appendable=((SoyJbcSrcPrintDirective.Streamable)directive).applyForJbcSrcStreaming(context,appendable,ImmutableList.of());
  }
  return appendable;
}","/** 
 * Applies all the streaming print directives to the appendable.
 * @param directives The directives. All are required to be {@link com.google.template.soy.jbcsrc.restricted.SoyJbcSrcPrintDirective.Streamable streamable}
 * @param appendable The appendable to wrap
 * @param context The render context for the plugins
 * @return The wrapped appendable
 */
static Expression applyStreamingEscapingDirectives(List<SoyPrintDirective> directives,Expression appendable,JbcSrcPluginContext context){
  for (  SoyPrintDirective directive : Lists.reverse(directives)) {
    appendable=((SoyJbcSrcPrintDirective.Streamable)directive).applyForJbcSrcStreaming(context,appendable,ImmutableList.of());
  }
  return appendable;
}",0.975438596491228
29343,"@Override public LoggingAdvisingAppendable appendLoggingFunctionInvocation(LoggingFunctionInvocation funCall,ImmutableList<Function<String,String>> escapers) throws IOException {
  getDelegateForAppend().appendLoggingFunctionInvocation(funCall,escapers).append(""String_Node_Str"");
  return this;
}","@Override public LoggingAdvisingAppendable appendLoggingFunctionInvocation(LoggingFunctionInvocation funCall,ImmutableList<Function<String,String>> escapers) throws IOException {
  delegate.appendLoggingFunctionInvocation(funCall,escapers);
  return this;
}",0.8989169675090253
29344,"@Override public Expression applyForJbcSrcStreaming(JbcSrcPluginContext context,Expression delegateAppendable,List<SoyExpression> args){
  return ConstructorRef.create(AnnotatingAppendable.class,LoggingAdvisingAppendable.class).construct(delegateAppendable);
}","@Override public Expression applyForJbcSrcStreaming(JbcSrcPluginContext context,Expression delegateAppendable,List<SoyExpression> args){
  Expression wrapperText;
  if (!args.isEmpty()) {
    wrapperText=args.get(0).coerceToString();
  }
 else {
    wrapperText=BytecodeUtils.constant(""String_Node_Str"");
  }
  return ConstructorRef.create(AnnotatingAppendable.class,String.class,LoggingAdvisingAppendable.class).construct(wrapperText,delegateAppendable);
}",0.7252440725244073
29345,"public AnnotatingAppendable(LoggingAdvisingAppendable delegate){
  this.delegate=delegate;
}","public AnnotatingAppendable(String wrapperText,LoggingAdvisingAppendable delegate){
  this.delegate=delegate;
  this.wrapperText=wrapperText;
}",0.7829787234042553
29346,"/** 
 * Handles a complex message with placeholders. 
 */
private Statement handleTranslationWithPlaceholders(MsgNode msg,ImmutableList<SoyPrintDirective> escapingDirectives,Expression soyMsgParts,Expression locale,ImmutableList<SoyMsgPart> parts){
  Expression placeholderMap=variables.getMsgPlaceholderMapField().accessor(thisVar);
  Map<String,Statement> placeholderNameToPutStatement=new LinkedHashMap<>();
  putPlaceholdersIntoMap(placeholderMap,msg,parts,placeholderNameToPutStatement);
  checkState(!placeholderNameToPutStatement.isEmpty());
  variables.setMsgPlaceholderMapMinSize(placeholderNameToPutStatement.size());
  Statement populateMap=Statement.concat(placeholderNameToPutStatement.values());
  Statement clearMap=placeholderMap.invokeVoid(MethodRef.LINKED_HASH_MAP_CLEAR);
  Statement render;
  if (areAllPrintDirectivesStreamable(escapingDirectives)) {
    AppendableAndOptions wrappedAppendable=applyStreamingEscapingDirectives(escapingDirectives,appendableExpression,parameterLookup.getRenderContext());
    Statement initAppendable=Statement.NULL_STATEMENT;
    Statement clearAppendable=Statement.NULL_STATEMENT;
    Expression appendableExpression=wrappedAppendable.appendable();
    if (wrappedAppendable.closeable()) {
      Scope scope=variables.enterScope();
      Variable appendableVar=scope.createTemporary(""String_Node_Str"",wrappedAppendable.appendable());
      initAppendable=appendableVar.initializer();
      appendableExpression=appendableVar.local();
      clearAppendable=Statement.concat(appendableVar.local().checkedCast(BytecodeUtils.CLOSEABLE_TYPE).invokeVoid(MethodRef.CLOSEABLE_CLOSE),scope.exitScope());
    }
    render=Statement.concat(initAppendable,MethodRef.RUNTIME_RENDER_SOY_MSG_PARTS_WITH_PLACEHOLDERS.invokeVoid(soyMsgParts,locale,placeholderMap,appendableExpression),clearAppendable);
  }
 else {
    Statement renderToBuffer=MethodRef.RUNTIME_RENDER_SOY_MSG_PARTS_WITH_PLACEHOLDERS.invokeVoid(soyMsgParts,locale,placeholderMap,tempBuffer());
    SoyExpression value=SoyExpression.forString(tempBuffer().invoke(MethodRef.ADVISING_STRING_BUILDER_GET_AND_CLEAR));
    for (    SoyPrintDirective directive : escapingDirectives) {
      value=parameterLookup.getRenderContext().applyPrintDirective(directive,value);
    }
    render=Statement.concat(renderToBuffer,appendableExpression.appendString(value.coerceToString()).toStatement());
  }
  return Statement.concat(populateMap,render,clearMap);
}","/** 
 * Handles a complex message with placeholders. 
 */
private Statement handleTranslationWithPlaceholders(MsgNode msg,ImmutableList<SoyPrintDirective> escapingDirectives,Expression soyMsgParts,Expression locale,ImmutableList<SoyMsgPart> parts){
  Expression placeholderMap=variables.getMsgPlaceholderMapField().accessor(thisVar);
  Map<String,Statement> placeholderNameToPutStatement=new LinkedHashMap<>();
  putPlaceholdersIntoMap(placeholderMap,msg,parts,placeholderNameToPutStatement);
  checkState(!placeholderNameToPutStatement.isEmpty());
  variables.setMsgPlaceholderMapMinSize(placeholderNameToPutStatement.size());
  Statement populateMap=Statement.concat(placeholderNameToPutStatement.values());
  Statement clearMap=placeholderMap.invokeVoid(MethodRef.LINKED_HASH_MAP_CLEAR);
  Statement render;
  if (areAllPrintDirectivesStreamable(escapingDirectives)) {
    AppendableAndOptions wrappedAppendable=applyStreamingEscapingDirectives(escapingDirectives,appendableExpression,parameterLookup.getRenderContext(),variables);
    Statement initAppendable=Statement.NULL_STATEMENT;
    Statement clearAppendable=Statement.NULL_STATEMENT;
    Expression appendableExpression=wrappedAppendable.appendable();
    if (wrappedAppendable.closeable()) {
      Scope scope=variables.enterScope();
      Variable appendableVar=scope.createTemporary(""String_Node_Str"",wrappedAppendable.appendable());
      initAppendable=appendableVar.initializer();
      appendableExpression=appendableVar.local();
      clearAppendable=Statement.concat(appendableVar.local().checkedCast(BytecodeUtils.CLOSEABLE_TYPE).invokeVoid(MethodRef.CLOSEABLE_CLOSE),scope.exitScope());
    }
    render=Statement.concat(initAppendable,MethodRef.RUNTIME_RENDER_SOY_MSG_PARTS_WITH_PLACEHOLDERS.invokeVoid(soyMsgParts,locale,placeholderMap,appendableExpression),clearAppendable);
  }
 else {
    Statement renderToBuffer=MethodRef.RUNTIME_RENDER_SOY_MSG_PARTS_WITH_PLACEHOLDERS.invokeVoid(soyMsgParts,locale,placeholderMap,tempBuffer());
    SoyExpression value=SoyExpression.forString(tempBuffer().invoke(MethodRef.ADVISING_STRING_BUILDER_GET_AND_CLEAR));
    for (    SoyPrintDirective directive : escapingDirectives) {
      value=parameterLookup.getRenderContext().applyPrintDirective(directive,value);
    }
    render=Statement.concat(renderToBuffer,appendableExpression.appendString(value.coerceToString()).toStatement());
  }
  return Statement.concat(populateMap,render,clearMap);
}",0.997964997964998
29347,"private static <T>AppendableAndOptions applyStreamingPrintDirectivesTo(List<DirectiveWithArgs> directivesToApply,Expression appendable,JbcSrcPluginContext context){
  AppendableAndOptions prev=AppendableAndOptions.create(appendable);
  List<Expression> closeables=new ArrayList<>();
  for (  DirectiveWithArgs directiveToApply : Lists.reverse(directivesToApply)) {
    AppendableAndOptions curr=directiveToApply.apply(context,prev.appendable());
    if (curr.closeable()) {
      closeables.add(curr.appendable());
    }
    prev=curr;
  }
  if (closeables.isEmpty()) {
    return prev;
  }
  if (closeables.size() == 1 && prev.appendable() == closeables.get(0)) {
    return prev;
  }
  return AppendableAndOptions.createCloseable(RUNTIME_PROPAGATE_CLOSE.invoke(prev.appendable(),BytecodeUtils.asImmutableList(Lists.reverse(closeables))));
}","private static AppendableAndOptions applyStreamingPrintDirectivesTo(List<DirectiveWithArgs> directivesToApply,Expression appendable,JbcSrcPluginContext context,TemplateVariableManager variableManager){
  final List<LocalVariable> closeables=new ArrayList<>();
  final List<Variable> appendableVars=new ArrayList<>();
  Scope scope=variableManager.enterScope();
  AppendableAndOptions prev=AppendableAndOptions.create(appendable);
  Variable prevVar=scope.createTemporary(""String_Node_Str"",appendable);
  appendableVars.add(prevVar);
  for (  DirectiveWithArgs directiveToApply : Lists.reverse(directivesToApply)) {
    AppendableAndOptions curr=directiveToApply.apply(context,prevVar.local());
    Variable currVar=scope.createTemporary(""String_Node_Str"",curr.appendable());
    appendableVars.add(currVar);
    if (curr.closeable()) {
      closeables.add(currVar.local());
    }
    prev=curr;
    prevVar=currVar;
  }
  final Expression appendableExpression;
  final boolean closeable;
  if (closeables.isEmpty()) {
    appendableExpression=prev.appendable();
    closeable=false;
  }
 else   if (closeables.size() == 1 && prev.closeable()) {
    appendableExpression=prev.appendable();
    closeable=true;
  }
 else {
    appendableExpression=RUNTIME_PROPAGATE_CLOSE.invoke(Iterables.getLast(appendableVars).local(),BytecodeUtils.asImmutableList(Lists.reverse(closeables)));
    closeable=true;
  }
  final Statement exitScope=scope.exitScope();
  Expression result=new Expression(appendableExpression.resultType()){
    @Override protected void doGen(    CodeBuilder adapter){
      for (      Variable var : appendableVars) {
        var.initializer().gen(adapter);
      }
      appendableExpression.gen(adapter);
      exitScope.gen(adapter);
    }
  }
;
  if (closeable) {
    return AppendableAndOptions.createCloseable(result);
  }
 else {
    return AppendableAndOptions.create(result);
  }
}",0.3139111434814275
29348,"/** 
 * Applies all the streaming print directives to the appendable.
 * @param directives The directives. All are required to be {@link com.google.template.soy.jbcsrc.restricted.SoyJbcSrcPrintDirective.Streamable streamable}
 * @param appendable The appendable to wrap
 * @param basic The expression compiler to use for compiling the arguments
 * @param renderContext The render context for the plugins
 * @return The wrapped appendable
 */
static AppendableAndOptions applyStreamingPrintDirectives(List<PrintDirectiveNode> directives,Expression appendable,BasicExpressionCompiler basic,JbcSrcPluginContext renderContext){
  List<DirectiveWithArgs> directivesToApply=new ArrayList<>();
  for (  PrintDirectiveNode directive : directives) {
    directivesToApply.add(DirectiveWithArgs.create((SoyJbcSrcPrintDirective.Streamable)directive.getPrintDirective(),basic.compileToList(directive.getArgs())));
  }
  return applyStreamingPrintDirectivesTo(directivesToApply,appendable,renderContext);
}","/** 
 * Applies all the streaming print directives to the appendable.
 * @param directives The directives. All are required to be {@link com.google.template.soy.jbcsrc.restricted.SoyJbcSrcPrintDirective.Streamable streamable}
 * @param appendable The appendable to wrap
 * @param basic The expression compiler to use for compiling the arguments
 * @param renderContext The render context for the plugins
 * @param variables The local variable manager
 * @return The wrapped appendable
 */
static AppendableAndOptions applyStreamingPrintDirectives(List<PrintDirectiveNode> directives,Expression appendable,BasicExpressionCompiler basic,JbcSrcPluginContext renderContext,TemplateVariableManager variables){
  List<DirectiveWithArgs> directivesToApply=new ArrayList<>();
  for (  PrintDirectiveNode directive : directives) {
    directivesToApply.add(DirectiveWithArgs.create((SoyJbcSrcPrintDirective.Streamable)directive.getPrintDirective(),basic.compileToList(directive.getArgs())));
  }
  return applyStreamingPrintDirectivesTo(directivesToApply,appendable,renderContext,variables);
}",0.956186807896004
29349,"/** 
 * Applies all the streaming print directives to the appendable.
 * @param directives The directives. All are required to be {@link com.google.template.soy.jbcsrc.restricted.SoyJbcSrcPrintDirective.Streamable streamable}
 * @param appendable The appendable to wrap
 * @param context The render context for the plugins
 * @return The wrapped appendable
 */
static AppendableAndOptions applyStreamingEscapingDirectives(List<SoyPrintDirective> directives,Expression appendable,JbcSrcPluginContext context){
  List<DirectiveWithArgs> directivesToApply=new ArrayList<>();
  for (  SoyPrintDirective directive : directives) {
    directivesToApply.add(DirectiveWithArgs.create((SoyJbcSrcPrintDirective.Streamable)directive));
  }
  return applyStreamingPrintDirectivesTo(directivesToApply,appendable,context);
}","/** 
 * Applies all the streaming print directives to the appendable.
 * @param directives The directives. All are required to be {@link com.google.template.soy.jbcsrc.restricted.SoyJbcSrcPrintDirective.Streamable streamable}
 * @param appendable The appendable to wrap
 * @param context The render context for the plugins
 * @param variables The local variable manager
 * @return The wrapped appendable
 */
static AppendableAndOptions applyStreamingEscapingDirectives(List<SoyPrintDirective> directives,Expression appendable,JbcSrcPluginContext context,TemplateVariableManager variables){
  List<DirectiveWithArgs> directivesToApply=new ArrayList<>();
  for (  SoyPrintDirective directive : directives) {
    directivesToApply.add(DirectiveWithArgs.create((SoyJbcSrcPrintDirective.Streamable)directive));
  }
  return applyStreamingPrintDirectivesTo(directivesToApply,appendable,context,variables);
}",0.9468147282291058
29350,"/** 
 * Renders a   {@link com.google.template.soy.jbcsrc.shared.CompiledTemplate} incrementally.<p>Similar to  {@link #renderIncrementally(Expression,List,Label)}, we need to: <ul> <li>Stash the CompiledTemplate in a field   {@code $currentCallee}, so that if we detach halfway through rendering we don't lose the value. Note, we could use the scope/variable system of   {@link TemplateVariableManager} to manage this value, but we know there willonly ever be 1 live at a time, so we can just manage the single special field ourselves. <li>Either apply all the streaming autoescapers to the current appendable and, stash it in the  {@code $currentAppendable} field for the same reasons as above, or call {@link JbcSrcRuntime#applyEscapers} to apply non-streaming print directives.<li>Invoke  {@link com.google.template.soy.jbcsrc.shared.CompiledTemplate#render} with thestandard detach logic. <li>Clear the two fields once rendering is complete. </ul>
 * @param parametersReattachPoint The label where execution should resume if we need to detachwhile calculating parameters.
 * @param node The call node
 * @param calleeExpression The expression that resolves to a constructed instance of the template
 * @return A statement rendering the template.
 */
private Statement renderCallNode(Label parametersReattachPoint,CallNode node,Expression calleeExpression){
  Statement initAppendable=Statement.NULL_STATEMENT;
  Statement clearAppendable=Statement.NULL_STATEMENT;
  Expression appendable;
  FieldRef currentCalleeField=variables.getCurrentCalleeField();
  if (!areAllPrintDirectivesStreamable(node)) {
    calleeExpression=MethodRef.RUNTIME_APPLY_ESCAPERS.invoke(calleeExpression,getEscapingDirectivesList(node));
    appendable=appendableExpression;
  }
 else {
    AppendableAndOptions wrappedAppendable=applyStreamingEscapingDirectives(node.getEscapingDirectives(),appendableExpression,parameterLookup.getRenderContext());
    FieldRef currentAppendableField=variables.getCurrentAppendable();
    initAppendable=currentAppendableField.putInstanceField(thisVar,wrappedAppendable.appendable());
    appendable=currentAppendableField.accessor(thisVar);
    clearAppendable=currentAppendableField.putInstanceField(thisVar,constantNull(LOGGING_ADVISING_APPENDABLE_TYPE));
    if (wrappedAppendable.closeable()) {
      clearAppendable=Statement.concat(currentAppendableField.accessor(thisVar).checkedCast(BytecodeUtils.CLOSEABLE_TYPE).invokeVoid(MethodRef.CLOSEABLE_CLOSE),clearAppendable);
    }
  }
  Statement initCallee=currentCalleeField.putInstanceField(thisVar,calleeExpression).labelStart(parametersReattachPoint);
  Expression callRender=currentCalleeField.accessor(thisVar).invoke(MethodRef.COMPILED_TEMPLATE_RENDER,appendable,parameterLookup.getRenderContext());
  Statement callCallee=detachState.detachForRender(callRender);
  Statement clearCallee=currentCalleeField.putInstanceField(thisVar,BytecodeUtils.constantNull(COMPILED_TEMPLATE_TYPE));
  return Statement.concat(initAppendable,initCallee,callCallee,clearCallee,clearAppendable);
}","/** 
 * Renders a   {@link com.google.template.soy.jbcsrc.shared.CompiledTemplate} incrementally.<p>Similar to  {@link #renderIncrementally(Expression,List,Label)}, we need to: <ul> <li>Stash the CompiledTemplate in a field   {@code $currentCallee}, so that if we detach halfway through rendering we don't lose the value. Note, we could use the scope/variable system of   {@link TemplateVariableManager} to manage this value, but we know there willonly ever be 1 live at a time, so we can just manage the single special field ourselves. <li>Either apply all the streaming autoescapers to the current appendable and, stash it in the  {@code $currentAppendable} field for the same reasons as above, or call {@link JbcSrcRuntime#applyEscapers} to apply non-streaming print directives.<li>Invoke  {@link com.google.template.soy.jbcsrc.shared.CompiledTemplate#render} with thestandard detach logic. <li>Clear the two fields once rendering is complete. </ul>
 * @param parametersReattachPoint The label where execution should resume if we need to detachwhile calculating parameters.
 * @param node The call node
 * @param calleeExpression The expression that resolves to a constructed instance of the template
 * @return A statement rendering the template.
 */
private Statement renderCallNode(Label parametersReattachPoint,CallNode node,Expression calleeExpression){
  Statement initAppendable=Statement.NULL_STATEMENT;
  Statement clearAppendable=Statement.NULL_STATEMENT;
  Expression appendable;
  FieldRef currentCalleeField=variables.getCurrentCalleeField();
  if (!areAllPrintDirectivesStreamable(node)) {
    calleeExpression=MethodRef.RUNTIME_APPLY_ESCAPERS.invoke(calleeExpression,getEscapingDirectivesList(node));
    appendable=appendableExpression;
  }
 else {
    AppendableAndOptions wrappedAppendable=applyStreamingEscapingDirectives(node.getEscapingDirectives(),appendableExpression,parameterLookup.getRenderContext(),variables);
    FieldRef currentAppendableField=variables.getCurrentAppendable();
    initAppendable=currentAppendableField.putInstanceField(thisVar,wrappedAppendable.appendable());
    appendable=currentAppendableField.accessor(thisVar);
    clearAppendable=currentAppendableField.putInstanceField(thisVar,constantNull(LOGGING_ADVISING_APPENDABLE_TYPE));
    if (wrappedAppendable.closeable()) {
      clearAppendable=Statement.concat(currentAppendableField.accessor(thisVar).checkedCast(BytecodeUtils.CLOSEABLE_TYPE).invokeVoid(MethodRef.CLOSEABLE_CLOSE),clearAppendable);
    }
  }
  Statement initCallee=currentCalleeField.putInstanceField(thisVar,calleeExpression).labelStart(parametersReattachPoint);
  Expression callRender=currentCalleeField.accessor(thisVar).invoke(MethodRef.COMPILED_TEMPLATE_RENDER,appendable,parameterLookup.getRenderContext());
  Statement callCallee=detachState.detachForRender(callRender);
  Statement clearCallee=currentCalleeField.putInstanceField(thisVar,BytecodeUtils.constantNull(COMPILED_TEMPLATE_TYPE));
  return Statement.concat(initAppendable,initCallee,callCallee,clearCallee,clearAppendable);
}",0.9983665468801044
29351,"/** 
 * Renders a   {@link SoyValueProvider} incrementally via {@link SoyValueProvider#renderAndResolve}<p>The strategy is to: <ul> <li>Stash the SoyValueProvider in a field   {@code $currentRenderee}, so that if we detach halfway through rendering we don't lose the value. Note, we could use the scope/variable system of   {@link TemplateVariableManager} to manage this value, but we know there willonly ever be 1 live at a time, so we can just manage the single special field ourselves. <li>Apply all the streaming autoescapers to the current appendable. Also, stash it in the {@code $currentAppendable} field for the same reasons as above.<li>Invoke  {@link SoyValueProvider#renderAndResolve} with the standard detach logic.<li>Clear the two fields once rendering is complete. </ul> <p>TODO(lukes): if the expression is a param, then this is kind of silly since it looks like <pre> {@code SoyValueProvider localParam = this.param; this.currentRenderee = localParam; SoyValueProvider localRenderee = this.currentRenderee; localRenderee.renderAndResolve();}</pre> <p>In this case we could elide the currentRenderee altogether if we knew the soyValueProvider expression was just a field read... And this is the _common_case for .renderAndResolve calls. to actually do this we could add a mechanism similar to the SaveStrategy enum for expressions, kind of like   {@link Expression#isCheap()} which isn't that useful in practice.
 * @param soyValueProvider The value to render incrementally
 * @param directives The streaming print directives applied to the expression
 * @param reattachPoint The point where execution should resume if the soyValueProvider detacheswhile being evaluated.
 * @return a statement for the full render.
 */
private Statement renderIncrementally(Expression soyValueProvider,List<PrintDirectiveNode> directives,Label reattachPoint){
  FieldRef currentRendereeField=variables.getCurrentRenderee();
  Statement initRenderee=currentRendereeField.putInstanceField(thisVar,soyValueProvider).labelStart(reattachPoint);
  Statement clearRenderee=currentRendereeField.putInstanceField(thisVar,constantNull(SOY_VALUE_PROVIDER_TYPE));
  Statement initAppendable=Statement.NULL_STATEMENT;
  Statement clearAppendable=Statement.NULL_STATEMENT;
  Expression appendable=appendableExpression;
  if (!directives.isEmpty()) {
    Label printDirectiveArgumentReattachPoint=new Label();
    AppendableAndOptions wrappedAppendable=applyStreamingPrintDirectives(directives,appendable,exprCompiler.asBasicCompiler(printDirectiveArgumentReattachPoint),parameterLookup.getRenderContext());
    FieldRef currentAppendableField=variables.getCurrentAppendable();
    initAppendable=currentAppendableField.putInstanceField(thisVar,wrappedAppendable.appendable()).labelStart(printDirectiveArgumentReattachPoint);
    appendable=currentAppendableField.accessor(thisVar);
    clearAppendable=currentAppendableField.putInstanceField(thisVar,constantNull(LOGGING_ADVISING_APPENDABLE_TYPE));
    if (wrappedAppendable.closeable()) {
      clearAppendable=Statement.concat(currentAppendableField.accessor(thisVar).checkedCast(BytecodeUtils.CLOSEABLE_TYPE).invokeVoid(MethodRef.CLOSEABLE_CLOSE),clearAppendable);
    }
  }
  Expression callRenderAndResolve=currentRendereeField.accessor(thisVar).invoke(MethodRef.SOY_VALUE_PROVIDER_RENDER_AND_RESOLVE,appendable,constant(false));
  Statement doCall=detachState.detachForRender(callRenderAndResolve);
  return Statement.concat(initRenderee,initAppendable,doCall,clearAppendable,clearRenderee);
}","/** 
 * Renders a   {@link SoyValueProvider} incrementally via {@link SoyValueProvider#renderAndResolve}<p>The strategy is to: <ul> <li>Stash the SoyValueProvider in a field   {@code $currentRenderee}, so that if we detach halfway through rendering we don't lose the value. Note, we could use the scope/variable system of   {@link TemplateVariableManager} to manage this value, but we know there willonly ever be 1 live at a time, so we can just manage the single special field ourselves. <li>Apply all the streaming autoescapers to the current appendable. Also, stash it in the {@code $currentAppendable} field for the same reasons as above.<li>Invoke  {@link SoyValueProvider#renderAndResolve} with the standard detach logic.<li>Clear the two fields once rendering is complete. </ul> <p>TODO(lukes): if the expression is a param, then this is kind of silly since it looks like <pre> {@code SoyValueProvider localParam = this.param; this.currentRenderee = localParam; SoyValueProvider localRenderee = this.currentRenderee; localRenderee.renderAndResolve();}</pre> <p>In this case we could elide the currentRenderee altogether if we knew the soyValueProvider expression was just a field read... And this is the _common_case for .renderAndResolve calls. to actually do this we could add a mechanism similar to the SaveStrategy enum for expressions, kind of like   {@link Expression#isCheap()} which isn't that useful in practice.
 * @param soyValueProvider The value to render incrementally
 * @param directives The streaming print directives applied to the expression
 * @param reattachPoint The point where execution should resume if the soyValueProvider detacheswhile being evaluated.
 * @return a statement for the full render.
 */
private Statement renderIncrementally(Expression soyValueProvider,List<PrintDirectiveNode> directives,Label reattachPoint){
  FieldRef currentRendereeField=variables.getCurrentRenderee();
  Statement initRenderee=currentRendereeField.putInstanceField(thisVar,soyValueProvider).labelStart(reattachPoint);
  Statement clearRenderee=currentRendereeField.putInstanceField(thisVar,constantNull(SOY_VALUE_PROVIDER_TYPE));
  Statement initAppendable=Statement.NULL_STATEMENT;
  Statement clearAppendable=Statement.NULL_STATEMENT;
  Expression appendable=appendableExpression;
  if (!directives.isEmpty()) {
    Label printDirectiveArgumentReattachPoint=new Label();
    AppendableAndOptions wrappedAppendable=applyStreamingPrintDirectives(directives,appendable,exprCompiler.asBasicCompiler(printDirectiveArgumentReattachPoint),parameterLookup.getRenderContext(),variables);
    FieldRef currentAppendableField=variables.getCurrentAppendable();
    initAppendable=currentAppendableField.putInstanceField(thisVar,wrappedAppendable.appendable()).labelStart(printDirectiveArgumentReattachPoint);
    appendable=currentAppendableField.accessor(thisVar);
    clearAppendable=currentAppendableField.putInstanceField(thisVar,constantNull(LOGGING_ADVISING_APPENDABLE_TYPE));
    if (wrappedAppendable.closeable()) {
      clearAppendable=Statement.concat(currentAppendableField.accessor(thisVar).checkedCast(BytecodeUtils.CLOSEABLE_TYPE).invokeVoid(MethodRef.CLOSEABLE_CLOSE),clearAppendable);
    }
  }
  Expression callRenderAndResolve=currentRendereeField.accessor(thisVar).invoke(MethodRef.SOY_VALUE_PROVIDER_RENDER_AND_RESOLVE,appendable,constant(false));
  Statement doCall=detachState.detachForRender(callRenderAndResolve);
  return Statement.concat(initRenderee,initAppendable,doCall,clearAppendable,clearRenderee);
}",0.9985871715173776
29352,"@Override public void close() throws IOException {
  delegate.append(suffix);
}","@Override public void close() throws IOException {
  if (appendCalled) {
    delegate.append(suffix);
  }
}",0.8494623655913979
29353,"@Override public LoggingAdvisingAppendable append(char c) throws IOException {
  return append(""String_Node_Str"" + c);
}","@Override public LoggingAdvisingAppendable append(CharSequence csq,int start,int end) throws IOException {
  appendCalled=true;
  return super.append(csq,start,end);
}",0.710801393728223
29354,"static boolean tryMatchCloseTag(ArrayDeque<HtmlTagEntry> openStack,HtmlTagEntry closeTag,Map<HtmlCloseTagNode,HtmlOpenTagNode> tagMatches,ErrorReporter errorReporter){
  if (closeTag.hasTagName()) {
    HtmlTagEntry entry=tryMatchCloseTag(openStack,closeTag.getTagName(),errorReporter);
    if (entry != null) {
      tagMatches.put((HtmlCloseTagNode)closeTag.getTagNode(),(HtmlOpenTagNode)entry.getTagNode());
    }
    return entry != null;
  }
  HtmlTagEntry openTag=openStack.peekFirst();
  if (openTag == null) {
    return false;
  }
 else   if (openTag.hasTagName()) {
    boolean matchCommonPrefix=tryMatchCommonPrefix(closeTag,openTag.getTagName());
    if (matchCommonPrefix && closeTag.hasEmptyBranches()) {
      return true;
    }
    if (!matchCommonPrefix) {
      return false;
    }
  }
 else {
    if (matchOrError(openTag,closeTag,errorReporter)) {
      openStack.pollFirst();
    }
 else {
      return false;
    }
  }
  return true;
}","/** 
 * Try to match a close tag with a stack of open tags, and report errors accordingly. <p>Return false if openStack is empty or we cannot find a common prefix for the current close tag. Notably returning true does not mean we find a match for the current close tag. When we definitely know there is a mismatch and report an error for that, we still return true. The return value is used by   {@code StrictHtmlValidationPass} to decide whether we should add thecloseTag to the queue. <p>TODO(b/65293620): Change the return results to an enum.
 */
static boolean tryMatchCloseTag(ArrayDeque<HtmlTagEntry> openStack,HtmlTagEntry closeTag,Map<HtmlCloseTagNode,HtmlOpenTagNode> tagMatches,ErrorReporter errorReporter){
  if (closeTag.hasTagName()) {
    HtmlTagEntry entry=tryMatchCloseTag(openStack,closeTag.getTagName(),errorReporter);
    if (entry != null) {
      tagMatches.put((HtmlCloseTagNode)closeTag.getTagNode(),(HtmlOpenTagNode)entry.getTagNode());
    }
    return entry != null;
  }
  HtmlTagEntry openTag=openStack.peekFirst();
  if (openTag == null) {
    return false;
  }
 else   if (openTag.hasTagName()) {
    boolean matchCommonPrefix=tryMatchCommonPrefix(closeTag,openTag.getTagName());
    if (matchCommonPrefix && closeTag.hasEmptyBranches()) {
      return true;
    }
    if (!matchCommonPrefix) {
      return false;
    }
  }
 else {
    if (matchOrError(openTag,closeTag,errorReporter)) {
      openStack.pollFirst();
    }
 else {
      return false;
    }
  }
  return true;
}",0.7767857142857143
29355,"/** 
 * {@code SwitchNode} is very similar with {@code IfNode}. The major difference is the way to generate conditions.
 */
@Override protected void visitSwitchNode(SwitchNode node){
  ConditionalBranches outerOpenTagBranches=new ConditionalBranches(openTagBranches);
  ConditionalBranches outerCloseTagBranches=new ConditionalBranches(closeTagBranches);
  openTagBranches.clear();
  closeTagBranches.clear();
  visitChildren(node);
  if (!openTagBranches.isEmpty() && !closeTagBranches.isEmpty()) {
    errorReporter.report(closeTagBranches.getSourceLocation(),UNEXPECTED_CLOSE_TAG);
    openTagBranches.clear();
    closeTagBranches.clear();
  }
  if (!openTagBranches.isEmpty()) {
    openTagStack.addFirst(new HtmlTagEntry(openTagBranches));
    openTagBranches.clear();
  }
  if (!closeTagBranches.isEmpty()) {
    closeTagQueue.addLast(new HtmlTagEntry(closeTagBranches));
    closeTagBranches.clear();
  }
  HtmlTagEntry.tryMatchOrError(openTagStack,closeTagQueue,errorReporter);
  openTagBranches.addAll(outerOpenTagBranches);
  closeTagBranches.addAll(outerCloseTagBranches);
}","/** 
 * {@code SwitchNode} is very similar with {@code IfNode}. The major difference is the way to generate conditions.
 */
@Override protected void visitSwitchNode(SwitchNode node){
  ConditionalBranches outerOpenTagBranches=new ConditionalBranches(openTagBranches);
  ConditionalBranches outerCloseTagBranches=new ConditionalBranches(closeTagBranches);
  openTagBranches.clear();
  closeTagBranches.clear();
  visitChildren(node);
  if (!openTagBranches.isEmpty() && !closeTagBranches.isEmpty()) {
    errorReporter.report(closeTagBranches.getSourceLocation(),UNEXPECTED_CLOSE_TAG_IN_CONTROL);
    openTagBranches.clear();
    closeTagBranches.clear();
  }
  if (!openTagBranches.isEmpty()) {
    openTagStack.addFirst(new HtmlTagEntry(openTagBranches));
    openTagBranches.clear();
  }
  if (!closeTagBranches.isEmpty()) {
    closeTagQueue.addLast(new HtmlTagEntry(closeTagBranches));
    closeTagBranches.clear();
  }
  HtmlTagEntry.tryMatchOrError(openTagStack,closeTagQueue,errorReporter);
  openTagBranches.addAll(outerOpenTagBranches);
  closeTagBranches.addAll(outerCloseTagBranches);
}",0.9949610627576728
29356,"/** 
 * When we visit IfNode, we do the following steps: <ul> <li>Create new   {@code ConditionalBranches} (and save old branches).<li>For each of its children, update the current conditions. <li>After visiting all children, check if branches are empty. If they are not empty (i.e., we find some HTML tags within this  {@code IfNode}), push the branches into corresponding stack or queue. <li>Restore the conditions and branches. </ul>
 */
@Override protected void visitIfNode(IfNode node){
  ConditionalBranches outerOpenTagBranches=new ConditionalBranches(openTagBranches);
  ConditionalBranches outerCloseTagBranches=new ConditionalBranches(closeTagBranches);
  openTagBranches.clear();
  closeTagBranches.clear();
  visitChildren(node);
  if (!openTagBranches.isEmpty() && !closeTagBranches.isEmpty()) {
    errorReporter.report(closeTagBranches.getSourceLocation(),UNEXPECTED_CLOSE_TAG);
    openTagBranches.clear();
    closeTagBranches.clear();
  }
  if (!openTagBranches.isEmpty()) {
    openTagStack.addFirst(new HtmlTagEntry(openTagBranches));
    openTagBranches.clear();
  }
  if (!closeTagBranches.isEmpty()) {
    closeTagQueue.addLast(new HtmlTagEntry(closeTagBranches));
    closeTagBranches.clear();
  }
  HtmlTagEntry.tryMatchOrError(openTagStack,closeTagQueue,errorReporter);
  openTagBranches.addAll(outerOpenTagBranches);
  closeTagBranches.addAll(outerCloseTagBranches);
}","/** 
 * When we visit IfNode, we do the following steps: <ul> <li>Create new   {@code ConditionalBranches} (and save old branches).<li>For each of its children, update the current conditions. <li>After visiting all children, check if branches are empty. If they are not empty (i.e., we find some HTML tags within this  {@code IfNode}), push the branches into corresponding stack or queue. <li>Restore the conditions and branches. </ul>
 */
@Override protected void visitIfNode(IfNode node){
  ConditionalBranches outerOpenTagBranches=new ConditionalBranches(openTagBranches);
  ConditionalBranches outerCloseTagBranches=new ConditionalBranches(closeTagBranches);
  openTagBranches.clear();
  closeTagBranches.clear();
  visitChildren(node);
  if (!openTagBranches.isEmpty() && !closeTagBranches.isEmpty()) {
    errorReporter.report(closeTagBranches.getSourceLocation(),UNEXPECTED_CLOSE_TAG_IN_CONTROL);
    openTagBranches.clear();
    closeTagBranches.clear();
  }
  if (!openTagBranches.isEmpty()) {
    openTagStack.addFirst(new HtmlTagEntry(openTagBranches));
    openTagBranches.clear();
  }
  if (!closeTagBranches.isEmpty()) {
    closeTagQueue.addLast(new HtmlTagEntry(closeTagBranches));
    closeTagBranches.clear();
  }
  HtmlTagEntry.tryMatchOrError(openTagStack,closeTagQueue,errorReporter);
  openTagBranches.addAll(outerOpenTagBranches);
  closeTagBranches.addAll(outerCloseTagBranches);
}",0.9960700250089316
29357,"@Override protected void visitHtmlCloseTagNode(HtmlCloseTagNode node){
  TagName closeTag=node.getTagName();
  HtmlTagEntry entry=new HtmlTagEntry(node);
  if (closeTag.isDefinitelyVoid()) {
    errorReporter.report(node.getSourceLocation(),INVALID_CLOSE_TAG,closeTag.getStaticTagName());
    return;
  }
  if (closeTag.isForeignContent()) {
    foreignContentEndLocation=node.getSourceLocation();
    inForeignContent=false;
  }
  if (!HtmlTagEntry.tryMatchCloseTag(openTagStack,entry,tagMatches,errorReporter)) {
    closeTagQueue.addLast(entry);
  }
}","@Override protected void visitHtmlCloseTagNode(HtmlCloseTagNode node){
  TagName closeTag=node.getTagName();
  HtmlTagEntry entry=new HtmlTagEntry(node);
  if (closeTag.isDefinitelyVoid()) {
    errorReporter.report(closeTag.getTagLocation(),INVALID_CLOSE_TAG,closeTag.getStaticTagName());
    return;
  }
  if (closeTag.isForeignContent()) {
    foreignContentEndLocation=node.getSourceLocation();
    inForeignContent=false;
  }
  if (!HtmlTagEntry.tryMatchCloseTag(openTagStack,entry,tagMatches,errorReporter)) {
    if (isInControlBlock(node)) {
      closeTagQueue.addLast(entry);
    }
 else {
      errorReporter.report(closeTag.getTagLocation(),UNEXPECTED_CLOSE_TAG);
    }
  }
}",0.8702659145850121
29358,"@Override public void run(SoyFileNode file,IdGenerator nodeIdGen){
  for (  TemplateNode template : file.getChildren()) {
    for (    TemplateParam param : template.getAllParams()) {
      if (param.isInjected() && param.name().equals(CSP_NONCE_VARIABLE_NAME)) {
        errorReporter.report(param.nameLocation(),IJ_CSP_NONCE_REFERENCE);
      }
    }
  }
  for (  VarRefNode var : SoyTreeUtils.getAllNodesOfType(file,VarRefNode.class)) {
    if (var.isDollarSignIjParameter() && var.getName().equals(CSP_NONCE_VARIABLE_NAME)) {
      errorReporter.report(var.getSourceLocation(),IJ_CSP_NONCE_REFERENCE);
    }
  }
  for (  HtmlOpenTagNode openTag : SoyTreeUtils.getAllNodesOfType(file,HtmlOpenTagNode.class)) {
    RcDataTagName rcDataTagName=openTag.getTagName().getRcDataTagName();
    if (rcDataTagName == RcDataTagName.SCRIPT || rcDataTagName == RcDataTagName.STYLE) {
      SourceLocation insertionLocation=openTag.getSourceLocation().getEndPoint().offset(0,openTag.isSelfClosing() ? 2 : -1).asLocation(openTag.getSourceLocation().getFilePath());
      openTag.addChild(createCspInjection(insertionLocation,nodeIdGen));
    }
  }
}","@Override public void run(SoyFileNode file,IdGenerator nodeIdGen){
  for (  TemplateNode template : file.getChildren()) {
    for (    TemplateParam param : template.getAllParams()) {
      if (param.isInjected() && param.name().equals(CSP_NONCE_VARIABLE_NAME)) {
        errorReporter.report(param.nameLocation(),IJ_CSP_NONCE_REFERENCE);
      }
    }
  }
  for (  VarRefNode var : SoyTreeUtils.getAllNodesOfType(file,VarRefNode.class)) {
    if (var.isDollarSignIjParameter() && var.getName().equals(CSP_NONCE_VARIABLE_NAME)) {
      errorReporter.report(var.getSourceLocation(),IJ_CSP_NONCE_REFERENCE);
    }
  }
  for (  HtmlOpenTagNode openTag : SoyTreeUtils.getAllNodesOfType(file,HtmlOpenTagNode.class)) {
    RcDataTagName rcDataTagName=openTag.getTagName().getRcDataTagName();
    if (rcDataTagName == RcDataTagName.SCRIPT || rcDataTagName == RcDataTagName.STYLE) {
      SourceLocation insertionLocation=openTag.getSourceLocation().getEndPoint().offset(0,openTag.isSelfClosing() ? -2 : -1).asLocation(openTag.getSourceLocation().getFilePath());
      openTag.addChild(createCspInjection(insertionLocation,nodeIdGen));
    }
  }
}",0.999560825647782
29359,"/** 
 * Extends the access chain with a bracket access to the given value.
 * @param nullSafe If true, code will be generated to ensure the chain is non-null beforedereferencing  {@code arg}.
 */
NullSafeAccumulator bracketAccess(CodeChunk.WithValue arg,boolean nullSafe){
  chain.add(new Bracket(arg,nullSafe));
  return this;
}","/** 
 * Extends the access chain with a bracket access to the given value.
 * @param nullSafe If true, code will be generated to ensure the chain is non-null beforedereferencing  {@code arg}.
 */
NullSafeAccumulator bracketAccess(CodeChunk.WithValue arg,boolean nullSafe){
  chain.add(new Bracket(arg,nullSafe));
  isRepeated=false;
  return this;
}",0.9380530973451328
29360,"/** 
 * Extends the access chain with a dot access to the given value.
 * @param nullSafe If true, code will be generated to ensure the chain is non-null beforedereferencing  {@code arg}.
 */
NullSafeAccumulator dotAccess(FieldAccess arg,boolean nullSafe){
  if (arg instanceof CallAndUnpack) {
    Preconditions.checkState(unpackFunction == null,""String_Node_Str"",unpackFunction);
    unpackFunction=((CallAndUnpack)arg).unpackFunctionName();
    isRepeated=((CallAndUnpack)arg).isRepeated();
  }
  chain.add(arg.toChainAccess(nullSafe));
  return this;
}","/** 
 * Extends the access chain with a dot access to the given value.
 * @param nullSafe If true, code will be generated to ensure the chain is non-null beforedereferencing  {@code arg}.
 */
NullSafeAccumulator dotAccess(FieldAccess arg,boolean nullSafe){
  if (arg instanceof CallAndUnpack) {
    Preconditions.checkState(unpackFunction == null,""String_Node_Str"",unpackFunction);
    CallAndUnpack callAndUnpack=(CallAndUnpack)arg;
    unpackFunction=callAndUnpack.unpackFunctionName();
    isRepeated=callAndUnpack.isRepeated();
  }
  chain.add(arg.toChainAccess(nullSafe));
  return this;
}",0.7130434782608696
29361,"/** 
 * See   {@link NullSafeAccumulator} for discussion. 
 */
private NullSafeAccumulator visitNullSafeNode(ExprNode node){
switch (node.getKind()) {
case FIELD_ACCESS_NODE:
    FieldAccessNode fieldAccess=(FieldAccessNode)node;
  NullSafeAccumulator base=visitNullSafeNode(fieldAccess.getBaseExprChild());
FieldAccess access=genCodeForFieldAccess(fieldAccess.getBaseExprChild().getType(),fieldAccess,fieldAccess.getFieldName());
return base.dotAccess(access,fieldAccess.isNullSafe());
case ITEM_ACCESS_NODE:
ItemAccessNode itemAccess=(ItemAccessNode)node;
base=visitNullSafeNode(itemAccess.getBaseExprChild());
CodeChunk.WithValue key=visit(itemAccess.getKeyExprChild());
return base.bracketAccess(key,itemAccess.isNullSafe());
default :
return new NullSafeAccumulator(visit(node));
}
}","/** 
 * See   {@link NullSafeAccumulator} for discussion. 
 */
private NullSafeAccumulator visitNullSafeNode(ExprNode node){
switch (node.getKind()) {
case FIELD_ACCESS_NODE:
{
      FieldAccessNode fieldAccess=(FieldAccessNode)node;
      NullSafeAccumulator base=visitNullSafeNode(fieldAccess.getBaseExprChild());
      FieldAccess access=genCodeForFieldAccess(fieldAccess.getBaseExprChild().getType(),fieldAccess,fieldAccess.getFieldName());
      return base.dotAccess(access,fieldAccess.isNullSafe());
    }
case ITEM_ACCESS_NODE:
{
    ItemAccessNode itemAccess=(ItemAccessNode)node;
    NullSafeAccumulator base=visitNullSafeNode(itemAccess.getBaseExprChild());
    CodeChunk.WithValue key=visit(itemAccess.getKeyExprChild());
    return base.bracketAccess(key,itemAccess.isNullSafe());
  }
default :
return new NullSafeAccumulator(visit(node));
}
}",0.9586374695863747
29362,"/** 
 * Convert this expression to a statement, by executing it and throwing away the result. <p>This is useful for invoking non-void methods when we don't care about the result.
 */
Statement toStatement(){
  return new Statement(){
    @Override void doGen(    CodeBuilder adapter){
      Expression.this.gen(adapter);
switch (resultType().getSize()) {
case 0:
        throw new AssertionError(""String_Node_Str"");
case 1:
      adapter.pop();
    break;
case 2:
  adapter.pop2();
break;
}
}
}
;
}","/** 
 * Convert this expression to a statement, by executing it and throwing away the result. <p>This is useful for invoking non-void methods when we don't care about the result.
 */
Statement toStatement(){
  return new Statement(){
    @Override void doGen(    CodeBuilder adapter){
      Expression.this.gen(adapter);
switch (resultType().getSize()) {
case 0:
        throw new AssertionError(""String_Node_Str"");
case 1:
      adapter.pop();
    break;
case 2:
  adapter.pop2();
break;
default :
throw new AssertionError();
}
}
}
;
}",0.9632495164410058
29363,"@Override public String toString(){
  String name=getClass().getSimpleName();
  if (name.isEmpty()) {
    name=""String_Node_Str"";
  }
  name=name + ""String_Node_Str"" + resultType+ ""String_Node_Str"";
  boolean needsLeadingSpace=false;
  if (features.has(Feature.CHEAP)) {
    name+=""String_Node_Str"";
    needsLeadingSpace=true;
  }
  if (features.has(Feature.NON_NULLABLE) && !BytecodeUtils.isPrimitive(resultType)) {
    name+=(needsLeadingSpace ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"";
  }
  return name + ""String_Node_Str"" + resultType()+ ""String_Node_Str""+ trace();
}","@Override public String toString(){
  String name=getClass().getSimpleName();
  if (name.isEmpty()) {
    name=""String_Node_Str"";
  }
  MoreObjects.ToStringHelper helper=MoreObjects.toStringHelper(name).omitNullValues();
  helper.add(""String_Node_Str"",resultType());
  extraToStringProperties(helper);
  helper.add(""String_Node_Str"",features.has(Feature.CHEAP) ? ""String_Node_Str"" : null);
  helper.add(""String_Node_Str"",features.has(Feature.NON_NULLABLE) && !BytecodeUtils.isPrimitive(resultType) ? ""String_Node_Str"" : null);
  return helper + ""String_Node_Str"" + trace();
}",0.4370179948586118
29364,"private Statement handleRepeatedNotNull(final SoyExpression listArg,FieldDescriptor field){
  Preconditions.checkArgument(listArg.isNonNullable());
  SoyExpression unboxed=listArg.unboxAs(List.class);
  Expression resolved=detacher.get().resolveSoyValueProviderList(unboxed);
  Scope scope=varManager.enterScope();
  final Statement scopeExit=scope.exitScope();
  final Variable list=scope.createTemporary(field.getName() + ""String_Node_Str"",resolved);
  final Variable index=scope.createTemporary(field.getName() + ""String_Node_Str"",constant(0));
  final Variable listSize=scope.createTemporary(field.getName() + ""String_Node_Str"",MethodRef.LIST_SIZE.invoke(list.local()));
  SoyType elementSoyType=((ListType)unboxed.soyType()).getElementType();
  SoyRuntimeType elementType=SoyRuntimeType.getBoxedType(elementSoyType);
  Expression getAndResolve=list.local().invoke(MethodRef.LIST_GET,index.local()).checkedCast(SOY_VALUE_PROVIDER_TYPE).invoke(MethodRef.SOY_VALUE_PROVIDER_RESOLVE).checkedCast(elementType.runtimeType());
  SoyExpression soyValue=SoyExpression.forSoyValue(elementType.soyType(),getAndResolve).asNonNullable();
  final Statement getAndAddOne=field.isExtension() ? handleExtension(soyValue,field) : handleNormalSetter(soyValue,field);
  return new Statement(){
    @Override void doGen(    CodeBuilder cb){
      list.initializer().gen(cb);
      listSize.initializer().gen(cb);
      listSize.local().gen(cb);
      Label listIsEmpty=new Label();
      cb.ifZCmp(Opcodes.IFEQ,listIsEmpty);
      index.initializer().gen(cb);
      Label loopStart=cb.mark();
      getAndAddOne.gen(cb);
      cb.iinc(index.local().index(),1);
      index.local().gen(cb);
      listSize.local().gen(cb);
      cb.ifICmp(Opcodes.IFLT,loopStart);
      cb.mark(listIsEmpty);
      scopeExit.gen(cb);
    }
  }
;
}","private Statement handleRepeatedNotNull(final SoyExpression listArg,FieldDescriptor field){
  Preconditions.checkArgument(listArg.isNonNullable());
  SoyExpression unboxed=listArg.unboxAs(List.class);
  Expression resolved=detacher.get().resolveSoyValueProviderList(unboxed);
  Scope scope=varManager.enterScope();
  final Variable list=scope.createTemporary(field.getName() + ""String_Node_Str"",resolved);
  final Variable index=scope.createTemporary(field.getName() + ""String_Node_Str"",constant(0));
  final Variable listSize=scope.createTemporary(field.getName() + ""String_Node_Str"",MethodRef.LIST_SIZE.invoke(list.local()));
  final Statement scopeExit=scope.exitScope();
  SoyType elementSoyType=((ListType)unboxed.soyType()).getElementType();
  SoyRuntimeType elementType=SoyRuntimeType.getBoxedType(elementSoyType);
  Expression getAndResolve=list.local().invoke(MethodRef.LIST_GET,index.local()).checkedCast(SOY_VALUE_PROVIDER_TYPE).invoke(MethodRef.SOY_VALUE_PROVIDER_RESOLVE).checkedCast(elementType.runtimeType());
  SoyExpression soyValue=SoyExpression.forSoyValue(elementType.soyType(),getAndResolve).asNonNullable();
  final Statement getAndAddOne=field.isExtension() ? handleExtension(soyValue,field) : handleNormalSetter(soyValue,field);
  return new Statement(){
    @Override void doGen(    CodeBuilder cb){
      list.initializer().gen(cb);
      listSize.initializer().gen(cb);
      listSize.local().gen(cb);
      Label listIsEmpty=new Label();
      cb.ifZCmp(Opcodes.IFEQ,listIsEmpty);
      index.initializer().gen(cb);
      Label loopStart=cb.mark();
      getAndAddOne.gen(cb);
      cb.iinc(index.local().index(),1);
      index.local().gen(cb);
      listSize.local().gen(cb);
      cb.ifICmp(Opcodes.IFLT,loopStart);
      cb.mark(listIsEmpty);
      scopeExit.gen(cb);
    }
  }
;
}",0.9740761169332598
29365,"/** 
 * Write a local variable table entry for every registered variable. 
 */
void generateTableEntries(CodeBuilder ga){
  for (  Variable var : allVariables) {
    var.local.tableEntry(ga);
  }
}","/** 
 * Write a local variable table entry for every registered variable. 
 */
void generateTableEntries(CodeBuilder ga){
  for (  Variable var : allVariables) {
    try {
      var.local.tableEntry(ga);
    }
 catch (    Throwable t) {
      throw new RuntimeException(""String_Node_Str"" + var.local,t);
    }
  }
}",0.76953125
29366,"@Override Variable createSynthetic(SyntheticVarName varName,Expression initExpr,SaveStrategy strategy){
  VarKey key=VarKey.create(Kind.SYNTHETIC,varName.name());
  String name=fieldNames.generateName(""String_Node_Str"" + varName.name());
  return doCreate(name,new Label(),scopeExit,initExpr,key,strategy);
}","@Override Variable createSynthetic(SyntheticVarName varName,Expression initExpr,SaveStrategy strategy){
  checkState(!exited,""String_Node_Str"");
  VarKey key=VarKey.create(Kind.SYNTHETIC,varName.name());
  String name=fieldNames.generateName(""String_Node_Str"" + varName.name());
  return doCreate(name,new Label(),scopeExit,initExpr,key,strategy);
}",0.9375951293759512
29367,"@Override Variable createTemporary(String name,Expression initExpr){
  VarKey key=VarKey.create(Kind.TEMPORARY,name);
  name=fieldNames.generateName(""String_Node_Str"" + name);
  return doCreate(name,new Label(),scopeExit,initExpr,key,SaveStrategy.NEVER);
}","@Override Variable createTemporary(String name,Expression initExpr){
  checkState(!exited,""String_Node_Str"");
  VarKey key=VarKey.create(Kind.TEMPORARY,name);
  name=fieldNames.generateName(""String_Node_Str"" + name);
  return doCreate(name,new Label(),scopeExit,initExpr,key,SaveStrategy.NEVER);
}",0.9258589511754068
29368,"@Override Variable create(String name,Expression initExpr,SaveStrategy strategy){
  VarKey key=VarKey.create(Kind.USER_DEFINED,name);
  name=fieldNames.generateName(name);
  return doCreate(name,new Label(),scopeExit,initExpr,key,strategy);
}","@Override Variable create(String name,Expression initExpr,SaveStrategy strategy){
  checkState(!exited,""String_Node_Str"");
  VarKey key=VarKey.create(Kind.USER_DEFINED,name);
  name=fieldNames.generateName(name);
  return doCreate(name,new Label(),scopeExit,initExpr,key,strategy);
}",0.921904761904762
29369,"/** 
 * Enters a new scope. Variables may only be defined within a scope. 
 */
Scope enterScope(){
  final Map<VarKey,Variable> currentFrame=new LinkedHashMap<>();
  final Label scopeExit=new Label();
  frames.push(currentFrame);
  return new Scope(){
    @Override Variable createSynthetic(    SyntheticVarName varName,    Expression initExpr,    SaveStrategy strategy){
      VarKey key=VarKey.create(Kind.SYNTHETIC,varName.name());
      String name=fieldNames.generateName(""String_Node_Str"" + varName.name());
      return doCreate(name,new Label(),scopeExit,initExpr,key,strategy);
    }
    @Override Variable createTemporary(    String name,    Expression initExpr){
      VarKey key=VarKey.create(Kind.TEMPORARY,name);
      name=fieldNames.generateName(""String_Node_Str"" + name);
      return doCreate(name,new Label(),scopeExit,initExpr,key,SaveStrategy.NEVER);
    }
    @Override Variable create(    String name,    Expression initExpr,    SaveStrategy strategy){
      VarKey key=VarKey.create(Kind.USER_DEFINED,name);
      name=fieldNames.generateName(name);
      return doCreate(name,new Label(),scopeExit,initExpr,key,strategy);
    }
    @Override Statement exitScope(){
      frames.pop();
      final Set<Label> endLabels=Sets.newIdentityHashSet();
      for (      Variable var : currentFrame.values()) {
        endLabels.add(var.local.end());
        availableSlots.clear(var.local.index(),var.local.index() + var.local.resultType().getSize());
      }
      return new Statement(){
        @Override void doGen(        CodeBuilder adapter){
          for (          Label label : endLabels) {
            adapter.visitLabel(label);
          }
        }
      }
;
    }
    private Variable doCreate(    String name,    Label start,    Label end,    Expression initExpr,    VarKey key,    SaveStrategy strategy){
      int index=reserveSlotFor(initExpr.resultType());
      LocalVariable local=LocalVariable.createLocal(name,index,initExpr.resultType(),start,end);
      Variable var;
switch (strategy) {
case DERIVED:
        var=new DerivedVariable(initExpr,local);
      break;
case NEVER:
    var=new TemporaryVariable(initExpr,local);
  break;
case STORE:
var=new FieldSavedVariable(initExpr,local);
break;
default :
throw new AssertionError();
}
currentFrame.put(key,var);
allVariables.add(var);
return var;
}
}
;
}","/** 
 * Enters a new scope. Variables may only be defined within a scope. 
 */
Scope enterScope(){
  final Map<VarKey,Variable> currentFrame=new LinkedHashMap<>();
  final Label scopeExit=new Label();
  frames.push(currentFrame);
  return new Scope(){
    boolean exited;
    @Override Variable createSynthetic(    SyntheticVarName varName,    Expression initExpr,    SaveStrategy strategy){
      checkState(!exited,""String_Node_Str"");
      VarKey key=VarKey.create(Kind.SYNTHETIC,varName.name());
      String name=fieldNames.generateName(""String_Node_Str"" + varName.name());
      return doCreate(name,new Label(),scopeExit,initExpr,key,strategy);
    }
    @Override Variable createTemporary(    String name,    Expression initExpr){
      checkState(!exited,""String_Node_Str"");
      VarKey key=VarKey.create(Kind.TEMPORARY,name);
      name=fieldNames.generateName(""String_Node_Str"" + name);
      return doCreate(name,new Label(),scopeExit,initExpr,key,SaveStrategy.NEVER);
    }
    @Override Variable create(    String name,    Expression initExpr,    SaveStrategy strategy){
      checkState(!exited,""String_Node_Str"");
      VarKey key=VarKey.create(Kind.USER_DEFINED,name);
      name=fieldNames.generateName(name);
      return doCreate(name,new Label(),scopeExit,initExpr,key,strategy);
    }
    @Override Statement exitScope(){
      checkState(!exited,""String_Node_Str"");
      exited=true;
      frames.pop();
      final Set<Label> endLabels=Sets.newIdentityHashSet();
      for (      Variable var : currentFrame.values()) {
        endLabels.add(var.local.end());
        availableSlots.clear(var.local.index(),var.local.index() + var.local.resultType().getSize());
      }
      return new Statement(){
        @Override void doGen(        CodeBuilder adapter){
          for (          Label label : endLabels) {
            adapter.visitLabel(label);
          }
        }
      }
;
    }
    private Variable doCreate(    String name,    Label start,    Label end,    Expression initExpr,    VarKey key,    SaveStrategy strategy){
      int index=reserveSlotFor(initExpr.resultType());
      LocalVariable local=LocalVariable.createLocal(name,index,initExpr.resultType(),start,end);
      Variable var;
switch (strategy) {
case DERIVED:
        var=new DerivedVariable(initExpr,local);
      break;
case NEVER:
    var=new TemporaryVariable(initExpr,local);
  break;
case STORE:
var=new FieldSavedVariable(initExpr,local);
break;
default :
throw new AssertionError();
}
currentFrame.put(key,var);
allVariables.add(var);
return var;
}
}
;
}",0.9554062309102016
29370,"@Override Statement exitScope(){
  frames.pop();
  final Set<Label> endLabels=Sets.newIdentityHashSet();
  for (  Variable var : currentFrame.values()) {
    endLabels.add(var.local.end());
    availableSlots.clear(var.local.index(),var.local.index() + var.local.resultType().getSize());
  }
  return new Statement(){
    @Override void doGen(    CodeBuilder adapter){
      for (      Label label : endLabels) {
        adapter.visitLabel(label);
      }
    }
  }
;
}","@Override Statement exitScope(){
  checkState(!exited,""String_Node_Str"");
  exited=true;
  frames.pop();
  final Set<Label> endLabels=Sets.newIdentityHashSet();
  for (  Variable var : currentFrame.values()) {
    endLabels.add(var.local.end());
    availableSlots.clear(var.local.index(),var.local.index() + var.local.resultType().getSize());
  }
  return new Statement(){
    @Override void doGen(    CodeBuilder adapter){
      for (      Label label : endLabels) {
        adapter.visitLabel(label);
      }
    }
  }
;
}",0.943661971830986
29371,"private static void checkIntComparisonOpcode(Type comparisonType,int opcode){
switch (opcode) {
case Opcodes.IFEQ:
case Opcodes.IFNE:
    return;
case Opcodes.IFGT:
case Opcodes.IFGE:
case Opcodes.IFLT:
case Opcodes.IFLE:
  if (comparisonType.getSort() == Type.ARRAY || comparisonType.getSort() == Type.OBJECT) {
    throw new IllegalArgumentException(""String_Node_Str"" + comparisonType + ""String_Node_Str""+ Printer.OPCODES[opcode]);
  }
return;
}
throw new IllegalArgumentException(""String_Node_Str"" + opcode);
}","private static void checkIntComparisonOpcode(Type comparisonType,int opcode){
switch (opcode) {
case Opcodes.IFEQ:
case Opcodes.IFNE:
    return;
case Opcodes.IFGT:
case Opcodes.IFGE:
case Opcodes.IFLT:
case Opcodes.IFLE:
  if (comparisonType.getSort() == Type.ARRAY || comparisonType.getSort() == Type.OBJECT) {
    throw new IllegalArgumentException(""String_Node_Str"" + comparisonType + ""String_Node_Str""+ Printer.OPCODES[opcode]);
  }
return;
default :
throw new IllegalArgumentException(""String_Node_Str"" + opcode);
}
}",0.9884169884169884
29372,"/** 
 * Outputs bytecode that unboxes the current top element of the stack as   {@code asType}. Top of stack must not be null. <p>Always prefer using   {@link SoyExpression#unboxAs} over this method, whenever possible.<p>Guarantees: * Bytecode output will not change stack height * Output will only change the top element, and nothing below that
 * @return the type of the result of the unbox operation
 */
static Type unboxUnchecked(CodeBuilder cb,SoyRuntimeType soyType,Class<?> asType){
  checkArgument(soyType.isBoxed(),""String_Node_Str"",soyType);
  Type fromType=soyType.runtimeType();
  checkArgument(!SoyValue.class.isAssignableFrom(asType),""String_Node_Str"",fromType,asType);
  if (isDefinitelyAssignableFrom(Type.getType(asType),fromType)) {
    return fromType;
  }
  if (asType.equals(boolean.class)) {
    MethodRef.SOY_VALUE_BOOLEAN_VALUE.invokeUnchecked(cb);
    return Type.BOOLEAN_TYPE;
  }
  if (asType.equals(long.class)) {
    MethodRef.SOY_VALUE_LONG_VALUE.invokeUnchecked(cb);
    return Type.LONG_TYPE;
  }
  if (asType.equals(double.class)) {
    MethodRef.SOY_VALUE_FLOAT_VALUE.invokeUnchecked(cb);
    return Type.DOUBLE_TYPE;
  }
  if (asType.equals(String.class)) {
    MethodRef.SOY_VALUE_STRING_VALUE.invokeUnchecked(cb);
    return STRING_TYPE;
  }
  if (asType.equals(List.class)) {
    cb.checkCast(SOY_LIST_TYPE);
    MethodRef.SOY_LIST_AS_JAVA_LIST.invokeUnchecked(cb);
    return LIST_TYPE;
  }
  if (asType.equals(Message.class)) {
    if (!isDefinitelyAssignableFrom(SOY_PROTO_VALUE_TYPE,fromType)) {
      cb.checkCast(SOY_PROTO_VALUE_TYPE);
    }
    MethodRef.SOY_PROTO_VALUE_GET_PROTO.invokeUnchecked(cb);
    return MESSAGE_TYPE;
  }
  throw new UnsupportedOperationException(""String_Node_Str"" + fromType + ""String_Node_Str""+ asType);
}","/** 
 * Outputs bytecode that unboxes the current top element of the stack as   {@code asType}. Top of stack must not be null. <p>Always prefer using   {@link SoyExpression#unboxAs} over this method, whenever possible.<p>Guarantees: * Bytecode output will not change stack height * Output will only change the top element, and nothing below that
 * @return the type of the result of the unbox operation
 */
static Type unboxUnchecked(CodeBuilder cb,SoyRuntimeType soyType,Class<?> asType){
  checkArgument(soyType.isBoxed(),""String_Node_Str"",soyType);
  Type fromType=soyType.runtimeType();
  checkArgument(!SoyValue.class.isAssignableFrom(asType),""String_Node_Str"",fromType,asType);
  if (isDefinitelyAssignableFrom(Type.getType(asType),fromType)) {
    return fromType;
  }
  if (asType.equals(boolean.class)) {
    MethodRef.SOY_VALUE_BOOLEAN_VALUE.invokeUnchecked(cb);
    return Type.BOOLEAN_TYPE;
  }
  if (asType.equals(long.class)) {
    MethodRef.SOY_VALUE_LONG_VALUE.invokeUnchecked(cb);
    return Type.LONG_TYPE;
  }
  if (asType.equals(double.class)) {
    MethodRef.SOY_VALUE_FLOAT_VALUE.invokeUnchecked(cb);
    return Type.DOUBLE_TYPE;
  }
  if (asType.equals(String.class)) {
    MethodRef.SOY_VALUE_STRING_VALUE.invokeUnchecked(cb);
    return STRING_TYPE;
  }
  if (asType.equals(List.class)) {
    cb.checkCast(SOY_LIST_TYPE);
    MethodRef.SOY_LIST_AS_JAVA_LIST.invokeUnchecked(cb);
    return LIST_TYPE;
  }
  if (asType.equals(Message.class)) {
    if (!isDefinitelyAssignableFrom(SOY_PROTO_VALUE_IMPL_TYPE,fromType)) {
      cb.checkCast(SOY_PROTO_VALUE_IMPL_TYPE);
    }
    MethodRef.SOY_PROTO_VALUE_GET_PROTO.invokeUnchecked(cb);
    return MESSAGE_TYPE;
  }
  throw new UnsupportedOperationException(""String_Node_Str"" + fromType + ""String_Node_Str""+ asType);
}",0.997195737521032
29373,"/** 
 * Generate bytecode that coerces the top of stack to the correct type for the given field setter.
 */
private static void coerce(CodeBuilder cb,Type currentType,FieldDescriptor field){
switch (field.getJavaType()) {
case BOOLEAN:
case DOUBLE:
case STRING:
    break;
case FLOAT:
  if (!currentType.equals(Type.FLOAT_TYPE)) {
    cb.cast(currentType,Type.FLOAT_TYPE);
  }
break;
case INT:
if (!currentType.equals(Type.INT_TYPE)) {
cb.cast(currentType,Type.INT_TYPE);
}
break;
case LONG:
if (shouldConvertBetweenStringAndLong(field)) {
MethodRef.LONG_PARSE_LONG.invokeUnchecked(cb);
}
break;
case BYTE_STRING:
BASE_ENCODING_BASE_64.invokeUnchecked(cb);
cb.swap();
BASE_ENCODING_DECODE.invokeUnchecked(cb);
BYTE_STRING_COPY_FROM.invokeUnchecked(cb);
break;
case MESSAGE:
coerceToMessage(cb,field);
break;
case ENUM:
if (!currentType.equals(Type.INT_TYPE)) {
cb.cast(currentType,Type.INT_TYPE);
}
if (!isProto3EnumField(field)) {
getForNumberMethod(field.getEnumType()).invokeUnchecked(cb);
}
return;
default :
throw new AssertionError(""String_Node_Str"" + field);
}
if (field.isExtension()) {
Type fieldType=getRuntimeType(field);
if (isPrimitive(fieldType)) {
cb.valueOf(fieldType);
}
}
}","/** 
 * Generate bytecode that coerces the top of stack to the correct type for the given field setter.
 */
private static void coerce(CodeBuilder cb,Type currentType,FieldDescriptor field){
switch (field.getJavaType()) {
case BOOLEAN:
case DOUBLE:
case STRING:
    break;
case FLOAT:
  if (!currentType.equals(Type.FLOAT_TYPE)) {
    cb.cast(currentType,Type.FLOAT_TYPE);
  }
break;
case INT:
if (!currentType.equals(Type.INT_TYPE)) {
cb.cast(currentType,Type.INT_TYPE);
}
break;
case LONG:
if (shouldConvertBetweenStringAndLong(field)) {
MethodRef.LONG_PARSE_LONG.invokeUnchecked(cb);
}
break;
case BYTE_STRING:
BASE_ENCODING_BASE_64.invokeUnchecked(cb);
cb.swap();
BASE_ENCODING_DECODE.invokeUnchecked(cb);
BYTE_STRING_COPY_FROM.invokeUnchecked(cb);
break;
case MESSAGE:
coerceToMessage(cb,currentType,field);
break;
case ENUM:
if (!currentType.equals(Type.INT_TYPE)) {
cb.cast(currentType,Type.INT_TYPE);
}
if (!isProto3EnumField(field)) {
getForNumberMethod(field.getEnumType()).invokeUnchecked(cb);
}
return;
default :
throw new AssertionError(""String_Node_Str"" + field);
}
if (field.isExtension()) {
Type fieldType=getRuntimeType(field);
if (isPrimitive(fieldType)) {
cb.valueOf(fieldType);
}
}
}",0.9949874686716792
29374,"private static void coerceToMessage(CodeBuilder cb,FieldDescriptor field){
  if (isSafeProto(field)) {
    MethodRef toProto=SANITIZED_CONTENT_TO_PROTO.get(field.getMessageType().getFullName());
    toProto.invokeUnchecked(cb);
  }
  cb.checkCast(getRuntimeType(field));
}","private static void coerceToMessage(CodeBuilder cb,Type currentType,FieldDescriptor field){
  Type runtimeFieldType=getRuntimeType(field);
  if (isSafeProto(field)) {
    MethodRef toProto=SANITIZED_CONTENT_TO_PROTO.get(field.getMessageType().getFullName());
    if (!currentType.equals(BytecodeUtils.SANITIZED_CONTENT_TYPE)) {
      cb.checkCast(BytecodeUtils.SANITIZED_CONTENT_TYPE);
    }
    toProto.invokeUnchecked(cb);
    currentType=toProto.returnType();
  }
  if (!currentType.equals(runtimeFieldType)) {
    cb.checkCast(runtimeFieldType);
  }
}",0.5465538089480049
29375,"@Override void doGen(CodeBuilder cb){
  cb.checkCast(EXTENDABLE_BUILDER_TYPE);
  baseArg.gen(cb);
  Label argIsNull=null;
  Label end=null;
  if (isNullable) {
    argIsNull=new Label();
    end=new Label();
    cb.dup();
    cb.ifNull(argIsNull);
  }
  unboxAndCoerce(cb,baseArg,field);
  extensionIdentifier.gen(cb);
  cb.swap();
  setterMethod.invokeUnchecked(cb);
  if (isNullable) {
    cb.goTo(end);
    cb.mark(argIsNull);
    cb.pop();
    cb.mark(end);
  }
  cb.checkCast(builderRuntimeType(descriptor).type());
}","@Override void doGen(CodeBuilder cb){
  baseArg.gen(cb);
  Label argIsNull=null;
  Label end=null;
  if (isNullable) {
    argIsNull=new Label();
    end=new Label();
    cb.dup();
    cb.ifNull(argIsNull);
  }
  unboxAndCoerce(cb,baseArg,field);
  extensionIdentifier.gen(cb);
  cb.swap();
  setterMethod.invokeUnchecked(cb);
  if (isNullable) {
    cb.goTo(end);
    cb.mark(argIsNull);
    cb.pop();
    cb.mark(end);
  }
  cb.checkCast(builderRuntimeType(descriptor).type());
}",0.1874376869391824
29376,"/** 
 * Assuming that the value of   {@code baseArg} is on the top of the stack. unbox and coerce it tobe compatible with the given field descriptor.
 */
private static void unboxAndCoerce(CodeBuilder cb,SoyExpression baseArg,FieldDescriptor field){
  Type currentType;
  if (!isSafeProto(field)) {
    if (baseArg.isBoxed()) {
      currentType=unboxUnchecked(cb,baseArg.soyRuntimeType(),classToUnboxTo(field));
    }
 else {
      currentType=baseArg.resultType();
    }
  }
 else {
    currentType=SANITIZED_CONTENT_TYPE;
  }
  coerce(cb,currentType,field);
}","/** 
 * Assuming that the value of   {@code baseArg} is on the top of the stack. unbox and coerce it tobe compatible with the given field descriptor.
 */
private static void unboxAndCoerce(CodeBuilder cb,SoyExpression baseArg,FieldDescriptor field){
  Type currentType;
  if (!isSafeProto(field)) {
    if (baseArg.isBoxed()) {
      currentType=unboxUnchecked(cb,baseArg.soyRuntimeType(),classToUnboxTo(field));
    }
 else {
      currentType=baseArg.resultType();
    }
  }
 else {
    currentType=baseArg.resultType();
  }
  coerce(cb,currentType,field);
}",0.962566844919786
29377,"private Statement handleExtension(final SoyExpression baseArg,final FieldDescriptor field){
  final Expression extensionIdentifier=getExtensionField(field).accessor();
  final MethodRef setterMethod=field.isRepeated() ? EXTENDABLE_BUILDER_ADD_EXTENSION : EXTENDABLE_BUILDER_SET_EXTENSION;
  final boolean isNullable=!baseArg.isNonNullable();
  return new Statement(){
    @Override void doGen(    CodeBuilder cb){
      cb.checkCast(EXTENDABLE_BUILDER_TYPE);
      baseArg.gen(cb);
      Label argIsNull=null;
      Label end=null;
      if (isNullable) {
        argIsNull=new Label();
        end=new Label();
        cb.dup();
        cb.ifNull(argIsNull);
      }
      unboxAndCoerce(cb,baseArg,field);
      extensionIdentifier.gen(cb);
      cb.swap();
      setterMethod.invokeUnchecked(cb);
      if (isNullable) {
        cb.goTo(end);
        cb.mark(argIsNull);
        cb.pop();
        cb.mark(end);
      }
      cb.checkCast(builderRuntimeType(descriptor).type());
    }
  }
;
}","private Statement handleExtension(final SoyExpression baseArg,final FieldDescriptor field){
  final Expression extensionIdentifier=getExtensionField(field).accessor();
  final MethodRef setterMethod=field.isRepeated() ? EXTENDABLE_BUILDER_ADD_EXTENSION : EXTENDABLE_BUILDER_SET_EXTENSION;
  final boolean isNullable=!baseArg.isNonNullable();
  return new Statement(){
    @Override void doGen(    CodeBuilder cb){
      baseArg.gen(cb);
      Label argIsNull=null;
      Label end=null;
      if (isNullable) {
        argIsNull=new Label();
        end=new Label();
        cb.dup();
        cb.ifNull(argIsNull);
      }
      unboxAndCoerce(cb,baseArg,field);
      extensionIdentifier.gen(cb);
      cb.swap();
      setterMethod.invokeUnchecked(cb);
      if (isNullable) {
        cb.goTo(end);
        cb.mark(argIsNull);
        cb.pop();
        cb.mark(end);
      }
      cb.checkCast(builderRuntimeType(descriptor).type());
    }
  }
;
}",0.5002573340195574
29378,"@Override protected String getCommonSuperClass(String left,String right){
  boolean leftIsGenerated=left.startsWith(Names.INTERNAL_CLASS_PREFIX);
  boolean rightIsGenerated=right.startsWith(Names.INTERNAL_CLASS_PREFIX);
  if (!leftIsGenerated & !rightIsGenerated) {
    return super.getCommonSuperClass(left,right);
  }
  return OBJECT.internalName();
}","@Override protected String getCommonSuperClass(String left,String right){
  boolean leftIsGenerated=left.startsWith(Names.INTERNAL_CLASS_PREFIX);
  boolean rightIsGenerated=right.startsWith(Names.INTERNAL_CLASS_PREFIX);
  if (!leftIsGenerated && !rightIsGenerated) {
    if ((left.equals(PROTO_EXTENDABLE_BUILDER) && right.endsWith(""String_Node_Str"")) || (right.equals(PROTO_EXTENDABLE_BUILDER) && left.endsWith(""String_Node_Str""))) {
      return PROTO_EXTENDABLE_BUILDER;
    }
    try {
      return super.getCommonSuperClass(left,right);
    }
 catch (    RuntimeException re) {
      throw new RuntimeException(""String_Node_Str"" + left + ""String_Node_Str""+ right);
    }
  }
  return OBJECT.internalName();
}",0.6622889305816135
29379,"private static PrimitiveSoyType protoType(SoyProtoType soyType){
  return new PrimitiveSoyType(soyType,Type.getType('L' + soyType.getNameForBackend(SoyBackendKind.JBC_SRC).replace('.','/') + ';'),BytecodeUtils.SOY_PROTO_VALUE_TYPE);
}","private static PrimitiveSoyType protoType(SoyProtoType soyType){
  return new PrimitiveSoyType(soyType,Type.getType('L' + soyType.getNameForBackend(SoyBackendKind.JBC_SRC).replace('.','/') + ';'),BytecodeUtils.SOY_PROTO_VALUE_IMPL_TYPE);
}",0.9894291754756872
29380,"/** 
 * Creates a code chunk declaring an automatically-named variable initialized to the given value.
 */
public VariableDeclaration declare(CodeChunk.WithValue rhs){
  return CodeChunk.declare(newVarName(),rhs);
}","/** 
 * Creates a code chunk declaring an automatically-named variable with no initializer. 
 */
public VariableDeclaration declare(){
  return VariableDeclaration.create(newVarName(),null);
}",0.7813267813267813
29381,"/** 
 * Creates a code chunk representing a JavaScript number literal. 
 */
public static WithValue number(double value){
  return Leaf.create(Double.toString(value));
}","/** 
 * Creates a code chunk representing a JavaScript number literal. 
 */
public static WithValue number(double value){
  return Leaf.create(Double.toString(value),true);
}",0.9854227405247812
29382,"/** 
 * Creates a code chunk representing a JavaScript identifier.
 * @throws IllegalArgumentException if {@code id} is not a valid JavaScript identifier.
 */
static WithValue id(String id,Iterable<GoogRequire> requires){
  CodeChunkUtils.checkId(id);
  return Leaf.create(id,requires);
}","/** 
 * Creates a code chunk representing a JavaScript identifier.
 * @throws IllegalArgumentException if {@code id} is not a valid JavaScript identifier.
 */
static WithValue id(String id,Iterable<GoogRequire> requires){
  CodeChunkUtils.checkId(id);
  return Leaf.create(id,true,requires);
}",0.991394148020654
29383,"/** 
 * Creates a code chunk representing a JavaScript string literal.
 * @param contents The contents of the string literal. The contents will be escaped appropriatelyand embedded inside single quotes.
 */
public static WithValue stringLiteral(String contents){
  String escaped=BaseUtils.escapeToSoyString(contents,true);
  escaped=escaped.replace(""String_Node_Str"",""String_Node_Str"");
  return Leaf.create(escaped);
}","/** 
 * Creates a code chunk representing a JavaScript string literal.
 * @param contents The contents of the string literal. The contents will be escaped appropriatelyand embedded inside single quotes.
 */
public static WithValue stringLiteral(String contents){
  String escaped=BaseUtils.escapeToSoyString(contents,true);
  escaped=escaped.replace(""String_Node_Str"",""String_Node_Str"");
  return Leaf.create(escaped,true);
}",0.9940828402366864
29384,"/** 
 * Creates a new code chunk from the given expression. The expression's precedence is preserved.
 */
public static WithValue fromExpr(JsExpr expr,Iterable<GoogRequire> requires){
  return Leaf.create(expr,requires);
}","/** 
 * Creates a new code chunk from the given expression. The expression's precedence is preserved.
 */
public static WithValue fromExpr(JsExpr expr,Iterable<GoogRequire> requires){
  return Leaf.create(expr,false,requires);
}",0.9866666666666668
29385,"/** 
 * If every branch in an   {@code if}-  {@code else if}-  {@code else} statement represents a value, thewhole statement represents a value, namely that of the taken branch. Make this explicit by declaring a variable before the statement and assigning into it in every branch.
 */
CodeChunk.WithValue asConditionalExpression(CodeChunk.Generator codeGenerator){
  Preconditions.checkState(everyBranchHasAValue());
  VariableDeclaration decl=codeGenerator.declare(WithValue.LITERAL_NULL);
  CodeChunk.WithValue var=decl.ref();
  ConditionalBuilder builder=null;
  for (  IfThenPair oldCondition : conditions()) {
    CodeChunk.WithValue newConsequent=var.assign((CodeChunk.WithValue)oldCondition.consequent);
    if (builder == null) {
      builder=CodeChunk.ifStatement(oldCondition.predicate,newConsequent);
    }
 else {
      builder.elseif_(oldCondition.predicate,newConsequent);
    }
  }
  if (trailingElse() != null) {
    builder.else_(var.assign((CodeChunk.WithValue)trailingElse()));
  }
  return var.withInitialStatements(ImmutableList.of(decl,builder.build()));
}","/** 
 * If every branch in an   {@code if}-  {@code else if}-  {@code else} statement represents a value, thewhole statement represents a value, namely that of the taken branch. Make this explicit by declaring a variable before the statement and assigning into it in every branch.
 */
CodeChunk.WithValue asConditionalExpression(CodeChunk.Generator codeGenerator){
  Preconditions.checkState(everyBranchHasAValue());
  VariableDeclaration decl=codeGenerator.declare();
  CodeChunk.WithValue var=decl.ref();
  ConditionalBuilder builder=null;
  for (  IfThenPair oldCondition : conditions()) {
    CodeChunk.WithValue newConsequent=var.assign((CodeChunk.WithValue)oldCondition.consequent);
    if (builder == null) {
      builder=CodeChunk.ifStatement(oldCondition.predicate,newConsequent);
    }
 else {
      builder.elseif_(oldCondition.predicate,newConsequent);
    }
  }
  if (trailingElse() != null) {
    builder.else_(var.assign((CodeChunk.WithValue)trailingElse()));
  }
  return var.withInitialStatements(ImmutableList.of(decl,builder.build()));
}",0.9897003745318352
29386,"static Leaf create(JsExpr value,Iterable<GoogRequire> requires){
  return new AutoValue_Leaf(value,ImmutableSet.copyOf(requires));
}","static Leaf create(JsExpr value,boolean isCheap,Iterable<GoogRequire> requires){
  return new AutoValue_Leaf(value,ImmutableSet.copyOf(requires),isCheap);
}",0.9166666666666666
29387,"/** 
 * Returns a code chunk representing the entire access chain. Null-safe accesses in the chain generate code to make sure the chain is non-null before performing the access.
 */
CodeChunk.WithValue result(CodeChunk.Generator codeGenerator){
  ImmutableList<CodeChunk.WithValue> intermediateValues=buildIntermediateValues();
  Preconditions.checkState(intermediateValues.size() == chain.size() + 1);
  CodeChunk.WithValue cur=intermediateValues.get(intermediateValues.size() - 1);
  for (int i=intermediateValues.size() - 2; i >= 0; --i) {
    CodeChunk.WithValue chunk=intermediateValues.get(i);
    boolean nullSafe=chain.get(i).nullSafe;
    if (nullSafe) {
      cur=ifExpression(chunk.doubleEqualsNull(),LITERAL_NULL).else_(cur).build(codeGenerator);
    }
  }
  if (unpackFunction == null) {
    return cur;
  }
 else   if (!isRepeated) {
    return unpackFunction.call(cur);
  }
 else {
    return GOOG_ARRAY_MAP.call(cur,unpackFunction);
  }
}","/** 
 * Returns a code chunk representing the entire access chain. Null-safe accesses in the chain generate code to make sure the chain is non-null before performing the access.
 */
CodeChunk.WithValue result(CodeChunk.Generator codeGenerator){
  CodeChunk.WithValue accessChain=buildAccessChain(base,codeGenerator,chain.iterator());
  if (unpackFunction == null) {
    return accessChain;
  }
 else   if (!isRepeated) {
    return unpackFunction.call(accessChain);
  }
 else {
    return GOOG_ARRAY_MAP.call(accessChain,unpackFunction);
  }
}",0.501002004008016
29388,"@Test public void testNullSafeChain(){
  NullSafeAccumulator accum=new NullSafeAccumulator(CodeChunk.id(""String_Node_Str""));
  assertThat(accum).generates(""String_Node_Str"");
  assertThat(accum.dotAccess(FieldAccess.id(""String_Node_Str""),true)).generates(""String_Node_Str"");
  assertThat(accum.bracketAccess(CodeChunk.id(""String_Node_Str""),true)).generates(""String_Node_Str"");
  assertThat(accum.dotAccess(FieldAccess.id(""String_Node_Str""),true)).generates(""String_Node_Str"");
  assertThat(accum.bracketAccess(CodeChunk.id(""String_Node_Str""),true)).generates(""String_Node_Str"");
}","@Test public void testNullSafeChain(){
  NullSafeAccumulator accum=new NullSafeAccumulator(CodeChunk.id(""String_Node_Str""));
  assertThat(accum).generates(""String_Node_Str"");
  assertThat(accum.dotAccess(FieldAccess.id(""String_Node_Str""),true)).generates(""String_Node_Str"");
  assertThat(accum.bracketAccess(CodeChunk.id(""String_Node_Str""),true)).generates(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertThat(accum.dotAccess(FieldAccess.id(""String_Node_Str""),true)).generates(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertThat(accum.bracketAccess(CodeChunk.id(""String_Node_Str""),true)).generates(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.6082852648138437
29389,"@Test public void testMixedChains(){
  NullSafeAccumulator accum=new NullSafeAccumulator(CodeChunk.id(""String_Node_Str""));
  assertThat(accum).generates(""String_Node_Str"");
  assertThat(accum.dotAccess(FieldAccess.id(""String_Node_Str""),true)).generates(""String_Node_Str"");
  assertThat(accum.bracketAccess(CodeChunk.id(""String_Node_Str""),false)).generates(""String_Node_Str"");
  assertThat(accum.dotAccess(FieldAccess.id(""String_Node_Str""),true)).generates(""String_Node_Str"");
  assertThat(accum.bracketAccess(CodeChunk.id(""String_Node_Str""),false)).generates(""String_Node_Str"");
}","@Test public void testMixedChains(){
  NullSafeAccumulator accum=new NullSafeAccumulator(CodeChunk.id(""String_Node_Str""));
  assertThat(accum).generates(""String_Node_Str"");
  assertThat(accum.dotAccess(FieldAccess.id(""String_Node_Str""),true)).generates(""String_Node_Str"");
  assertThat(accum.bracketAccess(CodeChunk.id(""String_Node_Str""),false)).generates(""String_Node_Str"");
  assertThat(accum.dotAccess(FieldAccess.id(""String_Node_Str""),true)).generates(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertThat(accum.bracketAccess(CodeChunk.id(""String_Node_Str""),false)).generates(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.8333333333333334
29390,"/** 
 * Generates Incremental DOM JS source code given a Soy parse tree, an options object, and an optional bundle of translated messages.
 * @param soyTree The Soy parse tree to generate JS source code for.
 * @param registry The template registry that contains all the template information.
 * @param options The compilation options relevant to this backend.
 * @param errorReporter The Soy error reporter that collects errors during code generation.
 * @return A list of strings where each string represents the JS source code that belongs in oneJS file. The generated JS files correspond one-to-one to the original Soy source files.
 */
public List<String> genJsSrc(SoyFileSetNode soyTree,TemplateRegistry registry,SoyIncrementalDomSrcOptions options,ErrorReporter errorReporter){
  SoyJsSrcOptions incrementalJSSrcOptions=options.toJsSrcOptions();
  try (GuiceSimpleScope.InScope inScope=apiCallScope.enter()){
    inScope.seed(SoyJsSrcOptions.class,incrementalJSSrcOptions);
    BidiGlobalDir bidiGlobalDir=SoyBidiUtils.decodeBidiGlobalDirFromJsOptions(incrementalJSSrcOptions.getBidiGlobalDir(),incrementalJSSrcOptions.getUseGoogIsRtlForBidiGlobalDir());
    ApiCallScopeUtils.seedSharedParams(inScope,null,bidiGlobalDir);
    optimizeBidiCodeGenVisitorProvider.get().exec(soyTree);
    new HtmlContextVisitor(errorReporter).exec(soyTree);
    if (errorReporter.hasErrors()) {
      return Collections.emptyList();
    }
    new UnescapingVisitor().exec(soyTree);
    new IncrementalDomExtractMsgVariablesVisitor().exec(soyTree);
    new CombineConsecutiveRawTextNodesVisitor().exec(soyTree);
    return genIncrementalDomCodeVisitorProvider.get().gen(soyTree,registry,errorReporter);
  }
 }","/** 
 * Generates Incremental DOM JS source code given a Soy parse tree, an options object, and an optional bundle of translated messages.
 * @param soyTree The Soy parse tree to generate JS source code for.
 * @param registry The template registry that contains all the template information.
 * @param options The compilation options relevant to this backend.
 * @param errorReporter The Soy error reporter that collects errors during code generation.
 * @return A list of strings where each string represents the JS source code that belongs in oneJS file. The generated JS files correspond one-to-one to the original Soy source files.
 */
public List<String> genJsSrc(SoyFileSetNode soyTree,TemplateRegistry registry,SoyIncrementalDomSrcOptions options,ErrorReporter errorReporter){
  SoyJsSrcOptions incrementalJSSrcOptions=options.toJsSrcOptions();
  try (GuiceSimpleScope.InScope inScope=apiCallScope.enter()){
    inScope.seed(SoyJsSrcOptions.class,incrementalJSSrcOptions);
    BidiGlobalDir bidiGlobalDir=SoyBidiUtils.decodeBidiGlobalDirFromJsOptions(incrementalJSSrcOptions.getBidiGlobalDir(),incrementalJSSrcOptions.getUseGoogIsRtlForBidiGlobalDir());
    ApiCallScopeUtils.seedSharedParams(inScope,null,bidiGlobalDir);
    optimizeBidiCodeGenVisitorProvider.get().exec(soyTree);
    new HtmlContextVisitor(errorReporter).exec(soyTree);
    if (errorReporter.hasErrors()) {
      return Collections.emptyList();
    }
    new UnescapingVisitor().exec(soyTree);
    new IncrementalDomExtractMsgVariablesVisitor().exec(soyTree);
    new CombineConsecutiveRawTextNodesPass().run(soyTree);
    return genIncrementalDomCodeVisitorProvider.get().gen(soyTree,registry,errorReporter);
  }
 }",0.9433628318584072
29391,"/** 
 * Generates JS source code given a Soy parse tree, an options object, and an optional bundle of translated messages.
 * @param soyTree The Soy parse tree to generate JS source code for.
 * @param templateRegistry The template registry that contains all the template information.
 * @param jsSrcOptions The compilation options relevant to this backend.
 * @param msgBundle The bundle of translated messages, or null to use the messages from the Soysource.
 * @param errorReporter The Soy error reporter that collects errors during code generation.
 * @return A list of strings where each string represents the JS source code that belongs in oneJS file. The generated JS files correspond one-to-one to the original Soy source files.
 */
public List<String> genJsSrc(SoyFileSetNode soyTree,TemplateRegistry templateRegistry,SoyJsSrcOptions jsSrcOptions,@Nullable SoyMsgBundle msgBundle,ErrorReporter errorReporter){
  Preconditions.checkState(!jsSrcOptions.getUseGoogIsRtlForBidiGlobalDir() || jsSrcOptions.shouldProvideRequireSoyNamespaces() || jsSrcOptions.shouldProvideRequireJsFunctions(),""String_Node_Str"" + ""String_Node_Str"");
  try (GuiceSimpleScope.InScope inScope=apiCallScope.enter()){
    inScope.seed(SoyJsSrcOptions.class,jsSrcOptions);
    BidiGlobalDir bidiGlobalDir=SoyBidiUtils.decodeBidiGlobalDirFromJsOptions(jsSrcOptions.getBidiGlobalDir(),jsSrcOptions.getUseGoogIsRtlForBidiGlobalDir());
    ApiCallScopeUtils.seedSharedParams(inScope,msgBundle,bidiGlobalDir);
    if (jsSrcOptions.shouldGenerateGoogMsgDefs()) {
      new ExtractMsgVariablesVisitor().exec(soyTree);
      Preconditions.checkState(bidiGlobalDir != null,""String_Node_Str"");
    }
 else {
      Preconditions.checkState(bidiGlobalDir == null || bidiGlobalDir.isStaticValue(),""String_Node_Str"");
      new InsertMsgsVisitor(msgBundle,errorReporter).exec(soyTree);
      new CombineConsecutiveRawTextNodesVisitor().exec(soyTree);
    }
    optimizeBidiCodeGenVisitorProvider.get().exec(soyTree);
    return genJsCodeVisitorProvider.get().gen(soyTree,templateRegistry,errorReporter);
  }
 }","/** 
 * Generates JS source code given a Soy parse tree, an options object, and an optional bundle of translated messages.
 * @param soyTree The Soy parse tree to generate JS source code for.
 * @param templateRegistry The template registry that contains all the template information.
 * @param jsSrcOptions The compilation options relevant to this backend.
 * @param msgBundle The bundle of translated messages, or null to use the messages from the Soysource.
 * @param errorReporter The Soy error reporter that collects errors during code generation.
 * @return A list of strings where each string represents the JS source code that belongs in oneJS file. The generated JS files correspond one-to-one to the original Soy source files.
 */
public List<String> genJsSrc(SoyFileSetNode soyTree,TemplateRegistry templateRegistry,SoyJsSrcOptions jsSrcOptions,@Nullable SoyMsgBundle msgBundle,ErrorReporter errorReporter){
  Preconditions.checkState(!jsSrcOptions.getUseGoogIsRtlForBidiGlobalDir() || jsSrcOptions.shouldProvideRequireSoyNamespaces() || jsSrcOptions.shouldProvideRequireJsFunctions(),""String_Node_Str"" + ""String_Node_Str"");
  try (GuiceSimpleScope.InScope inScope=apiCallScope.enter()){
    inScope.seed(SoyJsSrcOptions.class,jsSrcOptions);
    BidiGlobalDir bidiGlobalDir=SoyBidiUtils.decodeBidiGlobalDirFromJsOptions(jsSrcOptions.getBidiGlobalDir(),jsSrcOptions.getUseGoogIsRtlForBidiGlobalDir());
    ApiCallScopeUtils.seedSharedParams(inScope,msgBundle,bidiGlobalDir);
    if (jsSrcOptions.shouldGenerateGoogMsgDefs()) {
      new ExtractMsgVariablesVisitor().exec(soyTree);
      Preconditions.checkState(bidiGlobalDir != null,""String_Node_Str"");
    }
 else {
      Preconditions.checkState(bidiGlobalDir == null || bidiGlobalDir.isStaticValue(),""String_Node_Str"");
      new InsertMsgsVisitor(msgBundle,errorReporter).exec(soyTree);
      new CombineConsecutiveRawTextNodesPass().run(soyTree);
    }
    optimizeBidiCodeGenVisitorProvider.get().exec(soyTree);
    return genJsCodeVisitorProvider.get().gen(soyTree,templateRegistry,errorReporter);
  }
 }",0.9281581485053038
29392,"@Override protected void visitSoyFileSetNode(SoyFileSetNode node){
  if (!bidiGlobalDir.isStaticValue()) {
    return;
  }
  nodeIdGen=node.getNodeIdGenerator();
  madeReplacement=false;
  visitChildren(node);
  if (madeReplacement) {
    new CombineConsecutiveRawTextNodesVisitor().exec(node);
  }
}","@Override protected void visitSoyFileSetNode(SoyFileSetNode node){
  if (!bidiGlobalDir.isStaticValue()) {
    return;
  }
  nodeIdGen=node.getNodeIdGenerator();
  madeReplacement=false;
  visitChildren(node);
  if (madeReplacement) {
    new CombineConsecutiveRawTextNodesPass().run(node);
  }
}",0.9697986577181208
29393,"private PassManager(Builder builder){
  this.registry=checkNotNull(builder.registry);
  this.soyFunctionMap=checkNotNull(builder.soyFunctionMap);
  this.errorReporter=checkNotNull(builder.errorReporter);
  this.declaredSyntaxVersion=checkNotNull(builder.declaredSyntaxVersion);
  this.options=checkNotNull(builder.opts);
  boolean allowUnknownGlobals=builder.allowUnknownGlobals;
  boolean disableAllTypeChecking=builder.disableAllTypeChecking;
  this.desugarHtmlNodes=builder.desugarHtmlNodes;
  this.autoescaper=builder.autoescaperEnabled ? new ContextualAutoescaper(builder.soyPrintDirectives) : null;
  this.simplifyVisitor=options.isOptimizerEnabled() ? SimplifyVisitor.create(builder.soyPrintDirectives) : null;
  ImmutableList.Builder<CompilerFilePass> singleFilePassesBuilder=ImmutableList.<CompilerFilePass>builder().add(new HtmlRewritePass(errorReporter)).add(new ContentSecurityPolicyNonceInjectionPass(errorReporter)).add(new InsertMsgPlaceholderNodesPass(errorReporter)).add(new RewriteGendersPass()).add(new RewriteRemaindersPass()).add(new StrictHtmlValidationPass(options.getExperimentalFeatures(),errorReporter)).add(new RewriteGlobalsPass(registry,options.getCompileTimeGlobals(),errorReporter)).add(new ResolveNamesPass());
  singleFilePassesBuilder.add(new ResolveFunctionsPass());
  if (!disableAllTypeChecking) {
    singleFilePassesBuilder.add(new ResolveExpressionTypesPass());
  }
  singleFilePassesBuilder.add(new ResolvePackageRelativeCssNamesPass());
  if (!allowUnknownGlobals) {
    singleFilePassesBuilder.add(new CheckGlobalsPass(errorReporter));
  }
  singleFilePassesBuilder.add(new ValidateAliasesPass()).add(new CheckNonEmptyMsgNodesPass(errorReporter)).add(new CheckSyntaxVersionPass());
  if (!disableAllTypeChecking) {
    singleFilePassesBuilder.add(new CheckProtoInitCallsPass(errorReporter)).add(new CheckFunctionCallsPass(builder.allowUnknownFunctions,declaredSyntaxVersion,errorReporter));
  }
  if (options.isStrictAutoescapingRequired() == TriState.ENABLED) {
    singleFilePassesBuilder.add(new EnforceStrictAutoescapingPass());
  }
  if (builder.addHtmlCommentsForDebug) {
    singleFilePassesBuilder.add(new AddHtmlCommentsForDebugPass());
  }
  this.singleFilePasses=singleFilePassesBuilder.build();
  ImmutableList.Builder<CompilerFileSetPass> beforeAutoescaperFileSetPassBuilder=ImmutableList.<CompilerFileSetPass>builder().add(new CheckTemplateParamsPass());
  if (!disableAllTypeChecking) {
    beforeAutoescaperFileSetPassBuilder.add(new CheckTemplateCallsPass(errorReporter));
  }
  beforeAutoescaperFileSetPassBuilder.add(new CheckVisibilityPass()).add(new CheckDelegatesPass()).add(new CheckEscapingSanityFileSetPass(errorReporter));
  if (options.allowExternalCalls() == TriState.DISABLED) {
    beforeAutoescaperFileSetPassBuilder.add(new StrictDepsPass());
  }
  beforeAutoescaperFileSetPassBuilder.add(new CombinedRawTextNodesPass());
  this.crossTemplateCheckingPasses=beforeAutoescaperFileSetPassBuilder.build();
  ImmutableList.Builder<CompilerFileSetPass> simplificationPassesBuilder=ImmutableList.builder();
  if (desugarHtmlNodes) {
    simplificationPassesBuilder.add(new DesugarHtmlNodesPass());
  }
  if (builder.optimize) {
    simplificationPassesBuilder.add(new OptimizationPass());
  }
  simplificationPassesBuilder.add(new CombinedRawTextNodesPass());
  this.simplificationPasses=simplificationPassesBuilder.build();
}","private PassManager(Builder builder){
  this.registry=checkNotNull(builder.registry);
  this.soyFunctionMap=checkNotNull(builder.soyFunctionMap);
  this.errorReporter=checkNotNull(builder.errorReporter);
  this.declaredSyntaxVersion=checkNotNull(builder.declaredSyntaxVersion);
  this.options=checkNotNull(builder.opts);
  boolean allowUnknownGlobals=builder.allowUnknownGlobals;
  boolean disableAllTypeChecking=builder.disableAllTypeChecking;
  this.desugarHtmlNodes=builder.desugarHtmlNodes;
  this.autoescaper=builder.autoescaperEnabled ? new ContextualAutoescaper(builder.soyPrintDirectives) : null;
  this.simplifyVisitor=options.isOptimizerEnabled() ? SimplifyVisitor.create(builder.soyPrintDirectives) : null;
  ImmutableList.Builder<CompilerFilePass> singleFilePassesBuilder=ImmutableList.<CompilerFilePass>builder().add(new HtmlRewritePass(errorReporter)).add(new ContentSecurityPolicyNonceInjectionPass(errorReporter)).add(new InsertMsgPlaceholderNodesPass(errorReporter)).add(new RewriteGendersPass()).add(new RewriteRemaindersPass()).add(new StrictHtmlValidationPass(options.getExperimentalFeatures(),errorReporter)).add(new RewriteGlobalsPass(registry,options.getCompileTimeGlobals(),errorReporter)).add(new ResolveNamesPass());
  singleFilePassesBuilder.add(new ResolveFunctionsPass());
  if (!disableAllTypeChecking) {
    singleFilePassesBuilder.add(new ResolveExpressionTypesPass());
  }
  singleFilePassesBuilder.add(new ResolvePackageRelativeCssNamesPass());
  if (!allowUnknownGlobals) {
    singleFilePassesBuilder.add(new CheckGlobalsPass(errorReporter));
  }
  singleFilePassesBuilder.add(new ValidateAliasesPass()).add(new CheckNonEmptyMsgNodesPass(errorReporter)).add(new CheckSyntaxVersionPass());
  if (!disableAllTypeChecking) {
    singleFilePassesBuilder.add(new CheckProtoInitCallsPass(errorReporter)).add(new CheckFunctionCallsPass(builder.allowUnknownFunctions,declaredSyntaxVersion,errorReporter));
  }
  if (options.isStrictAutoescapingRequired() == TriState.ENABLED) {
    singleFilePassesBuilder.add(new EnforceStrictAutoescapingPass());
  }
  if (builder.addHtmlCommentsForDebug) {
    singleFilePassesBuilder.add(new AddHtmlCommentsForDebugPass());
  }
  this.singleFilePasses=singleFilePassesBuilder.build();
  ImmutableList.Builder<CompilerFileSetPass> beforeAutoescaperFileSetPassBuilder=ImmutableList.<CompilerFileSetPass>builder().add(new CheckTemplateParamsPass());
  if (!disableAllTypeChecking) {
    beforeAutoescaperFileSetPassBuilder.add(new CheckTemplateCallsPass(errorReporter));
  }
  beforeAutoescaperFileSetPassBuilder.add(new CheckVisibilityPass()).add(new CheckDelegatesPass()).add(new CheckEscapingSanityFileSetPass(errorReporter));
  if (options.allowExternalCalls() == TriState.DISABLED) {
    beforeAutoescaperFileSetPassBuilder.add(new StrictDepsPass());
  }
  beforeAutoescaperFileSetPassBuilder.add(new CombineConsecutiveRawTextNodesPass());
  this.crossTemplateCheckingPasses=beforeAutoescaperFileSetPassBuilder.build();
  ImmutableList.Builder<CompilerFileSetPass> simplificationPassesBuilder=ImmutableList.builder();
  if (desugarHtmlNodes) {
    simplificationPassesBuilder.add(new DesugarHtmlNodesPass());
  }
  if (builder.optimize) {
    simplificationPassesBuilder.add(new OptimizationPass());
  }
  simplificationPassesBuilder.add(new CombineConsecutiveRawTextNodesPass());
  this.simplificationPasses=simplificationPassesBuilder.build();
}",0.9964747356051704
29394,"/** 
 * This method should be called at the end of a sequence of basic whitespace tokens. This is how we implement the line joining algorithm.
 * @param next The next basic text token image, or null if the next token isn't a basic token.
 */
private void maybeCollapseWhitespace(@Nullable String next){
  if (basicStartOfWhitespace != -1) {
    if (basicHasNewline) {
      if (basicStart == basicStartOfWhitespace || next == null) {
        buffer.delete(basicStartOfWhitespace,buffer.length());
        offsets.delete(basicStartOfWhitespace);
        if (next == null && endColumnAtStartOfWhitespace != -1) {
          offsets.setEndLocation(endLineAtStartOfWhitespace,endColumnAtStartOfWhitespace);
        }
      }
 else {
        if (next.charAt(0) == '<' || buffer.charAt(basicStartOfWhitespace - 1) == '>') {
          buffer.delete(basicStartOfWhitespace,buffer.length());
          offsets.delete(basicStartOfWhitespace);
        }
 else {
          buffer.replace(basicStartOfWhitespace,buffer.length(),""String_Node_Str"");
          offsets.delete(basicStartOfWhitespace);
        }
      }
      discontinuityReason=Reason.WHITESPACE;
      basicHasNewline=false;
    }
    basicStartOfWhitespace=-1;
  }
}","/** 
 * This method should be called at the end of a sequence of basic whitespace tokens. This is how we implement the line joining algorithm.
 * @param next The next basic text token image, or null if the next token isn't a basic token.
 */
private void maybeCollapseWhitespace(@Nullable String next){
  if (basicStartOfWhitespace != -1) {
    if (basicHasNewline) {
      offsets.delete(basicStartOfWhitespace);
      if (basicStart == basicStartOfWhitespace || next == null) {
        buffer.setLength(basicStartOfWhitespace);
        if (next == null && endColumnAtStartOfWhitespace != -1) {
          offsets.setEndLocation(endLineAtStartOfWhitespace,endColumnAtStartOfWhitespace);
        }
      }
 else {
        if (next.charAt(0) == '<' || buffer.charAt(basicStartOfWhitespace - 1) == '>') {
          buffer.setLength(basicStartOfWhitespace);
        }
 else {
          buffer.setLength(basicStartOfWhitespace);
          buffer.append(' ');
        }
      }
      discontinuityReason=Reason.WHITESPACE;
      basicHasNewline=false;
    }
    basicStartOfWhitespace=-1;
  }
}",0.8222029488291414
29395,"/** 
 * Builds a lookup map that can be used for finding all callers of a particular template. All entries in the map (both keys and values) are HTML templates with strict auto escape mode.
 */
private Multimap<TemplateNode,TemplateNode> buildStrictHtmlCallers(TemplateRegistry registry){
  Multimap<TemplateNode,TemplateNode> strictHtmlCallers=LinkedHashMultimap.create();
  for (  TemplateNode template : registry.getAllTemplates()) {
    for (    CallNode callNode : SoyTreeUtils.getAllNodesOfType(template,CallNode.class)) {
      if (callNode instanceof CallBasicNode) {
        TemplateNode callee=registry.getBasicTemplate(((CallBasicNode)callNode).getCalleeName());
        if (isStrictAndKindHtml(callee)) {
          strictHtmlCallers.put(callee,template);
        }
      }
 else       if (callNode instanceof CallDelegateNode) {
        ImmutableList<TemplateDelegateNode> potentialCallees=registry.getDelTemplateSelector().delTemplateNameToValues().get(((CallDelegateNode)callNode).getDelCalleeName());
        for (        TemplateDelegateNode callee : potentialCallees) {
          if (isStrictAndKindHtml(callee)) {
            strictHtmlCallers.put(callee,template);
          }
        }
      }
    }
  }
  return strictHtmlCallers;
}","/** 
 * Builds a lookup map that can be used for finding all callers of a particular template. All entries in the map (both keys and values) are HTML templates with strict auto escape mode.
 */
private Multimap<TemplateNode,TemplateNode> buildStrictHtmlCallers(TemplateRegistry registry){
  Multimap<TemplateNode,TemplateNode> strictHtmlCallers=LinkedHashMultimap.create();
  for (  TemplateNode template : registry.getAllTemplates()) {
    if (!isStrictAndKindHtml(template)) {
      continue;
    }
    for (    CallNode callNode : SoyTreeUtils.getAllNodesOfType(template,CallNode.class)) {
      if (callNode instanceof CallBasicNode) {
        TemplateNode callee=registry.getBasicTemplate(((CallBasicNode)callNode).getCalleeName());
        if (isStrictAndKindHtml(callee)) {
          strictHtmlCallers.put(callee,template);
        }
      }
 else       if (callNode instanceof CallDelegateNode) {
        ImmutableList<TemplateDelegateNode> potentialCallees=registry.getDelTemplateSelector().delTemplateNameToValues().get(((CallDelegateNode)callNode).getDelCalleeName());
        for (        TemplateDelegateNode callee : potentialCallees) {
          if (isStrictAndKindHtml(callee)) {
            strictHtmlCallers.put(callee,template);
          }
        }
      }
    }
  }
  return strictHtmlCallers;
}",0.9750972762645914
29396,"@Override public Optional<Class<?>> load(Type key) throws Exception {
switch (key.getSort()) {
case Type.ARRAY:
    Optional<Class<?>> elementType=objectTypeToClassCache.getUnchecked(key.getElementType());
  if (elementType.isPresent()) {
    return Optional.<Class<?>>of(Array.newInstance(elementType.get(),0).getClass());
  }
return Optional.absent();
case Type.VOID:
return Optional.<Class<?>>of(void.class);
case Type.BOOLEAN:
return Optional.<Class<?>>of(boolean.class);
case Type.BYTE:
return Optional.<Class<?>>of(byte.class);
case Type.CHAR:
return Optional.<Class<?>>of(char.class);
case Type.DOUBLE:
return Optional.<Class<?>>of(double.class);
case Type.INT:
return Optional.<Class<?>>of(int.class);
case Type.SHORT:
return Optional.<Class<?>>of(short.class);
case Type.LONG:
return Optional.<Class<?>>of(long.class);
case Type.FLOAT:
return Optional.<Class<?>>of(float.class);
case Type.OBJECT:
try {
return Optional.<Class<?>>of(Class.forName(key.getClassName(),false,BytecodeUtils.class.getClassLoader()));
}
 catch (ClassNotFoundException e) {
return Optional.absent();
}
default :
throw new IllegalArgumentException(""String_Node_Str"" + key);
}
}","@Override public Optional<Class<?>> load(Type key) throws Exception {
switch (key.getSort()) {
case Type.ARRAY:
    Optional<Class<?>> elementType=objectTypeToClassCache.getUnchecked(key.getElementType());
  if (elementType.isPresent()) {
    return Optional.<Class<?>>of(Array.newInstance(elementType.get(),0).getClass());
  }
return Optional.absent();
case Type.VOID:
return Optional.<Class<?>>of(void.class);
case Type.BOOLEAN:
return Optional.<Class<?>>of(boolean.class);
case Type.BYTE:
return Optional.<Class<?>>of(byte.class);
case Type.CHAR:
return Optional.<Class<?>>of(char.class);
case Type.DOUBLE:
return Optional.<Class<?>>of(double.class);
case Type.INT:
return Optional.<Class<?>>of(int.class);
case Type.SHORT:
return Optional.<Class<?>>of(short.class);
case Type.LONG:
return Optional.<Class<?>>of(long.class);
case Type.FLOAT:
return Optional.<Class<?>>of(float.class);
case Type.OBJECT:
try {
String className=key.getClassName();
if (className.startsWith(Names.CLASS_PREFIX)) {
return Optional.absent();
}
return Optional.<Class<?>>of(Class.forName(className,false,BytecodeUtils.class.getClassLoader()));
}
 catch (ClassNotFoundException e) {
return Optional.absent();
}
default :
throw new IllegalArgumentException(""String_Node_Str"" + key);
}
}",0.9488448844884488
29397,"@Override protected final Optional<Expression> visitExprNode(ExprNode node){
  if (allowsBoxing()) {
    Optional<SoyExpression> compileWithNoDetaches=exprCompiler.compileWithNoDetaches(node);
    if (compileWithNoDetaches.isPresent()) {
      return Optional.<Expression>of(compileWithNoDetaches.get().box());
    }
  }
  return Optional.absent();
}","@Override protected final Optional<Expression> visitExprNode(ExprNode node){
  if (allowsBoxing()) {
    Optional<SoyExpression> compileWithNoDetaches=exprCompiler.compileWithNoDetaches(node);
    if (compileWithNoDetaches.isPresent()) {
      return Optional.of(compileWithNoDetaches.get().boxAsSoyValueProvider());
    }
  }
  return Optional.absent();
}",0.9575070821529744
29398,"/** 
 * Returns an expression that accesses this static field. 
 */
Expression accessor(){
  checkState(isStatic());
  Features features=Features.of(Feature.CHEAP);
  if (!isNullable()) {
    features=features.plus(Feature.NON_NULLABLE);
  }
  return new Expression(type(),features){
    @Override void doGen(    CodeBuilder mv){
      mv.getStatic(owner().type(),FieldRef.this.name(),resultType());
    }
  }
;
}","/** 
 * Returns an expression that accesses this static field. 
 */
Expression accessor(){
  checkState(isStatic());
  Features features=Features.of(Feature.CHEAP);
  if (!isNullable()) {
    features=features.plus(Feature.NON_NULLABLE);
  }
  return new Expression(type(),features){
    @Override void doGen(    CodeBuilder mv){
      accessStaticUnchecked(mv);
    }
  }
;
}",0.8973384030418251
29399,"private SoyExpression invokeSoyFunction(FunctionNode node,List<SoyExpression> args){
  Expression soyJavaFunctionExpr=MethodRef.RENDER_CONTEXT_GET_FUNCTION.invoke(parameterLookup.getRenderContext(),constant(node.getFunctionName()));
  Expression list=SoyExpression.asBoxedList(args);
  return SoyExpression.forSoyValue(UnknownType.getInstance(),MethodRef.RUNTIME_CALL_SOY_FUNCTION.invoke(soyJavaFunctionExpr,list));
}","private SoyExpression invokeSoyFunction(FunctionNode node,List<SoyExpression> args){
  Expression soyJavaFunctionExpr=MethodRef.RENDER_CONTEXT_GET_FUNCTION.invoke(parameterLookup.getRenderContext(),constant(node.getFunctionName()));
  Expression list=SoyExpression.asBoxedList(args);
  return SoyExpression.forSoyValue(node.getType(),MethodRef.RUNTIME_CALL_SOY_FUNCTION.invoke(soyJavaFunctionExpr,list).checkedCast(SoyRuntimeType.getBoxedType(node.getType()).runtimeType()));
}",0.883668903803132
29400,"@Override protected void visitHtmlAttributeValueNode(HtmlAttributeValueNode node){
  visitChildren(node);
  Quotes quotes=node.getQuotes();
  if (quotes == Quotes.NONE) {
    replacements.addAll(node.getChildren());
  }
 else {
    replacements.add(createPrefix(quotes.getQuotationCharacter(),node));
    replacements.addAll(node.getChildren());
    replacements.add(createSuffix(quotes.getQuotationCharacter(),node));
  }
}","@Override protected void visitHtmlAttributeValueNode(HtmlAttributeValueNode node){
  visitChildren(node);
  Quotes quotes=node.getQuotes();
  if (quotes == Quotes.NONE) {
    replacements.addAll(node.getChildren());
    needsSpaceSelfClosingTag=true;
  }
 else {
    replacements.add(createPrefix(quotes.getQuotationCharacter(),node));
    replacements.addAll(node.getChildren());
    replacements.add(createSuffix(quotes.getQuotationCharacter(),node));
    needsSpaceSelfClosingTag=false;
  }
}",0.9227421109902068
29401,"@Override protected void visitLetContentNode(LetContentNode node){
  boolean prev=needsSpaceForAttribute;
  needsSpaceForAttribute=false;
  visitChildren(node);
  needsSpaceForAttribute=prev;
}","@Override protected void visitLetContentNode(LetContentNode node){
  visitRenderUnitNode(node);
}",0.5862068965517241
29402,"@Override protected void visitCallParamContentNode(CallParamContentNode node){
  boolean oldInTag=needsSpaceForAttribute;
  needsSpaceForAttribute=false;
  visitChildren(node);
  needsSpaceForAttribute=oldInTag;
}","@Override protected void visitCallParamContentNode(CallParamContentNode node){
  visitRenderUnitNode(node);
}",0.6024844720496895
29403,"private void visitControlFlowBranches(List<? extends ParentSoyNode<?>> branches){
  boolean start=needsSpaceForAttribute;
  boolean end=needsSpaceForAttribute;
  for (  ParentSoyNode<?> branch : branches) {
    visitChildren(branch);
    end|=needsSpaceForAttribute;
    needsSpaceForAttribute=start;
  }
  needsSpaceForAttribute=end;
}","private void visitControlFlowBranches(List<? extends ParentSoyNode<?>> branches){
  boolean startNeedsSpaceForAttribute=needsSpaceForAttribute;
  boolean endNeedsSpaceForAttribute=needsSpaceForAttribute;
  boolean startNeedsSpaceForSelfClosingTag=needsSpaceSelfClosingTag;
  boolean endNeedsSpaceForSelfClosingTag=needsSpaceSelfClosingTag;
  for (  ParentSoyNode<?> branch : branches) {
    visitChildren(branch);
    endNeedsSpaceForAttribute|=needsSpaceForAttribute;
    needsSpaceForAttribute=startNeedsSpaceForAttribute;
    endNeedsSpaceForSelfClosingTag|=needsSpaceSelfClosingTag;
    needsSpaceSelfClosingTag=startNeedsSpaceForSelfClosingTag;
  }
  needsSpaceForAttribute=endNeedsSpaceForAttribute;
  needsSpaceSelfClosingTag=endNeedsSpaceForSelfClosingTag;
}",0.499092558983666
29404,"@Override protected void visitHtmlOpenTagNode(HtmlOpenTagNode node){
  needsSpaceForAttribute=true;
  visitChildren(node);
  needsSpaceForAttribute=false;
  replacements.add(createPrefix(""String_Node_Str"",node));
  replacements.addAll(node.getChildren());
  replacements.add(createSuffix(node.isSelfClosing() ? ""String_Node_Str"" : ""String_Node_Str"",node));
}","@Override protected void visitHtmlOpenTagNode(HtmlOpenTagNode node){
  visitHtmlTagNode(node);
}",0.3876651982378855
29405,"@Override protected void visitHtmlCloseTagNode(HtmlCloseTagNode node){
  needsSpaceForAttribute=true;
  visitChildren(node);
  needsSpaceForAttribute=false;
  replacements.add(createPrefix(""String_Node_Str"",node));
  replacements.addAll(node.getChildren());
  replacements.add(createSuffix(""String_Node_Str"",node));
}","@Override protected void visitHtmlCloseTagNode(HtmlCloseTagNode node){
  visitHtmlTagNode(node);
}",0.4337349397590361
29406,"@Test public void testNoOpRewrites() throws Exception {
  assertNoOp(""String_Node_Str"");
  assertNoOp(""String_Node_Str"");
  assertNoOp(""String_Node_Str"");
  assertNoOp(""String_Node_Str"");
}","@Test public void testNoOpRewrites() throws Exception {
  assertNoOp(""String_Node_Str"");
  assertNoOp(""String_Node_Str"");
  assertNoOp(""String_Node_Str"");
  assertNoOp(""String_Node_Str"");
  assertNoOp(""String_Node_Str"");
  assertNoOp(""String_Node_Str"");
  assertNoOp(""String_Node_Str"");
}",0.7924528301886793
29407,"@Override protected void visitHtmlAttributeValueNode(HtmlAttributeValueNode node){
  context=context.transitionToState(HtmlContext.HTML_BEFORE_ATTRIBUTE_VALUE);
  Context.AttributeEndDelimiter delim;
switch (node.getQuotes()) {
case DOUBLE:
    delim=Context.AttributeEndDelimiter.DOUBLE_QUOTE;
  break;
case NONE:
delim=Context.AttributeEndDelimiter.SPACE_OR_TAG_END;
break;
case SINGLE:
delim=Context.AttributeEndDelimiter.SINGLE_QUOTE;
break;
default :
throw new AssertionError();
}
context=context.transitionToAttrValue(delim);
visitChildren(node);
}","@Override protected void visitHtmlAttributeValueNode(HtmlAttributeValueNode node){
  context=context.transitionToState(HtmlContext.HTML_BEFORE_ATTRIBUTE_VALUE);
  Context.AttributeEndDelimiter delim;
switch (node.getQuotes()) {
case DOUBLE:
    delim=Context.AttributeEndDelimiter.DOUBLE_QUOTE;
  break;
case NONE:
delim=Context.AttributeEndDelimiter.SPACE_OR_TAG_END;
break;
case SINGLE:
delim=Context.AttributeEndDelimiter.SINGLE_QUOTE;
break;
default :
throw new AssertionError();
}
context=context.transitionToAttrValue(delim);
visitChildren(node);
context=context.transitionToTagBody();
}",0.9659982563208368
29408,"private void assertContextualRewriting(String expectedOutput,String... inputs) throws SoyAutoescapeException {
  String source=rewrite(inputs).toSourceString();
  source=source.replace(nonce(),""String_Node_Str"");
  assertThat(source.trim()).isEqualTo(expectedOutput);
}","private void assertContextualRewriting(String expectedOutput,String... inputs){
  String source=rewrite(inputs).toSourceString();
  source=source.replace(nonce(),""String_Node_Str"");
  assertThat(source.trim()).isEqualTo(expectedOutput);
}",0.9388560157790928
29409,"/** 
 * Handles step 6 by converting a list of InjectedSoyGenerators into an equivalent list where there is only one per text node and offset, and where the list is sorted by text node ID and offset.
 */
private static ImmutableListMultimap<RawTextNode,InjectedSoyGenerator> sortAndGroup(List<InjectedSoyGenerator> ungrouped){
  ListMultimap<RawTextNode,InjectedSoyGenerator> byNode=MultimapBuilder.hashKeys().arrayListValues().build();
  for (  InjectedSoyGenerator generator : ungrouped) {
    byNode.put(generator.rawTextNode,generator);
  }
  ImmutableListMultimap.Builder<RawTextNode,InjectedSoyGenerator> groupedAndSorted=ImmutableListMultimap.builder();
  for (  RawTextNode node : byNode.keySet()) {
    List<InjectedSoyGenerator> group=BY_OFFSET.sortedCopy(byNode.get(node));
    for (int i=0, end; i < group.size(); i++) {
      InjectedSoyGenerator firstGroupMember=group.get(i);
      end=i + 1;
      while (end < group.size() && group.get(end).offset == firstGroupMember.offset) {
        ++end;
      }
      InjectedSoyGenerator groupGenerator=end == i + 1 ? firstGroupMember : new GroupOfInjectedSoyGenerator(group.subList(i,end));
      groupedAndSorted.put(node,groupGenerator);
    }
  }
  return groupedAndSorted.build();
}","/** 
 * Handles step 6 by converting a list of InjectedSoyGenerators into an equivalent list where there is only one per text node and offset, and where the list is sorted by text node ID and offset.
 */
private static ImmutableListMultimap<RawTextNode,InjectedSoyGenerator> sortAndGroup(List<InjectedSoyGenerator> ungrouped){
  ListMultimap<RawTextNode,InjectedSoyGenerator> byNode=MultimapBuilder.hashKeys().arrayListValues().build();
  for (  InjectedSoyGenerator generator : ungrouped) {
    byNode.put(generator.rawTextNode,generator);
  }
  ImmutableListMultimap.Builder<RawTextNode,InjectedSoyGenerator> groupedAndSorted=ImmutableListMultimap.builder();
  for (  RawTextNode node : byNode.keySet()) {
    List<InjectedSoyGenerator> group=BY_OFFSET.sortedCopy(byNode.get(node));
    for (int i=0; i < group.size(); ) {
      InjectedSoyGenerator firstGroupMember=group.get(i);
      int start=i;
      ++i;
      while (i < group.size() && group.get(i).offset == firstGroupMember.offset) {
        ++i;
      }
      InjectedSoyGenerator groupGenerator=i == start + 1 ? firstGroupMember : new GroupOfInjectedSoyGenerator(group.subList(start,i));
      groupedAndSorted.put(node,groupGenerator);
    }
  }
  return groupedAndSorted.build();
}",0.918506623845845
29410,"/** 
 * Handles steps 3-5 by creating a NonceAttrGenerator for each location at the ^ in   {@code <scriptfoo=bar^>} immediately after the run of attributes in a script tag.
 */
private static void findNonceAttrLocations(Iterable<? extends SlicedRawTextNode> slicedRawTextNodes,ImmutableList.Builder<InjectedSoyGenerator> out){
  for (  SlicedRawTextNode.RawTextSlice slice : SlicedRawTextNode.find(slicedRawTextNodes,null,IN_SCRIPT_OR_STYLE_TAG_PREDICATE,IN_SCRIPT_OR_STYLE_BODY_PREDICATE)) {
    String rawText=slice.getRawText();
    int rawTextLen=rawText.length();
    if (rawText.charAt(rawTextLen - 1) != '>') {
      throw new IllegalStateException(""String_Node_Str"" + rawText);
    }
    int insertionPoint=rawTextLen - 1;
    if (insertionPoint - 1 >= 0 && rawText.charAt(insertionPoint - 1) == '/') {
      --insertionPoint;
    }
    out.add(new NonceAttrGenerator(slice.slicedRawTextNode.getRawTextNode(),slice.getStartOffset() + insertionPoint));
  }
}","/** 
 * Handles steps 3-5 by creating a NonceAttrGenerator for each location at the ^ in   {@code <scriptfoo=bar^>} immediately after the run of attributes in a script tag.
 */
private static void findNonceAttrLocations(Iterable<? extends SlicedRawTextNode> slicedRawTextNodes,ImmutableList.Builder<InjectedSoyGenerator> out){
  List<RawTextSlice> transitions=SlicedRawTextNode.find(slicedRawTextNodes,null,IN_SCRIPT_OR_STYLE_TAG_PREDICATE,IN_SCRIPT_OR_STYLE_BODY_PREDICATE);
  for (  SlicedRawTextNode.RawTextSlice slice : transitions) {
    String rawText=slice.getRawText();
    int rawTextLen=rawText.length();
    if (rawText.charAt(rawTextLen - 1) != '>') {
      throw new IllegalStateException(""String_Node_Str"" + rawText);
    }
    int insertionPoint=rawTextLen - 1;
    if (insertionPoint - 1 >= 0 && rawText.charAt(insertionPoint - 1) == '/') {
      --insertionPoint;
    }
    out.add(new NonceAttrGenerator(slice.getRawTextNode(),slice.getStartOffset() + insertionPoint));
  }
}",0.9203268641470888
29411,"/** 
 * The start offset (inclusive) into the text node's text. 
 */
public int getStartOffset(){
  return startOffset;
}","/** 
 * The start offset (inclusive) into the text node's text. 
 */
abstract int getStartOffset();",0.8454545454545455
29412,"/** 
 * The raw text of the slice. 
 */
public String getRawText(){
  return slicedRawTextNode.rawTextNode.getRawText().substring(startOffset,endOffset);
}","/** 
 * The raw text of the slice. 
 */
public String getRawText(){
  return getRawTextNode().getRawText().substring(getStartOffset(),getEndOffset());
}",0.8925081433224755
29413,"/** 
 * The slices that occur in the context described by the given predicates. <p>The order is deterministic but does not necessarily bear any relationship to the order in which slices can appear in the template's output because it is dependent on the ordering of individual templates in the parsed input.
 * @param slicedRawTextNodes The sliced raw text nodes to search.
 * @param prevContextPredicate Applied to the context before the slice being tested.
 * @param sliceContextPredicate Applied to the context of the slice being tested.
 * @param nextContextPredicate Applied to the context after the slice being tested.
 * @return a list of slices such that input predicates are all true when applied to the contextsat and around that slice.
 */
public static List<RawTextSlice> find(Iterable<? extends SlicedRawTextNode> slicedTextNodes,@Nullable Predicate<? super Context> prevContextPredicate,@Nullable Predicate<? super Context> sliceContextPredicate,@Nullable Predicate<? super Context> nextContextPredicate){
  if (prevContextPredicate == null) {
    prevContextPredicate=Predicates.<Context>alwaysTrue();
  }
  if (sliceContextPredicate == null) {
    sliceContextPredicate=Predicates.<Context>alwaysTrue();
  }
  if (nextContextPredicate == null) {
    nextContextPredicate=Predicates.<Context>alwaysTrue();
  }
  ImmutableList.Builder<RawTextSlice> matches=ImmutableList.builder();
  for (  SlicedRawTextNode slicedTextNode : slicedTextNodes) {
    slicedTextNode.mergeAdjacentSlicesWithSameContext();
    Context prevContext=slicedTextNode.startContext;
    List<RawTextSlice> slices=slicedTextNode.slices;
    for (int i=0, n=slices.size(); i < n; ++i) {
      RawTextSlice current=slices.get(i);
      Context nextContext;
      if (i + 1 < n) {
        nextContext=slices.get(i + 1).context;
      }
 else {
        nextContext=slicedTextNode.endContext;
      }
      if (prevContextPredicate.apply(prevContext) && sliceContextPredicate.apply(current.context) && nextContextPredicate.apply(nextContext)) {
        matches.add(current);
      }
      prevContext=current.context;
    }
  }
  return matches.build();
}","/** 
 * The slices that occur in the context described by the given predicates. <p>The order is deterministic but does not necessarily bear any relationship to the order in which slices can appear in the template's output because it is dependent on the ordering of individual templates in the parsed input.
 * @param slicedTextNodes The sliced raw text nodes to search.
 * @param prevContextPredicate Applied to the context before the slice being tested.
 * @param sliceContextPredicate Applied to the context of the slice being tested.
 * @param nextContextPredicate Applied to the context after the slice being tested.
 * @return a list of slices such that input predicates are all true when applied to the contextsat and around that slice.
 */
public static List<RawTextSlice> find(Iterable<? extends SlicedRawTextNode> slicedTextNodes,@Nullable Predicate<? super Context> prevContextPredicate,@Nullable Predicate<? super Context> sliceContextPredicate,@Nullable Predicate<? super Context> nextContextPredicate){
  if (prevContextPredicate == null) {
    prevContextPredicate=Predicates.<Context>alwaysTrue();
  }
  if (sliceContextPredicate == null) {
    sliceContextPredicate=Predicates.<Context>alwaysTrue();
  }
  if (nextContextPredicate == null) {
    nextContextPredicate=Predicates.<Context>alwaysTrue();
  }
  ImmutableSet.Builder<RawTextSlice> matches=ImmutableSet.builder();
  for (  SlicedRawTextNode slicedTextNode : slicedTextNodes) {
    Context prevContext=slicedTextNode.startContext;
    List<RawTextSlice> slices=slicedTextNode.slices;
    for (int i=0, n=slices.size(); i < n; ++i) {
      RawTextSlice current=slices.get(i);
      Context nextContext;
      if (i + 1 < n) {
        nextContext=slices.get(i + 1).getContext();
      }
 else {
        nextContext=slicedTextNode.endContext;
      }
      if (prevContextPredicate.apply(prevContext) && sliceContextPredicate.apply(current.getContext()) && nextContextPredicate.apply(nextContext)) {
        matches.add(current);
      }
      prevContext=current.getContext();
    }
  }
  return matches.build().asList();
}",0.9678486997635932
29414,"/** 
 * The length of the slice in   {@code char}s. 
 */
public int getLength(){
  return endOffset - startOffset;
}","/** 
 * The length of the slice in   {@code char}s. 
 */
public int getLength(){
  return getEndOffset() - getStartOffset();
}",0.950413223140496
29415,"/** 
 * For debugging. 
 */
@Override public String toString(){
  String rawText=getRawText();
  int id=slicedRawTextNode.rawTextNode.getId();
  return ""String_Node_Str"" + rawText.replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str""+ id;
}","/** 
 * For debugging. 
 */
@Override public String toString(){
  String rawText=getRawText();
  int id=getRawTextNode().getId();
  return ""String_Node_Str"" + rawText.replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str""+ id;
}",0.4404040404040404
29416,"/** 
 * Called by the builder to add slices as their context becomes known.
 * @param startOffset an offset (inclusive) into the rawTextNode's string content.
 * @param endOffset an offset (exclusive) into the rawTextNode's string content.
 * @param context the context for the slice.
 */
void addSlice(int startOffset,int endOffset,Context context){
  int lastSliceIndex=slices.size() - 1;
  if (lastSliceIndex >= 0) {
    RawTextSlice last=slices.get(lastSliceIndex);
    if (last.endOffset == startOffset && context.equals(last.context)) {
      slices.remove(lastSliceIndex);
      startOffset=last.startOffset;
    }
  }
  slices.add(new RawTextSlice(context,this,startOffset,endOffset));
}","/** 
 * Called by the builder to add slices as their context becomes known.
 * @param startOffset an offset (inclusive) into the rawTextNode's string content.
 * @param endOffset an offset (exclusive) into the rawTextNode's string content.
 * @param context the context for the slice.
 */
void addSlice(int startOffset,int endOffset,Context context){
  int lastSliceIndex=slices.size() - 1;
  if (lastSliceIndex >= 0) {
    RawTextSlice last=slices.get(lastSliceIndex);
    if (last.getEndOffset() == startOffset && context.equals(last.getContext())) {
      slices.remove(lastSliceIndex);
      startOffset=last.getStartOffset();
    }
  }
  slices.add(RawTextSlice.create(context,rawTextNode,startOffset,endOffset));
}",0.9328621908127208
29417,"/** 
 * Scans until the next whitespace, > or />, validates that the matched text is an html identifier and returns it.
 */
@Nullable RawTextNode consumeHtmlIdentifier(){
  boolean foundDelimiter=advanceWhileMatches(TAG_IDENTIFIER_MATCHER);
  RawTextNode node=consumeAsRawText();
  if (node != null) {
    if (foundDelimiter && INVALID_IDENTIFIER_CHAR_MATCHER.matches((char)currentChar())) {
      errorReporter.report(currentLocation(),INVALID_IDENTIFIER,(char)currentChar());
      advance();
      consume();
    }
  }
 else {
    errorReporter.report(currentLocation(),GENERIC_UNEXPECTED_CHAR,""String_Node_Str"");
    advance();
    consume();
  }
  return node;
}","/** 
 * Scans until the next whitespace, > or />, validates that the matched text is an html identifier and returns it. <p>Requires that we are not at the end of input
 */
@Nullable RawTextNode consumeHtmlIdentifier(SoyErrorKind errorForMissingIdentifier){
  boolean foundDelimiter=advanceWhileMatches(TAG_DELIMITER_MATCHER);
  RawTextNode node=consumeAsRawText();
  if (node != null) {
    int indexIn=INVALID_IDENTIFIER_CHAR_MATCHER.indexIn(node.getRawText());
    if (indexIn != -1) {
      errorReporter.report(node.substringLocation(indexIn,indexIn + 1),INVALID_IDENTIFIER,node.getRawText().charAt(indexIn));
    }
  }
 else   if (foundDelimiter) {
    errorReporter.report(currentLocation(),errorForMissingIdentifier);
    advance();
    consume();
  }
 else {
    throw new AssertionError(""String_Node_Str"");
  }
  return node;
}",0.6280771789753826
29418,"/** 
 * Handle the state where we are right before an attribute. <p>This state is kind of confusing, it just means we are in the middle of a tag and are definitely after some whitespace.
 */
void handleBeforeAttributeName(){
  if (tryCreateTagEnd()) {
    return;
  }
  if (consumeWhitespace()) {
    return;
  }
  RawTextNode identifier=consumeHtmlIdentifier();
  if (identifier == null) {
    context.resetAttribute();
    return;
  }
  context.startAttribute(identifier);
}","/** 
 * Handle the state where we are right before an attribute. <p>This state is kind of confusing, it just means we are in the middle of a tag and are definitely after some whitespace.
 */
void handleBeforeAttributeName(){
  if (tryCreateTagEnd()) {
    return;
  }
  if (consumeWhitespace()) {
    return;
  }
  RawTextNode identifier=consumeHtmlIdentifier(EXPECTED_ATTRIBUTE_NAME);
  if (identifier == null) {
    context.resetAttribute();
    return;
  }
  context.startAttribute(identifier);
}",0.9764102564102564
29419,"/** 
 * Handle parsing an html tag name. <p>Look for an html identifier and transition to AFTER_ATTRIBUTE_OR_TAG_NAME.
 */
void handleHtmlTagName(){
  if (consumeWhitespace()) {
    errorReporter.report(context.tagStartLocation(),UNEXPECTED_WS_AFTER_LT);
    context.reset();
    context.setState(State.PCDATA,currentPointOrEnd());
    return;
  }
  RawTextNode node=consumeHtmlIdentifier();
  if (node == null) {
    errorReporter.report(currentLocation(),GENERIC_UNEXPECTED_CHAR,""String_Node_Str"");
    context.setTagName(new TagName(new RawTextNode(nodeIdGen.genId(),""String_Node_Str"",currentLocation())));
  }
 else {
    context.setTagName(new TagName(node));
  }
}","/** 
 * Handle parsing an html tag name. <p>Look for an html identifier and transition to AFTER_ATTRIBUTE_OR_TAG_NAME.
 */
void handleHtmlTagName(){
  if (consumeWhitespace()) {
    errorReporter.report(context.tagStartLocation(),UNEXPECTED_WS_AFTER_LT);
    context.reset();
    context.setState(State.PCDATA,currentPointOrEnd());
    return;
  }
  RawTextNode node=consumeHtmlIdentifier(EXPECTED_TAG_NAME);
  if (node == null) {
    context.setTagName(new TagName(new RawTextNode(nodeIdGen.genId(),""String_Node_Str"",currentLocation())));
  }
 else {
    context.setTagName(new TagName(node));
  }
}",0.7669291338582677
29420,"@Override protected void visitMsgFallbackGroupNode(MsgFallbackGroupNode node){
  processPrintableNode(node);
}","@Override protected void visitMsgFallbackGroupNode(MsgFallbackGroupNode node){
  processPrintableNode(node);
  State oldState=context.setState(State.NONE,node.getSourceLocation().getBeginPoint());
  visitChildren(node);
  context.setState(oldState,node.getSourceLocation().getEndPoint());
}",0.55
29421,"/** 
 * Checks if all branches contain the given   {@TagName} at the head of their open stacks. 
 */
boolean hasCommonPrefix(TagName tag){
  if (!hasDefaultCond()) {
    return false;
  }
  for (  ConditionalBranch branch : branches) {
    if (branch.deque().isEmpty()) {
      return false;
    }
    HtmlTagEntry entry=branch.deque().peek();
    while (entry != null && entry.hasTagName() && !entry.getTagName().equals(tag) && entry.isDefinitelyOptional()) {
      branch.deque().poll();
      entry=branch.deque().peek();
    }
    if (entry.hasTagName()) {
      if (!entry.getTagName().equals(tag)) {
        return false;
      }
    }
 else {
      if (!entry.getBranches().hasCommonPrefix(tag)) {
        return false;
      }
    }
  }
  return true;
}","/** 
 * Checks if all branches contain the given   {@TagName} at the head of their open stacks. 
 */
boolean hasCommonPrefix(TagName tag){
  if (!hasDefaultCond()) {
    return false;
  }
  for (  ConditionalBranch branch : branches) {
    if (branch.deque().isEmpty()) {
      return false;
    }
    HtmlTagEntry entry=branch.deque().peek();
    while (entry.hasTagName() && !entry.getTagName().equals(tag) && entry.isDefinitelyOptional()) {
      branch.deque().poll();
      entry=branch.deque().peek();
      if (entry == null) {
        return false;
      }
    }
    if (entry.hasTagName()) {
      if (!entry.getTagName().equals(tag)) {
        return false;
      }
    }
 else {
      if (!entry.getBranches().hasCommonPrefix(tag)) {
        return false;
      }
    }
  }
  return true;
}",0.9078104993597952
29422,"/** 
 * A method that should be called after we visit a control flow node (  {@code IfNode} or {@code SwitchNode}). <p>Compared to   {@code matchOrError} methods, this method does not report an error when one ofthe deques is empty. However, if both deques are not empty but the top do not match, we should report an error. <p>Another difference is that we don't try to remove all optional tags from the openStack, if the closeQueue is empty. It is possible that some of the optional tags are ended in another control block, and we cannot remove them too eagerly. <p>After calling this method, <ul> <li>if it returns true, at least one of the stack/queue will be empty. <li>if it returns false, we have already reported an error. </ul>
 */
static boolean tryMatchOrError(ArrayDeque<HtmlTagEntry> openStack,ArrayDeque<HtmlTagEntry> closeQueue,ErrorReporter errorReporter){
  while (!openStack.isEmpty() && !closeQueue.isEmpty()) {
    HtmlTagEntry openTag=openStack.peekFirst();
    HtmlTagEntry closeTag=closeQueue.peekFirst();
    if (closeTag.isDefinitelyOptional()) {
      if (closeTag.getTagName().equals(openTag.getTagName())) {
        openStack.pollFirst();
        closeQueue.pollFirst();
        continue;
      }
      if (!openTag.hasTagName()) {
        if (tryMatchCommonPrefix(openTag,closeTag,errorReporter)) {
          openStack.pollFirst();
          closeQueue.pollFirst();
          continue;
        }
        errorReporter.report(closeTag.getSourceLocation(),UNEXPECTED_CLOSE_TAG);
        return false;
      }
    }
    if (closeTag.hasTagName()) {
      openTag=popOptionalTags(openStack);
    }
    if (matchOrError(openTag,closeTag,errorReporter)) {
      openStack.pollFirst();
      closeQueue.pollFirst();
    }
 else {
      return false;
    }
  }
  return true;
}","/** 
 * A method that should be called after we visit a control flow node (  {@code IfNode} or {@code SwitchNode}). <p>Compared to   {@code matchOrError} methods, this method does not report an error when one ofthe deques is empty. However, if both deques are not empty but the top do not match, we should report an error. <p>Another difference is that we don't try to remove all optional tags from the openStack, if the closeQueue is empty. It is possible that some of the optional tags are ended in another control block, and we cannot remove them too eagerly. <p>After calling this method, <ul> <li>if it returns true, at least one of the stack/queue will be empty. <li>if it returns false, we have already reported an error. </ul>
 */
static boolean tryMatchOrError(ArrayDeque<HtmlTagEntry> openStack,ArrayDeque<HtmlTagEntry> closeQueue,ErrorReporter errorReporter){
  while (!openStack.isEmpty() && !closeQueue.isEmpty()) {
    HtmlTagEntry openTag=openStack.peekFirst();
    HtmlTagEntry closeTag=closeQueue.peekFirst();
    if (closeTag.hasTagName()) {
      if (closeTag.getTagName().equals(openTag.getTagName())) {
        openStack.pollFirst();
        closeQueue.pollFirst();
        continue;
      }
 else {
        if (openTag.isDefinitelyOptional()) {
          openStack.pollFirst();
          continue;
        }
 else         if (!openTag.hasTagName()) {
          openTag.getBranches().popOptionalTags();
          if (openTag.getBranches().isEmpty()) {
            openStack.pollFirst();
            continue;
          }
          if (tryMatchCommonPrefix(openTag,closeTag,errorReporter)) {
            openStack.pollFirst();
            closeQueue.pollFirst();
            continue;
          }
          return false;
        }
      }
      openTag=popOptionalTags(openStack);
    }
    if (matchOrError(openTag,closeTag,errorReporter)) {
      openStack.pollFirst();
      closeQueue.pollFirst();
    }
 else {
      return false;
    }
  }
  return true;
}",0.7194282689253574
29423,"/** 
 * Consume a portion of text and compute the next context. Output is stored in member variables.
 * @param text Non empty.
 */
private void processNextToken(String text,Context context) throws SoyAutoescapeException {
  int earliestStart=Integer.MAX_VALUE;
  int earliestEnd=-1;
  Transition earliestTransition=null;
  Matcher earliestMatcher=null;
  for (  Transition transition : TRANSITIONS.get(context.state)) {
    Matcher matcher=transition.pattern.matcher(text);
    try {
      if (matcher.find()) {
        int start=matcher.start();
        if (start < earliestStart) {
          int end=matcher.end();
          if (transition.isApplicableTo(context,matcher)) {
            earliestStart=start;
            earliestEnd=end;
            earliestTransition=transition;
            earliestMatcher=matcher;
          }
        }
      }
    }
 catch (    StackOverflowError soe) {
      throw new RuntimeException(""String_Node_Str"" + transition.pattern,soe);
    }
  }
  if (earliestTransition != null) {
    this.next=earliestTransition.computeNextContext(context,earliestMatcher);
    this.numCharsConsumed=earliestEnd;
  }
 else {
    throw SoyAutoescapeException.createWithoutMetaInfo(""String_Node_Str"" + text + ""String_Node_Str""+ context);
  }
  if (numCharsConsumed == 0 && this.next.state == context.state) {
    throw new IllegalStateException(""String_Node_Str"" + text + ""String_Node_Str""+ context);
  }
}","/** 
 * Consume a portion of text and compute the next context. Output is stored in member variables.
 * @param text Non empty.
 */
private void processNextToken(String text,Context context) throws SoyAutoescapeException {
  int earliestStart=Integer.MAX_VALUE;
  int earliestEnd=-1;
  Transition earliestTransition=null;
  Matcher earliestMatcher=null;
  for (  Transition transition : TRANSITIONS.get(context.state)) {
    Matcher matcher=transition.pattern.matcher(text);
    try {
      while (matcher.find() && matcher.start() < earliestStart) {
        int start=matcher.start();
        int end=matcher.end();
        if (transition.isApplicableTo(context,matcher)) {
          earliestStart=start;
          earliestEnd=end;
          earliestTransition=transition;
          earliestMatcher=matcher;
          break;
        }
      }
    }
 catch (    StackOverflowError soe) {
      throw new RuntimeException(""String_Node_Str"" + transition.pattern,soe);
    }
  }
  if (earliestTransition != null) {
    this.next=earliestTransition.computeNextContext(context,earliestMatcher);
    this.numCharsConsumed=earliestEnd;
  }
 else {
    throw SoyAutoescapeException.createWithoutMetaInfo(""String_Node_Str"" + text + ""String_Node_Str""+ context);
  }
  if (numCharsConsumed == 0 && this.next.state == context.state) {
    throw new IllegalStateException(""String_Node_Str"" + text + ""String_Node_Str""+ context);
  }
}",0.7744202389318342
29424,"@Test public void testFakeScripts(){
  assertInjected(join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + NONCE + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","@Test public void testFakeScripts(){
  assertInjected(join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + NONCE + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + NONCE + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9649122807017544
29425,"@Test public void testFakeScripts() throws Exception {
  assertInjected(join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","@Test public void testFakeScripts() throws Exception {
  assertInjected(join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9765625
29426,"/** 
 * Checks if all branches contain the given   {@TagName} at the head of their open stacks. 
 */
boolean hasCommonPrefix(TagName tag){
  if (!hasDefaultCond()) {
    return false;
  }
  for (  ConditionalBranch branch : branches) {
    if (branch.deque().isEmpty()) {
      return false;
    }
    HtmlTagEntry entry=branch.deque().peek();
    if (entry.hasTagName()) {
      if (!entry.getTagName().equals(tag)) {
        return false;
      }
    }
 else {
      if (!entry.getBranches().hasCommonPrefix(tag)) {
        return false;
      }
    }
  }
  return true;
}","/** 
 * Checks if all branches contain the given   {@TagName} at the head of their open stacks. 
 */
boolean hasCommonPrefix(TagName tag){
  if (!hasDefaultCond()) {
    return false;
  }
  for (  ConditionalBranch branch : branches) {
    if (branch.deque().isEmpty()) {
      return false;
    }
    HtmlTagEntry entry=branch.deque().peek();
    while (entry != null && entry.hasTagName() && !entry.getTagName().equals(tag) && entry.isDefinitelyOptional()) {
      branch.deque().poll();
      entry=branch.deque().peek();
    }
    if (entry.hasTagName()) {
      if (!entry.getTagName().equals(tag)) {
        return false;
      }
    }
 else {
      if (!entry.getBranches().hasCommonPrefix(tag)) {
        return false;
      }
    }
  }
  return true;
}",0.7775280898876404
29427,"/** 
 * A method that should be called after we visit a control flow node (  {@code IfNode} or {@code SwitchNode}). <p>Compared to   {@code matchOrError} methods, this method does not report an error when one ofthe deques is empty. However, if both deques are not empty but the top do not match, we should report an error. <p>Another difference is that we don't try to remove all optional tags from the openStack, if the closeQueue is empty. It is possible that some of the optional tags are ended in another control block, and we cannot remove them too eagerly.
 */
public static boolean tryMatchOrError(ArrayDeque<HtmlTagEntry> openStack,ArrayDeque<HtmlTagEntry> closeQueue,ErrorReporter errorReporter){
  while (!openStack.isEmpty() && !closeQueue.isEmpty()) {
    HtmlTagEntry openTag=openStack.peekFirst();
    HtmlTagEntry closeTag=closeQueue.peekFirst();
    if (closeTag.isDefinitelyOptional()) {
      if (closeTag.getTagName().equals(openTag.getTagName())) {
        openStack.pollFirst();
        closeQueue.pollFirst();
        continue;
      }
      if (!openTag.hasTagName()) {
        if (tryMatchCommonPrefix(openTag,closeTag,errorReporter)) {
          openStack.pollFirst();
          closeQueue.pollFirst();
          return true;
        }
        return false;
      }
    }
    if (closeTag.hasTagName()) {
      while (!openStack.isEmpty()) {
        openTag=openStack.peekFirst();
        if (openTag.isDefinitelyOptional()) {
          openStack.pollFirst();
          continue;
        }
 else         if (!openTag.hasTagName()) {
          openTag.getBranches().popOptionalTags();
          if (openTag.getBranches().isEmpty()) {
            openStack.pollFirst();
            continue;
          }
        }
        break;
      }
    }
    if (matchOrError(openTag,closeTag,errorReporter)) {
      openStack.pollFirst();
      closeQueue.pollFirst();
    }
 else {
      return false;
    }
  }
  return true;
}","/** 
 * A method that should be called after we visit a control flow node (  {@code IfNode} or {@code SwitchNode}). <p>Compared to   {@code matchOrError} methods, this method does not report an error when one ofthe deques is empty. However, if both deques are not empty but the top do not match, we should report an error. <p>Another difference is that we don't try to remove all optional tags from the openStack, if the closeQueue is empty. It is possible that some of the optional tags are ended in another control block, and we cannot remove them too eagerly.
 */
static boolean tryMatchOrError(ArrayDeque<HtmlTagEntry> openStack,ArrayDeque<HtmlTagEntry> closeQueue,ErrorReporter errorReporter){
  while (!openStack.isEmpty() && !closeQueue.isEmpty()) {
    HtmlTagEntry openTag=openStack.peekFirst();
    HtmlTagEntry closeTag=closeQueue.peekFirst();
    if (closeTag.isDefinitelyOptional()) {
      if (closeTag.getTagName().equals(openTag.getTagName())) {
        openStack.pollFirst();
        closeQueue.pollFirst();
        continue;
      }
      if (!openTag.hasTagName()) {
        if (tryMatchCommonPrefix(openTag,closeTag,errorReporter)) {
          openStack.pollFirst();
          closeQueue.pollFirst();
          return true;
        }
        return false;
      }
    }
    if (closeTag.hasTagName()) {
      while (!openStack.isEmpty()) {
        openTag=openStack.peekFirst();
        if (openTag.isDefinitelyOptional()) {
          openStack.pollFirst();
          continue;
        }
 else         if (!openTag.hasTagName()) {
          openTag.getBranches().popOptionalTags();
          if (openTag.getBranches().isEmpty()) {
            openStack.pollFirst();
            continue;
          }
        }
        break;
      }
    }
    if (matchOrError(openTag,closeTag,errorReporter)) {
      openStack.pollFirst();
      closeQueue.pollFirst();
    }
 else {
      return false;
    }
  }
  return true;
}",0.9981935483870968
29428,"/** 
 * Tries to find common prefix and report errors accordingly. 
 */
private static boolean tryMatchCommonPrefix(HtmlTagEntry openTag,HtmlTagEntry closeTag,ErrorReporter errorReporter){
  Preconditions.checkArgument(openTag.hasTagName() != closeTag.hasTagName());
  boolean matchCommonPrefix=false;
  if (openTag.hasTagName()) {
    TagName openTagName=openTag.getTagName();
    if (closeTag.getBranches().hasCommonPrefix(openTagName)) {
      closeTag.getBranches().popAllBranches();
      matchCommonPrefix=true;
      if (!closeTag.getBranches().isEmpty()) {
        matchCommonPrefix=false;
        errorReporter.report(closeTag.getSourceLocation(),UNEXPECTED_CLOSE_TAG_WITH_EXPECTATION,openTagName.getStaticTagNameAsLowerCase().get());
      }
    }
 else {
      errorReporter.report(openTagName.getTagLocation(),OPEN_TAG_NOT_CLOSED);
    }
  }
 else {
    TagName closeTagName=closeTag.getTagName();
    if (openTag.getBranches().hasCommonPrefix(closeTagName)) {
      openTag.getBranches().popAllBranches();
      matchCommonPrefix=true;
      if (!openTag.getBranches().isEmpty()) {
        matchCommonPrefix=false;
        errorReporter.report(openTag.getSourceLocation(),OPEN_TAG_NOT_CLOSED);
      }
    }
 else {
      errorReporter.report(closeTagName.getTagLocation(),UNEXPECTED_CLOSE_TAG);
    }
  }
  return matchCommonPrefix;
}","/** 
 * Tries to find common prefix and report errors accordingly. 
 */
private static boolean tryMatchCommonPrefix(HtmlTagEntry openTag,HtmlTagEntry closeTag,ErrorReporter errorReporter){
  Preconditions.checkArgument(openTag.hasTagName() != closeTag.hasTagName());
  return openTag.hasTagName() ? tryMatchCommonPrefix(openTag.getTagName(),closeTag,errorReporter) : tryMatchCommonPrefix(openTag,closeTag.getTagName(),errorReporter);
}",0.3241727425687044
29429,"@Override protected void visitHtmlCloseTagNode(HtmlCloseTagNode node){
  TagName closeTag=node.getTagName();
  if (isDefinitelyVoid(node)) {
    errorReporter.report(node.getSourceLocation(),INVALID_CLOSE_TAG,closeTag.getStaticTagName().getRawText());
    return;
  }
  if (closeTag.isForeignContent()) {
    foreignContentEndLocation=node.getSourceLocation();
    inForeignContent=false;
  }
  HtmlTagEntry openTag=openTagStack.peekFirst();
  while (openTag != null && openTag.hasTagName() && !openTag.getTagName().equals(closeTag) && openTag.isDefinitelyOptional()) {
    openTagStack.pollFirst();
    openTag=openTagStack.peekFirst();
  }
  if (openTag != null && openTag.hasTagName()) {
    if (HtmlTagEntry.matchOrError(openTag.getTagName(),closeTag,errorReporter)) {
      openTagStack.pollFirst();
    }
  }
 else {
    closeTagQueue.addLast(new HtmlTagEntry(closeTag));
  }
}","@Override protected void visitHtmlCloseTagNode(HtmlCloseTagNode node){
  TagName closeTag=node.getTagName();
  if (isDefinitelyVoid(node)) {
    errorReporter.report(node.getSourceLocation(),INVALID_CLOSE_TAG,closeTag.getStaticTagName().getRawText());
    return;
  }
  if (closeTag.isForeignContent()) {
    foreignContentEndLocation=node.getSourceLocation();
    inForeignContent=false;
  }
  if (!HtmlTagEntry.tryMatchCloseTag(openTagStack,closeTag,errorReporter)) {
    closeTagQueue.addLast(new HtmlTagEntry(closeTag));
  }
}",0.6765746638358103
29430,"/** 
 * Remove a common   {@code TagName} from all branches. Note that we assume that each branchcontains the  {@code TagName}. You will need to explicitly call   {@code hasCommonPrefix} beforecalling this method.
 */
void popAllBranches(){
  for (  ConditionalBranch branch : branches) {
    HtmlTagEntry entry=branch.deque().peek();
    if (entry.hasTagName()) {
      branch.deque().pop();
    }
 else {
      entry.getBranches().popAllBranches();
    }
  }
}","/** 
 * Remove a common   {@code TagName} from all branches. Note that we assume that each branchcontains the  {@code TagName}. You will need to explicitly call   {@code hasCommonPrefix} beforecalling this method.
 */
void popAllBranches(){
  for (  ConditionalBranch branch : branches) {
    HtmlTagEntry entry=branch.deque().peek();
    if (entry.hasTagName()) {
      branch.deque().pop();
    }
 else {
      entry.getBranches().popAllBranches();
    }
  }
  removeEmptyDeque();
}",0.9746300211416492
29431,"/** 
 * A method that should be called after we visit a control flow node (  {@code IfNode} or {@code SwitchNode}). <p>Compared to   {@code matchOrError} methods, this method does not report an error when one ofthe deques is empty. However, if both deques are not empty but the top do not match, we should report an error. <p>Another difference is that we don't try to remove all optional tags from the openStack, if the closeQueue is empty. It is possible that some of the optional tags are ended in another control block, and we cannot remove them too eagerly.
 */
public static boolean tryMatchOrError(ArrayDeque<HtmlTagEntry> openStack,ArrayDeque<HtmlTagEntry> closeQueue,ErrorReporter errorReporter){
  while (!openStack.isEmpty() && !closeQueue.isEmpty()) {
    HtmlTagEntry openTag=openStack.peekFirst();
    HtmlTagEntry closeTag=closeQueue.peekFirst();
    if (closeTag.isDefinitelyOptional()) {
      if (closeTag.getTagName().equals(openTag.getTagName())) {
        openStack.pollFirst();
        closeQueue.pollFirst();
        continue;
      }
      if (!openTag.hasTagName()) {
        return tryMatchCommonPrefix(openTag,closeTag,errorReporter);
      }
    }
    if (closeTag.hasTagName()) {
      while (!openStack.isEmpty()) {
        openTag=openStack.peekFirst();
        if (openTag.isDefinitelyOptional()) {
          openStack.pollFirst();
          continue;
        }
 else         if (!openTag.hasTagName()) {
          openTag.getBranches().popOptionalTags();
          if (openTag.getBranches().isEmpty()) {
            openStack.pollFirst();
            continue;
          }
        }
        break;
      }
    }
    if (matchOrError(openTag,closeTag,errorReporter)) {
      openStack.pollFirst();
      closeQueue.pollFirst();
    }
 else {
      return false;
    }
  }
  return true;
}","/** 
 * A method that should be called after we visit a control flow node (  {@code IfNode} or {@code SwitchNode}). <p>Compared to   {@code matchOrError} methods, this method does not report an error when one ofthe deques is empty. However, if both deques are not empty but the top do not match, we should report an error. <p>Another difference is that we don't try to remove all optional tags from the openStack, if the closeQueue is empty. It is possible that some of the optional tags are ended in another control block, and we cannot remove them too eagerly.
 */
public static boolean tryMatchOrError(ArrayDeque<HtmlTagEntry> openStack,ArrayDeque<HtmlTagEntry> closeQueue,ErrorReporter errorReporter){
  while (!openStack.isEmpty() && !closeQueue.isEmpty()) {
    HtmlTagEntry openTag=openStack.peekFirst();
    HtmlTagEntry closeTag=closeQueue.peekFirst();
    if (closeTag.isDefinitelyOptional()) {
      if (closeTag.getTagName().equals(openTag.getTagName())) {
        openStack.pollFirst();
        closeQueue.pollFirst();
        continue;
      }
      if (!openTag.hasTagName()) {
        if (tryMatchCommonPrefix(openTag,closeTag,errorReporter)) {
          openStack.pollFirst();
          closeQueue.pollFirst();
          return true;
        }
        return false;
      }
    }
    if (closeTag.hasTagName()) {
      while (!openStack.isEmpty()) {
        openTag=openStack.peekFirst();
        if (openTag.isDefinitelyOptional()) {
          openStack.pollFirst();
          continue;
        }
 else         if (!openTag.hasTagName()) {
          openTag.getBranches().popOptionalTags();
          if (openTag.getBranches().isEmpty()) {
            openStack.pollFirst();
            continue;
          }
        }
        break;
      }
    }
    if (matchOrError(openTag,closeTag,errorReporter)) {
      openStack.pollFirst();
      closeQueue.pollFirst();
    }
 else {
      return false;
    }
  }
  return true;
}",0.9641052911459718
29432,"/** 
 * A method that should be called after we visit a control flow node (  {@code IfNode} or {@code SwitchNode}). <p>Compared to   {@code matchOrError} methods, this method does not report an error when one ofthe deques is empty. However, if both deques are not empty but the top do not match, we should report an error.
 */
public static void tryMatchOrError(ArrayDeque<HtmlTagEntry> openStack,ArrayDeque<HtmlTagEntry> closeQueue,ErrorReporter errorReporter){
  while (!openStack.isEmpty() && !closeQueue.isEmpty()) {
    if (!matchOrError(openStack.pollFirst(),closeQueue.pollFirst(),errorReporter)) {
      return;
    }
  }
}","/** 
 * A method that should be called after we visit a control flow node (  {@code IfNode} or {@code SwitchNode}). <p>Compared to   {@code matchOrError} methods, this method does not report an error when one ofthe deques is empty. However, if both deques are not empty but the top do not match, we should report an error. <p>Another difference is that we don't try to remove all optional tags from the openStack, if the closeQueue is empty. It is possible that some of the optional tags are ended in another control block, and we cannot remove them too eagerly.
 */
public static boolean tryMatchOrError(ArrayDeque<HtmlTagEntry> openStack,ArrayDeque<HtmlTagEntry> closeQueue,ErrorReporter errorReporter){
  while (!openStack.isEmpty() && !closeQueue.isEmpty()) {
    if (!closeQueue.peekFirst().isDefinitelyOptional() && openStack.peekFirst().isDefinitelyOptional()) {
      openStack.pollFirst();
      continue;
    }
    if (!matchOrError(openStack.pollFirst(),closeQueue.pollFirst(),errorReporter)) {
      return false;
    }
  }
  return true;
}",0.7391562685680333
29433,"/** 
 * A helper method that compare two   {@code HtmlTagEntry}s. 
 */
public static boolean matchOrError(@Nullable HtmlTagEntry openTag,@Nullable HtmlTagEntry closeTag,ErrorReporter errorReporter){
  if (openTag == null && closeTag == null) {
    return true;
  }
  if (openTag == null && closeTag != null) {
    errorReporter.report(closeTag.getSourceLocation(),UNEXPECTED_CLOSE_TAG);
    return false;
  }
  if (openTag != null && closeTag == null) {
    errorReporter.report(openTag.getSourceLocation(),OPEN_TAG_NOT_CLOSED);
    return false;
  }
  if (openTag.hasTagName() != closeTag.hasTagName()) {
    boolean matchCommonPrefix=false;
    if (openTag.hasTagName()) {
      TagName openTagName=openTag.getTagName();
      if (closeTag.getBranches().hasCommonPrefix(openTagName)) {
        closeTag.getBranches().popAllBranches();
        matchCommonPrefix=true;
        if (!closeTag.getBranches().isEmpty()) {
          matchCommonPrefix=false;
          errorReporter.report(closeTag.getSourceLocation(),UNEXPECTED_CLOSE_TAG_WITH_EXPECTATION,openTagName.getStaticTagNameAsLowerCase().get());
        }
      }
 else {
        errorReporter.report(openTagName.getTagLocation(),OPEN_TAG_NOT_CLOSED);
      }
    }
 else {
      TagName closeTagName=closeTag.getTagName();
      if (openTag.getBranches().hasCommonPrefix(closeTagName)) {
        openTag.getBranches().popAllBranches();
        matchCommonPrefix=true;
        if (!openTag.getBranches().isEmpty()) {
          matchCommonPrefix=false;
          errorReporter.report(openTag.getSourceLocation(),OPEN_TAG_NOT_CLOSED);
        }
      }
 else {
        errorReporter.report(closeTagName.getTagLocation(),UNEXPECTED_CLOSE_TAG);
      }
    }
    return matchCommonPrefix;
  }
  if (openTag.hasTagName()) {
    return matchOrError(openTag.getTagName(),closeTag.getTagName(),errorReporter);
  }
 else {
    List<ConditionalBranches.ConditionalBranch> openBranches=openTag.getBranches().getBranches();
    List<ConditionalBranches.ConditionalBranch> closeBranches=closeTag.getBranches().getBranches();
    SourceLocation location=closeTag.getSourceLocation();
    if (openBranches.size() != closeBranches.size()) {
      errorReporter.report(location,MISMATCH_TAG);
      return false;
    }
    for (int i=0; i < openBranches.size(); ++i) {
      ConditionalBranches.ConditionalBranch openBranch=openBranches.get(i);
      ConditionalBranches.ConditionalBranch closeBranch=closeBranches.get(i);
      if (!openBranch.condition().equals(closeBranch.condition())) {
        errorReporter.report(location,MISMATCH_TAG);
        return false;
      }
      ArrayDeque<HtmlTagEntry> openStack=openBranch.deque();
      ArrayDeque<HtmlTagEntry> closeQueue=closeBranch.deque();
      while (!openStack.isEmpty() && !closeQueue.isEmpty()) {
        if (!closeQueue.peekFirst().isDefinitelyOptional() && openStack.peekFirst().isDefinitelyOptional()) {
          openStack.pollFirst();
          continue;
        }
        if (!matchOrError(openStack.pollFirst(),closeQueue.pollFirst(),errorReporter)) {
          return false;
        }
      }
      if (openStack.isEmpty() && closeQueue.isEmpty()) {
        continue;
      }
 else       if (openStack.isEmpty()) {
        errorReporter.report(closeQueue.pollFirst().getSourceLocation(),UNEXPECTED_CLOSE_TAG);
        return false;
      }
 else {
        errorReporter.report(openStack.pollFirst().getSourceLocation(),OPEN_TAG_NOT_CLOSED);
        return false;
      }
    }
    return true;
  }
}","/** 
 * A helper method that compare two   {@code HtmlTagEntry}s. 
 */
public static boolean matchOrError(@Nullable HtmlTagEntry openTag,@Nullable HtmlTagEntry closeTag,ErrorReporter errorReporter){
  if (openTag == null && closeTag == null) {
    return true;
  }
  if (openTag == null && closeTag != null) {
    errorReporter.report(closeTag.getSourceLocation(),UNEXPECTED_CLOSE_TAG);
    return false;
  }
  if (openTag != null && closeTag == null) {
    errorReporter.report(openTag.getSourceLocation(),OPEN_TAG_NOT_CLOSED);
    return false;
  }
  if (openTag.hasTagName() != closeTag.hasTagName()) {
    boolean matchCommonPrefix=false;
    if (openTag.hasTagName()) {
      TagName openTagName=openTag.getTagName();
      if (closeTag.getBranches().hasCommonPrefix(openTagName)) {
        closeTag.getBranches().popAllBranches();
        matchCommonPrefix=true;
        if (!closeTag.getBranches().isEmpty()) {
          matchCommonPrefix=false;
          errorReporter.report(closeTag.getSourceLocation(),UNEXPECTED_CLOSE_TAG_WITH_EXPECTATION,openTagName.getStaticTagNameAsLowerCase().get());
        }
      }
 else {
        errorReporter.report(openTagName.getTagLocation(),OPEN_TAG_NOT_CLOSED);
      }
    }
 else {
      TagName closeTagName=closeTag.getTagName();
      if (openTag.getBranches().hasCommonPrefix(closeTagName)) {
        openTag.getBranches().popAllBranches();
        matchCommonPrefix=true;
        if (!openTag.getBranches().isEmpty()) {
          matchCommonPrefix=false;
          errorReporter.report(openTag.getSourceLocation(),OPEN_TAG_NOT_CLOSED);
        }
      }
 else {
        errorReporter.report(closeTagName.getTagLocation(),UNEXPECTED_CLOSE_TAG);
      }
    }
    return matchCommonPrefix;
  }
  if (openTag.hasTagName()) {
    return matchOrError(openTag.getTagName(),closeTag.getTagName(),errorReporter);
  }
 else {
    List<ConditionalBranches.ConditionalBranch> openBranches=openTag.getBranches().getBranches();
    List<ConditionalBranches.ConditionalBranch> closeBranches=closeTag.getBranches().getBranches();
    SourceLocation location=closeTag.getSourceLocation();
    if (openBranches.size() != closeBranches.size()) {
      errorReporter.report(location,MISMATCH_TAG);
      return false;
    }
    for (int i=0; i < openBranches.size(); ++i) {
      ConditionalBranches.ConditionalBranch openBranch=openBranches.get(i);
      ConditionalBranches.ConditionalBranch closeBranch=closeBranches.get(i);
      if (!openBranch.condition().equals(closeBranch.condition())) {
        errorReporter.report(location,MISMATCH_TAG);
        return false;
      }
      ArrayDeque<HtmlTagEntry> openStack=openBranch.deque();
      ArrayDeque<HtmlTagEntry> closeQueue=closeBranch.deque();
      if (!matchOrError(openStack,closeQueue,errorReporter)) {
        return false;
      }
    }
    return true;
  }
}",0.8798492225537929
29434,"/** 
 * A method that should be called after we visit a control flow node (  {@code IfNode} or {@code SwitchNode}). <p>Compared to   {@code matchOrError} methods, this method does not report an error when one ofthe deques is empty. However, if both deques are not empty but the top do not match, we should report an error. <p>Another difference is that we don't try to remove all optional tags from the openStack, if the closeQueue is empty. It is possible that some of the optional tags are ended in another control block, and we cannot remove them too eagerly.
 */
public static boolean tryMatchOrError(ArrayDeque<HtmlTagEntry> openStack,ArrayDeque<HtmlTagEntry> closeQueue,ErrorReporter errorReporter){
  while (!openStack.isEmpty() && !closeQueue.isEmpty()) {
    if (!closeQueue.peekFirst().isDefinitelyOptional() && openStack.peekFirst().isDefinitelyOptional()) {
      openStack.pollFirst();
      continue;
    }
    if (!matchOrError(openStack.pollFirst(),closeQueue.pollFirst(),errorReporter)) {
      return false;
    }
  }
  return true;
}","/** 
 * A method that should be called after we visit a control flow node (  {@code IfNode} or {@code SwitchNode}). <p>Compared to   {@code matchOrError} methods, this method does not report an error when one ofthe deques is empty. However, if both deques are not empty but the top do not match, we should report an error. <p>Another difference is that we don't try to remove all optional tags from the openStack, if the closeQueue is empty. It is possible that some of the optional tags are ended in another control block, and we cannot remove them too eagerly.
 */
public static boolean tryMatchOrError(ArrayDeque<HtmlTagEntry> openStack,ArrayDeque<HtmlTagEntry> closeQueue,ErrorReporter errorReporter){
  while (!openStack.isEmpty() && !closeQueue.isEmpty()) {
    HtmlTagEntry openTag=openStack.peekFirst();
    HtmlTagEntry closeTag=closeQueue.peekFirst();
    if (closeTag.isDefinitelyOptional()) {
      if (closeTag.getTagName().equals(openTag.getTagName())) {
        openStack.pollFirst();
        closeQueue.pollFirst();
        continue;
      }
      if (!openTag.hasTagName()) {
        return tryMatchCommonPrefix(openTag,closeTag,errorReporter);
      }
    }
    if (closeTag.hasTagName()) {
      while (!openStack.isEmpty()) {
        openTag=openStack.peekFirst();
        if (openTag.isDefinitelyOptional()) {
          openStack.pollFirst();
          continue;
        }
 else         if (!openTag.hasTagName()) {
          openTag.getBranches().popOptionalTags();
          if (openTag.getBranches().isEmpty()) {
            openStack.pollFirst();
            continue;
          }
        }
        break;
      }
    }
    if (matchOrError(openTag,closeTag,errorReporter)) {
      openStack.pollFirst();
      closeQueue.pollFirst();
    }
 else {
      return false;
    }
  }
  return true;
}",0.7005571030640668
29435,"/** 
 * A helper method that compare two   {@code HtmlTagEntry}s. 
 */
public static boolean matchOrError(@Nullable HtmlTagEntry openTag,@Nullable HtmlTagEntry closeTag,ErrorReporter errorReporter){
  if (openTag == null && closeTag == null) {
    return true;
  }
  if (openTag == null && closeTag != null) {
    errorReporter.report(closeTag.getSourceLocation(),UNEXPECTED_CLOSE_TAG);
    return false;
  }
  if (openTag != null && closeTag == null) {
    errorReporter.report(openTag.getSourceLocation(),OPEN_TAG_NOT_CLOSED);
    return false;
  }
  if (openTag.hasTagName() != closeTag.hasTagName()) {
    boolean matchCommonPrefix=false;
    if (openTag.hasTagName()) {
      TagName openTagName=openTag.getTagName();
      if (closeTag.getBranches().hasCommonPrefix(openTagName)) {
        closeTag.getBranches().popAllBranches();
        matchCommonPrefix=true;
        if (!closeTag.getBranches().isEmpty()) {
          matchCommonPrefix=false;
          errorReporter.report(closeTag.getSourceLocation(),UNEXPECTED_CLOSE_TAG_WITH_EXPECTATION,openTagName.getStaticTagNameAsLowerCase().get());
        }
      }
 else {
        errorReporter.report(openTagName.getTagLocation(),OPEN_TAG_NOT_CLOSED);
      }
    }
 else {
      TagName closeTagName=closeTag.getTagName();
      if (openTag.getBranches().hasCommonPrefix(closeTagName)) {
        openTag.getBranches().popAllBranches();
        matchCommonPrefix=true;
        if (!openTag.getBranches().isEmpty()) {
          matchCommonPrefix=false;
          errorReporter.report(openTag.getSourceLocation(),OPEN_TAG_NOT_CLOSED);
        }
      }
 else {
        errorReporter.report(closeTagName.getTagLocation(),UNEXPECTED_CLOSE_TAG);
      }
    }
    return matchCommonPrefix;
  }
  if (openTag.hasTagName()) {
    return matchOrError(openTag.getTagName(),closeTag.getTagName(),errorReporter);
  }
 else {
    List<ConditionalBranches.ConditionalBranch> openBranches=openTag.getBranches().getBranches();
    List<ConditionalBranches.ConditionalBranch> closeBranches=closeTag.getBranches().getBranches();
    SourceLocation location=closeTag.getSourceLocation();
    if (openBranches.size() != closeBranches.size()) {
      errorReporter.report(location,MISMATCH_TAG);
      return false;
    }
    for (int i=0; i < openBranches.size(); ++i) {
      ConditionalBranches.ConditionalBranch openBranch=openBranches.get(i);
      ConditionalBranches.ConditionalBranch closeBranch=closeBranches.get(i);
      if (!openBranch.condition().equals(closeBranch.condition())) {
        errorReporter.report(location,MISMATCH_TAG);
        return false;
      }
      ArrayDeque<HtmlTagEntry> openStack=openBranch.deque();
      ArrayDeque<HtmlTagEntry> closeQueue=closeBranch.deque();
      if (!matchOrError(openStack,closeQueue,errorReporter)) {
        return false;
      }
    }
    return true;
  }
}","/** 
 * A helper method that compare two   {@code HtmlTagEntry}s. 
 */
public static boolean matchOrError(@Nullable HtmlTagEntry openTag,@Nullable HtmlTagEntry closeTag,ErrorReporter errorReporter){
  if (openTag == null && closeTag == null) {
    return true;
  }
  if (openTag == null && closeTag != null) {
    errorReporter.report(closeTag.getSourceLocation(),UNEXPECTED_CLOSE_TAG);
    return false;
  }
  if (openTag != null && closeTag == null) {
    errorReporter.report(openTag.getSourceLocation(),OPEN_TAG_NOT_CLOSED);
    return false;
  }
  if (openTag.hasTagName() != closeTag.hasTagName()) {
    return tryMatchCommonPrefix(openTag,closeTag,errorReporter);
  }
  if (openTag.hasTagName()) {
    return matchOrError(openTag.getTagName(),closeTag.getTagName(),errorReporter);
  }
 else {
    List<ConditionalBranches.ConditionalBranch> openBranches=openTag.getBranches().getBranches();
    List<ConditionalBranches.ConditionalBranch> closeBranches=closeTag.getBranches().getBranches();
    SourceLocation location=closeTag.getSourceLocation();
    if (openBranches.size() != closeBranches.size()) {
      errorReporter.report(location,MISMATCH_TAG);
      return false;
    }
    for (int i=0; i < openBranches.size(); ++i) {
      ConditionalBranches.ConditionalBranch openBranch=openBranches.get(i);
      ConditionalBranches.ConditionalBranch closeBranch=closeBranches.get(i);
      if (!openBranch.condition().equals(closeBranch.condition())) {
        errorReporter.report(location,MISMATCH_TAG);
        return false;
      }
      ArrayDeque<HtmlTagEntry> openStack=openBranch.deque();
      ArrayDeque<HtmlTagEntry> closeQueue=closeBranch.deque();
      if (!matchOrError(openStack,closeQueue,errorReporter)) {
        return false;
      }
    }
    return true;
  }
}",0.7570475575640198
29436,"@Override protected void visitTemplateNode(TemplateNode node){
  Checkpoint checkpoint=errorReporter.checkpoint();
  visitChildren(node);
  if (errorReporter.errorsSince(checkpoint)) {
    return;
  }
  matchTagsInDeques();
}","@Override protected void visitTemplateNode(TemplateNode node){
  Checkpoint checkpoint=errorReporter.checkpoint();
  visitChildren(node);
  if (errorReporter.errorsSince(checkpoint)) {
    return;
  }
  HtmlTagEntry.matchOrError(openTagStack,closeTagQueue,errorReporter);
}",0.8514056224899599
29437,"@Override protected void visitHtmlCloseTagNode(HtmlCloseTagNode node){
  TagName closeTag=node.getTagName();
  if (isDefinitelyVoid(node)) {
    errorReporter.report(node.getSourceLocation(),INVALID_CLOSE_TAG,closeTag.getStaticTagName().getRawText());
    return;
  }
  if (closeTag.isForeignContent()) {
    foreignContentEndLocation=node.getSourceLocation();
    inForeignContent=false;
  }
  if (!closeTag.isDefinitelyOptional()) {
    popOptionalTags(false);
  }
  if (!openTagStack.isEmpty() && openTagStack.peekFirst().hasTagName()) {
    TagName openTag=openTagStack.peekFirst().getTagName();
    if (HtmlTagEntry.matchOrError(openTag,closeTag,errorReporter)) {
      openTagStack.pollFirst();
    }
  }
 else {
    closeTagQueue.addLast(new HtmlTagEntry(closeTag));
  }
}","@Override protected void visitHtmlCloseTagNode(HtmlCloseTagNode node){
  TagName closeTag=node.getTagName();
  if (isDefinitelyVoid(node)) {
    errorReporter.report(node.getSourceLocation(),INVALID_CLOSE_TAG,closeTag.getStaticTagName().getRawText());
    return;
  }
  if (closeTag.isForeignContent()) {
    foreignContentEndLocation=node.getSourceLocation();
    inForeignContent=false;
  }
  HtmlTagEntry openTag=openTagStack.peekFirst();
  while (openTag != null && openTag.hasTagName() && !openTag.getTagName().equals(closeTag) && openTag.isDefinitelyOptional()) {
    openTagStack.pollFirst();
    openTag=openTagStack.peekFirst();
  }
  if (openTag != null && openTag.hasTagName()) {
    if (HtmlTagEntry.matchOrError(openTag.getTagName(),closeTag,errorReporter)) {
      openTagStack.pollFirst();
    }
  }
 else {
    closeTagQueue.addLast(new HtmlTagEntry(closeTag));
  }
}",0.7689530685920578
29438,"/** 
 * Called to handle whitespace that was completely removed from a raw text node. 
 */
void handleJoinedWhitespace(SourceLocation.Point point,boolean atEndOfBlock){
switch (context.getState()) {
case UNQUOTED_ATTRIBUTE_VALUE:
    context.createUnquotedAttributeValue(point);
case AFTER_TAG_NAME_OR_ATTRIBUTE:
  context.setState(State.BEFORE_ATTRIBUTE_NAME,point);
return;
case AFTER_ATTRIBUTE_NAME:
if (atEndOfBlock) {
context.setState(State.BEFORE_ATTRIBUTE_NAME,point);
return;
}
case BEFORE_ATTRIBUTE_VALUE:
case BEFORE_ATTRIBUTE_NAME:
case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:
case HTML_TAG_NAME:
case HTML_COMMENT:
case CDATA:
case NONE:
case SINGLE_QUOTED_ATTRIBUTE_VALUE:
case DOUBLE_QUOTED_ATTRIBUTE_VALUE:
case PCDATA:
case RCDATA_SCRIPT:
case RCDATA_STYLE:
case RCDATA_TEXTAREA:
case RCDATA_TITLE:
case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:
case XML_DECLARATION:
return;
}
throw new AssertionError();
}","/** 
 * Called to handle whitespace that was completely removed from a raw text node. 
 */
void handleJoinedWhitespace(SourceLocation.Point point){
switch (context.getState()) {
case UNQUOTED_ATTRIBUTE_VALUE:
    context.createUnquotedAttributeValue(point);
case AFTER_TAG_NAME_OR_ATTRIBUTE:
  context.setState(State.BEFORE_ATTRIBUTE_NAME,point);
return;
case AFTER_ATTRIBUTE_NAME:
int currentChar=currentChar();
if (currentChar == -1 || (!CharMatcher.whitespace().matches((char)currentChar) && '=' != (char)currentChar)) {
context.setState(State.BEFORE_ATTRIBUTE_NAME,point);
return;
}
case BEFORE_ATTRIBUTE_VALUE:
case BEFORE_ATTRIBUTE_NAME:
case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:
case HTML_TAG_NAME:
case HTML_COMMENT:
case CDATA:
case NONE:
case SINGLE_QUOTED_ATTRIBUTE_VALUE:
case DOUBLE_QUOTED_ATTRIBUTE_VALUE:
case PCDATA:
case RCDATA_SCRIPT:
case RCDATA_STYLE:
case RCDATA_TEXTAREA:
case RCDATA_TITLE:
case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:
case XML_DECLARATION:
return;
}
throw new AssertionError();
}",0.9131565262610504
29439,"/** 
 * For RawText we need to examine every character. <p>We track an index and an offset into the current RawTextNode (currentRawTextIndex and currentRawTextOffset respectively). 'advance' methods move the index and 'consume' methods optionally move the index and always set the offset == index. (they 'consume' the text between the offset and the index. <p>handle* methods will 'handle the current state' <ul> <li>Precondition : They are in the given state and not at the end of the input <li> Postcondition: They have either advanced the current index or changed states (generally both) </ul> <p>NOTE: a consequence of these conditions is that they are only guaranteed to be able to consume a single character. <p>At the end of visiting a raw text node, all the input will be consumed.
 */
@Override protected void visitRawTextNode(RawTextNode node){
  currentRawTextNode=node;
  currentRawText=node.getRawText();
  currentRawTextOffset=0;
  currentRawTextIndex=0;
  int prevStartIndex=-1;
  while (currentRawTextIndex < currentRawText.length()) {
    int startIndex=currentRawTextIndex;
    if (startIndex != prevStartIndex && currentRawTextNode.missingWhitespaceAt(startIndex)) {
      handleJoinedWhitespace(currentPoint(),false);
    }
    prevStartIndex=startIndex;
    State startState=context.getState();
switch (startState) {
case NONE:
      currentRawTextIndex=currentRawTextOffset=currentRawText.length();
    break;
case PCDATA:
  handlePcData();
break;
case DOUBLE_QUOTED_ATTRIBUTE_VALUE:
handleQuotedAttributeValue(true);
break;
case SINGLE_QUOTED_ATTRIBUTE_VALUE:
handleQuotedAttributeValue(false);
break;
case BEFORE_ATTRIBUTE_VALUE:
handleBeforeAttributeValue();
break;
case AFTER_TAG_NAME_OR_ATTRIBUTE:
handleAfterTagNameOrAttribute();
break;
case BEFORE_ATTRIBUTE_NAME:
handleBeforeAttributeName();
break;
case UNQUOTED_ATTRIBUTE_VALUE:
handleUnquotedAttributeValue();
break;
case AFTER_ATTRIBUTE_NAME:
handleAfterAttributeName();
break;
case HTML_TAG_NAME:
handleHtmlTagName();
break;
case RCDATA_STYLE:
handleRcData(TagName.SpecialTagName.STYLE);
break;
case RCDATA_TITLE:
handleRcData(TagName.SpecialTagName.TITLE);
break;
case RCDATA_SCRIPT:
handleRcData(TagName.SpecialTagName.SCRIPT);
break;
case RCDATA_TEXTAREA:
handleRcData(TagName.SpecialTagName.TEXTAREA);
break;
case CDATA:
handleCData();
break;
case HTML_COMMENT:
handleHtmlComment();
break;
case XML_DECLARATION:
handleXmlDeclaration();
break;
case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:
handleXmlAttributeQuoted(true);
break;
case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:
handleXmlAttributeQuoted(false);
break;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + startState);
}
if (context.getState() == startState && startIndex == currentRawTextIndex) {
throw new IllegalStateException(""String_Node_Str"" + startState.name() + ""String_Node_Str""+ currentLocation());
}
if (currentRawTextOffset > currentRawTextIndex) {
throw new IllegalStateException(""String_Node_Str"" + currentRawTextOffset + ""String_Node_Str""+ currentRawTextIndex);
}
}
if (currentRawTextIndex != currentRawText.length()) {
throw new AssertionError(""String_Node_Str"");
}
if (currentRawTextOffset < currentRawTextIndex && currentRawTextOffset != 0) {
RawTextNode suffix=consumeAsRawText();
edits.replace(node,suffix);
}
if (currentRawTextNode.missingWhitespaceAt(currentRawText.length())) {
handleJoinedWhitespace(currentRawTextNode.getSourceLocation().getEndPoint(),true);
}
}","/** 
 * For RawText we need to examine every character. <p>We track an index and an offset into the current RawTextNode (currentRawTextIndex and currentRawTextOffset respectively). 'advance' methods move the index and 'consume' methods optionally move the index and always set the offset == index. (they 'consume' the text between the offset and the index. <p>handle* methods will 'handle the current state' <ul> <li>Precondition : They are in the given state and not at the end of the input <li> Postcondition: They have either advanced the current index or changed states (generally both) </ul> <p>NOTE: a consequence of these conditions is that they are only guaranteed to be able to consume a single character. <p>At the end of visiting a raw text node, all the input will be consumed.
 */
@Override protected void visitRawTextNode(RawTextNode node){
  currentRawTextNode=node;
  currentRawText=node.getRawText();
  currentRawTextOffset=0;
  currentRawTextIndex=0;
  int prevStartIndex=-1;
  while (currentRawTextIndex < currentRawText.length()) {
    int startIndex=currentRawTextIndex;
    if (startIndex != prevStartIndex && currentRawTextNode.missingWhitespaceAt(startIndex)) {
      handleJoinedWhitespace(currentPoint());
    }
    prevStartIndex=startIndex;
    State startState=context.getState();
switch (startState) {
case NONE:
      currentRawTextIndex=currentRawTextOffset=currentRawText.length();
    break;
case PCDATA:
  handlePcData();
break;
case DOUBLE_QUOTED_ATTRIBUTE_VALUE:
handleQuotedAttributeValue(true);
break;
case SINGLE_QUOTED_ATTRIBUTE_VALUE:
handleQuotedAttributeValue(false);
break;
case BEFORE_ATTRIBUTE_VALUE:
handleBeforeAttributeValue();
break;
case AFTER_TAG_NAME_OR_ATTRIBUTE:
handleAfterTagNameOrAttribute();
break;
case BEFORE_ATTRIBUTE_NAME:
handleBeforeAttributeName();
break;
case UNQUOTED_ATTRIBUTE_VALUE:
handleUnquotedAttributeValue();
break;
case AFTER_ATTRIBUTE_NAME:
handleAfterAttributeName();
break;
case HTML_TAG_NAME:
handleHtmlTagName();
break;
case RCDATA_STYLE:
handleRcData(TagName.SpecialTagName.STYLE);
break;
case RCDATA_TITLE:
handleRcData(TagName.SpecialTagName.TITLE);
break;
case RCDATA_SCRIPT:
handleRcData(TagName.SpecialTagName.SCRIPT);
break;
case RCDATA_TEXTAREA:
handleRcData(TagName.SpecialTagName.TEXTAREA);
break;
case CDATA:
handleCData();
break;
case HTML_COMMENT:
handleHtmlComment();
break;
case XML_DECLARATION:
handleXmlDeclaration();
break;
case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:
handleXmlAttributeQuoted(true);
break;
case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:
handleXmlAttributeQuoted(false);
break;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + startState);
}
if (context.getState() == startState && startIndex == currentRawTextIndex) {
throw new IllegalStateException(""String_Node_Str"" + startState.name() + ""String_Node_Str""+ currentLocation());
}
if (currentRawTextOffset > currentRawTextIndex) {
throw new IllegalStateException(""String_Node_Str"" + currentRawTextOffset + ""String_Node_Str""+ currentRawTextIndex);
}
}
if (currentRawTextIndex != currentRawText.length()) {
throw new AssertionError(""String_Node_Str"");
}
if (currentRawTextOffset < currentRawTextIndex && currentRawTextOffset != 0) {
RawTextNode suffix=consumeAsRawText();
edits.replace(node,suffix);
}
if (currentRawTextNode.missingWhitespaceAt(currentRawText.length())) {
handleJoinedWhitespace(currentRawTextNode.getSourceLocation().getEndPoint());
}
}",0.998399068548974
29440,"/** 
 * Scans until the next whitespace, > or />, validates that the matched text is an html identifier and returns it.
 */
@Nullable RawTextNode consumeHtmlIdentifier(){
  advanceWhileMatches(TAG_RAW_TEXT_MATCHER);
  RawTextNode node=consumeAsRawText();
  if (node != null) {
    int invalidChar=indexOfInvalidNameCharacter(node.getRawText());
    if (invalidChar != -1) {
      errorReporter.report(node.substringLocation(invalidChar,invalidChar + 1),INVALID_IDENTIFIER,node.getRawText().charAt(invalidChar));
    }
  }
 else {
    errorReporter.report(currentLocation(),GENERIC_UNEXPECTED_CHAR,""String_Node_Str"");
    advance();
    consume();
  }
  return node;
}","/** 
 * Scans until the next whitespace, > or />, validates that the matched text is an html identifier and returns it.
 */
@Nullable RawTextNode consumeHtmlIdentifier(){
  boolean foundDelimiter=advanceWhileMatches(TAG_IDENTIFIER_MATCHER);
  RawTextNode node=consumeAsRawText();
  if (node != null) {
    if (foundDelimiter && INVALID_IDENTIFIER_CHAR_MATCHER.matches((char)currentChar())) {
      errorReporter.report(currentLocation(),INVALID_IDENTIFIER,(char)currentChar());
      advance();
      consume();
    }
  }
 else {
    errorReporter.report(currentLocation(),GENERIC_UNEXPECTED_CHAR,""String_Node_Str"");
    advance();
    consume();
  }
  return node;
}",0.6506746626686657
29441,"/** 
 * Visits a control flow structure like an if, switch or a loop. <p>The main thing this is responsible for is calculating what state to enter after the control flow is complete.
 * @param parent The parent node, each child will be a block representing one of the branches
 * @param children The child blocks. We don't use {@code parent.getChildren()} directly to makeit possible to handle ForNodes using this method.
 * @param overallName The name, for error reporting purposes, to assign to the control flowstructure
 * @param blockNamer A function to provide a name for each child block, the key is the index ofthe block
 * @param willExactlyOneBranchExecuteOnce Whether or not it is guaranteed that exactly onebranch of the structure will execute exactly one time.
 * @param willAtLeastOneBranchExecute Whether or not it is guaranteed that at least one of thebranches will execute (as opposed to no branches executing).
 */
void visitControlFlowStructure(StandaloneNode parent,List<? extends BlockNode> children,String overallName,Function<? super BlockNode,String> blockNamer,boolean willExactlyOneBranchExecuteOnce,boolean willAtLeastOneBranchExecute){
  if (children.isEmpty()) {
    return;
  }
  State startingState=context.getState();
  State endingState=visitBranches(children,blockNamer);
  SourceLocation.Point endPoint=parent.getSourceLocation().getEndPoint();
switch (startingState) {
case AFTER_TAG_NAME_OR_ATTRIBUTE:
case BEFORE_ATTRIBUTE_NAME:
case AFTER_ATTRIBUTE_NAME:
    context.addTagChild(parent);
  if (willAtLeastOneBranchExecute && endingState == State.BEFORE_ATTRIBUTE_NAME) {
    context.setState(State.BEFORE_ATTRIBUTE_NAME,endPoint);
  }
break;
case HTML_TAG_NAME:
errorReporter.report(parent.getSourceLocation(),INVALID_LOCATION_FOR_CONTROL_FLOW,overallName,""String_Node_Str"");
throw new AbortParsingBlockError();
case BEFORE_ATTRIBUTE_VALUE:
if (!willExactlyOneBranchExecuteOnce) {
errorReporter.report(parent.getSourceLocation(),CONDITIONAL_BLOCK_ISNT_GUARANTEED_TO_PRODUCE_ONE_ATTRIBUTE_VALUE,overallName);
}
if (willAtLeastOneBranchExecute && endingState == State.UNQUOTED_ATTRIBUTE_VALUE) {
context.addAttributeValuePart(parent);
context.setState(State.UNQUOTED_ATTRIBUTE_VALUE,endPoint);
}
 else {
context.setAttributeValue(parent);
if (willAtLeastOneBranchExecute && endingState == State.BEFORE_ATTRIBUTE_NAME) {
context.setState(State.BEFORE_ATTRIBUTE_NAME,endPoint);
}
}
break;
case UNQUOTED_ATTRIBUTE_VALUE:
case DOUBLE_QUOTED_ATTRIBUTE_VALUE:
case SINGLE_QUOTED_ATTRIBUTE_VALUE:
context.addAttributeValuePart(parent);
break;
case HTML_COMMENT:
case NONE:
case PCDATA:
case RCDATA_SCRIPT:
case RCDATA_STYLE:
case RCDATA_TEXTAREA:
case RCDATA_TITLE:
case XML_DECLARATION:
case CDATA:
case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:
case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:
break;
default :
throw new AssertionError(""String_Node_Str"" + startingState);
}
}","/** 
 * Visits a control flow structure like an if, switch or a loop. <p>The main thing this is responsible for is calculating what state to enter after the control flow is complete.
 * @param parent The parent node, each child will be a block representing one of the branches
 * @param children The child blocks. We don't use {@code parent.getChildren()} directly to makeit possible to handle ForNodes using this method.
 * @param overallName The name, for error reporting purposes, to assign to the control flowstructure
 * @param blockNamer A function to provide a name for each child block, the key is the index ofthe block
 * @param willExactlyOneBranchExecuteOnce Whether or not it is guaranteed that exactly onebranch of the structure will execute exactly one time.
 * @param willAtLeastOneBranchExecute Whether or not it is guaranteed that at least one of thebranches will execute (as opposed to no branches executing).
 */
void visitControlFlowStructure(StandaloneNode parent,List<? extends BlockNode> children,String overallName,Function<? super BlockNode,String> blockNamer,boolean willExactlyOneBranchExecuteOnce,boolean willAtLeastOneBranchExecute){
  if (children.isEmpty()) {
    return;
  }
  State startingState=context.getState();
  State endingState=visitBranches(children,blockNamer);
  SourceLocation.Point endPoint=parent.getSourceLocation().getEndPoint();
switch (startingState) {
case AFTER_TAG_NAME_OR_ATTRIBUTE:
case BEFORE_ATTRIBUTE_NAME:
case AFTER_ATTRIBUTE_NAME:
    context.addTagChild(parent);
  context.setState(endingState,endPoint);
break;
case HTML_TAG_NAME:
errorReporter.report(parent.getSourceLocation(),INVALID_LOCATION_FOR_CONTROL_FLOW,overallName,""String_Node_Str"");
throw new AbortParsingBlockError();
case BEFORE_ATTRIBUTE_VALUE:
if (!willExactlyOneBranchExecuteOnce) {
errorReporter.report(parent.getSourceLocation(),CONDITIONAL_BLOCK_ISNT_GUARANTEED_TO_PRODUCE_ONE_ATTRIBUTE_VALUE,overallName);
}
if (willAtLeastOneBranchExecute && endingState == State.UNQUOTED_ATTRIBUTE_VALUE) {
context.addAttributeValuePart(parent);
context.setState(State.UNQUOTED_ATTRIBUTE_VALUE,endPoint);
}
 else {
context.setAttributeValue(parent);
if (willAtLeastOneBranchExecute && endingState == State.BEFORE_ATTRIBUTE_NAME) {
context.setState(State.BEFORE_ATTRIBUTE_NAME,endPoint);
}
}
break;
case UNQUOTED_ATTRIBUTE_VALUE:
case DOUBLE_QUOTED_ATTRIBUTE_VALUE:
case SINGLE_QUOTED_ATTRIBUTE_VALUE:
context.addAttributeValuePart(parent);
break;
case HTML_COMMENT:
case NONE:
case PCDATA:
case RCDATA_SCRIPT:
case RCDATA_STYLE:
case RCDATA_TEXTAREA:
case RCDATA_TITLE:
case XML_DECLARATION:
case CDATA:
case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:
case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:
break;
default :
throw new AssertionError(""String_Node_Str"" + startingState);
}
}",0.9758590308370044
29442,"void maybeFinishPendingAttribute(SourceLocation.Point currentPoint){
  if (hasUnquotedAttributeValueParts()) {
    createUnquotedAttributeValue(currentPoint);
  }
 else   if (hasQuotedAttributeValueParts()) {
    errorReporter.report(currentPoint.asLocation(filePath),FOUND_END_OF_ATTRIBUTE_STARTED_IN_ANOTHER_BLOCK);
    throw new AbortParsingBlockError();
  }
  if (attributeName != null) {
    createAttributeNode();
  }
}","void maybeFinishPendingAttribute(SourceLocation.Point currentPoint){
  if (hasUnquotedAttributeValueParts()) {
    createUnquotedAttributeValue(currentPoint);
  }
 else   if (hasQuotedAttributeValueParts()) {
    errorReporter.report(currentPoint.asLocation(filePath),FOUND_END_OF_ATTRIBUTE_STARTED_IN_ANOTHER_BLOCK);
    throw new AbortParsingBlockError();
  }
  if (attributeName != null) {
    SourceLocation location=attributeName.getSourceLocation();
    HtmlAttributeNode attribute;
    if (attributeValue != null) {
      attribute=new HtmlAttributeNode(nodeIdGen.genId(),location,checkNotNull(equalsSignLocation));
      location=location.extend(attributeValue.getSourceLocation());
      edits.addChild(attribute,attributeName);
      edits.addChild(attribute,attributeValue);
    }
 else {
      attribute=new HtmlAttributeNode(nodeIdGen.genId(),location,null);
      edits.addChild(attribute,attributeName);
    }
    attributeName=null;
    equalsSignLocation=null;
    attributeValue=null;
    directTagChildren.add(attribute);
    edits.remove(attribute);
  }
}",0.5533333333333333
29443,"/** 
 * Called to handle whitespace that was completely removed from a raw text node. 
 */
void handleJoinedWhitespace(SourceLocation.Point point,boolean atEndOfBlock){
switch (context.getState()) {
case UNQUOTED_ATTRIBUTE_VALUE:
    context.createUnquotedAttributeValue(point);
  return;
case AFTER_TAG_NAME_OR_ATTRIBUTE:
context.setState(State.BEFORE_ATTRIBUTE_NAME,point);
return;
case AFTER_ATTRIBUTE_NAME:
if (atEndOfBlock) {
context.setState(State.BEFORE_ATTRIBUTE_NAME,point);
return;
}
case BEFORE_ATTRIBUTE_VALUE:
case BEFORE_ATTRIBUTE_NAME:
case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:
case HTML_TAG_NAME:
case HTML_COMMENT:
case CDATA:
case NONE:
case SINGLE_QUOTED_ATTRIBUTE_VALUE:
case DOUBLE_QUOTED_ATTRIBUTE_VALUE:
case PCDATA:
case RCDATA_SCRIPT:
case RCDATA_STYLE:
case RCDATA_TEXTAREA:
case RCDATA_TITLE:
case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:
case XML_DECLARATION:
return;
}
throw new AssertionError();
}","/** 
 * Called to handle whitespace that was completely removed from a raw text node. 
 */
void handleJoinedWhitespace(SourceLocation.Point point,boolean atEndOfBlock){
switch (context.getState()) {
case UNQUOTED_ATTRIBUTE_VALUE:
    context.createUnquotedAttributeValue(point);
case AFTER_TAG_NAME_OR_ATTRIBUTE:
  context.setState(State.BEFORE_ATTRIBUTE_NAME,point);
return;
case AFTER_ATTRIBUTE_NAME:
if (atEndOfBlock) {
context.setState(State.BEFORE_ATTRIBUTE_NAME,point);
return;
}
case BEFORE_ATTRIBUTE_VALUE:
case BEFORE_ATTRIBUTE_NAME:
case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:
case HTML_TAG_NAME:
case HTML_COMMENT:
case CDATA:
case NONE:
case SINGLE_QUOTED_ATTRIBUTE_VALUE:
case DOUBLE_QUOTED_ATTRIBUTE_VALUE:
case PCDATA:
case RCDATA_SCRIPT:
case RCDATA_STYLE:
case RCDATA_TEXTAREA:
case RCDATA_TITLE:
case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:
case XML_DECLARATION:
return;
}
throw new AssertionError();
}",0.9934426229508196
29444,"/** 
 * Applies the given print directive to   {@code expr} and returns the result.
 * @param generator The CodeChunk generator to use.
 * @param expr The expression to apply the print directive to.
 * @param directive The print directive to apply.
 * @param args Print directive args, if any.
 */
public static CodeChunk.WithValue applyDirective(CodeChunk.Generator generator,CodeChunk.WithValue expr,SoyJsSrcPrintDirective directive,List<CodeChunk.WithValue> args){
  List<JsExpr> argExprs=Lists.transform(args,TO_JS_EXPR);
  JsExpr applied=directive.applyForJsSrc(expr.singleExprOrName(),argExprs);
  RequiresCollector.IntoImmutableSet collector=new RequiresCollector.IntoImmutableSet();
  expr.collectRequires(collector);
  boolean isSingleExpr=expr.isRepresentableAsSingleExpression();
  for (  CodeChunk.WithValue arg : args) {
    arg.collectRequires(collector);
    if (!arg.isRepresentableAsSingleExpression()) {
      isSingleExpr=false;
      break;
    }
  }
  if (directive instanceof SoyLibraryAssistedJsSrcPrintDirective) {
    for (    String name : ((SoyLibraryAssistedJsSrcPrintDirective)directive).getRequiredJsLibNames()) {
      collector.add(GoogRequire.create(name));
    }
  }
  return isSingleExpr ? fromExpr(applied,collector.get()) : generator.newChunk().statement(expr).statements(args).assign(fromExpr(applied,collector.get())).buildAsValue();
}","/** 
 * Applies the given print directive to   {@code expr} and returns the result.
 * @param generator The CodeChunk generator to use.
 * @param expr The expression to apply the print directive to.
 * @param directive The print directive to apply.
 * @param args Print directive args, if any.
 */
public static CodeChunk.WithValue applyDirective(CodeChunk.Generator generator,CodeChunk.WithValue expr,SoyJsSrcPrintDirective directive,List<CodeChunk.WithValue> args){
  List<JsExpr> argExprs=Lists.transform(args,TO_JS_EXPR);
  JsExpr applied=directive.applyForJsSrc(expr.singleExprOrName(),argExprs);
  RequiresCollector.IntoImmutableSet collector=new RequiresCollector.IntoImmutableSet();
  expr.collectRequires(collector);
  boolean isSingleExpr=expr.isRepresentableAsSingleExpression();
  for (  CodeChunk.WithValue arg : args) {
    arg.collectRequires(collector);
    if (!arg.isRepresentableAsSingleExpression()) {
      isSingleExpr=false;
    }
  }
  if (directive instanceof SoyLibraryAssistedJsSrcPrintDirective) {
    for (    String name : ((SoyLibraryAssistedJsSrcPrintDirective)directive).getRequiredJsLibNames()) {
      collector.add(GoogRequire.create(name));
    }
  }
  return isSingleExpr ? fromExpr(applied,collector.get()) : generator.newChunk().statement(expr).statements(args).assign(fromExpr(applied,collector.get())).buildAsValue();
}",0.9952468007312614
29445,"/** 
 * A helper method that compare two   {@code HtmlTagEntry}s. 
 */
public static boolean matchOrError(@Nullable HtmlTagEntry openTag,@Nullable HtmlTagEntry closeTag,ErrorReporter errorReporter){
  if (openTag == null && closeTag == null) {
    return true;
  }
  if (openTag == null && closeTag != null) {
    errorReporter.report(closeTag.getSourceLocation(),UNEXPECTED_CLOSE_TAG);
    return false;
  }
  if (openTag != null && closeTag == null) {
    errorReporter.report(openTag.getSourceLocation(),OPEN_TAG_NOT_CLOSED);
    return false;
  }
  if (openTag.hasTagName() != closeTag.hasTagName()) {
    boolean matchCommonPrefix=false;
    if (openTag.hasTagName()) {
      TagName openTagName=openTag.getTagName();
      if (closeTag.getBranches().hasCommonPrefix(openTagName)) {
        closeTag.getBranches().popAllBranches();
        matchCommonPrefix=true;
        if (!closeTag.getBranches().isEmpty()) {
          matchCommonPrefix=false;
          errorReporter.report(closeTag.getSourceLocation(),UNEXPECTED_CLOSE_TAG_WITH_EXPECTATION,openTagName.getStaticTagNameAsLowerCase().get());
        }
      }
 else {
        errorReporter.report(openTagName.getTagLocation(),OPEN_TAG_NOT_CLOSED);
      }
    }
 else {
      TagName closeTagName=closeTag.getTagName();
      if (openTag.getBranches().hasCommonPrefix(closeTagName)) {
        openTag.getBranches().popAllBranches();
        matchCommonPrefix=true;
        if (!openTag.getBranches().isEmpty()) {
          matchCommonPrefix=false;
          errorReporter.report(openTag.getSourceLocation(),OPEN_TAG_NOT_CLOSED);
        }
      }
 else {
        errorReporter.report(closeTagName.getTagLocation(),UNEXPECTED_CLOSE_TAG);
      }
    }
    return matchCommonPrefix;
  }
  if (openTag.hasTagName()) {
    return matchOrError(openTag.getTagName(),closeTag.getTagName(),errorReporter);
  }
 else {
    List<ConditionalBranches.ConditionalBranch> openBranches=openTag.getBranches().getBranches();
    List<ConditionalBranches.ConditionalBranch> closeBranches=closeTag.getBranches().getBranches();
    SourceLocation location=closeTag.getSourceLocation();
    if (openBranches.size() != closeBranches.size()) {
      errorReporter.report(location,MISMATCH_TAG);
      return false;
    }
    for (int i=0; i < openBranches.size(); ++i) {
      ConditionalBranches.ConditionalBranch openBranch=openBranches.get(i);
      ConditionalBranches.ConditionalBranch closeBranch=closeBranches.get(i);
      if (!openBranch.condition().equals(closeBranch.condition())) {
        errorReporter.report(location,MISMATCH_TAG);
        return false;
      }
      ArrayDeque<HtmlTagEntry> openStack=openBranch.deque();
      ArrayDeque<HtmlTagEntry> closeQueue=closeBranch.deque();
      while (!openStack.isEmpty() && !closeQueue.isEmpty()) {
        if (!closeQueue.peekFirst().isDefinitelyOptional() && openStack.peekFirst().isDefinitelyOptional()) {
          openStack.pollFirst();
          continue;
        }
        if (!matchOrError(openStack.pollFirst(),closeQueue.pollFirst(),errorReporter)) {
          return false;
        }
      }
    }
    return true;
  }
}","/** 
 * A helper method that compare two   {@code HtmlTagEntry}s. 
 */
public static boolean matchOrError(@Nullable HtmlTagEntry openTag,@Nullable HtmlTagEntry closeTag,ErrorReporter errorReporter){
  if (openTag == null && closeTag == null) {
    return true;
  }
  if (openTag == null && closeTag != null) {
    errorReporter.report(closeTag.getSourceLocation(),UNEXPECTED_CLOSE_TAG);
    return false;
  }
  if (openTag != null && closeTag == null) {
    errorReporter.report(openTag.getSourceLocation(),OPEN_TAG_NOT_CLOSED);
    return false;
  }
  if (openTag.hasTagName() != closeTag.hasTagName()) {
    boolean matchCommonPrefix=false;
    if (openTag.hasTagName()) {
      TagName openTagName=openTag.getTagName();
      if (closeTag.getBranches().hasCommonPrefix(openTagName)) {
        closeTag.getBranches().popAllBranches();
        matchCommonPrefix=true;
        if (!closeTag.getBranches().isEmpty()) {
          matchCommonPrefix=false;
          errorReporter.report(closeTag.getSourceLocation(),UNEXPECTED_CLOSE_TAG_WITH_EXPECTATION,openTagName.getStaticTagNameAsLowerCase().get());
        }
      }
 else {
        errorReporter.report(openTagName.getTagLocation(),OPEN_TAG_NOT_CLOSED);
      }
    }
 else {
      TagName closeTagName=closeTag.getTagName();
      if (openTag.getBranches().hasCommonPrefix(closeTagName)) {
        openTag.getBranches().popAllBranches();
        matchCommonPrefix=true;
        if (!openTag.getBranches().isEmpty()) {
          matchCommonPrefix=false;
          errorReporter.report(openTag.getSourceLocation(),OPEN_TAG_NOT_CLOSED);
        }
      }
 else {
        errorReporter.report(closeTagName.getTagLocation(),UNEXPECTED_CLOSE_TAG);
      }
    }
    return matchCommonPrefix;
  }
  if (openTag.hasTagName()) {
    return matchOrError(openTag.getTagName(),closeTag.getTagName(),errorReporter);
  }
 else {
    List<ConditionalBranches.ConditionalBranch> openBranches=openTag.getBranches().getBranches();
    List<ConditionalBranches.ConditionalBranch> closeBranches=closeTag.getBranches().getBranches();
    SourceLocation location=closeTag.getSourceLocation();
    if (openBranches.size() != closeBranches.size()) {
      errorReporter.report(location,MISMATCH_TAG);
      return false;
    }
    for (int i=0; i < openBranches.size(); ++i) {
      ConditionalBranches.ConditionalBranch openBranch=openBranches.get(i);
      ConditionalBranches.ConditionalBranch closeBranch=closeBranches.get(i);
      if (!openBranch.condition().equals(closeBranch.condition())) {
        errorReporter.report(location,MISMATCH_TAG);
        return false;
      }
      ArrayDeque<HtmlTagEntry> openStack=openBranch.deque();
      ArrayDeque<HtmlTagEntry> closeQueue=closeBranch.deque();
      while (!openStack.isEmpty() && !closeQueue.isEmpty()) {
        if (!closeQueue.peekFirst().isDefinitelyOptional() && openStack.peekFirst().isDefinitelyOptional()) {
          openStack.pollFirst();
          continue;
        }
        if (!matchOrError(openStack.pollFirst(),closeQueue.pollFirst(),errorReporter)) {
          return false;
        }
      }
      if (openStack.isEmpty() && closeQueue.isEmpty()) {
        continue;
      }
 else       if (openStack.isEmpty()) {
        errorReporter.report(closeQueue.pollFirst().getSourceLocation(),UNEXPECTED_CLOSE_TAG);
        return false;
      }
 else {
        errorReporter.report(openStack.pollFirst().getSourceLocation(),OPEN_TAG_NOT_CLOSED);
        return false;
      }
    }
    return true;
  }
}",0.9382530120481928
29446,"/** 
 * Eats all whitespace from the input prefix. Returns   {@code true} if we matched any whitespacecharacters.
 */
boolean consumeWhitespace(){
  int startIndex=currentRawTextIndex;
  advanceWhileMatches(CharMatcher.whitespace());
  consume();
  return currentRawTextIndex != startIndex;
}","/** 
 * Eats all whitespace from the input prefix. Returns   {@code true} if we matched any whitespacecharacters.
 */
boolean consumeWhitespace(){
  int startIndex=currentRawTextIndex;
  advanceWhileMatches(CharMatcher.whitespace());
  consume();
  edits.remove(currentRawTextNode);
  return currentRawTextIndex != startIndex;
}",0.9419354838709676
29447,"@VisibleForTesting public HtmlRewritePass(ImmutableList<String> experimentalFeatures,ErrorReporter errorReporter){
  this.enabled=experimentalFeatures.contains(""String_Node_Str"");
  this.errorReporter=errorReporter;
}","public HtmlRewritePass(ImmutableList<String> experimentalFeatures,ErrorReporter errorReporter){
  this.enabled=experimentalFeatures.contains(""String_Node_Str"");
  this.errorReporter=errorReporter;
}",0.9542168674698795
29448,"/** 
 * Apply all edits. 
 */
void apply(){
  for (  StandaloneNode nodeToRemove : toRemove) {
    BlockNode parent=nodeToRemove.getParent();
    List<StandaloneNode> children=replacements.get(nodeToRemove);
    if (!children.isEmpty()) {
      parent.addChildren(parent.getChildIndex(nodeToRemove),children);
    }
    parent.removeChild(nodeToRemove);
  }
  for (  Map.Entry<BlockNode,List<StandaloneNode>> entry : asMap(newChildren).entrySet()) {
    entry.getKey().addChildren(entry.getValue());
  }
  clear();
}","/** 
 * Apply all edits. 
 */
void apply(){
  for (  StandaloneNode nodeToRemove : toRemove) {
    BlockNode parent=nodeToRemove.getParent();
    int index=parent.getChildIndex(nodeToRemove);
    parent.removeChild(index);
    List<StandaloneNode> children=replacements.get(nodeToRemove);
    if (!children.isEmpty()) {
      parent.addChildren(index,children);
    }
  }
  for (  Map.Entry<BlockNode,List<StandaloneNode>> entry : asMap(newChildren).entrySet()) {
    entry.getKey().addChildren(entry.getValue());
  }
  clear();
}",0.8565965583173997
29449,"@Test public void testConditionalQuotedAttributeValues(){
  TemplateNode node=runPass(""String_Node_Str"");
  assertThatSourceString(node).isEqualTo(""String_Node_Str"");
  assertThatASTString(node).isEqualTo(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  node=runPass(""String_Node_Str"" + ""String_Node_Str"");
  assertThatSourceString(node).isEqualTo(""String_Node_Str"" + ""String_Node_Str"");
  assertThatASTString(node).isEqualTo(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","@Test public void testConditionalQuotedAttributeValues(){
  TemplateNode node=runPass(""String_Node_Str"");
  assertThatSourceString(node).isEqualTo(""String_Node_Str"");
  assertThatASTString(node).isEqualTo(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  node=runPass(""String_Node_Str"" + ""String_Node_Str"");
  assertThatSourceString(node).isEqualTo(""String_Node_Str"" + ""String_Node_Str"");
  assertThatASTString(node).isEqualTo(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9831410825199643
29450,"/** 
 * Handle immediately after an attribute name. <p>Look for an '=' sign to signal the presence of an attribute value
 */
void handleAfterAttributeName(){
  boolean ws=consumeWhitespace();
  int current=currentChar();
  if (current == '=') {
    SourceLocation.Point equalsSignPoint=currentPoint();
    advance();
    consume();
    consumeWhitespace();
    context.setEqualsSignLocation(equalsSignPoint,currentPointOrEnd());
  }
 else {
    context.createAttributeNode();
    if (ws) {
      context.setState(State.BEFORE_ATTRIBUTE_NAME,currentPointOrEnd());
    }
  }
}","/** 
 * Handle immediately after an attribute name. <p>Look for an '=' sign to signal the presence of an attribute value
 */
void handleAfterAttributeName(){
  boolean ws=consumeWhitespace();
  int current=currentChar();
  if (current == '=') {
    SourceLocation.Point equalsSignPoint=currentPoint();
    advance();
    consume();
    consumeWhitespace();
    context.setEqualsSignLocation(equalsSignPoint,currentPointOrEnd());
  }
 else {
    context.setState(ws ? State.BEFORE_ATTRIBUTE_NAME : State.AFTER_TAG_NAME_OR_ATTRIBUTE,currentPointOrEnd());
  }
}",0.9028268551236748
29451,"/** 
 * Handle immediately before an attribute value. <p>Look for a quote character to signal the beginning of a quoted attribute value or switch to UNQUOTED_ATTRIBUTE_VALUE to handle that.
 */
void handleBeforeAttributeValue(){
  int c=currentChar();
  if (c == '\'' || c == '""') {
    SourceLocation.Point quotePoint=currentPoint();
    context.startQuotedAttributeValue(currentRawTextNode,quotePoint,c == '""' ? State.DOUBLE_QUOTED_ATTRIBUTE_VALUE : State.SINGLE_QUOTED_ATTRIBUTE_VALUE);
    advance();
    consume();
  }
 else {
    context.setState(State.UNQUOTED_ATTRIBUTE_VALUE,currentPoint());
  }
}","/** 
 * Handle immediately before an attribute value. <p>Look for a quote character to signal the beginning of a quoted attribute value or switch to UNQUOTED_ATTRIBUTE_VALUE to handle that.
 */
void handleBeforeAttributeValue(){
  boolean ws=consumeWhitespace();
  if (ws) {
    return;
  }
  int c=currentChar();
  if (c == '\'' || c == '""') {
    SourceLocation.Point quotePoint=currentPoint();
    context.startQuotedAttributeValue(currentRawTextNode,quotePoint,c == '""' ? State.DOUBLE_QUOTED_ATTRIBUTE_VALUE : State.SINGLE_QUOTED_ATTRIBUTE_VALUE);
    advance();
    consume();
  }
 else {
    context.setState(State.UNQUOTED_ATTRIBUTE_VALUE,currentPoint());
  }
}",0.9513343799058084
29452,"/** 
 * Called to handle whitespace that was completely removed from a raw text node. 
 */
void handleJoinedWhitespace(SourceLocation.Point point){
switch (context.getState()) {
case UNQUOTED_ATTRIBUTE_VALUE:
    context.createUnquotedAttributeValue(point);
  return;
case AFTER_TAG_NAME_OR_ATTRIBUTE:
context.setState(State.BEFORE_ATTRIBUTE_NAME,point);
return;
case BEFORE_ATTRIBUTE_VALUE:
case BEFORE_ATTRIBUTE_NAME:
case AFTER_ATTRIBUTE_NAME:
case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:
case HTML_TAG_NAME:
case HTML_COMMENT:
case CDATA:
case NONE:
case SINGLE_QUOTED_ATTRIBUTE_VALUE:
case DOUBLE_QUOTED_ATTRIBUTE_VALUE:
case PCDATA:
case RCDATA_SCRIPT:
case RCDATA_STYLE:
case RCDATA_TEXTAREA:
case RCDATA_TITLE:
case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:
case XML_DECLARATION:
return;
}
throw new AssertionError();
}","/** 
 * Called to handle whitespace that was completely removed from a raw text node. 
 */
void handleJoinedWhitespace(SourceLocation.Point point,boolean atEndOfBlock){
switch (context.getState()) {
case UNQUOTED_ATTRIBUTE_VALUE:
    context.createUnquotedAttributeValue(point);
  return;
case AFTER_TAG_NAME_OR_ATTRIBUTE:
context.setState(State.BEFORE_ATTRIBUTE_NAME,point);
return;
case AFTER_ATTRIBUTE_NAME:
if (atEndOfBlock) {
context.setState(State.BEFORE_ATTRIBUTE_NAME,point);
return;
}
case BEFORE_ATTRIBUTE_VALUE:
case BEFORE_ATTRIBUTE_NAME:
case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:
case HTML_TAG_NAME:
case HTML_COMMENT:
case CDATA:
case NONE:
case SINGLE_QUOTED_ATTRIBUTE_VALUE:
case DOUBLE_QUOTED_ATTRIBUTE_VALUE:
case PCDATA:
case RCDATA_SCRIPT:
case RCDATA_STYLE:
case RCDATA_TEXTAREA:
case RCDATA_TITLE:
case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:
case XML_DECLARATION:
return;
}
throw new AssertionError();
}",0.9065743944636678
29453,"/** 
 * Handle unquoted attribute values. <p>Search for whitespace or the end of the tag as a delimiter.
 */
void handleUnquotedAttributeValue(){
  boolean foundDelimiter=advanceWhileMatches(TAG_RAW_TEXT_MATCHER);
  RawTextNode node=consumeAsRawText();
  if (node != null) {
    int badCharIndex=BAD_UNQUOTED_ATTRIBUTE_CHARACTER_MATCHER.indexIn(node.getRawText());
    if (badCharIndex != -1) {
      errorReporter.report(node.substringLocation(badCharIndex,badCharIndex + 1),ILLEGAL_HTML_ATTRIBUTE_CHARACTER);
    }
    context.addAttributeValuePart(node);
  }
  if (foundDelimiter) {
    context.createUnquotedAttributeValue(currentPoint());
  }
}","/** 
 * Handle unquoted attribute values. <p>Search for whitespace or the end of the tag as a delimiter.
 */
void handleUnquotedAttributeValue(){
  boolean foundDelimiter=advanceWhileMatches(UNQUOTED_ATTRIBUTE_VALUE_MATCHER);
  RawTextNode node=consumeAsRawText();
  if (node != null) {
    context.addAttributeValuePart(node);
  }
  if (foundDelimiter) {
    context.createUnquotedAttributeValue(currentPoint());
    char c=(char)currentChar();
    if (!UNQUOTED_ATTRIBUTE_VALUE_DELIMITER.matches(c)) {
      errorReporter.report(currentLocation(),ILLEGAL_HTML_ATTRIBUTE_CHARACTER);
      advance();
      consume();
    }
  }
}",0.4913928012519561
29454,"/** 
 * Handle   {@link State#XML_DECLARATION}. <p>This is for things like   {@code <!DOCTYPE HTML PUBLIC""http://www.w3.org/TR/html4/strict.dtd"">}. . We are looking for the end or a quoted 'attribute'.
 */
void handleXmlDeclaration(){
  boolean foundDelimiter=advanceWhileMatches(XML_DECLARATION_NON_DELIMITERS);
  if (foundDelimiter) {
    int c=currentChar();
    advance();
    if (c == '""') {
      context.setState(State.DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE,currentPoint());
    }
 else     if (c == '\'') {
      context.setState(State.SINGLE_QUOTED_XML_ATTRIBUTE_VALUE,currentPoint());
    }
 else     if (c == '>') {
      context.setState(State.PCDATA,currentPoint());
    }
 else {
      throw new AssertionError(""String_Node_Str"" + c);
    }
  }
}","/** 
 * Handle   {@link State#XML_DECLARATION}. <p>This is for things like   {@code <!DOCTYPE HTML PUBLIC""http://www.w3.org/TR/html4/strict.dtd"">}. . We are looking for the end or a quoted 'attribute'.
 */
void handleXmlDeclaration(){
  boolean foundDelimiter=advanceWhileMatches(XML_DECLARATION_NON_DELIMITERS);
  if (foundDelimiter) {
    int c=currentChar();
    SourceLocation.Point currentPoint=currentPoint();
    advance();
    if (c == '""') {
      context.setState(State.DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE,currentPoint);
    }
 else     if (c == '\'') {
      context.setState(State.SINGLE_QUOTED_XML_ATTRIBUTE_VALUE,currentPoint);
    }
 else     if (c == '>') {
      context.setState(State.PCDATA,currentPoint);
    }
 else {
      throw new AssertionError(""String_Node_Str"" + c);
    }
  }
}",0.9614890885750964
29455,"/** 
 * For RawText we need to examine every character. <p>We track an index and an offset into the current RawTextNode (currentRawTextIndex and currentRawTextOffset respectively). 'advance' methods move the index and 'consume' methods optionally move the index and always set the offset == index. (they 'consume' the text between the offset and the index. <p>handle* methods will 'handle the current state' <ul> <li>Precondition : They are in the given state and not at the end of the input <li> Postcondition: They have either advanced the current index or changed states (generally both) </ul> <p>NOTE: a consequence of these conditions is that they are only guaranteed to be able to consume a single character. <p>At the end of visiting a raw text node, all the input will be consumed.
 */
@Override protected void visitRawTextNode(RawTextNode node){
  currentRawTextNode=node;
  currentRawText=node.getRawText();
  currentRawTextOffset=0;
  currentRawTextIndex=0;
  while (currentRawTextIndex < currentRawText.length()) {
    int startIndex=currentRawTextIndex;
    if (currentRawTextNode.missingWhitespaceAt(startIndex)) {
      handleJoinedWhitespace(currentPoint());
    }
    State startState=context.getState();
switch (startState) {
case NONE:
      currentRawTextIndex=currentRawTextOffset=currentRawText.length();
    break;
case PCDATA:
  handlePcData();
break;
case DOUBLE_QUOTED_ATTRIBUTE_VALUE:
handleQuotedAttributeValue(true);
break;
case SINGLE_QUOTED_ATTRIBUTE_VALUE:
handleQuotedAttributeValue(false);
break;
case BEFORE_ATTRIBUTE_VALUE:
handleBeforeAttributeValue();
break;
case AFTER_TAG_NAME_OR_ATTRIBUTE:
handleAfterTagNameOrAttribute();
break;
case BEFORE_ATTRIBUTE_NAME:
handleBeforeAttributeName();
break;
case UNQUOTED_ATTRIBUTE_VALUE:
handleUnquotedAttributeValue();
break;
case AFTER_ATTRIBUTE_NAME:
handleAfterAttributeName();
break;
case HTML_TAG_NAME:
handleHtmlTagName();
break;
case RCDATA_STYLE:
handleRcData(TagName.SpecialTagName.STYLE);
break;
case RCDATA_TITLE:
handleRcData(TagName.SpecialTagName.TITLE);
break;
case RCDATA_SCRIPT:
handleRcData(TagName.SpecialTagName.SCRIPT);
break;
case RCDATA_TEXTAREA:
handleRcData(TagName.SpecialTagName.TEXTAREA);
break;
case CDATA:
handleCData();
break;
case HTML_COMMENT:
handleHtmlComment();
break;
case XML_DECLARATION:
handleXmlDeclaration();
break;
case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:
handleXmlAttributeQuoted(true);
break;
case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:
handleXmlAttributeQuoted(false);
break;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + startState);
}
if (context.getState() == startState && startIndex == currentRawTextIndex) {
throw new IllegalStateException(""String_Node_Str"" + startState.name() + ""String_Node_Str""+ currentLocation());
}
if (currentRawTextOffset > currentRawTextIndex) {
throw new IllegalStateException(""String_Node_Str"" + currentRawTextOffset + ""String_Node_Str""+ currentRawTextIndex);
}
}
if (currentRawTextIndex != currentRawText.length()) {
throw new AssertionError(""String_Node_Str"");
}
if (currentRawTextOffset < currentRawTextIndex && currentRawTextOffset != 0) {
RawTextNode suffix=consumeAsRawText();
edits.replace(node,suffix);
}
if (currentRawTextNode.missingWhitespaceAt(currentRawText.length())) {
handleJoinedWhitespace(currentRawTextNode.getSourceLocation().getEndPoint());
}
}","/** 
 * For RawText we need to examine every character. <p>We track an index and an offset into the current RawTextNode (currentRawTextIndex and currentRawTextOffset respectively). 'advance' methods move the index and 'consume' methods optionally move the index and always set the offset == index. (they 'consume' the text between the offset and the index. <p>handle* methods will 'handle the current state' <ul> <li>Precondition : They are in the given state and not at the end of the input <li> Postcondition: They have either advanced the current index or changed states (generally both) </ul> <p>NOTE: a consequence of these conditions is that they are only guaranteed to be able to consume a single character. <p>At the end of visiting a raw text node, all the input will be consumed.
 */
@Override protected void visitRawTextNode(RawTextNode node){
  currentRawTextNode=node;
  currentRawText=node.getRawText();
  currentRawTextOffset=0;
  currentRawTextIndex=0;
  while (currentRawTextIndex < currentRawText.length()) {
    int startIndex=currentRawTextIndex;
    if (currentRawTextNode.missingWhitespaceAt(startIndex)) {
      handleJoinedWhitespace(currentPoint(),false);
    }
    State startState=context.getState();
switch (startState) {
case NONE:
      currentRawTextIndex=currentRawTextOffset=currentRawText.length();
    break;
case PCDATA:
  handlePcData();
break;
case DOUBLE_QUOTED_ATTRIBUTE_VALUE:
handleQuotedAttributeValue(true);
break;
case SINGLE_QUOTED_ATTRIBUTE_VALUE:
handleQuotedAttributeValue(false);
break;
case BEFORE_ATTRIBUTE_VALUE:
handleBeforeAttributeValue();
break;
case AFTER_TAG_NAME_OR_ATTRIBUTE:
handleAfterTagNameOrAttribute();
break;
case BEFORE_ATTRIBUTE_NAME:
handleBeforeAttributeName();
break;
case UNQUOTED_ATTRIBUTE_VALUE:
handleUnquotedAttributeValue();
break;
case AFTER_ATTRIBUTE_NAME:
handleAfterAttributeName();
break;
case HTML_TAG_NAME:
handleHtmlTagName();
break;
case RCDATA_STYLE:
handleRcData(TagName.SpecialTagName.STYLE);
break;
case RCDATA_TITLE:
handleRcData(TagName.SpecialTagName.TITLE);
break;
case RCDATA_SCRIPT:
handleRcData(TagName.SpecialTagName.SCRIPT);
break;
case RCDATA_TEXTAREA:
handleRcData(TagName.SpecialTagName.TEXTAREA);
break;
case CDATA:
handleCData();
break;
case HTML_COMMENT:
handleHtmlComment();
break;
case XML_DECLARATION:
handleXmlDeclaration();
break;
case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:
handleXmlAttributeQuoted(true);
break;
case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:
handleXmlAttributeQuoted(false);
break;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + startState);
}
if (context.getState() == startState && startIndex == currentRawTextIndex) {
throw new IllegalStateException(""String_Node_Str"" + startState.name() + ""String_Node_Str""+ currentLocation());
}
if (currentRawTextOffset > currentRawTextIndex) {
throw new IllegalStateException(""String_Node_Str"" + currentRawTextOffset + ""String_Node_Str""+ currentRawTextIndex);
}
}
if (currentRawTextIndex != currentRawText.length()) {
throw new AssertionError(""String_Node_Str"");
}
if (currentRawTextOffset < currentRawTextIndex && currentRawTextOffset != 0) {
RawTextNode suffix=consumeAsRawText();
edits.replace(node,suffix);
}
if (currentRawTextNode.missingWhitespaceAt(currentRawText.length())) {
handleJoinedWhitespace(currentRawTextNode.getSourceLocation().getEndPoint(),true);
}
}",0.9983569828230022
29456,"@Test public void testAttributes(){
  TemplateNode node=runPass(""String_Node_Str"");
  assertThatSourceString(node).isEqualTo(""String_Node_Str"");
  String structure=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  assertThatASTString(node).isEqualTo(structure);
  node=runPass(""String_Node_Str"");
  assertThatSourceString(node).isEqualTo(""String_Node_Str"");
  assertThatASTString(node).isEqualTo(structure);
  node=runPass(""String_Node_Str"");
  assertThatSourceString(node).isEqualTo(""String_Node_Str"");
  assertThatASTString(node).isEqualTo(structure);
}","@Test public void testAttributes(){
  TemplateNode node=runPass(""String_Node_Str"");
  assertThatSourceString(node).isEqualTo(""String_Node_Str"");
  String structure=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  assertThatASTString(node).isEqualTo(structure);
  node=runPass(""String_Node_Str"");
  assertThatSourceString(node).isEqualTo(""String_Node_Str"");
  assertThatASTString(node).isEqualTo(structure);
  node=runPass(""String_Node_Str"");
  assertThatSourceString(node).isEqualTo(""String_Node_Str"");
  assertThatASTString(node).isEqualTo(structure);
  node=runPass(""String_Node_Str"");
  assertThatSourceString(node).isEqualTo(""String_Node_Str"");
  HtmlOpenTagNode openTag=(HtmlOpenTagNode)node.getChild(1);
  assertThat(openTag.isSelfClosing()).isFalse();
  HtmlAttributeValueNode attributeValue=(HtmlAttributeValueNode)((HtmlAttributeNode)openTag.getChild(0)).getChild(1);
  assertThat(attributeValue.getQuotes()).isEqualTo(HtmlAttributeValueNode.Quotes.NONE);
  assertThat(((RawTextNode)attributeValue.getChild(0)).getRawText()).isEqualTo(""String_Node_Str"");
}",0.7153203342618384
29457,"/** 
 * For RawText we need to examine every character. <p>We track an index and an offset into the current RawTextNode (currentRawTextIndex and currentRawTextOffset respectively). 'advance' methods move the index and 'consume' methods optionally move the index and always set the offset == index. (they 'consume' the text between the offset and the index. <p>handle* methods will 'handle the current state' <ul> <li>Precondition : They are in the given state and not at the end of the input <li> Postcondition: They have either advanced the current index or changed states (generally both) </ul> <p>NOTE: a consequence of these conditions is that they are only guaranteed to be able to consume a single character. <p>At the end of visiting a raw text node, all the input will be consumed.
 */
@Override protected void visitRawTextNode(RawTextNode node){
  currentRawTextNode=node;
  currentRawText=node.getRawText();
  currentRawTextOffset=0;
  currentRawTextIndex=0;
  while (currentRawTextIndex < currentRawText.length()) {
    int startIndex=currentRawTextIndex;
    if (currentRawTextNode.missingWhitespaceAt(startIndex)) {
      handleJoinedWhitespace(currentPoint(),false);
    }
    State startState=context.getState();
switch (startState) {
case NONE:
      currentRawTextIndex=currentRawTextOffset=currentRawText.length();
    break;
case PCDATA:
  handlePcData();
break;
case DOUBLE_QUOTED_ATTRIBUTE_VALUE:
handleQuotedAttributeValue(true);
break;
case SINGLE_QUOTED_ATTRIBUTE_VALUE:
handleQuotedAttributeValue(false);
break;
case BEFORE_ATTRIBUTE_VALUE:
handleBeforeAttributeValue();
break;
case AFTER_TAG_NAME_OR_ATTRIBUTE:
handleAfterTagNameOrAttribute();
break;
case BEFORE_ATTRIBUTE_NAME:
handleBeforeAttributeName();
break;
case UNQUOTED_ATTRIBUTE_VALUE:
handleUnquotedAttributeValue();
break;
case AFTER_ATTRIBUTE_NAME:
handleAfterAttributeName();
break;
case HTML_TAG_NAME:
handleHtmlTagName();
break;
case RCDATA_STYLE:
handleRcData(TagName.SpecialTagName.STYLE);
break;
case RCDATA_TITLE:
handleRcData(TagName.SpecialTagName.TITLE);
break;
case RCDATA_SCRIPT:
handleRcData(TagName.SpecialTagName.SCRIPT);
break;
case RCDATA_TEXTAREA:
handleRcData(TagName.SpecialTagName.TEXTAREA);
break;
case CDATA:
handleCData();
break;
case HTML_COMMENT:
handleHtmlComment();
break;
case XML_DECLARATION:
handleXmlDeclaration();
break;
case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:
handleXmlAttributeQuoted(true);
break;
case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:
handleXmlAttributeQuoted(false);
break;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + startState);
}
if (context.getState() == startState && startIndex == currentRawTextIndex) {
throw new IllegalStateException(""String_Node_Str"" + startState.name() + ""String_Node_Str""+ currentLocation());
}
if (currentRawTextOffset > currentRawTextIndex) {
throw new IllegalStateException(""String_Node_Str"" + currentRawTextOffset + ""String_Node_Str""+ currentRawTextIndex);
}
}
if (currentRawTextIndex != currentRawText.length()) {
throw new AssertionError(""String_Node_Str"");
}
if (currentRawTextOffset < currentRawTextIndex && currentRawTextOffset != 0) {
RawTextNode suffix=consumeAsRawText();
edits.replace(node,suffix);
}
if (currentRawTextNode.missingWhitespaceAt(currentRawText.length())) {
handleJoinedWhitespace(currentRawTextNode.getSourceLocation().getEndPoint(),true);
}
}","/** 
 * For RawText we need to examine every character. <p>We track an index and an offset into the current RawTextNode (currentRawTextIndex and currentRawTextOffset respectively). 'advance' methods move the index and 'consume' methods optionally move the index and always set the offset == index. (they 'consume' the text between the offset and the index. <p>handle* methods will 'handle the current state' <ul> <li>Precondition : They are in the given state and not at the end of the input <li> Postcondition: They have either advanced the current index or changed states (generally both) </ul> <p>NOTE: a consequence of these conditions is that they are only guaranteed to be able to consume a single character. <p>At the end of visiting a raw text node, all the input will be consumed.
 */
@Override protected void visitRawTextNode(RawTextNode node){
  currentRawTextNode=node;
  currentRawText=node.getRawText();
  currentRawTextOffset=0;
  currentRawTextIndex=0;
  int prevStartIndex=-1;
  while (currentRawTextIndex < currentRawText.length()) {
    int startIndex=currentRawTextIndex;
    if (startIndex != prevStartIndex && currentRawTextNode.missingWhitespaceAt(startIndex)) {
      handleJoinedWhitespace(currentPoint(),false);
    }
    prevStartIndex=startIndex;
    State startState=context.getState();
switch (startState) {
case NONE:
      currentRawTextIndex=currentRawTextOffset=currentRawText.length();
    break;
case PCDATA:
  handlePcData();
break;
case DOUBLE_QUOTED_ATTRIBUTE_VALUE:
handleQuotedAttributeValue(true);
break;
case SINGLE_QUOTED_ATTRIBUTE_VALUE:
handleQuotedAttributeValue(false);
break;
case BEFORE_ATTRIBUTE_VALUE:
handleBeforeAttributeValue();
break;
case AFTER_TAG_NAME_OR_ATTRIBUTE:
handleAfterTagNameOrAttribute();
break;
case BEFORE_ATTRIBUTE_NAME:
handleBeforeAttributeName();
break;
case UNQUOTED_ATTRIBUTE_VALUE:
handleUnquotedAttributeValue();
break;
case AFTER_ATTRIBUTE_NAME:
handleAfterAttributeName();
break;
case HTML_TAG_NAME:
handleHtmlTagName();
break;
case RCDATA_STYLE:
handleRcData(TagName.SpecialTagName.STYLE);
break;
case RCDATA_TITLE:
handleRcData(TagName.SpecialTagName.TITLE);
break;
case RCDATA_SCRIPT:
handleRcData(TagName.SpecialTagName.SCRIPT);
break;
case RCDATA_TEXTAREA:
handleRcData(TagName.SpecialTagName.TEXTAREA);
break;
case CDATA:
handleCData();
break;
case HTML_COMMENT:
handleHtmlComment();
break;
case XML_DECLARATION:
handleXmlDeclaration();
break;
case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:
handleXmlAttributeQuoted(true);
break;
case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:
handleXmlAttributeQuoted(false);
break;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + startState);
}
if (context.getState() == startState && startIndex == currentRawTextIndex) {
throw new IllegalStateException(""String_Node_Str"" + startState.name() + ""String_Node_Str""+ currentLocation());
}
if (currentRawTextOffset > currentRawTextIndex) {
throw new IllegalStateException(""String_Node_Str"" + currentRawTextOffset + ""String_Node_Str""+ currentRawTextIndex);
}
}
if (currentRawTextIndex != currentRawText.length()) {
throw new AssertionError(""String_Node_Str"");
}
if (currentRawTextOffset < currentRawTextIndex && currentRawTextOffset != 0) {
RawTextNode suffix=consumeAsRawText();
edits.replace(node,suffix);
}
if (currentRawTextNode.missingWhitespaceAt(currentRawText.length())) {
handleJoinedWhitespace(currentRawTextNode.getSourceLocation().getEndPoint(),true);
}
}",0.9870473947600824
29458,"/** 
 * Returns true if this switch has a   {@code default} case. 
 */
public boolean hasDefaultCase(){
  return getChild(numChildren() - 1) instanceof SwitchDefaultNode;
}","/** 
 * Returns true if this switch has a   {@code default} case. 
 */
public boolean hasDefaultCase(){
  return numChildren() > 0 && getChild(numChildren() - 1) instanceof SwitchDefaultNode;
}",0.9424657534246575
29459,"void setAttributeValue(StandaloneNode node){
  checkNotNull(node);
  checkState(attributeValue == null);
  edits.remove(node);
  attributeValue=node;
  setState(State.AFTER_TAG_NAME_OR_ATTRIBUTE,node.getSourceLocation().getEndPoint());
}","void setAttributeValue(StandaloneNode node){
  checkNotNull(node);
  checkState(attributeValue == null,""String_Node_Str"",node.getSourceLocation());
  edits.remove(node);
  attributeValue=node;
  setState(State.AFTER_TAG_NAME_OR_ATTRIBUTE,node.getSourceLocation().getEndPoint());
}",0.9168278529980658
29460,"/** 
 * Resets parsing state, this is useful for error recovery. 
 */
void reset(){
  tagStartPoint=null;
  tagStartNode=null;
  tagName=null;
  directTagChildren.clear();
  resetAttribute();
  resetAttributeValue();
}","/** 
 * Resets all parsing state, this is useful for error recovery. 
 */
void reset(){
  tagStartPoint=null;
  tagStartNode=null;
  tagName=null;
  directTagChildren.clear();
  resetAttribute();
}",0.9301204819277108
29461,"void setEqualsSignLocation(SourceLocation.Point equalsSignPoint,SourceLocation.Point stateTransitionPoint){
  checkNotNull(equalsSignPoint);
  checkState(attributeName != null);
  checkState(equalsSignLocation == null);
  equalsSignLocation=equalsSignPoint;
  setState(State.BEFORE_ATTRIBUTE_VALUE,stateTransitionPoint);
}","void setEqualsSignLocation(SourceLocation.Point equalsSignPoint,SourceLocation.Point stateTransitionPoint){
  checkNotNull(equalsSignPoint);
  if (attributeName == null) {
    errorReporter.report(stateTransitionPoint.asLocation(filePath),FOUND_EQ_WITH_ATTRIBUTE_IN_ANOTHER_BLOCK);
    throw new AbortParsingBlockError();
  }
  checkState(equalsSignLocation == null);
  equalsSignLocation=equalsSignPoint;
  setState(State.BEFORE_ATTRIBUTE_VALUE,stateTransitionPoint);
}",0.5303030303030303
29462,"/** 
 * Visits a block and returns the finalState. 
 */
State visitBlock(State startState,BlockNode node,String blockName,Checkpoint checkpoint){
  visitChildren(node);
  context.finishBlock();
  State finalState=context.getState();
  SourceLocation.Point finalStateTransitionPoint=context.getStateTransitionPoint();
  if (finalState.isInvalidForEndOfBlock()) {
    errorReporter.report(node.getSourceLocation(),BLOCK_ENDS_IN_INVALID_STATE,blockName,finalState);
    finalState=startState;
  }
  if (!errorReporter.errorsSince(checkpoint)) {
    State reconciled=startState.reconcile(finalState);
    if (reconciled == null) {
      String suggestion=reconciliationFailureHint(startState,finalState);
      errorReporter.report(finalStateTransitionPoint.asLocation(filePath),BLOCK_CHANGES_CONTEXT,blockName,startState,finalState,suggestion != null ? ""String_Node_Str"" + suggestion : ""String_Node_Str"");
    }
 else {
      finalState=reconciled;
      reparentNodes(node,context,finalState);
    }
  }
 else {
    finalState=startState;
  }
  context.setState(finalState,node.getSourceLocation().getEndPoint());
  return finalState;
}","/** 
 * Visits a block and returns the finalState. 
 */
State visitBlock(State startState,BlockNode node,String blockName,Checkpoint checkpoint){
  try {
    visitChildren(node);
  }
 catch (  AbortParsingBlockError abortProcessingError) {
switch (startState) {
case AFTER_ATTRIBUTE_NAME:
case AFTER_TAG_NAME_OR_ATTRIBUTE:
case BEFORE_ATTRIBUTE_NAME:
case BEFORE_ATTRIBUTE_VALUE:
case SINGLE_QUOTED_ATTRIBUTE_VALUE:
case DOUBLE_QUOTED_ATTRIBUTE_VALUE:
case UNQUOTED_ATTRIBUTE_VALUE:
case HTML_TAG_NAME:
      context.resetAttribute();
    context.setState(State.BEFORE_ATTRIBUTE_NAME,node.getSourceLocation().getEndPoint());
  break;
case CDATA:
case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:
case HTML_COMMENT:
case NONE:
case PCDATA:
case RCDATA_SCRIPT:
case RCDATA_STYLE:
case RCDATA_TEXTAREA:
case RCDATA_TITLE:
case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:
case XML_DECLARATION:
context.reset();
context.setState(startState,node.getSourceLocation().getEndPoint());
break;
}
}
context.finishBlock();
State finalState=context.getState();
SourceLocation.Point finalStateTransitionPoint=context.getStateTransitionPoint();
if (finalState.isInvalidForEndOfBlock()) {
errorReporter.report(node.getSourceLocation(),BLOCK_ENDS_IN_INVALID_STATE,blockName,finalState);
finalState=startState;
}
if (!errorReporter.errorsSince(checkpoint)) {
State reconciled=startState.reconcile(finalState);
if (reconciled == null) {
String suggestion=reconciliationFailureHint(startState,finalState);
errorReporter.report(finalStateTransitionPoint.asLocation(filePath),BLOCK_CHANGES_CONTEXT,blockName,startState,finalState,suggestion != null ? ""String_Node_Str"" + suggestion : ""String_Node_Str"");
}
 else {
finalState=reconciled;
reparentNodes(node,context,finalState);
}
}
 else {
finalState=startState;
}
context.setState(finalState,node.getSourceLocation().getEndPoint());
return finalState;
}",0.7105175292153589
29463,"/** 
 * Attempts to finish the current tag, returns true if it did. 
 */
boolean tryCreateTagEnd(){
  int c=currentChar();
  if (c == '>') {
    if (context.hasTagStart()) {
      SourceLocation.Point point=currentPoint();
      context.setState(context.createTag(currentRawTextNode,false,point),point);
    }
 else {
      context.reset();
      errorReporter.report(currentLocation(),FOUND_END_TAG_STARTED_IN_ANOTHER_BLOCK);
    }
    advance();
    consume();
    return true;
  }
 else   if (matchPrefix(""String_Node_Str"",false)) {
    advance();
    if (context.hasTagStart()) {
      SourceLocation.Point point=currentPoint();
      context.setState(context.createTag(currentRawTextNode,true,point),point);
    }
 else {
      context.reset();
      errorReporter.report(currentLocation(),FOUND_END_TAG_STARTED_IN_ANOTHER_BLOCK);
    }
    advance();
    consume();
    return true;
  }
  return false;
}","/** 
 * Attempts to finish the current tag, returns true if it did. 
 */
boolean tryCreateTagEnd(){
  int c=currentChar();
  if (c == '>') {
    if (context.hasTagStart()) {
      SourceLocation.Point point=currentPoint();
      context.setState(context.createTag(currentRawTextNode,false,point),point);
    }
 else {
      errorReporter.report(currentLocation(),FOUND_END_TAG_STARTED_IN_ANOTHER_BLOCK);
      throw new AbortParsingBlockError();
    }
    advance();
    consume();
    return true;
  }
 else   if (matchPrefix(""String_Node_Str"",false)) {
    advance();
    if (context.hasTagStart()) {
      SourceLocation.Point point=currentPoint();
      context.setState(context.createTag(currentRawTextNode,true,point),point);
    }
 else {
      errorReporter.report(currentLocation(),FOUND_END_TAG_STARTED_IN_ANOTHER_BLOCK);
      throw new AbortParsingBlockError();
    }
    advance();
    consume();
    return true;
  }
  return false;
}",0.930032292787944
29464,"/** 
 * Visits a control flow structure like an if, switch or a loop. <p>The main thing this is responsible for is calculating what state to enter after the control flow is complete.
 * @param parent The parent node, each child will be a block representing one of the branches
 * @param children The child blocks. We don't use {@code parent.getChildren()} directly to makeit possible to handle ForNodes using this method.
 * @param overallName The name, for error reporting purposes, to assign to the control flowstructure
 * @param blockNamer A function to provide a name for each child block, the key is the index ofthe block
 * @param willExactlyOneBranchExecuteOnce Whether or not it is guaranteed that exactly onebranch of the structure will execute exactly one time.
 * @param willAtLeastOneBranchExecute Whether or not it is guaranteed that at least one of thebranches will execute (as opposed to no branches executing).
 */
void visitControlFlowStructure(StandaloneNode parent,List<? extends BlockNode> children,String overallName,Function<? super BlockNode,String> blockNamer,boolean willExactlyOneBranchExecuteOnce,boolean willAtLeastOneBranchExecute){
  if (children.isEmpty()) {
    return;
  }
  State startingState=context.getState();
  State endingState=visitBranches(children,blockNamer);
  SourceLocation.Point endPoint=parent.getSourceLocation().getEndPoint();
switch (startingState) {
case AFTER_TAG_NAME_OR_ATTRIBUTE:
case BEFORE_ATTRIBUTE_NAME:
case AFTER_ATTRIBUTE_NAME:
    context.addTagChild(parent);
  if (willAtLeastOneBranchExecute && endingState == State.BEFORE_ATTRIBUTE_NAME) {
    context.setState(State.BEFORE_ATTRIBUTE_NAME,endPoint);
  }
break;
case HTML_TAG_NAME:
errorReporter.report(parent.getSourceLocation(),INVALID_LOCATION_FOR_CONTROL_FLOW,overallName,""String_Node_Str"");
context.reset();
context.setState(State.PCDATA,parent.getSourceLocation().getBeginPoint());
break;
case BEFORE_ATTRIBUTE_VALUE:
if (!willExactlyOneBranchExecuteOnce) {
errorReporter.report(parent.getSourceLocation(),CONDITIONAL_BLOCK_ISNT_GUARANTEED_TO_PRODUCE_ONE_ATTRIBUTE_VALUE,overallName);
}
if (willAtLeastOneBranchExecute && endingState == State.UNQUOTED_ATTRIBUTE_VALUE) {
context.addAttributeValuePart(parent);
context.setState(State.UNQUOTED_ATTRIBUTE_VALUE,endPoint);
}
 else {
context.setAttributeValue(parent);
if (willAtLeastOneBranchExecute && endingState == State.BEFORE_ATTRIBUTE_NAME) {
context.setState(State.BEFORE_ATTRIBUTE_NAME,endPoint);
}
}
break;
case UNQUOTED_ATTRIBUTE_VALUE:
case DOUBLE_QUOTED_ATTRIBUTE_VALUE:
case SINGLE_QUOTED_ATTRIBUTE_VALUE:
context.addAttributeValuePart(parent);
break;
case HTML_COMMENT:
case NONE:
case PCDATA:
case RCDATA_SCRIPT:
case RCDATA_STYLE:
case RCDATA_TEXTAREA:
case RCDATA_TITLE:
case XML_DECLARATION:
case CDATA:
case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:
case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:
break;
default :
throw new AssertionError(""String_Node_Str"" + startingState);
}
}","/** 
 * Visits a control flow structure like an if, switch or a loop. <p>The main thing this is responsible for is calculating what state to enter after the control flow is complete.
 * @param parent The parent node, each child will be a block representing one of the branches
 * @param children The child blocks. We don't use {@code parent.getChildren()} directly to makeit possible to handle ForNodes using this method.
 * @param overallName The name, for error reporting purposes, to assign to the control flowstructure
 * @param blockNamer A function to provide a name for each child block, the key is the index ofthe block
 * @param willExactlyOneBranchExecuteOnce Whether or not it is guaranteed that exactly onebranch of the structure will execute exactly one time.
 * @param willAtLeastOneBranchExecute Whether or not it is guaranteed that at least one of thebranches will execute (as opposed to no branches executing).
 */
void visitControlFlowStructure(StandaloneNode parent,List<? extends BlockNode> children,String overallName,Function<? super BlockNode,String> blockNamer,boolean willExactlyOneBranchExecuteOnce,boolean willAtLeastOneBranchExecute){
  if (children.isEmpty()) {
    return;
  }
  State startingState=context.getState();
  State endingState=visitBranches(children,blockNamer);
  SourceLocation.Point endPoint=parent.getSourceLocation().getEndPoint();
switch (startingState) {
case AFTER_TAG_NAME_OR_ATTRIBUTE:
case BEFORE_ATTRIBUTE_NAME:
case AFTER_ATTRIBUTE_NAME:
    context.addTagChild(parent);
  if (willAtLeastOneBranchExecute && endingState == State.BEFORE_ATTRIBUTE_NAME) {
    context.setState(State.BEFORE_ATTRIBUTE_NAME,endPoint);
  }
break;
case HTML_TAG_NAME:
errorReporter.report(parent.getSourceLocation(),INVALID_LOCATION_FOR_CONTROL_FLOW,overallName,""String_Node_Str"");
throw new AbortParsingBlockError();
case BEFORE_ATTRIBUTE_VALUE:
if (!willExactlyOneBranchExecuteOnce) {
errorReporter.report(parent.getSourceLocation(),CONDITIONAL_BLOCK_ISNT_GUARANTEED_TO_PRODUCE_ONE_ATTRIBUTE_VALUE,overallName);
}
if (willAtLeastOneBranchExecute && endingState == State.UNQUOTED_ATTRIBUTE_VALUE) {
context.addAttributeValuePart(parent);
context.setState(State.UNQUOTED_ATTRIBUTE_VALUE,endPoint);
}
 else {
context.setAttributeValue(parent);
if (willAtLeastOneBranchExecute && endingState == State.BEFORE_ATTRIBUTE_NAME) {
context.setState(State.BEFORE_ATTRIBUTE_NAME,endPoint);
}
}
break;
case UNQUOTED_ATTRIBUTE_VALUE:
case DOUBLE_QUOTED_ATTRIBUTE_VALUE:
case SINGLE_QUOTED_ATTRIBUTE_VALUE:
context.addAttributeValuePart(parent);
break;
case HTML_COMMENT:
case NONE:
case PCDATA:
case RCDATA_SCRIPT:
case RCDATA_STYLE:
case RCDATA_TEXTAREA:
case RCDATA_TITLE:
case XML_DECLARATION:
case CDATA:
case DOUBLE_QUOTED_XML_ATTRIBUTE_VALUE:
case SINGLE_QUOTED_XML_ATTRIBUTE_VALUE:
break;
default :
throw new AssertionError(""String_Node_Str"" + startingState);
}
}",0.9782645901078212
29465,"/** 
 * Records the start of an html tag
 * @param tagStartNode The node where it started
 * @param isCloseTag is is a close tag
 * @param point the source location of the {@code <} character.
 */
void startTag(RawTextNode tagStartNode,boolean isCloseTag,SourceLocation.Point point){
  checkState(this.tagStartPoint == null);
  checkState(this.tagStartNode == null);
  checkState(this.directTagChildren.isEmpty());
  if (startingState != State.PCDATA) {
    errorReporter.report(point.asLocation(filePath),BLOCK_TRANSITION_DISALLOWED,blockName,startingState,""String_Node_Str"");
    reset();
  }
  this.tagStartPoint=checkNotNull(point);
  this.tagStartNode=checkNotNull(tagStartNode);
  this.isCloseTag=isCloseTag;
}","/** 
 * Records the start of an html tag
 * @param tagStartNode The node where it started
 * @param isCloseTag is is a close tag
 * @param point the source location of the {@code <} character.
 */
void startTag(RawTextNode tagStartNode,boolean isCloseTag,SourceLocation.Point point){
  checkState(this.tagStartPoint == null);
  checkState(this.tagStartNode == null);
  checkState(this.directTagChildren.isEmpty());
  if (startingState != State.PCDATA) {
    errorReporter.report(point.asLocation(filePath),BLOCK_TRANSITION_DISALLOWED,blockName,startingState,""String_Node_Str"");
    throw new AbortParsingBlockError();
  }
  this.tagStartPoint=checkNotNull(point);
  this.tagStartNode=checkNotNull(tagStartNode);
  this.isCloseTag=isCloseTag;
}",0.9746401644962304
29466,"void maybeFinishPendingAttribute(SourceLocation.Point currentPoint){
  if (hasUnquotedAttributeValueParts()) {
    createUnquotedAttributeValue(currentPoint);
  }
 else   if (hasQuotedAttributeValueParts()) {
    errorReporter.report(currentPoint.asLocation(filePath),FOUND_END_OF_ATTRIBUTE_STARTED_IN_ANOTHER_BLOCK);
    resetAttribute();
  }
  if (attributeName != null) {
    createAttributeNode();
  }
}","void maybeFinishPendingAttribute(SourceLocation.Point currentPoint){
  if (hasUnquotedAttributeValueParts()) {
    createUnquotedAttributeValue(currentPoint);
  }
 else   if (hasQuotedAttributeValueParts()) {
    errorReporter.report(currentPoint.asLocation(filePath),FOUND_END_OF_ATTRIBUTE_STARTED_IN_ANOTHER_BLOCK);
    throw new AbortParsingBlockError();
  }
  if (attributeName != null) {
    createAttributeNode();
  }
}",0.9447115384615384
29467,"/** 
 * Handle a quoted attribute value. <p>These are easy we just look for the end quote.
 */
void handleQuotedAttributeValue(boolean doubleQuoted){
  boolean hasQuote=advanceWhileMatches(doubleQuoted ? NOT_DOUBLE_QUOTE : NOT_SINGLE_QUOTE);
  RawTextNode data=consumeAsRawText();
  if (data != null) {
    context.addAttributeValuePart(data);
  }
  if (hasQuote) {
    if (context.hasQuotedAttributeValueParts()) {
      context.createQuotedAttributeValue(currentRawTextNode,doubleQuoted,currentPoint());
    }
 else {
      errorReporter.report(currentLocation(),FOUND_END_OF_ATTRIBUTE_STARTED_IN_ANOTHER_BLOCK);
      context.resetAttribute();
      context.setState(State.BEFORE_ATTRIBUTE_NAME,currentPoint());
    }
    advance();
    consume();
  }
}","/** 
 * Handle a quoted attribute value. <p>These are easy we just look for the end quote.
 */
void handleQuotedAttributeValue(boolean doubleQuoted){
  boolean hasQuote=advanceWhileMatches(doubleQuoted ? NOT_DOUBLE_QUOTE : NOT_SINGLE_QUOTE);
  RawTextNode data=consumeAsRawText();
  if (data != null) {
    context.addAttributeValuePart(data);
  }
  if (hasQuote) {
    if (context.hasQuotedAttributeValueParts()) {
      context.createQuotedAttributeValue(currentRawTextNode,doubleQuoted,currentPoint());
    }
 else {
      errorReporter.report(currentLocation(),FOUND_END_OF_ATTRIBUTE_STARTED_IN_ANOTHER_BLOCK);
      throw new AbortParsingBlockError();
    }
    advance();
    consume();
  }
}",0.9160935350756534
29468,"void startAttribute(StandaloneNode attrName){
  maybeFinishPendingAttribute(attrName.getSourceLocation().getBeginPoint());
  checkNotNull(attrName);
  checkState(attributeName == null);
  if (startingState == State.BEFORE_ATTRIBUTE_VALUE) {
    errorReporter.report(attrName.getSourceLocation(),BLOCK_TRANSITION_DISALLOWED,blockName,startingState,""String_Node_Str"");
    resetAttribute();
  }
  edits.remove(attrName);
  attributeName=attrName;
  setState(State.AFTER_ATTRIBUTE_NAME,attrName.getSourceLocation().getEndPoint());
}","void startAttribute(StandaloneNode attrName){
  maybeFinishPendingAttribute(attrName.getSourceLocation().getBeginPoint());
  checkNotNull(attrName);
  checkState(attributeName == null);
  if (startingState == State.BEFORE_ATTRIBUTE_VALUE) {
    errorReporter.report(attrName.getSourceLocation(),BLOCK_TRANSITION_DISALLOWED,blockName,startingState,""String_Node_Str"");
    throw new AbortParsingBlockError();
  }
  edits.remove(attrName);
  attributeName=attrName;
  setState(State.AFTER_ATTRIBUTE_NAME,attrName.getSourceLocation().getEndPoint());
}",0.9572490706319704
29469,"void resetAttribute(){
  attributeName=null;
  equalsSignLocation=null;
  attributeValue=null;
}","void resetAttribute(){
  attributeName=null;
  equalsSignLocation=null;
  attributeValue=null;
  quotedAttributeValueStart=null;
  attributeValueChildren.clear();
}",0.7384615384615385
29470,"/** 
 * Completes an unquoted attribute value. 
 */
void createUnquotedAttributeValue(SourceLocation.Point endPoint){
  if (!hasUnquotedAttributeValueParts()) {
    if (attributeName != null) {
      errorReporter.report(endPoint.asLocation(filePath),EXPECTED_ATTRIBUTE_VALUE);
    }
 else {
      errorReporter.report(endPoint.asLocation(filePath),FOUND_END_OF_ATTRIBUTE_STARTED_IN_ANOTHER_BLOCK);
    }
    resetAttribute();
    setState(State.AFTER_TAG_NAME_OR_ATTRIBUTE,endPoint);
    return;
  }
  HtmlAttributeValueNode valueNode=new HtmlAttributeValueNode(nodeIdGen.genId(),getLocationOf(attributeValueChildren),Quotes.NONE);
  edits.addChildren(valueNode,attributeValueChildren);
  attributeValueChildren.clear();
  setAttributeValue(valueNode);
}","/** 
 * Completes an unquoted attribute value. 
 */
void createUnquotedAttributeValue(SourceLocation.Point endPoint){
  if (!hasUnquotedAttributeValueParts()) {
    if (attributeName != null) {
      errorReporter.report(endPoint.asLocation(filePath),EXPECTED_ATTRIBUTE_VALUE);
    }
 else {
      errorReporter.report(endPoint.asLocation(filePath),FOUND_END_OF_ATTRIBUTE_STARTED_IN_ANOTHER_BLOCK);
      throw new AbortParsingBlockError();
    }
    resetAttribute();
    setState(State.AFTER_TAG_NAME_OR_ATTRIBUTE,endPoint);
    return;
  }
  HtmlAttributeValueNode valueNode=new HtmlAttributeValueNode(nodeIdGen.genId(),getLocationOf(attributeValueChildren),Quotes.NONE);
  edits.addChildren(valueNode,attributeValueChildren);
  attributeValueChildren.clear();
  setAttributeValue(valueNode);
}",0.9729381443298968
29471,"/** 
 * Outputs bytecode that unboxes the current top element of the stack as   {@code asType}. Top of stack must not be null. <p>Always prefer using   {@link SoyExpression#unboxAs} over this method, whenever possible.<p>Guarantees: * Bytecode output will not change stack height * Output will only change the top element, and nothing below that
 * @return the type of the result of the unbox operation
 */
static Type unboxUnchecked(CodeBuilder cb,Type fromType,Class<?> asType){
  checkArgument(!SoyValue.class.isAssignableFrom(asType),""String_Node_Str"",fromType,asType);
  if (isDefinitelyAssignableFrom(Type.getType(asType),fromType)) {
    return fromType;
  }
  if (asType.equals(boolean.class)) {
    MethodRef.SOY_VALUE_BOOLEAN_VALUE.invokeUnchecked(cb);
    return Type.BOOLEAN_TYPE;
  }
  if (asType.equals(long.class)) {
    MethodRef.SOY_VALUE_LONG_VALUE.invokeUnchecked(cb);
    return Type.LONG_TYPE;
  }
  if (asType.equals(double.class)) {
    MethodRef.SOY_VALUE_FLOAT_VALUE.invokeUnchecked(cb);
    return Type.DOUBLE_TYPE;
  }
  if (asType.equals(String.class)) {
    MethodRef.SOY_VALUE_STRING_VALUE.invokeUnchecked(cb);
    return STRING_TYPE;
  }
  if (asType.equals(List.class)) {
    cb.checkCast(SOY_LIST_TYPE);
    MethodRef.SOY_LIST_AS_JAVA_LIST.invokeUnchecked(cb);
    return LIST_TYPE;
  }
  if (asType.equals(Message.class)) {
    if (!isDefinitelyAssignableFrom(SOY_PROTO_VALUE_TYPE,fromType)) {
      cb.checkCast(SOY_PROTO_VALUE_TYPE);
    }
    MethodRef.SOY_PROTO_VALUE_GET_PROTO.invokeUnchecked(cb);
    return MESSAGE_TYPE;
  }
  throw new UnsupportedOperationException(""String_Node_Str"" + fromType + ""String_Node_Str""+ asType);
}","/** 
 * Outputs bytecode that unboxes the current top element of the stack as   {@code asType}. Top of stack must not be null. <p>Always prefer using   {@link SoyExpression#unboxAs} over this method, whenever possible.<p>Guarantees: * Bytecode output will not change stack height * Output will only change the top element, and nothing below that
 * @return the type of the result of the unbox operation
 */
static Type unboxUnchecked(CodeBuilder cb,SoyRuntimeType soyType,Class<?> asType){
  checkArgument(soyType.isBoxed(),""String_Node_Str"",soyType);
  Type fromType=soyType.runtimeType();
  checkArgument(!SoyValue.class.isAssignableFrom(asType),""String_Node_Str"",fromType,asType);
  if (isDefinitelyAssignableFrom(Type.getType(asType),fromType)) {
    return fromType;
  }
  if (asType.equals(boolean.class)) {
    MethodRef.SOY_VALUE_BOOLEAN_VALUE.invokeUnchecked(cb);
    return Type.BOOLEAN_TYPE;
  }
  if (asType.equals(long.class)) {
    MethodRef.SOY_VALUE_LONG_VALUE.invokeUnchecked(cb);
    return Type.LONG_TYPE;
  }
  if (asType.equals(double.class)) {
    MethodRef.SOY_VALUE_FLOAT_VALUE.invokeUnchecked(cb);
    return Type.DOUBLE_TYPE;
  }
  if (asType.equals(String.class)) {
    MethodRef.SOY_VALUE_STRING_VALUE.invokeUnchecked(cb);
    return STRING_TYPE;
  }
  if (asType.equals(List.class)) {
    cb.checkCast(SOY_LIST_TYPE);
    MethodRef.SOY_LIST_AS_JAVA_LIST.invokeUnchecked(cb);
    return LIST_TYPE;
  }
  if (asType.equals(Message.class)) {
    if (!isDefinitelyAssignableFrom(SOY_PROTO_VALUE_TYPE,fromType)) {
      cb.checkCast(SOY_PROTO_VALUE_TYPE);
    }
    MethodRef.SOY_PROTO_VALUE_GET_PROTO.invokeUnchecked(cb);
    return MESSAGE_TYPE;
  }
  throw new UnsupportedOperationException(""String_Node_Str"" + fromType + ""String_Node_Str""+ asType);
}",0.963435867672664
29472,"/** 
 * Generate bytecode that coerces the top of stack to the correct type for the given field. 
 */
private static void coerce(CodeBuilder cb,Type currentType,FieldDescriptor field){
switch (field.getJavaType()) {
case BOOLEAN:
case DOUBLE:
case STRING:
    return;
case FLOAT:
  if (!currentType.equals(Type.FLOAT_TYPE)) {
    cb.cast(currentType,Type.FLOAT_TYPE);
  }
return;
case INT:
if (!currentType.equals(Type.INT_TYPE)) {
cb.cast(currentType,Type.INT_TYPE);
}
return;
case LONG:
if (shouldConvertBetweenStringAndLong(field)) {
MethodRef.LONG_PARSE_LONG.invokeUnchecked(cb);
}
return;
case BYTE_STRING:
BASE_ENCODING_BASE_64.invokeUnchecked(cb);
cb.swap();
BASE_ENCODING_DECODE.invokeUnchecked(cb);
BYTE_STRING_COPY_FROM.invokeUnchecked(cb);
return;
case MESSAGE:
coerceToMessage(cb,field);
return;
case ENUM:
if (!currentType.equals(Type.INT_TYPE)) {
cb.cast(currentType,Type.INT_TYPE);
}
if (!isProto3EnumField(field)) {
getForNumberMethod(field.getEnumType()).invokeUnchecked(cb);
}
return;
default :
throw new AssertionError(""String_Node_Str"" + field);
}
}","/** 
 * Generate bytecode that coerces the top of stack to the correct type for the given field setter.
 */
private static void coerce(CodeBuilder cb,Type currentType,FieldDescriptor field){
switch (field.getJavaType()) {
case BOOLEAN:
case DOUBLE:
case STRING:
    break;
case FLOAT:
  if (!currentType.equals(Type.FLOAT_TYPE)) {
    cb.cast(currentType,Type.FLOAT_TYPE);
  }
break;
case INT:
if (!currentType.equals(Type.INT_TYPE)) {
cb.cast(currentType,Type.INT_TYPE);
}
break;
case LONG:
if (shouldConvertBetweenStringAndLong(field)) {
MethodRef.LONG_PARSE_LONG.invokeUnchecked(cb);
}
break;
case BYTE_STRING:
BASE_ENCODING_BASE_64.invokeUnchecked(cb);
cb.swap();
BASE_ENCODING_DECODE.invokeUnchecked(cb);
BYTE_STRING_COPY_FROM.invokeUnchecked(cb);
break;
case MESSAGE:
coerceToMessage(cb,field);
break;
case ENUM:
if (!currentType.equals(Type.INT_TYPE)) {
cb.cast(currentType,Type.INT_TYPE);
}
if (!isProto3EnumField(field)) {
getForNumberMethod(field.getEnumType()).invokeUnchecked(cb);
}
return;
default :
throw new AssertionError(""String_Node_Str"" + field);
}
if (field.isExtension()) {
Type fieldType=getRuntimeType(field);
if (isPrimitive(fieldType)) {
cb.valueOf(fieldType);
}
}
}",0.9123893805309734
29473,"/** 
 * Returns a Statement that handles a single proto builder setFoo() call. <p>The Statement assumes that just before .gen(), there is an instance of the proto builder at the top of the stack. After .gen() it is guaranteed to leave an instance of the builder at the top of the stack, without changing stack heights.
 */
private Statement handleNormalSetter(final SoyExpression baseArg,final FieldDescriptor field){
  final MethodRef setterMethod=getSetOrAddMethod(field);
  if (baseArg.isNonNullable()) {
    final Expression arg=shouldUnbox(field) ? baseArg.unboxAs(classToUnboxTo(field)) : baseArg;
    return new Statement(){
      @Override void doGen(      CodeBuilder cb){
        arg.gen(cb);
        coerce(cb,arg.resultType(),field);
        setterMethod.invokeUnchecked(cb);
      }
    }
;
  }
  return new Statement(){
    @Override void doGen(    CodeBuilder cb){
      baseArg.gen(cb);
      Label argIsNull=new Label();
      Label end=new Label();
      cb.dup();
      cb.ifNull(argIsNull);
      Type currentType;
      if (shouldUnbox(field)) {
        currentType=unboxUnchecked(cb,baseArg.soyRuntimeType().runtimeType(),classToUnboxTo(field));
      }
 else {
        currentType=SANITIZED_CONTENT_TYPE;
      }
      coerce(cb,currentType,field);
      setterMethod.invokeUnchecked(cb);
      cb.goTo(end);
      cb.mark(argIsNull);
      cb.pop();
      cb.mark(end);
    }
  }
;
}","/** 
 * Returns a Statement that handles a single proto builder setFoo() call. <p>The Statement assumes that just before .gen(), there is an instance of the proto builder at the top of the stack. After .gen() it is guaranteed to leave an instance of the builder at the top of the stack, without changing stack heights.
 */
private Statement handleNormalSetter(final SoyExpression baseArg,final FieldDescriptor field){
  final MethodRef setterMethod=getSetOrAddMethod(field);
  final boolean isNullable=!baseArg.isNonNullable();
  return new Statement(){
    @Override void doGen(    CodeBuilder cb){
      baseArg.gen(cb);
      Label argIsNull=null;
      Label end=null;
      if (isNullable) {
        argIsNull=new Label();
        end=new Label();
        cb.dup();
        cb.ifNull(argIsNull);
      }
      unboxAndCoerce(cb,baseArg,field);
      setterMethod.invokeUnchecked(cb);
      if (isNullable) {
        cb.goTo(end);
        cb.mark(argIsNull);
        cb.pop();
        cb.mark(end);
      }
    }
  }
;
}",0.4837515425750719
29474,"@Override void doGen(CodeBuilder cb){
  cb.checkCast(EXTENDABLE_BUILDER_TYPE);
  baseArg.gen(cb);
  Label argIsNull=new Label();
  Label end=new Label();
  cb.dup();
  cb.ifNull(argIsNull);
  Type currentType;
  if (shouldUnbox(field)) {
    currentType=unboxUnchecked(cb,baseArg.soyRuntimeType().runtimeType(),classToUnboxTo(field));
  }
 else {
    currentType=SANITIZED_CONTENT_TYPE;
  }
  coerce(cb,currentType,field);
  Type fieldType=getRuntimeType(field);
  if (isPrimitive(fieldType)) {
    cb.valueOf(fieldType);
  }
  extensionIdentifier.gen(cb);
  cb.swap();
  setterMethod.invokeUnchecked(cb);
  cb.goTo(end);
  cb.mark(argIsNull);
  cb.pop();
  cb.mark(end);
  cb.checkCast(builderRuntimeType(descriptor).type());
}","@Override void doGen(CodeBuilder cb){
  cb.checkCast(EXTENDABLE_BUILDER_TYPE);
  baseArg.gen(cb);
  Label argIsNull=null;
  Label end=null;
  if (isNullable) {
    argIsNull=new Label();
    end=new Label();
    cb.dup();
    cb.ifNull(argIsNull);
  }
  unboxAndCoerce(cb,baseArg,field);
  extensionIdentifier.gen(cb);
  cb.swap();
  setterMethod.invokeUnchecked(cb);
  if (isNullable) {
    cb.goTo(end);
    cb.mark(argIsNull);
    cb.pop();
    cb.mark(end);
  }
  cb.checkCast(builderRuntimeType(descriptor).type());
}",0.2592
29475,"private Statement handleExtension(final SoyExpression baseArg,final FieldDescriptor field){
  final Expression extensionIdentifier=getExtensionField(field).accessor();
  final MethodRef setterMethod=field.isRepeated() ? EXTENDABLE_BUILDER_ADD_EXTENSION : EXTENDABLE_BUILDER_SET_EXTENSION;
  if (baseArg.isNonNullable()) {
    final Expression arg=shouldUnbox(field) ? baseArg.unboxAs(classToUnboxTo(field)) : baseArg;
    return new Statement(){
      @Override void doGen(      CodeBuilder cb){
        cb.checkCast(EXTENDABLE_BUILDER_TYPE);
        extensionIdentifier.gen(cb);
        arg.gen(cb);
        coerce(cb,arg.resultType(),field);
        Type fieldType=getRuntimeType(field);
        if (isPrimitive(fieldType)) {
          cb.valueOf(fieldType);
        }
        setterMethod.invokeUnchecked(cb);
        cb.checkCast(builderRuntimeType(descriptor).type());
      }
    }
;
  }
  return new Statement(){
    @Override void doGen(    CodeBuilder cb){
      cb.checkCast(EXTENDABLE_BUILDER_TYPE);
      baseArg.gen(cb);
      Label argIsNull=new Label();
      Label end=new Label();
      cb.dup();
      cb.ifNull(argIsNull);
      Type currentType;
      if (shouldUnbox(field)) {
        currentType=unboxUnchecked(cb,baseArg.soyRuntimeType().runtimeType(),classToUnboxTo(field));
      }
 else {
        currentType=SANITIZED_CONTENT_TYPE;
      }
      coerce(cb,currentType,field);
      Type fieldType=getRuntimeType(field);
      if (isPrimitive(fieldType)) {
        cb.valueOf(fieldType);
      }
      extensionIdentifier.gen(cb);
      cb.swap();
      setterMethod.invokeUnchecked(cb);
      cb.goTo(end);
      cb.mark(argIsNull);
      cb.pop();
      cb.mark(end);
      cb.checkCast(builderRuntimeType(descriptor).type());
    }
  }
;
}","private Statement handleExtension(final SoyExpression baseArg,final FieldDescriptor field){
  final Expression extensionIdentifier=getExtensionField(field).accessor();
  final MethodRef setterMethod=field.isRepeated() ? EXTENDABLE_BUILDER_ADD_EXTENSION : EXTENDABLE_BUILDER_SET_EXTENSION;
  final boolean isNullable=!baseArg.isNonNullable();
  return new Statement(){
    @Override void doGen(    CodeBuilder cb){
      cb.checkCast(EXTENDABLE_BUILDER_TYPE);
      baseArg.gen(cb);
      Label argIsNull=null;
      Label end=null;
      if (isNullable) {
        argIsNull=new Label();
        end=new Label();
        cb.dup();
        cb.ifNull(argIsNull);
      }
      unboxAndCoerce(cb,baseArg,field);
      extensionIdentifier.gen(cb);
      cb.swap();
      setterMethod.invokeUnchecked(cb);
      if (isNullable) {
        cb.goTo(end);
        cb.mark(argIsNull);
        cb.pop();
        cb.mark(end);
      }
      cb.checkCast(builderRuntimeType(descriptor).type());
    }
  }
;
}",0.3200579290369297
29476,"@Override public void report(SourceLocation sourceLocation,SoyErrorKind error,Object... args){
  throw new AssertionError(String.format(""String_Node_Str"",error.format(args),sourceLocation));
}","@Override public void report(SourceLocation sourceLocation,SoyErrorKind error,Object... args){
  checkNotNull(sourceLocation);
  throw new AssertionError(String.format(""String_Node_Str"",error.format(args),sourceLocation));
}",0.9230769230769232
29477,"@Override public void report(SourceLocation sourceLocation,SoyErrorKind error,Object... args){
  errorMessages.add(error.format(args));
}","@Override public void report(SourceLocation sourceLocation,SoyErrorKind error,Object... args){
  checkNotNull(sourceLocation);
  errorMessages.add(error.format(args));
}",0.8954248366013072
29478,"@Override public SoyError create(SourceLocation location,SoyErrorKind kind,Object... args){
  String message=kind.format(args);
  return createError(location,kind,message,location + ""String_Node_Str"" + message);
}","@Override public SoyError create(SourceLocation location,SoyErrorKind kind,Object... args){
  checkNotNull(location);
  String message=kind.format(args);
  return createError(location,kind,message,location + ""String_Node_Str"" + message);
}",0.9424778761061948
29479,"/** 
 * Sets the SoyDoc for the node to be built. The SoyDoc will be parsed to fill in SoyDoc param info.
 * @return This builder.
 */
public TemplateNodeBuilder setSoyDoc(String soyDoc,SourceLocation soyDocLocation){
  Preconditions.checkState(this.soyDoc == null);
  Preconditions.checkState(cmdText != null);
  this.soyDoc=soyDoc;
  Preconditions.checkArgument(soyDoc.startsWith(""String_Node_Str"") && soyDoc.endsWith(""String_Node_Str""));
  String cleanedSoyDoc=cleanSoyDocHelper(soyDoc);
  this.soyDocDesc=parseSoyDocDescHelper(cleanedSoyDoc);
  this.addParams(parseSoyDocDeclsHelper(cleanedSoyDoc,soyDocLocation));
  return this;
}","/** 
 * Sets the SoyDoc for the node to be built. The SoyDoc will be parsed to fill in SoyDoc param info.
 * @return This builder.
 */
public TemplateNodeBuilder setSoyDoc(String soyDoc,SourceLocation soyDocLocation){
  Preconditions.checkState(this.soyDoc == null);
  Preconditions.checkState(cmdText != null);
  this.soyDoc=soyDoc;
  Preconditions.checkArgument(soyDoc.startsWith(""String_Node_Str"") && soyDoc.endsWith(""String_Node_Str""));
  String cleanedSoyDoc=cleanSoyDocHelper(soyDoc);
  this.soyDocDesc=parseSoyDocDescHelper(cleanedSoyDoc);
  this.addParams(parseSoyDocDeclsHelper(soyDoc,cleanedSoyDoc,soyDocLocation));
  return this;
}",0.9819890368050116
29480,"/** 
 * Private helper for the constructor to parse the SoyDoc declarations.
 * @param cleanedSoyDoc The cleaned SoyDoc text. Must not be null.
 * @return A SoyDocDeclsInfo object with the parsed info.
 */
private List<SoyDocParam> parseSoyDocDeclsHelper(String cleanedSoyDoc,SourceLocation soyDocSourceLocation){
  List<SoyDocParam> params=new ArrayList<>();
  Matcher matcher=SOY_DOC_DECL_PATTERN.matcher(cleanedSoyDoc);
  boolean isFound=matcher.find();
  while (isFound) {
    String declKeyword=matcher.group(1);
    String declText=matcher.group(2);
    int descStart=matcher.end();
    isFound=matcher.find();
    int descEnd=(isFound) ? matcher.start() : cleanedSoyDoc.length();
    String desc=cleanedSoyDoc.substring(descStart,descEnd).trim();
    if (declKeyword.equals(""String_Node_Str"") || declKeyword.equals(""String_Node_Str"")) {
      if (SOY_DOC_PARAM_TEXT_PATTERN.matcher(declText).matches()) {
        params.add(new SoyDocParam(declText,declKeyword.equals(""String_Node_Str""),desc));
      }
 else {
        if (declText.startsWith(""String_Node_Str"")) {
          if (!isMarkedV1) {
            errorReporter.report(soyDocSourceLocation,LEGACY_COMPATIBLE_PARAM_TAG,declText);
          }
        }
 else {
          errorReporter.report(soyDocSourceLocation,INVALID_SOYDOC_PARAM,declText);
        }
      }
    }
 else {
      throw new AssertionError();
    }
  }
  return params;
}","/** 
 * Private helper for the constructor to parse the SoyDoc declarations.
 * @param cleanedSoyDoc The cleaned SoyDoc text. Must not be null.
 * @return A SoyDocDeclsInfo object with the parsed info.
 */
private List<SoyDocParam> parseSoyDocDeclsHelper(String originalSoyDoc,String cleanedSoyDoc,SourceLocation soyDocSourceLocation){
  List<SoyDocParam> params=new ArrayList<>();
  RawTextNode originalSoyDocAsNode=new RawTextNode(-1,originalSoyDoc,soyDocSourceLocation);
  Matcher matcher=SOY_DOC_DECL_PATTERN.matcher(cleanedSoyDoc);
  boolean isFound=matcher.find();
  while (isFound) {
    String declKeyword=matcher.group(1);
    String declText=matcher.group(2);
    String fullMatch=matcher.group();
    int indexOfParamName=originalSoyDoc.indexOf(declText,originalSoyDoc.indexOf(fullMatch));
    SourceLocation paramLocation=originalSoyDocAsNode.substringLocation(indexOfParamName,indexOfParamName + declText.length());
    int descStart=matcher.end();
    isFound=matcher.find();
    int descEnd=(isFound) ? matcher.start() : cleanedSoyDoc.length();
    String desc=cleanedSoyDoc.substring(descStart,descEnd).trim();
    if (declKeyword.equals(""String_Node_Str"") || declKeyword.equals(""String_Node_Str"")) {
      if (SOY_DOC_PARAM_TEXT_PATTERN.matcher(declText).matches()) {
        params.add(new SoyDocParam(declText,declKeyword.equals(""String_Node_Str""),desc,paramLocation));
      }
 else {
        if (declText.startsWith(""String_Node_Str"")) {
          if (!isMarkedV1) {
            errorReporter.report(paramLocation,LEGACY_COMPATIBLE_PARAM_TAG,declText);
          }
        }
 else {
          errorReporter.report(paramLocation,INVALID_SOYDOC_PARAM,declText);
        }
      }
    }
 else {
      throw new AssertionError();
    }
  }
  return params;
}",0.8674850487881649
29481,"/** 
 * Helper for   {@code setSoyDoc()} and {@code setHeaderDecls()}. This method is intended to be called at most once for SoyDoc params and at most once for header params.
 * @param params The params to add.
 */
public TemplateNodeBuilder addParams(Iterable<? extends TemplateParam> params){
  Set<String> seenParamKeys=new HashSet<>();
  if (this.params == null) {
    this.params=ImmutableList.copyOf(params);
  }
 else {
    for (    TemplateParam oldParam : this.params) {
      seenParamKeys.add(oldParam.name());
    }
    this.params=ImmutableList.<TemplateParam>builder().addAll(this.params).addAll(params).build();
  }
  for (  TemplateParam param : params) {
    if (param.name().equals(""String_Node_Str"")) {
      errorReporter.report(paramSourceLocation(param),INVALID_PARAM_NAMED_IJ);
    }
    if (!seenParamKeys.add(param.name())) {
      errorReporter.report(paramSourceLocation(param),PARAM_ALREADY_DECLARED,param.name());
    }
  }
  return this;
}","/** 
 * Helper for   {@code setSoyDoc()} and {@code setHeaderDecls()}. This method is intended to be called at most once for SoyDoc params and at most once for header params.
 * @param params The params to add.
 */
public TemplateNodeBuilder addParams(Iterable<? extends TemplateParam> params){
  Set<String> seenParamKeys=new HashSet<>();
  if (this.params == null) {
    this.params=ImmutableList.copyOf(params);
  }
 else {
    for (    TemplateParam oldParam : this.params) {
      seenParamKeys.add(oldParam.name());
    }
    this.params=ImmutableList.<TemplateParam>builder().addAll(this.params).addAll(params).build();
  }
  for (  TemplateParam param : params) {
    if (param.name().equals(""String_Node_Str"")) {
      errorReporter.report(param.nameLocation(),INVALID_PARAM_NAMED_IJ);
    }
    if (!seenParamKeys.add(param.name())) {
      errorReporter.report(param.nameLocation(),PARAM_ALREADY_DECLARED,param.name());
    }
  }
  return this;
}",0.9854620976116304
29482,"public HeaderParam(String name,SourceLocation nameLocation,SoyType type,TypeNode typeNode,boolean isRequired,boolean isInjected,@Nullable String desc){
  super(name,type,isRequired,isInjected,desc);
  Preconditions.checkArgument(type != null);
  this.nameLocation=nameLocation;
  this.typeNode=typeNode;
}","public HeaderParam(String name,SourceLocation nameLocation,SoyType type,TypeNode typeNode,boolean isRequired,boolean isInjected,@Nullable String desc){
  super(name,type,isRequired,isInjected,desc,nameLocation);
  Preconditions.checkArgument(type != null);
  this.typeNode=typeNode;
}",0.865874363327674
29483,"@Override public SoyDocParam copyEssential(){
  SoyDocParam soyDocParam=new SoyDocParam(name(),isRequired(),null);
  soyDocParam.setLocalVariableIndex(localVariableIndex());
  return soyDocParam;
}","@Override public SoyDocParam copyEssential(){
  SoyDocParam soyDocParam=new SoyDocParam(name(),isRequired(),null,null);
  soyDocParam.setLocalVariableIndex(localVariableIndex());
  return soyDocParam;
}",0.987468671679198
29484,"TemplateParam(TemplateParam param){
  super(param);
  this.isRequired=param.isRequired;
  this.isInjected=param.isInjected;
  this.desc=param.desc;
}","TemplateParam(TemplateParam param){
  super(param);
  this.isRequired=param.isRequired;
  this.isInjected=param.isInjected;
  this.desc=param.desc;
  this.nameLocation=param.nameLocation;
}",0.8816568047337278
29485,"@Override void doFormatOutputExpr(FormattingContext ctx,OutputContext outputContext){
  ctx.append(varName());
}","@Override void doFormatOutputExpr(FormattingContext ctx,OutputContext outputContext){
  if (outputContext != OutputContext.EXPRESSION) {
    return;
  }
  ctx.append(varName());
}",0.7697594501718213
29486,"/** 
 * Layer of indirection to check if the output expression should end in a semicolon+newline. Subclasses must call this, and not   {@link #doFormatOutputExpr}.
 * @param outputContext The surrounding context where the expression is inserted.
 */
final void formatOutputExpr(FormattingContext ctx,OutputContext outputContext){
  doFormatOutputExpr(ctx,outputContext);
  if (outputContext == STATEMENT && !(this instanceof Composite) && !(this instanceof GoogRequire && (((GoogRequire)this).underlying() instanceof Composite))) {
    ctx.append(';').endLine();
  }
}","/** 
 * Layer of indirection to check if the output expression should end in a semicolon+newline. Subclasses must call this, and not   {@link #doFormatOutputExpr}.
 * @param outputContext The surrounding context where the expression is inserted.
 */
final void formatOutputExpr(FormattingContext ctx,OutputContext outputContext){
  doFormatOutputExpr(ctx,outputContext);
  if (outputContext == STATEMENT && !(this instanceof Composite) && !(this instanceof Assignment) && !(this instanceof GoogRequire && (((GoogRequire)this).underlying() instanceof Composite || ((GoogRequire)this).underlying() instanceof Assignment))) {
    ctx.append(';').endLine();
  }
}",0.925835370823146
29487,"/** 
 * Example: <pre> {let $boo} Hello {$name} {/let} </pre> might generate <pre> var boo35 = 'Hello ' + opt_data.name; </pre>
 */
@Override protected void visitLetContentNode(LetContentNode node){
  if (node.getChildren().size() == 1 && node.getChild(0) instanceof MsgFallbackGroupNode) {
    String msgVar=getAssistantForMsgs().generateMsgGroupVariable((MsgFallbackGroupNode)node.getChild(0));
    templateTranslationContext.soyToJsVariableMappings().put(node.getVarName(),id(msgVar));
    return;
  }
  String generatedVarName=node.getUniqueVarName();
  jsCodeBuilder.pushOutputVar(generatedVarName);
  visitChildren(node);
  jsCodeBuilder.popOutputVar();
  if (node.getContentKind() != null) {
    final String sanitizedContentOrdainer=NodeContentKinds.toJsSanitizedContentOrdainerForInternalBlocks(node.getContentKind());
    jsCodeBuilder.appendLine(generatedVarName,""String_Node_Str"",sanitizedContentOrdainer,""String_Node_Str"",generatedVarName,""String_Node_Str"");
  }
  templateTranslationContext.soyToJsVariableMappings().put(node.getVarName(),id(generatedVarName));
}","/** 
 * Example: <pre> {let $boo} Hello {$name} {/let} </pre> might generate <pre> var boo35 = 'Hello ' + opt_data.name; </pre>
 */
@Override protected void visitLetContentNode(LetContentNode node){
  if (node.getChildren().size() == 1 && node.getChild(0) instanceof MsgFallbackGroupNode) {
    String msgVar=getAssistantForMsgs().generateMsgGroupVariable((MsgFallbackGroupNode)node.getChild(0));
    templateTranslationContext.soyToJsVariableMappings().put(node.getVarName(),id(msgVar));
    return;
  }
  String generatedVarName=node.getUniqueVarName();
  CodeChunk.WithValue generatedVar=id(generatedVarName);
  jsCodeBuilder.pushOutputVar(generatedVarName);
  visitChildren(node);
  jsCodeBuilder.popOutputVar();
  if (node.getContentKind() != null) {
    jsCodeBuilder.append(assign(generatedVarName,sanitizedContentOrdainerFunctionForInternalBlocks(node.getContentKind()).call(generatedVar)));
  }
  templateTranslationContext.soyToJsVariableMappings().put(node.getVarName(),generatedVar);
}",0.8244937319189971
29488,"/** 
 * Outputs a   {@link TemplateNode}, generating the function open and close, along with a a debug template name. <p>If aliasing is not performed (which is always the case for V1 templates), this looks like: <pre> my.namespace.func = function(opt_data, opt_sb) { ... }; if (goog.DEBUG) { my.namespace.func.soyTemplateName = 'my.namespace.func'; } </pre> <p>If aliasing is performed, this looks like: <pre> function $func(opt_data, opt_sb) { ... } exports.func = $func; if (goog.DEBUG) { $func.soyTemplateName = 'my.namespace.func'; } <p>Note that the alias is not exactly the function name as in may conflict with a reserved JavaScript identifier. </pre>
 */
@Override protected void visitTemplateNode(TemplateNode node){
  boolean useStrongTyping=hasStrictParams(node);
  String templateName=node.getTemplateName();
  String partialName=node.getPartialTemplateName();
  String alias;
  boolean addToExports=jsSrcOptions.shouldGenerateGoogModules();
  if (addToExports && node instanceof TemplateDelegateNode) {
    alias=node.getPartialTemplateName().substring(1);
  }
 else {
    alias=templateAliases.get(templateName);
  }
  UniqueNameGenerator nameGenerator=JsSrcNameGenerators.forLocalVariables();
  CodeChunk.Generator codeGenerator=CodeChunk.Generator.create(nameGenerator);
  templateTranslationContext=TranslationContext.of(SoyToJsVariableMappings.forNewTemplate(),codeGenerator,nameGenerator);
  genJsExprsVisitor=genJsExprsVisitorFactory.create(templateTranslationContext,templateAliases,errorReporter);
  assistantForMsgs=null;
  String paramsRecordType=null;
  if (jsSrcOptions.shouldGenerateJsdoc()) {
    jsCodeBuilder.appendLine(""String_Node_Str"");
    jsCodeBuilder.append(""String_Node_Str"");
    if (useStrongTyping) {
      paramsRecordType=genParamsRecordType(node);
      jsCodeBuilder.append(paramsRecordType);
    }
 else {
      jsCodeBuilder.append(""String_Node_Str"");
    }
    jsCodeBuilder.appendLine(""String_Node_Str"");
    jsCodeBuilder.appendLine(""String_Node_Str"");
    jsCodeBuilder.appendLine(""String_Node_Str"");
    String returnType=getTemplateReturnType(node);
    jsCodeBuilder.appendLine(""String_Node_Str"",returnType,""String_Node_Str"");
    String suppressions=""String_Node_Str"";
    jsCodeBuilder.appendLine(""String_Node_Str"" + suppressions + ""String_Node_Str"");
    if (node.getVisibility() == Visibility.PRIVATE) {
      jsCodeBuilder.appendLine(""String_Node_Str"");
    }
    jsCodeBuilder.appendLine(""String_Node_Str"");
  }
  if (addToExports) {
    jsCodeBuilder.appendLine(""String_Node_Str"",alias,""String_Node_Str"");
  }
 else {
    jsCodeBuilder.appendLine(alias,""String_Node_Str"");
  }
  jsCodeBuilder.increaseIndent();
  if (!SoyTreeUtils.getAllNodesOfType(node,NullCoalescingOpNode.class).isEmpty() || !SoyTreeUtils.getAllNodesOfType(node,SwitchNode.class).isEmpty()) {
    jsCodeBuilder.appendLine(""String_Node_Str"");
  }
  if (new ShouldEnsureDataIsDefinedVisitor().exec(node)) {
    jsCodeBuilder.appendLine(""String_Node_Str"");
  }
  if (shouldEnsureIjDataIsDefined(node)) {
    jsCodeBuilder.appendLine(""String_Node_Str"");
  }
  generateFunctionBody(node);
  jsCodeBuilder.decreaseIndent();
  if (addToExports) {
    jsCodeBuilder.appendLine(""String_Node_Str"");
    jsCodeBuilder.appendLine(""String_Node_Str"",partialName.substring(1),""String_Node_Str"",alias,""String_Node_Str"");
  }
 else {
    jsCodeBuilder.appendLine(""String_Node_Str"");
  }
  if (paramsRecordType != null) {
    jsCodeBuilder.appendLine(""String_Node_Str"");
    jsCodeBuilder.appendLine(""String_Node_Str"",paramsRecordType,""String_Node_Str"");
    jsCodeBuilder.appendLine(""String_Node_Str"");
    jsCodeBuilder.appendLine(alias + ""String_Node_Str"");
  }
  jsCodeBuilder.appendLine(""String_Node_Str"");
  jsCodeBuilder.increaseIndent();
  jsCodeBuilder.appendLine(alias + ""String_Node_Str"" + templateName+ ""String_Node_Str"");
  jsCodeBuilder.decreaseIndent();
  jsCodeBuilder.appendLine(""String_Node_Str"");
  if (node instanceof TemplateDelegateNode) {
    TemplateDelegateNode nodeAsDelTemplate=(TemplateDelegateNode)node;
    String delTemplateIdExprText=""String_Node_Str"" + delTemplateNamer.getDelegateName(nodeAsDelTemplate) + ""String_Node_Str"";
    String delTemplateVariantExprText=""String_Node_Str"" + nodeAsDelTemplate.getDelTemplateVariant() + ""String_Node_Str"";
    jsCodeBuilder.appendLine(""String_Node_Str"",delTemplateIdExprText,""String_Node_Str"",delTemplateVariantExprText,""String_Node_Str"",nodeAsDelTemplate.getDelPriority().toString(),""String_Node_Str"",alias,""String_Node_Str"");
  }
}","/** 
 * Outputs a   {@link TemplateNode}, generating the function open and close, along with a a debug template name. <p>If aliasing is not performed (which is always the case for V1 templates), this looks like: <pre> my.namespace.func = function(opt_data, opt_sb) { ... }; if (goog.DEBUG) { my.namespace.func.soyTemplateName = 'my.namespace.func'; } </pre> <p>If aliasing is performed, this looks like: <pre> function $func(opt_data, opt_sb) { ... } exports.func = $func; if (goog.DEBUG) { $func.soyTemplateName = 'my.namespace.func'; } <p>Note that the alias is not exactly the function name as in may conflict with a reserved JavaScript identifier. </pre>
 */
@Override protected void visitTemplateNode(TemplateNode node){
  boolean useStrongTyping=hasStrictParams(node);
  String templateName=node.getTemplateName();
  String partialName=node.getPartialTemplateName();
  String alias;
  boolean addToExports=jsSrcOptions.shouldGenerateGoogModules();
  if (addToExports && node instanceof TemplateDelegateNode) {
    alias=node.getPartialTemplateName().substring(1);
  }
 else {
    alias=templateAliases.get(templateName);
  }
  UniqueNameGenerator nameGenerator=JsSrcNameGenerators.forLocalVariables();
  CodeChunk.Generator codeGenerator=CodeChunk.Generator.create(nameGenerator);
  templateTranslationContext=TranslationContext.of(SoyToJsVariableMappings.forNewTemplate(),codeGenerator,nameGenerator);
  genJsExprsVisitor=genJsExprsVisitorFactory.create(templateTranslationContext,templateAliases,errorReporter);
  assistantForMsgs=null;
  String paramsRecordType=null;
  if (jsSrcOptions.shouldGenerateJsdoc()) {
    jsCodeBuilder.appendLine(""String_Node_Str"");
    jsCodeBuilder.append(""String_Node_Str"");
    if (useStrongTyping) {
      paramsRecordType=genParamsRecordType(node);
      jsCodeBuilder.append(paramsRecordType);
    }
 else {
      jsCodeBuilder.append(""String_Node_Str"");
    }
    jsCodeBuilder.appendLine(""String_Node_Str"");
    jsCodeBuilder.appendLine(""String_Node_Str"");
    jsCodeBuilder.appendLine(""String_Node_Str"");
    String returnType=getTemplateReturnType(node);
    jsCodeBuilder.appendLine(""String_Node_Str"",returnType,""String_Node_Str"");
    String suppressions=""String_Node_Str"";
    jsCodeBuilder.appendLine(""String_Node_Str"" + suppressions + ""String_Node_Str"");
    if (node.getVisibility() == Visibility.PRIVATE) {
      jsCodeBuilder.appendLine(""String_Node_Str"");
    }
    jsCodeBuilder.appendLine(""String_Node_Str"");
  }
  if (addToExports) {
    jsCodeBuilder.appendLine(""String_Node_Str"",alias,""String_Node_Str"");
  }
 else {
    jsCodeBuilder.appendLine(alias,""String_Node_Str"");
  }
  jsCodeBuilder.increaseIndent();
  if (!SoyTreeUtils.getAllNodesOfType(node,NullCoalescingOpNode.class).isEmpty() || !SoyTreeUtils.getAllNodesOfType(node,SwitchNode.class).isEmpty()) {
    jsCodeBuilder.appendLine(""String_Node_Str"");
  }
  if (new ShouldEnsureDataIsDefinedVisitor().exec(node)) {
    jsCodeBuilder.appendLine(""String_Node_Str"");
  }
  if (shouldEnsureIjDataIsDefined(node)) {
    jsCodeBuilder.appendLine(""String_Node_Str"");
  }
  generateFunctionBody(node);
  jsCodeBuilder.decreaseIndent();
  if (addToExports) {
    jsCodeBuilder.appendLine(""String_Node_Str"");
    jsCodeBuilder.appendLine(""String_Node_Str"",partialName.substring(1),""String_Node_Str"",alias,""String_Node_Str"");
  }
 else {
    jsCodeBuilder.appendLine(""String_Node_Str"");
  }
  if (paramsRecordType != null) {
    jsCodeBuilder.appendLine(""String_Node_Str"");
    jsCodeBuilder.appendLine(""String_Node_Str"",paramsRecordType,""String_Node_Str"");
    jsCodeBuilder.appendLine(""String_Node_Str"");
    jsCodeBuilder.appendLine(alias + ""String_Node_Str"");
  }
  jsCodeBuilder.appendLine(""String_Node_Str"");
  jsCodeBuilder.increaseIndent();
  jsCodeBuilder.appendLine(alias + ""String_Node_Str"" + templateName+ ""String_Node_Str"");
  jsCodeBuilder.decreaseIndent();
  jsCodeBuilder.appendLine(""String_Node_Str"");
  if (node instanceof TemplateDelegateNode) {
    TemplateDelegateNode nodeAsDelTemplate=(TemplateDelegateNode)node;
    jsCodeBuilder.append(SOY_REGISTER_DELEGATE_FN.call(SOY_GET_DELTEMPLATE_ID.call(stringLiteral(delTemplateNamer.getDelegateName(nodeAsDelTemplate))),stringLiteral(nodeAsDelTemplate.getDelTemplateVariant()),number(nodeAsDelTemplate.getDelPriority().getValue()),dottedIdNoRequire(alias)));
  }
}",0.9276605349283376
29489,"@Test public void testDelTemplate(){
  String testFileContent=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  TemplateNode template=(TemplateNode)SharedTestUtils.getNode(SoyFileSetParserBuilder.forFileContents(testFileContent).parse().fileSet());
  String expectedJsCode=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  genJsCodeVisitor.jsCodeBuilder=new JsCodeBuilder();
  genJsCodeVisitor.visitForTesting(template,ExplodingErrorReporter.get());
  assertThat(genJsCodeVisitor.jsCodeBuilder.getCode()).isEqualTo(expectedJsCode);
}","@Test public void testDelTemplate(){
  String testFileContent=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ParseResult parseResult=SoyFileSetParserBuilder.forFileContents(testFileContent).parse();
  String expectedJsCode=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  genJsCodeVisitor.jsSrcOptions.setShouldProvideRequireSoyNamespaces(true);
  String file=genJsCodeVisitor.gen(parseResult.fileSet(),parseResult.registry(),ExplodingErrorReporter.get()).get(0);
  assertThat(file).endsWith(expectedJsCode);
}",0.7381546134663342
29490,"public void testIsEqualto(){
  SoyListData sld0=new SoyListData();
  SoyListData sld1=new SoyListData(""String_Node_Str"");
  assertTrue(sld0.equals(sld0));
  assertTrue(sld1.equals(sld1));
  assertFalse(sld0.equals(sld1));
  assertFalse(sld0.equals(new SoyListData()));
}","public void testIsEqualto(){
  SoyListData sld0=new SoyListData();
  SoyListData sld1=new SoyListData(""String_Node_Str"");
  new EqualsTester().addEqualityGroup(sld0).addEqualityGroup(sld1).testEquals();
  assertFalse(sld0.equals(new SoyListData()));
}",0.6333973128598849
29491,"public void testIsEqualto(){
  SoyMapData smd0=new SoyMapData();
  SoyMapData smd1=new SoyMapData(""String_Node_Str"",""String_Node_Str"");
  assertTrue(smd0.equals(smd0));
  assertTrue(smd1.equals(smd1));
  assertFalse(smd0.equals(smd1));
  assertFalse(smd0.equals(new SoyMapData()));
}","public void testIsEqualto(){
  SoyMapData smd0=new SoyMapData();
  SoyMapData smd1=new SoyMapData(""String_Node_Str"",""String_Node_Str"");
  new EqualsTester().addEqualityGroup(smd0).addEqualityGroup(smd1).testEquals();
  assertFalse(smd0.equals(new SoyMapData()));
}",0.6508226691042047
29492,"/** 
 * Given a collection type, compute the element type.
 * @param collectionType The base type.
 * @param owningNode The current error context, in other words the SoyNode owning theexpression being scanned.
 * @return The type of the elements of the collection.
 */
private SoyType getElementType(SoyType collectionType,ExprHolderNode owningNode){
  Preconditions.checkNotNull(collectionType);
switch (collectionType.getKind()) {
case UNKNOWN:
    return UnknownType.getInstance();
case LIST:
  return ((ListType)collectionType).getElementType();
case UNION:
{
  UnionType unionType=(UnionType)collectionType;
  List<SoyType> fieldTypes=new ArrayList<>(unionType.getMembers().size());
  for (  SoyType unionMember : unionType.getMembers()) {
    fieldTypes.add(getElementType(unionMember,owningNode));
  }
  return typeOps.computeLowestCommonType(fieldTypes);
}
default :
throw new AssertionError(""String_Node_Str"" + collectionType);
}
}","/** 
 * Given a collection type, compute the element type.
 * @param collectionType The base type.
 * @param node The ForeachNonemptyNode being iterated.
 * @return The type of the elements of the collection.
 */
private SoyType getElementType(SoyType collectionType,ForeachNonemptyNode node){
  Preconditions.checkNotNull(collectionType);
switch (collectionType.getKind()) {
case UNKNOWN:
    return UnknownType.getInstance();
case LIST:
  return ((ListType)collectionType).getElementType();
case UNION:
{
  UnionType unionType=(UnionType)collectionType;
  List<SoyType> fieldTypes=new ArrayList<>(unionType.getMembers().size());
  for (  SoyType unionMember : unionType.getMembers()) {
    SoyType elementType=getElementType(unionMember,node);
    if (elementType.getKind() == SoyType.Kind.ERROR) {
      return ErrorType.getInstance();
    }
    fieldTypes.add(elementType);
  }
  return typeOps.computeLowestCommonType(fieldTypes);
}
default :
errorReporter.report(node.getParent().getSourceLocation(),BAD_FOREACH_TYPE,node.getExpr().toSourceString(),node.getExpr().getType());
return ErrorType.getInstance();
}
}",0.6387943607194944
29493,"@Override protected void visitForeachNonemptyNode(ForeachNonemptyNode node){
  visitExpressions(node.getParent());
  node.getVar().setType(getElementType(node.getExpr().getType(),node.getParent()));
  visitChildren(node);
}","@Override protected void visitForeachNonemptyNode(ForeachNonemptyNode node){
  visitExpressions(node.getParent());
  node.getVar().setType(getElementType(node.getExpr().getType(),node));
  visitChildren(node);
}",0.9723502304147466
29494,"@Override public TemplateBasicNodeBuilder setCmdText(String cmdText){
  Preconditions.checkState(this.cmdText == null);
  this.cmdText=cmdText;
  String commandTextForParsing=cmdText;
  String nameAttr;
  Matcher ntnMatcher=NONATTRIBUTE_TEMPLATE_NAME.matcher(commandTextForParsing);
  if (ntnMatcher.find()) {
    nameAttr=ntnMatcher.group();
    commandTextForParsing=commandTextForParsing.substring(ntnMatcher.end()).trim();
  }
 else {
    errorReporter.report(sourceLocation,MISSING_TEMPLATE_NAME);
    return this;
  }
  Map<String,String> attributes=ATTRIBUTES_PARSER.parse(commandTextForParsing,errorReporter,sourceLocation);
  if (attributes.get(""String_Node_Str"").equals(""String_Node_Str"")) {
    visibility=Visibility.LEGACY_PRIVATE;
  }
  String visibilityName=attributes.get(""String_Node_Str"");
  if (visibilityName != null) {
    if (visibility != null) {
      errorReporter.report(sourceLocation,PRIVATE_AND_VISIBILITY,visibilityName);
    }
    visibility=Visibility.forAttributeValue(visibilityName);
  }
  if (visibility == null) {
    visibility=Visibility.PUBLIC;
  }
  setAutoescapeCmdText(attributes);
  setRequireCssCmdText(attributes);
  setCssBaseCmdText(attributes);
  setV1Marker(attributes);
  if (BaseUtils.isIdentifierWithLeadingDot(nameAttr)) {
    if (soyFileHeaderInfo.namespace == null) {
      throw LegacyInternalSyntaxException.createWithMetaInfo(""String_Node_Str"",sourceLocation);
    }
    setTemplateNames(soyFileHeaderInfo.namespace + nameAttr,nameAttr);
  }
 else {
    if (!isMarkedV1 && BaseUtils.isDottedIdentifier(nameAttr)) {
      errorReporter.report(sourceLocation,FULLY_QUALIFIED_NAME);
    }
    setTemplateNames(nameAttr,null);
  }
  this.templateNameForUserMsgs=getTemplateName();
  return this;
}","@Override public TemplateBasicNodeBuilder setCmdText(String cmdText){
  Preconditions.checkState(this.cmdText == null);
  this.cmdText=cmdText;
  String commandTextForParsing=cmdText;
  String nameAttr;
  Matcher ntnMatcher=TEMPLATE_NAME.matcher(commandTextForParsing);
  if (ntnMatcher.find()) {
    nameAttr=ntnMatcher.group(1);
    commandTextForParsing=commandTextForParsing.substring(ntnMatcher.end()).trim();
  }
 else {
    errorReporter.report(sourceLocation,MISSING_TEMPLATE_NAME);
    return this;
  }
  Map<String,String> attributes=ATTRIBUTES_PARSER.parse(commandTextForParsing,errorReporter,sourceLocation);
  if (attributes.get(""String_Node_Str"").equals(""String_Node_Str"")) {
    visibility=Visibility.LEGACY_PRIVATE;
  }
  String visibilityName=attributes.get(""String_Node_Str"");
  if (visibilityName != null) {
    if (visibility != null) {
      errorReporter.report(sourceLocation,PRIVATE_AND_VISIBILITY,visibilityName);
    }
    visibility=Visibility.forAttributeValue(visibilityName);
  }
  if (visibility == null) {
    visibility=Visibility.PUBLIC;
  }
  setAutoescapeCmdText(attributes);
  setRequireCssCmdText(attributes);
  setCssBaseCmdText(attributes);
  setV1Marker(attributes);
  if (BaseUtils.isIdentifierWithLeadingDot(nameAttr)) {
    if (soyFileHeaderInfo.namespace == null) {
      throw LegacyInternalSyntaxException.createWithMetaInfo(""String_Node_Str"",sourceLocation);
    }
    setTemplateNames(soyFileHeaderInfo.namespace + nameAttr,nameAttr);
  }
 else {
    if (!isMarkedV1 && BaseUtils.isDottedIdentifier(nameAttr)) {
      errorReporter.report(sourceLocation,FULLY_QUALIFIED_NAME);
    }
    setTemplateNames(nameAttr,null);
  }
  this.templateNameForUserMsgs=getTemplateName();
  return this;
}",0.9959885386819484
29495,"@Override public TemplateDelegateNodeBuilder setSoyDoc(String soyDoc){
  if (soyDoc == null) {
    errorReporter.report(sourceLocation,NO_SOY_DOC);
  }
  return (TemplateDelegateNodeBuilder)super.setSoyDoc(soyDoc);
}","@Override public TemplateDelegateNodeBuilder setSoyDoc(String soyDoc){
  return (TemplateDelegateNodeBuilder)super.setSoyDoc(soyDoc);
}",0.7692307692307693
29496,"private String computeLcTagName(ErrorReporter errorReporter){
  String firstChildText=((RawTextNode)children.get(0)).getRawText();
  Matcher matcher=TAG_NAME_PATTERN.matcher(firstChildText);
  if (!matcher.find()) {
    if (firstChildText.startsWith(""String_Node_Str"")) {
      errorReporter.report(sourceLocation,HTML_COMMENT_WITHIN_MSG_BLOCK,firstChildText);
    }
 else {
      errorReporter.report(sourceLocation,UNNAMED_HTML_TAG_WITHIN_MSG_BLOCK,firstChildText);
    }
  }
  return matcher.group().toLowerCase(Locale.ENGLISH);
}","@Nullable private String computeLcTagName(ErrorReporter errorReporter){
  String firstChildText=((RawTextNode)children.get(0)).getRawText();
  Matcher matcher=TAG_NAME_PATTERN.matcher(firstChildText);
  if (!matcher.find()) {
    if (firstChildText.startsWith(""String_Node_Str"")) {
      errorReporter.report(sourceLocation,HTML_COMMENT_WITHIN_MSG_BLOCK,firstChildText);
    }
 else {
      errorReporter.report(sourceLocation,UNNAMED_HTML_TAG_WITHIN_MSG_BLOCK,firstChildText);
    }
    return null;
  }
  return matcher.group().toLowerCase(Locale.ENGLISH);
}",0.9752973467520586
29497,"public ResolvePackageRelativeCssNamesVisitor(ErrorReporter errorReporter){
  this.errorReporter=errorReporter;
}","ResolvePackageRelativeCssNamesVisitor(ErrorReporter errorReporter){
  this.errorReporter=errorReporter;
}",0.967741935483871
29498,"@Override protected void visitCssNode(CssNode node){
  String selectorText=node.getSelectorText();
  if (!selectorText.startsWith(""String_Node_Str"")) {
    return;
  }
  if (node.getComponentNameExpr() != null) {
    throw SoySyntaxExceptionUtils.createWithNode(""String_Node_Str"" + selectorText + ""String_Node_Str"",node);
  }
  if (packagePrefix == null) {
    throw SoySyntaxExceptionUtils.createWithNode(""String_Node_Str"" + selectorText + ""String_Node_Str"",node);
  }
  BlockNode parent=node.getParent();
  int indexInParent=parent.getChildIndex(node);
  parent.removeChild(indexInParent);
  CssNode newNode=new CssNode(node,packagePrefix + selectorText.substring(1),new CopyState());
  parent.addChild(indexInParent,newNode);
}","@Override protected void visitCssNode(CssNode node){
  String selectorText=node.getSelectorText();
  if (!selectorText.startsWith(""String_Node_Str"")) {
    return;
  }
  if (node.getComponentNameExpr() != null) {
    errorReporter.report(node.getSourceLocation(),PACKAGE_RELATIVE_CLASS_NAME_USED_WITH_COMPONENT_NAME,selectorText);
  }
  if (packagePrefix == null) {
    errorReporter.report(node.getSourceLocation(),NO_CSS_PACKAGE,selectorText);
  }
  BlockNode parent=node.getParent();
  int indexInParent=parent.getChildIndex(node);
  parent.removeChild(indexInParent);
  CssNode newNode=new CssNode(node,packagePrefix + selectorText.substring(1),new CopyState());
  parent.addChild(indexInParent,newNode);
}",0.7361111111111112
29499,"public void testMissingCssBase(){
  try {
    compileTemplate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  SoySyntaxException e) {
    assertThat(e.getMessage()).contains(""String_Node_Str"");
  }
}","public void testMissingCssBase(){
  FormattingErrorReporter errorReporter=new FormattingErrorReporter();
  compileTemplate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",errorReporter);
  assertThat(errorReporter.getErrorMessages()).hasSize(1);
  assertThat(errorReporter.getErrorMessages().get(0)).isEqualTo(""String_Node_Str"");
}",0.533532041728763
29500,"public void testWithComponentName(){
  try {
    compileTemplate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  SoySyntaxException e) {
    assertThat(e.getMessage()).contains(""String_Node_Str"");
  }
}","public void testWithComponentName(){
  FormattingErrorReporter errorReporter=new FormattingErrorReporter();
  compileTemplate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",errorReporter);
  assertThat(errorReporter.getErrorMessages()).hasSize(2);
  assertThat(errorReporter.getErrorMessages().get(0)).isEqualTo(""String_Node_Str"");
  assertThat(errorReporter.getErrorMessages().get(1)).isEqualTo(""String_Node_Str"");
}",0.4666666666666667
29501,"public List<CssNode> compileTemplate(String templateText){
  ErrorReporter boom=ExplodingErrorReporter.get();
  SoyFileSetNode soyTree=SoyFileSetParserBuilder.forFileContents(templateText).errorReporter(boom).parse().fileSet();
  TemplateNode template=(TemplateNode)SharedTestUtils.getNode(soyTree);
  new ResolvePackageRelativeCssNamesVisitor(boom).exec(template);
  return getCssNodes(template);
}","private List<CssNode> compileTemplate(String templateText){
  return compileTemplate(templateText,ExplodingErrorReporter.get());
}",0.3667296786389414
29502,"@Override protected void visitTemplateNode(TemplateNode node){
  currentTemplateName=node.getTemplateNameForUserMsgs();
  localVariables=new LocalVariables();
  localVariables.enterScope();
  ijParams=new HashMap<>();
  for (  TemplateParam param : node.getAllParams()) {
    localVariables.define(param,node);
  }
  visitSoyNode(node);
  localVariables.exitScope();
  localVariables.verify();
  node.setMaxLocalVariableTableSize(localVariables.nextSlotToClaim);
  localVariables=null;
  ijParams=null;
}","@Override protected void visitTemplateNode(TemplateNode node){
  localVariables=new LocalVariables();
  localVariables.enterScope();
  ijParams=new HashMap<>();
  for (  TemplateParam param : node.getAllParams()) {
    localVariables.define(param,node);
  }
  visitSoyNode(node);
  localVariables.exitScope();
  localVariables.verify();
  node.setMaxLocalVariableTableSize(localVariables.nextSlotToClaim);
  localVariables=null;
  ijParams=null;
}",0.94006309148265
29503,"private void visitExpressions(ExprHolderNode node){
  ResolveNamesExprVisitor exprVisitor=new ResolveNamesExprVisitor(node);
  for (  ExprUnion exprUnion : node.getAllExprUnions()) {
    if (exprUnion.getExpr() != null) {
      exprVisitor.exec(exprUnion.getExpr());
    }
  }
}","private void visitExpressions(ExprHolderNode node){
  ResolveNamesExprVisitor exprVisitor=new ResolveNamesExprVisitor();
  for (  ExprUnion exprUnion : node.getAllExprUnions()) {
    if (exprUnion.getExpr() != null) {
      exprVisitor.exec(exprUnion.getExpr());
    }
  }
}",0.9927536231884058
29504,"@Override protected void visitVarRefNode(VarRefNode varRef){
  if (varRef.isInjected()) {
    InjectedParam ijParam=ijParams.get(varRef.getName());
    if (ijParam == null) {
      ijParam=new InjectedParam(varRef.getName());
      ijParams.put(varRef.getName(),ijParam);
    }
    varRef.setDefn(ijParam);
    return;
  }
  VarDefn varDefn=localVariables.lookup(varRef.getName());
  if (varDefn == null) {
    if (declaredSyntaxVersion.num >= SyntaxVersion.V9_9.num) {
      throw createExceptionForInvalidExpr(""String_Node_Str"" + varRef.getName());
    }
 else {
      varDefn=new UndeclaredVar(varRef.getName());
    }
  }
  varRef.setDefn(varDefn);
}","@Override protected void visitVarRefNode(VarRefNode varRef){
  if (varRef.isInjected()) {
    InjectedParam ijParam=ijParams.get(varRef.getName());
    if (ijParam == null) {
      ijParam=new InjectedParam(varRef.getName());
      ijParams.put(varRef.getName(),ijParam);
    }
    varRef.setDefn(ijParam);
    return;
  }
  VarDefn varDefn=localVariables.lookup(varRef.getName());
  if (varDefn == null) {
    varDefn=new UndeclaredVar(varRef.getName());
  }
  varRef.setDefn(varDefn);
}",0.7320490367775832
29505,"/** 
 * Defines a variable. 
 */
void define(VarDefn defn,SoyNode definingNode){
  VarDefn preexisting=lookup(defn.name());
  if (preexisting != null) {
    throw SoySyntaxException.createWithMetaInfo(""String_Node_Str"" + defn.name() + ""String_Node_Str"",definingNode.getSourceLocation(),null,currentTemplateName);
  }
  currentScope.peek().put(defn.name(),defn);
  defn.setLocalVariableIndex(claimSlot());
}","/** 
 * Defines a variable. 
 */
void define(VarDefn defn,SoyNode definingNode){
  VarDefn preexisting=lookup(defn.name());
  if (preexisting != null) {
    Optional<SourceLocation> sourceLocation=forVarDefn(preexisting);
    String location=sourceLocation.isPresent() ? ""String_Node_Str"" + sourceLocation.get().getLineNumber() : ""String_Node_Str"";
    errorReporter.report(definingNode.getSourceLocation(),VARIABLE_ALREADY_DEFINED,defn.name(),location);
    return;
  }
  currentScope.peek().put(defn.name(),defn);
  defn.setLocalVariableIndex(claimSlot());
}",0.3354037267080745
29506,"ResolveNamesVisitor(SyntaxVersion declaredSyntaxVersion,ErrorReporter errorReporter){
  this.errorReporter=errorReporter;
  this.declaredSyntaxVersion=declaredSyntaxVersion;
}","ResolveNamesVisitor(ErrorReporter errorReporter){
  this.errorReporter=errorReporter;
}",0.6641221374045801
29507,"@Override public Void exec(ExprNode node){
  Preconditions.checkArgument(node instanceof ExprRootNode);
  this.currExprRootNode=(ExprRootNode)node;
  visit(node);
  this.currExprRootNode=null;
  return null;
}","@Override public Void exec(ExprNode node){
  Preconditions.checkArgument(node instanceof ExprRootNode);
  visit(node);
  return null;
}",0.7848837209302325
29508,"public void testLogicalOps(){
  String testTemplateContent=constructTemplateSource(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  SoyFileSetNode soyTree=SoyFileSetParserBuilder.forFileContents(testTemplateContent).declaredSyntaxVersion(SyntaxVersion.V2_0).doRunInitialParsingPasses(false).typeRegistry(typeRegistry).parse().fileSet();
  createResolveNamesVisitor(SyntaxVersion.V2_0).exec(soyTree);
  createResolveExpressionTypesVisitor(SyntaxVersion.V2_0).exec(soyTree);
  List<SoyType> types=getCapturedTypes(soyTree);
  assertThat(types.get(0)).isEqualTo(UnknownType.getInstance());
  assertThat(types.get(1)).isEqualTo(UnknownType.getInstance());
  assertThat(types.get(2)).isEqualTo(UnknownType.getInstance());
  assertThat(types.get(3)).isEqualTo(UnknownType.getInstance());
  assertThat(types.get(4)).isEqualTo(UnknownType.getInstance());
  assertThat(types.get(5)).isEqualTo(UnknownType.getInstance());
  assertThat(types.get(6)).isEqualTo(BoolType.getInstance());
  assertThat(types.get(7)).isEqualTo(BoolType.getInstance());
  assertThat(types.get(8)).isEqualTo(BoolType.getInstance());
  soyTree=SoyFileSetParserBuilder.forFileContents(testTemplateContent).declaredSyntaxVersion(SyntaxVersion.V2_3).doRunInitialParsingPasses(false).typeRegistry(typeRegistry).parse().fileSet();
  createResolveNamesVisitor(SyntaxVersion.V2_3).exec(soyTree);
  createResolveExpressionTypesVisitor(SyntaxVersion.V2_3).exec(soyTree);
  types=getCapturedTypes(soyTree);
  assertThat(types.get(0)).isEqualTo(BoolType.getInstance());
  assertThat(types.get(1)).isEqualTo(BoolType.getInstance());
  assertThat(types.get(2)).isEqualTo(BoolType.getInstance());
  assertThat(types.get(3)).isEqualTo(BoolType.getInstance());
  assertThat(types.get(4)).isEqualTo(BoolType.getInstance());
  assertThat(types.get(5)).isEqualTo(BoolType.getInstance());
  assertThat(types.get(6)).isEqualTo(BoolType.getInstance());
  assertThat(types.get(7)).isEqualTo(BoolType.getInstance());
  assertThat(types.get(8)).isEqualTo(BoolType.getInstance());
}","public void testLogicalOps(){
  String testTemplateContent=constructTemplateSource(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  SoyFileSetNode soyTree=SoyFileSetParserBuilder.forFileContents(testTemplateContent).declaredSyntaxVersion(SyntaxVersion.V2_0).doRunInitialParsingPasses(false).typeRegistry(typeRegistry).parse().fileSet();
  new ResolveNamesVisitor(ExplodingErrorReporter.get()).exec(soyTree);
  createResolveExpressionTypesVisitor(SyntaxVersion.V2_0).exec(soyTree);
  List<SoyType> types=getCapturedTypes(soyTree);
  assertThat(types.get(0)).isEqualTo(UnknownType.getInstance());
  assertThat(types.get(1)).isEqualTo(UnknownType.getInstance());
  assertThat(types.get(2)).isEqualTo(UnknownType.getInstance());
  assertThat(types.get(3)).isEqualTo(UnknownType.getInstance());
  assertThat(types.get(4)).isEqualTo(UnknownType.getInstance());
  assertThat(types.get(5)).isEqualTo(UnknownType.getInstance());
  assertThat(types.get(6)).isEqualTo(BoolType.getInstance());
  assertThat(types.get(7)).isEqualTo(BoolType.getInstance());
  assertThat(types.get(8)).isEqualTo(BoolType.getInstance());
  soyTree=SoyFileSetParserBuilder.forFileContents(testTemplateContent).declaredSyntaxVersion(SyntaxVersion.V2_3).doRunInitialParsingPasses(false).typeRegistry(typeRegistry).parse().fileSet();
  new ResolveNamesVisitor(ExplodingErrorReporter.get()).exec(soyTree);
  createResolveExpressionTypesVisitor(SyntaxVersion.V2_3).exec(soyTree);
  types=getCapturedTypes(soyTree);
  assertThat(types.get(0)).isEqualTo(BoolType.getInstance());
  assertThat(types.get(1)).isEqualTo(BoolType.getInstance());
  assertThat(types.get(2)).isEqualTo(BoolType.getInstance());
  assertThat(types.get(3)).isEqualTo(BoolType.getInstance());
  assertThat(types.get(4)).isEqualTo(BoolType.getInstance());
  assertThat(types.get(5)).isEqualTo(BoolType.getInstance());
  assertThat(types.get(6)).isEqualTo(BoolType.getInstance());
  assertThat(types.get(7)).isEqualTo(BoolType.getInstance());
  assertThat(types.get(8)).isEqualTo(BoolType.getInstance());
}",0.4179172351068667
29509,"public void testParamNameLookupSuccess(){
  SoyFileSetNode soyTree=SoyFileSetParserBuilder.forFileContents(constructTemplateSource(""String_Node_Str"",""String_Node_Str"")).parse().fileSet();
  createResolveNamesVisitorForMaxSyntaxVersion().exec(soyTree);
  TemplateNode n=soyTree.getChild(0).getChild(0);
  assertThat(n.getMaxLocalVariableTableSize()).isEqualTo(1);
  assertThat(n.getParams().get(0).localVariableIndex()).isEqualTo(0);
}","public void testParamNameLookupSuccess(){
  SoyFileSetNode soyTree=SoyFileSetParserBuilder.forFileContents(constructTemplateSource(""String_Node_Str"",""String_Node_Str"")).parse().fileSet();
  new ResolveNamesVisitor(ExplodingErrorReporter.get()).exec(soyTree);
  TemplateNode n=soyTree.getChild(0).getChild(0);
  assertThat(n.getMaxLocalVariableTableSize()).isEqualTo(1);
  assertThat(n.getParams().get(0).localVariableIndex()).isEqualTo(0);
}",0.9348571428571428
29510,"public void testInjectedParamNameLookupSuccess(){
  SoyFileSetNode soyTree=SoyFileSetParserBuilder.forFileContents(constructTemplateSource(""String_Node_Str"",""String_Node_Str"")).parse().fileSet();
  createResolveNamesVisitorForMaxSyntaxVersion().exec(soyTree);
  TemplateNode n=soyTree.getChild(0).getChild(0);
  assertThat(n.getMaxLocalVariableTableSize()).isEqualTo(1);
  assertThat(n.getInjectedParams().get(0).localVariableIndex()).isEqualTo(0);
}","public void testInjectedParamNameLookupSuccess(){
  SoyFileSetNode soyTree=SoyFileSetParserBuilder.forFileContents(constructTemplateSource(""String_Node_Str"",""String_Node_Str"")).parse().fileSet();
  new ResolveNamesVisitor(ExplodingErrorReporter.get()).exec(soyTree);
  TemplateNode n=soyTree.getChild(0).getChild(0);
  assertThat(n.getMaxLocalVariableTableSize()).isEqualTo(1);
  assertThat(n.getInjectedParams().get(0).localVariableIndex()).isEqualTo(0);
}",0.9371554575523704
29511,"public void testLetNameLookupSuccess(){
  SoyFileSetNode soyTree=SoyFileSetParserBuilder.forFileContents(constructTemplateSource(""String_Node_Str"",""String_Node_Str"")).parse().fileSet();
  createResolveNamesVisitorForMaxSyntaxVersion().exec(soyTree);
  TemplateNode n=soyTree.getChild(0).getChild(0);
  assertThat(n.getMaxLocalVariableTableSize()).isEqualTo(1);
  assertThat(((LetValueNode)n.getChild(0)).getVar().localVariableIndex()).isEqualTo(0);
}","public void testLetNameLookupSuccess(){
  SoyFileSetNode soyTree=SoyFileSetParserBuilder.forFileContents(constructTemplateSource(""String_Node_Str"",""String_Node_Str"")).parse().fileSet();
  new ResolveNamesVisitor(ExplodingErrorReporter.get()).exec(soyTree);
  TemplateNode n=soyTree.getChild(0).getChild(0);
  assertThat(n.getMaxLocalVariableTableSize()).isEqualTo(1);
  assertThat(((LetValueNode)n.getChild(0)).getVar().localVariableIndex()).isEqualTo(0);
}",0.9371554575523704
29512,"public void testMultiplLocalsAndScopesNumbering(){
  SoyFileSetNode soyTree=SoyFileSetParserBuilder.forFileContents(constructTemplateSource(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).parse().fileSet();
  createResolveNamesVisitorForMaxSyntaxVersion().exec(soyTree);
  TemplateNode n=soyTree.getChild(0).getChild(0);
  assertThat(n.getMaxLocalVariableTableSize()).isEqualTo(6);
  assertThat(n.getParams().get(0).localVariableIndex()).isEqualTo(0);
  assertThat(n.getParams().get(1).localVariableIndex()).isEqualTo(1);
  assertThat(((LetValueNode)n.getChild(0)).getVar().localVariableIndex()).isEqualTo(2);
  ForeachNonemptyNode foreachNonEmptyNode=(ForeachNonemptyNode)((ForeachNode)n.getChild(1)).getChild(0);
  assertThat(foreachNonEmptyNode.getVar().currentLoopIndexIndex()).isEqualTo(3);
  assertThat(foreachNonEmptyNode.getVar().isLastIteratorIndex()).isEqualTo(4);
  assertThat(foreachNonEmptyNode.getVar().localVariableIndex()).isEqualTo(5);
  assertThat(((LetValueNode)n.getChild(2)).getVar().localVariableIndex()).isEqualTo(3);
}","public void testMultiplLocalsAndScopesNumbering(){
  SoyFileSetNode soyTree=SoyFileSetParserBuilder.forFileContents(constructTemplateSource(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).parse().fileSet();
  new ResolveNamesVisitor(ExplodingErrorReporter.get()).exec(soyTree);
  TemplateNode n=soyTree.getChild(0).getChild(0);
  assertThat(n.getMaxLocalVariableTableSize()).isEqualTo(6);
  assertThat(n.getParams().get(0).localVariableIndex()).isEqualTo(0);
  assertThat(n.getParams().get(1).localVariableIndex()).isEqualTo(1);
  assertThat(((LetValueNode)n.getChild(0)).getVar().localVariableIndex()).isEqualTo(2);
  ForeachNonemptyNode foreachNonEmptyNode=(ForeachNonemptyNode)((ForeachNode)n.getChild(1)).getChild(0);
  assertThat(foreachNonEmptyNode.getVar().currentLoopIndexIndex()).isEqualTo(3);
  assertThat(foreachNonEmptyNode.getVar().isLastIteratorIndex()).isEqualTo(4);
  assertThat(foreachNonEmptyNode.getVar().localVariableIndex()).isEqualTo(5);
  assertThat(((LetValueNode)n.getChild(2)).getVar().localVariableIndex()).isEqualTo(3);
}",0.9746779209240336
29513,"public void testMultipleLocals(){
  SoyFileSetNode soyTree=SoyFileSetParserBuilder.forFileContents(constructTemplateSource(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).parse().fileSet();
  createResolveNamesVisitorForMaxSyntaxVersion().exec(soyTree);
  TemplateNode n=soyTree.getChild(0).getChild(0);
  assertThat(n.getMaxLocalVariableTableSize()).isEqualTo(3);
  LetValueNode firstLet=(LetValueNode)n.getChild(0);
  LetValueNode secondLet=(LetValueNode)n.getChild(1);
  LetValueNode thirdLet=(LetValueNode)n.getChild(2);
  assertThat(firstLet.getVar().localVariableIndex()).isEqualTo(0);
  assertThat(secondLet.getVar().localVariableIndex()).isEqualTo(1);
  assertThat(thirdLet.getVar().localVariableIndex()).isEqualTo(2);
  assertThat(((VarRefNode)secondLet.getValueExpr().getRoot()).getDefnDecl()).isEqualTo(firstLet.getVar());
  assertThat(((VarRefNode)thirdLet.getValueExpr().getRoot()).getDefnDecl()).isEqualTo(secondLet.getVar());
}","public void testMultipleLocals(){
  SoyFileSetNode soyTree=SoyFileSetParserBuilder.forFileContents(constructTemplateSource(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).parse().fileSet();
  new ResolveNamesVisitor(ExplodingErrorReporter.get()).exec(soyTree);
  TemplateNode n=soyTree.getChild(0).getChild(0);
  assertThat(n.getMaxLocalVariableTableSize()).isEqualTo(3);
  LetValueNode firstLet=(LetValueNode)n.getChild(0);
  LetValueNode secondLet=(LetValueNode)n.getChild(1);
  LetValueNode thirdLet=(LetValueNode)n.getChild(2);
  assertThat(firstLet.getVar().localVariableIndex()).isEqualTo(0);
  assertThat(secondLet.getVar().localVariableIndex()).isEqualTo(1);
  assertThat(thirdLet.getVar().localVariableIndex()).isEqualTo(2);
  assertThat(((VarRefNode)secondLet.getValueExpr().getRoot()).getDefnDecl()).isEqualTo(firstLet.getVar());
  assertThat(((VarRefNode)thirdLet.getValueExpr().getRoot()).getDefnDecl()).isEqualTo(secondLet.getVar());
}",0.3691662296801258
29514,"/** 
 * Assertions function that checks to make sure that name resolution fails with the expected exception.
 * @param fileContent The template source.
 * @param expectedError The expected failure message (a substring).
 */
private void assertResolveNamesFails(String expectedError,String fileContent){
  try {
    SoyFileSetParserBuilder.forFileContents(fileContent).declaredSyntaxVersion(SyntaxVersion.V2_0).typeRegistry(typeRegistry).parse();
    fail(""String_Node_Str"");
  }
 catch (  SoySyntaxException e) {
    String message=e.getMessage();
    assertWithMessage(""String_Node_Str"" + message + ""String_Node_Str""+ expectedError+ ""String_Node_Str"").that(message.contains(expectedError)).isTrue();
  }
}","private void assertResolveNamesFails(String expectedError,String fileContent){
  FormattingErrorReporter errorReporter=new FormattingErrorReporter();
  SoyFileSetParserBuilder.forFileContents(fileContent).declaredSyntaxVersion(SyntaxVersion.V2_0).errorReporter(errorReporter).typeRegistry(typeRegistry).parse();
  assertThat(errorReporter.getErrorMessages()).hasSize(1);
  assertThat(errorReporter.getErrorMessages().get(0)).isEqualTo(expectedError);
}",0.3920552677029361
29515,"public void testLetContentSlotLifetime(){
  SoyFileSetNode soyTree=SoyFileSetParserBuilder.forFileContents(constructTemplateSource(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).parse().fileSet();
  createResolveNamesVisitorForMaxSyntaxVersion().exec(soyTree);
  TemplateNode n=soyTree.getChild(0).getChild(0);
  assertThat(n.getMaxLocalVariableTableSize()).isEqualTo(2);
  LetContentNode aLetNode=(LetContentNode)n.getChild(0);
  assertThat(aLetNode.getVar().localVariableIndex()).isEqualTo(1);
  LetValueNode bLetNode=(LetValueNode)((IfCondNode)((IfNode)aLetNode.getChild(0)).getChild(0)).getChild(0);
  assertThat(bLetNode.getVar().localVariableIndex()).isEqualTo(0);
}","public void testLetContentSlotLifetime(){
  SoyFileSetNode soyTree=SoyFileSetParserBuilder.forFileContents(constructTemplateSource(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).parse().fileSet();
  new ResolveNamesVisitor(ExplodingErrorReporter.get()).exec(soyTree);
  TemplateNode n=soyTree.getChild(0).getChild(0);
  assertThat(n.getMaxLocalVariableTableSize()).isEqualTo(2);
  LetContentNode aLetNode=(LetContentNode)n.getChild(0);
  assertThat(aLetNode.getVar().localVariableIndex()).isEqualTo(1);
  LetValueNode bLetNode=(LetValueNode)((IfCondNode)((IfNode)aLetNode.getChild(0)).getChild(0)).getChild(0);
  assertThat(bLetNode.getVar().localVariableIndex()).isEqualTo(0);
}",0.962326503635162
29516,"@Override protected final SoyExpression visitConditionalOpNode(ConditionalOpNode node){
  final SoyExpression condition=visit(node.getChild(0)).coerceToBoolean();
  SoyExpression trueBranch=visit(node.getChild(1));
  SoyExpression falseBranch=visit(node.getChild(2));
  boolean typesEqual=trueBranch.soyType().equals(falseBranch.soyType());
  if (typesEqual) {
    if (trueBranch.isBoxed() == falseBranch.isBoxed()) {
      return trueBranch.withSource(ternary(condition,trueBranch,falseBranch));
    }
    Optional<SoyExpression> unboxedTrue=trueBranch.tryUnbox();
    Optional<SoyExpression> unboxedFalse=falseBranch.tryUnbox();
    if (unboxedTrue.isPresent() && unboxedFalse.isPresent()) {
      return unboxedTrue.get().withSource(ternary(condition,unboxedTrue.get(),unboxedFalse.get()));
    }
  }
  if (trueBranch.isKnownInt() && falseBranch.isKnownInt()) {
    final SoyExpression trueAsLong=trueBranch.unboxAs(long.class);
    final SoyExpression falseAsLong=falseBranch.unboxAs(long.class);
    return SoyExpression.forInt(ternary(condition,trueAsLong,falseAsLong));
  }
  if (trueBranch.isKnownFloat() && falseBranch.isKnownFloat()) {
    final SoyExpression trueAsFloat=trueBranch.unboxAs(double.class);
    final SoyExpression falseAsFloat=falseBranch.unboxAs(double.class);
    return SoyExpression.forFloat(ternary(condition,trueAsFloat,falseAsFloat));
  }
  if (typesEqual && trueBranch.isKnownStringOrSanitizedContent() && falseBranch.isKnownStringOrSanitizedContent()) {
    final SoyExpression trueAsString=trueBranch.coerceToString();
    final SoyExpression falseAsString=falseBranch.coerceToString();
    Expression ternary=ternary(condition,trueAsString,falseAsString);
    if (trueBranch.isKnownSanitizedContent()) {
      return SoyExpression.forSanitizedString(ternary,((SanitizedType)trueBranch.soyType()).getContentKind());
    }
    return SoyExpression.forString(ternary);
  }
  final Expression trueBoxed=trueBranch.box().cast(SoyValue.class);
  final Expression falseBoxed=falseBranch.box().cast(SoyValue.class);
  return SoyExpression.forSoyValue(UnknownType.getInstance(),ternary(condition,trueBoxed,falseBoxed));
}","@Override protected final SoyExpression visitConditionalOpNode(ConditionalOpNode node){
  final SoyExpression condition=visit(node.getChild(0)).coerceToBoolean();
  SoyExpression trueBranch=visit(node.getChild(1));
  SoyExpression falseBranch=visit(node.getChild(2));
  boolean typesEqual=trueBranch.soyType().equals(falseBranch.soyType());
  if (typesEqual) {
    if (trueBranch.isBoxed() == falseBranch.isBoxed()) {
      return trueBranch.withSource(ternary(condition,trueBranch,falseBranch));
    }
    return trueBranch.withSource(ternary(condition,trueBranch.box(),falseBranch.box()));
  }
  return SoyExpression.forSoyValue(UnknownType.getInstance(),ternary(condition,trueBranch.box().cast(SoyValue.class),falseBranch.box().cast(SoyValue.class)));
}",0.3655765920826161
29517,"@Override protected SoyExpression visitNullCoalescingOpNode(NullCoalescingOpNode node){
  final SoyExpression left=visit(node.getLeftChild());
  if (left.isNonNullable()) {
    return left;
  }
  final SoyExpression right=visit(node.getRightChild());
  SoyType nonNullLeftType=SoyTypes.removeNull(left.soyType());
  Features features=Features.of();
  if (Expression.areAllCheap(left,right)) {
    features=features.plus(Feature.CHEAP);
  }
  if (right.isNonNullable()) {
    features=features.plus(Feature.NON_NULLABLE);
  }
  if (nonNullLeftType.equals(right.soyType())) {
    if (left.isBoxed() == right.isBoxed()) {
      return right.withSource(firstNonNull(left,right));
    }
    if (right.isBoxed()) {
      Optional<SoyExpression> unboxedRight=right.tryUnbox();
      if (unboxedRight.isPresent()) {
        return left.withSource(firstNonNull(left,unboxedRight.get()));
      }
    }
 else {
      final Label leftIsNull=new Label();
      final Optional<SoyExpression> nullCheckedUnboxedLeft=left.withSource(new Expression(left.resultType(),features){
        @Override void doGen(        CodeBuilder cb){
          left.gen(cb);
          cb.dup();
          cb.ifNull(leftIsNull);
        }
      }
).asNonNullable().tryUnbox();
      if (nullCheckedUnboxedLeft.isPresent()) {
        return right.withSource(new Expression(right.resultType(),features){
          @Override void doGen(          CodeBuilder adapter){
            nullCheckedUnboxedLeft.get().gen(adapter);
            Label end=new Label();
            adapter.goTo(end);
            adapter.mark(leftIsNull);
            adapter.pop();
            right.gen(adapter);
            adapter.mark(end);
          }
        }
);
      }
    }
  }
  return SoyExpression.forSoyValue(UnknownType.getInstance(),firstNonNull(left.box().cast(SoyValue.class),right.box().cast(SoyValue.class)));
}","@Override protected SoyExpression visitNullCoalescingOpNode(NullCoalescingOpNode node){
  final SoyExpression left=visit(node.getLeftChild());
  if (left.isNonNullable()) {
    return left;
  }
  final SoyExpression right=visit(node.getRightChild());
  SoyType nonNullLeftType=SoyTypes.removeNull(left.soyType());
  Features features=Features.of();
  if (Expression.areAllCheap(left,right)) {
    features=features.plus(Feature.CHEAP);
  }
  if (right.isNonNullable()) {
    features=features.plus(Feature.NON_NULLABLE);
  }
  if (nonNullLeftType.equals(right.soyType())) {
    if (left.isBoxed() == right.isBoxed()) {
      return right.withSource(firstNonNull(left,right));
    }
    if (right.isBoxed()) {
      SoyExpression boxedLeft=left.box();
      return boxedLeft.withSource(firstNonNull(boxedLeft,right));
    }
 else {
      final Label leftIsNull=new Label();
      final Optional<SoyExpression> nullCheckedUnboxedLeft=left.withSource(new Expression(left.resultType(),features){
        @Override void doGen(        CodeBuilder cb){
          left.gen(cb);
          cb.dup();
          cb.ifNull(leftIsNull);
        }
      }
).asNonNullable().tryUnbox();
      if (nullCheckedUnboxedLeft.isPresent()) {
        return right.withSource(new Expression(right.resultType(),features){
          @Override void doGen(          CodeBuilder adapter){
            nullCheckedUnboxedLeft.get().gen(adapter);
            Label end=new Label();
            adapter.goTo(end);
            adapter.mark(leftIsNull);
            adapter.pop();
            right.gen(adapter);
            adapter.mark(end);
          }
        }
);
      }
    }
  }
  return SoyExpression.forSoyValue(UnknownType.getInstance(),firstNonNull(left.box().cast(SoyValue.class),right.box().cast(SoyValue.class)));
}",0.9513395297977036
29518,"@Override protected final SoyExpression visitMinusOpNode(MinusOpNode node){
  final SoyExpression left=visit(node.getChild(0));
  final SoyExpression right=visit(node.getChild(1));
  if (left.assignableToNullableInt() && right.assignableToNullableInt()) {
    return applyBinaryIntOperator(Opcodes.LSUB,left,right);
  }
  if (left.assignableToNullableNumber() && right.assignableToNullableNumber()) {
    return applyBinaryFloatOperator(Opcodes.DSUB,left,right);
  }
  return SoyExpression.forSoyValue(SoyTypes.NUMBER_TYPE,MethodRef.RUNTIME_MINUS.invoke(left.box(),right.box()));
}","@Override protected final SoyExpression visitMinusOpNode(MinusOpNode node){
  final SoyExpression left=visit(node.getChild(0));
  final SoyExpression right=visit(node.getChild(1));
  if (left.assignableToNullableNumber() && right.assignableToNullableNumber()) {
    if (left.assignableToNullableInt() && right.assignableToNullableInt()) {
      return applyBinaryIntOperator(Opcodes.LSUB,left,right);
    }
    if (left.assignableToNullableFloat() || right.assignableToNullableFloat()) {
      return applyBinaryFloatOperator(Opcodes.DSUB,left,right);
    }
  }
  return SoyExpression.forSoyValue(SoyTypes.NUMBER_TYPE,MethodRef.RUNTIME_MINUS.invoke(left.box(),right.box()));
}",0.8035003977724742
29519,"@Override protected final SoyExpression visitPlusOpNode(PlusOpNode node){
  SoyExpression left=visit(node.getChild(0));
  SoyExpression right=visit(node.getChild(1));
  if (left.assignableToNullableInt() && right.assignableToNullableInt()) {
    return applyBinaryIntOperator(Opcodes.LADD,left,right);
  }
  if (left.assignableToNullableNumber() && right.assignableToNullableNumber()) {
    return applyBinaryFloatOperator(Opcodes.DADD,left,right);
  }
  if (left.isKnownString() || right.isKnownString()) {
    SoyExpression leftString=left.coerceToString();
    SoyExpression rightString=right.coerceToString();
    return SoyExpression.forString(leftString.invoke(MethodRef.STRING_CONCAT,rightString));
  }
  return SoyExpression.forSoyValue(SoyTypes.NUMBER_TYPE,MethodRef.RUNTIME_PLUS.invoke(left.box(),right.box()));
}","@Override protected final SoyExpression visitPlusOpNode(PlusOpNode node){
  SoyExpression left=visit(node.getChild(0));
  SoyExpression right=visit(node.getChild(1));
  if (left.assignableToNullableNumber() && right.assignableToNullableNumber()) {
    if (left.assignableToNullableInt() && right.assignableToNullableInt()) {
      return applyBinaryIntOperator(Opcodes.LADD,left,right);
    }
    if (left.assignableToNullableFloat() || right.assignableToNullableFloat()) {
      return applyBinaryFloatOperator(Opcodes.DADD,left,right);
    }
  }
  if (left.isKnownString() || right.isKnownString()) {
    SoyExpression leftString=left.coerceToString();
    SoyExpression rightString=right.coerceToString();
    return SoyExpression.forString(leftString.invoke(MethodRef.STRING_CONCAT,rightString));
  }
  return SoyExpression.forSoyValue(SoyTypes.NUMBER_TYPE,MethodRef.RUNTIME_PLUS.invoke(left.box(),right.box()));
}",0.8581275129236071
29520,"@Override protected final SoyExpression visitTimesOpNode(TimesOpNode node){
  final SoyExpression left=visit(node.getChild(0));
  final SoyExpression right=visit(node.getChild(1));
  if (left.assignableToNullableInt() && right.assignableToNullableInt()) {
    return applyBinaryIntOperator(Opcodes.LMUL,left,right);
  }
  if (left.assignableToNullableNumber() && right.assignableToNullableNumber()) {
    return applyBinaryFloatOperator(Opcodes.DMUL,left,right);
  }
  return SoyExpression.forSoyValue(SoyTypes.NUMBER_TYPE,MethodRef.RUNTIME_TIMES.invoke(left.box(),right.box()));
}","@Override protected final SoyExpression visitTimesOpNode(TimesOpNode node){
  final SoyExpression left=visit(node.getChild(0));
  final SoyExpression right=visit(node.getChild(1));
  if (left.assignableToNullableNumber() && right.assignableToNullableNumber()) {
    if (left.assignableToNullableInt() && right.assignableToNullableInt()) {
      return applyBinaryIntOperator(Opcodes.LMUL,left,right);
    }
    if (left.assignableToNullableFloat() || right.assignableToNullableFloat()) {
      return applyBinaryFloatOperator(Opcodes.DMUL,left,right);
    }
  }
  return SoyExpression.forSoyValue(SoyTypes.NUMBER_TYPE,MethodRef.RUNTIME_TIMES.invoke(left.box(),right.box()));
}",0.8035003977724742
29521,"/** 
 * @see com.google.template.soy.basicfunctions.MinFunction
 */
private SoyExpression invokeMinFunction(SoyExpression left,SoyExpression right){
  if (left.assignableToNullableInt() && right.assignableToNullableInt()) {
    return SoyExpression.forInt(MATH_MIN_LONG.invoke(left.unboxAs(long.class),right.unboxAs(long.class)));
  }
 else   if (left.assignableToNullableFloat() && right.assignableToNullableFloat()) {
    return SoyExpression.forInt(MATH_MIN_DOUBLE.invoke(left.unboxAs(double.class),right.unboxAs(double.class)));
  }
 else {
    return SoyExpression.forSoyValue(NUMBER_TYPE,MIN_FN.invoke(left.box(),right.box()));
  }
}","/** 
 * @see com.google.template.soy.basicfunctions.MinFunction
 */
private SoyExpression invokeMinFunction(SoyExpression left,SoyExpression right){
  if (left.assignableToNullableInt() && right.assignableToNullableInt()) {
    return SoyExpression.forInt(MATH_MIN_LONG.invoke(left.unboxAs(long.class),right.unboxAs(long.class)));
  }
 else   if (left.assignableToNullableFloat() && right.assignableToNullableFloat()) {
    return SoyExpression.forFloat(MATH_MIN_DOUBLE.invoke(left.unboxAs(double.class),right.unboxAs(double.class)));
  }
 else {
    return SoyExpression.forSoyValue(NUMBER_TYPE,MIN_FN.invoke(left.box(),right.box()));
  }
}",0.9953125
29522,"/** 
 * @see com.google.template.soy.basicfunctions.MaxFunction
 */
private SoyExpression invokeMaxFunction(SoyExpression left,SoyExpression right){
  if (left.assignableToNullableInt() && right.assignableToNullableInt()) {
    return SoyExpression.forInt(MATH_MAX_LONG.invoke(left.unboxAs(long.class),right.unboxAs(long.class)));
  }
 else   if (left.assignableToNullableFloat() && right.assignableToNullableFloat()) {
    return SoyExpression.forInt(MATH_MAX_DOUBLE.invoke(left.unboxAs(double.class),right.unboxAs(double.class)));
  }
 else {
    return SoyExpression.forSoyValue(NUMBER_TYPE,MAX_FN.invoke(left.box(),right.box()));
  }
}","/** 
 * @see com.google.template.soy.basicfunctions.MaxFunction
 */
private SoyExpression invokeMaxFunction(SoyExpression left,SoyExpression right){
  if (left.assignableToNullableInt() && right.assignableToNullableInt()) {
    return SoyExpression.forInt(MATH_MAX_LONG.invoke(left.unboxAs(long.class),right.unboxAs(long.class)));
  }
 else   if (left.assignableToNullableFloat() && right.assignableToNullableFloat()) {
    return SoyExpression.forFloat(MATH_MAX_DOUBLE.invoke(left.unboxAs(double.class),right.unboxAs(double.class)));
  }
 else {
    return SoyExpression.forSoyValue(NUMBER_TYPE,MAX_FN.invoke(left.box(),right.box()));
  }
}",0.9953125
29523,"@Override protected Statement visitSwitchNode(SwitchNode node){
  SoyExpression expression=exprCompiler.compile(node.getExpr());
  Statement init;
  List<IfBlock> cases=new ArrayList<>();
  Optional<Statement> defaultBlock=Optional.absent();
  Scope scope=variables.enterScope();
  Variable variable=scope.createSynthetic(SyntheticVarName.forSwitch(node),expression,STORE);
  init=variable.initializer();
  expression=expression.withSource(variable.local());
  for (  SoyNode child : node.getChildren()) {
    if (child instanceof SwitchCaseNode) {
      SwitchCaseNode caseNode=(SwitchCaseNode)child;
      Label reattachPoint=new Label();
      List<Expression> comparisons=new ArrayList<>();
      for (      ExprRootNode caseExpr : caseNode.getExprList()) {
        comparisons.add(compareSoyEquals(expression,exprCompiler.compile(caseExpr,reattachPoint)));
      }
      Expression condition=BytecodeUtils.logicalOr(comparisons).labelStart(reattachPoint);
      Statement block=visitChildrenInNewScope(caseNode);
      cases.add(IfBlock.create(condition,block));
    }
 else {
      SwitchDefaultNode defaultNode=(SwitchDefaultNode)child;
      defaultBlock=Optional.of(visitChildrenInNewScope(defaultNode));
    }
  }
  Statement exitScope=scope.exitScope();
  return Statement.concat(init,ControlFlow.ifElseChain(cases,defaultBlock),exitScope).withSourceLocation(node.getSourceLocation());
}","@Override protected Statement visitSwitchNode(SwitchNode node){
  List<SoyNode> children=node.getChildren();
  if (children.isEmpty()) {
    return Statement.NULL_STATEMENT;
  }
  if (children.size() == 1 && children.get(0) instanceof SwitchDefaultNode) {
    return visitChildrenInNewScope((SwitchDefaultNode)children.get(0));
  }
  SoyExpression expression=exprCompiler.compile(node.getExpr());
  Statement init;
  List<IfBlock> cases=new ArrayList<>();
  Optional<Statement> defaultBlock=Optional.absent();
  Scope scope=variables.enterScope();
  Variable variable=scope.createSynthetic(SyntheticVarName.forSwitch(node),expression,STORE);
  init=variable.initializer();
  expression=expression.withSource(variable.local());
  for (  SoyNode child : children) {
    if (child instanceof SwitchCaseNode) {
      SwitchCaseNode caseNode=(SwitchCaseNode)child;
      Label reattachPoint=new Label();
      List<Expression> comparisons=new ArrayList<>();
      for (      ExprRootNode caseExpr : caseNode.getExprList()) {
        comparisons.add(compareSoyEquals(expression,exprCompiler.compile(caseExpr,reattachPoint)));
      }
      Expression condition=BytecodeUtils.logicalOr(comparisons).labelStart(reattachPoint);
      Statement block=visitChildrenInNewScope(caseNode);
      cases.add(IfBlock.create(condition,block));
    }
 else {
      SwitchDefaultNode defaultNode=(SwitchDefaultNode)child;
      defaultBlock=Optional.of(visitChildrenInNewScope(defaultNode));
    }
  }
  Statement exitScope=scope.exitScope();
  return Statement.concat(init,ControlFlow.ifElseChain(cases,defaultBlock),exitScope).withSourceLocation(node.getSourceLocation());
}",0.9037328094302554
29524,"public void testDelCall_delVariant() throws IOException {
  String soyFileContent1=Joiner.on(""String_Node_Str"").join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  SoyFileSetNode soyTree=SoyFileSetParserBuilder.forFileContents(soyFileContent1).parse().fileSet();
  TemplateRegistry templateRegistry=new TemplateRegistry(soyTree,ExplodingErrorReporter.get());
  CompiledTemplates templates=BytecodeCompiler.compile(templateRegistry,false,ExplodingErrorReporter.get()).get();
  DelTemplateSelectorImpl.Factory selectorFactory=new DelTemplateSelectorImpl.Factory(templateRegistry,templates);
  CompiledTemplate.Factory factory=templates.getTemplateFactory(""String_Node_Str"");
  RenderContext context=DEFAULT_CONTEXT.toBuilder().withTemplateSelector(selectorFactory.create(ImmutableSet.<String>of())).build();
  AdvisingStringBuilder builder=new AdvisingStringBuilder();
  assertEquals(RenderResult.done(),factory.create(TemplateTester.asRecord(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"")),EMPTY_DICT).render(builder,context));
  assertThat(builder.getAndClearBuffer()).isEqualTo(""String_Node_Str"");
  assertEquals(RenderResult.done(),factory.create(TemplateTester.asRecord(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"")),EMPTY_DICT).render(builder,context));
  assertThat(builder.getAndClearBuffer()).isEqualTo(""String_Node_Str"");
  assertEquals(RenderResult.done(),factory.create(TemplateTester.asRecord(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"")),EMPTY_DICT).render(builder,context));
  assertThat(builder.toString()).isEqualTo(""String_Node_Str"");
}","public void testDelCall_delVariant() throws IOException {
  String soyFileContent1=Joiner.on(""String_Node_Str"").join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  SoyFileSetNode soyTree=SoyFileSetParserBuilder.forFileContents(soyFileContent1).parse().fileSet();
  TemplateRegistry templateRegistry=new TemplateRegistry(soyTree,ExplodingErrorReporter.get());
  CompiledTemplates templates=BytecodeCompiler.compile(templateRegistry,false,ExplodingErrorReporter.get()).get();
  DelTemplateSelectorImpl.Factory selectorFactory=new DelTemplateSelectorImpl.Factory(templateRegistry,templates);
  CompiledTemplate.Factory factory=templates.getTemplateFactory(""String_Node_Str"");
  RenderContext context=DEFAULT_CONTEXT.toBuilder().withTemplateSelector(selectorFactory.create(ImmutableSet.<String>of())).build();
  AdvisingStringBuilder builder=new AdvisingStringBuilder();
  assertEquals(RenderResult.done(),factory.create(TemplateTester.asRecord(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"")),EMPTY_DICT).render(builder,context));
  assertThat(builder.getAndClearBuffer()).isEqualTo(""String_Node_Str"");
  assertEquals(RenderResult.done(),factory.create(TemplateTester.asRecord(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"")),EMPTY_DICT).render(builder,context));
  assertThat(builder.getAndClearBuffer()).isEqualTo(""String_Node_Str"");
  assertEquals(RenderResult.done(),factory.create(TemplateTester.asRecord(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"")),EMPTY_DICT).render(builder,context));
  assertThat(builder.toString()).isEmpty();
}",0.992138791000271
29525,"/** 
 * Runs this pass on the given template.
 */
public boolean exec(TemplateNode template){
  List<TemplateParam> params=template.getParams();
  for (  TemplateParam param : params) {
    if (param.isRequired()) {
      return false;
    }
  }
  ExistsRegDataRefInExprVisitor helperVisitor=new ExistsRegDataRefInExprVisitor(errorReporter);
  SoytreeUtils.execOnAllV2ExprsShortcircuitably(template,helperVisitor,new Shortcircuiter<Void>(){
    @Override public boolean shouldShortcircuit(    AbstractNodeVisitor<ExprNode,Void> exprNodeVisitor){
      return ((ExistsRegDataRefInExprVisitor)exprNodeVisitor).foundRegDataRef();
    }
  }
,errorReporter);
  return helperVisitor.foundRegDataRef();
}","@Override public Boolean exec(Node node){
  visit(node);
  return shouldEnsureDataIsDefined;
}",0.179519595448799
29526,"private Statement putPlaceholderIntoMap(Expression mapExpression,MsgPlaceholderNode placeholder) throws AssertionError {
  StandaloneNode initialNode=placeholder.getChild(0);
  String mapKey=placeholder.getBaseVarName();
  Statement putEntyInMap;
  if (initialNode instanceof MsgHtmlTagNode) {
    putEntyInMap=addHtmlTagNodeToPlaceholderMap(mapExpression,mapKey,(MsgHtmlTagNode)initialNode);
  }
 else   if (initialNode instanceof CallNode) {
    putEntyInMap=addCallNodeToPlaceholderMap(mapExpression,mapKey,(CallNode)initialNode);
  }
 else   if (initialNode instanceof PrintNode) {
    putEntyInMap=addPrintNodeToPlaceholderMap(mapExpression,mapKey,(PrintNode)initialNode);
  }
 else {
    throw new AssertionError();
  }
  return putEntyInMap;
}","private void putPlaceholderIntoMap(Expression mapExpression,MsgNode originalMsg,Map<String,Statement> placeholderNameToPutStatement,SoyMsgPlaceholderPart placeholder) throws AssertionError {
  MsgPlaceholderNode repPlaceholderNode=originalMsg.getRepPlaceholderNode(placeholder.getPlaceholderName());
  String placeholderName=placeholder.getPlaceholderName();
  if (!placeholderNameToPutStatement.containsKey(placeholderName)) {
    StandaloneNode initialNode=repPlaceholderNode.getChild(0);
    Statement putEntyInMap;
    if (initialNode instanceof MsgHtmlTagNode) {
      putEntyInMap=addHtmlTagNodeToPlaceholderMap(mapExpression,placeholderName,(MsgHtmlTagNode)initialNode);
    }
 else     if (initialNode instanceof CallNode) {
      putEntyInMap=addCallNodeToPlaceholderMap(mapExpression,placeholderName,(CallNode)initialNode);
    }
 else     if (initialNode instanceof PrintNode) {
      putEntyInMap=addPrintNodeToPlaceholderMap(mapExpression,placeholderName,(PrintNode)initialNode);
    }
 else {
      throw new AssertionError();
    }
    placeholderNameToPutStatement.put(placeholder.getPlaceholderName(),putEntyInMap);
  }
}",0.6726694915254238
29527,"/** 
 * Handles a translation consisting of raw text with placeholders.
 */
private Statement handleTranslationWithPlaceholders(MsgNode msg,List<String> escapingDirectives,Expression soyMsg){
  Expression placeholderMap=variables.getMsgPlaceholderMapField().accessor(thisVar);
  Map<String,Statement> placeholderNameToPutStatement=new LinkedHashMap<>();
  putPlaceholdersIntoMap(placeholderMap,msg,placeholderNameToPutStatement);
  checkState(!placeholderNameToPutStatement.isEmpty());
  variables.setMsgPlaceholderMapMinSize(placeholderNameToPutStatement.size());
  Statement populateMap=Statement.concat(placeholderNameToPutStatement.values());
  Statement clearMap=placeholderMap.invokeVoid(MethodRef.LINKED_HASH_MAP_CLEAR);
  Statement render;
  if (escapingDirectives.isEmpty()) {
    render=MethodRef.RUNTIME_RENDER_SOY_MSG_WITH_PLACEHOLDERS.invokeVoid(soyMsg,placeholderMap,appendableExpression);
  }
 else {
    Statement renderToBuffer=MethodRef.RUNTIME_RENDER_SOY_MSG_WITH_PLACEHOLDERS.invokeVoid(soyMsg,placeholderMap,tempBuffer());
    SoyExpression value=SoyExpression.forString(tempBuffer().invoke(MethodRef.ADVISING_STRING_BUILDER_GET_AND_CLEAR));
    for (    String directive : escapingDirectives) {
      value=value.applyPrintDirective(variableLookup.getRenderContext(),directive);
    }
    render=Statement.concat(renderToBuffer,appendableExpression.appendString(value.coerceToString()).toStatement());
  }
  Statement detach=detachState.detachLimited(appendableExpression);
  return Statement.concat(populateMap,render,clearMap,detach).withSourceLocation(msg.getSourceLocation());
}","/** 
 * Handles a complex message with placeholders.
 */
private Statement handleTranslationWithPlaceholders(MsgNode msg,List<String> escapingDirectives,Expression soyMsg,ImmutableList<SoyMsgPart> parts){
  Expression placeholderMap=variables.getMsgPlaceholderMapField().accessor(thisVar);
  Map<String,Statement> placeholderNameToPutStatement=new LinkedHashMap<>();
  putPlaceholdersIntoMap(placeholderMap,msg,parts,placeholderNameToPutStatement);
  checkState(!placeholderNameToPutStatement.isEmpty());
  variables.setMsgPlaceholderMapMinSize(placeholderNameToPutStatement.size());
  Statement populateMap=Statement.concat(placeholderNameToPutStatement.values());
  Statement clearMap=placeholderMap.invokeVoid(MethodRef.LINKED_HASH_MAP_CLEAR);
  Statement render;
  if (escapingDirectives.isEmpty()) {
    render=MethodRef.RUNTIME_RENDER_SOY_MSG_WITH_PLACEHOLDERS.invokeVoid(soyMsg,placeholderMap,appendableExpression);
  }
 else {
    Statement renderToBuffer=MethodRef.RUNTIME_RENDER_SOY_MSG_WITH_PLACEHOLDERS.invokeVoid(soyMsg,placeholderMap,tempBuffer());
    SoyExpression value=SoyExpression.forString(tempBuffer().invoke(MethodRef.ADVISING_STRING_BUILDER_GET_AND_CLEAR));
    for (    String directive : escapingDirectives) {
      value=value.applyPrintDirective(variableLookup.getRenderContext(),directive);
    }
    render=Statement.concat(renderToBuffer,appendableExpression.appendString(value.coerceToString()).toStatement());
  }
  Statement detach=detachState.detachLimited(appendableExpression);
  return Statement.concat(populateMap,render,clearMap,detach).withSourceLocation(msg.getSourceLocation());
}",0.9742795165788658
29528,"/** 
 * Compiles the given   {@link MsgNode} to a statement with the given escaping directives applied.<p>The returned statement must be written to a location with a stack depth of zero.
 * @param id The computed msg id
 * @param msg The msg node
 * @param escapingDirectives The set of escaping directives to apply.
 */
Statement compileMessage(long id,MsgNode msg,List<String> escapingDirectives){
  Expression soyMsg=variableLookup.getRenderContext().invoke(MethodRef.RENDER_CONTEXT_GET_SOY_MSG,constant(id));
  Statement printMsg;
  if (msg.isRawTextMsg()) {
    printMsg=handleBasicTranslation(escapingDirectives,soyMsg);
  }
 else {
    printMsg=handleTranslationWithPlaceholders(msg,escapingDirectives,soyMsg);
  }
  return Statement.concat(printMsg.withSourceLocation(msg.getSourceLocation()),detachState.detachLimited(appendableExpression));
}","/** 
 * Compiles the given   {@link MsgNode} to a statement with the given escaping directives applied.<p>The returned statement must be written to a location with a stack depth of zero.
 * @param partsAndId The computed msg id
 * @param msg The msg node
 * @param escapingDirectives The set of escaping directives to apply.
 */
Statement compileMessage(MsgPartsAndIds partsAndId,MsgNode msg,List<String> escapingDirectives){
  Expression soyMsg=variableLookup.getRenderContext().invoke(MethodRef.RENDER_CONTEXT_GET_SOY_MSG,constant(partsAndId.id));
  Statement printMsg;
  if (msg.isRawTextMsg()) {
    printMsg=handleBasicTranslation(escapingDirectives,soyMsg);
  }
 else {
    printMsg=handleTranslationWithPlaceholders(msg,escapingDirectives,soyMsg,partsAndId.parts);
  }
  return Statement.concat(printMsg.withSourceLocation(msg.getSourceLocation()),detachState.detachLimited(appendableExpression));
}",0.9613196814562004
29529,"/** 
 * Adds a   {@link Statement} to {@link Map#put} every msg placeholder, plural variable and selectcase value into  {@code mapExpression}
 */
private void putPlaceholdersIntoMap(Expression mapExpression,ParentSoyNode<?> msg,Map<String,Statement> placeholderNameToPutStatement){
  for (  SoyNode child : msg.getChildren()) {
    String varName;
    boolean addPlaceholder=true;
    if (child instanceof MsgSubstUnitNode) {
      varName=((MsgSubstUnitNode)child).getBaseVarName();
      if (placeholderNameToPutStatement.containsKey(varName)) {
        addPlaceholder=false;
      }
    }
 else {
      continue;
    }
    if (child instanceof MsgPluralNode) {
      MsgPluralNode plural=(MsgPluralNode)child;
      if (addPlaceholder) {
        Label reattachPoint=new Label();
        Expression value=soyNodeCompiler.compileToInt(plural.getExpr(),reattachPoint);
        placeholderNameToPutStatement.put(varName,putToMap(mapExpression,varName,value).labelStart(reattachPoint));
      }
      for (      CaseOrDefaultNode caseOrDefault : plural.getChildren()) {
        putPlaceholdersIntoMap(mapExpression,caseOrDefault,placeholderNameToPutStatement);
      }
    }
 else     if (child instanceof MsgSelectNode) {
      MsgSelectNode select=(MsgSelectNode)child;
      if (addPlaceholder) {
        Label reattachPoint=new Label();
        Expression value=soyNodeCompiler.compileToString(select.getExpr(),reattachPoint);
        placeholderNameToPutStatement.put(varName,putToMap(mapExpression,varName,value).labelStart(reattachPoint));
      }
      for (      CaseOrDefaultNode caseOrDefault : select.getChildren()) {
        putPlaceholdersIntoMap(mapExpression,caseOrDefault,placeholderNameToPutStatement);
      }
    }
 else     if (child instanceof MsgPlaceholderNode) {
      if (addPlaceholder) {
        placeholderNameToPutStatement.put(varName,putPlaceholderIntoMap(mapExpression,(MsgPlaceholderNode)child));
      }
    }
 else {
      throw new AssertionError(""String_Node_Str"" + child);
    }
  }
}","/** 
 * Adds a   {@link Statement} to {@link Map#put} every msg placeholder, plural variable and selectcase value into  {@code mapExpression}
 */
private void putPlaceholdersIntoMap(Expression mapExpression,MsgNode originalMsg,Iterable<? extends SoyMsgPart> parts,Map<String,Statement> placeholderNameToPutStatement){
  for (  SoyMsgPart child : parts) {
    if (child instanceof SoyMsgRawTextPart || child instanceof SoyMsgPluralRemainderPart) {
      continue;
    }
    if (child instanceof SoyMsgPluralPart) {
      putPluralPartIntoMap(mapExpression,originalMsg,placeholderNameToPutStatement,(SoyMsgPluralPart)child);
    }
 else     if (child instanceof SoyMsgSelectPart) {
      putSelectPartIntoMap(mapExpression,originalMsg,placeholderNameToPutStatement,(SoyMsgSelectPart)child);
    }
 else     if (child instanceof SoyMsgPlaceholderPart) {
      putPlaceholderIntoMap(mapExpression,originalMsg,placeholderNameToPutStatement,(SoyMsgPlaceholderPart)child);
    }
 else {
      throw new AssertionError(""String_Node_Str"" + child);
    }
  }
}",0.3119505047215891
29530,"/** 
 * MsgFallbackGroupNodes have either one or two children.  In the 2 child case the second child is the   {@code} fallbackmsg}} entry.  For this we generate code that looks like: <pre>  {@code}if (renderContext.hasMsg(primaryId))  <render primary msg> } else { <render fallback msg> } }</pre> <p>All of the logic for actually rendering   {@code msg} nodes is handled by the{@link MsgCompiler}.
 */
@Override protected Statement visitMsgFallbackGroupNode(MsgFallbackGroupNode node){
  MsgNode msg=node.getMsg();
  long id=MsgUtils.computeMsgIdForDualFormat(msg);
  ImmutableList<String> escapingDirectives=node.getEscapingDirectiveNames();
  Statement renderDefault=getMsgCompiler().compileMessage(id,msg,escapingDirectives);
  if (node.hasFallbackMsg()) {
    MsgNode fallback=node.getFallbackMsg();
    long fallbackId=MsgUtils.computeMsgIdForDualFormat(node.getChild(1));
    IfBlock ifAvailableRenderDefault=IfBlock.create(variableLookup.getRenderContext().invoke(MethodRef.RENDER_CONTEXT_USE_PRIMARY_MSG,constant(id),constant(fallbackId)),renderDefault);
    return ControlFlow.ifElseChain(ImmutableList.of(ifAvailableRenderDefault),Optional.of(getMsgCompiler().compileMessage(fallbackId,fallback,escapingDirectives)));
  }
 else {
    return renderDefault;
  }
}","/** 
 * MsgFallbackGroupNodes have either one or two children.  In the 2 child case the second child is the   {@code} fallbackmsg}} entry.  For this we generate code that looks like: <pre>  {@code}if (renderContext.hasMsg(primaryId))  <render primary msg> } else { <render fallback msg> } }</pre> <p>All of the logic for actually rendering   {@code msg} nodes is handled by the{@link MsgCompiler}.
 */
@Override protected Statement visitMsgFallbackGroupNode(MsgFallbackGroupNode node){
  MsgNode msg=node.getMsg();
  MsgPartsAndIds idAndParts=MsgUtils.buildMsgPartsAndComputeMsgIdForDualFormat(msg);
  ImmutableList<String> escapingDirectives=node.getEscapingDirectiveNames();
  Statement renderDefault=getMsgCompiler().compileMessage(idAndParts,msg,escapingDirectives);
  if (node.hasFallbackMsg()) {
    MsgNode fallback=node.getFallbackMsg();
    MsgPartsAndIds fallbackIdAndParts=MsgUtils.buildMsgPartsAndComputeMsgIdForDualFormat(fallback);
    IfBlock ifAvailableRenderDefault=IfBlock.create(variableLookup.getRenderContext().invoke(MethodRef.RENDER_CONTEXT_USE_PRIMARY_MSG,constant(idAndParts.id),constant(fallbackIdAndParts.id)),renderDefault);
    return ControlFlow.ifElseChain(ImmutableList.of(ifAvailableRenderDefault),Optional.of(getMsgCompiler().compileMessage(fallbackIdAndParts,fallback,escapingDirectives)));
  }
 else {
    return renderDefault;
  }
}",0.9340909090909092
29531,"/** 
 * Return a   {@link SanitizedContent} valued continuation.  Rendering logic is delegated to the {@link WriteContinuation}, but it is assumed that the builder is the render target.
 */
static Continuation<SanitizedContent> strictContinuation(WriteContinuation delegate,AdvisingStringBuilder builder,final ContentKind kind){
  if (delegate.result().isDone()) {
    return new ResultContinuation<>(UnsafeSanitizedContentOrdainer.ordainAsSafe(builder.toString(),kind));
  }
  return new AbstractContinuation<SanitizedContent>(delegate,builder){
    @Override Continuation<SanitizedContent> nextContinuation(    WriteContinuation next){
      return strictContinuation(delegate,builder,kind);
    }
  }
;
}","/** 
 * Return a   {@link SanitizedContent} valued continuation.  Rendering logic is delegated to the {@link WriteContinuation}, but it is assumed that the builder is the render target.
 */
static Continuation<SanitizedContent> strictContinuation(WriteContinuation delegate,AdvisingStringBuilder builder,final ContentKind kind){
  if (delegate.result().isDone()) {
    return new ResultContinuation<>(UnsafeSanitizedContentOrdainer.ordainAsSafe(builder.toString(),kind));
  }
  return new AbstractContinuation<SanitizedContent>(delegate,builder){
    @Override Continuation<SanitizedContent> nextContinuation(    WriteContinuation next){
      return strictContinuation(next,builder,kind);
    }
  }
;
}",0.9914893617021276
29532,"private VarRefNode(VarRefNode orig){
  super(orig);
  this.name=orig.name;
  this.isInjected=orig.isInjected;
  this.isNullSafeInjected=orig.isNullSafeInjected;
  this.defn=orig.defn;
}","private VarRefNode(VarRefNode orig){
  super(orig);
  this.name=orig.name;
  this.isInjected=orig.isInjected;
  this.isNullSafeInjected=orig.isNullSafeInjected;
  this.subtituteType=orig.subtituteType;
  this.defn=orig.defn;
}",0.9002433090024331
29533,"private void compile(){
  if (classData == null) {
    SoyFileSetNode fileSet=SoyFileSetParserBuilder.forFileContents(getSubject()).typeRegistry(typeRegistry).parse();
    new UnsupportedFeatureReporter(ExplodingErrorReporter.get()).check(fileSet);
    SoyMsgBundle messages=new ExtractMsgsVisitor(ExplodingErrorReporter.get()).exec(fileSet);
    SoyMsgBundle defaultBundle=messages;
    if (this.msgBundle != null) {
      messages=this.msgBundle;
    }
    defaultContext=defaultContext.toBuilder().withMessageBundles(messages,defaultBundle).build();
    TemplateRegistry registry=new TemplateRegistry(fileSet,ExplodingErrorReporter.get());
    CompiledTemplateRegistry compilerRegistry=new CompiledTemplateRegistry(registry);
    String templateName=Iterables.getOnlyElement(registry.getBasicTemplatesMap().keySet());
    CompiledTemplateMetadata classInfo=compilerRegistry.getTemplateInfo(templateName);
    classData=new TemplateCompiler(compilerRegistry,classInfo,ExplodingErrorReporter.get()).compile();
    checkClasses(classData);
    factory=BytecodeCompiler.loadFactory(classInfo,new MemoryClassLoader.Builder().addAll(classData).build());
  }
}","private void compile(){
  if (classData == null) {
    SoyFileSetNode fileSet=SoyFileSetParserBuilder.forFileContents(getSubject()).typeRegistry(typeRegistry).parse();
    new UnsupportedFeatureReporter(ExplodingErrorReporter.get()).check(fileSet);
    fileSet=SoytreeUtils.cloneNode(fileSet);
    SoyMsgBundle messages=new ExtractMsgsVisitor(ExplodingErrorReporter.get()).exec(fileSet);
    SoyMsgBundle defaultBundle=messages;
    if (this.msgBundle != null) {
      messages=this.msgBundle;
    }
    defaultContext=defaultContext.toBuilder().withMessageBundles(messages,defaultBundle).build();
    TemplateRegistry registry=new TemplateRegistry(fileSet,ExplodingErrorReporter.get());
    CompiledTemplateRegistry compilerRegistry=new CompiledTemplateRegistry(registry);
    String templateName=Iterables.getOnlyElement(registry.getBasicTemplatesMap().keySet());
    CompiledTemplateMetadata classInfo=compilerRegistry.getTemplateInfo(templateName);
    classData=new TemplateCompiler(compilerRegistry,classInfo,ExplodingErrorReporter.get()).compile();
    checkClasses(classData);
    factory=BytecodeCompiler.loadFactory(classInfo,new MemoryClassLoader.Builder().addAll(classData).build());
  }
}",0.9809079338141704
29534,"public void testFloatExpressions(){
  SoyExpression expr=SoyExpression.forFloat(constant(12.34D));
  assertThatExpression(expr).evaluatesTo(12.34D);
  assertThatExpression(expr.box()).evaluatesTo(FloatData.forValue(12.34D));
  assertThatExpression(expr.box().convert(double.class)).evaluatesTo(12.34D);
  assertThatExpression(expr.convert(boolean.class)).evaluatesTo(true);
  assertThatExpression(SoyExpression.forFloat(constant(0D)).convert(boolean.class)).evaluatesTo(false);
  assertThatExpression(expr.convert(String.class)).evaluatesTo(""String_Node_Str"");
}","public void testFloatExpressions(){
  SoyExpression expr=SoyExpression.forFloat(constant(12.34D));
  assertThatExpression(expr).evaluatesTo(12.34D);
  assertThatExpression(expr.box()).evaluatesTo(FloatData.forValue(12.34D));
  assertThatExpression(expr.box().convert(double.class)).evaluatesTo(12.34D);
  assertThatExpression(SoyExpression.forSoyValue(FloatType.getInstance(),expr.box()).convert(String.class)).evaluatesTo(""String_Node_Str"");
  assertThatExpression(expr.convert(boolean.class)).evaluatesTo(true);
  assertThatExpression(SoyExpression.forFloat(constant(0D)).convert(boolean.class)).evaluatesTo(false);
  assertThatExpression(expr.convert(String.class)).evaluatesTo(""String_Node_Str"");
}",0.6091772151898734
29535,"public void testIntExpressions(){
  SoyExpression expr=SoyExpression.forInt(constant(12L));
  assertThatExpression(expr).evaluatesTo(12L);
  assertThatExpression(expr.box()).evaluatesTo(IntegerData.forValue(12));
  assertThatExpression(expr.box().convert(long.class)).evaluatesTo(12L);
  assertThatExpression(expr.convert(boolean.class)).evaluatesTo(true);
  assertThatExpression(SoyExpression.forInt(constant(0L)).convert(boolean.class)).evaluatesTo(false);
  assertThatExpression(expr.convert(String.class)).evaluatesTo(""String_Node_Str"");
}","public void testIntExpressions(){
  SoyExpression expr=SoyExpression.forInt(constant(12L));
  assertThatExpression(expr).evaluatesTo(12L);
  assertThatExpression(expr.box()).evaluatesTo(IntegerData.forValue(12));
  assertThatExpression(expr.box().convert(long.class)).evaluatesTo(12L);
  assertThatExpression(expr.convert(double.class)).evaluatesTo(12D);
  assertThatExpression(SoyExpression.forSoyValue(AnyType.getInstance(),expr.box()).convert(double.class)).evaluatesTo(12D);
  assertThatExpression(expr.convert(boolean.class)).evaluatesTo(true);
  assertThatExpression(SoyExpression.forInt(constant(0L)).convert(boolean.class)).evaluatesTo(false);
  assertThatExpression(expr.convert(String.class)).evaluatesTo(""String_Node_Str"");
}",0.8491008600469117
29536,"@Override public Expression resolveSoyValueProvider(final Expression soyValueProvider){
  soyValueProvider.checkAssignableTo(Type.getType(SoyValueProvider.class));
  return new SimpleExpression(Type.getType(SoyValue.class),false){
    @Override void doGen(    GeneratorAdapter adapter){
      soyValueProvider.gen(adapter);
      adapter.dup();
      MethodRef.SOY_VALUE_PROVIDER_STATUS.invokeUnchecked(adapter);
      adapter.dup();
      MethodRef.RENDER_RESULT_IS_DONE.invokeUnchecked(adapter);
      adapter.ifZCmp(Opcodes.IFEQ,detachPoint);
      adapter.pop();
      MethodRef.SOY_VALUE_PROVIDER_RESOLVE.invokeUnchecked(adapter);
    }
  }
;
}","@Override public Expression resolveSoyValueProvider(final Expression soyValueProvider){
  soyValueProvider.checkAssignableTo(Type.getType(SoyValueProvider.class));
  return new SimpleExpression(Type.getType(SoyValue.class),false){
    @Override void doGen(    GeneratorAdapter adapter){
      soyValueProvider.gen(adapter);
      adapter.dup();
      MethodRef.SOY_VALUE_PROVIDER_STATUS.invokeUnchecked(adapter);
      adapter.dup();
      MethodRef.RENDER_RESULT_IS_DONE.invokeUnchecked(adapter);
      Label resolve=new Label();
      adapter.ifZCmp(Opcodes.IFNE,resolve);
      saveOperation.gen(adapter);
      adapter.returnValue();
      adapter.mark(resolve);
      adapter.pop();
      MethodRef.SOY_VALUE_PROVIDER_RESOLVE.invokeUnchecked(adapter);
    }
  }
;
}",0.8964059196617337
29537,"@Override public Expression makeDetachable(final Expression exp){
  return new SimpleExpression(exp.resultType(),exp.isConstant()){
    @Override void doGen(    GeneratorAdapter adapter){
      adapter.mark(reattachPoint);
      exp.gen(adapter);
      Label skip=new Label();
      adapter.goTo(skip);
      adapter.mark(detachPoint);
      saveOperation.gen(adapter);
      adapter.returnValue();
      adapter.mark(skip);
    }
  }
;
}","@Override public Expression makeDetachable(final Expression exp){
  return new SimpleExpression(exp.resultType(),exp.isConstant()){
    @Override void doGen(    GeneratorAdapter adapter){
      adapter.mark(reattachPoint);
      exp.gen(adapter);
    }
  }
;
}",0.7277936962750716
29538,"@Override public String apply(String singleQuoted){
  if (singleQuoted.length() < 2 || singleQuoted.charAt(0) != '\'' || singleQuoted.charAt(singleQuoted.length() - 1) != '\'') {
    throw new IllegalArgumentException(String.format(""String_Node_Str"" + ""String_Node_Str"",singleQuoted));
  }
  return singleQuoted.substring(1,singleQuoted.length() - 1);
}","@Override public String apply(TargetExpr expr){
  return expr.getText();
}",0.2857142857142857
29539,"/** 
 * Converts a list of TargetExpr's into a list of safe tags as an argument for the supported backends. This will iterate over the expressions, ensure they're valid safe tags, and convert them into an array of Strings. <p>The generated output is valid for JS and Python. Any other languages should reevaluate if they require changes.
 * @param args A list of possible safe tags.
 * @return A string containing the safe tags argument.
 */
private String generateOptionalSafeTagsArg(List<? extends TargetExpr> args){
  String optionalSafeTagsArg=""String_Node_Str"";
  if (!args.isEmpty()) {
    Iterable<String> optionalSafeTagExprs=Iterables.transform(args,TARGET_EXPR_TO_STRING);
    FluentIterable.from(optionalSafeTagExprs).transform(SINGLE_QUOTED_TO_UNQUOTED).transform(OptionalSafeTag.FROM_TAG_NAME).toSet();
    optionalSafeTagsArg=""String_Node_Str"" + ARG_JOINER.join(optionalSafeTagExprs) + ""String_Node_Str"";
  }
  return optionalSafeTagsArg;
}","/** 
 * Converts a list of TargetExpr's into a list of safe tags as an argument for the supported backends. This will iterate over the expressions, ensure they're valid safe tags, and convert them into an array of Strings. <p>The generated output is valid for JS and Python. Any other languages should reevaluate if they require changes.
 * @param args A list of possible safe tags.
 * @return A string containing the safe tags argument.
 */
private String generateOptionalSafeTagsArg(List<? extends TargetExpr> args){
  String optionalSafeTagsArg=""String_Node_Str"";
  if (!args.isEmpty()) {
    Iterable<String> optionalSafeTagExprs=Iterables.transform(args,TARGET_EXPR_TO_STRING);
    for (    String singleQuoted : optionalSafeTagExprs) {
      if (singleQuoted.length() < 2 || singleQuoted.charAt(0) != '\'' || singleQuoted.charAt(singleQuoted.length() - 1) != '\'') {
        throw new IllegalArgumentException(String.format(""String_Node_Str"" + ""String_Node_Str"",singleQuoted));
      }
      String tagName=singleQuoted.substring(1,singleQuoted.length() - 1);
      OptionalSafeTag.fromTagName(tagName);
    }
    optionalSafeTagsArg=""String_Node_Str"" + ARG_JOINER.join(optionalSafeTagExprs) + ""String_Node_Str"";
  }
  return optionalSafeTagsArg;
}",0.7753623188405797
29540,"/** 
 * Constructor.
 * @param soyTree The Soy tree from which to build a template registry.
 */
public TemplateRegistry(SoyFileSetNode soyTree){
  Map<String,TemplateBasicNode> tempBasicTemplatesMap=Maps.newHashMap();
  Map<String,Set<DelTemplateKey>> tempDelTemplateNameToKeysMap=Maps.newHashMap();
  Map<DelTemplateKey,Map<Integer,Map<String,TemplateDelegateNode>>> tempDelTemplatesMap=Maps.newHashMap();
  for (  SoyFileNode soyFile : soyTree.getChildren()) {
    for (    TemplateNode template : soyFile.getChildren()) {
      if (template instanceof TemplateBasicNode) {
        tempBasicTemplatesMap.put(template.getTemplateName(),(TemplateBasicNode)template);
      }
 else {
        TemplateDelegateNode delTemplate=(TemplateDelegateNode)template;
        DelTemplateKey delTemplateKey=delTemplate.getDelTemplateKey();
        String delTemplateName=delTemplate.getDelTemplateName();
        Set<DelTemplateKey> keys=tempDelTemplateNameToKeysMap.get(delTemplateName);
        if (keys == null) {
          keys=Sets.newLinkedHashSet();
          tempDelTemplateNameToKeysMap.put(delTemplateName,keys);
        }
        keys.add(delTemplateKey);
        int delPriority=delTemplate.getDelPriority();
        String delPackageName=delTemplate.getDelPackageName();
        Map<Integer,Map<String,TemplateDelegateNode>> tempDivisions=tempDelTemplatesMap.get(delTemplateKey);
        if (tempDivisions == null) {
          tempDivisions=Maps.newHashMap();
          tempDelTemplatesMap.put(delTemplateKey,tempDivisions);
        }
        Map<String,TemplateDelegateNode> tempDivision=tempDivisions.get(delPriority);
        if (tempDivision == null) {
          tempDivision=Maps.newHashMap();
          tempDivisions.put(delPriority,tempDivision);
        }
        if (tempDivision.containsKey(delPackageName)) {
          TemplateDelegateNode prevTemplate=tempDivision.get(delPackageName);
          String prevTemplateFilePath=prevTemplate.getNearestAncestor(SoyFileNode.class).getFilePath();
          String currTemplateFilePath=delTemplate.getNearestAncestor(SoyFileNode.class).getFilePath();
          String errorMsgPrefix=(delPackageName == null) ? ""String_Node_Str"" : ""String_Node_Str"";
          if (currTemplateFilePath != null && currTemplateFilePath.equals(prevTemplateFilePath)) {
            throw SoySyntaxException.createWithoutMetaInfo(String.format(errorMsgPrefix + ""String_Node_Str"",delTemplateKey,currTemplateFilePath));
          }
 else {
            throw SoySyntaxException.createWithoutMetaInfo(String.format(errorMsgPrefix + ""String_Node_Str"",delTemplateKey,prevTemplateFilePath,currTemplateFilePath));
          }
        }
        tempDivision.put(delPackageName,delTemplate);
      }
    }
  }
  basicTemplatesMap=Collections.unmodifiableMap(tempBasicTemplatesMap);
  ImmutableMap.Builder<DelTemplateKey,List<DelegateTemplateDivision>> delTemplatesMapBuilder=ImmutableMap.builder();
  for (  DelTemplateKey delTemplateKey : tempDelTemplatesMap.keySet()) {
    Map<Integer,Map<String,TemplateDelegateNode>> tempDivisions=tempDelTemplatesMap.get(delTemplateKey);
    ImmutableList.Builder<DelegateTemplateDivision> divisionsBuilder=ImmutableList.builder();
    for (int priority=TemplateNode.MAX_PRIORITY; priority >= 0; priority--) {
      if (!tempDivisions.containsKey(priority)) {
        continue;
      }
      Map<String,TemplateDelegateNode> tempDivision=tempDivisions.get(priority);
      DelegateTemplateDivision division=new DelegateTemplateDivision(priority,tempDivision);
      divisionsBuilder.add(division);
    }
    delTemplatesMapBuilder.put(delTemplateKey,divisionsBuilder.build());
  }
  delTemplatesMap=delTemplatesMapBuilder.build();
  delTemplateNameToKeysMap=Collections.unmodifiableMap(tempDelTemplateNameToKeysMap);
}","/** 
 * Constructor.
 * @param soyTree The Soy tree from which to build a template registry.
 */
public TemplateRegistry(SoyFileSetNode soyTree){
  Map<String,TemplateBasicNode> tempBasicTemplatesMap=new LinkedHashMap<>();
  Map<String,Set<DelTemplateKey>> tempDelTemplateNameToKeysMap=new LinkedHashMap<>();
  Map<DelTemplateKey,Map<Integer,Map<String,TemplateDelegateNode>>> tempDelTemplatesMap=new LinkedHashMap<>();
  for (  SoyFileNode soyFile : soyTree.getChildren()) {
    for (    TemplateNode template : soyFile.getChildren()) {
      if (template instanceof TemplateBasicNode) {
        tempBasicTemplatesMap.put(template.getTemplateName(),(TemplateBasicNode)template);
      }
 else {
        TemplateDelegateNode delTemplate=(TemplateDelegateNode)template;
        DelTemplateKey delTemplateKey=delTemplate.getDelTemplateKey();
        String delTemplateName=delTemplate.getDelTemplateName();
        Set<DelTemplateKey> keys=tempDelTemplateNameToKeysMap.get(delTemplateName);
        if (keys == null) {
          keys=Sets.newLinkedHashSet();
          tempDelTemplateNameToKeysMap.put(delTemplateName,keys);
        }
        keys.add(delTemplateKey);
        int delPriority=delTemplate.getDelPriority();
        String delPackageName=delTemplate.getDelPackageName();
        Map<Integer,Map<String,TemplateDelegateNode>> tempDivisions=tempDelTemplatesMap.get(delTemplateKey);
        if (tempDivisions == null) {
          tempDivisions=new LinkedHashMap<>();
          tempDelTemplatesMap.put(delTemplateKey,tempDivisions);
        }
        Map<String,TemplateDelegateNode> tempDivision=tempDivisions.get(delPriority);
        if (tempDivision == null) {
          tempDivision=new LinkedHashMap<>();
          tempDivisions.put(delPriority,tempDivision);
        }
        if (tempDivision.containsKey(delPackageName)) {
          TemplateDelegateNode prevTemplate=tempDivision.get(delPackageName);
          String prevTemplateFilePath=prevTemplate.getNearestAncestor(SoyFileNode.class).getFilePath();
          String currTemplateFilePath=delTemplate.getNearestAncestor(SoyFileNode.class).getFilePath();
          String errorMsgPrefix=(delPackageName == null) ? ""String_Node_Str"" : ""String_Node_Str"";
          if (currTemplateFilePath != null && currTemplateFilePath.equals(prevTemplateFilePath)) {
            throw SoySyntaxException.createWithoutMetaInfo(String.format(errorMsgPrefix + ""String_Node_Str"",delTemplateKey,currTemplateFilePath));
          }
 else {
            throw SoySyntaxException.createWithoutMetaInfo(String.format(errorMsgPrefix + ""String_Node_Str"",delTemplateKey,prevTemplateFilePath,currTemplateFilePath));
          }
        }
        tempDivision.put(delPackageName,delTemplate);
      }
    }
  }
  basicTemplatesMap=Collections.unmodifiableMap(tempBasicTemplatesMap);
  ImmutableMap.Builder<DelTemplateKey,List<DelegateTemplateDivision>> delTemplatesMapBuilder=ImmutableMap.builder();
  for (  DelTemplateKey delTemplateKey : tempDelTemplatesMap.keySet()) {
    Map<Integer,Map<String,TemplateDelegateNode>> tempDivisions=tempDelTemplatesMap.get(delTemplateKey);
    ImmutableList.Builder<DelegateTemplateDivision> divisionsBuilder=ImmutableList.builder();
    for (int priority=TemplateNode.MAX_PRIORITY; priority >= 0; priority--) {
      if (!tempDivisions.containsKey(priority)) {
        continue;
      }
      Map<String,TemplateDelegateNode> tempDivision=tempDivisions.get(priority);
      DelegateTemplateDivision division=new DelegateTemplateDivision(priority,tempDivision);
      divisionsBuilder.add(division);
    }
    delTemplatesMapBuilder.put(delTemplateKey,divisionsBuilder.build());
  }
  delTemplatesMap=delTemplatesMapBuilder.build();
  delTemplateNameToKeysMap=Collections.unmodifiableMap(tempDelTemplateNameToKeysMap);
}",0.9907627342306676
29541,"public DelegateTemplateDivision(int delPriority,Map<String,TemplateDelegateNode> delPackageNameToDelTemplateMap){
  this.delPriority=delPriority;
  this.delPackageNameToDelTemplateMap=Collections.unmodifiableMap(Maps.newHashMap(delPackageNameToDelTemplateMap));
}","public DelegateTemplateDivision(int delPriority,Map<String,TemplateDelegateNode> delPackageNameToDelTemplateMap){
  this.delPriority=delPriority;
  this.delPackageNameToDelTemplateMap=Collections.unmodifiableMap(Maps.newLinkedHashMap(delPackageNameToDelTemplateMap));
}",0.9887218045112782
29542,"private void checkCallParamTypes(CallNode call,TemplateNode callee){
  TemplateParamTypes calleeParamTypes=getTemplateParamTypes(callee);
  Set<String> explicitParams=Sets.newHashSet();
  for (  CallParamNode callerParam : call.getChildren()) {
    SoyType argType=null;
    if (callerParam.getKind() == SoyNode.Kind.CALL_PARAM_VALUE_NODE) {
      ExprNode expr=((CallParamValueNode)callerParam).getValueExprUnion().getExpr();
      if (expr != null) {
        argType=expr.getType();
      }
    }
 else     if (callerParam.getKind() == SoyNode.Kind.CALL_PARAM_CONTENT_NODE) {
      argType=SanitizedType.getTypeForContentKind(((CallParamContentNode)callerParam).getContentKind());
    }
    if (argType == null) {
      continue;
    }
    Collection<SoyType> declaredParamTypes=calleeParamTypes.params.get(callerParam.getKey());
    for (    SoyType formalType : declaredParamTypes) {
      checkArgumentAgainstParamType(call,callerParam.getKey(),argType,formalType,calleeParamTypes.isIndirect(callerParam.getKey()));
    }
    explicitParams.add(callerParam.getKey());
  }
  if (call.isPassingData()) {
    if (call.isPassingAllData() && template.getParams() != null) {
      for (      TemplateParam callerParam : template.getParams()) {
        if (!(callerParam instanceof HeaderParam)) {
          continue;
        }
        String paramName=callerParam.name();
        if (explicitParams.contains(paramName)) {
          continue;
        }
        Collection<SoyType> declaredParamTypes=calleeParamTypes.params.get(paramName);
        for (        SoyType formalType : declaredParamTypes) {
          checkArgumentAgainstParamType(call,paramName,callerParam.type(),formalType,calleeParamTypes.isIndirect(paramName));
        }
      }
    }
 else {
    }
  }
}","private void checkCallParamTypes(CallNode call,TemplateNode callee){
  TemplateParamTypes calleeParamTypes=getTemplateParamTypes(callee);
  Set<String> explicitParams=Sets.newHashSet();
  for (  CallParamNode callerParam : call.getChildren()) {
    SoyType argType=null;
    if (callerParam.getKind() == SoyNode.Kind.CALL_PARAM_VALUE_NODE) {
      ExprNode expr=((CallParamValueNode)callerParam).getValueExprUnion().getExpr();
      if (expr != null) {
        argType=expr.getType();
      }
    }
 else     if (callerParam.getKind() == SoyNode.Kind.CALL_PARAM_CONTENT_NODE) {
      argType=SanitizedType.getTypeForContentKind(((CallParamContentNode)callerParam).getContentKind());
    }
    if (argType != null) {
      Collection<SoyType> declaredParamTypes=calleeParamTypes.params.get(callerParam.getKey());
      for (      SoyType formalType : declaredParamTypes) {
        checkArgumentAgainstParamType(call,callerParam.getKey(),argType,formalType,calleeParamTypes.isIndirect(callerParam.getKey()));
      }
    }
    explicitParams.add(callerParam.getKey());
  }
  if (call.isPassingData()) {
    if (call.isPassingAllData() && template.getParams() != null) {
      for (      TemplateParam callerParam : template.getParams()) {
        if (!(callerParam instanceof HeaderParam)) {
          continue;
        }
        String paramName=callerParam.name();
        if (explicitParams.contains(paramName)) {
          continue;
        }
        Collection<SoyType> declaredParamTypes=calleeParamTypes.params.get(paramName);
        for (        SoyType formalType : declaredParamTypes) {
          checkArgumentAgainstParamType(call,paramName,callerParam.type(),formalType,calleeParamTypes.isIndirect(paramName));
        }
      }
    }
 else {
    }
  }
}",0.9898190045248868
29543,"public void testNullableIndirectParams(){
  assertValidSoyFiles(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testNullableIndirectParams(){
  assertValidSoyFiles(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9794520547945206
29544,"public void testNoArgumentTypeMismatch(){
  assertValidSoyFiles(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertValidSoyFiles(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testNoArgumentTypeMismatch(){
  assertValidSoyFiles(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertValidSoyFiles(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.975
29545,"public void testIndirectParams(){
  assertInvalidSoyFiles(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertValidSoyFiles(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testIndirectParams(){
  assertInvalidSoyFiles(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertValidSoyFiles(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9897025171624714
29546,"public final void testOutputPathFormatFlag() throws Exception {
  File soyFile=getTempFile(""String_Node_Str"");
  Files.write(""String_Node_Str"",soyFile,UTF_8);
  String dir=soyFile.getParent().toString();
  String name=soyFile.getName();
  File xmlFile=new File(dir,name.substring(0,name.length() - 4) + ""String_Node_Str"");
  SoyMsgExtractor.main(""String_Node_Str"",""String_Node_Str"",soyFile.toString());
  String xmlContent=Files.toString(xmlFile,UTF_8);
  assertTrue(xmlContent,xmlContent.contains(""String_Node_Str""));
}","public final void testOutputPathFormatFlag() throws Exception {
  File soyFile=getTempFile(""String_Node_Str"");
  Files.write(""String_Node_Str"" + ""String_Node_Str"",soyFile,UTF_8);
  String dir=soyFile.getParent().toString();
  String name=soyFile.getName();
  File xmlFile=new File(dir,name.substring(0,name.length() - 4) + ""String_Node_Str"");
  SoyMsgExtractor.main(""String_Node_Str"",""String_Node_Str"",soyFile.toString());
  String xmlContent=Files.toString(xmlFile,UTF_8);
  assertTrue(xmlContent,xmlContent.contains(""String_Node_Str""));
}",0.981132075471698
29547,"public final void testOutputFileFlag() throws Exception {
  File soyFile1=getTempFile(""String_Node_Str"");
  Files.write(""String_Node_Str"",soyFile1,UTF_8);
  File soyFile2=getTempFile(""String_Node_Str"");
  Files.write(""String_Node_Str"",soyFile2,UTF_8);
  File xmlFile=getTempFile(""String_Node_Str"");
  SoyMsgExtractor.main(""String_Node_Str"",xmlFile.toString(),soyFile1.toString(),soyFile2.toString());
  String xmlContent=Files.toString(xmlFile,UTF_8);
  assertTrue(xmlContent,xmlContent.contains(""String_Node_Str""));
  assertTrue(xmlContent,xmlContent.contains(""String_Node_Str""));
}","public final void testOutputFileFlag() throws Exception {
  File soyFile1=getTempFile(""String_Node_Str"");
  Files.write(""String_Node_Str"" + ""String_Node_Str"",soyFile1,UTF_8);
  File soyFile2=getTempFile(""String_Node_Str"");
  Files.write(""String_Node_Str"" + ""String_Node_Str"",soyFile2,UTF_8);
  File xmlFile=getTempFile(""String_Node_Str"");
  SoyMsgExtractor.main(""String_Node_Str"",xmlFile.toString(),soyFile1.toString(),soyFile2.toString());
  String xmlContent=Files.toString(xmlFile,UTF_8);
  assertTrue(xmlContent,xmlContent.contains(""String_Node_Str""));
  assertTrue(xmlContent,xmlContent.contains(""String_Node_Str""));
}",0.966832504145937
29548,"/** 
 * @return The original error message from the Soy compiler without anymetadata about the location where the error appears.  
 */
public String getOriginalMessage(){
  return super.getMessage();
}","/** 
 * @return The original error message from the Soy compiler without anymetadata about the location where the error appears.
 */
public String getOriginalMessage(){
  return super.getMessage();
}",0.995
29549,"/** 
 * Parses a response from the network or cache and delivers it. The provided Runnable will be executed after delivery.
 */
public void postResponse(Request<?> request,Response<?> response,Runnable runnable);","/** 
 * Parses a response from the network or cache and delivers it. The provided Runnable will be executed after delivery.
 */
void postResponse(Request<?> request,Response<?> response,Runnable runnable);",0.9832134292565948
29550,"/** 
 * Posts an error for the given request.
 */
public void postError(Request<?> request,NetroidError error);","/** 
 * Posts an error for the given request.
 */
void postError(Request<?> request,NetroidError error);",0.9674418604651164
29551,"/** 
 * Set the request delivery that use to post http networking callbacks.
 */
public void setDelivery(Delivery delivery);","/** 
 * Set the request delivery that use to post http networking callbacks.
 */
void setDelivery(Delivery delivery);",0.970954356846473
29552,"/** 
 * Performs the specified request.
 * @param request Request to process
 * @return A {@link NetworkResponse} with data and caching metadata; will never be null
 * @throws NetroidError on errors
 */
public NetworkResponse performRequest(Request<?> request) throws NetroidError ;","/** 
 * Performs the specified request.
 * @param request Request to process
 * @return A {@link NetworkResponse} with data and caching metadata; will never be null
 * @throws NetroidError on errors
 */
NetworkResponse performRequest(Request<?> request) throws NetroidError ;",0.9874326750448832
29553,"/** 
 * Returns the current timeout (used for logging).
 */
public int getCurrentTimeout();","/** 
 * Returns the current timeout (used for logging).
 */
int getCurrentTimeout();",0.96
29554,"/** 
 * Returns the current retry count (used for logging).
 */
public int getCurrentRetryCount();","/** 
 * Returns the current retry count (used for logging).
 */
int getCurrentRetryCount();",0.9629629629629628
29555,"/** 
 * Prepares for the next retry by applying a backoff to the timeout.
 * @param error The error code of the last attempt.
 * @throws NetroidError In the event that the retry could not be performed (for example if weran out of attempts), the passed in error is thrown.
 */
public void retry(NetroidError error) throws NetroidError ;","/** 
 * Prepares for the next retry by applying a backoff to the timeout.
 * @param error The error code of the last attempt.
 * @throws NetroidError In the event that the retry could not be performed (for example if weran out of attempts), the passed in error is thrown.
 */
void retry(NetroidError error) throws NetroidError ;",0.9894419306184012
29556,"/** 
 * Initializes the DiskCache by scanning for all files currently in the specified root directory. Creates the root directory if necessary.
 */
public synchronized void initialize(){
  if (!mRootDirectory.exists()) {
    if (!mRootDirectory.mkdirs()) {
      NetroidLog.e(""String_Node_Str"",mRootDirectory.getAbsolutePath());
    }
    return;
  }
  File[] files=mRootDirectory.listFiles();
  if (files == null) {
    return;
  }
  for (  File file : files) {
    FileInputStream fis=null;
    try {
      fis=new FileInputStream(file);
      CacheHeader entry=CacheHeader.readHeader(fis);
      if (entry.isExpired()) {
        file.delete();
      }
 else {
        entry.size=file.length();
        putEntry(entry.key,entry);
      }
    }
 catch (    IOException e) {
      if (file != null) {
        file.delete();
      }
    }
 finally {
      try {
        if (fis != null) {
          fis.close();
        }
      }
 catch (      IOException ignored) {
      }
    }
  }
}","/** 
 * Initializes the DiskCache by scanning for all files currently in the specified root directory. Creates the root directory if necessary.
 */
public synchronized void initialize(){
  if (!mRootDirectory.exists()) {
    if (!mRootDirectory.mkdirs()) {
      NetroidLog.e(""String_Node_Str"",mRootDirectory.getAbsolutePath());
    }
    return;
  }
  File[] files=mRootDirectory.listFiles();
  if (files == null) {
    return;
  }
  for (  File file : files) {
    FileInputStream fis=null;
    try {
      fis=new FileInputStream(file);
      CacheHeader entry=CacheHeader.readHeader(fis);
      if (entry.isExpired()) {
        file.delete();
      }
 else {
        entry.size=file.length();
        putEntry(entry.key,entry);
      }
    }
 catch (    IOException e) {
      file.delete();
    }
 finally {
      try {
        if (fis != null) {
          fis.close();
        }
      }
 catch (      IOException ignored) {
      }
    }
  }
}",0.966907962771458
29557,"/** 
 * In this method, we got the Content-Length, with the TemporaryFile length, we can calculate the actually size of the whole file, if TemporaryFile not exists, we'll take the store file length then compare to actually size, and if equals, we consider this download was already done. We used   {@link RandomAccessFile} to continue download, when download success,the TemporaryFile will be rename to StoreFile.
 */
@Override public byte[] handleResponse(HttpResponse response,Delivery delivery) throws IOException, ServerError {
  HttpEntity entity=response.getEntity();
  long fileSize=entity.getContentLength();
  if (fileSize <= 0) {
    NetroidLog.d(""String_Node_Str"");
  }
  long downloadedSize=mTemporaryFile.length();
  boolean isSupportRange=HttpUtils.isSupportRange(response);
  if (isSupportRange) {
    fileSize+=downloadedSize;
    String realRangeValue=HttpUtils.getHeader(response,""String_Node_Str"");
    if (!TextUtils.isEmpty(realRangeValue)) {
      String assumeRangeValue=""String_Node_Str"" + downloadedSize + ""String_Node_Str""+ (fileSize - 1);
      if (TextUtils.indexOf(realRangeValue,assumeRangeValue) == -1) {
        throw new IllegalStateException(""String_Node_Str"" + assumeRangeValue + ""String_Node_Str""+ realRangeValue+ ""String_Node_Str""+ ""String_Node_Str""+ mTemporaryFile+ ""String_Node_Str"");
      }
    }
  }
  if (fileSize > 0 && mStoreFile.length() == fileSize) {
    mStoreFile.renameTo(mTemporaryFile);
    delivery.postDownloadProgress(this,fileSize,fileSize);
    return null;
  }
  RandomAccessFile tmpFileRaf=new RandomAccessFile(mTemporaryFile,""String_Node_Str"");
  if (isSupportRange) {
    tmpFileRaf.seek(downloadedSize);
  }
 else {
    tmpFileRaf.setLength(0);
    downloadedSize=0;
  }
  try {
    InputStream in=entity.getContent();
    if (HttpUtils.isGzipContent(response) && !(in instanceof GZIPInputStream)) {
      in=new GZIPInputStream(in);
    }
    byte[] buffer=new byte[6 * 1024];
    int offset;
    while ((offset=in.read(buffer)) != -1) {
      tmpFileRaf.write(buffer,0,offset);
      downloadedSize+=offset;
      delivery.postDownloadProgress(this,fileSize,downloadedSize);
      if (isCanceled()) {
        delivery.postCancel(this);
        break;
      }
    }
  }
  finally {
    try {
      if (entity != null)       entity.consumeContent();
    }
 catch (    Exception e) {
      NetroidLog.v(""String_Node_Str"");
    }
    tmpFileRaf.close();
  }
  return null;
}","/** 
 * In this method, we got the Content-Length, with the TemporaryFile length, we can calculate the actually size of the whole file, if TemporaryFile not exists, we'll take the store file length then compare to actually size, and if equals, we consider this download was already done. We used   {@link RandomAccessFile} to continue download, when download success,the TemporaryFile will be rename to StoreFile.
 */
@Override public byte[] handleResponse(HttpResponse response,Delivery delivery) throws IOException, ServerError {
  HttpEntity entity=response.getEntity();
  long fileSize=entity.getContentLength();
  if (fileSize <= 0) {
    NetroidLog.d(""String_Node_Str"");
  }
  long downloadedSize=mTemporaryFile.length();
  boolean isSupportRange=HttpUtils.isSupportRange(response);
  if (isSupportRange) {
    fileSize+=downloadedSize;
    String realRangeValue=HttpUtils.getHeader(response,""String_Node_Str"");
    if (!TextUtils.isEmpty(realRangeValue)) {
      String assumeRangeValue=""String_Node_Str"" + downloadedSize + ""String_Node_Str""+ (fileSize - 1);
      if (TextUtils.indexOf(realRangeValue,assumeRangeValue) == -1) {
        throw new IllegalStateException(""String_Node_Str"" + assumeRangeValue + ""String_Node_Str""+ realRangeValue+ ""String_Node_Str""+ ""String_Node_Str""+ mTemporaryFile+ ""String_Node_Str"");
      }
    }
  }
  if (fileSize > 0 && mStoreFile.length() == fileSize) {
    mStoreFile.renameTo(mTemporaryFile);
    delivery.postDownloadProgress(this,fileSize,fileSize);
    return null;
  }
  RandomAccessFile tmpFileRaf=new RandomAccessFile(mTemporaryFile,""String_Node_Str"");
  if (isSupportRange) {
    tmpFileRaf.seek(downloadedSize);
  }
 else {
    tmpFileRaf.setLength(0);
    downloadedSize=0;
  }
  try {
    InputStream in=entity.getContent();
    if (HttpUtils.isGzipContent(response) && !(in instanceof GZIPInputStream)) {
      in=new GZIPInputStream(in);
    }
    byte[] buffer=new byte[6 * 1024];
    int offset;
    while ((offset=in.read(buffer)) != -1) {
      tmpFileRaf.write(buffer,0,offset);
      downloadedSize+=offset;
      delivery.postDownloadProgress(this,fileSize,downloadedSize);
      if (isCanceled()) {
        delivery.postCancel(this);
        break;
      }
    }
  }
  finally {
    try {
      entity.consumeContent();
    }
 catch (    Exception e) {
      NetroidLog.v(""String_Node_Str"");
    }
    tmpFileRaf.close();
  }
  return null;
}",0.9946325350949629
29558,"@SuppressWarnings(""String_Node_Str"") private static List<NameValuePair> getPostParameterPairs(Map<String,String> postParams){
  List<NameValuePair> result=new ArrayList<NameValuePair>(postParams.size());
  for (  String key : postParams.keySet()) {
    result.add(new BasicNameValuePair(key,postParams.get(key)));
  }
  return result;
}","private static List<NameValuePair> getPostParameterPairs(Map<String,String> postParams){
  List<NameValuePair> result=new ArrayList<NameValuePair>(postParams.size());
  for (  String key : postParams.keySet()) {
    result.add(new BasicNameValuePair(key,postParams.get(key)));
  }
  return result;
}",0.9417322834645668
29559,"/** 
 * Performs an HTTP request with the given parameters. <p/> <p>A GET request is sent if request.getPostBody() == null. A POST request is sent otherwise, and the Content-Type header is set to request.getPostBodyContentType().</p>
 * @param request the request to perform
 * @return the HTTP response
 */
public HttpResponse performRequest(Request<?> request) throws IOException, AuthFailureError ;","/** 
 * Performs an HTTP request with the given parameters. <p/> <p>A GET request is sent if request.getPostBody() == null. A POST request is sent otherwise, and the Content-Type header is set to request.getPostBodyContentType().</p>
 * @param request the request to perform
 * @return the HTTP response
 */
HttpResponse performRequest(Request<?> request) throws IOException, AuthFailureError ;",0.9911949685534592
29560,"/** 
 * Synchronously retrieves an auth token.
 * @throws AuthFailureError If authentication did not succeed
 */
public String getAuthToken() throws AuthFailureError ;","/** 
 * Synchronously retrieves an auth token.
 * @throws AuthFailureError If authentication did not succeed
 */
String getAuthToken() throws AuthFailureError ;",0.9785932721712538
29561,"/** 
 * Invalidates the provided auth token.
 */
public void invalidateAuthToken(String authToken);","/** 
 * Invalidates the provided auth token.
 */
void invalidateAuthToken(String authToken);",0.9633507853403142
29562,"public void putBitmap(String url,Bitmap bitmap);","void putBitmap(String url,Bitmap bitmap);",0.9213483146067416
29563,"private void loadSdcardImage(){
  mNetworkImageView.setImageUrl(SelfImageLoader.RES_SDCARD + ""String_Node_Str"",mImageLoader);
}","private void loadSdcardImage(){
  mNetworkImageView.setImageUrl(SelfImageLoader.RES_SDCARD + Environment.getExternalStorageDirectory() + ""String_Node_Str"",mImageLoader);
}",0.8523489932885906
29564,"/** 
 * Pause this task when it status was DOWNLOADING, in fact, we just marked the request should be cancel, http request cannot stop immediately, we assume it will finish soon, thus we set the status as PAUSE, let Task Queue deploy a new Request, that will cause parallel tasks growing beyond maximum task count, but it doesn't matter, we believe that situation never longer.
 * @return true if did the pause operation.
 */
public boolean pause(){
  if (mStatus == STATUS_DOWNLOADING) {
    mStatus=STATUS_PAUSE;
    mRequest.cancel();
    schedule();
    return true;
  }
  return false;
}","/** 
 * Pause this task when it status was DOWNLOADING|WAITING. In fact, we just marked the request should be cancel, http request cannot stop immediately, we assume it will finish soon, thus we set the status as PAUSE, let Task Queue deploy a new Request. That will cause parallel tasks growing beyond maximum task count, but it doesn't matter, we expected that situation never stay longer.
 * @return true if did the pause operation.
 */
public boolean pause(){
switch (mStatus) {
case STATUS_DOWNLOADING:
    mRequest.cancel();
case STATUS_WAITING:
  mStatus=STATUS_PAUSE;
schedule();
return true;
default :
return false;
}
}",0.6704918032786885
29565,"@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  DownloadTask task=mDownloadList.get(position);
switch (task.controller.getStatus()) {
case FileDownloader.DownloadController.STATUS_DOWNLOADING:
    task.controller.pause();
  task.invalidate();
break;
case FileDownloader.DownloadController.STATUS_PAUSE:
task.controller.resume();
task.invalidate();
break;
}
}","@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  DownloadTask task=mDownloadList.get(position);
switch (task.controller.getStatus()) {
case DownloadController.STATUS_DOWNLOADING:
case DownloadController.STATUS_WAITING:
    task.controller.pause();
  task.invalidate();
break;
case DownloadController.STATUS_PAUSE:
task.controller.resume();
task.invalidate();
break;
}
}",0.913793103448276
29566,"private void invalidate(){
  if (btnStatus == null)   return;
  if (!TextUtils.equals((CharSequence)btnStatus.getTag(),storeFileName))   return;
switch (controller.getStatus()) {
case FileDownloader.DownloadController.STATUS_DOWNLOADING:
    if (fileSize > 0 && downloadedSize > 0) {
      btnStatus.setText(DECIMAL_POINT.format(downloadedSize * 1.0f / fileSize * 100) + '%');
    }
 else {
      btnStatus.setText(""String_Node_Str"");
    }
  break;
case FileDownloader.DownloadController.STATUS_WAITING:
btnStatus.setText(""String_Node_Str"");
break;
case FileDownloader.DownloadController.STATUS_PAUSE:
btnStatus.setText(""String_Node_Str"");
break;
case FileDownloader.DownloadController.STATUS_SUCCESS:
btnStatus.setText(""String_Node_Str"");
break;
}
txvDownloadedSize.setText(Formatter.formatFileSize(FileDownloadActivity.this,downloadedSize));
txvFileSize.setText(Formatter.formatFileSize(FileDownloadActivity.this,fileSize));
}","private void invalidate(){
  if (btnStatus == null)   return;
  if (!TextUtils.equals((CharSequence)btnStatus.getTag(),storeFileName))   return;
switch (controller.getStatus()) {
case DownloadController.STATUS_DOWNLOADING:
    if (fileSize > 0 && downloadedSize > 0) {
      btnStatus.setText(DECIMAL_POINT.format(downloadedSize * 1.0f / fileSize * 100) + '%');
    }
 else {
      btnStatus.setText(""String_Node_Str"");
    }
  break;
case DownloadController.STATUS_WAITING:
btnStatus.setText(""String_Node_Str"");
break;
case DownloadController.STATUS_PAUSE:
btnStatus.setText(""String_Node_Str"");
break;
case DownloadController.STATUS_SUCCESS:
btnStatus.setText(""String_Node_Str"");
break;
}
txvDownloadedSize.setText(Formatter.formatFileSize(FileDownloadActivity.this,downloadedSize));
txvFileSize.setText(Formatter.formatFileSize(FileDownloadActivity.this,fileSize));
}",0.9666295884315906
29567,"/** 
 * The ListView menu is inflated and added to de DrawerLayout
 */
private void configureList(){
}","/** 
 * The ListView menu is inflated and added to de DrawerLayout
 */
private void configureList(){
  LayoutInflater inflater=(LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mListView=(ListView)inflater.inflate(R.layout.navigation_list,this,false);
  mListView.setPadding(mListPaddingLeft,mListPaddingTop,mListPaddingRight,mListPaddingBottom);
  ((DrawerLayout.LayoutParams)mListView.getLayoutParams()).gravity=mDrawerGravity;
  if (mHeaderView != null) {
    setMenuHeader(mHeaderView,mHeaderClickable);
  }
  if (mFooterView != null) {
    setMenuFooter(mFooterView,mFooterClickable);
  }
  addView(mListView);
  mListView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> adapterView,    View view,    int i,    long l){
      if (mHeaderView != null && i == 0 && !mHeaderClickable) {
        return;
      }
      if (mFooterView != null && i == mListView.getCount() - 1 && !mFooterClickable) {
        return;
      }
      check(i);
      if (mSelectionListener != null) {
        mSelectionListener.onSectionSelected(view,i,l);
      }
      if (mShouldChangeTitle && i != 0 && i != mListView.getCount() - 1) {
        CharSequence title=(CharSequence)mListView.getAdapter().getItem(i);
        mActivity.setTitle(title);
      }
      closeDrawerMenu();
    }
  }
);
}",0.1376518218623481
29568,"/** 
 * Set custom listener so when a ListView item is clicked, it's also checked
 * @param listener The OnNavigationSectionSelected listener. Use null to disable.
 */
public void setOnNavigationSectionSelected(OnNavigationSectionSelected listener){
  mSelectionListener=listener;
  if (mSelectionListener != null) {
    mListView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
      @Override public void onItemClick(      AdapterView<?> adapterView,      View view,      int i,      long l){
        if (mHeaderView != null && i == 0 && !mHeaderClickable) {
          return;
        }
        if (mFooterView != null && i == mListView.getCount() - 1 && !mFooterClickable) {
          return;
        }
        check(i);
        mSelectionListener.onSectionSelected(view,i,l);
        closeDrawerMenu();
      }
    }
);
  }
 else {
    mListView.setOnItemClickListener(null);
  }
}","/** 
 * Set custom listener so when a ListView item is clicked, it's also checked
 * @param listener The OnNavigationSectionSelected listener. Use null to disable.
 */
public void setOnNavigationSectionSelected(OnNavigationSectionSelected listener){
  mSelectionListener=listener;
}",0.4775613886536833
29569,"@Override public void onItemClick(AdapterView<?> adapterView,View view,int i,long l){
  if (mHeaderView != null && i == 0 && !mHeaderClickable) {
    return;
  }
  if (mFooterView != null && i == mListView.getCount() - 1 && !mFooterClickable) {
    return;
  }
  check(i);
  mSelectionListener.onSectionSelected(view,i,l);
  closeDrawerMenu();
}","@Override public void onItemClick(AdapterView<?> adapterView,View view,int i,long l){
  if (mHeaderView != null && i == 0 && !mHeaderClickable) {
    return;
  }
  if (mFooterView != null && i == mListView.getCount() - 1 && !mFooterClickable) {
    return;
  }
  check(i);
  if (mSelectionListener != null) {
    mSelectionListener.onSectionSelected(view,i,l);
  }
  closeDrawerMenu();
}",0.9426229508196722
29570,"/** 
 * The ListView menu is inflated and added to de DrawerLayout
 */
private void configureList(){
  LayoutInflater inflater=(LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mListView=(ListView)inflater.inflate(R.layout.navigation_list,this,false);
  mListView.setPadding(mListPaddingLeft,mListPaddingTop,mListPaddingRight,mListPaddingBottom);
  ((DrawerLayout.LayoutParams)mListView.getLayoutParams()).gravity=mDrawerGravity;
  if (mHeaderView != null) {
    setMenuHeader(mHeaderView,mHeaderClickable);
  }
  if (mFooterView != null) {
    setMenuFooter(mFooterView,mFooterClickable);
  }
  addView(mListView);
}","/** 
 * The ListView menu is inflated and added to de DrawerLayout
 */
private void configureList(){
  LayoutInflater inflater=(LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mListView=(ListView)inflater.inflate(R.layout.navigation_list,this,false);
  mListView.setPadding(mListPaddingLeft,mListPaddingTop,mListPaddingRight,mListPaddingBottom);
  ((DrawerLayout.LayoutParams)mListView.getLayoutParams()).gravity=mDrawerGravity;
  if (mHeaderView != null) {
    setMenuHeader(mHeaderView,mHeaderClickable);
  }
  if (mFooterView != null) {
    setMenuFooter(mFooterView,mFooterClickable);
  }
  addView(mListView);
  mListView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> adapterView,    View view,    int i,    long l){
      if (mHeaderView != null && i == 0 && !mHeaderClickable) {
        return;
      }
      if (mFooterView != null && i == mListView.getCount() - 1 && !mFooterClickable) {
        return;
      }
      check(i);
      if (mSelectionListener != null) {
        mSelectionListener.onSectionSelected(view,i,l);
      }
      closeDrawerMenu();
    }
  }
);
}",0.7073569482288828
29571,"public AudioAnalysisSection createModelObject(JsonObject jsonObject){
  if (jsonObject == null || jsonObject.isJsonNull()) {
    return null;
  }
  return new AudioAnalysisSection.Builder().setKey(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsInt() : null).setKeyConfidence(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsFloat() : null).setLoudness(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsFloat() : null).setMeasure(hasAndNotNull(jsonObject,""String_Node_Str"") ? new AudioAnalysisMeasure.JsonUtil().createModelObject(jsonObject.getAsJsonObject(""String_Node_Str"")) : null).setMode(hasAndNotNull(jsonObject,""String_Node_Str"") ? Modality.keyOf(jsonObject.get(""String_Node_Str"").getAsInt()) : null).setModeConfidence(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsFloat() : null).setTempo(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsFloat() : null).setTempoConfidence(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsFloat() : null).setTimeSignature(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsInt() : null).setTimeSignatureConfidence(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsFloat() : null).build();
}","public AudioAnalysisSection createModelObject(JsonObject jsonObject){
  if (jsonObject == null || jsonObject.isJsonNull()) {
    return null;
  }
  return new AudioAnalysisSection.Builder().setKey(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsInt() : null).setKeyConfidence(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsFloat() : null).setLoudness(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsFloat() : null).setMeasure((hasAndNotNull(jsonObject,""String_Node_Str"") && hasAndNotNull(jsonObject,""String_Node_Str"") && hasAndNotNull(jsonObject,""String_Node_Str"")) ? new AudioAnalysisMeasure.JsonUtil().createModelObject(jsonObject) : null).setMode(hasAndNotNull(jsonObject,""String_Node_Str"") ? Modality.keyOf(jsonObject.get(""String_Node_Str"").getAsInt()) : null).setModeConfidence(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsFloat() : null).setTempo(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsFloat() : null).setTempoConfidence(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsFloat() : null).setTimeSignature(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsInt() : null).setTimeSignatureConfidence(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsFloat() : null).build();
}",0.9548120041393584
29572,"public AudioAnalysisSegment createModelObject(JsonObject jsonObject){
  if (jsonObject == null || jsonObject.isJsonNull()) {
    return null;
  }
  return new AudioAnalysisSegment.Builder().setLoudnessEnd(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsFloat() : null).setLoudnessMax(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsFloat() : null).setLoudnessMaxTime(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsFloat() : null).setLoudnessStart(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsFloat() : null).setMeasure(hasAndNotNull(jsonObject,""String_Node_Str"") ? new AudioAnalysisMeasure.JsonUtil().createModelObject(jsonObject.getAsJsonObject(""String_Node_Str"")) : null).setPitches(hasAndNotNull(jsonObject,""String_Node_Str"") ? new Gson().fromJson(jsonObject.getAsJsonArray(""String_Node_Str""),float[].class) : null).setTimbre(hasAndNotNull(jsonObject,""String_Node_Str"") ? new Gson().fromJson(jsonObject.getAsJsonArray(""String_Node_Str""),float[].class) : null).build();
}","public AudioAnalysisSegment createModelObject(JsonObject jsonObject){
  if (jsonObject == null || jsonObject.isJsonNull()) {
    return null;
  }
  return new AudioAnalysisSegment.Builder().setLoudnessEnd(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsFloat() : null).setLoudnessMax(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsFloat() : null).setLoudnessMaxTime(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsFloat() : null).setLoudnessStart(hasAndNotNull(jsonObject,""String_Node_Str"") ? jsonObject.get(""String_Node_Str"").getAsFloat() : null).setMeasure((hasAndNotNull(jsonObject,""String_Node_Str"") && hasAndNotNull(jsonObject,""String_Node_Str"") && hasAndNotNull(jsonObject,""String_Node_Str"")) ? new AudioAnalysisMeasure.JsonUtil().createModelObject(jsonObject) : null).setPitches(hasAndNotNull(jsonObject,""String_Node_Str"") ? new Gson().fromJson(jsonObject.getAsJsonArray(""String_Node_Str""),float[].class) : null).setTimbre(hasAndNotNull(jsonObject,""String_Node_Str"") ? new Gson().fromJson(jsonObject.getAsJsonArray(""String_Node_Str""),float[].class) : null).build();
}",0.9433145824318476
29573,"/** 
 * Get information about an users available devices.
 * @return A {@link GetUsersAvailableDevices.Builder}.
 */
public GetUsersAvailableDevicesRequest.Builder getUsersAvailableDevices(){
  return new GetUsersAvailableDevicesRequest.Builder(accessToken).setDefaults(httpManager,scheme,host,port);
}","/** 
 * Get information about an users available devices.
 * @return A {@link GetUsersAvailableDevicesRequest.Builder}.
 */
public GetUsersAvailableDevicesRequest.Builder getUsersAvailableDevices(){
  return new GetUsersAvailableDevicesRequest.Builder(accessToken).setDefaults(httpManager,scheme,host,port);
}",0.9885433715220948
29574,"@Test public void shouldCreatePlaylist_sync() throws Exception {
  final Api api=Api.builder().accessToken(""String_Node_Str"").build();
  final PlaylistCreationRequest request=api.createPlaylist(""String_Node_Str"",""String_Node_Str"").publicAccess(true).httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final Playlist playlist=request.get();
  assertFalse(playlist.isCollaborative());
  assertNull(playlist.getDescription());
  assertEquals(""String_Node_Str"",playlist.getExternalUrls().get(""String_Node_Str""));
  assertNull(playlist.getFollowers());
  assertEquals(""String_Node_Str"",playlist.getHref());
  assertEquals(""String_Node_Str"",playlist.getId());
  assertEquals(1,playlist.getImages().size());
  assertNull(playlist.getImages().get(0));
  assertEquals(""String_Node_Str"",playlist.getName());
  assertNotNull(playlist.getOwner());
  assertTrue(playlist.isPublicAccess());
  assertNull(playlist.getTracks());
  assertEquals(ObjectType.PLAYLIST,playlist.getType());
  assertEquals(""String_Node_Str"",playlist.getUri());
}","@Test public void shouldCreatePlaylist_sync() throws Exception {
  final Api api=Api.builder().accessToken(""String_Node_Str"").build();
  final PlaylistCreationRequest request=api.createPlaylist(""String_Node_Str"",""String_Node_Str"").publicAccess(true).httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final Playlist playlist=request.get();
  assertFalse(playlist.getIsCollaborative());
  assertNull(playlist.getDescription());
  assertEquals(""String_Node_Str"",playlist.getExternalUrls().get(""String_Node_Str""));
  assertNull(playlist.getFollowers());
  assertEquals(""String_Node_Str"",playlist.getHref());
  assertEquals(""String_Node_Str"",playlist.getId());
  assertEquals(1,playlist.getImages().size());
  assertNull(playlist.getImages().get(0));
  assertEquals(""String_Node_Str"",playlist.getName());
  assertNotNull(playlist.getOwner());
  assertTrue(playlist.getIsPublicAccess());
  assertNull(playlist.getTracks());
  assertEquals(ObjectType.PLAYLIST,playlist.getType());
  assertEquals(""String_Node_Str"",playlist.getUri());
}",0.9952785646836638
29575,"@Test public void shouldCreatePlaylist_async() throws Exception {
  final Api api=Api.builder().accessToken(""String_Node_Str"").build();
  final PlaylistCreationRequest request=api.createPlaylist(""String_Node_Str"",""String_Node_Str"").publicAccess(true).httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final CountDownLatch asyncCompleted=new CountDownLatch(1);
  final SettableFuture<Playlist> playlistFuture=request.getAsync();
  Futures.addCallback(playlistFuture,new FutureCallback<Playlist>(){
    @Override public void onSuccess(    Playlist playlist){
      assertNotNull(playlist);
      assertFalse(playlist.isCollaborative());
      assertNull(playlist.getDescription());
      assertEquals(""String_Node_Str"",playlist.getExternalUrls().get(""String_Node_Str""));
      assertNull(playlist.getFollowers());
      assertEquals(""String_Node_Str"",playlist.getHref());
      assertEquals(""String_Node_Str"",playlist.getId());
      assertEquals(1,playlist.getImages().size());
      assertNull(playlist.getImages().get(0));
      assertEquals(""String_Node_Str"",playlist.getName());
      assertNotNull(playlist.getOwner());
      assertTrue(playlist.isPublicAccess());
      assertNull(playlist.getTracks());
      assertEquals(ObjectType.PLAYLIST,playlist.getType());
      assertEquals(""String_Node_Str"",playlist.getUri());
      asyncCompleted.countDown();
    }
    @Override public void onFailure(    Throwable throwable){
      fail(""String_Node_Str"" + throwable.getMessage());
    }
  }
);
  asyncCompleted.await(1,TimeUnit.SECONDS);
}","@Test public void shouldCreatePlaylist_async() throws Exception {
  final Api api=Api.builder().accessToken(""String_Node_Str"").build();
  final PlaylistCreationRequest request=api.createPlaylist(""String_Node_Str"",""String_Node_Str"").publicAccess(true).httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final CountDownLatch asyncCompleted=new CountDownLatch(1);
  final SettableFuture<Playlist> playlistFuture=request.getAsync();
  Futures.addCallback(playlistFuture,new FutureCallback<Playlist>(){
    @Override public void onSuccess(    Playlist playlist){
      assertNotNull(playlist);
      assertFalse(playlist.getIsCollaborative());
      assertNull(playlist.getDescription());
      assertEquals(""String_Node_Str"",playlist.getExternalUrls().get(""String_Node_Str""));
      assertNull(playlist.getFollowers());
      assertEquals(""String_Node_Str"",playlist.getHref());
      assertEquals(""String_Node_Str"",playlist.getId());
      assertEquals(1,playlist.getImages().size());
      assertNull(playlist.getImages().get(0));
      assertEquals(""String_Node_Str"",playlist.getName());
      assertNotNull(playlist.getOwner());
      assertTrue(playlist.getIsPublicAccess());
      assertNull(playlist.getTracks());
      assertEquals(ObjectType.PLAYLIST,playlist.getType());
      assertEquals(""String_Node_Str"",playlist.getUri());
      asyncCompleted.countDown();
    }
    @Override public void onFailure(    Throwable throwable){
      fail(""String_Node_Str"" + throwable.getMessage());
    }
  }
);
  asyncCompleted.await(1,TimeUnit.SECONDS);
}",0.9968334388853703
29576,"@Override public void onSuccess(Playlist playlist){
  assertNotNull(playlist);
  assertFalse(playlist.isCollaborative());
  assertNull(playlist.getDescription());
  assertEquals(""String_Node_Str"",playlist.getExternalUrls().get(""String_Node_Str""));
  assertNull(playlist.getFollowers());
  assertEquals(""String_Node_Str"",playlist.getHref());
  assertEquals(""String_Node_Str"",playlist.getId());
  assertEquals(1,playlist.getImages().size());
  assertNull(playlist.getImages().get(0));
  assertEquals(""String_Node_Str"",playlist.getName());
  assertNotNull(playlist.getOwner());
  assertTrue(playlist.isPublicAccess());
  assertNull(playlist.getTracks());
  assertEquals(ObjectType.PLAYLIST,playlist.getType());
  assertEquals(""String_Node_Str"",playlist.getUri());
  asyncCompleted.countDown();
}","@Override public void onSuccess(Playlist playlist){
  assertNotNull(playlist);
  assertFalse(playlist.getIsCollaborative());
  assertNull(playlist.getDescription());
  assertEquals(""String_Node_Str"",playlist.getExternalUrls().get(""String_Node_Str""));
  assertNull(playlist.getFollowers());
  assertEquals(""String_Node_Str"",playlist.getHref());
  assertEquals(""String_Node_Str"",playlist.getId());
  assertEquals(1,playlist.getImages().size());
  assertNull(playlist.getImages().get(0));
  assertEquals(""String_Node_Str"",playlist.getName());
  assertNotNull(playlist.getOwner());
  assertTrue(playlist.getIsPublicAccess());
  assertNull(playlist.getTracks());
  assertEquals(ObjectType.PLAYLIST,playlist.getType());
  assertEquals(""String_Node_Str"",playlist.getUri());
  asyncCompleted.countDown();
}",0.9937106918238994
29577,"@Test public void shouldGetTracksResult_async() throws Exception {
  final Api api=Api.DEFAULT_API;
  final TopTracksRequest request=api.getTopTracksForArtist(""String_Node_Str"",""String_Node_Str"").httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final CountDownLatch asyncCompleted=new CountDownLatch(1);
  final SettableFuture<List<Track>> tracksFuture=request.getAsync();
  Futures.addCallback(tracksFuture,new FutureCallback<List<Track>>(){
    @Override public void onSuccess(    List<Track> tracks){
      assertTrue(tracks.size() > 0);
      Track firstTrack=tracks.get(0);
      assertNotNull(firstTrack.getAlbum());
      assertNotNull(firstTrack.getArtists());
      assertNotNull(firstTrack.getAvailableMarkets());
      assertTrue(firstTrack.getDiscNumber() > 0);
      assertTrue(firstTrack.getDuration() > 0);
      assertNotNull(firstTrack.isExplicit());
      assertNotNull(firstTrack.getExternalIds());
      String id=firstTrack.getId();
      assertNotNull(firstTrack.getId());
      assertEquals(""String_Node_Str"" + id,firstTrack.getExternalUrls().get(""String_Node_Str""));
      assertEquals(""String_Node_Str"" + id,firstTrack.getHref());
      assertTrue(firstTrack.getPopularity() >= 0 && firstTrack.getPopularity() <= 100);
      assertNotNull(firstTrack.getPreviewUrl());
      assertTrue(firstTrack.getTrackNumber() >= 0);
      assertEquals(ObjectType.TRACK,firstTrack.getType());
      assertEquals(""String_Node_Str"" + id,firstTrack.getUri());
      asyncCompleted.countDown();
    }
    @Override public void onFailure(    Throwable throwable){
      fail(""String_Node_Str"");
    }
  }
);
  asyncCompleted.await(1,TimeUnit.SECONDS);
}","@Test public void shouldGetTracksResult_async() throws Exception {
  final Api api=Api.DEFAULT_API;
  final TopTracksRequest request=api.getTopTracksForArtist(""String_Node_Str"",""String_Node_Str"").httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final CountDownLatch asyncCompleted=new CountDownLatch(1);
  final SettableFuture<List<Track>> tracksFuture=request.getAsync();
  Futures.addCallback(tracksFuture,new FutureCallback<List<Track>>(){
    @Override public void onSuccess(    List<Track> tracks){
      assertTrue(tracks.size() > 0);
      Track firstTrack=tracks.get(0);
      assertNotNull(firstTrack.getAlbum());
      assertNotNull(firstTrack.getArtists());
      assertNotNull(firstTrack.getAvailableMarkets());
      assertTrue(firstTrack.getDiscNumber() > 0);
      assertTrue(firstTrack.getDurationMs() > 0);
      assertNotNull(firstTrack.getIsExplicit());
      assertNotNull(firstTrack.getExternalIds());
      String id=firstTrack.getId();
      assertNotNull(firstTrack.getId());
      assertEquals(""String_Node_Str"" + id,firstTrack.getExternalUrls().get(""String_Node_Str""));
      assertEquals(""String_Node_Str"" + id,firstTrack.getHref());
      assertTrue(firstTrack.getPopularity() >= 0 && firstTrack.getPopularity() <= 100);
      assertNotNull(firstTrack.getPreviewUrl());
      assertTrue(firstTrack.getTrackNumber() >= 0);
      assertEquals(ObjectType.TRACK,firstTrack.getType());
      assertEquals(""String_Node_Str"" + id,firstTrack.getUri());
      asyncCompleted.countDown();
    }
    @Override public void onFailure(    Throwable throwable){
      fail(""String_Node_Str"");
    }
  }
);
  asyncCompleted.await(1,TimeUnit.SECONDS);
}",0.9979369289714116
29578,"@Test public void shouldGetTracksResult_sync() throws Exception {
  final Api api=Api.DEFAULT_API;
  final TopTracksRequest request=api.getTopTracksForArtist(""String_Node_Str"",""String_Node_Str"").httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final List<Track> tracks=request.get();
  assertTrue(tracks.size() > 0);
  Track firstTrack=tracks.get(0);
  assertNotNull(firstTrack.getAlbum());
  assertNotNull(firstTrack.getArtists());
  assertNotNull(firstTrack.getAvailableMarkets());
  assertTrue(firstTrack.getDiscNumber() > 0);
  assertTrue(firstTrack.getDuration() > 0);
  assertNotNull(firstTrack.isExplicit());
  assertNotNull(firstTrack.getExternalIds());
  String id=firstTrack.getId();
  assertNotNull(firstTrack.getId());
  assertEquals(""String_Node_Str"" + id,firstTrack.getExternalUrls().get(""String_Node_Str""));
  assertEquals(""String_Node_Str"" + id,firstTrack.getHref());
  assertTrue(firstTrack.getPopularity() >= 0 && firstTrack.getPopularity() <= 100);
  assertNotNull(firstTrack.getPreviewUrl());
  assertTrue(firstTrack.getTrackNumber() >= 0);
  assertEquals(ObjectType.TRACK,firstTrack.getType());
  assertEquals(""String_Node_Str"" + id,firstTrack.getUri());
}","@Test public void shouldGetTracksResult_sync() throws Exception {
  final Api api=Api.DEFAULT_API;
  final TopTracksRequest request=api.getTopTracksForArtist(""String_Node_Str"",""String_Node_Str"").httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final List<Track> tracks=request.get();
  assertTrue(tracks.size() > 0);
  Track firstTrack=tracks.get(0);
  assertNotNull(firstTrack.getAlbum());
  assertNotNull(firstTrack.getArtists());
  assertNotNull(firstTrack.getAvailableMarkets());
  assertTrue(firstTrack.getDiscNumber() > 0);
  assertTrue(firstTrack.getDurationMs() > 0);
  assertNotNull(firstTrack.getIsExplicit());
  assertNotNull(firstTrack.getExternalIds());
  String id=firstTrack.getId();
  assertNotNull(firstTrack.getId());
  assertEquals(""String_Node_Str"" + id,firstTrack.getExternalUrls().get(""String_Node_Str""));
  assertEquals(""String_Node_Str"" + id,firstTrack.getHref());
  assertTrue(firstTrack.getPopularity() >= 0 && firstTrack.getPopularity() <= 100);
  assertNotNull(firstTrack.getPreviewUrl());
  assertTrue(firstTrack.getTrackNumber() >= 0);
  assertEquals(ObjectType.TRACK,firstTrack.getType());
  assertEquals(""String_Node_Str"" + id,firstTrack.getUri());
}",0.9971181556195964
29579,"@Override public void onSuccess(List<Track> tracks){
  assertTrue(tracks.size() > 0);
  Track firstTrack=tracks.get(0);
  assertNotNull(firstTrack.getAlbum());
  assertNotNull(firstTrack.getArtists());
  assertNotNull(firstTrack.getAvailableMarkets());
  assertTrue(firstTrack.getDiscNumber() > 0);
  assertTrue(firstTrack.getDuration() > 0);
  assertNotNull(firstTrack.isExplicit());
  assertNotNull(firstTrack.getExternalIds());
  String id=firstTrack.getId();
  assertNotNull(firstTrack.getId());
  assertEquals(""String_Node_Str"" + id,firstTrack.getExternalUrls().get(""String_Node_Str""));
  assertEquals(""String_Node_Str"" + id,firstTrack.getHref());
  assertTrue(firstTrack.getPopularity() >= 0 && firstTrack.getPopularity() <= 100);
  assertNotNull(firstTrack.getPreviewUrl());
  assertTrue(firstTrack.getTrackNumber() >= 0);
  assertEquals(ObjectType.TRACK,firstTrack.getType());
  assertEquals(""String_Node_Str"" + id,firstTrack.getUri());
  asyncCompleted.countDown();
}","@Override public void onSuccess(List<Track> tracks){
  assertTrue(tracks.size() > 0);
  Track firstTrack=tracks.get(0);
  assertNotNull(firstTrack.getAlbum());
  assertNotNull(firstTrack.getArtists());
  assertNotNull(firstTrack.getAvailableMarkets());
  assertTrue(firstTrack.getDiscNumber() > 0);
  assertTrue(firstTrack.getDurationMs() > 0);
  assertNotNull(firstTrack.getIsExplicit());
  assertNotNull(firstTrack.getExternalIds());
  String id=firstTrack.getId();
  assertNotNull(firstTrack.getId());
  assertEquals(""String_Node_Str"" + id,firstTrack.getExternalUrls().get(""String_Node_Str""));
  assertEquals(""String_Node_Str"" + id,firstTrack.getHref());
  assertTrue(firstTrack.getPopularity() >= 0 && firstTrack.getPopularity() <= 100);
  assertNotNull(firstTrack.getPreviewUrl());
  assertTrue(firstTrack.getTrackNumber() >= 0);
  assertEquals(ObjectType.TRACK,firstTrack.getType());
  assertEquals(""String_Node_Str"" + id,firstTrack.getUri());
  asyncCompleted.countDown();
}",0.9964230965763924
29580,"@Test public void shouldGetPlaylistsForUser_async() throws Exception {
  final String accessToken=""String_Node_Str"";
  final Api api=Api.builder().build();
  final UserPlaylistsRequest request=api.getPlaylistsForUser(""String_Node_Str"").accessToken(accessToken).limit(10).offset(2).httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final CountDownLatch asyncCompleted=new CountDownLatch(1);
  final SettableFuture<Paging<PlaylistSimplified>> playlistsPageFuture=request.getAsync();
  Futures.addCallback(playlistsPageFuture,new FutureCallback<Paging<PlaylistSimplified>>(){
    @Override public void onSuccess(    Paging<PlaylistSimplified> playlistsPage){
      assertTrue(playlistsPage.getTotal() >= 0);
      assertNull(playlistsPage.getNext());
      assertEquals(""String_Node_Str"",playlistsPage.getPrevious());
      assertEquals(10,playlistsPage.getLimit());
      assertEquals(2,playlistsPage.getOffset());
      assertEquals(""String_Node_Str"",playlistsPage.getHref());
      final PlaylistSimplified simplePlaylist=playlistsPage.getItems().get(0);
      final String playlistId=simplePlaylist.getId();
      assertNotNull(playlistId);
      assertTrue(playlistId.length() > 0);
      assertEquals(false,simplePlaylist.isCollaborative());
      assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getExternalUrls().get(""String_Node_Str""));
      assertNotNull(simplePlaylist.getName());
      assertNotNull(simplePlaylist.getOwner());
      assertNotNull(simplePlaylist.isPublicAccess());
      assertNotNull(simplePlaylist.getTracks().getHref());
      assertNotNull(simplePlaylist.getTracks().getTotal());
      assertEquals(ObjectType.PLAYLIST,simplePlaylist.getType());
      assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getUri());
      assertEquals(1,simplePlaylist.getImages().size());
      assertEquals(""String_Node_Str"",simplePlaylist.getImages().get(0).getUrl());
      assertNull(simplePlaylist.getImages().get(0).getWidth());
      assertNull(simplePlaylist.getImages().get(0).getHeight());
      asyncCompleted.countDown();
    }
    @Override public void onFailure(    Throwable throwable){
      fail(""String_Node_Str"" + throwable.getMessage());
    }
  }
);
  asyncCompleted.await(1,TimeUnit.SECONDS);
}","@Test public void shouldGetPlaylistsForUser_async() throws Exception {
  final String accessToken=""String_Node_Str"";
  final Api api=Api.builder().build();
  final UserPlaylistsRequest request=api.getPlaylistsForUser(""String_Node_Str"").accessToken(accessToken).limit(10).offset(2).httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final CountDownLatch asyncCompleted=new CountDownLatch(1);
  final SettableFuture<Paging<PlaylistSimplified>> playlistsPageFuture=request.getAsync();
  Futures.addCallback(playlistsPageFuture,new FutureCallback<Paging<PlaylistSimplified>>(){
    @Override public void onSuccess(    Paging<PlaylistSimplified> playlistsPage){
      assertTrue(playlistsPage.getTotal() >= 0);
      assertNull(playlistsPage.getNext());
      assertEquals(""String_Node_Str"",playlistsPage.getPrevious());
      assertEquals(10,playlistsPage.getLimit());
      assertEquals(2,playlistsPage.getOffset());
      assertEquals(""String_Node_Str"",playlistsPage.getHref());
      final PlaylistSimplified simplePlaylist=playlistsPage.getItems().get(0);
      final String playlistId=simplePlaylist.getId();
      assertNotNull(playlistId);
      assertTrue(playlistId.length() > 0);
      assertEquals(false,simplePlaylist.getIsCollaborative());
      assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getExternalUrls().get(""String_Node_Str""));
      assertNotNull(simplePlaylist.getName());
      assertNotNull(simplePlaylist.getOwner());
      assertNotNull(simplePlaylist.getIsPublicAccess());
      assertNotNull(simplePlaylist.getTracks().getHref());
      assertNotNull(simplePlaylist.getTracks().getTotal());
      assertEquals(ObjectType.PLAYLIST,simplePlaylist.getType());
      assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getUri());
      assertEquals(1,simplePlaylist.getImages().size());
      assertEquals(""String_Node_Str"",simplePlaylist.getImages().get(0).getUrl());
      assertNull(simplePlaylist.getImages().get(0).getWidth());
      assertNull(simplePlaylist.getImages().get(0).getHeight());
      asyncCompleted.countDown();
    }
    @Override public void onFailure(    Throwable throwable){
      fail(""String_Node_Str"" + throwable.getMessage());
    }
  }
);
  asyncCompleted.await(1,TimeUnit.SECONDS);
}",0.9978108581436076
29581,"@Test public void shouldGetPlaylistsForUser_sync() throws Exception {
  final String accessToken=""String_Node_Str"";
  final Api api=Api.builder().build();
  final UserPlaylistsRequest request=api.getPlaylistsForUser(""String_Node_Str"").accessToken(accessToken).httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final Paging<PlaylistSimplified> playlistsPage=request.get();
  assertTrue(playlistsPage.getTotal() >= 0);
  assertNull(playlistsPage.getNext());
  assertEquals(""String_Node_Str"",playlistsPage.getPrevious());
  assertEquals(10,playlistsPage.getLimit());
  assertEquals(2,playlistsPage.getOffset());
  assertEquals(""String_Node_Str"",playlistsPage.getHref());
  final PlaylistSimplified simplePlaylist=playlistsPage.getItems().get(0);
  final String playlistId=simplePlaylist.getId();
  assertNotNull(playlistId);
  assertTrue(playlistId.length() > 0);
  assertEquals(false,simplePlaylist.isCollaborative());
  assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getExternalUrls().get(""String_Node_Str""));
  assertNotNull(simplePlaylist.getName());
  assertNotNull(simplePlaylist.getOwner());
  assertNotNull(simplePlaylist.isPublicAccess());
  assertNotNull(simplePlaylist.getTracks().getHref());
  assertNotNull(simplePlaylist.getTracks().getTotal());
  assertEquals(ObjectType.PLAYLIST,simplePlaylist.getType());
  assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getUri());
  assertEquals(1,simplePlaylist.getImages().size());
  assertEquals(""String_Node_Str"",simplePlaylist.getImages().get(0).getUrl());
  assertNull(simplePlaylist.getImages().get(0).getWidth());
  assertNull(simplePlaylist.getImages().get(0).getHeight());
}","@Test public void shouldGetPlaylistsForUser_sync() throws Exception {
  final String accessToken=""String_Node_Str"";
  final Api api=Api.builder().build();
  final UserPlaylistsRequest request=api.getPlaylistsForUser(""String_Node_Str"").accessToken(accessToken).httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final Paging<PlaylistSimplified> playlistsPage=request.get();
  assertTrue(playlistsPage.getTotal() >= 0);
  assertNull(playlistsPage.getNext());
  assertEquals(""String_Node_Str"",playlistsPage.getPrevious());
  assertEquals(10,playlistsPage.getLimit());
  assertEquals(2,playlistsPage.getOffset());
  assertEquals(""String_Node_Str"",playlistsPage.getHref());
  final PlaylistSimplified simplePlaylist=playlistsPage.getItems().get(0);
  final String playlistId=simplePlaylist.getId();
  assertNotNull(playlistId);
  assertTrue(playlistId.length() > 0);
  assertEquals(false,simplePlaylist.getIsCollaborative());
  assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getExternalUrls().get(""String_Node_Str""));
  assertNotNull(simplePlaylist.getName());
  assertNotNull(simplePlaylist.getOwner());
  assertNotNull(simplePlaylist.getIsPublicAccess());
  assertNotNull(simplePlaylist.getTracks().getHref());
  assertNotNull(simplePlaylist.getTracks().getTotal());
  assertEquals(ObjectType.PLAYLIST,simplePlaylist.getType());
  assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getUri());
  assertEquals(1,simplePlaylist.getImages().size());
  assertEquals(""String_Node_Str"",simplePlaylist.getImages().get(0).getUrl());
  assertNull(simplePlaylist.getImages().get(0).getWidth());
  assertNull(simplePlaylist.getImages().get(0).getHeight());
}",0.9970466627288836
29582,"@Override public void onSuccess(Paging<PlaylistSimplified> playlistsPage){
  assertTrue(playlistsPage.getTotal() >= 0);
  assertNull(playlistsPage.getNext());
  assertEquals(""String_Node_Str"",playlistsPage.getPrevious());
  assertEquals(10,playlistsPage.getLimit());
  assertEquals(2,playlistsPage.getOffset());
  assertEquals(""String_Node_Str"",playlistsPage.getHref());
  final PlaylistSimplified simplePlaylist=playlistsPage.getItems().get(0);
  final String playlistId=simplePlaylist.getId();
  assertNotNull(playlistId);
  assertTrue(playlistId.length() > 0);
  assertEquals(false,simplePlaylist.isCollaborative());
  assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getExternalUrls().get(""String_Node_Str""));
  assertNotNull(simplePlaylist.getName());
  assertNotNull(simplePlaylist.getOwner());
  assertNotNull(simplePlaylist.isPublicAccess());
  assertNotNull(simplePlaylist.getTracks().getHref());
  assertNotNull(simplePlaylist.getTracks().getTotal());
  assertEquals(ObjectType.PLAYLIST,simplePlaylist.getType());
  assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getUri());
  assertEquals(1,simplePlaylist.getImages().size());
  assertEquals(""String_Node_Str"",simplePlaylist.getImages().get(0).getUrl());
  assertNull(simplePlaylist.getImages().get(0).getWidth());
  assertNull(simplePlaylist.getImages().get(0).getHeight());
  asyncCompleted.countDown();
}","@Override public void onSuccess(Paging<PlaylistSimplified> playlistsPage){
  assertTrue(playlistsPage.getTotal() >= 0);
  assertNull(playlistsPage.getNext());
  assertEquals(""String_Node_Str"",playlistsPage.getPrevious());
  assertEquals(10,playlistsPage.getLimit());
  assertEquals(2,playlistsPage.getOffset());
  assertEquals(""String_Node_Str"",playlistsPage.getHref());
  final PlaylistSimplified simplePlaylist=playlistsPage.getItems().get(0);
  final String playlistId=simplePlaylist.getId();
  assertNotNull(playlistId);
  assertTrue(playlistId.length() > 0);
  assertEquals(false,simplePlaylist.getIsCollaborative());
  assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getExternalUrls().get(""String_Node_Str""));
  assertNotNull(simplePlaylist.getName());
  assertNotNull(simplePlaylist.getOwner());
  assertNotNull(simplePlaylist.getIsPublicAccess());
  assertNotNull(simplePlaylist.getTracks().getHref());
  assertNotNull(simplePlaylist.getTracks().getTotal());
  assertEquals(ObjectType.PLAYLIST,simplePlaylist.getType());
  assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getUri());
  assertEquals(1,simplePlaylist.getImages().size());
  assertEquals(""String_Node_Str"",simplePlaylist.getImages().get(0).getUrl());
  assertNull(simplePlaylist.getImages().get(0).getWidth());
  assertNull(simplePlaylist.getImages().get(0).getHeight());
  asyncCompleted.countDown();
}",0.9964080459770116
29583,"public static String assemble(UtilProtos.Url url){
  try {
    if (!url.getPath().contains(""String_Node_Str"")) {
      final URIBuilder uriBuilder=new URIBuilder();
      URI uri=uriBuilder.build();
      return uri.toString();
    }
 else {
      final URI uri=new URI(SCHEME_NAMES.get(url.getScheme()),null,url.getHost(),url.getPort(),null,null,null);
      return uri.toString() + url.getPath();
    }
  }
 catch (  Throwable e) {
    throw new IllegalStateException(e);
  }
}","public static String assemble(UtilProtos.Url url){
  try {
    if (!url.getPath().contains(""String_Node_Str"")) {
      final URIBuilder uriBuilder=new URIBuilder();
      final URI uri=new URIBuilder().setScheme(SCHEME_NAMES.get(url.getScheme())).setPath(url.getPath()).setHost(url.getHost()).setPort(url.getPort()).build();
      return uri.toString();
    }
 else {
      final URI uri=new URI(SCHEME_NAMES.get(url.getScheme()),null,url.getHost(),url.getPort(),null,null,null);
      return uri.toString() + url.getPath();
    }
  }
 catch (  Throwable e) {
    throw new IllegalStateException(e);
  }
}",0.7250922509225092
29584,"private static String readFromFile(File file) throws IOException {
  Reader reader=new FileReader(file);
  CharBuffer charBuffer=CharBuffer.allocate(MAX_TEST_DATA_FILE_SIZE);
  reader.read(charBuffer);
  charBuffer.position(0);
  return charBuffer.toString();
}","private static String readFromFile(File file) throws IOException {
  BufferedReader in=new BufferedReader(new InputStreamReader(new FileInputStream(file),""String_Node_Str""));
  StringBuilder out=new StringBuilder();
  String line;
  while ((line=in.readLine()) != null) {
    out.append(line);
  }
  in.close();
  return out.toString();
}",0.337228714524207
29585,"/** 
 * Create a list of Copyright object.
 * @param copyrightsJson A JSON array containing copyright information retrieved from the Web API.
 * @return A list of Copyright objects.
 */
public static List<Copyright> createCopyrights(JSONArray copyrightsJson){
  List<Copyright> copyrights=new ArrayList<Copyright>();
  for (int i=0; i < copyrightsJson.size(); i++) {
    Copyright copyright=new Copyright();
    JSONObject copyrightJson=copyrightsJson.getJSONObject(i);
    if (existsAndNotNull(""String_Node_Str"",copyrightJson)) {
      copyright.setText(copyrightJson.getString(""String_Node_Str""));
    }
    if (existsAndNotNull(""String_Node_Str"",copyrightJson)) {
      copyright.setType(copyrightJson.getString(""String_Node_Str""));
    }
    copyrights.add(copyright);
  }
  return copyrights;
}","/** 
 * Create a list of Copyright object.
 * @param copyrightsJson A JSON array containing copyright information retrieved from the Web API.
 * @return A list of Copyright objects.
 */
public static List<Copyright> createCopyrights(JSONArray copyrightsJson){
  List<Copyright> copyrights=new ArrayList<Copyright>();
  for (int i=0; i < copyrightsJson.size(); i++) {
    Copyright copyright=new Copyright();
    JSONObject copyrightJson=copyrightsJson.getJSONObject(i);
    if (existsAndNotNull(""String_Node_Str"",copyrightJson)) {
      copyright.setText(copyrightJson.getString(""String_Node_Str""));
    }
    if (existsAndNotNull(""String_Node_Str"",copyrightJson)) {
      copyright.setType(CopyrightType.valueOf(copyrightJson.getString(""String_Node_Str"")));
    }
    copyrights.add(copyright);
  }
  return copyrights;
}",0.9858112276372608
29586,"public static List<String> createAvailableMarkets(JSONArray availableMarketsJson){
  List<String> availableMarkets=new ArrayList<String>();
  for (int i=0; i < availableMarketsJson.size(); i++) {
    availableMarkets.add(availableMarketsJson.getString(i));
  }
  return availableMarkets;
}","public static List<CountryCode> createAvailableMarkets(JSONArray availableMarketsJson){
  List<CountryCode> availableMarkets=new ArrayList<>();
  for (int i=0; i < availableMarketsJson.size(); i++) {
    availableMarkets.add(CountryCode.getByCode(availableMarketsJson.getString(i)));
  }
  return availableMarkets;
}",0.8297520661157025
29587,"private static Album createAlbum(JSONObject albumJson){
  if (albumJson == null || albumJson.isNullObject()) {
    return null;
  }
  Album album=new Album();
  album.setAlbumType(createAlbumType(albumJson.getString(""String_Node_Str"")));
  album.setArtists(createSimpleArtists(albumJson.getJSONArray(""String_Node_Str"")));
  album.setAvailableMarkets(createAvailableMarkets(albumJson.getJSONArray(""String_Node_Str"")));
  album.setCopyrights(createCopyrights(albumJson.getJSONArray(""String_Node_Str"")));
  album.setExternalIds(createExternalIds(albumJson.getJSONObject(""String_Node_Str"")));
  album.setExternalUrls(createExternalUrls(albumJson.getJSONObject(""String_Node_Str"")));
  album.setGenres(createGenres(albumJson.getJSONArray(""String_Node_Str"")));
  album.setHref(albumJson.getString(""String_Node_Str""));
  album.setId(albumJson.getString(""String_Node_Str""));
  album.setImages(createImages(albumJson.getJSONArray(""String_Node_Str"")));
  album.setName(albumJson.getString(""String_Node_Str""));
  album.setPopularity(albumJson.getInt(""String_Node_Str""));
  album.setReleaseDate(albumJson.getString(""String_Node_Str""));
  album.setReleaseDatePrecision(albumJson.getString(""String_Node_Str""));
  album.setTracks(createSimpleTrackPage(albumJson.getJSONObject(""String_Node_Str"")));
  album.setType(createObjectType(albumJson.getString(""String_Node_Str"")));
  album.setUri(albumJson.getString(""String_Node_Str""));
  return album;
}","private static Album createAlbum(JSONObject albumJson){
  if (albumJson == null || albumJson.isNullObject()) {
    return null;
  }
  Album album=new Album();
  album.setAlbumType(createAlbumType(albumJson.getString(""String_Node_Str"")));
  album.setArtists(createSimpleArtists(albumJson.getJSONArray(""String_Node_Str"")));
  album.setAvailableMarkets(createAvailableMarkets(albumJson.getJSONArray(""String_Node_Str"")));
  album.setCopyrights(createCopyrights(albumJson.getJSONArray(""String_Node_Str"")));
  album.setExternalIds(createExternalIds(albumJson.getJSONObject(""String_Node_Str"")));
  album.setExternalUrls(createExternalUrls(albumJson.getJSONObject(""String_Node_Str"")));
  album.setGenres(createGenres(albumJson.getJSONArray(""String_Node_Str"")));
  album.setHref(albumJson.getString(""String_Node_Str""));
  album.setId(albumJson.getString(""String_Node_Str""));
  album.setImages(createImages(albumJson.getJSONArray(""String_Node_Str"")));
  album.setName(albumJson.getString(""String_Node_Str""));
  album.setPopularity(albumJson.getInt(""String_Node_Str""));
  album.setReleaseDate(albumJson.getString(""String_Node_Str""));
  album.setReleaseDatePrecision(ReleaseDatePrecision.valueOf(albumJson.getString(""String_Node_Str"")));
  album.setTracks(createSimpleTrackPage(albumJson.getJSONObject(""String_Node_Str"")));
  album.setType(createObjectType(albumJson.getString(""String_Node_Str"")));
  album.setUri(albumJson.getString(""String_Node_Str""));
  return album;
}",0.9640138408304498
29588,"private static Track createTrack(JSONObject trackJson){
  Track track=new Track();
  track.setAlbum(createSimpleAlbum(trackJson.getJSONObject(""String_Node_Str"")));
  track.setArtists(createSimpleArtists(trackJson.getJSONArray(""String_Node_Str"")));
  track.setAvailableMarkets(createAvailableMarkets(trackJson.getJSONArray(""String_Node_Str"")));
  track.setDiscNumber(trackJson.getInt(""String_Node_Str""));
  track.setDuration(trackJson.getInt(""String_Node_Str""));
  track.setExplicit(trackJson.getBoolean(""String_Node_Str""));
  track.setExternalIds(createExternalIds(trackJson.getJSONObject(""String_Node_Str"")));
  track.setExternalUrls(createExternalUrls(trackJson.getJSONObject(""String_Node_Str"")));
  track.setHref(trackJson.getString(""String_Node_Str""));
  track.setId(trackJson.getString(""String_Node_Str""));
  track.setName(trackJson.getString(""String_Node_Str""));
  track.setPopularity(trackJson.getInt(""String_Node_Str""));
  track.setPreviewUrl(trackJson.getString(""String_Node_Str""));
  track.setTrackNumber(trackJson.getInt((""String_Node_Str"")));
  track.setType(createObjectType(trackJson.getString(""String_Node_Str"")));
  track.setUri(trackJson.getString(""String_Node_Str""));
  return track;
}","private static Track createTrack(JSONObject trackJson){
  Track track=new Track();
  track.setAlbum(createSimpleAlbum(trackJson.getJSONObject(""String_Node_Str"")));
  track.setArtists(createSimpleArtists(trackJson.getJSONArray(""String_Node_Str"")));
  track.setAvailableMarkets(createAvailableMarkets(trackJson.getJSONArray(""String_Node_Str"")));
  track.setDiscNumber(trackJson.getInt(""String_Node_Str""));
  track.setDurationMs(trackJson.getInt(""String_Node_Str""));
  track.setExplicit(trackJson.getBoolean(""String_Node_Str""));
  track.setExternalIds(createExternalIds(trackJson.getJSONObject(""String_Node_Str"")));
  track.setExternalUrls(createExternalUrls(trackJson.getJSONObject(""String_Node_Str"")));
  track.setHref(trackJson.getString(""String_Node_Str""));
  track.setId(trackJson.getString(""String_Node_Str""));
  track.setName(trackJson.getString(""String_Node_Str""));
  track.setPopularity(trackJson.getInt(""String_Node_Str""));
  track.setPreviewUrl(trackJson.getString(""String_Node_Str""));
  track.setTrackNumber(trackJson.getInt((""String_Node_Str"")));
  track.setType(createObjectType(trackJson.getString(""String_Node_Str"")));
  track.setUri(trackJson.getString(""String_Node_Str""));
  return track;
}",0.9991694352159468
29589,"public static List<String> createGenres(JSONArray genres){
  List<String> returnedGenres=new ArrayList<String>();
  for (int i=0; i < genres.size(); i++) {
    returnedGenres.add(genres.getString(i));
  }
  return returnedGenres;
}","public static List<String> createGenres(JSONArray genres){
  List<String> returnedGenres=new ArrayList<>();
  for (int i=0; i < genres.size(); i++) {
    returnedGenres.add(genres.getString(i));
  }
  return returnedGenres;
}",0.986842105263158
29590,"public static List<Album> createAlbums(JSONArray jsonArray){
  List<Album> returnedAlbums=new ArrayList<Album>();
  for (int i=0; i < jsonArray.size(); i++) {
    returnedAlbums.add(createSimpleAlbum(jsonArray.getJSONObject(i)));
  }
  return returnedAlbums;
}","public static List<Album> createAlbums(JSONArray jsonArray){
  List<Album> returnedAlbums=new ArrayList<Album>();
  for (int i=0; i < jsonArray.size(); i++) {
    returnedAlbums.add(createAlbum(jsonArray.getJSONObject(i)));
  }
  return returnedAlbums;
}",0.9883268482490272
29591,"public static List<Boolean> createBooleans(String response){
  List<Boolean> returnedArray=new ArrayList<Boolean>();
  JSONArray tracksContainedArray=JSONArray.fromObject(response);
  for (  Object tracksContainedString : tracksContainedArray) {
    if (String.valueOf(tracksContainedString).equals(""String_Node_Str"")) {
      returnedArray.add(false);
    }
 else {
      returnedArray.add(true);
    }
  }
  return returnedArray;
}","public static List<Boolean> createBooleans(String response){
  List<Boolean> returnedArray=new ArrayList<>();
  JSONArray tracksContainedArray=JSONArray.fromObject(response);
  for (  Object tracksContainedString : tracksContainedArray) {
    if (String.valueOf(tracksContainedString).equals(""String_Node_Str"")) {
      returnedArray.add(false);
    }
 else {
      returnedArray.add(true);
    }
  }
  return returnedArray;
}",0.9918509895227008
29592,"public static Paging<AlbumSimplified> createSimpleAlbumPage(JSONObject simpleAlbumPageJson){
  Paging<AlbumSimplified> page=createItemlessSimpleAlbumPage(simpleAlbumPageJson);
  page.setItems(createSimpleAlbums(simpleAlbumPageJson.getJSONArray(""String_Node_Str"")));
  return page;
}","public static Paging<AlbumSimplified> createSimpleAlbumPage(JSONObject simpleAlbumPageJson){
  Paging<AlbumSimplified> page=createItemlessSimpleAlbumPage(simpleAlbumPageJson);
  page.setItems(createAlbumsSimplified(simpleAlbumPageJson.getJSONArray(""String_Node_Str"")));
  return page;
}",0.9507042253521126
29593,"public static TrackSimplified createSimpleTrack(JSONObject simpleTrackJson){
  TrackSimplified track=new TrackSimplified();
  track.setArtists(createSimpleArtists(simpleTrackJson.getJSONArray(""String_Node_Str"")));
  track.setAvailableMarkets(createAvailableMarkets(simpleTrackJson.getJSONArray(""String_Node_Str"")));
  track.setDiscNumber(simpleTrackJson.getInt(""String_Node_Str""));
  track.setDuration(simpleTrackJson.getInt(""String_Node_Str""));
  track.setExplicit(simpleTrackJson.getBoolean(""String_Node_Str""));
  track.setExternalUrls(createExternalUrls(simpleTrackJson.getJSONObject(""String_Node_Str"")));
  track.setHref(simpleTrackJson.getString(""String_Node_Str""));
  track.setId(simpleTrackJson.getString(""String_Node_Str""));
  track.setName(simpleTrackJson.getString(""String_Node_Str""));
  track.setPreviewUrl(simpleTrackJson.getString(""String_Node_Str""));
  track.setTrackNumber(simpleTrackJson.getInt(""String_Node_Str""));
  track.setType(createObjectType(simpleTrackJson.getString(""String_Node_Str"")));
  track.setUri(simpleTrackJson.getString(""String_Node_Str""));
  return track;
}","public static TrackSimplified createSimpleTrack(JSONObject simpleTrackJson){
  TrackSimplified track=new TrackSimplified();
  track.setArtists(createSimpleArtists(simpleTrackJson.getJSONArray(""String_Node_Str"")));
  track.setAvailableMarkets(createAvailableMarkets(simpleTrackJson.getJSONArray(""String_Node_Str"")));
  track.setDiscNumber(simpleTrackJson.getInt(""String_Node_Str""));
  track.setDurationMs(simpleTrackJson.getInt(""String_Node_Str""));
  track.setExplicit(simpleTrackJson.getBoolean(""String_Node_Str""));
  track.setExternalUrls(createExternalUrls(simpleTrackJson.getJSONObject(""String_Node_Str"")));
  track.setHref(simpleTrackJson.getString(""String_Node_Str""));
  track.setId(simpleTrackJson.getString(""String_Node_Str""));
  track.setName(simpleTrackJson.getString(""String_Node_Str""));
  track.setPreviewUrl(simpleTrackJson.getString(""String_Node_Str""));
  track.setTrackNumber(simpleTrackJson.getInt(""String_Node_Str""));
  track.setType(createObjectType(simpleTrackJson.getString(""String_Node_Str"")));
  track.setUri(simpleTrackJson.getString(""String_Node_Str""));
  return track;
}",0.9990850869167428
29594,"public static User createUser(JSONObject userJson){
  User user=new User();
  user.setExternalUrls(createExternalUrls(userJson.getJSONObject(""String_Node_Str"")));
  user.setHref(userJson.getString(""String_Node_Str""));
  user.setId(userJson.getString(""String_Node_Str""));
  user.setType(createObjectType(userJson.getString(""String_Node_Str"")));
  user.setUri(userJson.getString(""String_Node_Str""));
  user.setFollowers(createFollowers(userJson.getJSONObject(""String_Node_Str"")));
  if (existsAndNotNull(""String_Node_Str"",userJson)) {
    user.setDisplayName(userJson.getString(""String_Node_Str""));
  }
  if (existsAndNotNull(""String_Node_Str"",userJson)) {
    user.setEmail(userJson.getString(""String_Node_Str""));
  }
  if (existsAndNotNull(""String_Node_Str"",userJson)) {
    user.setImages(createImages(userJson.getJSONArray(""String_Node_Str"")));
  }
  if (existsAndNotNull(""String_Node_Str"",userJson)) {
    user.setProduct(createProductType(userJson.getString(""String_Node_Str"")));
  }
  if (existsAndNotNull(""String_Node_Str"",userJson)) {
    user.setCountry(userJson.getString(""String_Node_Str""));
  }
  if (existsAndNotNull(""String_Node_Str"",userJson)) {
    user.setBirthdate(userJson.getString(""String_Node_Str""));
  }
  return user;
}","public static User createUser(JSONObject userJson){
  User user=new User();
  user.setExternalUrls(createExternalUrls(userJson.getJSONObject(""String_Node_Str"")));
  user.setHref(userJson.getString(""String_Node_Str""));
  user.setId(userJson.getString(""String_Node_Str""));
  user.setType(createObjectType(userJson.getString(""String_Node_Str"")));
  user.setUri(userJson.getString(""String_Node_Str""));
  user.setFollowers(createFollowers(userJson.getJSONObject(""String_Node_Str"")));
  if (existsAndNotNull(""String_Node_Str"",userJson)) {
    user.setDisplayName(userJson.getString(""String_Node_Str""));
  }
  if (existsAndNotNull(""String_Node_Str"",userJson)) {
    user.setEmail(userJson.getString(""String_Node_Str""));
  }
  if (existsAndNotNull(""String_Node_Str"",userJson)) {
    user.setImages(createImages(userJson.getJSONArray(""String_Node_Str"")));
  }
  if (existsAndNotNull(""String_Node_Str"",userJson)) {
    user.setProduct(createProductType(userJson.getString(""String_Node_Str"")));
  }
  if (existsAndNotNull(""String_Node_Str"",userJson)) {
    user.setCountry(CountryCode.getByCode(userJson.getString(""String_Node_Str"")));
  }
  if (existsAndNotNull(""String_Node_Str"",userJson)) {
    user.setBirthdate(userJson.getString(""String_Node_Str""));
  }
  return user;
}",0.9621061029118468
29595,"public SnapshotResult get() throws IOException, WebApiException {
  return JsonUtil.createSnapshotResponse(postJson());
}","public SnapshotResult get() throws IOException, WebApiException {
  return JsonUtil.createSnapshotResult(postJson());
}",0.9666666666666668
29596,"public SettableFuture<SnapshotResult> getAsync(){
  final SettableFuture<SnapshotResult> addTrackFuture=SettableFuture.create();
  try {
    addTrackFuture.set(JsonUtil.createSnapshotResponse(postJson()));
  }
 catch (  Exception e) {
    addTrackFuture.setException(e);
  }
  return addTrackFuture;
}","public SettableFuture<SnapshotResult> getAsync(){
  final SettableFuture<SnapshotResult> addTrackFuture=SettableFuture.create();
  try {
    addTrackFuture.set(JsonUtil.createSnapshotResult(postJson()));
  }
 catch (  Exception e) {
    addTrackFuture.setException(e);
  }
  return addTrackFuture;
}",0.9866666666666668
29597,"public Page<SimpleAlbum> get() throws IOException, WebApiException {
  final JSONObject jsonObject=JSONObject.fromObject(getJson());
  return JsonUtil.createSimpleAlbumPage(JSONObject.fromObject(jsonObject).getJSONObject(""String_Node_Str""));
}","public Paging<AlbumSimplified> get() throws IOException, WebApiException {
  final JSONObject jsonObject=JSONObject.fromObject(getJson());
  return JsonUtil.createSimpleAlbumPage(JSONObject.fromObject(jsonObject).getJSONObject(""String_Node_Str""));
}",0.959349593495935
29598,"public Page<SimpleAlbum> get() throws IOException, WebApiException {
  final JSONObject jsonObject=JSONObject.fromObject(getJson());
  return JsonUtil.createSimpleAlbumPage(jsonObject);
}","public Paging<AlbumSimplified> get() throws IOException, WebApiException {
  final JSONObject jsonObject=JSONObject.fromObject(getJson());
  return JsonUtil.createSimpleAlbumPage(jsonObject);
}",0.9526315789473684
29599,"public Page<Artist> get() throws IOException, WebApiException {
  final JSONObject jsonObject=JSONObject.fromObject(getJson());
  return JsonUtil.createArtistPage(jsonObject.getJSONObject(""String_Node_Str""));
}","public Paging<Artist> get() throws IOException, WebApiException {
  final JSONObject jsonObject=JSONObject.fromObject(getJson());
  return JsonUtil.createArtistPage(jsonObject.getJSONObject(""String_Node_Str""));
}",0.990521327014218
29600,"private static AudioFeature createAudioFeature(JSONObject audioFeatureJson){
  if (audioFeatureJson == null || audioFeatureJson.isNullObject()) {
    return null;
  }
  AudioFeature audioFeature=new AudioFeature();
  audioFeature.setDanceability(audioFeatureJson.getDouble(""String_Node_Str""));
  audioFeature.setEnergy(audioFeatureJson.getDouble(""String_Node_Str""));
  audioFeature.setKey(audioFeatureJson.getInt(""String_Node_Str""));
  audioFeature.setLoudness(audioFeatureJson.getDouble(""String_Node_Str""));
  audioFeature.setMode(audioFeatureJson.getInt(""String_Node_Str""));
  audioFeature.setSpeechiness(audioFeatureJson.getDouble(""String_Node_Str""));
  audioFeature.setAcousticness(audioFeatureJson.getDouble(""String_Node_Str""));
  audioFeature.setInstrumentalness(audioFeatureJson.getDouble(""String_Node_Str""));
  audioFeature.setLiveness(audioFeatureJson.getDouble(""String_Node_Str""));
  audioFeature.setValence(audioFeatureJson.getDouble(""String_Node_Str""));
  audioFeature.setTempo(audioFeatureJson.getDouble(""String_Node_Str""));
  audioFeature.setType(audioFeatureJson.getString(""String_Node_Str""));
  audioFeature.setId(audioFeatureJson.getString(""String_Node_Str""));
  audioFeature.setUri(audioFeatureJson.getString(""String_Node_Str""));
  audioFeature.setTrackHref(audioFeatureJson.getString(""String_Node_Str""));
  audioFeature.setAnalysisUrl(audioFeatureJson.getString(""String_Node_Str""));
  audioFeature.setDurationMs(audioFeatureJson.getInt(""String_Node_Str""));
  audioFeature.setTimeSignature(audioFeatureJson.getInt(""String_Node_Str""));
  return audioFeature;
}","private static AudioFeature createAudioFeature(JSONObject audioFeatureJson){
  if (audioFeatureJson == null || audioFeatureJson.isNullObject()) {
    return null;
  }
  AudioFeature audioFeature=new AudioFeature();
  audioFeature.setDanceability(audioFeatureJson.getDouble(""String_Node_Str""));
  audioFeature.setEnergy(audioFeatureJson.getDouble(""String_Node_Str""));
  audioFeature.setKey(audioFeatureJson.getInt(""String_Node_Str""));
  audioFeature.setLoudness(audioFeatureJson.getDouble(""String_Node_Str""));
  audioFeature.setMode(Modality.valueOf(audioFeatureJson.getString(""String_Node_Str"")));
  audioFeature.setSpeechiness(audioFeatureJson.getDouble(""String_Node_Str""));
  audioFeature.setAcousticness(audioFeatureJson.getDouble(""String_Node_Str""));
  audioFeature.setInstrumentalness(audioFeatureJson.getDouble(""String_Node_Str""));
  audioFeature.setLiveness(audioFeatureJson.getDouble(""String_Node_Str""));
  audioFeature.setValence(audioFeatureJson.getDouble(""String_Node_Str""));
  audioFeature.setTempo(audioFeatureJson.getDouble(""String_Node_Str""));
  audioFeature.setType(ObjectType.valueOf(audioFeatureJson.getString(""String_Node_Str"")));
  audioFeature.setId(audioFeatureJson.getString(""String_Node_Str""));
  audioFeature.setUri(audioFeatureJson.getString(""String_Node_Str""));
  audioFeature.setTrackHref(audioFeatureJson.getString(""String_Node_Str""));
  audioFeature.setAnalysisUrl(audioFeatureJson.getString(""String_Node_Str""));
  audioFeature.setDurationMs(audioFeatureJson.getInt(""String_Node_Str""));
  audioFeature.setTimeSignature(audioFeatureJson.getInt(""String_Node_Str""));
  return audioFeature;
}",0.9339593114241002
29601,"public Page<LibraryTrack> get() throws IOException, WebApiException {
  final JSONObject jsonObject=JSONObject.fromObject(getJson());
  return JsonUtil.createLibraryTracksPage(jsonObject);
}","public Paging<LibraryTrack> get() throws IOException, WebApiException {
  final JSONObject jsonObject=JSONObject.fromObject(getJson());
  return JsonUtil.createLibraryTracksPage(jsonObject);
}",0.9895287958115184
29602,"public Page<PlaylistTrack> get() throws IOException, WebApiException {
  final JSONObject jsonObject=JSONObject.fromObject(getJson());
  return JsonUtil.createPlaylistTrackPage(jsonObject);
}","public Paging<PlaylistTrack> get() throws IOException, WebApiException {
  final JSONObject jsonObject=JSONObject.fromObject(getJson());
  return JsonUtil.createPlaylistTrackPage(jsonObject);
}",0.9895833333333334
29603,"public Page<Track> get() throws IOException, WebApiException {
  final JSONObject jsonObject=JSONObject.fromObject(getJson());
  return JsonUtil.createTrackPage(jsonObject);
}","public Paging<Track> get() throws IOException, WebApiException {
  final JSONObject jsonObject=JSONObject.fromObject(getJson());
  return JsonUtil.createTrackPage(jsonObject);
}",0.9886363636363636
29604,"public Page<SimplePlaylist> get() throws IOException, WebApiException {
  final JSONObject jsonObject=JSONObject.fromObject(getJson());
  return JsonUtil.createSimplePlaylistsPage(jsonObject);
}","public Paging<PlaylistSimplified> get() throws IOException, WebApiException {
  final JSONObject jsonObject=JSONObject.fromObject(getJson());
  return JsonUtil.createSimplePlaylistsPage(jsonObject);
}",0.934010152284264
29605,"public static String assemble(UtilProtos.Url url){
  try {
    if (!url.getPath().contains(""String_Node_Str"")) {
      final URIBuilder uriBuilder=new URIBuilder();
      URI uri=uriBuilder.build();
      return uri.toString();
    }
 else {
      final URI uri=new URI(SCHEME_NAMES.get(url.getScheme()),null,url.getHost(),url.getPort(),null,null,null);
      return uri.toString() + url.getPath();
    }
  }
 catch (  Throwable e) {
    throw new IllegalStateException(e);
  }
}","public static String assemble(UtilProtos.Url url){
  try {
    if (!url.getPath().contains(""String_Node_Str"")) {
      final URI uri=new URIBuilder().setScheme(SCHEME_NAMES.get(url.getScheme())).setPath(url.getPath()).setHost(url.getHost()).setPort(url.getPort()).build();
      return uri.toString();
    }
 else {
      final URI uri=new URI(SCHEME_NAMES.get(url.getScheme()),null,url.getHost(),url.getPort(),null,null,null);
      return uri.toString() + url.getPath();
    }
  }
 catch (  Throwable e) {
    throw new IllegalStateException(e);
  }
}",0.6686046511627907
29606,"private static String readFromFile(File file) throws IOException {
  Reader reader=new FileReader(file);
  CharBuffer charBuffer=CharBuffer.allocate(MAX_TEST_DATA_FILE_SIZE);
  reader.read(charBuffer);
  charBuffer.position(0);
  return charBuffer.toString();
}","private static String readFromFile(File file) throws IOException {
  BufferedReader in=new BufferedReader(new InputStreamReader(new FileInputStream(file),""String_Node_Str""));
  StringBuilder out=new StringBuilder();
  String line;
  while ((line=in.readLine()) != null) {
    out.append(line);
  }
  in.close();
  return out.toString();
}",0.337228714524207
29607,"@Test public void shouldGetAlbumResultForIds_async() throws Exception {
  final Api api=Api.DEFAULT_API;
  final AlbumsRequest request=api.getAlbums(""String_Node_Str"").httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final CountDownLatch asyncCompleted=new CountDownLatch(1);
  final SettableFuture<List<Album>> albumsFuture=request.getAsync();
  Futures.addCallback(albumsFuture,new FutureCallback<List<Album>>(){
    @Override public void onSuccess(    List<Album> albums){
      assertEquals(1,albums.size());
      Album firstAlbum=albums.get(0);
      assertEquals(""String_Node_Str"",firstAlbum.getId());
      assertEquals(AlbumType.ALBUM,firstAlbum.getAlbumType());
      assertEquals(""String_Node_Str"",firstAlbum.getReleaseDate());
      assertEquals(""String_Node_Str"",firstAlbum.getReleaseDatePrecision());
      assertEquals(2,firstAlbum.getCopyrights().size());
      List<ArtistSimplified> artists=firstAlbum.getArtists();
      ArtistSimplified firstArtist=artists.get(0);
      assertEquals(""String_Node_Str"",firstArtist.getHref());
      assertEquals(""String_Node_Str"",firstArtist.getId());
      Paging<TrackSimplified> tracksPage=firstAlbum.getTracks();
      assertEquals(""String_Node_Str"",tracksPage.getHref());
      assertEquals(0,tracksPage.getOffset());
      assertEquals(50,tracksPage.getLimit());
      assertEquals(20,tracksPage.getTotal());
      assertEquals(""String_Node_Str"",tracksPage.getItems().get(0).getId());
      asyncCompleted.countDown();
    }
    @Override public void onFailure(    Throwable throwable){
      fail();
    }
  }
);
  asyncCompleted.await(1,TimeUnit.SECONDS);
}","@Test public void shouldGetAlbumResultForIds_async() throws Exception {
  final Api api=Api.DEFAULT_API;
  final AlbumsRequest request=api.getAlbums(""String_Node_Str"").httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final CountDownLatch asyncCompleted=new CountDownLatch(1);
  final SettableFuture<List<Album>> albumsFuture=request.getAsync();
  Futures.addCallback(albumsFuture,new FutureCallback<List<Album>>(){
    @Override public void onSuccess(    List<Album> albums){
      assertEquals(1,albums.size());
      Album firstAlbum=albums.get(0);
      assertEquals(""String_Node_Str"",firstAlbum.getId());
      assertEquals(AlbumType.ALBUM,firstAlbum.getAlbumType());
      assertEquals(""String_Node_Str"",firstAlbum.getReleaseDate());
      assertEquals(ReleaseDatePrecision.day,firstAlbum.getReleaseDatePrecision());
      assertEquals(2,firstAlbum.getCopyrights().size());
      List<ArtistSimplified> artists=firstAlbum.getArtists();
      ArtistSimplified firstArtist=artists.get(0);
      assertEquals(""String_Node_Str"",firstArtist.getHref());
      assertEquals(""String_Node_Str"",firstArtist.getId());
      Paging<TrackSimplified> tracksPage=firstAlbum.getTracks();
      assertEquals(""String_Node_Str"",tracksPage.getHref());
      assertEquals(0,tracksPage.getOffset());
      assertEquals(50,tracksPage.getLimit());
      assertEquals(20,tracksPage.getTotal());
      assertEquals(""String_Node_Str"",tracksPage.getItems().get(0).getId());
      asyncCompleted.countDown();
    }
    @Override public void onFailure(    Throwable throwable){
      fail();
    }
  }
);
  asyncCompleted.await(1,TimeUnit.SECONDS);
}",0.9876245095079988
29608,"@Test public void shouldGetAlbumResultForIds_sync() throws Exception {
  final Api api=Api.DEFAULT_API;
  final AlbumsRequest request=api.getAlbums(""String_Node_Str"").httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  List<Album> albums=request.get();
  assertEquals(1,albums.size());
  Album firstAlbum=albums.get(0);
  assertEquals(""String_Node_Str"",firstAlbum.getId());
  assertEquals(AlbumType.ALBUM,firstAlbum.getAlbumType());
  assertEquals(""String_Node_Str"",firstAlbum.getReleaseDate());
  assertEquals(""String_Node_Str"",firstAlbum.getReleaseDatePrecision());
  List<ArtistSimplified> artists=firstAlbum.getArtists();
  ArtistSimplified firstArtist=artists.get(0);
  assertEquals(""String_Node_Str"",firstArtist.getHref());
  assertEquals(""String_Node_Str"",firstArtist.getId());
  Paging<TrackSimplified> tracksPage=firstAlbum.getTracks();
  assertEquals(""String_Node_Str"",tracksPage.getHref());
  assertEquals(0,tracksPage.getOffset());
  assertEquals(50,tracksPage.getLimit());
  assertEquals(20,tracksPage.getTotal());
  assertEquals(""String_Node_Str"",tracksPage.getItems().get(0).getId());
}","@Test public void shouldGetAlbumResultForIds_sync() throws Exception {
  final Api api=Api.DEFAULT_API;
  final AlbumsRequest request=api.getAlbums(""String_Node_Str"").httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  List<Album> albums=request.get();
  assertEquals(1,albums.size());
  Album firstAlbum=albums.get(0);
  assertEquals(""String_Node_Str"",firstAlbum.getId());
  assertEquals(AlbumType.ALBUM,firstAlbum.getAlbumType());
  assertEquals(""String_Node_Str"",firstAlbum.getReleaseDate());
  assertEquals(ReleaseDatePrecision.day,firstAlbum.getReleaseDatePrecision());
  List<ArtistSimplified> artists=firstAlbum.getArtists();
  ArtistSimplified firstArtist=artists.get(0);
  assertEquals(""String_Node_Str"",firstArtist.getHref());
  assertEquals(""String_Node_Str"",firstArtist.getId());
  Paging<TrackSimplified> tracksPage=firstAlbum.getTracks();
  assertEquals(""String_Node_Str"",tracksPage.getHref());
  assertEquals(0,tracksPage.getOffset());
  assertEquals(50,tracksPage.getLimit());
  assertEquals(20,tracksPage.getTotal());
  assertEquals(""String_Node_Str"",tracksPage.getItems().get(0).getId());
}",0.9819621645402552
29609,"@Test public void shouldGetCurrentUser_async() throws Exception {
  final Api api=Api.DEFAULT_API;
  final CurrentUserRequest request=api.getMe().accessToken(""String_Node_Str"").httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final CountDownLatch asyncCompleted=new CountDownLatch(1);
  final SettableFuture<User> userFuture=request.getAsync();
  Futures.addCallback(userFuture,new FutureCallback<User>(){
    @Override public void onSuccess(    User user){
      assertNotNull(user);
      assertEquals(""String_Node_Str"",user.getDisplayName());
      assertEquals(""String_Node_Str"",user.getEmail());
      assertEquals(""String_Node_Str"",user.getExternalUrls().get(""String_Node_Str""));
      assertEquals(""String_Node_Str"",user.getHref());
      assertEquals(""String_Node_Str"",user.getId());
      assertEquals(""String_Node_Str"",user.getCountry());
      assertNotNull(user.getFollowers());
      assertNull(user.getImages().get(0).getHeight());
      assertNull(user.getImages().get(0).getWidth());
      assertEquals(""String_Node_Str"",user.getImages().get(0).getUrl());
      assertEquals(ProductType.PREMIUM,user.getProduct());
      assertEquals(""String_Node_Str"",user.getUri());
      assertEquals(""String_Node_Str"",user.getBirthdate());
      asyncCompleted.countDown();
    }
    @Override public void onFailure(    Throwable throwable){
      fail(""String_Node_Str"" + throwable.getMessage());
    }
  }
);
  asyncCompleted.await(1,TimeUnit.SECONDS);
}","@Test public void shouldGetCurrentUser_async() throws Exception {
  final Api api=Api.DEFAULT_API;
  final CurrentUserRequest request=api.getMe().accessToken(""String_Node_Str"").httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final CountDownLatch asyncCompleted=new CountDownLatch(1);
  final SettableFuture<User> userFuture=request.getAsync();
  Futures.addCallback(userFuture,new FutureCallback<User>(){
    @Override public void onSuccess(    User user){
      assertNotNull(user);
      assertEquals(""String_Node_Str"",user.getDisplayName());
      assertEquals(""String_Node_Str"",user.getEmail());
      assertEquals(""String_Node_Str"",user.getExternalUrls().get(""String_Node_Str""));
      assertEquals(""String_Node_Str"",user.getHref());
      assertEquals(""String_Node_Str"",user.getId());
      assertEquals(CountryCode.SE,user.getCountry());
      assertNotNull(user.getFollowers());
      assertEquals(0,user.getImages().get(0).getHeight());
      assertEquals(0,user.getImages().get(0).getWidth());
      assertEquals(""String_Node_Str"",user.getImages().get(0).getUrl());
      assertEquals(ProductType.PREMIUM,user.getProduct());
      assertEquals(""String_Node_Str"",user.getUri());
      assertEquals(""String_Node_Str"",user.getBirthdate());
      asyncCompleted.countDown();
    }
    @Override public void onFailure(    Throwable throwable){
      fail(""String_Node_Str"" + throwable.getMessage());
    }
  }
);
  asyncCompleted.await(1,TimeUnit.SECONDS);
}",0.9802873371199464
29610,"@Test public void shouldGetCurrentUser_sync() throws Exception {
  final Api api=Api.DEFAULT_API;
  final CurrentUserRequest request=api.getMe().accessToken(""String_Node_Str"").httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final User user=request.get();
  assertNotNull(user);
  assertEquals(""String_Node_Str"",user.getDisplayName());
  assertEquals(""String_Node_Str"",user.getEmail());
  assertEquals(""String_Node_Str"",user.getExternalUrls().get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",user.getHref());
  assertEquals(""String_Node_Str"",user.getId());
  assertEquals(""String_Node_Str"",user.getCountry());
  assertNotNull(user.getFollowers());
  assertNull(user.getImages().get(0).getHeight());
  assertNull(user.getImages().get(0).getWidth());
  assertEquals(""String_Node_Str"",user.getImages().get(0).getUrl());
  assertEquals(ProductType.PREMIUM,user.getProduct());
  assertEquals(""String_Node_Str"",user.getUri());
  assertEquals(""String_Node_Str"",user.getBirthdate());
}","@Test public void shouldGetCurrentUser_sync() throws Exception {
  final Api api=Api.DEFAULT_API;
  final CurrentUserRequest request=api.getMe().accessToken(""String_Node_Str"").httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final User user=request.get();
  assertNotNull(user);
  assertEquals(""String_Node_Str"",user.getDisplayName());
  assertEquals(""String_Node_Str"",user.getEmail());
  assertEquals(""String_Node_Str"",user.getExternalUrls().get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",user.getHref());
  assertEquals(""String_Node_Str"",user.getId());
  assertEquals(CountryCode.SE,user.getCountry());
  assertNotNull(user.getFollowers());
  assertEquals(0,user.getImages().get(0).getHeight());
  assertEquals(0,user.getImages().get(0).getWidth());
  assertEquals(""String_Node_Str"",user.getImages().get(0).getUrl());
  assertEquals(ProductType.PREMIUM,user.getProduct());
  assertEquals(""String_Node_Str"",user.getUri());
  assertEquals(""String_Node_Str"",user.getBirthdate());
}",0.9623839765510503
29611,"@Override public void onSuccess(User user){
  assertNotNull(user);
  assertEquals(""String_Node_Str"",user.getDisplayName());
  assertEquals(""String_Node_Str"",user.getEmail());
  assertEquals(""String_Node_Str"",user.getExternalUrls().get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",user.getHref());
  assertEquals(""String_Node_Str"",user.getId());
  assertEquals(""String_Node_Str"",user.getCountry());
  assertNotNull(user.getFollowers());
  assertNull(user.getImages().get(0).getHeight());
  assertNull(user.getImages().get(0).getWidth());
  assertEquals(""String_Node_Str"",user.getImages().get(0).getUrl());
  assertEquals(ProductType.PREMIUM,user.getProduct());
  assertEquals(""String_Node_Str"",user.getUri());
  assertEquals(""String_Node_Str"",user.getBirthdate());
  asyncCompleted.countDown();
}","@Override public void onSuccess(User user){
  assertNotNull(user);
  assertEquals(""String_Node_Str"",user.getDisplayName());
  assertEquals(""String_Node_Str"",user.getEmail());
  assertEquals(""String_Node_Str"",user.getExternalUrls().get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",user.getHref());
  assertEquals(""String_Node_Str"",user.getId());
  assertEquals(CountryCode.SE,user.getCountry());
  assertNotNull(user.getFollowers());
  assertEquals(0,user.getImages().get(0).getHeight());
  assertEquals(0,user.getImages().get(0).getWidth());
  assertEquals(""String_Node_Str"",user.getImages().get(0).getUrl());
  assertEquals(ProductType.PREMIUM,user.getProduct());
  assertEquals(""String_Node_Str"",user.getUri());
  assertEquals(""String_Node_Str"",user.getBirthdate());
  asyncCompleted.countDown();
}",0.9522628642281464
29612,"@Test public void shouldGetNewReleases_async() throws Exception {
  final Api api=Api.DEFAULT_API;
  final NewReleasesRequest request=api.getNewReleases().limit(3).offset(1).country(""String_Node_Str"").httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final CountDownLatch asyncCompleted=new CountDownLatch(1);
  final SettableFuture<NewReleases> future=request.getAsync();
  Futures.addCallback(future,new FutureCallback<NewReleases>(){
    @Override public void onSuccess(    NewReleases newReleases){
      assertNotNull(newReleases.getAlbums());
      Paging<AlbumSimplified> albums=newReleases.getAlbums();
      assertEquals(""String_Node_Str"",albums.getHref());
      assertEquals(3,albums.getLimit());
      assertEquals(1,albums.getOffset());
      assertEquals(""String_Node_Str"",albums.getNext());
      assertEquals(""String_Node_Str"",albums.getPrevious());
      assertEquals(500,albums.getTotal());
      AlbumSimplified firstItem=albums.getItems().get(0);
      assertEquals(AlbumType.SINGLE,firstItem.getAlbumType());
      assertEquals(1,firstItem.getAvailableMarkets().size());
      assertEquals(""String_Node_Str"",firstItem.getAvailableMarkets().get(0));
      assertNotNull(firstItem.getExternalUrls());
      assertEquals(""String_Node_Str"",firstItem.getUri());
      asyncCompleted.countDown();
    }
    @Override public void onFailure(    Throwable throwable){
      fail(""String_Node_Str"");
    }
  }
);
  asyncCompleted.await(1,TimeUnit.SECONDS);
}","@Test public void shouldGetNewReleases_async() throws Exception {
  final Api api=Api.DEFAULT_API;
  final NewReleasesRequest request=api.getNewReleases().limit(3).offset(1).country(""String_Node_Str"").httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final CountDownLatch asyncCompleted=new CountDownLatch(1);
  final SettableFuture<NewReleases> future=request.getAsync();
  Futures.addCallback(future,new FutureCallback<NewReleases>(){
    @Override public void onSuccess(    NewReleases newReleases){
      assertNotNull(newReleases.getAlbums());
      Paging<AlbumSimplified> albums=newReleases.getAlbums();
      assertEquals(""String_Node_Str"",albums.getHref());
      assertEquals(3,albums.getLimit());
      assertEquals(1,albums.getOffset());
      assertEquals(""String_Node_Str"",albums.getNext());
      assertEquals(""String_Node_Str"",albums.getPrevious());
      assertEquals(500,albums.getTotal());
      AlbumSimplified firstItem=albums.getItems().get(0);
      assertEquals(AlbumType.SINGLE,firstItem.getAlbumType());
      assertEquals(1,firstItem.getAvailableMarkets().size());
      assertEquals(CountryCode.SE,firstItem.getAvailableMarkets().get(0));
      assertNotNull(firstItem.getExternalUrls());
      assertEquals(""String_Node_Str"",firstItem.getUri());
      asyncCompleted.countDown();
    }
    @Override public void onFailure(    Throwable throwable){
      fail(""String_Node_Str"");
    }
  }
);
  asyncCompleted.await(1,TimeUnit.SECONDS);
}",0.9896769896769896
29613,"@Test public void shouldGetArtistsResult_sync() throws Exception {
  final Api api=Api.DEFAULT_API;
  final NewReleasesRequest request=api.getNewReleases().limit(3).offset(1).country(""String_Node_Str"").httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  NewReleases newReleases=request.get();
  assertNotNull(newReleases.getAlbums());
  Paging<AlbumSimplified> albums=newReleases.getAlbums();
  assertEquals(""String_Node_Str"",albums.getHref());
  assertEquals(3,albums.getLimit());
  assertEquals(1,albums.getOffset());
  assertEquals(""String_Node_Str"",albums.getNext());
  assertEquals(""String_Node_Str"",albums.getPrevious());
  assertEquals(500,albums.getTotal());
  AlbumSimplified firstItem=albums.getItems().get(0);
  assertEquals(AlbumType.SINGLE,firstItem.getAlbumType());
  assertEquals(1,firstItem.getAvailableMarkets().size());
  assertEquals(""String_Node_Str"",firstItem.getAvailableMarkets().get(0));
  assertNotNull(firstItem.getExternalUrls());
  assertEquals(""String_Node_Str"",firstItem.getUri());
}","@Test public void shouldGetArtistsResult_sync() throws Exception {
  final Api api=Api.DEFAULT_API;
  final NewReleasesRequest request=api.getNewReleases().limit(3).offset(1).country(""String_Node_Str"").httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  NewReleases newReleases=request.get();
  assertNotNull(newReleases.getAlbums());
  Paging<AlbumSimplified> albums=newReleases.getAlbums();
  assertEquals(""String_Node_Str"",albums.getHref());
  assertEquals(3,albums.getLimit());
  assertEquals(1,albums.getOffset());
  assertEquals(""String_Node_Str"",albums.getNext());
  assertEquals(""String_Node_Str"",albums.getPrevious());
  assertEquals(500,albums.getTotal());
  AlbumSimplified firstItem=albums.getItems().get(0);
  assertEquals(AlbumType.SINGLE,firstItem.getAlbumType());
  assertEquals(1,firstItem.getAvailableMarkets().size());
  assertEquals(CountryCode.SE,firstItem.getAvailableMarkets().get(0));
  assertNotNull(firstItem.getExternalUrls());
  assertEquals(""String_Node_Str"",firstItem.getUri());
}",0.985146142788692
29614,"@Override public void onSuccess(NewReleases newReleases){
  assertNotNull(newReleases.getAlbums());
  Paging<AlbumSimplified> albums=newReleases.getAlbums();
  assertEquals(""String_Node_Str"",albums.getHref());
  assertEquals(3,albums.getLimit());
  assertEquals(1,albums.getOffset());
  assertEquals(""String_Node_Str"",albums.getNext());
  assertEquals(""String_Node_Str"",albums.getPrevious());
  assertEquals(500,albums.getTotal());
  AlbumSimplified firstItem=albums.getItems().get(0);
  assertEquals(AlbumType.SINGLE,firstItem.getAlbumType());
  assertEquals(1,firstItem.getAvailableMarkets().size());
  assertEquals(""String_Node_Str"",firstItem.getAvailableMarkets().get(0));
  assertNotNull(firstItem.getExternalUrls());
  assertEquals(""String_Node_Str"",firstItem.getUri());
  asyncCompleted.countDown();
}","@Override public void onSuccess(NewReleases newReleases){
  assertNotNull(newReleases.getAlbums());
  Paging<AlbumSimplified> albums=newReleases.getAlbums();
  assertEquals(""String_Node_Str"",albums.getHref());
  assertEquals(3,albums.getLimit());
  assertEquals(1,albums.getOffset());
  assertEquals(""String_Node_Str"",albums.getNext());
  assertEquals(""String_Node_Str"",albums.getPrevious());
  assertEquals(500,albums.getTotal());
  AlbumSimplified firstItem=albums.getItems().get(0);
  assertEquals(AlbumType.SINGLE,firstItem.getAlbumType());
  assertEquals(1,firstItem.getAvailableMarkets().size());
  assertEquals(CountryCode.SE,firstItem.getAvailableMarkets().get(0));
  assertNotNull(firstItem.getExternalUrls());
  assertEquals(""String_Node_Str"",firstItem.getUri());
  asyncCompleted.countDown();
}",0.9807811531308122
29615,"@Test public void shouldGetPlaylistsForUser_async() throws Exception {
  final String accessToken=""String_Node_Str"";
  final Api api=Api.builder().build();
  final UserPlaylistsRequest request=api.getPlaylistsForUser(""String_Node_Str"").accessToken(accessToken).limit(10).offset(2).httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final CountDownLatch asyncCompleted=new CountDownLatch(1);
  final SettableFuture<Paging<PlaylistSimplified>> playlistsPageFuture=request.getAsync();
  Futures.addCallback(playlistsPageFuture,new FutureCallback<Paging<PlaylistSimplified>>(){
    @Override public void onSuccess(    Paging<PlaylistSimplified> playlistsPage){
      assertTrue(playlistsPage.getTotal() >= 0);
      assertNull(playlistsPage.getNext());
      assertEquals(""String_Node_Str"",playlistsPage.getPrevious());
      assertEquals(10,playlistsPage.getLimit());
      assertEquals(2,playlistsPage.getOffset());
      assertEquals(""String_Node_Str"",playlistsPage.getHref());
      final PlaylistSimplified simplePlaylist=playlistsPage.getItems().get(0);
      final String playlistId=simplePlaylist.getId();
      assertNotNull(playlistId);
      assertTrue(playlistId.length() > 0);
      assertEquals(false,simplePlaylist.getIsCollaborative());
      assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getExternalUrls().get(""String_Node_Str""));
      assertNotNull(simplePlaylist.getName());
      assertNotNull(simplePlaylist.getOwner());
      assertNotNull(simplePlaylist.getIsPublicAccess());
      assertNotNull(simplePlaylist.getTracks().getHref());
      assertNotNull(simplePlaylist.getTracks().getTotal());
      assertEquals(ObjectType.PLAYLIST,simplePlaylist.getType());
      assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getUri());
      assertEquals(1,simplePlaylist.getImages().size());
      assertEquals(""String_Node_Str"",simplePlaylist.getImages().get(0).getUrl());
      assertNull(simplePlaylist.getImages().get(0).getWidth());
      assertNull(simplePlaylist.getImages().get(0).getHeight());
      asyncCompleted.countDown();
    }
    @Override public void onFailure(    Throwable throwable){
      fail(""String_Node_Str"" + throwable.getMessage());
    }
  }
);
  asyncCompleted.await(1,TimeUnit.SECONDS);
}","@Test public void shouldGetPlaylistsForUser_async() throws Exception {
  final String accessToken=""String_Node_Str"";
  final Api api=Api.builder().build();
  final UserPlaylistsRequest request=api.getPlaylistsForUser(""String_Node_Str"").accessToken(accessToken).limit(10).offset(2).httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final CountDownLatch asyncCompleted=new CountDownLatch(1);
  final SettableFuture<Paging<PlaylistSimplified>> playlistsPageFuture=request.getAsync();
  Futures.addCallback(playlistsPageFuture,new FutureCallback<Paging<PlaylistSimplified>>(){
    @Override public void onSuccess(    Paging<PlaylistSimplified> playlistsPage){
      assertTrue(playlistsPage.getTotal() >= 0);
      assertNull(playlistsPage.getNext());
      assertEquals(""String_Node_Str"",playlistsPage.getPrevious());
      assertEquals(10,playlistsPage.getLimit());
      assertEquals(2,playlistsPage.getOffset());
      assertEquals(""String_Node_Str"",playlistsPage.getHref());
      final PlaylistSimplified simplePlaylist=playlistsPage.getItems().get(0);
      final String playlistId=simplePlaylist.getId();
      assertNotNull(playlistId);
      assertTrue(playlistId.length() > 0);
      assertEquals(false,simplePlaylist.getIsCollaborative());
      assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getExternalUrls().get(""String_Node_Str""));
      assertNotNull(simplePlaylist.getName());
      assertNotNull(simplePlaylist.getOwner());
      assertNotNull(simplePlaylist.getIsPublicAccess());
      assertNotNull(simplePlaylist.getTracks().getHref());
      assertNotNull(simplePlaylist.getTracks().getTotal());
      assertEquals(ObjectType.PLAYLIST,simplePlaylist.getType());
      assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getUri());
      assertEquals(1,simplePlaylist.getImages().size());
      assertEquals(""String_Node_Str"",simplePlaylist.getImages().get(0).getUrl());
      assertEquals(0,simplePlaylist.getImages().get(0).getWidth());
      assertEquals(0,simplePlaylist.getImages().get(0).getHeight());
      asyncCompleted.countDown();
    }
    @Override public void onFailure(    Throwable throwable){
      fail(""String_Node_Str"" + throwable.getMessage());
    }
  }
);
  asyncCompleted.await(1,TimeUnit.SECONDS);
}",0.9938891313836752
29616,"@Test public void shouldGetPlaylistsForUser_sync() throws Exception {
  final String accessToken=""String_Node_Str"";
  final Api api=Api.builder().build();
  final UserPlaylistsRequest request=api.getPlaylistsForUser(""String_Node_Str"").accessToken(accessToken).httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final Paging<PlaylistSimplified> playlistsPage=request.get();
  assertTrue(playlistsPage.getTotal() >= 0);
  assertNull(playlistsPage.getNext());
  assertEquals(""String_Node_Str"",playlistsPage.getPrevious());
  assertEquals(10,playlistsPage.getLimit());
  assertEquals(2,playlistsPage.getOffset());
  assertEquals(""String_Node_Str"",playlistsPage.getHref());
  final PlaylistSimplified simplePlaylist=playlistsPage.getItems().get(0);
  final String playlistId=simplePlaylist.getId();
  assertNotNull(playlistId);
  assertTrue(playlistId.length() > 0);
  assertEquals(false,simplePlaylist.getIsCollaborative());
  assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getExternalUrls().get(""String_Node_Str""));
  assertNotNull(simplePlaylist.getName());
  assertNotNull(simplePlaylist.getOwner());
  assertNotNull(simplePlaylist.getIsPublicAccess());
  assertNotNull(simplePlaylist.getTracks().getHref());
  assertNotNull(simplePlaylist.getTracks().getTotal());
  assertEquals(ObjectType.PLAYLIST,simplePlaylist.getType());
  assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getUri());
  assertEquals(1,simplePlaylist.getImages().size());
  assertEquals(""String_Node_Str"",simplePlaylist.getImages().get(0).getUrl());
  assertNull(simplePlaylist.getImages().get(0).getWidth());
  assertNull(simplePlaylist.getImages().get(0).getHeight());
}","@Test public void shouldGetPlaylistsForUser_sync() throws Exception {
  final String accessToken=""String_Node_Str"";
  final Api api=Api.builder().build();
  final UserPlaylistsRequest request=api.getPlaylistsForUser(""String_Node_Str"").accessToken(accessToken).httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str"")).build();
  final Paging<PlaylistSimplified> playlistsPage=request.get();
  assertTrue(playlistsPage.getTotal() >= 0);
  assertNull(playlistsPage.getNext());
  assertEquals(""String_Node_Str"",playlistsPage.getPrevious());
  assertEquals(10,playlistsPage.getLimit());
  assertEquals(2,playlistsPage.getOffset());
  assertEquals(""String_Node_Str"",playlistsPage.getHref());
  final PlaylistSimplified simplePlaylist=playlistsPage.getItems().get(0);
  final String playlistId=simplePlaylist.getId();
  assertNotNull(playlistId);
  assertTrue(playlistId.length() > 0);
  assertEquals(false,simplePlaylist.getIsCollaborative());
  assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getExternalUrls().get(""String_Node_Str""));
  assertNotNull(simplePlaylist.getName());
  assertNotNull(simplePlaylist.getOwner());
  assertNotNull(simplePlaylist.getIsPublicAccess());
  assertNotNull(simplePlaylist.getTracks().getHref());
  assertNotNull(simplePlaylist.getTracks().getTotal());
  assertEquals(ObjectType.PLAYLIST,simplePlaylist.getType());
  assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getUri());
  assertEquals(1,simplePlaylist.getImages().size());
  assertEquals(""String_Node_Str"",simplePlaylist.getImages().get(0).getUrl());
  assertEquals(0,simplePlaylist.getImages().get(0).getWidth());
  assertEquals(0,simplePlaylist.getImages().get(0).getHeight());
}",0.991764705882353
29617,"@Override public void onSuccess(Paging<PlaylistSimplified> playlistsPage){
  assertTrue(playlistsPage.getTotal() >= 0);
  assertNull(playlistsPage.getNext());
  assertEquals(""String_Node_Str"",playlistsPage.getPrevious());
  assertEquals(10,playlistsPage.getLimit());
  assertEquals(2,playlistsPage.getOffset());
  assertEquals(""String_Node_Str"",playlistsPage.getHref());
  final PlaylistSimplified simplePlaylist=playlistsPage.getItems().get(0);
  final String playlistId=simplePlaylist.getId();
  assertNotNull(playlistId);
  assertTrue(playlistId.length() > 0);
  assertEquals(false,simplePlaylist.getIsCollaborative());
  assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getExternalUrls().get(""String_Node_Str""));
  assertNotNull(simplePlaylist.getName());
  assertNotNull(simplePlaylist.getOwner());
  assertNotNull(simplePlaylist.getIsPublicAccess());
  assertNotNull(simplePlaylist.getTracks().getHref());
  assertNotNull(simplePlaylist.getTracks().getTotal());
  assertEquals(ObjectType.PLAYLIST,simplePlaylist.getType());
  assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getUri());
  assertEquals(1,simplePlaylist.getImages().size());
  assertEquals(""String_Node_Str"",simplePlaylist.getImages().get(0).getUrl());
  assertNull(simplePlaylist.getImages().get(0).getWidth());
  assertNull(simplePlaylist.getImages().get(0).getHeight());
  asyncCompleted.countDown();
}","@Override public void onSuccess(Paging<PlaylistSimplified> playlistsPage){
  assertTrue(playlistsPage.getTotal() >= 0);
  assertNull(playlistsPage.getNext());
  assertEquals(""String_Node_Str"",playlistsPage.getPrevious());
  assertEquals(10,playlistsPage.getLimit());
  assertEquals(2,playlistsPage.getOffset());
  assertEquals(""String_Node_Str"",playlistsPage.getHref());
  final PlaylistSimplified simplePlaylist=playlistsPage.getItems().get(0);
  final String playlistId=simplePlaylist.getId();
  assertNotNull(playlistId);
  assertTrue(playlistId.length() > 0);
  assertEquals(false,simplePlaylist.getIsCollaborative());
  assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getExternalUrls().get(""String_Node_Str""));
  assertNotNull(simplePlaylist.getName());
  assertNotNull(simplePlaylist.getOwner());
  assertNotNull(simplePlaylist.getIsPublicAccess());
  assertNotNull(simplePlaylist.getTracks().getHref());
  assertNotNull(simplePlaylist.getTracks().getTotal());
  assertEquals(ObjectType.PLAYLIST,simplePlaylist.getType());
  assertEquals(""String_Node_Str"" + playlistId,simplePlaylist.getUri());
  assertEquals(1,simplePlaylist.getImages().size());
  assertEquals(""String_Node_Str"",simplePlaylist.getImages().get(0).getUrl());
  assertEquals(0,simplePlaylist.getImages().get(0).getWidth());
  assertEquals(0,simplePlaylist.getImages().get(0).getHeight());
  asyncCompleted.countDown();
}",0.9899928520371694
29618,"public CategoryRequest build(){
  path(""String_Node_Str"");
  return new CategoryRequest(this);
}","public CategoryRequest build(){
  return new CategoryRequest(this);
}",0.8363636363636363
29619,"/** 
 * Get a playlist's tracks.
 * @param userId The playlist's owner's username.
 * @param playlistId The playlist's id.
 * @return A builder object that can be used to build a request to retrieve playlist tracks.
 */
public PlaylistTracksRequest.Builder getPlaylistTracks(String userId,String playlistId){
  final PlaylistTracksRequest.Builder builder=PlaylistTracksRequest.builder();
  setDefaults(builder);
  builder.path(""String_Node_Str"" + userId + ""String_Node_Str""+ playlistId+ ""String_Node_Str"");
  return builder;
}","/** 
 * Get a playlist's tracks.
 * @param userId The playlist's owner's username.
 * @param playlistId The playlist's id.
 * @return A builder object that can be used to build a request to retrieve playlist tracks.
 */
public PlaylistTracksRequest.Builder getPlaylistTracks(String userId,String playlistId){
  final PlaylistTracksRequest.Builder builder=PlaylistTracksRequest.builder();
  setDefaults(builder);
  userId=UrlUtil.userToUri(userId);
  builder.path(""String_Node_Str"" + userId + ""String_Node_Str""+ playlistId+ ""String_Node_Str"");
  return builder;
}",0.9669117647058824
29620,"/** 
 * Add tracks to a playlist.
 * @param userId The owner's username.
 * @param playlistId The playlist's ID.
 * @param trackUris URIs of the tracks to add.
 * @return A builder object that can e used to build a request to add tracks to a playlist.
 */
public AddTrackToPlaylistRequest.Builder addTracksToPlaylist(String userId,String playlistId,List<String> trackUris){
  final AddTrackToPlaylistRequest.Builder builder=AddTrackToPlaylistRequest.builder();
  setDefaults(builder);
  final JSONArray jsonArrayUri=new JSONArray();
  jsonArrayUri.addAll(trackUris);
  builder.body(jsonArrayUri);
  builder.path(""String_Node_Str"" + userId + ""String_Node_Str""+ playlistId+ ""String_Node_Str"");
  return builder;
}","/** 
 * Add tracks to a playlist.
 * @param userId The owner's username.
 * @param playlistId The playlist's ID.
 * @param trackUris URIs of the tracks to add.
 * @return A builder object that can e used to build a request to add tracks to a playlist.
 */
public AddTrackToPlaylistRequest.Builder addTracksToPlaylist(String userId,String playlistId,List<String> trackUris){
  final AddTrackToPlaylistRequest.Builder builder=AddTrackToPlaylistRequest.builder();
  setDefaults(builder);
  final JSONArray jsonArrayUri=new JSONArray();
  jsonArrayUri.addAll(trackUris);
  builder.body(jsonArrayUri);
  userId=UrlUtil.userToUri(userId);
  builder.path(""String_Node_Str"" + userId + ""String_Node_Str""+ playlistId+ ""String_Node_Str"");
  return builder;
}",0.9753086419753086
29621,"/** 
 * Get a playlist.
 * @param userId The playlist's owner's username.
 * @param playlistId The playlist's ID.
 * @return A builder object that can be used to build a request to retrieve a playlist.
 */
public PlaylistRequest.Builder getPlaylist(String userId,String playlistId){
  PlaylistRequest.Builder builder=PlaylistRequest.builder();
  setDefaults(builder);
  builder.path(""String_Node_Str"" + userId + ""String_Node_Str""+ playlistId);
  return builder;
}","/** 
 * Get a playlist.
 * @param userId The playlist's owner's username.
 * @param playlistId The playlist's ID.
 * @return A builder object that can be used to build a request to retrieve a playlist.
 */
public PlaylistRequest.Builder getPlaylist(String userId,String playlistId){
  PlaylistRequest.Builder builder=PlaylistRequest.builder();
  setDefaults(builder);
  userId=UrlUtil.userToUri(userId);
  builder.path(""String_Node_Str"" + userId + ""String_Node_Str""+ playlistId);
  return builder;
}",0.9625779625779626
29622,"/** 
 * Create a playlist.
 * @param userId The playlist's owner.
 * @param title The name of the playlist.
 * @return A builder object that can be used to build a request to create a playlist.
 */
public PlaylistCreationRequest.Builder createPlaylist(String userId,String title){
  final PlaylistCreationRequest.Builder builder=PlaylistCreationRequest.builder();
  setDefaults(builder);
  builder.title(title);
  builder.path(""String_Node_Str"" + userId + ""String_Node_Str"");
  return builder;
}","/** 
 * Create a playlist.
 * @param userId The playlist's owner.
 * @param title The name of the playlist.
 * @return A builder object that can be used to build a request to create a playlist.
 */
public PlaylistCreationRequest.Builder createPlaylist(String userId,String title){
  final PlaylistCreationRequest.Builder builder=PlaylistCreationRequest.builder();
  setDefaults(builder);
  builder.title(title);
  userId=UrlUtil.userToUri(userId);
  builder.path(""String_Node_Str"" + userId + ""String_Node_Str"");
  return builder;
}",0.9649122807017544
29623,"/** 
 * Get a user's starred tracks.
 * @param userId The starred playlist's owner's username.
 * @return A builder object that can be used to build a request to retrieve a user's starredtracks.
 */
public PlaylistTracksRequest.Builder getStarred(String userId){
  final PlaylistTracksRequest.Builder builder=PlaylistTracksRequest.builder();
  setDefaults(builder);
  builder.path(""String_Node_Str"" + userId + ""String_Node_Str"");
  return builder;
}","/** 
 * Get a user's starred tracks.
 * @param userId The starred playlist's owner's username.
 * @return A builder object that can be used to build a request to retrieve a user's starredtracks.
 */
public PlaylistTracksRequest.Builder getStarred(String userId){
  final PlaylistTracksRequest.Builder builder=PlaylistTracksRequest.builder();
  setDefaults(builder);
  userId=UrlUtil.userToUri(userId);
  builder.path(""String_Node_Str"" + userId + ""String_Node_Str"");
  return builder;
}",0.961456102783726
29624,"/** 
 * Update a playlist's properties.
 * @param userId The owner's username.
 * @param playlistId The playlist's ID.
 * @return A builder object that can be used to build a request to change a playlist's details.
 */
public ChangePlaylistDetailsRequest.Builder changePlaylistDetails(String userId,String playlistId){
  final ChangePlaylistDetailsRequest.Builder builder=ChangePlaylistDetailsRequest.builder();
  setDefaults(builder);
  builder.path(""String_Node_Str"" + userId + ""String_Node_Str""+ playlistId);
  return builder;
}","/** 
 * Update a playlist's properties.
 * @param userId The owner's username.
 * @param playlistId The playlist's ID.
 * @return A builder object that can be used to build a request to change a playlist's details.
 */
public ChangePlaylistDetailsRequest.Builder changePlaylistDetails(String userId,String playlistId){
  final ChangePlaylistDetailsRequest.Builder builder=ChangePlaylistDetailsRequest.builder();
  setDefaults(builder);
  userId=UrlUtil.userToUri(userId);
  builder.path(""String_Node_Str"" + userId + ""String_Node_Str""+ playlistId);
  return builder;
}",0.9672131147540984
29625,"public PlaylistRequest.Builder getPlaylist(String playlistId,String userId){
  PlaylistRequest.Builder builder=PlaylistRequest.builder();
  builder.path(""String_Node_Str"" + userId + ""String_Node_Str""+ playlistId);
  setDefaults(builder);
  return builder;
}","public PlaylistRequest.Builder getPlaylist(String userId,String playlistId){
  PlaylistRequest.Builder builder=PlaylistRequest.builder();
  builder.path(""String_Node_Str"" + userId + ""String_Node_Str""+ playlistId);
  setDefaults(builder);
  return builder;
}",0.953307392996109
29626,"public static ReleaseDate createReleaseDate(JSONObject releaseDateJson){
  ReleaseDate releaseDate=new ReleaseDate();
  releaseDate.setYear(releaseDateJson.getInt(""String_Node_Str""));
  if (releaseDateJson.has(""String_Node_Str"") && !releaseDateJson.get(""String_Node_Str"").equals(""String_Node_Str"")) {
    releaseDate.setMonth(releaseDateJson.getInt(""String_Node_Str""));
  }
  if (releaseDateJson.has(""String_Node_Str"") && !releaseDateJson.get(""String_Node_Str"").equals(""String_Node_Str"")) {
    releaseDate.setDate(releaseDateJson.getInt(""String_Node_Str""));
  }
  return releaseDate;
}","public static ReleaseDate createReleaseDate(JSONObject releaseDateJson){
  ReleaseDate releaseDate=new ReleaseDate();
  releaseDate.setYear(releaseDateJson.getInt(""String_Node_Str""));
  if (releaseDateJson.has(""String_Node_Str"") && !releaseDateJson.get(""String_Node_Str"").equals(""String_Node_Str"")) {
    releaseDate.setMonth(releaseDateJson.getInt(""String_Node_Str""));
  }
 else {
    releaseDate.setMonth(null);
  }
  if (releaseDateJson.has(""String_Node_Str"") && !releaseDateJson.get(""String_Node_Str"").equals(""String_Node_Str"")) {
    releaseDate.setDate(releaseDateJson.getInt(""String_Node_Str""));
  }
 else {
    releaseDate.setDate(null);
  }
  return releaseDate;
}",0.9023034154090548
29627,"public void setMonth(int month){
  this.month=month;
}","public void setMonth(Integer month){
  this.month=month;
}",0.9464285714285714
29628,"public void setDate(int date){
  this.date=date;
}","public void setDate(Integer date){
  this.date=date;
}",0.9423076923076924
29629,"public int getDate(){
  return date;
}","public Integer getDate(){
  return date;
}",0.925
29630,"public int getMonth(){
  return month;
}","public Integer getMonth(){
  return month;
}",0.9285714285714286
29631,"@Test public void shouldGetAlbumResultForIds_async() throws Exception {
  final Api api=Api.DEFAULT_API;
  final HttpManager mockedHttpManager=TestUtil.MockedHttpManager.returningJson(""String_Node_Str"");
  final AlbumsRequest request=api.getAlbums(""String_Node_Str"").httpManager(mockedHttpManager).build();
  final CountDownLatch asyncCompleted=new CountDownLatch(1);
  final SettableFuture<List<Album>> albumsFuture=request.getAsync();
  Futures.addCallback(albumsFuture,new FutureCallback<List<Album>>(){
    @Override public void onSuccess(    List<Album> albums){
      assertEquals(1,albums.size());
      Album firstAlbum=albums.get(0);
      assertEquals(""String_Node_Str"",firstAlbum.getId());
      asyncCompleted.countDown();
    }
    @Override public void onFailure(    Throwable throwable){
      fail();
    }
  }
);
  asyncCompleted.await(1,TimeUnit.SECONDS);
}","@Test public void shouldGetAlbumResultForIds_async() throws Exception {
  final Api api=Api.DEFAULT_API;
  final AlbumsRequest.Builder requestBuilder=api.getAlbums(""String_Node_Str"");
  if (TestConfiguration.USE_MOCK_RESPONSES) {
    requestBuilder.httpManager(TestUtil.MockedHttpManager.returningJson(""String_Node_Str""));
  }
  final AlbumsRequest request=requestBuilder.build();
  final CountDownLatch asyncCompleted=new CountDownLatch(1);
  final SettableFuture<List<Album>> albumsFuture=request.getAsync();
  Futures.addCallback(albumsFuture,new FutureCallback<List<Album>>(){
    @Override public void onSuccess(    List<Album> albums){
      assertEquals(1,albums.size());
      Album firstAlbum=albums.get(0);
      assertEquals(""String_Node_Str"",firstAlbum.getId());
      assertEquals(AlbumType.ALBUM,firstAlbum.getAlbumType());
      assertTrue(firstAlbum.getReleaseDate().getDate().equals(8));
      assertTrue(firstAlbum.getReleaseDate().getMonth().equals(11));
      assertEquals(2013,firstAlbum.getReleaseDate().getYear());
      List<SimpleArtist> artists=firstAlbum.getArtists();
      SimpleArtist firstArtist=artists.get(0);
      assertEquals(""String_Node_Str"",firstArtist.getHref());
      assertEquals(""String_Node_Str"",firstArtist.getId());
      Page<SimpleTrack> tracksPage=firstAlbum.getTracks();
      assertEquals(""String_Node_Str"",tracksPage.getHref());
      assertEquals(0,tracksPage.getOffset());
      assertEquals(50,tracksPage.getLimit());
      assertEquals(38,tracksPage.getTotal());
      assertEquals(""String_Node_Str"",tracksPage.getItems().get(0).getId());
      asyncCompleted.countDown();
    }
    @Override public void onFailure(    Throwable throwable){
      fail();
    }
  }
);
  asyncCompleted.await(1,TimeUnit.SECONDS);
}",0.5905482041587902
29632,"private String execute(HttpMethod method){
  HttpClient httpClient=new HttpClient(connectionManager);
  try {
    int statusCode=httpClient.executeMethod(method);
    if (statusCode != HttpStatus.SC_OK) {
      String error=String.format(""String_Node_Str"",statusCode,HttpStatus.getStatusText(statusCode),method.getResponseBodyAsString());
      throw new RuntimeException(error);
    }
    String responseBody=method.getResponseBodyAsString();
    if (responseBody == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    return responseBody;
  }
 catch (  HttpException e) {
    throw new RuntimeException(e);
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
 finally {
    method.releaseConnection();
  }
}","private String execute(HttpMethod method){
  HttpClient httpClient=new HttpClient(connectionManager);
  try {
    httpClient.executeMethod(method);
    String responseBody=method.getResponseBodyAsString();
    if (responseBody == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    return responseBody;
  }
 catch (  HttpException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
 finally {
    method.releaseConnection();
  }
}",0.5311526479750779
29633,"public Model definition(ObjectNode node,String location,ParseResult result){
  if (result == null) {
    result=new ParseResult();
  }
  if (node == null) {
    result.missing(location,""String_Node_Str"");
    return null;
  }
  if (node.get(""String_Node_Str"") != null) {
    return refModel(node,location,result);
  }
  if (node.get(""String_Node_Str"") != null) {
    return allOfModel(node,location,result);
  }
  Model model=null;
  String value=null;
  String type=getString(""String_Node_Str"",node,false,location,result);
  Model m=new ModelImpl();
  if (""String_Node_Str"".equals(type)) {
    ArrayModel am=new ArrayModel();
    ObjectNode propertyNode=getObject(""String_Node_Str"",node,false,location,result);
    Map<String,Property> properties=properties(propertyNode,location,result);
    am.setProperties(properties);
    ObjectNode itemsNode=getObject(""String_Node_Str"",node,false,location,result);
    Property items=property(itemsNode,location,result);
    if (items != null) {
      am.items(items);
    }
    Integer maxItems=getInteger(""String_Node_Str"",node,false,location,result);
    am.setMaxItems(maxItems);
    Integer minItems=getInteger(""String_Node_Str"",node,false,location,result);
    am.setMinItems(minItems);
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        am.setVendorExtension(key,extension(node.get(key)));
      }
    }
    model=am;
  }
 else {
    ModelImpl impl=new ModelImpl();
    impl.setType(type);
    JsonNode ap=node.get(""String_Node_Str"");
    if (ap != null && ap.getNodeType().equals(JsonNodeType.OBJECT)) {
      impl.setAdditionalProperties(Json.mapper().convertValue(ap,Property.class));
    }
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDefaultValue(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setFormat(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDiscriminator(value);
    Boolean bp=getBoolean(""String_Node_Str"",node,false,location,result);
    if (bp != null) {
      impl.setUniqueItems(bp);
    }
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setPattern(value);
    BigDecimal maximum=getBigDecimal(""String_Node_Str"",node,false,location,result);
    if (maximum != null) {
      impl.maximum(maximum);
    }
    BigDecimal minimum=getBigDecimal(""String_Node_Str"",node,false,location,result);
    if (minimum != null) {
      impl.minimum(minimum);
    }
    Integer minLength=getInteger(""String_Node_Str"",node,false,location,result);
    if (minLength != null) {
      impl.setMinLength(minLength);
    }
    Integer maxLength=getInteger(""String_Node_Str"",node,false,location,result);
    if (maxLength != null) {
      impl.setMaxLength(maxLength);
    }
    BigDecimal multipleOf=getBigDecimal(""String_Node_Str"",node,false,location,result);
    if (multipleOf != null) {
      impl.setMultipleOf(multipleOf);
    }
    ap=node.get(""String_Node_Str"");
    if (ap != null) {
      ArrayNode arrayNode=getArray(""String_Node_Str"",node,false,location,result);
      if (arrayNode != null) {
        for (        JsonNode n : arrayNode) {
          if (n.isValueNode()) {
            impl._enum(n.asText());
          }
 else {
            result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
          }
        }
      }
    }
    JsonNode xml=node.get(""String_Node_Str"");
    if (xml != null) {
      impl.setXml(Json.mapper().convertValue(xml,Xml.class));
    }
    ObjectNode externalDocs=getObject(""String_Node_Str"",node,false,location,result);
    ExternalDocs docs=externalDocs(externalDocs,location,result);
    impl.setExternalDocs(docs);
    ObjectNode properties=getObject(""String_Node_Str"",node,false,location,result);
    if (properties != null) {
      Set<String> propertyNames=getKeys(properties);
      for (      String propertyName : propertyNames) {
        JsonNode propertyNode=properties.get(propertyName);
        if (propertyNode.getNodeType().equals(JsonNodeType.OBJECT)) {
          ObjectNode on=(ObjectNode)propertyNode;
          Property property=property(on,location,result);
          impl.property(propertyName,property);
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",propertyNode);
        }
      }
    }
    ArrayNode required=getArray(""String_Node_Str"",node,false,location,result);
    if (required != null) {
      List<String> requiredProperties=new ArrayList<String>();
      for (      JsonNode n : required) {
        if (n.getNodeType().equals(JsonNodeType.STRING)) {
          requiredProperties.add(((TextNode)n).textValue());
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
        }
      }
      if (requiredProperties.size() > 0) {
        impl.setRequired(requiredProperties);
      }
    }
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        impl.setVendorExtension(key,extension(node.get(key)));
      }
 else       if (!SCHEMA_KEYS.contains(key)) {
        result.extra(location,key,node.get(key));
      }
    }
    model=impl;
  }
  JsonNode exampleNode=node.get(""String_Node_Str"");
  if (exampleNode != null) {
    Object example=Json.mapper().convertValue(exampleNode,Object.class);
    model.setExample(example);
  }
  if (model != null) {
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setDescription(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setTitle(value);
  }
  return model;
}","public Model definition(ObjectNode node,String location,ParseResult result){
  if (result == null) {
    result=new ParseResult();
  }
  if (node == null) {
    result.missing(location,""String_Node_Str"");
    return null;
  }
  if (node.get(""String_Node_Str"") != null) {
    return refModel(node,location,result);
  }
  if (node.get(""String_Node_Str"") != null) {
    return allOfModel(node,location,result);
  }
  Model model=null;
  String value=null;
  String type=getString(""String_Node_Str"",node,false,location,result);
  Model m=new ModelImpl();
  if (""String_Node_Str"".equals(type)) {
    ArrayModel am=new ArrayModel();
    ObjectNode propertyNode=getObject(""String_Node_Str"",node,false,location,result);
    Map<String,Property> properties=properties(propertyNode,location,result);
    am.setProperties(properties);
    ObjectNode itemsNode=getObject(""String_Node_Str"",node,false,location,result);
    Property items=property(itemsNode,location,result);
    if (items != null) {
      am.items(items);
    }
    Integer maxItems=getInteger(""String_Node_Str"",node,false,location,result);
    am.setMaxItems(maxItems);
    Integer minItems=getInteger(""String_Node_Str"",node,false,location,result);
    am.setMinItems(minItems);
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        am.setVendorExtension(key,extension(node.get(key)));
      }
    }
    model=am;
  }
 else {
    ModelImpl impl=new ModelImpl();
    impl.setType(type);
    JsonNode ap=node.get(""String_Node_Str"");
    if (ap != null && ap.getNodeType().equals(JsonNodeType.OBJECT)) {
      impl.setAdditionalProperties(Json.mapper().convertValue(ap,Property.class));
    }
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDefaultValue(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setFormat(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDiscriminator(value);
    Boolean bp=getBoolean(""String_Node_Str"",node,false,location,result);
    if (bp != null) {
      impl.setUniqueItems(bp);
    }
    bp=getBoolean(""String_Node_Str"",node,false,location,result);
    if (bp != null) {
      impl.setExclusiveMaximum(bp);
    }
    bp=getBoolean(""String_Node_Str"",node,false,location,result);
    if (bp != null) {
      impl.setExclusiveMinimum(bp);
    }
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setPattern(value);
    BigDecimal maximum=getBigDecimal(""String_Node_Str"",node,false,location,result);
    if (maximum != null) {
      impl.maximum(maximum);
    }
    BigDecimal minimum=getBigDecimal(""String_Node_Str"",node,false,location,result);
    if (minimum != null) {
      impl.minimum(minimum);
    }
    Integer minLength=getInteger(""String_Node_Str"",node,false,location,result);
    if (minLength != null) {
      impl.setMinLength(minLength);
    }
    Integer maxLength=getInteger(""String_Node_Str"",node,false,location,result);
    if (maxLength != null) {
      impl.setMaxLength(maxLength);
    }
    BigDecimal multipleOf=getBigDecimal(""String_Node_Str"",node,false,location,result);
    if (multipleOf != null) {
      impl.setMultipleOf(multipleOf);
    }
    ap=node.get(""String_Node_Str"");
    if (ap != null) {
      ArrayNode arrayNode=getArray(""String_Node_Str"",node,false,location,result);
      if (arrayNode != null) {
        for (        JsonNode n : arrayNode) {
          if (n.isValueNode()) {
            impl._enum(n.asText());
          }
 else {
            result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
          }
        }
      }
    }
    JsonNode xml=node.get(""String_Node_Str"");
    if (xml != null) {
      impl.setXml(Json.mapper().convertValue(xml,Xml.class));
    }
    ObjectNode externalDocs=getObject(""String_Node_Str"",node,false,location,result);
    ExternalDocs docs=externalDocs(externalDocs,location,result);
    impl.setExternalDocs(docs);
    ObjectNode properties=getObject(""String_Node_Str"",node,false,location,result);
    if (properties != null) {
      Set<String> propertyNames=getKeys(properties);
      for (      String propertyName : propertyNames) {
        JsonNode propertyNode=properties.get(propertyName);
        if (propertyNode.getNodeType().equals(JsonNodeType.OBJECT)) {
          ObjectNode on=(ObjectNode)propertyNode;
          Property property=property(on,location,result);
          impl.property(propertyName,property);
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",propertyNode);
        }
      }
    }
    ArrayNode required=getArray(""String_Node_Str"",node,false,location,result);
    if (required != null) {
      List<String> requiredProperties=new ArrayList<String>();
      for (      JsonNode n : required) {
        if (n.getNodeType().equals(JsonNodeType.STRING)) {
          requiredProperties.add(((TextNode)n).textValue());
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
        }
      }
      if (requiredProperties.size() > 0) {
        impl.setRequired(requiredProperties);
      }
    }
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        impl.setVendorExtension(key,extension(node.get(key)));
      }
 else       if (!SCHEMA_KEYS.contains(key)) {
        result.extra(location,key,node.get(key));
      }
    }
    model=impl;
  }
  JsonNode exampleNode=node.get(""String_Node_Str"");
  if (exampleNode != null) {
    Object example=Json.mapper().convertValue(exampleNode,Object.class);
    model.setExample(example);
  }
  if (model != null) {
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setDescription(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setTitle(value);
  }
  return model;
}",0.9777509486029664
29634,"public Property property(ObjectNode node,String location,ParseResult result){
  if (node != null) {
    if (node.get(""String_Node_Str"") == null) {
      JsonNode enumNode=node.get(""String_Node_Str"");
      if (enumNode != null && enumNode.isArray()) {
        String type=inferTypeFromArray((ArrayNode)enumNode);
        node.put(""String_Node_Str"",type);
      }
    }
  }
  if (node.get(""String_Node_Str"") != null && node.get(""String_Node_Str"").isTextual()) {
    String mungedRef=mungedRef(node.get(""String_Node_Str"").textValue());
    if (mungedRef != null) {
      node.put(""String_Node_Str"",mungedRef);
    }
  }
  return Json.mapper().convertValue(node,Property.class);
}","public Property property(ObjectNode node,String location,ParseResult result){
  if (node != null) {
    if (node.get(""String_Node_Str"") == null) {
      JsonNode enumNode=node.get(""String_Node_Str"");
      if (enumNode != null && enumNode.isArray()) {
        String type=inferTypeFromArray((ArrayNode)enumNode);
        node.put(""String_Node_Str"",type);
      }
    }
  }
  return Json.mapper().convertValue(node,Property.class);
}",0.7790802524797115
29635,"public Parameter parameter(ObjectNode obj,String location,ParseResult result){
  if (obj == null) {
    return null;
  }
  Parameter output=null;
  JsonNode ref=obj.get(""String_Node_Str"");
  if (ref != null) {
    if (ref.getNodeType().equals(JsonNodeType.STRING)) {
      String mungedRef=mungedRef(ref.textValue());
      if (mungedRef != null) {
        obj.put(""String_Node_Str"",mungedRef);
        ref=obj.get(""String_Node_Str"");
      }
      return refParameter((TextNode)ref,location,result);
    }
 else {
      result.invalidType(location,""String_Node_Str"",""String_Node_Str"",obj);
      return null;
    }
  }
  String l=null;
  JsonNode ln=obj.get(""String_Node_Str"");
  if (ln != null) {
    l=ln.asText();
  }
 else {
    l=""String_Node_Str"";
  }
  location+=""String_Node_Str"" + l + ""String_Node_Str"";
  String value=getString(""String_Node_Str"",obj,true,location,result);
  if (value != null) {
    String type=getString(""String_Node_Str"",obj,false,location,result);
    String format=getString(""String_Node_Str"",obj,false,location,result);
    AbstractSerializableParameter<?> sp=null;
    if (""String_Node_Str"".equals(value)) {
      sp=new QueryParameter();
    }
 else     if (""String_Node_Str"".equals(value)) {
      sp=new HeaderParameter();
    }
 else     if (""String_Node_Str"".equals(value)) {
      sp=new PathParameter();
    }
 else     if (""String_Node_Str"".equals(value)) {
      sp=new FormParameter();
    }
    if (sp != null) {
      getString(""String_Node_Str"",obj,true,location,result);
      Map<PropertyBuilder.PropertyId,Object> map=new LinkedHashMap<PropertyBuilder.PropertyId,Object>();
      map.put(TYPE,type);
      map.put(FORMAT,format);
      String defaultValue=getString(""String_Node_Str"",obj,false,location,result);
      map.put(DEFAULT,defaultValue);
      sp.setDefault(defaultValue);
      BigDecimal bd=getBigDecimal(""String_Node_Str"",obj,false,location,result);
      if (bd != null) {
        map.put(MAXIMUM,bd);
        sp.setMaximum(bd);
      }
      Boolean bl=getBoolean(""String_Node_Str"",obj,false,location,result);
      if (bl != null) {
        map.put(EXCLUSIVE_MAXIMUM,bl);
        sp.setExclusiveMaximum(bl);
      }
      bd=getBigDecimal(""String_Node_Str"",obj,false,location,result);
      if (bd != null) {
        map.put(MINIMUM,bd);
        sp.setMinimum(bd);
      }
      bl=getBoolean(""String_Node_Str"",obj,false,location,result);
      if (bl != null) {
        map.put(EXCLUSIVE_MINIMUM,bl);
        sp.setExclusiveMinimum(bl);
      }
      Integer maxLength=getInteger(""String_Node_Str"",obj,false,location,result);
      map.put(MAX_LENGTH,maxLength);
      sp.setMaxLength(maxLength);
      Integer minLength=getInteger(""String_Node_Str"",obj,false,location,result);
      map.put(MIN_LENGTH,minLength);
      sp.setMinLength(minLength);
      String pat=getString(""String_Node_Str"",obj,false,location,result);
      map.put(PATTERN,pat);
      sp.setPattern(pat);
      Integer iv=getInteger(""String_Node_Str"",obj,false,location,result);
      map.put(MAX_ITEMS,iv);
      sp.setMaxItems(iv);
      iv=getInteger(""String_Node_Str"",obj,false,location,result);
      map.put(MIN_ITEMS,iv);
      sp.setMinItems(iv);
      iv=getInteger(""String_Node_Str"",obj,false,location,result);
      map.put(MIN_LENGTH,iv);
      sp.setMinLength(iv);
      iv=getInteger(""String_Node_Str"",obj,false,location,result);
      map.put(MAX_LENGTH,iv);
      sp.setMaxLength(iv);
      bd=getBigDecimal(""String_Node_Str"",obj,false,location,result);
      if (bd != null) {
        map.put(MULTIPLE_OF,bd);
        sp.setMultipleOf(bd.doubleValue());
      }
      Boolean uniqueItems=getBoolean(""String_Node_Str"",obj,false,location,result);
      map.put(UNIQUE_ITEMS,uniqueItems);
      sp.setUniqueItems(uniqueItems);
      ArrayNode an=getArray(""String_Node_Str"",obj,false,location,result);
      if (an != null) {
        List<String> _enum=new ArrayList<String>();
        for (        JsonNode n : an) {
          if (n.isValueNode()) {
            _enum.add(n.asText());
          }
 else {
            result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
          }
        }
        sp.setEnum(_enum);
        map.put(ENUM,_enum);
      }
      bl=getBoolean(""String_Node_Str"",obj,false,location,result);
      if (bl != null) {
        map.put(READ_ONLY,bl);
        sp.setReadOnly(bl);
      }
      bl=getBoolean(""String_Node_Str"",obj,false,location,result);
      if (bl != null) {
        map.put(ALLOW_EMPTY_VALUE,bl);
        sp.setAllowEmptyValue(bl);
      }
      Property prop=PropertyBuilder.build(type,format,map);
      if (prop != null) {
        sp.setProperty(prop);
        ObjectNode items=getObject(""String_Node_Str"",obj,false,location,result);
        if (items != null) {
          Property inner=schema(null,items,location,result);
          sp.setItems(inner);
        }
      }
      Set<String> keys=getKeys(obj);
      for (      String key : keys) {
        if (key.startsWith(""String_Node_Str"")) {
          sp.setVendorExtension(key,extension(obj.get(key)));
        }
 else         if (!PARAMETER_KEYS.contains(key)) {
          result.extra(location,key,obj.get(key));
        }
      }
      String collectionFormat=getString(""String_Node_Str"",obj,false,location,result);
      sp.setCollectionFormat(collectionFormat);
      output=sp;
    }
 else     if (""String_Node_Str"".equals(value)) {
      BodyParameter bp=new BodyParameter();
      JsonNode node=obj.get(""String_Node_Str"");
      if (node != null && node instanceof ObjectNode) {
        bp.setSchema(this.definition((ObjectNode)node,location,result));
      }
      ObjectNode examplesNode=getObject(""String_Node_Str"",obj,false,location,result);
      if (examplesNode != null) {
        Map<String,String> examples=Json.mapper().convertValue(examplesNode,Json.mapper().getTypeFactory().constructMapType(Map.class,String.class,Object.class));
        bp.setExamples(examples);
      }
      String pat=getString(""String_Node_Str"",obj,false,location,result);
      if (pat != null) {
        bp.setPattern(pat);
      }
      Boolean bl=getBoolean(""String_Node_Str"",obj,false,location,result);
      if (bl != null) {
        bp.setReadOnly(bl);
      }
      Set<String> keys=getKeys(obj);
      for (      String key : keys) {
        if (key.startsWith(""String_Node_Str"")) {
          bp.setVendorExtension(key,extension(obj.get(key)));
        }
 else         if (!BODY_PARAMETER_KEYS.contains(key)) {
          result.extra(location,key,obj.get(key));
        }
      }
      output=bp;
    }
    if (output != null) {
      value=getString(""String_Node_Str"",obj,true,location,result);
      output.setName(value);
      value=getString(""String_Node_Str"",obj,false,location,result);
      output.setDescription(value);
      Boolean required=getBoolean(""String_Node_Str"",obj,false,location,result);
      if (required != null) {
        output.setRequired(required);
      }
    }
  }
  return output;
}","public Parameter parameter(ObjectNode obj,String location,ParseResult result){
  if (obj == null) {
    return null;
  }
  Parameter output=null;
  JsonNode ref=obj.get(""String_Node_Str"");
  if (ref != null) {
    if (ref.getNodeType().equals(JsonNodeType.STRING)) {
      return refParameter((TextNode)ref,location,result);
    }
 else {
      result.invalidType(location,""String_Node_Str"",""String_Node_Str"",obj);
      return null;
    }
  }
  String l=null;
  JsonNode ln=obj.get(""String_Node_Str"");
  if (ln != null) {
    l=ln.asText();
  }
 else {
    l=""String_Node_Str"";
  }
  location+=""String_Node_Str"" + l + ""String_Node_Str"";
  String value=getString(""String_Node_Str"",obj,true,location,result);
  if (value != null) {
    String type=getString(""String_Node_Str"",obj,false,location,result);
    String format=getString(""String_Node_Str"",obj,false,location,result);
    AbstractSerializableParameter<?> sp=null;
    if (""String_Node_Str"".equals(value)) {
      sp=new QueryParameter();
    }
 else     if (""String_Node_Str"".equals(value)) {
      sp=new HeaderParameter();
    }
 else     if (""String_Node_Str"".equals(value)) {
      sp=new PathParameter();
    }
 else     if (""String_Node_Str"".equals(value)) {
      sp=new FormParameter();
    }
    if (sp != null) {
      getString(""String_Node_Str"",obj,true,location,result);
      Map<PropertyBuilder.PropertyId,Object> map=new LinkedHashMap<PropertyBuilder.PropertyId,Object>();
      map.put(TYPE,type);
      map.put(FORMAT,format);
      String defaultValue=getString(""String_Node_Str"",obj,false,location,result);
      map.put(DEFAULT,defaultValue);
      sp.setDefault(defaultValue);
      BigDecimal bd=getBigDecimal(""String_Node_Str"",obj,false,location,result);
      if (bd != null) {
        map.put(MAXIMUM,bd);
        sp.setMaximum(bd);
      }
      Boolean bl=getBoolean(""String_Node_Str"",obj,false,location,result);
      if (bl != null) {
        map.put(EXCLUSIVE_MAXIMUM,bl);
        sp.setExclusiveMaximum(bl);
      }
      bd=getBigDecimal(""String_Node_Str"",obj,false,location,result);
      if (bd != null) {
        map.put(MINIMUM,bd);
        sp.setMinimum(bd);
      }
      bl=getBoolean(""String_Node_Str"",obj,false,location,result);
      if (bl != null) {
        map.put(EXCLUSIVE_MINIMUM,bl);
        sp.setExclusiveMinimum(bl);
      }
      Integer maxLength=getInteger(""String_Node_Str"",obj,false,location,result);
      map.put(MAX_LENGTH,maxLength);
      sp.setMaxLength(maxLength);
      Integer minLength=getInteger(""String_Node_Str"",obj,false,location,result);
      map.put(MIN_LENGTH,minLength);
      sp.setMinLength(minLength);
      String pat=getString(""String_Node_Str"",obj,false,location,result);
      map.put(PATTERN,pat);
      sp.setPattern(pat);
      Integer iv=getInteger(""String_Node_Str"",obj,false,location,result);
      map.put(MAX_ITEMS,iv);
      sp.setMaxItems(iv);
      iv=getInteger(""String_Node_Str"",obj,false,location,result);
      map.put(MIN_ITEMS,iv);
      sp.setMinItems(iv);
      iv=getInteger(""String_Node_Str"",obj,false,location,result);
      map.put(MIN_LENGTH,iv);
      sp.setMinLength(iv);
      iv=getInteger(""String_Node_Str"",obj,false,location,result);
      map.put(MAX_LENGTH,iv);
      sp.setMaxLength(iv);
      bd=getBigDecimal(""String_Node_Str"",obj,false,location,result);
      if (bd != null) {
        map.put(MULTIPLE_OF,bd);
        sp.setMultipleOf(bd.doubleValue());
      }
      Boolean uniqueItems=getBoolean(""String_Node_Str"",obj,false,location,result);
      map.put(UNIQUE_ITEMS,uniqueItems);
      sp.setUniqueItems(uniqueItems);
      ArrayNode an=getArray(""String_Node_Str"",obj,false,location,result);
      if (an != null) {
        List<String> _enum=new ArrayList<String>();
        for (        JsonNode n : an) {
          if (n.isValueNode()) {
            _enum.add(n.asText());
          }
 else {
            result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
          }
        }
        sp.setEnum(_enum);
        map.put(ENUM,_enum);
      }
      bl=getBoolean(""String_Node_Str"",obj,false,location,result);
      if (bl != null) {
        map.put(READ_ONLY,bl);
        sp.setReadOnly(bl);
      }
      bl=getBoolean(""String_Node_Str"",obj,false,location,result);
      if (bl != null) {
        map.put(ALLOW_EMPTY_VALUE,bl);
        sp.setAllowEmptyValue(bl);
      }
      Property prop=PropertyBuilder.build(type,format,map);
      if (prop != null) {
        sp.setProperty(prop);
        ObjectNode items=getObject(""String_Node_Str"",obj,false,location,result);
        if (items != null) {
          Property inner=schema(null,items,location,result);
          sp.setItems(inner);
        }
      }
      Set<String> keys=getKeys(obj);
      for (      String key : keys) {
        if (key.startsWith(""String_Node_Str"")) {
          sp.setVendorExtension(key,extension(obj.get(key)));
        }
 else         if (!PARAMETER_KEYS.contains(key)) {
          result.extra(location,key,obj.get(key));
        }
      }
      String collectionFormat=getString(""String_Node_Str"",obj,false,location,result);
      sp.setCollectionFormat(collectionFormat);
      output=sp;
    }
 else     if (""String_Node_Str"".equals(value)) {
      BodyParameter bp=new BodyParameter();
      JsonNode node=obj.get(""String_Node_Str"");
      if (node != null && node instanceof ObjectNode) {
        bp.setSchema(this.definition((ObjectNode)node,location,result));
      }
      ObjectNode examplesNode=getObject(""String_Node_Str"",obj,false,location,result);
      if (examplesNode != null) {
        Map<String,String> examples=Json.mapper().convertValue(examplesNode,Json.mapper().getTypeFactory().constructMapType(Map.class,String.class,Object.class));
        bp.setExamples(examples);
      }
      String pat=getString(""String_Node_Str"",obj,false,location,result);
      if (pat != null) {
        bp.setPattern(pat);
      }
      Boolean bl=getBoolean(""String_Node_Str"",obj,false,location,result);
      if (bl != null) {
        bp.setReadOnly(bl);
      }
      Set<String> keys=getKeys(obj);
      for (      String key : keys) {
        if (key.startsWith(""String_Node_Str"")) {
          bp.setVendorExtension(key,extension(obj.get(key)));
        }
 else         if (!BODY_PARAMETER_KEYS.contains(key)) {
          result.extra(location,key,obj.get(key));
        }
      }
      output=bp;
    }
    if (output != null) {
      value=getString(""String_Node_Str"",obj,true,location,result);
      output.setName(value);
      value=getString(""String_Node_Str"",obj,false,location,result);
      output.setDescription(value);
      Boolean required=getBoolean(""String_Node_Str"",obj,false,location,result);
      if (required != null) {
        output.setRequired(required);
      }
    }
  }
  return output;
}",0.987242679037402
29636,"public Response response(ObjectNode node,String location,ParseResult result){
  if (node == null)   return null;
  Response output=new Response();
  JsonNode ref=node.get(""String_Node_Str"");
  if (ref != null) {
    if (ref.getNodeType().equals(JsonNodeType.STRING)) {
      return refResponse((TextNode)ref,location,result);
    }
 else {
      result.invalidType(location,""String_Node_Str"",""String_Node_Str"",node);
      return null;
    }
  }
  String value=getString(""String_Node_Str"",node,true,location,result);
  output.description(value);
  ObjectNode schema=getObject(""String_Node_Str"",node,false,location,result);
  if (schema != null) {
    JsonNode schemaRef=schema.get(""String_Node_Str"");
    if (schemaRef != null) {
      if (schemaRef.getNodeType().equals(JsonNodeType.STRING)) {
        String mungedRef=mungedRef(schemaRef.textValue());
        if (mungedRef != null) {
          schema.put(""String_Node_Str"",mungedRef);
          schemaRef=schema.get(""String_Node_Str"");
        }
        Model schemaProp=new RefModel(schemaRef.textValue());
        output.responseSchema(schemaProp);
      }
 else {
        result.invalidType(location,""String_Node_Str"",""String_Node_Str"",node);
      }
    }
 else {
      output.responseSchema(Json.mapper().convertValue(schema,Model.class));
    }
  }
  ObjectNode headersNode=getObject(""String_Node_Str"",node,false,location,result);
  if (headersNode != null) {
    Map<String,Property> headers=Json.mapper().convertValue(headersNode,Json.mapper().getTypeFactory().constructMapType(Map.class,String.class,Property.class));
    output.headers(headers);
  }
  ObjectNode examplesNode=getObject(""String_Node_Str"",node,false,location,result);
  if (examplesNode != null) {
    Map<String,Object> examples=Json.mapper().convertValue(examplesNode,Json.mapper().getTypeFactory().constructMapType(Map.class,String.class,Object.class));
    output.setExamples(examples);
  }
  Set<String> keys=getKeys(node);
  for (  String key : keys) {
    if (key.startsWith(""String_Node_Str"")) {
      output.setVendorExtension(key,extension(node.get(key)));
    }
 else     if (!RESPONSE_KEYS.contains(key)) {
      result.extra(location,key,node.get(key));
    }
  }
  return output;
}","public Response response(ObjectNode node,String location,ParseResult result){
  if (node == null)   return null;
  Response output=new Response();
  JsonNode ref=node.get(""String_Node_Str"");
  if (ref != null) {
    if (ref.getNodeType().equals(JsonNodeType.STRING)) {
      return refResponse((TextNode)ref,location,result);
    }
 else {
      result.invalidType(location,""String_Node_Str"",""String_Node_Str"",node);
      return null;
    }
  }
  String value=getString(""String_Node_Str"",node,true,location,result);
  output.description(value);
  ObjectNode schema=getObject(""String_Node_Str"",node,false,location,result);
  if (schema != null) {
    JsonNode schemaRef=schema.get(""String_Node_Str"");
    if (schemaRef != null) {
      if (schemaRef.getNodeType().equals(JsonNodeType.STRING)) {
        Model schemaProp=new RefModel(schemaRef.textValue());
        output.responseSchema(schemaProp);
      }
 else {
        result.invalidType(location,""String_Node_Str"",""String_Node_Str"",node);
      }
    }
 else {
      output.responseSchema(Json.mapper().convertValue(schema,Model.class));
    }
  }
  ObjectNode headersNode=getObject(""String_Node_Str"",node,false,location,result);
  if (headersNode != null) {
    Map<String,Property> headers=Json.mapper().convertValue(headersNode,Json.mapper().getTypeFactory().constructMapType(Map.class,String.class,Property.class));
    output.headers(headers);
  }
  ObjectNode examplesNode=getObject(""String_Node_Str"",node,false,location,result);
  if (examplesNode != null) {
    Map<String,Object> examples=Json.mapper().convertValue(examplesNode,Json.mapper().getTypeFactory().constructMapType(Map.class,String.class,Object.class));
    output.setExamples(examples);
  }
  Set<String> keys=getKeys(node);
  for (  String key : keys) {
    if (key.startsWith(""String_Node_Str"")) {
      output.setVendorExtension(key,extension(node.get(key)));
    }
 else     if (!RESPONSE_KEYS.contains(key)) {
      result.extra(location,key,node.get(key));
    }
  }
  return output;
}",0.951909476661952
29637,"@Test public void testIssue306(){
  SwaggerDeserializationResult result=new SwaggerParser().readWithInfo(""String_Node_Str"",null,true);
  assertNotNull(result.getSwagger());
  Swagger swagger=result.getSwagger();
  assertTrue(swagger.getDefinitions().size() == 5);
  assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
  assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
  assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
}","@Test public void testIssue306(){
  SwaggerDeserializationResult result=new SwaggerParser().readWithInfo(""String_Node_Str"",null,true);
  assertNotNull(result.getSwagger());
  Swagger swagger=result.getSwagger();
  assertTrue(swagger.getDefinitions().size() == 6);
  assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
  assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
  assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
}",0.9978401727861772
29638,"private void processRefProperty(RefProperty subRef,String externalFile){
  if (isAnExternalRefFormat(subRef.getRefFormat())) {
    String joinedRef=join(externalFile,subRef.get$ref());
    subRef.set$ref(processRefToExternalDefinition(joinedRef,subRef.getRefFormat()));
  }
 else {
    processRefToExternalDefinition(externalFile + subRef.get$ref(),RefFormat.RELATIVE);
  }
}","private void processRefProperty(RefProperty subRef,String externalFile){
  if (isAnExternalRefFormat(subRef.getRefFormat())) {
    String joinedRef=join(externalFile,subRef.get$ref());
    subRef.set$ref(processRefToExternalDefinition(joinedRef,subRef.getRefFormat()));
  }
 else   if (isAnExternalRefFormat(subRef.getOriginalRefFormat())) {
    String joinedRef=join(externalFile,subRef.getOriginalRef());
    subRef.set$ref(processRefToExternalDefinition(joinedRef,subRef.getOriginalRefFormat()));
  }
 else {
    processRefToExternalDefinition(externalFile + subRef.get$ref(),RefFormat.RELATIVE);
  }
}",0.7653061224489796
29639,"public String processRefToExternalDefinition(String $ref,RefFormat refFormat){
  String renamedRef=cache.getRenamedRef($ref);
  if (renamedRef != null) {
    return renamedRef;
  }
  final Model model=cache.loadRef($ref,refFormat,Model.class);
  if (model == null) {
    LOGGER.warn(""String_Node_Str"" + $ref + ""String_Node_Str""+ ""String_Node_Str"");
    return $ref;
  }
  String newRef;
  Map<String,Model> definitions=swagger.getDefinitions();
  if (definitions == null) {
    definitions=new LinkedHashMap<>();
  }
  final String possiblyConflictingDefinitionName=computeDefinitionName($ref);
  String tryName=null;
  Model existingModel=definitions.get(possiblyConflictingDefinitionName);
  if (existingModel != null) {
    LOGGER.debug(""String_Node_Str"" + existingModel + ""String_Node_Str"");
    if (existingModel instanceof RefModel) {
      existingModel=null;
    }
 else {
      int i=2;
      for (      String name : definitions.keySet()) {
        if (name.equals(possiblyConflictingDefinitionName)) {
          tryName=possiblyConflictingDefinitionName + ""String_Node_Str"" + i;
          existingModel=definitions.get(tryName);
          i++;
        }
      }
    }
  }
  if (StringUtils.isNotBlank(tryName)) {
    newRef=tryName;
  }
 else {
    newRef=possiblyConflictingDefinitionName;
  }
  cache.putRenamedRef($ref,newRef);
  if (existingModel == null) {
    swagger.addDefinition(newRef,model);
    cache.addReferencedKey(newRef);
    String file=$ref.split(""String_Node_Str"")[0];
    if (model instanceof RefModel) {
      RefModel refModel=(RefModel)model;
      if (isAnExternalRefFormat(refModel.getRefFormat())) {
        refModel.set$ref(processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat()));
      }
 else {
        processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
      }
    }
    if (model instanceof ComposedModel) {
      ComposedModel composedModel=(ComposedModel)model;
      List<Model> listOfAllOF=composedModel.getAllOf();
      for (      Model allOfModel : listOfAllOF) {
        if (allOfModel instanceof RefModel) {
          RefModel refModel=(RefModel)allOfModel;
          if (isAnExternalRefFormat(refModel.getRefFormat())) {
            String joinedRef=join(file,refModel.get$ref());
            refModel.set$ref(processRefToExternalDefinition(joinedRef,refModel.getRefFormat()));
          }
 else {
            processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
          }
        }
 else         if (allOfModel instanceof ModelImpl) {
          processProperties(allOfModel.getProperties(),file);
        }
      }
    }
    processProperties(model.getProperties(),file);
    if (model instanceof ModelImpl) {
      ModelImpl modelImpl=(ModelImpl)model;
      Property additionalProperties=modelImpl.getAdditionalProperties();
      if (additionalProperties != null) {
        if (additionalProperties instanceof RefProperty) {
          processRefProperty(((RefProperty)additionalProperties),file);
        }
 else         if (additionalProperties instanceof ArrayProperty) {
          ArrayProperty arrayProp=(ArrayProperty)additionalProperties;
          if (arrayProp.getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)arrayProp.getItems(),file);
          }
        }
 else         if (additionalProperties instanceof MapProperty) {
          MapProperty mapProp=(MapProperty)additionalProperties;
          if (mapProp.getAdditionalProperties() instanceof RefProperty) {
            processRefProperty((RefProperty)mapProp.getAdditionalProperties(),file);
          }
 else           if (mapProp.getAdditionalProperties() instanceof ArrayProperty && ((ArrayProperty)mapProp.getAdditionalProperties()).getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)((ArrayProperty)mapProp.getAdditionalProperties()).getItems(),file);
          }
        }
      }
    }
    if (model instanceof ArrayModel && ((ArrayModel)model).getItems() instanceof RefProperty) {
      processRefProperty((RefProperty)((ArrayModel)model).getItems(),file);
    }
  }
  return newRef;
}","public String processRefToExternalDefinition(String $ref,RefFormat refFormat){
  String renamedRef=cache.getRenamedRef($ref);
  if (renamedRef != null) {
    return renamedRef;
  }
  final Model model=cache.loadRef($ref,refFormat,Model.class);
  if (model == null) {
    LOGGER.warn(""String_Node_Str"" + $ref + ""String_Node_Str""+ ""String_Node_Str"");
    return $ref;
  }
  String newRef;
  Map<String,Model> definitions=swagger.getDefinitions();
  if (definitions == null) {
    definitions=new LinkedHashMap<>();
  }
  final String possiblyConflictingDefinitionName=computeDefinitionName($ref);
  String tryName=null;
  Model existingModel=definitions.get(possiblyConflictingDefinitionName);
  if (existingModel != null) {
    LOGGER.debug(""String_Node_Str"" + existingModel + ""String_Node_Str"");
    if (existingModel instanceof RefModel) {
      existingModel=null;
    }
 else {
      int i=2;
      for (      String name : definitions.keySet()) {
        if (name.equals(possiblyConflictingDefinitionName)) {
          tryName=possiblyConflictingDefinitionName + ""String_Node_Str"" + i;
          existingModel=definitions.get(tryName);
          i++;
        }
      }
    }
  }
  if (StringUtils.isNotBlank(tryName)) {
    newRef=tryName;
  }
 else {
    newRef=possiblyConflictingDefinitionName;
  }
  cache.putRenamedRef($ref,newRef);
  if (existingModel == null) {
    swagger.addDefinition(newRef,model);
    cache.addReferencedKey(newRef);
    String file=$ref.split(""String_Node_Str"")[0];
    if (model instanceof RefModel) {
      RefModel refModel=(RefModel)model;
      if (isAnExternalRefFormat(refModel.getRefFormat())) {
        refModel.set$ref(processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat()));
      }
 else {
        processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
      }
    }
    if (model instanceof ComposedModel) {
      ComposedModel composedModel=(ComposedModel)model;
      List<Model> listOfAllOF=composedModel.getAllOf();
      for (      Model allOfModel : listOfAllOF) {
        if (allOfModel instanceof RefModel) {
          RefModel refModel=(RefModel)allOfModel;
          if (isAnExternalRefFormat(refModel.getRefFormat())) {
            String joinedRef=join(file,refModel.get$ref());
            refModel.set$ref(processRefToExternalDefinition(joinedRef,refModel.getRefFormat()));
          }
 else           if (isAnExternalRefFormat(refModel.getOriginalRefFormat())) {
            String joinedRef=join(file,refModel.getOriginalRef());
            refModel.set$ref(processRefToExternalDefinition(joinedRef,refModel.getOriginalRefFormat()));
          }
 else {
            processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
          }
        }
 else         if (allOfModel instanceof ModelImpl) {
          processProperties(allOfModel.getProperties(),file);
        }
      }
    }
    processProperties(model.getProperties(),file);
    if (model instanceof ModelImpl) {
      ModelImpl modelImpl=(ModelImpl)model;
      Property additionalProperties=modelImpl.getAdditionalProperties();
      if (additionalProperties != null) {
        if (additionalProperties instanceof RefProperty) {
          processRefProperty(((RefProperty)additionalProperties),file);
        }
 else         if (additionalProperties instanceof ArrayProperty) {
          ArrayProperty arrayProp=(ArrayProperty)additionalProperties;
          if (arrayProp.getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)arrayProp.getItems(),file);
          }
        }
 else         if (additionalProperties instanceof MapProperty) {
          MapProperty mapProp=(MapProperty)additionalProperties;
          if (mapProp.getAdditionalProperties() instanceof RefProperty) {
            processRefProperty((RefProperty)mapProp.getAdditionalProperties(),file);
          }
 else           if (mapProp.getAdditionalProperties() instanceof ArrayProperty && ((ArrayProperty)mapProp.getAdditionalProperties()).getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)((ArrayProperty)mapProp.getAdditionalProperties()).getItems(),file);
          }
        }
      }
    }
    if (model instanceof ArrayModel && ((ArrayModel)model).getItems() instanceof RefProperty) {
      processRefProperty((RefProperty)((ArrayModel)model).getItems(),file);
    }
  }
  return newRef;
}",0.9694068192433444
29640,"private void processRefModel(RefModel refModel){
  if (isAnExternalRefFormat(refModel.getRefFormat())) {
    final String newRef=externalRefProcessor.processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat());
    if (newRef != null) {
      refModel.set$ref(newRef);
    }
  }
}","private void processRefModel(RefModel refModel){
  String newRef=null;
  if (isAnExternalRefFormat(refModel.getRefFormat())) {
    newRef=externalRefProcessor.processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat());
  }
 else   if (isAnExternalRefFormat(refModel.getOriginalRefFormat())) {
    newRef=externalRefProcessor.processRefToExternalDefinition(refModel.getOriginalRef(),refModel.getOriginalRefFormat());
  }
  if (newRef != null) {
    refModel.set$ref(newRef);
  }
}",0.6936708860759494
29641,"public List<Parameter> processParameters(List<Parameter> parameters){
  if (parameters == null) {
    return null;
  }
  final List<Parameter> processedPathLevelParameters=new ArrayList<>();
  final List<Parameter> refParameters=new ArrayList<>();
  for (  Parameter parameter : parameters) {
    if (parameter instanceof RefParameter) {
      RefParameter refParameter=(RefParameter)parameter;
      final Parameter resolvedParameter=cache.loadRef(refParameter.get$ref(),refParameter.getRefFormat(),Parameter.class);
      if (resolvedParameter == null) {
        processedPathLevelParameters.add(refParameter);
        continue;
      }
      boolean matched=false;
      for (      Parameter param : processedPathLevelParameters) {
        if (param.getName() != null) {
          if (param.getName().equals(resolvedParameter.getName())) {
            matched=true;
            break;
          }
        }
      }
      for (      Parameter param : parameters) {
        if (param.getName() != null) {
          if (param.getName().equals(resolvedParameter.getName())) {
            matched=true;
            break;
          }
        }
      }
      if (resolvedParameter instanceof BodyParameter) {
        BodyParameter bodyParameter=(BodyParameter)resolvedParameter;
        final Model schema=bodyParameter.getSchema();
        modelProcessor.processModel(schema);
      }
      if (matched) {
        refParameters.add(resolvedParameter);
      }
 else {
        processedPathLevelParameters.add(resolvedParameter);
      }
    }
 else {
      if (parameter instanceof BodyParameter) {
        BodyParameter bodyParameter=(BodyParameter)parameter;
        final Model schema=bodyParameter.getSchema();
        modelProcessor.processModel(schema);
      }
      processedPathLevelParameters.add(parameter);
    }
  }
  for (  Parameter resolvedParameter : refParameters) {
    int pos=0;
    for (    Parameter param : processedPathLevelParameters) {
      if (param.getName().equals(resolvedParameter.getName())) {
        processedPathLevelParameters.set(pos,resolvedParameter);
        break;
      }
      pos++;
    }
  }
  return processedPathLevelParameters;
}","public List<Parameter> processParameters(List<Parameter> parameters){
  if (parameters == null) {
    return null;
  }
  final List<Parameter> processedPathLevelParameters=new ArrayList<>();
  final List<Parameter> refParameters=new ArrayList<>();
  for (  Parameter parameter : parameters) {
    if (parameter instanceof RefParameter) {
      RefParameter refParameter=(RefParameter)parameter;
      Parameter resolvedParameter=cache.loadRef(refParameter.get$ref(),refParameter.getRefFormat(),Parameter.class);
      if (resolvedParameter == null) {
        resolvedParameter=cache.loadRef(refParameter.getOriginalRef(),refParameter.getOriginalRefFormat(),Parameter.class);
        if (resolvedParameter == null) {
          processedPathLevelParameters.add(refParameter);
          continue;
        }
      }
      boolean matched=false;
      for (      Parameter param : processedPathLevelParameters) {
        if (param.getName() != null) {
          if (param.getName().equals(resolvedParameter.getName())) {
            matched=true;
            break;
          }
        }
      }
      for (      Parameter param : parameters) {
        if (param.getName() != null) {
          if (param.getName().equals(resolvedParameter.getName())) {
            matched=true;
            break;
          }
        }
      }
      if (resolvedParameter instanceof BodyParameter) {
        BodyParameter bodyParameter=(BodyParameter)resolvedParameter;
        final Model schema=bodyParameter.getSchema();
        modelProcessor.processModel(schema);
      }
      if (matched) {
        refParameters.add(resolvedParameter);
      }
 else {
        processedPathLevelParameters.add(resolvedParameter);
      }
    }
 else {
      if (parameter instanceof BodyParameter) {
        BodyParameter bodyParameter=(BodyParameter)parameter;
        final Model schema=bodyParameter.getSchema();
        modelProcessor.processModel(schema);
      }
      processedPathLevelParameters.add(parameter);
    }
  }
  for (  Parameter resolvedParameter : refParameters) {
    int pos=0;
    for (    Parameter param : processedPathLevelParameters) {
      if (param.getName().equals(resolvedParameter.getName())) {
        processedPathLevelParameters.set(pos,resolvedParameter);
        break;
      }
      pos++;
    }
  }
  return processedPathLevelParameters;
}",0.9591340843825932
29642,"public void processPaths(){
  final Map<String,Path> pathMap=swagger.getPaths();
  if (pathMap == null) {
    return;
  }
  for (  String pathStr : pathMap.keySet()) {
    Path path=pathMap.get(pathStr);
    if (settings.addParametersToEachOperation()) {
      List<Parameter> parameters=path.getParameters();
      if (parameters != null) {
        List<Operation> operations=path.getOperations();
        if (operations != null) {
          for (          Operation operation : operations) {
            List<Parameter> parametersToAdd=new ArrayList<Parameter>();
            List<Parameter> existingParameters=operation.getParameters();
            for (            Parameter parameterToAdd : parameters) {
              boolean matched=false;
              for (              Parameter existingParameter : existingParameters) {
                if (parameterToAdd.getIn() != null && parameterToAdd.getIn().equals(existingParameter.getIn()) && parameterToAdd.getName().equals(existingParameter.getName())) {
                  matched=true;
                }
              }
              if (!matched) {
                parametersToAdd.add(parameterToAdd);
              }
            }
            if (parametersToAdd.size() > 0) {
              operation.getParameters().addAll(0,parametersToAdd);
            }
          }
        }
      }
      path.setParameters(null);
    }
    if (path instanceof RefPath) {
      RefPath refPath=(RefPath)path;
      Path resolvedPath=cache.loadRef(refPath.get$ref(),refPath.getRefFormat(),Path.class);
      String pathRef=refPath.get$ref().split(""String_Node_Str"")[0];
      updateLocalRefs(resolvedPath,pathRef);
      if (resolvedPath != null) {
        swagger.path(pathStr,resolvedPath);
        path=resolvedPath;
      }
    }
    final List<Parameter> processedPathParameters=parameterProcessor.processParameters(path.getParameters());
    path.setParameters(processedPathParameters);
    final Map<HttpMethod,Operation> operationMap=path.getOperationMap();
    for (    HttpMethod httpMethod : operationMap.keySet()) {
      Operation operation=operationMap.get(httpMethod);
      operationProcessor.processOperation(operation);
    }
  }
}","public void processPaths(){
  final Map<String,Path> pathMap=swagger.getPaths();
  if (pathMap == null) {
    return;
  }
  for (  String pathStr : pathMap.keySet()) {
    Path path=pathMap.get(pathStr);
    if (settings.addParametersToEachOperation()) {
      List<Parameter> parameters=path.getParameters();
      if (parameters != null) {
        List<Operation> operations=path.getOperations();
        if (operations != null) {
          for (          Operation operation : operations) {
            List<Parameter> parametersToAdd=new ArrayList<Parameter>();
            List<Parameter> existingParameters=operation.getParameters();
            for (            Parameter parameterToAdd : parameters) {
              boolean matched=false;
              for (              Parameter existingParameter : existingParameters) {
                if (parameterToAdd.getIn() != null && parameterToAdd.getIn().equals(existingParameter.getIn()) && parameterToAdd.getName().equals(existingParameter.getName())) {
                  matched=true;
                }
              }
              if (!matched) {
                parametersToAdd.add(parameterToAdd);
              }
            }
            if (parametersToAdd.size() > 0) {
              operation.getParameters().addAll(0,parametersToAdd);
            }
          }
        }
      }
      path.setParameters(null);
    }
    if (path instanceof RefPath) {
      RefPath refPath=(RefPath)path;
      Path resolvedPath=cache.loadRef(refPath.get$ref(),refPath.getRefFormat(),Path.class);
      if (resolvedPath == null) {
        resolvedPath=cache.loadRef(refPath.getOriginalRef(),refPath.getOriginalRefFormat(),Path.class);
      }
      String pathRef=refPath.get$ref().split(""String_Node_Str"")[0];
      if (resolvedPath != null) {
        updateLocalRefs(resolvedPath,pathRef);
        swagger.path(pathStr,resolvedPath);
        path=resolvedPath;
      }
    }
    final List<Parameter> processedPathParameters=parameterProcessor.processParameters(path.getParameters());
    path.setParameters(processedPathParameters);
    final Map<HttpMethod,Operation> operationMap=path.getOperationMap();
    for (    HttpMethod httpMethod : operationMap.keySet()) {
      Operation operation=operationMap.get(httpMethod);
      operationProcessor.processOperation(operation);
    }
  }
}",0.9475539885412076
29643,"@Test public void testAllOfFlatAndNested(){
  for (  String path : Arrays.asList(""String_Node_Str"",""String_Node_Str"")) {
    Swagger swagger=new SwaggerParser().read(path);
    assertEquals(3,swagger.getDefinitions().size());
    ComposedModel composedModel=(ComposedModel)swagger.getDefinitions().get(""String_Node_Str"");
    assertEquals(((RefModel)composedModel.getParent()).getSimpleRef(),""String_Node_Str"");
    Map<String,Property> props=composedModel.getChild().getProperties();
    assertEquals(((RefProperty)props.get(""String_Node_Str"")).getSimpleRef(),""String_Node_Str"");
    assertEquals(((RefProperty)((ArrayProperty)props.get(""String_Node_Str"")).getItems()).getSimpleRef(),""String_Node_Str"");
  }
}","@Test public void testAllOfFlatAndNested(){
  for (  String path : Arrays.asList(""String_Node_Str"",""String_Node_Str"")) {
    Swagger swagger=new SwaggerParser().read(path);
    assertEquals(3,swagger.getDefinitions().size());
    assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
    assertTrue(swagger.getDefinitions().get(""String_Node_Str"") instanceof RefModel);
    assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
    assertTrue(swagger.getDefinitions().get(""String_Node_Str"") instanceof ComposedModel);
    ComposedModel composedModel=(ComposedModel)swagger.getDefinitions().get(""String_Node_Str"");
    assertEquals(((RefModel)composedModel.getParent()).getSimpleRef(),""String_Node_Str"");
    Map<String,Property> props=composedModel.getChild().getProperties();
    assertEquals(((RefProperty)props.get(""String_Node_Str"")).getSimpleRef(),""String_Node_Str"");
    assertEquals(((RefProperty)((ArrayProperty)props.get(""String_Node_Str"")).getItems()).getSimpleRef(),""String_Node_Str"");
  }
}",0.8203350664355864
29644,"@Test public void testIssue306(){
  SwaggerDeserializationResult result=new SwaggerParser().readWithInfo(""String_Node_Str"",null,true);
  assertNotNull(result.getSwagger());
  Swagger swagger=result.getSwagger();
  assertTrue(swagger.getDefinitions().size() == 6);
  assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
  assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
  assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
}","@Test public void testIssue306(){
  SwaggerDeserializationResult result=new SwaggerParser().readWithInfo(""String_Node_Str"",null,true);
  assertNotNull(result.getSwagger());
  Swagger swagger=result.getSwagger();
  assertTrue(swagger.getDefinitions().size() == 5);
  assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
  assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
  assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
}",0.9978401727861772
29645,"@Test public void testIssue421(){
  SwaggerDeserializationResult result=new SwaggerParser().readWithInfo(""String_Node_Str"",null,true);
  assertNotNull(result.getSwagger());
  Swagger swagger=result.getSwagger();
  assertNotNull(swagger.getPath(""String_Node_Str""));
  assertNotNull(swagger.getPath(""String_Node_Str"").getGet());
  assertNotNull(swagger.getPath(""String_Node_Str"").getGet().getParameters());
  assertTrue(swagger.getPath(""String_Node_Str"").getGet().getParameters().size() == 1);
  assertTrue(swagger.getPath(""String_Node_Str"").getGet().getParameters().get(0).getName().equals(""String_Node_Str""));
  assertTrue(swagger.getDefinitions().get(""String_Node_Str"") instanceof ModelImpl);
  assertTrue(swagger.getDefinitions().get(""String_Node_Str"").getProperties().size() == 6);
  assertNotNull(swagger.getPath(""String_Node_Str"").getPost());
  assertNotNull(swagger.getPath(""String_Node_Str"").getPost().getParameters());
  assertTrue(swagger.getPath(""String_Node_Str"").getPost().getParameters().size() == 3);
  assertTrue(swagger.getPath(""String_Node_Str"").getPost().getParameters().get(1) instanceof RefParameter);
  assertTrue(((RefParameter)swagger.getPath(""String_Node_Str"").getPost().getParameters().get(1)).getRefFormat() == RefFormat.INTERNAL);
  assertTrue(((RefParameter)swagger.getPath(""String_Node_Str"").getPost().getParameters().get(1)).getSimpleRef().equals(""String_Node_Str""));
  assertNotNull(swagger.getPath(""String_Node_Str""));
  assertNotNull(swagger.getPath(""String_Node_Str"").getPost());
  assertNotNull(swagger.getPath(""String_Node_Str"").getPost().getParameters());
  assertTrue(swagger.getPath(""String_Node_Str"").getPost().getParameters().size() == 1);
  assertTrue(swagger.getPath(""String_Node_Str"").getPost().getParameters().get(0) instanceof BodyParameter);
  assertNotNull(((BodyParameter)swagger.getPath(""String_Node_Str"").getPost().getParameters().get(0)).getSchema());
  assertTrue(((BodyParameter)swagger.getPath(""String_Node_Str"").getPost().getParameters().get(0)).getSchema() instanceof RefModel);
  assertTrue(((RefModel)((BodyParameter)swagger.getPath(""String_Node_Str"").getPost().getParameters().get(0)).getSchema()).getSimpleRef().equals(""String_Node_Str""));
  assertTrue(swagger.getDefinitions().get(""String_Node_Str"") instanceof ModelImpl);
  assertTrue(swagger.getDefinitions().get(""String_Node_Str"").getProperties().size() == 6);
}","@Test public void testIssue421(){
  SwaggerDeserializationResult result=new SwaggerParser().readWithInfo(""String_Node_Str"",null,true);
  assertNotNull(result.getSwagger());
  Swagger swagger=result.getSwagger();
  assertNotNull(swagger.getPath(""String_Node_Str""));
  assertNotNull(swagger.getPath(""String_Node_Str"").getGet());
  assertNotNull(swagger.getPath(""String_Node_Str"").getGet().getParameters());
  assertTrue(swagger.getPath(""String_Node_Str"").getGet().getParameters().size() == 1);
  Yaml.prettyPrint(swagger.getPaths());
  assertTrue(swagger.getPath(""String_Node_Str"").getGet().getParameters().get(0).getName().equals(""String_Node_Str""));
  assertTrue(swagger.getDefinitions().get(""String_Node_Str"") instanceof ModelImpl);
  assertTrue(swagger.getDefinitions().get(""String_Node_Str"").getProperties().size() == 6);
  assertNotNull(swagger.getPath(""String_Node_Str"").getPost());
  assertNotNull(swagger.getPath(""String_Node_Str"").getPost().getParameters());
  assertTrue(swagger.getPath(""String_Node_Str"").getPost().getParameters().size() == 3);
  assertTrue(swagger.getPath(""String_Node_Str"").getPost().getParameters().get(1) instanceof RefParameter);
  assertTrue(((RefParameter)swagger.getPath(""String_Node_Str"").getPost().getParameters().get(1)).getRefFormat() == RefFormat.INTERNAL);
  assertTrue(((RefParameter)swagger.getPath(""String_Node_Str"").getPost().getParameters().get(1)).getSimpleRef().equals(""String_Node_Str""));
  assertNotNull(swagger.getPath(""String_Node_Str""));
  assertNotNull(swagger.getPath(""String_Node_Str"").getPost());
  assertNotNull(swagger.getPath(""String_Node_Str"").getPost().getParameters());
  assertTrue(swagger.getPath(""String_Node_Str"").getPost().getParameters().size() == 1);
  assertTrue(swagger.getPath(""String_Node_Str"").getPost().getParameters().get(0) instanceof BodyParameter);
  assertNotNull(((BodyParameter)swagger.getPath(""String_Node_Str"").getPost().getParameters().get(0)).getSchema());
  assertTrue(((BodyParameter)swagger.getPath(""String_Node_Str"").getPost().getParameters().get(0)).getSchema() instanceof RefModel);
  assertTrue(((RefModel)((BodyParameter)swagger.getPath(""String_Node_Str"").getPost().getParameters().get(0)).getSchema()).getSimpleRef().equals(""String_Node_Str""));
  assertTrue(swagger.getDefinitions().get(""String_Node_Str"") instanceof ModelImpl);
  assertTrue(swagger.getDefinitions().get(""String_Node_Str"").getProperties().size() == 6);
}",0.9916562369628704
29646,"public Model definition(ObjectNode node,String location,ParseResult result){
  if (result == null) {
    result=new ParseResult();
  }
  if (node == null) {
    result.missing(location,""String_Node_Str"");
    return null;
  }
  if (node.get(""String_Node_Str"") != null) {
    return refModel(node,location,result);
  }
  if (node.get(""String_Node_Str"") != null) {
    return allOfModel(node,location,result);
  }
  Model model=null;
  String value=null;
  String type=getString(""String_Node_Str"",node,false,location,result);
  Model m=new ModelImpl();
  if (""String_Node_Str"".equals(type)) {
    ArrayModel am=new ArrayModel();
    ObjectNode propertyNode=getObject(""String_Node_Str"",node,false,location,result);
    Map<String,Property> properties=properties(propertyNode,location,result);
    am.setProperties(properties);
    ObjectNode itemsNode=getObject(""String_Node_Str"",node,false,location,result);
    Property items=property(itemsNode,location,result);
    if (items != null) {
      am.items(items);
    }
    Integer maxItems=getInteger(""String_Node_Str"",node,false,location,result);
    am.setMaxItems(maxItems);
    Integer minItems=getInteger(""String_Node_Str"",node,false,location,result);
    am.setMinItems(minItems);
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        am.setVendorExtension(key,extension(node.get(key)));
      }
    }
    model=am;
  }
 else {
    ModelImpl impl=new ModelImpl();
    impl.setType(type);
    JsonNode ap=node.get(""String_Node_Str"");
    if (ap != null && ap.getNodeType().equals(JsonNodeType.OBJECT)) {
      impl.setAdditionalProperties(Json.mapper().convertValue(ap,Property.class));
    }
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDefaultValue(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setFormat(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDiscriminator(value);
    Boolean bp=getBoolean(""String_Node_Str"",node,false,location,result);
    if (bp != null) {
      impl.setUniqueItems(bp);
    }
    ap=node.get(""String_Node_Str"");
    if (ap != null) {
      ArrayNode arrayNode=getArray(""String_Node_Str"",node,false,location,result);
      if (arrayNode != null) {
        for (        JsonNode n : arrayNode) {
          if (n.isValueNode()) {
            impl._enum(n.asText());
          }
 else {
            result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
          }
        }
      }
    }
    JsonNode xml=node.get(""String_Node_Str"");
    if (xml != null) {
      impl.setXml(Json.mapper().convertValue(xml,Xml.class));
    }
    ObjectNode externalDocs=getObject(""String_Node_Str"",node,false,location,result);
    ExternalDocs docs=externalDocs(externalDocs,location,result);
    impl.setExternalDocs(docs);
    ObjectNode properties=getObject(""String_Node_Str"",node,false,location,result);
    if (properties != null) {
      Set<String> propertyNames=getKeys(properties);
      for (      String propertyName : propertyNames) {
        JsonNode propertyNode=properties.get(propertyName);
        if (propertyNode.getNodeType().equals(JsonNodeType.OBJECT)) {
          ObjectNode on=(ObjectNode)propertyNode;
          Property property=property(on,location,result);
          impl.property(propertyName,property);
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",propertyNode);
        }
      }
    }
    ArrayNode required=getArray(""String_Node_Str"",node,false,location,result);
    if (required != null) {
      List<String> requiredProperties=new ArrayList<String>();
      for (      JsonNode n : required) {
        if (n.getNodeType().equals(JsonNodeType.STRING)) {
          requiredProperties.add(((TextNode)n).textValue());
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
        }
      }
      if (requiredProperties.size() > 0) {
        impl.setRequired(requiredProperties);
      }
    }
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        impl.setVendorExtension(key,extension(node.get(key)));
      }
 else       if (!SCHEMA_KEYS.contains(key)) {
        result.extra(location,key,node.get(key));
      }
    }
    model=impl;
  }
  JsonNode exampleNode=node.get(""String_Node_Str"");
  if (exampleNode != null) {
    Object example=Json.mapper().convertValue(exampleNode,Object.class);
    model.setExample(example);
  }
  if (model != null) {
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setDescription(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setTitle(value);
  }
  return model;
}","public Model definition(ObjectNode node,String location,ParseResult result){
  if (result == null) {
    result=new ParseResult();
  }
  if (node == null) {
    result.missing(location,""String_Node_Str"");
    return null;
  }
  if (node.get(""String_Node_Str"") != null) {
    return refModel(node,location,result);
  }
  if (node.get(""String_Node_Str"") != null) {
    return allOfModel(node,location,result);
  }
  Model model=null;
  String value=null;
  String type=getString(""String_Node_Str"",node,false,location,result);
  Model m=new ModelImpl();
  if (""String_Node_Str"".equals(type)) {
    ArrayModel am=new ArrayModel();
    ObjectNode propertyNode=getObject(""String_Node_Str"",node,false,location,result);
    Map<String,Property> properties=properties(propertyNode,location,result);
    am.setProperties(properties);
    ObjectNode itemsNode=getObject(""String_Node_Str"",node,false,location,result);
    Property items=property(itemsNode,location,result);
    if (items != null) {
      am.items(items);
    }
    Integer maxItems=getInteger(""String_Node_Str"",node,false,location,result);
    am.setMaxItems(maxItems);
    Integer minItems=getInteger(""String_Node_Str"",node,false,location,result);
    am.setMinItems(minItems);
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        am.setVendorExtension(key,extension(node.get(key)));
      }
    }
    model=am;
  }
 else {
    ModelImpl impl=new ModelImpl();
    impl.setType(type);
    JsonNode ap=node.get(""String_Node_Str"");
    if (ap != null && ap.getNodeType().equals(JsonNodeType.OBJECT)) {
      impl.setAdditionalProperties(Json.mapper().convertValue(ap,Property.class));
    }
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDefaultValue(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setFormat(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDiscriminator(value);
    Boolean bp=getBoolean(""String_Node_Str"",node,false,location,result);
    if (bp != null) {
      impl.setUniqueItems(bp);
    }
    bp=getBoolean(""String_Node_Str"",node,false,location,result);
    if (bp != null) {
      impl.setExclusiveMaximum(bp);
    }
    bp=getBoolean(""String_Node_Str"",node,false,location,result);
    if (bp != null) {
      impl.setExclusiveMinimum(bp);
    }
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setPattern(value);
    BigDecimal maximum=getBigDecimal(""String_Node_Str"",node,false,location,result);
    if (maximum != null) {
      impl.maximum(maximum);
    }
    BigDecimal minimum=getBigDecimal(""String_Node_Str"",node,false,location,result);
    if (minimum != null) {
      impl.minimum(minimum);
    }
    Integer minLength=getInteger(""String_Node_Str"",node,false,location,result);
    if (minLength != null) {
      impl.setMinLength(minLength);
    }
    Integer maxLength=getInteger(""String_Node_Str"",node,false,location,result);
    if (maxLength != null) {
      impl.setMaxLength(maxLength);
    }
    BigDecimal multipleOf=getBigDecimal(""String_Node_Str"",node,false,location,result);
    if (multipleOf != null) {
      impl.setMultipleOf(multipleOf);
    }
    ap=node.get(""String_Node_Str"");
    if (ap != null) {
      ArrayNode arrayNode=getArray(""String_Node_Str"",node,false,location,result);
      if (arrayNode != null) {
        for (        JsonNode n : arrayNode) {
          if (n.isValueNode()) {
            impl._enum(n.asText());
          }
 else {
            result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
          }
        }
      }
    }
    JsonNode xml=node.get(""String_Node_Str"");
    if (xml != null) {
      impl.setXml(Json.mapper().convertValue(xml,Xml.class));
    }
    ObjectNode externalDocs=getObject(""String_Node_Str"",node,false,location,result);
    ExternalDocs docs=externalDocs(externalDocs,location,result);
    impl.setExternalDocs(docs);
    ObjectNode properties=getObject(""String_Node_Str"",node,false,location,result);
    if (properties != null) {
      Set<String> propertyNames=getKeys(properties);
      for (      String propertyName : propertyNames) {
        JsonNode propertyNode=properties.get(propertyName);
        if (propertyNode.getNodeType().equals(JsonNodeType.OBJECT)) {
          ObjectNode on=(ObjectNode)propertyNode;
          Property property=property(on,location,result);
          impl.property(propertyName,property);
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",propertyNode);
        }
      }
    }
    ArrayNode required=getArray(""String_Node_Str"",node,false,location,result);
    if (required != null) {
      List<String> requiredProperties=new ArrayList<String>();
      for (      JsonNode n : required) {
        if (n.getNodeType().equals(JsonNodeType.STRING)) {
          requiredProperties.add(((TextNode)n).textValue());
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
        }
      }
      if (requiredProperties.size() > 0) {
        impl.setRequired(requiredProperties);
      }
    }
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        impl.setVendorExtension(key,extension(node.get(key)));
      }
 else       if (!SCHEMA_KEYS.contains(key)) {
        result.extra(location,key,node.get(key));
      }
    }
    model=impl;
  }
  JsonNode exampleNode=node.get(""String_Node_Str"");
  if (exampleNode != null) {
    Object example=Json.mapper().convertValue(exampleNode,Object.class);
    model.setExample(example);
  }
  if (model != null) {
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setDescription(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setTitle(value);
  }
  return model;
}",0.896891866741113
29647,"public List<Parameter> processParameters(List<Parameter> parameters){
  if (parameters == null) {
    return null;
  }
  final List<Parameter> processedPathLevelParameters=new ArrayList<>();
  final List<Parameter> refParameters=new ArrayList<>();
  for (  Parameter parameter : parameters) {
    if (parameter instanceof RefParameter) {
      RefParameter refParameter=(RefParameter)parameter;
      final Parameter resolvedParameter=cache.loadRef(refParameter.get$ref(),refParameter.getRefFormat(),Parameter.class);
      if (resolvedParameter == null) {
        processedPathLevelParameters.add(refParameter);
        continue;
      }
      boolean matched=false;
      for (      Parameter param : processedPathLevelParameters) {
        if (param.getName().equals(resolvedParameter.getName())) {
          matched=true;
          break;
        }
      }
      for (      Parameter param : parameters) {
        if (param.getName() != null) {
          if (param.getName().equals(resolvedParameter.getName())) {
            matched=true;
            break;
          }
        }
      }
      if (resolvedParameter instanceof BodyParameter) {
        BodyParameter bodyParameter=(BodyParameter)resolvedParameter;
        final Model schema=bodyParameter.getSchema();
        modelProcessor.processModel(schema);
      }
      if (matched) {
        refParameters.add(resolvedParameter);
      }
 else {
        processedPathLevelParameters.add(resolvedParameter);
      }
    }
 else {
      if (parameter instanceof BodyParameter) {
        BodyParameter bodyParameter=(BodyParameter)parameter;
        final Model schema=bodyParameter.getSchema();
        modelProcessor.processModel(schema);
      }
      processedPathLevelParameters.add(parameter);
    }
  }
  for (  Parameter resolvedParameter : refParameters) {
    int pos=0;
    for (    Parameter param : processedPathLevelParameters) {
      if (param.getName().equals(resolvedParameter.getName())) {
        processedPathLevelParameters.set(pos,resolvedParameter);
        break;
      }
      pos++;
    }
  }
  return processedPathLevelParameters;
}","public List<Parameter> processParameters(List<Parameter> parameters){
  if (parameters == null) {
    return null;
  }
  final List<Parameter> processedPathLevelParameters=new ArrayList<>();
  final List<Parameter> refParameters=new ArrayList<>();
  for (  Parameter parameter : parameters) {
    if (parameter instanceof RefParameter) {
      RefParameter refParameter=(RefParameter)parameter;
      final Parameter resolvedParameter=cache.loadRef(refParameter.get$ref(),refParameter.getRefFormat(),Parameter.class);
      if (resolvedParameter == null) {
        processedPathLevelParameters.add(refParameter);
        continue;
      }
      boolean matched=false;
      for (      Parameter param : processedPathLevelParameters) {
        if (param.getName() != null) {
          if (param.getName().equals(resolvedParameter.getName())) {
            matched=true;
            break;
          }
        }
      }
      for (      Parameter param : parameters) {
        if (param.getName() != null) {
          if (param.getName().equals(resolvedParameter.getName())) {
            matched=true;
            break;
          }
        }
      }
      if (resolvedParameter instanceof BodyParameter) {
        BodyParameter bodyParameter=(BodyParameter)resolvedParameter;
        final Model schema=bodyParameter.getSchema();
        modelProcessor.processModel(schema);
      }
      if (matched) {
        refParameters.add(resolvedParameter);
      }
 else {
        processedPathLevelParameters.add(resolvedParameter);
      }
    }
 else {
      if (parameter instanceof BodyParameter) {
        BodyParameter bodyParameter=(BodyParameter)parameter;
        final Model schema=bodyParameter.getSchema();
        modelProcessor.processModel(schema);
      }
      processedPathLevelParameters.add(parameter);
    }
  }
  for (  Parameter resolvedParameter : refParameters) {
    int pos=0;
    for (    Parameter param : processedPathLevelParameters) {
      if (param.getName().equals(resolvedParameter.getName())) {
        processedPathLevelParameters.set(pos,resolvedParameter);
        break;
      }
      pos++;
    }
  }
  return processedPathLevelParameters;
}",0.9867349313474516
29648,"public String processRefToExternalDefinition(String $ref,RefFormat refFormat){
  String renamedRef=cache.getRenamedRef($ref);
  if (renamedRef != null) {
    return renamedRef;
  }
  final Model model=cache.loadRef($ref,refFormat,Model.class);
  if (model == null) {
    LOGGER.warn(""String_Node_Str"" + $ref + ""String_Node_Str""+ ""String_Node_Str"");
    return $ref;
  }
  String newRef;
  Map<String,Model> definitions=swagger.getDefinitions();
  if (definitions == null) {
    definitions=new LinkedHashMap<>();
  }
  final String possiblyConflictingDefinitionName=computeDefinitionName($ref,definitions.keySet());
  Model existingModel=definitions.get(possiblyConflictingDefinitionName);
  if (existingModel != null) {
    LOGGER.debug(""String_Node_Str"" + existingModel + ""String_Node_Str"");
    if (existingModel instanceof RefModel) {
      existingModel=null;
    }
  }
  newRef=possiblyConflictingDefinitionName;
  cache.putRenamedRef($ref,newRef);
  if (existingModel == null) {
    swagger.addDefinition(newRef,model);
    cache.addReferencedKey(newRef);
    String file=$ref.split(""String_Node_Str"")[0];
    if (model instanceof RefModel) {
      RefModel refModel=(RefModel)model;
      if (isAnExternalRefFormat(refModel.getRefFormat())) {
        refModel.set$ref(processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat()));
      }
 else {
        processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
      }
    }
    if (model instanceof ComposedModel) {
      ComposedModel composedModel=(ComposedModel)model;
      List<Model> listOfAllOF=composedModel.getAllOf();
      for (      Model allOfModel : listOfAllOF) {
        if (allOfModel instanceof RefModel) {
          RefModel refModel=(RefModel)allOfModel;
          if (isAnExternalRefFormat(refModel.getRefFormat())) {
            String joinedRef=join(file,refModel.get$ref());
            refModel.set$ref(processRefToExternalDefinition(joinedRef,refModel.getRefFormat()));
          }
 else {
            processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
          }
        }
 else         if (allOfModel instanceof ModelImpl) {
          processProperties(allOfModel.getProperties(),file);
        }
      }
    }
    processProperties(model.getProperties(),file);
    if (model instanceof ModelImpl) {
      ModelImpl modelImpl=(ModelImpl)model;
      Property additionalProperties=modelImpl.getAdditionalProperties();
      if (additionalProperties != null) {
        if (additionalProperties instanceof RefProperty) {
          processRefProperty(((RefProperty)additionalProperties),file);
        }
 else         if (additionalProperties instanceof ArrayProperty) {
          ArrayProperty arrayProp=(ArrayProperty)additionalProperties;
          if (arrayProp.getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)arrayProp.getItems(),file);
          }
        }
 else         if (additionalProperties instanceof MapProperty) {
          MapProperty mapProp=(MapProperty)additionalProperties;
          if (mapProp.getAdditionalProperties() instanceof RefProperty) {
            processRefProperty((RefProperty)mapProp.getAdditionalProperties(),file);
          }
 else           if (mapProp.getAdditionalProperties() instanceof ArrayProperty && ((ArrayProperty)mapProp.getAdditionalProperties()).getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)((ArrayProperty)mapProp.getAdditionalProperties()).getItems(),file);
          }
        }
      }
    }
    if (model instanceof ArrayModel && ((ArrayModel)model).getItems() instanceof RefProperty) {
      processRefProperty((RefProperty)((ArrayModel)model).getItems(),file);
    }
  }
  return newRef;
}","public String processRefToExternalDefinition(String $ref,RefFormat refFormat){
  String renamedRef=cache.getRenamedRef($ref);
  if (renamedRef != null) {
    return renamedRef;
  }
  final Model model=cache.loadRef($ref,refFormat,Model.class);
  if (model == null) {
    LOGGER.warn(""String_Node_Str"" + $ref + ""String_Node_Str""+ ""String_Node_Str"");
    return $ref;
  }
  String newRef;
  Map<String,Model> definitions=swagger.getDefinitions();
  if (definitions == null) {
    definitions=new LinkedHashMap<>();
  }
  final String possiblyConflictingDefinitionName=computeDefinitionName($ref);
  String tryName=null;
  Model existingModel=definitions.get(possiblyConflictingDefinitionName);
  if (existingModel != null) {
    LOGGER.debug(""String_Node_Str"" + existingModel + ""String_Node_Str"");
    if (existingModel instanceof RefModel) {
      existingModel=null;
    }
 else {
      int i=2;
      for (      String name : definitions.keySet()) {
        if (name.equals(possiblyConflictingDefinitionName)) {
          tryName=possiblyConflictingDefinitionName + ""String_Node_Str"" + i;
          existingModel=definitions.get(tryName);
          i++;
        }
      }
    }
  }
  if (StringUtils.isNotBlank(tryName)) {
    newRef=tryName;
  }
 else {
    newRef=possiblyConflictingDefinitionName;
  }
  cache.putRenamedRef($ref,newRef);
  if (existingModel == null) {
    swagger.addDefinition(newRef,model);
    cache.addReferencedKey(newRef);
    String file=$ref.split(""String_Node_Str"")[0];
    if (model instanceof RefModel) {
      RefModel refModel=(RefModel)model;
      if (isAnExternalRefFormat(refModel.getRefFormat())) {
        refModel.set$ref(processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat()));
      }
 else {
        processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
      }
    }
    if (model instanceof ComposedModel) {
      ComposedModel composedModel=(ComposedModel)model;
      List<Model> listOfAllOF=composedModel.getAllOf();
      for (      Model allOfModel : listOfAllOF) {
        if (allOfModel instanceof RefModel) {
          RefModel refModel=(RefModel)allOfModel;
          if (isAnExternalRefFormat(refModel.getRefFormat())) {
            String joinedRef=join(file,refModel.get$ref());
            refModel.set$ref(processRefToExternalDefinition(joinedRef,refModel.getRefFormat()));
          }
 else {
            processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
          }
        }
 else         if (allOfModel instanceof ModelImpl) {
          processProperties(allOfModel.getProperties(),file);
        }
      }
    }
    processProperties(model.getProperties(),file);
    if (model instanceof ModelImpl) {
      ModelImpl modelImpl=(ModelImpl)model;
      Property additionalProperties=modelImpl.getAdditionalProperties();
      if (additionalProperties != null) {
        if (additionalProperties instanceof RefProperty) {
          processRefProperty(((RefProperty)additionalProperties),file);
        }
 else         if (additionalProperties instanceof ArrayProperty) {
          ArrayProperty arrayProp=(ArrayProperty)additionalProperties;
          if (arrayProp.getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)arrayProp.getItems(),file);
          }
        }
 else         if (additionalProperties instanceof MapProperty) {
          MapProperty mapProp=(MapProperty)additionalProperties;
          if (mapProp.getAdditionalProperties() instanceof RefProperty) {
            processRefProperty((RefProperty)mapProp.getAdditionalProperties(),file);
          }
 else           if (mapProp.getAdditionalProperties() instanceof ArrayProperty && ((ArrayProperty)mapProp.getAdditionalProperties()).getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)((ArrayProperty)mapProp.getAdditionalProperties()).getItems(),file);
          }
        }
      }
    }
    if (model instanceof ArrayModel && ((ArrayModel)model).getItems() instanceof RefProperty) {
      processRefProperty((RefProperty)((ArrayModel)model).getItems(),file);
    }
  }
  return newRef;
}",0.9457991156032848
29649,"public static String computeDefinitionName(String ref,Set<String> reserved){
  final String[] refParts=ref.split(""String_Node_Str"");
  if (refParts.length > 2) {
    throw new RuntimeException(""String_Node_Str"" + ref);
  }
  final String file=refParts[0];
  final String definitionPath=refParts.length == 2 ? refParts[1] : null;
  String plausibleName;
  if (definitionPath != null) {
    final String[] jsonPathElements=definitionPath.split(""String_Node_Str"");
    plausibleName=jsonPathElements[jsonPathElements.length - 1];
  }
 else {
    final String[] filePathElements=file.split(""String_Node_Str"");
    plausibleName=filePathElements[filePathElements.length - 1];
    final String[] split=plausibleName.split(""String_Node_Str"");
    plausibleName=split[0];
  }
  String tryName=plausibleName;
  for (int i=2; reserved.contains(tryName); i++) {
    tryName=plausibleName + ""String_Node_Str"" + i;
  }
  return tryName;
}","public static String computeDefinitionName(String ref){
  final String[] refParts=ref.split(""String_Node_Str"");
  if (refParts.length > 2) {
    throw new RuntimeException(""String_Node_Str"" + ref);
  }
  final String file=refParts[0];
  final String definitionPath=refParts.length == 2 ? refParts[1] : null;
  String plausibleName;
  if (definitionPath != null) {
    final String[] jsonPathElements=definitionPath.split(""String_Node_Str"");
    plausibleName=jsonPathElements[jsonPathElements.length - 1];
  }
 else {
    final String[] filePathElements=file.split(""String_Node_Str"");
    plausibleName=filePathElements[filePathElements.length - 1];
    final String[] split=plausibleName.split(""String_Node_Str"");
    plausibleName=split[0];
  }
  return plausibleName;
}",0.901591043017089
29650,"@Test public void testRefNameConflicts() throws Exception {
  Swagger swagger=new SwaggerParser().read(""String_Node_Str"");
  assertEquals(""String_Node_Str"",((RefProperty)swagger.getPath(""String_Node_Str"").getPost().getResponses().get(""String_Node_Str"").getSchema()).get$ref());
  assertEquals(""String_Node_Str"",((RefProperty)swagger.getPath(""String_Node_Str"").getPost().getResponses().get(""String_Node_Str"").getSchema()).get$ref());
  assertEquals(""String_Node_Str"",((RefProperty)swagger.getPath(""String_Node_Str"").getPost().getResponses().get(""String_Node_Str"").getSchema()).get$ref());
  assertEquals(""String_Node_Str"",swagger.getDefinitions().get(""String_Node_Str"").getProperties().get(""String_Node_Str"").getExample());
  assertEquals(""String_Node_Str"",swagger.getDefinitions().get(""String_Node_Str"").getProperties().get(""String_Node_Str"").getExample());
}","@Test public void testRefNameConflicts() throws Exception {
  Swagger swagger=new SwaggerParser().read(""String_Node_Str"");
  Yaml.prettyPrint(swagger);
  assertTrue(swagger.getDefinitions().size() == 2);
  assertEquals(""String_Node_Str"",((RefProperty)swagger.getPath(""String_Node_Str"").getPost().getResponses().get(""String_Node_Str"").getSchema()).get$ref());
  assertEquals(""String_Node_Str"",((RefProperty)swagger.getPath(""String_Node_Str"").getPost().getResponses().get(""String_Node_Str"").getSchema()).get$ref());
  assertEquals(""String_Node_Str"",((RefProperty)swagger.getPath(""String_Node_Str"").getPost().getResponses().get(""String_Node_Str"").getSchema()).get$ref());
  assertEquals(""String_Node_Str"",swagger.getDefinitions().get(""String_Node_Str"").getProperties().get(""String_Node_Str"").getExample());
  assertEquals(""String_Node_Str"",swagger.getDefinitions().get(""String_Node_Str"").getProperties().get(""String_Node_Str"").getExample());
}",0.9549749861033908
29651,"@Test public void testRefEnum() throws Exception {
  Swagger swagger=new SwaggerParser().read(""String_Node_Str"");
  Assert.assertNotNull(swagger);
  Assert.assertTrue(swagger.getDefinitions().size() == 5);
  Yaml.prettyPrint(swagger);
  Assert.assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
  Assert.assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
  Assert.assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
}","@Test public void testRefEnum() throws Exception {
  Swagger swagger=new SwaggerParser().read(""String_Node_Str"");
  Assert.assertNotNull(swagger);
  Assert.assertTrue(swagger.getDefinitions().size() == 5);
  Assert.assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
  Assert.assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
  Assert.assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
}",0.9670828603859252
29652,"@Test public void testComputeDefinitionName() throws Exception {
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",RefUtils.computeDefinitionName(""String_Node_Str"",singleton(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",RefUtils.computeDefinitionName(""String_Node_Str"",new HashSet<>(asList(""String_Node_Str"",""String_Node_Str""))));
}","@Test public void testComputeDefinitionName() throws Exception {
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
}",0.9329173166926678
29653,"private void doComputeDefinitionNameTestCase(String ref,String expectedDefinitionName){
  assertEquals(expectedDefinitionName,RefUtils.computeDefinitionName(ref,Collections.<String>emptySet()));
}","private void doComputeDefinitionNameTestCase(String ref,String expectedDefinitionName){
  assertEquals(expectedDefinitionName,RefUtils.computeDefinitionName(ref));
}",0.9141274238227148
29654,"public String processRefToExternalDefinition(String $ref,RefFormat refFormat){
  String renamedRef=cache.getRenamedRef($ref);
  if (renamedRef != null) {
    return renamedRef;
  }
  final Model model=cache.loadRef($ref,refFormat,Model.class);
  if (model == null) {
    LOGGER.warn(""String_Node_Str"" + $ref + ""String_Node_Str""+ ""String_Node_Str"");
    return $ref;
  }
  String newRef;
  Map<String,Model> definitions=swagger.getDefinitions();
  if (definitions == null) {
    definitions=new LinkedHashMap<>();
  }
  final String possiblyConflictingDefinitionName=computeDefinitionName($ref,definitions.keySet());
  Model existingModel=definitions.get(possiblyConflictingDefinitionName);
  if (existingModel != null) {
    LOGGER.debug(""String_Node_Str"" + existingModel + ""String_Node_Str"");
    if (existingModel instanceof RefModel) {
      existingModel=null;
    }
  }
  newRef=possiblyConflictingDefinitionName;
  cache.putRenamedRef($ref,newRef);
  if (existingModel == null) {
    swagger.addDefinition(newRef,model);
    cache.addReferencedKey(newRef);
    String file=$ref.split(""String_Node_Str"")[0];
    if (model instanceof RefModel) {
      RefModel refModel=(RefModel)model;
      if (isAnExternalRefFormat(refModel.getRefFormat())) {
        refModel.set$ref(processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat()));
      }
 else {
        processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
      }
    }
    if (model instanceof ComposedModel) {
      ComposedModel composedModel=(ComposedModel)model;
      List<Model> listOfAllOF=composedModel.getAllOf();
      for (      Model allOfModel : listOfAllOF) {
        if (allOfModel instanceof RefModel) {
          RefModel refModel=(RefModel)allOfModel;
          if (isAnExternalRefFormat(refModel.getRefFormat())) {
            String joinedRef=join(file,refModel.get$ref());
            refModel.set$ref(processRefToExternalDefinition(joinedRef,refModel.getRefFormat()));
          }
 else {
            processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
          }
        }
 else         if (allOfModel instanceof ModelImpl) {
          processProperties(allOfModel.getProperties(),file);
        }
      }
    }
    processProperties(model.getProperties(),file);
    if (model instanceof ModelImpl) {
      ModelImpl modelImpl=(ModelImpl)model;
      Property additionalProperties=modelImpl.getAdditionalProperties();
      if (additionalProperties != null) {
        if (additionalProperties instanceof RefProperty) {
          processRefProperty(((RefProperty)additionalProperties),file);
        }
 else         if (additionalProperties instanceof ArrayProperty) {
          ArrayProperty arrayProp=(ArrayProperty)additionalProperties;
          if (arrayProp.getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)arrayProp.getItems(),file);
          }
        }
 else         if (additionalProperties instanceof MapProperty) {
          MapProperty mapProp=(MapProperty)additionalProperties;
          if (mapProp.getAdditionalProperties() instanceof RefProperty) {
            processRefProperty((RefProperty)mapProp.getAdditionalProperties(),file);
          }
 else           if (mapProp.getAdditionalProperties() instanceof ArrayProperty && ((ArrayProperty)mapProp.getAdditionalProperties()).getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)((ArrayProperty)mapProp.getAdditionalProperties()).getItems(),file);
          }
        }
      }
    }
    if (model instanceof ArrayModel && ((ArrayModel)model).getItems() instanceof RefProperty) {
      processRefProperty((RefProperty)((ArrayModel)model).getItems(),file);
    }
  }
  return newRef;
}","public String processRefToExternalDefinition(String $ref,RefFormat refFormat){
  String renamedRef=cache.getRenamedRef($ref);
  if (renamedRef != null) {
    return renamedRef;
  }
  final Model model=cache.loadRef($ref,refFormat,Model.class);
  if (model == null) {
    LOGGER.warn(""String_Node_Str"" + $ref + ""String_Node_Str""+ ""String_Node_Str"");
    return $ref;
  }
  String newRef;
  Map<String,Model> definitions=swagger.getDefinitions();
  if (definitions == null) {
    definitions=new LinkedHashMap<>();
  }
  final String possiblyConflictingDefinitionName=computeDefinitionName($ref);
  String tryName=null;
  Model existingModel=definitions.get(possiblyConflictingDefinitionName);
  if (existingModel != null) {
    LOGGER.debug(""String_Node_Str"" + existingModel + ""String_Node_Str"");
    if (existingModel instanceof RefModel) {
      existingModel=null;
    }
 else {
      int i=2;
      for (      String name : definitions.keySet()) {
        if (name.equals(possiblyConflictingDefinitionName)) {
          tryName=possiblyConflictingDefinitionName + ""String_Node_Str"" + i;
          existingModel=definitions.get(tryName);
          i++;
        }
      }
    }
  }
  if (StringUtils.isNotBlank(tryName)) {
    newRef=tryName;
  }
 else {
    newRef=possiblyConflictingDefinitionName;
  }
  cache.putRenamedRef($ref,newRef);
  if (existingModel == null) {
    swagger.addDefinition(newRef,model);
    cache.addReferencedKey(newRef);
    String file=$ref.split(""String_Node_Str"")[0];
    if (model instanceof RefModel) {
      RefModel refModel=(RefModel)model;
      if (isAnExternalRefFormat(refModel.getRefFormat())) {
        refModel.set$ref(processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat()));
      }
 else {
        processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
      }
    }
    if (model instanceof ComposedModel) {
      ComposedModel composedModel=(ComposedModel)model;
      List<Model> listOfAllOF=composedModel.getAllOf();
      for (      Model allOfModel : listOfAllOF) {
        if (allOfModel instanceof RefModel) {
          RefModel refModel=(RefModel)allOfModel;
          if (isAnExternalRefFormat(refModel.getRefFormat())) {
            String joinedRef=join(file,refModel.get$ref());
            refModel.set$ref(processRefToExternalDefinition(joinedRef,refModel.getRefFormat()));
          }
 else {
            processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
          }
        }
 else         if (allOfModel instanceof ModelImpl) {
          processProperties(allOfModel.getProperties(),file);
        }
      }
    }
    processProperties(model.getProperties(),file);
    if (model instanceof ModelImpl) {
      ModelImpl modelImpl=(ModelImpl)model;
      Property additionalProperties=modelImpl.getAdditionalProperties();
      if (additionalProperties != null) {
        if (additionalProperties instanceof RefProperty) {
          processRefProperty(((RefProperty)additionalProperties),file);
        }
 else         if (additionalProperties instanceof ArrayProperty) {
          ArrayProperty arrayProp=(ArrayProperty)additionalProperties;
          if (arrayProp.getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)arrayProp.getItems(),file);
          }
        }
 else         if (additionalProperties instanceof MapProperty) {
          MapProperty mapProp=(MapProperty)additionalProperties;
          if (mapProp.getAdditionalProperties() instanceof RefProperty) {
            processRefProperty((RefProperty)mapProp.getAdditionalProperties(),file);
          }
 else           if (mapProp.getAdditionalProperties() instanceof ArrayProperty && ((ArrayProperty)mapProp.getAdditionalProperties()).getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)((ArrayProperty)mapProp.getAdditionalProperties()).getItems(),file);
          }
        }
      }
    }
    if (model instanceof ArrayModel && ((ArrayModel)model).getItems() instanceof RefProperty) {
      processRefProperty((RefProperty)((ArrayModel)model).getItems(),file);
    }
  }
  return newRef;
}",0.9457991156032848
29655,"public static String computeDefinitionName(String ref,Set<String> reserved){
  final String[] refParts=ref.split(""String_Node_Str"");
  if (refParts.length > 2) {
    throw new RuntimeException(""String_Node_Str"" + ref);
  }
  final String file=refParts[0];
  final String definitionPath=refParts.length == 2 ? refParts[1] : null;
  String plausibleName;
  if (definitionPath != null) {
    final String[] jsonPathElements=definitionPath.split(""String_Node_Str"");
    plausibleName=jsonPathElements[jsonPathElements.length - 1];
  }
 else {
    final String[] filePathElements=file.split(""String_Node_Str"");
    plausibleName=filePathElements[filePathElements.length - 1];
    final String[] split=plausibleName.split(""String_Node_Str"");
    plausibleName=split[0];
  }
  String tryName=plausibleName;
  for (int i=2; reserved.contains(tryName); i++) {
    tryName=plausibleName + ""String_Node_Str"" + i;
  }
  return tryName;
}","public static String computeDefinitionName(String ref){
  final String[] refParts=ref.split(""String_Node_Str"");
  if (refParts.length > 2) {
    throw new RuntimeException(""String_Node_Str"" + ref);
  }
  final String file=refParts[0];
  final String definitionPath=refParts.length == 2 ? refParts[1] : null;
  String plausibleName;
  if (definitionPath != null) {
    final String[] jsonPathElements=definitionPath.split(""String_Node_Str"");
    plausibleName=jsonPathElements[jsonPathElements.length - 1];
  }
 else {
    final String[] filePathElements=file.split(""String_Node_Str"");
    plausibleName=filePathElements[filePathElements.length - 1];
    final String[] split=plausibleName.split(""String_Node_Str"");
    plausibleName=split[0];
  }
  return plausibleName;
}",0.901591043017089
29656,"@Test public void testRefNameConflicts() throws Exception {
  Swagger swagger=new SwaggerParser().read(""String_Node_Str"");
  assertEquals(""String_Node_Str"",((RefProperty)swagger.getPath(""String_Node_Str"").getPost().getResponses().get(""String_Node_Str"").getSchema()).get$ref());
  assertEquals(""String_Node_Str"",((RefProperty)swagger.getPath(""String_Node_Str"").getPost().getResponses().get(""String_Node_Str"").getSchema()).get$ref());
  assertEquals(""String_Node_Str"",((RefProperty)swagger.getPath(""String_Node_Str"").getPost().getResponses().get(""String_Node_Str"").getSchema()).get$ref());
  assertEquals(""String_Node_Str"",swagger.getDefinitions().get(""String_Node_Str"").getProperties().get(""String_Node_Str"").getExample());
  assertEquals(""String_Node_Str"",swagger.getDefinitions().get(""String_Node_Str"").getProperties().get(""String_Node_Str"").getExample());
}","@Test public void testRefNameConflicts() throws Exception {
  Swagger swagger=new SwaggerParser().read(""String_Node_Str"");
  Yaml.prettyPrint(swagger);
  assertTrue(swagger.getDefinitions().size() == 2);
  assertEquals(""String_Node_Str"",((RefProperty)swagger.getPath(""String_Node_Str"").getPost().getResponses().get(""String_Node_Str"").getSchema()).get$ref());
  assertEquals(""String_Node_Str"",((RefProperty)swagger.getPath(""String_Node_Str"").getPost().getResponses().get(""String_Node_Str"").getSchema()).get$ref());
  assertEquals(""String_Node_Str"",((RefProperty)swagger.getPath(""String_Node_Str"").getPost().getResponses().get(""String_Node_Str"").getSchema()).get$ref());
  assertEquals(""String_Node_Str"",swagger.getDefinitions().get(""String_Node_Str"").getProperties().get(""String_Node_Str"").getExample());
  assertEquals(""String_Node_Str"",swagger.getDefinitions().get(""String_Node_Str"").getProperties().get(""String_Node_Str"").getExample());
}",0.9549749861033908
29657,"@Test public void testRefEnum() throws Exception {
  Swagger swagger=new SwaggerParser().read(""String_Node_Str"");
  Assert.assertNotNull(swagger);
  Assert.assertTrue(swagger.getDefinitions().size() == 5);
  Yaml.prettyPrint(swagger);
  Assert.assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
  Assert.assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
  Assert.assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
}","@Test public void testRefEnum() throws Exception {
  Swagger swagger=new SwaggerParser().read(""String_Node_Str"");
  Assert.assertNotNull(swagger);
  Assert.assertTrue(swagger.getDefinitions().size() == 5);
  Assert.assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
  Assert.assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
  Assert.assertNotNull(swagger.getDefinitions().get(""String_Node_Str""));
}",0.9670828603859252
29658,"@Test public void testComputeDefinitionName() throws Exception {
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",RefUtils.computeDefinitionName(""String_Node_Str"",singleton(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",RefUtils.computeDefinitionName(""String_Node_Str"",new HashSet<>(asList(""String_Node_Str"",""String_Node_Str""))));
}","@Test public void testComputeDefinitionName() throws Exception {
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
  doComputeDefinitionNameTestCase(""String_Node_Str"",""String_Node_Str"");
}",0.9329173166926678
29659,"private void doComputeDefinitionNameTestCase(String ref,String expectedDefinitionName){
  assertEquals(expectedDefinitionName,RefUtils.computeDefinitionName(ref,Collections.<String>emptySet()));
}","private void doComputeDefinitionNameTestCase(String ref,String expectedDefinitionName){
  assertEquals(expectedDefinitionName,RefUtils.computeDefinitionName(ref));
}",0.9141274238227148
29660,"public Model modelFromExtendedTypedObject(ExtendedTypedObject obj){
  String type=obj.getType() == null ? null : obj.getType().toString();
  String format=obj.getFormat() == null ? null : obj.getFormat().toString();
  Model output=null;
  if (obj.getRef() != null) {
    output=new RefModel().asDefault(obj.getRef());
  }
 else {
    if (""String_Node_Str"".equals(type)) {
      ArrayModel am=new ArrayModel();
      Items items=obj.getItems();
      type=items.getType() == null ? null : items.getType().toString();
      format=items.getFormat() == null ? null : items.getFormat().toString();
      Property innerType=PropertyBuilder.build(type,format,null);
      if (innerType != null) {
        am.setItems(innerType);
      }
 else       if (items.getRef() != null) {
        am.setItems(new RefProperty(items.getRef()));
      }
 else {
        am.setItems(new RefProperty(type));
      }
      output=am;
    }
 else {
      Property input=PropertyBuilder.build(type,format,null);
      if (input != null) {
        output=PropertyBuilder.toModel(input);
      }
 else       if (!""String_Node_Str"".equals(type)) {
        output=new RefModel().asDefault(type);
      }
    }
  }
  return output;
}","public Model modelFromExtendedTypedObject(ExtendedTypedObject obj){
  String type=obj.getType() == null ? null : obj.getType().toString();
  String format=obj.getFormat() == null ? null : obj.getFormat().toString();
  Model output=null;
  if (obj.getRef() != null) {
    output=new RefModel().asDefault(obj.getRef());
  }
 else {
    if (""String_Node_Str"".equals(type)) {
      ArrayModel am=new ArrayModel();
      Items items=obj.getItems();
      type=items.getType() == null ? null : items.getType().toString();
      format=items.getFormat() == null ? null : items.getFormat().toString();
      Property innerType=PropertyBuilder.build(type,format,null);
      if (innerType != null) {
        am.setItems(innerType);
      }
      if (items.getRef() != null) {
        am.setItems(new RefProperty(items.getRef()));
      }
 else {
        am.setItems(new RefProperty(type));
      }
      output=am;
    }
 else {
      Property input=PropertyBuilder.build(type,format,null);
      if (input != null) {
        output=PropertyBuilder.toModel(input);
      }
 else       if (!""String_Node_Str"".equals(type)) {
        output=new RefModel().asDefault(type);
      }
    }
  }
  return output;
}",0.9975020815986678
29661,"private void processRefProperty(RefProperty subRef,String externalFile){
  if (isAnExternalRefFormat(subRef.getRefFormat())) {
    String $ref=constructRef(subRef,externalFile);
    subRef.set$ref($ref);
    if ($ref.startsWith(""String_Node_Str""))     processRefToExternalDefinition($ref,RefFormat.RELATIVE);
 else {
      processRefToExternalDefinition($ref,RefFormat.URL);
    }
  }
 else {
    processRefToExternalDefinition(externalFile + subRef.get$ref(),RefFormat.RELATIVE);
  }
}","private void processRefProperty(RefProperty subRef,String externalFile){
  if (isAnExternalRefFormat(subRef.getRefFormat())) {
    if (subRef.get$ref().startsWith(""String_Node_Str""))     processRefToExternalDefinition(subRef.get$ref(),RefFormat.RELATIVE);
 else {
      processRefToExternalDefinition(subRef.get$ref(),RefFormat.URL);
    }
  }
 else {
    processRefToExternalDefinition(externalFile + subRef.get$ref(),RefFormat.RELATIVE);
  }
}",0.8700322234156821
29662,"@Test public void testRefNameConflicts() throws Exception {
  Swagger swagger=new SwaggerParser().read(""String_Node_Str"");
  Yaml.prettyPrint(swagger);
  assertTrue(swagger.getDefinitions().size() == 2);
  assertEquals(""String_Node_Str"",((RefProperty)swagger.getPath(""String_Node_Str"").getPost().getResponses().get(""String_Node_Str"").getSchema()).get$ref());
  assertEquals(""String_Node_Str"",((RefProperty)swagger.getPath(""String_Node_Str"").getPost().getResponses().get(""String_Node_Str"").getSchema()).get$ref());
  assertEquals(""String_Node_Str"",((RefProperty)swagger.getPath(""String_Node_Str"").getPost().getResponses().get(""String_Node_Str"").getSchema()).get$ref());
  assertEquals(""String_Node_Str"",swagger.getDefinitions().get(""String_Node_Str"").getProperties().get(""String_Node_Str"").getExample());
  assertEquals(""String_Node_Str"",swagger.getDefinitions().get(""String_Node_Str"").getProperties().get(""String_Node_Str"").getExample());
}","@Test public void testRefNameConflicts() throws Exception {
  Swagger swagger=new SwaggerParser().read(""String_Node_Str"");
  assertTrue(swagger.getDefinitions().size() == 2);
  assertEquals(""String_Node_Str"",((RefProperty)swagger.getPath(""String_Node_Str"").getPost().getResponses().get(""String_Node_Str"").getSchema()).get$ref());
  assertEquals(""String_Node_Str"",((RefProperty)swagger.getPath(""String_Node_Str"").getPost().getResponses().get(""String_Node_Str"").getSchema()).get$ref());
  assertEquals(""String_Node_Str"",((RefProperty)swagger.getPath(""String_Node_Str"").getPost().getResponses().get(""String_Node_Str"").getSchema()).get$ref());
  assertEquals(""String_Node_Str"",swagger.getDefinitions().get(""String_Node_Str"").getProperties().get(""String_Node_Str"").getExample());
  assertEquals(""String_Node_Str"",swagger.getDefinitions().get(""String_Node_Str"").getProperties().get(""String_Node_Str"").getExample());
}",0.984332793084819
29663,"public String processRefToExternalDefinition(String $ref,RefFormat refFormat){
  String renamedRef=cache.getRenamedRef($ref);
  if (renamedRef != null) {
    return renamedRef;
  }
  final Model model=cache.loadRef($ref,refFormat,Model.class);
  if (model == null) {
    LOGGER.warn(""String_Node_Str"" + $ref + ""String_Node_Str""+ ""String_Node_Str"");
    return $ref;
  }
  String newRef;
  Map<String,Model> definitions=swagger.getDefinitions();
  if (definitions == null) {
    definitions=new LinkedHashMap<>();
  }
  final String possiblyConflictingDefinitionName=computeDefinitionName($ref,definitions.keySet());
  Model existingModel=definitions.get(possiblyConflictingDefinitionName);
  if (existingModel != null) {
    LOGGER.debug(""String_Node_Str"" + existingModel + ""String_Node_Str"");
    if (existingModel instanceof RefModel) {
      existingModel=null;
    }
  }
  newRef=possiblyConflictingDefinitionName;
  cache.putRenamedRef($ref,newRef);
  if (existingModel == null) {
    swagger.addDefinition(newRef,model);
    cache.addReferencedKey(newRef);
    String file=$ref.split(""String_Node_Str"")[0];
    if (model instanceof RefModel) {
      RefModel refModel=(RefModel)model;
      if (isAnExternalRefFormat(refModel.getRefFormat())) {
        refModel.set$ref(processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat()));
      }
 else {
        processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
      }
    }
 else     if (model instanceof ComposedModel) {
      ComposedModel composedModel=(ComposedModel)model;
      List<Model> listOfAllOF=composedModel.getAllOf();
      for (      Model allOfModel : listOfAllOF) {
        if (allOfModel instanceof RefModel) {
          RefModel refModel=(RefModel)allOfModel;
          if (isAnExternalRefFormat(refModel.getRefFormat())) {
            String joinedRef=join(file,refModel.get$ref());
            refModel.set$ref(processRefToExternalDefinition(joinedRef,refModel.getRefFormat()));
          }
 else {
            processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
          }
        }
      }
    }
    Map<String,Property> subProps=model.getProperties();
    if (subProps != null) {
      for (      Map.Entry<String,Property> prop : subProps.entrySet()) {
        if (prop.getValue() instanceof RefProperty) {
          processRefProperty((RefProperty)prop.getValue(),file);
        }
 else         if (prop.getValue() instanceof ArrayProperty) {
          ArrayProperty arrayProp=(ArrayProperty)prop.getValue();
          if (arrayProp.getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)arrayProp.getItems(),file);
          }
        }
 else         if (prop.getValue() instanceof MapProperty) {
          MapProperty mapProp=(MapProperty)prop.getValue();
          if (mapProp.getAdditionalProperties() instanceof RefProperty) {
            processRefProperty((RefProperty)mapProp.getAdditionalProperties(),file);
          }
 else           if (mapProp.getAdditionalProperties() instanceof ArrayProperty && ((ArrayProperty)mapProp.getAdditionalProperties()).getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)((ArrayProperty)mapProp.getAdditionalProperties()).getItems(),file);
          }
        }
      }
    }
    if (model instanceof ModelImpl) {
      ModelImpl modelImpl=(ModelImpl)model;
      Property additionalProperties=modelImpl.getAdditionalProperties();
      if (additionalProperties != null) {
        if (additionalProperties instanceof RefProperty) {
          processRefProperty(((RefProperty)additionalProperties),file);
        }
 else         if (additionalProperties instanceof ArrayProperty) {
          ArrayProperty arrayProp=(ArrayProperty)additionalProperties;
          if (arrayProp.getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)arrayProp.getItems(),file);
          }
        }
 else         if (additionalProperties instanceof MapProperty) {
          MapProperty mapProp=(MapProperty)additionalProperties;
          if (mapProp.getAdditionalProperties() instanceof RefProperty) {
            processRefProperty((RefProperty)mapProp.getAdditionalProperties(),file);
          }
 else           if (mapProp.getAdditionalProperties() instanceof ArrayProperty && ((ArrayProperty)mapProp.getAdditionalProperties()).getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)((ArrayProperty)mapProp.getAdditionalProperties()).getItems(),file);
          }
        }
      }
    }
    if (model instanceof ArrayModel && ((ArrayModel)model).getItems() instanceof RefProperty) {
      processRefProperty((RefProperty)((ArrayModel)model).getItems(),file);
    }
  }
  return newRef;
}","public String processRefToExternalDefinition(String $ref,RefFormat refFormat){
  String renamedRef=cache.getRenamedRef($ref);
  if (renamedRef != null) {
    return renamedRef;
  }
  final Model model=cache.loadRef($ref,refFormat,Model.class);
  if (model == null) {
    LOGGER.warn(""String_Node_Str"" + $ref + ""String_Node_Str""+ ""String_Node_Str"");
    return $ref;
  }
  String newRef;
  Map<String,Model> definitions=swagger.getDefinitions();
  if (definitions == null) {
    definitions=new LinkedHashMap<>();
  }
  final String possiblyConflictingDefinitionName=computeDefinitionName($ref,definitions.keySet());
  Model existingModel=definitions.get(possiblyConflictingDefinitionName);
  if (existingModel != null) {
    LOGGER.debug(""String_Node_Str"" + existingModel + ""String_Node_Str"");
    if (existingModel instanceof RefModel) {
      existingModel=null;
    }
  }
  newRef=possiblyConflictingDefinitionName;
  cache.putRenamedRef($ref,newRef);
  if (existingModel == null) {
    swagger.addDefinition(newRef,model);
    cache.addReferencedKey(newRef);
    String file=$ref.split(""String_Node_Str"")[0];
    if (model instanceof RefModel) {
      RefModel refModel=(RefModel)model;
      if (isAnExternalRefFormat(refModel.getRefFormat())) {
        refModel.set$ref(processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat()));
      }
 else {
        processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
      }
    }
 else     if (model instanceof ComposedModel) {
      ComposedModel composedModel=(ComposedModel)model;
      List<Model> listOfAllOF=composedModel.getAllOf();
      for (      Model allOfModel : listOfAllOF) {
        if (allOfModel instanceof RefModel) {
          RefModel refModel=(RefModel)allOfModel;
          if (isAnExternalRefFormat(refModel.getRefFormat())) {
            String joinedRef=join(file,refModel.get$ref());
            refModel.set$ref(processRefToExternalDefinition(joinedRef,refModel.getRefFormat()));
          }
 else {
            processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
          }
        }
 else         if (allOfModel instanceof ModelImpl) {
          processProperties(allOfModel.getProperties(),file);
        }
      }
    }
    processProperties(model.getProperties(),file);
    if (model instanceof ModelImpl) {
      ModelImpl modelImpl=(ModelImpl)model;
      Property additionalProperties=modelImpl.getAdditionalProperties();
      if (additionalProperties != null) {
        if (additionalProperties instanceof RefProperty) {
          processRefProperty(((RefProperty)additionalProperties),file);
        }
 else         if (additionalProperties instanceof ArrayProperty) {
          ArrayProperty arrayProp=(ArrayProperty)additionalProperties;
          if (arrayProp.getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)arrayProp.getItems(),file);
          }
        }
 else         if (additionalProperties instanceof MapProperty) {
          MapProperty mapProp=(MapProperty)additionalProperties;
          if (mapProp.getAdditionalProperties() instanceof RefProperty) {
            processRefProperty((RefProperty)mapProp.getAdditionalProperties(),file);
          }
 else           if (mapProp.getAdditionalProperties() instanceof ArrayProperty && ((ArrayProperty)mapProp.getAdditionalProperties()).getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)((ArrayProperty)mapProp.getAdditionalProperties()).getItems(),file);
          }
        }
      }
    }
    if (model instanceof ArrayModel && ((ArrayModel)model).getItems() instanceof RefProperty) {
      processRefProperty((RefProperty)((ArrayModel)model).getItems(),file);
    }
  }
  return newRef;
}",0.6642480983031013
29664,"public static String readExternalUrlRef(String file,RefFormat refFormat,List<AuthorizationValue> auths,String rootPath){
  if (!RefUtils.isAnExternalRefFormat(refFormat)) {
    throw new RuntimeException(""String_Node_Str"");
  }
  String result;
  try {
    if (refFormat == RefFormat.URL) {
      result=RemoteUrl.urlToString(file,auths);
    }
 else {
      String url=buildUrl(rootPath,file);
      return readExternalRef(url,RefFormat.URL,auths,null);
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + refFormat + ""String_Node_Str""+ file,e);
  }
  return result;
}","public static String readExternalUrlRef(String file,RefFormat refFormat,List<AuthorizationValue> auths,String rootPath){
  if (!RefUtils.isAnExternalRefFormat(refFormat)) {
    throw new RuntimeException(""String_Node_Str"");
  }
  String result;
  try {
    if (refFormat == RefFormat.URL) {
      result=RemoteUrl.urlToString(file,auths);
    }
 else {
      String url=buildUrl(rootPath,file);
      return readExternalRef(url,RefFormat.URL,auths,null);
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + refFormat + ""String_Node_Str""+ file+ ""String_Node_Str""+ rootPath,e);
  }
  return result;
}",0.9765182186234818
29665,"public static String readExternalRef(String file,RefFormat refFormat,List<AuthorizationValue> auths,Path parentDirectory){
  if (!RefUtils.isAnExternalRefFormat(refFormat)) {
    throw new RuntimeException(""String_Node_Str"");
  }
  String result;
  try {
    if (refFormat == RefFormat.URL) {
      result=RemoteUrl.urlToString(file,auths);
    }
 else {
      final Path pathToUse=parentDirectory.resolve(file).normalize();
      if (Files.exists(pathToUse)) {
        result=IOUtils.toString(new FileInputStream(pathToUse.toFile()),""String_Node_Str"");
      }
 else {
        result=ClasspathHelper.loadFileFromClasspath(file);
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + refFormat + ""String_Node_Str""+ file,e);
  }
  return result;
}","public static String readExternalRef(String file,RefFormat refFormat,List<AuthorizationValue> auths,Path parentDirectory){
  if (!RefUtils.isAnExternalRefFormat(refFormat)) {
    throw new RuntimeException(""String_Node_Str"");
  }
  String result;
  try {
    if (refFormat == RefFormat.URL) {
      result=RemoteUrl.urlToString(file,auths);
    }
 else {
      final Path pathToUse=parentDirectory.resolve(file).normalize();
      if (Files.exists(pathToUse)) {
        result=IOUtils.toString(new FileInputStream(pathToUse.toFile()),""String_Node_Str"");
      }
 else {
        result=ClasspathHelper.loadFileFromClasspath(file);
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + refFormat + ""String_Node_Str""+ file+ ""String_Node_Str""+ parentDirectory,e);
  }
  return result;
}",0.9776119402985076
29666,"@Test public void testIssue304(){
  SwaggerDeserializationResult result=new SwaggerParser().readWithInfo(""String_Node_Str"",null,true);
  assertNotNull(result.getSwagger());
  Swagger swagger=result.getSwagger();
  assertFalse(swagger.getDefinitions().get(""String_Node_Str"") instanceof RefModel);
}","@Test public void testIssue304(){
  SwaggerDeserializationResult result=new SwaggerParser().readWithInfo(""String_Node_Str"",null,true);
  assertNotNull(result.getSwagger().getDefinitions());
}",0.7827868852459017
29667,"public String processRefToExternalDefinition(String $ref,RefFormat refFormat){
  String renamedRef=cache.getRenamedRef($ref);
  if (renamedRef != null) {
    return renamedRef;
  }
  final Model model=cache.loadRef($ref,refFormat,Model.class);
  if (model == null) {
    LOGGER.warn(""String_Node_Str"" + $ref + ""String_Node_Str""+ ""String_Node_Str"");
    return $ref;
  }
  String newRef;
  Map<String,Model> definitions=swagger.getDefinitions();
  if (definitions == null) {
    definitions=new LinkedHashMap<>();
  }
  final String possiblyConflictingDefinitionName=computeDefinitionName($ref,definitions.keySet());
  Model existingModel=definitions.get(possiblyConflictingDefinitionName);
  if (existingModel != null) {
    LOGGER.debug(""String_Node_Str"" + existingModel + ""String_Node_Str"");
    if (existingModel instanceof RefModel) {
      existingModel=null;
    }
  }
  newRef=possiblyConflictingDefinitionName;
  cache.putRenamedRef($ref,newRef);
  if (existingModel == null) {
    swagger.addDefinition(newRef,model);
    cache.addReferencedKey(newRef);
    String file=$ref.split(""String_Node_Str"")[0];
    if (model instanceof RefModel) {
      RefModel refModel=(RefModel)model;
      if (isAnExternalRefFormat(refModel.getRefFormat())) {
        refModel.set$ref(processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat()));
      }
 else {
        processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
      }
    }
 else     if (model instanceof ComposedModel) {
      ComposedModel composedModel=(ComposedModel)model;
      List<Model> listOfAllOF=composedModel.getAllOf();
      for (      Model allOfModel : listOfAllOF) {
        if (allOfModel instanceof RefModel) {
          RefModel refModel=(RefModel)allOfModel;
          if (isAnExternalRefFormat(refModel.getRefFormat())) {
            refModel.set$ref(processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat()));
          }
 else {
            processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
          }
        }
      }
    }
    Map<String,Property> subProps=model.getProperties();
    if (subProps != null) {
      for (      Map.Entry<String,Property> prop : subProps.entrySet()) {
        if (prop.getValue() instanceof RefProperty) {
          processRefProperty((RefProperty)prop.getValue(),file);
        }
 else         if (prop.getValue() instanceof ArrayProperty) {
          ArrayProperty arrayProp=(ArrayProperty)prop.getValue();
          if (arrayProp.getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)arrayProp.getItems(),file);
          }
        }
 else         if (prop.getValue() instanceof MapProperty) {
          MapProperty mapProp=(MapProperty)prop.getValue();
          if (mapProp.getAdditionalProperties() instanceof RefProperty) {
            processRefProperty((RefProperty)mapProp.getAdditionalProperties(),file);
          }
 else           if (mapProp.getAdditionalProperties() instanceof ArrayProperty && ((ArrayProperty)mapProp.getAdditionalProperties()).getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)((ArrayProperty)mapProp.getAdditionalProperties()).getItems(),file);
          }
        }
      }
    }
    if (model instanceof ArrayModel && ((ArrayModel)model).getItems() instanceof RefProperty) {
      processRefProperty((RefProperty)((ArrayModel)model).getItems(),file);
    }
  }
  return newRef;
}","public String processRefToExternalDefinition(String $ref,RefFormat refFormat){
  String renamedRef=cache.getRenamedRef($ref);
  if (renamedRef != null) {
    return renamedRef;
  }
  final Model model=cache.loadRef($ref,refFormat,Model.class);
  if (model == null) {
    LOGGER.warn(""String_Node_Str"" + $ref + ""String_Node_Str""+ ""String_Node_Str"");
    return $ref;
  }
  String newRef;
  Map<String,Model> definitions=swagger.getDefinitions();
  if (definitions == null) {
    definitions=new LinkedHashMap<>();
  }
  final String possiblyConflictingDefinitionName=computeDefinitionName($ref,definitions.keySet());
  Model existingModel=definitions.get(possiblyConflictingDefinitionName);
  if (existingModel != null) {
    LOGGER.debug(""String_Node_Str"" + existingModel + ""String_Node_Str"");
    if (existingModel instanceof RefModel) {
      existingModel=null;
    }
  }
  newRef=possiblyConflictingDefinitionName;
  cache.putRenamedRef($ref,newRef);
  if (existingModel == null) {
    swagger.addDefinition(newRef,model);
    cache.addReferencedKey(newRef);
    String file=$ref.split(""String_Node_Str"")[0];
    if (model instanceof RefModel) {
      RefModel refModel=(RefModel)model;
      if (isAnExternalRefFormat(refModel.getRefFormat())) {
        refModel.set$ref(processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat()));
      }
 else {
        processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
      }
    }
 else     if (model instanceof ComposedModel) {
      ComposedModel composedModel=(ComposedModel)model;
      List<Model> listOfAllOF=composedModel.getAllOf();
      for (      Model allOfModel : listOfAllOF) {
        if (allOfModel instanceof RefModel) {
          RefModel refModel=(RefModel)allOfModel;
          if (isAnExternalRefFormat(refModel.getRefFormat())) {
            refModel.set$ref(processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat()));
          }
 else {
            processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
          }
        }
      }
    }
    Map<String,Property> subProps=model.getProperties();
    if (subProps != null) {
      for (      Map.Entry<String,Property> prop : subProps.entrySet()) {
        if (prop.getValue() instanceof RefProperty) {
          processRefProperty((RefProperty)prop.getValue(),file);
        }
 else         if (prop.getValue() instanceof ArrayProperty) {
          ArrayProperty arrayProp=(ArrayProperty)prop.getValue();
          if (arrayProp.getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)arrayProp.getItems(),file);
          }
        }
 else         if (prop.getValue() instanceof MapProperty) {
          MapProperty mapProp=(MapProperty)prop.getValue();
          if (mapProp.getAdditionalProperties() instanceof RefProperty) {
            processRefProperty((RefProperty)mapProp.getAdditionalProperties(),file);
          }
 else           if (mapProp.getAdditionalProperties() instanceof ArrayProperty && ((ArrayProperty)mapProp.getAdditionalProperties()).getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)((ArrayProperty)mapProp.getAdditionalProperties()).getItems(),file);
          }
        }
      }
    }
    if (model instanceof ModelImpl) {
      ModelImpl modelImpl=(ModelImpl)model;
      Property additionalProperties=modelImpl.getAdditionalProperties();
      if (additionalProperties != null) {
        if (additionalProperties instanceof RefProperty) {
          processRefProperty(((RefProperty)additionalProperties),file);
        }
 else         if (additionalProperties instanceof ArrayProperty) {
          ArrayProperty arrayProp=(ArrayProperty)additionalProperties;
          if (arrayProp.getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)arrayProp.getItems(),file);
          }
        }
 else         if (additionalProperties instanceof MapProperty) {
          MapProperty mapProp=(MapProperty)additionalProperties;
          if (mapProp.getAdditionalProperties() instanceof RefProperty) {
            processRefProperty((RefProperty)mapProp.getAdditionalProperties(),file);
          }
 else           if (mapProp.getAdditionalProperties() instanceof ArrayProperty && ((ArrayProperty)mapProp.getAdditionalProperties()).getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)((ArrayProperty)mapProp.getAdditionalProperties()).getItems(),file);
          }
        }
      }
    }
    if (model instanceof ArrayModel && ((ArrayModel)model).getItems() instanceof RefProperty) {
      processRefProperty((RefProperty)((ArrayModel)model).getItems(),file);
    }
  }
  return newRef;
}",0.8398194461388313
29668,"public Model definition(ObjectNode node,String location,ParseResult result){
  if (result == null) {
    result=new ParseResult();
  }
  if (node == null) {
    result.missing(location,""String_Node_Str"");
    return null;
  }
  if (node.get(""String_Node_Str"") != null) {
    return refModel(node,location,result);
  }
  if (node.get(""String_Node_Str"") != null) {
    return allOfModel(node,location,result);
  }
  Model model=null;
  String value=null;
  String type=getString(""String_Node_Str"",node,false,location,result);
  Model m=new ModelImpl();
  if (""String_Node_Str"".equals(type)) {
    ArrayModel am=new ArrayModel();
    ObjectNode propertyNode=getObject(""String_Node_Str"",node,false,location,result);
    Map<String,Property> properties=properties(propertyNode,location,result);
    am.setProperties(properties);
    ObjectNode itemsNode=getObject(""String_Node_Str"",node,false,location,result);
    Property items=property(itemsNode,location,result);
    if (items != null) {
      am.items(items);
    }
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        am.setVendorExtension(key,extension(node.get(key)));
      }
    }
    model=am;
  }
 else {
    ModelImpl impl=new ModelImpl();
    impl.setType(type);
    JsonNode ap=node.get(""String_Node_Str"");
    if (ap != null && ap.getNodeType().equals(JsonNodeType.OBJECT)) {
      impl.setAdditionalProperties(Json.mapper().convertValue(ap,Property.class));
    }
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDefaultValue(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setFormat(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDiscriminator(value);
    Boolean bp=getBoolean(""String_Node_Str"",node,false,location,result);
    if (bp != null) {
      impl.setUniqueItems(bp);
    }
    ap=node.get(""String_Node_Str"");
    if (ap != null) {
      ArrayNode arrayNode=getArray(""String_Node_Str"",node,false,location,result);
      if (arrayNode != null) {
        for (        JsonNode n : arrayNode) {
          if (n.isValueNode()) {
            impl._enum(n.asText());
          }
 else {
            result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
          }
        }
      }
    }
    JsonNode xml=node.get(""String_Node_Str"");
    if (xml != null) {
      impl.setXml(Json.mapper().convertValue(xml,Xml.class));
    }
    ObjectNode externalDocs=getObject(""String_Node_Str"",node,false,location,result);
    ExternalDocs docs=externalDocs(externalDocs,location,result);
    impl.setExternalDocs(docs);
    ObjectNode properties=getObject(""String_Node_Str"",node,false,location,result);
    if (properties != null) {
      Set<String> propertyNames=getKeys(properties);
      for (      String propertyName : propertyNames) {
        JsonNode propertyNode=properties.get(propertyName);
        if (propertyNode.getNodeType().equals(JsonNodeType.OBJECT)) {
          ObjectNode on=(ObjectNode)propertyNode;
          Property property=property(on,location,result);
          impl.property(propertyName,property);
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",propertyNode);
        }
      }
    }
    ArrayNode required=getArray(""String_Node_Str"",node,false,location,result);
    if (required != null) {
      List<String> requiredProperties=new ArrayList<String>();
      for (      JsonNode n : required) {
        if (n.getNodeType().equals(JsonNodeType.STRING)) {
          requiredProperties.add(((TextNode)n).textValue());
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
        }
      }
      if (requiredProperties.size() > 0) {
        impl.setRequired(requiredProperties);
      }
    }
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        impl.setVendorExtension(key,extension(node.get(key)));
      }
 else       if (!SCHEMA_KEYS.contains(key)) {
        result.extra(location,key,node.get(key));
      }
    }
    model=impl;
  }
  JsonNode exampleNode=node.get(""String_Node_Str"");
  if (exampleNode != null) {
    if (exampleNode.getNodeType().equals(JsonNodeType.OBJECT)) {
      ObjectNode on=getObject(""String_Node_Str"",node,false,location,result);
      if (on != null) {
        model.setExample(on);
      }
    }
 else     if (exampleNode.isValueNode()) {
      model.setExample(exampleNode.asText());
    }
 else {
      model.setExample(exampleNode.toString());
    }
  }
  if (model != null) {
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setDescription(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setTitle(value);
  }
  return model;
}","public Model definition(ObjectNode node,String location,ParseResult result){
  if (result == null) {
    result=new ParseResult();
  }
  if (node == null) {
    result.missing(location,""String_Node_Str"");
    return null;
  }
  if (node.get(""String_Node_Str"") != null) {
    return refModel(node,location,result);
  }
  if (node.get(""String_Node_Str"") != null) {
    return allOfModel(node,location,result);
  }
  Model model=null;
  String value=null;
  String type=getString(""String_Node_Str"",node,false,location,result);
  Model m=new ModelImpl();
  if (""String_Node_Str"".equals(type)) {
    ArrayModel am=new ArrayModel();
    ObjectNode propertyNode=getObject(""String_Node_Str"",node,false,location,result);
    Map<String,Property> properties=properties(propertyNode,location,result);
    am.setProperties(properties);
    ObjectNode itemsNode=getObject(""String_Node_Str"",node,false,location,result);
    Property items=property(itemsNode,location,result);
    if (items != null) {
      am.items(items);
    }
    Integer maxItems=getInteger(""String_Node_Str"",node,false,location,result);
    am.setMaxItems(maxItems);
    Integer minItems=getInteger(""String_Node_Str"",node,false,location,result);
    am.setMinItems(minItems);
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        am.setVendorExtension(key,extension(node.get(key)));
      }
    }
    model=am;
  }
 else {
    ModelImpl impl=new ModelImpl();
    impl.setType(type);
    JsonNode ap=node.get(""String_Node_Str"");
    if (ap != null && ap.getNodeType().equals(JsonNodeType.OBJECT)) {
      impl.setAdditionalProperties(Json.mapper().convertValue(ap,Property.class));
    }
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDefaultValue(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setFormat(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDiscriminator(value);
    Boolean bp=getBoolean(""String_Node_Str"",node,false,location,result);
    if (bp != null) {
      impl.setUniqueItems(bp);
    }
    ap=node.get(""String_Node_Str"");
    if (ap != null) {
      ArrayNode arrayNode=getArray(""String_Node_Str"",node,false,location,result);
      if (arrayNode != null) {
        for (        JsonNode n : arrayNode) {
          if (n.isValueNode()) {
            impl._enum(n.asText());
          }
 else {
            result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
          }
        }
      }
    }
    JsonNode xml=node.get(""String_Node_Str"");
    if (xml != null) {
      impl.setXml(Json.mapper().convertValue(xml,Xml.class));
    }
    ObjectNode externalDocs=getObject(""String_Node_Str"",node,false,location,result);
    ExternalDocs docs=externalDocs(externalDocs,location,result);
    impl.setExternalDocs(docs);
    ObjectNode properties=getObject(""String_Node_Str"",node,false,location,result);
    if (properties != null) {
      Set<String> propertyNames=getKeys(properties);
      for (      String propertyName : propertyNames) {
        JsonNode propertyNode=properties.get(propertyName);
        if (propertyNode.getNodeType().equals(JsonNodeType.OBJECT)) {
          ObjectNode on=(ObjectNode)propertyNode;
          Property property=property(on,location,result);
          impl.property(propertyName,property);
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",propertyNode);
        }
      }
    }
    ArrayNode required=getArray(""String_Node_Str"",node,false,location,result);
    if (required != null) {
      List<String> requiredProperties=new ArrayList<String>();
      for (      JsonNode n : required) {
        if (n.getNodeType().equals(JsonNodeType.STRING)) {
          requiredProperties.add(((TextNode)n).textValue());
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
        }
      }
      if (requiredProperties.size() > 0) {
        impl.setRequired(requiredProperties);
      }
    }
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        impl.setVendorExtension(key,extension(node.get(key)));
      }
 else       if (!SCHEMA_KEYS.contains(key)) {
        result.extra(location,key,node.get(key));
      }
    }
    model=impl;
  }
  JsonNode exampleNode=node.get(""String_Node_Str"");
  if (exampleNode != null) {
    if (exampleNode.getNodeType().equals(JsonNodeType.OBJECT)) {
      ObjectNode on=getObject(""String_Node_Str"",node,false,location,result);
      if (on != null) {
        model.setExample(on);
      }
    }
 else     if (exampleNode.isValueNode()) {
      model.setExample(exampleNode.asText());
    }
 else {
      model.setExample(exampleNode.toString());
    }
  }
  if (model != null) {
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setDescription(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setTitle(value);
  }
  return model;
}",0.9780816408606476
29669,"public String processRefToExternalDefinition(String $ref,RefFormat refFormat){
  String renamedRef=cache.getRenamedRef($ref);
  if (renamedRef != null) {
    return renamedRef;
  }
  final Model model=cache.loadRef($ref,refFormat,Model.class);
  if (model == null) {
    LOGGER.warn(""String_Node_Str"" + $ref + ""String_Node_Str""+ ""String_Node_Str"");
    return $ref;
  }
  String newRef;
  Map<String,Model> definitions=swagger.getDefinitions();
  if (definitions == null) {
    definitions=new LinkedHashMap<>();
  }
  final String possiblyConflictingDefinitionName=computeDefinitionName($ref,definitions.keySet());
  Model existingModel=definitions.get(possiblyConflictingDefinitionName);
  if (existingModel != null) {
    LOGGER.debug(""String_Node_Str"" + existingModel + ""String_Node_Str"");
    if (existingModel instanceof RefModel) {
      existingModel=null;
    }
  }
  newRef=possiblyConflictingDefinitionName;
  cache.putRenamedRef($ref,newRef);
  if (existingModel == null) {
    swagger.addDefinition(newRef,model);
    cache.addReferencedKey(newRef);
    String file=$ref.split(""String_Node_Str"")[0];
    if (model instanceof RefModel) {
      RefModel refModel=(RefModel)model;
      if (isAnExternalRefFormat(refModel.getRefFormat())) {
        refModel.set$ref(processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat()));
      }
 else {
        processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
      }
    }
 else     if (model instanceof ComposedModel) {
      ComposedModel composedModel=(ComposedModel)model;
      List<Model> listOfAllOF=composedModel.getAllOf();
      for (      Model allOfModel : listOfAllOF) {
        if (allOfModel instanceof RefModel) {
          RefModel refModel=(RefModel)allOfModel;
          if (isAnExternalRefFormat(refModel.getRefFormat())) {
            refModel.set$ref(processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat()));
          }
 else {
            processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
          }
        }
      }
    }
    Map<String,Property> subProps=model.getProperties();
    if (subProps != null) {
      for (      Map.Entry<String,Property> prop : subProps.entrySet()) {
        if (prop.getValue() instanceof RefProperty) {
          processRefProperty((RefProperty)prop.getValue(),file);
        }
 else         if (prop.getValue() instanceof ArrayProperty) {
          ArrayProperty arrayProp=(ArrayProperty)prop.getValue();
          if (arrayProp.getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)arrayProp.getItems(),file);
          }
        }
 else         if (prop.getValue() instanceof MapProperty) {
          MapProperty mapProp=(MapProperty)prop.getValue();
          if (mapProp.getAdditionalProperties() instanceof RefProperty) {
            processRefProperty((RefProperty)mapProp.getAdditionalProperties(),file);
          }
 else           if (mapProp.getAdditionalProperties() instanceof ArrayProperty && ((ArrayProperty)mapProp.getAdditionalProperties()).getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)((ArrayProperty)mapProp.getAdditionalProperties()).getItems(),file);
          }
        }
      }
    }
    if (model instanceof ModelImpl) {
      ModelImpl modelImpl=(ModelImpl)model;
      Property additionalProperties=modelImpl.getAdditionalProperties();
      if (additionalProperties != null) {
        if (additionalProperties instanceof RefProperty) {
          processRefProperty(((RefProperty)additionalProperties),file);
        }
 else         if (additionalProperties instanceof ArrayProperty) {
          ArrayProperty arrayProp=(ArrayProperty)additionalProperties;
          if (arrayProp.getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)arrayProp.getItems(),file);
          }
        }
 else         if (additionalProperties instanceof MapProperty) {
          MapProperty mapProp=(MapProperty)additionalProperties;
          if (mapProp.getAdditionalProperties() instanceof RefProperty) {
            processRefProperty((RefProperty)mapProp.getAdditionalProperties(),file);
          }
 else           if (mapProp.getAdditionalProperties() instanceof ArrayProperty && ((ArrayProperty)mapProp.getAdditionalProperties()).getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)((ArrayProperty)mapProp.getAdditionalProperties()).getItems(),file);
          }
        }
      }
    }
    if (model instanceof ArrayModel && ((ArrayModel)model).getItems() instanceof RefProperty) {
      processRefProperty((RefProperty)((ArrayModel)model).getItems(),file);
    }
  }
  return newRef;
}","public String processRefToExternalDefinition(String $ref,RefFormat refFormat){
  String renamedRef=cache.getRenamedRef($ref);
  if (renamedRef != null) {
    return renamedRef;
  }
  final Model model=cache.loadRef($ref,refFormat,Model.class);
  if (model == null) {
    LOGGER.warn(""String_Node_Str"" + $ref + ""String_Node_Str""+ ""String_Node_Str"");
    return $ref;
  }
  String newRef;
  Map<String,Model> definitions=swagger.getDefinitions();
  if (definitions == null) {
    definitions=new LinkedHashMap<>();
  }
  final String possiblyConflictingDefinitionName=computeDefinitionName($ref,definitions.keySet());
  Model existingModel=definitions.get(possiblyConflictingDefinitionName);
  if (existingModel != null) {
    LOGGER.debug(""String_Node_Str"" + existingModel + ""String_Node_Str"");
    if (existingModel instanceof RefModel) {
      existingModel=null;
    }
  }
  newRef=possiblyConflictingDefinitionName;
  cache.putRenamedRef($ref,newRef);
  if (existingModel == null) {
    swagger.addDefinition(newRef,model);
    cache.addReferencedKey(newRef);
    String file=$ref.split(""String_Node_Str"")[0];
    if (model instanceof RefModel) {
      RefModel refModel=(RefModel)model;
      if (isAnExternalRefFormat(refModel.getRefFormat())) {
        refModel.set$ref(processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat()));
      }
 else {
        processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
      }
    }
 else     if (model instanceof ComposedModel) {
      ComposedModel composedModel=(ComposedModel)model;
      List<Model> listOfAllOF=composedModel.getAllOf();
      for (      Model allOfModel : listOfAllOF) {
        if (allOfModel instanceof RefModel) {
          RefModel refModel=(RefModel)allOfModel;
          if (isAnExternalRefFormat(refModel.getRefFormat())) {
            String joinedRef=join(file,refModel.get$ref());
            refModel.set$ref(processRefToExternalDefinition(joinedRef,refModel.getRefFormat()));
          }
 else {
            processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
          }
        }
      }
    }
    Map<String,Property> subProps=model.getProperties();
    if (subProps != null) {
      for (      Map.Entry<String,Property> prop : subProps.entrySet()) {
        if (prop.getValue() instanceof RefProperty) {
          processRefProperty((RefProperty)prop.getValue(),file);
        }
 else         if (prop.getValue() instanceof ArrayProperty) {
          ArrayProperty arrayProp=(ArrayProperty)prop.getValue();
          if (arrayProp.getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)arrayProp.getItems(),file);
          }
        }
 else         if (prop.getValue() instanceof MapProperty) {
          MapProperty mapProp=(MapProperty)prop.getValue();
          if (mapProp.getAdditionalProperties() instanceof RefProperty) {
            processRefProperty((RefProperty)mapProp.getAdditionalProperties(),file);
          }
 else           if (mapProp.getAdditionalProperties() instanceof ArrayProperty && ((ArrayProperty)mapProp.getAdditionalProperties()).getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)((ArrayProperty)mapProp.getAdditionalProperties()).getItems(),file);
          }
        }
      }
    }
    if (model instanceof ModelImpl) {
      ModelImpl modelImpl=(ModelImpl)model;
      Property additionalProperties=modelImpl.getAdditionalProperties();
      if (additionalProperties != null) {
        if (additionalProperties instanceof RefProperty) {
          processRefProperty(((RefProperty)additionalProperties),file);
        }
 else         if (additionalProperties instanceof ArrayProperty) {
          ArrayProperty arrayProp=(ArrayProperty)additionalProperties;
          if (arrayProp.getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)arrayProp.getItems(),file);
          }
        }
 else         if (additionalProperties instanceof MapProperty) {
          MapProperty mapProp=(MapProperty)additionalProperties;
          if (mapProp.getAdditionalProperties() instanceof RefProperty) {
            processRefProperty((RefProperty)mapProp.getAdditionalProperties(),file);
          }
 else           if (mapProp.getAdditionalProperties() instanceof ArrayProperty && ((ArrayProperty)mapProp.getAdditionalProperties()).getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)((ArrayProperty)mapProp.getAdditionalProperties()).getItems(),file);
          }
        }
      }
    }
    if (model instanceof ArrayModel && ((ArrayModel)model).getItems() instanceof RefProperty) {
      processRefProperty((RefProperty)((ArrayModel)model).getItems(),file);
    }
  }
  return newRef;
}",0.990841141172755
29670,"public SwaggerDeserializationResult readWithInfo(String swaggerAsString){
  if (swaggerAsString == null) {
    return new SwaggerDeserializationResult().message(""String_Node_Str"");
  }
  try {
    JsonNode node;
    if (swaggerAsString.trim().startsWith(""String_Node_Str"")) {
      ObjectMapper mapper=Json.mapper();
      node=mapper.readTree(swaggerAsString);
    }
 else {
      node=DeserializationUtils.readYamlTree(swaggerAsString);
    }
    SwaggerDeserializationResult result=new Swagger20Parser().readWithInfo(node);
    if (result != null) {
      result.setSwagger(new SwaggerResolver(result.getSwagger(),new ArrayList<AuthorizationValue>(),null).resolve());
    }
 else {
      result=new SwaggerDeserializationResult().message(""String_Node_Str"");
    }
    return result;
  }
 catch (  Exception e) {
    return new SwaggerDeserializationResult().message(""String_Node_Str"");
  }
}","public SwaggerDeserializationResult readWithInfo(String swaggerAsString,boolean resolve){
  if (swaggerAsString == null) {
    return new SwaggerDeserializationResult().message(""String_Node_Str"");
  }
  try {
    JsonNode node;
    if (swaggerAsString.trim().startsWith(""String_Node_Str"")) {
      ObjectMapper mapper=Json.mapper();
      node=mapper.readTree(swaggerAsString);
    }
 else {
      node=DeserializationUtils.readYamlTree(swaggerAsString);
    }
    SwaggerDeserializationResult result=new Swagger20Parser().readWithInfo(node);
    if (result != null) {
      if (resolve) {
        result.setSwagger(new SwaggerResolver(result.getSwagger(),new ArrayList<AuthorizationValue>(),null).resolve());
      }
    }
 else {
      result=new SwaggerDeserializationResult().message(""String_Node_Str"");
    }
    return result;
  }
 catch (  Exception e) {
    return new SwaggerDeserializationResult().message(""String_Node_Str"");
  }
}",0.9743869209809264
29671,"public Model definition(ObjectNode node,String location,ParseResult result){
  if (result == null) {
    result=new ParseResult();
  }
  if (node == null) {
    result.missing(location,""String_Node_Str"");
    return null;
  }
  if (node.get(""String_Node_Str"") != null) {
    return refModel(node,location,result);
  }
  if (node.get(""String_Node_Str"") != null) {
    return allOfModel(node,location,result);
  }
  Model model=null;
  String value=null;
  String type=getString(""String_Node_Str"",node,false,location,result);
  Model m=new ModelImpl();
  if (""String_Node_Str"".equals(type)) {
    ArrayModel am=new ArrayModel();
    ObjectNode propertyNode=getObject(""String_Node_Str"",node,false,location,result);
    Map<String,Property> properties=properties(propertyNode,location,result);
    am.setProperties(properties);
    ObjectNode itemsNode=getObject(""String_Node_Str"",node,false,location,result);
    Property items=property(itemsNode,location,result);
    if (items != null) {
      am.items(items);
    }
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        am.setVendorExtension(key,extension(node.get(key)));
      }
    }
    model=am;
  }
 else {
    ModelImpl impl=new ModelImpl();
    impl.setType(type);
    JsonNode ap=node.get(""String_Node_Str"");
    if (ap != null && ap.getNodeType().equals(JsonNodeType.OBJECT)) {
      impl.setAdditionalProperties(Json.mapper().convertValue(ap,Property.class));
    }
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDefaultValue(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setFormat(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDiscriminator(value);
    Boolean bp=getBoolean(""String_Node_Str"",node,false,location,result);
    if (bp != null) {
      impl.setUniqueItems(bp);
    }
    ap=node.get(""String_Node_Str"");
    if (ap != null) {
      ArrayNode arrayNode=getArray(""String_Node_Str"",node,false,location,result);
      if (arrayNode != null) {
        for (        JsonNode n : arrayNode) {
          if (n.isValueNode()) {
            impl._enum(n.asText());
          }
 else {
            result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
          }
        }
      }
    }
    JsonNode xml=node.get(""String_Node_Str"");
    if (xml != null) {
      impl.setXml(Json.mapper().convertValue(xml,Xml.class));
    }
    ObjectNode externalDocs=getObject(""String_Node_Str"",node,false,location,result);
    ExternalDocs docs=externalDocs(externalDocs,location,result);
    impl.setExternalDocs(docs);
    ObjectNode properties=getObject(""String_Node_Str"",node,false,location,result);
    if (properties != null) {
      Set<String> propertyNames=getKeys(properties);
      for (      String propertyName : propertyNames) {
        JsonNode propertyNode=properties.get(propertyName);
        if (propertyNode.getNodeType().equals(JsonNodeType.OBJECT)) {
          ObjectNode on=(ObjectNode)propertyNode;
          Property property=property(on,location,result);
          impl.property(propertyName,property);
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",propertyNode);
        }
      }
    }
    ArrayNode required=getArray(""String_Node_Str"",node,false,location,result);
    if (required != null) {
      List<String> requiredProperties=new ArrayList<String>();
      for (      JsonNode n : required) {
        if (n.getNodeType().equals(JsonNodeType.STRING)) {
          requiredProperties.add(((TextNode)n).textValue());
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
        }
      }
      if (requiredProperties.size() > 0) {
        impl.setRequired(requiredProperties);
      }
    }
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        impl.setVendorExtension(key,extension(node.get(key)));
      }
 else       if (!SCHEMA_KEYS.contains(key)) {
        result.extra(location,key,node.get(key));
      }
    }
    if (""String_Node_Str"".equals(Json.pretty(impl)))     return null;
    model=impl;
  }
  JsonNode exampleNode=node.get(""String_Node_Str"");
  if (exampleNode != null) {
    if (exampleNode.getNodeType().equals(JsonNodeType.OBJECT)) {
      ObjectNode on=getObject(""String_Node_Str"",node,false,location,result);
      if (on != null) {
        model.setExample(on);
      }
    }
 else {
      model.setExample(exampleNode.toString());
    }
  }
  if (model != null) {
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setDescription(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setTitle(value);
  }
  return model;
}","public Model definition(ObjectNode node,String location,ParseResult result){
  if (result == null) {
    result=new ParseResult();
  }
  if (node == null) {
    result.missing(location,""String_Node_Str"");
    return null;
  }
  if (node.get(""String_Node_Str"") != null) {
    return refModel(node,location,result);
  }
  if (node.get(""String_Node_Str"") != null) {
    return allOfModel(node,location,result);
  }
  Model model=null;
  String value=null;
  String type=getString(""String_Node_Str"",node,false,location,result);
  Model m=new ModelImpl();
  if (""String_Node_Str"".equals(type)) {
    ArrayModel am=new ArrayModel();
    ObjectNode propertyNode=getObject(""String_Node_Str"",node,false,location,result);
    Map<String,Property> properties=properties(propertyNode,location,result);
    am.setProperties(properties);
    ObjectNode itemsNode=getObject(""String_Node_Str"",node,false,location,result);
    Property items=property(itemsNode,location,result);
    if (items != null) {
      am.items(items);
    }
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        am.setVendorExtension(key,extension(node.get(key)));
      }
    }
    model=am;
  }
 else {
    ModelImpl impl=new ModelImpl();
    impl.setType(type);
    JsonNode ap=node.get(""String_Node_Str"");
    if (ap != null && ap.getNodeType().equals(JsonNodeType.OBJECT)) {
      impl.setAdditionalProperties(Json.mapper().convertValue(ap,Property.class));
    }
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDefaultValue(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setFormat(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDiscriminator(value);
    Boolean bp=getBoolean(""String_Node_Str"",node,false,location,result);
    if (bp != null) {
      impl.setUniqueItems(bp);
    }
    ap=node.get(""String_Node_Str"");
    if (ap != null) {
      ArrayNode arrayNode=getArray(""String_Node_Str"",node,false,location,result);
      if (arrayNode != null) {
        for (        JsonNode n : arrayNode) {
          if (n.isValueNode()) {
            impl._enum(n.asText());
          }
 else {
            result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
          }
        }
      }
    }
    JsonNode xml=node.get(""String_Node_Str"");
    if (xml != null) {
      impl.setXml(Json.mapper().convertValue(xml,Xml.class));
    }
    ObjectNode externalDocs=getObject(""String_Node_Str"",node,false,location,result);
    ExternalDocs docs=externalDocs(externalDocs,location,result);
    impl.setExternalDocs(docs);
    ObjectNode properties=getObject(""String_Node_Str"",node,false,location,result);
    if (properties != null) {
      Set<String> propertyNames=getKeys(properties);
      for (      String propertyName : propertyNames) {
        JsonNode propertyNode=properties.get(propertyName);
        if (propertyNode.getNodeType().equals(JsonNodeType.OBJECT)) {
          ObjectNode on=(ObjectNode)propertyNode;
          Property property=property(on,location,result);
          impl.property(propertyName,property);
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",propertyNode);
        }
      }
    }
    ArrayNode required=getArray(""String_Node_Str"",node,false,location,result);
    if (required != null) {
      List<String> requiredProperties=new ArrayList<String>();
      for (      JsonNode n : required) {
        if (n.getNodeType().equals(JsonNodeType.STRING)) {
          requiredProperties.add(((TextNode)n).textValue());
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
        }
      }
      if (requiredProperties.size() > 0) {
        impl.setRequired(requiredProperties);
      }
    }
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        impl.setVendorExtension(key,extension(node.get(key)));
      }
 else       if (!SCHEMA_KEYS.contains(key)) {
        result.extra(location,key,node.get(key));
      }
    }
    model=impl;
  }
  JsonNode exampleNode=node.get(""String_Node_Str"");
  if (exampleNode != null) {
    if (exampleNode.getNodeType().equals(JsonNodeType.OBJECT)) {
      ObjectNode on=getObject(""String_Node_Str"",node,false,location,result);
      if (on != null) {
        model.setExample(on);
      }
    }
 else {
      model.setExample(exampleNode.toString());
    }
  }
  if (model != null) {
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setDescription(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setTitle(value);
  }
  return model;
}",0.992714404662781
29672,"public Model definition(ObjectNode node,String location,ParseResult result){
  if (result == null) {
    result=new ParseResult();
  }
  if (node == null) {
    result.missing(location,""String_Node_Str"");
    return null;
  }
  if (node.get(""String_Node_Str"") != null) {
    return refModel(node,location,result);
  }
  if (node.get(""String_Node_Str"") != null) {
    return allOfModel(node,location,result);
  }
  Model model=null;
  String value=null;
  String type=getString(""String_Node_Str"",node,false,location,result);
  Model m=new ModelImpl();
  if (""String_Node_Str"".equals(type)) {
    ArrayModel am=new ArrayModel();
    ObjectNode propertyNode=getObject(""String_Node_Str"",node,false,location,result);
    Map<String,Property> properties=properties(propertyNode,location,result);
    am.setProperties(properties);
    ObjectNode itemsNode=getObject(""String_Node_Str"",node,false,location,result);
    Property items=property(itemsNode,location,result);
    if (items != null) {
      am.items(items);
    }
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        am.setVendorExtension(key,extension(node.get(key)));
      }
    }
    model=am;
  }
 else {
    ModelImpl impl=new ModelImpl();
    impl.setType(type);
    JsonNode ap=node.get(""String_Node_Str"");
    if (ap != null && ap.getNodeType().equals(JsonNodeType.OBJECT)) {
      impl.setAdditionalProperties(Json.mapper().convertValue(ap,Property.class));
    }
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDefaultValue(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setFormat(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDiscriminator(value);
    Boolean bp=getBoolean(""String_Node_Str"",node,false,location,result);
    if (bp != null) {
      impl.setUniqueItems(bp);
    }
    ap=node.get(""String_Node_Str"");
    if (ap != null) {
      ArrayNode arrayNode=getArray(""String_Node_Str"",node,false,location,result);
      if (arrayNode != null) {
        for (        JsonNode n : arrayNode) {
          if (n.isValueNode()) {
            impl._enum(n.asText());
          }
 else {
            result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
          }
        }
      }
    }
    JsonNode xml=node.get(""String_Node_Str"");
    if (xml != null) {
      impl.setXml(Json.mapper().convertValue(xml,Xml.class));
    }
    ObjectNode externalDocs=getObject(""String_Node_Str"",node,false,location,result);
    ExternalDocs docs=externalDocs(externalDocs,location,result);
    impl.setExternalDocs(docs);
    ObjectNode properties=getObject(""String_Node_Str"",node,false,location,result);
    if (properties != null) {
      Set<String> propertyNames=getKeys(properties);
      for (      String propertyName : propertyNames) {
        JsonNode propertyNode=properties.get(propertyName);
        if (propertyNode.getNodeType().equals(JsonNodeType.OBJECT)) {
          ObjectNode on=(ObjectNode)propertyNode;
          Property property=property(on,location,result);
          impl.property(propertyName,property);
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",propertyNode);
        }
      }
    }
    ArrayNode required=getArray(""String_Node_Str"",node,false,location,result);
    if (required != null) {
      List<String> requiredProperties=new ArrayList<String>();
      for (      JsonNode n : required) {
        if (n.getNodeType().equals(JsonNodeType.STRING)) {
          requiredProperties.add(((TextNode)n).textValue());
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
        }
      }
      if (requiredProperties.size() > 0) {
        impl.setRequired(requiredProperties);
      }
    }
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        impl.setVendorExtension(key,extension(node.get(key)));
      }
 else       if (!SCHEMA_KEYS.contains(key)) {
        result.extra(location,key,node.get(key));
      }
    }
    if (""String_Node_Str"".equals(Json.pretty(impl)))     return null;
    model=impl;
  }
  JsonNode exampleNode=node.get(""String_Node_Str"");
  if (exampleNode != null) {
    if (exampleNode.getNodeType().equals(JsonNodeType.OBJECT)) {
      ObjectNode on=getObject(""String_Node_Str"",node,false,location,result);
      if (on != null) {
        model.setExample(on);
      }
    }
 else {
      model.setExample(exampleNode.toString());
    }
  }
  if (model != null) {
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setDescription(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setTitle(value);
  }
  return model;
}","public Model definition(ObjectNode node,String location,ParseResult result){
  if (result == null) {
    result=new ParseResult();
  }
  if (node == null) {
    result.missing(location,""String_Node_Str"");
    return null;
  }
  if (node.get(""String_Node_Str"") != null) {
    return refModel(node,location,result);
  }
  if (node.get(""String_Node_Str"") != null) {
    return allOfModel(node,location,result);
  }
  Model model=null;
  String value=null;
  String type=getString(""String_Node_Str"",node,false,location,result);
  Model m=new ModelImpl();
  if (""String_Node_Str"".equals(type)) {
    ArrayModel am=new ArrayModel();
    ObjectNode propertyNode=getObject(""String_Node_Str"",node,false,location,result);
    Map<String,Property> properties=properties(propertyNode,location,result);
    am.setProperties(properties);
    ObjectNode itemsNode=getObject(""String_Node_Str"",node,false,location,result);
    Property items=property(itemsNode,location,result);
    if (items != null) {
      am.items(items);
    }
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        am.setVendorExtension(key,extension(node.get(key)));
      }
    }
    model=am;
  }
 else {
    ModelImpl impl=new ModelImpl();
    impl.setType(type);
    JsonNode ap=node.get(""String_Node_Str"");
    if (ap != null && ap.getNodeType().equals(JsonNodeType.OBJECT)) {
      impl.setAdditionalProperties(Json.mapper().convertValue(ap,Property.class));
    }
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDefaultValue(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setFormat(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDiscriminator(value);
    Boolean bp=getBoolean(""String_Node_Str"",node,false,location,result);
    if (bp != null) {
      impl.setUniqueItems(bp);
    }
    ap=node.get(""String_Node_Str"");
    if (ap != null) {
      ArrayNode arrayNode=getArray(""String_Node_Str"",node,false,location,result);
      if (arrayNode != null) {
        for (        JsonNode n : arrayNode) {
          if (n.isValueNode()) {
            impl._enum(n.asText());
          }
 else {
            result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
          }
        }
      }
    }
    JsonNode xml=node.get(""String_Node_Str"");
    if (xml != null) {
      impl.setXml(Json.mapper().convertValue(xml,Xml.class));
    }
    ObjectNode externalDocs=getObject(""String_Node_Str"",node,false,location,result);
    ExternalDocs docs=externalDocs(externalDocs,location,result);
    impl.setExternalDocs(docs);
    ObjectNode properties=getObject(""String_Node_Str"",node,false,location,result);
    if (properties != null) {
      Set<String> propertyNames=getKeys(properties);
      for (      String propertyName : propertyNames) {
        JsonNode propertyNode=properties.get(propertyName);
        if (propertyNode.getNodeType().equals(JsonNodeType.OBJECT)) {
          ObjectNode on=(ObjectNode)propertyNode;
          Property property=property(on,location,result);
          impl.property(propertyName,property);
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",propertyNode);
        }
      }
    }
    ArrayNode required=getArray(""String_Node_Str"",node,false,location,result);
    if (required != null) {
      List<String> requiredProperties=new ArrayList<String>();
      for (      JsonNode n : required) {
        if (n.getNodeType().equals(JsonNodeType.STRING)) {
          requiredProperties.add(((TextNode)n).textValue());
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
        }
      }
      if (requiredProperties.size() > 0) {
        impl.setRequired(requiredProperties);
      }
    }
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        impl.setVendorExtension(key,extension(node.get(key)));
      }
 else       if (!SCHEMA_KEYS.contains(key)) {
        result.extra(location,key,node.get(key));
      }
    }
    model=impl;
  }
  JsonNode exampleNode=node.get(""String_Node_Str"");
  if (exampleNode != null) {
    if (exampleNode.getNodeType().equals(JsonNodeType.OBJECT)) {
      ObjectNode on=getObject(""String_Node_Str"",node,false,location,result);
      if (on != null) {
        model.setExample(on);
      }
    }
 else {
      model.setExample(exampleNode.toString());
    }
  }
  if (model != null) {
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setDescription(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setTitle(value);
  }
  return model;
}",0.992714404662781
29673,"public void processPaths(){
  final Map<String,Path> pathMap=swagger.getPaths();
  if (pathMap == null) {
    return;
  }
  for (  String pathStr : pathMap.keySet()) {
    Path path=pathMap.get(pathStr);
    if (settings.addParametersToEachOperation()) {
      List<Parameter> parameters=path.getParameters();
      if (parameters != null) {
        List<Operation> operations=path.getOperations();
        if (operations != null) {
          for (          Operation operation : operations) {
            List<Parameter> parametersToAdd=new ArrayList<Parameter>();
            boolean matched=false;
            List<Parameter> existingParameters=operation.getParameters();
            for (            Parameter parameterToAdd : parameters) {
              for (              Parameter existingParameter : existingParameters) {
                if (parameterToAdd.getIn() != null && parameterToAdd.getIn().equals(existingParameter.getIn()) && parameterToAdd.getName().equals(existingParameter.getName())) {
                  matched=true;
                }
              }
              if (!matched) {
                parametersToAdd.add(parameterToAdd);
              }
            }
            if (parametersToAdd.size() > 0) {
              operation.getParameters().addAll(0,parametersToAdd);
            }
          }
        }
      }
      path.setParameters(null);
    }
    if (path instanceof RefPath) {
      RefPath refPath=(RefPath)path;
      Path resolvedPath=cache.loadRef(refPath.get$ref(),refPath.getRefFormat(),Path.class);
      String pathRef=refPath.get$ref().split(""String_Node_Str"")[0];
      updateLocalRefs(resolvedPath,pathRef);
      if (resolvedPath != null) {
        swagger.path(pathStr,resolvedPath);
        path=resolvedPath;
      }
    }
    final List<Parameter> processedPathParameters=parameterProcessor.processParameters(path.getParameters());
    path.setParameters(processedPathParameters);
    final Map<HttpMethod,Operation> operationMap=path.getOperationMap();
    for (    HttpMethod httpMethod : operationMap.keySet()) {
      Operation operation=operationMap.get(httpMethod);
      operationProcessor.processOperation(operation);
    }
  }
}","public void processPaths(){
  final Map<String,Path> pathMap=swagger.getPaths();
  if (pathMap == null) {
    return;
  }
  for (  String pathStr : pathMap.keySet()) {
    Path path=pathMap.get(pathStr);
    if (settings.addParametersToEachOperation()) {
      List<Parameter> parameters=path.getParameters();
      if (parameters != null) {
        List<Operation> operations=path.getOperations();
        if (operations != null) {
          for (          Operation operation : operations) {
            List<Parameter> parametersToAdd=new ArrayList<Parameter>();
            List<Parameter> existingParameters=operation.getParameters();
            for (            Parameter parameterToAdd : parameters) {
              boolean matched=false;
              for (              Parameter existingParameter : existingParameters) {
                if (parameterToAdd.getIn() != null && parameterToAdd.getIn().equals(existingParameter.getIn()) && parameterToAdd.getName().equals(existingParameter.getName())) {
                  matched=true;
                }
              }
              if (!matched) {
                parametersToAdd.add(parameterToAdd);
              }
            }
            if (parametersToAdd.size() > 0) {
              operation.getParameters().addAll(0,parametersToAdd);
            }
          }
        }
      }
      path.setParameters(null);
    }
    if (path instanceof RefPath) {
      RefPath refPath=(RefPath)path;
      Path resolvedPath=cache.loadRef(refPath.get$ref(),refPath.getRefFormat(),Path.class);
      String pathRef=refPath.get$ref().split(""String_Node_Str"")[0];
      updateLocalRefs(resolvedPath,pathRef);
      if (resolvedPath != null) {
        swagger.path(pathStr,resolvedPath);
        path=resolvedPath;
      }
    }
    final List<Parameter> processedPathParameters=parameterProcessor.processParameters(path.getParameters());
    path.setParameters(processedPathParameters);
    final Map<HttpMethod,Operation> operationMap=path.getOperationMap();
    for (    HttpMethod httpMethod : operationMap.keySet()) {
      Operation operation=operationMap.get(httpMethod);
      operationProcessor.processOperation(operation);
    }
  }
}",0.9339106654512306
29674,"public List<Parameter> processParameters(List<Parameter> parameters){
  if (parameters == null) {
    return null;
  }
  final List<Parameter> processedPathLevelParameters=new ArrayList<>();
  for (  Parameter parameter : parameters) {
    if (parameter instanceof RefParameter) {
      RefParameter refParameter=(RefParameter)parameter;
      final Parameter resolvedParameter=cache.loadRef(refParameter.get$ref(),refParameter.getRefFormat(),Parameter.class);
      parameter=resolvedParameter;
    }
    if (parameter instanceof BodyParameter) {
      BodyParameter bodyParameter=(BodyParameter)parameter;
      final Model schema=bodyParameter.getSchema();
      modelProcessor.processModel(schema);
    }
    processedPathLevelParameters.add(parameter);
  }
  return processedPathLevelParameters;
}","public List<Parameter> processParameters(List<Parameter> parameters){
  if (parameters == null) {
    return null;
  }
  final List<Parameter> processedPathLevelParameters=new ArrayList<>();
  final List<Parameter> refParameters=new ArrayList<>();
  for (  Parameter parameter : parameters) {
    if (parameter instanceof RefParameter) {
      RefParameter refParameter=(RefParameter)parameter;
      final Parameter resolvedParameter=cache.loadRef(refParameter.get$ref(),refParameter.getRefFormat(),Parameter.class);
      parameter=resolvedParameter;
      refParameters.add(parameter);
    }
 else     if (parameter instanceof BodyParameter) {
      BodyParameter bodyParameter=(BodyParameter)parameter;
      final Model schema=bodyParameter.getSchema();
      modelProcessor.processModel(schema);
    }
 else {
      processedPathLevelParameters.add(parameter);
    }
  }
  for (  Parameter refParam : refParameters) {
    int pos=0;
    for (    Parameter param : processedPathLevelParameters) {
      if (refParam.getName().equals(param.getName())) {
        processedPathLevelParameters.set(pos,refParam);
      }
      pos++;
    }
  }
  return processedPathLevelParameters;
}",0.7991947659788626
29675,"public String processRefToExternalDefinition(String $ref,RefFormat refFormat){
  final Model model=cache.loadRef($ref,refFormat,Model.class);
  String newRef;
  Map<String,Model> definitions=swagger.getDefinitions();
  if (definitions == null) {
    definitions=new HashMap<>();
  }
  final String possiblyConflictingDefinitionName=computeDefinitionName($ref);
  final Model existingModel=definitions.get(possiblyConflictingDefinitionName);
  if (existingModel != null) {
    LOGGER.debug(""String_Node_Str"" + existingModel + ""String_Node_Str"");
  }
  newRef=possiblyConflictingDefinitionName;
  cache.putRenamedRef($ref,newRef);
  String file=$ref.split(""String_Node_Str"")[0];
  if (model instanceof RefModel) {
    RefModel refModel=(RefModel)model;
    if (isAnExternalRefFormat(refModel.getRefFormat())) {
      refModel.set$ref(processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat()));
    }
 else {
      processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
    }
  }
  Map<String,Property> subProps=model.getProperties();
  if (subProps != null) {
    for (    Map.Entry<String,Property> prop : subProps.entrySet()) {
      if (prop.getValue() instanceof RefProperty) {
        RefProperty subRef=(RefProperty)prop.getValue();
        if (isAnExternalRefFormat(subRef.getRefFormat())) {
          subRef.set$ref(processRefToExternalDefinition(subRef.get$ref(),subRef.getRefFormat()));
        }
 else {
          processRefToExternalDefinition(file + subRef.get$ref(),RefFormat.RELATIVE);
        }
      }
    }
  }
  if (existingModel == null) {
    swagger.addDefinition(newRef,model);
  }
  return newRef;
}","public String processRefToExternalDefinition(String $ref,RefFormat refFormat){
  final Model model=cache.loadRef($ref,refFormat,Model.class);
  String newRef;
  Map<String,Model> definitions=swagger.getDefinitions();
  if (definitions == null) {
    definitions=new HashMap<>();
  }
  final String possiblyConflictingDefinitionName=computeDefinitionName($ref);
  final Model existingModel=definitions.get(possiblyConflictingDefinitionName);
  if (existingModel != null) {
    LOGGER.debug(""String_Node_Str"" + existingModel + ""String_Node_Str"");
  }
  newRef=possiblyConflictingDefinitionName;
  cache.putRenamedRef($ref,newRef);
  String file=$ref.split(""String_Node_Str"")[0];
  if (model instanceof RefModel) {
    RefModel refModel=(RefModel)model;
    if (isAnExternalRefFormat(refModel.getRefFormat())) {
      refModel.set$ref(processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat()));
    }
 else {
      processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
    }
  }
  Map<String,Property> subProps=model.getProperties();
  if (subProps != null) {
    for (    Map.Entry<String,Property> prop : subProps.entrySet()) {
      if (prop.getValue() instanceof RefProperty) {
        RefProperty subRef=(RefProperty)prop.getValue();
        if (isAnExternalRefFormat(subRef.getRefFormat())) {
          subRef.set$ref(processRefToExternalDefinition(subRef.get$ref(),subRef.getRefFormat()));
        }
 else {
          processRefToExternalDefinition(file + subRef.get$ref(),RefFormat.RELATIVE);
        }
      }
 else       if (prop.getValue() instanceof ArrayProperty) {
        ArrayProperty arrayProp=(ArrayProperty)prop.getValue();
        if (arrayProp.getItems() instanceof RefProperty) {
          RefProperty subRef=(RefProperty)arrayProp.getItems();
          if (isAnExternalRefFormat(subRef.getRefFormat())) {
            subRef.set$ref(processRefToExternalDefinition(subRef.get$ref(),subRef.getRefFormat()));
          }
 else {
            processRefToExternalDefinition(file + subRef.get$ref(),RefFormat.RELATIVE);
          }
        }
      }
    }
  }
  if (existingModel == null) {
    swagger.addDefinition(newRef,model);
  }
  return newRef;
}",0.8586197983975188
29676,"public String processRefToExternalDefinition(String $ref,RefFormat refFormat){
  final Model model=cache.loadRef($ref,refFormat,Model.class);
  String newRef;
  Map<String,Model> definitions=swagger.getDefinitions();
  if (definitions == null) {
    definitions=new HashMap<>();
  }
  final String possiblyConflictingDefinitionName=computeDefinitionName($ref);
  final Model existingModel=definitions.get(possiblyConflictingDefinitionName);
  if (existingModel != null) {
    LOGGER.debug(""String_Node_Str"" + existingModel + ""String_Node_Str"");
  }
  newRef=possiblyConflictingDefinitionName;
  cache.putRenamedRef($ref,newRef);
  String file=$ref.split(""String_Node_Str"")[0];
  if (model instanceof RefModel) {
    RefModel refModel=(RefModel)model;
    if (isAnExternalRefFormat(refModel.getRefFormat())) {
      refModel.set$ref(processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat()));
    }
 else {
      processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
    }
  }
  Map<String,Property> subProps=model.getProperties();
  if (subProps != null) {
    for (    Map.Entry<String,Property> prop : subProps.entrySet()) {
      if (prop.getValue() instanceof RefProperty) {
        RefProperty subRef=(RefProperty)prop.getValue();
        if (isAnExternalRefFormat(subRef.getRefFormat())) {
          subRef.set$ref(processRefToExternalDefinition(subRef.get$ref(),subRef.getRefFormat()));
        }
 else {
          processRefToExternalDefinition(file + subRef.get$ref(),RefFormat.RELATIVE);
        }
      }
 else       if (prop.getValue() instanceof ArrayProperty) {
        ArrayProperty arrayProp=(ArrayProperty)prop.getValue();
        if (arrayProp.getItems() instanceof RefProperty) {
          RefProperty subRef=(RefProperty)arrayProp.getItems();
          if (isAnExternalRefFormat(subRef.getRefFormat())) {
            subRef.set$ref(processRefToExternalDefinition(subRef.get$ref(),subRef.getRefFormat()));
          }
 else {
            processRefToExternalDefinition(file + subRef.get$ref(),RefFormat.RELATIVE);
          }
        }
      }
 else       if (prop.getValue() instanceof MapProperty) {
        MapProperty mapProp=(MapProperty)prop.getValue();
        if (mapProp.getAdditionalProperties() instanceof RefProperty) {
          RefProperty subRef=(RefProperty)mapProp.getAdditionalProperties();
          if (isAnExternalRefFormat(subRef.getRefFormat())) {
            subRef.set$ref(processRefToExternalDefinition(subRef.get$ref(),subRef.getRefFormat()));
          }
 else {
            processRefToExternalDefinition(file + subRef.get$ref(),RefFormat.RELATIVE);
          }
        }
      }
    }
  }
  if (model instanceof ArrayModel && ((ArrayModel)model).getItems() instanceof RefProperty) {
    RefProperty subRef=(RefProperty)((ArrayModel)model).getItems();
    if (isAnExternalRefFormat(subRef.getRefFormat())) {
      subRef.set$ref(processRefToExternalDefinition(subRef.get$ref(),subRef.getRefFormat()));
    }
 else {
      processRefToExternalDefinition(file + subRef.get$ref(),RefFormat.RELATIVE);
    }
  }
  if (existingModel == null) {
    swagger.addDefinition(newRef,model);
  }
  return newRef;
}","public String processRefToExternalDefinition(String $ref,RefFormat refFormat){
  final Model model=cache.loadRef($ref,refFormat,Model.class);
  String newRef;
  Map<String,Model> definitions=swagger.getDefinitions();
  if (definitions == null) {
    definitions=new HashMap<>();
  }
  final String possiblyConflictingDefinitionName=computeDefinitionName($ref);
  final Model existingModel=definitions.get(possiblyConflictingDefinitionName);
  if (existingModel != null) {
    LOGGER.debug(""String_Node_Str"" + existingModel + ""String_Node_Str"");
  }
  newRef=possiblyConflictingDefinitionName;
  cache.putRenamedRef($ref,newRef);
  if (existingModel == null) {
    swagger.addDefinition(newRef,model);
    String file=$ref.split(""String_Node_Str"")[0];
    if (model instanceof RefModel) {
      RefModel refModel=(RefModel)model;
      if (isAnExternalRefFormat(refModel.getRefFormat())) {
        refModel.set$ref(processRefToExternalDefinition(refModel.get$ref(),refModel.getRefFormat()));
      }
 else {
        processRefToExternalDefinition(file + refModel.get$ref(),RefFormat.RELATIVE);
      }
    }
    Map<String,Property> subProps=model.getProperties();
    if (subProps != null) {
      for (      Map.Entry<String,Property> prop : subProps.entrySet()) {
        if (prop.getValue() instanceof RefProperty) {
          processRefProperty((RefProperty)prop.getValue(),file);
        }
 else         if (prop.getValue() instanceof ArrayProperty) {
          ArrayProperty arrayProp=(ArrayProperty)prop.getValue();
          if (arrayProp.getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)arrayProp.getItems(),file);
          }
        }
 else         if (prop.getValue() instanceof MapProperty) {
          MapProperty mapProp=(MapProperty)prop.getValue();
          if (mapProp.getAdditionalProperties() instanceof RefProperty) {
            processRefProperty((RefProperty)mapProp.getAdditionalProperties(),file);
          }
 else           if (mapProp.getAdditionalProperties() instanceof ArrayProperty && ((ArrayProperty)mapProp.getAdditionalProperties()).getItems() instanceof RefProperty) {
            processRefProperty((RefProperty)((ArrayProperty)mapProp.getAdditionalProperties()).getItems(),file);
          }
        }
      }
    }
    if (model instanceof ArrayModel && ((ArrayModel)model).getItems() instanceof RefProperty) {
      processRefProperty((RefProperty)((ArrayModel)model).getItems(),file);
    }
  }
  return newRef;
}",0.4870575805599577
29677,"public void processPaths(){
  final Map<String,Path> pathMap=swagger.getPaths();
  if (pathMap == null) {
    return;
  }
  for (  String pathStr : pathMap.keySet()) {
    Path path=pathMap.get(pathStr);
    List<Parameter> parameters=path.getParameters();
    if (parameters != null) {
      List<Operation> operations=path.getOperations();
      List<Parameter> parametersToAdd=new ArrayList<Parameter>();
      if (operations != null) {
        for (        Operation operation : operations) {
          boolean matched=false;
          List<Parameter> existingParameters=operation.getParameters();
          for (          Parameter parameterToAdd : parameters) {
            for (            Parameter existingParameter : existingParameters) {
              if (parameterToAdd.getIn() != null && parameterToAdd.getIn().equals(existingParameter.getIn()) && parameterToAdd.getName().equals(existingParameter.getName())) {
                matched=true;
              }
            }
            if (!matched) {
              parametersToAdd.add(parameterToAdd);
            }
          }
          if (parametersToAdd.size() > 0) {
            operation.getParameters().addAll(0,parametersToAdd);
          }
        }
      }
    }
    path.setParameters(null);
    if (path instanceof RefPath) {
      RefPath refPath=(RefPath)path;
      Path resolvedPath=cache.loadRef(refPath.get$ref(),refPath.getRefFormat(),Path.class);
      if (resolvedPath != null) {
        swagger.path(pathStr,resolvedPath);
        path=resolvedPath;
      }
    }
    final List<Parameter> processedPathParameters=parameterProcessor.processParameters(path.getParameters());
    path.setParameters(processedPathParameters);
    final Map<HttpMethod,Operation> operationMap=path.getOperationMap();
    for (    HttpMethod httpMethod : operationMap.keySet()) {
      Operation operation=operationMap.get(httpMethod);
      operationProcessor.processOperation(operation);
    }
  }
}","public void processPaths(){
  final Map<String,Path> pathMap=swagger.getPaths();
  if (pathMap == null) {
    return;
  }
  for (  String pathStr : pathMap.keySet()) {
    Path path=pathMap.get(pathStr);
    List<Parameter> parameters=path.getParameters();
    if (parameters != null) {
      List<Operation> operations=path.getOperations();
      if (operations != null) {
        for (        Operation operation : operations) {
          List<Parameter> parametersToAdd=new ArrayList<Parameter>();
          boolean matched=false;
          List<Parameter> existingParameters=operation.getParameters();
          for (          Parameter parameterToAdd : parameters) {
            for (            Parameter existingParameter : existingParameters) {
              if (parameterToAdd.getIn() != null && parameterToAdd.getIn().equals(existingParameter.getIn()) && parameterToAdd.getName().equals(existingParameter.getName())) {
                matched=true;
              }
            }
            if (!matched) {
              parametersToAdd.add(parameterToAdd);
            }
          }
          if (parametersToAdd.size() > 0) {
            operation.getParameters().addAll(0,parametersToAdd);
          }
        }
      }
    }
    path.setParameters(null);
    if (path instanceof RefPath) {
      RefPath refPath=(RefPath)path;
      Path resolvedPath=cache.loadRef(refPath.get$ref(),refPath.getRefFormat(),Path.class);
      if (resolvedPath != null) {
        swagger.path(pathStr,resolvedPath);
        path=resolvedPath;
      }
    }
    final List<Parameter> processedPathParameters=parameterProcessor.processParameters(path.getParameters());
    path.setParameters(processedPathParameters);
    final Map<HttpMethod,Operation> operationMap=path.getOperationMap();
    for (    HttpMethod httpMethod : operationMap.keySet()) {
      Operation operation=operationMap.get(httpMethod);
      operationProcessor.processOperation(operation);
    }
  }
}",0.4900763358778626
29678,"public String processRefToExternalDefinition(String $ref,RefFormat refFormat){
  final Model model=cache.loadRef($ref,refFormat,Model.class);
  String newRef;
  Map<String,Model> definitions=swagger.getDefinitions();
  if (definitions == null) {
    definitions=new HashMap<>();
  }
  final String possiblyConflictingDefinitionName=computeDefinitionName($ref);
  final Model existingModel=definitions.get(possiblyConflictingDefinitionName);
  if (existingModel != null) {
    final String previouslyRenamedRef=cache.getRenamedRef($ref);
    if (previouslyRenamedRef != null) {
      newRef=previouslyRenamedRef;
    }
 else {
      String deconflictedName=deconflictName(possiblyConflictingDefinitionName,definitions);
      cache.putRenamedRef($ref,deconflictedName);
      newRef=deconflictedName;
      swagger.addDefinition(deconflictedName,model);
    }
  }
 else {
    newRef=possiblyConflictingDefinitionName;
    cache.putRenamedRef($ref,newRef);
    Map<String,Property> subProps=model.getProperties();
    if (subProps != null) {
      for (      Map.Entry<String,Property> prop : subProps.entrySet()) {
        if (prop.getValue() instanceof RefProperty) {
          RefProperty subRef=(RefProperty)prop.getValue();
          subRef.set$ref(processRefToExternalDefinition(subRef.get$ref(),subRef.getRefFormat()));
        }
      }
    }
    swagger.addDefinition(newRef,model);
  }
  return newRef;
}","public String processRefToExternalDefinition(String $ref,RefFormat refFormat){
  System.out.println(""String_Node_Str"" + $ref);
  final Model model=cache.loadRef($ref,refFormat,Model.class);
  if (model == null) {
    System.out.println(""String_Node_Str"" + $ref);
    ;
  }
  String newRef;
  Map<String,Model> definitions=swagger.getDefinitions();
  if (definitions == null) {
    definitions=new HashMap<>();
  }
  final String possiblyConflictingDefinitionName=computeDefinitionName($ref);
  final Model existingModel=definitions.get(possiblyConflictingDefinitionName);
  if (existingModel != null) {
    final String previouslyRenamedRef=cache.getRenamedRef($ref);
    if (previouslyRenamedRef != null) {
      newRef=previouslyRenamedRef;
    }
 else {
      String deconflictedName=deconflictName(possiblyConflictingDefinitionName,definitions);
      cache.putRenamedRef($ref,deconflictedName);
      newRef=deconflictedName;
      swagger.addDefinition(deconflictedName,model);
    }
  }
 else {
    newRef=possiblyConflictingDefinitionName;
    cache.putRenamedRef($ref,newRef);
    Map<String,Property> subProps=model.getProperties();
    if (subProps != null) {
      for (      Map.Entry<String,Property> prop : subProps.entrySet()) {
        if (prop.getValue() instanceof RefProperty) {
          RefProperty subRef=(RefProperty)prop.getValue();
          System.out.println(subRef.get$ref() + ""String_Node_Str"" + subRef.getRefFormat());
          if (isAnExternalRefFormat(subRef.getRefFormat()))           subRef.set$ref(processRefToExternalDefinition(subRef.get$ref(),subRef.getRefFormat()));
        }
      }
    }
    swagger.addDefinition(newRef,model);
  }
  return newRef;
}",0.9005471515931767
29679,"@Test public void testNestedExternalRefs(@Injectable final Model mockedModel){
  final RefFormat refFormat=RefFormat.URL;
  Swagger testedSwagger=new Swagger();
  final String customerURL=""String_Node_Str"";
  final Model customerModel=new ModelImpl();
  Map<String,Property> custProps=new HashMap<String,Property>();
  RefProperty address=new RefProperty();
  final String addressURL=""String_Node_Str"";
  address.set$ref(addressURL);
  custProps.put(""String_Node_Str"",address);
  customerModel.setProperties(custProps);
  final Model addressModel=new ModelImpl();
  Map<String,Property> addressProps=new HashMap<String,Property>();
  RefProperty contact=new RefProperty();
  final String contactURL=""String_Node_Str"";
  contact.set$ref(contactURL);
  addressProps.put(""String_Node_Str"",contact);
  addressModel.setProperties(addressProps);
  final Model contactModel=new ModelImpl();
  Property contactProp=new StringProperty();
  contactProp.setName(""String_Node_Str"");
  contactProp.setRequired(true);
  Map<String,Property> contactProps=new HashMap<String,Property>();
  contactProps.put(""String_Node_Str"",contactProp);
  contactModel.setProperties(contactProps);
  new Expectations(){
{
      cache.loadRef(customerURL,refFormat,Model.class);
      result=customerModel;
      times=1;
      cache.loadRef(addressURL,refFormat,Model.class);
      result=addressModel;
      times=1;
      cache.loadRef(contactURL,refFormat,Model.class);
      result=contactModel;
      times=1;
    }
  }
;
  String actualRef=new ExternalRefProcessor(cache,testedSwagger).processRefToExternalDefinition(customerURL,refFormat);
  assertTrue(testedSwagger.getDefinitions().get(""String_Node_Str"") != null);
  assertTrue(testedSwagger.getDefinitions().get(""String_Node_Str"") != null);
  assertTrue(testedSwagger.getDefinitions().get(""String_Node_Str"") != null);
  assertTrue(testedSwagger.getDefinitions().size() == 3);
}","@Test public void testNestedExternalRefs(@Injectable final Model mockedModel){
  final RefFormat refFormat=RefFormat.URL;
  Swagger testedSwagger=new Swagger();
  final String customerURL=""String_Node_Str"";
  final Model customerModel=new ModelImpl();
  Map<String,Property> custProps=new HashMap<String,Property>();
  RefProperty address=new RefProperty();
  final String addressURL=""String_Node_Str"";
  address.set$ref(addressURL);
  custProps.put(""String_Node_Str"",address);
  final String loyaltyURL=""String_Node_Str"";
  RefProperty loyaltyProp=new RefProperty();
  loyaltyProp.set$ref(loyaltyURL);
  loyaltyProp.setName(""String_Node_Str"");
  loyaltyProp.setRequired(true);
  custProps.put(""String_Node_Str"",loyaltyProp);
  customerModel.setProperties(custProps);
  final Model addressModel=new ModelImpl();
  Map<String,Property> addressProps=new HashMap<String,Property>();
  RefProperty contact=new RefProperty();
  final String contactURL=""String_Node_Str"";
  contact.set$ref(contactURL);
  addressProps.put(""String_Node_Str"",contact);
  addressModel.setProperties(addressProps);
  final Model contactModel=new ModelImpl();
  Property contactProp=new StringProperty();
  contactProp.setName(""String_Node_Str"");
  contactProp.setRequired(true);
  Map<String,Property> contactProps=new HashMap<String,Property>();
  contactProps.put(""String_Node_Str"",contactProp);
  contactModel.setProperties(contactProps);
  new Expectations(){
{
      cache.loadRef(customerURL,refFormat,Model.class);
      result=customerModel;
      times=1;
      cache.loadRef(addressURL,refFormat,Model.class);
      result=addressModel;
      times=1;
      cache.loadRef(contactURL,refFormat,Model.class);
      result=contactModel;
      times=1;
    }
  }
;
  String actualRef=new ExternalRefProcessor(cache,testedSwagger).processRefToExternalDefinition(customerURL,refFormat);
  assertTrue(testedSwagger.getDefinitions().get(""String_Node_Str"") != null);
  assertTrue(testedSwagger.getDefinitions().get(""String_Node_Str"") != null);
  assertTrue(testedSwagger.getDefinitions().get(""String_Node_Str"") != null);
}",0.9235382308845578
29680,"public String processRefToExternalDefinition(String $ref,RefFormat refFormat){
  System.out.println(""String_Node_Str"" + $ref);
  final Model model=cache.loadRef($ref,refFormat,Model.class);
  if (model == null) {
    System.out.println(""String_Node_Str"" + $ref);
    ;
  }
  String newRef;
  Map<String,Model> definitions=swagger.getDefinitions();
  if (definitions == null) {
    definitions=new HashMap<>();
  }
  final String possiblyConflictingDefinitionName=computeDefinitionName($ref);
  final Model existingModel=definitions.get(possiblyConflictingDefinitionName);
  if (existingModel != null) {
    final String previouslyRenamedRef=cache.getRenamedRef($ref);
    if (previouslyRenamedRef != null) {
      newRef=previouslyRenamedRef;
    }
 else {
      String deconflictedName=deconflictName(possiblyConflictingDefinitionName,definitions);
      cache.putRenamedRef($ref,deconflictedName);
      newRef=deconflictedName;
      swagger.addDefinition(deconflictedName,model);
    }
  }
 else {
    newRef=possiblyConflictingDefinitionName;
    cache.putRenamedRef($ref,newRef);
    Map<String,Property> subProps=model.getProperties();
    if (subProps != null) {
      for (      Map.Entry<String,Property> prop : subProps.entrySet()) {
        if (prop.getValue() instanceof RefProperty) {
          RefProperty subRef=(RefProperty)prop.getValue();
          System.out.println(subRef.get$ref() + ""String_Node_Str"" + subRef.getRefFormat());
          if (isAnExternalRefFormat(subRef.getRefFormat()))           subRef.set$ref(processRefToExternalDefinition(subRef.get$ref(),subRef.getRefFormat()));
        }
      }
    }
    swagger.addDefinition(newRef,model);
  }
  return newRef;
}","public String processRefToExternalDefinition(String $ref,RefFormat refFormat){
  final Model model=cache.loadRef($ref,refFormat,Model.class);
  String newRef;
  Map<String,Model> definitions=swagger.getDefinitions();
  if (definitions == null) {
    definitions=new HashMap<>();
  }
  final String possiblyConflictingDefinitionName=computeDefinitionName($ref);
  final Model existingModel=definitions.get(possiblyConflictingDefinitionName);
  if (existingModel != null) {
    final String previouslyRenamedRef=cache.getRenamedRef($ref);
    if (previouslyRenamedRef != null) {
      newRef=previouslyRenamedRef;
    }
 else {
      String deconflictedName=deconflictName(possiblyConflictingDefinitionName,definitions);
      cache.putRenamedRef($ref,deconflictedName);
      newRef=deconflictedName;
      swagger.addDefinition(deconflictedName,model);
    }
  }
 else {
    newRef=possiblyConflictingDefinitionName;
    cache.putRenamedRef($ref,newRef);
    Map<String,Property> subProps=model.getProperties();
    if (subProps != null) {
      for (      Map.Entry<String,Property> prop : subProps.entrySet()) {
        if (prop.getValue() instanceof RefProperty) {
          RefProperty subRef=(RefProperty)prop.getValue();
          if (isAnExternalRefFormat(subRef.getRefFormat()))           subRef.set$ref(processRefToExternalDefinition(subRef.get$ref(),subRef.getRefFormat()));
        }
      }
    }
    swagger.addDefinition(newRef,model);
  }
  return newRef;
}",0.9295863593305967
29681,"public Model definition(ObjectNode node,String location,ParseResult result){
  if (node == null) {
    result.missing(location,""String_Node_Str"");
  }
  if (node.get(""String_Node_Str"") != null) {
    return refModel(node,location,result);
  }
  if (node.get(""String_Node_Str"") != null) {
    return allOfModel(node,location,result);
  }
  Model model=null;
  String value=null;
  value=getString(""String_Node_Str"",node,false,location,result);
  model.setTitle(value);
  String type=getString(""String_Node_Str"",node,false,location,result);
  Model m=new ModelImpl();
  if (""String_Node_Str"".equals(type)) {
    ArrayModel am=new ArrayModel();
    ObjectNode propertyNode=getObject(""String_Node_Str"",node,false,location,result);
    Map<String,Property> properties=properties(propertyNode,location,result);
    am.setProperties(properties);
    ObjectNode itemsNode=getObject(""String_Node_Str"",node,false,location,result);
    Property items=property(itemsNode,location,result);
    if (items != null) {
      am.items(items);
    }
    model=am;
  }
 else {
    ModelImpl impl=new ModelImpl();
    impl.setType(value);
    JsonNode ap=node.get(""String_Node_Str"");
    if (ap != null && ap.getNodeType().equals(JsonNodeType.OBJECT)) {
      impl.setAdditionalProperties(Json.mapper().convertValue(ap,Property.class));
    }
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDefaultValue(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setFormat(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDescription(value);
    JsonNode xml=node.get(""String_Node_Str"");
    if (xml != null) {
      impl.setXml(Json.mapper().convertValue(xml,Xml.class));
    }
    ObjectNode externalDocs=getObject(""String_Node_Str"",node,false,location,result);
    ExternalDocs docs=externalDocs(externalDocs,location,result);
    impl.setExternalDocs(docs);
    ObjectNode properties=getObject(""String_Node_Str"",node,true,location,result);
    if (properties != null) {
      Set<String> propertyNames=getKeys(properties);
      for (      String propertyName : propertyNames) {
        JsonNode propertyNode=properties.get(propertyName);
        if (propertyNode.getNodeType().equals(JsonNodeType.OBJECT)) {
          ObjectNode on=(ObjectNode)propertyNode;
          Property property=property(on,location,result);
          impl.property(propertyName,property);
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",propertyNode);
        }
      }
    }
    ArrayNode required=getArray(""String_Node_Str"",node,false,location,result);
    if (required != null) {
      List<String> requiredProperties=new ArrayList<String>();
      for (      JsonNode n : required) {
        if (n.getNodeType().equals(JsonNodeType.STRING)) {
          requiredProperties.add(((TextNode)n).textValue());
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
        }
      }
      if (requiredProperties.size() > 0) {
        impl.setRequired(requiredProperties);
      }
    }
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        impl.setVendorExtension(key,extension(node.get(key)));
      }
 else       if (!SCHEMA_KEYS.contains(key)) {
        result.extra(location,key,node.get(key));
      }
    }
    if (""String_Node_Str"".equals(Json.pretty(impl)))     return null;
    model=impl;
  }
  JsonNode exampleNode=node.get(""String_Node_Str"");
  if (exampleNode != null) {
    if (exampleNode.getNodeType().equals(JsonNodeType.OBJECT)) {
      ObjectNode on=getObject(""String_Node_Str"",node,false,location,result);
      if (on != null) {
        model.setExample(on);
      }
    }
 else {
      model.setExample(exampleNode.asText());
    }
  }
  value=getString(""String_Node_Str"",node,false,location,result);
  model.setDescription(value);
  return model;
}","public Model definition(ObjectNode node,String location,ParseResult result){
  if (node == null) {
    result.missing(location,""String_Node_Str"");
  }
  if (node.get(""String_Node_Str"") != null) {
    return refModel(node,location,result);
  }
  if (node.get(""String_Node_Str"") != null) {
    return allOfModel(node,location,result);
  }
  Model model=null;
  String value=null;
  String type=getString(""String_Node_Str"",node,false,location,result);
  Model m=new ModelImpl();
  if (""String_Node_Str"".equals(type)) {
    ArrayModel am=new ArrayModel();
    ObjectNode propertyNode=getObject(""String_Node_Str"",node,false,location,result);
    Map<String,Property> properties=properties(propertyNode,location,result);
    am.setProperties(properties);
    ObjectNode itemsNode=getObject(""String_Node_Str"",node,false,location,result);
    Property items=property(itemsNode,location,result);
    if (items != null) {
      am.items(items);
    }
    model=am;
  }
 else {
    ModelImpl impl=new ModelImpl();
    impl.setType(value);
    JsonNode ap=node.get(""String_Node_Str"");
    if (ap != null && ap.getNodeType().equals(JsonNodeType.OBJECT)) {
      impl.setAdditionalProperties(Json.mapper().convertValue(ap,Property.class));
    }
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDefaultValue(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setFormat(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    impl.setDescription(value);
    JsonNode xml=node.get(""String_Node_Str"");
    if (xml != null) {
      impl.setXml(Json.mapper().convertValue(xml,Xml.class));
    }
    ObjectNode externalDocs=getObject(""String_Node_Str"",node,false,location,result);
    ExternalDocs docs=externalDocs(externalDocs,location,result);
    impl.setExternalDocs(docs);
    ObjectNode properties=getObject(""String_Node_Str"",node,true,location,result);
    if (properties != null) {
      Set<String> propertyNames=getKeys(properties);
      for (      String propertyName : propertyNames) {
        JsonNode propertyNode=properties.get(propertyName);
        if (propertyNode.getNodeType().equals(JsonNodeType.OBJECT)) {
          ObjectNode on=(ObjectNode)propertyNode;
          Property property=property(on,location,result);
          impl.property(propertyName,property);
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",propertyNode);
        }
      }
    }
    ArrayNode required=getArray(""String_Node_Str"",node,false,location,result);
    if (required != null) {
      List<String> requiredProperties=new ArrayList<String>();
      for (      JsonNode n : required) {
        if (n.getNodeType().equals(JsonNodeType.STRING)) {
          requiredProperties.add(((TextNode)n).textValue());
        }
 else {
          result.invalidType(location,""String_Node_Str"",""String_Node_Str"",n);
        }
      }
      if (requiredProperties.size() > 0) {
        impl.setRequired(requiredProperties);
      }
    }
    Set<String> keys=getKeys(node);
    for (    String key : keys) {
      if (key.startsWith(""String_Node_Str"")) {
        impl.setVendorExtension(key,extension(node.get(key)));
      }
 else       if (!SCHEMA_KEYS.contains(key)) {
        result.extra(location,key,node.get(key));
      }
    }
    if (""String_Node_Str"".equals(Json.pretty(impl)))     return null;
    model=impl;
  }
  JsonNode exampleNode=node.get(""String_Node_Str"");
  if (exampleNode != null) {
    if (exampleNode.getNodeType().equals(JsonNodeType.OBJECT)) {
      ObjectNode on=getObject(""String_Node_Str"",node,false,location,result);
      if (on != null) {
        model.setExample(on);
      }
    }
 else {
      model.setExample(exampleNode.asText());
    }
  }
  if (model != null) {
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setDescription(value);
    value=getString(""String_Node_Str"",node,false,location,result);
    model.setTitle(value);
  }
  return model;
}",0.9695907896383432
29682,"public Property propertyFromTypedObject(ExtendedTypedObject obj){
  String type=obj.getType() == null ? null : obj.getType().toString();
  String format=obj.getFormat() == null ? null : obj.getFormat().toString();
  Property output=null;
  if (""String_Node_Str"".equals(type)) {
    ArrayProperty am=new ArrayProperty();
    Items items=obj.getItems();
    if (items == null) {
      System.out.println(""String_Node_Str"");
      Json.prettyPrint(obj);
      items=new Items();
      items.setType(""String_Node_Str"");
    }
    type=items.getType() == null ? null : items.getType().toString();
    format=items.getFormat() == null ? null : items.getFormat().toString();
    Property innerType=PropertyBuilder.build(type,format,null);
    if (innerType != null)     am.setItems(innerType);
 else     if (items.getRef() != null) {
      am.setItems(new RefProperty(items.getRef()));
    }
 else     am.setItems(new RefProperty(type));
    output=am;
  }
 else {
    Map<String,Object> args=new HashMap<String,Object>();
    if (obj.getEnumValues() != null && obj.getEnumValues().size() > 0) {
      args.put(""String_Node_Str"",obj.getEnumValues());
    }
    if (obj.getMinimum() != null) {
      args.put(""String_Node_Str"",Double.parseDouble(obj.getMinimum()));
    }
    if (obj.getMaximum() != null) {
      args.put(""String_Node_Str"",Double.parseDouble(obj.getMaximum()));
    }
    Property i=PropertyBuilder.build(type,format,args);
    if (i != null)     output=i;
 else {
      if (obj.getRef() != null)       output=new RefProperty(obj.getRef());
 else       if (type != null)       output=new RefProperty(type);
 else       output=new RefProperty(""String_Node_Str"");
    }
  }
  return output;
}","public Property propertyFromTypedObject(ExtendedTypedObject obj){
  String type=obj.getType() == null ? null : obj.getType().toString();
  String format=obj.getFormat() == null ? null : obj.getFormat().toString();
  Property output=null;
  if (""String_Node_Str"".equals(type)) {
    ArrayProperty am=new ArrayProperty();
    Items items=obj.getItems();
    if (items == null) {
      System.out.println(""String_Node_Str"");
      Json.prettyPrint(obj);
      items=new Items();
      items.setType(""String_Node_Str"");
    }
    type=items.getType() == null ? null : items.getType().toString();
    format=items.getFormat() == null ? null : items.getFormat().toString();
    Property innerType=PropertyBuilder.build(type,format,null);
    if (innerType != null)     am.setItems(innerType);
 else     if (items.getRef() != null) {
      am.setItems(new RefProperty(items.getRef()));
    }
 else     am.setItems(new RefProperty(type));
    output=am;
  }
 else {
    Map<String,Object> args=new HashMap<String,Object>();
    if (obj.getEnumValues() != null && obj.getEnumValues().size() > 0) {
      args.put(""String_Node_Str"",obj.getEnumValues());
    }
    if (obj.getMinimum() != null) {
      args.put(""String_Node_Str"",Double.parseDouble(obj.getMinimum()));
    }
    if (obj.getMaximum() != null) {
      args.put(""String_Node_Str"",Double.parseDouble(obj.getMaximum()));
    }
    Property i=PropertyBuilder.build(type,format,args);
    if (i != null)     output=i;
 else {
      if (obj.getRef() != null)       output=new RefProperty(obj.getRef());
 else       if (type != null && !type.equals(""String_Node_Str""))       output=new RefProperty(type);
    }
  }
  return output;
}",0.9633136094674556
29683,"public static String urlToString(String url,List<AuthorizationValue> auths) throws Exception {
  InputStream is=null;
  URLConnection conn=null;
  BufferedReader br=null;
  try {
    if (auths != null) {
      StringBuilder queryString=new StringBuilder();
      for (      AuthorizationValue auth : auths) {
        if (""String_Node_Str"".equals(auth.getType())) {
          if (queryString.toString().length() == 0)           queryString.append(""String_Node_Str"");
 else           queryString.append(""String_Node_Str"");
          queryString.append(URLEncoder.encode(auth.getKeyName(),""String_Node_Str"")).append(""String_Node_Str"").append(URLEncoder.encode(auth.getValue(),""String_Node_Str""));
        }
      }
      if (queryString.toString().length() != 0)       url=url + queryString.toString();
      conn=new URL(url).openConnection();
      for (      AuthorizationValue auth : auths) {
        if (""String_Node_Str"".equals(auth.getType())) {
          conn.setRequestProperty(auth.getKeyName(),auth.getValue());
        }
      }
    }
 else {
      conn=new URL(url).openConnection();
    }
    StringBuilder sb=new StringBuilder();
    String line;
    is=conn.getInputStream();
    br=new BufferedReader(new InputStreamReader(is));
    while ((line=br.readLine()) != null) {
      sb.append(line);
    }
    return sb.toString();
  }
 catch (  javax.net.ssl.SSLProtocolException e) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    throw e;
  }
catch (  Exception e) {
    e.printStackTrace();
    throw e;
  }
 finally {
    if (is != null)     is.close();
    if (br != null)     br.close();
  }
}","public static String urlToString(String url,List<AuthorizationValue> auths) throws Exception {
  InputStream is=null;
  URLConnection conn=null;
  BufferedReader br=null;
  try {
    if (auths != null) {
      StringBuilder queryString=new StringBuilder();
      for (      AuthorizationValue auth : auths) {
        if (""String_Node_Str"".equals(auth.getType())) {
          if (queryString.toString().length() == 0)           queryString.append(""String_Node_Str"");
 else           queryString.append(""String_Node_Str"");
          queryString.append(URLEncoder.encode(auth.getKeyName(),""String_Node_Str"")).append(""String_Node_Str"").append(URLEncoder.encode(auth.getValue(),""String_Node_Str""));
        }
      }
      if (queryString.toString().length() != 0)       url=url + queryString.toString();
      conn=new URL(url).openConnection();
      for (      AuthorizationValue auth : auths) {
        if (""String_Node_Str"".equals(auth.getType())) {
          conn.setRequestProperty(auth.getKeyName(),auth.getValue());
        }
      }
    }
 else {
      conn=new URL(url).openConnection();
    }
    StringBuilder sb=new StringBuilder();
    String line;
    is=conn.getInputStream();
    br=new BufferedReader(new InputStreamReader(is));
    while ((line=br.readLine()) != null) {
      sb.append(line).append(""String_Node_Str"");
    }
    return sb.toString();
  }
 catch (  javax.net.ssl.SSLProtocolException e) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    throw e;
  }
catch (  Exception e) {
    e.printStackTrace();
    throw e;
  }
 finally {
    if (is != null)     is.close();
    if (br != null)     br.close();
  }
}",0.9923076923076924
29684,"/** 
 * Return a migrator renaming object members <p>Note that this migrator will not fail if the member to rename does not exists; however it <strong>will</strong> fail if the <em>target</em> member already exists in the target JSON Object.</p>
 * @param from the member name to rename
 * @param to the new name
 * @return a migrator
 */
public static SwaggerMigrator renameMember(final String from,final String to){
  Objects.requireNonNull(from);
  Objects.requireNonNull(to);
  return new SwaggerMigrator(){
    @Nonnull @Override public JsonNode migrate(    @Nonnull final JsonNode input){
      Objects.requireNonNull(input);
      if (!input.has(from))       return input;
      if (input.has(to))       throw new UncheckedSwaggerTransformException();
      final ObjectNode ret=input.deepCopy();
      ret.put(to,ret.get(from));
      ret.remove(from);
      return ret;
    }
  }
;
}","/** 
 * Return a migrator renaming object members <p>Note that this migrator will not fail if the member to rename does not exists; however it <strong>will</strong> fail if the <em>target</em> member already exists in the target JSON Object.</p>
 * @param from the member name to rename
 * @param to the new name
 * @return a migrator
 */
public static SwaggerMigrator renameMember(final String from,final String to){
  Objects.requireNonNull(from);
  Objects.requireNonNull(to);
  return new SwaggerMigrator(){
    @Nonnull @Override public JsonNode migrate(    @Nonnull final JsonNode input) throws SwaggerTransformException {
      Objects.requireNonNull(input);
      if (!input.has(from))       return input;
      if (input.has(to))       throw new SwaggerTransformException(""String_Node_Str"" + ""String_Node_Str"" + to + '""');
      final ObjectNode ret=input.deepCopy();
      ret.put(to,ret.get(from));
      ret.remove(from);
      return ret;
    }
  }
;
}",0.8120624663435649
29685,"@Nonnull @Override public JsonNode migrate(@Nonnull final JsonNode input) throws SwaggerMigrationException {
  Objects.requireNonNull(input);
  final MutableJsonTree tree=new MutableJsonTree(input);
  SwaggerMigrator migrator;
  migrator=membersToString(""String_Node_Str"",""String_Node_Str"");
  tree.applyMigrator(migrator);
  migrator=patchFromResource(""String_Node_Str"");
  tree.applyMigrator(migrator);
  return tree.getBaseNode();
}","@Nonnull @Override public JsonNode migrate(@Nonnull final JsonNode input) throws SwaggerMigrationException {
  Objects.requireNonNull(input);
  final MutableJsonTree tree=new MutableJsonTree(input);
  SwaggerMigrator migrator;
  migrator=membersToString(""String_Node_Str"",""String_Node_Str"");
  tree.applyMigrator(migrator);
  migrator=patchFromResource(""String_Node_Str"");
  tree.applyMigrator(migrator);
  if (input.path(""String_Node_Str"").isTextual()) {
    String basePath=input.get(""String_Node_Str"").textValue();
    ((ObjectNode)tree.getCurrentNode()).remove(""String_Node_Str"");
    try {
      basePath=checkLegalBasePath(basePath);
    }
 catch (    IllegalArgumentException e) {
      throw new SwaggerMigrationException(e.getMessage());
    }
    migrator=new PathAppenderMigrator(basePath);
    tree.setPointer(JsonPointer.of(""String_Node_Str""));
    tree.applyMigratorToElements(migrator);
  }
  return tree.getBaseNode();
}",0.6010211524434719
29686,"@Nonnull @Override public JsonNode migrate(@Nonnull final JsonNode input) throws SwaggerTransformException {
  Objects.requireNonNull(input,""String_Node_Str"");
  final ObjectNode ret=input.deepCopy();
  JsonNode node;
  for (  final String memberName : memberNames) {
    node=input.path(memberName);
    if (node.isMissingNode())     continue;
    if (node.isContainerNode())     throw new UncheckedSwaggerTransformException(""String_Node_Str"");
    if (!node.isTextual())     ret.put(memberName,node.asText());
  }
  return ret;
}","@Nonnull @Override public JsonNode migrate(@Nonnull final JsonNode input) throws SwaggerTransformException {
  Objects.requireNonNull(input,""String_Node_Str"");
  final ObjectNode ret=input.deepCopy();
  JsonNode node;
  for (  final String memberName : memberNames) {
    node=input.path(memberName);
    if (node.isMissingNode())     continue;
    if (node.isContainerNode())     throw new SwaggerTransformException(""String_Node_Str"" + ""String_Node_Str"");
    if (!node.isTextual())     ret.put(memberName,node.asText());
  }
  return ret;
}",0.972972972972973
29687,"public V11TypeMigrator(){
  try {
    final JsonNode node=JsonLoader.fromResource(""String_Node_Str"");
    patches=MAPPER.readValue(node.traverse(),TYPE_REF);
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","public V11TypeMigrator(){
  try {
    JsonNode node;
    node=JsonLoader.fromResource(""String_Node_Str"");
    patches=MAPPER.readValue(node.traverse(),TYPE_REF);
    node=JsonLoader.fromResource(""String_Node_Str"");
    fileTypePatch=MAPPER.readValue(node.traverse(),JsonPatch.class);
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.7774193548387097
29688,"@Nonnull @Override public JsonNode migrate(@Nonnull final JsonNode input) throws SwaggerMigrationException {
  Objects.requireNonNull(input);
  final JsonNode node=input.path(""String_Node_Str"");
  if (node.isMissingNode())   return input;
  if (!node.isTextual())   throw new SwaggerMigrationException(""String_Node_Str"");
  final String dataType=node.textValue();
  final JsonPatch patch=Optional.fromNullable(patches.get(dataType)).or(DEFAULT_PATCH);
  return SwaggerMigrators.fromPatch(patch).migrate(input);
}","@Nonnull @Override public JsonNode migrate(@Nonnull final JsonNode input) throws SwaggerMigrationException {
  Objects.requireNonNull(input);
  final JsonNode node=input.path(""String_Node_Str"");
  if (node.isMissingNode())   return postMigrate(input);
  if (!node.isTextual())   throw new SwaggerMigrationException(""String_Node_Str"");
  final String dataType=node.textValue();
  final JsonPatch patch=Optional.fromNullable(patches.get(dataType)).or(DEFAULT_PATCH);
  final JsonNode migrated=SwaggerMigrators.fromPatch(patch).migrate(input);
  return postMigrate(migrated);
}",0.9208103130755064
29689,"@Nonnull @Override public JsonNode migrate(@Nonnull final JsonNode input) throws SwaggerTransformException {
  final MutableJsonTree tree=new MutableJsonTree(input);
  tree.applyMigrator(renameMember(""String_Node_Str"",""String_Node_Str""));
  tree.setPointer(PARAMETERS);
  tree.applyMigratorToElements(parametersMigrator);
  return tree.getBaseNode();
}","@Nonnull @Override public JsonNode migrate(@Nonnull final JsonNode input) throws SwaggerTransformException {
  final MutableJsonTree tree=new MutableJsonTree(input);
  tree.applyMigrator(renameMember(""String_Node_Str"",""String_Node_Str""));
  tree.applyMigrator(renameMember(""String_Node_Str"",""String_Node_Str""));
  JsonPointer ptr=JsonPointer.of(""String_Node_Str"");
  if (!ptr.path(tree.getBaseNode()).isMissingNode()) {
    tree.setPointer(ptr);
    tree.applyMigratorToElements(renameMember(""String_Node_Str"",""String_Node_Str""));
  }
  tree.setPointer(PARAMETERS);
  tree.applyMigratorToElements(parametersMigrator);
  return tree.getBaseNode();
}",0.704
29690,"public TAUnit readTA(int partition,int unit,boolean withlog) throws X10FlashException, IOException {
  if (!_bundle.simulate()) {
    String command=""String_Node_Str"" + partition + ""String_Node_Str""+ unit;
    logger.info(""String_Node_Str"" + command);
    USBFlash.write(command.getBytes());
    CommandPacket reply=USBFlash.readCommandReply(true);
    logger.info(""String_Node_Str"" + reply.getResponse());
    if (reply.getResponse().equals(""String_Node_Str"")) {
      TAUnit taunit=new TAUnit(unit,reply.getDataArray());
      return taunit;
    }
 else {
      logger.warn(""String_Node_Str"" + reply.getMessage() + ""String_Node_Str""+ HexDump.toHex(unit)+ ""String_Node_Str"");
    }
  }
  return null;
}","public TAUnit readTA(int partition,int unit,boolean withlog) throws X10FlashException, IOException {
  if (!_bundle.simulate()) {
    String command=""String_Node_Str"" + partition + ""String_Node_Str""+ unit;
    if (withlog)     logger.info(""String_Node_Str"" + command);
    USBFlash.write(command.getBytes());
    CommandPacket reply=USBFlash.readCommandReply(true);
    if (withlog)     logger.info(""String_Node_Str"" + reply.getResponse());
    if (reply.getResponse().equals(""String_Node_Str"")) {
      TAUnit taunit=new TAUnit(unit,reply.getDataArray());
      return taunit;
    }
 else {
      if (withlog)       logger.warn(""String_Node_Str"" + reply.getMessage() + ""String_Node_Str""+ HexDump.toHex(unit)+ ""String_Node_Str"");
    }
  }
  return null;
}",0.9636737491432488
29691,"public void writeTA(int partition,TAUnit unit) throws X10FlashException, IOException {
  try {
    logger.info(""String_Node_Str"" + HexDump.toHex(unit.getUnitNumber()) + ""String_Node_Str""+ partition);
    if (!_bundle.simulate()) {
      logger.info(""String_Node_Str"" + HexDump.toHex(unit.getDataLength()));
      String command=""String_Node_Str"" + HexDump.toHex(unit.getDataLength());
      USBFlash.write(command.getBytes());
      CommandPacket p=USBFlash.readCommandReply(false);
      if (unit.getDataLength() > 0) {
        USBFlash.write(unit.getUnitData());
      }
      p=USBFlash.readCommandReply(true);
      logger.info(""String_Node_Str"" + p.getResponse());
      logger.info(""String_Node_Str"" + partition + ""String_Node_Str""+ unit.getUnitNumber());
      command=""String_Node_Str"" + partition + ""String_Node_Str""+ unit.getUnitNumber();
      USBFlash.write(command.getBytes());
      p=USBFlash.readCommandReply(true);
      logger.info(""String_Node_Str"" + p.getResponse());
    }
  }
 catch (  Exception e) {
  }
}","public void writeTA(int partition,TAUnit unit) throws X10FlashException, IOException {
  try {
    logger.info(""String_Node_Str"" + HexDump.toHex((int)unit.getUnitNumber()) + ""String_Node_Str""+ partition);
    if (!_bundle.simulate()) {
      logger.info(""String_Node_Str"" + HexDump.toHex(unit.getDataLength()));
      String command=""String_Node_Str"" + HexDump.toHex(unit.getDataLength());
      USBFlash.write(command.getBytes());
      CommandPacket p=USBFlash.readCommandReply(false);
      if (unit.getDataLength() > 0) {
        USBFlash.write(unit.getUnitData());
      }
      p=USBFlash.readCommandReply(true);
      logger.info(""String_Node_Str"" + p.getResponse());
      logger.info(""String_Node_Str"" + partition + ""String_Node_Str""+ unit.getUnitNumber());
      command=""String_Node_Str"" + partition + ""String_Node_Str""+ unit.getUnitNumber();
      USBFlash.write(command.getBytes());
      p=USBFlash.readCommandReply(true);
      logger.info(""String_Node_Str"" + p.getResponse());
    }
  }
 catch (  Exception e) {
  }
}",0.997573993207181
29692,"private void backupTA(int partition,String timestamp){
  logger.info(""String_Node_Str"" + partition);
  String folder=OS.getFolderRegisteredDevices() + File.separator + getPhoneProperty(""String_Node_Str"")+ File.separator+ ""String_Node_Str""+ File.separator+ timestamp;
  new File(folder).mkdirs();
  TextFile tazone=new TextFile(folder + File.separator + partition+ ""String_Node_Str"",""String_Node_Str"");
  try {
    tazone.open(false);
  }
 catch (  Exception e1) {
    logger.error(""String_Node_Str"");
    return;
  }
  try {
    tazone.writeln(HexDump.toHex((byte)partition));
    for (int unit=0; unit < 12000; unit++) {
      LogProgress.updateProgress();
      try {
        TAUnit taunit=this.readTA(partition,unit,false);
        if (taunit != null)         tazone.writeln(taunit.toString());
      }
 catch (      Exception e3) {
      }
    }
    tazone.close();
    logger.info(""String_Node_Str"" + partition + ""String_Node_Str""+ folder+ File.separator+ partition+ ""String_Node_Str"");
  }
 catch (  Exception e) {
  }
}","private void backupTA(int partition,String timestamp){
  logger.info(""String_Node_Str"" + partition);
  String folder=OS.getFolderRegisteredDevices() + File.separator + getPhoneProperty(""String_Node_Str"")+ File.separator+ ""String_Node_Str""+ File.separator+ timestamp;
  new File(folder).mkdirs();
  TextFile tazone=new TextFile(folder + File.separator + partition+ ""String_Node_Str"",""String_Node_Str"");
  try {
    tazone.open(false);
  }
 catch (  Exception e1) {
    logger.error(""String_Node_Str"");
    return;
  }
  try {
    tazone.writeln(HexDump.toHex((byte)partition));
    for (int unit=0; unit < 12000; unit++) {
      LogProgress.updateProgress();
      try {
        TAUnit taunit=this.readTA(partition,unit,false);
        if (taunit != null)         tazone.writeln(taunit.toString());
      }
 catch (      Exception e3) {
        e3.printStackTrace();
      }
    }
    tazone.close();
    logger.info(""String_Node_Str"" + partition + ""String_Node_Str""+ folder+ File.separator+ partition+ ""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9738965353583294
29693,"public void flashImage(SinFile sin,String partitionname) throws X10FlashException, IOException {
  String command=""String_Node_Str"";
  logger.info(""String_Node_Str"" + sin.getName());
  if (!_bundle.simulate()) {
    command=""String_Node_Str"" + HexDump.toHex(sin.getHeader().length);
    logger.info(""String_Node_Str"" + command);
    USBFlash.write(command.getBytes());
    CommandPacket p=USBFlash.readCommandReply(false);
    USBFlash.write(sin.getHeader());
    p=USBFlash.readCommandReply(true);
    logger.info(""String_Node_Str"" + p.getResponse());
    command=""String_Node_Str"" + partitionname;
    logger.info(""String_Node_Str"" + command);
    USBFlash.write(command.getBytes());
    p=USBFlash.readCommandReply(true);
    logger.info(""String_Node_Str"" + p.getStatus());
  }
  TarArchiveInputStream tarIn=new TarArchiveInputStream(new GzipCompressorInputStream(new FileInputStream(sin.getFile())));
  TarArchiveEntry entry=null;
  while ((entry=tarIn.getNextTarEntry()) != null) {
    if (!entry.getName().endsWith(""String_Node_Str"")) {
      logger.info(""String_Node_Str"" + entry.getName());
      if (!_bundle.simulate()) {
        command=""String_Node_Str"" + HexDump.toHex((int)entry.getSize());
        logger.info(""String_Node_Str"" + command);
        USBFlash.write(command.getBytes());
        CommandPacket p=USBFlash.readCommandReply(false);
      }
      CircularByteBuffer cb=new CircularByteBuffer(CircularByteBuffer.INFINITE_SIZE);
      IOUtils.copy(tarIn,cb.getOutputStream());
      LogProgress.initProgress(cb.getAvailable() / USBFlash.getUSBBufferSize() + 1);
      while (cb.getAvailable() > 0) {
        byte[] buffer=new byte[cb.getAvailable() >= USBFlash.getUSBBufferSize() ? USBFlash.getUSBBufferSize() : cb.getAvailable()];
        cb.getInputStream().read(buffer);
        LogProgress.updateProgress();
        if (!_bundle.simulate()) {
          USBFlash.write(buffer);
        }
 else {
          try {
            Thread.sleep(50);
          }
 catch (          Exception e) {
          }
        }
      }
      if (!_bundle.simulate()) {
        CommandPacket p=USBFlash.readCommandReply(true);
        logger.info(""String_Node_Str"" + p.getResponse());
      }
      if (!_bundle.simulate()) {
        command=""String_Node_Str"" + partitionname;
        logger.info(""String_Node_Str"" + command);
        USBFlash.write(command.getBytes());
        CommandPacket p=USBFlash.readCommandReply(true);
        logger.info(""String_Node_Str"" + p.getResponse());
      }
      LogProgress.initProgress(0);
    }
  }
  tarIn.close();
}","public void flashImage(SinFile sin,String partitionname) throws X10FlashException, IOException {
  String command=""String_Node_Str"";
  logger.info(""String_Node_Str"" + sin.getName());
  if (!_bundle.simulate()) {
    command=""String_Node_Str"" + HexDump.toHex(sin.getHeader().length);
    logger.info(""String_Node_Str"" + command);
    USBFlash.write(command.getBytes());
    CommandPacket p=USBFlash.readCommandReply(false);
    USBFlash.write(sin.getHeader());
    p=USBFlash.readCommandReply(true);
    logger.info(""String_Node_Str"" + p.getResponse());
    command=""String_Node_Str"" + partitionname;
    logger.info(""String_Node_Str"" + command);
    USBFlash.write(command.getBytes());
    p=USBFlash.readCommandReply(true);
    logger.info(""String_Node_Str"" + p.getResponse());
  }
  TarArchiveInputStream tarIn=new TarArchiveInputStream(new GzipCompressorInputStream(new FileInputStream(sin.getFile())));
  TarArchiveEntry entry=null;
  while ((entry=tarIn.getNextTarEntry()) != null) {
    if (!entry.getName().endsWith(""String_Node_Str"")) {
      logger.info(""String_Node_Str"" + entry.getName());
      if (!_bundle.simulate()) {
        command=""String_Node_Str"" + HexDump.toHex((int)entry.getSize());
        logger.info(""String_Node_Str"" + command);
        USBFlash.write(command.getBytes());
        CommandPacket p=USBFlash.readCommandReply(false);
      }
      CircularByteBuffer cb=new CircularByteBuffer(CircularByteBuffer.INFINITE_SIZE);
      IOUtils.copy(tarIn,cb.getOutputStream());
      LogProgress.initProgress(cb.getAvailable() / USBFlash.getUSBBufferSize() + 1);
      while (cb.getAvailable() > 0) {
        byte[] buffer=new byte[cb.getAvailable() >= USBFlash.getUSBBufferSize() ? USBFlash.getUSBBufferSize() : cb.getAvailable()];
        cb.getInputStream().read(buffer);
        LogProgress.updateProgress();
        if (!_bundle.simulate()) {
          USBFlash.write(buffer);
        }
 else {
          try {
            Thread.sleep(50);
          }
 catch (          Exception e) {
          }
        }
      }
      if (!_bundle.simulate()) {
        CommandPacket p=USBFlash.readCommandReply(true);
        logger.info(""String_Node_Str"" + p.getResponse());
      }
      if (!_bundle.simulate()) {
        command=""String_Node_Str"" + partitionname;
        logger.info(""String_Node_Str"" + command);
        USBFlash.write(command.getBytes());
        CommandPacket p=USBFlash.readCommandReply(true);
        logger.info(""String_Node_Str"" + p.getResponse());
      }
      LogProgress.initProgress(0);
    }
  }
  tarIn.close();
}",0.9972688255950058
29694,"public void addData(byte[] datachunk){
  for (int i=0; i < datachunk.length; i++) {
    if (bresponse.toByteArray().length < 4) {
      bresponse.write(datachunk[i]);
      if (response.length() == 0 && bresponse.toByteArray().length == 4) {
        response=new String(bresponse.toByteArray());
      }
    }
 else {
      if (response.equals(""String_Node_Str"") || response.equals(""String_Node_Str"")) {
        bdata.write(datachunk[i]);
      }
 else       if (response.equals(""String_Node_Str"")) {
        if (blength.toByteArray().length < 8) {
          blength.write(datachunk[i]);
          if (length == -1 && blength.toByteArray().length == 8) {
            length=BytesUtil.getInt(blength.toByteArray());
          }
        }
 else {
          if (((char)datachunk[i] == 'O' || (char)datachunk[i] == 'F') && tmpdata.toByteArray().length == 0) {
            tmpdata.write(datachunk[i]);
          }
 else           if (((char)datachunk[i] == 'K' || (char)datachunk[i] == 'A') && tmpdata.toByteArray().length == 1) {
            tmpdata.write(datachunk[i]);
          }
 else           if (((char)datachunk[i] == 'A' || (char)datachunk[i] == 'I') && tmpdata.toByteArray().length == 2) {
            tmpdata.write(datachunk[i]);
          }
 else           if (((char)datachunk[i] == 'Y' || (char)datachunk[i] == 'L') && tmpdata.toByteArray().length == 3) {
            tmpdata.write(datachunk[i]);
            response=new String(tmpdata.toByteArray());
          }
 else {
            if (tmpdata.toByteArray().length > 0) {
              byte[] result=BytesUtil.concatAll(bdata.toByteArray(),tmpdata.toByteArray());
              tmpdata=new ByteArrayOutputStream();
              bdata=new ByteArrayOutputStream();
              try {
                bdata.write(result);
              }
 catch (              IOException ioe) {
              }
            }
            bdata.write(datachunk[i]);
          }
        }
      }
    }
  }
}","public void addData(byte[] datachunk){
  for (int i=0; i < datachunk.length; i++) {
    if (bresponse.toByteArray().length < 4) {
      bresponse.write(datachunk[i]);
      if (response.length() == 0 && bresponse.toByteArray().length == 4) {
        response=new String(bresponse.toByteArray());
      }
    }
 else {
      if (response.equals(""String_Node_Str"") || response.equals(""String_Node_Str"")) {
        bdata.write(datachunk[i]);
      }
 else       if (response.equals(""String_Node_Str"")) {
        if (blength.toByteArray().length < 8) {
          blength.write(datachunk[i]);
          if (length == -1 && blength.toByteArray().length == 8) {
            length=BytesUtil.getInt(blength.toByteArray());
          }
        }
 else {
          tmpdata.write(datachunk[i]);
          try {
            if (new String(tmpdata.toByteArray()).endsWith(""String_Node_Str"")) {
              response=""String_Node_Str"";
              bdata.write(Arrays.copyOf(tmpdata.toByteArray(),tmpdata.toByteArray().length - 4));
            }
            if (new String(tmpdata.toByteArray()).endsWith(""String_Node_Str"")) {
              response=""String_Node_Str"";
              bdata.write(Arrays.copyOf(tmpdata.toByteArray(),tmpdata.toByteArray().length - 4));
            }
          }
 catch (          Exception e) {
          }
        }
      }
    }
  }
}",0.5013607499244028
29695,"public XMLBootDelivery(File xmlsource) throws IOException, JDOMException {
  SAXBuilder builder=new SAXBuilder();
  FileInputStream fin=new FileInputStream(xmlsource);
  Document document=builder.build(fin);
  String spaceid=document.getRootElement().getAttribute(""String_Node_Str"").getValue();
  bootversion=document.getRootElement().getAttribute(""String_Node_Str"").getValue().replaceAll(spaceid,""String_Node_Str"").trim();
  if (bootversion.startsWith(""String_Node_Str""))   bootversion=bootversion.substring(1);
  Iterator<Element> i=document.getRootElement().getChildren().iterator();
  while (i.hasNext()) {
    Element e=i.next();
    XMLBootConfig c=new XMLBootConfig(e.getAttributeValue(""String_Node_Str""));
    c.setTA(e.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getAttributeValue(""String_Node_Str""));
    Iterator<Element> files=e.getChild(""String_Node_Str"").getChildren().iterator();
    while (files.hasNext()) {
      c.addFile(files.next().getAttributeValue(""String_Node_Str""));
    }
    c.setAttributes(e.getChild(""String_Node_Str"").getAttributeValue(""String_Node_Str""));
    bootconfigs.add(c);
  }
  fin.close();
}","public XMLBootDelivery(File xmlsource) throws IOException, JDOMException {
  SAXBuilder builder=new SAXBuilder();
  FileInputStream fin=new FileInputStream(xmlsource);
  Document document=builder.build(fin);
  String spaceid=document.getRootElement().getAttribute(""String_Node_Str"").getValue();
  bootversion=document.getRootElement().getAttribute(""String_Node_Str"").getValue().replaceAll(spaceid,""String_Node_Str"").trim();
  if (bootversion.startsWith(""String_Node_Str""))   bootversion=bootversion.substring(1);
  Iterator<Element> i=document.getRootElement().getChildren().iterator();
  while (i.hasNext()) {
    Element e=i.next();
    XMLBootConfig c=new XMLBootConfig(e.getAttributeValue(""String_Node_Str""));
    if (e.getChild(""String_Node_Str"").getChild(""String_Node_Str"") != null) {
      c.setTA(e.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getAttributeValue(""String_Node_Str""));
    }
    Iterator<Element> files=e.getChild(""String_Node_Str"").getChildren().iterator();
    while (files.hasNext()) {
      c.addFile(files.next().getAttributeValue(""String_Node_Str""));
    }
    c.setAttributes(e.getChild(""String_Node_Str"").getAttributeValue(""String_Node_Str""));
    bootconfigs.add(c);
  }
  fin.close();
}",0.9641803624104508
29696,"public Enumeration<Object> getFiles(){
  Properties flist=new Properties();
  Enumeration<XMLBootConfig> e=bootconfigs.elements();
  while (e.hasMoreElements()) {
    XMLBootConfig bc=e.nextElement();
    flist.setProperty(bc.getTA(),bc.getTA());
    Iterator<String> fl=bc.getFiles().iterator();
    while (fl.hasNext()) {
      String f=fl.next();
      flist.setProperty(f,f);
    }
  }
  return flist.keys();
}","public Enumeration<Object> getFiles(){
  Properties flist=new Properties();
  Enumeration<XMLBootConfig> e=bootconfigs.elements();
  while (e.hasMoreElements()) {
    XMLBootConfig bc=e.nextElement();
    if (bc.getTA().length() > 0)     flist.setProperty(bc.getTA(),bc.getTA());
    Iterator<String> fl=bc.getFiles().iterator();
    while (fl.hasNext()) {
      String f=fl.next();
      flist.setProperty(f,f);
    }
  }
  return flist.keys();
}",0.9198606271777005
29697,"public TAUnit readTA(int partition,int unit) throws X10FlashException, IOException {
  logger.info(""String_Node_Str"" + unit + ""String_Node_Str""+ partition);
  if (!_bundle.simulate()) {
    String command=""String_Node_Str"" + partition + ""String_Node_Str""+ unit;
    logger.info(command);
    USBFlash.write(command.getBytes());
    logger.info(""String_Node_Str"");
    CommandPacket reply=USBFlash.readCommandReply();
    logger.info(""String_Node_Str"" + reply.getMessage());
  }
  return null;
}","public TAUnit readTA(int partition,int unit) throws X10FlashException, IOException {
  if (!_bundle.simulate()) {
    String command=""String_Node_Str"" + partition + ""String_Node_Str""+ unit;
    USBFlash.write(command.getBytes());
    CommandPacket reply=USBFlash.readCommandReply();
    if (reply.getStatus() == 1) {
      logger.info(""String_Node_Str"" + unit + ""String_Node_Str""+ partition);
      TAUnit taunit=new TAUnit(unit,reply.getMessage().getBytes());
      return taunit;
    }
  }
  return null;
}",0.5528942115768463
29698,"public void backupTA(){
}","private void backupTA(int partition,String timestamp){
  logger.info(""String_Node_Str"" + partition);
  String folder=OS.getFolderRegisteredDevices() + File.separator + getPhoneProperty(""String_Node_Str"")+ File.separator+ ""String_Node_Str""+ File.separator+ timestamp;
  new File(folder).mkdirs();
  TextFile tazone=new TextFile(folder + File.separator + partition+ ""String_Node_Str"",""String_Node_Str"");
  try {
    tazone.open(false);
  }
 catch (  Exception e1) {
    logger.error(""String_Node_Str"");
    return;
  }
  try {
    tazone.writeln(HexDump.toHex((byte)partition));
    for (int unit=0; unit < 8000; unit++) {
      LogProgress.updateProgress();
      try {
        TAUnit taunit=this.readTA(partition,unit);
        if (taunit != null)         tazone.writeln(taunit.toString());
      }
 catch (      Exception e3) {
      }
    }
    tazone.close();
    logger.info(""String_Node_Str"" + partition + ""String_Node_Str""+ folder+ File.separator+ partition+ ""String_Node_Str"");
  }
 catch (  Exception e) {
  }
}",0.0383141762452107
29699,"public void loadProperties(){
  phoneprops=new Properties();
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",HexDump.toHex(getRootKeyHash().getBytes()).replaceAll(""String_Node_Str"",""String_Node_Str""));
    logger.info(""String_Node_Str"" + phoneprops.getProperty(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
}","public void loadProperties(){
  phoneprops=new Properties();
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
    phoneprops.setProperty(""String_Node_Str"",phoneprops.getProperty(""String_Node_Str"").split(""String_Node_Str"")[1]);
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
    phoneprops.setProperty(""String_Node_Str"",phoneprops.getProperty(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",getVar(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
  try {
    phoneprops.setProperty(""String_Node_Str"",HexDump.toHex(getRootKeyHash().getBytes()).replaceAll(""String_Node_Str"",""String_Node_Str""));
    logger.info(""String_Node_Str"" + phoneprops.getProperty(""String_Node_Str""));
  }
 catch (  Exception e) {
  }
}",0.9695985832349469
29700,"public void close(){
}","public void close(){
  try {
    sync();
    powerDown();
  }
 catch (  Exception e) {
  }
  USBFlash.close();
}",0.3283582089552239
29701,"public void runScript(){
  try {
    TextFile tf=new TextFile(getFlashScript(),""String_Node_Str"");
    logger.info(""String_Node_Str"" + tf.getFileName());
    Map<Integer,String> map=tf.getMap();
    Iterator<Integer> keys=map.keySet().iterator();
    writeTA(2,new TAUnit(10100,new byte[]{0x01}));
    while (keys.hasNext()) {
      String param1=""String_Node_Str"";
      String param2=""String_Node_Str"";
      String line=map.get(keys.next());
      String[] parsed=line.split(""String_Node_Str"");
      String action=parsed[0];
      if (parsed.length > 1)       param1=parsed[1];
      if (parsed.length > 2)       param2=parsed[2];
      if (action.equals(""String_Node_Str"")) {
        BundleEntry b=_bundle.searchEntry(param2);
        if (b != null) {
          SinFile sin=new SinFile(new File(b.getAbsolutePath()));
          flashImage(sin,param1);
        }
 else {
          if (bc != null) {
            String file=bc.getMatchingFile(param2);
            if (file != null) {
              SinFile sin=new SinFile(new File(file));
              flashImage(sin,param1);
            }
 else {
              logger.warn(param2 + ""String_Node_Str"");
            }
          }
 else {
            logger.warn(param2 + ""String_Node_Str"");
          }
        }
      }
 else       if (action.equals(""String_Node_Str"")) {
        if (pd != null) {
          String file=pd.getMatchingFile(param2);
          if (file != null) {
            SinFile sin=new SinFile(new File(file));
            repartition(sin,Integer.parseInt(param1));
          }
 else {
            logger.warn(param2 + ""String_Node_Str"");
          }
        }
 else {
          logger.warn(param2 + ""String_Node_Str"");
        }
      }
 else       if (action.equals(""String_Node_Str"")) {
        if (Integer.parseInt(param1) == 2)         if (TaPartition2.get(Long.parseLong(param2)) != null) {
          writeTA(2,TaPartition2.get(Long.parseLong(param2)));
        }
 else {
          if (!param2.equals(""String_Node_Str"") && !param2.equals(""String_Node_Str""))           logger.warn(""String_Node_Str"" + param2 + ""String_Node_Str"");
        }
      }
    }
    String result=ZonedDateTime.now().format(DateTimeFormatter.ofPattern(""String_Node_Str""));
    TAUnit tau=new TAUnit(10021,BytesUtil.concatAll(result.getBytes(),new byte[]{0x00}));
    writeTA(2,tau);
    writeTA(2,new TAUnit(10100,new byte[]{0x00}));
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void runScript(){
  try {
    TextFile tf=new TextFile(getFlashScript(),""String_Node_Str"");
    logger.info(""String_Node_Str"" + tf.getFileName());
    Map<Integer,String> map=tf.getMap();
    Iterator<Integer> keys=map.keySet().iterator();
    setFlashState(true);
    while (keys.hasNext()) {
      String param1=""String_Node_Str"";
      String param2=""String_Node_Str"";
      String line=map.get(keys.next());
      String[] parsed=line.split(""String_Node_Str"");
      String action=parsed[0];
      if (parsed.length > 1)       param1=parsed[1];
      if (parsed.length > 2)       param2=parsed[2];
      if (action.equals(""String_Node_Str"")) {
        BundleEntry b=_bundle.searchEntry(param2);
        if (b != null) {
          SinFile sin=new SinFile(new File(b.getAbsolutePath()));
          flashImage(sin,param1);
        }
 else {
          if (bc != null) {
            String file=bc.getMatchingFile(param2);
            if (file != null) {
              SinFile sin=new SinFile(new File(file));
              flashImage(sin,param1);
            }
 else {
              logger.warn(param2 + ""String_Node_Str"");
            }
          }
 else {
            logger.warn(param2 + ""String_Node_Str"");
          }
        }
      }
 else       if (action.equals(""String_Node_Str"")) {
        if (pd != null) {
          String file=pd.getMatchingFile(param2);
          if (file != null) {
            SinFile sin=new SinFile(new File(file));
            repartition(sin,Integer.parseInt(param1));
          }
 else {
            logger.warn(param2 + ""String_Node_Str"");
          }
        }
 else {
          logger.warn(param2 + ""String_Node_Str"");
        }
      }
 else       if (action.equals(""String_Node_Str"")) {
        if (Integer.parseInt(param1) == 2)         if (TaPartition2.get(Long.parseLong(param2)) != null) {
          writeTA(2,TaPartition2.get(Long.parseLong(param2)));
        }
 else {
          if (!param2.equals(""String_Node_Str"") && !param2.equals(""String_Node_Str""))           logger.warn(""String_Node_Str"" + param2 + ""String_Node_Str"");
        }
      }
    }
    setFlashState(false);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.929510670403104
29702,"public void flash() throws X10FlashException, IOException {
  try {
    logger.info(""String_Node_Str"");
    loadProperties();
    bc=getBootConfig();
    pd=_bundle.getXMLPartitionDelivery();
    if (pd != null)     pd.setFolder(_bundle.getPartitionDelivery().getFolder());
 else {
      String result=WidgetTask.openYESNOBox(_curshell,""String_Node_Str"");
      if (Integer.parseInt(result) != SWT.YES)       throw new X10FlashException(""String_Node_Str"");
    }
    loadTAFiles();
    if (hasScript()) {
      if (checkScript())       runScript();
    }
 else {
      logger.error(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
  }
  LogProgress.initProgress(0);
  sync();
  powerDown();
  DeviceChangedListener.pause(false);
}","public void flash() throws X10FlashException, IOException {
  try {
    logger.info(""String_Node_Str"");
    bc=getBootConfig();
    pd=_bundle.getXMLPartitionDelivery();
    if (pd != null)     pd.setFolder(_bundle.getPartitionDelivery().getFolder());
 else {
      String result=WidgetTask.openYESNOBox(_curshell,""String_Node_Str"");
      if (Integer.parseInt(result) != SWT.YES)       throw new X10FlashException(""String_Node_Str"");
    }
    loadTAFiles();
    if (hasScript()) {
      if (checkScript())       runScript();
    }
 else {
      logger.error(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
  }
  LogProgress.initProgress(0);
  close();
}",0.938483547925608
29703,"public static Flasher getFlasher(Bundle b,Shell sh){
  DeviceEntry ent=Devices.getDeviceFromVariant(b.getDevice());
  if (ent.getProtocol().equals(""String_Node_Str""))   return new S1Flasher(b,sh);
  if (ent.getProtocol().equals(""String_Node_Str""))   return new CommandFlasher(b,sh);
  return null;
}","public static Flasher getFlasher(Bundle b,Shell sh){
  if (Devices.getConnectedDevice().getPid().equals(""String_Node_Str""))   return new S1Flasher(b,sh);
  if (Devices.getConnectedDevice().getPid().equals(""String_Node_Str""))   return new CommandFlasher(b,sh);
  if (Devices.getDeviceFromVariant(b.getDevice()).getProtocol().equals(""String_Node_Str""))   return new CommandFlasher(b,sh);
  return new S1Flasher(b,sh);
}",0.3659217877094972
29704,"public void closeDevice(int par){
  try {
    endSession(par);
  }
 catch (  Exception e) {
  }
  USBFlash.close();
  DeviceChangedListener.pause(false);
}","public void closeDevice(int par){
  try {
    endSession(par);
  }
 catch (  Exception e) {
  }
  USBFlash.close();
}",0.8602941176470589
29705,"public void close(){
  try {
    endSession();
  }
 catch (  Exception e) {
  }
  USBFlash.close();
  DeviceChangedListener.pause(false);
}","public void close(){
  try {
    endSession();
  }
 catch (  Exception e) {
  }
  USBFlash.close();
}",0.8416666666666667
29706,"public void addData(byte[] datachunk) throws IOException {
  JBBPBitInputStream chunkStream=new JBBPBitInputStream(new ByteArrayInputStream(datachunk));
  while (chunkStream.hasAvailableData()) {
    if (tempbuffer == null)     tempbuffer=chunkStream.readByteArray(1);
 else     tempbuffer=BytesUtil.concatAll(tempbuffer,chunkStream.readByteArray(1));
    if (!isHeaderValid()) {
      if (tempbuffer.length == 13) {
        JBBPBitInputStream headerStream=new JBBPBitInputStream(new ByteArrayInputStream(tempbuffer));
        command=headerStream.readInt(JBBPByteOrder.BIG_ENDIAN);
        flag=headerStream.readInt(JBBPByteOrder.BIG_ENDIAN);
        length=headerStream.readInt(JBBPByteOrder.BIG_ENDIAN);
        hdrcksum=(byte)headerStream.readByte();
        headerStream.close();
        tempbuffer=null;
      }
    }
 else     if (!isDataComplete()) {
      if (tempbuffer.length == length) {
        JBBPBitInputStream dataStream=new JBBPBitInputStream(new ByteArrayInputStream(tempbuffer));
        data=dataStream.readByteArray(length);
        dataStream.close();
        tempbuffer=null;
      }
    }
 else     if (!isCRCComplete()) {
      if (tempbuffer.length == 4) {
        JBBPBitInputStream crcStream=new JBBPBitInputStream(new ByteArrayInputStream(tempbuffer));
        crc32=crcStream.readByteArray(4);
        crcStream.close();
        tempbuffer=null;
      }
    }
  }
  chunkStream.close();
}","public void addData(byte[] datachunk) throws IOException {
  for (int i=0; i < datachunk.length; i++) {
    if (bcommand.toByteArray().length < 4) {
      bcommand.write(datachunk[i]);
      if (command == 0 && bcommand.toByteArray().length == 4) {
        command=BytesUtil.getInt(bcommand.toByteArray());
      }
    }
 else     if (bflag.toByteArray().length < 4) {
      bflag.write(datachunk[i]);
      if (flag == 0 && bflag.toByteArray().length == 4) {
        flag=BytesUtil.getInt(bflag.toByteArray());
      }
    }
 else     if (blength.toByteArray().length < 4) {
      blength.write(datachunk[i]);
      if (length == 0 && blength.toByteArray().length == 4) {
        length=BytesUtil.getInt(blength.toByteArray());
      }
    }
 else     if (hdrcksum == 0) {
      hdrcksum=datachunk[i];
    }
 else     if (bdata.toByteArray().length < length) {
      bdata.write(datachunk[i]);
      if (data == null && bdata.toByteArray().length == length) {
        data=bdata.toByteArray();
      }
    }
 else     if (bcrc32.toByteArray().length < 4) {
      bcrc32.write(datachunk[i]);
      if (crc32 == null && bcrc32.toByteArray().length == 4) {
        crc32=bcrc32.toByteArray();
      }
    }
  }
}",0.1612780524914416
29707,"public static void close(){
  if (OS.getName().equals(""String_Node_Str"")) {
    USBFlashWin32.windowsClose();
  }
 else   USBFlashLinux.linuxClose();
  DeviceChangedListener.pause(false);
}","public static void close(){
  if (OS.getName().equals(""String_Node_Str"")) {
    USBFlashWin32.windowsClose();
  }
 else   USBFlashLinux.linuxClose();
}",0.888235294117647
29708,"public static void open(String pid) throws IOException, Exception {
  DeviceChangedListener.pause(true);
  if (OS.getName().equals(""String_Node_Str"")) {
    USBFlashWin32.windowsOpen(pid);
  }
 else {
    USBFlashLinux.linuxOpen(pid);
  }
}","public static void open(String pid) throws IOException, Exception {
  if (OS.getName().equals(""String_Node_Str"")) {
    USBFlashWin32.windowsOpen(pid);
  }
 else {
    USBFlashLinux.linuxOpen(pid);
  }
}",0.9164785553047404
29709,"public static void windowsReadS1Reply() throws X10FlashException, IOException {
  logger.debug(""String_Node_Str"");
  S1Packet p=new S1Packet(JKernel32.readBytes(13));
  logger.debug(""String_Node_Str"");
  if (p.getDataLength() > 0)   p.addData(JKernel32.readBytes(p.getDataLength()));
  p.addData(JKernel32.readBytes(4));
  p.validate();
  logger.debug(""String_Node_Str"" + p);
  lastreply=p.getDataArray();
  lastflags=p.getFlags();
}","public static void windowsReadS1Reply() throws X10FlashException, IOException {
  logger.debug(""String_Node_Str"");
  byte[] read=JKernel32.readBytes(0x1000);
  S1Packet p=new S1Packet(read);
  while (p.hasMoreToRead()) {
    read=JKernel32.readBytes(0x1000);
    p.addData(read);
  }
  p.validate();
  logger.debug(""String_Node_Str"" + p);
  lastreply=p.getDataArray();
  lastflags=p.getFlags();
}",0.4680337756332931
29710,"public void parseDataHeader(JBBPBitInputStream sinStream) throws IOException {
  JBBPParser dataHeaderParser=JBBPParser.prepare(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  JBBPParser addrBlocksParser=JBBPParser.prepare(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  JBBPParser LZ4ABlocksParser=JBBPParser.prepare(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  try {
    dataHeader=dataHeaderParser.parse(sinStream).mapTo(DataHeader.class);
  }
 catch (  Exception e) {
    dataHeader=new DataHeader();
    dataHeader.mmcfMagic=new String(""String_Node_Str"").getBytes();
    dataHeader.gptpLen=0;
    dataHeader.mmcfLen=0;
  }
  if (new String(dataHeader.mmcfMagic).equals(""String_Node_Str"")) {
    long addrLength=dataHeader.mmcfLen - dataHeader.gptpLen;
    long read=0;
    byte[] amagic=new byte[4];
    dataBlocks=new Vector<Object>();
    while (read < addrLength) {
      sinStream.read(amagic);
      read+=4;
      if (new String(amagic).equals(""String_Node_Str"")) {
        AddrBlock addrBlock=addrBlocksParser.parse(sinStream).mapTo(AddrBlock.class);
        dataBlocks.add(addrBlock);
        read+=(addrBlock.blockLen - 4);
      }
      if (new String(amagic).equals(""String_Node_Str"")) {
        LZ4ABlock lz4aBlock=LZ4ABlocksParser.parse(sinStream).mapTo(LZ4ABlock.class);
        dataBlocks.add(lz4aBlock);
        read+=(lz4aBlock.blockLen - 4);
      }
    }
  }
 else {
    dataHeader=new DataHeader();
    dataHeader.gptpLen=0;
    dataHeader.mmcfLen=0;
  }
  dataType=getDataTypePriv();
  dataSize=getDataSizePriv();
}","public void parseDataHeader(JBBPBitInputStream sinStream) throws IOException {
  JBBPParser dataHeaderParser=JBBPParser.prepare(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  JBBPParser addrBlocksParser=JBBPParser.prepare(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  JBBPParser LZ4ABlocksParser=JBBPParser.prepare(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  try {
    byte[] mmcfmagic=new byte[4];
    sinStream.read(mmcfmagic);
    if (!new String(mmcfmagic).equals(""String_Node_Str""))     throw new Exception(""String_Node_Str"");
    sinStream.skip(-4);
    dataHeader=dataHeaderParser.parse(sinStream).mapTo(DataHeader.class);
  }
 catch (  Exception e) {
    dataHeader=new DataHeader();
    dataHeader.mmcfMagic=new String(""String_Node_Str"").getBytes();
    dataHeader.gptpLen=0;
    dataHeader.mmcfLen=0;
  }
  if (new String(dataHeader.mmcfMagic).equals(""String_Node_Str"")) {
    long addrLength=dataHeader.mmcfLen - dataHeader.gptpLen;
    long read=0;
    byte[] amagic=new byte[4];
    dataBlocks=new Vector<Object>();
    while (read < addrLength) {
      sinStream.read(amagic);
      read+=4;
      if (new String(amagic).equals(""String_Node_Str"")) {
        AddrBlock addrBlock=addrBlocksParser.parse(sinStream).mapTo(AddrBlock.class);
        dataBlocks.add(addrBlock);
        read+=(addrBlock.blockLen - 4);
      }
      if (new String(amagic).equals(""String_Node_Str"")) {
        LZ4ABlock lz4aBlock=LZ4ABlocksParser.parse(sinStream).mapTo(LZ4ABlock.class);
        dataBlocks.add(lz4aBlock);
        read+=(lz4aBlock.blockLen - 4);
      }
    }
  }
 else {
    dataHeader=new DataHeader();
    dataHeader.gptpLen=0;
    dataHeader.mmcfLen=0;
  }
  dataType=getDataTypePriv();
  dataSize=getDataSizePriv();
}",0.9489714133048356
29711,"public String getFlashScript(String version,String model){
  FilenameFilter fscFilter=new FilenameFilter(){
    public boolean accept(    File dir,    String name){
      return (name.toLowerCase().equals(filter.toLowerCase()));
    }
  }
;
  File mydevices=new File(this.getMyDeviceDir());
  File devices=new File(this.getDeviceDir());
  File[] fsc;
  filter=model + ""String_Node_Str"" + version+ ""String_Node_Str"";
  fsc=mydevices.listFiles(fscFilter);
  if (fsc.length > 0)   return fsc[0].getAbsolutePath();
  fsc=devices.listFiles(fscFilter);
  if (fsc.length > 0)   return fsc[0].getAbsolutePath();
  String[] vnumbers=version.split(""String_Node_Str"");
  for (int i=vnumbers.length; i > 0; i--) {
    filter=""String_Node_Str"";
    for (int j=0; j < i; j++) {
      filter=filter + (j > 0 ? ""String_Node_Str"" : ""String_Node_Str"") + vnumbers[j];
    }
    filter=filter + ""String_Node_Str"";
    fsc=mydevices.listFiles(fscFilter);
    if (fsc.length > 0)     return fsc[0].getAbsolutePath();
    fsc=devices.listFiles(fscFilter);
    if (fsc.length > 0)     return fsc[0].getAbsolutePath();
  }
  return ""String_Node_Str"";
}","public String getFlashScript(String version,String model){
  FilenameFilter fscFilter=new FilenameFilter(){
    public boolean accept(    File dir,    String name){
      return (name.toLowerCase().equals(filter.toLowerCase()));
    }
  }
;
  File mydevices=new File(this.getMyDeviceDir());
  File devices=new File(this.getDeviceDir());
  File[] fsc;
  filter=model + ""String_Node_Str"" + version+ ""String_Node_Str"";
  if (mydevices.exists()) {
    fsc=mydevices.listFiles(fscFilter);
    if (fsc.length > 0)     return fsc[0].getAbsolutePath();
  }
  fsc=devices.listFiles(fscFilter);
  if (fsc.length > 0)   return fsc[0].getAbsolutePath();
  String[] vnumbers=version.split(""String_Node_Str"");
  for (int i=vnumbers.length; i > 0; i--) {
    filter=""String_Node_Str"";
    for (int j=0; j < i; j++) {
      filter=filter + (j > 0 ? ""String_Node_Str"" : ""String_Node_Str"") + vnumbers[j];
    }
    filter=filter + ""String_Node_Str"";
    if (mydevices.exists()) {
      fsc=mydevices.listFiles(fscFilter);
      if (fsc.length > 0)       return fsc[0].getAbsolutePath();
    }
    fsc=devices.listFiles(fscFilter);
    if (fsc.length > 0)     return fsc[0].getAbsolutePath();
  }
  return ""String_Node_Str"";
}",0.921165381319623
29712,"public void parseDataHeader(JBBPBitInputStream sinStream) throws IOException {
  JBBPParser dataHeaderParser=JBBPParser.prepare(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  JBBPParser addrBlocksParser=JBBPParser.prepare(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  JBBPParser LZ4ABlocksParser=JBBPParser.prepare(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  dheader=sinStream.readByteArray(blocks.blocks[0].length);
  JBBPBitInputStream dheaderStream=new JBBPBitInputStream(new ByteArrayInputStream(dheader));
  if (new String(dheaderStream.readByteArray(4)).equals(""String_Node_Str"")) {
    dheaderStream.reset();
    dataHeader=dataHeaderParser.parse(dheaderStream).mapTo(DataHeader.class);
    dataHeader.addrList=dheaderStream.readByteArray(dataHeader.mmcfLen - dataHeader.gptpLen);
    JBBPBitInputStream addrListStream=new JBBPBitInputStream(new ByteArrayInputStream(dataHeader.addrList));
    byte[] amagic=new byte[4];
    dataBlocks=new Vector<Object>();
    while (addrListStream.hasAvailableData()) {
      addrListStream.read(amagic);
      if (new String(amagic).equals(""String_Node_Str"")) {
        AddrBlock addrBlock=addrBlocksParser.parse(addrListStream).mapTo(AddrBlock.class);
        dataBlocks.add(addrBlock);
      }
      if (new String(amagic).equals(""String_Node_Str"")) {
        LZ4ABlock lz4aBlock=LZ4ABlocksParser.parse(addrListStream).mapTo(LZ4ABlock.class);
        dataBlocks.add(lz4aBlock);
      }
    }
  }
 else {
    dataHeader=new DataHeader();
    dataHeader.gptpLen=0;
    dataHeader.mmcfLen=0;
  }
  dataType=getDataTypePriv();
  dataSize=getDataSizePriv();
}","public void parseDataHeader(JBBPBitInputStream sinStream) throws IOException {
  JBBPParser dataHeaderParser=JBBPParser.prepare(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  JBBPParser addrBlocksParser=JBBPParser.prepare(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  JBBPParser LZ4ABlocksParser=JBBPParser.prepare(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  dataHeader=dataHeaderParser.parse(sinStream).mapTo(DataHeader.class);
  if (new String(dataHeader.mmcfMagic).equals(""String_Node_Str"")) {
    long addrLength=dataHeader.mmcfLen - dataHeader.gptpLen;
    long read=0;
    byte[] amagic=new byte[4];
    dataBlocks=new Vector<Object>();
    while (read < addrLength) {
      sinStream.read(amagic);
      read+=4;
      if (new String(amagic).equals(""String_Node_Str"")) {
        AddrBlock addrBlock=addrBlocksParser.parse(sinStream).mapTo(AddrBlock.class);
        dataBlocks.add(addrBlock);
        read+=(addrBlock.blockLen - 4);
      }
      if (new String(amagic).equals(""String_Node_Str"")) {
        LZ4ABlock lz4aBlock=LZ4ABlocksParser.parse(sinStream).mapTo(LZ4ABlock.class);
        dataBlocks.add(lz4aBlock);
        read+=(lz4aBlock.blockLen - 4);
      }
    }
  }
 else {
    dataHeader=new DataHeader();
    dataHeader.gptpLen=0;
    dataHeader.mmcfLen=0;
  }
  dataType=getDataTypePriv();
  dataSize=getDataSizePriv();
}",0.7315789473684211
29713,"public void parseDataHeader(JBBPBitInputStream sinStream) throws IOException {
  JBBPParser dataHeaderParser=JBBPParser.prepare(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  JBBPParser addrBlocksParser=JBBPParser.prepare(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  JBBPParser LZ4ABlocksParser=JBBPParser.prepare(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  dataHeader=dataHeaderParser.parse(sinStream).mapTo(DataHeader.class);
  if (new String(dataHeader.mmcfMagic).equals(""String_Node_Str"")) {
    long addrLength=dataHeader.mmcfLen - dataHeader.gptpLen;
    long read=0;
    byte[] amagic=new byte[4];
    dataBlocks=new Vector<Object>();
    while (read < addrLength) {
      sinStream.read(amagic);
      read+=4;
      if (new String(amagic).equals(""String_Node_Str"")) {
        AddrBlock addrBlock=addrBlocksParser.parse(sinStream).mapTo(AddrBlock.class);
        dataBlocks.add(addrBlock);
        read+=(addrBlock.blockLen - 4);
      }
      if (new String(amagic).equals(""String_Node_Str"")) {
        LZ4ABlock lz4aBlock=LZ4ABlocksParser.parse(sinStream).mapTo(LZ4ABlock.class);
        dataBlocks.add(lz4aBlock);
        read+=(lz4aBlock.blockLen - 4);
      }
    }
  }
 else {
    dataHeader=new DataHeader();
    dataHeader.gptpLen=0;
    dataHeader.mmcfLen=0;
  }
  dataType=getDataTypePriv();
  dataSize=getDataSizePriv();
}","public void parseDataHeader(JBBPBitInputStream sinStream) throws IOException {
  JBBPParser dataHeaderParser=JBBPParser.prepare(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  JBBPParser addrBlocksParser=JBBPParser.prepare(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  JBBPParser LZ4ABlocksParser=JBBPParser.prepare(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  try {
    dataHeader=dataHeaderParser.parse(sinStream).mapTo(DataHeader.class);
  }
 catch (  Exception e) {
    dataHeader=new DataHeader();
    dataHeader.mmcfMagic=new String(""String_Node_Str"").getBytes();
    dataHeader.gptpLen=0;
    dataHeader.mmcfLen=0;
  }
  if (new String(dataHeader.mmcfMagic).equals(""String_Node_Str"")) {
    long addrLength=dataHeader.mmcfLen - dataHeader.gptpLen;
    long read=0;
    byte[] amagic=new byte[4];
    dataBlocks=new Vector<Object>();
    while (read < addrLength) {
      sinStream.read(amagic);
      read+=4;
      if (new String(amagic).equals(""String_Node_Str"")) {
        AddrBlock addrBlock=addrBlocksParser.parse(sinStream).mapTo(AddrBlock.class);
        dataBlocks.add(addrBlock);
        read+=(addrBlock.blockLen - 4);
      }
      if (new String(amagic).equals(""String_Node_Str"")) {
        LZ4ABlock lz4aBlock=LZ4ABlocksParser.parse(sinStream).mapTo(LZ4ABlock.class);
        dataBlocks.add(lz4aBlock);
        read+=(lz4aBlock.blockLen - 4);
      }
    }
  }
 else {
    dataHeader=new DataHeader();
    dataHeader.gptpLen=0;
    dataHeader.mmcfLen=0;
  }
  dataType=getDataTypePriv();
  dataSize=getDataSizePriv();
}",0.9419124218051832
29714,"public void sendLoader() throws FileNotFoundException, IOException, X10FlashException, SinFileException {
  if (_bundle.hasLoader()) {
    SinFile sin=new SinFile(new File(_bundle.getLoader().getAbsolutePath()));
    if (sin.getVersion() >= 2)     sin.setChunkSize(0x10000);
 else     sin.setChunkSize(0x1000);
    uploadImage(sin);
    if (!_bundle.simulate()) {
      USBFlash.readS1Reply();
    }
  }
 else   logger.warn(""String_Node_Str"");
  if (!_bundle.simulate()) {
    hookDevice(true);
    maxS1packetsize=Integer.parseInt(phoneprops.getProperty(""String_Node_Str""),16);
  }
 else   maxS1packetsize=0x080000;
  if ((maxS1packetsize / 1024) < 1024)   logger.info(""String_Node_Str"" + maxS1packetsize / 1024 + ""String_Node_Str"");
 else   logger.info(""String_Node_Str"" + maxS1packetsize / 1024 / 1024 + ""String_Node_Str"");
  if (_bundle.getMaxBuffer() == 0) {
    USBFlash.setUSBBufferSize(maxS1packetsize);
    if ((maxS1packetsize / 1024) < 1024)     logger.info(""String_Node_Str"" + maxS1packetsize / 1024 + ""String_Node_Str"");
 else     logger.info(""String_Node_Str"" + maxS1packetsize / 1024 / 1024 + ""String_Node_Str"");
  }
  if (_bundle.getMaxBuffer() == 1) {
    USBFlash.setUSBBufferSize(512 * 1024);
    logger.info(""String_Node_Str"");
  }
  if (_bundle.getMaxBuffer() == 2) {
    USBFlash.setUSBBufferSize(256 * 1024);
    logger.info(""String_Node_Str"");
  }
  if (_bundle.getMaxBuffer() == 3) {
    USBFlash.setUSBBufferSize(128 * 1024);
    logger.info(""String_Node_Str"");
  }
  if (_bundle.getMaxBuffer() == 4) {
    USBFlash.setUSBBufferSize(64 * 1024);
    logger.info(""String_Node_Str"");
  }
  if (_bundle.getMaxBuffer() == 5) {
    USBFlash.setUSBBufferSize(32 * 1024);
    logger.info(""String_Node_Str"");
  }
  LogProgress.initProgress(_bundle.getMaxProgress(maxS1packetsize));
}","public void sendLoader() throws FileNotFoundException, IOException, X10FlashException, SinFileException {
  if (!_bundle.hasLoader() || modded_loader) {
    if (modded_loader)     logger.info(""String_Node_Str"");
 else     logger.info(""String_Node_Str"");
    String loader=getDefaultLoader();
    if (new File(loader).exists()) {
      _bundle.setLoader(new File(loader));
    }
 else     logger.info(""String_Node_Str"");
  }
  if (_bundle.hasLoader()) {
    SinFile sin=new SinFile(new File(_bundle.getLoader().getAbsolutePath()));
    if (sin.getVersion() >= 2)     sin.setChunkSize(0x10000);
 else     sin.setChunkSize(0x1000);
    uploadImage(sin);
    if (!_bundle.simulate()) {
      USBFlash.readS1Reply();
    }
  }
 else   logger.warn(""String_Node_Str"");
  if (!_bundle.simulate()) {
    hookDevice(true);
    maxS1packetsize=Integer.parseInt(phoneprops.getProperty(""String_Node_Str""),16);
  }
 else   maxS1packetsize=0x080000;
  if ((maxS1packetsize / 1024) < 1024)   logger.info(""String_Node_Str"" + maxS1packetsize / 1024 + ""String_Node_Str"");
 else   logger.info(""String_Node_Str"" + maxS1packetsize / 1024 / 1024 + ""String_Node_Str"");
  if (_bundle.getMaxBuffer() == 0) {
    USBFlash.setUSBBufferSize(maxS1packetsize);
    if ((maxS1packetsize / 1024) < 1024)     logger.info(""String_Node_Str"" + maxS1packetsize / 1024 + ""String_Node_Str"");
 else     logger.info(""String_Node_Str"" + maxS1packetsize / 1024 / 1024 + ""String_Node_Str"");
  }
  if (_bundle.getMaxBuffer() == 1) {
    USBFlash.setUSBBufferSize(512 * 1024);
    logger.info(""String_Node_Str"");
  }
  if (_bundle.getMaxBuffer() == 2) {
    USBFlash.setUSBBufferSize(256 * 1024);
    logger.info(""String_Node_Str"");
  }
  if (_bundle.getMaxBuffer() == 3) {
    USBFlash.setUSBBufferSize(128 * 1024);
    logger.info(""String_Node_Str"");
  }
  if (_bundle.getMaxBuffer() == 4) {
    USBFlash.setUSBBufferSize(64 * 1024);
    logger.info(""String_Node_Str"");
  }
  if (_bundle.getMaxBuffer() == 5) {
    USBFlash.setUSBBufferSize(32 * 1024);
    logger.info(""String_Node_Str"");
  }
  LogProgress.initProgress(_bundle.getMaxProgress(maxS1packetsize));
}",0.9188361408882084
29715,"public void flashDevice(){
  try {
    logger.info(""String_Node_Str"");
    if (!_bundle.hasLoader() || modded_loader) {
      if (modded_loader)       logger.info(""String_Node_Str"");
 else       logger.info(""String_Node_Str"");
      String loader=getDefaultLoader();
      if (new File(loader).exists()) {
        _bundle.setLoader(new File(loader));
      }
 else       logger.info(""String_Node_Str"");
    }
    sendLoader();
    bc=getBootConfig();
    loadTAFiles();
    if (hasScript()) {
      if (checkScript())       runScript();
    }
 else {
      logger.info(""String_Node_Str"");
      oldFlashEngine();
    }
    logger.info(""String_Node_Str"");
    logger.info(""String_Node_Str"");
    logger.info(""String_Node_Str"");
    LogProgress.initProgress(0);
  }
 catch (  Exception ioe) {
    ioe.printStackTrace();
    closeDevice();
    logger.error(ioe.getMessage());
    logger.error(""String_Node_Str"");
    LogProgress.initProgress(0);
  }
}","public void flashDevice(){
  try {
    logger.info(""String_Node_Str"");
    sendLoader();
    bc=getBootConfig();
    loadTAFiles();
    if (hasScript()) {
      if (checkScript())       runScript();
    }
 else {
      logger.info(""String_Node_Str"");
      oldFlashEngine();
    }
    logger.info(""String_Node_Str"");
    logger.info(""String_Node_Str"");
    logger.info(""String_Node_Str"");
    LogProgress.initProgress(0);
  }
 catch (  Exception ioe) {
    ioe.printStackTrace();
    closeDevice();
    logger.error(ioe.getMessage());
    logger.error(""String_Node_Str"");
    LogProgress.initProgress(0);
  }
}",0.7830551989730423
29716,"public CDFInfoLoader(String tac8,String cda) throws MalformedURLException, IOException, ParserConfigurationException {
  userinfo=new Properties();
  userinfo.load(new URL(""String_Node_Str"").openStream());
  userinfo.setProperty(""String_Node_Str"",userinfo.getProperty(""String_Node_Str"").toLowerCase());
  doc=DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
  rootNode=doc.createElement(""String_Node_Str"");
  doc.appendChild(rootNode);
  load(tac8,cda);
  System.out.println(this);
  FirmwaresList flist=new FirmwaresList();
  NodeList nl=rootNode.getChildNodes();
  for (int i=0; i < nl.getLength(); i++) {
    Node release=nl.item(i);
    Firmware f=new Firmware(((Element)release).getAttribute(""String_Node_Str""),((Element)release).getAttribute(""String_Node_Str""));
    NodeList files=release.getChildNodes();
    for (int j=0; j < files.getLength(); j++) {
      Element file=(Element)files.item(j);
      String id=file.getAttribute(""String_Node_Str"");
      String folder=id.substring(id.length() - 3);
      String filepath=""String_Node_Str"";
      if (file.getAttribute(""String_Node_Str"").equals(""String_Node_Str"")) {
        filepath=""String_Node_Str"" + folder + ""String_Node_Str""+ file.getAttribute(""String_Node_Str"");
        filepath=filepath + ""String_Node_Str"" + NGHash.generateHash(filepath);
        FileSet fs=new FileSet();
        fs.setId(Integer.parseInt(id));
        fs.addUrl(""String_Node_Str"" + filepath + ""String_Node_Str"");
        fs.setCheckSum(Long.parseLong(file.getAttribute(""String_Node_Str"")));
        f.addFileSet(fs);
      }
 else {
        FileSet fs=new FileSet();
        fs.setId(Integer.parseInt(id));
        for (int k=1; k <= Integer.parseInt(file.getAttribute(""String_Node_Str"")); k++) {
          filepath=""String_Node_Str"" + folder + ""String_Node_Str""+ file.getAttribute(""String_Node_Str"")+ ""String_Node_Str""+ file.getAttribute(""String_Node_Str"")+ ""String_Node_Str""+ k;
          filepath=filepath + ""String_Node_Str"" + NGHash.generateHash(filepath);
          fs.addUrl(""String_Node_Str"" + filepath + ""String_Node_Str"");
        }
        fs.setCheckSum(Long.parseLong(file.getAttribute(""String_Node_Str"")));
        f.addFileSet(fs);
        ;
      }
    }
    flist.add(f);
  }
  latest=flist.getLatest();
  System.out.println(latest.getRelease() + ""String_Node_Str"" + latest.getRevision());
}","public CDFInfoLoader(String tac8,String cda) throws MalformedURLException, IOException, ParserConfigurationException {
  userinfo=new Properties();
  userinfo.load(new URL(""String_Node_Str"").openStream());
  userinfo.setProperty(""String_Node_Str"",userinfo.getProperty(""String_Node_Str"").toLowerCase());
  doc=DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
  rootNode=doc.createElement(""String_Node_Str"");
  doc.appendChild(rootNode);
  load(tac8,cda);
  FirmwaresList flist=new FirmwaresList();
  NodeList nl=rootNode.getChildNodes();
  for (int i=0; i < nl.getLength(); i++) {
    Node release=nl.item(i);
    Firmware f=new Firmware(((Element)release).getAttribute(""String_Node_Str""),((Element)release).getAttribute(""String_Node_Str""));
    NodeList files=release.getChildNodes();
    for (int j=0; j < files.getLength(); j++) {
      Element file=(Element)files.item(j);
      String id=file.getAttribute(""String_Node_Str"");
      String folder=id.substring(id.length() - 3);
      String filepath=""String_Node_Str"";
      if (file.getAttribute(""String_Node_Str"").equals(""String_Node_Str"")) {
        filepath=""String_Node_Str"" + folder + ""String_Node_Str""+ file.getAttribute(""String_Node_Str"");
        filepath=filepath + ""String_Node_Str"" + NGHash.generateHash(filepath);
        FileSet fs=new FileSet();
        fs.setId(Integer.parseInt(id));
        fs.addUrl(""String_Node_Str"" + filepath + ""String_Node_Str"");
        fs.setCheckSum(Long.parseLong(file.getAttribute(""String_Node_Str"")));
        f.addFileSet(fs);
      }
 else {
        FileSet fs=new FileSet();
        fs.setId(Integer.parseInt(id));
        for (int k=1; k <= Integer.parseInt(file.getAttribute(""String_Node_Str"")); k++) {
          filepath=""String_Node_Str"" + folder + ""String_Node_Str""+ file.getAttribute(""String_Node_Str"")+ ""String_Node_Str""+ file.getAttribute(""String_Node_Str"")+ ""String_Node_Str""+ k;
          filepath=filepath + ""String_Node_Str"" + NGHash.generateHash(filepath);
          fs.addUrl(""String_Node_Str"" + filepath + ""String_Node_Str"");
        }
        fs.setCheckSum(Long.parseLong(file.getAttribute(""String_Node_Str"")));
        f.addFileSet(fs);
        ;
      }
    }
    flist.add(f);
  }
  latest=flist.getLatest();
}",0.9753566796368353
29717,"public AutoExpandBrowserPrefix(MutatingVisitController visitController,ErrorManager errorManager){
  this.visitController=visitController;
  this.errorManager=errorManager;
  this.expansionRules=BrowserPrefixGenerator.getExpansionRules();
}","public AutoExpandBrowserPrefix(MutatingVisitController visitController){
  this.visitController=visitController;
  this.expansionRules=BrowserPrefixGenerator.getExpansionRules();
}",0.8571428571428571
29718,"@Override protected void runPass(){
  new CreateMixins(tree.getMutatingVisitController(),errorManager).runPass();
  new CreateConstantReferences(tree.getMutatingVisitController()).runPass();
  new CreateDefinitionNodes(tree.getMutatingVisitController(),errorManager).runPass();
  new CreateComponentNodes(tree.getMutatingVisitController(),errorManager).runPass();
  new AutoExpandBrowserPrefix(tree.getMutatingVisitController(),errorManager).runPass();
  CollectMixinDefinitions collectDefinitions=new CollectMixinDefinitions(tree.getMutatingVisitController(),errorManager);
  collectDefinitions.runPass();
  new ReplaceMixins(tree.getMutatingVisitController(),errorManager,collectDefinitions.getDefinitions()).runPass();
  new ProcessComponents<Object>(tree.getMutatingVisitController(),errorManager).runPass();
  CollectConstantDefinitions collectConstantDefinitionsPass=new CollectConstantDefinitions(tree);
  collectConstantDefinitionsPass.runPass();
  ReplaceConstantReferences replaceConstantReferences=new ReplaceConstantReferences(tree,collectConstantDefinitionsPass.getConstantDefinitions(),true,errorManager,false);
  replaceConstantReferences.runPass();
}","@Override protected void runPass(){
  new CreateMixins(tree.getMutatingVisitController(),errorManager).runPass();
  new CreateConstantReferences(tree.getMutatingVisitController()).runPass();
  new CreateDefinitionNodes(tree.getMutatingVisitController(),errorManager).runPass();
  new CreateComponentNodes(tree.getMutatingVisitController(),errorManager).runPass();
  new AutoExpandBrowserPrefix(tree.getMutatingVisitController()).runPass();
  CollectMixinDefinitions collectDefinitions=new CollectMixinDefinitions(tree.getMutatingVisitController(),errorManager);
  collectDefinitions.runPass();
  new ReplaceMixins(tree.getMutatingVisitController(),errorManager,collectDefinitions.getDefinitions()).runPass();
  new ProcessComponents<Object>(tree.getMutatingVisitController(),errorManager).runPass();
  CollectConstantDefinitions collectConstantDefinitionsPass=new CollectConstantDefinitions(tree);
  collectConstantDefinitionsPass.runPass();
  ReplaceConstantReferences replaceConstantReferences=new ReplaceConstantReferences(tree,collectConstantDefinitionsPass.getConstantDefinitions(),true,errorManager,false);
  replaceConstantReferences.runPass();
}",0.994394135403191
29719,"/** 
 * Finishes the source mapping for the given node at the current position. This is intended to be called immediately after the whole node is written to the buffer.
 * @param node the {@link CssNode} to be processed
 * @param endLine the last character's line number when it ends writing output
 * @param endCharIndex the last character's character index when it ends writing output
 */
@Override public void endSourceMapping(CssNode node,int endLine,int endCharIndex){
  Preconditions.checkState(node != null);
  Preconditions.checkState(endLine >= 0);
  Preconditions.checkState(endCharIndex >= 0);
  if (!mappings.isEmpty() && mappings.peek().node == node) {
    Mapping mapping=mappings.pop();
    mapping.end=new FilePosition(endLine,endCharIndex);
  }
}","/** 
 * Finishes the source mapping for the given node at the current position. This is intended to be called immediately after the whole node is written to the buffer.
 * @param node the {@link CssNode} to be processed
 * @param endLine the last character's line number when it ends writing output
 * @param endCharIndex the last character's character index when it ends writing output
 */
@Override public void endSourceMapping(CssNode node,int endLine,int endCharIndex){
  Preconditions.checkState(node != null);
  Preconditions.checkState(endLine >= 0);
  Preconditions.checkState(endCharIndex >= -1);
  if (!mappings.isEmpty() && mappings.peek().node == node) {
    Mapping mapping=mappings.pop();
    mapping.end=new FilePosition(endLine,endCharIndex);
  }
}",0.9980353634577604
29720,"/** 
 * Finishes the source mapping for the given node at the current position. This is intended to be called immediately after the whole node is written to the buffer.
 * @param node the {@link CssNode} to be processed
 * @param endLine the last character's line number when it ends writing output
 * @param endCharIndex the last character's character index when it ends writing output
 */
public void endSourceMapping(CssNode node,int endLine,int endCharIndex);","/** 
 * Finishes the source mapping for the given node at the current position. This is intended to be called immediately after the whole node is written to the buffer.
 * @param node the {@link CssNode} to be processed
 * @param endLine the last character's line number when it ends writing output
 * @param endCharIndex the last character's character index when it ends writing outputor one less than the corresponding  {@link #startSourceMapping startCharIndex} ifa source mapping is empty.
 */
public void endSourceMapping(CssNode node,int endLine,int endCharIndex);",0.8964181994191674
29721,"/** 
 * @return a map from each GSS function name to the function
 */
public static Map<String,GssFunction> getFunctionMap(){
  return ImmutableMap.<String,GssFunction>builder().put(""String_Node_Str"",new GssFunctions.AddToNumericValue()).put(""String_Node_Str"",new GssFunctions.SubtractFromNumericValue()).put(""String_Node_Str"",new GssFunctions.Mult()).put(""String_Node_Str"",new GssFunctions.Div()).put(""String_Node_Str"",new GssFunctions.MinValue()).put(""String_Node_Str"",new GssFunctions.MaxValue()).put(""String_Node_Str"",new GssFunctions.AddScalar()).put(""String_Node_Str"",new GssFunctions.SubtractScalar()).put(""String_Node_Str"",new BlendColorsHsb()).put(""String_Node_Str"",new BlendColorsRgb()).put(""String_Node_Str"",new MakeMutedColor()).put(""String_Node_Str"",new AddHsbToCssColor()).put(""String_Node_Str"",new MakeContrastingColor()).put(""String_Node_Str"",new AdjustBrightness()).put(""String_Node_Str"",new SelectFrom()).build();
}","/** 
 * @return a map from each GSS function name to the function
 */
public static Map<String,GssFunction> getFunctionMap(){
  return ImmutableMap.<String,GssFunction>builder().put(""String_Node_Str"",new GssFunctions.AddToNumericValue()).put(""String_Node_Str"",new GssFunctions.SubtractFromNumericValue()).put(""String_Node_Str"",new GssFunctions.Mult()).put(""String_Node_Str"",new GssFunctions.Div()).put(""String_Node_Str"",new GssFunctions.MinValue()).put(""String_Node_Str"",new GssFunctions.MaxValue()).put(""String_Node_Str"",new BlendColorsHsb()).put(""String_Node_Str"",new BlendColorsRgb()).put(""String_Node_Str"",new MakeMutedColor()).put(""String_Node_Str"",new AddHsbToCssColor()).put(""String_Node_Str"",new MakeContrastingColor()).put(""String_Node_Str"",new AdjustBrightness()).put(""String_Node_Str"",new SelectFrom()).build();
}",0.937962435970404
29722,"public void testMultGetCallResultString_noUnits() throws GssFunctionException {
  GssFunctions.Mult funct=new GssFunctions.Mult();
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
  GssFunctions.SubtractScalar subtractScalar=new GssFunctions.SubtractScalar();
  assertEquals(""String_Node_Str"",subtractScalar.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
  GssFunctions.AddScalar addScalar=new GssFunctions.AddScalar();
  assertEquals(""String_Node_Str"",addScalar.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
}","public void testMultGetCallResultString_noUnits() throws GssFunctionException {
  GssFunctions.Mult funct=new GssFunctions.Mult();
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
}",0.6511627906976745
29723,"public void testAddGetCallResultString() throws GssFunctionException {
  GssFunctions.AddToNumericValue funct=new GssFunctions.AddToNumericValue();
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
}","public void testAddGetCallResultString() throws GssFunctionException {
  GssFunctions.AddToNumericValue funct=new GssFunctions.AddToNumericValue();
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
}",0.8678815489749431
29724,"public void testMaxGetCallResultString() throws GssFunctionException {
  GssFunctions.MaxValue funct=new GssFunctions.MaxValue();
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
}","public void testMaxGetCallResultString() throws GssFunctionException {
  GssFunctions.MaxValue funct=new GssFunctions.MaxValue();
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
}",0.8622327790973872
29725,"public void testMinGetCallResultString() throws GssFunctionException {
  GssFunctions.MinValue funct=new GssFunctions.MinValue();
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
}","public void testMinGetCallResultString() throws GssFunctionException {
  GssFunctions.MinValue funct=new GssFunctions.MinValue();
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
}",0.8622327790973872
29726,"public void testSubGetCallResultString() throws GssFunctionException {
  GssFunctions.SubtractFromNumericValue funct=new GssFunctions.SubtractFromNumericValue();
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
}","public void testSubGetCallResultString() throws GssFunctionException {
  GssFunctions.SubtractFromNumericValue funct=new GssFunctions.SubtractFromNumericValue();
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(""String_Node_Str"",funct.getCallResultString(ImmutableList.of(""String_Node_Str"",""String_Node_Str"")));
}",0.8719646799116998
29727,"private static Size parseSize(String sizeWithUnits) throws GssFunctionException {
  int unitIndex=CharMatcher.JAVA_LETTER.indexIn(sizeWithUnits);
  String size=unitIndex > 0 ? sizeWithUnits.substring(0,unitIndex) : sizeWithUnits;
  String units=unitIndex > 0 ? sizeWithUnits.substring(unitIndex) : CssNumericNode.NO_UNITS;
  checkSize(size,units,null,null);
  return new Size(size,units);
}","private static Size parseSize(String sizeWithUnits,boolean isUnitOptional) throws GssFunctionException {
  int unitIndex=CharMatcher.JAVA_LETTER.indexIn(sizeWithUnits);
  String size=unitIndex > 0 ? sizeWithUnits.substring(0,unitIndex) : sizeWithUnits;
  String units=unitIndex > 0 ? sizeWithUnits.substring(unitIndex) : CssNumericNode.NO_UNITS;
  checkSize(size,units,null,null,isUnitOptional);
  return new Size(size,units);
}",0.9535452322738386
29728,"protected CssClassSelectorNode(CssClassSelectorNode node){
  this(node.refinerName,node.getSourceCodeLocation());
}","protected CssClassSelectorNode(CssClassSelectorNode node){
  this(node.refinerName,node.getSourceCodeLocation());
  this.setComments(node.getComments());
}",0.8518518518518519
29729,"public void testDeepCopy(){
  SourceCode sourceCode=new SourceCode(""String_Node_Str"",null);
  SourceCodeLocation location=new SourceCodeLocation(sourceCode,1,1,1,2,1,1);
  CssSelectorNode node=new CssSelectorNode(""String_Node_Str"",location);
  node.setChunk(""String_Node_Str"");
  CssClassSelectorNode refiner=new CssClassSelectorNode(""String_Node_Str"",location);
  node.getRefiners().addChildToBack(refiner);
  CssSelectorNode copy=node.deepCopy();
  assertEquals(node.getChunk(),copy.getChunk());
  assertEquals(node.getSelectorName(),copy.getSelectorName());
  assertEquals(node.getSourceCodeLocation(),copy.getSourceCodeLocation());
}","public void testDeepCopy(){
  SourceCode sourceCode=new SourceCode(""String_Node_Str"",null);
  SourceCodeLocation location=new SourceCodeLocation(sourceCode,1,1,1,2,1,1);
  CssSelectorNode node=new CssSelectorNode(""String_Node_Str"",location);
  node.setChunk(""String_Node_Str"");
  CssClassSelectorNode refiner=new CssClassSelectorNode(""String_Node_Str"",location);
  node.getRefiners().addChildToBack(refiner);
  refiner.appendComment(new CssCommentNode(""String_Node_Str"",null));
  CssSelectorNode copy=node.deepCopy();
  assertEquals(node.getChunk(),copy.getChunk());
  assertEquals(node.getSelectorName(),copy.getSelectorName());
  assertEquals(node.getSourceCodeLocation(),copy.getSourceCodeLocation());
  assertEquals(node.getRefiners().getChildAt(0).getComments(),copy.getRefiners().getChildAt(0).getComments());
}",0.8762035763411279
29730,"public float[] getStateAsHSV(){
  if (state == null) {
    float[] result={0,0,0};
    return result;
  }
  String[] stateSplit=state.split(""String_Node_Str"");
  if (stateSplit.length == 3) {
    float[] result={Float.parseFloat(stateSplit[0]),Float.parseFloat(stateSplit[1]) / 100,Float.parseFloat(stateSplit[2]) / 100};
    return result;
  }
 else {
    float[] result={0,0,0};
    return result;
  }
}","public float[] getStateAsHSV(){
  if (state == null) {
    return new float[]{0,0,0};
  }
  String[] stateSplit=state.split(""String_Node_Str"");
  if (stateSplit.length == 3) {
    return new float[]{Float.parseFloat(stateSplit[0]),Float.parseFloat(stateSplit[1]) / 100,Float.parseFloat(stateSplit[2]) / 100};
  }
 else {
    return new float[]{0,0,0};
  }
}",0.7191601049868767
29731,"/** 
 * If fullscreen is enabled and we are on at least android 4.4 set the system visibility to fullscreen + immersive + noNav
 * @author Dan Cunningham
 */
protected void checkFullscreen(){
  if (isFullscreenEnabled()) {
    int uiOptions=getWindow().getDecorView().getSystemUiVisibility();
    uiOptions|=View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
    uiOptions|=View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;
    uiOptions|=View.SYSTEM_UI_FLAG_FULLSCREEN;
    getWindow().getDecorView().setSystemUiVisibility(uiOptions);
  }
}","/** 
 * If fullscreen is enabled and we are on at least android 4.4 set the system visibility to fullscreen + immersive + noNav
 * @author Dan Cunningham
 */
protected void checkFullscreen(){
  if (isFullscreenEnabled()) {
    int uiOptions=getWindow().getDecorView().getSystemUiVisibility();
    uiOptions|=View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
      uiOptions|=View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;
      uiOptions|=View.SYSTEM_UI_FLAG_FULLSCREEN;
    }
    getWindow().getDecorView().setSystemUiVisibility(uiOptions);
  }
}",0.9338168631006346
29732,"private void loadDrawerItems(){
  mDrawerItemList.clear();
  if (mSitemapList != null) {
    mDrawerItemList.add(OpenHABDrawerItem.headerItem(getString(R.string.mainmenu_openhab_sitemaps)));
    for (    OpenHABSitemap sitemap : mSitemapList) {
      mDrawerItemList.add(new OpenHABDrawerItem(sitemap));
    }
  }
  mDrawerItemList.add(OpenHABDrawerItem.dividerItem());
  int iconColor=ContextCompat.getColor(this,R.color.colorAccent_themeDark);
  Drawable notificationDrawable=getResources().getDrawable(R.drawable.ic_notifications_black_24dp);
  notificationDrawable.setColorFilter(iconColor,PorterDuff.Mode.SRC_IN);
  if (getNotificationSettings() != null) {
    mDrawerItemList.add(OpenHABDrawerItem.menuItem(""String_Node_Str"",notificationDrawable,DRAWER_NOTIFICATIONS));
  }
  Drawable settingsDrawable=getResources().getDrawable(R.drawable.ic_settings_black_24dp);
  settingsDrawable.setColorFilter(iconColor,PorterDuff.Mode.SRC_IN);
  mDrawerItemList.add(OpenHABDrawerItem.menuItem(getString(R.string.mainmenu_openhab_preferences),settingsDrawable,DRAWER_PREFERENCES));
  Drawable aboutDrawable=getResources().getDrawable(R.drawable.ic_info_outline);
  aboutDrawable.setColorFilter(iconColor,PorterDuff.Mode.SRC_IN);
  mDrawerItemList.add(OpenHABDrawerItem.menuItem(getString(R.string.about_title),aboutDrawable,DRAWER_ABOUT));
  mDrawerAdapter.notifyDataSetChanged();
}","private void loadDrawerItems(){
  mDrawerItemList.clear();
  if (mSitemapList != null) {
    mDrawerItemList.add(OpenHABDrawerItem.headerItem(getString(R.string.mainmenu_openhab_sitemaps)));
    for (    OpenHABSitemap sitemap : mSitemapList) {
      mDrawerItemList.add(new OpenHABDrawerItem(sitemap));
    }
  }
  mDrawerItemList.add(OpenHABDrawerItem.dividerItem());
  int iconColor=ContextCompat.getColor(this,R.color.colorAccent_themeDark);
  Drawable notificationDrawable=getResources().getDrawable(R.drawable.ic_notifications_black_24dp);
  notificationDrawable.setColorFilter(iconColor,PorterDuff.Mode.SRC_IN);
  if (getNotificationSettings() != null) {
    mDrawerItemList.add(OpenHABDrawerItem.menuItem(getString(R.string.app_notifications),notificationDrawable,DRAWER_NOTIFICATIONS));
  }
  Drawable settingsDrawable=getResources().getDrawable(R.drawable.ic_settings_black_24dp);
  settingsDrawable.setColorFilter(iconColor,PorterDuff.Mode.SRC_IN);
  mDrawerItemList.add(OpenHABDrawerItem.menuItem(getString(R.string.mainmenu_openhab_preferences),settingsDrawable,DRAWER_PREFERENCES));
  Drawable aboutDrawable=getResources().getDrawable(R.drawable.ic_info_outline);
  aboutDrawable.setColorFilter(iconColor,PorterDuff.Mode.SRC_IN);
  mDrawerItemList.add(OpenHABDrawerItem.menuItem(getString(R.string.about_title),aboutDrawable,DRAWER_ABOUT));
  mDrawerAdapter.notifyDataSetChanged();
}",0.9848594087959625
29733,"protected void clientSSLSetup(Context ctx,Boolean ignoreSSLHostname,Boolean ignoreCertTrust){
  if (ignoreSSLHostname) {
    clientBuilder.hostnameVerifier(new HostnameVerifier(){
      @Override public boolean verify(      String hostname,      SSLSession session){
        return true;
      }
    }
);
  }
  X509TrustManager x509TrustManager=null;
  if (ignoreCertTrust) {
    x509TrustManager=new X509TrustManager(){
      @Override public void checkClientTrusted(      java.security.cert.X509Certificate[] chain,      String authType) throws CertificateException {
      }
      @Override public void checkServerTrusted(      java.security.cert.X509Certificate[] chain,      String authType) throws CertificateException {
      }
      @Override public java.security.cert.X509Certificate[] getAcceptedIssuers(){
        return new java.security.cert.X509Certificate[]{};
      }
    }
;
  }
 else {
    try {
      TrustManagerFactory trustManagerFactory=TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
      trustManagerFactory.init((KeyStore)null);
      TrustManager[] trustManagers=trustManagerFactory.getTrustManagers();
      for (      TrustManager trustManager : trustManagers) {
        if (trustManager instanceof X509TrustManager) {
          x509TrustManager=(X509TrustManager)trustManager;
          break;
        }
      }
    }
 catch (    Exception e) {
      Log.d(TAG,""String_Node_Str"",e);
    }
  }
  try {
    final SSLContext sslContext=SSLContext.getInstance(""String_Node_Str"");
    sslContext.init(MyKeyManager.getInstance(ctx),new TrustManager[]{x509TrustManager},new java.security.SecureRandom());
    final SSLSocketFactory sslSocketFactory=sslContext.getSocketFactory();
    clientBuilder.sslSocketFactory(sslSocketFactory,x509TrustManager);
  }
 catch (  Exception e) {
    Log.d(TAG,""String_Node_Str"",e);
  }
  client=clientBuilder.build();
}","protected void clientSSLSetup(Context ctx,Boolean ignoreSSLHostname,Boolean ignoreCertTrust){
  if (ignoreSSLHostname) {
    clientBuilder.hostnameVerifier(new HostnameVerifier(){
      @SuppressLint(""String_Node_Str"") @Override public boolean verify(      String hostname,      SSLSession session){
        return true;
      }
    }
);
  }
  X509TrustManager x509TrustManager=null;
  if (ignoreCertTrust) {
    x509TrustManager=new X509TrustManager(){
      @Override public void checkClientTrusted(      java.security.cert.X509Certificate[] chain,      String authType) throws CertificateException {
      }
      @Override public void checkServerTrusted(      java.security.cert.X509Certificate[] chain,      String authType) throws CertificateException {
      }
      @Override public java.security.cert.X509Certificate[] getAcceptedIssuers(){
        return new java.security.cert.X509Certificate[]{};
      }
    }
;
  }
 else {
    try {
      TrustManagerFactory trustManagerFactory=TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
      trustManagerFactory.init((KeyStore)null);
      TrustManager[] trustManagers=trustManagerFactory.getTrustManagers();
      for (      TrustManager trustManager : trustManagers) {
        if (trustManager instanceof X509TrustManager) {
          x509TrustManager=(X509TrustManager)trustManager;
          break;
        }
      }
    }
 catch (    Exception e) {
      Log.d(TAG,""String_Node_Str"",e);
    }
  }
  try {
    final SSLContext sslContext=SSLContext.getInstance(""String_Node_Str"");
    sslContext.init(MyKeyManager.getInstance(ctx),new TrustManager[]{x509TrustManager},new java.security.SecureRandom());
    final SSLSocketFactory sslSocketFactory=sslContext.getSocketFactory();
    clientBuilder.sslSocketFactory(sslSocketFactory,x509TrustManager);
  }
 catch (  Exception e) {
    Log.d(TAG,""String_Node_Str"",e);
  }
  client=clientBuilder.build();
}",0.9914129586260734
29734,"@Override public boolean verify(String hostname,SSLSession session){
  return true;
}","@SuppressLint(""String_Node_Str"") @Override public boolean verify(String hostname,SSLSession session){
  return true;
}",0.8374384236453202
29735,"public boolean isVolumeHandled(){
  return openHABWidgetAdapter.isVolumeHandled();
}","public boolean isVolumeHandled(){
  if (openHABWidgetAdapter != null) {
    return openHABWidgetAdapter.isVolumeHandled();
  }
  return false;
}",0.7368421052631579
29736,"public boolean onVolumeDown(){
  return openHABWidgetAdapter.onVolumeDown();
}","public boolean onVolumeDown(){
  if (openHABWidgetAdapter != null) {
    return openHABWidgetAdapter.onVolumeDown();
  }
  return false;
}",0.7222222222222222
29737,"public boolean onVolumeUp(){
  return openHABWidgetAdapter.onVolumeUp();
}","public boolean onVolumeUp(){
  if (openHABWidgetAdapter != null) {
    return openHABWidgetAdapter.onVolumeUp();
  }
  return false;
}",0.7115384615384616
29738,"/** 
 * Loads data from sitemap page URL and passes it to processContent
 * @param pageUrl  an absolute base URL of openHAB sitemap page
 * @param longPolling  enable long polling when loading page
 * @return      void
 */
public void showPage(String pageUrl,final boolean longPolling){
  Log.i(TAG,""String_Node_Str"" + pageUrl + ""String_Node_Str""+ longPolling);
  if (!longPolling)   startProgressIndicator();
  List<BasicHeader> headers=new LinkedList<BasicHeader>();
  headers.add(new BasicHeader(""String_Node_Str"",""String_Node_Str""));
  headers.add(new BasicHeader(""String_Node_Str"",""String_Node_Str""));
  if (longPolling) {
    mAsyncHttpClient.setTimeout(300000);
    headers.add(new BasicHeader(""String_Node_Str"",""String_Node_Str""));
    if (this.mAtmosphereTrackingId == null) {
      headers.add(new BasicHeader(""String_Node_Str"",""String_Node_Str""));
    }
 else {
      headers.add(new BasicHeader(""String_Node_Str"",this.mAtmosphereTrackingId));
    }
  }
 else {
    headers.add(new BasicHeader(""String_Node_Str"",""String_Node_Str""));
    mAsyncHttpClient.setTimeout(10000);
  }
  mAsyncHttpClient.get(mActivity,pageUrl,headers.toArray(new BasicHeader[]{}),null,new DocumentHttpResponseHandler(){
    @Override public void onSuccess(    int statusCode,    Header[] headers,    Document document){
      for (int i=0; i < headers.length; i++) {
        Log.i(TAG,headers[i].getName() + ""String_Node_Str"" + headers[i].getValue());
        if (headers[i].getName().equalsIgnoreCase(""String_Node_Str"")) {
          Log.i(TAG,""String_Node_Str"" + headers[i].getValue());
          OpenHABWidgetListFragment.this.mAtmosphereTrackingId=headers[i].getValue();
        }
      }
      if (document != null) {
        Log.d(TAG,""String_Node_Str"" + document.toString());
        if (!longPolling)         stopProgressIndicator();
        processContent(document,longPolling);
      }
 else {
        Log.e(TAG,""String_Node_Str"");
        showPage(displayPageUrl,true);
      }
    }
    @Override public void onFailure(    Throwable error,    String content){
      mAtmosphereTrackingId=null;
      if (!longPolling)       stopProgressIndicator();
      if (error instanceof AsyncHttpAbortException) {
        Log.d(TAG,""String_Node_Str"" + displayPageUrl + ""String_Node_Str"");
        return;
      }
      if (error instanceof SocketTimeoutException) {
        Log.d(TAG,""String_Node_Str"");
        showPage(displayPageUrl,false);
        return;
      }
 else {
        Log.e(TAG,error.getClass().toString());
        Log.e(TAG,""String_Node_Str"" + error.getClass().toString() + ""String_Node_Str"");
        networkHandler.removeCallbacks(networkRunnable);
        networkRunnable=new Runnable(){
          @Override public void run(){
            showPage(displayPageUrl,false);
          }
        }
;
        networkHandler.postDelayed(networkRunnable,10 * 1000);
      }
    }
  }
,mTag);
}","/** 
 * Loads data from sitemap page URL and passes it to processContent
 * @param pageUrl  an absolute base URL of openHAB sitemap page
 * @param longPolling  enable long polling when loading page
 * @return      void
 */
public void showPage(String pageUrl,final boolean longPolling){
  Log.i(TAG,""String_Node_Str"" + pageUrl + ""String_Node_Str""+ longPolling);
  if (!longPolling)   startProgressIndicator();
  List<BasicHeader> headers=new LinkedList<BasicHeader>();
  headers.add(new BasicHeader(""String_Node_Str"",""String_Node_Str""));
  headers.add(new BasicHeader(""String_Node_Str"",""String_Node_Str""));
  if (longPolling) {
    mAsyncHttpClient.setTimeout(300000);
    headers.add(new BasicHeader(""String_Node_Str"",""String_Node_Str""));
    if (this.mAtmosphereTrackingId == null) {
      headers.add(new BasicHeader(""String_Node_Str"",""String_Node_Str""));
    }
 else {
      headers.add(new BasicHeader(""String_Node_Str"",this.mAtmosphereTrackingId));
    }
  }
 else {
    headers.add(new BasicHeader(""String_Node_Str"",""String_Node_Str""));
    mAsyncHttpClient.setTimeout(10000);
  }
  mAsyncHttpClient.get(mActivity,pageUrl,headers.toArray(new BasicHeader[]{}),null,new DocumentHttpResponseHandler(){
    @Override public void onSuccess(    int statusCode,    Header[] headers,    Document document){
      for (int i=0; i < headers.length; i++) {
        if (headers[i].getName().equalsIgnoreCase(""String_Node_Str"")) {
          Log.i(TAG,""String_Node_Str"" + headers[i].getValue());
          OpenHABWidgetListFragment.this.mAtmosphereTrackingId=headers[i].getValue();
        }
      }
      if (document != null) {
        if (!longPolling)         stopProgressIndicator();
        processContent(document,longPolling);
      }
 else {
        Log.e(TAG,""String_Node_Str"");
        showPage(displayPageUrl,true);
      }
    }
    @Override public void onFailure(    Throwable error,    String content){
      mAtmosphereTrackingId=null;
      if (!longPolling)       stopProgressIndicator();
      if (error instanceof AsyncHttpAbortException) {
        Log.d(TAG,""String_Node_Str"" + displayPageUrl + ""String_Node_Str"");
        return;
      }
      if (error instanceof SocketTimeoutException) {
        Log.d(TAG,""String_Node_Str"");
        showPage(displayPageUrl,false);
        return;
      }
 else {
        Log.e(TAG,error.getClass().toString());
        Log.e(TAG,""String_Node_Str"" + error.getClass().toString() + ""String_Node_Str"");
        networkHandler.removeCallbacks(networkRunnable);
        networkRunnable=new Runnable(){
          @Override public void run(){
            showPage(displayPageUrl,false);
          }
        }
;
        networkHandler.postDelayed(networkRunnable,10 * 1000);
      }
    }
  }
,mTag);
}",0.708281610214577
29739,"@Override public void onSuccess(int statusCode,Header[] headers,Document document){
  for (int i=0; i < headers.length; i++) {
    Log.i(TAG,headers[i].getName() + ""String_Node_Str"" + headers[i].getValue());
    if (headers[i].getName().equalsIgnoreCase(""String_Node_Str"")) {
      Log.i(TAG,""String_Node_Str"" + headers[i].getValue());
      OpenHABWidgetListFragment.this.mAtmosphereTrackingId=headers[i].getValue();
    }
  }
  if (document != null) {
    Log.d(TAG,""String_Node_Str"" + document.toString());
    if (!longPolling)     stopProgressIndicator();
    processContent(document,longPolling);
  }
 else {
    Log.e(TAG,""String_Node_Str"");
    showPage(displayPageUrl,true);
  }
}","@Override public void onSuccess(int statusCode,Header[] headers,Document document){
  for (int i=0; i < headers.length; i++) {
    if (headers[i].getName().equalsIgnoreCase(""String_Node_Str"")) {
      Log.i(TAG,""String_Node_Str"" + headers[i].getValue());
      OpenHABWidgetListFragment.this.mAtmosphereTrackingId=headers[i].getValue();
    }
  }
  if (document != null) {
    if (!longPolling)     stopProgressIndicator();
    processContent(document,longPolling);
  }
 else {
    Log.e(TAG,""String_Node_Str"");
    showPage(displayPageUrl,true);
  }
}",0.7187751813053989
29740,"public void writeTag(Tag tag,String openhabUri){
  Log.d(TAG,""String_Node_Str"");
  TextView writeTagMessage=(TextView)findViewById(R.id.write_tag_message);
  if (openhabUri == null) {
    writeTagMessage.setText(R.string.info_write_failed);
    return;
  }
  if (openhabUri.length() == 0) {
    writeTagMessage.setText(R.string.info_write_failed);
    return;
  }
  NdefRecord[] ndefRecords;
  ndefRecords=new NdefRecord[1];
  ndefRecords[0]=NdefRecord.createUri(openhabUri);
  NdefMessage message=new NdefMessage(ndefRecords);
  NdefFormatable ndefFormatable=NdefFormatable.get(tag);
  if (ndefFormatable != null) {
    Log.d(TAG,""String_Node_Str"");
    try {
      ndefFormatable.connect();
      ndefFormatable.format(message);
      ndefFormatable.close();
      writeTagMessage.setText(R.string.info_write_tag_finished);
      autoCloseActivity();
    }
 catch (    IOException e) {
      if (e.getMessage() != null)       Log.e(TAG,e.getMessage());
      writeTagMessage.setText(R.string.info_write_failed);
    }
catch (    FormatException e) {
      Log.e(TAG,e.getMessage());
      writeTagMessage.setText(R.string.info_write_failed);
    }
  }
 else {
    Log.d(TAG,""String_Node_Str"");
    Ndef ndef=Ndef.get(tag);
    if (ndef != null) {
      try {
        Log.d(TAG,""String_Node_Str"");
        ndef.connect();
        Log.d(TAG,""String_Node_Str"");
        if (ndef.isWritable()) {
          ndef.writeNdefMessage(message);
        }
        Log.d(TAG,""String_Node_Str"");
        ndef.close();
        writeTagMessage.setText(R.string.info_write_tag_finished);
        autoCloseActivity();
      }
 catch (      IOException e) {
        if (e != null)         Log.e(TAG,e.getMessage());
      }
catch (      FormatException e) {
        Log.e(TAG,e.getMessage());
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"");
      writeTagMessage.setText(R.string.info_write_failed);
    }
  }
}","public void writeTag(Tag tag,String openhabUri){
  Log.d(TAG,""String_Node_Str"");
  TextView writeTagMessage=(TextView)findViewById(R.id.write_tag_message);
  if (openhabUri == null) {
    writeTagMessage.setText(R.string.info_write_failed);
    return;
  }
  if (openhabUri.length() == 0) {
    writeTagMessage.setText(R.string.info_write_failed);
    return;
  }
  NdefRecord[] ndefRecords;
  ndefRecords=new NdefRecord[1];
  ndefRecords[0]=NdefRecord.createUri(openhabUri);
  NdefMessage message=new NdefMessage(ndefRecords);
  NdefFormatable ndefFormatable=NdefFormatable.get(tag);
  if (ndefFormatable != null) {
    Log.d(TAG,""String_Node_Str"");
    try {
      ndefFormatable.connect();
      ndefFormatable.format(message);
      ndefFormatable.close();
      writeTagMessage.setText(R.string.info_write_tag_finished);
      autoCloseActivity();
    }
 catch (    IOException e) {
      if (e.getMessage() != null)       Log.e(TAG,e.getMessage());
      writeTagMessage.setText(R.string.info_write_failed);
    }
catch (    FormatException e) {
      Log.e(TAG,e.getMessage());
      writeTagMessage.setText(R.string.info_write_failed);
    }
  }
 else {
    Log.d(TAG,""String_Node_Str"");
    Ndef ndef=Ndef.get(tag);
    if (ndef != null) {
      try {
        Log.d(TAG,""String_Node_Str"");
        ndef.connect();
        Log.d(TAG,""String_Node_Str"");
        if (ndef.isWritable()) {
          ndef.writeNdefMessage(message);
        }
        Log.d(TAG,""String_Node_Str"");
        ndef.close();
        writeTagMessage.setText(R.string.info_write_tag_finished);
        autoCloseActivity();
      }
 catch (      IOException e) {
        if (e != null)         Log.e(TAG,e.getClass().getCanonicalName());
        writeTagMessage.setText(R.string.info_write_failed);
      }
catch (      FormatException e) {
        Log.e(TAG,e.getMessage());
        writeTagMessage.setText(R.string.info_write_failed);
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"");
      writeTagMessage.setText(R.string.info_write_failed);
    }
  }
}",0.9637699518621738
29741,"@SuppressWarnings(""String_Node_Str"") @Override public View getView(int position,View convertView,ViewGroup parent){
  final RelativeLayout widgetView;
  TextView labelTextView;
  TextView valueTextView;
  int widgetLayout;
  String[] splitString;
  OpenHABWidget openHABWidget=getItem(position);
  int screenWidth=((WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getWidth();
switch (this.getItemViewType(position)) {
case TYPE_FRAME:
    widgetLayout=R.layout.openhabwidgetlist_frameitem;
  break;
case TYPE_GROUP:
widgetLayout=R.layout.openhabwidgetlist_groupitem;
break;
case TYPE_SECTIONSWITCH:
widgetLayout=R.layout.openhabwidgetlist_sectionswitchitem;
break;
case TYPE_SWITCH:
widgetLayout=R.layout.openhabwidgetlist_switchitem;
break;
case TYPE_ROLLERSHUTTER:
widgetLayout=R.layout.openhabwidgetlist_rollershutteritem;
break;
case TYPE_TEXT:
widgetLayout=R.layout.openhabwidgetlist_textitem;
break;
case TYPE_SLIDER:
widgetLayout=R.layout.openhabwidgetlist_slideritem;
break;
case TYPE_IMAGE:
widgetLayout=R.layout.openhabwidgetlist_imageitem;
break;
case TYPE_SELECTION:
widgetLayout=R.layout.openhabwidgetlist_selectionitem;
break;
case TYPE_SETPOINT:
widgetLayout=R.layout.openhabwidgetlist_setpointitem;
break;
case TYPE_CHART:
widgetLayout=R.layout.openhabwidgetlist_chartitem;
break;
case TYPE_VIDEO:
widgetLayout=R.layout.openhabwidgetlist_videoitem;
break;
case TYPE_VIDEO_MJPEG:
widgetLayout=R.layout.openhabwidgetlist_videomjpegitem;
break;
case TYPE_WEB:
widgetLayout=R.layout.openhabwidgetlist_webitem;
break;
case TYPE_COLOR:
widgetLayout=R.layout.openhabwidgetlist_coloritem;
break;
default :
widgetLayout=R.layout.openhabwidgetlist_genericitem;
break;
}
if (convertView == null) {
widgetView=new RelativeLayout(getContext());
String inflater=Context.LAYOUT_INFLATER_SERVICE;
LayoutInflater vi;
vi=(LayoutInflater)getContext().getSystemService(inflater);
vi.inflate(widgetLayout,widgetView,true);
}
 else {
widgetView=(RelativeLayout)convertView;
}
Integer iconColor=openHABWidget.getIconColor();
Integer labelColor=openHABWidget.getLabelColor();
Integer valueColor=openHABWidget.getValueColor();
MySmartImageView widgetImage=(MySmartImageView)widgetView.findViewById(R.id.widgetimage);
if (widgetImage != null) {
if (openHABWidget.getIcon() != null) {
String iconUrl=openHABBaseUrl + ""String_Node_Str"" + Uri.encode(openHABWidget.getIcon() + ""String_Node_Str"");
widgetImage.setImageUrl(iconUrl,R.drawable.blank_icon,openHABUsername,openHABPassword);
if (iconColor != null) widgetImage.setColorFilter(iconColor);
 else widgetImage.clearColorFilter();
}
}
TextView defaultTextView=new TextView(widgetView.getContext());
labelTextView=(TextView)widgetView.findViewById(R.id.widgetlabel);
if (labelColor != null && labelTextView != null) {
Log.d(TAG,String.format(""String_Node_Str"",labelColor));
labelTextView.setTextColor(labelColor);
}
 else if (labelTextView != null) labelTextView.setTextColor(defaultTextView.getTextColors().getDefaultColor());
valueTextView=(TextView)widgetView.findViewById(R.id.widgetvalue);
if (valueColor != null && valueTextView != null) {
Log.d(TAG,String.format(""String_Node_Str"",valueColor));
valueTextView.setTextColor(valueColor);
}
 else if (valueTextView != null) valueTextView.setTextColor(defaultTextView.getTextColors().getDefaultColor());
defaultTextView=null;
switch (getItemViewType(position)) {
case TYPE_FRAME:
if (labelTextView != null) {
labelTextView.setText(openHABWidget.getLabel());
if (valueColor != null) labelTextView.setTextColor(valueColor);
}
widgetView.setClickable(false);
if (openHABWidget.getLabel().length() > 0) {
widgetView.setVisibility(View.VISIBLE);
labelTextView.setVisibility(View.VISIBLE);
}
 else {
widgetView.setVisibility(View.GONE);
labelTextView.setVisibility(View.GONE);
}
break;
case TYPE_GROUP:
if (labelTextView != null && valueTextView != null) {
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
labelTextView.setText(splitString[0]);
if (splitString.length > 1) {
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setText(""String_Node_Str"");
}
}
break;
case TYPE_SECTIONSWITCH:
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
if (splitString.length > 1 && valueTextView != null) {
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setText(""String_Node_Str"");
}
RadioGroup sectionSwitchRadioGroup=(RadioGroup)widgetView.findViewById(R.id.sectionswitchradiogroup);
sectionSwitchRadioGroup.removeAllViews();
sectionSwitchRadioGroup.setTag(openHABWidget);
Iterator<OpenHABWidgetMapping> sectionMappingIterator=openHABWidget.getMappings().iterator();
while (sectionMappingIterator.hasNext()) {
OpenHABWidgetMapping widgetMapping=sectionMappingIterator.next();
SegmentedControlButton segmentedControlButton=(SegmentedControlButton)LayoutInflater.from(sectionSwitchRadioGroup.getContext()).inflate(R.layout.openhabwidgetlist_sectionswitchitem_button,sectionSwitchRadioGroup,false);
segmentedControlButton.setText(widgetMapping.getLabel());
segmentedControlButton.setTag(widgetMapping.getCommand());
if (openHABWidget.getItem() != null && widgetMapping.getCommand() != null) {
if (widgetMapping.getCommand().equals(openHABWidget.getItem().getState())) {
segmentedControlButton.setChecked(true);
}
 else {
segmentedControlButton.setChecked(false);
}
}
 else {
segmentedControlButton.setChecked(false);
}
segmentedControlButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View view){
Log.i(TAG,""String_Node_Str"");
RadioGroup group=(RadioGroup)view.getParent();
if (group.getTag() != null) {
OpenHABWidget radioWidget=(OpenHABWidget)group.getTag();
SegmentedControlButton selectedButton=(SegmentedControlButton)view;
if (selectedButton.getTag() != null) {
sendItemCommand(radioWidget.getItem(),(String)selectedButton.getTag());
}
}
}
}
);
sectionSwitchRadioGroup.addView(segmentedControlButton);
}
sectionSwitchRadioGroup.setOnCheckedChangeListener(new OnCheckedChangeListener(){
public void onCheckedChanged(RadioGroup group,int checkedId){
OpenHABWidget radioWidget=(OpenHABWidget)group.getTag();
SegmentedControlButton selectedButton=(SegmentedControlButton)group.findViewById(checkedId);
if (selectedButton != null) {
Log.d(TAG,""String_Node_Str"" + selectedButton.getText());
Log.d(TAG,""String_Node_Str"" + (String)selectedButton.getTag());
sendItemCommand(radioWidget.getItem(),(String)selectedButton.getTag());
}
}
}
);
break;
case TYPE_SWITCH:
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
Switch switchSwitch=(Switch)widgetView.findViewById(R.id.switchswitch);
if (openHABWidget.hasItem()) {
if (openHABWidget.getItem().getStateAsBoolean()) {
switchSwitch.setChecked(true);
}
 else {
switchSwitch.setChecked(false);
}
}
switchSwitch.setTag(openHABWidget.getItem());
switchSwitch.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
Switch switchSwitch=(Switch)v;
OpenHABItem linkedItem=(OpenHABItem)switchSwitch.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) if (!switchSwitch.isChecked()) {
sendItemCommand(linkedItem,""String_Node_Str"");
}
 else {
sendItemCommand(linkedItem,""String_Node_Str"");
}
return false;
}
}
);
break;
case TYPE_COLOR:
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
ImageButton colorUpButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_up);
ImageButton colorDownButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_down);
ImageButton colorColorButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_color);
colorUpButton.setTag(openHABWidget.getItem());
colorDownButton.setTag(openHABWidget.getItem());
colorColorButton.setTag(openHABWidget.getItem());
colorUpButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(colorItem,""String_Node_Str"");
return false;
}
}
);
colorDownButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(colorItem,""String_Node_Str"");
return false;
}
}
);
colorColorButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) {
Log.d(TAG,""String_Node_Str"");
ColorPickerDialog colorDialog=new ColorPickerDialog(widgetView.getContext(),new OnColorChangedListener(){
public void colorChanged(float[] hsv,View v){
Log.d(TAG,""String_Node_Str"" + hsv[0] + ""String_Node_Str""+ hsv[1]+ ""String_Node_Str""+ hsv[2]);
String newColor=String.valueOf(hsv[0]) + ""String_Node_Str"" + String.valueOf(hsv[1] * 100)+ ""String_Node_Str""+ String.valueOf(hsv[2] * 100);
OpenHABItem colorItem=(OpenHABItem)v.getTag();
sendItemCommand(colorItem,newColor);
}
}
,colorItem.getStateAsHSV());
colorDialog.setTag(colorItem);
colorDialog.show();
}
return false;
}
}
);
break;
case TYPE_ROLLERSHUTTER:
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
ImageButton rollershutterUpButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_up);
ImageButton rollershutterStopButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_stop);
ImageButton rollershutterDownButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_down);
rollershutterUpButton.setTag(openHABWidget.getItem());
rollershutterStopButton.setTag(openHABWidget.getItem());
rollershutterDownButton.setTag(openHABWidget.getItem());
rollershutterUpButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
rollershutterStopButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
rollershutterDownButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
break;
case TYPE_TEXT:
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) if (splitString.length > 0) {
labelTextView.setText(splitString[0]);
}
 else {
labelTextView.setText(openHABWidget.getLabel());
}
if (valueTextView != null) if (splitString.length > 1) {
valueTextView.setVisibility(View.VISIBLE);
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setVisibility(View.GONE);
valueTextView.setText(""String_Node_Str"");
}
break;
case TYPE_SLIDER:
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
SeekBar sliderSeekBar=(SeekBar)widgetView.findViewById(R.id.sliderseekbar);
if (openHABWidget.hasItem()) {
sliderSeekBar.setTag(openHABWidget.getItem());
int sliderState=0;
try {
sliderState=(int)Float.parseFloat(openHABWidget.getItem().getState());
}
 catch (NumberFormatException e) {
if (e != null) {
Crittercism.logHandledException(e);
Log.e(TAG,e.getMessage());
}
if (openHABWidget.getItem().getState().equals(""String_Node_Str"")) {
sliderState=0;
}
 else if (openHABWidget.getItem().getState().equals(""String_Node_Str"")) {
sliderState=100;
}
}
sliderSeekBar.setProgress(sliderState);
sliderSeekBar.setOnSeekBarChangeListener(new OnSeekBarChangeListener(){
public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
}
public void onStartTrackingTouch(SeekBar seekBar){
Log.d(TAG,""String_Node_Str"" + seekBar.getProgress());
}
public void onStopTrackingTouch(SeekBar seekBar){
Log.d(TAG,""String_Node_Str"" + seekBar.getProgress());
OpenHABItem sliderItem=(OpenHABItem)seekBar.getTag();
if (sliderItem != null && seekBar != null) sendItemCommand(sliderItem,String.valueOf(seekBar.getProgress()));
}
}
);
}
break;
case TYPE_IMAGE:
MySmartImageView imageImage=(MySmartImageView)widgetView.findViewById(R.id.imageimage);
imageImage.setImageUrl(ensureAbsoluteURL(openHABBaseUrl,openHABWidget.getUrl()),false,openHABUsername,openHABPassword);
if (openHABWidget.getRefresh() > 0) {
imageImage.setRefreshRate(openHABWidget.getRefresh());
refreshImageList.add(imageImage);
}
break;
case TYPE_CHART:
MySmartImageView chartImage=(MySmartImageView)widgetView.findViewById(R.id.chartimage);
OpenHABItem chartItem=openHABWidget.getItem();
Random random=new Random();
String chartUrl=""String_Node_Str"";
if (chartItem != null) {
if (chartItem.getType().equals(""String_Node_Str"")) {
chartUrl=openHABBaseUrl + ""String_Node_Str"" + chartItem.getName()+ ""String_Node_Str""+ openHABWidget.getPeriod()+ ""String_Node_Str""+ String.valueOf(random.nextInt());
}
 else {
chartUrl=openHABBaseUrl + ""String_Node_Str"" + chartItem.getName()+ ""String_Node_Str""+ openHABWidget.getPeriod()+ ""String_Node_Str""+ String.valueOf(random.nextInt());
}
if (openHABWidget.getService() != null && openHABWidget.getService().length() > 0) {
chartUrl+=""String_Node_Str"" + openHABWidget.getService();
}
}
Log.d(TAG,""String_Node_Str"" + chartUrl);
if (chartImage == null) Log.e(TAG,""String_Node_Str"");
chartImage.setImageUrl(chartUrl,false,openHABUsername,openHABPassword);
ViewGroup.LayoutParams chartLayoutParams=chartImage.getLayoutParams();
chartLayoutParams.height=(int)(screenWidth / 1.88);
chartImage.setLayoutParams(chartLayoutParams);
if (openHABWidget.getRefresh() > 0) {
chartImage.setRefreshRate(openHABWidget.getRefresh());
refreshImageList.add(chartImage);
}
Log.d(TAG,""String_Node_Str"" + chartLayoutParams.width + ""String_Node_Str""+ chartLayoutParams.height);
break;
case TYPE_VIDEO:
VideoView videoVideo=(VideoView)widgetView.findViewById(R.id.videovideo);
Log.d(TAG,""String_Node_Str"" + openHABWidget.getUrl());
WindowManager wm=(WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE);
ViewGroup.LayoutParams videoLayoutParams=videoVideo.getLayoutParams();
videoLayoutParams.height=(int)(wm.getDefaultDisplay().getWidth() / 1.77);
videoVideo.setLayoutParams(videoLayoutParams);
if (!videoWidgetList.contains(videoVideo)) videoWidgetList.add(videoVideo);
if (!videoVideo.isPlaying()) {
videoVideo.setVideoURI(Uri.parse(openHABWidget.getUrl()));
videoVideo.start();
}
Log.d(TAG,""String_Node_Str"" + videoVideo.getHeight());
break;
case TYPE_VIDEO_MJPEG:
Log.d(TAG,""String_Node_Str"");
ImageView mjpegImage=(ImageView)widgetView.findViewById(R.id.mjpegimage);
MjpegStreamer mjpegStreamer=new MjpegStreamer(openHABWidget.getUrl(),this.openHABUsername,this.openHABPassword,this.getContext());
mjpegStreamer.setTargetImageView(mjpegImage);
mjpegStreamer.start();
if (!mjpegWidgetList.contains(mjpegStreamer)) mjpegWidgetList.add(mjpegStreamer);
break;
case TYPE_WEB:
WebView webWeb=(WebView)widgetView.findViewById(R.id.webweb);
if (openHABWidget.getHeight() > 0) {
ViewGroup.LayoutParams webLayoutParams=webWeb.getLayoutParams();
webLayoutParams.height=openHABWidget.getHeight() * 80;
webWeb.setLayoutParams(webLayoutParams);
}
webWeb.setWebViewClient(new WebViewClient());
webWeb.getSettings().setJavaScriptEnabled(true);
webWeb.loadUrl(openHABWidget.getUrl());
break;
case TYPE_SELECTION:
int spinnerSelectedIndex=-1;
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
Spinner selectionSpinner=(Spinner)widgetView.findViewById(R.id.selectionspinner);
ArrayList<String> spinnerArray=new ArrayList<String>();
Iterator<OpenHABWidgetMapping> mappingIterator=openHABWidget.getMappings().iterator();
while (mappingIterator.hasNext()) {
OpenHABWidgetMapping openHABWidgetMapping=mappingIterator.next();
spinnerArray.add(openHABWidgetMapping.getLabel());
if (openHABWidgetMapping.getCommand() != null && openHABWidget.getItem() != null) if (openHABWidgetMapping.getCommand().equals(openHABWidget.getItem().getState())) {
spinnerSelectedIndex=spinnerArray.size() - 1;
}
}
ArrayAdapter<String> spinnerAdapter=new ArrayAdapter<String>(this.getContext(),android.R.layout.simple_spinner_item,spinnerArray);
spinnerAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
selectionSpinner.setAdapter(spinnerAdapter);
selectionSpinner.setTag(openHABWidget);
if (spinnerSelectedIndex >= 0) selectionSpinner.setSelection(spinnerSelectedIndex);
selectionSpinner.setOnItemSelectedListener(new OnItemSelectedListener(){
public void onItemSelected(AdapterView<?> parent,View view,int index,long id){
Log.d(TAG,""String_Node_Str"" + index);
Spinner spinner=(Spinner)parent;
String selectedLabel=(String)spinner.getAdapter().getItem(index);
Log.d(TAG,""String_Node_Str"" + selectedLabel);
OpenHABWidget openHABWidget=(OpenHABWidget)parent.getTag();
if (openHABWidget != null) {
Log.d(TAG,""String_Node_Str"" + openHABWidget.getMapping(index).getLabel());
Iterator<OpenHABWidgetMapping> mappingIterator=openHABWidget.getMappings().iterator();
while (mappingIterator.hasNext()) {
OpenHABWidgetMapping openHABWidgetMapping=mappingIterator.next();
if (openHABWidgetMapping.getLabel().equals(selectedLabel)) {
Log.d(TAG,""String_Node_Str"" + openHABWidgetMapping.getCommand());
if (openHABWidget.getItem().getState() != null) if (!openHABWidget.getItem().getState().equals(openHABWidgetMapping.getCommand())) {
Log.d(TAG,""String_Node_Str"");
sendItemCommand(openHABWidget.getItem(),openHABWidgetMapping.getCommand());
}
}
}
}
}
public void onNothingSelected(AdapterView<?> arg0){
}
}
);
break;
case TYPE_SETPOINT:
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
if (valueTextView != null) if (splitString.length > 1) {
valueTextView.setVisibility(View.VISIBLE);
valueTextView.setText(splitString[1]);
}
Button setPointMinusButton=(Button)widgetView.findViewById(R.id.setpointbutton_minus);
Button setPointPlusButton=(Button)widgetView.findViewById(R.id.setpointbutton_plus);
setPointMinusButton.setTag(openHABWidget);
setPointPlusButton.setTag(openHABWidget);
setPointMinusButton.setOnClickListener(new OnClickListener(){
public void onClick(View v){
Log.d(TAG,""String_Node_Str"");
OpenHABWidget setPointWidget=(OpenHABWidget)v.getTag();
float currentValue=Float.valueOf(setPointWidget.getItem().getState()).floatValue();
currentValue=currentValue - setPointWidget.getStep();
if (currentValue < setPointWidget.getMinValue()) currentValue=setPointWidget.getMinValue();
if (currentValue > setPointWidget.getMaxValue()) currentValue=setPointWidget.getMaxValue();
sendItemCommand(setPointWidget.getItem(),String.valueOf(currentValue));
}
}
);
setPointPlusButton.setOnClickListener(new OnClickListener(){
public void onClick(View v){
Log.d(TAG,""String_Node_Str"");
OpenHABWidget setPointWidget=(OpenHABWidget)v.getTag();
float currentValue=Float.valueOf(setPointWidget.getItem().getState()).floatValue();
currentValue=currentValue + setPointWidget.getStep();
if (currentValue < setPointWidget.getMinValue()) currentValue=setPointWidget.getMinValue();
if (currentValue > setPointWidget.getMaxValue()) currentValue=setPointWidget.getMaxValue();
sendItemCommand(setPointWidget.getItem(),String.valueOf(currentValue));
}
}
);
break;
default :
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
break;
}
LinearLayout dividerLayout=(LinearLayout)widgetView.findViewById(R.id.listdivider);
if (dividerLayout != null) {
if (position < this.getCount() - 1) {
if (this.getItemViewType(position + 1) == TYPE_FRAME) {
dividerLayout.setVisibility(View.GONE);
}
 else {
dividerLayout.setVisibility(View.VISIBLE);
}
}
 else {
dividerLayout.setVisibility(View.GONE);
}
}
return widgetView;
}","@SuppressWarnings(""String_Node_Str"") @Override public View getView(int position,View convertView,ViewGroup parent){
  final RelativeLayout widgetView;
  TextView labelTextView;
  TextView valueTextView;
  int widgetLayout;
  String[] splitString;
  OpenHABWidget openHABWidget=getItem(position);
  int screenWidth=((WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getWidth();
switch (this.getItemViewType(position)) {
case TYPE_FRAME:
    widgetLayout=R.layout.openhabwidgetlist_frameitem;
  break;
case TYPE_GROUP:
widgetLayout=R.layout.openhabwidgetlist_groupitem;
break;
case TYPE_SECTIONSWITCH:
widgetLayout=R.layout.openhabwidgetlist_sectionswitchitem;
break;
case TYPE_SWITCH:
widgetLayout=R.layout.openhabwidgetlist_switchitem;
break;
case TYPE_ROLLERSHUTTER:
widgetLayout=R.layout.openhabwidgetlist_rollershutteritem;
break;
case TYPE_TEXT:
widgetLayout=R.layout.openhabwidgetlist_textitem;
break;
case TYPE_SLIDER:
widgetLayout=R.layout.openhabwidgetlist_slideritem;
break;
case TYPE_IMAGE:
widgetLayout=R.layout.openhabwidgetlist_imageitem;
break;
case TYPE_SELECTION:
widgetLayout=R.layout.openhabwidgetlist_selectionitem;
break;
case TYPE_SETPOINT:
widgetLayout=R.layout.openhabwidgetlist_setpointitem;
break;
case TYPE_CHART:
widgetLayout=R.layout.openhabwidgetlist_chartitem;
break;
case TYPE_VIDEO:
widgetLayout=R.layout.openhabwidgetlist_videoitem;
break;
case TYPE_VIDEO_MJPEG:
widgetLayout=R.layout.openhabwidgetlist_videomjpegitem;
break;
case TYPE_WEB:
widgetLayout=R.layout.openhabwidgetlist_webitem;
break;
case TYPE_COLOR:
widgetLayout=R.layout.openhabwidgetlist_coloritem;
break;
default :
widgetLayout=R.layout.openhabwidgetlist_genericitem;
break;
}
if (convertView == null) {
widgetView=new RelativeLayout(getContext());
String inflater=Context.LAYOUT_INFLATER_SERVICE;
LayoutInflater vi;
vi=(LayoutInflater)getContext().getSystemService(inflater);
vi.inflate(widgetLayout,widgetView,true);
}
 else {
widgetView=(RelativeLayout)convertView;
}
Integer iconColor=openHABWidget.getIconColor();
Integer labelColor=openHABWidget.getLabelColor();
Integer valueColor=openHABWidget.getValueColor();
MySmartImageView widgetImage=(MySmartImageView)widgetView.findViewById(R.id.widgetimage);
if (widgetImage != null) {
if (openHABWidget.getIcon() != null) {
String iconUrl=openHABBaseUrl + ""String_Node_Str"" + Uri.encode(openHABWidget.getIcon() + ""String_Node_Str"");
widgetImage.setImageUrl(iconUrl,R.drawable.blank_icon,openHABUsername,openHABPassword);
if (iconColor != null) widgetImage.setColorFilter(iconColor);
 else widgetImage.clearColorFilter();
}
}
TextView defaultTextView=new TextView(widgetView.getContext());
labelTextView=(TextView)widgetView.findViewById(R.id.widgetlabel);
if (labelColor != null && labelTextView != null) {
Log.d(TAG,String.format(""String_Node_Str"",labelColor));
labelTextView.setTextColor(labelColor);
}
 else if (labelTextView != null) labelTextView.setTextColor(defaultTextView.getTextColors().getDefaultColor());
valueTextView=(TextView)widgetView.findViewById(R.id.widgetvalue);
if (valueColor != null && valueTextView != null) {
Log.d(TAG,String.format(""String_Node_Str"",valueColor));
valueTextView.setTextColor(valueColor);
}
 else if (valueTextView != null) valueTextView.setTextColor(defaultTextView.getTextColors().getDefaultColor());
defaultTextView=null;
switch (getItemViewType(position)) {
case TYPE_FRAME:
if (labelTextView != null) {
labelTextView.setText(openHABWidget.getLabel());
if (valueColor != null) labelTextView.setTextColor(valueColor);
}
widgetView.setClickable(false);
if (openHABWidget.getLabel().length() > 0) {
widgetView.setVisibility(View.VISIBLE);
labelTextView.setVisibility(View.VISIBLE);
}
 else {
widgetView.setVisibility(View.GONE);
labelTextView.setVisibility(View.GONE);
}
break;
case TYPE_GROUP:
if (labelTextView != null && valueTextView != null) {
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
labelTextView.setText(splitString[0]);
if (splitString.length > 1) {
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setText(""String_Node_Str"");
}
}
break;
case TYPE_SECTIONSWITCH:
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
if (splitString.length > 1 && valueTextView != null) {
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setText(""String_Node_Str"");
}
RadioGroup sectionSwitchRadioGroup=(RadioGroup)widgetView.findViewById(R.id.sectionswitchradiogroup);
sectionSwitchRadioGroup.removeAllViews();
sectionSwitchRadioGroup.setTag(openHABWidget);
Iterator<OpenHABWidgetMapping> sectionMappingIterator=openHABWidget.getMappings().iterator();
while (sectionMappingIterator.hasNext()) {
OpenHABWidgetMapping widgetMapping=sectionMappingIterator.next();
SegmentedControlButton segmentedControlButton=(SegmentedControlButton)LayoutInflater.from(sectionSwitchRadioGroup.getContext()).inflate(R.layout.openhabwidgetlist_sectionswitchitem_button,sectionSwitchRadioGroup,false);
segmentedControlButton.setText(widgetMapping.getLabel());
segmentedControlButton.setTag(widgetMapping.getCommand());
if (openHABWidget.getItem() != null && widgetMapping.getCommand() != null) {
if (widgetMapping.getCommand().equals(openHABWidget.getItem().getState())) {
segmentedControlButton.setChecked(true);
}
 else {
segmentedControlButton.setChecked(false);
}
}
 else {
segmentedControlButton.setChecked(false);
}
segmentedControlButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View view){
Log.i(TAG,""String_Node_Str"");
RadioGroup group=(RadioGroup)view.getParent();
if (group.getTag() != null) {
OpenHABWidget radioWidget=(OpenHABWidget)group.getTag();
SegmentedControlButton selectedButton=(SegmentedControlButton)view;
if (selectedButton.getTag() != null) {
sendItemCommand(radioWidget.getItem(),(String)selectedButton.getTag());
}
}
}
}
);
sectionSwitchRadioGroup.addView(segmentedControlButton);
}
sectionSwitchRadioGroup.setOnCheckedChangeListener(new OnCheckedChangeListener(){
public void onCheckedChanged(RadioGroup group,int checkedId){
OpenHABWidget radioWidget=(OpenHABWidget)group.getTag();
SegmentedControlButton selectedButton=(SegmentedControlButton)group.findViewById(checkedId);
if (selectedButton != null) {
Log.d(TAG,""String_Node_Str"" + selectedButton.getText());
Log.d(TAG,""String_Node_Str"" + (String)selectedButton.getTag());
sendItemCommand(radioWidget.getItem(),(String)selectedButton.getTag());
}
}
}
);
break;
case TYPE_SWITCH:
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
Switch switchSwitch=(Switch)widgetView.findViewById(R.id.switchswitch);
if (openHABWidget.hasItem()) {
if (openHABWidget.getItem().getStateAsBoolean()) {
switchSwitch.setChecked(true);
}
 else {
switchSwitch.setChecked(false);
}
}
switchSwitch.setTag(openHABWidget.getItem());
switchSwitch.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
Switch switchSwitch=(Switch)v;
OpenHABItem linkedItem=(OpenHABItem)switchSwitch.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) if (!switchSwitch.isChecked()) {
sendItemCommand(linkedItem,""String_Node_Str"");
}
 else {
sendItemCommand(linkedItem,""String_Node_Str"");
}
return false;
}
}
);
break;
case TYPE_COLOR:
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
ImageButton colorUpButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_up);
ImageButton colorDownButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_down);
ImageButton colorColorButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_color);
colorUpButton.setTag(openHABWidget.getItem());
colorDownButton.setTag(openHABWidget.getItem());
colorColorButton.setTag(openHABWidget.getItem());
colorUpButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(colorItem,""String_Node_Str"");
return false;
}
}
);
colorDownButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(colorItem,""String_Node_Str"");
return false;
}
}
);
colorColorButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) {
Log.d(TAG,""String_Node_Str"");
ColorPickerDialog colorDialog=new ColorPickerDialog(widgetView.getContext(),new OnColorChangedListener(){
public void colorChanged(float[] hsv,View v){
Log.d(TAG,""String_Node_Str"" + hsv[0] + ""String_Node_Str""+ hsv[1]+ ""String_Node_Str""+ hsv[2]);
String newColor=String.valueOf(hsv[0]) + ""String_Node_Str"" + String.valueOf(hsv[1] * 100)+ ""String_Node_Str""+ String.valueOf(hsv[2] * 100);
OpenHABItem colorItem=(OpenHABItem)v.getTag();
sendItemCommand(colorItem,newColor);
}
}
,colorItem.getStateAsHSV());
colorDialog.setTag(colorItem);
colorDialog.show();
}
return false;
}
}
);
break;
case TYPE_ROLLERSHUTTER:
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
ImageButton rollershutterUpButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_up);
ImageButton rollershutterStopButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_stop);
ImageButton rollershutterDownButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_down);
rollershutterUpButton.setTag(openHABWidget.getItem());
rollershutterStopButton.setTag(openHABWidget.getItem());
rollershutterDownButton.setTag(openHABWidget.getItem());
rollershutterUpButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
rollershutterStopButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
rollershutterDownButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
break;
case TYPE_TEXT:
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) if (splitString.length > 0) {
labelTextView.setText(splitString[0]);
}
 else {
labelTextView.setText(openHABWidget.getLabel());
}
if (valueTextView != null) if (splitString.length > 1) {
valueTextView.setVisibility(View.VISIBLE);
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setVisibility(View.GONE);
valueTextView.setText(""String_Node_Str"");
}
break;
case TYPE_SLIDER:
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
SeekBar sliderSeekBar=(SeekBar)widgetView.findViewById(R.id.sliderseekbar);
if (openHABWidget.hasItem()) {
sliderSeekBar.setTag(openHABWidget.getItem());
int sliderState=0;
try {
sliderState=(int)Float.parseFloat(openHABWidget.getItem().getState());
}
 catch (NumberFormatException e) {
if (e != null) {
Crittercism.logHandledException(e);
Log.e(TAG,e.getMessage());
}
if (openHABWidget.getItem().getState().equals(""String_Node_Str"")) {
sliderState=0;
}
 else if (openHABWidget.getItem().getState().equals(""String_Node_Str"")) {
sliderState=100;
}
}
sliderSeekBar.setProgress(sliderState);
sliderSeekBar.setOnSeekBarChangeListener(new OnSeekBarChangeListener(){
public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
}
public void onStartTrackingTouch(SeekBar seekBar){
Log.d(TAG,""String_Node_Str"" + seekBar.getProgress());
}
public void onStopTrackingTouch(SeekBar seekBar){
Log.d(TAG,""String_Node_Str"" + seekBar.getProgress());
OpenHABItem sliderItem=(OpenHABItem)seekBar.getTag();
if (sliderItem != null && seekBar != null) sendItemCommand(sliderItem,String.valueOf(seekBar.getProgress()));
}
}
);
}
break;
case TYPE_IMAGE:
MySmartImageView imageImage=(MySmartImageView)widgetView.findViewById(R.id.imageimage);
imageImage.setImageUrl(ensureAbsoluteURL(openHABBaseUrl,openHABWidget.getUrl()),false,openHABUsername,openHABPassword);
if (openHABWidget.getRefresh() > 0) {
imageImage.setRefreshRate(openHABWidget.getRefresh());
refreshImageList.add(imageImage);
}
break;
case TYPE_CHART:
MySmartImageView chartImage=(MySmartImageView)widgetView.findViewById(R.id.chartimage);
OpenHABItem chartItem=openHABWidget.getItem();
Random random=new Random();
String chartUrl=""String_Node_Str"";
if (chartItem != null) {
if (chartItem.getType().equals(""String_Node_Str"")) {
chartUrl=openHABBaseUrl + ""String_Node_Str"" + chartItem.getName()+ ""String_Node_Str""+ openHABWidget.getPeriod()+ ""String_Node_Str""+ String.valueOf(random.nextInt());
}
 else {
chartUrl=openHABBaseUrl + ""String_Node_Str"" + chartItem.getName()+ ""String_Node_Str""+ openHABWidget.getPeriod()+ ""String_Node_Str""+ String.valueOf(random.nextInt());
}
if (openHABWidget.getService() != null && openHABWidget.getService().length() > 0) {
chartUrl+=""String_Node_Str"" + openHABWidget.getService();
}
}
Log.d(TAG,""String_Node_Str"" + chartUrl);
if (chartImage == null) Log.e(TAG,""String_Node_Str"");
ViewGroup.LayoutParams chartLayoutParams=chartImage.getLayoutParams();
chartLayoutParams.height=(int)(screenWidth / 2);
chartImage.setLayoutParams(chartLayoutParams);
chartUrl+=""String_Node_Str"" + String.valueOf(screenWidth);
chartUrl+=""String_Node_Str"" + String.valueOf(screenWidth / 2);
chartImage.setImageUrl(chartUrl,false,openHABUsername,openHABPassword);
if (openHABWidget.getRefresh() > 0) {
chartImage.setRefreshRate(openHABWidget.getRefresh());
refreshImageList.add(chartImage);
}
Log.d(TAG,""String_Node_Str"" + chartLayoutParams.width + ""String_Node_Str""+ chartLayoutParams.height);
break;
case TYPE_VIDEO:
VideoView videoVideo=(VideoView)widgetView.findViewById(R.id.videovideo);
Log.d(TAG,""String_Node_Str"" + openHABWidget.getUrl());
WindowManager wm=(WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE);
ViewGroup.LayoutParams videoLayoutParams=videoVideo.getLayoutParams();
videoLayoutParams.height=(int)(wm.getDefaultDisplay().getWidth() / 1.77);
videoVideo.setLayoutParams(videoLayoutParams);
if (!videoWidgetList.contains(videoVideo)) videoWidgetList.add(videoVideo);
if (!videoVideo.isPlaying()) {
videoVideo.setVideoURI(Uri.parse(openHABWidget.getUrl()));
videoVideo.start();
}
Log.d(TAG,""String_Node_Str"" + videoVideo.getHeight());
break;
case TYPE_VIDEO_MJPEG:
Log.d(TAG,""String_Node_Str"");
ImageView mjpegImage=(ImageView)widgetView.findViewById(R.id.mjpegimage);
MjpegStreamer mjpegStreamer=new MjpegStreamer(openHABWidget.getUrl(),this.openHABUsername,this.openHABPassword,this.getContext());
mjpegStreamer.setTargetImageView(mjpegImage);
mjpegStreamer.start();
if (!mjpegWidgetList.contains(mjpegStreamer)) mjpegWidgetList.add(mjpegStreamer);
break;
case TYPE_WEB:
WebView webWeb=(WebView)widgetView.findViewById(R.id.webweb);
if (openHABWidget.getHeight() > 0) {
ViewGroup.LayoutParams webLayoutParams=webWeb.getLayoutParams();
webLayoutParams.height=openHABWidget.getHeight() * 80;
webWeb.setLayoutParams(webLayoutParams);
}
webWeb.setWebViewClient(new WebViewClient());
webWeb.getSettings().setJavaScriptEnabled(true);
webWeb.loadUrl(openHABWidget.getUrl());
break;
case TYPE_SELECTION:
int spinnerSelectedIndex=-1;
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
Spinner selectionSpinner=(Spinner)widgetView.findViewById(R.id.selectionspinner);
ArrayList<String> spinnerArray=new ArrayList<String>();
Iterator<OpenHABWidgetMapping> mappingIterator=openHABWidget.getMappings().iterator();
while (mappingIterator.hasNext()) {
OpenHABWidgetMapping openHABWidgetMapping=mappingIterator.next();
spinnerArray.add(openHABWidgetMapping.getLabel());
if (openHABWidgetMapping.getCommand() != null && openHABWidget.getItem() != null) if (openHABWidgetMapping.getCommand().equals(openHABWidget.getItem().getState())) {
spinnerSelectedIndex=spinnerArray.size() - 1;
}
}
ArrayAdapter<String> spinnerAdapter=new ArrayAdapter<String>(this.getContext(),android.R.layout.simple_spinner_item,spinnerArray);
spinnerAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
selectionSpinner.setAdapter(spinnerAdapter);
selectionSpinner.setTag(openHABWidget);
if (spinnerSelectedIndex >= 0) selectionSpinner.setSelection(spinnerSelectedIndex);
selectionSpinner.setOnItemSelectedListener(new OnItemSelectedListener(){
public void onItemSelected(AdapterView<?> parent,View view,int index,long id){
Log.d(TAG,""String_Node_Str"" + index);
Spinner spinner=(Spinner)parent;
String selectedLabel=(String)spinner.getAdapter().getItem(index);
Log.d(TAG,""String_Node_Str"" + selectedLabel);
OpenHABWidget openHABWidget=(OpenHABWidget)parent.getTag();
if (openHABWidget != null) {
Log.d(TAG,""String_Node_Str"" + openHABWidget.getMapping(index).getLabel());
Iterator<OpenHABWidgetMapping> mappingIterator=openHABWidget.getMappings().iterator();
while (mappingIterator.hasNext()) {
OpenHABWidgetMapping openHABWidgetMapping=mappingIterator.next();
if (openHABWidgetMapping.getLabel().equals(selectedLabel)) {
Log.d(TAG,""String_Node_Str"" + openHABWidgetMapping.getCommand());
if (openHABWidget.getItem().getState() != null) if (!openHABWidget.getItem().getState().equals(openHABWidgetMapping.getCommand())) {
Log.d(TAG,""String_Node_Str"");
sendItemCommand(openHABWidget.getItem(),openHABWidgetMapping.getCommand());
}
}
}
}
}
public void onNothingSelected(AdapterView<?> arg0){
}
}
);
break;
case TYPE_SETPOINT:
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
if (valueTextView != null) if (splitString.length > 1) {
valueTextView.setVisibility(View.VISIBLE);
valueTextView.setText(splitString[1]);
}
Button setPointMinusButton=(Button)widgetView.findViewById(R.id.setpointbutton_minus);
Button setPointPlusButton=(Button)widgetView.findViewById(R.id.setpointbutton_plus);
setPointMinusButton.setTag(openHABWidget);
setPointPlusButton.setTag(openHABWidget);
setPointMinusButton.setOnClickListener(new OnClickListener(){
public void onClick(View v){
Log.d(TAG,""String_Node_Str"");
OpenHABWidget setPointWidget=(OpenHABWidget)v.getTag();
float currentValue=Float.valueOf(setPointWidget.getItem().getState()).floatValue();
currentValue=currentValue - setPointWidget.getStep();
if (currentValue < setPointWidget.getMinValue()) currentValue=setPointWidget.getMinValue();
if (currentValue > setPointWidget.getMaxValue()) currentValue=setPointWidget.getMaxValue();
sendItemCommand(setPointWidget.getItem(),String.valueOf(currentValue));
}
}
);
setPointPlusButton.setOnClickListener(new OnClickListener(){
public void onClick(View v){
Log.d(TAG,""String_Node_Str"");
OpenHABWidget setPointWidget=(OpenHABWidget)v.getTag();
float currentValue=Float.valueOf(setPointWidget.getItem().getState()).floatValue();
currentValue=currentValue + setPointWidget.getStep();
if (currentValue < setPointWidget.getMinValue()) currentValue=setPointWidget.getMinValue();
if (currentValue > setPointWidget.getMaxValue()) currentValue=setPointWidget.getMaxValue();
sendItemCommand(setPointWidget.getItem(),String.valueOf(currentValue));
}
}
);
break;
default :
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
break;
}
LinearLayout dividerLayout=(LinearLayout)widgetView.findViewById(R.id.listdivider);
if (dividerLayout != null) {
if (position < this.getCount() - 1) {
if (this.getItemViewType(position + 1) == TYPE_FRAME) {
dividerLayout.setVisibility(View.GONE);
}
 else {
dividerLayout.setVisibility(View.VISIBLE);
}
}
 else {
dividerLayout.setVisibility(View.GONE);
}
}
return widgetView;
}",0.9888334752463204
29742,"public void clearSelection(){
  if (getListView() != null && this.isVisible()) {
    getListView().clearChoices();
    getListView().requestLayout();
  }
}","public void clearSelection(){
  if (getListView() != null && this.isVisible() && isAdded()) {
    getListView().clearChoices();
    getListView().requestLayout();
  }
}",0.959752321981424
29743,"public void clearSelection(){
  getListView().clearChoices();
  getListView().requestLayout();
}","public void clearSelection(){
  if (getListView() != null) {
    getListView().clearChoices();
    getListView().requestLayout();
  }
}",0.8311688311688312
29744,"public void sendItemCommand(OpenHABItem item,String command){
  try {
    StringEntity se=new StringEntity(command);
    mAsyncHttpClient.post(getContext(),item.getLink(),se,""String_Node_Str"",new AsyncHttpResponseHandler(){
      @Override public void onSuccess(      String response){
        Log.d(TAG,""String_Node_Str"");
      }
      @Override public void onFailure(      Throwable error,      String errorResponse){
        Log.e(TAG,""String_Node_Str"" + error.getMessage());
        if (errorResponse != null)         Log.e(TAG,""String_Node_Str"" + errorResponse);
      }
    }
);
  }
 catch (  UnsupportedEncodingException e) {
    if (e != null)     Log.e(TAG,e.getMessage());
  }
}","public void sendItemCommand(OpenHABItem item,String command){
  try {
    if (item != null && command != null) {
      StringEntity se=new StringEntity(command);
      mAsyncHttpClient.post(getContext(),item.getLink(),se,""String_Node_Str"",new AsyncHttpResponseHandler(){
        @Override public void onSuccess(        String response){
          Log.d(TAG,""String_Node_Str"");
        }
        @Override public void onFailure(        Throwable error,        String errorResponse){
          Log.e(TAG,""String_Node_Str"" + error.getMessage());
          if (errorResponse != null)           Log.e(TAG,""String_Node_Str"" + errorResponse);
        }
      }
);
    }
  }
 catch (  UnsupportedEncodingException e) {
    if (e != null)     Log.e(TAG,e.getMessage());
  }
}",0.9470790378006873
29745,"/** 
 * Parse XML sitemap page and show it
 * @param document	XML Document
 * @return      void
 */
public void processContent(Document document,boolean longPolling){
  openHABWidgetAdapter.stopVideoWidgets();
  openHABWidgetAdapter.stopImageRefresh();
  Node rootNode=document.getFirstChild();
  openHABWidgetDataSource.setSourceNode(rootNode);
  widgetList.clear();
  for (  OpenHABWidget w : openHABWidgetDataSource.getWidgets()) {
    if (w.getType().equals(""String_Node_Str"") && TextUtils.isEmpty(w.getLabel()))     continue;
    widgetList.add(w);
  }
  openHABWidgetAdapter.notifyDataSetChanged();
  if (!longPolling) {
    getListView().clearChoices();
    Log.d(TAG,String.format(""String_Node_Str"",mCurrentSelectedItem));
    if (mCurrentSelectedItem >= 0)     getListView().setItemChecked(mCurrentSelectedItem,true);
  }
  if (getActivity() != null && mIsVisible)   getActivity().setTitle(openHABWidgetDataSource.getTitle());
  if (this.nfcWidgetId != null && this.nfcCommand != null) {
    Log.d(TAG,""String_Node_Str"");
    OpenHABWidget nfcWidget=this.openHABWidgetDataSource.getWidgetById(this.nfcWidgetId);
    OpenHABItem nfcItem=nfcWidget.getItem();
    if (nfcWidget != null && nfcItem != null) {
      if (this.nfcCommand.equals(""String_Node_Str"")) {
        if (nfcItem.getType().equals(""String_Node_Str"")) {
          if (nfcItem.getStateAsBoolean())           this.openHABWidgetAdapter.sendItemCommand(nfcItem,""String_Node_Str"");
 else           this.openHABWidgetAdapter.sendItemCommand(nfcItem,""String_Node_Str"");
        }
 else {
          if (nfcItem.getStateAsBoolean())           this.openHABWidgetAdapter.sendItemCommand(nfcItem,""String_Node_Str"");
 else           this.openHABWidgetAdapter.sendItemCommand(nfcItem,""String_Node_Str"");
        }
      }
 else {
        this.openHABWidgetAdapter.sendItemCommand(nfcItem,this.nfcCommand);
      }
    }
    this.nfcWidgetId=null;
    this.nfcCommand=null;
    if (this.nfcAutoClose) {
      getActivity().finish();
    }
  }
  showPage(displayPageUrl,true);
}","/** 
 * Parse XML sitemap page and show it
 * @param document	XML Document
 * @return      void
 */
public void processContent(Document document,boolean longPolling){
  openHABWidgetAdapter.stopVideoWidgets();
  openHABWidgetAdapter.stopImageRefresh();
  Node rootNode=document.getFirstChild();
  openHABWidgetDataSource.setSourceNode(rootNode);
  widgetList.clear();
  for (  OpenHABWidget w : openHABWidgetDataSource.getWidgets()) {
    if (w.getType().equals(""String_Node_Str"") && TextUtils.isEmpty(w.getLabel()))     continue;
    widgetList.add(w);
  }
  openHABWidgetAdapter.notifyDataSetChanged();
  if (!longPolling && isAdded()) {
    getListView().clearChoices();
    Log.d(TAG,String.format(""String_Node_Str"",mCurrentSelectedItem));
    if (mCurrentSelectedItem >= 0)     getListView().setItemChecked(mCurrentSelectedItem,true);
  }
  if (getActivity() != null && mIsVisible)   getActivity().setTitle(openHABWidgetDataSource.getTitle());
  if (this.nfcWidgetId != null && this.nfcCommand != null) {
    Log.d(TAG,""String_Node_Str"");
    OpenHABWidget nfcWidget=this.openHABWidgetDataSource.getWidgetById(this.nfcWidgetId);
    OpenHABItem nfcItem=nfcWidget.getItem();
    if (nfcWidget != null && nfcItem != null) {
      if (this.nfcCommand.equals(""String_Node_Str"")) {
        if (nfcItem.getType().equals(""String_Node_Str"")) {
          if (nfcItem.getStateAsBoolean())           this.openHABWidgetAdapter.sendItemCommand(nfcItem,""String_Node_Str"");
 else           this.openHABWidgetAdapter.sendItemCommand(nfcItem,""String_Node_Str"");
        }
 else {
          if (nfcItem.getStateAsBoolean())           this.openHABWidgetAdapter.sendItemCommand(nfcItem,""String_Node_Str"");
 else           this.openHABWidgetAdapter.sendItemCommand(nfcItem,""String_Node_Str"");
        }
      }
 else {
        this.openHABWidgetAdapter.sendItemCommand(nfcItem,this.nfcCommand);
      }
    }
    this.nfcWidgetId=null;
    this.nfcCommand=null;
    if (this.nfcAutoClose) {
      getActivity().finish();
    }
  }
  showPage(displayPageUrl,true);
}",0.9968176254589964
29746,"private void showCertificateDialog(final int decisionId,String certMessage){
  AlertDialog.Builder builder=new AlertDialog.Builder(OpenHABMainActivity.this);
  builder.setMessage(certMessage).setTitle(R.string.mtm_accept_cert);
  builder.setPositiveButton(R.string.mtm_decision_always,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialogInterface,    int i){
      Log.d(TAG,""String_Node_Str"");
      sendMTMDecision(decisionId,MTMDecision.DECISION_ALWAYS);
    }
  }
);
  builder.setNeutralButton(R.string.mtm_decision_once,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialogInterface,    int i){
      Log.d(TAG,""String_Node_Str"");
      sendMTMDecision(decisionId,MTMDecision.DECISION_ONCE);
    }
  }
);
  builder.setNegativeButton(R.string.mtm_decision_abort,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialogInterface,    int i){
      Log.d(TAG,""String_Node_Str"");
      sendMTMDecision(decisionId,MTMDecision.DECISION_ABORT);
    }
  }
);
  AlertDialog certAlert=builder.create();
  certAlert.show();
}","private void showCertificateDialog(final int decisionId,String certMessage){
  if (this.isFinishing())   return;
  AlertDialog.Builder builder=new AlertDialog.Builder(OpenHABMainActivity.this);
  builder.setMessage(certMessage).setTitle(R.string.mtm_accept_cert);
  builder.setPositiveButton(R.string.mtm_decision_always,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialogInterface,    int i){
      Log.d(TAG,""String_Node_Str"");
      sendMTMDecision(decisionId,MTMDecision.DECISION_ALWAYS);
    }
  }
);
  builder.setNeutralButton(R.string.mtm_decision_once,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialogInterface,    int i){
      Log.d(TAG,""String_Node_Str"");
      sendMTMDecision(decisionId,MTMDecision.DECISION_ONCE);
    }
  }
);
  builder.setNegativeButton(R.string.mtm_decision_abort,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialogInterface,    int i){
      Log.d(TAG,""String_Node_Str"");
      sendMTMDecision(decisionId,MTMDecision.DECISION_ABORT);
    }
  }
);
  AlertDialog certAlert=builder.create();
  certAlert.show();
}",0.9842381786339754
29747,"@Override protected Boolean doInBackground(String... strings){
  try {
    URL url=new URL(strings[0]);
    Socket s=new Socket();
    s.connect(new InetSocketAddress(url.getHost(),url.getPort()),1000);
    Log.d(TAG,""String_Node_Str"");
    s.close();
    return true;
  }
 catch (  MalformedURLException e) {
    Log.e(TAG,e.getMessage());
    return false;
  }
catch (  IOException e) {
    Log.e(TAG,e.getMessage());
    return false;
  }
}","@Override protected Boolean doInBackground(String... strings){
  try {
    URL url=new URL(strings[0]);
    int checkPort=url.getPort();
    if (url.getProtocol().equals(""String_Node_Str"") && checkPort == -1)     checkPort=80;
    if (url.getProtocol().equals(""String_Node_Str"") && checkPort == -1)     checkPort=443;
    Socket s=new Socket();
    s.connect(new InetSocketAddress(url.getHost(),checkPort),1000);
    Log.d(TAG,""String_Node_Str"");
    s.close();
    return true;
  }
 catch (  MalformedURLException e) {
    Log.e(TAG,e.getMessage());
    return false;
  }
catch (  IOException e) {
    Log.e(TAG,e.getMessage());
    return false;
  }
}",0.7846715328467153
29748,"private boolean checkUrlReachability(String urlString){
  Log.d(TAG,""String_Node_Str"" + urlString);
  try {
    return new AsyncTask<String,Void,Boolean>(){
      @Override protected Boolean doInBackground(      String... strings){
        try {
          URL url=new URL(strings[0]);
          Socket s=new Socket();
          s.connect(new InetSocketAddress(url.getHost(),url.getPort()),1000);
          Log.d(TAG,""String_Node_Str"");
          s.close();
          return true;
        }
 catch (        MalformedURLException e) {
          Log.e(TAG,e.getMessage());
          return false;
        }
catch (        IOException e) {
          Log.e(TAG,e.getMessage());
          return false;
        }
      }
    }
.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,urlString).get();
  }
 catch (  InterruptedException e) {
    Log.e(TAG,e.getMessage());
    return false;
  }
catch (  ExecutionException e) {
    Log.e(TAG,e.getMessage());
    return false;
  }
}","private boolean checkUrlReachability(String urlString){
  Log.d(TAG,""String_Node_Str"" + urlString);
  try {
    return new AsyncTask<String,Void,Boolean>(){
      @Override protected Boolean doInBackground(      String... strings){
        try {
          URL url=new URL(strings[0]);
          int checkPort=url.getPort();
          if (url.getProtocol().equals(""String_Node_Str"") && checkPort == -1)           checkPort=80;
          if (url.getProtocol().equals(""String_Node_Str"") && checkPort == -1)           checkPort=443;
          Socket s=new Socket();
          s.connect(new InetSocketAddress(url.getHost(),checkPort),1000);
          Log.d(TAG,""String_Node_Str"");
          s.close();
          return true;
        }
 catch (        MalformedURLException e) {
          Log.e(TAG,e.getMessage());
          return false;
        }
catch (        IOException e) {
          Log.e(TAG,e.getMessage());
          return false;
        }
      }
    }
.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,urlString).get();
  }
 catch (  InterruptedException e) {
    Log.e(TAG,e.getMessage());
    return false;
  }
catch (  ExecutionException e) {
    Log.e(TAG,e.getMessage());
    return false;
  }
}",0.8760330578512396
29749,"public String getTitle(){
  String[] splitString;
  if (title != null) {
    splitString=title.split(""String_Node_Str"");
    return splitString[0];
  }
  return ""String_Node_Str"";
}","public String getTitle(){
  String[] splitString;
  if (title != null) {
    splitString=title.split(""String_Node_Str"");
    if (splitString.length > 0) {
      return splitString[0];
    }
 else {
      return title;
    }
  }
  return ""String_Node_Str"";
}",0.8264840182648402
29750,"@Override protected void onHandleIntent(Intent intent){
  Bundle extras=intent.getExtras();
  int notificationId;
  if (mNotificationManager == null)   mNotificationManager=(NotificationManager)this.getSystemService(Context.NOTIFICATION_SERVICE);
  GoogleCloudMessaging gcm=GoogleCloudMessaging.getInstance(this);
  String messageType=gcm.getMessageType(intent);
  Log.d(TAG,""String_Node_Str"" + messageType);
  if (!extras.isEmpty()) {
    if (GoogleCloudMessaging.MESSAGE_TYPE_MESSAGE.equals(messageType)) {
      if (!intent.hasExtra(""String_Node_Str"")) {
        notificationId=1;
      }
 else {
        notificationId=Integer.parseInt(intent.getExtras().getString(""String_Node_Str""));
      }
      if (intent.getExtras().getString(""String_Node_Str"").equals(""String_Node_Str"")) {
        sendNotification(intent.getExtras().getString(""String_Node_Str""),notificationId);
      }
 else       if (intent.getExtras().getString(""String_Node_Str"").equals(""String_Node_Str"")) {
        mNotificationManager.cancel(Integer.parseInt(intent.getExtras().getString(""String_Node_Str"")));
      }
    }
  }
  GcmBroadcastReceiver.completeWakefulIntent(intent);
}","@Override protected void onHandleIntent(Intent intent){
  Bundle extras=intent.getExtras();
  if (extras == null)   return;
  int notificationId;
  if (mNotificationManager == null)   mNotificationManager=(NotificationManager)this.getSystemService(Context.NOTIFICATION_SERVICE);
  GoogleCloudMessaging gcm=GoogleCloudMessaging.getInstance(this);
  String messageType=gcm.getMessageType(intent);
  Log.d(TAG,""String_Node_Str"" + messageType);
  if (!extras.isEmpty()) {
    if (GoogleCloudMessaging.MESSAGE_TYPE_MESSAGE.equals(messageType)) {
      if (!intent.hasExtra(""String_Node_Str"")) {
        notificationId=1;
      }
 else {
        notificationId=Integer.parseInt(intent.getExtras().getString(""String_Node_Str""));
      }
      if (intent.getExtras().getString(""String_Node_Str"").equals(""String_Node_Str"")) {
        sendNotification(intent.getExtras().getString(""String_Node_Str""),notificationId);
      }
 else       if (intent.getExtras().getString(""String_Node_Str"").equals(""String_Node_Str"")) {
        mNotificationManager.cancel(Integer.parseInt(intent.getExtras().getString(""String_Node_Str"")));
      }
    }
  }
  GcmBroadcastReceiver.completeWakefulIntent(intent);
}",0.9863130881094953
29751,"public void setSourceNode(Node rootNode){
  Log.i(TAG,""String_Node_Str"");
  rootWidget=new OpenHABWidget();
  rootWidget.setType(""String_Node_Str"");
  if (rootNode.hasChildNodes()) {
    NodeList childNodes=rootNode.getChildNodes();
    for (int i=0; i < childNodes.getLength(); i++) {
      Node childNode=childNodes.item(i);
      if (childNode.getNodeName().equals(""String_Node_Str"")) {
        new OpenHABWidget(rootWidget,childNode);
      }
 else       if (childNode.getNodeName().equals(""String_Node_Str"")) {
        this.setTitle(childNode.getTextContent());
      }
 else       if (childNode.getNodeName().equals(""String_Node_Str"")) {
        this.setId(childNode.getTextContent());
      }
 else       if (childNode.getNodeName().equals(""String_Node_Str"")) {
        this.setIcon(childNode.getTextContent());
      }
 else       if (childNode.getNodeName().equals(""String_Node_Str"")) {
        this.setLink(childNode.getTextContent());
      }
    }
  }
}","public void setSourceNode(Node rootNode){
  Log.i(TAG,""String_Node_Str"");
  if (rootNode == null)   return;
  rootWidget=new OpenHABWidget();
  rootWidget.setType(""String_Node_Str"");
  if (rootNode.hasChildNodes()) {
    NodeList childNodes=rootNode.getChildNodes();
    for (int i=0; i < childNodes.getLength(); i++) {
      Node childNode=childNodes.item(i);
      if (childNode.getNodeName().equals(""String_Node_Str"")) {
        new OpenHABWidget(rootWidget,childNode);
      }
 else       if (childNode.getNodeName().equals(""String_Node_Str"")) {
        this.setTitle(childNode.getTextContent());
      }
 else       if (childNode.getNodeName().equals(""String_Node_Str"")) {
        this.setId(childNode.getTextContent());
      }
 else       if (childNode.getNodeName().equals(""String_Node_Str"")) {
        this.setIcon(childNode.getTextContent());
      }
 else       if (childNode.getNodeName().equals(""String_Node_Str"")) {
        this.setLink(childNode.getTextContent());
      }
    }
  }
}",0.9826883910386964
29752,"@SuppressWarnings(""String_Node_Str"") @Override public View getView(int position,View convertView,ViewGroup parent){
  final RelativeLayout widgetView;
  TextView labelTextView;
  TextView valueTextView;
  int widgetLayout;
  String[] splitString;
  OpenHABWidget openHABWidget=getItem(position);
  int screenWidth=((WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getWidth();
switch (this.getItemViewType(position)) {
case TYPE_FRAME:
    widgetLayout=R.layout.openhabwidgetlist_frameitem;
  break;
case TYPE_GROUP:
widgetLayout=R.layout.openhabwidgetlist_groupitem;
break;
case TYPE_SECTIONSWITCH:
widgetLayout=R.layout.openhabwidgetlist_sectionswitchitem;
break;
case TYPE_SWITCH:
widgetLayout=R.layout.openhabwidgetlist_switchitem;
break;
case TYPE_ROLLERSHUTTER:
widgetLayout=R.layout.openhabwidgetlist_rollershutteritem;
break;
case TYPE_TEXT:
widgetLayout=R.layout.openhabwidgetlist_textitem;
break;
case TYPE_SLIDER:
widgetLayout=R.layout.openhabwidgetlist_slideritem;
break;
case TYPE_IMAGE:
widgetLayout=R.layout.openhabwidgetlist_imageitem;
break;
case TYPE_SELECTION:
widgetLayout=R.layout.openhabwidgetlist_selectionitem;
break;
case TYPE_SETPOINT:
widgetLayout=R.layout.openhabwidgetlist_setpointitem;
break;
case TYPE_CHART:
widgetLayout=R.layout.openhabwidgetlist_chartitem;
break;
case TYPE_VIDEO:
widgetLayout=R.layout.openhabwidgetlist_videoitem;
break;
case TYPE_VIDEO_MJPEG:
widgetLayout=R.layout.openhabwidgetlist_videomjpegitem;
break;
case TYPE_WEB:
widgetLayout=R.layout.openhabwidgetlist_webitem;
break;
case TYPE_COLOR:
widgetLayout=R.layout.openhabwidgetlist_coloritem;
break;
default :
widgetLayout=R.layout.openhabwidgetlist_genericitem;
break;
}
if (convertView == null) {
widgetView=new RelativeLayout(getContext());
String inflater=Context.LAYOUT_INFLATER_SERVICE;
LayoutInflater vi;
vi=(LayoutInflater)getContext().getSystemService(inflater);
vi.inflate(widgetLayout,widgetView,true);
}
 else {
widgetView=(RelativeLayout)convertView;
}
Integer iconColor=openHABWidget.getIconColor();
Integer labelColor=openHABWidget.getLabelColor();
Integer valueColor=openHABWidget.getValueColor();
MySmartImageView widgetImage=(MySmartImageView)widgetView.findViewById(R.id.widgetimage);
if (widgetImage != null) {
if (openHABWidget.getIcon() != null) {
String iconUrl=openHABBaseUrl + ""String_Node_Str"" + Uri.encode(openHABWidget.getIcon() + ""String_Node_Str"");
widgetImage.setImageUrl(iconUrl,R.drawable.blank_icon,openHABUsername,openHABPassword);
if (iconColor != null) widgetImage.setColorFilter(iconColor);
 else widgetImage.clearColorFilter();
}
}
TextView defaultTextView=new TextView(widgetView.getContext());
labelTextView=(TextView)widgetView.findViewById(R.id.widgetlabel);
if (labelColor != null && labelTextView != null) {
Log.d(TAG,String.format(""String_Node_Str"",labelColor));
labelTextView.setTextColor(labelColor);
}
 else if (labelTextView != null) labelTextView.setTextColor(defaultTextView.getTextColors().getDefaultColor());
valueTextView=(TextView)widgetView.findViewById(R.id.widgetvalue);
if (valueColor != null && valueTextView != null) {
Log.d(TAG,String.format(""String_Node_Str"",valueColor));
valueTextView.setTextColor(valueColor);
}
 else if (valueTextView != null) valueTextView.setTextColor(defaultTextView.getTextColors().getDefaultColor());
defaultTextView=null;
switch (getItemViewType(position)) {
case TYPE_FRAME:
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
widgetView.setClickable(false);
if (openHABWidget.getLabel().length() > 0) {
widgetView.setVisibility(View.VISIBLE);
labelTextView.setVisibility(View.VISIBLE);
}
 else {
widgetView.setVisibility(View.GONE);
labelTextView.setVisibility(View.GONE);
}
break;
case TYPE_GROUP:
if (labelTextView != null && valueTextView != null) {
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
labelTextView.setText(splitString[0]);
if (splitString.length > 1) {
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setText(""String_Node_Str"");
}
}
break;
case TYPE_SECTIONSWITCH:
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
if (splitString.length > 1 && valueTextView != null) {
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setText(""String_Node_Str"");
}
RadioGroup sectionSwitchRadioGroup=(RadioGroup)widgetView.findViewById(R.id.sectionswitchradiogroup);
sectionSwitchRadioGroup.removeAllViews();
sectionSwitchRadioGroup.setTag(openHABWidget);
Iterator<OpenHABWidgetMapping> sectionMappingIterator=openHABWidget.getMappings().iterator();
while (sectionMappingIterator.hasNext()) {
OpenHABWidgetMapping widgetMapping=sectionMappingIterator.next();
SegmentedControlButton segmentedControlButton=(SegmentedControlButton)LayoutInflater.from(sectionSwitchRadioGroup.getContext()).inflate(R.layout.openhabwidgetlist_sectionswitchitem_button,sectionSwitchRadioGroup,false);
segmentedControlButton.setText(widgetMapping.getLabel());
segmentedControlButton.setTag(widgetMapping.getCommand());
if (openHABWidget.getItem() != null && widgetMapping.getCommand() != null) {
if (widgetMapping.getCommand().equals(openHABWidget.getItem().getState())) {
segmentedControlButton.setChecked(true);
}
 else {
segmentedControlButton.setChecked(false);
}
}
 else {
segmentedControlButton.setChecked(false);
}
segmentedControlButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View view){
Log.i(TAG,""String_Node_Str"");
RadioGroup group=(RadioGroup)view.getParent();
if (group.getTag() != null) {
OpenHABWidget radioWidget=(OpenHABWidget)group.getTag();
SegmentedControlButton selectedButton=(SegmentedControlButton)view;
if (selectedButton.getTag() != null) {
sendItemCommand(radioWidget.getItem(),(String)selectedButton.getTag());
}
}
}
}
);
sectionSwitchRadioGroup.addView(segmentedControlButton);
}
sectionSwitchRadioGroup.setOnCheckedChangeListener(new OnCheckedChangeListener(){
public void onCheckedChanged(RadioGroup group,int checkedId){
OpenHABWidget radioWidget=(OpenHABWidget)group.getTag();
SegmentedControlButton selectedButton=(SegmentedControlButton)group.findViewById(checkedId);
if (selectedButton != null) {
Log.d(TAG,""String_Node_Str"" + selectedButton.getText());
Log.d(TAG,""String_Node_Str"" + (String)selectedButton.getTag());
sendItemCommand(radioWidget.getItem(),(String)selectedButton.getTag());
}
}
}
);
break;
case TYPE_SWITCH:
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
Switch switchSwitch=(Switch)widgetView.findViewById(R.id.switchswitch);
if (openHABWidget.hasItem()) {
if (openHABWidget.getItem().getStateAsBoolean()) {
switchSwitch.setChecked(true);
}
 else {
switchSwitch.setChecked(false);
}
}
switchSwitch.setTag(openHABWidget.getItem());
switchSwitch.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
Switch switchSwitch=(Switch)v;
OpenHABItem linkedItem=(OpenHABItem)switchSwitch.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) if (!switchSwitch.isChecked()) {
sendItemCommand(linkedItem,""String_Node_Str"");
}
 else {
sendItemCommand(linkedItem,""String_Node_Str"");
}
return false;
}
}
);
break;
case TYPE_COLOR:
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
ImageButton colorUpButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_up);
ImageButton colorDownButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_down);
ImageButton colorColorButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_color);
colorUpButton.setTag(openHABWidget.getItem());
colorDownButton.setTag(openHABWidget.getItem());
colorColorButton.setTag(openHABWidget.getItem());
colorUpButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(colorItem,""String_Node_Str"");
return false;
}
}
);
colorDownButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(colorItem,""String_Node_Str"");
return false;
}
}
);
colorColorButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) {
Log.d(TAG,""String_Node_Str"");
ColorPickerDialog colorDialog=new ColorPickerDialog(widgetView.getContext(),new OnColorChangedListener(){
public void colorChanged(float[] hsv,View v){
Log.d(TAG,""String_Node_Str"" + hsv[0] + ""String_Node_Str""+ hsv[1]+ ""String_Node_Str""+ hsv[2]);
String newColor=String.valueOf(hsv[0]) + ""String_Node_Str"" + String.valueOf(hsv[1] * 100)+ ""String_Node_Str""+ String.valueOf(hsv[2] * 100);
OpenHABItem colorItem=(OpenHABItem)v.getTag();
sendItemCommand(colorItem,newColor);
}
}
,colorItem.getStateAsHSV());
colorDialog.setTag(colorItem);
colorDialog.show();
}
return false;
}
}
);
break;
case TYPE_ROLLERSHUTTER:
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
ImageButton rollershutterUpButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_up);
ImageButton rollershutterStopButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_stop);
ImageButton rollershutterDownButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_down);
rollershutterUpButton.setTag(openHABWidget.getItem());
rollershutterStopButton.setTag(openHABWidget.getItem());
rollershutterDownButton.setTag(openHABWidget.getItem());
rollershutterUpButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
rollershutterStopButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
rollershutterDownButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
break;
case TYPE_TEXT:
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) if (splitString.length > 0) {
labelTextView.setText(splitString[0]);
}
 else {
labelTextView.setText(openHABWidget.getLabel());
}
if (valueTextView != null) if (splitString.length > 1) {
valueTextView.setVisibility(View.VISIBLE);
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setVisibility(View.GONE);
valueTextView.setText(""String_Node_Str"");
}
break;
case TYPE_SLIDER:
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
SeekBar sliderSeekBar=(SeekBar)widgetView.findViewById(R.id.sliderseekbar);
if (openHABWidget.hasItem()) {
sliderSeekBar.setTag(openHABWidget.getItem());
int sliderState=0;
try {
sliderState=(int)Float.parseFloat(openHABWidget.getItem().getState());
}
 catch (NumberFormatException e) {
if (e != null) {
Crittercism.logHandledException(e);
Log.e(TAG,e.getMessage());
}
if (openHABWidget.getItem().getState().equals(""String_Node_Str"")) {
sliderState=0;
}
 else if (openHABWidget.getItem().getState().equals(""String_Node_Str"")) {
sliderState=100;
}
}
sliderSeekBar.setProgress(sliderState);
sliderSeekBar.setOnSeekBarChangeListener(new OnSeekBarChangeListener(){
public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
}
public void onStartTrackingTouch(SeekBar seekBar){
Log.d(TAG,""String_Node_Str"" + seekBar.getProgress());
}
public void onStopTrackingTouch(SeekBar seekBar){
Log.d(TAG,""String_Node_Str"" + seekBar.getProgress());
OpenHABItem sliderItem=(OpenHABItem)seekBar.getTag();
if (sliderItem != null && seekBar != null) sendItemCommand(sliderItem,String.valueOf(seekBar.getProgress()));
}
}
);
}
break;
case TYPE_IMAGE:
MySmartImageView imageImage=(MySmartImageView)widgetView.findViewById(R.id.imageimage);
imageImage.setImageUrl(ensureAbsoluteURL(openHABBaseUrl,openHABWidget.getUrl()),false,openHABUsername,openHABPassword);
if (openHABWidget.getRefresh() > 0) {
imageImage.setRefreshRate(openHABWidget.getRefresh());
refreshImageList.add(imageImage);
}
break;
case TYPE_CHART:
MySmartImageView chartImage=(MySmartImageView)widgetView.findViewById(R.id.chartimage);
OpenHABItem chartItem=openHABWidget.getItem();
Random random=new Random();
String chartUrl=""String_Node_Str"";
if (chartItem != null) {
if (chartItem.getType().equals(""String_Node_Str"")) {
chartUrl=openHABBaseUrl + ""String_Node_Str"" + chartItem.getName()+ ""String_Node_Str""+ openHABWidget.getPeriod()+ ""String_Node_Str""+ String.valueOf(random.nextInt());
}
 else {
chartUrl=openHABBaseUrl + ""String_Node_Str"" + chartItem.getName()+ ""String_Node_Str""+ openHABWidget.getPeriod()+ ""String_Node_Str""+ String.valueOf(random.nextInt());
}
if (openHABWidget.getService() != null && openHABWidget.getService().length() > 0) {
chartUrl+=""String_Node_Str"" + openHABWidget.getService();
}
}
Log.d(TAG,""String_Node_Str"" + chartUrl);
if (chartImage == null) Log.e(TAG,""String_Node_Str"");
chartImage.setImageUrl(chartUrl,false,openHABUsername,openHABPassword);
ViewGroup.LayoutParams chartLayoutParams=chartImage.getLayoutParams();
chartLayoutParams.height=(int)(screenWidth / 1.88);
chartImage.setLayoutParams(chartLayoutParams);
if (openHABWidget.getRefresh() > 0) {
chartImage.setRefreshRate(openHABWidget.getRefresh());
refreshImageList.add(chartImage);
}
Log.d(TAG,""String_Node_Str"" + chartLayoutParams.width + ""String_Node_Str""+ chartLayoutParams.height);
break;
case TYPE_VIDEO:
VideoView videoVideo=(VideoView)widgetView.findViewById(R.id.videovideo);
Log.d(TAG,""String_Node_Str"" + openHABWidget.getUrl());
WindowManager wm=(WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE);
ViewGroup.LayoutParams videoLayoutParams=videoVideo.getLayoutParams();
videoLayoutParams.height=(int)(wm.getDefaultDisplay().getWidth() / 1.77);
videoVideo.setLayoutParams(videoLayoutParams);
if (!videoWidgetList.contains(videoVideo)) videoWidgetList.add(videoVideo);
if (!videoVideo.isPlaying()) {
videoVideo.setVideoURI(Uri.parse(openHABWidget.getUrl()));
videoVideo.start();
}
Log.d(TAG,""String_Node_Str"" + videoVideo.getHeight());
break;
case TYPE_VIDEO_MJPEG:
Log.d(TAG,""String_Node_Str"");
ImageView mjpegImage=(ImageView)widgetView.findViewById(R.id.mjpegimage);
MjpegStreamer mjpegStreamer=new MjpegStreamer(openHABWidget.getUrl(),this.openHABUsername,this.openHABPassword,this.getContext());
mjpegStreamer.setTargetImageView(mjpegImage);
mjpegStreamer.start();
if (!mjpegWidgetList.contains(mjpegStreamer)) mjpegWidgetList.add(mjpegStreamer);
break;
case TYPE_WEB:
WebView webWeb=(WebView)widgetView.findViewById(R.id.webweb);
if (openHABWidget.getHeight() > 0) {
ViewGroup.LayoutParams webLayoutParams=webWeb.getLayoutParams();
webLayoutParams.height=openHABWidget.getHeight() * 80;
webWeb.setLayoutParams(webLayoutParams);
}
webWeb.setWebViewClient(new WebViewClient());
webWeb.getSettings().setJavaScriptEnabled(true);
webWeb.loadUrl(openHABWidget.getUrl());
break;
case TYPE_SELECTION:
int spinnerSelectedIndex=-1;
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
Spinner selectionSpinner=(Spinner)widgetView.findViewById(R.id.selectionspinner);
ArrayList<String> spinnerArray=new ArrayList<String>();
Iterator<OpenHABWidgetMapping> mappingIterator=openHABWidget.getMappings().iterator();
while (mappingIterator.hasNext()) {
OpenHABWidgetMapping openHABWidgetMapping=mappingIterator.next();
spinnerArray.add(openHABWidgetMapping.getLabel());
if (openHABWidgetMapping.getCommand() != null && openHABWidget.getItem() != null) if (openHABWidgetMapping.getCommand().equals(openHABWidget.getItem().getState())) {
spinnerSelectedIndex=spinnerArray.size() - 1;
}
}
ArrayAdapter<String> spinnerAdapter=new ArrayAdapter<String>(this.getContext(),android.R.layout.simple_spinner_item,spinnerArray);
spinnerAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
selectionSpinner.setAdapter(spinnerAdapter);
selectionSpinner.setTag(openHABWidget);
if (spinnerSelectedIndex >= 0) selectionSpinner.setSelection(spinnerSelectedIndex);
selectionSpinner.setOnItemSelectedListener(new OnItemSelectedListener(){
public void onItemSelected(AdapterView<?> parent,View view,int index,long id){
Log.d(TAG,""String_Node_Str"" + index);
Spinner spinner=(Spinner)parent;
String selectedLabel=(String)spinner.getAdapter().getItem(index);
Log.d(TAG,""String_Node_Str"" + selectedLabel);
OpenHABWidget openHABWidget=(OpenHABWidget)parent.getTag();
if (openHABWidget != null) {
Log.d(TAG,""String_Node_Str"" + openHABWidget.getMapping(index).getLabel());
Iterator<OpenHABWidgetMapping> mappingIterator=openHABWidget.getMappings().iterator();
while (mappingIterator.hasNext()) {
OpenHABWidgetMapping openHABWidgetMapping=mappingIterator.next();
if (openHABWidgetMapping.getLabel().equals(selectedLabel)) {
Log.d(TAG,""String_Node_Str"" + openHABWidgetMapping.getCommand());
if (!openHABWidget.getItem().getState().equals(openHABWidgetMapping.getCommand())) {
Log.d(TAG,""String_Node_Str"");
sendItemCommand(openHABWidget.getItem(),openHABWidgetMapping.getCommand());
}
}
}
}
}
public void onNothingSelected(AdapterView<?> arg0){
}
}
);
break;
case TYPE_SETPOINT:
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
if (valueTextView != null) if (splitString.length > 1) {
valueTextView.setVisibility(View.VISIBLE);
valueTextView.setText(splitString[1]);
}
Button setPointMinusButton=(Button)widgetView.findViewById(R.id.setpointbutton_minus);
Button setPointPlusButton=(Button)widgetView.findViewById(R.id.setpointbutton_plus);
setPointMinusButton.setTag(openHABWidget);
setPointPlusButton.setTag(openHABWidget);
setPointMinusButton.setOnClickListener(new OnClickListener(){
public void onClick(View v){
Log.d(TAG,""String_Node_Str"");
OpenHABWidget setPointWidget=(OpenHABWidget)v.getTag();
float currentValue=Float.valueOf(setPointWidget.getItem().getState()).floatValue();
currentValue=currentValue - setPointWidget.getStep();
if (currentValue < setPointWidget.getMinValue()) currentValue=setPointWidget.getMinValue();
if (currentValue > setPointWidget.getMaxValue()) currentValue=setPointWidget.getMaxValue();
sendItemCommand(setPointWidget.getItem(),String.valueOf(currentValue));
}
}
);
setPointPlusButton.setOnClickListener(new OnClickListener(){
public void onClick(View v){
Log.d(TAG,""String_Node_Str"");
OpenHABWidget setPointWidget=(OpenHABWidget)v.getTag();
float currentValue=Float.valueOf(setPointWidget.getItem().getState()).floatValue();
currentValue=currentValue + setPointWidget.getStep();
if (currentValue < setPointWidget.getMinValue()) currentValue=setPointWidget.getMinValue();
if (currentValue > setPointWidget.getMaxValue()) currentValue=setPointWidget.getMaxValue();
sendItemCommand(setPointWidget.getItem(),String.valueOf(currentValue));
}
}
);
break;
default :
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
break;
}
LinearLayout dividerLayout=(LinearLayout)widgetView.findViewById(R.id.listdivider);
if (dividerLayout != null) {
if (position < this.getCount() - 1) {
if (this.getItemViewType(position + 1) == TYPE_FRAME) {
dividerLayout.setVisibility(View.GONE);
}
 else {
dividerLayout.setVisibility(View.VISIBLE);
}
}
 else {
dividerLayout.setVisibility(View.GONE);
}
}
return widgetView;
}","@SuppressWarnings(""String_Node_Str"") @Override public View getView(int position,View convertView,ViewGroup parent){
  final RelativeLayout widgetView;
  TextView labelTextView;
  TextView valueTextView;
  int widgetLayout;
  String[] splitString;
  OpenHABWidget openHABWidget=getItem(position);
  int screenWidth=((WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getWidth();
switch (this.getItemViewType(position)) {
case TYPE_FRAME:
    widgetLayout=R.layout.openhabwidgetlist_frameitem;
  break;
case TYPE_GROUP:
widgetLayout=R.layout.openhabwidgetlist_groupitem;
break;
case TYPE_SECTIONSWITCH:
widgetLayout=R.layout.openhabwidgetlist_sectionswitchitem;
break;
case TYPE_SWITCH:
widgetLayout=R.layout.openhabwidgetlist_switchitem;
break;
case TYPE_ROLLERSHUTTER:
widgetLayout=R.layout.openhabwidgetlist_rollershutteritem;
break;
case TYPE_TEXT:
widgetLayout=R.layout.openhabwidgetlist_textitem;
break;
case TYPE_SLIDER:
widgetLayout=R.layout.openhabwidgetlist_slideritem;
break;
case TYPE_IMAGE:
widgetLayout=R.layout.openhabwidgetlist_imageitem;
break;
case TYPE_SELECTION:
widgetLayout=R.layout.openhabwidgetlist_selectionitem;
break;
case TYPE_SETPOINT:
widgetLayout=R.layout.openhabwidgetlist_setpointitem;
break;
case TYPE_CHART:
widgetLayout=R.layout.openhabwidgetlist_chartitem;
break;
case TYPE_VIDEO:
widgetLayout=R.layout.openhabwidgetlist_videoitem;
break;
case TYPE_VIDEO_MJPEG:
widgetLayout=R.layout.openhabwidgetlist_videomjpegitem;
break;
case TYPE_WEB:
widgetLayout=R.layout.openhabwidgetlist_webitem;
break;
case TYPE_COLOR:
widgetLayout=R.layout.openhabwidgetlist_coloritem;
break;
default :
widgetLayout=R.layout.openhabwidgetlist_genericitem;
break;
}
if (convertView == null) {
widgetView=new RelativeLayout(getContext());
String inflater=Context.LAYOUT_INFLATER_SERVICE;
LayoutInflater vi;
vi=(LayoutInflater)getContext().getSystemService(inflater);
vi.inflate(widgetLayout,widgetView,true);
}
 else {
widgetView=(RelativeLayout)convertView;
}
Integer iconColor=openHABWidget.getIconColor();
Integer labelColor=openHABWidget.getLabelColor();
Integer valueColor=openHABWidget.getValueColor();
MySmartImageView widgetImage=(MySmartImageView)widgetView.findViewById(R.id.widgetimage);
if (widgetImage != null) {
if (openHABWidget.getIcon() != null) {
String iconUrl=openHABBaseUrl + ""String_Node_Str"" + Uri.encode(openHABWidget.getIcon() + ""String_Node_Str"");
widgetImage.setImageUrl(iconUrl,R.drawable.blank_icon,openHABUsername,openHABPassword);
if (iconColor != null) widgetImage.setColorFilter(iconColor);
 else widgetImage.clearColorFilter();
}
}
TextView defaultTextView=new TextView(widgetView.getContext());
labelTextView=(TextView)widgetView.findViewById(R.id.widgetlabel);
if (labelColor != null && labelTextView != null) {
Log.d(TAG,String.format(""String_Node_Str"",labelColor));
labelTextView.setTextColor(labelColor);
}
 else if (labelTextView != null) labelTextView.setTextColor(defaultTextView.getTextColors().getDefaultColor());
valueTextView=(TextView)widgetView.findViewById(R.id.widgetvalue);
if (valueColor != null && valueTextView != null) {
Log.d(TAG,String.format(""String_Node_Str"",valueColor));
valueTextView.setTextColor(valueColor);
}
 else if (valueTextView != null) valueTextView.setTextColor(defaultTextView.getTextColors().getDefaultColor());
defaultTextView=null;
switch (getItemViewType(position)) {
case TYPE_FRAME:
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
widgetView.setClickable(false);
if (openHABWidget.getLabel().length() > 0) {
widgetView.setVisibility(View.VISIBLE);
labelTextView.setVisibility(View.VISIBLE);
}
 else {
widgetView.setVisibility(View.GONE);
labelTextView.setVisibility(View.GONE);
}
break;
case TYPE_GROUP:
if (labelTextView != null && valueTextView != null) {
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
labelTextView.setText(splitString[0]);
if (splitString.length > 1) {
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setText(""String_Node_Str"");
}
}
break;
case TYPE_SECTIONSWITCH:
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
if (splitString.length > 1 && valueTextView != null) {
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setText(""String_Node_Str"");
}
RadioGroup sectionSwitchRadioGroup=(RadioGroup)widgetView.findViewById(R.id.sectionswitchradiogroup);
sectionSwitchRadioGroup.removeAllViews();
sectionSwitchRadioGroup.setTag(openHABWidget);
Iterator<OpenHABWidgetMapping> sectionMappingIterator=openHABWidget.getMappings().iterator();
while (sectionMappingIterator.hasNext()) {
OpenHABWidgetMapping widgetMapping=sectionMappingIterator.next();
SegmentedControlButton segmentedControlButton=(SegmentedControlButton)LayoutInflater.from(sectionSwitchRadioGroup.getContext()).inflate(R.layout.openhabwidgetlist_sectionswitchitem_button,sectionSwitchRadioGroup,false);
segmentedControlButton.setText(widgetMapping.getLabel());
segmentedControlButton.setTag(widgetMapping.getCommand());
if (openHABWidget.getItem() != null && widgetMapping.getCommand() != null) {
if (widgetMapping.getCommand().equals(openHABWidget.getItem().getState())) {
segmentedControlButton.setChecked(true);
}
 else {
segmentedControlButton.setChecked(false);
}
}
 else {
segmentedControlButton.setChecked(false);
}
segmentedControlButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View view){
Log.i(TAG,""String_Node_Str"");
RadioGroup group=(RadioGroup)view.getParent();
if (group.getTag() != null) {
OpenHABWidget radioWidget=(OpenHABWidget)group.getTag();
SegmentedControlButton selectedButton=(SegmentedControlButton)view;
if (selectedButton.getTag() != null) {
sendItemCommand(radioWidget.getItem(),(String)selectedButton.getTag());
}
}
}
}
);
sectionSwitchRadioGroup.addView(segmentedControlButton);
}
sectionSwitchRadioGroup.setOnCheckedChangeListener(new OnCheckedChangeListener(){
public void onCheckedChanged(RadioGroup group,int checkedId){
OpenHABWidget radioWidget=(OpenHABWidget)group.getTag();
SegmentedControlButton selectedButton=(SegmentedControlButton)group.findViewById(checkedId);
if (selectedButton != null) {
Log.d(TAG,""String_Node_Str"" + selectedButton.getText());
Log.d(TAG,""String_Node_Str"" + (String)selectedButton.getTag());
sendItemCommand(radioWidget.getItem(),(String)selectedButton.getTag());
}
}
}
);
break;
case TYPE_SWITCH:
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
Switch switchSwitch=(Switch)widgetView.findViewById(R.id.switchswitch);
if (openHABWidget.hasItem()) {
if (openHABWidget.getItem().getStateAsBoolean()) {
switchSwitch.setChecked(true);
}
 else {
switchSwitch.setChecked(false);
}
}
switchSwitch.setTag(openHABWidget.getItem());
switchSwitch.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
Switch switchSwitch=(Switch)v;
OpenHABItem linkedItem=(OpenHABItem)switchSwitch.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) if (!switchSwitch.isChecked()) {
sendItemCommand(linkedItem,""String_Node_Str"");
}
 else {
sendItemCommand(linkedItem,""String_Node_Str"");
}
return false;
}
}
);
break;
case TYPE_COLOR:
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
ImageButton colorUpButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_up);
ImageButton colorDownButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_down);
ImageButton colorColorButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_color);
colorUpButton.setTag(openHABWidget.getItem());
colorDownButton.setTag(openHABWidget.getItem());
colorColorButton.setTag(openHABWidget.getItem());
colorUpButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(colorItem,""String_Node_Str"");
return false;
}
}
);
colorDownButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(colorItem,""String_Node_Str"");
return false;
}
}
);
colorColorButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) {
Log.d(TAG,""String_Node_Str"");
ColorPickerDialog colorDialog=new ColorPickerDialog(widgetView.getContext(),new OnColorChangedListener(){
public void colorChanged(float[] hsv,View v){
Log.d(TAG,""String_Node_Str"" + hsv[0] + ""String_Node_Str""+ hsv[1]+ ""String_Node_Str""+ hsv[2]);
String newColor=String.valueOf(hsv[0]) + ""String_Node_Str"" + String.valueOf(hsv[1] * 100)+ ""String_Node_Str""+ String.valueOf(hsv[2] * 100);
OpenHABItem colorItem=(OpenHABItem)v.getTag();
sendItemCommand(colorItem,newColor);
}
}
,colorItem.getStateAsHSV());
colorDialog.setTag(colorItem);
colorDialog.show();
}
return false;
}
}
);
break;
case TYPE_ROLLERSHUTTER:
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
ImageButton rollershutterUpButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_up);
ImageButton rollershutterStopButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_stop);
ImageButton rollershutterDownButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_down);
rollershutterUpButton.setTag(openHABWidget.getItem());
rollershutterStopButton.setTag(openHABWidget.getItem());
rollershutterDownButton.setTag(openHABWidget.getItem());
rollershutterUpButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
rollershutterStopButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
rollershutterDownButton.setOnTouchListener(new OnTouchListener(){
public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
break;
case TYPE_TEXT:
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) if (splitString.length > 0) {
labelTextView.setText(splitString[0]);
}
 else {
labelTextView.setText(openHABWidget.getLabel());
}
if (valueTextView != null) if (splitString.length > 1) {
valueTextView.setVisibility(View.VISIBLE);
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setVisibility(View.GONE);
valueTextView.setText(""String_Node_Str"");
}
break;
case TYPE_SLIDER:
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
SeekBar sliderSeekBar=(SeekBar)widgetView.findViewById(R.id.sliderseekbar);
if (openHABWidget.hasItem()) {
sliderSeekBar.setTag(openHABWidget.getItem());
int sliderState=0;
try {
sliderState=(int)Float.parseFloat(openHABWidget.getItem().getState());
}
 catch (NumberFormatException e) {
if (e != null) {
Crittercism.logHandledException(e);
Log.e(TAG,e.getMessage());
}
if (openHABWidget.getItem().getState().equals(""String_Node_Str"")) {
sliderState=0;
}
 else if (openHABWidget.getItem().getState().equals(""String_Node_Str"")) {
sliderState=100;
}
}
sliderSeekBar.setProgress(sliderState);
sliderSeekBar.setOnSeekBarChangeListener(new OnSeekBarChangeListener(){
public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
}
public void onStartTrackingTouch(SeekBar seekBar){
Log.d(TAG,""String_Node_Str"" + seekBar.getProgress());
}
public void onStopTrackingTouch(SeekBar seekBar){
Log.d(TAG,""String_Node_Str"" + seekBar.getProgress());
OpenHABItem sliderItem=(OpenHABItem)seekBar.getTag();
if (sliderItem != null && seekBar != null) sendItemCommand(sliderItem,String.valueOf(seekBar.getProgress()));
}
}
);
}
break;
case TYPE_IMAGE:
MySmartImageView imageImage=(MySmartImageView)widgetView.findViewById(R.id.imageimage);
imageImage.setImageUrl(ensureAbsoluteURL(openHABBaseUrl,openHABWidget.getUrl()),false,openHABUsername,openHABPassword);
if (openHABWidget.getRefresh() > 0) {
imageImage.setRefreshRate(openHABWidget.getRefresh());
refreshImageList.add(imageImage);
}
break;
case TYPE_CHART:
MySmartImageView chartImage=(MySmartImageView)widgetView.findViewById(R.id.chartimage);
OpenHABItem chartItem=openHABWidget.getItem();
Random random=new Random();
String chartUrl=""String_Node_Str"";
if (chartItem != null) {
if (chartItem.getType().equals(""String_Node_Str"")) {
chartUrl=openHABBaseUrl + ""String_Node_Str"" + chartItem.getName()+ ""String_Node_Str""+ openHABWidget.getPeriod()+ ""String_Node_Str""+ String.valueOf(random.nextInt());
}
 else {
chartUrl=openHABBaseUrl + ""String_Node_Str"" + chartItem.getName()+ ""String_Node_Str""+ openHABWidget.getPeriod()+ ""String_Node_Str""+ String.valueOf(random.nextInt());
}
if (openHABWidget.getService() != null && openHABWidget.getService().length() > 0) {
chartUrl+=""String_Node_Str"" + openHABWidget.getService();
}
}
Log.d(TAG,""String_Node_Str"" + chartUrl);
if (chartImage == null) Log.e(TAG,""String_Node_Str"");
chartImage.setImageUrl(chartUrl,false,openHABUsername,openHABPassword);
ViewGroup.LayoutParams chartLayoutParams=chartImage.getLayoutParams();
chartLayoutParams.height=(int)(screenWidth / 1.88);
chartImage.setLayoutParams(chartLayoutParams);
if (openHABWidget.getRefresh() > 0) {
chartImage.setRefreshRate(openHABWidget.getRefresh());
refreshImageList.add(chartImage);
}
Log.d(TAG,""String_Node_Str"" + chartLayoutParams.width + ""String_Node_Str""+ chartLayoutParams.height);
break;
case TYPE_VIDEO:
VideoView videoVideo=(VideoView)widgetView.findViewById(R.id.videovideo);
Log.d(TAG,""String_Node_Str"" + openHABWidget.getUrl());
WindowManager wm=(WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE);
ViewGroup.LayoutParams videoLayoutParams=videoVideo.getLayoutParams();
videoLayoutParams.height=(int)(wm.getDefaultDisplay().getWidth() / 1.77);
videoVideo.setLayoutParams(videoLayoutParams);
if (!videoWidgetList.contains(videoVideo)) videoWidgetList.add(videoVideo);
if (!videoVideo.isPlaying()) {
videoVideo.setVideoURI(Uri.parse(openHABWidget.getUrl()));
videoVideo.start();
}
Log.d(TAG,""String_Node_Str"" + videoVideo.getHeight());
break;
case TYPE_VIDEO_MJPEG:
Log.d(TAG,""String_Node_Str"");
ImageView mjpegImage=(ImageView)widgetView.findViewById(R.id.mjpegimage);
MjpegStreamer mjpegStreamer=new MjpegStreamer(openHABWidget.getUrl(),this.openHABUsername,this.openHABPassword,this.getContext());
mjpegStreamer.setTargetImageView(mjpegImage);
mjpegStreamer.start();
if (!mjpegWidgetList.contains(mjpegStreamer)) mjpegWidgetList.add(mjpegStreamer);
break;
case TYPE_WEB:
WebView webWeb=(WebView)widgetView.findViewById(R.id.webweb);
if (openHABWidget.getHeight() > 0) {
ViewGroup.LayoutParams webLayoutParams=webWeb.getLayoutParams();
webLayoutParams.height=openHABWidget.getHeight() * 80;
webWeb.setLayoutParams(webLayoutParams);
}
webWeb.setWebViewClient(new WebViewClient());
webWeb.getSettings().setJavaScriptEnabled(true);
webWeb.loadUrl(openHABWidget.getUrl());
break;
case TYPE_SELECTION:
int spinnerSelectedIndex=-1;
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
Spinner selectionSpinner=(Spinner)widgetView.findViewById(R.id.selectionspinner);
ArrayList<String> spinnerArray=new ArrayList<String>();
Iterator<OpenHABWidgetMapping> mappingIterator=openHABWidget.getMappings().iterator();
while (mappingIterator.hasNext()) {
OpenHABWidgetMapping openHABWidgetMapping=mappingIterator.next();
spinnerArray.add(openHABWidgetMapping.getLabel());
if (openHABWidgetMapping.getCommand() != null && openHABWidget.getItem() != null) if (openHABWidgetMapping.getCommand().equals(openHABWidget.getItem().getState())) {
spinnerSelectedIndex=spinnerArray.size() - 1;
}
}
ArrayAdapter<String> spinnerAdapter=new ArrayAdapter<String>(this.getContext(),android.R.layout.simple_spinner_item,spinnerArray);
spinnerAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
selectionSpinner.setAdapter(spinnerAdapter);
selectionSpinner.setTag(openHABWidget);
if (spinnerSelectedIndex >= 0) selectionSpinner.setSelection(spinnerSelectedIndex);
selectionSpinner.setOnItemSelectedListener(new OnItemSelectedListener(){
public void onItemSelected(AdapterView<?> parent,View view,int index,long id){
Log.d(TAG,""String_Node_Str"" + index);
Spinner spinner=(Spinner)parent;
String selectedLabel=(String)spinner.getAdapter().getItem(index);
Log.d(TAG,""String_Node_Str"" + selectedLabel);
OpenHABWidget openHABWidget=(OpenHABWidget)parent.getTag();
if (openHABWidget != null) {
Log.d(TAG,""String_Node_Str"" + openHABWidget.getMapping(index).getLabel());
Iterator<OpenHABWidgetMapping> mappingIterator=openHABWidget.getMappings().iterator();
while (mappingIterator.hasNext()) {
OpenHABWidgetMapping openHABWidgetMapping=mappingIterator.next();
if (openHABWidgetMapping.getLabel().equals(selectedLabel)) {
Log.d(TAG,""String_Node_Str"" + openHABWidgetMapping.getCommand());
if (openHABWidget.getItem().getState() != null) if (!openHABWidget.getItem().getState().equals(openHABWidgetMapping.getCommand())) {
Log.d(TAG,""String_Node_Str"");
sendItemCommand(openHABWidget.getItem(),openHABWidgetMapping.getCommand());
}
}
}
}
}
public void onNothingSelected(AdapterView<?> arg0){
}
}
);
break;
case TYPE_SETPOINT:
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
if (valueTextView != null) if (splitString.length > 1) {
valueTextView.setVisibility(View.VISIBLE);
valueTextView.setText(splitString[1]);
}
Button setPointMinusButton=(Button)widgetView.findViewById(R.id.setpointbutton_minus);
Button setPointPlusButton=(Button)widgetView.findViewById(R.id.setpointbutton_plus);
setPointMinusButton.setTag(openHABWidget);
setPointPlusButton.setTag(openHABWidget);
setPointMinusButton.setOnClickListener(new OnClickListener(){
public void onClick(View v){
Log.d(TAG,""String_Node_Str"");
OpenHABWidget setPointWidget=(OpenHABWidget)v.getTag();
float currentValue=Float.valueOf(setPointWidget.getItem().getState()).floatValue();
currentValue=currentValue - setPointWidget.getStep();
if (currentValue < setPointWidget.getMinValue()) currentValue=setPointWidget.getMinValue();
if (currentValue > setPointWidget.getMaxValue()) currentValue=setPointWidget.getMaxValue();
sendItemCommand(setPointWidget.getItem(),String.valueOf(currentValue));
}
}
);
setPointPlusButton.setOnClickListener(new OnClickListener(){
public void onClick(View v){
Log.d(TAG,""String_Node_Str"");
OpenHABWidget setPointWidget=(OpenHABWidget)v.getTag();
float currentValue=Float.valueOf(setPointWidget.getItem().getState()).floatValue();
currentValue=currentValue + setPointWidget.getStep();
if (currentValue < setPointWidget.getMinValue()) currentValue=setPointWidget.getMinValue();
if (currentValue > setPointWidget.getMaxValue()) currentValue=setPointWidget.getMaxValue();
sendItemCommand(setPointWidget.getItem(),String.valueOf(currentValue));
}
}
);
break;
default :
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
break;
}
LinearLayout dividerLayout=(LinearLayout)widgetView.findViewById(R.id.listdivider);
if (dividerLayout != null) {
if (position < this.getCount() - 1) {
if (this.getItemViewType(position + 1) == TYPE_FRAME) {
dividerLayout.setVisibility(View.GONE);
}
 else {
dividerLayout.setVisibility(View.VISIBLE);
}
}
 else {
dividerLayout.setVisibility(View.GONE);
}
}
return widgetView;
}",0.9988235870790648
29753,"public void onItemSelected(AdapterView<?> parent,View view,int index,long id){
  Log.d(TAG,""String_Node_Str"" + index);
  Spinner spinner=(Spinner)parent;
  String selectedLabel=(String)spinner.getAdapter().getItem(index);
  Log.d(TAG,""String_Node_Str"" + selectedLabel);
  OpenHABWidget openHABWidget=(OpenHABWidget)parent.getTag();
  if (openHABWidget != null) {
    Log.d(TAG,""String_Node_Str"" + openHABWidget.getMapping(index).getLabel());
    Iterator<OpenHABWidgetMapping> mappingIterator=openHABWidget.getMappings().iterator();
    while (mappingIterator.hasNext()) {
      OpenHABWidgetMapping openHABWidgetMapping=mappingIterator.next();
      if (openHABWidgetMapping.getLabel().equals(selectedLabel)) {
        Log.d(TAG,""String_Node_Str"" + openHABWidgetMapping.getCommand());
        if (!openHABWidget.getItem().getState().equals(openHABWidgetMapping.getCommand())) {
          Log.d(TAG,""String_Node_Str"");
          sendItemCommand(openHABWidget.getItem(),openHABWidgetMapping.getCommand());
        }
      }
    }
  }
}","public void onItemSelected(AdapterView<?> parent,View view,int index,long id){
  Log.d(TAG,""String_Node_Str"" + index);
  Spinner spinner=(Spinner)parent;
  String selectedLabel=(String)spinner.getAdapter().getItem(index);
  Log.d(TAG,""String_Node_Str"" + selectedLabel);
  OpenHABWidget openHABWidget=(OpenHABWidget)parent.getTag();
  if (openHABWidget != null) {
    Log.d(TAG,""String_Node_Str"" + openHABWidget.getMapping(index).getLabel());
    Iterator<OpenHABWidgetMapping> mappingIterator=openHABWidget.getMappings().iterator();
    while (mappingIterator.hasNext()) {
      OpenHABWidgetMapping openHABWidgetMapping=mappingIterator.next();
      if (openHABWidgetMapping.getLabel().equals(selectedLabel)) {
        Log.d(TAG,""String_Node_Str"" + openHABWidgetMapping.getCommand());
        if (openHABWidget.getItem().getState() != null)         if (!openHABWidget.getItem().getState().equals(openHABWidgetMapping.getCommand())) {
          Log.d(TAG,""String_Node_Str"");
          sendItemCommand(openHABWidget.getItem(),openHABWidgetMapping.getCommand());
        }
      }
    }
  }
}",0.9736346516007532
29754,"public void sendItemCommand(String itemName,String command){
  try {
    StringEntity se=new StringEntity(command);
    mAsyncHttpClient.post(this,openHABBaseUrl + ""String_Node_Str"" + itemName,se,""String_Node_Str"",new AsyncHttpResponseHandler(){
      @Override public void onSuccess(      String response){
        Log.d(TAG,""String_Node_Str"");
      }
      @Override public void onFailure(      Throwable error,      String errorResponse){
        Log.e(TAG,""String_Node_Str"" + error.getMessage());
        if (errorResponse != null)         Log.e(TAG,""String_Node_Str"" + errorResponse);
      }
    }
);
  }
 catch (  UnsupportedEncodingException e) {
    if (e.getMessage() != null)     Log.e(TAG,e.getMessage());
  }
}","public void sendItemCommand(String itemName,String command){
  try {
    StringEntity se=new StringEntity(command,""String_Node_Str"");
    mAsyncHttpClient.post(this,openHABBaseUrl + ""String_Node_Str"" + itemName,se,""String_Node_Str"",new AsyncHttpResponseHandler(){
      @Override public void onSuccess(      String response){
        Log.d(TAG,""String_Node_Str"");
      }
      @Override public void onFailure(      Throwable error,      String errorResponse){
        Log.e(TAG,""String_Node_Str"" + error.getMessage());
        if (errorResponse != null)         Log.e(TAG,""String_Node_Str"" + errorResponse);
      }
    }
);
  }
 catch (  UnsupportedEncodingException e) {
    if (e.getMessage() != null)     Log.e(TAG,e.getMessage());
  }
}",0.9877216916780356
29755,"private void showAlertDialog(String alertMessage){
  AlertDialog.Builder builder=new AlertDialog.Builder(OpenHABMainActivity.this);
  builder.setMessage(alertMessage).setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
    }
  }
);
  AlertDialog alert=builder.create();
  alert.show();
}","private void showAlertDialog(String alertMessage){
  if (this.isFinishing())   return;
  AlertDialog.Builder builder=new AlertDialog.Builder(OpenHABMainActivity.this);
  builder.setMessage(alertMessage).setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
    }
  }
);
  AlertDialog alert=builder.create();
  alert.show();
}",0.9540816326530612
29756,"@Override public Fragment getItem(int position){
  Log.d(TAG,String.format(""String_Node_Str"",position));
  OpenHABWidgetListFragment fragment=fragmentList.get(position);
  return fragment;
}","@Override public Fragment getItem(int position){
  Log.d(TAG,String.format(""String_Node_Str"",position));
  return fragmentList.get(position);
}",0.8468468468468469
29757,"@Override public int getItemPosition(Object object){
  Log.d(TAG,""String_Node_Str"");
  if (actualColumnCountChanged)   return POSITION_NONE;
  if (fragmentList.contains(object)) {
    int index=fragmentList.indexOf(object);
    return index;
  }
  return POSITION_NONE;
}","@Override public int getItemPosition(Object object){
  Log.d(TAG,""String_Node_Str"");
  if (actualColumnCountChanged)   return POSITION_NONE;
  if (fragmentList.contains(object)) {
    return fragmentList.indexOf(object);
  }
  return POSITION_NONE;
}",0.8445297504798465
29758,"public void onClick(DialogInterface dialogInterface,int i){
  Log.d(TAG,""String_Node_Str"");
  MemorizingTrustManager.interactResult(decisionId,MTMDecision.DECISION_ABORT);
}","public void onClick(DialogInterface dialogInterface,int i){
  Log.d(TAG,""String_Node_Str"");
  sendMTMDecision(decisionId,MTMDecision.DECISION_ABORT);
}",0.8641975308641975
29759,"private void showCertificateDialog(final int decisionId,String certMessage){
  AlertDialog.Builder builder=new AlertDialog.Builder(OpenHABMainActivity.this);
  builder.setMessage(certMessage).setTitle(R.string.mtm_accept_cert);
  builder.setPositiveButton(R.string.mtm_decision_always,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialogInterface,    int i){
      Log.d(TAG,""String_Node_Str"");
      MemorizingTrustManager.interactResult(decisionId,MTMDecision.DECISION_ALWAYS);
    }
  }
);
  builder.setNeutralButton(R.string.mtm_decision_once,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialogInterface,    int i){
      Log.d(TAG,""String_Node_Str"");
      MemorizingTrustManager.interactResult(decisionId,MTMDecision.DECISION_ONCE);
    }
  }
);
  builder.setNegativeButton(R.string.mtm_decision_abort,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialogInterface,    int i){
      Log.d(TAG,""String_Node_Str"");
      MemorizingTrustManager.interactResult(decisionId,MTMDecision.DECISION_ABORT);
    }
  }
);
  AlertDialog certAlert=builder.create();
  certAlert.show();
}","private void showCertificateDialog(final int decisionId,String certMessage){
  AlertDialog.Builder builder=new AlertDialog.Builder(OpenHABMainActivity.this);
  builder.setMessage(certMessage).setTitle(R.string.mtm_accept_cert);
  builder.setPositiveButton(R.string.mtm_decision_always,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialogInterface,    int i){
      Log.d(TAG,""String_Node_Str"");
      sendMTMDecision(decisionId,MTMDecision.DECISION_ALWAYS);
    }
  }
);
  builder.setNeutralButton(R.string.mtm_decision_once,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialogInterface,    int i){
      Log.d(TAG,""String_Node_Str"");
      sendMTMDecision(decisionId,MTMDecision.DECISION_ONCE);
    }
  }
);
  builder.setNegativeButton(R.string.mtm_decision_abort,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialogInterface,    int i){
      Log.d(TAG,""String_Node_Str"");
      sendMTMDecision(decisionId,MTMDecision.DECISION_ABORT);
    }
  }
);
  AlertDialog certAlert=builder.create();
  certAlert.show();
}",0.9351771823681936
29760,"public void sendItemCommand(String itemName,String command){
  try {
    StringEntity se=new StringEntity(command);
    mAsyncHttpClient.post(this,openHABBaseUrl + ""String_Node_Str"" + itemName,se,""String_Node_Str"",new AsyncHttpResponseHandler(){
      @Override public void onSuccess(      String response){
        Log.d(TAG,""String_Node_Str"");
      }
      @Override public void onFailure(      Throwable error,      String errorResponse){
        Log.e(TAG,""String_Node_Str"" + error.getMessage());
        if (errorResponse != null)         Log.e(TAG,""String_Node_Str"" + errorResponse);
      }
    }
);
  }
 catch (  UnsupportedEncodingException e) {
    if (e != null)     Log.e(TAG,e.getMessage());
  }
}","public void sendItemCommand(String itemName,String command){
  try {
    StringEntity se=new StringEntity(command);
    mAsyncHttpClient.post(this,openHABBaseUrl + ""String_Node_Str"" + itemName,se,""String_Node_Str"",new AsyncHttpResponseHandler(){
      @Override public void onSuccess(      String response){
        Log.d(TAG,""String_Node_Str"");
      }
      @Override public void onFailure(      Throwable error,      String errorResponse){
        Log.e(TAG,""String_Node_Str"" + error.getMessage());
        if (errorResponse != null)         Log.e(TAG,""String_Node_Str"" + errorResponse);
      }
    }
);
  }
 catch (  UnsupportedEncodingException e) {
    if (e.getMessage() != null)     Log.e(TAG,e.getMessage());
  }
}",0.9909407665505228
29761,"/** 
 * This method is called when activity receives a new intent while running
 */
@Override public void onNewIntent(Intent newIntent){
  if (newIntent.getAction() != null) {
    Log.d(TAG,""String_Node_Str"" + newIntent.getAction().toString());
    if (newIntent.getAction().equals(""String_Node_Str"")) {
      Log.d(TAG,""String_Node_Str"");
      if (newIntent.getDataString() != null) {
        Log.d(TAG,""String_Node_Str"" + newIntent.getDataString());
        onNfcTag(newIntent.getDataString());
      }
    }
  }
}","/** 
 * This method is called when activity receives a new intent while running
 */
@Override public void onNewIntent(Intent newIntent){
  if (newIntent.getAction() != null) {
    Log.d(TAG,""String_Node_Str"" + newIntent.getAction());
    if (newIntent.getAction().equals(""String_Node_Str"")) {
      Log.d(TAG,""String_Node_Str"");
      if (newIntent.getDataString() != null) {
        Log.d(TAG,""String_Node_Str"" + newIntent.getDataString());
        onNfcTag(newIntent.getDataString());
      }
    }
  }
}",0.989247311827957
29762,"public void start(){
  SharedPreferences settings=PreferenceManager.getDefaultSharedPreferences(mCtx);
  mCtx.registerReceiver(mConnectivityChangeReceiver,new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
  if (settings.getBoolean(""String_Node_Str"",false)) {
    mOpenHABUrl=mCtx.getString(R.string.openhab_demo_url);
    Log.d(TAG,""String_Node_Str"" + mOpenHABUrl);
    openHABTracked(mOpenHABUrl,mCtx.getString(R.string.info_demo_mode));
    return;
  }
 else {
    mOpenHABUrl=Util.normalizeUrl(settings.getString(""String_Node_Str"",""String_Node_Str""));
    if (mOpenHABUrl.length() > 0) {
      Log.d(TAG,""String_Node_Str"" + mOpenHABUrl);
      openHABTracked(mOpenHABUrl,mCtx.getString(R.string.info_conn_url));
      return;
    }
 else {
      ConnectivityManager connectivityManager=(ConnectivityManager)mCtx.getSystemService(Context.CONNECTIVITY_SERVICE);
      NetworkInfo activeNetworkInfo=connectivityManager.getActiveNetworkInfo();
      if (activeNetworkInfo != null) {
        Log.d(TAG,""String_Node_Str"");
        if (activeNetworkInfo.getType() == ConnectivityManager.TYPE_MOBILE || mDiscoveryEnabled == false) {
          if (!mDiscoveryEnabled) {
            Log.d(TAG,""String_Node_Str"");
          }
 else {
            Log.d(TAG,""String_Node_Str"" + activeNetworkInfo.getSubtypeName() + ""String_Node_Str"");
          }
          mOpenHABUrl=Util.normalizeUrl(settings.getString(""String_Node_Str"",""String_Node_Str""));
          if (mOpenHABUrl.length() > 0) {
            Log.d(TAG,""String_Node_Str"" + mOpenHABUrl);
            openHABTracked(mOpenHABUrl,mCtx.getString(R.string.info_conn_rem_url));
          }
 else {
            openHABError(mCtx.getString(R.string.error_no_url));
          }
        }
        if (activeNetworkInfo.getType() == ConnectivityManager.TYPE_WIFI || activeNetworkInfo.getType() == ConnectivityManager.TYPE_ETHERNET) {
          Log.i(TAG,""String_Node_Str"");
          mServiceResolver=new AsyncServiceResolver(mCtx,this,mOpenHABServiceType);
          bonjourDiscoveryStarted();
          mServiceResolver.start();
        }
 else {
          Log.e(TAG,""String_Node_Str"" + activeNetworkInfo.getTypeName() + ""String_Node_Str"");
          openHABError(""String_Node_Str"" + activeNetworkInfo.getTypeName() + ""String_Node_Str"");
        }
      }
 else {
        Log.e(TAG,""String_Node_Str"");
        openHABError(mCtx.getString(R.string.error_network_not_available));
      }
    }
  }
}","public void start(){
  SharedPreferences settings=PreferenceManager.getDefaultSharedPreferences(mCtx);
  mCtx.registerReceiver(mConnectivityChangeReceiver,new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
  if (settings.getBoolean(""String_Node_Str"",false)) {
    mOpenHABUrl=mCtx.getString(R.string.openhab_demo_url);
    Log.d(TAG,""String_Node_Str"" + mOpenHABUrl);
    openHABTracked(mOpenHABUrl,mCtx.getString(R.string.info_demo_mode));
    return;
  }
 else {
    mOpenHABUrl=Util.normalizeUrl(settings.getString(""String_Node_Str"",""String_Node_Str""));
    if (mOpenHABUrl.length() > 0) {
      Log.d(TAG,""String_Node_Str"" + mOpenHABUrl);
      openHABTracked(mOpenHABUrl,mCtx.getString(R.string.info_conn_url));
      return;
    }
 else {
      ConnectivityManager connectivityManager=(ConnectivityManager)mCtx.getSystemService(Context.CONNECTIVITY_SERVICE);
      NetworkInfo activeNetworkInfo=connectivityManager.getActiveNetworkInfo();
      if (activeNetworkInfo != null) {
        Log.d(TAG,""String_Node_Str"");
        if (activeNetworkInfo.getType() == ConnectivityManager.TYPE_MOBILE || mDiscoveryEnabled == false) {
          if (!mDiscoveryEnabled) {
            Log.d(TAG,""String_Node_Str"");
          }
 else {
            Log.d(TAG,""String_Node_Str"" + activeNetworkInfo.getSubtypeName() + ""String_Node_Str"");
          }
          mOpenHABUrl=Util.normalizeUrl(settings.getString(""String_Node_Str"",""String_Node_Str""));
          if (mOpenHABUrl.length() > 0) {
            Log.d(TAG,""String_Node_Str"" + mOpenHABUrl);
            openHABTracked(mOpenHABUrl,mCtx.getString(R.string.info_conn_rem_url));
          }
 else {
            openHABError(mCtx.getString(R.string.error_no_url));
          }
        }
 else         if (activeNetworkInfo.getType() == ConnectivityManager.TYPE_WIFI || activeNetworkInfo.getType() == ConnectivityManager.TYPE_ETHERNET) {
          Log.i(TAG,""String_Node_Str"");
          mServiceResolver=new AsyncServiceResolver(mCtx,this,mOpenHABServiceType);
          bonjourDiscoveryStarted();
          mServiceResolver.start();
        }
 else {
          Log.e(TAG,""String_Node_Str"" + activeNetworkInfo.getTypeName() + ""String_Node_Str"");
          openHABError(""String_Node_Str"" + activeNetworkInfo.getTypeName() + ""String_Node_Str"");
        }
      }
 else {
        Log.e(TAG,""String_Node_Str"");
        openHABError(mCtx.getString(R.string.error_network_not_available));
      }
    }
  }
}",0.9987735077677842
29763,"public void writeTag(Tag tag,String openhabUri){
  Log.d(TAG,""String_Node_Str"");
  TextView writeTagMessage=(TextView)findViewById(R.id.write_tag_message);
  NdefRecord[] ndefRecords;
  ndefRecords=new NdefRecord[1];
  ndefRecords[0]=NdefRecord.createUri(openhabUri);
  NdefMessage message=new NdefMessage(ndefRecords);
  NdefFormatable ndefFormatable=NdefFormatable.get(tag);
  if (ndefFormatable != null) {
    Log.d(TAG,""String_Node_Str"");
    try {
      ndefFormatable.connect();
      ndefFormatable.format(message);
      ndefFormatable.close();
      writeTagMessage.setText(R.string.info_write_tag_finished);
      autoCloseActivity();
    }
 catch (    IOException e) {
      if (e.getMessage() != null)       Log.e(TAG,e.getMessage());
      writeTagMessage.setText(R.string.info_write_failed);
    }
catch (    FormatException e) {
      Log.e(TAG,e.getMessage());
      writeTagMessage.setText(R.string.info_write_failed);
    }
  }
 else {
    Log.d(TAG,""String_Node_Str"");
    Ndef ndef=Ndef.get(tag);
    if (ndef != null) {
      try {
        Log.d(TAG,""String_Node_Str"");
        ndef.connect();
        Log.d(TAG,""String_Node_Str"");
        if (ndef.isWritable()) {
          ndef.writeNdefMessage(message);
        }
        Log.d(TAG,""String_Node_Str"");
        ndef.close();
        writeTagMessage.setText(R.string.info_write_tag_finished);
        autoCloseActivity();
      }
 catch (      IOException e) {
        Log.e(TAG,e.getMessage());
      }
catch (      FormatException e) {
        Log.e(TAG,e.getMessage());
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"");
      writeTagMessage.setText(R.string.info_write_failed);
    }
  }
}","public void writeTag(Tag tag,String openhabUri){
  Log.d(TAG,""String_Node_Str"");
  TextView writeTagMessage=(TextView)findViewById(R.id.write_tag_message);
  NdefRecord[] ndefRecords;
  ndefRecords=new NdefRecord[1];
  ndefRecords[0]=NdefRecord.createUri(openhabUri);
  NdefMessage message=new NdefMessage(ndefRecords);
  NdefFormatable ndefFormatable=NdefFormatable.get(tag);
  if (ndefFormatable != null) {
    Log.d(TAG,""String_Node_Str"");
    try {
      ndefFormatable.connect();
      ndefFormatable.format(message);
      ndefFormatable.close();
      writeTagMessage.setText(R.string.info_write_tag_finished);
      autoCloseActivity();
    }
 catch (    IOException e) {
      if (e.getMessage() != null)       Log.e(TAG,e.getMessage());
      writeTagMessage.setText(R.string.info_write_failed);
    }
catch (    FormatException e) {
      Log.e(TAG,e.getMessage());
      writeTagMessage.setText(R.string.info_write_failed);
    }
  }
 else {
    Log.d(TAG,""String_Node_Str"");
    Ndef ndef=Ndef.get(tag);
    if (ndef != null) {
      try {
        Log.d(TAG,""String_Node_Str"");
        ndef.connect();
        Log.d(TAG,""String_Node_Str"");
        if (ndef.isWritable()) {
          ndef.writeNdefMessage(message);
        }
        Log.d(TAG,""String_Node_Str"");
        ndef.close();
        writeTagMessage.setText(R.string.info_write_tag_finished);
        autoCloseActivity();
      }
 catch (      IOException e) {
        if (e != null)         Log.e(TAG,e.getMessage());
      }
catch (      FormatException e) {
        Log.e(TAG,e.getMessage());
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"");
      writeTagMessage.setText(R.string.info_write_failed);
    }
  }
}",0.9931730483823092
29764,"@Override public void onCreate(Bundle savedInstanceState){
  Log.d(""String_Node_Str"",""String_Node_Str"");
  PreferenceManager.setDefaultValues(this,R.xml.preferences,false);
  try {
    PreferenceManager.getDefaultSharedPreferences(this).edit().putString(""String_Node_Str"",getPackageManager().getPackageInfo(getPackageName(),0).versionName).commit();
  }
 catch (  NameNotFoundException e1) {
  }
  Util.setActivityTheme(this);
  openHABServiceType=getString(R.string.openhab_service_type);
  requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
  requestWindowFeature(Window.FEATURE_PROGRESS);
  setProgressBarIndeterminateVisibility(true);
  JSONObject crittercismConfig=new JSONObject();
  try {
    crittercismConfig.put(""String_Node_Str"",true);
  }
 catch (  JSONException e) {
    if (e.getMessage() != null)     Log.e(TAG,e.getMessage());
 else     Log.e(TAG,""String_Node_Str"");
  }
  Crittercism.init(getApplicationContext(),""String_Node_Str"",crittercismConfig);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.openhabwidgetlist);
  SharedPreferences settings=PreferenceManager.getDefaultSharedPreferences(this);
  if (settings.getBoolean(""String_Node_Str"",false)) {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
  }
  openHABUsername=settings.getString(""String_Node_Str"",null);
  openHABPassword=settings.getString(""String_Node_Str"",null);
  openHABWidgetDataSource=new OpenHABWidgetDataSource();
  openHABWidgetAdapter=new OpenHABWidgetAdapter(OpenHABWidgetListActivity.this,R.layout.openhabwidgetlist_genericitem,widgetList);
  getListView().setAdapter(openHABWidgetAdapter);
  openHABWidgetAdapter.setOpenHABUsername(openHABUsername);
  openHABWidgetAdapter.setOpenHABPassword(openHABPassword);
  this.getActionBar().setHomeButtonEnabled(true);
  if (savedInstanceState != null) {
    displayPageUrl=savedInstanceState.getString(""String_Node_Str"");
    pageStack=savedInstanceState.getParcelableArrayList(""String_Node_Str"");
    openHABBaseUrl=savedInstanceState.getString(""String_Node_Str"");
    sitemapRootUrl=savedInstanceState.getString(""String_Node_Str"");
    openHABWidgetAdapter.setOpenHABBaseUrl(openHABBaseUrl);
  }
  if (displayPageUrl.length() > 0) {
    Log.d(TAG,""String_Node_Str"" + displayPageUrl);
    showPage(displayPageUrl,false);
  }
 else {
    if (getIntent() != null) {
      if (getIntent().getAction().equals(""String_Node_Str"")) {
        nfcTagData=getIntent().getDataString();
      }
    }
    if (settings.getBoolean(""String_Node_Str"",false)) {
      openHABBaseUrl=getString(R.string.openhab_demo_url);
      Log.i(TAG,""String_Node_Str"" + openHABBaseUrl);
      Toast.makeText(getApplicationContext(),getString(R.string.info_demo_mode),Toast.LENGTH_LONG).show();
      showTime();
    }
 else {
      openHABBaseUrl=normalizeUrl(settings.getString(""String_Node_Str"",""String_Node_Str""));
      if (openHABBaseUrl.length() > 0) {
        Log.i(TAG,""String_Node_Str"" + openHABBaseUrl);
        Toast.makeText(getApplicationContext(),getString(R.string.info_conn_url),Toast.LENGTH_SHORT).show();
        showTime();
      }
 else {
        ConnectivityManager connectivityManager=(ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo activeNetworkInfo=connectivityManager.getActiveNetworkInfo();
        if (activeNetworkInfo != null) {
          Log.i(TAG,""String_Node_Str"");
          if (activeNetworkInfo.getType() == ConnectivityManager.TYPE_MOBILE) {
            Log.i(TAG,""String_Node_Str"" + activeNetworkInfo.getSubtypeName() + ""String_Node_Str"");
            openHABBaseUrl=normalizeUrl(settings.getString(""String_Node_Str"",""String_Node_Str""));
            if (openHABBaseUrl.length() > 0) {
              Toast.makeText(getApplicationContext(),getString(R.string.info_conn_rem_url),Toast.LENGTH_SHORT).show();
              Log.i(TAG,""String_Node_Str"" + openHABBaseUrl);
              showTime();
            }
 else {
              Toast.makeText(getApplicationContext(),getString(R.string.error_no_url),Toast.LENGTH_LONG).show();
            }
          }
          if (activeNetworkInfo.getType() == ConnectivityManager.TYPE_WIFI || activeNetworkInfo.getType() == ConnectivityManager.TYPE_ETHERNET) {
            Log.i(TAG,""String_Node_Str"");
            AsyncServiceResolver serviceResolver=new AsyncServiceResolver(this,openHABServiceType);
            progressDialog=ProgressDialog.show(this,""String_Node_Str"",""String_Node_Str"",true);
            serviceResolver.start();
          }
 else {
            Log.i(TAG,""String_Node_Str"" + activeNetworkInfo.getTypeName() + ""String_Node_Str"");
          }
        }
 else {
          Log.i(TAG,""String_Node_Str"");
          Toast.makeText(getApplicationContext(),getString(R.string.error_network_not_available),Toast.LENGTH_LONG).show();
        }
      }
    }
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  Log.d(""String_Node_Str"",""String_Node_Str"");
  PreferenceManager.setDefaultValues(this,R.xml.preferences,false);
  try {
    PreferenceManager.getDefaultSharedPreferences(this).edit().putString(""String_Node_Str"",getPackageManager().getPackageInfo(getPackageName(),0).versionName).commit();
  }
 catch (  NameNotFoundException e1) {
  }
  Util.setActivityTheme(this);
  openHABServiceType=getString(R.string.openhab_service_type);
  requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
  requestWindowFeature(Window.FEATURE_PROGRESS);
  setProgressBarIndeterminateVisibility(true);
  JSONObject crittercismConfig=new JSONObject();
  try {
    crittercismConfig.put(""String_Node_Str"",true);
  }
 catch (  JSONException e) {
    if (e.getMessage() != null)     Log.e(TAG,e.getMessage());
 else     Log.e(TAG,""String_Node_Str"");
  }
  Crittercism.init(getApplicationContext(),""String_Node_Str"",crittercismConfig);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.openhabwidgetlist);
  SharedPreferences settings=PreferenceManager.getDefaultSharedPreferences(this);
  if (settings.getBoolean(""String_Node_Str"",false)) {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
  }
  openHABUsername=settings.getString(""String_Node_Str"",null);
  openHABPassword=settings.getString(""String_Node_Str"",null);
  openHABWidgetDataSource=new OpenHABWidgetDataSource();
  openHABWidgetAdapter=new OpenHABWidgetAdapter(OpenHABWidgetListActivity.this,R.layout.openhabwidgetlist_genericitem,widgetList);
  getListView().setAdapter(openHABWidgetAdapter);
  openHABWidgetAdapter.setOpenHABUsername(openHABUsername);
  openHABWidgetAdapter.setOpenHABPassword(openHABPassword);
  this.getActionBar().setHomeButtonEnabled(true);
  if (savedInstanceState != null) {
    displayPageUrl=savedInstanceState.getString(""String_Node_Str"");
    pageStack=savedInstanceState.getParcelableArrayList(""String_Node_Str"");
    openHABBaseUrl=savedInstanceState.getString(""String_Node_Str"");
    sitemapRootUrl=savedInstanceState.getString(""String_Node_Str"");
    openHABWidgetAdapter.setOpenHABBaseUrl(openHABBaseUrl);
  }
  if (displayPageUrl.length() > 0) {
    Log.d(TAG,""String_Node_Str"" + displayPageUrl);
    showPage(displayPageUrl,false);
  }
 else {
    if (getIntent() != null) {
      if (getIntent().getAction().equals(""String_Node_Str"")) {
        nfcTagData=getIntent().getDataString();
      }
    }
    if (settings.getBoolean(""String_Node_Str"",false)) {
      openHABBaseUrl=getString(R.string.openhab_demo_url);
      Log.i(TAG,""String_Node_Str"" + openHABBaseUrl);
      Toast.makeText(getApplicationContext(),getString(R.string.info_demo_mode),Toast.LENGTH_LONG).show();
      showTime();
    }
 else {
      openHABBaseUrl=normalizeUrl(settings.getString(""String_Node_Str"",""String_Node_Str""));
      if (openHABBaseUrl.length() > 0) {
        Log.i(TAG,""String_Node_Str"" + openHABBaseUrl);
        Toast.makeText(getApplicationContext(),getString(R.string.info_conn_url),Toast.LENGTH_SHORT).show();
        showTime();
      }
 else {
        ConnectivityManager connectivityManager=(ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo activeNetworkInfo=connectivityManager.getActiveNetworkInfo();
        if (activeNetworkInfo != null) {
          Log.i(TAG,""String_Node_Str"");
          if (activeNetworkInfo.getType() == ConnectivityManager.TYPE_MOBILE) {
            Log.i(TAG,""String_Node_Str"" + activeNetworkInfo.getSubtypeName() + ""String_Node_Str"");
            openHABBaseUrl=normalizeUrl(settings.getString(""String_Node_Str"",""String_Node_Str""));
            if (openHABBaseUrl.length() > 0) {
              Toast.makeText(getApplicationContext(),getString(R.string.info_conn_rem_url),Toast.LENGTH_SHORT).show();
              Log.i(TAG,""String_Node_Str"" + openHABBaseUrl);
              showTime();
            }
 else {
              Toast.makeText(getApplicationContext(),getString(R.string.error_no_url),Toast.LENGTH_LONG).show();
            }
          }
          if (activeNetworkInfo.getType() == ConnectivityManager.TYPE_WIFI || activeNetworkInfo.getType() == ConnectivityManager.TYPE_ETHERNET) {
            Log.i(TAG,""String_Node_Str"");
            this.serviceResolver=new AsyncServiceResolver(this,openHABServiceType);
            progressDialog=ProgressDialog.show(this,""String_Node_Str"",""String_Node_Str"",true);
            this.serviceResolver.start();
          }
 else {
            Log.i(TAG,""String_Node_Str"" + activeNetworkInfo.getTypeName() + ""String_Node_Str"");
          }
        }
 else {
          Log.i(TAG,""String_Node_Str"");
          Toast.makeText(getApplicationContext(),getString(R.string.error_network_not_available),Toast.LENGTH_LONG).show();
        }
      }
    }
  }
}",0.9968004954071628
29765,"@Override protected void onDestroy(){
  super.onDestroy();
  Log.d(TAG,""String_Node_Str"" + this.displayPageUrl);
  if (pageAsyncHttpClient != null)   pageAsyncHttpClient.cancelRequests(this,true);
}","@Override protected void onDestroy(){
  super.onDestroy();
  Log.d(TAG,""String_Node_Str"" + this.displayPageUrl);
  if (this.progressDialog != null)   this.progressDialog.dismiss();
  if (this.serviceResolver != null)   this.serviceResolver.interrupt();
  if (pageAsyncHttpClient != null)   pageAsyncHttpClient.cancelRequests(this,true);
}",0.667910447761194
29766,"@Override public void onServiceResolveFailed(){
  progressDialog.dismiss();
  Log.i(TAG,""String_Node_Str"");
  SharedPreferences settings=PreferenceManager.getDefaultSharedPreferences(this);
  openHABBaseUrl=normalizeUrl(settings.getString(""String_Node_Str"",""String_Node_Str""));
  if (openHABBaseUrl.length() > 0) {
    Toast.makeText(getApplicationContext(),getString(R.string.info_conn_rem_url),Toast.LENGTH_SHORT).show();
    Log.i(TAG,""String_Node_Str"" + openHABBaseUrl);
    showTime();
  }
 else {
    Toast.makeText(getApplicationContext(),getString(R.string.error_no_url),Toast.LENGTH_LONG).show();
  }
}","@Override public void onServiceResolveFailed(){
  if (progressDialog.isShowing())   progressDialog.dismiss();
  Log.i(TAG,""String_Node_Str"");
  SharedPreferences settings=PreferenceManager.getDefaultSharedPreferences(this);
  openHABBaseUrl=normalizeUrl(settings.getString(""String_Node_Str"",""String_Node_Str""));
  if (openHABBaseUrl.length() > 0) {
    Toast.makeText(getApplicationContext(),getString(R.string.info_conn_rem_url),Toast.LENGTH_SHORT).show();
    Log.i(TAG,""String_Node_Str"" + openHABBaseUrl);
    showTime();
  }
 else {
    Toast.makeText(getApplicationContext(),getString(R.string.error_no_url),Toast.LENGTH_LONG).show();
  }
}",0.9729299363057324
29767,"@SuppressWarnings(""String_Node_Str"") @Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.preferences);
  Preference urlPreference=getPreferenceScreen().findPreference(""String_Node_Str"");
  Preference altUrlPreference=getPreferenceScreen().findPreference(""String_Node_Str"");
  urlPreference.setOnPreferenceChangeListener(new OnPreferenceChangeListener(){
    @Override public boolean onPreferenceChange(    Preference preference,    Object newValue){
      String newUrl=(String)newValue;
      if (newUrl.length() == 0)       return true;
      if (urlIsValid(newUrl)) {
        return true;
      }
      showAlertDialog(""String_Node_Str"");
      return false;
    }
  }
);
  altUrlPreference.setOnPreferenceChangeListener(new OnPreferenceChangeListener(){
    @Override public boolean onPreferenceChange(    Preference preference,    Object newValue){
      String newUrl=(String)newValue;
      if (newUrl.length() == 0)       return true;
      if (urlIsValid(newUrl)) {
        return true;
      }
      showAlertDialog(""String_Node_Str"");
      return false;
    }
  }
);
  setResult(RESULT_OK);
}","@SuppressWarnings(""String_Node_Str"") @Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.preferences);
  Preference urlPreference=getPreferenceScreen().findPreference(""String_Node_Str"");
  Preference altUrlPreference=getPreferenceScreen().findPreference(""String_Node_Str"");
  urlPreference.setOnPreferenceChangeListener(new OnPreferenceChangeListener(){
    @Override public boolean onPreferenceChange(    Preference preference,    Object newValue){
      Log.d(""String_Node_Str"",""String_Node_Str"" + (String)newValue);
      String newUrl=(String)newValue;
      if (newUrl.length() == 0)       return true;
      if (urlIsValid(newUrl)) {
        return true;
      }
      showAlertDialog(getString(R.string.erorr_invalid_url));
      return false;
    }
  }
);
  altUrlPreference.setOnPreferenceChangeListener(new OnPreferenceChangeListener(){
    @Override public boolean onPreferenceChange(    Preference preference,    Object newValue){
      String newUrl=(String)newValue;
      if (newUrl.length() == 0)       return true;
      if (urlIsValid(newUrl)) {
        return true;
      }
      showAlertDialog(getString(R.string.erorr_invalid_url));
      return false;
    }
  }
);
  setResult(RESULT_OK);
}",0.9285425918449738
29768,"@Override public boolean onPreferenceChange(Preference preference,Object newValue){
  String newUrl=(String)newValue;
  if (newUrl.length() == 0)   return true;
  if (urlIsValid(newUrl)) {
    return true;
  }
  showAlertDialog(""String_Node_Str"");
  return false;
}","@Override public boolean onPreferenceChange(Preference preference,Object newValue){
  String newUrl=(String)newValue;
  if (newUrl.length() == 0)   return true;
  if (urlIsValid(newUrl)) {
    return true;
  }
  showAlertDialog(getString(R.string.erorr_invalid_url));
  return false;
}",0.9345454545454546
29769,"private String normalizeUrl(String sourceUrl){
  String normalizedUrl=""String_Node_Str"";
  try {
    URL url=new URL(sourceUrl);
    normalizedUrl=url.toString();
    if (!normalizedUrl.endsWith(""String_Node_Str""))     normalizedUrl=normalizedUrl + ""String_Node_Str"";
  }
 catch (  MalformedURLException e) {
    Log.d(TAG,""String_Node_Str"");
  }
  return normalizedUrl;
}","private String normalizeUrl(String sourceUrl){
  String normalizedUrl=""String_Node_Str"";
  try {
    URL url=new URL(sourceUrl);
    normalizedUrl=url.toString();
    normalizedUrl=normalizedUrl.replace(""String_Node_Str"",""String_Node_Str"");
    normalizedUrl=normalizedUrl.replace(""String_Node_Str"",""String_Node_Str"");
    if (!normalizedUrl.endsWith(""String_Node_Str""))     normalizedUrl=normalizedUrl + ""String_Node_Str"";
  }
 catch (  MalformedURLException e) {
    Log.d(TAG,""String_Node_Str"");
  }
  return normalizedUrl;
}",0.8266666666666667
29770,"@Override public void onResume(){
  Log.i(TAG,""String_Node_Str"");
  super.onResume();
  PendingIntent pendingIntent=PendingIntent.getActivity(this,0,new Intent(this,getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP),0);
  NfcAdapter.getDefaultAdapter(this).enableForegroundDispatch(this,pendingIntent,null,null);
}","@Override public void onResume(){
  Log.i(TAG,""String_Node_Str"");
  super.onResume();
  PendingIntent pendingIntent=PendingIntent.getActivity(this,0,new Intent(this,getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP),0);
  if (NfcAdapter.getDefaultAdapter(this) != null)   NfcAdapter.getDefaultAdapter(this).enableForegroundDispatch(this,pendingIntent,null,null);
}",0.9269005847953216
29771,"@Override public void onNewIntent(Intent newIntent){
  Log.i(TAG,""String_Node_Str"" + newIntent.toString());
  try {
    URI openhabURI=new URI(newIntent.getDataString());
    Log.i(TAG,openhabURI.getScheme());
    Log.i(TAG,openhabURI.getHost());
    Log.i(TAG,openhabURI.getPath());
    if (openhabURI.getHost().equals(""String_Node_Str"")) {
      Log.i(TAG,""String_Node_Str"");
      String newPageUrl=this.openHABBaseUrl + ""String_Node_Str"" + openhabURI.getPath();
      Log.i(TAG,""String_Node_Str"" + newPageUrl);
      navigateToPage(newPageUrl);
    }
  }
 catch (  URISyntaxException e) {
    e.printStackTrace();
  }
}","@Override public void onNewIntent(Intent newIntent){
  Log.i(TAG,""String_Node_Str"" + newIntent.toString());
  if (newIntent.getDataString() != null)   try {
    URI openhabURI=new URI(newIntent.getDataString());
    Log.i(TAG,openhabURI.getScheme());
    Log.i(TAG,openhabURI.getHost());
    Log.i(TAG,openhabURI.getPath());
    if (openhabURI.getHost().equals(""String_Node_Str"")) {
      Log.i(TAG,""String_Node_Str"");
      String newPageUrl=this.openHABBaseUrl + ""String_Node_Str"" + openhabURI.getPath();
      Log.i(TAG,""String_Node_Str"" + newPageUrl);
      navigateToPage(newPageUrl);
    }
  }
 catch (  URISyntaxException e) {
    e.printStackTrace();
  }
}",0.9681429681429682
29772,"public void writeTag(Tag tag,String openhabUri){
  Log.i(TAG,""String_Node_Str"");
  Ndef ndef=Ndef.get(tag);
  if (ndef != null) {
    try {
      NdefRecord[] ndefRecords;
      ndefRecords=new NdefRecord[1];
      ndefRecords[0]=NdefRecord.createUri(openhabUri);
      NdefMessage message=new NdefMessage(ndefRecords);
      Log.i(TAG,""String_Node_Str"");
      ndef.connect();
      Log.i(TAG,""String_Node_Str"");
      if (ndef.isWritable()) {
        ndef.writeNdefMessage(message);
      }
      Log.i(TAG,""String_Node_Str"");
      ndef.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
catch (    FormatException e) {
      e.printStackTrace();
    }
  }
}","public void writeTag(Tag tag,String openhabUri){
  Log.i(TAG,""String_Node_Str"");
  NdefRecord[] ndefRecords;
  ndefRecords=new NdefRecord[1];
  ndefRecords[0]=NdefRecord.createUri(openhabUri);
  NdefMessage message=new NdefMessage(ndefRecords);
  NdefFormatable ndefFormatable=NdefFormatable.get(tag);
  if (ndefFormatable != null) {
    Log.i(TAG,""String_Node_Str"");
    try {
      ndefFormatable.connect();
      ndefFormatable.format(message);
      ndefFormatable.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
catch (    FormatException e) {
      e.printStackTrace();
    }
  }
 else {
    Log.i(TAG,""String_Node_Str"");
    Ndef ndef=Ndef.get(tag);
    if (ndef != null) {
      try {
        Log.i(TAG,""String_Node_Str"");
        ndef.connect();
        Log.i(TAG,""String_Node_Str"");
        if (ndef.isWritable()) {
          ndef.writeNdefMessage(message);
        }
        Log.i(TAG,""String_Node_Str"");
        ndef.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
catch (      FormatException e) {
        e.printStackTrace();
      }
    }
  }
}",0.5662251655629139
29773,"@Override public void onResume(){
  Log.i(TAG,""String_Node_Str"");
  super.onResume();
  PendingIntent pendingIntent=PendingIntent.getActivity(this,0,new Intent(this,getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP),0);
  NfcAdapter.getDefaultAdapter(this).enableForegroundDispatch(this,pendingIntent,null,null);
}","@Override public void onResume(){
  Log.i(TAG,""String_Node_Str"");
  super.onResume();
  PendingIntent pendingIntent=PendingIntent.getActivity(this,0,new Intent(this,getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP),0);
  if (NfcAdapter.getDefaultAdapter(this) != null)   NfcAdapter.getDefaultAdapter(this).enableForegroundDispatch(this,pendingIntent,null,null);
}",0.9269005847953216
29774,"public float[] getStateAsHSV(){
  String[] stateSplit=state.split(""String_Node_Str"");
  if (stateSplit.length == 3) {
    float[] result={Float.parseFloat(stateSplit[0]),Float.parseFloat(stateSplit[1]),Float.parseFloat(stateSplit[2])};
    return result;
  }
 else {
    return null;
  }
}","public float[] getStateAsHSV(){
  String[] stateSplit=state.split(""String_Node_Str"");
  if (stateSplit.length == 3) {
    float[] result={Float.parseFloat(stateSplit[0]),Float.parseFloat(stateSplit[1]) / 100,Float.parseFloat(stateSplit[2]) / 100};
    return result;
  }
 else {
    return null;
  }
}",0.9796610169491524
29775,"public void setHSVColor(float[] hsv){
  mAngle=this.colorToAngle(Color.HSVToColor(hsv));
  mSaturation=hsv[1];
  mBrightness=1 - hsv[2];
  mPointerColor.setColor(calculateColor(mAngle));
  updateBrightnessAndSaturation();
  postInvalidate();
}","public void setHSVColor(float[] hsv){
  Log.i(""String_Node_Str"",String.format(""String_Node_Str"",hsv[0],hsv[1],hsv[2]));
  mAngle=this.colorToAngle(Color.HSVToColor(hsv));
  mSaturation=hsv[1];
  mBrightness=1 - hsv[2];
  mPointerColor.setColor(calculateColor(mAngle));
  updateBrightnessAndSaturation();
  postInvalidate();
}",0.8556338028169014
29776,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  OnColorChangedListener l=new OnColorChangedListener(){
    public void colorChanged(    int color,    View v){
      mListener.colorChanged(color,v);
      dismiss();
    }
  }
;
  this.colorPickerView=new ColorPicker(getContext());
  if (this.tag != null)   this.colorPickerView.setTag(this.tag);
  setContentView(this.colorPickerView);
  setTitle(""String_Node_Str"");
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  OnColorChangedListener l=new OnColorChangedListener(){
    public void colorChanged(    int color,    View v){
      mListener.colorChanged(color,v);
      dismiss();
    }
  }
;
  this.colorPickerView=new ColorPicker(getContext());
  this.colorPickerView.setHSVColor(mInitialColor);
  if (this.tag != null)   this.colorPickerView.setTag(this.tag);
  setContentView(this.colorPickerView);
  setTitle(""String_Node_Str"");
}",0.9487437185929648
29777,"public ColorPickerDialog(Context context,OnColorChangedListener listener,int initialColor){
  super(context);
  mListener=listener;
  mInitialColor=initialColor;
}","public ColorPickerDialog(Context context,OnColorChangedListener listener,float[] initialColor){
  super(context);
  mListener=listener;
  mInitialColor=initialColor;
}",0.9757575757575756
29778,"@SuppressWarnings(""String_Node_Str"") @Override public View getView(int position,View convertView,ViewGroup parent){
  final RelativeLayout widgetView;
  TextView labelTextView;
  TextView valueTextView;
  int widgetLayout=0;
  String[] splitString={};
  OpenHABWidget openHABWidget=getItem(position);
  int screenWidth=((WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getWidth();
switch (this.getItemViewType(position)) {
case TYPE_FRAME:
    widgetLayout=R.layout.openhabwidgetlist_frameitem;
  break;
case TYPE_GROUP:
widgetLayout=R.layout.openhabwidgetlist_groupitem;
break;
case TYPE_SECTIONSWITCH:
widgetLayout=R.layout.openhabwidgetlist_sectionswitchitem;
break;
case TYPE_SWITCH:
widgetLayout=R.layout.openhabwidgetlist_switchitem;
break;
case TYPE_ROLLERSHUTTER:
widgetLayout=R.layout.openhabwidgetlist_rollershutteritem;
break;
case TYPE_TEXT:
widgetLayout=R.layout.openhabwidgetlist_textitem;
break;
case TYPE_SLIDER:
widgetLayout=R.layout.openhabwidgetlist_slideritem;
break;
case TYPE_IMAGE:
widgetLayout=R.layout.openhabwidgetlist_imageitem;
break;
case TYPE_SELECTION:
widgetLayout=R.layout.openhabwidgetlist_selectionitem;
break;
case TYPE_SETPOINT:
widgetLayout=R.layout.openhabwidgetlist_setpointitem;
break;
case TYPE_CHART:
widgetLayout=R.layout.openhabwidgetlist_chartitem;
break;
case TYPE_VIDEO:
widgetLayout=R.layout.openhabwidgetlist_videoitem;
break;
case TYPE_WEB:
widgetLayout=R.layout.openhabwidgetlist_webitem;
break;
case TYPE_COLOR:
widgetLayout=R.layout.openhabwidgetlist_coloritem;
break;
default :
widgetLayout=R.layout.openhabwidgetlist_genericitem;
break;
}
if (convertView == null) {
widgetView=new RelativeLayout(getContext());
String inflater=Context.LAYOUT_INFLATER_SERVICE;
LayoutInflater vi;
vi=(LayoutInflater)getContext().getSystemService(inflater);
vi.inflate(widgetLayout,widgetView,true);
}
 else {
widgetView=(RelativeLayout)convertView;
}
switch (getItemViewType(position)) {
case TYPE_FRAME:
labelTextView=(TextView)widgetView.findViewById(R.id.framelabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
widgetView.setClickable(false);
if (openHABWidget.getLabel().length() > 0) {
widgetView.setVisibility(View.VISIBLE);
labelTextView.setVisibility(View.VISIBLE);
}
 else {
widgetView.setVisibility(View.GONE);
labelTextView.setVisibility(View.GONE);
}
break;
case TYPE_GROUP:
labelTextView=(TextView)widgetView.findViewById(R.id.grouplabel);
valueTextView=(TextView)widgetView.findViewById(R.id.groupvalue);
if (labelTextView != null && valueTextView != null) {
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
labelTextView.setText(splitString[0]);
if (splitString.length > 1) {
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setText(""String_Node_Str"");
}
}
MySmartImageView groupImage=(MySmartImageView)widgetView.findViewById(R.id.groupimage);
groupImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SECTIONSWITCH:
labelTextView=(TextView)widgetView.findViewById(R.id.sectionswitchlabel);
valueTextView=(TextView)widgetView.findViewById(R.id.sectionswitchvalue);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
if (splitString.length > 1 && valueTextView != null) {
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setText(""String_Node_Str"");
}
RadioGroup sectionSwitchRadioGroup=(RadioGroup)widgetView.findViewById(R.id.sectionswitchradiogroup);
sectionSwitchRadioGroup.removeAllViews();
sectionSwitchRadioGroup.setTag(openHABWidget);
Iterator<OpenHABWidgetMapping> sectionMappingIterator=openHABWidget.getMappings().iterator();
while (sectionMappingIterator.hasNext()) {
OpenHABWidgetMapping widgetMapping=sectionMappingIterator.next();
SegmentedControlButton segmentedControlButton=(SegmentedControlButton)LayoutInflater.from(sectionSwitchRadioGroup.getContext()).inflate(R.layout.openhabwidgetlist_sectionswitchitem_button,sectionSwitchRadioGroup,false);
segmentedControlButton.setText(widgetMapping.getLabel());
segmentedControlButton.setTag(widgetMapping.getCommand());
if (widgetMapping.getCommand().equals(openHABWidget.getItem().getState())) {
segmentedControlButton.setChecked(true);
}
 else {
segmentedControlButton.setChecked(false);
}
sectionSwitchRadioGroup.addView(segmentedControlButton);
}
sectionSwitchRadioGroup.setOnCheckedChangeListener(new OnCheckedChangeListener(){
@Override public void onCheckedChanged(RadioGroup group,int checkedId){
OpenHABWidget radioWidget=(OpenHABWidget)group.getTag();
SegmentedControlButton selectedButton=(SegmentedControlButton)group.findViewById(checkedId);
if (selectedButton != null) {
Log.i(""String_Node_Str"",""String_Node_Str"" + selectedButton.getText());
Log.i(""String_Node_Str"",""String_Node_Str"" + (String)selectedButton.getTag());
sendItemCommand(radioWidget.getItem(),(String)selectedButton.getTag());
}
}
}
);
MySmartImageView sectionSwitchImage=(MySmartImageView)widgetView.findViewById(R.id.sectionswitchimage);
sectionSwitchImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SWITCH:
labelTextView=(TextView)widgetView.findViewById(R.id.switchlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
Switch switchSwitch=(Switch)widgetView.findViewById(R.id.switchswitch);
if (openHABWidget.hasItem()) {
if (openHABWidget.getItem().getState().equals(""String_Node_Str"")) {
switchSwitch.setChecked(true);
}
 else {
switchSwitch.setChecked(false);
}
}
switchSwitch.setTag(openHABWidget.getItem());
switchSwitch.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
Switch switchSwitch=(Switch)v;
OpenHABItem linkedItem=(OpenHABItem)switchSwitch.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) if (!switchSwitch.isChecked()) {
sendItemCommand(linkedItem,""String_Node_Str"");
}
 else {
sendItemCommand(linkedItem,""String_Node_Str"");
}
return false;
}
}
);
MySmartImageView switchImage=(MySmartImageView)widgetView.findViewById(R.id.switchimage);
switchImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_COLOR:
labelTextView=(TextView)widgetView.findViewById(R.id.colorlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
ImageButton colorUpButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_up);
ImageButton colorDownButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_down);
ImageButton colorColorButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_color);
colorUpButton.setTag(openHABWidget.getItem());
colorDownButton.setTag(openHABWidget.getItem());
colorColorButton.setTag(openHABWidget.getItem());
colorUpButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(colorItem,""String_Node_Str"");
return false;
}
}
);
colorDownButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(colorItem,""String_Node_Str"");
return false;
}
}
);
colorColorButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) {
Log.i(""String_Node_Str"",""String_Node_Str"");
ColorPickerDialog colorDialog=new ColorPickerDialog(widgetView.getContext(),new OnColorChangedListener(){
@Override public void colorChanged(int color,View v){
Log.i(""String_Node_Str"",""String_Node_Str"" + color);
float[] HSVColor={0,0,0};
Color.colorToHSV(color,HSVColor);
Log.i(""String_Node_Str"",""String_Node_Str"" + HSVColor[0] + ""String_Node_Str""+ HSVColor[1]+ ""String_Node_Str""+ HSVColor[2]);
String newColor=String.valueOf(HSVColor[0]) + ""String_Node_Str"" + String.valueOf(HSVColor[1])+ ""String_Node_Str""+ String.valueOf(HSVColor[2]);
OpenHABItem colorItem=(OpenHABItem)v.getTag();
sendItemCommand(colorItem,newColor);
}
}
,colorItem.getStateAsColor());
colorDialog.setTag(colorItem);
colorDialog.show();
}
return false;
}
}
);
MySmartImageView colorImage=(MySmartImageView)widgetView.findViewById(R.id.colorimage);
colorImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_ROLLERSHUTTER:
labelTextView=(TextView)widgetView.findViewById(R.id.rollershutterlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
ImageButton rollershutterUpButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_up);
ImageButton rollershutterStopButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_stop);
ImageButton rollershutterDownButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_down);
rollershutterUpButton.setTag(openHABWidget.getItem());
rollershutterStopButton.setTag(openHABWidget.getItem());
rollershutterDownButton.setTag(openHABWidget.getItem());
rollershutterUpButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
rollershutterStopButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
rollershutterDownButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
MySmartImageView rollershutterImage=(MySmartImageView)widgetView.findViewById(R.id.rollershutterimage);
rollershutterImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_TEXT:
labelTextView=(TextView)widgetView.findViewById(R.id.textlabel);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
valueTextView=(TextView)widgetView.findViewById(R.id.textvalue);
if (valueTextView != null) if (splitString.length > 1) {
valueTextView.setVisibility(View.VISIBLE);
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setVisibility(View.GONE);
valueTextView.setText(""String_Node_Str"");
}
MySmartImageView textImage=(MySmartImageView)widgetView.findViewById(R.id.textimage);
textImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SLIDER:
labelTextView=(TextView)widgetView.findViewById(R.id.sliderlabel);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
MySmartImageView itemImage=(MySmartImageView)widgetView.findViewById(R.id.sliderimage);
itemImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
SeekBar sliderSeekBar=(SeekBar)widgetView.findViewById(R.id.sliderseekbar);
if (openHABWidget.hasItem()) {
sliderSeekBar.setTag(openHABWidget.getItem());
int sliderState=(int)Float.parseFloat(openHABWidget.getItem().getState());
sliderSeekBar.setProgress(sliderState);
sliderSeekBar.setOnSeekBarChangeListener(new OnSeekBarChangeListener(){
@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
}
@Override public void onStartTrackingTouch(SeekBar seekBar){
Log.i(""String_Node_Str"",""String_Node_Str"" + seekBar.getProgress());
}
@Override public void onStopTrackingTouch(SeekBar seekBar){
Log.i(""String_Node_Str"",""String_Node_Str"" + seekBar.getProgress());
OpenHABItem sliderItem=(OpenHABItem)seekBar.getTag();
sendItemCommand(sliderItem,String.valueOf(seekBar.getProgress()));
}
}
);
}
break;
case TYPE_IMAGE:
MySmartImageView imageImage=(MySmartImageView)widgetView.findViewById(R.id.imageimage);
imageImage.setImageUrl(ensureAbsoluteURL(openHABBaseUrl,openHABWidget.getUrl()),false);
if (openHABWidget.getRefresh() > 0) {
imageImage.setRefreshRate(openHABWidget.getRefresh());
refreshImageList.add(imageImage);
}
break;
case TYPE_CHART:
MySmartImageView chartImage=(MySmartImageView)widgetView.findViewById(R.id.chartimage);
OpenHABItem chartItem=openHABWidget.getItem();
Random random=new Random();
String chartUrl=""String_Node_Str"";
if (chartItem.getType().equals(""String_Node_Str"")) {
chartUrl=openHABBaseUrl + ""String_Node_Str"" + chartItem.getName()+ ""String_Node_Str""+ openHABWidget.getPeriod()+ ""String_Node_Str""+ String.valueOf(random.nextInt());
}
Log.i(""String_Node_Str"",""String_Node_Str"" + chartUrl);
if (chartImage == null) Log.e(""String_Node_Str"",""String_Node_Str"");
if (openHABUsername != null && openHABPassword != null) chartImage.setImageUrl(chartUrl,false,openHABUsername,openHABPassword);
 else chartImage.setImageUrl(chartUrl,false);
ViewGroup.LayoutParams chartLayoutParams=chartImage.getLayoutParams();
chartLayoutParams.height=(int)(screenWidth / 1.88);
chartImage.setLayoutParams(chartLayoutParams);
if (openHABWidget.getRefresh() > 0) {
chartImage.setRefreshRate(openHABWidget.getRefresh());
refreshImageList.add(chartImage);
}
Log.i(""String_Node_Str"",""String_Node_Str"" + chartLayoutParams.width + ""String_Node_Str""+ chartLayoutParams.height);
break;
case TYPE_VIDEO:
VideoView videoVideo=(VideoView)widgetView.findViewById(R.id.videovideo);
Log.i(""String_Node_Str"",""String_Node_Str"" + openHABWidget.getUrl());
WindowManager wm=(WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE);
ViewGroup.LayoutParams videoLayoutParams=videoVideo.getLayoutParams();
videoLayoutParams.height=(int)(wm.getDefaultDisplay().getWidth() / 1.77);
videoVideo.setLayoutParams(videoLayoutParams);
if (!videoWidgetList.contains(videoVideo)) videoWidgetList.add(videoVideo);
if (!videoVideo.isPlaying()) {
videoVideo.setVideoURI(Uri.parse(openHABWidget.getUrl()));
videoVideo.start();
}
Log.i(""String_Node_Str"",""String_Node_Str"" + videoVideo.getHeight());
break;
case TYPE_WEB:
WebView webWeb=(WebView)widgetView.findViewById(R.id.webweb);
if (openHABWidget.getHeight() > 0) {
ViewGroup.LayoutParams webLayoutParams=webWeb.getLayoutParams();
webLayoutParams.height=openHABWidget.getHeight() * 80;
webWeb.setLayoutParams(webLayoutParams);
}
webWeb.setWebViewClient(new WebViewClient());
webWeb.loadUrl(openHABWidget.getUrl());
break;
case TYPE_SELECTION:
labelTextView=(TextView)widgetView.findViewById(R.id.selectionlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
Spinner selectionSpinner=(Spinner)widgetView.findViewById(R.id.selectionspinner);
ArrayList<String> spinnerArray=new ArrayList<String>();
Iterator<OpenHABWidgetMapping> mappingIterator=openHABWidget.getMappings().iterator();
while (mappingIterator.hasNext()) {
spinnerArray.add(mappingIterator.next().getLabel());
}
ArrayAdapter<String> spinnerAdapter=new ArrayAdapter<String>(this.getContext(),android.R.layout.simple_spinner_item,spinnerArray);
spinnerAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
selectionSpinner.setAdapter(spinnerAdapter);
selectionSpinner.setTag(openHABWidget);
selectionSpinner.setSelection((int)Float.parseFloat(openHABWidget.getItem().getState()));
selectionSpinner.setOnItemSelectedListener(new OnItemSelectedListener(){
@Override public void onItemSelected(AdapterView<?> parent,View view,int index,long id){
Log.i(""String_Node_Str"",""String_Node_Str"" + index);
OpenHABWidget openHABWidget=(OpenHABWidget)parent.getTag();
if (openHABWidget != null) Log.i(""String_Node_Str"",""String_Node_Str"" + openHABWidget.getMapping(index).getLabel());
if (!openHABWidget.getItem().getState().equals(openHABWidget.getMapping(index).getCommand())) sendItemCommand(openHABWidget.getItem(),openHABWidget.getMapping(index).getCommand());
}
@Override public void onNothingSelected(AdapterView<?> arg0){
}
}
);
MySmartImageView selectionImage=(MySmartImageView)widgetView.findViewById(R.id.selectionimage);
selectionImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SETPOINT:
labelTextView=(TextView)widgetView.findViewById(R.id.setpointlabel);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
MySmartImageView setPointImage=(MySmartImageView)widgetView.findViewById(R.id.setpointimage);
setPointImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
TextView setPointValueTextView=(TextView)widgetView.findViewById(R.id.setpointvaluelabel);
if (setPointValueTextView != null) if (splitString.length > 1) {
setPointValueTextView.setVisibility(View.VISIBLE);
setPointValueTextView.setText(splitString[1]);
}
Button setPointMinusButton=(Button)widgetView.findViewById(R.id.setpointbutton_minus);
Button setPointPlusButton=(Button)widgetView.findViewById(R.id.setpointbutton_plus);
setPointMinusButton.setTag(openHABWidget);
setPointPlusButton.setTag(openHABWidget);
setPointMinusButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View v){
Log.i(""String_Node_Str"",""String_Node_Str"");
OpenHABWidget setPointWidget=(OpenHABWidget)v.getTag();
float currentValue=Float.valueOf(setPointWidget.getItem().getState()).floatValue();
currentValue=currentValue - setPointWidget.getStep();
if (currentValue < setPointWidget.getMinValue()) currentValue=setPointWidget.getMinValue();
sendItemCommand(setPointWidget.getItem(),String.valueOf(currentValue));
}
}
);
setPointPlusButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View v){
Log.i(""String_Node_Str"",""String_Node_Str"");
OpenHABWidget setPointWidget=(OpenHABWidget)v.getTag();
float currentValue=Float.valueOf(setPointWidget.getItem().getState()).floatValue();
currentValue=currentValue + setPointWidget.getStep();
if (currentValue > setPointWidget.getMaxValue()) currentValue=setPointWidget.getMaxValue();
sendItemCommand(setPointWidget.getItem(),String.valueOf(currentValue));
}
}
);
break;
default :
labelTextView=(TextView)widgetView.findViewById(R.id.itemlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
MySmartImageView sliderImage=(MySmartImageView)widgetView.findViewById(R.id.itemimage);
sliderImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
}
LinearLayout dividerLayout=(LinearLayout)widgetView.findViewById(R.id.listdivider);
if (dividerLayout != null) {
if (position < this.getCount() - 1) {
if (this.getItemViewType(position + 1) == TYPE_FRAME) {
dividerLayout.setVisibility(View.GONE);
}
 else {
dividerLayout.setVisibility(View.VISIBLE);
}
}
 else {
dividerLayout.setVisibility(View.GONE);
}
}
return widgetView;
}","@SuppressWarnings(""String_Node_Str"") @Override public View getView(int position,View convertView,ViewGroup parent){
  final RelativeLayout widgetView;
  TextView labelTextView;
  TextView valueTextView;
  int widgetLayout=0;
  String[] splitString={};
  OpenHABWidget openHABWidget=getItem(position);
  int screenWidth=((WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getWidth();
switch (this.getItemViewType(position)) {
case TYPE_FRAME:
    widgetLayout=R.layout.openhabwidgetlist_frameitem;
  break;
case TYPE_GROUP:
widgetLayout=R.layout.openhabwidgetlist_groupitem;
break;
case TYPE_SECTIONSWITCH:
widgetLayout=R.layout.openhabwidgetlist_sectionswitchitem;
break;
case TYPE_SWITCH:
widgetLayout=R.layout.openhabwidgetlist_switchitem;
break;
case TYPE_ROLLERSHUTTER:
widgetLayout=R.layout.openhabwidgetlist_rollershutteritem;
break;
case TYPE_TEXT:
widgetLayout=R.layout.openhabwidgetlist_textitem;
break;
case TYPE_SLIDER:
widgetLayout=R.layout.openhabwidgetlist_slideritem;
break;
case TYPE_IMAGE:
widgetLayout=R.layout.openhabwidgetlist_imageitem;
break;
case TYPE_SELECTION:
widgetLayout=R.layout.openhabwidgetlist_selectionitem;
break;
case TYPE_SETPOINT:
widgetLayout=R.layout.openhabwidgetlist_setpointitem;
break;
case TYPE_CHART:
widgetLayout=R.layout.openhabwidgetlist_chartitem;
break;
case TYPE_VIDEO:
widgetLayout=R.layout.openhabwidgetlist_videoitem;
break;
case TYPE_WEB:
widgetLayout=R.layout.openhabwidgetlist_webitem;
break;
case TYPE_COLOR:
widgetLayout=R.layout.openhabwidgetlist_coloritem;
break;
default :
widgetLayout=R.layout.openhabwidgetlist_genericitem;
break;
}
if (convertView == null) {
widgetView=new RelativeLayout(getContext());
String inflater=Context.LAYOUT_INFLATER_SERVICE;
LayoutInflater vi;
vi=(LayoutInflater)getContext().getSystemService(inflater);
vi.inflate(widgetLayout,widgetView,true);
}
 else {
widgetView=(RelativeLayout)convertView;
}
switch (getItemViewType(position)) {
case TYPE_FRAME:
labelTextView=(TextView)widgetView.findViewById(R.id.framelabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
widgetView.setClickable(false);
if (openHABWidget.getLabel().length() > 0) {
widgetView.setVisibility(View.VISIBLE);
labelTextView.setVisibility(View.VISIBLE);
}
 else {
widgetView.setVisibility(View.GONE);
labelTextView.setVisibility(View.GONE);
}
break;
case TYPE_GROUP:
labelTextView=(TextView)widgetView.findViewById(R.id.grouplabel);
valueTextView=(TextView)widgetView.findViewById(R.id.groupvalue);
if (labelTextView != null && valueTextView != null) {
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
labelTextView.setText(splitString[0]);
if (splitString.length > 1) {
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setText(""String_Node_Str"");
}
}
MySmartImageView groupImage=(MySmartImageView)widgetView.findViewById(R.id.groupimage);
groupImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SECTIONSWITCH:
labelTextView=(TextView)widgetView.findViewById(R.id.sectionswitchlabel);
valueTextView=(TextView)widgetView.findViewById(R.id.sectionswitchvalue);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
if (splitString.length > 1 && valueTextView != null) {
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setText(""String_Node_Str"");
}
RadioGroup sectionSwitchRadioGroup=(RadioGroup)widgetView.findViewById(R.id.sectionswitchradiogroup);
sectionSwitchRadioGroup.removeAllViews();
sectionSwitchRadioGroup.setTag(openHABWidget);
Iterator<OpenHABWidgetMapping> sectionMappingIterator=openHABWidget.getMappings().iterator();
while (sectionMappingIterator.hasNext()) {
OpenHABWidgetMapping widgetMapping=sectionMappingIterator.next();
SegmentedControlButton segmentedControlButton=(SegmentedControlButton)LayoutInflater.from(sectionSwitchRadioGroup.getContext()).inflate(R.layout.openhabwidgetlist_sectionswitchitem_button,sectionSwitchRadioGroup,false);
segmentedControlButton.setText(widgetMapping.getLabel());
segmentedControlButton.setTag(widgetMapping.getCommand());
if (widgetMapping.getCommand().equals(openHABWidget.getItem().getState())) {
segmentedControlButton.setChecked(true);
}
 else {
segmentedControlButton.setChecked(false);
}
sectionSwitchRadioGroup.addView(segmentedControlButton);
}
sectionSwitchRadioGroup.setOnCheckedChangeListener(new OnCheckedChangeListener(){
@Override public void onCheckedChanged(RadioGroup group,int checkedId){
OpenHABWidget radioWidget=(OpenHABWidget)group.getTag();
SegmentedControlButton selectedButton=(SegmentedControlButton)group.findViewById(checkedId);
if (selectedButton != null) {
Log.i(""String_Node_Str"",""String_Node_Str"" + selectedButton.getText());
Log.i(""String_Node_Str"",""String_Node_Str"" + (String)selectedButton.getTag());
sendItemCommand(radioWidget.getItem(),(String)selectedButton.getTag());
}
}
}
);
MySmartImageView sectionSwitchImage=(MySmartImageView)widgetView.findViewById(R.id.sectionswitchimage);
sectionSwitchImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SWITCH:
labelTextView=(TextView)widgetView.findViewById(R.id.switchlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
Switch switchSwitch=(Switch)widgetView.findViewById(R.id.switchswitch);
if (openHABWidget.hasItem()) {
if (openHABWidget.getItem().getState().equals(""String_Node_Str"")) {
switchSwitch.setChecked(true);
}
 else {
switchSwitch.setChecked(false);
}
}
switchSwitch.setTag(openHABWidget.getItem());
switchSwitch.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
Switch switchSwitch=(Switch)v;
OpenHABItem linkedItem=(OpenHABItem)switchSwitch.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) if (!switchSwitch.isChecked()) {
sendItemCommand(linkedItem,""String_Node_Str"");
}
 else {
sendItemCommand(linkedItem,""String_Node_Str"");
}
return false;
}
}
);
MySmartImageView switchImage=(MySmartImageView)widgetView.findViewById(R.id.switchimage);
switchImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_COLOR:
labelTextView=(TextView)widgetView.findViewById(R.id.colorlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
ImageButton colorUpButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_up);
ImageButton colorDownButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_down);
ImageButton colorColorButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_color);
colorUpButton.setTag(openHABWidget.getItem());
colorDownButton.setTag(openHABWidget.getItem());
colorColorButton.setTag(openHABWidget.getItem());
colorUpButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(colorItem,""String_Node_Str"");
return false;
}
}
);
colorDownButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(colorItem,""String_Node_Str"");
return false;
}
}
);
colorColorButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) {
Log.i(""String_Node_Str"",""String_Node_Str"");
ColorPickerDialog colorDialog=new ColorPickerDialog(widgetView.getContext(),new OnColorChangedListener(){
@Override public void colorChanged(int color,View v){
Log.i(""String_Node_Str"",""String_Node_Str"" + color);
float[] HSVColor={0,0,0};
Color.colorToHSV(color,HSVColor);
Log.i(""String_Node_Str"",""String_Node_Str"" + HSVColor[0] + ""String_Node_Str""+ HSVColor[1]+ ""String_Node_Str""+ HSVColor[2]);
String newColor=String.valueOf(HSVColor[0]) + ""String_Node_Str"" + String.valueOf(HSVColor[1])+ ""String_Node_Str""+ String.valueOf(HSVColor[2]);
OpenHABItem colorItem=(OpenHABItem)v.getTag();
sendItemCommand(colorItem,newColor);
}
}
,colorItem.getStateAsHSV());
colorDialog.setTag(colorItem);
colorDialog.show();
}
return false;
}
}
);
MySmartImageView colorImage=(MySmartImageView)widgetView.findViewById(R.id.colorimage);
colorImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_ROLLERSHUTTER:
labelTextView=(TextView)widgetView.findViewById(R.id.rollershutterlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
ImageButton rollershutterUpButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_up);
ImageButton rollershutterStopButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_stop);
ImageButton rollershutterDownButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_down);
rollershutterUpButton.setTag(openHABWidget.getItem());
rollershutterStopButton.setTag(openHABWidget.getItem());
rollershutterDownButton.setTag(openHABWidget.getItem());
rollershutterUpButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
rollershutterStopButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
rollershutterDownButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
MySmartImageView rollershutterImage=(MySmartImageView)widgetView.findViewById(R.id.rollershutterimage);
rollershutterImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_TEXT:
labelTextView=(TextView)widgetView.findViewById(R.id.textlabel);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
valueTextView=(TextView)widgetView.findViewById(R.id.textvalue);
if (valueTextView != null) if (splitString.length > 1) {
valueTextView.setVisibility(View.VISIBLE);
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setVisibility(View.GONE);
valueTextView.setText(""String_Node_Str"");
}
MySmartImageView textImage=(MySmartImageView)widgetView.findViewById(R.id.textimage);
textImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SLIDER:
labelTextView=(TextView)widgetView.findViewById(R.id.sliderlabel);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
MySmartImageView itemImage=(MySmartImageView)widgetView.findViewById(R.id.sliderimage);
itemImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
SeekBar sliderSeekBar=(SeekBar)widgetView.findViewById(R.id.sliderseekbar);
if (openHABWidget.hasItem()) {
sliderSeekBar.setTag(openHABWidget.getItem());
int sliderState=(int)Float.parseFloat(openHABWidget.getItem().getState());
sliderSeekBar.setProgress(sliderState);
sliderSeekBar.setOnSeekBarChangeListener(new OnSeekBarChangeListener(){
@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
}
@Override public void onStartTrackingTouch(SeekBar seekBar){
Log.i(""String_Node_Str"",""String_Node_Str"" + seekBar.getProgress());
}
@Override public void onStopTrackingTouch(SeekBar seekBar){
Log.i(""String_Node_Str"",""String_Node_Str"" + seekBar.getProgress());
OpenHABItem sliderItem=(OpenHABItem)seekBar.getTag();
sendItemCommand(sliderItem,String.valueOf(seekBar.getProgress()));
}
}
);
}
break;
case TYPE_IMAGE:
MySmartImageView imageImage=(MySmartImageView)widgetView.findViewById(R.id.imageimage);
imageImage.setImageUrl(ensureAbsoluteURL(openHABBaseUrl,openHABWidget.getUrl()),false);
if (openHABWidget.getRefresh() > 0) {
imageImage.setRefreshRate(openHABWidget.getRefresh());
refreshImageList.add(imageImage);
}
break;
case TYPE_CHART:
MySmartImageView chartImage=(MySmartImageView)widgetView.findViewById(R.id.chartimage);
OpenHABItem chartItem=openHABWidget.getItem();
Random random=new Random();
String chartUrl=""String_Node_Str"";
if (chartItem.getType().equals(""String_Node_Str"")) {
chartUrl=openHABBaseUrl + ""String_Node_Str"" + chartItem.getName()+ ""String_Node_Str""+ openHABWidget.getPeriod()+ ""String_Node_Str""+ String.valueOf(random.nextInt());
}
Log.i(""String_Node_Str"",""String_Node_Str"" + chartUrl);
if (chartImage == null) Log.e(""String_Node_Str"",""String_Node_Str"");
if (openHABUsername != null && openHABPassword != null) chartImage.setImageUrl(chartUrl,false,openHABUsername,openHABPassword);
 else chartImage.setImageUrl(chartUrl,false);
ViewGroup.LayoutParams chartLayoutParams=chartImage.getLayoutParams();
chartLayoutParams.height=(int)(screenWidth / 1.88);
chartImage.setLayoutParams(chartLayoutParams);
if (openHABWidget.getRefresh() > 0) {
chartImage.setRefreshRate(openHABWidget.getRefresh());
refreshImageList.add(chartImage);
}
Log.i(""String_Node_Str"",""String_Node_Str"" + chartLayoutParams.width + ""String_Node_Str""+ chartLayoutParams.height);
break;
case TYPE_VIDEO:
VideoView videoVideo=(VideoView)widgetView.findViewById(R.id.videovideo);
Log.i(""String_Node_Str"",""String_Node_Str"" + openHABWidget.getUrl());
WindowManager wm=(WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE);
ViewGroup.LayoutParams videoLayoutParams=videoVideo.getLayoutParams();
videoLayoutParams.height=(int)(wm.getDefaultDisplay().getWidth() / 1.77);
videoVideo.setLayoutParams(videoLayoutParams);
if (!videoWidgetList.contains(videoVideo)) videoWidgetList.add(videoVideo);
if (!videoVideo.isPlaying()) {
videoVideo.setVideoURI(Uri.parse(openHABWidget.getUrl()));
videoVideo.start();
}
Log.i(""String_Node_Str"",""String_Node_Str"" + videoVideo.getHeight());
break;
case TYPE_WEB:
WebView webWeb=(WebView)widgetView.findViewById(R.id.webweb);
if (openHABWidget.getHeight() > 0) {
ViewGroup.LayoutParams webLayoutParams=webWeb.getLayoutParams();
webLayoutParams.height=openHABWidget.getHeight() * 80;
webWeb.setLayoutParams(webLayoutParams);
}
webWeb.setWebViewClient(new WebViewClient());
webWeb.loadUrl(openHABWidget.getUrl());
break;
case TYPE_SELECTION:
labelTextView=(TextView)widgetView.findViewById(R.id.selectionlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
Spinner selectionSpinner=(Spinner)widgetView.findViewById(R.id.selectionspinner);
ArrayList<String> spinnerArray=new ArrayList<String>();
Iterator<OpenHABWidgetMapping> mappingIterator=openHABWidget.getMappings().iterator();
while (mappingIterator.hasNext()) {
spinnerArray.add(mappingIterator.next().getLabel());
}
ArrayAdapter<String> spinnerAdapter=new ArrayAdapter<String>(this.getContext(),android.R.layout.simple_spinner_item,spinnerArray);
spinnerAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
selectionSpinner.setAdapter(spinnerAdapter);
selectionSpinner.setTag(openHABWidget);
selectionSpinner.setSelection((int)Float.parseFloat(openHABWidget.getItem().getState()));
selectionSpinner.setOnItemSelectedListener(new OnItemSelectedListener(){
@Override public void onItemSelected(AdapterView<?> parent,View view,int index,long id){
Log.i(""String_Node_Str"",""String_Node_Str"" + index);
OpenHABWidget openHABWidget=(OpenHABWidget)parent.getTag();
if (openHABWidget != null) Log.i(""String_Node_Str"",""String_Node_Str"" + openHABWidget.getMapping(index).getLabel());
if (!openHABWidget.getItem().getState().equals(openHABWidget.getMapping(index).getCommand())) sendItemCommand(openHABWidget.getItem(),openHABWidget.getMapping(index).getCommand());
}
@Override public void onNothingSelected(AdapterView<?> arg0){
}
}
);
MySmartImageView selectionImage=(MySmartImageView)widgetView.findViewById(R.id.selectionimage);
selectionImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SETPOINT:
labelTextView=(TextView)widgetView.findViewById(R.id.setpointlabel);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
MySmartImageView setPointImage=(MySmartImageView)widgetView.findViewById(R.id.setpointimage);
setPointImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
TextView setPointValueTextView=(TextView)widgetView.findViewById(R.id.setpointvaluelabel);
if (setPointValueTextView != null) if (splitString.length > 1) {
setPointValueTextView.setVisibility(View.VISIBLE);
setPointValueTextView.setText(splitString[1]);
}
Button setPointMinusButton=(Button)widgetView.findViewById(R.id.setpointbutton_minus);
Button setPointPlusButton=(Button)widgetView.findViewById(R.id.setpointbutton_plus);
setPointMinusButton.setTag(openHABWidget);
setPointPlusButton.setTag(openHABWidget);
setPointMinusButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View v){
Log.i(""String_Node_Str"",""String_Node_Str"");
OpenHABWidget setPointWidget=(OpenHABWidget)v.getTag();
float currentValue=Float.valueOf(setPointWidget.getItem().getState()).floatValue();
currentValue=currentValue - setPointWidget.getStep();
if (currentValue < setPointWidget.getMinValue()) currentValue=setPointWidget.getMinValue();
sendItemCommand(setPointWidget.getItem(),String.valueOf(currentValue));
}
}
);
setPointPlusButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View v){
Log.i(""String_Node_Str"",""String_Node_Str"");
OpenHABWidget setPointWidget=(OpenHABWidget)v.getTag();
float currentValue=Float.valueOf(setPointWidget.getItem().getState()).floatValue();
currentValue=currentValue + setPointWidget.getStep();
if (currentValue > setPointWidget.getMaxValue()) currentValue=setPointWidget.getMaxValue();
sendItemCommand(setPointWidget.getItem(),String.valueOf(currentValue));
}
}
);
break;
default :
labelTextView=(TextView)widgetView.findViewById(R.id.itemlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
MySmartImageView sliderImage=(MySmartImageView)widgetView.findViewById(R.id.itemimage);
sliderImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
}
LinearLayout dividerLayout=(LinearLayout)widgetView.findViewById(R.id.listdivider);
if (dividerLayout != null) {
if (position < this.getCount() - 1) {
if (this.getItemViewType(position + 1) == TYPE_FRAME) {
dividerLayout.setVisibility(View.GONE);
}
 else {
dividerLayout.setVisibility(View.VISIBLE);
}
}
 else {
dividerLayout.setVisibility(View.GONE);
}
}
return widgetView;
}",0.9997977550814036
29779,"public OpenHABWidgetAdapter(Context context,int resource,List<OpenHABWidget> objects){
  super(context,resource,objects);
  videoWidgetList=new ArrayList<VideoView>();
}","public OpenHABWidgetAdapter(Context context,int resource,List<OpenHABWidget> objects){
  super(context,resource,objects);
  videoWidgetList=new ArrayList<VideoView>();
  refreshImageList=new ArrayList<MySmartImageView>();
}",0.8622448979591837
29780,"@Override public View getView(int position,View convertView,ViewGroup parent){
  RelativeLayout widgetView;
  TextView labelTextView;
  TextView valueTextView;
  int widgetLayout=0;
  String[] splitString={};
  OpenHABWidget openHABWidget=getItem(position);
switch (this.getItemViewType(position)) {
case TYPE_FRAME:
    widgetLayout=R.layout.openhabwidgetlist_frameitem;
  break;
case TYPE_GROUP:
widgetLayout=R.layout.openhabwidgetlist_groupitem;
break;
case TYPE_SECTIONSWITCH:
widgetLayout=R.layout.openhabwidgetlist_sectionswitchitem;
break;
case TYPE_SWITCH:
widgetLayout=R.layout.openhabwidgetlist_switchitem;
break;
case TYPE_ROLLERSHUTTER:
widgetLayout=R.layout.openhabwidgetlist_rollershutteritem;
break;
case TYPE_TEXT:
widgetLayout=R.layout.openhabwidgetlist_textitem;
break;
case TYPE_SLIDER:
widgetLayout=R.layout.openhabwidgetlist_slideritem;
break;
case TYPE_IMAGE:
widgetLayout=R.layout.openhabwidgetlist_imageitem;
break;
case TYPE_SELECTION:
widgetLayout=R.layout.openhabwidgetlist_selectionitem;
break;
case TYPE_SETPOINT:
widgetLayout=R.layout.openhabwidgetlist_setpointitem;
break;
case TYPE_CHART:
widgetLayout=R.layout.openhabwidgetlist_chartitem;
break;
case TYPE_VIDEO:
widgetLayout=R.layout.openhabwidgetlist_videoitem;
break;
case TYPE_WEB:
widgetLayout=R.layout.openhabwidgetlist_webitem;
break;
default :
widgetLayout=R.layout.openhabwidgetlist_genericitem;
break;
}
if (convertView == null) {
widgetView=new RelativeLayout(getContext());
String inflater=Context.LAYOUT_INFLATER_SERVICE;
LayoutInflater vi;
vi=(LayoutInflater)getContext().getSystemService(inflater);
vi.inflate(widgetLayout,widgetView,true);
}
 else {
widgetView=(RelativeLayout)convertView;
}
switch (getItemViewType(position)) {
case TYPE_FRAME:
labelTextView=(TextView)widgetView.findViewById(R.id.framelabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
widgetView.setClickable(false);
if (openHABWidget.getLabel().length() > 0) {
widgetView.setVisibility(View.VISIBLE);
labelTextView.setVisibility(View.VISIBLE);
}
 else {
widgetView.setVisibility(View.GONE);
labelTextView.setVisibility(View.GONE);
}
break;
case TYPE_GROUP:
labelTextView=(TextView)widgetView.findViewById(R.id.grouplabel);
valueTextView=(TextView)widgetView.findViewById(R.id.groupvalue);
if (labelTextView != null && valueTextView != null) {
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
labelTextView.setText(splitString[0]);
if (splitString.length > 1) {
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setText(""String_Node_Str"");
}
}
MySmartImageView groupImage=(MySmartImageView)widgetView.findViewById(R.id.groupimage);
groupImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SECTIONSWITCH:
labelTextView=(TextView)widgetView.findViewById(R.id.sectionswitchlabel);
valueTextView=(TextView)widgetView.findViewById(R.id.sectionswitchvalue);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
if (splitString.length > 1 && valueTextView != null) {
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setText(""String_Node_Str"");
}
RadioGroup sectionSwitchRadioGroup=(RadioGroup)widgetView.findViewById(R.id.sectionswitchradiogroup);
sectionSwitchRadioGroup.removeAllViews();
sectionSwitchRadioGroup.setTag(openHABWidget);
Iterator<OpenHABWidgetMapping> sectionMappingIterator=openHABWidget.getMappings().iterator();
while (sectionMappingIterator.hasNext()) {
OpenHABWidgetMapping widgetMapping=sectionMappingIterator.next();
SegmentedControlButton segmentedControlButton=(SegmentedControlButton)LayoutInflater.from(sectionSwitchRadioGroup.getContext()).inflate(R.layout.openhabwidgetlist_sectionswitchitem_button,sectionSwitchRadioGroup,false);
segmentedControlButton.setText(widgetMapping.getLabel());
segmentedControlButton.setTag(widgetMapping.getCommand());
if (widgetMapping.getCommand().equals(openHABWidget.getItem().getState())) {
segmentedControlButton.setChecked(true);
}
 else {
segmentedControlButton.setChecked(false);
}
sectionSwitchRadioGroup.addView(segmentedControlButton);
}
sectionSwitchRadioGroup.setOnCheckedChangeListener(new OnCheckedChangeListener(){
@Override public void onCheckedChanged(RadioGroup group,int checkedId){
OpenHABWidget radioWidget=(OpenHABWidget)group.getTag();
SegmentedControlButton selectedButton=(SegmentedControlButton)group.findViewById(checkedId);
if (selectedButton != null) {
Log.i(""String_Node_Str"",""String_Node_Str"" + selectedButton.getText());
Log.i(""String_Node_Str"",""String_Node_Str"" + (String)selectedButton.getTag());
sendItemCommand(radioWidget.getItem(),(String)selectedButton.getTag());
}
}
}
);
MySmartImageView sectionSwitchImage=(MySmartImageView)widgetView.findViewById(R.id.sectionswitchimage);
sectionSwitchImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SWITCH:
labelTextView=(TextView)widgetView.findViewById(R.id.switchlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
Switch switchSwitch=(Switch)widgetView.findViewById(R.id.switchswitch);
if (openHABWidget.hasItem()) {
if (openHABWidget.getItem().getState().equals(""String_Node_Str"")) {
switchSwitch.setChecked(true);
}
 else {
switchSwitch.setChecked(false);
}
}
switchSwitch.setTag(openHABWidget.getItem());
switchSwitch.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
Switch switchSwitch=(Switch)v;
OpenHABItem linkedItem=(OpenHABItem)switchSwitch.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) if (!switchSwitch.isChecked()) {
sendItemCommand(linkedItem,""String_Node_Str"");
}
 else {
sendItemCommand(linkedItem,""String_Node_Str"");
}
return false;
}
}
);
MySmartImageView switchImage=(MySmartImageView)widgetView.findViewById(R.id.switchimage);
switchImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_ROLLERSHUTTER:
labelTextView=(TextView)widgetView.findViewById(R.id.rollershutterlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
ImageButton rollershutterUpButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_up);
ImageButton rollershutterStopButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_stop);
ImageButton rollershutterDownButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_down);
rollershutterUpButton.setTag(openHABWidget.getItem());
rollershutterStopButton.setTag(openHABWidget.getItem());
rollershutterDownButton.setTag(openHABWidget.getItem());
rollershutterUpButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
rollershutterStopButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
rollershutterDownButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
MySmartImageView rollershutterImage=(MySmartImageView)widgetView.findViewById(R.id.rollershutterimage);
rollershutterImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_TEXT:
labelTextView=(TextView)widgetView.findViewById(R.id.textlabel);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
valueTextView=(TextView)widgetView.findViewById(R.id.textvalue);
if (valueTextView != null) if (splitString.length > 1) {
valueTextView.setVisibility(View.VISIBLE);
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setVisibility(View.GONE);
valueTextView.setText(""String_Node_Str"");
}
MySmartImageView textImage=(MySmartImageView)widgetView.findViewById(R.id.textimage);
textImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SLIDER:
labelTextView=(TextView)widgetView.findViewById(R.id.sliderlabel);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
MySmartImageView itemImage=(MySmartImageView)widgetView.findViewById(R.id.sliderimage);
itemImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
SeekBar sliderSeekBar=(SeekBar)widgetView.findViewById(R.id.sliderseekbar);
if (openHABWidget.hasItem()) {
sliderSeekBar.setTag(openHABWidget.getItem());
int sliderState=(int)Float.parseFloat(openHABWidget.getItem().getState());
sliderSeekBar.setProgress(sliderState);
sliderSeekBar.setOnSeekBarChangeListener(new OnSeekBarChangeListener(){
@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
}
@Override public void onStartTrackingTouch(SeekBar seekBar){
Log.i(""String_Node_Str"",""String_Node_Str"" + seekBar.getProgress());
}
@Override public void onStopTrackingTouch(SeekBar seekBar){
Log.i(""String_Node_Str"",""String_Node_Str"" + seekBar.getProgress());
OpenHABItem sliderItem=(OpenHABItem)seekBar.getTag();
sendItemCommand(sliderItem,String.valueOf(seekBar.getProgress()));
}
}
);
}
break;
case TYPE_IMAGE:
MySmartImageView imageImage=(MySmartImageView)widgetView.findViewById(R.id.imageimage);
imageImage.setImageUrl(ensureAbsoluteURL(openHABBaseUrl,openHABWidget.getUrl()),false);
if (openHABWidget.getRefresh() > 0) {
imageImage.setRefreshRate(openHABWidget.getRefresh());
}
break;
case TYPE_CHART:
MySmartImageView chartImage=(MySmartImageView)widgetView.findViewById(R.id.chartimage);
OpenHABItem chartItem=openHABWidget.getItem();
Random random=new Random();
String chartUrl=""String_Node_Str"";
if (chartItem.getType().equals(""String_Node_Str"")) {
chartUrl=openHABBaseUrl + ""String_Node_Str"" + chartItem.getName()+ ""String_Node_Str""+ openHABWidget.getPeriod()+ ""String_Node_Str""+ String.valueOf(random.nextInt());
}
Log.i(""String_Node_Str"",""String_Node_Str"" + chartUrl);
chartImage.setImageUrl(chartUrl,false);
ViewGroup.LayoutParams chartLayoutParams=chartImage.getLayoutParams();
int screenWidth=((WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getWidth();
chartLayoutParams.height=(int)(screenWidth / 1.88);
chartImage.setLayoutParams(chartLayoutParams);
if (openHABWidget.getRefresh() > 0) chartImage.setRefreshRate(openHABWidget.getRefresh());
Log.i(""String_Node_Str"",""String_Node_Str"" + chartLayoutParams.width + ""String_Node_Str""+ chartLayoutParams.height);
break;
case TYPE_VIDEO:
VideoView videoVideo=(VideoView)widgetView.findViewById(R.id.videovideo);
Log.i(""String_Node_Str"",""String_Node_Str"" + openHABWidget.getUrl());
videoVideo.setVideoURI(Uri.parse(openHABWidget.getUrl()));
WindowManager wm=(WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE);
ViewGroup.LayoutParams videoLayoutParams=videoVideo.getLayoutParams();
videoLayoutParams.height=(int)(wm.getDefaultDisplay().getWidth() / 1.77);
videoVideo.setLayoutParams(videoLayoutParams);
videoWidgetList.add(videoVideo);
videoVideo.start();
Log.i(""String_Node_Str"",""String_Node_Str"" + videoVideo.getHeight());
break;
case TYPE_WEB:
WebView webWeb=(WebView)widgetView.findViewById(R.id.webweb);
if (openHABWidget.getHeight() > 0) {
ViewGroup.LayoutParams webLayoutParams=webWeb.getLayoutParams();
webLayoutParams.height=openHABWidget.getHeight() * 80;
webWeb.setLayoutParams(webLayoutParams);
}
webWeb.setWebViewClient(new WebViewClient());
webWeb.loadUrl(openHABWidget.getUrl());
break;
case TYPE_SELECTION:
labelTextView=(TextView)widgetView.findViewById(R.id.selectionlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
Spinner selectionSpinner=(Spinner)widgetView.findViewById(R.id.selectionspinner);
ArrayList<String> spinnerArray=new ArrayList<String>();
Iterator<OpenHABWidgetMapping> mappingIterator=openHABWidget.getMappings().iterator();
while (mappingIterator.hasNext()) {
spinnerArray.add(mappingIterator.next().getLabel());
}
ArrayAdapter<String> spinnerAdapter=new ArrayAdapter<String>(this.getContext(),android.R.layout.simple_spinner_item,spinnerArray);
spinnerAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
selectionSpinner.setAdapter(spinnerAdapter);
selectionSpinner.setTag(openHABWidget);
selectionSpinner.setSelection((int)Float.parseFloat(openHABWidget.getItem().getState()));
selectionSpinner.setOnItemSelectedListener(new OnItemSelectedListener(){
@Override public void onItemSelected(AdapterView<?> parent,View view,int index,long id){
Log.i(""String_Node_Str"",""String_Node_Str"" + index);
OpenHABWidget openHABWidget=(OpenHABWidget)parent.getTag();
if (openHABWidget != null) Log.i(""String_Node_Str"",""String_Node_Str"" + openHABWidget.getMapping(index).getLabel());
if (!openHABWidget.getItem().getState().equals(openHABWidget.getMapping(index).getCommand())) sendItemCommand(openHABWidget.getItem(),openHABWidget.getMapping(index).getCommand());
}
@Override public void onNothingSelected(AdapterView<?> arg0){
}
}
);
MySmartImageView selectionImage=(MySmartImageView)widgetView.findViewById(R.id.selectionimage);
selectionImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SETPOINT:
labelTextView=(TextView)widgetView.findViewById(R.id.setpointlabel);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
MySmartImageView setPointImage=(MySmartImageView)widgetView.findViewById(R.id.setpointimage);
setPointImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
TextView setPointValueTextView=(TextView)widgetView.findViewById(R.id.setpointvaluelabel);
if (setPointValueTextView != null) if (splitString.length > 1) {
setPointValueTextView.setVisibility(View.VISIBLE);
setPointValueTextView.setText(splitString[1]);
}
Button setPointMinusButton=(Button)widgetView.findViewById(R.id.setpointbutton_minus);
Button setPointPlusButton=(Button)widgetView.findViewById(R.id.setpointbutton_plus);
setPointMinusButton.setTag(openHABWidget);
setPointPlusButton.setTag(openHABWidget);
setPointMinusButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View v){
Log.i(""String_Node_Str"",""String_Node_Str"");
OpenHABWidget setPointWidget=(OpenHABWidget)v.getTag();
float currentValue=Float.valueOf(setPointWidget.getItem().getState()).floatValue();
currentValue=currentValue - setPointWidget.getStep();
if (currentValue < setPointWidget.getMinValue()) currentValue=setPointWidget.getMinValue();
sendItemCommand(setPointWidget.getItem(),String.valueOf(currentValue));
}
}
);
setPointPlusButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View v){
Log.i(""String_Node_Str"",""String_Node_Str"");
OpenHABWidget setPointWidget=(OpenHABWidget)v.getTag();
float currentValue=Float.valueOf(setPointWidget.getItem().getState()).floatValue();
currentValue=currentValue + setPointWidget.getStep();
if (currentValue > setPointWidget.getMaxValue()) currentValue=setPointWidget.getMaxValue();
sendItemCommand(setPointWidget.getItem(),String.valueOf(currentValue));
}
}
);
break;
default :
labelTextView=(TextView)widgetView.findViewById(R.id.itemlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
MySmartImageView sliderImage=(MySmartImageView)widgetView.findViewById(R.id.itemimage);
sliderImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
}
LinearLayout dividerLayout=(LinearLayout)widgetView.findViewById(R.id.listdivider);
if (dividerLayout != null) {
if (position < this.getCount() - 1) {
if (this.getItemViewType(position + 1) == TYPE_FRAME) {
dividerLayout.setVisibility(View.GONE);
}
 else {
dividerLayout.setVisibility(View.VISIBLE);
}
}
 else {
dividerLayout.setVisibility(View.GONE);
}
}
return widgetView;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  RelativeLayout widgetView;
  TextView labelTextView;
  TextView valueTextView;
  int widgetLayout=0;
  String[] splitString={};
  OpenHABWidget openHABWidget=getItem(position);
switch (this.getItemViewType(position)) {
case TYPE_FRAME:
    widgetLayout=R.layout.openhabwidgetlist_frameitem;
  break;
case TYPE_GROUP:
widgetLayout=R.layout.openhabwidgetlist_groupitem;
break;
case TYPE_SECTIONSWITCH:
widgetLayout=R.layout.openhabwidgetlist_sectionswitchitem;
break;
case TYPE_SWITCH:
widgetLayout=R.layout.openhabwidgetlist_switchitem;
break;
case TYPE_ROLLERSHUTTER:
widgetLayout=R.layout.openhabwidgetlist_rollershutteritem;
break;
case TYPE_TEXT:
widgetLayout=R.layout.openhabwidgetlist_textitem;
break;
case TYPE_SLIDER:
widgetLayout=R.layout.openhabwidgetlist_slideritem;
break;
case TYPE_IMAGE:
widgetLayout=R.layout.openhabwidgetlist_imageitem;
break;
case TYPE_SELECTION:
widgetLayout=R.layout.openhabwidgetlist_selectionitem;
break;
case TYPE_SETPOINT:
widgetLayout=R.layout.openhabwidgetlist_setpointitem;
break;
case TYPE_CHART:
widgetLayout=R.layout.openhabwidgetlist_chartitem;
break;
case TYPE_VIDEO:
widgetLayout=R.layout.openhabwidgetlist_videoitem;
break;
case TYPE_WEB:
widgetLayout=R.layout.openhabwidgetlist_webitem;
break;
default :
widgetLayout=R.layout.openhabwidgetlist_genericitem;
break;
}
if (convertView == null) {
widgetView=new RelativeLayout(getContext());
String inflater=Context.LAYOUT_INFLATER_SERVICE;
LayoutInflater vi;
vi=(LayoutInflater)getContext().getSystemService(inflater);
vi.inflate(widgetLayout,widgetView,true);
}
 else {
widgetView=(RelativeLayout)convertView;
}
switch (getItemViewType(position)) {
case TYPE_FRAME:
labelTextView=(TextView)widgetView.findViewById(R.id.framelabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
widgetView.setClickable(false);
if (openHABWidget.getLabel().length() > 0) {
widgetView.setVisibility(View.VISIBLE);
labelTextView.setVisibility(View.VISIBLE);
}
 else {
widgetView.setVisibility(View.GONE);
labelTextView.setVisibility(View.GONE);
}
break;
case TYPE_GROUP:
labelTextView=(TextView)widgetView.findViewById(R.id.grouplabel);
valueTextView=(TextView)widgetView.findViewById(R.id.groupvalue);
if (labelTextView != null && valueTextView != null) {
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
labelTextView.setText(splitString[0]);
if (splitString.length > 1) {
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setText(""String_Node_Str"");
}
}
MySmartImageView groupImage=(MySmartImageView)widgetView.findViewById(R.id.groupimage);
groupImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SECTIONSWITCH:
labelTextView=(TextView)widgetView.findViewById(R.id.sectionswitchlabel);
valueTextView=(TextView)widgetView.findViewById(R.id.sectionswitchvalue);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
if (splitString.length > 1 && valueTextView != null) {
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setText(""String_Node_Str"");
}
RadioGroup sectionSwitchRadioGroup=(RadioGroup)widgetView.findViewById(R.id.sectionswitchradiogroup);
sectionSwitchRadioGroup.removeAllViews();
sectionSwitchRadioGroup.setTag(openHABWidget);
Iterator<OpenHABWidgetMapping> sectionMappingIterator=openHABWidget.getMappings().iterator();
while (sectionMappingIterator.hasNext()) {
OpenHABWidgetMapping widgetMapping=sectionMappingIterator.next();
SegmentedControlButton segmentedControlButton=(SegmentedControlButton)LayoutInflater.from(sectionSwitchRadioGroup.getContext()).inflate(R.layout.openhabwidgetlist_sectionswitchitem_button,sectionSwitchRadioGroup,false);
segmentedControlButton.setText(widgetMapping.getLabel());
segmentedControlButton.setTag(widgetMapping.getCommand());
if (widgetMapping.getCommand().equals(openHABWidget.getItem().getState())) {
segmentedControlButton.setChecked(true);
}
 else {
segmentedControlButton.setChecked(false);
}
sectionSwitchRadioGroup.addView(segmentedControlButton);
}
sectionSwitchRadioGroup.setOnCheckedChangeListener(new OnCheckedChangeListener(){
@Override public void onCheckedChanged(RadioGroup group,int checkedId){
OpenHABWidget radioWidget=(OpenHABWidget)group.getTag();
SegmentedControlButton selectedButton=(SegmentedControlButton)group.findViewById(checkedId);
if (selectedButton != null) {
Log.i(""String_Node_Str"",""String_Node_Str"" + selectedButton.getText());
Log.i(""String_Node_Str"",""String_Node_Str"" + (String)selectedButton.getTag());
sendItemCommand(radioWidget.getItem(),(String)selectedButton.getTag());
}
}
}
);
MySmartImageView sectionSwitchImage=(MySmartImageView)widgetView.findViewById(R.id.sectionswitchimage);
sectionSwitchImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SWITCH:
labelTextView=(TextView)widgetView.findViewById(R.id.switchlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
Switch switchSwitch=(Switch)widgetView.findViewById(R.id.switchswitch);
if (openHABWidget.hasItem()) {
if (openHABWidget.getItem().getState().equals(""String_Node_Str"")) {
switchSwitch.setChecked(true);
}
 else {
switchSwitch.setChecked(false);
}
}
switchSwitch.setTag(openHABWidget.getItem());
switchSwitch.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
Switch switchSwitch=(Switch)v;
OpenHABItem linkedItem=(OpenHABItem)switchSwitch.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) if (!switchSwitch.isChecked()) {
sendItemCommand(linkedItem,""String_Node_Str"");
}
 else {
sendItemCommand(linkedItem,""String_Node_Str"");
}
return false;
}
}
);
MySmartImageView switchImage=(MySmartImageView)widgetView.findViewById(R.id.switchimage);
switchImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_ROLLERSHUTTER:
labelTextView=(TextView)widgetView.findViewById(R.id.rollershutterlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
ImageButton rollershutterUpButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_up);
ImageButton rollershutterStopButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_stop);
ImageButton rollershutterDownButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_down);
rollershutterUpButton.setTag(openHABWidget.getItem());
rollershutterStopButton.setTag(openHABWidget.getItem());
rollershutterDownButton.setTag(openHABWidget.getItem());
rollershutterUpButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
rollershutterStopButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
rollershutterDownButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
MySmartImageView rollershutterImage=(MySmartImageView)widgetView.findViewById(R.id.rollershutterimage);
rollershutterImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_TEXT:
labelTextView=(TextView)widgetView.findViewById(R.id.textlabel);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
valueTextView=(TextView)widgetView.findViewById(R.id.textvalue);
if (valueTextView != null) if (splitString.length > 1) {
valueTextView.setVisibility(View.VISIBLE);
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setVisibility(View.GONE);
valueTextView.setText(""String_Node_Str"");
}
MySmartImageView textImage=(MySmartImageView)widgetView.findViewById(R.id.textimage);
textImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SLIDER:
labelTextView=(TextView)widgetView.findViewById(R.id.sliderlabel);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
MySmartImageView itemImage=(MySmartImageView)widgetView.findViewById(R.id.sliderimage);
itemImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
SeekBar sliderSeekBar=(SeekBar)widgetView.findViewById(R.id.sliderseekbar);
if (openHABWidget.hasItem()) {
sliderSeekBar.setTag(openHABWidget.getItem());
int sliderState=(int)Float.parseFloat(openHABWidget.getItem().getState());
sliderSeekBar.setProgress(sliderState);
sliderSeekBar.setOnSeekBarChangeListener(new OnSeekBarChangeListener(){
@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
}
@Override public void onStartTrackingTouch(SeekBar seekBar){
Log.i(""String_Node_Str"",""String_Node_Str"" + seekBar.getProgress());
}
@Override public void onStopTrackingTouch(SeekBar seekBar){
Log.i(""String_Node_Str"",""String_Node_Str"" + seekBar.getProgress());
OpenHABItem sliderItem=(OpenHABItem)seekBar.getTag();
sendItemCommand(sliderItem,String.valueOf(seekBar.getProgress()));
}
}
);
}
break;
case TYPE_IMAGE:
MySmartImageView imageImage=(MySmartImageView)widgetView.findViewById(R.id.imageimage);
imageImage.setImageUrl(ensureAbsoluteURL(openHABBaseUrl,openHABWidget.getUrl()),false);
if (openHABWidget.getRefresh() > 0) {
imageImage.setRefreshRate(openHABWidget.getRefresh());
refreshImageList.add(imageImage);
}
break;
case TYPE_CHART:
MySmartImageView chartImage=(MySmartImageView)widgetView.findViewById(R.id.chartimage);
OpenHABItem chartItem=openHABWidget.getItem();
Random random=new Random();
String chartUrl=""String_Node_Str"";
if (chartItem.getType().equals(""String_Node_Str"")) {
chartUrl=openHABBaseUrl + ""String_Node_Str"" + chartItem.getName()+ ""String_Node_Str""+ openHABWidget.getPeriod()+ ""String_Node_Str""+ String.valueOf(random.nextInt());
}
Log.i(""String_Node_Str"",""String_Node_Str"" + chartUrl);
chartImage.setImageUrl(chartUrl,false);
ViewGroup.LayoutParams chartLayoutParams=chartImage.getLayoutParams();
int screenWidth=((WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getWidth();
chartLayoutParams.height=(int)(screenWidth / 1.88);
chartImage.setLayoutParams(chartLayoutParams);
if (openHABWidget.getRefresh() > 0) {
chartImage.setRefreshRate(openHABWidget.getRefresh());
refreshImageList.add(chartImage);
}
Log.i(""String_Node_Str"",""String_Node_Str"" + chartLayoutParams.width + ""String_Node_Str""+ chartLayoutParams.height);
break;
case TYPE_VIDEO:
VideoView videoVideo=(VideoView)widgetView.findViewById(R.id.videovideo);
Log.i(""String_Node_Str"",""String_Node_Str"" + openHABWidget.getUrl());
WindowManager wm=(WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE);
ViewGroup.LayoutParams videoLayoutParams=videoVideo.getLayoutParams();
videoLayoutParams.height=(int)(wm.getDefaultDisplay().getWidth() / 1.77);
videoVideo.setLayoutParams(videoLayoutParams);
if (!videoWidgetList.contains(videoVideo)) videoWidgetList.add(videoVideo);
if (!videoVideo.isPlaying()) {
videoVideo.setVideoURI(Uri.parse(openHABWidget.getUrl()));
videoVideo.start();
}
Log.i(""String_Node_Str"",""String_Node_Str"" + videoVideo.getHeight());
break;
case TYPE_WEB:
WebView webWeb=(WebView)widgetView.findViewById(R.id.webweb);
if (openHABWidget.getHeight() > 0) {
ViewGroup.LayoutParams webLayoutParams=webWeb.getLayoutParams();
webLayoutParams.height=openHABWidget.getHeight() * 80;
webWeb.setLayoutParams(webLayoutParams);
}
webWeb.setWebViewClient(new WebViewClient());
webWeb.loadUrl(openHABWidget.getUrl());
break;
case TYPE_SELECTION:
labelTextView=(TextView)widgetView.findViewById(R.id.selectionlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
Spinner selectionSpinner=(Spinner)widgetView.findViewById(R.id.selectionspinner);
ArrayList<String> spinnerArray=new ArrayList<String>();
Iterator<OpenHABWidgetMapping> mappingIterator=openHABWidget.getMappings().iterator();
while (mappingIterator.hasNext()) {
spinnerArray.add(mappingIterator.next().getLabel());
}
ArrayAdapter<String> spinnerAdapter=new ArrayAdapter<String>(this.getContext(),android.R.layout.simple_spinner_item,spinnerArray);
spinnerAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
selectionSpinner.setAdapter(spinnerAdapter);
selectionSpinner.setTag(openHABWidget);
selectionSpinner.setSelection((int)Float.parseFloat(openHABWidget.getItem().getState()));
selectionSpinner.setOnItemSelectedListener(new OnItemSelectedListener(){
@Override public void onItemSelected(AdapterView<?> parent,View view,int index,long id){
Log.i(""String_Node_Str"",""String_Node_Str"" + index);
OpenHABWidget openHABWidget=(OpenHABWidget)parent.getTag();
if (openHABWidget != null) Log.i(""String_Node_Str"",""String_Node_Str"" + openHABWidget.getMapping(index).getLabel());
if (!openHABWidget.getItem().getState().equals(openHABWidget.getMapping(index).getCommand())) sendItemCommand(openHABWidget.getItem(),openHABWidget.getMapping(index).getCommand());
}
@Override public void onNothingSelected(AdapterView<?> arg0){
}
}
);
MySmartImageView selectionImage=(MySmartImageView)widgetView.findViewById(R.id.selectionimage);
selectionImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SETPOINT:
labelTextView=(TextView)widgetView.findViewById(R.id.setpointlabel);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
MySmartImageView setPointImage=(MySmartImageView)widgetView.findViewById(R.id.setpointimage);
setPointImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
TextView setPointValueTextView=(TextView)widgetView.findViewById(R.id.setpointvaluelabel);
if (setPointValueTextView != null) if (splitString.length > 1) {
setPointValueTextView.setVisibility(View.VISIBLE);
setPointValueTextView.setText(splitString[1]);
}
Button setPointMinusButton=(Button)widgetView.findViewById(R.id.setpointbutton_minus);
Button setPointPlusButton=(Button)widgetView.findViewById(R.id.setpointbutton_plus);
setPointMinusButton.setTag(openHABWidget);
setPointPlusButton.setTag(openHABWidget);
setPointMinusButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View v){
Log.i(""String_Node_Str"",""String_Node_Str"");
OpenHABWidget setPointWidget=(OpenHABWidget)v.getTag();
float currentValue=Float.valueOf(setPointWidget.getItem().getState()).floatValue();
currentValue=currentValue - setPointWidget.getStep();
if (currentValue < setPointWidget.getMinValue()) currentValue=setPointWidget.getMinValue();
sendItemCommand(setPointWidget.getItem(),String.valueOf(currentValue));
}
}
);
setPointPlusButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View v){
Log.i(""String_Node_Str"",""String_Node_Str"");
OpenHABWidget setPointWidget=(OpenHABWidget)v.getTag();
float currentValue=Float.valueOf(setPointWidget.getItem().getState()).floatValue();
currentValue=currentValue + setPointWidget.getStep();
if (currentValue > setPointWidget.getMaxValue()) currentValue=setPointWidget.getMaxValue();
sendItemCommand(setPointWidget.getItem(),String.valueOf(currentValue));
}
}
);
break;
default :
labelTextView=(TextView)widgetView.findViewById(R.id.itemlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
MySmartImageView sliderImage=(MySmartImageView)widgetView.findViewById(R.id.itemimage);
sliderImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
}
LinearLayout dividerLayout=(LinearLayout)widgetView.findViewById(R.id.listdivider);
if (dividerLayout != null) {
if (position < this.getCount() - 1) {
if (this.getItemViewType(position + 1) == TYPE_FRAME) {
dividerLayout.setVisibility(View.GONE);
}
 else {
dividerLayout.setVisibility(View.VISIBLE);
}
}
 else {
dividerLayout.setVisibility(View.GONE);
}
}
return widgetView;
}",0.9909845788849349
29781,"/** 
 * Parse XML sitemap page and show it
 * @param content	XML as a text
 * @return      void
 */
public void processContent(String content){
  DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
  try {
    DocumentBuilder builder=factory.newDocumentBuilder();
    Document document;
    document=builder.parse(new ByteArrayInputStream(content.getBytes(""String_Node_Str"")));
    Node rootNode=document.getFirstChild();
    openHABWidgetDataSource.setSourceNode(rootNode);
    widgetList.clear();
    openHABWidgetAdapter.stopVideoWidgets();
    for (    OpenHABWidget w : openHABWidgetDataSource.getWidgets()) {
      widgetList.add(w);
    }
    openHABWidgetAdapter.notifyDataSetChanged();
    setTitle(openHABWidgetDataSource.getTitle());
    setProgressBarIndeterminateVisibility(false);
    getListView().setSelection(0);
    getListView().setOnItemClickListener(new OnItemClickListener(){
      @Override public void onItemClick(      AdapterView<?> parent,      View view,      int position,      long id){
        Log.i(TAG,""String_Node_Str"" + String.valueOf(position));
        OpenHABWidget openHABWidget=openHABWidgetAdapter.getItem(position);
        if (openHABWidget.hasLinkedPage()) {
          pageStack.add(0,new OpenHABPage(displayPageUrl,OpenHABWidgetListActivity.this.getListView().getFirstVisiblePosition()));
          displayPageUrl=openHABWidget.getLinkedPage().getLink();
          showPage(openHABWidget.getLinkedPage().getLink(),false);
        }
      }
    }
);
  }
 catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  showPage(displayPageUrl,true);
}","/** 
 * Parse XML sitemap page and show it
 * @param content	XML as a text
 * @return      void
 */
public void processContent(String content){
  DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
  try {
    DocumentBuilder builder=factory.newDocumentBuilder();
    Document document;
    document=builder.parse(new ByteArrayInputStream(content.getBytes(""String_Node_Str"")));
    Node rootNode=document.getFirstChild();
    openHABWidgetDataSource.setSourceNode(rootNode);
    widgetList.clear();
    openHABWidgetAdapter.stopVideoWidgets();
    openHABWidgetAdapter.stopImageRefresh();
    for (    OpenHABWidget w : openHABWidgetDataSource.getWidgets()) {
      widgetList.add(w);
    }
    openHABWidgetAdapter.notifyDataSetChanged();
    setTitle(openHABWidgetDataSource.getTitle());
    setProgressBarIndeterminateVisibility(false);
    getListView().setSelection(0);
    getListView().setOnItemClickListener(new OnItemClickListener(){
      @Override public void onItemClick(      AdapterView<?> parent,      View view,      int position,      long id){
        Log.i(TAG,""String_Node_Str"" + String.valueOf(position));
        OpenHABWidget openHABWidget=openHABWidgetAdapter.getItem(position);
        if (openHABWidget.hasLinkedPage()) {
          pageStack.add(0,new OpenHABPage(displayPageUrl,OpenHABWidgetListActivity.this.getListView().getFirstVisiblePosition()));
          displayPageUrl=openHABWidget.getLinkedPage().getLink();
          showPage(openHABWidget.getLinkedPage().getLink(),false);
        }
      }
    }
);
  }
 catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  showPage(displayPageUrl,true);
}",0.987688098495212
29782,"@SuppressWarnings(""String_Node_Str"") @Override public View getView(int position,View convertView,ViewGroup parent){
  final RelativeLayout widgetView;
  TextView labelTextView;
  TextView valueTextView;
  int widgetLayout=0;
  String[] splitString={};
  OpenHABWidget openHABWidget=getItem(position);
  int screenWidth=((WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getWidth();
switch (this.getItemViewType(position)) {
case TYPE_FRAME:
    widgetLayout=R.layout.openhabwidgetlist_frameitem;
  break;
case TYPE_GROUP:
widgetLayout=R.layout.openhabwidgetlist_groupitem;
break;
case TYPE_SECTIONSWITCH:
widgetLayout=R.layout.openhabwidgetlist_sectionswitchitem;
break;
case TYPE_SWITCH:
widgetLayout=R.layout.openhabwidgetlist_switchitem;
break;
case TYPE_ROLLERSHUTTER:
widgetLayout=R.layout.openhabwidgetlist_rollershutteritem;
break;
case TYPE_TEXT:
widgetLayout=R.layout.openhabwidgetlist_textitem;
break;
case TYPE_SLIDER:
widgetLayout=R.layout.openhabwidgetlist_slideritem;
break;
case TYPE_IMAGE:
widgetLayout=R.layout.openhabwidgetlist_imageitem;
break;
case TYPE_SELECTION:
widgetLayout=R.layout.openhabwidgetlist_selectionitem;
break;
case TYPE_SETPOINT:
widgetLayout=R.layout.openhabwidgetlist_setpointitem;
break;
case TYPE_CHART:
widgetLayout=R.layout.openhabwidgetlist_chartitem;
break;
case TYPE_VIDEO:
widgetLayout=R.layout.openhabwidgetlist_videoitem;
break;
case TYPE_WEB:
widgetLayout=R.layout.openhabwidgetlist_webitem;
break;
case TYPE_COLOR:
widgetLayout=R.layout.openhabwidgetlist_coloritem;
break;
default :
widgetLayout=R.layout.openhabwidgetlist_genericitem;
break;
}
if (convertView == null) {
widgetView=new RelativeLayout(getContext());
String inflater=Context.LAYOUT_INFLATER_SERVICE;
LayoutInflater vi;
vi=(LayoutInflater)getContext().getSystemService(inflater);
vi.inflate(widgetLayout,widgetView,true);
}
 else {
widgetView=(RelativeLayout)convertView;
}
switch (getItemViewType(position)) {
case TYPE_FRAME:
labelTextView=(TextView)widgetView.findViewById(R.id.framelabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
widgetView.setClickable(false);
if (openHABWidget.getLabel().length() > 0) {
widgetView.setVisibility(View.VISIBLE);
labelTextView.setVisibility(View.VISIBLE);
}
 else {
widgetView.setVisibility(View.GONE);
labelTextView.setVisibility(View.GONE);
}
break;
case TYPE_GROUP:
labelTextView=(TextView)widgetView.findViewById(R.id.grouplabel);
valueTextView=(TextView)widgetView.findViewById(R.id.groupvalue);
if (labelTextView != null && valueTextView != null) {
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
labelTextView.setText(splitString[0]);
if (splitString.length > 1) {
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setText(""String_Node_Str"");
}
}
MySmartImageView groupImage=(MySmartImageView)widgetView.findViewById(R.id.groupimage);
groupImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SECTIONSWITCH:
labelTextView=(TextView)widgetView.findViewById(R.id.sectionswitchlabel);
valueTextView=(TextView)widgetView.findViewById(R.id.sectionswitchvalue);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
if (splitString.length > 1 && valueTextView != null) {
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setText(""String_Node_Str"");
}
RadioGroup sectionSwitchRadioGroup=(RadioGroup)widgetView.findViewById(R.id.sectionswitchradiogroup);
sectionSwitchRadioGroup.removeAllViews();
sectionSwitchRadioGroup.setTag(openHABWidget);
Iterator<OpenHABWidgetMapping> sectionMappingIterator=openHABWidget.getMappings().iterator();
while (sectionMappingIterator.hasNext()) {
OpenHABWidgetMapping widgetMapping=sectionMappingIterator.next();
SegmentedControlButton segmentedControlButton=(SegmentedControlButton)LayoutInflater.from(sectionSwitchRadioGroup.getContext()).inflate(R.layout.openhabwidgetlist_sectionswitchitem_button,sectionSwitchRadioGroup,false);
segmentedControlButton.setText(widgetMapping.getLabel());
segmentedControlButton.setTag(widgetMapping.getCommand());
if (widgetMapping.getCommand().equals(openHABWidget.getItem().getState())) {
segmentedControlButton.setChecked(true);
}
 else {
segmentedControlButton.setChecked(false);
}
sectionSwitchRadioGroup.addView(segmentedControlButton);
}
sectionSwitchRadioGroup.setOnCheckedChangeListener(new OnCheckedChangeListener(){
@Override public void onCheckedChanged(RadioGroup group,int checkedId){
OpenHABWidget radioWidget=(OpenHABWidget)group.getTag();
SegmentedControlButton selectedButton=(SegmentedControlButton)group.findViewById(checkedId);
if (selectedButton != null) {
Log.i(""String_Node_Str"",""String_Node_Str"" + selectedButton.getText());
Log.i(""String_Node_Str"",""String_Node_Str"" + (String)selectedButton.getTag());
sendItemCommand(radioWidget.getItem(),(String)selectedButton.getTag());
}
}
}
);
MySmartImageView sectionSwitchImage=(MySmartImageView)widgetView.findViewById(R.id.sectionswitchimage);
sectionSwitchImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SWITCH:
labelTextView=(TextView)widgetView.findViewById(R.id.switchlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
Switch switchSwitch=(Switch)widgetView.findViewById(R.id.switchswitch);
if (openHABWidget.hasItem()) {
if (openHABWidget.getItem().getState().equals(""String_Node_Str"")) {
switchSwitch.setChecked(true);
}
 else {
switchSwitch.setChecked(false);
}
}
switchSwitch.setTag(openHABWidget.getItem());
switchSwitch.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
Switch switchSwitch=(Switch)v;
OpenHABItem linkedItem=(OpenHABItem)switchSwitch.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) if (!switchSwitch.isChecked()) {
sendItemCommand(linkedItem,""String_Node_Str"");
}
 else {
sendItemCommand(linkedItem,""String_Node_Str"");
}
return false;
}
}
);
MySmartImageView switchImage=(MySmartImageView)widgetView.findViewById(R.id.switchimage);
switchImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_COLOR:
labelTextView=(TextView)widgetView.findViewById(R.id.colorlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
ImageButton colorUpButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_up);
ImageButton colorDownButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_down);
ImageButton colorColorButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_color);
colorUpButton.setTag(openHABWidget.getItem());
colorDownButton.setTag(openHABWidget.getItem());
colorColorButton.setTag(openHABWidget.getItem());
colorUpButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(colorItem,""String_Node_Str"");
return false;
}
}
);
colorDownButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(colorItem,""String_Node_Str"");
return false;
}
}
);
colorColorButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
Log.i(""String_Node_Str"",""String_Node_Str"" + colorItem.getStateAsHSV()[0] + ""String_Node_Str""+ colorItem.getStateAsHSV()[1]+ ""String_Node_Str""+ colorItem.getStateAsHSV()[2]);
Log.i(""String_Node_Str"",""String_Node_Str"" + colorItem.getStateAsColor());
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) {
Log.i(""String_Node_Str"",""String_Node_Str"");
ColorPickerDialog colorDialog=new ColorPickerDialog(widgetView.getContext(),new OnColorChangedListener(){
@Override public void colorChanged(int color,View v){
Log.i(""String_Node_Str"",""String_Node_Str"" + color);
float[] HSVColor={0,0,0};
Color.colorToHSV(color,HSVColor);
Log.i(""String_Node_Str"",""String_Node_Str"" + HSVColor[0] + ""String_Node_Str""+ HSVColor[1]+ ""String_Node_Str""+ HSVColor[2]);
String newColor=String.valueOf(HSVColor[0]) + ""String_Node_Str"" + String.valueOf(HSVColor[1])+ ""String_Node_Str""+ String.valueOf(HSVColor[2]);
OpenHABItem colorItem=(OpenHABItem)v.getTag();
sendItemCommand(colorItem,newColor);
}
}
,colorItem.getStateAsColor());
colorDialog.setTag(colorItem);
colorDialog.show();
}
return false;
}
}
);
MySmartImageView colorImage=(MySmartImageView)widgetView.findViewById(R.id.colorimage);
colorImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_ROLLERSHUTTER:
labelTextView=(TextView)widgetView.findViewById(R.id.rollershutterlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
ImageButton rollershutterUpButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_up);
ImageButton rollershutterStopButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_stop);
ImageButton rollershutterDownButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_down);
rollershutterUpButton.setTag(openHABWidget.getItem());
rollershutterStopButton.setTag(openHABWidget.getItem());
rollershutterDownButton.setTag(openHABWidget.getItem());
rollershutterUpButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
rollershutterStopButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
rollershutterDownButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
MySmartImageView rollershutterImage=(MySmartImageView)widgetView.findViewById(R.id.rollershutterimage);
rollershutterImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_TEXT:
labelTextView=(TextView)widgetView.findViewById(R.id.textlabel);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
valueTextView=(TextView)widgetView.findViewById(R.id.textvalue);
if (valueTextView != null) if (splitString.length > 1) {
valueTextView.setVisibility(View.VISIBLE);
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setVisibility(View.GONE);
valueTextView.setText(""String_Node_Str"");
}
MySmartImageView textImage=(MySmartImageView)widgetView.findViewById(R.id.textimage);
textImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SLIDER:
labelTextView=(TextView)widgetView.findViewById(R.id.sliderlabel);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
MySmartImageView itemImage=(MySmartImageView)widgetView.findViewById(R.id.sliderimage);
itemImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
SeekBar sliderSeekBar=(SeekBar)widgetView.findViewById(R.id.sliderseekbar);
if (openHABWidget.hasItem()) {
sliderSeekBar.setTag(openHABWidget.getItem());
int sliderState=(int)Float.parseFloat(openHABWidget.getItem().getState());
sliderSeekBar.setProgress(sliderState);
sliderSeekBar.setOnSeekBarChangeListener(new OnSeekBarChangeListener(){
@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
}
@Override public void onStartTrackingTouch(SeekBar seekBar){
Log.i(""String_Node_Str"",""String_Node_Str"" + seekBar.getProgress());
}
@Override public void onStopTrackingTouch(SeekBar seekBar){
Log.i(""String_Node_Str"",""String_Node_Str"" + seekBar.getProgress());
OpenHABItem sliderItem=(OpenHABItem)seekBar.getTag();
sendItemCommand(sliderItem,String.valueOf(seekBar.getProgress()));
}
}
);
}
break;
case TYPE_IMAGE:
MySmartImageView imageImage=(MySmartImageView)widgetView.findViewById(R.id.imageimage);
imageImage.setImageUrl(ensureAbsoluteURL(openHABBaseUrl,openHABWidget.getUrl()),false);
if (openHABWidget.getRefresh() > 0) {
imageImage.setRefreshRate(openHABWidget.getRefresh());
refreshImageList.add(imageImage);
}
break;
case TYPE_CHART:
MySmartImageView chartImage=(MySmartImageView)widgetView.findViewById(R.id.chartimage);
OpenHABItem chartItem=openHABWidget.getItem();
Random random=new Random();
String chartUrl=""String_Node_Str"";
if (chartItem.getType().equals(""String_Node_Str"")) {
chartUrl=openHABBaseUrl + ""String_Node_Str"" + chartItem.getName()+ ""String_Node_Str""+ openHABWidget.getPeriod()+ ""String_Node_Str""+ String.valueOf(random.nextInt());
}
Log.i(""String_Node_Str"",""String_Node_Str"" + chartUrl);
if (chartImage == null) Log.e(""String_Node_Str"",""String_Node_Str"");
if (openHABUsername != null && openHABPassword != null) chartImage.setImageUrl(chartUrl,false,openHABUsername,openHABPassword);
 else chartImage.setImageUrl(chartUrl,false);
ViewGroup.LayoutParams chartLayoutParams=chartImage.getLayoutParams();
chartLayoutParams.height=(int)(screenWidth / 1.88);
chartImage.setLayoutParams(chartLayoutParams);
if (openHABWidget.getRefresh() > 0) {
chartImage.setRefreshRate(openHABWidget.getRefresh());
refreshImageList.add(chartImage);
}
Log.i(""String_Node_Str"",""String_Node_Str"" + chartLayoutParams.width + ""String_Node_Str""+ chartLayoutParams.height);
break;
case TYPE_VIDEO:
VideoView videoVideo=(VideoView)widgetView.findViewById(R.id.videovideo);
Log.i(""String_Node_Str"",""String_Node_Str"" + openHABWidget.getUrl());
WindowManager wm=(WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE);
ViewGroup.LayoutParams videoLayoutParams=videoVideo.getLayoutParams();
videoLayoutParams.height=(int)(wm.getDefaultDisplay().getWidth() / 1.77);
videoVideo.setLayoutParams(videoLayoutParams);
if (!videoWidgetList.contains(videoVideo)) videoWidgetList.add(videoVideo);
if (!videoVideo.isPlaying()) {
videoVideo.setVideoURI(Uri.parse(openHABWidget.getUrl()));
videoVideo.start();
}
Log.i(""String_Node_Str"",""String_Node_Str"" + videoVideo.getHeight());
break;
case TYPE_WEB:
WebView webWeb=(WebView)widgetView.findViewById(R.id.webweb);
if (openHABWidget.getHeight() > 0) {
ViewGroup.LayoutParams webLayoutParams=webWeb.getLayoutParams();
webLayoutParams.height=openHABWidget.getHeight() * 80;
webWeb.setLayoutParams(webLayoutParams);
}
webWeb.setWebViewClient(new WebViewClient());
webWeb.loadUrl(openHABWidget.getUrl());
break;
case TYPE_SELECTION:
labelTextView=(TextView)widgetView.findViewById(R.id.selectionlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
Spinner selectionSpinner=(Spinner)widgetView.findViewById(R.id.selectionspinner);
ArrayList<String> spinnerArray=new ArrayList<String>();
Iterator<OpenHABWidgetMapping> mappingIterator=openHABWidget.getMappings().iterator();
while (mappingIterator.hasNext()) {
spinnerArray.add(mappingIterator.next().getLabel());
}
ArrayAdapter<String> spinnerAdapter=new ArrayAdapter<String>(this.getContext(),android.R.layout.simple_spinner_item,spinnerArray);
spinnerAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
selectionSpinner.setAdapter(spinnerAdapter);
selectionSpinner.setTag(openHABWidget);
selectionSpinner.setSelection((int)Float.parseFloat(openHABWidget.getItem().getState()));
selectionSpinner.setOnItemSelectedListener(new OnItemSelectedListener(){
@Override public void onItemSelected(AdapterView<?> parent,View view,int index,long id){
Log.i(""String_Node_Str"",""String_Node_Str"" + index);
OpenHABWidget openHABWidget=(OpenHABWidget)parent.getTag();
if (openHABWidget != null) Log.i(""String_Node_Str"",""String_Node_Str"" + openHABWidget.getMapping(index).getLabel());
if (!openHABWidget.getItem().getState().equals(openHABWidget.getMapping(index).getCommand())) sendItemCommand(openHABWidget.getItem(),openHABWidget.getMapping(index).getCommand());
}
@Override public void onNothingSelected(AdapterView<?> arg0){
}
}
);
MySmartImageView selectionImage=(MySmartImageView)widgetView.findViewById(R.id.selectionimage);
selectionImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SETPOINT:
labelTextView=(TextView)widgetView.findViewById(R.id.setpointlabel);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
MySmartImageView setPointImage=(MySmartImageView)widgetView.findViewById(R.id.setpointimage);
setPointImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
TextView setPointValueTextView=(TextView)widgetView.findViewById(R.id.setpointvaluelabel);
if (setPointValueTextView != null) if (splitString.length > 1) {
setPointValueTextView.setVisibility(View.VISIBLE);
setPointValueTextView.setText(splitString[1]);
}
Button setPointMinusButton=(Button)widgetView.findViewById(R.id.setpointbutton_minus);
Button setPointPlusButton=(Button)widgetView.findViewById(R.id.setpointbutton_plus);
setPointMinusButton.setTag(openHABWidget);
setPointPlusButton.setTag(openHABWidget);
setPointMinusButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View v){
Log.i(""String_Node_Str"",""String_Node_Str"");
OpenHABWidget setPointWidget=(OpenHABWidget)v.getTag();
float currentValue=Float.valueOf(setPointWidget.getItem().getState()).floatValue();
currentValue=currentValue - setPointWidget.getStep();
if (currentValue < setPointWidget.getMinValue()) currentValue=setPointWidget.getMinValue();
sendItemCommand(setPointWidget.getItem(),String.valueOf(currentValue));
}
}
);
setPointPlusButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View v){
Log.i(""String_Node_Str"",""String_Node_Str"");
OpenHABWidget setPointWidget=(OpenHABWidget)v.getTag();
float currentValue=Float.valueOf(setPointWidget.getItem().getState()).floatValue();
currentValue=currentValue + setPointWidget.getStep();
if (currentValue > setPointWidget.getMaxValue()) currentValue=setPointWidget.getMaxValue();
sendItemCommand(setPointWidget.getItem(),String.valueOf(currentValue));
}
}
);
break;
default :
labelTextView=(TextView)widgetView.findViewById(R.id.itemlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
MySmartImageView sliderImage=(MySmartImageView)widgetView.findViewById(R.id.itemimage);
sliderImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
}
LinearLayout dividerLayout=(LinearLayout)widgetView.findViewById(R.id.listdivider);
if (dividerLayout != null) {
if (position < this.getCount() - 1) {
if (this.getItemViewType(position + 1) == TYPE_FRAME) {
dividerLayout.setVisibility(View.GONE);
}
 else {
dividerLayout.setVisibility(View.VISIBLE);
}
}
 else {
dividerLayout.setVisibility(View.GONE);
}
}
return widgetView;
}","@SuppressWarnings(""String_Node_Str"") @Override public View getView(int position,View convertView,ViewGroup parent){
  final RelativeLayout widgetView;
  TextView labelTextView;
  TextView valueTextView;
  int widgetLayout=0;
  String[] splitString={};
  OpenHABWidget openHABWidget=getItem(position);
  int screenWidth=((WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getWidth();
switch (this.getItemViewType(position)) {
case TYPE_FRAME:
    widgetLayout=R.layout.openhabwidgetlist_frameitem;
  break;
case TYPE_GROUP:
widgetLayout=R.layout.openhabwidgetlist_groupitem;
break;
case TYPE_SECTIONSWITCH:
widgetLayout=R.layout.openhabwidgetlist_sectionswitchitem;
break;
case TYPE_SWITCH:
widgetLayout=R.layout.openhabwidgetlist_switchitem;
break;
case TYPE_ROLLERSHUTTER:
widgetLayout=R.layout.openhabwidgetlist_rollershutteritem;
break;
case TYPE_TEXT:
widgetLayout=R.layout.openhabwidgetlist_textitem;
break;
case TYPE_SLIDER:
widgetLayout=R.layout.openhabwidgetlist_slideritem;
break;
case TYPE_IMAGE:
widgetLayout=R.layout.openhabwidgetlist_imageitem;
break;
case TYPE_SELECTION:
widgetLayout=R.layout.openhabwidgetlist_selectionitem;
break;
case TYPE_SETPOINT:
widgetLayout=R.layout.openhabwidgetlist_setpointitem;
break;
case TYPE_CHART:
widgetLayout=R.layout.openhabwidgetlist_chartitem;
break;
case TYPE_VIDEO:
widgetLayout=R.layout.openhabwidgetlist_videoitem;
break;
case TYPE_WEB:
widgetLayout=R.layout.openhabwidgetlist_webitem;
break;
case TYPE_COLOR:
widgetLayout=R.layout.openhabwidgetlist_coloritem;
break;
default :
widgetLayout=R.layout.openhabwidgetlist_genericitem;
break;
}
if (convertView == null) {
widgetView=new RelativeLayout(getContext());
String inflater=Context.LAYOUT_INFLATER_SERVICE;
LayoutInflater vi;
vi=(LayoutInflater)getContext().getSystemService(inflater);
vi.inflate(widgetLayout,widgetView,true);
}
 else {
widgetView=(RelativeLayout)convertView;
}
switch (getItemViewType(position)) {
case TYPE_FRAME:
labelTextView=(TextView)widgetView.findViewById(R.id.framelabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
widgetView.setClickable(false);
if (openHABWidget.getLabel().length() > 0) {
widgetView.setVisibility(View.VISIBLE);
labelTextView.setVisibility(View.VISIBLE);
}
 else {
widgetView.setVisibility(View.GONE);
labelTextView.setVisibility(View.GONE);
}
break;
case TYPE_GROUP:
labelTextView=(TextView)widgetView.findViewById(R.id.grouplabel);
valueTextView=(TextView)widgetView.findViewById(R.id.groupvalue);
if (labelTextView != null && valueTextView != null) {
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
labelTextView.setText(splitString[0]);
if (splitString.length > 1) {
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setText(""String_Node_Str"");
}
}
MySmartImageView groupImage=(MySmartImageView)widgetView.findViewById(R.id.groupimage);
groupImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SECTIONSWITCH:
labelTextView=(TextView)widgetView.findViewById(R.id.sectionswitchlabel);
valueTextView=(TextView)widgetView.findViewById(R.id.sectionswitchvalue);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
if (splitString.length > 1 && valueTextView != null) {
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setText(""String_Node_Str"");
}
RadioGroup sectionSwitchRadioGroup=(RadioGroup)widgetView.findViewById(R.id.sectionswitchradiogroup);
sectionSwitchRadioGroup.removeAllViews();
sectionSwitchRadioGroup.setTag(openHABWidget);
Iterator<OpenHABWidgetMapping> sectionMappingIterator=openHABWidget.getMappings().iterator();
while (sectionMappingIterator.hasNext()) {
OpenHABWidgetMapping widgetMapping=sectionMappingIterator.next();
SegmentedControlButton segmentedControlButton=(SegmentedControlButton)LayoutInflater.from(sectionSwitchRadioGroup.getContext()).inflate(R.layout.openhabwidgetlist_sectionswitchitem_button,sectionSwitchRadioGroup,false);
segmentedControlButton.setText(widgetMapping.getLabel());
segmentedControlButton.setTag(widgetMapping.getCommand());
if (widgetMapping.getCommand().equals(openHABWidget.getItem().getState())) {
segmentedControlButton.setChecked(true);
}
 else {
segmentedControlButton.setChecked(false);
}
sectionSwitchRadioGroup.addView(segmentedControlButton);
}
sectionSwitchRadioGroup.setOnCheckedChangeListener(new OnCheckedChangeListener(){
@Override public void onCheckedChanged(RadioGroup group,int checkedId){
OpenHABWidget radioWidget=(OpenHABWidget)group.getTag();
SegmentedControlButton selectedButton=(SegmentedControlButton)group.findViewById(checkedId);
if (selectedButton != null) {
Log.i(""String_Node_Str"",""String_Node_Str"" + selectedButton.getText());
Log.i(""String_Node_Str"",""String_Node_Str"" + (String)selectedButton.getTag());
sendItemCommand(radioWidget.getItem(),(String)selectedButton.getTag());
}
}
}
);
MySmartImageView sectionSwitchImage=(MySmartImageView)widgetView.findViewById(R.id.sectionswitchimage);
sectionSwitchImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SWITCH:
labelTextView=(TextView)widgetView.findViewById(R.id.switchlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
Switch switchSwitch=(Switch)widgetView.findViewById(R.id.switchswitch);
if (openHABWidget.hasItem()) {
if (openHABWidget.getItem().getState().equals(""String_Node_Str"")) {
switchSwitch.setChecked(true);
}
 else {
switchSwitch.setChecked(false);
}
}
switchSwitch.setTag(openHABWidget.getItem());
switchSwitch.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
Switch switchSwitch=(Switch)v;
OpenHABItem linkedItem=(OpenHABItem)switchSwitch.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) if (!switchSwitch.isChecked()) {
sendItemCommand(linkedItem,""String_Node_Str"");
}
 else {
sendItemCommand(linkedItem,""String_Node_Str"");
}
return false;
}
}
);
MySmartImageView switchImage=(MySmartImageView)widgetView.findViewById(R.id.switchimage);
switchImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_COLOR:
labelTextView=(TextView)widgetView.findViewById(R.id.colorlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
ImageButton colorUpButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_up);
ImageButton colorDownButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_down);
ImageButton colorColorButton=(ImageButton)widgetView.findViewById(R.id.colorbutton_color);
colorUpButton.setTag(openHABWidget.getItem());
colorDownButton.setTag(openHABWidget.getItem());
colorColorButton.setTag(openHABWidget.getItem());
colorUpButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(colorItem,""String_Node_Str"");
return false;
}
}
);
colorDownButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(colorItem,""String_Node_Str"");
return false;
}
}
);
colorColorButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton colorButton=(ImageButton)v;
OpenHABItem colorItem=(OpenHABItem)colorButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) {
Log.i(""String_Node_Str"",""String_Node_Str"");
ColorPickerDialog colorDialog=new ColorPickerDialog(widgetView.getContext(),new OnColorChangedListener(){
@Override public void colorChanged(int color,View v){
Log.i(""String_Node_Str"",""String_Node_Str"" + color);
float[] HSVColor={0,0,0};
Color.colorToHSV(color,HSVColor);
Log.i(""String_Node_Str"",""String_Node_Str"" + HSVColor[0] + ""String_Node_Str""+ HSVColor[1]+ ""String_Node_Str""+ HSVColor[2]);
String newColor=String.valueOf(HSVColor[0]) + ""String_Node_Str"" + String.valueOf(HSVColor[1])+ ""String_Node_Str""+ String.valueOf(HSVColor[2]);
OpenHABItem colorItem=(OpenHABItem)v.getTag();
sendItemCommand(colorItem,newColor);
}
}
,colorItem.getStateAsColor());
colorDialog.setTag(colorItem);
colorDialog.show();
}
return false;
}
}
);
MySmartImageView colorImage=(MySmartImageView)widgetView.findViewById(R.id.colorimage);
colorImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_ROLLERSHUTTER:
labelTextView=(TextView)widgetView.findViewById(R.id.rollershutterlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
ImageButton rollershutterUpButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_up);
ImageButton rollershutterStopButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_stop);
ImageButton rollershutterDownButton=(ImageButton)widgetView.findViewById(R.id.rollershutterbutton_down);
rollershutterUpButton.setTag(openHABWidget.getItem());
rollershutterStopButton.setTag(openHABWidget.getItem());
rollershutterDownButton.setTag(openHABWidget.getItem());
rollershutterUpButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
rollershutterStopButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
rollershutterDownButton.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View v,MotionEvent motionEvent){
ImageButton rollershutterButton=(ImageButton)v;
OpenHABItem rollershutterItem=(OpenHABItem)rollershutterButton.getTag();
if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) sendItemCommand(rollershutterItem,""String_Node_Str"");
return false;
}
}
);
MySmartImageView rollershutterImage=(MySmartImageView)widgetView.findViewById(R.id.rollershutterimage);
rollershutterImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_TEXT:
labelTextView=(TextView)widgetView.findViewById(R.id.textlabel);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
valueTextView=(TextView)widgetView.findViewById(R.id.textvalue);
if (valueTextView != null) if (splitString.length > 1) {
valueTextView.setVisibility(View.VISIBLE);
valueTextView.setText(splitString[1]);
}
 else {
valueTextView.setVisibility(View.GONE);
valueTextView.setText(""String_Node_Str"");
}
MySmartImageView textImage=(MySmartImageView)widgetView.findViewById(R.id.textimage);
textImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SLIDER:
labelTextView=(TextView)widgetView.findViewById(R.id.sliderlabel);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
MySmartImageView itemImage=(MySmartImageView)widgetView.findViewById(R.id.sliderimage);
itemImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
SeekBar sliderSeekBar=(SeekBar)widgetView.findViewById(R.id.sliderseekbar);
if (openHABWidget.hasItem()) {
sliderSeekBar.setTag(openHABWidget.getItem());
int sliderState=(int)Float.parseFloat(openHABWidget.getItem().getState());
sliderSeekBar.setProgress(sliderState);
sliderSeekBar.setOnSeekBarChangeListener(new OnSeekBarChangeListener(){
@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
}
@Override public void onStartTrackingTouch(SeekBar seekBar){
Log.i(""String_Node_Str"",""String_Node_Str"" + seekBar.getProgress());
}
@Override public void onStopTrackingTouch(SeekBar seekBar){
Log.i(""String_Node_Str"",""String_Node_Str"" + seekBar.getProgress());
OpenHABItem sliderItem=(OpenHABItem)seekBar.getTag();
sendItemCommand(sliderItem,String.valueOf(seekBar.getProgress()));
}
}
);
}
break;
case TYPE_IMAGE:
MySmartImageView imageImage=(MySmartImageView)widgetView.findViewById(R.id.imageimage);
imageImage.setImageUrl(ensureAbsoluteURL(openHABBaseUrl,openHABWidget.getUrl()),false);
if (openHABWidget.getRefresh() > 0) {
imageImage.setRefreshRate(openHABWidget.getRefresh());
refreshImageList.add(imageImage);
}
break;
case TYPE_CHART:
MySmartImageView chartImage=(MySmartImageView)widgetView.findViewById(R.id.chartimage);
OpenHABItem chartItem=openHABWidget.getItem();
Random random=new Random();
String chartUrl=""String_Node_Str"";
if (chartItem.getType().equals(""String_Node_Str"")) {
chartUrl=openHABBaseUrl + ""String_Node_Str"" + chartItem.getName()+ ""String_Node_Str""+ openHABWidget.getPeriod()+ ""String_Node_Str""+ String.valueOf(random.nextInt());
}
Log.i(""String_Node_Str"",""String_Node_Str"" + chartUrl);
if (chartImage == null) Log.e(""String_Node_Str"",""String_Node_Str"");
if (openHABUsername != null && openHABPassword != null) chartImage.setImageUrl(chartUrl,false,openHABUsername,openHABPassword);
 else chartImage.setImageUrl(chartUrl,false);
ViewGroup.LayoutParams chartLayoutParams=chartImage.getLayoutParams();
chartLayoutParams.height=(int)(screenWidth / 1.88);
chartImage.setLayoutParams(chartLayoutParams);
if (openHABWidget.getRefresh() > 0) {
chartImage.setRefreshRate(openHABWidget.getRefresh());
refreshImageList.add(chartImage);
}
Log.i(""String_Node_Str"",""String_Node_Str"" + chartLayoutParams.width + ""String_Node_Str""+ chartLayoutParams.height);
break;
case TYPE_VIDEO:
VideoView videoVideo=(VideoView)widgetView.findViewById(R.id.videovideo);
Log.i(""String_Node_Str"",""String_Node_Str"" + openHABWidget.getUrl());
WindowManager wm=(WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE);
ViewGroup.LayoutParams videoLayoutParams=videoVideo.getLayoutParams();
videoLayoutParams.height=(int)(wm.getDefaultDisplay().getWidth() / 1.77);
videoVideo.setLayoutParams(videoLayoutParams);
if (!videoWidgetList.contains(videoVideo)) videoWidgetList.add(videoVideo);
if (!videoVideo.isPlaying()) {
videoVideo.setVideoURI(Uri.parse(openHABWidget.getUrl()));
videoVideo.start();
}
Log.i(""String_Node_Str"",""String_Node_Str"" + videoVideo.getHeight());
break;
case TYPE_WEB:
WebView webWeb=(WebView)widgetView.findViewById(R.id.webweb);
if (openHABWidget.getHeight() > 0) {
ViewGroup.LayoutParams webLayoutParams=webWeb.getLayoutParams();
webLayoutParams.height=openHABWidget.getHeight() * 80;
webWeb.setLayoutParams(webLayoutParams);
}
webWeb.setWebViewClient(new WebViewClient());
webWeb.loadUrl(openHABWidget.getUrl());
break;
case TYPE_SELECTION:
labelTextView=(TextView)widgetView.findViewById(R.id.selectionlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
Spinner selectionSpinner=(Spinner)widgetView.findViewById(R.id.selectionspinner);
ArrayList<String> spinnerArray=new ArrayList<String>();
Iterator<OpenHABWidgetMapping> mappingIterator=openHABWidget.getMappings().iterator();
while (mappingIterator.hasNext()) {
spinnerArray.add(mappingIterator.next().getLabel());
}
ArrayAdapter<String> spinnerAdapter=new ArrayAdapter<String>(this.getContext(),android.R.layout.simple_spinner_item,spinnerArray);
spinnerAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
selectionSpinner.setAdapter(spinnerAdapter);
selectionSpinner.setTag(openHABWidget);
selectionSpinner.setSelection((int)Float.parseFloat(openHABWidget.getItem().getState()));
selectionSpinner.setOnItemSelectedListener(new OnItemSelectedListener(){
@Override public void onItemSelected(AdapterView<?> parent,View view,int index,long id){
Log.i(""String_Node_Str"",""String_Node_Str"" + index);
OpenHABWidget openHABWidget=(OpenHABWidget)parent.getTag();
if (openHABWidget != null) Log.i(""String_Node_Str"",""String_Node_Str"" + openHABWidget.getMapping(index).getLabel());
if (!openHABWidget.getItem().getState().equals(openHABWidget.getMapping(index).getCommand())) sendItemCommand(openHABWidget.getItem(),openHABWidget.getMapping(index).getCommand());
}
@Override public void onNothingSelected(AdapterView<?> arg0){
}
}
);
MySmartImageView selectionImage=(MySmartImageView)widgetView.findViewById(R.id.selectionimage);
selectionImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
case TYPE_SETPOINT:
labelTextView=(TextView)widgetView.findViewById(R.id.setpointlabel);
splitString=openHABWidget.getLabel().split(""String_Node_Str"");
if (labelTextView != null) labelTextView.setText(splitString[0]);
MySmartImageView setPointImage=(MySmartImageView)widgetView.findViewById(R.id.setpointimage);
setPointImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
TextView setPointValueTextView=(TextView)widgetView.findViewById(R.id.setpointvaluelabel);
if (setPointValueTextView != null) if (splitString.length > 1) {
setPointValueTextView.setVisibility(View.VISIBLE);
setPointValueTextView.setText(splitString[1]);
}
Button setPointMinusButton=(Button)widgetView.findViewById(R.id.setpointbutton_minus);
Button setPointPlusButton=(Button)widgetView.findViewById(R.id.setpointbutton_plus);
setPointMinusButton.setTag(openHABWidget);
setPointPlusButton.setTag(openHABWidget);
setPointMinusButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View v){
Log.i(""String_Node_Str"",""String_Node_Str"");
OpenHABWidget setPointWidget=(OpenHABWidget)v.getTag();
float currentValue=Float.valueOf(setPointWidget.getItem().getState()).floatValue();
currentValue=currentValue - setPointWidget.getStep();
if (currentValue < setPointWidget.getMinValue()) currentValue=setPointWidget.getMinValue();
sendItemCommand(setPointWidget.getItem(),String.valueOf(currentValue));
}
}
);
setPointPlusButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View v){
Log.i(""String_Node_Str"",""String_Node_Str"");
OpenHABWidget setPointWidget=(OpenHABWidget)v.getTag();
float currentValue=Float.valueOf(setPointWidget.getItem().getState()).floatValue();
currentValue=currentValue + setPointWidget.getStep();
if (currentValue > setPointWidget.getMaxValue()) currentValue=setPointWidget.getMaxValue();
sendItemCommand(setPointWidget.getItem(),String.valueOf(currentValue));
}
}
);
break;
default :
labelTextView=(TextView)widgetView.findViewById(R.id.itemlabel);
if (labelTextView != null) labelTextView.setText(openHABWidget.getLabel());
MySmartImageView sliderImage=(MySmartImageView)widgetView.findViewById(R.id.itemimage);
sliderImage.setImageUrl(openHABBaseUrl + ""String_Node_Str"" + openHABWidget.getIcon()+ ""String_Node_Str"");
break;
}
LinearLayout dividerLayout=(LinearLayout)widgetView.findViewById(R.id.listdivider);
if (dividerLayout != null) {
if (position < this.getCount() - 1) {
if (this.getItemViewType(position + 1) == TYPE_FRAME) {
dividerLayout.setVisibility(View.GONE);
}
 else {
dividerLayout.setVisibility(View.VISIBLE);
}
}
 else {
dividerLayout.setVisibility(View.GONE);
}
}
return widgetView;
}",0.9937697834497312
29783,"/** 
 * Parse XML sitemap page and show it
 * @param content	XML as a text
 * @return      void
 */
public void processContent(String content){
  DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
  try {
    DocumentBuilder builder=factory.newDocumentBuilder();
    Document document;
    openHABWidgetAdapter.stopVideoWidgets();
    openHABWidgetAdapter.stopImageRefresh();
    document=builder.parse(new ByteArrayInputStream(content.getBytes(""String_Node_Str"")));
    Node rootNode=document.getFirstChild();
    openHABWidgetDataSource.setSourceNode(rootNode);
    widgetList.clear();
    for (    OpenHABWidget w : openHABWidgetDataSource.getWidgets()) {
      widgetList.add(w);
    }
    openHABWidgetAdapter.notifyDataSetChanged();
    setTitle(openHABWidgetDataSource.getTitle());
    setProgressBarIndeterminateVisibility(false);
    getListView().setOnItemClickListener(new OnItemClickListener(){
      @Override public void onItemClick(      AdapterView<?> parent,      View view,      int position,      long id){
        Log.i(TAG,""String_Node_Str"" + String.valueOf(position));
        OpenHABWidget openHABWidget=openHABWidgetAdapter.getItem(position);
        if (openHABWidget.hasLinkedPage()) {
          pageStack.add(0,new OpenHABPage(displayPageUrl,OpenHABWidgetListActivity.this.getListView().getFirstVisiblePosition()));
          displayPageUrl=openHABWidget.getLinkedPage().getLink();
          showPage(openHABWidget.getLinkedPage().getLink(),false);
        }
      }
    }
);
  }
 catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  showPage(displayPageUrl,true);
}","/** 
 * Parse XML sitemap page and show it
 * @param content	XML as a text
 * @return      void
 */
public void processContent(String content){
  DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
  try {
    DocumentBuilder builder=factory.newDocumentBuilder();
    Document document;
    openHABWidgetAdapter.stopVideoWidgets();
    openHABWidgetAdapter.stopImageRefresh();
    if (content != null) {
      document=builder.parse(new ByteArrayInputStream(content.getBytes(""String_Node_Str"")));
    }
 else {
      Log.i(TAG,""String_Node_Str"");
      return;
    }
    Node rootNode=document.getFirstChild();
    openHABWidgetDataSource.setSourceNode(rootNode);
    widgetList.clear();
    for (    OpenHABWidget w : openHABWidgetDataSource.getWidgets()) {
      widgetList.add(w);
    }
    openHABWidgetAdapter.notifyDataSetChanged();
    setTitle(openHABWidgetDataSource.getTitle());
    setProgressBarIndeterminateVisibility(false);
    getListView().setOnItemClickListener(new OnItemClickListener(){
      @Override public void onItemClick(      AdapterView<?> parent,      View view,      int position,      long id){
        Log.i(TAG,""String_Node_Str"" + String.valueOf(position));
        OpenHABWidget openHABWidget=openHABWidgetAdapter.getItem(position);
        if (openHABWidget.hasLinkedPage()) {
          pageStack.add(0,new OpenHABPage(displayPageUrl,OpenHABWidgetListActivity.this.getListView().getFirstVisiblePosition()));
          displayPageUrl=openHABWidget.getLinkedPage().getLink();
          showPage(openHABWidget.getLinkedPage().getLink(),false);
        }
      }
    }
);
  }
 catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  showPage(displayPageUrl,true);
}",0.9734513274336284
29784,"@Override public void onFailure(Throwable e){
  if (e.getMessage() != null) {
    if (e.getMessage().equals(""String_Node_Str"")) {
      showAlertDialog(""String_Node_Str"");
    }
 else {
      showAlertDialog(""String_Node_Str"" + e.getMessage());
    }
  }
 else {
    showAlertDialog(""String_Node_Str"");
  }
}","@Override public void onFailure(Throwable e){
  if (e.getMessage() != null) {
    if (e.getMessage().equals(""String_Node_Str"")) {
      showAlertDialog(""String_Node_Str"");
    }
 else {
      showAlertDialog(""String_Node_Str"" + e.getMessage());
    }
  }
 else {
  }
}",0.9201388888888888
29785,"/** 
 * Parse XML sitemap page and show it
 * @param content	XML as a text
 * @return      void
 */
public void processContent(String content){
  DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
  try {
    DocumentBuilder builder=factory.newDocumentBuilder();
    Document document;
    document=builder.parse(new ByteArrayInputStream(content.getBytes(""String_Node_Str"")));
    Node rootNode=document.getFirstChild();
    openHABWidgetDataSource.setSourceNode(rootNode);
    widgetList.clear();
    openHABWidgetAdapter.stopVideoWidgets();
    openHABWidgetAdapter.stopImageRefresh();
    for (    OpenHABWidget w : openHABWidgetDataSource.getWidgets()) {
      widgetList.add(w);
    }
    openHABWidgetAdapter.notifyDataSetChanged();
    setTitle(openHABWidgetDataSource.getTitle());
    setProgressBarIndeterminateVisibility(false);
    getListView().setSelection(0);
    getListView().setOnItemClickListener(new OnItemClickListener(){
      @Override public void onItemClick(      AdapterView<?> parent,      View view,      int position,      long id){
        Log.i(TAG,""String_Node_Str"" + String.valueOf(position));
        OpenHABWidget openHABWidget=openHABWidgetAdapter.getItem(position);
        if (openHABWidget.hasLinkedPage()) {
          pageStack.add(0,new OpenHABPage(displayPageUrl,OpenHABWidgetListActivity.this.getListView().getFirstVisiblePosition()));
          displayPageUrl=openHABWidget.getLinkedPage().getLink();
          showPage(openHABWidget.getLinkedPage().getLink(),false);
        }
      }
    }
);
  }
 catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  showPage(displayPageUrl,true);
}","/** 
 * Parse XML sitemap page and show it
 * @param content	XML as a text
 * @return      void
 */
public void processContent(String content){
  DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
  try {
    DocumentBuilder builder=factory.newDocumentBuilder();
    Document document;
    document=builder.parse(new ByteArrayInputStream(content.getBytes(""String_Node_Str"")));
    Node rootNode=document.getFirstChild();
    openHABWidgetDataSource.setSourceNode(rootNode);
    widgetList.clear();
    openHABWidgetAdapter.stopVideoWidgets();
    openHABWidgetAdapter.stopImageRefresh();
    for (    OpenHABWidget w : openHABWidgetDataSource.getWidgets()) {
      widgetList.add(w);
    }
    openHABWidgetAdapter.notifyDataSetChanged();
    setTitle(openHABWidgetDataSource.getTitle());
    setProgressBarIndeterminateVisibility(false);
    getListView().setOnItemClickListener(new OnItemClickListener(){
      @Override public void onItemClick(      AdapterView<?> parent,      View view,      int position,      long id){
        Log.i(TAG,""String_Node_Str"" + String.valueOf(position));
        OpenHABWidget openHABWidget=openHABWidgetAdapter.getItem(position);
        if (openHABWidget.hasLinkedPage()) {
          pageStack.add(0,new OpenHABPage(displayPageUrl,OpenHABWidgetListActivity.this.getListView().getFirstVisiblePosition()));
          displayPageUrl=openHABWidget.getLinkedPage().getLink();
          showPage(openHABWidget.getLinkedPage().getLink(),false);
        }
      }
    }
);
  }
 catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  showPage(displayPageUrl,true);
}",0.990450204638472
29786,"/** 
 * Get sitemaps from openHAB, if user already configured preffered sitemap just open it. If no preffered sitemap is configured - let user select one.
 * @param baseUrl  an absolute base URL of openHAB to open
 * @return      void
 */
private void selectSitemap(final String baseURL,final boolean forceSelect){
  Log.i(TAG,""String_Node_Str"" + baseURL + ""String_Node_Str"");
  AsyncHttpClient asyncHttpClient=new MyAsyncHttpClient();
  asyncHttpClient.setBasicAuthCredientidals(openHABUsername,openHABPassword);
  asyncHttpClient.get(baseURL + ""String_Node_Str"",new AsyncHttpResponseHandler(){
    @Override public void onSuccess(    String content){
      List<OpenHABSitemap> sitemapList=parseSitemapList(content);
      if (sitemapList.size() == 0) {
        showAlertDialog(""String_Node_Str"");
        return;
      }
      if (forceSelect) {
        showSitemapSelectionDialog(sitemapList);
      }
 else {
        SharedPreferences settings=PreferenceManager.getDefaultSharedPreferences(OpenHABWidgetListActivity.this);
        String configuredSitemap=settings.getString(""String_Node_Str"",""String_Node_Str"");
        if (configuredSitemap.length() > 0) {
          if (sitemapExists(sitemapList,configuredSitemap)) {
            Log.i(TAG,""String_Node_Str"");
            OpenHABSitemap selectedSitemap=getSitemapByName(sitemapList,configuredSitemap);
            openSitemap(selectedSitemap.getHomepageLink());
          }
 else {
            Log.i(TAG,""String_Node_Str"");
            if (sitemapList.size() == 1) {
              Log.i(TAG,""String_Node_Str"");
              Editor preferencesEditor=settings.edit();
              preferencesEditor.putString(""String_Node_Str"",sitemapList.get(0).getName());
              preferencesEditor.commit();
              openSitemap(sitemapList.get(0).getHomepageLink());
            }
 else {
              Log.i(TAG,""String_Node_Str"");
              showSitemapSelectionDialog(sitemapList);
            }
          }
        }
 else {
          if (sitemapList.size() == 1) {
            Log.i(TAG,""String_Node_Str"");
            Editor preferencesEditor=settings.edit();
            preferencesEditor.putString(""String_Node_Str"",sitemapList.get(0).getName());
            preferencesEditor.commit();
            openSitemap(sitemapList.get(0).getHomepageLink());
          }
 else {
            Log.i(TAG,""String_Node_Str"");
            showSitemapSelectionDialog(sitemapList);
          }
        }
      }
    }
    @Override public void onFailure(    Throwable e){
      if (e.getMessage() != null) {
        if (e.getMessage().equals(""String_Node_Str"")) {
          showAlertDialog(""String_Node_Str"");
        }
 else {
          showAlertDialog(""String_Node_Str"" + e.getMessage());
        }
      }
 else {
        showAlertDialog(""String_Node_Str"");
      }
    }
  }
);
}","/** 
 * Get sitemaps from openHAB, if user already configured preffered sitemap just open it. If no preffered sitemap is configured - let user select one.
 * @param baseUrl  an absolute base URL of openHAB to open
 * @return      void
 */
private void selectSitemap(final String baseURL,final boolean forceSelect){
  Log.i(TAG,""String_Node_Str"" + baseURL + ""String_Node_Str"");
  AsyncHttpClient asyncHttpClient=new MyAsyncHttpClient();
  asyncHttpClient.setBasicAuthCredientidals(openHABUsername,openHABPassword);
  asyncHttpClient.get(baseURL + ""String_Node_Str"",new AsyncHttpResponseHandler(){
    @Override public void onSuccess(    String content){
      List<OpenHABSitemap> sitemapList=parseSitemapList(content);
      if (sitemapList.size() == 0) {
        showAlertDialog(""String_Node_Str"");
        return;
      }
      if (forceSelect) {
        showSitemapSelectionDialog(sitemapList);
      }
 else {
        SharedPreferences settings=PreferenceManager.getDefaultSharedPreferences(OpenHABWidgetListActivity.this);
        String configuredSitemap=settings.getString(""String_Node_Str"",""String_Node_Str"");
        if (configuredSitemap.length() > 0) {
          if (sitemapExists(sitemapList,configuredSitemap)) {
            Log.i(TAG,""String_Node_Str"");
            OpenHABSitemap selectedSitemap=getSitemapByName(sitemapList,configuredSitemap);
            openSitemap(selectedSitemap.getHomepageLink());
          }
 else {
            Log.i(TAG,""String_Node_Str"");
            if (sitemapList.size() == 1) {
              Log.i(TAG,""String_Node_Str"");
              Editor preferencesEditor=settings.edit();
              preferencesEditor.putString(""String_Node_Str"",sitemapList.get(0).getName());
              preferencesEditor.commit();
              openSitemap(sitemapList.get(0).getHomepageLink());
            }
 else {
              Log.i(TAG,""String_Node_Str"");
              showSitemapSelectionDialog(sitemapList);
            }
          }
        }
 else {
          if (sitemapList.size() == 1) {
            Log.i(TAG,""String_Node_Str"");
            Editor preferencesEditor=settings.edit();
            preferencesEditor.putString(""String_Node_Str"",sitemapList.get(0).getName());
            preferencesEditor.commit();
            openSitemap(sitemapList.get(0).getHomepageLink());
          }
 else {
            Log.i(TAG,""String_Node_Str"");
            showSitemapSelectionDialog(sitemapList);
          }
        }
      }
    }
    @Override public void onFailure(    Throwable e){
      if (e.getMessage() != null) {
        if (e.getMessage().equals(""String_Node_Str"")) {
          showAlertDialog(""String_Node_Str"");
        }
 else {
          showAlertDialog(""String_Node_Str"" + e.getMessage());
        }
      }
 else {
      }
    }
  }
);
}",0.9921736036997508
29787,"/** 
 * We run all openHAB browsing in a single activity, so we need to intercept 'Back' key to get back to previous sitemap page. If no pages in stack - simulate typical android app behaviour - exit application.
 */
@Override public boolean onKeyDown(int keyCode,KeyEvent event){
  Log.i(TAG,""String_Node_Str"" + keyCode);
  if (keyCode == 4) {
    Log.i(TAG,""String_Node_Str"");
    if (pageStack.size() > 0) {
      displayPageUrl=pageStack.get(0).getPageUrl();
      pageStack.remove(0);
      showPage(displayPageUrl,false);
    }
 else {
      Log.i(TAG,""String_Node_Str"");
      finish();
    }
    return true;
  }
 else {
    return super.onKeyDown(keyCode,event);
  }
}","/** 
 * We run all openHAB browsing in a single activity, so we need to intercept 'Back' key to get back to previous sitemap page. If no pages in stack - simulate typical android app behaviour - exit application.
 */
@Override public boolean onKeyDown(int keyCode,KeyEvent event){
  Log.i(TAG,""String_Node_Str"" + keyCode);
  if (keyCode == 4) {
    Log.i(TAG,""String_Node_Str"");
    if (pageStack.size() > 0) {
      displayPageUrl=pageStack.get(0).getPageUrl();
      Log.i(TAG,String.format(""String_Node_Str"",pageStack.get(0).getWidgetListPosition()));
      widgetListPosition=pageStack.get(0).getWidgetListPosition();
      pageStack.remove(0);
      showPage(displayPageUrl,false);
    }
 else {
      Log.i(TAG,""String_Node_Str"");
      finish();
    }
    return true;
  }
 else {
    return super.onKeyDown(keyCode,event);
  }
}",0.8949107732980833
29788,"/** 
 * Parse XML sitemap page and show it
 * @param content	XML as a text
 * @return      void
 */
public void processContent(String content){
  DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
  try {
    DocumentBuilder builder=factory.newDocumentBuilder();
    Document document;
    openHABWidgetAdapter.stopVideoWidgets();
    openHABWidgetAdapter.stopImageRefresh();
    if (content != null) {
      document=builder.parse(new ByteArrayInputStream(content.getBytes(""String_Node_Str"")));
    }
 else {
      Log.i(TAG,""String_Node_Str"");
      return;
    }
    Node rootNode=document.getFirstChild();
    openHABWidgetDataSource.setSourceNode(rootNode);
    widgetList.clear();
    for (    OpenHABWidget w : openHABWidgetDataSource.getWidgets()) {
      widgetList.add(w);
    }
    openHABWidgetAdapter.notifyDataSetChanged();
    setTitle(openHABWidgetDataSource.getTitle());
    setProgressBarIndeterminateVisibility(false);
    getListView().setOnItemClickListener(new OnItemClickListener(){
      @Override public void onItemClick(      AdapterView<?> parent,      View view,      int position,      long id){
        Log.i(TAG,""String_Node_Str"" + String.valueOf(position));
        OpenHABWidget openHABWidget=openHABWidgetAdapter.getItem(position);
        if (openHABWidget.hasLinkedPage()) {
          pageStack.add(0,new OpenHABPage(displayPageUrl,OpenHABWidgetListActivity.this.getListView().getFirstVisiblePosition()));
          displayPageUrl=openHABWidget.getLinkedPage().getLink();
          showPage(openHABWidget.getLinkedPage().getLink(),false);
        }
      }
    }
);
  }
 catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  showPage(displayPageUrl,true);
}","/** 
 * Parse XML sitemap page and show it
 * @param content	XML as a text
 * @return      void
 */
public void processContent(String content){
  DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
  try {
    DocumentBuilder builder=factory.newDocumentBuilder();
    Document document;
    openHABWidgetAdapter.stopVideoWidgets();
    openHABWidgetAdapter.stopImageRefresh();
    if (content != null) {
      document=builder.parse(new ByteArrayInputStream(content.getBytes(""String_Node_Str"")));
    }
 else {
      Log.i(TAG,""String_Node_Str"");
      return;
    }
    Node rootNode=document.getFirstChild();
    openHABWidgetDataSource.setSourceNode(rootNode);
    widgetList.clear();
    for (    OpenHABWidget w : openHABWidgetDataSource.getWidgets()) {
      widgetList.add(w);
    }
    openHABWidgetAdapter.notifyDataSetChanged();
    setTitle(openHABWidgetDataSource.getTitle());
    setProgressBarIndeterminateVisibility(false);
    getListView().setSelection(this.widgetListPosition);
    getListView().setOnItemClickListener(new OnItemClickListener(){
      @Override public void onItemClick(      AdapterView<?> parent,      View view,      int position,      long id){
        Log.i(TAG,""String_Node_Str"" + String.valueOf(position));
        OpenHABWidget openHABWidget=openHABWidgetAdapter.getItem(position);
        if (openHABWidget.hasLinkedPage()) {
          pageStack.add(0,new OpenHABPage(displayPageUrl,OpenHABWidgetListActivity.this.getListView().getFirstVisiblePosition()));
          displayPageUrl=openHABWidget.getLinkedPage().getLink();
          showPage(openHABWidget.getLinkedPage().getLink(),false);
        }
      }
    }
);
  }
 catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  this.widgetListPosition=0;
  showPage(displayPageUrl,true);
}",0.978027593254982
29789,"@Override public void afterAll(ExtensionContext context) throws Exception {
  new CommonReportHelper().finishReport((ReportModel)context.getStore(NAMESPACE).get(REPORT_MODEL));
}","@Override public void afterAll(ExtensionContext context) throws Exception {
  ScenarioHolder.get().removeScenarioOfCurrentThread();
  new CommonReportHelper().finishReport((ReportModel)context.getStore(NAMESPACE).get(REPORT_MODEL));
}",0.8640776699029126
29790,"public void some_failing_step(){
  Assertions.assertTrue(false,""String_Node_Str"");
}","public WhenStage some_failing_step(){
  Assertions.assertTrue(false,""String_Node_Str"");
  return this;
}",0.851063829787234
29791,"private <T>void updateScenarioState(T t){
  injector.updateValues(t);
}","private <T>void updateScenarioState(T t){
  try {
    injector.updateValues(t);
  }
 catch (  JGivenMissingRequiredScenarioStateException e) {
    if (!suppressExceptions) {
      throw e;
    }
  }
}",0.5166051660516605
29792,"@SuppressWarnings(""String_Node_Str"") public void updateValues(Object object){
  validateFields(object);
  for (  ScenarioStateField field : getScenarioFields(object)) {
    Object value=getValue(field);
    if (value != null) {
      try {
        field.getField().set(object,value);
      }
 catch (      IllegalAccessException e) {
        throw new RuntimeException(""String_Node_Str"" + field.getField(),e);
      }
      log.debug(""String_Node_Str"",field.getField(),value);
    }
 else     if (field.isRequired()) {
      throw new JGivenMissingRequiredScenarioStateException(field.getField());
    }
  }
}","/** 
 * @throws JGivenMissingRequiredScenarioStateException in case a field requiresa value and the value is not present
 */
@SuppressWarnings(""String_Node_Str"") public void updateValues(Object object){
  validateFields(object);
  for (  ScenarioStateField field : getScenarioFields(object)) {
    Object value=getValue(field);
    if (value != null) {
      try {
        field.getField().set(object,value);
      }
 catch (      IllegalAccessException e) {
        throw new RuntimeException(""String_Node_Str"" + field.getField(),e);
      }
      log.debug(""String_Node_Str"",field.getField(),value);
    }
 else     if (field.isRequired()) {
      throw new JGivenMissingRequiredScenarioStateException(field.getField());
    }
  }
}",0.9069247952345496
29793,"@Test @Ignore(""String_Node_Str"") @Pending public void required_does_not_fail_for_pending_scenarios() throws Throwable {
  when().some_action();
}","@Test @Pending public void required_does_not_fail_for_pending_scenarios() throws Throwable {
  when().some_action();
}",0.8973384030418251
29794,"public THEN then(String translatedGiven){
  addIntroWord(translatedGiven);
  return getThenStage();
}","public THEN then(String translatedThen){
  addIntroWord(translatedThen);
  return getThenStage();
}",0.95
29795,"public WHEN when(String translatedGiven){
  addIntroWord(translatedGiven);
  return getWhenStage();
}","public WHEN when(String translatedWhen){
  addIntroWord(translatedWhen);
  return getWhenStage();
}",0.95
29796,"private List<ColumnSpec> getColumnSpecs(List<List<String>> dataTableModel){
  ColumnSpec[] result=new ColumnSpec[dataTableModel.get(0).size()];
  for (int nrow=0; nrow < dataTableModel.size(); nrow++) {
    List<String> row=dataTableModel.get(nrow);
    for (int ncol=0; ncol < row.size(); ncol++) {
      String value=row.get(ncol);
      int width=value.length();
      ColumnSpec spec=result[ncol];
      if (spec == null) {
        spec=new ColumnSpec();
        result[ncol]=spec;
      }
      if (width > spec.width) {
        spec.width=width;
      }
      if (nrow > 0 && Doubles.tryParse(value) == null) {
        spec.leftAligned=true;
      }
    }
  }
  return Lists.newArrayList(result);
}","private List<ColumnSpec> getColumnSpecs(List<List<String>> dataTableModel){
  ColumnSpec[] result=new ColumnSpec[dataTableModel.get(0).size()];
  for (int nrow=0; nrow < dataTableModel.size(); nrow++) {
    List<String> row=dataTableModel.get(nrow);
    for (int ncol=0; ncol < row.size(); ncol++) {
      String value=row.get(ncol);
      int width=Math.max(value.length(),1);
      ColumnSpec spec=result[ncol];
      if (spec == null) {
        spec=new ColumnSpec();
        result[ncol]=spec;
      }
      if (width > spec.width) {
        spec.width=width;
      }
      if (nrow > 0 && Doubles.tryParse(value) == null) {
        spec.leftAligned=true;
      }
    }
  }
  return Lists.newArrayList(result);
}",0.991549295774648
29797,"static private Collection<List<String>> splitRow(List<String> row){
  List<List<String>> columns=Lists.newArrayListWithExpectedSize(row.size());
  int nRows=0;
  for (  String cell : row) {
    List<String> lines=FluentIterable.from(Splitter.on('\n').split(cell)).toList();
    if (lines.size() > nRows) {
      nRows=lines.size();
    }
    columns.add(lines);
  }
  List<List<String>> rows=Lists.newArrayListWithCapacity(nRows);
  for (int iRow=0; iRow < nRows; iRow++) {
    List<String> newRow=Lists.newArrayListWithExpectedSize(row.size());
    for (int iCol=0; iCol < columns.size(); iCol++) {
      List<String> column=columns.get(iCol);
      String cell=""String_Node_Str"";
      if (iRow < column.size()) {
        cell=column.get(iRow);
      }
      newRow.add(cell);
    }
    rows.add(newRow);
  }
  return rows;
}","static private Collection<List<String>> splitRow(List<String> row){
  List<List<String>> columns=Lists.newArrayListWithExpectedSize(row.size());
  int nRows=0;
  for (  String cell : row) {
    List<String> lines=FluentIterable.from(Splitter.onPattern(""String_Node_Str"").split(cell)).toList();
    if (lines.size() > nRows) {
      nRows=lines.size();
    }
    columns.add(lines);
  }
  List<List<String>> rows=Lists.newArrayListWithCapacity(nRows);
  for (int iRow=0; iRow < nRows; iRow++) {
    List<String> newRow=Lists.newArrayListWithExpectedSize(row.size());
    for (int iCol=0; iCol < columns.size(); iCol++) {
      List<String> column=columns.get(iCol);
      String cell=""String_Node_Str"";
      if (iRow < column.size()) {
        cell=column.get(iRow);
      }
      newRow.add(cell);
    }
    rows.add(newRow);
  }
  return rows;
}",0.982078853046595
29798,"@Test public void handleNewLinesOneNewLine() throws Exception {
  String[][] testData=new String[][]{{""String_Node_Str"",""String_Node_Str""}};
  List<List<String>> result=PlainTextTableWriter.handleNewLines(toListOfList(testData));
  List<List<String>> expected=toListOfList(new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}});
  assertThat(result).isEqualTo(expected);
}","@Test @DataProvider({""String_Node_Str"",""String_Node_Str""}) public void handleNewLinesOneNewLine(String testString) throws Exception {
  String[][] testData=new String[][]{{testString,""String_Node_Str""}};
  List<List<String>> result=PlainTextTableWriter.handleNewLines(toListOfList(testData));
  List<List<String>> expected=toListOfList(new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}});
  assertThat(result).isEqualTo(expected);
}",0.8901472253680635
29799,"private boolean wordsAreDifferent(StepModel firstStep,StepModel stepModel){
  for (int iWord=0; iWord < firstStep.getWords().size(); iWord++) {
    Word firstWord=firstStep.getWord(iWord);
    Word word=stepModel.getWord(iWord);
    if (firstWord.isArg() != word.isArg()) {
      return true;
    }
    if (!firstWord.isArg() && !firstWord.getValue().equals(word.getValue())) {
      return true;
    }
  }
  return false;
}","private boolean wordsAreDifferent(StepModel firstStep,StepModel stepModel){
  for (int iWord=0; iWord < firstStep.getWords().size(); iWord++) {
    Word firstWord=firstStep.getWord(iWord);
    Word word=stepModel.getWord(iWord);
    if (firstWord.isArg() != word.isArg()) {
      return true;
    }
    if (!firstWord.isArg() && !firstWord.getValue().equals(word.getValue())) {
      return true;
    }
    if (firstWord.isArg() && firstWord.isDataTable() && !firstWord.getArgumentInfo().getDataTable().equals(word.getArgumentInfo().getDataTable())) {
      return true;
    }
  }
  return false;
}",0.8023483365949119
29800,"/** 
 * Returns a list with argument words that are not equal in all cases
 */
List<List<Word>> getDifferentArguments(List<List<Word>> argumentWords){
  List<List<Word>> result=Lists.newArrayList();
  for (int i=0; i < argumentWords.size(); i++) {
    result.add(Lists.<Word>newArrayList());
  }
  int nWords=argumentWords.get(0).size();
  for (int iWord=0; iWord < nWords; iWord++) {
    Word wordOfFirstCase=argumentWords.get(0).get(iWord);
    boolean different=false;
    for (int iCase=1; iCase < argumentWords.size(); iCase++) {
      Word wordOfCase=argumentWords.get(iCase).get(iWord);
      if (!wordOfCase.getFormattedValue().equals(wordOfFirstCase.getFormattedValue())) {
        different=true;
        break;
      }
    }
    if (different) {
      for (int iCase=0; iCase < argumentWords.size(); iCase++) {
        result.get(iCase).add(argumentWords.get(iCase).get(iWord));
      }
    }
  }
  return result;
}","/** 
 * Returns a list with argument words that are not equal in all cases
 */
List<List<Word>> getDifferentArguments(List<List<Word>> argumentWords){
  List<List<Word>> result=Lists.newArrayList();
  for (int i=0; i < argumentWords.size(); i++) {
    result.add(Lists.<Word>newArrayList());
  }
  int nWords=argumentWords.get(0).size();
  for (int iWord=0; iWord < nWords; iWord++) {
    Word wordOfFirstCase=argumentWords.get(0).get(iWord);
    if (wordOfFirstCase.isDataTable()) {
      continue;
    }
    boolean different=false;
    for (int iCase=1; iCase < argumentWords.size(); iCase++) {
      Word wordOfCase=argumentWords.get(iCase).get(iWord);
      if (!wordOfCase.getFormattedValue().equals(wordOfFirstCase.getFormattedValue())) {
        different=true;
        break;
      }
    }
    if (different) {
      for (int iCase=0; iCase < argumentWords.size(); iCase++) {
        result.get(iCase).add(argumentWords.get(iCase).get(iWord));
      }
    }
  }
  return result;
}",0.9671018276762402
29801,"private static Iterable<?> toIterable(Object value){
  if (value instanceof Iterable<?>) {
    return (Iterable<?>)value;
  }
  if (value.getClass().isArray()) {
    Object[] array=(Object[])value;
    return Arrays.asList(array);
  }
  return null;
}","private static Iterable<?> toIterable(Object value){
  if (value instanceof Iterable<?>) {
    return (Iterable<?>)value;
  }
  if (value.getClass().isArray()) {
    return arrayToList(value);
  }
  return null;
}",0.771551724137931
29802,"public void analyze(ScenarioModel scenarioModel){
  if (scenarioModel.getScenarioCases().size() < 2) {
    return;
  }
  CollectPhase collectPhase=new CollectPhase(scenarioModel);
  scenarioModel.accept(collectPhase);
  try {
    reduceMatrix(scenarioModel,collectPhase.argumentMatrix);
    scenarioModel.setCasesAsTable(allStepsEqual(collectPhase.allWords));
    if (!scenarioModel.isCasesAsTable()) {
      new CaseDifferenceAnalyzer().analyze(scenarioModel);
    }
  }
 catch (  IndexOutOfBoundsException e) {
    log.info(""String_Node_Str"" + scenarioModel.getClassName() + ""String_Node_Str""+ scenarioModel.getTestMethodName()+ ""String_Node_Str""+ ""String_Node_Str"");
    scenarioModel.setCasesAsTable(false);
  }
}","public void analyze(ScenarioModel scenarioModel){
  if (scenarioModel.getScenarioCases().size() < 2) {
    return;
  }
  CollectPhase collectPhase=new CollectPhase(scenarioModel);
  scenarioModel.accept(collectPhase);
  if (collectPhase.noDataTablePossible) {
    scenarioModel.setCasesAsTable(false);
    return;
  }
  try {
    reduceMatrix(scenarioModel,collectPhase.argumentMatrix);
    scenarioModel.setCasesAsTable(allStepsEqual(collectPhase.allWords));
    if (!scenarioModel.isCasesAsTable()) {
      new CaseDifferenceAnalyzer().analyze(scenarioModel);
    }
  }
 catch (  IndexOutOfBoundsException e) {
    log.info(""String_Node_Str"" + scenarioModel.getClassName() + ""String_Node_Str""+ scenarioModel.getTestMethodName()+ ""String_Node_Str""+ ""String_Node_Str"");
    scenarioModel.setCasesAsTable(false);
  }
}",0.9348109517601044
29803,"@Override public void visit(StepModel stepModel){
  for (  Word word : stepModel.words) {
    if (word.isArg()) {
      ArgumentHolder holder=new ArgumentHolder();
      holder.word=word;
      holder.params=getMatchingParameters(word);
      argumentsOfCurrentCase.add(holder);
    }
    allWordsOfCurrentCase.add(word);
  }
}","@Override public void visit(StepModel stepModel){
  if (stepModel.getAttachment() != null && stepModel.getAttachment().isShowDirectly()) {
    this.noDataTablePossible=true;
  }
  for (  Word word : stepModel.words) {
    if (word.isArg()) {
      ArgumentHolder holder=new ArgumentHolder();
      holder.word=word;
      holder.params=getMatchingParameters(word);
      argumentsOfCurrentCase.add(holder);
    }
    allWordsOfCurrentCase.add(word);
  }
}",0.8363171355498721
29804,"private void drawOval(int width,int height) throws IOException {
  BufferedImage image=new BufferedImage(width,height,BufferedImage.TYPE_INT_ARGB);
  Graphics2D g=image.createGraphics();
  g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  g.setStroke(new BasicStroke(10));
  g.setPaint(Color.BLUE);
  g.drawOval(10,10,width - 20,height - 20);
  ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
  try {
    ImageIO.write(image,""String_Node_Str"",outputStream);
    byte[] bytes=outputStream.toByteArray();
    currentStep.addAttachment(Attachment.fromBinaryBytes(bytes,MediaType.PNG).withTitle(""String_Node_Str"").showDirectly());
  }
  finally {
    outputStream.close();
  }
}","private void drawOval(int width,int height,Color color) throws IOException {
  BufferedImage image=new BufferedImage(width,height,BufferedImage.TYPE_INT_ARGB);
  Graphics2D g=image.createGraphics();
  g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  g.setStroke(new BasicStroke(10));
  g.setPaint(color);
  g.drawOval(10,10,width - 20,height - 20);
  ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
  try {
    ImageIO.write(image,""String_Node_Str"",outputStream);
    byte[] bytes=outputStream.toByteArray();
    currentStep.addAttachment(Attachment.fromBinaryBytes(bytes,MediaType.PNG).withTitle(""String_Node_Str"").showDirectly());
  }
  finally {
    outputStream.close();
  }
}",0.9815699658703072
29805,"public void an_oval_circle() throws IOException {
  drawOval(300,200);
}","public void an_oval_circle() throws IOException {
  drawOval(300,200,Color.BLUE);
}",0.9290322580645162
29806,"public void a_large_oval_circle() throws IOException {
  drawOval(800,600);
}","public void a_large_oval_circle() throws IOException {
  drawOval(800,600,Color.BLUE);
}",0.9333333333333332
29807,"public SELF the_tag_with_name_$_is_clicked(String tagName){
  List<WebElement> links=webDriver.findElements(By.linkText(tagName));
  for (  WebElement link : links) {
    WebElement tag=link.findElement(By.className(""String_Node_Str""));
    if (tag != null) {
      link.click();
      break;
    }
  }
  return self();
}","public SELF the_tag_with_name_$_is_clicked(String tagName){
  List<WebElement> links=webDriver.findElements(By.xpath(String.format(""String_Node_Str"",tagName)));
  links.get(0).click();
  return self();
}",0.5534351145038168
29808,"/** 
 * Creates a   {@code DataTable} with {@code numberOfColumns} columns from the given {@code data} including the header <p/> Example: <pre> table(2, ""name"", ""age"", // header ""Peter"", 20,   // first row of data ""Susan"", 35);  // second row of data </pre>
 * @param numberOfColumns the number of columns the resulting table should have
 * @param data            the data of the table represented as a one-dimensional list,the number of entries must be a multiple of  {@code numberOfColumns}. The first   {@numberOfColumns} elements are taken as the header of the table,the remaining values as data
 * @return a list of list that contains the same data as {@code data}, but in a two-dimensional form
 * @throws java.lang.IllegalArgumentException if {@code data.length % numberOfColumns != 0} 
 */
public static Iterable<? extends Iterable<?>> table(int numberOfColumns,Object... data){
  if (data.length % numberOfColumns != 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + data.length + ""String_Node_Str""+ numberOfColumns);
  }
  return Iterables.partition(Arrays.asList(data),numberOfColumns);
}","/** 
 * Creates a   {@code DataTable} with {@code numberOfColumns} columns from the given {@code data} including the header <p/> Example: <pre> table(2, ""name"", ""age"", // header ""Peter"", 20,   // first row of data ""Susan"", 35);  // second row of data </pre>
 * @param numberOfColumns the number of columns the resulting table should have
 * @param data            the data of the table represented as a one-dimensional list,the number of entries must be a multiple of  {@code numberOfColumns}. The first   {@code numberOfColumns} elements are taken as the header of the table,the remaining values as data
 * @return a list of list that contains the same data as {@code data}, but in a two-dimensional form
 * @throws java.lang.IllegalArgumentException if {@code data.length % numberOfColumns != 0} 
 */
public static Iterable<? extends Iterable<?>> table(int numberOfColumns,Object... data){
  if (data.length % numberOfColumns != 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + data.length + ""String_Node_Str""+ numberOfColumns);
  }
  return Iterables.partition(Arrays.asList(data),numberOfColumns);
}",0.9977588525324966
29809,"private boolean hasMultipleExplicitCases(){
  return !this.scenarioCase.getExplicitArguments().isEmpty() && !scenarioModel.isCasesAsTable();
}","private boolean hasMultipleExplicitCases(){
  return scenarioModel.getScenarioCases().size() > 1 && !scenarioModel.isCasesAsTable();
}",0.7971014492753623
29810,"@Override public void visitEnd(ScenarioCaseModel scenarioCase){
  if (!scenarioCase.success) {
    writer.println(""String_Node_Str"" + scenarioCase.errorMessage + ""String_Node_Str"");
  }
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
}","@Override public void visitEnd(ScenarioCaseModel scenarioCase){
  if (!scenarioCase.success) {
    writer.println(""String_Node_Str"" + scenarioCase.errorMessage + ""String_Node_Str"");
  }
  writer.println(""String_Node_Str"");
  if (hasMultipleExplicitCases()) {
    writer.println(""String_Node_Str"");
  }
  writer.println(""String_Node_Str"");
}",0.9341692789968652
29811,"@Override public void visit(StepModel stepModel){
  String intro=""String_Node_Str"";
  List<Word> words=stepModel.words;
  if (words.get(0).isIntroWord()) {
    intro=withColor(Color.BLUE,Attribute.INTENSITY_BOLD,INDENT + String.format(""String_Node_Str"" + maxFillWordLength + ""String_Node_Str"",WordUtil.capitalize(words.get(0).getValue())));
  }
 else {
    intro=INDENT + words.get(0).getValue();
  }
  String rest=joinWords(words.subList(1,words.size()));
  if (stepModel.isNotImplementedYet()) {
    rest=withColor(Color.BLACK,true,Attribute.INTENSITY_FAINT,rest + ""String_Node_Str"");
  }
 else   if (stepModel.isSkipped()) {
    rest=withColor(Color.BLACK,true,Attribute.INTENSITY_FAINT,rest + ""String_Node_Str"");
  }
 else   if (stepModel.isFailed()) {
    rest=withColor(Color.RED,true,Attribute.INTENSITY_FAINT,rest);
    rest+=withColor(Color.RED,true,Attribute.INTENSITY_BOLD,""String_Node_Str"");
  }
  writer.println(intro + rest);
}","@Override public void visit(StepModel stepModel){
  String intro=""String_Node_Str"";
  List<Word> words=stepModel.words;
  if (words.get(0).isIntroWord()) {
    intro=withColor(Color.BLUE,Attribute.INTENSITY_BOLD,INDENT + String.format(""String_Node_Str"" + maxFillWordLength + ""String_Node_Str"",WordUtil.capitalize(words.get(0).getValue())));
  }
 else {
    intro=INDENT + words.get(0).getValue() + ""String_Node_Str"";
  }
  String rest=joinWords(words.subList(1,words.size()));
  if (stepModel.isNotImplementedYet()) {
    rest=withColor(Color.BLACK,true,Attribute.INTENSITY_FAINT,rest + ""String_Node_Str"");
  }
 else   if (stepModel.isSkipped()) {
    rest=withColor(Color.BLACK,true,Attribute.INTENSITY_FAINT,rest + ""String_Node_Str"");
  }
 else   if (stepModel.isFailed()) {
    rest=withColor(Color.RED,true,Attribute.INTENSITY_FAINT,rest);
    rest+=withColor(Color.RED,true,Attribute.INTENSITY_BOLD,""String_Node_Str"");
  }
  writer.println(intro + rest);
}",0.9894847528916928
29812,"private void writeStatistics(){
  printWriter.write(""String_Node_Str"" + statistics.numClasses + ""String_Node_Str"");
  printWriter.write(""String_Node_Str"" + statistics.numScenarios + ""String_Node_Str"");
  printWriter.write(""String_Node_Str"" + statistics.numCases + ""String_Node_Str"");
  printWriter.write(""String_Node_Str"" + statistics.numFailedCases + ""String_Node_Str"");
  printWriter.write(""String_Node_Str"" + statistics.numSteps + ""String_Node_Str"");
  printWriter.write(""String_Node_Str"" + DurationFormatter.format(statistics.durationInNanos) + ""String_Node_Str"");
  printWriter.write(""String_Node_Str"" + DurationFormatter.format(statistics.durationInNanos / statistics.numCases));
}","private void writeStatistics(){
  printWriter.write(""String_Node_Str"" + statistics.numClasses + ""String_Node_Str"");
  printWriter.write(""String_Node_Str"" + statistics.numScenarios + ""String_Node_Str"");
  printWriter.write(""String_Node_Str"" + statistics.numCases + ""String_Node_Str"");
  printWriter.write(""String_Node_Str"" + statistics.numFailedCases + ""String_Node_Str"");
  printWriter.write(""String_Node_Str"" + statistics.numSteps + ""String_Node_Str"");
  printWriter.write(""String_Node_Str"" + DurationFormatter.format(statistics.durationInNanos) + ""String_Node_Str"");
  long averageNanos=statistics.numCases != 0 ? statistics.durationInNanos / statistics.numCases : 0;
  printWriter.write(""String_Node_Str"" + DurationFormatter.format(averageNanos));
}",0.8895066018068103
29813,"protected void starting(Statement base,FrameworkMethod testMethod,Object target){
  scenario.setModel(reportRule.getTestCaseModel());
  scenario.getExecutor().injectSteps(testInstance);
  Class<?> testClass=target.getClass();
  ReportModelBuilder modelBuilder=scenario.getModelBuilder();
  modelBuilder.setClassName(testClass.getName());
  scenario.getExecutor().startScenario(testMethod.getMethod(),getNamedArguments(base,testMethod,target));
  scenario.getExecutor().readScenarioState(testInstance);
}","protected void starting(Statement base,FrameworkMethod testMethod,Object target){
  scenario.setModel(reportRule.getTestCaseModel());
  scenario.getExecutor().injectSteps(testInstance);
  Class<?> testClass=target.getClass();
  ReportModelBuilder modelBuilder=scenario.getModelBuilder();
  modelBuilder.setTestClass(testClass);
  scenario.getExecutor().startScenario(testMethod.getMethod(),getNamedArguments(base,testMethod,target));
  scenario.getExecutor().readScenarioState(testInstance);
}",0.9518072289156626
29814,"@Override public void onTestStart(ITestResult paramITestResult){
  Object instance=paramITestResult.getInstance();
  scenarioCollectionModel.setClassName(instance.getClass().getName());
  if (instance instanceof ScenarioTestBase<?,?,?>) {
    ScenarioTestBase<?,?,?> testInstance=(ScenarioTestBase<?,?,?>)instance;
    scenario=testInstance.createNewScenario();
  }
 else {
    scenario=new ScenarioBase();
  }
  scenario.setModel(scenarioCollectionModel);
  Method method=paramITestResult.getMethod().getConstructorOrMethod().getMethod();
  scenario.getExecutor().startScenario(method,getArgumentsFrom(method,paramITestResult));
}","@Override public void onTestStart(ITestResult paramITestResult){
  Object instance=paramITestResult.getInstance();
  ReportModelBuilder builder=new ReportModelBuilder(scenarioCollectionModel);
  builder.setTestClass(instance.getClass());
  if (instance instanceof ScenarioTestBase<?,?,?>) {
    ScenarioTestBase<?,?,?> testInstance=(ScenarioTestBase<?,?,?>)instance;
    scenario=testInstance.createNewScenario();
  }
 else {
    scenario=new ScenarioBase();
  }
  scenario.setModel(scenarioCollectionModel);
  Method method=paramITestResult.getMethod().getConstructorOrMethod().getMethod();
  scenario.getExecutor().startScenario(method,getArgumentsFrom(method,paramITestResult));
}",0.9345509893455098
29815,"public TestScenario(String testMethod){
  this.testMethod=testMethod;
}","public TestScenario(String testMethod){
  this.testMethod=testMethod;
  this.testClass=TestScenarios.class;
}",0.7888888888888889
29816,"public boolean matches(ScenarioCriteria criteria){
  if (notImplementedYet != criteria.notImplementedYet) {
    return false;
  }
  if (failIfPassed != null && !failIfPassed.equals(criteria.failIfPassed)) {
    return false;
  }
  if (executeSteps != null && !executeSteps.equals(criteria.executeSteps)) {
    return false;
  }
  if (failing != criteria.failing) {
    return false;
  }
  if (numberOfSteps != null && numberOfSteps != criteria.numberOfSteps) {
    return false;
  }
  if (numberOfFailingStages != null && numberOfFailingStages != criteria.numberOfFailingStages) {
    return false;
  }
  if (failingStep != null && !failingStep.equals(criteria.failingStep)) {
    return false;
  }
  if (stageWithFailingAfterStageMethod != null && !stageWithFailingAfterStageMethod.equals(criteria.stageWithFailingAfterStageMethod)) {
    return false;
  }
  if (tagAnnotation != null && !tagAnnotation.equals(criteria.tagAnnotation)) {
    return false;
  }
  return true;
}","public boolean matches(ScenarioCriteria criteria){
  if (notImplementedYet != criteria.notImplementedYet) {
    return false;
  }
  if (failIfPassed != null && !failIfPassed.equals(criteria.failIfPassed)) {
    return false;
  }
  if (executeSteps != null && !executeSteps.equals(criteria.executeSteps)) {
    return false;
  }
  if (failing != criteria.failing) {
    return false;
  }
  if (numberOfSteps != null && numberOfSteps != criteria.numberOfSteps) {
    return false;
  }
  if (numberOfFailingStages != null && numberOfFailingStages != criteria.numberOfFailingStages) {
    return false;
  }
  if (failingStep != null && !failingStep.equals(criteria.failingStep)) {
    return false;
  }
  if (stageWithFailingAfterStageMethod != null && !stageWithFailingAfterStageMethod.equals(criteria.stageWithFailingAfterStageMethod)) {
    return false;
  }
  if (tagAnnotation != null && !tagAnnotation.equals(criteria.tagAnnotation)) {
    return false;
  }
  if (parameterizedRunner != null && !parameterizedRunner.equals(criteria.parameterizedRunner)) {
    return false;
  }
  if (numberOfParameters != null && numberOfParameters != criteria.numberOfParameters) {
    return false;
  }
  if (testClassDescription != null && !testClassDescription.equals(criteria.testClassDescription)) {
    return false;
  }
  return true;
}",0.8378143972246314
29817,"private static ScenarioCriteria addTestScenario(List<TestScenario> list,String testMethod){
  TestScenario testScenario=new TestScenario(testMethod);
  list.add(testScenario);
  return testScenario.criteria;
}","private static ScenarioCriteria addTestScenario(List<TestScenario> list,Class<?> testClass,String testMethod){
  TestScenario testScenario=new TestScenario(testClass);
  testScenario.testMethod=testMethod;
  list.add(testScenario);
  return testScenario.criteria;
}",0.6919831223628692
29818,"private static List<TestScenario> setupTestScenarios(){
  List<TestScenario> result=Lists.newArrayList();
  addTestScenario(result,""String_Node_Str"").numberOfSteps(2).failingStep(1);
  addTestScenario(result,""String_Node_Str"").numberOfSteps(3).failingStep(1);
  addTestScenario(result,""String_Node_Str"").numberOfSteps(2).failingStep(2);
  addTestScenario(result,""String_Node_Str"").numberOfSteps(2).numberOfFailingStages(2).failingStep(1);
  addTestScenario(result,""String_Node_Str"").numberOfSteps(2).numberOfFailingStages(2).stageWithFailingAfterStageMethod(2).failingStep(1);
  addTestScenario(result,""String_Node_Str"").notImplementedYet().numberOfSteps(2).failingStep(1);
  addTestScenario(result,""String_Node_Str"").notImplementedYet();
  addTestScenario(result,""String_Node_Str"").notImplementedYet().failIfPassed();
  addTestScenario(result,""String_Node_Str"").notImplementedYet().failIfPassed().failingStep(1);
  addTestScenario(result,""String_Node_Str"").notImplementedYet().executeSteps().failingStep(1);
  addTestScenario(result,""String_Node_Str"").tagAnnotation();
  return result;
}","private static List<TestScenario> setupTestScenarios(){
  List<TestScenario> result=Lists.newArrayList();
  addTestScenario(result,""String_Node_Str"").numberOfSteps(2).failingStep(1);
  addTestScenario(result,""String_Node_Str"").numberOfSteps(3).failingStep(1);
  addTestScenario(result,""String_Node_Str"").numberOfSteps(2).failingStep(2);
  addTestScenario(result,""String_Node_Str"").numberOfSteps(2).numberOfFailingStages(2).failingStep(1);
  addTestScenario(result,""String_Node_Str"").numberOfSteps(2).numberOfFailingStages(2).stageWithFailingAfterStageMethod(2).failingStep(1);
  addTestScenario(result,""String_Node_Str"").notImplementedYet().numberOfSteps(2).failingStep(1);
  addTestScenario(result,""String_Node_Str"").notImplementedYet();
  addTestScenario(result,""String_Node_Str"").notImplementedYet().failIfPassed();
  addTestScenario(result,""String_Node_Str"").notImplementedYet().failIfPassed().failingStep(1);
  addTestScenario(result,""String_Node_Str"").notImplementedYet().executeSteps().failingStep(1);
  addTestScenario(result,""String_Node_Str"").tagAnnotation();
  addTestScenario(result,TestClassWithParameterizedRunner.class).parameterizedRunner().numberOfParameters(2);
  addTestScenario(result,TestClassWithDescription.class,""String_Node_Str"").testClassDescription(TestClassWithDescription.class.getAnnotation(Description.class).value());
  return result;
}",0.8859934853420195
29819,"@AfterStage public void findScenario(){
  testScenario=TestScenarioRepository.findScenario(criteria);
}","@AfterStage public void findScenario(){
  if (testScenario == null) {
    testScenario=TestScenarioRepository.findScenario(criteria);
  }
}",0.8512396694214877
29820,"private void executeAfterStageMethods(Object stage) throws Throwable {
  StageState stageState=getStageState(stage);
  if (stageState.afterStageCalled)   return;
  stageState.afterStageCalled=true;
  executeAnnotatedMethods(stage,AfterStage.class);
}","private void executeAfterStageMethods(Object stage) throws Throwable {
  StageState stageState=getStageState(stage);
  if (stageState.afterStageCalled) {
    return;
  }
  stageState.afterStageCalled=true;
  executeAnnotatedMethods(stage,AfterStage.class);
}",0.984251968503937
29821,"@Override public void handleThrowable(Throwable t) throws Throwable {
  failed(t);
}","@Override public void handleThrowable(Throwable t) throws Throwable {
  listener.stepMethodFailed(t);
  failed(t);
}",0.84
29822,"/** 
 * Has to be called when the scenario is finished in order to execute after methods
 */
public void finished() throws Throwable {
  if (state == FINISHED)   return;
  if (state != STARTED)   throw new IllegalStateException(""String_Node_Str"" + state);
  state=FINISHED;
  methodInterceptor.enableMethodHandling(false);
  Throwable firstThrownException=failedException;
  if (beforeStepsWereExecuted) {
    if (currentStage != null) {
      try {
        executeAfterStageMethods(currentStage);
      }
 catch (      AssertionError e) {
        firstThrownException=logAndGetFirstException(firstThrownException,e);
      }
catch (      Exception e) {
        firstThrownException=logAndGetFirstException(firstThrownException,e);
      }
    }
    for (    StageState stage : reverse(newArrayList(stages.values()))) {
      try {
        executeAnnotatedMethods(stage.instance,AfterScenario.class);
      }
 catch (      AssertionError e) {
        firstThrownException=logAndGetFirstException(firstThrownException,e);
      }
catch (      Exception e) {
        firstThrownException=logAndGetFirstException(firstThrownException,e);
      }
    }
  }
  for (  Object rule : Lists.reverse(scenarioRules)) {
    try {
      invokeRuleMethod(rule,""String_Node_Str"");
    }
 catch (    AssertionError e) {
      firstThrownException=logAndGetFirstException(firstThrownException,e);
    }
catch (    Exception e) {
      firstThrownException=logAndGetFirstException(firstThrownException,e);
    }
  }
  failedException=firstThrownException;
  if (!suppressExceptions && failedException != null) {
    throw failedException;
  }
  if (failIfPass && failedException == null) {
    throw new FailIfPassedException();
  }
}","/** 
 * Has to be called when the scenario is finished in order to execute after methods
 */
public void finished() throws Throwable {
  if (state == FINISHED) {
    return;
  }
  if (state != STARTED) {
    throw new IllegalStateException(""String_Node_Str"" + state);
  }
  state=FINISHED;
  methodInterceptor.enableMethodHandling(false);
  Throwable firstThrownException=failedException;
  if (beforeStepsWereExecuted) {
    if (currentStage != null) {
      try {
        executeAfterStageMethods(currentStage);
      }
 catch (      AssertionError e) {
        firstThrownException=logAndGetFirstException(firstThrownException,e);
      }
catch (      Exception e) {
        firstThrownException=logAndGetFirstException(firstThrownException,e);
      }
    }
    for (    StageState stage : reverse(newArrayList(stages.values()))) {
      try {
        executeAnnotatedMethods(stage.instance,AfterScenario.class);
      }
 catch (      AssertionError e) {
        firstThrownException=logAndGetFirstException(firstThrownException,e);
      }
catch (      Exception e) {
        firstThrownException=logAndGetFirstException(firstThrownException,e);
      }
    }
  }
  for (  Object rule : Lists.reverse(scenarioRules)) {
    try {
      invokeRuleMethod(rule,""String_Node_Str"");
    }
 catch (    AssertionError e) {
      firstThrownException=logAndGetFirstException(firstThrownException,e);
    }
catch (    Exception e) {
      firstThrownException=logAndGetFirstException(firstThrownException,e);
    }
  }
  failedException=firstThrownException;
  if (!suppressExceptions && failedException != null) {
    throw failedException;
  }
  if (failIfPass && failedException == null) {
    throw new FailIfPassedException();
  }
}",0.9953596287703016
29823,"@SuppressWarnings(""String_Node_Str"") public <T>T addStage(Class<T> stepsClass){
  if (stages.containsKey(stepsClass))   return (T)stages.get(stepsClass).instance;
  T result=setupCglibProxy(stepsClass);
  stages.put(stepsClass,new StageState(result));
  gatherRules(result);
  injectSteps(result);
  return result;
}","@SuppressWarnings(""String_Node_Str"") public <T>T addStage(Class<T> stepsClass){
  if (stages.containsKey(stepsClass)) {
    return (T)stages.get(stepsClass).instance;
  }
  T result=setupCglibProxy(stepsClass);
  stages.put(stepsClass,new StageState(result));
  gatherRules(result);
  injectSteps(result);
  return result;
}",0.9875
29824,"@Override public void handleMethod(Object stageInstance,Method paramMethod,Object[] arguments,InvocationMode mode) throws Throwable {
  if (paramMethod.isSynthetic())   return;
  if (paramMethod.isAnnotationPresent(AfterStage.class) || paramMethod.isAnnotationPresent(BeforeStage.class) || paramMethod.isAnnotationPresent(BeforeScenario.class)|| paramMethod.isAnnotationPresent(AfterScenario.class)|| paramMethod.isAnnotationPresent(Hidden.class))   return;
  update(stageInstance);
  if (paramMethod.isAnnotationPresent(IntroWord.class)) {
    listener.introWordAdded(paramMethod.getName());
  }
 else {
    listener.stepMethodInvoked(paramMethod,Arrays.asList(arguments),mode);
  }
}","@Override public void handleMethod(Object stageInstance,Method paramMethod,Object[] arguments,InvocationMode mode) throws Throwable {
  if (paramMethod.isSynthetic()) {
    return;
  }
  if (paramMethod.isAnnotationPresent(AfterStage.class) || paramMethod.isAnnotationPresent(BeforeStage.class) || paramMethod.isAnnotationPresent(BeforeScenario.class)|| paramMethod.isAnnotationPresent(AfterScenario.class)|| paramMethod.isAnnotationPresent(Hidden.class)) {
    return;
  }
  update(stageInstance);
  if (paramMethod.isAnnotationPresent(IntroWord.class)) {
    listener.introWordAdded(paramMethod.getName());
  }
 else {
    listener.stepMethodInvoked(paramMethod,Arrays.asList(arguments),mode);
  }
}",0.9884559884559884
29825,"private void ensureBeforeStepsAreExecuted() throws Throwable {
  if (state != State.INIT)   return;
  state=State.STARTED;
  methodInterceptor.enableMethodHandling(false);
  try {
    for (    Object rule : scenarioRules) {
      invokeRuleMethod(rule,""String_Node_Str"");
    }
    beforeStepsWereExecuted=true;
    for (    StageState stage : stages.values()) {
      executeBeforeScenarioSteps(stage.instance);
    }
  }
 catch (  Throwable e) {
    failed(e);
    finished();
    throw e;
  }
  methodInterceptor.enableMethodHandling(true);
}","private void ensureBeforeStepsAreExecuted() throws Throwable {
  if (state != State.INIT) {
    return;
  }
  state=State.STARTED;
  methodInterceptor.enableMethodHandling(false);
  try {
    for (    Object rule : scenarioRules) {
      invokeRuleMethod(rule,""String_Node_Str"");
    }
    beforeStepsWereExecuted=true;
    for (    StageState stage : stages.values()) {
      executeBeforeScenarioSteps(stage.instance);
    }
  }
 catch (  Throwable e) {
    failed(e);
    finished();
    throw e;
  }
  methodInterceptor.enableMethodHandling(true);
}",0.97632058287796
29826,"private void printArg(Word word){
  String value=word.getArgumentInfo().isCaseArg() ? formatCaseArgument(word) : word.value;
  value=escapeToHtml(value);
  String multiLine=value.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
  String caseClass=word.getArgumentInfo().isCaseArg() ? ""String_Node_Str"" : ""String_Node_Str"";
  writer.print(format(""String_Node_Str"",caseClass,multiLine,value));
}","private void printArg(Word word){
  String value=word.getArgumentInfo().isCaseArg() ? formatCaseArgument(word) : HtmlEscapers.htmlEscaper().escape(word.value);
  value=escapeToHtml(value);
  String multiLine=value.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
  String caseClass=word.getArgumentInfo().isCaseArg() ? ""String_Node_Str"" : ""String_Node_Str"";
  writer.print(format(""String_Node_Str"",caseClass,multiLine,value));
}",0.9361207897793264
29827,"String formatCaseArgument(Word word){
  return word.value;
}","String formatCaseArgument(Word word){
  return HtmlEscapers.htmlEscaper().escape(word.value);
}",0.7741935483870968
29828,"@Override public void visit(StepModel stepModel){
  writer.print(""String_Node_Str"");
  boolean firstWord=true;
  for (  Word word : stepModel.words) {
    if (!firstWord) {
      writer.print(' ');
    }
    String text=word.value;
    if (firstWord && word.isIntroWord) {
      writer.print(format(""String_Node_Str"",WordUtil.capitalize(text)));
    }
 else     if (word.isArg()) {
      printArg(word);
    }
 else {
      writer.print(text);
    }
    firstWord=false;
  }
  StepStatus status=stepModel.getStatus();
  if (status != StepStatus.PASSED) {
    String lowerCase=status.toString().toLowerCase();
    writer.print(format(""String_Node_Str"",WordUtil.camelCase(lowerCase),lowerCase.replace('_',' ')));
  }
  writer.println(""String_Node_Str"");
}","@Override public void visit(StepModel stepModel){
  writer.print(""String_Node_Str"");
  boolean firstWord=true;
  for (  Word word : stepModel.words) {
    if (!firstWord) {
      writer.print(' ');
    }
    String text=HtmlEscapers.htmlEscaper().escape(word.value);
    if (firstWord && word.isIntroWord) {
      writer.print(format(""String_Node_Str"",WordUtil.capitalize(text)));
    }
 else     if (word.isArg()) {
      printArg(word);
    }
 else {
      writer.print(text);
    }
    firstWord=false;
  }
  StepStatus status=stepModel.getStatus();
  if (status != StepStatus.PASSED) {
    String lowerCase=status.toString().toLowerCase();
    writer.print(format(""String_Node_Str"",WordUtil.camelCase(lowerCase),lowerCase.replace('_',' ')));
  }
  writer.println(""String_Node_Str"");
}",0.9772874756651524
29829,"@Override public void scenarioFailed(Throwable e){
  if (!currentScenarioCase.steps.isEmpty()) {
    currentScenarioCase.steps.get(currentScenarioCase.steps.size() - 1).setStatus(StepStatus.FAILED);
  }
  setSuccess(false);
  setErrorMessage(e.getMessage());
}","@Override public void scenarioFailed(Throwable e){
  setSuccess(false);
  setErrorMessage(e.getMessage());
}",0.5869565217391305
29830,"public boolean isStepMethod(Method paramMethod){
  if (!Modifier.isPublic(paramMethod.getModifiers()))   return false;
  return true;
}","public boolean isStepMethod(Method paramMethod){
  if (!Modifier.isPublic(paramMethod.getModifiers())) {
    return false;
  }
  return true;
}",0.9712230215827338
29831,"@Override public void stepMethodInvoked(Method paramMethod,List<Object> arguments,InvocationMode mode){
  if (!isStepMethod(paramMethod))   return;
  addStepMethod(paramMethod,arguments,mode);
}","@Override public void stepMethodInvoked(Method paramMethod,List<Object> arguments,InvocationMode mode){
  if (!isStepMethod(paramMethod)) {
    return;
  }
  addStepMethod(paramMethod,arguments,mode);
}",0.9797979797979798
29832,"@Override public Statement apply(final Statement base,final FrameworkMethod method,final Object target){
  return new Statement(){
    @Override public void evaluate() throws Throwable {
      starting(base,method,target);
      try {
        base.evaluate();
        succeeded();
      }
 catch (      AssumptionViolatedException e) {
        throw e;
      }
catch (      Throwable t) {
        failed(t);
      }
    }
  }
;
}","@Override public Statement apply(final Statement base,final FrameworkMethod method,final Object target){
  return new Statement(){
    @Override public void evaluate() throws Throwable {
      starting(base,method,target);
      try {
        base.evaluate();
        succeeded();
      }
 catch (      AssumptionViolatedException e) {
        throw e;
      }
catch (      Throwable t) {
        failed(t);
        throw t;
      }
    }
  }
;
}",0.9462857142857144
29833,"@Override public void evaluate() throws Throwable {
  starting(base,method,target);
  try {
    base.evaluate();
    succeeded();
  }
 catch (  AssumptionViolatedException e) {
    throw e;
  }
catch (  Throwable t) {
    failed(t);
  }
}","@Override public void evaluate() throws Throwable {
  starting(base,method,target);
  try {
    base.evaluate();
    succeeded();
  }
 catch (  AssumptionViolatedException e) {
    throw e;
  }
catch (  Throwable t) {
    failed(t);
    throw t;
  }
}",0.9611451942740288
29834,"private static List<TestScenario> setupTestScenarios(){
  List<TestScenario> result=Lists.newArrayList();
  addTestScenario(result,""String_Node_Str"").numberOfSteps(2).failingStep(1);
  addTestScenario(result,""String_Node_Str"").numberOfSteps(2).failingStep(2);
  addTestScenario(result,""String_Node_Str"").notImplementedYet().numberOfSteps(2).failingStep(1);
  addTestScenario(result,""String_Node_Str"").notImplementedYet();
  addTestScenario(result,""String_Node_Str"").notImplementedYet().failIfPassed();
  addTestScenario(result,""String_Node_Str"").notImplementedYet().failIfPassed().failingStep(1);
  addTestScenario(result,""String_Node_Str"").notImplementedYet().executeSteps().failingStep(1);
  addTestScenario(result,""String_Node_Str"").tagAnnotation();
  return result;
}","private static List<TestScenario> setupTestScenarios(){
  List<TestScenario> result=Lists.newArrayList();
  addTestScenario(result,""String_Node_Str"").numberOfSteps(2).failingStep(1);
  addTestScenario(result,""String_Node_Str"").numberOfSteps(3).failingStep(1);
  addTestScenario(result,""String_Node_Str"").numberOfSteps(2).failingStep(2);
  addTestScenario(result,""String_Node_Str"").notImplementedYet().numberOfSteps(2).failingStep(1);
  addTestScenario(result,""String_Node_Str"").notImplementedYet();
  addTestScenario(result,""String_Node_Str"").notImplementedYet().failIfPassed();
  addTestScenario(result,""String_Node_Str"").notImplementedYet().failIfPassed().failingStep(1);
  addTestScenario(result,""String_Node_Str"").notImplementedYet().executeSteps().failingStep(1);
  addTestScenario(result,""String_Node_Str"").tagAnnotation();
  return result;
}",0.9524397776405188
29835,"@Test public void steps_following_failing_steps_are_reported_as_skipped(){
  given().a_failing_test_with_$_steps(2).and().step_$_fails(1);
  when().the_test_is_executed_with_JUnit();
  then().step_$_is_reported_as_failed(1).and().step_$_is_reported_as_skipped(2);
}","@Test public void steps_following_failing_steps_are_reported_as_skipped(){
  given().a_failing_test_with_$_steps(3).and().step_$_fails(1);
  when().the_test_is_executed_with_JUnit();
  then().step_$_is_reported_as_failed(1).and().step_$_is_reported_as_skipped(2).and().step_$_is_reported_as_skipped(3);
}",0.9279437609841829
29836,"public DeutscheTestSchritte JGiven_verwendet_wird(){
  return self();
}","public DeutscheTestStufe JGiven_verwendet_wird(){
  return self();
}",0.9496402877697842
29837,"public DeutscheTestSchritte generiert_JGiven_deutsche_Berichte(){
  return self();
}","public DeutscheTestStufe generiert_JGiven_deutsche_Berichte(){
  return self();
}",0.9575757575757576
29838,"public DeutscheTestSchritte ein_deutsches_Projekt(){
  return self();
}","public DeutscheTestStufe ein_deutsches_Projekt(){
  return self();
}",0.9496402877697842
29839,"public DeutscheTestSchritte die_Szenarien_in_deutsch_geschrieben_werden(){
  return self();
}","public DeutscheTestStufe die_Szenarien_in_deutsch_geschrieben_werden(){
  return self();
}",0.9617486338797814
29840,"public void a_step_fails(){
  Assertions.assertThat(true).as(""String_Node_Str"").isFalse();
}","public void a_step_fails(){
  throw new AssertionError();
}",0.6225165562913907
29841,"@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  Word other=(Word)obj;
  return Objects.equal(isIntroWord,other.isIntroWord) && Objects.equal(value,other.value) && Objects.equal(argumentInfo,other.argumentInfo);
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  Word other=(Word)obj;
  return Objects.equal(isIntroWord,other.isIntroWord) && Objects.equal(value,other.value) && Objects.equal(argumentInfo,other.argumentInfo);
}",0.7790697674418605
29842,"@Override protected String wordToString(Word word){
  if (word.isArg()) {
    int argIndex=word.getArgumentInfo().getParameterIndex();
    if (argIndex < currentScenarioModel.parameterNames.size()) {
      return ""String_Node_Str"" + currentScenarioModel.parameterNames.get(argIndex) + ""String_Node_Str"";
    }
  }
  return super.wordToString(word);
}","@Override protected String wordToString(Word word){
  if (word.isArg() && word.getArgumentInfo().isCaseArg()) {
    int argIndex=word.getArgumentInfo().getParameterIndex();
    if (argIndex < currentScenarioModel.parameterNames.size()) {
      return ""String_Node_Str"" + currentScenarioModel.parameterNames.get(argIndex) + ""String_Node_Str"";
    }
  }
  return super.wordToString(word);
}",0.948509485094851
29843,"/** 
 * Has to be called when the scenario is finished in order to execute after methods
 */
public void finished() throws Throwable {
  if (state == FINISHED)   return;
  if (state != STARTED)   throw new IllegalStateException(""String_Node_Str"" + state);
  state=FINISHED;
  methodInterceptor.enableMethodHandling(false);
  Throwable lastThrownException=failedException;
  if (beforeStepsWereExecuted) {
    if (currentStage != null) {
      try {
        executeAfterStageMethods(currentStage);
      }
 catch (      AssertionError e) {
        log.error(e.getMessage(),e);
        lastThrownException=e;
      }
catch (      Exception e) {
        log.error(e.getMessage(),e);
        lastThrownException=e;
      }
    }
    for (    StageState stage : reverse(newArrayList(stages.values()))) {
      try {
        executeAnnotatedMethods(stage.instance,AfterScenario.class);
      }
 catch (      Exception e) {
        log.error(e.getMessage(),e);
        lastThrownException=e;
      }
    }
  }
  for (  Object rule : Lists.reverse(scenarioRules)) {
    try {
      invokeRuleMethod(rule,""String_Node_Str"");
    }
 catch (    Exception e) {
      log.error(e.getMessage(),e);
      lastThrownException=e;
    }
  }
  if (lastThrownException != null) {
    throw lastThrownException;
  }
  if (failIfPass) {
    throw new AssertionFailedError(""String_Node_Str"");
  }
}","/** 
 * Has to be called when the scenario is finished in order to execute after methods
 */
public void finished() throws Throwable {
  if (state == FINISHED)   return;
  if (state != STARTED)   throw new IllegalStateException(""String_Node_Str"" + state);
  state=FINISHED;
  methodInterceptor.enableMethodHandling(false);
  Throwable lastThrownException=failedException;
  if (beforeStepsWereExecuted) {
    if (currentStage != null) {
      try {
        executeAfterStageMethods(currentStage);
      }
 catch (      AssertionError e) {
        log.error(e.getMessage(),e);
        lastThrownException=e;
      }
catch (      Exception e) {
        log.error(e.getMessage(),e);
        lastThrownException=e;
      }
    }
    for (    StageState stage : reverse(newArrayList(stages.values()))) {
      try {
        executeAnnotatedMethods(stage.instance,AfterScenario.class);
      }
 catch (      Exception e) {
        log.error(e.getMessage(),e);
        lastThrownException=e;
      }
    }
  }
  for (  Object rule : Lists.reverse(scenarioRules)) {
    try {
      invokeRuleMethod(rule,""String_Node_Str"");
    }
 catch (    Exception e) {
      log.error(e.getMessage(),e);
      lastThrownException=e;
    }
  }
  if (lastThrownException != null) {
    throw lastThrownException;
  }
  if (failIfPass) {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.9868900218499636
29844,"public void setPrependType(boolean prependType){
  this.prependType=prependType;
}","public Tag setPrependType(boolean prependType){
  this.prependType=prependType;
  return this;
}",0.8764044943820225
29845,"/** 
 * Has to be called when the scenario is finished in order to execute after methods
 */
public void finished() throws Throwable {
  if (state == FINISHED)   return;
  if (state != STARTED)   throw new IllegalStateException(""String_Node_Str"" + state);
  state=FINISHED;
  Exception lastThrownException=null;
  if (beforeStepsWereExecuted) {
    for (    StageState stage : reverse(newArrayList(stages.values()))) {
      try {
        executeAnnotatedMethods(stage.instance,AfterScenario.class);
      }
 catch (      Exception e) {
        log.error(e.getMessage(),e);
        lastThrownException=e;
      }
    }
  }
  for (  Object rule : Lists.reverse(scenarioRules)) {
    try {
      invokeRuleMethod(rule,""String_Node_Str"");
    }
 catch (    Exception e) {
      log.error(e.getMessage(),e);
      lastThrownException=e;
    }
  }
  if (lastThrownException != null) {
    throw lastThrownException;
  }
}","/** 
 * Has to be called when the scenario is finished in order to execute after methods
 */
public void finished() throws Throwable {
  if (state == FINISHED)   return;
  if (state != STARTED)   throw new IllegalStateException(""String_Node_Str"" + state);
  state=FINISHED;
  Throwable lastThrownException=null;
  if (beforeStepsWereExecuted) {
    if (currentStage != null) {
      try {
        executeAfterStageMethods(currentStage);
      }
 catch (      AssertionError e) {
        log.error(e.getMessage(),e);
        lastThrownException=e;
      }
catch (      Exception e) {
        log.error(e.getMessage(),e);
        lastThrownException=e;
      }
    }
    for (    StageState stage : reverse(newArrayList(stages.values()))) {
      try {
        executeAnnotatedMethods(stage.instance,AfterScenario.class);
      }
 catch (      Exception e) {
        log.error(e.getMessage(),e);
        lastThrownException=e;
      }
    }
  }
  for (  Object rule : Lists.reverse(scenarioRules)) {
    try {
      invokeRuleMethod(rule,""String_Node_Str"");
    }
 catch (    Exception e) {
      log.error(e.getMessage(),e);
      lastThrownException=e;
    }
  }
  if (lastThrownException != null) {
    throw lastThrownException;
  }
}",0.820631970260223
29846,"public void after(){
  throw new IllegalStateException(""String_Node_Str"");
}","@AfterStage public void after(){
  throw new SomeExceptionInAfterStage();
}",0.6887417218543046
29847,"@Test public void given_steps_are_reported(){
  given().some_test_step();
  getScenario().finished();
  ScenarioModel model=getScenario().getModel().getLastScenarioModel();
  assertThat(model.className).isEqualTo(StepsAreReported.class.getName());
  assertThat(model.testMethodName).isEqualTo(""String_Node_Str"");
  assertThat(model.description).isEqualTo(""String_Node_Str"");
  assertThat(model.parameterNames).isEmpty();
  assertThat(model.tags).isEmpty();
  assertThat(model.getScenarioCases()).hasSize(1);
  ScenarioCaseModel scenarioCase=model.getCase(0);
  assertThat(scenarioCase.arguments).isEmpty();
  assertThat(scenarioCase.caseNr).isEqualTo(1);
  assertThat(scenarioCase.steps).hasSize(1);
  StepModel step=scenarioCase.steps.get(0);
  assertThat(step.name).isEqualTo(""String_Node_Str"");
  assertThat(step.words).isEqualTo(Arrays.asList(new Word(""String_Node_Str""),new Word(""String_Node_Str"")));
  assertThat(step.notImplementedYet).isFalse();
}","@Test public void given_steps_are_reported(){
  given().some_test_step();
  getScenario().finished();
  ScenarioModel model=getScenario().getModel().getLastScenarioModel();
  assertThat(model.className).isEqualTo(StepsAreReported.class.getName());
  assertThat(model.testMethodName).isEqualTo(""String_Node_Str"");
  assertThat(model.description).isEqualTo(""String_Node_Str"");
  assertThat(model.parameterNames).isEmpty();
  assertThat(model.tags).isEmpty();
  assertThat(model.getScenarioCases()).hasSize(1);
  ScenarioCaseModel scenarioCase=model.getCase(0);
  assertThat(scenarioCase.arguments).isEmpty();
  assertThat(scenarioCase.caseNr).isEqualTo(1);
  assertThat(scenarioCase.steps).hasSize(1);
  StepModel step=scenarioCase.steps.get(0);
  assertThat(step.name).isEqualTo(""String_Node_Str"");
  assertThat(step.words).isEqualTo(Arrays.asList(Word.introWord(""String_Node_Str""),new Word(""String_Node_Str"")));
  assertThat(step.notImplementedYet).isFalse();
}",0.9676409185803758
29848,"@Test public void printf_annotation_uses_the_PrintfFormatter(){
  scenario.startScenario(""String_Node_Str"");
  given().a_step_with_a_printf_annotation_$(5.2);
  scenario.finished();
  StepModel step=scenario.getModel().getFirstStepModelOfLastScenario();
  assertThat(step.words.get(2).value).isEqualTo(""String_Node_Str"");
}","@Test public void printf_annotation_uses_the_PrintfFormatter(){
  scenario.startScenario(""String_Node_Str"");
  given().a_step_with_a_printf_annotation_$(5.2);
  scenario.finished();
  StepModel step=scenario.getModel().getFirstStepModelOfLastScenario();
  assertThat(step.words.get(2).value).isEqualTo(String.format(""String_Node_Str"",5.2));
}",0.9714285714285714
29849,"@Override public String format(T argumentToFormat,final String... formatterArguments){
  if (argumentToFormat == null) {
    return ""String_Node_Str"";
  }
  if (argumentToFormat.getClass().isArray()) {
    return Joiner.on(""String_Node_Str"").join(Iterables.transform(Arrays.asList((Object[])argumentToFormat),new Function<Object,String>(){
      @Override public String apply(      Object input){
        return new DefaultFormatter<Object>().format(input,formatterArguments);
      }
    }
));
  }
  return String.valueOf(argumentToFormat);
}","@Override public String format(T argumentToFormat,final String... formatterArguments){
  if (argumentToFormat == null) {
    return ""String_Node_Str"";
  }
  Class<? extends Object> clazz=argumentToFormat.getClass();
  if (clazz.isArray()) {
    DefaultFormatter<Object> defaultFormatter=new DefaultFormatter<Object>();
    StringBuilder sb=new StringBuilder();
    for (int i=0; i < Array.getLength(argumentToFormat); i++) {
      if (i > 0) {
        sb.append(""String_Node_Str"");
      }
      sb.append(defaultFormatter.format(Array.get(argumentToFormat,i)));
    }
    return sb.toString();
  }
  return String.valueOf(argumentToFormat);
}",0.3827993254637437
29850,"private void writeIndexFile(HtmlTocWriter tocWriter){
  File file=new File(toDir,""String_Node_Str"");
  PrintWriter printWriter=HtmlWriter.getPrintWriter(file);
  try {
    HtmlWriter htmlWriter=new HtmlWriter(printWriter);
    htmlWriter.writeHtmlHeader(""String_Node_Str"");
    tocWriter.writeToc(printWriter);
    ReportModel reportModel=new ReportModel();
    reportModel.className=""String_Node_Str"";
    htmlWriter.visit(reportModel);
    for (    Tag tag : tocWriter.getSortedTags()) {
      printWriter.println(ScenarioHtmlWriter.tagToHtml(tag));
    }
    htmlWriter.visitEnd(reportModel);
    htmlWriter.writeHtmlFooter();
  }
  finally {
    ResourceUtil.close(printWriter);
  }
}","private void writeIndexFile(HtmlTocWriter tocWriter){
  File file=new File(toDir,""String_Node_Str"");
  PrintWriter printWriter=HtmlWriter.getPrintWriter(file);
  try {
    HtmlWriter htmlWriter=new HtmlWriter(printWriter);
    htmlWriter.writeHtmlHeader(""String_Node_Str"");
    ReportModel reportModel=new ReportModel();
    reportModel.className=""String_Node_Str"";
    htmlWriter.writeHeader(reportModel);
    tocWriter.writeToc(printWriter);
    htmlWriter.visit(reportModel);
    for (    Tag tag : tocWriter.getSortedTags()) {
      printWriter.println(ScenarioHtmlWriter.tagToHtml(tag));
    }
    htmlWriter.visitEnd(reportModel);
    htmlWriter.writeHtmlFooter();
  }
  finally {
    ResourceUtil.close(printWriter);
  }
}",0.9188426252646436
29851,"public void writeHtmlFooter(){
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
}","public void writeHtmlFooter(){
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
}",0.8867313915857605
29852,"public void write(ReportModel model,HtmlTocWriter htmlTocWriter){
  writeHtmlHeader(model.className);
  if (htmlTocWriter != null) {
    htmlTocWriter.writeToc(writer);
  }
  model.accept(this);
  writeHtmlFooter();
}","public void write(ReportModel model,HtmlTocWriter htmlTocWriter){
  writeHtmlHeader(model.className);
  writeHeader(model);
  if (htmlTocWriter != null) {
    htmlTocWriter.writeToc(writer);
  }
  model.accept(this);
  writeHtmlFooter();
}",0.9517543859649122
29853,"/** 
 * Starts the scenario with the given method and arguments. Derives the description from the method name.
 * @param method the method that started the scenario
 * @param arguments the arguments of the method invocation
 */
public void startScenario(Method method,List<?> arguments){
  listener.scenarioStarted(method,arguments);
}","/** 
 * Starts the scenario with the given method and arguments. Derives the description from the method name.
 * @param method the method that started the scenario
 * @param arguments the arguments of the method invocation
 */
public void startScenario(Method method,List<?> arguments){
  listener.scenarioStarted(method,arguments);
  if (method.isAnnotationPresent(NotImplementedYet.class)) {
    methodInterceptor.disableMethodExecution();
  }
}",0.855683269476373
29854,"@SuppressWarnings(""String_Node_Str"") public <T>T addStage(Class<T> stepsClass){
  if (stages.containsKey(stepsClass))   return (T)stages.get(stepsClass).instance;
  Enhancer e=new Enhancer();
  e.setSuperclass(stepsClass);
  StepMethodInterceptor callback=new StepMethodInterceptor(new MethodHandler(),stackDepth);
  e.setCallback(callback);
  T result=(T)e.create();
  callback.enable();
  stages.put(stepsClass,new StageState(result));
  gatherRules(result);
  injectSteps(result);
  return result;
}","@SuppressWarnings(""String_Node_Str"") public <T>T addStage(Class<T> stepsClass){
  if (stages.containsKey(stepsClass))   return (T)stages.get(stepsClass).instance;
  Enhancer e=new Enhancer();
  e.setSuperclass(stepsClass);
  e.setCallback(methodInterceptor);
  T result=(T)e.create();
  methodInterceptor.enableMethodHandling();
  stages.put(stepsClass,new StageState(result));
  gatherRules(result);
  injectSteps(result);
  return result;
}",0.6779661016949152
29855,"@Override public Object intercept(Object receiver,Method method,Object[] parameters,MethodProxy methodProxy) throws Throwable {
  if (enabled && stackDepth.get() == 0 && !method.getDeclaringClass().equals(Object.class)) {
    scenarioMethodHandler.handleMethod(receiver,method,parameters);
  }
  if (method.isAnnotationPresent(NotImplementedYet.class) || receiver.getClass().isAnnotationPresent(NotImplementedYet.class)) {
    if (!method.getReturnType().isAssignableFrom(receiver.getClass())) {
      log.warn(""String_Node_Str"" + method.getName() + ""String_Node_Str""+ method.getDeclaringClass().getSimpleName()+ ""String_Node_Str""+ ""String_Node_Str"");
      return null;
    }
    return receiver;
  }
  try {
    stackDepth.incrementAndGet();
    return methodProxy.invokeSuper(receiver,parameters);
  }
 catch (  Throwable t) {
    scenarioMethodHandler.handleThrowable(t);
    throw t;
  }
 finally {
    stackDepth.decrementAndGet();
  }
}","@Override public Object intercept(Object receiver,Method method,Object[] parameters,MethodProxy methodProxy) throws Throwable {
  if (methodHandlingEnabled && stackDepth.get() == 0 && !method.getDeclaringClass().equals(Object.class)) {
    scenarioMethodHandler.handleMethod(receiver,method,parameters);
  }
  if (!methodExecutionEnabled || method.isAnnotationPresent(NotImplementedYet.class) || receiver.getClass().isAnnotationPresent(NotImplementedYet.class)) {
    if (!method.getReturnType().isAssignableFrom(receiver.getClass())) {
      log.warn(""String_Node_Str"" + method.getName() + ""String_Node_Str""+ method.getDeclaringClass().getSimpleName()+ ""String_Node_Str""+ ""String_Node_Str"");
      return null;
    }
    return receiver;
  }
  try {
    stackDepth.incrementAndGet();
    return methodProxy.invokeSuper(receiver,parameters);
  }
 catch (  Throwable t) {
    scenarioMethodHandler.handleThrowable(t);
    throw t;
  }
 finally {
    stackDepth.decrementAndGet();
  }
}",0.9247535028541776
29856,"public abstract void handleReportModel(ReportModel model,File file);","@Override public abstract void handleReportModel(ReportModel model,File file);",0.9315068493150684
29857,"public void generate(File toDir,String targetFileName,File sourceDir) throws IOException {
  if (!toDir.isDirectory())   throw new RuntimeException(toDir + ""String_Node_Str"");
  log.info(""String_Node_Str"" + targetFileName + ""String_Node_Str""+ toDir);
  this.toDir=toDir;
  writer=new PrintWriter(new File(toDir,targetFileName),Charsets.UTF_8.name());
  utils=new HtmlWriterUtils(writer);
  try {
    writeStart();
    for (    ReportModelFile f : Files.fileTreeTraverser().breadthFirstTraversal(sourceDir).filter(FilePredicates.endsWith(""String_Node_Str"")).transform(new TestCaseFileReader())) {
      handleReportModel(f.model,f.file);
    }
    writeEnd();
  }
  finally {
    ResourceUtil.close(writer);
  }
  copyFileToTargetDir(""String_Node_Str"");
  copyFileToTargetDir(""String_Node_Str"");
}","public void generate(File toDir,String targetFileName,File sourceDir) throws IOException {
  if (!toDir.isDirectory())   throw new RuntimeException(toDir + ""String_Node_Str"");
  log.info(""String_Node_Str"" + targetFileName + ""String_Node_Str""+ toDir);
  this.toDir=toDir;
  writer=new PrintWriter(new File(toDir,targetFileName),Charsets.UTF_8.name());
  utils=new HtmlWriterUtils(writer);
  try {
    writeStart();
    new JsonModelTraverser().traverseModels(sourceDir,this);
    writeEnd();
  }
  finally {
    ResourceUtil.close(writer);
  }
  copyFileToTargetDir(""String_Node_Str"");
  copyFileToTargetDir(""String_Node_Str"");
}",0.824438202247191
29858,"@Override public int compare(ModelFile o1,ModelFile o2){
  return o1.model.getSimpleClassName().compareTo(o2.model.getSimpleClassName());
}","@Override public int compare(Tag o1,Tag o2){
  return o1.toString().compareTo(o2.toString());
}",0.6581196581196581
29859,"@Override public void handleReportModel(ReportModel model,File file){
  String targetFileName=Files.getNameWithoutExtension(file.getName()) + ""String_Node_Str"";
  File targetFile=new File(toDir,targetFileName);
  log.debug(""String_Node_Str"" + targetFile);
  try {
    HtmlFileWriter.writeModelToFile(model,targetFile);
    ModelFile modelFile=new ModelFile();
    modelFile.model=model;
    modelFile.file=targetFile;
    models.add(modelFile);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + file + ""String_Node_Str""+ e);
    throw Throwables.propagate(e);
  }
}","@Override public void handleReportModel(ReportModel model,File file){
  String targetFileName=Files.getNameWithoutExtension(file.getName()) + ""String_Node_Str"";
  File targetFile=new File(toDir,targetFileName);
  log.debug(""String_Node_Str"" + targetFile);
  try {
    HtmlFileWriter.writeModelToFile(model,targetFile);
    ModelFile modelFile=new ModelFile();
    modelFile.model=model;
    modelFile.file=targetFile;
    models.add(modelFile);
    for (    ScenarioModel scenario : model.scenarios) {
      for (      Tag tag : scenario.tags) {
        addToMap(tag,scenario);
      }
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + file + ""String_Node_Str""+ e);
    throw Throwables.propagate(e);
  }
}",0.8871834228702993
29860,"@Override public void writeEnd(){
  Comparator<ModelFile> comparator=new Comparator<ModelFile>(){
    @Override public int compare(    ModelFile o1,    ModelFile o2){
      return o1.model.getSimpleClassName().compareTo(o2.model.getSimpleClassName());
    }
  }
;
  Collections.sort(models,comparator);
  for (  ModelFile modelFile : models) {
    writeFileLink(modelFile);
  }
}","@Override public void writeEnd(){
  Comparator<ModelFile> comparator=new Comparator<ModelFile>(){
    @Override public int compare(    ModelFile o1,    ModelFile o2){
      return o1.model.getSimpleClassName().compareTo(o2.model.getSimpleClassName());
    }
  }
;
  Collections.sort(models,comparator);
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  for (  ModelFile modelFile : models) {
    writeFileLink(modelFile);
  }
  writer.println(""String_Node_Str"");
  writeTagFiles();
}",0.8536036036036037
29861,"private static PrintWriter getPrintWriter(File file){
  try {
    return new PrintWriter(file);
  }
 catch (  FileNotFoundException e) {
    throw Throwables.propagate(e);
  }
}","private static PrintWriter getPrintWriter(File file){
  try {
    return new PrintWriter(file,Charsets.UTF_8.name());
  }
 catch (  FileNotFoundException e) {
    throw Throwables.propagate(e);
  }
catch (  UnsupportedEncodingException e) {
    throw Throwables.propagate(e);
  }
}",0.7685589519650655
29862,"public static void writeModelToFile(ReportModel model,File file){
  PrintWriter printWriter=getPrintWriter(file);
  try {
    HtmlWriter htmlWriter=new HtmlWriter(printWriter);
    htmlWriter.writeHtmlHeader(model.className);
    htmlWriter.write(model);
    htmlWriter.writeHtmlFooter();
  }
  finally {
    ResourceUtil.close(printWriter);
  }
}","public static void writeModelToFile(ReportModel model,File file){
  PrintWriter printWriter=getPrintWriter(file);
  try {
    HtmlWriter htmlWriter=new HtmlWriter(printWriter);
    htmlWriter.write(model);
  }
  finally {
    ResourceUtil.close(printWriter);
  }
}",0.690671031096563
29863,"public void generate() throws IOException {
  if (!toDir.exists() && !toDir.mkdirs()) {
    log.error(""String_Node_Str"" + toDir);
    return;
  }
  if (frames) {
    new FrameBasedHtmlReportGenerator().generate(toDir,sourceDir);
  }
 else {
    new FrameBasedHtmlReportGenerator().generate(toDir,sourceDir);
    new SingleFileHtmlReportGenerator().generate(toDir,""String_Node_Str"",sourceDir);
  }
  if (customCssFile != null) {
    if (!customCssFile.canRead()) {
      log.info(""String_Node_Str"" + customCssFile + ""String_Node_Str"");
    }
 else {
      Files.copy(customCssFile,new File(toDir,""String_Node_Str""));
    }
  }
}","public void generate() throws IOException {
  if (!toDir.exists() && !toDir.mkdirs()) {
    log.error(""String_Node_Str"" + toDir);
    return;
  }
  new FrameBasedHtmlReportGenerator().generate(toDir,sourceDir);
  new SingleFileHtmlReportGenerator().generate(toDir,""String_Node_Str"",sourceDir);
  if (customCssFile != null) {
    if (!customCssFile.canRead()) {
      log.info(""String_Node_Str"" + customCssFile + ""String_Node_Str"");
    }
 else {
      Files.copy(customCssFile,new File(toDir,""String_Node_Str""));
    }
  }
}",0.8618592528236316
29864,"@Test @TestTag({""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) public void annotations_are_translated_to_tags(){
  given().some_test_step();
  getScenario().finished();
  ScenarioModel model=getScenario().getModel().getLastScenarioModel();
  assertThat(model.tags).hasSize(1);
  assertThat(model.tags.get(0).getName()).isEqualTo(""String_Node_Str"");
  assertThat(model.tags.get(0).getValue()).isEqualTo(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
}","@Test @TestTag({""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) public void annotations_are_translated_to_tags(){
  given().some_test_step();
  getScenario().finished();
  ScenarioModel model=getScenario().getModel().getLastScenarioModel();
  assertThat(model.tags).hasSize(1);
  assertThat(model.getTags().get(0).getName()).isEqualTo(""String_Node_Str"");
  assertThat(model.getTags().get(0).getValue()).isEqualTo(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
}",0.973305954825462
29865,"@Test @TestTag({""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) @UseDataProvider(""String_Node_Str"") public void annotations_are_translated_to_tags_only_once(int n){
  given().some_test_step();
  getScenario().finished();
  ScenarioModel model=getScenario().getModel().getLastScenarioModel();
  assertThat(model.tags).hasSize(1);
  assertThat(model.tags.get(0).getName()).isEqualTo(""String_Node_Str"");
  assertThat(model.tags.get(0).getValue()).isEqualTo(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
}","@Test @TestTag({""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) @UseDataProvider(""String_Node_Str"") public void annotations_are_translated_to_tags_only_once(int n){
  given().some_test_step();
  getScenario().finished();
  ScenarioModel model=getScenario().getModel().getLastScenarioModel();
  assertThat(model.tags).hasSize(1);
  assertThat(model.getTags().get(0).getName()).isEqualTo(""String_Node_Str"");
  assertThat(model.getTags().get(0).getValue()).isEqualTo(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
}",0.9758364312267658
29866,"@Override public void execute(){
  m_logger.info(""String_Node_Str"",m_appDef.getAppName());
  Date now=new Date();
  OLAPService olap=OLAPService.instance();
  List<String> shards=olap.listShards(m_appDef);
  for (  String shardName : shards) {
    Date expirationDate=olap.getExpirationDate(m_appDef,shardName);
    if (expirationDate != null && expirationDate.before(now)) {
      olap.deleteShard(m_appDef,shardName);
      m_logger.info(""String_Node_Str"",shardName,m_appDef.getAppName());
    }
  }
}","@Override public void execute(){
  m_logger.info(""String_Node_Str"",m_appDef.getAppName());
  Date now=new Date();
  OLAPService olap=OLAPService.instance();
  List<String> shards=olap.listShards(m_appDef);
  for (  String shardName : shards) {
    Date expirationDate=olap.getExpirationDate(m_appDef,shardName);
    m_logger.debug(""String_Node_Str"",shardName,expirationDate);
    if (expirationDate != null && expirationDate.before(now)) {
      olap.deleteShard(m_appDef,shardName);
      m_logger.info(""String_Node_Str"",shardName,m_appDef.getAppName());
    }
  }
}",0.9401869158878504
29867,"private void attemptToExecuteTask(ApplicationDefinition appDef,Task task,TaskRecord taskRecord){
  Tenant tenant=Tenant.getTenant(appDef);
  String taskID=taskRecord.getTaskID();
  String claimID=""String_Node_Str"" + taskID;
  long claimStamp=System.currentTimeMillis();
  writeTaskClaim(tenant,claimID,claimStamp);
  if (taskClaimedByUs(tenant,claimID)) {
    startTask(appDef,task,taskRecord);
  }
}","private void attemptToExecuteTask(ApplicationDefinition appDef,Task task,TaskRecord taskRecord){
  Tenant tenant=Tenant.getTenant(appDef);
  String taskID=taskRecord.getTaskID();
  String claimID=""String_Node_Str"" + taskID;
  long claimStamp=System.currentTimeMillis();
  writeTaskClaim(tenant,claimID,claimStamp);
  if (taskClaimedByUs(tenant,claimID)) {
    startTask(appDef,task,taskRecord);
  }
 else {
    m_logger.info(""String_Node_Str"");
  }
}",0.9411764705882352
29868,"private boolean taskClaimedByUs(Tenant tenant,String claimID){
  waitForClaim();
  Iterator<DColumn> colIter=DBService.instance(tenant).getAllColumns(TaskManagerService.TASKS_STORE_NAME,claimID).iterator();
  if (colIter == null) {
    m_logger.warn(""String_Node_Str"",claimID);
    return false;
  }
  String claimingHost=m_hostClaimID;
  long earliestClaim=Long.MAX_VALUE;
  while (colIter.hasNext()) {
    DColumn col=colIter.next();
    try {
      long claimStamp=Long.parseLong(col.getValue());
      String claimHost=col.getName();
      if (claimStamp < earliestClaim) {
        claimingHost=claimHost;
        earliestClaim=claimStamp;
      }
 else       if (claimStamp == earliestClaim) {
        if (claimHost.compareTo(claimingHost) < 0) {
          claimingHost=claimHost;
        }
      }
    }
 catch (    NumberFormatException e) {
    }
  }
  return claimingHost.equals(m_hostClaimID) && !m_bShutdown;
}","private boolean taskClaimedByUs(Tenant tenant,String claimID){
  waitForClaim();
  Iterator<DColumn> colIter=DBService.instance(tenant).getAllColumns(TaskManagerService.TASKS_STORE_NAME,claimID).iterator();
  if (colIter == null) {
    m_logger.warn(""String_Node_Str"",claimID);
    return false;
  }
  String claimingHost=m_hostClaimID;
  long earliestClaim=Long.MAX_VALUE;
  while (colIter.hasNext()) {
    DColumn col=colIter.next();
    try {
      long claimStamp=Long.parseLong(col.getValue());
      long secondsSinceClaim=(System.currentTimeMillis() - claimStamp) / 1000;
      if (secondsSinceClaim > 600)       continue;
      String claimHost=col.getName();
      if (claimStamp < earliestClaim) {
        claimingHost=claimHost;
        earliestClaim=claimStamp;
      }
 else       if (claimStamp == earliestClaim) {
        if (claimHost.compareTo(claimingHost) < 0) {
          claimingHost=claimHost;
        }
      }
    }
 catch (    NumberFormatException e) {
    }
  }
  return claimingHost.equals(m_hostClaimID) && !m_bShutdown;
}",0.934077079107505
29869,"/** 
 * Apply aall updates in the given   {@link DBTransaction} to our DynamoDB instance.
 * @param dbTran {@link DBTransaction} with updates.
 */
public void commit(DBTransaction dbTran){
  try {
    applyUpdates(dbTran);
  }
 catch (  Exception e) {
    if (e instanceof AmazonServiceException) {
      String rawMessage=((AmazonServiceException)e).getRawResponseContent();
      m_logger.error(""String_Node_Str"",e,rawMessage);
    }
 else {
      m_logger.error(""String_Node_Str"",e);
    }
    throw e;
  }
 finally {
    dbTran.clear();
  }
}","/** 
 * Apply aall updates in the given   {@link DBTransaction} to our DynamoDB instance.
 * @param dbTran {@link DBTransaction} with updates.
 */
public void commit(DBTransaction dbTran){
  try {
    applyUpdates(dbTran);
  }
 catch (  Exception e) {
    m_logger.error(""String_Node_Str"",e);
    throw e;
  }
 finally {
    dbTran.clear();
  }
}",0.6748878923766816
29870,"@Override public void initializeApplication(ApplicationDefinition oldAppDef,ApplicationDefinition appDef){
  checkServiceState();
  m_olap.createApplication(appDef.getAppName());
}","@Override public void initializeApplication(ApplicationDefinition oldAppDef,ApplicationDefinition appDef){
  checkServiceState();
  Tenant tenant=Tenant.getTenant(appDef);
  m_olap.createApplication(tenant,appDef.getAppName());
}",0.8801955990220048
29871,"private DBService createDefaultDBService(){
  String dbServiceName=ServerParams.instance().getModuleParamString(""String_Node_Str"",""String_Node_Str"");
  if (Utils.isEmpty(dbServiceName)) {
    throw new RuntimeException(""String_Node_Str"");
  }
  DBService dbservice=null;
  Tenant defaultTenant=TenantService.instance().getDefaultTenant();
  boolean bDBOpened=false;
  while (!bDBOpened) {
    try {
      @SuppressWarnings(""String_Node_Str"") Class<DBService> serviceClass=(Class<DBService>)Class.forName(dbServiceName);
      Constructor<DBService> constructor=serviceClass.getConstructor(Tenant.class);
      dbservice=constructor.newInstance(defaultTenant);
      dbservice.initialize();
      dbservice.start();
      bDBOpened=true;
    }
 catch (    IllegalArgumentException e) {
      throw new RuntimeException(""String_Node_Str"" + dbServiceName,e);
    }
catch (    ClassNotFoundException e) {
      throw new RuntimeException(""String_Node_Str"" + dbServiceName + ""String_Node_Str"",e);
    }
catch (    NoSuchMethodException e) {
      throw new RuntimeException(""String_Node_Str"" + dbServiceName,e);
    }
catch (    SecurityException|InstantiationException|IllegalAccessException|InvocationTargetException e) {
      throw new RuntimeException(""String_Node_Str"" + dbServiceName,e);
    }
catch (    DBNotAvailableException e) {
      m_logger.info(""String_Node_Str"");
      try {
        Thread.sleep(db_connect_retry_wait_millis);
      }
 catch (      InterruptedException ex2) {
      }
    }
catch (    Throwable e) {
      throw new RuntimeException(""String_Node_Str"" + dbServiceName,e);
    }
  }
  return dbservice;
}","private DBService createDefaultDBService(){
  String dbServiceName=ServerParams.instance().getModuleParamString(""String_Node_Str"",""String_Node_Str"");
  if (Utils.isEmpty(dbServiceName)) {
    throw new RuntimeException(""String_Node_Str"");
  }
  DBService dbservice=null;
  Tenant defaultTenant=TenantService.instance().getDefaultTenant();
  boolean bDBOpened=false;
  while (!bDBOpened) {
    try {
      @SuppressWarnings(""String_Node_Str"") Class<DBService> serviceClass=(Class<DBService>)Class.forName(dbServiceName);
      Constructor<DBService> constructor=serviceClass.getConstructor(Tenant.class);
      dbservice=constructor.newInstance(defaultTenant);
      dbservice.initialize();
      dbservice.start();
      bDBOpened=true;
    }
 catch (    IllegalArgumentException e) {
      throw new RuntimeException(""String_Node_Str"" + dbServiceName,e);
    }
catch (    ClassNotFoundException e) {
      throw new RuntimeException(""String_Node_Str"" + dbServiceName + ""String_Node_Str"",e);
    }
catch (    NoSuchMethodException e) {
      throw new RuntimeException(""String_Node_Str"" + dbServiceName,e);
    }
catch (    SecurityException|InstantiationException|IllegalAccessException e) {
      throw new RuntimeException(""String_Node_Str"" + dbServiceName,e);
    }
catch (    InvocationTargetException e) {
      if (!(e.getTargetException() instanceof DBNotAvailableException)) {
        throw new RuntimeException(""String_Node_Str"" + dbServiceName,e);
      }
    }
catch (    DBNotAvailableException e) {
    }
catch (    Throwable e) {
      throw new RuntimeException(""String_Node_Str"" + dbServiceName,e);
    }
    if (!bDBOpened) {
      m_logger.info(""String_Node_Str"");
      try {
        Thread.sleep(db_connect_retry_wait_millis);
      }
 catch (      InterruptedException ex2) {
      }
    }
  }
  return dbservice;
}",0.7368117613144999
29872,"/** 
 * Add the given list of DBObjects to the builder.
 * @param list dbObjectList  New list of {@link DBObject}.
 * @return          This {@link Builder}.
 */
public Builder withObjects(List<DBObject> dbObjectList){
  for (  DBObject dbObject : dbObjectList) {
    dbObjectBatch.addObject(dbObject);
  }
  return this;
}","/** 
 * Add the given list of DBObjects to the builder.
 * @param dbObjectList dbObjectList  New list of {@link DBObject}.
 * @return             This {@link Builder}.
 */
public Builder withObjects(List<DBObject> dbObjectList){
  for (  DBObject dbObject : dbObjectList) {
    dbObjectBatch.addObject(dbObject);
  }
  return this;
}",0.9801526717557252
29873,"/** 
 * Get the value of the parameter with the given name belonging to this service as a boolean. If the parameter is not found, false is returned.
 * @param paramName Name of parameter to find.
 * @return          Parameter value found or false if not found.
 */
public boolean getParamBoolean(String paramName){
  Object paramValue=getParam(paramName);
  if (paramValue == null) {
    return false;
  }
  return Boolean.parseBoolean(paramValue.toString());
}","/** 
 * Get the value of the parameter with the given name belonging to this service as a boolean. If the parameter is not found, defaultValue is returned.
 * @param paramName Name of parameter to find.
 * @return          Parameter value found or defaultValue if not found.
 */
public boolean getParamBoolean(String paramName,boolean defaultValue){
  Object paramValue=getParam(paramName);
  if (paramValue == null) {
    return defaultValue;
  }
  return Boolean.parseBoolean(paramValue.toString());
}",0.925311203319502
29874,"void onNewrequest(){
  m_webservice.notifyNewRequest();
}","void onNewrequest(){
  if (m_webservice != null) {
    m_webservice.notifyNewRequest();
  }
}",0.76
29875,"void onRequestSuccess(long startTimeNanos){
  m_webservice.notifyRequestSuccess(startTimeNanos);
}","void onRequestSuccess(long startTimeNanos){
  if (m_webservice != null) {
    m_webservice.notifyRequestSuccess(startTimeNanos);
  }
}",0.8448275862068966
29876,"void onRequestFailed(Throwable e){
  m_webservice.notifyRequestFailed(e);
}","void onRequestFailed(Throwable e){
  if (m_webservice != null) {
    m_webservice.notifyRequestFailed(e);
  }
}",0.8064516129032258
29877,"void onRequestRejected(String reason){
  m_webservice.notifyRequestRejected(reason);
}","void onRequestRejected(String reason){
  if (m_webservice != null) {
    m_webservice.notifyRequestRejected(reason);
  }
}",0.8269230769230769
29878,"private void createApplication(){
  String schema=getSchema();
  ContentType contentType=null;
  if (m_config.schema.toLowerCase().endsWith(""String_Node_Str"")) {
    contentType=ContentType.APPLICATION_JSON;
  }
 else   if (m_config.schema.toLowerCase().endsWith(""String_Node_Str"")) {
    contentType=ContentType.TEXT_XML;
  }
 else {
    logErrorThrow(""String_Node_Str"",m_config.schema);
  }
  try {
    m_logger.info(""String_Node_Str"",m_config.app,m_config.schema);
    m_client.createApplication(schema,contentType);
  }
 catch (  Exception e) {
    logErrorThrow(""String_Node_Str"",e);
  }
  try {
    m_session=m_client.openApplication(m_config.app);
  }
 catch (  RuntimeException e) {
    logErrorThrow(""String_Node_Str"",m_config.app);
  }
  String ss=m_session.getAppDef().getStorageService();
  if (!Utils.isEmpty(ss) && ss.equals(""String_Node_Str"")) {
    m_bOLAPApp=true;
  }
  loadTables();
}","private void createApplication(){
  String schema=getSchema();
  ContentType contentType=null;
  if (m_config.schema.toLowerCase().endsWith(""String_Node_Str"")) {
    contentType=ContentType.APPLICATION_JSON;
  }
 else   if (m_config.schema.toLowerCase().endsWith(""String_Node_Str"")) {
    contentType=ContentType.TEXT_XML;
  }
 else {
    logErrorThrow(""String_Node_Str"",m_config.schema);
  }
  try {
    m_logger.info(""String_Node_Str"",m_config.app,m_config.schema);
    m_client.createApplication(schema,contentType);
  }
 catch (  Exception e) {
    logErrorThrow(""String_Node_Str"",e);
  }
  try {
    m_session=m_client.openApplication(m_config.app);
  }
 catch (  RuntimeException e) {
    logErrorThrow(""String_Node_Str"",m_config.app,e.toString());
  }
  String ss=m_session.getAppDef().getStorageService();
  if (!Utils.isEmpty(ss) && ss.startsWith(""String_Node_Str"")) {
    m_bOLAPApp=true;
  }
  loadTables();
}",0.984092155787164
29879,"/** 
 * Make a copy of this object with the same updates and values but with a new object ID.
 * @param objID   Object IF of new object.
 * @return          Copy of this object except for the object ID.
 */
public DBObject makeCopy(String objID){
  DBObject newObj=new DBObject();
  newObj.m_valueMap.putAll(m_valueMap);
  newObj.m_valueRemoveMap.putAll(m_valueRemoveMap);
  return newObj;
}","/** 
 * Make a copy of this object with the same updates and values but with a new object ID.
 * @param objID   Object IF of new object.
 * @return          Copy of this object except for the object ID.
 */
public DBObject makeCopy(String objID){
  DBObject newObj=new DBObject();
  newObj.m_valueMap.putAll(m_valueMap);
  newObj.setObjectID(objID);
  newObj.m_valueRemoveMap.putAll(m_valueRemoveMap);
  return newObj;
}",0.8360049321824907
29880,"private boolean storeExists(String keyspace,String tableName){
  KeyspaceMetadata ksMetadata=m_cluster.getMetadata().getKeyspace(keyspace);
  return (ksMetadata != null) && (ksMetadata.getTable(tableName) != null);
}","private boolean storeExists(String cqlKeyspace,String tableName){
}",0.4452296819787986
29881,"/** 
 * Get the   {@link PreparedStatement} for the given {@link CQLStatementCache.Update} tothe given table name, residing in the given keyspace. If needed, the update statement is compiled and cached.
 * @param keyspace      Keyspace name.
 * @param update        Update statement type.
 * @param tableName     Quoted table name.
 * @return              PreparedStatement for requested keyspace/table/update.
 */
public PreparedStatement getPreparedUpdate(String keyspace,Update update,String tableName){
}","/** 
 * Get the   {@link PreparedStatement} for the given {@link CQLStatementCache.Update} tothe given table name, residing in the given keyspace. If needed, the update statement is compiled and cached.
 * @param keyspace      Keyspace name.
 * @param update        Update statement type.
 * @param storeName     Store (ColumnFamily) name.
 * @return              PreparedStatement for requested keyspace/table/update.
 */
public PreparedStatement getPreparedUpdate(String keyspace,Update update,String storeName){
}",0.953125
29882,"@Override public Iterator<DColumn> getColumnSlice(Tenant tenant,String storeName,String rowKey,String startCol,String endCol){
  checkState();
  String keyspace=tenant.getKeyspace();
  String tableName=storeToCQLName(storeName);
  return new CQLColumnIterator(executeQuery(Query.SELECT_1_ROW_COLUMN_RANGE,keyspace,tableName,rowKey,startCol,endCol));
}","@Override public Iterator<DColumn> getColumnSlice(Tenant tenant,String storeName,String rowKey,String startCol,String endCol){
  checkState();
  String keyspace=storeToCQLName(tenant.getKeyspace());
  String tableName=storeToCQLName(storeName);
  return new CQLColumnIterator(executeQuery(Query.SELECT_1_ROW_COLUMN_RANGE,keyspace,tableName,rowKey,startCol,endCol));
}",0.977715877437326
29883,"/** 
 * Get the   {@link PreparedStatement} for the given {@link CQLStatementCache.Query} tothe given table name, residing in the given keyspace. If needed, the query statement is compiled and cached.
 * @param keyspace      Keyspace name.
 * @param query         Query statement type.
 * @param tableName     Quoted table name.
 * @return              PreparedStatement for requested keyspace/table/update.
 */
public PreparedStatement getPreparedQuery(String keyspace,Query query,String tableName){
}","/** 
 * Get the   {@link PreparedStatement} for the given {@link CQLStatementCache.Query} tothe given table name, residing in the given keyspace. If needed, the query statement is compiled and cached.
 * @param keyspace      Keyspace name.
 * @param query         Query statement type.
 * @param storeName     Store (ColumnFamily) name.
 * @return              PreparedStatement for requested keyspace/table/update.
 */
public PreparedStatement getPreparedQuery(String keyspace,Query query,String storeName){
}",0.9525691699604744
29884,"@Override public DColumn getColumn(Tenant tenant,String storeName,String rowKey,String colName){
  checkState();
  String keyspace=tenant.getKeyspace();
  String tableName=storeToCQLName(storeName);
  CQLColumnIterator colIter=new CQLColumnIterator(executeQuery(Query.SELECT_1_ROW_1_COLUMN,keyspace,tableName,rowKey,colName));
  if (!colIter.hasNext()) {
    return null;
  }
  return colIter.next();
}","@Override public DColumn getColumn(Tenant tenant,String storeName,String rowKey,String colName){
  checkState();
  String keyspace=storeToCQLName(tenant.getKeyspace());
  String tableName=storeToCQLName(storeName);
  CQLColumnIterator colIter=new CQLColumnIterator(executeQuery(Query.SELECT_1_ROW_1_COLUMN,keyspace,tableName,rowKey,colName));
  if (!colIter.hasNext()) {
    return null;
  }
  return colIter.next();
}",0.9804878048780488
29885,"@Override public Iterator<DRow> getRowsColumns(Tenant tenant,String storeName,Collection<String> rowKeys,Collection<String> colNames){
  checkState();
  String keyspace=tenant.getKeyspace();
  String tableName=storeToCQLName(storeName);
  return new CQLRowIterator(executeQuery(Query.SELECT_ROW_SET_COLUMN_SET,keyspace,tableName,new ArrayList<String>(rowKeys),new ArrayList<String>(colNames)));
}","@Override public Iterator<DRow> getRowsColumns(Tenant tenant,String storeName,Collection<String> rowKeys,Collection<String> colNames){
  checkState();
  String keyspace=storeToCQLName(tenant.getKeyspace());
  String tableName=storeToCQLName(storeName);
  return new CQLRowIterator(executeQuery(Query.SELECT_ROW_SET_COLUMN_SET,keyspace,tableName,new ArrayList<String>(rowKeys),new ArrayList<String>(colNames)));
}",0.9801980198019802
29886,"@Override public void dropTenant(Tenant tenant){
  String cqlKeyspace=storeToCQLName(tenant.getKeyspace());
synchronized (m_ksSessionMap) {
    Session session=m_ksSessionMap.get(cqlKeyspace);
    if (session != null) {
      session.close();
      m_ksSessionMap.remove(cqlKeyspace);
      m_ksStatementCacheMap.remove(cqlKeyspace);
    }
    try (Session noKSSession=m_cluster.connect()){
      CQLSchemaManager schemaMgr=new CQLSchemaManager(noKSSession,null);
      schemaMgr.dropKeyspace(cqlKeyspace);
    }
   }
}","@Override public void dropTenant(Tenant tenant){
  checkState();
  String cqlKeyspace=storeToCQLName(tenant.getKeyspace());
synchronized (m_ksSessionMap) {
    Session session=m_ksSessionMap.get(cqlKeyspace);
    if (session != null) {
      session.close();
      m_ksSessionMap.remove(cqlKeyspace);
      m_ksStatementCacheMap.remove(cqlKeyspace);
    }
    try (Session noKSSession=m_cluster.connect()){
      CQLSchemaManager schemaMgr=new CQLSchemaManager(noKSSession,null);
      schemaMgr.dropKeyspace(cqlKeyspace);
    }
   }
}",0.9848197343453512
29887,"@Override public Collection<Tenant> getTenants(){
  checkState();
  List<Tenant> tenants=new ArrayList<>();
  try (Session session=m_cluster.connect()){
    List<KeyspaceMetadata> keyspaceList=m_cluster.getMetadata().getKeyspaces();
    for (    KeyspaceMetadata ksMetadata : keyspaceList) {
      if (ksMetadata.getTable(SchemaService.APPS_STORE_NAME) != null) {
        tenants.add(new Tenant(ksMetadata.getName()));
      }
    }
  }
   return tenants;
}","@Override public Collection<Tenant> getTenants(){
  checkState();
  List<Tenant> tenants=new ArrayList<>();
  try (Session session=m_cluster.connect()){
    List<KeyspaceMetadata> keyspaceList=m_cluster.getMetadata().getKeyspaces();
    for (    KeyspaceMetadata ksMetadata : keyspaceList) {
      if (ksMetadata.getTable(APPS_CQL_NAME) != null) {
        tenants.add(new Tenant(ksMetadata.getName()));
      }
    }
  }
   return tenants;
}",0.975501113585746
29888,"/** 
 * Return true if column values for the given keyspace/table name are binary.
 * @param keyspace  Quoted keyspace name.
 * @param tableName Quoted columnfamily name.
 * @return          True if the given table's column values are binary.
 */
public boolean columnValueIsBinary(String keyspace,String tableName){
}","/** 
 * Return true if column values for the given keyspace/table name are binary.
 * @param keyspace  Keyspace name.
 * @param storeName Store (ColumnFamily) name.
 * @return          True if the given table's column values are binary.
 */
public boolean columnValueIsBinary(String keyspace,String storeName){
  String cqlKeyspace=storeToCQLName(keyspace);
  String tableName=storeToCQLName(storeName);
  KeyspaceMetadata ksMetadata=m_cluster.getMetadata().getKeyspace(cqlKeyspace);
  TableMetadata tableMetadata=ksMetadata.getTable(tableName);
  ColumnMetadata colMetadata=tableMetadata.getColumn(""String_Node_Str"");
  return colMetadata.getType().equals(DataType.blob());
}",0.5573440643863179
29889,"@Override public Iterator<DRow> getAllRowsAllColumns(Tenant tenant,String storeName){
  checkState();
  String keyspace=tenant.getKeyspace();
  String tableName=storeToCQLName(storeName);
  return new CQLRowIterator(executeQuery(Query.SELECT_ALL_ROWS_ALL_COLUMNS,keyspace,tableName));
}","@Override public Iterator<DRow> getAllRowsAllColumns(Tenant tenant,String storeName){
  checkState();
  String keyspace=storeToCQLName(tenant.getKeyspace());
  String tableName=storeToCQLName(storeName);
  return new CQLRowIterator(executeQuery(Query.SELECT_ALL_ROWS_ALL_COLUMNS,keyspace,tableName));
}",0.9727891156462584
29890,"@Override public void createTenant(Tenant tenant){
  String cqlKeyspace=storeToCQLName(tenant.getKeyspace());
  KeyspaceMetadata ksMetadata=m_cluster.getMetadata().getKeyspace(cqlKeyspace);
  if (ksMetadata == null) {
    try (Session session=m_cluster.connect()){
      CQLSchemaManager schemaMgr=new CQLSchemaManager(session,null);
      schemaMgr.createKeyspace(cqlKeyspace);
    }
   }
}","@Override public void createTenant(Tenant tenant){
  checkState();
  String cqlKeyspace=storeToCQLName(tenant.getKeyspace());
  KeyspaceMetadata ksMetadata=m_cluster.getMetadata().getKeyspace(cqlKeyspace);
  if (ksMetadata == null) {
    try (Session session=m_cluster.connect()){
      CQLSchemaManager schemaMgr=new CQLSchemaManager(session,null);
      schemaMgr.createKeyspace(cqlKeyspace);
    }
   }
}",0.9799498746867168
29891,"private ResultSet executeQuery(Query query,String cqlKeyspace,String tableName,Object... values){
  m_logger.debug(""String_Node_Str"",new Object[]{query,cqlKeyspace,tableName,values.length});
  Session session=getOrCreateKeyspaceSession(cqlKeyspace);
  PreparedStatement prepState=getPreparedQuery(cqlKeyspace,query,tableName);
  BoundStatement boundState=prepState.bind(values);
  return session.execute(boundState);
}","private ResultSet executeQuery(Query query,String cqlKeyspace,String tableName,Object... values){
}",0.3829787234042553
29892,"private Session getOrCreateKeyspaceSession(String keyspace){
  String cqlKeyspace=storeToCQLName(keyspace);
  Session session=m_ksSessionMap.get(cqlKeyspace);
  if (session == null) {
synchronized (m_ksSessionMap) {
      session=m_ksSessionMap.get(cqlKeyspace);
      if (session == null) {
        session=m_cluster.connect(cqlKeyspace);
        m_ksSessionMap.put(cqlKeyspace,session);
        m_ksStatementCacheMap.put(cqlKeyspace,new CQLStatementCache(session));
      }
    }
  }
  return session;
}","private Session getOrCreateKeyspaceSession(String cqlKeyspace){
}",0.2280701754385964
29893,"@Override public Iterator<DColumn> getAllColumns(Tenant tenant,String storeName,String rowKey){
  checkState();
  String keyspace=tenant.getKeyspace();
  String tableName=storeToCQLName(storeName);
  return new CQLColumnIterator(executeQuery(Query.SELECT_1_ROW_ALL_COLUMNS,keyspace,tableName,rowKey));
}","@Override public Iterator<DColumn> getAllColumns(Tenant tenant,String storeName,String rowKey){
  checkState();
  String keyspace=storeToCQLName(tenant.getKeyspace());
  String tableName=storeToCQLName(storeName);
  return new CQLColumnIterator(executeQuery(Query.SELECT_1_ROW_ALL_COLUMNS,keyspace,tableName,rowKey));
}",0.9742765273311896
29894,"@Override public Iterator<DRow> getRowsAllColumns(Tenant tenant,String storeName,Collection<String> rowKeys){
  checkState();
  String keyspace=tenant.getKeyspace();
  String tableName=storeToCQLName(storeName);
  return new CQLRowIterator(executeQuery(Query.SELECT_ROW_SET_ALL_COLUMNS,keyspace,tableName,new ArrayList<String>(rowKeys)));
}","@Override public Iterator<DRow> getRowsAllColumns(Tenant tenant,String storeName,Collection<String> rowKeys){
  checkState();
  String keyspace=storeToCQLName(tenant.getKeyspace());
  String tableName=storeToCQLName(storeName);
  return new CQLRowIterator(executeQuery(Query.SELECT_ROW_SET_ALL_COLUMNS,keyspace,tableName,new ArrayList<String>(rowKeys)));
}",0.9770114942528736
29895,"/** 
 * Get the CQL session being used by this CQL service.
 * @param keyspace Keyspace to which session applies.
 * @return         The CQL Session object connected to the appropriate keyspace.
 */
public Session getSession(String keyspace){
  return getOrCreateKeyspaceSession(keyspace);
}","/** 
 * Get the CQL session being used by this CQL service.
 * @param keyspace Keyspace to which session applies.
 * @return         The CQL Session object connected to the appropriate keyspace.
 */
public Session getSession(String keyspace){
  String cqlKeyspace=storeToCQLName(keyspace);
  return getOrCreateKeyspaceSession(cqlKeyspace);
}",0.8417721518987342
29896,"@Override public Iterator<DRow> getRowsColumnSlice(Tenant tenant,String storeName,Collection<String> rowKeys,String startCol,String endCol){
  checkState();
  String keyspace=tenant.getKeyspace();
  String tableName=storeToCQLName(storeName);
  return new CQLRowIterator(executeQuery(Query.SELECT_ROW_SET_COLUMN_RANGE,keyspace,tableName,new ArrayList<String>(rowKeys),startCol,endCol));
}","@Override public Iterator<DRow> getRowsColumnSlice(Tenant tenant,String storeName,Collection<String> rowKeys,String startCol,String endCol){
  checkState();
  String keyspace=storeToCQLName(tenant.getKeyspace());
  String tableName=storeToCQLName(storeName);
  return new CQLRowIterator(executeQuery(Query.SELECT_ROW_SET_COLUMN_RANGE,keyspace,tableName,new ArrayList<String>(rowKeys),startCol,endCol));
}",0.9797979797979798
29897,"/** 
 * Start a new CQLTransaction.
 */
public CQLTransaction(Tenant tenant){
  m_keyspace=tenant.getKeyspace();
  m_session=CQLService.instance().getSession(m_keyspace);
}","/** 
 * Start a new CQLTransaction.
 */
public CQLTransaction(Tenant tenant){
  m_keyspace=CQLService.storeToCQLName(tenant.getKeyspace());
  m_session=CQLService.instance().getSession(m_keyspace);
}",0.9272237196765498
29898,"/** 
 * Update the schema for this session's application with the given definition. The text must be formatted in XML or JSON, as defined by the given content type. True is returned if the update was successful. An exception is thrown if an error occurred.
 * @param text          Text of updated schema definition.
 * @param contentType   Format of text. Must be {@link ContentType#APPLICATION_JSON} or{@link ContentType#TEXT_XML}.
 * @return              True if the schema update was successful.
 */
public boolean updateSchema(String text,ContentType contentType){
  Utils.require(text != null && text.length() > 0,""String_Node_Str"");
  Utils.require(contentType != null,""String_Node_Str"");
  try {
    byte[] body=Utils.toBytes(text);
    String uri=uriRoot() + ""String_Node_Str"" + Utils.urlEncode(m_appDef.getAppName());
    RESTResponse response=m_restClient.sendRequest(HttpMethod.PUT,uri,ContentType.APPLICATION_JSON,body);
    m_logger.debug(""String_Node_Str"",response.toString());
    throwIfErrorResponse(response);
    return true;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Update the schema for this session's application with the given definition. The text must be formatted in XML or JSON, as defined by the given content type. True is returned if the update was successful. An exception is thrown if an error occurred.
 * @param text          Text of updated schema definition.
 * @param contentType   Format of text. Must be {@link ContentType#APPLICATION_JSON} or{@link ContentType#TEXT_XML}.
 * @return              True if the schema update was successful.
 */
public boolean updateSchema(String text,ContentType contentType){
  Utils.require(text != null && text.length() > 0,""String_Node_Str"");
  Utils.require(contentType != null,""String_Node_Str"");
  try {
    byte[] body=Utils.toBytes(text);
    StringBuilder uri=new StringBuilder(""String_Node_Str"");
    uri.append(Utils.urlEncode(m_appDef.getAppName()));
    addTenantParam(uri);
    RESTResponse response=m_restClient.sendRequest(HttpMethod.PUT,uri.toString(),ContentType.APPLICATION_JSON,body);
    m_logger.debug(""String_Node_Str"",response.toString());
    throwIfErrorResponse(response);
    return true;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9585695595290014
29899,"/** 
 * Refresh this session's application schema from the database. Since the application's   {@link ApplicationDefinition} is cached, it could be out of dateif the schema has been modified. This method fetches the latest version and returns it. An exception is thrown if the application has been deleted or any other error occurs.
 * @return  Latest version of this session's application as an{@link ApplicationDefinition}, which is also cahced.
 * @see #getAppDef()
 */
public ApplicationDefinition refreshSchema(){
  try {
    String uri=uriRoot() + ""String_Node_Str"" + Utils.urlEncode(m_appDef.getAppName());
    RESTResponse response=m_restClient.sendRequest(HttpMethod.GET,uri);
    m_logger.debug(""String_Node_Str"",response.toString());
    throwIfErrorResponse(response);
    m_appDef.parse(getUNodeResult(response));
    return m_appDef;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Refresh this session's application schema from the database. Since the application's   {@link ApplicationDefinition} is cached, it could be out of dateif the schema has been modified. This method fetches the latest version and returns it. An exception is thrown if the application has been deleted or any other error occurs.
 * @return  Latest version of this session's application as an{@link ApplicationDefinition}, which is also cahced.
 * @see #getAppDef()
 */
public ApplicationDefinition refreshSchema(){
  try {
    StringBuilder uri=new StringBuilder(""String_Node_Str"");
    uri.append(Utils.urlEncode(m_appDef.getAppName()));
    addTenantParam(uri);
    RESTResponse response=m_restClient.sendRequest(HttpMethod.GET,uri.toString());
    m_logger.debug(""String_Node_Str"",response.toString());
    throwIfErrorResponse(response);
    m_appDef.parse(getUNodeResult(response));
    return m_appDef;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9499736703528172
29900,"/** 
 * Get the   {@link ApplicationDefinition} for the given application name. If theconnected Doradus server has no such application defined, null is returned.
 * @param appName   Application name.
 * @return          Application's {@link ApplicationDefinition}, if it exists, otherwise null.
 */
public ApplicationDefinition getAppDef(String appName){
  Utils.require(!m_restClient.isClosed(),""String_Node_Str"");
  Utils.require(appName != null && appName.length() > 0,""String_Node_Str"");
  try {
    String uri=uriRoot() + ""String_Node_Str"" + Utils.urlEncode(appName);
    RESTResponse response=m_restClient.sendRequest(HttpMethod.GET,uri);
    m_logger.debug(""String_Node_Str"",response.toString());
    if (response.getCode() == HttpCode.NOT_FOUND) {
      return null;
    }
    throwIfErrorResponse(response);
    ApplicationDefinition appDef=new ApplicationDefinition();
    appDef.parse(UNode.parse(response.getBody(),response.getContentType()));
    return appDef;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Get the   {@link ApplicationDefinition} for the given application name. If theconnected Doradus server has no such application defined, null is returned.
 * @param appName   Application name.
 * @return          Application's {@link ApplicationDefinition}, if it exists, otherwise null.
 */
public ApplicationDefinition getAppDef(String appName){
  Utils.require(!m_restClient.isClosed(),""String_Node_Str"");
  Utils.require(appName != null && appName.length() > 0,""String_Node_Str"");
  try {
    StringBuilder uri=new StringBuilder(""String_Node_Str"");
    uri.append(Utils.urlEncode(appName));
    addTenantParam(uri);
    RESTResponse response=m_restClient.sendRequest(HttpMethod.GET,uri.toString());
    m_logger.debug(""String_Node_Str"",response.toString());
    if (response.getCode() == HttpCode.NOT_FOUND) {
      return null;
    }
    throwIfErrorResponse(response);
    ApplicationDefinition appDef=new ApplicationDefinition();
    appDef.parse(UNode.parse(response.getBody(),response.getContentType()));
    return appDef;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9558755225267068
29901,"/** 
 * Get the   {@link ApplicationDefinition} for all applications defined in the tenantidentified by this client's credentials.
 * @return  A collection of all applications defined in the database, possible empty.
 */
public Collection<ApplicationDefinition> getAllAppDefs(){
  Utils.require(!m_restClient.isClosed(),""String_Node_Str"");
  try {
    String uri=uriRoot() + ""String_Node_Str"";
    RESTResponse response=m_restClient.sendRequest(HttpMethod.GET,uri);
    m_logger.debug(""String_Node_Str"",response.toString());
    throwIfErrorResponse(response);
    UNode rootNode=UNode.parse(response.getBody(),response.getContentType());
    List<ApplicationDefinition> appDefList=new ArrayList<ApplicationDefinition>();
    for (    UNode appNode : rootNode.getMemberList()) {
      ApplicationDefinition appDef=new ApplicationDefinition();
      appDef.parse(appNode);
      appDefList.add(appDef);
    }
    return appDefList;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Get the   {@link ApplicationDefinition} for all applications defined in the tenantidentified by this client's credentials.
 * @return  A collection of all applications defined in the database, possible empty.
 */
public Collection<ApplicationDefinition> getAllAppDefs(){
  Utils.require(!m_restClient.isClosed(),""String_Node_Str"");
  try {
    StringBuilder uri=new StringBuilder(""String_Node_Str"");
    addTenantParam(uri);
    RESTResponse response=m_restClient.sendRequest(HttpMethod.GET,uri.toString());
    m_logger.debug(""String_Node_Str"",response.toString());
    throwIfErrorResponse(response);
    UNode rootNode=UNode.parse(response.getBody(),response.getContentType());
    List<ApplicationDefinition> appDefList=new ArrayList<ApplicationDefinition>();
    for (    UNode appNode : rootNode.getMemberList()) {
      ApplicationDefinition appDef=new ApplicationDefinition();
      appDef.parse(appNode);
      appDefList.add(appDef);
    }
    return appDefList;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9639024390243902
29902,"/** 
 * Delete an existing application from the current Doradus tenant, including all of its tables and data. Because updates are idempotent, deleting an already-deleted application is acceptable. Hence, if no error is thrown, the result is always true. An exception is thrown if an error occurs.
 * @param appName   Name of existing application to delete.
 * @param key       Name of key of application to delete. Can be null if theapplication has no key.
 * @return          True if the application was deleted or already deleted.
 */
public boolean deleteApplication(String appName,String key){
  Utils.require(!m_restClient.isClosed(),""String_Node_Str"");
  Utils.require(appName != null && appName.length() > 0,""String_Node_Str"");
  Utils.require(key != null && key.length() > 0,""String_Node_Str"");
  try {
    String uri=uriRoot() + ""String_Node_Str"" + Utils.urlEncode(appName)+ ""String_Node_Str""+ Utils.urlEncode(key);
    RESTResponse response=m_restClient.sendRequest(HttpMethod.DELETE,uri);
    m_logger.debug(""String_Node_Str"",response.toString());
    if (response.getCode() != HttpCode.NOT_FOUND) {
      throwIfErrorResponse(response);
    }
    return true;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Delete an existing application from the current Doradus tenant, including all of its tables and data. Because updates are idempotent, deleting an already-deleted application is acceptable. Hence, if no error is thrown, the result is always true. An exception is thrown if an error occurs.
 * @param appName   Name of existing application to delete.
 * @param key       Name of key of application to delete. Can be null if theapplication has no key.
 * @return          True if the application was deleted or already deleted.
 */
public boolean deleteApplication(String appName,String key){
  Utils.require(!m_restClient.isClosed(),""String_Node_Str"");
  Utils.require(appName != null && appName.length() > 0,""String_Node_Str"");
  Utils.require(key != null && key.length() > 0,""String_Node_Str"");
  try {
    StringBuilder uri=new StringBuilder(""String_Node_Str"");
    uri.append(Utils.urlEncode(appName));
    uri.append(""String_Node_Str"");
    uri.append(Utils.urlEncode(key));
    addTenantParam(uri);
    RESTResponse response=m_restClient.sendRequest(HttpMethod.DELETE,uri.toString());
    m_logger.debug(""String_Node_Str"",response.toString());
    if (response.getCode() != HttpCode.NOT_FOUND) {
      throwIfErrorResponse(response);
    }
    return true;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9476541295075612
29903,"/** 
 * Delete the OLAP shard with the given name belonging to this session's application. True is returned if the delete was successful. An exception is thrown if an error occurred.
 * @param shard     Shard name.
 * @return          True if the shard was successfully deleted.
 */
public boolean deleteShard(String shard){
  Utils.require(!Utils.isEmpty(shard),""String_Node_Str"");
  try {
    String uri=uriRoot() + Utils.urlEncode(m_appDef.getAppName()) + ""String_Node_Str""+ Utils.urlEncode(shard);
    RESTResponse response=m_restClient.sendRequest(HttpMethod.DELETE,uri);
    m_logger.debug(""String_Node_Str"",response.toString());
    throwIfErrorResponse(response);
    return true;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Delete the OLAP shard with the given name belonging to this session's application. True is returned if the delete was successful. An exception is thrown if an error occurred.
 * @param shard     Shard name.
 * @return          True if the shard was successfully deleted.
 */
public boolean deleteShard(String shard){
  Utils.require(!Utils.isEmpty(shard),""String_Node_Str"");
  try {
    StringBuilder uri=new StringBuilder(""String_Node_Str"");
    uri.append(Utils.urlEncode(m_appDef.getAppName()));
    uri.append(""String_Node_Str"");
    uri.append(Utils.urlEncode(shard));
    addTenantParam(uri);
    RESTResponse response=m_restClient.sendRequest(HttpMethod.DELETE,uri.toString());
    m_logger.debug(""String_Node_Str"",response.toString());
    throwIfErrorResponse(response);
    return true;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9080882352941176
29904,"/** 
 * Perform an object query for the given table and query parameters. The table must belong to this session's OLAP application. Recognized query parameters are: <table> <tr><td>Name</td><td>Value</td><td>Description</td></tr> <tr><td>q</td> <td>query expression</td> <td>Required. Query expression that selects objects in the table. ""*"" selects all objects.</td> </tr> <tr><td>f</td> <td>field list</td> <td>Comma-separated list of fields to return in the query.</td> </tr> <tr><td>s</td> <td>integer</td> <td>Number of objects to return in the page. Defaults to the value configured for the server. 0 means ""all objects"".</td> </tr> <tr><td>o</td> <td>field [ASC|DESC]</td> <td>Order the results by the given scalar field name, optionally followed by ASC (ascending, the default) or DESC (descending).</td> </tr> <tr><td>k</td> <td>integer</td> <td>Skip the given number of objects, thereby returning a secondary page of results.</td> </tr> <tr><td>shards</td> <td>shard list</td> <td>Comma-separated list of shards to query. Either this or the ""range"" parameter must be provided, but not both.</td> </tr> <tr><td>range</td> <td><i>shard-from</i>[,<i>shard-to</i>]</td> <td>Defines a range of shards to query beginning with shards whose name is greater than or equal to the <i>shard-from</i> name. If a <i>shard-to</i> name is given, shard names must also be less than or equal to that name. Either this or the ""shards"" parameter must be provided, but not both.</td> </tr> </table> If the ""k"" is not given, the first page of the query is returned. Results are returned in a   {@link QueryResult} object. An exception is thrown if a parameter isinvalid or a database error occurs.
 * @param tableName Name of table to query. 
 * @param params    Names and values of query parameters. 
 * @return          {@link QueryResult} containing results.
 */
@Override public QueryResult objectQuery(String tableName,Map<String,String> params){
  Utils.require(tableName != null,""String_Node_Str"");
  Utils.require(params != null,""String_Node_Str"");
  TableDefinition tableDef=m_appDef.getTableDef(tableName);
  Utils.require(tableDef != null,""String_Node_Str"",tableName);
  StringBuilder uri=new StringBuilder();
  uri.append(uriRoot());
  uri.append(Utils.urlEncode(tableDef.getAppDef().getAppName()));
  uri.append(""String_Node_Str"");
  uri.append(Utils.urlEncode(tableDef.getTableName()));
  uri.append(""String_Node_Str"");
  Utils.require(params.containsKey(""String_Node_Str""),""String_Node_Str"");
  uri.append(""String_Node_Str"");
  uri.append(Utils.urlEncode(params.get(""String_Node_Str"")));
  for (  String name : params.keySet()) {
    String value=params.get(name);
switch (name) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
      uri.append(""String_Node_Str"");
    uri.append(name);
  uri.append(""String_Node_Str"");
uri.append(Utils.urlEncode(value));
break;
case ""String_Node_Str"":
break;
default :
Utils.require(false,""String_Node_Str"",name);
}
}
try {
RESTResponse response=m_restClient.sendRequest(HttpMethod.GET,uri.toString());
m_logger.debug(""String_Node_Str"",response.toString());
QueryResult result=null;
if (response.getCode() != HttpCode.OK) {
result=new QueryResult(tableDef,response.getBody());
}
 else {
result=new QueryResult(tableDef,getUNodeResult(response));
}
return result;
}
 catch (Exception e) {
throw new RuntimeException(e);
}
}","/** 
 * Perform an object query for the given table and query parameters. The table must belong to this session's OLAP application. Recognized query parameters are: <table> <tr><td>Name</td><td>Value</td><td>Description</td></tr> <tr><td>q</td> <td>query expression</td> <td>Required. Query expression that selects objects in the table. ""*"" selects all objects.</td> </tr> <tr><td>f</td> <td>field list</td> <td>Comma-separated list of fields to return in the query.</td> </tr> <tr><td>s</td> <td>integer</td> <td>Number of objects to return in the page. Defaults to the value configured for the server. 0 means ""all objects"".</td> </tr> <tr><td>o</td> <td>field [ASC|DESC]</td> <td>Order the results by the given scalar field name, optionally followed by ASC (ascending, the default) or DESC (descending).</td> </tr> <tr><td>k</td> <td>integer</td> <td>Skip the given number of objects, thereby returning a secondary page of results.</td> </tr> <tr><td>shards</td> <td>shard list</td> <td>Comma-separated list of shards to query. Either this or the ""range"" parameter must be provided, but not both.</td> </tr> <tr><td>range</td> <td><i>shard-from</i>[,<i>shard-to</i>]</td> <td>Defines a range of shards to query beginning with shards whose name is greater than or equal to the <i>shard-from</i> name. If a <i>shard-to</i> name is given, shard names must also be less than or equal to that name. Either this or the ""shards"" parameter must be provided, but not both.</td> </tr> </table> If the ""k"" is not given, the first page of the query is returned. Results are returned in a   {@link QueryResult} object. An exception is thrown if a parameter isinvalid or a database error occurs.
 * @param tableName Name of table to query. 
 * @param params    Names and values of query parameters. 
 * @return          {@link QueryResult} containing results.
 */
@Override public QueryResult objectQuery(String tableName,Map<String,String> params){
  Utils.require(tableName != null,""String_Node_Str"");
  Utils.require(params != null,""String_Node_Str"");
  TableDefinition tableDef=m_appDef.getTableDef(tableName);
  Utils.require(tableDef != null,""String_Node_Str"",tableName);
  StringBuilder uri=new StringBuilder(""String_Node_Str"");
  uri.append(Utils.urlEncode(tableDef.getAppDef().getAppName()));
  uri.append(""String_Node_Str"");
  uri.append(Utils.urlEncode(tableDef.getTableName()));
  uri.append(""String_Node_Str"");
  Utils.require(params.containsKey(""String_Node_Str""),""String_Node_Str"");
  uri.append(""String_Node_Str"");
  uri.append(Utils.urlEncode(params.get(""String_Node_Str"")));
  for (  String name : params.keySet()) {
    String value=params.get(name);
switch (name) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
      uri.append(""String_Node_Str"");
    uri.append(name);
  uri.append(""String_Node_Str"");
uri.append(Utils.urlEncode(value));
break;
case ""String_Node_Str"":
break;
default :
Utils.require(false,""String_Node_Str"",name);
}
}
addTenantParam(uri);
try {
RESTResponse response=m_restClient.sendRequest(HttpMethod.GET,uri.toString());
m_logger.debug(""String_Node_Str"",response.toString());
QueryResult result=null;
if (response.getCode() != HttpCode.OK) {
result=new QueryResult(tableDef,response.getBody());
}
 else {
result=new QueryResult(tableDef,getUNodeResult(response));
}
return result;
}
 catch (Exception e) {
throw new RuntimeException(e);
}
}",0.9909025270758124
29905,"/** 
 * Perform an aggregate query for the given table and query parameters. The table must belong to this session's application. Query parameters are specific to the storage service managing the application. Common parameters are: <table> <tr><td>Name</td><td>Value</td><td>Description</td></tr> <tr><td>m</td> <td>metric list</td> <td>Required. Comma-separated list of metric expression(s) to compute.</td> </tr> <tr><td>q</td> <td>query expression</td> <td>Optional. Query expression that selects objects in the table. Default is ""*"", which selects all objects.</td> </tr> <tr><td>f</td> <td>grouping parameter</td> <td>Optional. Comma-separated list of grouping field expressions. When present, creates a grouped aggregate query instead of a global aggregate query.</td> </tr> <tr><td>pair</td> <td>pair list</td> <td>Optiona. A comma-separated of pair of link paths that define a special <i>dual role</i> query. See OLAP documentation about the operation of this special query type.</td> </tr> <tr><td>shards</td> <td>shard list</td> <td>Comma-separated list of shards to query. Either this or the ""range"" parameter must be provided, but not both.</td> </tr> <tr><td>range</td> <td><i>shard-from</i>[,<i>shard-to</i>]</td> <td>Defines a range of shards to query beginning with shards whose name is greater than or equal to the <i>shard-from</i> name. If a <i>shard-to</i> name is given, shard names must also be less than or equal to that name. Either this or the ""shards"" parameter must be provided, but not both.</td> </tr> <tr><td>xshards</td> <td>shard list</td> <td>Comma-separated list of shards that define the search scope of xlinks. This parameter is only meaningful when the aggregate query uses xlinks. Either this or the ""xrange"" parameter can be provided, but not both. If neither ""xshards"" nor ""xrange"" is specified, the search scope of xlinks is defined by the ""shards"" or ""range"" parameter.</td> </tr> <tr><td>xrange</td> <td><i>shard-from</i>[,<i>shard-to</i>]</td> <td>Defines a range of shards to query for xlink values beginning with shards whose name is greater than or equal to the <i>shard-from</i> name. If a <i>shard-to</i> name is given, shard names must also be less than or equal to that name. Either this or the ""xshards"" parameter can be provided, but not both. If neither ""xshards"" nor ""xrange"" is specified, the search scope of xlinks is defined by the ""shards"" or ""range"" parameter.</td> </tr> </table> Results are turned in the given   {@link AggregateResult} object. An exception is thrownif a parameter is invalid or a database error occurs.
 * @param tableName Name of table to query.
 * @param params    Names and values of aggregate query parameters. 
 * @return          {@link AggregateResult} containing results.
 */
@Override public AggregateResult aggregateQuery(String tableName,Map<String,String> params){
  Utils.require(!Utils.isEmpty(tableName),""String_Node_Str"");
  Utils.require(params != null && params.size() > 0,""String_Node_Str"");
  TableDefinition tableDef=m_appDef.getTableDef(tableName);
  Utils.require(tableDef != null,""String_Node_Str"",m_appDef.getAppName(),tableName);
  StringBuilder uri=new StringBuilder();
  uri.append(uriRoot());
  uri.append(Utils.urlEncode(m_appDef.getAppName()));
  uri.append(""String_Node_Str"");
  uri.append(Utils.urlEncode(tableDef.getTableName()));
  uri.append(""String_Node_Str"");
  Utils.require(params.containsKey(""String_Node_Str""),""String_Node_Str"");
  uri.append(""String_Node_Str"");
  uri.append(Utils.urlEncode(params.get(""String_Node_Str"")));
  for (  String name : params.keySet()) {
    String value=params.get(name);
switch (name) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
      uri.append(""String_Node_Str"");
    uri.append(name);
  uri.append(""String_Node_Str"");
uri.append(Utils.urlEncode(value));
break;
case ""String_Node_Str"":
break;
default :
Utils.require(false,""String_Node_Str"",name);
}
}
try {
RESTResponse response=m_restClient.sendRequest(HttpMethod.GET,uri.toString());
m_logger.debug(""String_Node_Str"",response.toString());
AggregateResult result=new AggregateResult();
if (response.getCode() != HttpCode.OK) {
result.setErrorMessage(response.getBody());
}
 else {
result.parse(UNode.parse(response.getBody(),response.getContentType()));
}
return result;
}
 catch (Exception e) {
throw new RuntimeException(e);
}
}","/** 
 * Perform an aggregate query for the given table and query parameters. The table must belong to this session's application. Query parameters are specific to the storage service managing the application. Common parameters are: <table> <tr><td>Name</td><td>Value</td><td>Description</td></tr> <tr><td>m</td> <td>metric list</td> <td>Required. Comma-separated list of metric expression(s) to compute.</td> </tr> <tr><td>q</td> <td>query expression</td> <td>Optional. Query expression that selects objects in the table. Default is ""*"", which selects all objects.</td> </tr> <tr><td>f</td> <td>grouping parameter</td> <td>Optional. Comma-separated list of grouping field expressions. When present, creates a grouped aggregate query instead of a global aggregate query.</td> </tr> <tr><td>pair</td> <td>pair list</td> <td>Optiona. A comma-separated of pair of link paths that define a special <i>dual role</i> query. See OLAP documentation about the operation of this special query type.</td> </tr> <tr><td>shards</td> <td>shard list</td> <td>Comma-separated list of shards to query. Either this or the ""range"" parameter must be provided, but not both.</td> </tr> <tr><td>range</td> <td><i>shard-from</i>[,<i>shard-to</i>]</td> <td>Defines a range of shards to query beginning with shards whose name is greater than or equal to the <i>shard-from</i> name. If a <i>shard-to</i> name is given, shard names must also be less than or equal to that name. Either this or the ""shards"" parameter must be provided, but not both.</td> </tr> <tr><td>xshards</td> <td>shard list</td> <td>Comma-separated list of shards that define the search scope of xlinks. This parameter is only meaningful when the aggregate query uses xlinks. Either this or the ""xrange"" parameter can be provided, but not both. If neither ""xshards"" nor ""xrange"" is specified, the search scope of xlinks is defined by the ""shards"" or ""range"" parameter.</td> </tr> <tr><td>xrange</td> <td><i>shard-from</i>[,<i>shard-to</i>]</td> <td>Defines a range of shards to query for xlink values beginning with shards whose name is greater than or equal to the <i>shard-from</i> name. If a <i>shard-to</i> name is given, shard names must also be less than or equal to that name. Either this or the ""xshards"" parameter can be provided, but not both. If neither ""xshards"" nor ""xrange"" is specified, the search scope of xlinks is defined by the ""shards"" or ""range"" parameter.</td> </tr> </table> Results are turned in the given   {@link AggregateResult} object. An exception is thrownif a parameter is invalid or a database error occurs.
 * @param tableName Name of table to query.
 * @param params    Names and values of aggregate query parameters. 
 * @return          {@link AggregateResult} containing results.
 */
@Override public AggregateResult aggregateQuery(String tableName,Map<String,String> params){
  Utils.require(!Utils.isEmpty(tableName),""String_Node_Str"");
  Utils.require(params != null && params.size() > 0,""String_Node_Str"");
  TableDefinition tableDef=m_appDef.getTableDef(tableName);
  Utils.require(tableDef != null,""String_Node_Str"",m_appDef.getAppName(),tableName);
  StringBuilder uri=new StringBuilder(""String_Node_Str"");
  uri.append(Utils.urlEncode(m_appDef.getAppName()));
  uri.append(""String_Node_Str"");
  uri.append(Utils.urlEncode(tableDef.getTableName()));
  uri.append(""String_Node_Str"");
  Utils.require(params.containsKey(""String_Node_Str""),""String_Node_Str"");
  uri.append(""String_Node_Str"");
  uri.append(Utils.urlEncode(params.get(""String_Node_Str"")));
  for (  String name : params.keySet()) {
    String value=params.get(name);
switch (name) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
      uri.append(""String_Node_Str"");
    uri.append(name);
  uri.append(""String_Node_Str"");
uri.append(Utils.urlEncode(value));
break;
case ""String_Node_Str"":
break;
default :
Utils.require(false,""String_Node_Str"",name);
}
}
addTenantParam(uri);
try {
RESTResponse response=m_restClient.sendRequest(HttpMethod.GET,uri.toString());
m_logger.debug(""String_Node_Str"",response.toString());
AggregateResult result=new AggregateResult();
if (response.getCode() != HttpCode.OK) {
result.setErrorMessage(response.getBody());
}
 else {
result.parse(UNode.parse(response.getBody(),response.getContentType()));
}
return result;
}
 catch (Exception e) {
throw new RuntimeException(e);
}
}",0.9929522317932654
29906,"/** 
 * Add the given batch of objects defined by the given   {@link DBObjectBatch} to thegiven OLAP shard. Objects can belong to different tables, but all tables must belong to this session's application. If the update was successful, the GUID of the segment is returned within the given  {@link BatchResult}. An exception is thrown if an error occurs.
 * @param shard         Name of shard to load.
 * @param dbObjBatch    {@link DBObjectBatch} of objects to add.
 * @return              {@link BatchResult} containing results of the update.
 */
public BatchResult addBatch(String shard,DBObjectBatch dbObjBatch){
  Utils.require(!Utils.isEmpty(shard),""String_Node_Str"");
  Utils.require(dbObjBatch != null && dbObjBatch.getObjectCount() > 0,""String_Node_Str"");
  try {
    byte[] body=null;
    body=dbObjBatch.toDoc().toCompressedJSON();
    String uri=uriRoot() + Utils.urlEncode(m_appDef.getAppName()) + ""String_Node_Str""+ Utils.urlEncode(shard);
    RESTResponse response=m_restClient.sendRequestCompressed(HttpMethod.POST,uri,ContentType.APPLICATION_JSON,body);
    m_logger.debug(""String_Node_Str"",response.toString());
    return createBatchResult(response);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Add the given batch of objects defined by the given   {@link DBObjectBatch} to thegiven OLAP shard. Objects can belong to different tables, but all tables must belong to this session's application. If the update was successful, the GUID of the segment is returned within the given  {@link BatchResult}. An exception is thrown if an error occurs.
 * @param shard         Name of shard to load.
 * @param dbObjBatch    {@link DBObjectBatch} of objects to add.
 * @return              {@link BatchResult} containing results of the update.
 */
public BatchResult addBatch(String shard,DBObjectBatch dbObjBatch){
  Utils.require(!Utils.isEmpty(shard),""String_Node_Str"");
  Utils.require(dbObjBatch != null && dbObjBatch.getObjectCount() > 0,""String_Node_Str"");
  try {
    byte[] body=null;
    body=dbObjBatch.toDoc().toCompressedJSON();
    StringBuilder uri=new StringBuilder();
    uri.append(Utils.urlEncode(m_appDef.getAppName()));
    uri.append(""String_Node_Str"");
    uri.append(Utils.urlEncode(shard));
    addTenantParam(uri);
    RESTResponse response=m_restClient.sendRequestCompressed(HttpMethod.POST,uri.toString(),ContentType.APPLICATION_JSON,body);
    m_logger.debug(""String_Node_Str"",response.toString());
    return createBatchResult(response);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9483495145631068
29907,"/** 
 * Delete the objects in the given batch from the given shard. The result of the update is returned as a   {@link BatchResult}.
 * @param shard         Name of the shard from which to delete objects.
 * @param dbObjBatch    {@link DBObjectBatch} of objects to delete.
 * @return              A {@link BatchResult} object containing the results of theupdate request.
 */
@Override public BatchResult deleteBatch(String shard,DBObjectBatch dbObjBatch){
  Utils.require(!Utils.isEmpty(shard),""String_Node_Str"");
  Utils.require(dbObjBatch != null && dbObjBatch.getObjectCount() > 0,""String_Node_Str"");
  try {
    byte[] body=Utils.toBytes(dbObjBatch.toDoc().toJSON());
    String uri=uriRoot() + Utils.urlEncode(m_appDef.getAppName()) + ""String_Node_Str""+ Utils.urlEncode(shard);
    RESTResponse response=m_restClient.sendRequest(HttpMethod.DELETE,uri,ContentType.APPLICATION_JSON,body);
    m_logger.debug(""String_Node_Str"",response.toString());
    return createBatchResult(response);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Delete the objects in the given batch from the given shard. The result of the update is returned as a   {@link BatchResult}.
 * @param shard         Name of the shard from which to delete objects.
 * @param dbObjBatch    {@link DBObjectBatch} of objects to delete.
 * @return              A {@link BatchResult} object containing the results of theupdate request.
 */
@Override public BatchResult deleteBatch(String shard,DBObjectBatch dbObjBatch){
  Utils.require(!Utils.isEmpty(shard),""String_Node_Str"");
  Utils.require(dbObjBatch != null && dbObjBatch.getObjectCount() > 0,""String_Node_Str"");
  try {
    byte[] body=Utils.toBytes(dbObjBatch.toDoc().toJSON());
    StringBuilder uri=new StringBuilder();
    uri.append(Utils.urlEncode(m_appDef.getAppName()));
    uri.append(""String_Node_Str"");
    uri.append(Utils.urlEncode(shard));
    addTenantParam(uri);
    RESTResponse response=m_restClient.sendRequest(HttpMethod.DELETE,uri.toString(),ContentType.APPLICATION_JSON,body);
    m_logger.debug(""String_Node_Str"",response.toString());
    return createBatchResult(response);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.94006309148265
29908,"/** 
 * Request a merge of the OLAP shard with the given name belonging to this session's application. Optionally set the shard's expire-date to the given value. True is returned if the merge was successful. An exception is thrown if an error occurred.
 * @param shard         Shard name.
 * @param expireDate    Optional value for shard's new expire-date. Leave null if theshard should have no expiration date.
 * @return              True if the merge was successful.
 */
public boolean mergeShard(String shard,Date expireDate){
  Utils.require(!Utils.isEmpty(shard),""String_Node_Str"");
  try {
    StringBuilder uri=new StringBuilder();
    uri.append(uriRoot());
    uri.append(Utils.urlEncode(m_appDef.getAppName()));
    uri.append(""String_Node_Str"");
    uri.append(Utils.urlEncode(shard));
    if (expireDate != null) {
      uri.append(""String_Node_Str"");
      uri.append(Utils.urlEncode(Utils.formatDateUTC(expireDate)));
    }
    RESTResponse response=m_restClient.sendRequest(HttpMethod.POST,uri.toString());
    m_logger.debug(""String_Node_Str"",response.toString());
    throwIfErrorResponse(response);
    return true;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Request a merge of the OLAP shard with the given name belonging to this session's application. Optionally set the shard's expire-date to the given value. True is returned if the merge was successful. An exception is thrown if an error occurred.
 * @param shard         Shard name.
 * @param expireDate    Optional value for shard's new expire-date. Leave null if theshard should have no expiration date.
 * @return              True if the merge was successful.
 */
public boolean mergeShard(String shard,Date expireDate){
  Utils.require(!Utils.isEmpty(shard),""String_Node_Str"");
  try {
    StringBuilder uri=new StringBuilder(""String_Node_Str"");
    uri.append(Utils.urlEncode(m_appDef.getAppName()));
    uri.append(""String_Node_Str"");
    uri.append(Utils.urlEncode(shard));
    if (expireDate != null) {
      uri.append(""String_Node_Str"");
      uri.append(Utils.urlEncode(Utils.formatDateUTC(expireDate)));
    }
    addTenantParam(uri);
    RESTResponse response=m_restClient.sendRequest(HttpMethod.POST,uri.toString());
    m_logger.debug(""String_Node_Str"",response.toString());
    throwIfErrorResponse(response);
    return true;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9715229054890632
29909,"/** 
 * Get the object with the given ID from the given table. Null is returned if there is no such object.
 * @param tableName     Name of table to get object from. It must belong to thissession's application.
 * @param objectID      Object's ID.
 * @return              {@link DBObject} containing all of the object's scalar and linkfield values, or null if the object does not exist.
 */
public DBObject getObject(String tableName,String objectID){
  Utils.require(!Utils.isEmpty(tableName),""String_Node_Str"");
  Utils.require(!Utils.isEmpty(objectID),""String_Node_Str"");
  TableDefinition tableDef=m_appDef.getTableDef(tableName);
  Utils.require(tableDef != null,""String_Node_Str"",m_appDef.getAppName(),tableName);
  try {
    String uri=uriRoot() + Utils.urlEncode(m_appDef.getAppName()) + ""String_Node_Str""+ Utils.urlEncode(tableName)+ ""String_Node_Str""+ Utils.urlEncode(objectID);
    RESTResponse response=m_restClient.sendRequest(HttpMethod.GET,uri);
    m_logger.debug(""String_Node_Str"",response.toString());
    if (response.getCode() != HttpCode.OK) {
      return null;
    }
    return new DBObject().parse(getUNodeResult(response));
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Get the object with the given ID from the given table. Null is returned if there is no such object.
 * @param tableName     Name of table to get object from. It must belong to thissession's application.
 * @param objectID      Object's ID.
 * @return              {@link DBObject} containing all of the object's scalar and linkfield values, or null if the object does not exist.
 */
public DBObject getObject(String tableName,String objectID){
  Utils.require(!Utils.isEmpty(tableName),""String_Node_Str"");
  Utils.require(!Utils.isEmpty(objectID),""String_Node_Str"");
  TableDefinition tableDef=m_appDef.getTableDef(tableName);
  Utils.require(tableDef != null,""String_Node_Str"",m_appDef.getAppName(),tableName);
  try {
    StringBuilder uri=new StringBuilder(""String_Node_Str"");
    uri.append(Utils.urlEncode(m_appDef.getAppName()));
    uri.append(""String_Node_Str"");
    uri.append(Utils.urlEncode(tableName));
    uri.append(""String_Node_Str"");
    uri.append(Utils.urlEncode(objectID));
    addTenantParam(uri);
    RESTResponse response=m_restClient.sendRequest(HttpMethod.GET,uri.toString());
    m_logger.debug(""String_Node_Str"",response.toString());
    if (response.getCode() != HttpCode.OK) {
      return null;
    }
    return new DBObject().parse(getUNodeResult(response));
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9264705882352942
29910,"/** 
 * Perform an aggregate query for the given table and query parameters. The table must belong to this session's application. Query parameters are specific to the storage service managing the application. Common parameters are: <table> <tr><td>Name</td><td>Value</td><td>Description</td></tr> <tr><td>m</td> <td>metric list</td> <td>Required. Comma-separated list of metric expression(s) to compute.</td> </tr> <tr><td>q</td> <td>query expression</td> <td>Optional. Query expression that selects objects in the table. Default is ""*"", which selects all objects.</td> </tr> <tr><td>f</td> <td>grouping parameter</td> <td>Optional. Comma-separated list of grouping field expressions. When present, creates a grouped aggregate query instead of a global aggregate query. Either this or the 'cf' paramter can be provided, but not both.</td> </tr> <tr><td>cf</td> <td>composite grouping parameter</td> <td>Optional. Comma-separated list of grouping field expressions. When present, creates a grouped aggregate query instead of a global aggregate query. The 'cf' parameter causes a <i>composite</i> group to be generated for secondary groups. If single-level aggregate queries, 'cf' is the same as 'f'. Either this or the 'f' parameter can be specified, but not both.</td> </tr> </table> Results are turned in the given   {@link AggregateResult} object. An exception is thrownif a parameter is invalid or a database error occurs.
 * @param tableName Name of table to query.
 * @param params    Names and values of aggregate query parameters. 
 * @return          {@link AggregateResult} containing results.
 */
@Override public AggregateResult aggregateQuery(String tableName,Map<String,String> params){
  Utils.require(!Utils.isEmpty(tableName),""String_Node_Str"");
  Utils.require(params != null && params.size() > 0,""String_Node_Str"");
  TableDefinition tableDef=m_appDef.getTableDef(tableName);
  Utils.require(tableDef != null,""String_Node_Str"",m_appDef.getAppName(),tableName);
  StringBuilder uri=new StringBuilder();
  uri.append(uriRoot());
  uri.append(Utils.urlEncode(m_appDef.getAppName()));
  uri.append(""String_Node_Str"");
  uri.append(Utils.urlEncode(tableDef.getTableName()));
  uri.append(""String_Node_Str"");
  Utils.require(params.containsKey(""String_Node_Str""),""String_Node_Str"");
  uri.append(""String_Node_Str"");
  uri.append(Utils.urlEncode(params.get(""String_Node_Str"")));
  for (  String name : params.keySet()) {
    String value=params.get(name);
switch (name) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
      uri.append(""String_Node_Str"");
    uri.append(name);
  uri.append(""String_Node_Str"");
uri.append(Utils.urlEncode(value));
break;
case ""String_Node_Str"":
break;
default :
Utils.require(false,""String_Node_Str"",name);
}
}
try {
RESTResponse response=m_restClient.sendRequest(HttpMethod.GET,uri.toString());
m_logger.debug(""String_Node_Str"",response.toString());
AggregateResult result=new AggregateResult();
if (response.getCode() != HttpCode.OK) {
result.setErrorMessage(response.getBody());
}
 else {
result.parse(getUNodeResult(response));
}
return result;
}
 catch (Exception e) {
throw new RuntimeException(e);
}
}","/** 
 * Perform an aggregate query for the given table and query parameters. The table must belong to this session's application. Query parameters are specific to the storage service managing the application. Common parameters are: <table> <tr><td>Name</td><td>Value</td><td>Description</td></tr> <tr><td>m</td> <td>metric list</td> <td>Required. Comma-separated list of metric expression(s) to compute.</td> </tr> <tr><td>q</td> <td>query expression</td> <td>Optional. Query expression that selects objects in the table. Default is ""*"", which selects all objects.</td> </tr> <tr><td>f</td> <td>grouping parameter</td> <td>Optional. Comma-separated list of grouping field expressions. When present, creates a grouped aggregate query instead of a global aggregate query. Either this or the 'cf' paramter can be provided, but not both.</td> </tr> <tr><td>cf</td> <td>composite grouping parameter</td> <td>Optional. Comma-separated list of grouping field expressions. When present, creates a grouped aggregate query instead of a global aggregate query. The 'cf' parameter causes a <i>composite</i> group to be generated for secondary groups. If single-level aggregate queries, 'cf' is the same as 'f'. Either this or the 'f' parameter can be specified, but not both.</td> </tr> </table> Results are turned in the given   {@link AggregateResult} object. An exception is thrownif a parameter is invalid or a database error occurs.
 * @param tableName Name of table to query.
 * @param params    Names and values of aggregate query parameters. 
 * @return          {@link AggregateResult} containing results.
 */
@Override public AggregateResult aggregateQuery(String tableName,Map<String,String> params){
  Utils.require(!Utils.isEmpty(tableName),""String_Node_Str"");
  Utils.require(params != null && params.size() > 0,""String_Node_Str"");
  TableDefinition tableDef=m_appDef.getTableDef(tableName);
  Utils.require(tableDef != null,""String_Node_Str"",m_appDef.getAppName(),tableName);
  StringBuilder uri=new StringBuilder(""String_Node_Str"");
  uri.append(Utils.urlEncode(m_appDef.getAppName()));
  uri.append(""String_Node_Str"");
  uri.append(Utils.urlEncode(tableDef.getTableName()));
  uri.append(""String_Node_Str"");
  Utils.require(params.containsKey(""String_Node_Str""),""String_Node_Str"");
  uri.append(""String_Node_Str"");
  uri.append(Utils.urlEncode(params.get(""String_Node_Str"")));
  for (  String name : params.keySet()) {
    String value=params.get(name);
switch (name) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
      uri.append(""String_Node_Str"");
    uri.append(name);
  uri.append(""String_Node_Str"");
uri.append(Utils.urlEncode(value));
break;
case ""String_Node_Str"":
break;
default :
Utils.require(false,""String_Node_Str"",name);
}
}
addTenantParam(uri);
try {
RESTResponse response=m_restClient.sendRequest(HttpMethod.GET,uri.toString());
m_logger.debug(""String_Node_Str"",response.toString());
AggregateResult result=new AggregateResult();
if (response.getCode() != HttpCode.OK) {
result.setErrorMessage(response.getBody());
}
 else {
result.parse(getUNodeResult(response));
}
return result;
}
 catch (Exception e) {
throw new RuntimeException(e);
}
}",0.9901052300926652
29911,"/** 
 * Add the given object to the given table, which must be defined for a table that belongs to this session's application. This is a convenience method that bundles the DBObject in a   {@link DBObjectBatch} and calls{@link #addBatch(String,DBObjectBatch)}. The   {@link ObjectResult} from the batchresult is returned.
 * @param tableName Name of table to add object to.
 * @param dbObj     {@link DBObject} of object to add to the database.
 * @return          {@link ObjectResult} of the add request. The result can be used todetermine the ID of the object if it was added by the system.
 */
public ObjectResult addObject(String tableName,DBObject dbObj){
  Utils.require(!Utils.isEmpty(tableName),""String_Node_Str"");
  Utils.require(dbObj != null,""String_Node_Str"");
  TableDefinition tableDef=m_appDef.getTableDef(tableName);
  Utils.require(tableDef != null,""String_Node_Str"",m_appDef.getAppName(),tableName);
  try {
    DBObjectBatch dbObjBatch=new DBObjectBatch();
    dbObjBatch.addObject(dbObj);
    byte[] body=Utils.toBytes(dbObjBatch.toDoc().toJSON());
    String uri=uriRoot() + Utils.urlEncode(m_appDef.getAppName()) + ""String_Node_Str""+ Utils.urlEncode(tableName);
    RESTResponse response=m_restClient.sendRequest(HttpMethod.POST,uri,ContentType.APPLICATION_JSON,body);
    m_logger.debug(""String_Node_Str"",response.toString());
    BatchResult batchResult=createBatchResult(response);
    ObjectResult objResult=null;
    if (batchResult.isFailed()) {
      objResult=ObjectResult.newErrorResult(batchResult.getErrorMessage(),dbObj.getObjectID());
    }
 else {
      for (      String objID : batchResult.getResultObjectIDs()) {
        objResult=batchResult.getObjectResult(objID);
        break;
      }
    }
    return objResult;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Add the given object to the given table, which must be defined for a table that belongs to this session's application. This is a convenience method that bundles the DBObject in a   {@link DBObjectBatch} and calls{@link #addBatch(String,DBObjectBatch)}. The   {@link ObjectResult} from the batchresult is returned.
 * @param tableName Name of table to add object to.
 * @param dbObj     {@link DBObject} of object to add to the database.
 * @return          {@link ObjectResult} of the add request. The result can be used todetermine the ID of the object if it was added by the system.
 */
public ObjectResult addObject(String tableName,DBObject dbObj){
  Utils.require(!Utils.isEmpty(tableName),""String_Node_Str"");
  Utils.require(dbObj != null,""String_Node_Str"");
  TableDefinition tableDef=m_appDef.getTableDef(tableName);
  Utils.require(tableDef != null,""String_Node_Str"",m_appDef.getAppName(),tableName);
  try {
    DBObjectBatch dbObjBatch=new DBObjectBatch();
    dbObjBatch.addObject(dbObj);
    byte[] body=Utils.toBytes(dbObjBatch.toDoc().toJSON());
    StringBuilder uri=new StringBuilder(""String_Node_Str"");
    uri.append(Utils.urlEncode(m_appDef.getAppName()));
    uri.append(""String_Node_Str"");
    uri.append(Utils.urlEncode(tableName));
    addTenantParam(uri);
    RESTResponse response=m_restClient.sendRequest(HttpMethod.POST,uri.toString(),ContentType.APPLICATION_JSON,body);
    m_logger.debug(""String_Node_Str"",response.toString());
    BatchResult batchResult=createBatchResult(response);
    ObjectResult objResult=null;
    if (batchResult.isFailed()) {
      objResult=ObjectResult.newErrorResult(batchResult.getErrorMessage(),dbObj.getObjectID());
    }
 else {
      for (      String objID : batchResult.getResultObjectIDs()) {
        objResult=batchResult.getObjectResult(objID);
        break;
      }
    }
    return objResult;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9373673036093418
29912,"/** 
 * Add the given batch of objects to the given table, which must belong to this session's application. Objects are added if they do not currently exist or do not have an object ID assigned. Otherwise, existing objects are updated. The result of the update is returned as a   {@link BatchResult}.
 * @param tableName     Name of table to update.
 * @param dbObjBatch    {@link DBObjectBatch} of objects to add or update.
 * @return              A {@link BatchResult} object containing the results of theupdate request.
 */
@Override public BatchResult addBatch(String tableName,DBObjectBatch dbObjBatch){
  Utils.require(!Utils.isEmpty(tableName),""String_Node_Str"");
  Utils.require(dbObjBatch != null && dbObjBatch.getObjectCount() > 0,""String_Node_Str"");
  try {
    byte[] body=Utils.toBytes(dbObjBatch.toDoc().toJSON());
    String uri=uriRoot() + Utils.urlEncode(m_appDef.getAppName()) + ""String_Node_Str""+ Utils.urlEncode(tableName);
    RESTResponse response=m_restClient.sendRequest(HttpMethod.POST,uri,ContentType.APPLICATION_JSON,body);
    m_logger.debug(""String_Node_Str"",response.toString());
    return createBatchResult(response);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Add the given batch of objects to the given table, which must belong to this session's application. Objects are added if they do not currently exist or do not have an object ID assigned. Otherwise, existing objects are updated. The result of the update is returned as a   {@link BatchResult}.
 * @param tableName     Name of table to update.
 * @param dbObjBatch    {@link DBObjectBatch} of objects to add or update.
 * @return              A {@link BatchResult} object containing the results of theupdate request.
 */
@Override public BatchResult addBatch(String tableName,DBObjectBatch dbObjBatch){
  Utils.require(!Utils.isEmpty(tableName),""String_Node_Str"");
  Utils.require(dbObjBatch != null && dbObjBatch.getObjectCount() > 0,""String_Node_Str"");
  try {
    byte[] body=Utils.toBytes(dbObjBatch.toDoc().toJSON());
    StringBuilder uri=new StringBuilder(""String_Node_Str"");
    uri.append(Utils.urlEncode(m_appDef.getAppName()));
    uri.append(""String_Node_Str"");
    uri.append(Utils.urlEncode(tableName));
    addTenantParam(uri);
    RESTResponse response=m_restClient.sendRequest(HttpMethod.POST,uri.toString(),ContentType.APPLICATION_JSON,body);
    m_logger.debug(""String_Node_Str"",response.toString());
    return createBatchResult(response);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9075959279561472
29913,"/** 
 * Delete the objects in the given batch from the given table, which must belong to this session's Spider application. All objects in the batch must have IDs. The result of the update is returned as a   {@link BatchResult}.
 * @param tableName     Name of table from which to delete objects.
 * @param dbObjBatch    {@link DBObjectBatch} of objects to delete. The ID must be setfor each contained  {@link DBObject}.
 * @return              A {@link BatchResult} object containing the results of thedelete request.
 */
@Override public BatchResult deleteBatch(String tableName,DBObjectBatch dbObjBatch){
  Utils.require(!Utils.isEmpty(tableName),""String_Node_Str"");
  Utils.require(dbObjBatch != null && dbObjBatch.getObjectCount() > 0,""String_Node_Str"");
  TableDefinition tableDef=m_appDef.getTableDef(tableName);
  Utils.require(tableDef != null,""String_Node_Str"",m_appDef.getAppName(),tableName);
  try {
    byte[] body=Utils.toBytes(dbObjBatch.toDoc().toJSON());
    String uri=uriRoot() + Utils.urlEncode(m_appDef.getAppName()) + ""String_Node_Str""+ Utils.urlEncode(tableName);
    RESTResponse response=m_restClient.sendRequest(HttpMethod.DELETE,uri,ContentType.APPLICATION_JSON,body);
    m_logger.debug(""String_Node_Str"",response.toString());
    return createBatchResult(response);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Delete the objects in the given batch from the given table, which must belong to this session's Spider application. All objects in the batch must have IDs. The result of the update is returned as a   {@link BatchResult}.
 * @param tableName     Name of table from which to delete objects.
 * @param dbObjBatch    {@link DBObjectBatch} of objects to delete. The ID must be setfor each contained  {@link DBObject}.
 * @return              A {@link BatchResult} object containing the results of thedelete request.
 */
@Override public BatchResult deleteBatch(String tableName,DBObjectBatch dbObjBatch){
  Utils.require(!Utils.isEmpty(tableName),""String_Node_Str"");
  Utils.require(dbObjBatch != null && dbObjBatch.getObjectCount() > 0,""String_Node_Str"");
  TableDefinition tableDef=m_appDef.getTableDef(tableName);
  Utils.require(tableDef != null,""String_Node_Str"",m_appDef.getAppName(),tableName);
  try {
    byte[] body=Utils.toBytes(dbObjBatch.toDoc().toJSON());
    StringBuilder uri=new StringBuilder(""String_Node_Str"");
    uri.append(Utils.urlEncode(m_appDef.getAppName()));
    uri.append(""String_Node_Str"");
    uri.append(Utils.urlEncode(tableName));
    addTenantParam(uri);
    RESTResponse response=m_restClient.sendRequest(HttpMethod.DELETE,uri.toString(),ContentType.APPLICATION_JSON,body);
    m_logger.debug(""String_Node_Str"",response.toString());
    return createBatchResult(response);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9472944483485594
29914,"private static ArrayList<AggregationGroup> processItems(Context context,TableDefinition definition,ArrayList<Item> items){
  AggregationGroup aggregationGroup=new AggregationGroup(definition);
  TableDefinition tableDef=definition;
  boolean fieldDetected=false;
  ArrayList<AggregationGroup> result=new ArrayList<AggregationGroup>();
  int startPos=-1;
  int lastPos=-1;
  boolean includeList=false;
  for (int i=0; i < items.size(); i++) {
    Item item=items.get(i);
    if (item.item.getPtr() != -1) {
      lastPos=item.item.getPtr() + item.item.getValue().length();
    }
    if (startPos == -1)     startPos=item.item.getPtr();
    if (item.item.getType().equals(""String_Node_Str"")) {
      SetFilter(aggregationGroup,tableDef,item);
      continue;
    }
    if (item.item.getType().equals(""String_Node_Str"")) {
      SetFilter(aggregationGroup,tableDef,item);
      continue;
    }
    if (item.item.getType().equals(""String_Node_Str"")) {
      lastPos=item.item.getPtr();
      if (aggregationGroup.items != null) {
        result.add(aggregationGroup);
        aggregationGroup.text=context.inputString.substring(startPos,item.item.getPtr());
        startPos=item.item.getPtr() + item.item.getValue().length();
        aggregationGroup=new AggregationGroup(definition);
        tableDef=definition;
        fieldDetected=false;
      }
    }
 else     if (item.item.getValue().equals(""String_Node_Str"")) {
      result.add(aggregationGroup);
      aggregationGroup.text=context.inputString.substring(startPos,item.item.getPtr());
      startPos=item.item.getPtr() + item.item.getValue().length();
      aggregationGroup=new AggregationGroup(definition);
      SetFilter(aggregationGroup,tableDef,item);
      tableDef=definition;
      fieldDetected=false;
    }
 else {
      String type=item.item.getType();
      if (type.equals(SemanticNames.TRUNCATE_VALUE)) {
        aggregationGroup.truncate=item.item.getValue();
        continue;
      }
      if (type.equals(SemanticNames.TRUNCATE_SUBFIELD_VALUE)) {
        aggregationGroup.subField=AggregationGroup.SubField.valueOf(item.item.getValue());
        continue;
      }
      if (type.equals(SemanticNames.TIMEZONEVALUE)) {
        aggregationGroup.timeZone=item.item.getValue().trim();
        char ch=aggregationGroup.timeZone.charAt(0);
        if (ch == '+' || ch == '-') {
          aggregationGroup.timeZone=""String_Node_Str"" + aggregationGroup.timeZone;
        }
 else         if (Character.getType(ch) == Character.DECIMAL_DIGIT_NUMBER) {
          aggregationGroup.timeZone=""String_Node_Str"" + aggregationGroup.timeZone;
        }
        String prefix=aggregationGroup.timeZone.substring(0,4);
        String val=aggregationGroup.timeZone.substring(4);
switch (val.length()) {
case 1:
          aggregationGroup.timeZone=prefix + ""String_Node_Str"" + val+ ""String_Node_Str"";
        break;
case 2:
      aggregationGroup.timeZone=prefix + val + ""String_Node_Str"";
    break;
case 3:
  aggregationGroup.timeZone=prefix + ""String_Node_Str"" + val.substring(0,1)+ ""String_Node_Str""+ val.substring(1);
break;
case 4:
if (val.charAt(1) == ':') aggregationGroup.timeZone=prefix + ""String_Node_Str"" + val;
 else {
aggregationGroup.timeZone=prefix + val.substring(0,2) + ""String_Node_Str""+ val.substring(2);
}
break;
case 5:
break;
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
TimeZone zone=TimeZone.getTimeZone(aggregationGroup.timeZone);
String id=zone.getID();
if (id.compareTo(aggregationGroup.timeZone) != 0) {
throw new IllegalArgumentException(""String_Node_Str"" + aggregationGroup.timeZone + ""String_Node_Str"");
}
continue;
}
if (type.equals(SemanticNames.TIMEZONEDISPLAYNAME)) {
aggregationGroup.timeZone=item.item.getValue();
if (!isCorrectTimeZone(aggregationGroup.timeZone)) throw new IllegalArgumentException(""String_Node_Str"" + aggregationGroup.timeZone + ""String_Node_Str"");
continue;
}
if (type.equals(SemanticNames.GROUP)) {
continue;
}
if (type.equals(SemanticNames.BATCH_VALUE)) {
if (aggregationGroup.batch == null) aggregationGroup.batch=new ArrayList<Object>();
aggregationGroup.batch.add(item.item.getValue());
continue;
}
if (type.equals(SemanticNames.TOPBOTTOMVALUE)) {
aggregationGroup.selectionValue=Integer.parseInt(item.item.getValue());
continue;
}
if (type.equals(SemanticNames.UPPER)) {
aggregationGroup.tocase=SemanticNames.UPPER;
continue;
}
if (type.equals(SemanticNames.LOWER)) {
aggregationGroup.tocase=SemanticNames.LOWER;
continue;
}
if (type.equals(SemanticNames.TRUNCATE) || type.equals(SemanticNames.BATCH)) {
SetFilter(aggregationGroup,tableDef,item);
continue;
}
if (type.equals(SemanticNames.TERMS)) continue;
if (type.equals(SemanticNames.EXCLUDELIST)) {
includeList=false;
continue;
}
if (type.equals(SemanticNames.INCLUDELIST)) {
includeList=true;
continue;
}
if (type.equals(SemanticNames.EXCLUDE)) {
continue;
}
if (type.equals(SemanticNames.STOPVALUEANY)) {
if (aggregationGroup.stopWords == null) {
aggregationGroup.stopWords=new ArrayList<String>();
}
 else {
throw new IllegalArgumentException(""String_Node_Str"");
}
continue;
}
if (type.equals(SemanticNames.STOPVALUE)) {
if (aggregationGroup.stopWords == null) {
aggregationGroup.stopWords=new ArrayList<String>();
}
aggregationGroup.stopWords.add(item.item.getValue());
continue;
}
if (type.equals(SemanticNames.EXCLUDEVALUE)) {
String value=item.item.getValue();
if (""String_Node_Str"".equals(value)) value=null;
if (includeList) {
if (aggregationGroup.include == null) {
aggregationGroup.include=new ArrayList<String>();
}
aggregationGroup.include.add(value);
continue;
}
 else {
if (aggregationGroup.exclude == null) {
aggregationGroup.exclude=new ArrayList<String>();
}
aggregationGroup.exclude.add(value);
continue;
}
}
if (type.equals(SemanticNames.ALIAS)) {
aggregationGroup.name=item.item.getValue();
continue;
}
if (item.item.getValue().equals(""String_Node_Str"")) {
continue;
}
if (type.equals(SemanticNames.TOPBOTTOM)) {
if (item.item.getValue().equals(""String_Node_Str"")) aggregationGroup.selection=AggregationGroup.Selection.Top;
 else aggregationGroup.selection=AggregationGroup.Selection.Bottom;
SetFilter(aggregationGroup,tableDef,item);
continue;
}
AggregationGroupItem ai=new AggregationGroupItem();
if (aggregationGroup.items == null) aggregationGroup.items=new ArrayList<AggregationGroupItem>();
aggregationGroup.items.add(ai);
ai.name=item.item.getValue();
if (tableDef != null) {
FieldDefinition fd=tableDef.getFieldDef(ai.name);
ai.fieldDef=fd;
if (fd == null) throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(aggregationGroup.items));
if (fd.isGroupField()) {
ai.nestedLinks=GetNestedFieldsInfo(fd);
ai.isLink=true;
for (FieldDefinition nestedFieldDef : fd.getNestedFields()) {
if (nestedFieldDef.isGroupField()) {
List<LinkInfo> info=GetNestedFieldsInfo(nestedFieldDef);
if (info.size() == 0) throw new IllegalArgumentException(""String_Node_Str"" + nestedFieldDef.getName());
nestedFieldDef=info.get(0).fieldDef;
}
if (tableDef.isLinkField(nestedFieldDef.getName())) {
TableDefinition td=tableDef.getLinkExtentTableDef(nestedFieldDef);
if (td == null) {
throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(aggregationGroup.items));
}
tableDef=td;
}
ai.tableDef=tableDef;
break;
}
}
 else if (fd.isLinkField() || fd.isXLinkField()) {
ai.isLink=true;
if (fieldDetected) throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(aggregationGroup.items));
tableDef=tableDef.getLinkExtentTableDef(fd);
if (tableDef == null) {
throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(aggregationGroup.items));
}
}
 else {
if (fieldDetected) throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(aggregationGroup.items));
fieldDetected=true;
}
ai.tableDef=tableDef;
}
if (item.queryItems != null) {
for (int j=0; j < item.queryItems.size(); j++) {
ArrayList<GrammarItem> filterItems=item.queryItems.get(j);
ai.query=CompileQuery(tableDef,ai.query,filterItems);
GrammarItem last=filterItems.get(filterItems.size() - 2);
lastPos=last.getPtr() + last.getValue().length();
}
}
}
}
if (aggregationGroup != null && aggregationGroup.items != null) {
aggregationGroup.text=context.inputString.substring(startPos,lastPos);
result.add(aggregationGroup);
}
for (int i=0; i < result.size(); i++) {
AggregationGroup group=result.get(i);
if (group.batch != null && group.items != null) {
AggregationGroupItem item=group.items.get(group.items.size() - 1);
if (item.fieldDef == null) throw new IllegalArgumentException(""String_Node_Str"" + item.name);
FieldType itemType=item.fieldDef.getType();
if (itemType == FieldType.GROUP || itemType == FieldType.LINK || itemType == FieldType.XLINK || itemType == FieldType.BINARY || itemType == FieldType.BOOLEAN) throw new IllegalArgumentException(""String_Node_Str"" + itemType.toString() + ""String_Node_Str"");
for (int j=0; j < group.batch.size(); j++) {
try {
group.batch.set(j,convert(itemType,(String)group.batch.get(j)));
}
 catch (Exception e) {
throw new IllegalArgumentException(""String_Node_Str"" + group.batch.get(j) + ""String_Node_Str""+ item.fieldDef.getName());
}
}
if (group.batch.size() > 1) {
Object first=group.batch.get(0);
for (int j=1; j < group.batch.size(); j++) {
switch (compareBatchValues(itemType,first,group.batch.get(j))) {
case 0:
throw new IllegalArgumentException(""String_Node_Str"");
case 1:
throw new IllegalArgumentException(""String_Node_Str"");
}
first=group.batch.get(j);
}
}
}
if (group.truncate != null && group.items != null) {
AggregationGroupItem item=group.items.get(group.items.size() - 1);
if (item.fieldDef == null) throw new IllegalArgumentException(""String_Node_Str"" + item.name);
if (!(item.fieldDef.getType() == FieldType.TIMESTAMP)) throw new IllegalArgumentException(""String_Node_Str"");
}
}
for (int i=0; i < result.size(); i++) {
AggregationGroup group=result.get(i);
group.whereFilter=getWhereQuery(group);
}
return result;
}","private static ArrayList<AggregationGroup> processItems(Context context,TableDefinition definition,ArrayList<Item> items){
  AggregationGroup aggregationGroup=new AggregationGroup(definition);
  TableDefinition tableDef=definition;
  boolean fieldDetected=false;
  ArrayList<AggregationGroup> result=new ArrayList<AggregationGroup>();
  int startPos=-1;
  int lastPos=-1;
  boolean includeList=false;
  for (int i=0; i < items.size(); i++) {
    Item item=items.get(i);
    if (item.item.getPtr() != -1) {
      lastPos=item.item.getPtr() + item.item.getValue().length();
    }
    if (startPos == -1)     startPos=item.item.getPtr();
    if (item.item.getType().equals(""String_Node_Str"")) {
      SetFilter(aggregationGroup,tableDef,item);
      continue;
    }
    if (item.item.getType().equals(""String_Node_Str"")) {
      SetFilter(aggregationGroup,tableDef,item);
      continue;
    }
    if (item.item.getType().equals(""String_Node_Str"")) {
      lastPos=item.item.getPtr();
      if (aggregationGroup.items != null) {
        result.add(aggregationGroup);
        aggregationGroup.text=context.inputString.substring(startPos,item.item.getPtr());
        startPos=item.item.getPtr() + item.item.getValue().length();
        aggregationGroup=new AggregationGroup(definition);
        tableDef=definition;
        fieldDetected=false;
      }
    }
 else     if (item.item.getValue().equals(""String_Node_Str"")) {
      result.add(aggregationGroup);
      aggregationGroup.text=context.inputString.substring(startPos,item.item.getPtr());
      startPos=item.item.getPtr() + item.item.getValue().length();
      aggregationGroup=new AggregationGroup(definition);
      SetFilter(aggregationGroup,tableDef,item);
      tableDef=definition;
      fieldDetected=false;
    }
 else {
      String type=item.item.getType();
      if (type.equals(SemanticNames.TRUNCATE_VALUE)) {
        aggregationGroup.truncate=item.item.getValue();
        continue;
      }
      if (type.equals(SemanticNames.TRUNCATE_SUBFIELD_VALUE)) {
        aggregationGroup.subField=AggregationGroup.SubField.valueOf(item.item.getValue());
        continue;
      }
      if (type.equals(SemanticNames.TIMEZONEVALUE)) {
        aggregationGroup.timeZone=item.item.getValue().trim();
        char ch=aggregationGroup.timeZone.charAt(0);
        if (ch == '+' || ch == '-') {
          aggregationGroup.timeZone=""String_Node_Str"" + aggregationGroup.timeZone;
        }
 else         if (Character.getType(ch) == Character.DECIMAL_DIGIT_NUMBER) {
          aggregationGroup.timeZone=""String_Node_Str"" + aggregationGroup.timeZone;
        }
        String prefix=aggregationGroup.timeZone.substring(0,4);
        String val=aggregationGroup.timeZone.substring(4);
switch (val.length()) {
case 1:
          aggregationGroup.timeZone=prefix + ""String_Node_Str"" + val+ ""String_Node_Str"";
        break;
case 2:
      aggregationGroup.timeZone=prefix + val + ""String_Node_Str"";
    break;
case 3:
  aggregationGroup.timeZone=prefix + ""String_Node_Str"" + val.substring(0,1)+ ""String_Node_Str""+ val.substring(1);
break;
case 4:
if (val.charAt(1) == ':') aggregationGroup.timeZone=prefix + ""String_Node_Str"" + val;
 else {
aggregationGroup.timeZone=prefix + val.substring(0,2) + ""String_Node_Str""+ val.substring(2);
}
break;
case 5:
break;
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
TimeZone zone=TimeZone.getTimeZone(aggregationGroup.timeZone);
String id=zone.getID();
if (id.compareTo(aggregationGroup.timeZone) != 0) {
throw new IllegalArgumentException(""String_Node_Str"" + aggregationGroup.timeZone + ""String_Node_Str"");
}
continue;
}
if (type.equals(SemanticNames.TIMEZONEDISPLAYNAME)) {
aggregationGroup.timeZone=item.item.getValue();
if (!isCorrectTimeZone(aggregationGroup.timeZone)) throw new IllegalArgumentException(""String_Node_Str"" + aggregationGroup.timeZone + ""String_Node_Str"");
continue;
}
if (type.equals(SemanticNames.GROUP)) {
continue;
}
if (type.equals(SemanticNames.BATCH_VALUE)) {
if (aggregationGroup.batch == null) aggregationGroup.batch=new ArrayList<Object>();
aggregationGroup.batch.add(item.item.getValue());
continue;
}
if (type.equals(SemanticNames.TOPBOTTOMVALUE)) {
aggregationGroup.selectionValue=Integer.parseInt(item.item.getValue());
continue;
}
if (type.equals(SemanticNames.UPPER)) {
aggregationGroup.tocase=SemanticNames.UPPER;
continue;
}
if (type.equals(SemanticNames.LOWER)) {
aggregationGroup.tocase=SemanticNames.LOWER;
continue;
}
if (type.equals(SemanticNames.TRUNCATE) || type.equals(SemanticNames.BATCH)) {
SetFilter(aggregationGroup,tableDef,item);
continue;
}
if (type.equals(SemanticNames.TERMS)) continue;
if (type.equals(SemanticNames.EXCLUDELIST)) {
includeList=false;
continue;
}
if (type.equals(SemanticNames.INCLUDELIST)) {
includeList=true;
continue;
}
if (type.equals(SemanticNames.EXCLUDE)) {
continue;
}
if (type.equals(SemanticNames.STOPVALUEANY)) {
if (aggregationGroup.stopWords == null) {
aggregationGroup.stopWords=new ArrayList<String>();
}
 else {
throw new IllegalArgumentException(""String_Node_Str"");
}
continue;
}
if (type.equals(SemanticNames.STOPVALUE)) {
if (aggregationGroup.stopWords == null) {
aggregationGroup.stopWords=new ArrayList<String>();
}
aggregationGroup.stopWords.add(item.item.getValue());
continue;
}
if (type.equals(SemanticNames.EXCLUDEVALUE)) {
String value=item.item.getValue();
if (""String_Node_Str"".equals(value)) value=null;
if (includeList) {
if (aggregationGroup.include == null) {
aggregationGroup.include=new ArrayList<String>();
}
aggregationGroup.include.add(value);
continue;
}
 else {
if (aggregationGroup.exclude == null) {
aggregationGroup.exclude=new ArrayList<String>();
}
aggregationGroup.exclude.add(value);
continue;
}
}
if (type.equals(SemanticNames.ALIAS)) {
aggregationGroup.name=item.item.getValue();
continue;
}
if (item.item.getValue().equals(""String_Node_Str"")) {
continue;
}
if (type.equals(SemanticNames.TOPBOTTOM)) {
if (item.item.getValue().equals(""String_Node_Str"")) aggregationGroup.selection=AggregationGroup.Selection.Top;
 else aggregationGroup.selection=AggregationGroup.Selection.Bottom;
SetFilter(aggregationGroup,tableDef,item);
continue;
}
AggregationGroupItem ai=new AggregationGroupItem();
if (aggregationGroup.items == null) aggregationGroup.items=new ArrayList<AggregationGroupItem>();
aggregationGroup.items.add(ai);
ai.name=item.item.getValue();
if (tableDef != null) {
FieldDefinition fd=tableDef.getFieldDef(ai.name);
ai.fieldDef=fd;
if (fd == null) throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(aggregationGroup.items));
if (fd.isGroupField()) {
ai.nestedLinks=GetNestedFieldsInfo(fd);
ai.isLink=true;
for (FieldDefinition nestedFieldDef : fd.getNestedFields()) {
if (nestedFieldDef.isGroupField()) {
List<LinkInfo> info=GetNestedFieldsInfo(nestedFieldDef);
if (info.size() == 0) throw new IllegalArgumentException(""String_Node_Str"" + nestedFieldDef.getName());
nestedFieldDef=info.get(0).fieldDef;
}
if (tableDef.isLinkField(nestedFieldDef.getName()) || nestedFieldDef.isXLinkField()) {
TableDefinition td=tableDef.getLinkExtentTableDef(nestedFieldDef);
if (td == null) {
throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(aggregationGroup.items));
}
tableDef=td;
}
ai.tableDef=tableDef;
break;
}
}
 else if (fd.isLinkField() || fd.isXLinkField()) {
ai.isLink=true;
if (fieldDetected) throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(aggregationGroup.items));
tableDef=tableDef.getLinkExtentTableDef(fd);
if (tableDef == null) {
throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(aggregationGroup.items));
}
}
 else {
if (fieldDetected) throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(aggregationGroup.items));
fieldDetected=true;
}
ai.tableDef=tableDef;
}
if (item.queryItems != null) {
for (int j=0; j < item.queryItems.size(); j++) {
ArrayList<GrammarItem> filterItems=item.queryItems.get(j);
ai.query=CompileQuery(tableDef,ai.query,filterItems);
GrammarItem last=filterItems.get(filterItems.size() - 2);
lastPos=last.getPtr() + last.getValue().length();
}
}
}
}
if (aggregationGroup != null && aggregationGroup.items != null) {
aggregationGroup.text=context.inputString.substring(startPos,lastPos);
result.add(aggregationGroup);
}
for (int i=0; i < result.size(); i++) {
AggregationGroup group=result.get(i);
if (group.batch != null && group.items != null) {
AggregationGroupItem item=group.items.get(group.items.size() - 1);
if (item.fieldDef == null) throw new IllegalArgumentException(""String_Node_Str"" + item.name);
FieldType itemType=item.fieldDef.getType();
if (itemType == FieldType.GROUP || itemType == FieldType.LINK || itemType == FieldType.XLINK || itemType == FieldType.BINARY || itemType == FieldType.BOOLEAN) throw new IllegalArgumentException(""String_Node_Str"" + itemType.toString() + ""String_Node_Str"");
for (int j=0; j < group.batch.size(); j++) {
try {
group.batch.set(j,convert(itemType,(String)group.batch.get(j)));
}
 catch (Exception e) {
throw new IllegalArgumentException(""String_Node_Str"" + group.batch.get(j) + ""String_Node_Str""+ item.fieldDef.getName());
}
}
if (group.batch.size() > 1) {
Object first=group.batch.get(0);
for (int j=1; j < group.batch.size(); j++) {
switch (compareBatchValues(itemType,first,group.batch.get(j))) {
case 0:
throw new IllegalArgumentException(""String_Node_Str"");
case 1:
throw new IllegalArgumentException(""String_Node_Str"");
}
first=group.batch.get(j);
}
}
}
if (group.truncate != null && group.items != null) {
AggregationGroupItem item=group.items.get(group.items.size() - 1);
if (item.fieldDef == null) throw new IllegalArgumentException(""String_Node_Str"" + item.name);
if (!(item.fieldDef.getType() == FieldType.TIMESTAMP)) throw new IllegalArgumentException(""String_Node_Str"");
}
}
for (int i=0; i < result.size(); i++) {
AggregationGroup group=result.get(i);
group.whereFilter=getWhereQuery(group);
}
return result;
}",0.9983421250941974
29915,"private static ArrayList<AggregationMetric> BuildMetrics(Context context,TableDefinition definition){
  if (context == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (context.items.isEmpty())   return null;
  ArrayList<AggregationMetric> result=new ArrayList<AggregationMetric>();
  AggregationMetric metric=new AggregationMetric(definition);
  ArrayList<Item> items=extractTokens(context);
  TableDefinition tableDef=definition;
  boolean fieldDetected=false;
  int ptr=0;
  int inputPtr=0;
  for (int i=0; i < items.size(); i++) {
    Item item=items.get(i);
    if (item.item.getType().equals(SemanticNames.AGGREGATION_METRIC_FUNCTION_NAME)) {
      ptr=item.item.getPtr();
      metric.function=item.item.getValue();
      continue;
    }
    if (item.item.getType().equals(""String_Node_Str"")) {
      inputPtr=item.item.getPtr();
      continue;
    }
    if (item.item.getType().equals(""String_Node_Str"") && item.item.getValue().equals(""String_Node_Str"")) {
      result.add(metric);
      tableDef=definition;
      fieldDetected=false;
      metric.sourceText=context.inputString.substring(ptr,inputPtr);
      metric=new AggregationMetric(definition);
      continue;
    }
    if (fieldDetected)     throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(metric.items));
    AggregationGroupItem ai=new AggregationGroupItem();
    if (metric.items == null)     metric.items=new ArrayList<AggregationGroupItem>();
    metric.items.add(ai);
    ai.name=item.item.getValue();
    if (tableDef != null) {
      FieldDefinition fd=tableDef.getFieldDef(ai.name);
      ai.fieldDef=fd;
      if (fd == null) {
        if (i != (items.size() - 1)) {
          throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(metric.items));
        }
        if (!QueryUtils.isSystemField(ai.name)) {
          throw new IllegalArgumentException(""String_Node_Str"" + ai.name);
        }
      }
      if (tableDef.isLinkField(ai.name) || fd.isXLinkField()) {
        ai.isLink=true;
        if (fieldDetected)         throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(metric.items));
        tableDef=tableDef.getLinkExtentTableDef(fd);
        if (tableDef == null) {
          throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(metric.items));
        }
      }
 else {
        if (fd != null && fd.getType() == FieldType.GROUP)         throw new IllegalArgumentException(""String_Node_Str"");
        fieldDetected=true;
      }
      ai.tableDef=tableDef;
    }
    if (item.queryItems != null) {
      for (int j=0; j < item.queryItems.size(); j++) {
        ArrayList<GrammarItem> filterItems=item.queryItems.get(j);
        ai.query=CompileQuery(tableDef,ai.query,filterItems);
      }
    }
  }
  metric.sourceText=context.inputString.substring(ptr);
  result.add(metric);
  return result;
}","private static ArrayList<AggregationMetric> BuildMetrics(Context context,TableDefinition definition){
  if (context == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (context.items.isEmpty())   return null;
  ArrayList<AggregationMetric> result=new ArrayList<AggregationMetric>();
  AggregationMetric metric=new AggregationMetric(definition);
  ArrayList<Item> items=extractTokens(context);
  TableDefinition tableDef=definition;
  boolean fieldDetected=false;
  int ptr=0;
  int inputPtr=0;
  for (int i=0; i < items.size(); i++) {
    Item item=items.get(i);
    if (item.item.getType().equals(SemanticNames.AGGREGATION_METRIC_FUNCTION_NAME)) {
      ptr=item.item.getPtr();
      metric.function=item.item.getValue();
      continue;
    }
    if (item.item.getType().equals(""String_Node_Str"")) {
      inputPtr=item.item.getPtr();
      continue;
    }
    if (item.item.getType().equals(""String_Node_Str"") && item.item.getValue().equals(""String_Node_Str"")) {
      result.add(metric);
      tableDef=definition;
      fieldDetected=false;
      metric.sourceText=context.inputString.substring(ptr,inputPtr);
      metric=new AggregationMetric(definition);
      continue;
    }
    if (fieldDetected)     throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(metric.items));
    AggregationGroupItem ai=new AggregationGroupItem();
    if (metric.items == null)     metric.items=new ArrayList<AggregationGroupItem>();
    metric.items.add(ai);
    ai.name=item.item.getValue();
    if (tableDef != null) {
      FieldDefinition fd=tableDef.getFieldDef(ai.name);
      ai.fieldDef=fd;
      if (fd == null) {
        if (i != (items.size() - 1)) {
          throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(metric.items));
        }
        if (!QueryUtils.isSystemField(ai.name)) {
          throw new IllegalArgumentException(""String_Node_Str"" + ai.name);
        }
      }
      if (tableDef.isLinkField(ai.name) || (fd != null && fd.isXLinkField())) {
        ai.isLink=true;
        if (fieldDetected)         throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(metric.items));
        tableDef=tableDef.getLinkExtentTableDef(fd);
        if (tableDef == null) {
          throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(metric.items));
        }
      }
 else {
        if (fd != null && fd.getType() == FieldType.GROUP)         throw new IllegalArgumentException(""String_Node_Str"");
        fieldDetected=true;
      }
      ai.tableDef=tableDef;
    }
    if (item.queryItems != null) {
      for (int j=0; j < item.queryItems.size(); j++) {
        ArrayList<GrammarItem> filterItems=item.queryItems.get(j);
        ai.query=CompileQuery(tableDef,ai.query,filterItems);
      }
    }
  }
  metric.sourceText=context.inputString.substring(ptr);
  result.add(metric);
  return result;
}",0.997262149212868
29916,"private static ArrayList<MetricExpression> BuildMetricsExpression(Context context,TableDefinition definition){
  if (context == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (context.items.isEmpty())   return null;
  AggregationMetric metric=new AggregationMetric(definition);
  ArrayList<Item> items=extractMetricTokens(context);
  TableDefinition tableDef=definition;
  boolean fieldDetected=false;
  int ptr=0;
  int endMetricPtr=0;
  ArrayList<MetricExpression> resultList=new ArrayList<MetricExpression>();
  Stack<MetricExpression> expressions=new Stack<MetricExpression>();
  Stack<String> operations=new Stack<String>();
  for (int i=0; i < items.size(); i++) {
    Item item=items.get(i);
    if (item.item.getType().equals(""String_Node_Str"")) {
      pushOp(item.item.getValue(),expressions,operations);
      continue;
    }
    if (item.item.getType().equals(""String_Node_Str"")) {
      operations.push(item.item.getValue());
      continue;
    }
    if (item.item.getType().equals(""String_Node_Str"") && item.item.getValue().equals(""String_Node_Str"")) {
      String unit2=operations.pop();
      String unit1=operations.pop();
      String unit=operations.pop();
      GregorianCalendar c1, c2;
      try {
        c1=Utils.parseDate(unit1);
      }
 catch (      Exception e) {
        throw new IllegalArgumentException(""String_Node_Str"" + unit1);
      }
      try {
        c2=Utils.parseDate(unit2);
      }
 catch (      Exception e) {
        throw new IllegalArgumentException(""String_Node_Str"" + unit2);
      }
      LongIntegerExpression le=new LongIntegerExpression();
      le.value=TimeUtils.getTimeDifference(unit,c1,c2);
      expressions.push(le);
      metric=null;
      continue;
    }
    if (item.item.getType().equals(""String_Node_Str"")) {
      endMetricPtr=item.item.getPtr();
      continue;
    }
    if (item.item.getType().equals(""String_Node_Str"")) {
      NumberExpression ne=new NumberExpression();
      try {
        ne.value=Double.parseDouble(item.item.getValue());
      }
 catch (      Exception e) {
        throw new IllegalArgumentException(""String_Node_Str"" + item.item.getValue() + ""String_Node_Str"");
      }
      expressions.push(ne);
      metric=null;
      continue;
    }
    if (item.item.getType().equals(SemanticNames.AGGREGATION_METRIC_FUNCTION_NAME)) {
      ptr=item.item.getPtr();
      metric.function=item.item.getValue();
      if (item.queryItems != null) {
        for (int j=0; j < item.queryItems.size(); j++) {
          ArrayList<GrammarItem> filterItems=item.queryItems.get(j);
          metric.filter=CompileQuery(tableDef,metric.filter,filterItems);
        }
      }
      continue;
    }
    if (item.item.getType().equals(""String_Node_Str"") && item.item.getValue().equals(""String_Node_Str"")) {
      if (metric != null) {
        expressions.push(metric);
        metric.sourceText=context.inputString.substring(ptr,endMetricPtr);
      }
      tableDef=definition;
      fieldDetected=false;
      metric=new AggregationMetric(definition);
      continue;
    }
    if (item.item.getType().equals(SemanticNames.TRUNCATE_SUBFIELD_VALUE)) {
      metric.subField=AggregationGroup.SubField.valueOf(item.item.getValue());
      continue;
    }
    if (item.item.getType().equals(""String_Node_Str"") && item.item.getValue().equals(""String_Node_Str"")) {
      while (!operations.isEmpty()) {
        doOperation(operations.pop(),expressions,operations);
      }
      MetricExpression me=expressions.pop();
      if (!expressions.isEmpty())       throw new IllegalArgumentException(""String_Node_Str"");
      resultList.add(me);
      tableDef=definition;
      fieldDetected=false;
      metric=new AggregationMetric(definition);
      continue;
    }
    if (fieldDetected)     throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(metric.items));
    AggregationGroupItem ai=new AggregationGroupItem();
    if (metric.items == null)     metric.items=new ArrayList<AggregationGroupItem>();
    metric.items.add(ai);
    ai.name=item.item.getValue();
    if (tableDef != null) {
      FieldDefinition fd=tableDef.getFieldDef(ai.name);
      ai.fieldDef=fd;
      if (fd == null) {
        if (i != (items.size() - 1)) {
          throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(metric.items));
        }
        if (!QueryUtils.isSystemField(ai.name)) {
          throw new IllegalArgumentException(""String_Node_Str"" + ai.name);
        }
      }
      if (tableDef.isLinkField(ai.name) || fd.isXLinkField()) {
        ai.isLink=true;
        if (fieldDetected)         throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(metric.items));
        tableDef=tableDef.getLinkExtentTableDef(fd);
        if (tableDef == null) {
          throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(metric.items));
        }
      }
 else {
        if (fd != null && fd.getType() == FieldType.GROUP)         throw new IllegalArgumentException(""String_Node_Str"");
        fieldDetected=true;
      }
      ai.tableDef=tableDef;
    }
    if (item.queryItems != null) {
      if (ai.isLink) {
        for (int j=0; j < item.queryItems.size(); j++) {
          ArrayList<GrammarItem> filterItems=item.queryItems.get(j);
          ai.query=CompileQuery(tableDef,ai.query,filterItems);
        }
      }
 else {
        throw new IllegalArgumentException(ai.name + ""String_Node_Str"");
      }
    }
  }
  while (!operations.isEmpty()) {
    doOperation(operations.pop(),expressions,operations);
  }
  MetricExpression me=expressions.pop();
  if (!expressions.isEmpty())   throw new IllegalArgumentException(""String_Node_Str"");
  resultList.add(me);
  return resultList;
}","private static ArrayList<MetricExpression> BuildMetricsExpression(Context context,TableDefinition definition){
  if (context == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (context.items.isEmpty())   return null;
  AggregationMetric metric=new AggregationMetric(definition);
  ArrayList<Item> items=extractMetricTokens(context);
  TableDefinition tableDef=definition;
  boolean fieldDetected=false;
  int ptr=0;
  int endMetricPtr=0;
  ArrayList<MetricExpression> resultList=new ArrayList<MetricExpression>();
  Stack<MetricExpression> expressions=new Stack<MetricExpression>();
  Stack<String> operations=new Stack<String>();
  for (int i=0; i < items.size(); i++) {
    Item item=items.get(i);
    if (item.item.getType().equals(""String_Node_Str"")) {
      pushOp(item.item.getValue(),expressions,operations);
      continue;
    }
    if (item.item.getType().equals(""String_Node_Str"")) {
      operations.push(item.item.getValue());
      continue;
    }
    if (item.item.getType().equals(""String_Node_Str"") && item.item.getValue().equals(""String_Node_Str"")) {
      String unit2=operations.pop();
      String unit1=operations.pop();
      String unit=operations.pop();
      GregorianCalendar c1, c2;
      try {
        c1=Utils.parseDate(unit1);
      }
 catch (      Exception e) {
        throw new IllegalArgumentException(""String_Node_Str"" + unit1);
      }
      try {
        c2=Utils.parseDate(unit2);
      }
 catch (      Exception e) {
        throw new IllegalArgumentException(""String_Node_Str"" + unit2);
      }
      LongIntegerExpression le=new LongIntegerExpression();
      le.value=TimeUtils.getTimeDifference(unit,c1,c2);
      expressions.push(le);
      metric=null;
      continue;
    }
    if (item.item.getType().equals(""String_Node_Str"")) {
      endMetricPtr=item.item.getPtr();
      continue;
    }
    if (item.item.getType().equals(""String_Node_Str"")) {
      NumberExpression ne=new NumberExpression();
      try {
        ne.value=Double.parseDouble(item.item.getValue());
      }
 catch (      Exception e) {
        throw new IllegalArgumentException(""String_Node_Str"" + item.item.getValue() + ""String_Node_Str"");
      }
      expressions.push(ne);
      metric=null;
      continue;
    }
    if (item.item.getType().equals(SemanticNames.AGGREGATION_METRIC_FUNCTION_NAME)) {
      ptr=item.item.getPtr();
      metric.function=item.item.getValue();
      if (item.queryItems != null) {
        for (int j=0; j < item.queryItems.size(); j++) {
          ArrayList<GrammarItem> filterItems=item.queryItems.get(j);
          metric.filter=CompileQuery(tableDef,metric.filter,filterItems);
        }
      }
      continue;
    }
    if (item.item.getType().equals(""String_Node_Str"") && item.item.getValue().equals(""String_Node_Str"")) {
      if (metric != null) {
        expressions.push(metric);
        metric.sourceText=context.inputString.substring(ptr,endMetricPtr);
      }
      tableDef=definition;
      fieldDetected=false;
      metric=new AggregationMetric(definition);
      continue;
    }
    if (item.item.getType().equals(SemanticNames.TRUNCATE_SUBFIELD_VALUE)) {
      metric.subField=AggregationGroup.SubField.valueOf(item.item.getValue());
      continue;
    }
    if (item.item.getType().equals(""String_Node_Str"") && item.item.getValue().equals(""String_Node_Str"")) {
      while (!operations.isEmpty()) {
        doOperation(operations.pop(),expressions,operations);
      }
      MetricExpression me=expressions.pop();
      if (!expressions.isEmpty())       throw new IllegalArgumentException(""String_Node_Str"");
      resultList.add(me);
      tableDef=definition;
      fieldDetected=false;
      metric=new AggregationMetric(definition);
      continue;
    }
    if (fieldDetected)     throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(metric.items));
    AggregationGroupItem ai=new AggregationGroupItem();
    if (metric.items == null)     metric.items=new ArrayList<AggregationGroupItem>();
    metric.items.add(ai);
    ai.name=item.item.getValue();
    if (tableDef != null) {
      FieldDefinition fd=tableDef.getFieldDef(ai.name);
      ai.fieldDef=fd;
      if (fd == null) {
        if (i != (items.size() - 1)) {
          throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(metric.items));
        }
        if (!QueryUtils.isSystemField(ai.name)) {
          throw new IllegalArgumentException(""String_Node_Str"" + ai.name);
        }
      }
      if (tableDef.isLinkField(ai.name) || (fd != null && fd.isXLinkField())) {
        ai.isLink=true;
        if (fieldDetected)         throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(metric.items));
        tableDef=tableDef.getLinkExtentTableDef(fd);
        if (tableDef == null) {
          throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(metric.items));
        }
      }
 else {
        if (fd != null && fd.getType() == FieldType.GROUP)         throw new IllegalArgumentException(""String_Node_Str"");
        fieldDetected=true;
      }
      ai.tableDef=tableDef;
    }
    if (item.queryItems != null) {
      if (ai.isLink) {
        for (int j=0; j < item.queryItems.size(); j++) {
          ArrayList<GrammarItem> filterItems=item.queryItems.get(j);
          ai.query=CompileQuery(tableDef,ai.query,filterItems);
        }
      }
 else {
        throw new IllegalArgumentException(ai.name + ""String_Node_Str"");
      }
    }
  }
  while (!operations.isEmpty()) {
    doOperation(operations.pop(),expressions,operations);
  }
  MetricExpression me=expressions.pop();
  if (!expressions.isEmpty())   throw new IllegalArgumentException(""String_Node_Str"");
  resultList.add(me);
  return resultList;
}",0.9986139986139986
29917,"private static SortOrder BuildSort(Context context,TableDefinition definition){
  if (context == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (context.items.isEmpty())   return null;
  SortOrder result=new SortOrder();
  ArrayList<Item> items=extractTokens(context);
  TableDefinition tableDef=definition;
  boolean fieldDetected=false;
  for (int i=0; i < items.size(); i++) {
    Item item=items.get(i);
    if (item.item.getType().equals(SemanticNames.DESC)) {
      result.ascending=false;
      continue;
    }
    if (item.item.getType().equals(SemanticNames.ASC)) {
      result.ascending=true;
      continue;
    }
    if (fieldDetected)     throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(result.items));
    AggregationGroupItem ai=new AggregationGroupItem();
    if (result.items == null)     result.items=new ArrayList<AggregationGroupItem>();
    result.items.add(ai);
    ai.name=item.item.getValue();
    if (tableDef != null) {
      FieldDefinition fd=tableDef.getFieldDef(ai.name);
      ai.fieldDef=fd;
      if (fd == null) {
        if (i != (items.size() - 1)) {
          throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(result.items));
        }
        if (!QueryUtils.isSystemField(ai.name)) {
          throw new IllegalArgumentException(""String_Node_Str"" + ai.name);
        }
      }
      if (tableDef.isLinkField(ai.name)) {
        ai.isLink=true;
        if (fieldDetected)         throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(result.items));
        tableDef=tableDef.getLinkExtentTableDef(fd);
        if (tableDef == null) {
          throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(result.items));
        }
      }
 else {
        if (fd != null && fd.getType() == FieldType.GROUP)         throw new IllegalArgumentException(""String_Node_Str"");
        fieldDetected=true;
      }
      ai.tableDef=tableDef;
    }
  }
  if (!fieldDetected)   throw new IllegalArgumentException(""String_Node_Str"");
  return result;
}","private static SortOrder BuildSort(Context context,TableDefinition definition){
  if (context == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (context.items.isEmpty())   return null;
  SortOrder result=new SortOrder();
  ArrayList<Item> items=extractTokens(context);
  TableDefinition tableDef=definition;
  boolean fieldDetected=false;
  for (int i=0; i < items.size(); i++) {
    Item item=items.get(i);
    if (item.item.getType().equals(SemanticNames.DESC)) {
      result.ascending=false;
      continue;
    }
    if (item.item.getType().equals(SemanticNames.ASC)) {
      result.ascending=true;
      continue;
    }
    if (fieldDetected)     throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(result.items));
    AggregationGroupItem ai=new AggregationGroupItem();
    if (result.items == null)     result.items=new ArrayList<AggregationGroupItem>();
    result.items.add(ai);
    ai.name=item.item.getValue();
    if (tableDef != null) {
      FieldDefinition fd=tableDef.getFieldDef(ai.name);
      ai.fieldDef=fd;
      if (fd == null) {
        if (i != (items.size() - 1)) {
          throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(result.items));
        }
        if (!QueryUtils.isSystemField(ai.name)) {
          throw new IllegalArgumentException(""String_Node_Str"" + ai.name);
        }
      }
      if (tableDef.isLinkField(ai.name) || (fd != null && fd.isXLinkField())) {
        ai.isLink=true;
        if (fieldDetected)         throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(result.items));
        tableDef=tableDef.getLinkExtentTableDef(fd);
        if (tableDef == null) {
          throw new IllegalArgumentException(""String_Node_Str"" + QueryUtils.FullLinkName(result.items));
        }
      }
 else {
        if (fd != null && fd.getType() == FieldType.GROUP)         throw new IllegalArgumentException(""String_Node_Str"");
        fieldDetected=true;
      }
      ai.tableDef=tableDef;
    }
  }
  if (!fieldDetected)   throw new IllegalArgumentException(""String_Node_Str"");
  return result;
}",0.991283863368669
29918,"public Query visit(Stack<String> links,Query query){
  if (query instanceof BinaryQuery) {
    BinaryQuery bq=(BinaryQuery)query;
    if (bq.field != null) {
      if (bq.field.equals(""String_Node_Str"")) {
        if (bq.operation.equals(BinaryQuery.CONTAINS)) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
        IdQuery id=new IdQuery(bq.value);
        return id;
      }
      if (BinaryQuery.EQUALS.equals(bq.operation)) {
        if (tableDefinition != null) {
          if (!links.empty()) {
            ArrayList<String> path=QueryUtils.GetLinkPath(links);
            path.add(bq.field);
            if (QueryUtils.IsLink(path,tableDefinition)) {
              LinkIdQuery li=new LinkIdQuery(LinkQuery.ANY,bq.field,bq.value);
              return li;
            }
          }
 else {
            if (tableDefinition.isLinkField(bq.field)) {
              LinkIdQuery li=new LinkIdQuery(LinkQuery.ANY,bq.field,bq.value);
              return li;
            }
          }
        }
      }
    }
  }
  if (query instanceof LinkQuery || query instanceof TransitiveLinkQuery) {
    if (tableDefinition != null) {
      ArrayList<String> path=new ArrayList<String>();
      if (!links.empty()) {
        path=QueryUtils.GetLinkPath(links);
      }
      String linkName=""String_Node_Str"";
      if (query instanceof LinkQuery) {
        linkName=((LinkQuery)query).link;
      }
 else {
        linkName=((TransitiveLinkQuery)query).link;
      }
      path.add(linkName);
switch (QueryUtils.GetFieldType(path,tableDefinition)) {
case Link:
        break;
case Group:
      FieldDefinition groupfield=QueryUtils.GetField(path,tableDefinition);
    ArrayList<String> nestedLinks=QueryUtils.GetNestedFields(groupfield);
  if (nestedLinks.size() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + groupfield.getName() + ""String_Node_Str""+ QueryUtils.LinkName(path)+ ""String_Node_Str"");
  }
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + linkName + ""String_Node_Str""+ QueryUtils.LinkName(path)+ ""String_Node_Str"");
}
}
}
if (query instanceof LinkIdQuery) {
if (tableDefinition != null) {
LinkIdQuery q=(LinkIdQuery)query;
ArrayList<String> path=new ArrayList<String>();
if (!links.empty()) {
path=QueryUtils.GetLinkPath(links);
}
path.add(q.link);
if (!QueryUtils.IsLink(path,tableDefinition)) {
BinaryQuery bq=new BinaryQuery(BinaryQuery.EQUALS,q.link,q.id);
return bq;
}
}
}
return query;
}","public Query visit(Stack<String> links,Query query){
  if (query instanceof BinaryQuery) {
    BinaryQuery bq=(BinaryQuery)query;
    if (bq.field != null) {
      if (bq.field.equals(""String_Node_Str"")) {
        if (bq.operation.equals(BinaryQuery.CONTAINS)) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
        IdQuery id=new IdQuery(bq.value);
        return id;
      }
      if (BinaryQuery.EQUALS.equals(bq.operation)) {
        if (tableDefinition != null) {
          if (!links.empty()) {
            ArrayList<String> path=QueryUtils.GetLinkPath(links);
            path.add(bq.field);
            if (QueryUtils.IsLink(path,tableDefinition)) {
              LinkIdQuery li=new LinkIdQuery(LinkQuery.ANY,bq.field,bq.value);
              return li;
            }
          }
 else {
            FieldDefinition fd=tableDefinition.getFieldDef(bq.field);
            if (tableDefinition.isLinkField(bq.field) || (fd != null && fd.isXLinkField())) {
              LinkIdQuery li=new LinkIdQuery(LinkQuery.ANY,bq.field,bq.value);
              return li;
            }
          }
        }
      }
    }
  }
  if (query instanceof LinkQuery || query instanceof TransitiveLinkQuery) {
    if (tableDefinition != null) {
      ArrayList<String> path=new ArrayList<String>();
      if (!links.empty()) {
        path=QueryUtils.GetLinkPath(links);
      }
      String linkName=""String_Node_Str"";
      if (query instanceof LinkQuery) {
        linkName=((LinkQuery)query).link;
      }
 else {
        linkName=((TransitiveLinkQuery)query).link;
      }
      path.add(linkName);
switch (QueryUtils.GetFieldType(path,tableDefinition)) {
case Link:
        break;
case Group:
      FieldDefinition groupfield=QueryUtils.GetField(path,tableDefinition);
    ArrayList<String> nestedLinks=QueryUtils.GetNestedFields(groupfield);
  if (nestedLinks.size() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + groupfield.getName() + ""String_Node_Str""+ QueryUtils.LinkName(path)+ ""String_Node_Str"");
  }
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + linkName + ""String_Node_Str""+ QueryUtils.LinkName(path)+ ""String_Node_Str"");
}
}
}
if (query instanceof LinkIdQuery) {
if (tableDefinition != null) {
LinkIdQuery q=(LinkIdQuery)query;
ArrayList<String> path=new ArrayList<String>();
if (!links.empty()) {
path=QueryUtils.GetLinkPath(links);
}
path.add(q.link);
if (!QueryUtils.IsLink(path,tableDefinition)) {
BinaryQuery bq=new BinaryQuery(BinaryQuery.EQUALS,q.link,q.id);
return bq;
}
}
}
return query;
}",0.9688553858361436
29919,"protected static void CheckPath(ArrayList<String> path,int depth,TableDefinition tableDefinition,boolean lastLink){
  TableDefinition tableDef=tableDefinition;
  if (tableDef == null)   return;
  for (int i=0; i < depth - 1; i++) {
    String name=path.get(i);
    if (tableDef.isLinkField(name)) {
      FieldDefinition fd=tableDef.getFieldDef(name);
      if (fd == null)       throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      tableDef=tableDef.getLinkExtentTableDef(fd);
      if (tableDef == null)       throw new IllegalArgumentException(""String_Node_Str"" + name);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
  }
  String lname=path.get(depth);
  boolean lasttIsLink=tableDef.isLinkField(lname);
  if (lastLink) {
    if (!lasttIsLink)     throw new IllegalArgumentException(""String_Node_Str"" + lname + ""String_Node_Str"");
  }
 else {
    if (lasttIsLink)     throw new IllegalArgumentException(""String_Node_Str"" + lname + ""String_Node_Str"");
  }
}","protected static void CheckPath(ArrayList<String> path,int depth,TableDefinition tableDefinition,boolean lastLink){
  TableDefinition tableDef=tableDefinition;
  if (tableDef == null)   return;
  for (int i=0; i < depth - 1; i++) {
    String name=path.get(i);
    FieldDefinition fd=tableDef.getFieldDef(name);
    if (fd == null)     throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    if (tableDef.isLinkField(name) || (fd.isXLinkField())) {
      tableDef=tableDef.getLinkExtentTableDef(fd);
      if (tableDef == null)       throw new IllegalArgumentException(""String_Node_Str"" + name);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
  }
  String lname=path.get(depth);
  FieldDefinition fd=tableDef.getFieldDef(lname);
  boolean lasttIsLink=tableDef.isLinkField(lname) || (fd != null && fd.isXLinkField());
  if (lastLink) {
    if (!lasttIsLink)     throw new IllegalArgumentException(""String_Node_Str"" + lname + ""String_Node_Str"");
  }
 else {
    if (lasttIsLink)     throw new IllegalArgumentException(""String_Node_Str"" + lname + ""String_Node_Str"");
  }
}",0.8835740072202166
29920,"protected static TableDefinition GetTableDefinition(ArrayList<String> path,int index,TableDefinition tableDefinition){
  if (tableDefinition == null)   return null;
  FieldDefinition fd=null;
  TableDefinition tableDef=tableDefinition;
  for (int i=0; i < index; i++) {
    if (tableDef == null)     return null;
    fd=tableDef.getFieldDef(path.get(i));
    if (tableDef.isLinkField(path.get(i))) {
      if (fd == null)       return null;
      tableDef=tableDef.getLinkExtentTableDef(fd);
    }
 else {
      if (fd != null) {
        if (fd.isGroupField()) {
          ArrayList<String> nested=GetNestedFields(fd);
          fd=tableDef.getFieldDef(nested.get(0));
          if (tableDef.isLinkField(nested.get(0)))           tableDef=tableDef.getLinkExtentTableDef(fd);
 else           return tableDef;
        }
      }
    }
  }
  return tableDef;
}","protected static TableDefinition GetTableDefinition(ArrayList<String> path,int index,TableDefinition tableDefinition){
  if (tableDefinition == null)   return null;
  FieldDefinition fd=null;
  TableDefinition tableDef=tableDefinition;
  for (int i=0; i < index; i++) {
    if (tableDef == null)     return null;
    fd=tableDef.getFieldDef(path.get(i));
    if (tableDef.isLinkField(path.get(i)) || (fd != null && fd.isXLinkField())) {
      if (fd == null)       return null;
      tableDef=tableDef.getLinkExtentTableDef(fd);
    }
 else {
      if (fd != null) {
        if (fd.isGroupField()) {
          ArrayList<String> nested=GetNestedFields(fd);
          fd=tableDef.getFieldDef(nested.get(0));
          if (tableDef.isLinkField(nested.get(0)) || (fd != null && fd.isXLinkField()))           tableDef=tableDef.getLinkExtentTableDef(fd);
 else           return tableDef;
        }
      }
    }
  }
  return tableDef;
}",0.9585666293393056
29921,"protected static FieldDefinition GetField(ArrayList<String> path,int index,TableDefinition tableDefinition){
  if (tableDefinition == null)   return null;
  FieldDefinition fd=null;
  TableDefinition tableDef=tableDefinition;
  int current=0;
  while (true) {
    if (tableDef == null)     return null;
    fd=tableDef.getFieldDef(path.get(current));
    if (tableDef.isLinkField(path.get(current)) || (fd != null && fd.isXLinkField())) {
      if (fd == null)       return null;
      tableDef=tableDef.getLinkExtentTableDef(fd);
    }
    if (current == index)     return fd;
    if (fd != null && fd.isGroupField()) {
      ArrayList<String> nested=GetNestedFields(fd);
      fd=tableDef.getFieldDef(nested.get(0));
      if (tableDef.isLinkField(nested.get(0)))       tableDef=tableDef.getLinkExtentTableDef(fd);
    }
    current++;
  }
}","protected static FieldDefinition GetField(ArrayList<String> path,int index,TableDefinition tableDefinition){
  if (tableDefinition == null)   return null;
  FieldDefinition fd=null;
  TableDefinition tableDef=tableDefinition;
  int current=0;
  while (true) {
    if (tableDef == null)     return null;
    fd=tableDef.getFieldDef(path.get(current));
    if (tableDef.isLinkField(path.get(current)) || (fd != null && fd.isXLinkField())) {
      if (fd == null)       return null;
      tableDef=tableDef.getLinkExtentTableDef(fd);
    }
    if (current == index)     return fd;
    if (fd != null && fd.isGroupField()) {
      ArrayList<String> nested=GetNestedFields(fd);
      fd=tableDef.getFieldDef(nested.get(0));
      if (tableDef.isLinkField(nested.get(0)) || (fd != null && fd.isXLinkField()))       tableDef=tableDef.getLinkExtentTableDef(fd);
    }
    current++;
  }
}",0.9785258270458502
29922,"public static TableDefinition GetTableContext(Query q,TableDefinition definition){
  TableDefinition tableDef=definition;
  ArrayList<String> path=QueryUtils.GetPath(q,tableDef);
  for (int i=0; i < path.size(); i++) {
    FieldDefinition fd=tableDef.getFieldDef(path.get(i));
    if (fd == null) {
      if (i != (path.size() - 1)) {
        throw new IllegalArgumentException(""String_Node_Str"" + path.get(i));
      }
    }
    if (tableDef.isLinkField(path.get(i))) {
      tableDef=tableDef.getLinkExtentTableDef(fd);
      if (tableDef == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + path.get(i));
      }
    }
 else {
      if (fd != null && fd.getType() == FieldType.GROUP) {
        ArrayList<String> nestedLinks=QueryUtils.GetNestedFields(fd);
        if (nestedLinks.size() == 0) {
          throw new IllegalArgumentException(""String_Node_Str"" + fd.getName() + ""String_Node_Str""+ QueryUtils.LinkName(path)+ ""String_Node_Str"");
        }
 else {
          fd=tableDef.getFieldDef(nestedLinks.get(0));
          if (fd != null)           tableDef=tableDef.getLinkExtentTableDef(fd);
        }
      }
    }
  }
  return tableDef;
}","public static TableDefinition GetTableContext(Query q,TableDefinition definition){
  TableDefinition tableDef=definition;
  ArrayList<String> path=QueryUtils.GetPath(q,tableDef);
  for (int i=0; i < path.size(); i++) {
    FieldDefinition fd=tableDef.getFieldDef(path.get(i));
    if (fd == null) {
      if (i != (path.size() - 1)) {
        throw new IllegalArgumentException(""String_Node_Str"" + path.get(i));
      }
    }
    if (tableDef.isLinkField(path.get(i)) || (fd != null && fd.isXLinkField())) {
      tableDef=tableDef.getLinkExtentTableDef(fd);
      if (tableDef == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + path.get(i));
      }
    }
 else {
      if (fd != null && fd.getType() == FieldType.GROUP) {
        ArrayList<String> nestedLinks=QueryUtils.GetNestedFields(fd);
        if (nestedLinks.size() == 0) {
          throw new IllegalArgumentException(""String_Node_Str"" + fd.getName() + ""String_Node_Str""+ QueryUtils.LinkName(path)+ ""String_Node_Str"");
        }
 else {
          fd=tableDef.getFieldDef(nestedLinks.get(0));
          if (fd != null)           tableDef=tableDef.getLinkExtentTableDef(fd);
        }
      }
    }
  }
  return tableDef;
}",0.9843947701391818
29923,"public void next(){
  do {
    doNext();
  }
 while (doc != Integer.MAX_VALUE && num < 0);
}","public void next(){
  doNext();
}",0.528
29924,"public PathEntry(List<AggregationGroupItem> path,int index,int groupIndex,boolean isGroupPath){
  AggregationGroupItem item=path.get(index);
  this.tableDef=item.tableDef;
  this.groupIndex=groupIndex;
  name=item.name;
  query=item.query;
  if (query != null) {
    queryText=item.query.toString();
    if (USEQUERYCACHE) {
      queryCache=new LRUCache<ObjectID,Boolean>(QUERYCACHECAPACITY);
    }
    QueryExecutor qe=new QueryExecutor(tableDef);
    filter=qe.filter(item.query);
    Set<String> filterFields=new HashSet<String>();
    filter.addFields(filterFields);
    if (filterFields.contains(""String_Node_Str""))     fieldNames.add(""String_Node_Str"");
 else     fieldNames.addAll(filterFields);
  }
  nestedLinks=item.nestedLinks;
  isLink=item.isLink;
  if (index == path.size() - 1) {
    if (isLink) {
      PathEntry entry=new PathEntry(item.tableDef,groupIndex);
      entry.name=ANY;
      entry.isLink=false;
      add(entry,isGroupPath);
    }
 else     if (name != PathEntry.ANY) {
      fieldNames.add(name);
    }
  }
 else {
    add(new PathEntry(path,index + 1,groupIndex,isGroupPath),isGroupPath);
  }
}","public PathEntry(List<AggregationGroupItem> path,int index,int groupIndex,boolean isGroupPath){
  AggregationGroupItem item=path.get(index);
  this.tableDef=item.tableDef;
  this.groupIndex=groupIndex;
  name=item.name;
  nestedLinks=item.nestedLinks;
  isLink=item.isLink;
  PathEntry entry=null;
  if (index == path.size() - 1) {
    if (isLink) {
      entry=new PathEntry(item.tableDef,groupIndex);
      entry.name=ANY;
      entry.isLink=false;
      add(entry,isGroupPath);
    }
 else     if (name != PathEntry.ANY) {
      fieldNames.add(name);
    }
  }
 else {
    entry=new PathEntry(path,index + 1,groupIndex,isGroupPath);
    add(entry,isGroupPath);
  }
  if (item.query != null) {
    setQuery(item,isGroupPath ? this : entry);
  }
}",0.567769477054429
29925,"private void process(Entity obj,PathEntry entry,GroupSetEntry groupSetEntry,Set<String>[] groupKeys){
  for (  int groupIndex : entry.groupIndexes) {
    groupKeys[groupIndex].clear();
  }
  collectGroupValues(obj,entry,groupSetEntry,groupKeys);
  for (  int groupIndex : entry.groupIndexes) {
    if (groupKeys[groupIndex].size() == 0)     return;
  }
  if (entry.isLink) {
    if (entry.query != null) {
      if (!entry.checkCondition(obj)) {
        boolean result=entry.checkCondition(obj);
        if (!result)         return;
      }
    }
    for (    Entity linkedObject : obj.getLinkedEntities(entry.name,entry.fieldNames)) {
      process(linkedObject,entry.branches.get(0),groupSetEntry,groupKeys);
    }
  }
 else {
    if (entry.name == PathEntry.ANY) {
      updateMetric(obj.id().toString(),groupSetEntry,groupKeys);
    }
 else {
      String value=obj.get(entry.name);
      String[] values=value == null ? new String[]{value} : value.split(CommonDefs.MV_SCALAR_SEP_CHAR);
      for (      String collectionValue : values) {
        for (        Integer groupIndex : entry.matchingGroupIndexes) {
          groupKeys[groupIndex].clear();
          groupSetEntry.m_groupPaths[groupIndex].addValueKeys(groupKeys[groupIndex],collectionValue);
        }
        updateMetric(collectionValue,groupSetEntry,groupKeys);
      }
    }
  }
}","private void process(Entity obj,PathEntry entry,GroupSetEntry groupSetEntry,Set<String>[] groupKeys){
  for (  int groupIndex : entry.groupIndexes) {
    groupKeys[groupIndex].clear();
  }
  collectGroupValues(obj,entry,groupSetEntry,groupKeys);
  for (  int groupIndex : entry.groupIndexes) {
    if (groupKeys[groupIndex].size() == 0)     return;
  }
  if (entry.query != null) {
    if (!entry.checkCondition(obj)) {
      return;
    }
  }
  if (entry.isLink) {
    for (    Entity linkedObject : obj.getLinkedEntities(entry.name,entry.fieldNames)) {
      process(linkedObject,entry.branches.get(0),groupSetEntry,groupKeys);
    }
  }
 else {
    if (entry.name == PathEntry.ANY) {
      updateMetric(obj.id().toString(),groupSetEntry,groupKeys);
    }
 else {
      String value=obj.get(entry.name);
      String[] values=value == null ? new String[]{value} : value.split(CommonDefs.MV_SCALAR_SEP_CHAR);
      for (      String collectionValue : values) {
        for (        Integer groupIndex : entry.matchingGroupIndexes) {
          groupKeys[groupIndex].clear();
          groupSetEntry.m_groupPaths[groupIndex].addValueKeys(groupKeys[groupIndex],collectionValue);
        }
        updateMetric(collectionValue,groupSetEntry,groupKeys);
      }
    }
  }
}",0.9400534555173732
29926,"public static void checkContainingPreservedColumns(Map<byte[],NavigableSet<byte[]>> familyMap) throws IOException {
  for (  Entry<byte[],NavigableSet<byte[]>> entry : familyMap.entrySet()) {
    byte[] family=entry.getKey();
    for (    byte[] qualifier : entry.getValue()) {
      checkContainingPreservedColumn(family,qualifier);
    }
  }
}","public static void checkContainingPreservedColumns(Map<byte[],NavigableSet<byte[]>> familyMap) throws IOException {
  for (  Entry<byte[],NavigableSet<byte[]>> entry : familyMap.entrySet()) {
    byte[] family=entry.getKey();
    if (entry.getValue() != null) {
      for (      byte[] qualifier : entry.getValue()) {
        checkContainingPreservedColumn(family,qualifier);
      }
    }
  }
}",0.918918918918919
29927,"@Test public void testCheckContainingPreservedColumns(){
  Map<byte[],NavigableSet<byte[]>> familyMap=new HashMap<byte[],NavigableSet<byte[]>>();
  familyMap.put(FAMILY,new TreeSet<byte[]>(Bytes.BYTES_COMPARATOR));
  familyMap.get(FAMILY).add(QUALIFIER);
  try {
    ThemisRead.checkContainingPreservedColumns(familyMap);
  }
 catch (  IOException e) {
    Assert.fail();
  }
  familyMap.get(FAMILY).add(ColumnUtil.getPutColumn(new Column(FAMILY,QUALIFIER)).getQualifier());
  try {
    ThemisRead.checkContainingPreservedColumns(familyMap);
    Assert.fail();
  }
 catch (  IOException e) {
  }
}","@Test public void testCheckContainingPreservedColumns(){
  Map<byte[],NavigableSet<byte[]>> familyMap=new HashMap<byte[],NavigableSet<byte[]>>();
  familyMap.put(FAMILY,new TreeSet<byte[]>(Bytes.BYTES_COMPARATOR));
  familyMap.get(FAMILY).add(QUALIFIER);
  familyMap.put(ANOTHER_FAMILY,null);
  try {
    ThemisRead.checkContainingPreservedColumns(familyMap);
  }
 catch (  IOException e) {
    Assert.fail();
  }
  familyMap.get(FAMILY).add(ColumnUtil.getPutColumn(new Column(FAMILY,QUALIFIER)).getQualifier());
  try {
    ThemisRead.checkContainingPreservedColumns(familyMap);
    Assert.fail();
  }
 catch (  IOException e) {
  }
}",0.969155844155844
29928,"protected static byte[] concatQualifierWithSuffix(byte[] qualifier,String suffix){
  String qualiferString=qualifier == null ? ""String_Node_Str"" : Bytes.toString(qualifier);
  return Bytes.toBytes(qualiferString + suffix);
}","protected static byte[] concatQualifierWithSuffix(byte[] qualifier,byte[] suffix){
  return qualifier == null ? qualifier : Bytes.add(qualifier,suffix);
}",0.708994708994709
29929,"public static Column getPutColumn(Column dataColumn){
  return new Column(dataColumn.getFamily(),concatQualifierWithSuffix(dataColumn.getQualifier(),PUT_QUALIFIER_SUFFIX));
}","public static Column getPutColumn(Column dataColumn){
  return new Column(dataColumn.getFamily(),concatQualifierWithSuffix(dataColumn.getQualifier(),PUT_QUALIFIER_SUFFIX_BYTES));
}",0.9830508474576272
29930,"public static Column getDeleteColumn(Column dataColumn){
  return new Column(dataColumn.getFamily(),concatQualifierWithSuffix(dataColumn.getQualifier(),DELETE_QUALIFIER_SUFFIX));
}","public static Column getDeleteColumn(Column dataColumn){
  return new Column(dataColumn.getFamily(),concatQualifierWithSuffix(dataColumn.getQualifier(),DELETE_QUALIFIER_SUFFIX_BYTES));
}",0.9836065573770492
29931,"protected void prewriteRowWithLockClean(byte[] tableName,RowMutation mutation,boolean containPrimary) throws IOException {
  ThemisLock lock=prewriteRow(tableName,mutation,containPrimary);
  if (lock != null) {
    if (disableLockClean) {
      throw new LockConflictException(""String_Node_Str"" + lock.getColumn() + ""String_Node_Str""+ lock);
    }
    if (!ColumnUtil.isDataColumn(lock.getColumn())) {
      throw new ThemisFatalException(""String_Node_Str"" + Bytes.toString(tableName) + ""String_Node_Str""+ mutation+ ""String_Node_Str""+ lock.getColumn());
    }
    lockCleaner.tryToCleanLock(lock);
    lock=prewriteRow(tableName,mutation,containPrimary);
    if (lock != null) {
      throw new LockConflictException(""String_Node_Str"" + lock.getColumn() + ""String_Node_Str""+ lock);
    }
  }
}","protected void prewriteRowWithLockClean(byte[] tableName,RowMutation mutation,boolean containPrimary) throws IOException {
  ThemisLock lock=prewriteRow(tableName,mutation,containPrimary);
  if (lock != null) {
    if (disableLockClean) {
      throw new LockConflictException(""String_Node_Str"" + lock.getColumn() + ""String_Node_Str""+ lock);
    }
    if (!ColumnUtil.isDataColumn(lock.getColumn())) {
      throw new ThemisFatalException(""String_Node_Str"" + Bytes.toString(tableName) + ""String_Node_Str""+ mutation+ ""String_Node_Str""+ lock.getColumn());
    }
    lockCleaner.checkLockExpiredAndTryToCleanLock(lock);
    lock=prewriteRow(tableName,mutation,containPrimary);
    if (lock != null) {
      throw new LockConflictException(""String_Node_Str"" + lock.getColumn() + ""String_Node_Str""+ lock);
    }
  }
}",0.9869158878504672
29932,"public void tryToCleanLocks(byte[] tableName,List<KeyValue> lockColumns) throws IOException {
  List<ThemisLock> locks=constructLocks(tableName,lockColumns,cpClient);
  long startTs=lockColumns.get(0).getTimestamp();
  for (  ThemisLock lock : locks) {
    if (tryToCleanLock(lock)) {
      LOG.warn(""String_Node_Str"" + startTs + ""String_Node_Str""+ lock+ ""String_Node_Str""+ lock.getTimestamp());
    }
  }
}","public void tryToCleanLocks(byte[] tableName,List<KeyValue> lockColumns) throws IOException {
  List<ThemisLock> locks=constructLocks(tableName,lockColumns,cpClient,clientLockTTl);
  long startTs=lockColumns.get(0).getTimestamp();
  for (  ThemisLock lock : locks) {
    if (tryToCleanLock(lock)) {
      LOG.warn(""String_Node_Str"" + startTs + ""String_Node_Str""+ lock+ ""String_Node_Str""+ lock.getTimestamp());
    }
  }
}",0.9830917874396136
29933,"protected static void checkLockExpired(ThemisLock lock,ThemisCoprocessorClient cpClient,int clientLockTTL) throws IOException {
  if (clientLockTTL == 0) {
    lock.setLockExpired(cpClient.isLockExpired(lock.getColumn().getTableName(),lock.getColumn().getRow(),lock.getTimestamp()));
  }
 else {
    lock.setLockExpired(TransactionTTL.isLockExpired(lock.getTimestamp(),clientLockTTL));
    LOG.info(""String_Node_Str"" + lock + ""String_Node_Str""+ clientLockTTL+ ""String_Node_Str""+ TransactionTTL.timestampType);
  }
}","public static void checkLockExpired(ThemisLock lock,ThemisCoprocessorClient cpClient,int clientLockTTL) throws IOException {
  if (clientLockTTL == 0) {
    lock.setLockExpired(cpClient.isLockExpired(lock.getColumn().getTableName(),lock.getColumn().getRow(),lock.getTimestamp()));
  }
 else {
    lock.setLockExpired(TransactionTTL.isLockExpired(lock.getTimestamp(),clientLockTTL));
    LOG.info(""String_Node_Str"" + lock + ""String_Node_Str""+ clientLockTTL+ ""String_Node_Str""+ TransactionTTL.timestampType);
  }
}",0.9873417721518988
29934,"@Test public void testConstructLocks() throws IOException {
  ThemisLock expectLock=getPrimaryLock();
  List<KeyValue> kvs=new ArrayList<KeyValue>();
  kvs.add(getLockKv(KEYVALUE,ThemisLock.toByte(expectLock)));
  List<ThemisLock> locks=LockCleaner.constructLocks(TABLENAME,kvs,cpClient);
  Assert.assertEquals(1,locks.size());
  Assert.assertTrue(expectLock.equals(locks.get(0)));
  Assert.assertTrue(COLUMN.equals(locks.get(0).getColumn()));
  kvs.add(KEYVALUE);
  try {
    LockCleaner.constructLocks(TABLENAME,kvs,cpClient);
    Assert.fail();
  }
 catch (  ThemisFatalException e) {
  }
}","@Test public void testConstructLocks() throws IOException {
  ThemisLock expectLock=getPrimaryLock();
  List<KeyValue> kvs=new ArrayList<KeyValue>();
  kvs.add(getLockKv(KEYVALUE,ThemisLock.toByte(expectLock)));
  String rawClientLockTTL=conf.get(TransactionConstant.CLIENT_LOCK_TTL_KEY);
  int clientLockTTL=10;
  Threads.sleep(clientLockTTL);
  Assert.assertTrue(System.currentTimeMillis() - expectLock.getTimestamp() > clientLockTTL);
  List<ThemisLock> locks=LockCleaner.constructLocks(TABLENAME,kvs,cpClient,clientLockTTL);
  Assert.assertEquals(1,locks.size());
  Assert.assertTrue(expectLock.equals(locks.get(0)));
  Assert.assertTrue(COLUMN.equals(locks.get(0).getColumn()));
  Assert.assertTrue(locks.get(0).isLockExpired());
  conf.set(TransactionConstant.CLIENT_LOCK_TTL_KEY,rawClientLockTTL != null ? rawClientLockTTL : ""String_Node_Str"");
  kvs.add(KEYVALUE);
  try {
    LockCleaner.constructLocks(TABLENAME,kvs,cpClient,0);
    Assert.fail();
  }
 catch (  ThemisFatalException e) {
  }
}",0.7431077694235589
29935,"public void processConcreteFilter(Filter filter) throws IOException {
  Class<? extends Filter> filterCls=filter.getClass();
  if (ThemisCpUtil.DISALLOWD_FILTERS.contains(filterCls)) {
    throw new IOException(""String_Node_Str"" + filter + ""String_Node_Str""+ ThemisCpUtil.getDisallowedFilterClassNameString());
  }
}","public void processConcreteFilter(Filter filter) throws IOException {
  Class<? extends Filter> filterCls=filter.getClass();
  if (ThemisCpUtil.DISALLOWD_FILTERS.contains(filterCls)) {
    throw new IOException(""String_Node_Str"" + filter.getClass().getName() + ""String_Node_Str""+ ThemisCpUtil.getDisallowedFilterClassNameString());
  }
}",0.9678407350689128
29936,"public ThemisRead setFilter(Filter filter) throws IOException {
  ThemisCpUtil.processFilters(filter,new FilterCallable(){
    public void processConcreteFilter(    Filter filter) throws IOException {
      Class<? extends Filter> filterCls=filter.getClass();
      if (ThemisCpUtil.DISALLOWD_FILTERS.contains(filterCls)) {
        throw new IOException(""String_Node_Str"" + filter + ""String_Node_Str""+ ThemisCpUtil.getDisallowedFilterClassNameString());
      }
    }
  }
);
  return setFilterWithoutCheck(filter);
}","public ThemisRead setFilter(Filter filter) throws IOException {
  ThemisCpUtil.processFilters(filter,new FilterCallable(){
    public void processConcreteFilter(    Filter filter) throws IOException {
      Class<? extends Filter> filterCls=filter.getClass();
      if (ThemisCpUtil.DISALLOWD_FILTERS.contains(filterCls)) {
        throw new IOException(""String_Node_Str"" + filter.getClass().getName() + ""String_Node_Str""+ ThemisCpUtil.getDisallowedFilterClassNameString());
      }
    }
  }
);
  return setFilterWithoutCheck(filter);
}",0.98005698005698
29937,"@Test public void testScanWithLockClean() throws Exception {
  Mockito.when(mockRegister.isWorkerAlive(TestBase.CLIENT_TEST_ADDRESS)).thenReturn(false);
  prepareScanData(TRANSACTION_COLUMNS);
  writeLockAndData(COLUMN,prewriteTs - 5);
  ThemisScan pScan=prepareScan(TRANSACTION_COLUMNS);
  pScan.setCaching(10);
  ThemisScanner scanner=transaction.getScanner(TABLENAME,pScan);
  checkScanRow(new ColumnCoordinate[]{COLUMN_WITH_ANOTHER_ROW},scanner.next());
  checkResultForROW(scanner.next());
  checkAndCloseScanner(scanner);
  writeLockAndData(COLUMN,prewriteTs - 4);
  scanner=transaction.getScanner(TABLENAME,pScan);
  checkScanRow(new ColumnCoordinate[]{COLUMN_WITH_ANOTHER_ROW},scanner.next());
  Mockito.when(mockRegister.isWorkerAlive(TestBase.CLIENT_TEST_ADDRESS)).thenReturn(true);
  try {
    scanner.next();
    Assert.fail();
  }
 catch (  LockConflictException e) {
  }
 finally {
    scanner.close();
  }
  scanner=transaction.getScanner(TABLENAME,new ThemisScan(ROW,ROW).addFamily(ANOTHER_FAMILY));
  checkScanRow(new ColumnCoordinate[]{COLUMN_WITH_ANOTHER_FAMILY},scanner.next());
  checkAndCloseScanner(scanner);
  scanner=transaction.getScanner(TABLENAME,new ThemisScan(ROW,ROW).addFamily(FAMILY));
  Mockito.when(mockRegister.isWorkerAlive(TestBase.CLIENT_TEST_ADDRESS)).thenReturn(true);
  try {
    scanner.next();
    Assert.fail();
  }
 catch (  LockConflictException e) {
  }
 finally {
    scanner.close();
  }
  scanner=transaction.getScanner(TABLENAME,new ThemisScan(ROW,ROW));
  Mockito.when(mockRegister.isWorkerAlive(TestBase.CLIENT_TEST_ADDRESS)).thenReturn(true);
  try {
    scanner.next();
    Assert.fail();
  }
 catch (  LockConflictException e) {
  }
 finally {
    scanner.close();
  }
  scanner=transaction.getScanner(TABLENAME,new ThemisScan(ROW,ROW));
  Mockito.when(mockRegister.isWorkerAlive(TestBase.CLIENT_TEST_ADDRESS)).thenReturn(false);
  checkResultForROW(scanner.next());
  checkAndCloseScanner(scanner);
}","@Test public void testScanWithLockClean() throws Exception {
  Mockito.when(mockRegister.isWorkerAlive(TestBase.CLIENT_TEST_ADDRESS)).thenReturn(false);
  prepareScanData(TRANSACTION_COLUMNS);
  writeLockAndData(COLUMN,prewriteTs - 5);
  ThemisScan pScan=prepareScan(TRANSACTION_COLUMNS);
  pScan.setCaching(10);
  ThemisScanner scanner=transaction.getScanner(TABLENAME,pScan);
  checkScanRow(new ColumnCoordinate[]{COLUMN_WITH_ANOTHER_ROW},scanner.next());
  checkResultForROW(scanner.next());
  checkAndCloseScanner(scanner);
  writeLockAndData(COLUMN,prewriteTs - 4);
  scanner=transaction.getScanner(TABLENAME,pScan);
  checkScanRow(new ColumnCoordinate[]{COLUMN_WITH_ANOTHER_ROW},scanner.next());
  Mockito.when(mockRegister.isWorkerAlive(TestBase.CLIENT_TEST_ADDRESS)).thenReturn(true);
  try {
    scanner.next();
    Assert.fail();
  }
 catch (  LockConflictException e) {
  }
 finally {
    scanner.close();
  }
  scanner=transaction.getScanner(TABLENAME,new ThemisScan(ROW,ROW).addFamily(ANOTHER_FAMILY));
  checkScanRow(new ColumnCoordinate[]{COLUMN_WITH_ANOTHER_FAMILY},scanner.next());
  checkAndCloseScanner(scanner);
  scanner=transaction.getScanner(TABLENAME,new ThemisScan(ROW,ROW).addFamily(FAMILY));
  Mockito.when(mockRegister.isWorkerAlive(TestBase.CLIENT_TEST_ADDRESS)).thenReturn(true);
  try {
    scanner.next();
    Assert.fail();
  }
 catch (  LockConflictException e) {
  }
 finally {
    scanner.close();
  }
  scanner=transaction.getScanner(TABLENAME,new ThemisScan(ROW,ROW).addFamily(ANOTHER_FAMILY).addColumn(FAMILY,ANOTHER_QUALIFIER));
  checkScanRow(new ColumnCoordinate[]{COLUMN_WITH_ANOTHER_FAMILY,COLUMN_WITH_ANOTHER_QUALIFIER},scanner.next());
  checkAndCloseScanner(scanner);
  scanner=transaction.getScanner(TABLENAME,new ThemisScan(ROW,ROW));
  Mockito.when(mockRegister.isWorkerAlive(TestBase.CLIENT_TEST_ADDRESS)).thenReturn(true);
  try {
    scanner.next();
    Assert.fail();
  }
 catch (  LockConflictException e) {
  }
 finally {
    scanner.close();
  }
  scanner=transaction.getScanner(TABLENAME,new ThemisScan(ROW,ROW));
  Mockito.when(mockRegister.isWorkerAlive(TestBase.CLIENT_TEST_ADDRESS)).thenReturn(false);
  checkResultForROW(scanner.next());
  checkAndCloseScanner(scanner);
}",0.9339375149057954
29938,"public static void addLockAndWriteColumnToScan(Column column,Scan scan){
  Column lockColumn=ColumnUtil.getLockColumn(column);
  scan.addColumn(lockColumn.getFamily(),lockColumn.getQualifier());
  Column writeColumn=ColumnUtil.getPutColumn(column);
  scan.addColumn(writeColumn.getFamily(),writeColumn.getQualifier());
  Column deleteColumn=ColumnUtil.getDeleteColumn(column);
  scan.addColumn(deleteColumn.getFamily(),deleteColumn.getQualifier());
}","public static void addLockAndWriteColumnToScan(Column column,Scan scan){
  if (!(scan.getFamilyMap().containsKey(ColumnUtil.LOCK_FAMILY_NAME) && scan.getFamilyMap().get(ColumnUtil.LOCK_FAMILY_NAME) == null)) {
    Column lockColumn=ColumnUtil.getLockColumn(column);
    scan.addColumn(lockColumn.getFamily(),lockColumn.getQualifier());
  }
  Column writeColumn=ColumnUtil.getPutColumn(column);
  scan.addColumn(writeColumn.getFamily(),writeColumn.getQualifier());
  Column deleteColumn=ColumnUtil.getDeleteColumn(column);
  scan.addColumn(deleteColumn.getFamily(),deleteColumn.getQualifier());
}",0.861244019138756
29939,"public static Result removeNotRequiredLockColumns(Map<byte[],NavigableSet<byte[]>> familyMap,Result result){
  if (!result.isEmpty()) {
    List<KeyValue> kvs=new ArrayList<KeyValue>();
    for (    KeyValue kv : result.list()) {
      if (Bytes.equals(ColumnUtil.LOCK_FAMILY_NAME,kv.getFamily())) {
        Column dataColumn=ColumnUtil.getDataColumnFromLockColumn(new Column(kv.getFamily(),kv.getQualifier()));
        if (familyMap.containsKey(dataColumn.getFamily())) {
          kvs.add(kv);
        }
      }
 else {
        kvs.add(kv);
      }
    }
    if (kvs.size() != result.size()) {
      return new Result(kvs);
    }
  }
  return result;
}","public static Result removeNotRequiredLockColumns(Map<byte[],NavigableSet<byte[]>> familyMap,Result result){
  if (!result.isEmpty()) {
    List<KeyValue> kvs=new ArrayList<KeyValue>();
    for (    KeyValue kv : result.list()) {
      if (Bytes.equals(ColumnUtil.LOCK_FAMILY_NAME,kv.getFamily())) {
        Column dataColumn=ColumnUtil.getDataColumnFromLockColumn(new Column(kv.getFamily(),kv.getQualifier()));
        if (familyMap.containsKey(dataColumn.getFamily())) {
          Set<byte[]> qualifiers=familyMap.get(dataColumn.getFamily());
          if (qualifiers == null || qualifiers.size() == 0 || qualifiers.contains(dataColumn.getQualifier())) {
            kvs.add(kv);
          }
        }
      }
 else {
        kvs.add(kv);
      }
    }
    if (kvs.size() != result.size()) {
      return new Result(kvs);
    }
  }
  return result;
}",0.8685258964143426
29940,"protected static boolean next(HRegion region,final ThemisServerScanner s,List<Result> results,int limit) throws IOException {
  List<KeyValue> values=new ArrayList<KeyValue>();
  for (int i=0; i < limit; ) {
    try {
      boolean moreRows=s.next(values,SchemaMetrics.METRIC_NEXTSIZE);
      ThemisProtocolImpl.checkReadTTL(System.currentTimeMillis(),s.getStartTs(),currentRow(values));
      if (!values.isEmpty()) {
        Result result=ThemisCpUtil.removeNotRequiredLockColumns(s.getScan().getFamilyMap(),new Result(values));
        Pair<List<KeyValue>,List<KeyValue>> pResult=ThemisCpUtil.seperateLockAndWriteKvs(result.list());
        List<KeyValue> lockKvs=pResult.getFirst();
        if (lockKvs.size() == 0) {
          List<KeyValue> putKvs=ThemisCpUtil.getPutKvs(pResult.getSecond());
          if (putKvs.size() > 0) {
            Get dataGet=ThemisCpUtil.constructDataGetByPutKvs(putKvs,s.getDataColumnFilter());
            Result dataResult=region.get(dataGet,null);
            if (!dataResult.isEmpty()) {
              results.add(dataResult);
              ++i;
            }
          }
        }
 else {
          LOG.warn(""String_Node_Str"" + result.getRow());
          results.add(new Result(lockKvs));
          ++i;
        }
      }
      if (!moreRows) {
        return false;
      }
      values.clear();
    }
 catch (    Throwable e) {
      LOG.error(""String_Node_Str"" + values);
      throw new IOException(e);
    }
  }
  return true;
}","protected static boolean next(HRegion region,final ThemisServerScanner s,List<Result> results,int limit) throws IOException {
  List<KeyValue> values=new ArrayList<KeyValue>();
  for (int i=0; i < limit; ) {
    try {
      boolean moreRows=s.next(values,SchemaMetrics.METRIC_NEXTSIZE);
      ThemisProtocolImpl.checkReadTTL(System.currentTimeMillis(),s.getStartTs(),currentRow(values));
      if (!values.isEmpty()) {
        Result result=ThemisCpUtil.removeNotRequiredLockColumns(s.getDataScan().getFamilyMap(),new Result(values));
        Pair<List<KeyValue>,List<KeyValue>> pResult=ThemisCpUtil.seperateLockAndWriteKvs(result.list());
        List<KeyValue> lockKvs=pResult.getFirst();
        if (lockKvs.size() == 0) {
          List<KeyValue> putKvs=ThemisCpUtil.getPutKvs(pResult.getSecond());
          if (putKvs.size() > 0) {
            Get dataGet=ThemisCpUtil.constructDataGetByPutKvs(putKvs,s.getDataColumnFilter());
            Result dataResult=region.get(dataGet,null);
            if (!dataResult.isEmpty()) {
              results.add(dataResult);
              ++i;
            }
          }
        }
 else {
          LOG.warn(""String_Node_Str"" + result.getRow());
          results.add(new Result(lockKvs));
          ++i;
        }
      }
      if (!moreRows) {
        return false;
      }
      values.clear();
    }
 catch (    Throwable e) {
      LOG.error(""String_Node_Str"" + values);
      throw new IOException(e);
    }
  }
  return true;
}",0.9986440677966102
29941,"@Override public RegionScanner preScannerOpen(final ObserverContext<RegionCoprocessorEnvironment> e,final Scan scan,final RegionScanner s) throws IOException {
  try {
    Long themisStartTs=getStartTsFromAttribute(scan);
    if (themisStartTs != null) {
      ThemisCpUtil.prepareScan(scan,e.getEnvironment().getRegion().getTableDesc().getFamilies());
      checkFamily(e.getEnvironment().getRegion(),scan);
      ThemisProtocolImpl.checkReadTTL(System.currentTimeMillis(),themisStartTs,PRE_SCANNER_OPEN_FEEK_ROW);
      Scan internalScan=ThemisCpUtil.constructLockAndWriteScan(scan,themisStartTs);
      ThemisServerScanner pScanner=new ThemisServerScanner(e.getEnvironment().getRegion().getScanner(internalScan),internalScan,themisStartTs,scan.getFilter());
      e.bypass();
      return pScanner;
    }
    return s;
  }
 catch (  Throwable ex) {
    throw new DoNotRetryIOException(""String_Node_Str"",ex);
  }
}","@Override public RegionScanner preScannerOpen(final ObserverContext<RegionCoprocessorEnvironment> e,final Scan scan,final RegionScanner s) throws IOException {
  try {
    Long themisStartTs=getStartTsFromAttribute(scan);
    if (themisStartTs != null) {
      ThemisCpUtil.prepareScan(scan,e.getEnvironment().getRegion().getTableDesc().getFamilies());
      checkFamily(e.getEnvironment().getRegion(),scan);
      ThemisProtocolImpl.checkReadTTL(System.currentTimeMillis(),themisStartTs,PRE_SCANNER_OPEN_FEEK_ROW);
      Scan internalScan=ThemisCpUtil.constructLockAndWriteScan(scan,themisStartTs);
      ThemisServerScanner pScanner=new ThemisServerScanner(e.getEnvironment().getRegion().getScanner(internalScan),internalScan,themisStartTs,scan);
      e.bypass();
      return pScanner;
    }
    return s;
  }
 catch (  Throwable ex) {
    throw new DoNotRetryIOException(""String_Node_Str"",ex);
  }
}",0.9934065934065934
29942,"public ThemisServerScanner(RegionScanner scanner,Scan scan,long startTs,Filter dataColumnFilter){
  this.scan=scan;
  this.scanner=scanner;
  this.startTs=startTs;
  this.dataColumnFilter=dataColumnFilter;
}","public ThemisServerScanner(RegionScanner scanner,Scan scan,long startTs,Scan dataScan){
  this.scan=scan;
  this.scanner=scanner;
  this.startTs=startTs;
  this.dataScan=dataScan;
}",0.865979381443299
29943,"public Filter getDataColumnFilter(){
  return dataColumnFilter;
}","public Filter getDataColumnFilter(){
  return dataScan.getFilter();
}",0.8955223880597015
29944,"@Test public void testGetFamily() throws IOException {
  commitTestTransaction();
  Get get=new Get(ROW);
  Result iResult=cpClient.themisGet(TABLENAME,get,prewriteTs + 50);
  Assert.assertFalse(ThemisCpUtil.isLockResult(iResult));
  Assert.assertEquals(2,iResult.size());
  checkResultKvColumn(COLUMN_WITH_ANOTHER_FAMILY,iResult.list().get(0));
  checkResultKvColumn(COLUMN,iResult.list().get(1));
  commitOneColumn(COLUMN_WITH_ANOTHER_QUALIFIER,Type.Put,prewriteTs + 10,commitTs + 10);
  get=new Get(ROW);
  get.addFamily(FAMILY);
  iResult=cpClient.themisGet(TABLENAME,get,prewriteTs + 50);
  Assert.assertEquals(2,iResult.size());
  checkResultKvColumn(COLUMN_WITH_ANOTHER_QUALIFIER,iResult.list().get(0));
  checkResultKvColumn(COLUMN,iResult.list().get(1));
  get=new Get(ROW);
  get.addFamily(FAMILY);
  get.addColumn(ANOTHER_FAMILY,QUALIFIER);
  iResult=cpClient.themisGet(TABLENAME,get,prewriteTs + 50);
  Assert.assertEquals(3,iResult.size());
  checkResultKvColumn(COLUMN_WITH_ANOTHER_FAMILY,iResult.list().get(0));
  checkResultKvColumn(COLUMN_WITH_ANOTHER_QUALIFIER,iResult.list().get(1));
  checkResultKvColumn(COLUMN,iResult.list().get(2));
  writeLockAndData(COLUMN_WITH_ANOTHER_FAMILY,prewriteTs + 20);
  get=new Get(ROW);
  get.addFamily(FAMILY);
  iResult=cpClient.themisGet(TABLENAME,get,prewriteTs + 50);
  Assert.assertEquals(2,iResult.size());
  checkResultKvColumn(COLUMN_WITH_ANOTHER_QUALIFIER,iResult.list().get(0));
  checkResultKvColumn(COLUMN,iResult.list().get(1));
  get=new Get(ROW);
  get.addFamily(FAMILY);
  get.addColumn(ANOTHER_FAMILY,QUALIFIER);
  iResult=cpClient.themisGet(TABLENAME,get,prewriteTs + 50);
  checkGetOneColumnConflictResult(COLUMN_WITH_ANOTHER_FAMILY,iResult,prewriteTs + 20);
}","@Test public void testGetFamily() throws IOException {
  commitTestTransaction();
  Get get=new Get(ROW);
  Result iResult=cpClient.themisGet(TABLENAME,get,prewriteTs + 50);
  Assert.assertFalse(ThemisCpUtil.isLockResult(iResult));
  Assert.assertEquals(2,iResult.size());
  checkResultKvColumn(COLUMN_WITH_ANOTHER_FAMILY,iResult.list().get(0));
  checkResultKvColumn(COLUMN,iResult.list().get(1));
  commitOneColumn(COLUMN_WITH_ANOTHER_QUALIFIER,Type.Put,prewriteTs + 10,commitTs + 10);
  get=new Get(ROW);
  get.addFamily(FAMILY);
  iResult=cpClient.themisGet(TABLENAME,get,prewriteTs + 50);
  Assert.assertEquals(2,iResult.size());
  checkResultKvColumn(COLUMN_WITH_ANOTHER_QUALIFIER,iResult.list().get(0));
  checkResultKvColumn(COLUMN,iResult.list().get(1));
  get=new Get(ROW);
  get.addFamily(FAMILY);
  get.addColumn(ANOTHER_FAMILY,QUALIFIER);
  iResult=cpClient.themisGet(TABLENAME,get,prewriteTs + 50);
  Assert.assertEquals(3,iResult.size());
  checkResultKvColumn(COLUMN_WITH_ANOTHER_FAMILY,iResult.list().get(0));
  checkResultKvColumn(COLUMN_WITH_ANOTHER_QUALIFIER,iResult.list().get(1));
  checkResultKvColumn(COLUMN,iResult.list().get(2));
  writeLockAndData(COLUMN_WITH_ANOTHER_FAMILY,prewriteTs + 20);
  get=new Get(ROW);
  get.addFamily(FAMILY);
  iResult=cpClient.themisGet(TABLENAME,get,prewriteTs + 50);
  Assert.assertEquals(2,iResult.size());
  checkResultKvColumn(COLUMN_WITH_ANOTHER_QUALIFIER,iResult.list().get(0));
  checkResultKvColumn(COLUMN,iResult.list().get(1));
  get=new Get(ROW);
  get.addFamily(FAMILY);
  get.addColumn(ANOTHER_FAMILY,QUALIFIER);
  iResult=cpClient.themisGet(TABLENAME,get,prewriteTs + 50);
  checkGetOneColumnConflictResult(COLUMN_WITH_ANOTHER_FAMILY,iResult,prewriteTs + 20);
  get=new Get(ROW);
  get.addFamily(FAMILY);
  get.addColumn(ANOTHER_FAMILY,ANOTHER_QUALIFIER);
  iResult=cpClient.themisGet(TABLENAME,get,prewriteTs + 50);
  Assert.assertEquals(2,iResult.size());
  checkResultKvColumn(COLUMN_WITH_ANOTHER_QUALIFIER,iResult.list().get(0));
  checkResultKvColumn(COLUMN,iResult.list().get(1));
}",0.91378855786976
29945,"@Test public void testRemoveNotRequiredLockColumns(){
  Get get=new Get(ROW);
  get.addFamily(FAMILY);
  List<KeyValue> sourceKvs=new ArrayList<KeyValue>();
  sourceKvs.add(KEYVALUE);
  Column lockColumn=ColumnUtil.getLockColumn(FAMILY,QUALIFIER);
  KeyValue lockKv=new KeyValue(ROW,lockColumn.getFamily(),lockColumn.getQualifier(),PREWRITE_TS,Type.Put,VALUE);
  sourceKvs.add(lockKv);
  lockColumn=ColumnUtil.getLockColumn(ANOTHER_FAMILY,QUALIFIER);
  sourceKvs.add(new KeyValue(ROW,lockColumn.getFamily(),lockColumn.getQualifier(),PREWRITE_TS,Type.Put,VALUE));
  Result result=ThemisCpUtil.removeNotRequiredLockColumns(get.getFamilyMap(),new Result(sourceKvs));
  Assert.assertEquals(2,result.size());
  Assert.assertTrue(KEYVALUE.equals(result.list().get(0)));
  Assert.assertTrue(lockKv.equals(result.list().get(1)));
}","@Test public void testRemoveNotRequiredLockColumns(){
  Get get=new Get(ROW);
  get.addFamily(FAMILY);
  get.addColumn(ANOTHER_FAMILY,ANOTHER_QUALIFIER);
  List<KeyValue> sourceKvs=new ArrayList<KeyValue>();
  sourceKvs.add(KEYVALUE);
  Column lockColumn=ColumnUtil.getLockColumn(FAMILY,QUALIFIER);
  KeyValue lockKv=new KeyValue(ROW,lockColumn.getFamily(),lockColumn.getQualifier(),PREWRITE_TS,Type.Put,VALUE);
  sourceKvs.add(lockKv);
  lockColumn=ColumnUtil.getLockColumn(ANOTHER_FAMILY,QUALIFIER);
  sourceKvs.add(new KeyValue(ROW,lockColumn.getFamily(),lockColumn.getQualifier(),PREWRITE_TS,Type.Put,VALUE));
  Result result=ThemisCpUtil.removeNotRequiredLockColumns(get.getFamilyMap(),new Result(sourceKvs));
  Assert.assertEquals(2,result.size());
  Assert.assertTrue(KEYVALUE.equals(result.list().get(0)));
  Assert.assertTrue(lockKv.equals(result.list().get(1)));
}",0.9699469652327636
29946,"@Test public void testAddLockAndWriteColumnToScan(){
  Scan scan=new Scan();
  ThemisCpUtil.addLockAndWriteColumnToScan(COLUMN,scan);
  checkReadWithLockAndWriteColumns(scan.getFamilyMap(),COLUMN);
}","@Test public void testAddLockAndWriteColumnToScan(){
  Scan scan=new Scan();
  ThemisCpUtil.addLockAndWriteColumnToScan(COLUMN,scan);
  checkReadWithLockAndWriteColumns(scan.getFamilyMap(),COLUMN);
  scan=new Scan();
  scan.addFamily(ColumnUtil.LOCK_FAMILY_NAME);
  ThemisCpUtil.addLockAndWriteColumnToScan(COLUMN,scan);
  Assert.assertTrue(scan.getFamilyMap().containsKey(ColumnUtil.LOCK_FAMILY_NAME) && scan.getFamilyMap().get(ColumnUtil.LOCK_FAMILY_NAME) == null);
  checkReadWithWriteColumns(scan.getFamilyMap(),COLUMN);
}",0.5489655172413793
29947,"@Test public void testAddLockAndWriteColumnToGet() throws IOException {
  byte[][] families=new byte[][]{FAMILY,FAMILY,ANOTHER_FAMILY};
  byte[][] qualifiers=new byte[][]{QUALIFIER,ANOTHER_FAMILY,QUALIFIER};
  Get userGet=new Get(ROW);
  for (int i=0; i < families.length; ++i) {
    userGet.addColumn(families[i],qualifiers[i]);
  }
  Get internalGet=new Get(userGet.getRow());
  ThemisCpUtil.addLockAndWriteColumnToGet(userGet,internalGet,PREWRITE_TS);
  Assert.assertEquals(3,internalGet.getFamilyMap().size());
  Assert.assertEquals(4,internalGet.getFamilyMap().get(FAMILY).size());
  Assert.assertEquals(2,internalGet.getFamilyMap().get(ANOTHER_FAMILY).size());
  Assert.assertEquals(3,internalGet.getFamilyMap().get(ColumnUtil.LOCK_FAMILY_NAME).size());
  for (int i=0; i < families.length; ++i) {
    checkReadWithLockAndWriteColumns(internalGet.getFamilyMap(),new ColumnCoordinate(families[i],qualifiers[i]));
  }
  Assert.assertEquals(PREWRITE_TS,internalGet.getTimeRange().getMax());
  Assert.assertEquals(1,internalGet.getMaxVersions());
  userGet=new Get(ROW);
  userGet.addFamily(FAMILY);
  internalGet=new Get(userGet.getRow());
  ThemisCpUtil.addLockAndWriteColumnToGet(userGet,internalGet,PREWRITE_TS);
  checkAddLockAndDataFamily(internalGet,ColumnUtil.LOCK_FAMILY_NAME,FAMILY);
  Assert.assertTrue(internalGet.getFilter() instanceof ExcludeDataColumnFilter);
  userGet=new Get(ROW);
  userGet.addFamily(FAMILY);
  userGet.addColumn(ANOTHER_FAMILY,ANOTHER_QUALIFIER);
  internalGet=new Get(userGet.getRow());
  ThemisCpUtil.addLockAndWriteColumnToGet(userGet,internalGet,PREWRITE_TS);
  checkAddLockAndDataFamily(internalGet,ColumnUtil.LOCK_FAMILY_NAME,FAMILY);
  checkReadWithWriteColumns(internalGet.getFamilyMap(),new ColumnCoordinate(ANOTHER_FAMILY,ANOTHER_QUALIFIER));
}","@Test public void testAddLockAndWriteColumnToGet() throws IOException {
  byte[][] families=new byte[][]{FAMILY,FAMILY,ANOTHER_FAMILY};
  byte[][] qualifiers=new byte[][]{QUALIFIER,ANOTHER_FAMILY,QUALIFIER};
  Get userGet=new Get(ROW);
  for (int i=0; i < families.length; ++i) {
    userGet.addColumn(families[i],qualifiers[i]);
  }
  Get internalGet=new Get(userGet.getRow());
  ThemisCpUtil.addLockAndWriteColumnToGet(userGet,internalGet,PREWRITE_TS);
  Assert.assertEquals(3,internalGet.getFamilyMap().size());
  Assert.assertEquals(4,internalGet.getFamilyMap().get(FAMILY).size());
  Assert.assertEquals(2,internalGet.getFamilyMap().get(ANOTHER_FAMILY).size());
  Assert.assertEquals(3,internalGet.getFamilyMap().get(ColumnUtil.LOCK_FAMILY_NAME).size());
  for (int i=0; i < families.length; ++i) {
    checkReadWithLockAndWriteColumns(internalGet.getFamilyMap(),new ColumnCoordinate(families[i],qualifiers[i]));
  }
  Assert.assertEquals(PREWRITE_TS,internalGet.getTimeRange().getMax());
  Assert.assertEquals(1,internalGet.getMaxVersions());
  userGet=new Get(ROW);
  userGet.addFamily(FAMILY);
  internalGet=new Get(userGet.getRow());
  ThemisCpUtil.addLockAndWriteColumnToGet(userGet,internalGet,PREWRITE_TS);
  checkAddLockAndDataFamily(internalGet,ColumnUtil.LOCK_FAMILY_NAME,FAMILY);
  Assert.assertTrue(internalGet.getFilter() instanceof ExcludeDataColumnFilter);
  userGet=new Get(ROW);
  userGet.addFamily(ANOTHER_FAMILY);
  userGet.addColumn(FAMILY,ANOTHER_QUALIFIER);
  internalGet=new Get(userGet.getRow());
  ThemisCpUtil.addLockAndWriteColumnToGet(userGet,internalGet,PREWRITE_TS);
  checkAddLockAndDataFamily(internalGet,ColumnUtil.LOCK_FAMILY_NAME,ANOTHER_FAMILY);
  checkReadWithWriteColumns(internalGet.getFamilyMap(),new ColumnCoordinate(FAMILY,ANOTHER_QUALIFIER));
  Assert.assertTrue(internalGet.getFilter() instanceof ExcludeDataColumnFilter);
}",0.9577080491132332
29948,"@Test public void testCreateScanWithLockAndWriteColumns() throws IOException {
  byte[] startRow=Bytes.toBytes(""String_Node_Str"");
  byte[] stopRow=Bytes.toBytes(""String_Node_Str"");
  Scan scan=new Scan(startRow,stopRow);
  scan.addColumn(FAMILY,QUALIFIER);
  scan.addColumn(ANOTHER_FAMILY,ANOTHER_QUALIFIER);
  Scan createdScan=ThemisCpUtil.constructLockAndWriteScan(scan,PREWRITE_TS);
  Assert.assertArrayEquals(startRow,createdScan.getStartRow());
  Assert.assertArrayEquals(stopRow,createdScan.getStopRow());
  Assert.assertEquals(3,createdScan.getFamilies().length);
  checkReadWithLockAndWriteColumns(createdScan.getFamilyMap(),COLUMN);
  checkReadWithLockAndWriteColumns(createdScan.getFamilyMap(),new ColumnCoordinate(ANOTHER_FAMILY,ANOTHER_QUALIFIER));
  scan=new Scan(startRow,stopRow);
  scan.addFamily(FAMILY);
  scan.addColumn(ANOTHER_FAMILY,QUALIFIER);
  createdScan=ThemisCpUtil.constructLockAndWriteScan(scan,PREWRITE_TS);
  Assert.assertArrayEquals(startRow,createdScan.getStartRow());
  Assert.assertArrayEquals(stopRow,createdScan.getStopRow());
  Assert.assertEquals(3,createdScan.getFamilies().length);
  checkReadWithWriteColumns(createdScan.getFamilyMap(),new ColumnCoordinate(ANOTHER_FAMILY,QUALIFIER));
  Assert.assertTrue(createdScan.getFamilyMap().containsKey(FAMILY) && createdScan.getFamilyMap().get(FAMILY) == null);
  Assert.assertTrue(createdScan.getFamilyMap().containsKey(ColumnUtil.LOCK_FAMILY_NAME) && createdScan.getFamilyMap().get(ColumnUtil.LOCK_FAMILY_NAME) == null);
  Assert.assertTrue(createdScan.getFilter() instanceof ExcludeDataColumnFilter);
}","@Test public void testCreateScanWithLockAndWriteColumns() throws IOException {
  byte[] startRow=Bytes.toBytes(""String_Node_Str"");
  byte[] stopRow=Bytes.toBytes(""String_Node_Str"");
  Scan scan=new Scan(startRow,stopRow);
  scan.addColumn(FAMILY,QUALIFIER);
  scan.addColumn(ANOTHER_FAMILY,ANOTHER_QUALIFIER);
  Scan createdScan=ThemisCpUtil.constructLockAndWriteScan(scan,PREWRITE_TS);
  Assert.assertArrayEquals(startRow,createdScan.getStartRow());
  Assert.assertArrayEquals(stopRow,createdScan.getStopRow());
  Assert.assertEquals(3,createdScan.getFamilies().length);
  checkReadWithLockAndWriteColumns(createdScan.getFamilyMap(),COLUMN);
  checkReadWithLockAndWriteColumns(createdScan.getFamilyMap(),new ColumnCoordinate(ANOTHER_FAMILY,ANOTHER_QUALIFIER));
  scan=new Scan(startRow,stopRow);
  scan.addFamily(ANOTHER_FAMILY);
  scan.addColumn(FAMILY,QUALIFIER);
  createdScan=ThemisCpUtil.constructLockAndWriteScan(scan,PREWRITE_TS);
  Assert.assertArrayEquals(startRow,createdScan.getStartRow());
  Assert.assertArrayEquals(stopRow,createdScan.getStopRow());
  Assert.assertEquals(3,createdScan.getFamilies().length);
  checkReadWithWriteColumns(createdScan.getFamilyMap(),new ColumnCoordinate(FAMILY,QUALIFIER));
  Assert.assertTrue(createdScan.getFamilyMap().containsKey(ANOTHER_FAMILY) && createdScan.getFamilyMap().get(ANOTHER_FAMILY) == null);
  Assert.assertTrue(createdScan.getFamilyMap().containsKey(ColumnUtil.LOCK_FAMILY_NAME) && createdScan.getFamilyMap().get(ColumnUtil.LOCK_FAMILY_NAME) == null);
  Assert.assertTrue(createdScan.getFilter() instanceof ExcludeDataColumnFilter);
}",0.9316185696361357
29949,"@Test public void testScanWithDeletedRow() throws Exception {
  nextTransactionTs();
  writePutAndData(COLUMN,prewriteTs - 6,commitTs - 6);
  createTransactionWithMock();
  ThemisScanner scanner=prepareScanner(new ColumnCoordinate[]{COLUMN});
  checkReadColumnResultWithTs(scanner.next(),COLUMN,prewriteTs - 6);
  checkAndCloseScanner(scanner);
  writeDeleteColumn(COLUMN,prewriteTs - 3,commitTs - 3);
  scanner=prepareScanner(new ColumnCoordinate[]{COLUMN});
  checkAndCloseScanner(scanner);
  writeDeleteColumn(COLUMN_WITH_ANOTHER_ROW,prewriteTs - 2,commitTs - 2);
  writePutAndData(COLUMN,prewriteTs - 2,commitTs - 2);
  writePutAndData(COLUMN_WITH_ZZ_ROW,prewriteTs - 2,commitTs - 2);
  scanner=prepareScanner(new ColumnCoordinate[]{COLUMN_WITH_ANOTHER_ROW,COLUMN,COLUMN_WITH_ZZ_ROW});
  checkReadColumnResultWithTs(scanner.next(),COLUMN,prewriteTs - 2);
  checkReadColumnResultWithTs(scanner.next(),COLUMN_WITH_ZZ_ROW,prewriteTs - 2);
  checkAndCloseScanner(scanner);
  scanner.close();
}","@Test public void testScanWithDeletedRow() throws Exception {
  nextTransactionTs();
  writePutAndData(COLUMN,prewriteTs - 6,commitTs - 6);
  createTransactionWithMock();
  ThemisScanner scanner=prepareScanner(new ColumnCoordinate[]{COLUMN});
  checkReadColumnResultWithTs(scanner.next(),COLUMN,prewriteTs - 6);
  checkAndCloseScanner(scanner);
  writeDeleteColumn(COLUMN,prewriteTs - 3,commitTs - 3);
  scanner=prepareScanner(new ColumnCoordinate[]{COLUMN});
  checkAndCloseScanner(scanner);
  writeDeleteColumn(COLUMN_WITH_ANOTHER_ROW,prewriteTs - 2,commitTs - 2);
  writePutAndData(COLUMN,prewriteTs - 2,commitTs - 2);
  writePutAndData(COLUMN_WITH_ZZ_ROW,prewriteTs - 2,commitTs - 2);
  scanner=prepareScanner(new ColumnCoordinate[]{COLUMN_WITH_ANOTHER_ROW,COLUMN,COLUMN_WITH_ZZ_ROW});
  checkReadColumnResultWithTs(scanner.next(),COLUMN,prewriteTs - 2);
  checkReadColumnResultWithTs(scanner.next(),COLUMN_WITH_ZZ_ROW,prewriteTs - 2);
  checkAndCloseScanner(scanner);
}",0.9903406202338588
29950,"protected void writeDeleteColumn(ColumnCoordinate c,long prewriteTs,long commitTs) throws IOException {
  ColumnCoordinate deleteColumn=new ColumnCoordinate(c.getTableName(),c.getRow(),ColumnUtil.getPutColumn(c));
  writeWriteColumnInternal(deleteColumn,prewriteTs,commitTs);
}","protected void writeDeleteColumn(ColumnCoordinate c,long prewriteTs,long commitTs) throws IOException {
  ColumnCoordinate deleteColumn=new ColumnCoordinate(c.getTableName(),c.getRow(),ColumnUtil.getDeleteColumn(c));
  writeWriteColumnInternal(deleteColumn,prewriteTs,commitTs);
}",0.9838420107719928
29951,"@Test public void testScanWithNoRowkeyFilter() throws Exception {
  prepareScanData(TRANSACTION_COLUMNS);
  ValueFilter valueFilter=new ValueFilter(CompareOp.EQUAL,new BinaryComparator(ANOTHER_VALUE));
  ThemisScanner scanner=prepareScanner(TRANSACTION_COLUMNS,valueFilter);
  checkAndCloseScanner(scanner);
  SingleColumnValueFilter singleColumnFilter=new SingleColumnValueFilter(ANOTHER_FAMILY,QUALIFIER,CompareOp.EQUAL,VALUE);
  singleColumnFilter.setFilterIfMissing(true);
  scanner=prepareScanner(TRANSACTION_COLUMNS,singleColumnFilter);
  checkResultForROW(scanner.next());
  checkAndCloseScanner(scanner);
  valueFilter=new ValueFilter(CompareOp.EQUAL,new BinaryComparator(VALUE));
  singleColumnFilter=new SingleColumnValueFilter(QUALIFIER,QUALIFIER,CompareOp.EQUAL,ANOTHER_VALUE);
  FilterList filterList=new FilterList();
  filterList.addFilter(valueFilter);
  filterList.addFilter(singleColumnFilter);
  scanner=prepareScanner(TRANSACTION_COLUMNS,filterList);
  checkAndCloseScanner(scanner);
  filterList=new FilterList(Operator.MUST_PASS_ONE);
  filterList.addFilter(valueFilter);
  filterList.addFilter(singleColumnFilter);
  scanner=prepareScanner(TRANSACTION_COLUMNS,filterList);
  checkScanRow(new ColumnCoordinate[]{COLUMN_WITH_ANOTHER_ROW},scanner.next());
  checkResultForROW(scanner.next());
  checkAndCloseScanner(scanner);
}","@Test public void testScanWithNoRowkeyFilter() throws Exception {
  prepareScanData(TRANSACTION_COLUMNS);
  ValueFilter valueFilter=new ValueFilter(CompareOp.EQUAL,new BinaryComparator(ANOTHER_VALUE));
  ThemisScanner scanner=prepareScanner(TRANSACTION_COLUMNS,valueFilter);
  checkAndCloseScanner(scanner);
  SingleColumnValueFilter singleColumnFilter=new SingleColumnValueFilter(ANOTHER_FAMILY,QUALIFIER,CompareOp.EQUAL,VALUE);
  singleColumnFilter.setFilterIfMissing(true);
  scanner=prepareScanner(TRANSACTION_COLUMNS,singleColumnFilter);
  checkResultForROW(scanner.next());
  checkAndCloseScanner(scanner);
  valueFilter=new ValueFilter(CompareOp.EQUAL,new BinaryComparator(VALUE));
  singleColumnFilter=new SingleColumnValueFilter(QUALIFIER,QUALIFIER,CompareOp.EQUAL,ANOTHER_VALUE);
  singleColumnFilter.setFilterIfMissing(true);
  FilterList filterList=new FilterList();
  filterList.addFilter(valueFilter);
  filterList.addFilter(singleColumnFilter);
  scanner=prepareScanner(TRANSACTION_COLUMNS,filterList);
  checkAndCloseScanner(scanner);
  filterList=new FilterList(Operator.MUST_PASS_ONE);
  filterList.addFilter(valueFilter);
  filterList.addFilter(singleColumnFilter);
  scanner=prepareScanner(TRANSACTION_COLUMNS,filterList);
  checkScanRow(new ColumnCoordinate[]{COLUMN_WITH_ANOTHER_ROW},scanner.next());
  checkResultForROW(scanner.next());
  checkAndCloseScanner(scanner);
}",0.9828529733673842
29952,"@Test public void testScanWithFilter() throws IOException {
  prepareScanData(TRANSACTION_COLUMNS);
  writeData(COLUMN,lastTs(prewriteTs),ANOTHER_VALUE);
  ValueFilter valueFilter=new ValueFilter(CompareOp.EQUAL,new BinaryComparator(ANOTHER_VALUE));
  PrefixFilter prefixFilter=new PrefixFilter(ANOTHER_ROW);
  FilterList filterList=new FilterList();
  filterList.addFilter(valueFilter);
  filterList.addFilter(prefixFilter);
  ThemisScanner scanner=prepareScanner(TRANSACTION_COLUMNS,filterList);
  checkAndCloseScanner(scanner);
  filterList=new FilterList(Operator.MUST_PASS_ONE);
  filterList.addFilter(valueFilter);
  filterList.addFilter(prefixFilter);
  scanner=prepareScanner(TRANSACTION_COLUMNS,filterList);
  checkScanRow(new ColumnCoordinate[]{COLUMN_WITH_ANOTHER_ROW},scanner.next());
  Assert.assertEquals(3,scanner.next().size());
  checkAndCloseScanner(scanner);
}","@Test public void testScanWithFilter() throws IOException {
  prepareScanData(TRANSACTION_COLUMNS);
  writeData(COLUMN,lastTs(prewriteTs),ANOTHER_VALUE);
  ValueFilter valueFilter=new ValueFilter(CompareOp.EQUAL,new BinaryComparator(ANOTHER_VALUE));
  PrefixFilter prefixFilter=new PrefixFilter(ANOTHER_ROW);
  FilterList filterList=new FilterList();
  filterList.addFilter(valueFilter);
  filterList.addFilter(prefixFilter);
  ThemisScanner scanner=prepareScanner(TRANSACTION_COLUMNS,filterList);
  checkAndCloseScanner(scanner);
  filterList=new FilterList(Operator.MUST_PASS_ONE);
  filterList.addFilter(valueFilter);
  filterList.addFilter(prefixFilter);
  scanner=prepareScanner(TRANSACTION_COLUMNS,filterList);
  checkScanRow(new ColumnCoordinate[]{COLUMN_WITH_ANOTHER_ROW},scanner.next());
  Assert.assertEquals(1,scanner.next().size());
  checkAndCloseScanner(scanner);
}",0.9988623435722412
29953,"public static Scan constructLockAndWriteScan(Scan userScan,long startTs) throws IOException {
  Scan internalScan=new Scan(userScan);
  internalScan.setFamilyMap(new TreeMap<byte[],NavigableSet<byte[]>>(Bytes.BYTES_COMPARATOR));
  for (  Entry<byte[],NavigableSet<byte[]>> entry : userScan.getFamilyMap().entrySet()) {
    for (    byte[] qualifier : entry.getValue()) {
      Column dataColumn=new Column(entry.getKey(),qualifier);
      addLockAndWriteColumnToScan(dataColumn,internalScan);
    }
  }
  internalScan.setTimeRange(0,startTs);
  moveRowkeyFiltersForWriteScan(userScan,internalScan);
  return internalScan;
}","public static Scan constructLockAndWriteScan(Scan userScan,long startTs) throws IOException {
  Scan internalScan=new Scan(userScan);
  internalScan.setFilter(null);
  internalScan.setFamilyMap(new TreeMap<byte[],NavigableSet<byte[]>>(Bytes.BYTES_COMPARATOR));
  for (  Entry<byte[],NavigableSet<byte[]>> entry : userScan.getFamilyMap().entrySet()) {
    for (    byte[] qualifier : entry.getValue()) {
      Column dataColumn=new Column(entry.getKey(),qualifier);
      addLockAndWriteColumnToScan(dataColumn,internalScan);
    }
  }
  internalScan.setTimeRange(0,startTs);
  moveRowkeyFiltersForWriteScan(userScan,internalScan);
  return internalScan;
}",0.974960876369327
29954,"@Override protected HE_Mesh createBase(){
  if (cells == null) {
    return new HE_Mesh();
  }
  if (on == null) {
    return new HE_Mesh();
  }
  if (on.length > cells.size()) {
    return new HE_Mesh();
  }
  final int n=on.length;
  final FastTable<HE_Face> tmpfaces=new FastTable<HE_Face>();
  int nv=0;
  for (int i=0; i < n; i++) {
    final HE_Mesh m=cells.getMesh(i);
    if (on[i]) {
      final Iterator<HE_Face> fItr=m.fItr();
      while (fItr.hasNext()) {
        final HE_Face f=fItr.next();
        if (f.getTemporaryLabel() == -1) {
          tmpfaces.add(f);
          nv+=f.getFaceOrder();
        }
 else         if (!on[f.getTemporaryLabel()] || membrane) {
          tmpfaces.add(f);
          nv+=f.getFaceOrder();
        }
      }
    }
  }
  final WB_Coord[] vertices=new WB_Coord[nv];
  final int[][] faces=new int[tmpfaces.size()][];
  final int[] labels=new int[tmpfaces.size()];
  final int[] intlabels=new int[tmpfaces.size()];
  final int[] colors=new int[tmpfaces.size()];
  int cid=0;
  for (int i=0; i < tmpfaces.size(); i++) {
    final HE_Face f=tmpfaces.get(i);
    faces[i]=new int[f.getFaceOrder()];
    labels[i]=f.getLabel();
    intlabels[i]=f.getTemporaryLabel();
    colors[i]=f.getColor();
    HE_Halfedge he=f.getHalfedge();
    for (int j=0; j < f.getFaceOrder(); j++) {
      vertices[cid]=he.getVertex();
      faces[i][j]=cid;
      he=he.getNextInFace();
      cid++;
    }
  }
  final HEC_FromFacelist ffl=new HEC_FromFacelist().setVertices(vertices).setFaces(faces).setDuplicate(true);
  final HE_Mesh result=ffl.createBase();
  final Iterator<HE_Face> fItr=result.fItr();
  int i=0;
  HE_Face f;
  while (fItr.hasNext()) {
    f=fItr.next();
    f.setLabel(labels[i]);
    f.setTemporaryLabel(intlabels[i]);
    f.setColor(colors[i]);
    i++;
  }
  result.fixNonManifoldVertices();
  if (!capBoundaries) {
    final HE_Selection sel=HE_Selection.selectFacesWithInternalLabel(result,-1);
    final HE_FaceIterator fitr=sel.fItr();
    while (fitr.hasNext()) {
      result.deleteFace(fitr.next());
    }
    result.cleanUnusedElementsByFace();
    result.capHalfedges();
  }
  return result;
}","@Override protected HE_Mesh createBase(){
  if (cells == null) {
    return new HE_Mesh();
  }
  if (on == null) {
    return new HE_Mesh();
  }
  if (on.length > cells.size()) {
    return new HE_Mesh();
  }
  final int n=on.length;
  final FastTable<HE_Face> tmpfaces=new FastTable<HE_Face>();
  int nv=0;
  for (int i=0; i < n; i++) {
    final HE_Mesh m=cells.getMesh(i);
    if (on[i]) {
      final Iterator<HE_Face> fItr=m.fItr();
      while (fItr.hasNext()) {
        final HE_Face f=fItr.next();
        if (f.getTemporaryLabel() == -1) {
          tmpfaces.add(f);
          nv+=f.getFaceOrder();
        }
 else         if (!on[f.getTemporaryLabel()] || membrane) {
          tmpfaces.add(f);
          nv+=f.getFaceOrder();
        }
      }
    }
  }
  final WB_Coord[] vertices=new WB_Coord[nv];
  final int[][] faces=new int[tmpfaces.size()][];
  final int[] labels=new int[tmpfaces.size()];
  final int[] intlabels=new int[tmpfaces.size()];
  final int[] colors=new int[tmpfaces.size()];
  int cid=0;
  for (int i=0; i < tmpfaces.size(); i++) {
    final HE_Face f=tmpfaces.get(i);
    faces[i]=new int[f.getFaceOrder()];
    labels[i]=f.getLabel();
    intlabels[i]=f.getTemporaryLabel();
    colors[i]=f.getColor();
    HE_Halfedge he=f.getHalfedge();
    for (int j=0; j < f.getFaceOrder(); j++) {
      vertices[cid]=he.getVertex();
      faces[i][j]=cid;
      he=he.getNextInFace();
      cid++;
    }
  }
  final HEC_FromFacelist ffl=new HEC_FromFacelist().setVertices(vertices).setFaces(faces).setDuplicate(true);
  final HE_Mesh result=ffl.createBase();
  final Iterator<HE_Face> fItr=result.fItr();
  int i=0;
  HE_Face f;
  while (fItr.hasNext()) {
    f=fItr.next();
    f.setLabel(labels[i]);
    f.setTemporaryLabel(intlabels[i]);
    f.setColor(colors[i]);
    i++;
  }
  result.fixNonManifoldVertices();
  if (!capBoundaries) {
    final HE_Selection sel=HE_Selection.selectFacesWithTemporaryLabel(result,-1);
    final HE_FaceIterator fitr=sel.fItr();
    while (fitr.hasNext()) {
      result.deleteFace(fitr.next());
    }
    result.cleanUnusedElementsByFace();
    result.capHalfedges();
  }
  return result;
}",0.9960419091967404
29955,"@Override public HE_Mesh createBase(){
  if (container == null) {
    return new HE_Mesh();
  }
  if (points == null) {
    return container;
  }
  if (numberOfPoints == 0) {
    numberOfPoints=points.length;
  }
  if ((cellIndex < 0) || (cellIndex >= numberOfPoints)) {
    return container;
  }
  final HE_Mesh result=container.get();
  final ArrayList<WB_Plane> cutPlanes=new ArrayList<WB_Plane>();
  int id=0;
  final WB_Point O=new WB_Point();
  WB_Plane P;
  final int[] labels;
  if (limitPoints) {
    labels=new int[pointsToUse.length];
    for (    final int element : pointsToUse) {
      if (cellIndex != element) {
        final WB_Vector N=new WB_Vector(points[cellIndex]);
        N.subSelf(points[element]);
        N.normalizeSelf();
        O.set(points[cellIndex]);
        O.addSelf(points[element]);
        O.mulSelf(0.5);
        if (offset != 0) {
          O.addSelf(N.mul(offset));
        }
        P=new WB_Plane(O,N);
        cutPlanes.add(P);
        labels[id]=element;
        id++;
      }
    }
  }
 else {
    labels=new int[numberOfPoints - 1];
    for (int j=0; j < numberOfPoints; j++) {
      if (cellIndex != j) {
        final WB_Vector N=new WB_Vector(points[cellIndex]);
        N.subSelf(points[j]);
        N.normalizeSelf();
        O.set(points[cellIndex]);
        O.addSelf(points[j]);
        O.mulSelf(0.5);
        if (offset != 0) {
          O.addSelf(N.mul(offset));
        }
        P=new WB_Plane(O,N);
        cutPlanes.add(P);
        labels[id]=j;
        id++;
      }
    }
  }
  final HEM_MultiSlice msm=new HEM_MultiSlice();
  msm.setPlanes(cutPlanes).setCenter(new WB_Point(points[cellIndex])).setCap(!surface).setKeepCenter(true).setLabels(labels).setSimpleCap(simpleCap);
  result.modify(msm);
  inner=new HE_Selection(result);
  for (int i=0; i < labels.length; i++) {
    final HE_Selection sel=HE_Selection.selectFacesWithInternalLabel(result,labels[i]);
    if (sel.getNumberOfFaces() > 0) {
      final HE_FaceIterator fitr=sel.fItr();
      while (fitr.hasNext()) {
        result.deleteFace(fitr.next());
      }
      result.cleanUnusedElementsByFace();
      for (      final HE_Face f : result.capHoles()) {
        f.copyProperties(sel.getFaceWithIndex(0));
      }
    }
  }
  outer=msm.origFaces;
  return result;
}","@Override public HE_Mesh createBase(){
  if (container == null) {
    return new HE_Mesh();
  }
  if (points == null) {
    return container;
  }
  if (numberOfPoints == 0) {
    numberOfPoints=points.length;
  }
  if ((cellIndex < 0) || (cellIndex >= numberOfPoints)) {
    return container;
  }
  final HE_Mesh result=container.get();
  final ArrayList<WB_Plane> cutPlanes=new ArrayList<WB_Plane>();
  int id=0;
  final WB_Point O=new WB_Point();
  WB_Plane P;
  final int[] labels;
  if (limitPoints) {
    labels=new int[pointsToUse.length];
    for (    final int element : pointsToUse) {
      if (cellIndex != element) {
        final WB_Vector N=new WB_Vector(points[cellIndex]);
        N.subSelf(points[element]);
        N.normalizeSelf();
        O.set(points[cellIndex]);
        O.addSelf(points[element]);
        O.mulSelf(0.5);
        if (offset != 0) {
          O.addSelf(N.mul(offset));
        }
        P=new WB_Plane(O,N);
        cutPlanes.add(P);
        labels[id]=element;
        id++;
      }
    }
  }
 else {
    labels=new int[numberOfPoints - 1];
    for (int j=0; j < numberOfPoints; j++) {
      if (cellIndex != j) {
        final WB_Vector N=new WB_Vector(points[cellIndex]);
        N.subSelf(points[j]);
        N.normalizeSelf();
        O.set(points[cellIndex]);
        O.addSelf(points[j]);
        O.mulSelf(0.5);
        if (offset != 0) {
          O.addSelf(N.mul(offset));
        }
        P=new WB_Plane(O,N);
        cutPlanes.add(P);
        labels[id]=j;
        id++;
      }
    }
  }
  final HEM_MultiSlice msm=new HEM_MultiSlice();
  msm.setPlanes(cutPlanes).setCenter(new WB_Point(points[cellIndex])).setCap(!surface).setKeepCenter(true).setLabels(labels).setSimpleCap(simpleCap);
  result.modify(msm);
  inner=new HE_Selection(result);
  for (int i=0; i < labels.length; i++) {
    final HE_Selection sel=HE_Selection.selectFacesWithTemporaryLabel(result,labels[i]);
    if (sel.getNumberOfFaces() > 0) {
      final HE_FaceIterator fitr=sel.fItr();
      while (fitr.hasNext()) {
        result.deleteFace(fitr.next());
      }
      result.cleanUnusedElementsByFace();
      for (      final HE_Face f : result.capHoles()) {
        f.copyProperties(sel.getFaceWithIndex(0));
      }
    }
  }
  outer=msm.origFaces;
  return result;
}",0.9962987154365338
29956,"public static void main(final String[] args){
  WB_Point[] basepoints=new WB_Point[24];
  for (int i=0; i < 24; i++) {
    basepoints[i]=new WB_Point(0,50 + (250 * (i % 2)),0);
    if (i > 0) {
      basepoints[i].rotateAbout2PointAxisSelf((Math.PI / 12.0) * i,0,0,0,0,0,1);
    }
  }
  WB_Polygon polygon=WB_GeometryFactory.instance().createSimplePolygon(basepoints);
  HEC_Polygon creator=new HEC_Polygon();
  creator.setPolygon(polygon);
  creator.setThickness(50);
  HE_Mesh mesh=new HE_Mesh(creator);
  mesh.modify(new HEM_SliceSurface().setPlane(0,50.0,0,0,-1,0));
}","public static void main(final String[] args){
  HEC_Cylinder creator=new HEC_Cylinder();
  creator.setFacets(32).setSteps(16).setRadius(50).setHeight(400).setCenter(0,0,0);
  HE_Mesh mesh=new HE_Mesh(creator);
  HEM_Slice modifier=new HEM_Slice();
  modifier.setPlane(new WB_Plane(0,0,0,1,1,1));
  mesh.modify(modifier);
}",0.1252796420581655
29957,"void splitFaceInIntersections(final HE_Face f,final HE_Mesh mesh){
  Long[] intersectionVertices=new Long[2 * f.getFaceOrder()];
  Long[] polygon=new Long[2 * f.getFaceOrder()];
  int intersectionCount=0;
  int polygonCount=0;
  HE_FaceVertexCirculator fvCrc=f.fvCrc();
  HE_Vertex v;
  while (fvCrc.hasNext()) {
    v=fvCrc.next();
    polygon[polygonCount++]=v.getKey();
    if ((v.getTemporaryLabel() == ONVERTEX) || (v.getTemporaryLabel() == ONEDGE)) {
      intersectionVertices[intersectionCount++]=v.getKey();
      if (v.getTemporaryLabel() == ONVERTEX) {
        polygon[polygonCount++]=v.getKey();
      }
      v.clearVisited();
    }
  }
  if (intersectionCount < 2) {
    return;
  }
 else {
    intersectionVertices=Arrays.copyOf(intersectionVertices,intersectionCount);
    polygon=Arrays.copyOf(polygon,polygonCount);
    FastTable<Long[]> subPolygons=new FastTable<Long[]>();
    HE_Vertex v0=mesh.getVertexWithKey(intersectionVertices[0]);
    HE_Vertex v1;
    int i=1;
    do {
      v1=mesh.getVertexWithKey(intersectionVertices[i++]);
    }
 while (WB_Epsilon.isZeroSq(v0.getSqDistance3D(v1)));
    WB_Line intersectionLine=gf.createLineThroughPoints(v0,v1);
    Arrays.sort(intersectionVertices,new VertexOnLineComparator(mesh,intersectionLine));
    int trial=0;
    while (intersectionVertices.length > 1) {
      long key0=intersectionVertices[0];
      long key1=intersectionVertices[1];
      int index0=indexOf(key0,polygon);
      int index1=indexOf(key1,polygon);
      boolean solved=false;
      if (firstUnvisited(polygon,index0,mesh) == index1) {
        solved=true;
      }
 else {
        key1=intersectionVertices[0];
        key0=intersectionVertices[1];
        int tmp=index0;
        index0=index1;
        index1=tmp;
        if (firstUnvisited(polygon,index0,mesh) == index1) {
          solved=true;
        }
      }
      if (solved) {
        trial--;
        Long[] subPolygon=getSubPolygon(polygon,index0,index1);
        if (subPolygon.length > 2) {
          subPolygons.add(subPolygon);
        }
        polygon=getSubPolygon(polygon,index1,index0);
        intersectionVertices=Arrays.copyOfRange(intersectionVertices,2,intersectionVertices.length);
        if (intersectionVertices.length < 2) {
          subPolygons.add(polygon);
        }
        mesh.getVertexWithKey(key0).setVisited();
        mesh.getVertexWithKey(key1).setVisited();
      }
 else {
        trial++;
        reverse(intersectionVertices);
      }
      if (trial > 1) {
        break;
      }
    }
    for (    Long[] subPoly : subPolygons) {
      FastTable<HE_Halfedge> halfedges=new FastTable<HE_Halfedge>();
      HE_Halfedge he;
      HE_Face subFace=new HE_Face();
      subFace.copyProperties(f);
      for (int j=0; j < subPoly.length; j++) {
        he=new HE_Halfedge();
        if (subPoly[j] != subPoly[(j + 1) % subPoly.length]) {
          mesh.setVertex(he,mesh.getVertexWithKey(subPoly[j]));
          mesh.setHalfedge(he.getVertex(),he);
          mesh.setFace(he,subFace);
          halfedges.add(he);
          if (j == (subPoly.length - 1)) {
            he.setTemporaryLabel(1);
            cutEdges.add(he);
          }
        }
      }
      if (halfedges.size() > 2) {
        for (        HE_Halfedge fhe : halfedges) {
          if (fhe.getVertex().getTemporaryLabel() == FRONT) {
            front.add(subFace);
          }
 else           if (fhe.getVertex().getTemporaryLabel() == BACK) {
            back.add(subFace);
          }
        }
        mesh.setHalfedge(subFace,halfedges.get(0));
        for (int j=0, k=halfedges.size() - 1; j < halfedges.size(); k=j, j++) {
          mesh.setNext(halfedges.get(k),halfedges.get(j));
        }
        mesh.add(subFace);
        mesh.addHalfedges(halfedges);
      }
    }
    mesh.cutFace(f);
    mesh.pairHalfedges();
  }
}","void splitFaceInIntersections(final HE_Face f,final HE_Mesh mesh){
  Long[] intersectionVertices=new Long[2 * f.getFaceOrder()];
  Long[] polygon=new Long[2 * f.getFaceOrder()];
  int intersectionCount=0;
  int polygonCount=0;
  HE_FaceVertexCirculator fvCrc=f.fvCrc();
  HE_Vertex v;
  while (fvCrc.hasNext()) {
    v=fvCrc.next();
    polygon[polygonCount++]=v.getKey();
    if ((v.getTemporaryLabel() == ONVERTEX) || (v.getTemporaryLabel() == ONEDGE)) {
      intersectionVertices[intersectionCount++]=v.getKey();
      if (v.getTemporaryLabel() == ONVERTEX) {
        polygon[polygonCount++]=v.getKey();
      }
      v.clearVisited();
    }
  }
  if (intersectionCount < 2) {
    return;
  }
 else {
    intersectionVertices=Arrays.copyOf(intersectionVertices,intersectionCount);
    polygon=Arrays.copyOf(polygon,polygonCount);
    FastTable<Long[]> subPolygons=new FastTable<Long[]>();
    HE_Vertex v0=mesh.getVertexWithKey(intersectionVertices[0]);
    HE_Vertex v1;
    int i=1;
    do {
      v1=mesh.getVertexWithKey(intersectionVertices[i++]);
    }
 while (WB_Epsilon.isZeroSq(v0.getSqDistance3D(v1)) && (i < intersectionCount));
    WB_Line intersectionLine=gf.createLineThroughPoints(v0,v1);
    Arrays.sort(intersectionVertices,new VertexOnLineComparator(mesh,intersectionLine));
    int trial=0;
    while (intersectionVertices.length > 1) {
      long key0=intersectionVertices[0];
      long key1=intersectionVertices[1];
      int index0=indexOf(key0,polygon);
      int index1=indexOf(key1,polygon);
      boolean solved=false;
      if (firstUnvisited(polygon,index0,mesh) == index1) {
        solved=true;
      }
 else {
        key1=intersectionVertices[0];
        key0=intersectionVertices[1];
        int tmp=index0;
        index0=index1;
        index1=tmp;
        if (firstUnvisited(polygon,index0,mesh) == index1) {
          solved=true;
        }
      }
      if (solved) {
        trial--;
        Long[] subPolygon=getSubPolygon(polygon,index0,index1);
        if (subPolygon.length > 2) {
          subPolygons.add(subPolygon);
        }
        polygon=getSubPolygon(polygon,index1,index0);
        intersectionVertices=Arrays.copyOfRange(intersectionVertices,2,intersectionVertices.length);
        if (intersectionVertices.length < 2) {
          subPolygons.add(polygon);
        }
        mesh.getVertexWithKey(key0).setVisited();
        mesh.getVertexWithKey(key1).setVisited();
      }
 else {
        trial++;
        reverse(intersectionVertices);
      }
      if (trial > 1) {
        break;
      }
    }
    for (    Long[] subPoly : subPolygons) {
      FastTable<HE_Halfedge> halfedges=new FastTable<HE_Halfedge>();
      HE_Halfedge he;
      HE_Face subFace=new HE_Face();
      subFace.copyProperties(f);
      for (int j=0; j < subPoly.length; j++) {
        he=new HE_Halfedge();
        if (subPoly[j] != subPoly[(j + 1) % subPoly.length]) {
          mesh.setVertex(he,mesh.getVertexWithKey(subPoly[j]));
          mesh.setHalfedge(he.getVertex(),he);
          mesh.setFace(he,subFace);
          halfedges.add(he);
          if (j == (subPoly.length - 1)) {
            he.setTemporaryLabel(1);
            cutEdges.add(he);
          }
        }
      }
      if (halfedges.size() > 2) {
        for (        HE_Halfedge fhe : halfedges) {
          if (fhe.getVertex().getTemporaryLabel() == FRONT) {
            front.add(subFace);
          }
 else           if (fhe.getVertex().getTemporaryLabel() == BACK) {
            back.add(subFace);
          }
        }
        mesh.setHalfedge(subFace,halfedges.get(0));
        for (int j=0, k=halfedges.size() - 1; j < halfedges.size(); k=j, j++) {
          mesh.setNext(halfedges.get(k),halfedges.get(j));
        }
        mesh.add(subFace);
        mesh.addHalfedges(halfedges);
      }
    }
    mesh.cutFace(f);
    mesh.pairHalfedges();
  }
}",0.99649396182314
29958,"/** 
 * @param mesh 
 */
public static void stats(final HE_Mesh mesh){
  System.out.println(""String_Node_Str"" + mesh.getNumberOfFaces());
  System.out.println(""String_Node_Str"" + mesh.getNumberOfVertices());
  System.out.println(""String_Node_Str"" + mesh.getNumberOfEdges());
  System.out.println(""String_Node_Str"" + mesh.getNumberOfHalfedges());
}","/** 
 * @param mesh
 */
public static void stats(final HE_Mesh mesh){
  System.out.println(""String_Node_Str"" + mesh.getNumberOfFaces());
  System.out.println(""String_Node_Str"" + mesh.getNumberOfVertices());
  System.out.println(""String_Node_Str"" + mesh.getNumberOfEdges());
  System.out.println(""String_Node_Str"" + mesh.getNumberOfHalfedges());
}",0.9985569985569984
29959,"/** 
 * @param he1
 * @param he2
 */
public void setPair(final HE_Halfedge he1,final HE_Halfedge he2){
  if (he1.getPair() == null) {
    unpairedHalfedges.remove(he1);
  }
 else {
    if (he1.isEdge()) {
      edges.remove(he1);
    }
 else {
      halfedges.remove(he1);
    }
  }
  if (he2.getPair() == null) {
    unpairedHalfedges.remove(he2);
  }
 else {
    if (he2.isEdge()) {
      edges.remove(he2);
    }
 else {
      halfedges.remove(he2);
    }
  }
  he1._setPair(he2);
  he2._setPair(he1);
  if (he1.isEdge()) {
    edges.add(he1);
    halfedges.add(he2);
  }
 else   if (he2.isEdge()) {
    edges.add(he2);
    halfedges.add(he1);
  }
}","/** 
 * @param he1
 * @param he2
 */
public void setPair(final HE_Halfedge he1,final HE_Halfedge he2){
  remove(he1);
  remove(he2);
  he1._setPair(he2);
  he2._setPair(he1);
  add(he1);
  add(he2);
}",0.2934272300469484
29960,"/** 
 * @param label
 * @return
 */
public static HE_Selection selectFacesWithInternalLabel(final HE_Mesh mesh,final int label){
  final HE_Selection _selection=new HE_Selection(mesh);
  HE_Face f;
  final Iterator<HE_Face> fItr=mesh.fItr();
  while (fItr.hasNext()) {
    f=fItr.next();
    if (f.getTemporaryLabel() == label) {
      _selection.add(f);
    }
  }
  return _selection;
}","/** 
 * @param label
 * @return
 * @deprecated Use {@link #selectFacesWithTemporaryLabel(HE_Mesh,int)} instead
 */
public static HE_Selection selectFacesWithInternalLabel(final HE_Mesh mesh,final int label){
  return selectFacesWithTemporaryLabel(mesh,label);
}",0.4351851851851852
29961,"/** 
 * @param label
 * @return
 */
public static HE_Selection selectFacesWithOtherInternalLabel(final HE_Mesh mesh,final int label){
  final HE_Selection _selection=new HE_Selection(mesh);
  HE_Face f;
  final Iterator<HE_Face> fItr=mesh.fItr();
  while (fItr.hasNext()) {
    f=fItr.next();
    if (f.getTemporaryLabel() != label) {
      _selection.add(f);
    }
  }
  return _selection;
}","/** 
 * @param label
 * @return
 * @deprecated Use {@link #selectFacesWithOtherTemporaryLabel(HE_Mesh,int)} instead
 */
public static HE_Selection selectFacesWithOtherInternalLabel(final HE_Mesh mesh,final int label){
  return selectFacesWithOtherTemporaryLabel(mesh,label);
}",0.437125748502994
29962,"/** 
 * Collect vertices belonging to selection elements.
 */
public void collectVertices(){
  List<HE_Vertex> tmpVertices=new FastTable<HE_Vertex>();
  HE_FaceIterator fItr=fItr();
  HE_Face f;
  while (fItr.hasNext()) {
    f=fItr.next();
    tmpVertices=f.getFaceVertices();
    addVertices(tmpVertices);
  }
  HE_HalfedgeIterator heItr=heItr();
  while (heItr.hasNext()) {
    add(heItr.next().getVertex());
  }
}","/** 
 * Collect vertices belonging to selection elements.
 */
public void collectVertices(){
  List<HE_Vertex> tmpVertices=new FastTable<HE_Vertex>();
  HE_FaceIterator fItr=fItr();
  HE_Face f;
  while (fItr.hasNext()) {
    f=fItr.next();
    tmpVertices=f.getUniqueFaceVertices();
    addVertices(tmpVertices);
  }
  HE_HalfedgeIterator heItr=heItr();
  while (heItr.hasNext()) {
    add(heItr.next().getVertex());
  }
}",0.9928571428571428
29963,"public static HE_Selection selectVerticesWithInternalLabel(final HE_Mesh mesh,final int label){
  final HE_Selection _selection=new HE_Selection(mesh);
  HE_Vertex v;
  final Iterator<HE_Vertex> vItr=mesh.vItr();
  while (vItr.hasNext()) {
    v=vItr.next();
    if (v.getTemporaryLabel() == label) {
      _selection.add(v);
    }
  }
  return _selection;
}","/** 
 * @deprecated Use {@link #selectVerticesWithTemporaryLabel(HE_Mesh,int)} instead
 */
public static HE_Selection selectVerticesWithInternalLabel(final HE_Mesh mesh,final int label){
  return selectVerticesWithTemporaryLabel(mesh,label);
}",0.3594009983361065
29964,"public static HE_Selection selectVerticesWithOtherInternalLabel(final HE_Mesh mesh,final int label){
  final HE_Selection _selection=new HE_Selection(mesh);
  HE_Vertex v;
  final Iterator<HE_Vertex> vItr=mesh.vItr();
  while (vItr.hasNext()) {
    v=vItr.next();
    if (v.getTemporaryLabel() != label) {
      _selection.add(v);
    }
  }
  return _selection;
}","/** 
 * @deprecated Use {@link #selectVerticesWithOtherTemporaryLabel(HE_Mesh,int)} instead
 */
public static HE_Selection selectVerticesWithOtherInternalLabel(final HE_Mesh mesh,final int label){
  return selectVerticesWithOtherTemporaryLabel(mesh,label);
}",0.3639291465378422
29965,"@Override public WB_FaceListMesh getMesh(){
  createMesh();
  return mesh;
}","@Override public WB_FacelistMesh getMesh(){
  createMesh();
  return mesh;
}",0.986842105263158
29966,"/** 
 * @return
 */
public WB_FaceListMesh getMesh(){
  createMesh();
  return mesh;
}","/** 
 * @return
 */
public WB_FacelistMesh getMesh(){
  createMesh();
  return mesh;
}",0.9883720930232558
29967,"/** 
 * @return
 */
public WB_FaceListMesh getMesh(){
  createMesh();
  return mesh;
}","/** 
 * @return
 */
public WB_FacelistMesh getMesh(){
  createMesh();
  return mesh;
}",0.9883720930232558
29968,"/** 
 * @return
 */
public WB_FaceListMesh getMesh(){
  createMesh();
  return mesh;
}","/** 
 * @return
 */
public WB_FacelistMesh getMesh(){
  createMesh();
  return mesh;
}",0.9883720930232558
29969,"@Override protected HE_Mesh createBase(){
  if ((facets < 3) || (WB_Epsilon.isZero(radius))) {
    return null;
  }
  final WB_Point[] ppoints=new WB_Point[facets];
  for (int i=0; i < facets; i++) {
    final double x=radius * Math.cos(((Math.PI * 2.0) / facets) * i);
    final double y=radius * Math.sin(((Math.PI * 2.0) / facets) * i);
    ppoints[i]=new WB_Point(x,y,0.0);
  }
  final WB_Polygon polygon=gf.createSimplePolygon(ppoints);
  final WB_Vector norm=polygon.getPlane().getNormal();
  final int n=polygon.getNumberOfPoints();
  final boolean surf=WB_Epsilon.isZero(thickness);
  final WB_Coord[] points=new WB_Coord[surf ? n : 2 * n];
  for (int i=0; i < n; i++) {
    points[i]=polygon.getPoint(i);
  }
  if (!surf) {
    for (int i=0; i < n; i++) {
      points[n + i]=new WB_Point(points[i]).addMulSelf(thickness,norm).rotateAboutAxis2PSelf(Math.PI / facets,0,0,0,0,0,1);
    }
  }
  int[][] faces;
  if (surf) {
    faces=new int[1][n];
    for (int i=0; i < n; i++) {
      faces[0][i]=i;
    }
  }
 else {
    faces=new int[2 * n + 2][];
    faces[2 * n]=new int[n];
    faces[2 * n + 1]=new int[n];
    for (int i=0; i < n; i++) {
      faces[2 * n][i]=i;
      faces[2 * n + 1][i]=(2 * n) - 1 - i;
      faces[2 * i]=new int[3];
      faces[2 * i][0]=i;
      faces[2 * i][1]=n + i;
      faces[2 * i][2]=(i + 1) % n;
      faces[2 * i + 1]=new int[3];
      faces[2 * i + 1][0]=i + n;
      faces[2 * i + 1][2]=(i + 1) % n;
      faces[2 * i + 1][1]=n + ((i + 1) % n);
    }
  }
  final HEC_FromFacelist fl=new HEC_FromFacelist();
  fl.setVertices(points).setFaces(faces).setDuplicate(false);
  return fl.createBase().flipAllFaces();
}","@Override protected HE_Mesh createBase(){
  if ((facets < 3) || (WB_Epsilon.isZero(radius))) {
    return null;
  }
  final WB_Point[] ppoints=new WB_Point[facets];
  for (int i=0; i < facets; i++) {
    final double x=radius * Math.cos(((Math.PI * 2.0) / facets) * i);
    final double y=radius * Math.sin(((Math.PI * 2.0) / facets) * i);
    ppoints[i]=new WB_Point(x,y,0.0);
  }
  final WB_Polygon polygon=gf.createSimplePolygon(ppoints);
  final WB_Vector norm=polygon.getPlane().getNormal();
  final int n=polygon.getNumberOfPoints();
  final boolean surf=WB_Epsilon.isZero(thickness);
  final WB_Coord[] points=new WB_Coord[surf ? n : 2 * n];
  for (int i=0; i < n; i++) {
    points[i]=polygon.getPoint(i);
  }
  if (!surf) {
    for (int i=0; i < n; i++) {
      points[n + i]=new WB_Point(points[i]).addMulSelf(thickness,norm).rotateAboutAxis2PSelf(Math.PI / facets,0,0,0,0,0,1);
    }
  }
  int[][] faces;
  if (surf) {
    faces=new int[1][n];
    for (int i=0; i < n; i++) {
      faces[0][i]=i;
    }
  }
 else {
    faces=new int[2 * n + 2][];
    faces[2 * n]=new int[n];
    faces[2 * n + 1]=new int[n];
    for (int i=0; i < n; i++) {
      faces[2 * n][i]=i;
      faces[2 * n + 1][i]=(2 * n) - 1 - i;
      faces[2 * i]=new int[3];
      faces[2 * i][0]=i;
      faces[2 * i][1]=n + i;
      faces[2 * i][2]=(i + 1) % n;
      faces[2 * i + 1]=new int[3];
      faces[2 * i + 1][0]=i + n;
      faces[2 * i + 1][2]=(i + 1) % n;
      faces[2 * i + 1][1]=n + ((i + 1) % n);
    }
  }
  final HEC_FromFacelist fl=new HEC_FromFacelist();
  fl.setVertices(points).setFaces(faces).setDuplicate(false);
  return fl.createBase().flipFaces();
}",0.9990944763054632
29970,"@Override public HE_Mesh createBase(){
  final HE_Mesh result=new HE_Mesh();
  if ((source == null) || (source.getNumberOfFaces() < 3)) {
    return result;
  }
  final HashMap<Long,Long> faceVertexCorrelation=new HashMap<Long,Long>();
  final Iterator<HE_Face> fItr=source.fItr();
  HE_Face f;
  while (fItr.hasNext()) {
    f=fItr.next();
    final HE_Vertex cv=new HE_Vertex(f.getFaceCenter());
    faceVertexCorrelation.put(f.key(),cv.key());
    result.add(cv);
  }
  HE_Halfedge he;
  if (keepBoundary) {
    final Iterator<HE_Halfedge> heItr=source.heItr();
    while (heItr.hasNext()) {
      he=heItr.next();
      if (he.isOuterBoundary()) {
        HE_Vertex cv=new HE_Vertex(he.getEdgeCenter());
        faceVertexCorrelation.put(he.key(),cv.key());
        result.add(cv);
        cv=new HE_Vertex(he.getVertex());
        faceVertexCorrelation.put(he.getVertex().key(),cv.key());
        result.add(cv);
      }
    }
  }
  final Iterator<HE_Vertex> vItr=source.vItr();
  HE_Vertex v;
  final List<WB_Point> centers=new ArrayList<WB_Point>();
  while (vItr.hasNext()) {
    v=vItr.next();
    if (!v.isBoundary()) {
      he=v.getHalfedge();
      final List<HE_Halfedge> faceHalfedges=new ArrayList<HE_Halfedge>();
      final HE_Face nf=new HE_Face();
      final WB_Point p=new WB_Point();
      int n=0;
      do {
        final HE_Halfedge hen=new HE_Halfedge();
        faceHalfedges.add(hen);
        result.setFace(hen,nf);
        final Long key=faceVertexCorrelation.get(he.getFace().key());
        result.setVertex(hen,result.getVertexWithKey(key));
        p.addSelf(hen.getVertex());
        n++;
        if (hen.getVertex().getHalfedge() == null) {
          result.setHalfedge(hen.getVertex(),hen);
        }
        if (nf.getHalfedge() == null) {
          result.setHalfedge(nf,hen);
        }
        he=he.getNextInVertex();
      }
 while (he != v.getHalfedge());
      p.divSelf(n);
      centers.add(p);
      result.cycleHalfedges(faceHalfedges);
      result.addHalfedges(faceHalfedges);
      result.add(nf);
    }
 else     if (keepBoundary) {
      he=v.getHalfedge();
      while (!he.isOuterBoundary()) {
        he=he.getNextInVertex();
      }
      HE_Halfedge start=he;
      final List<HE_Halfedge> faceHalfedges=new ArrayList<HE_Halfedge>();
      final HE_Face nf=new HE_Face();
      final WB_Point p=new WB_Point();
      int n=0;
      HE_Halfedge hen=new HE_Halfedge();
      faceHalfedges.add(hen);
      result.setFace(hen,nf);
      Long key=faceVertexCorrelation.get(v.key());
      result.setVertex(hen,result.getVertexWithKey(key));
      p.addSelf(hen.getVertex());
      n++;
      hen=new HE_Halfedge();
      faceHalfedges.add(hen);
      result.setFace(hen,nf);
      key=faceVertexCorrelation.get(he.key());
      result.setVertex(hen,result.getVertexWithKey(key));
      p.addSelf(hen.getVertex());
      n++;
      result.setHalfedge(hen.getVertex(),hen);
      result.setHalfedge(nf,hen);
      he=he.getNextInVertex();
      do {
        hen=new HE_Halfedge();
        faceHalfedges.add(hen);
        result.setFace(hen,nf);
        key=(he.isOuterBoundary()) ? faceVertexCorrelation.get(he.key()) : faceVertexCorrelation.get(he.getFace().key());
        result.setVertex(hen,result.getVertexWithKey(key));
        p.addSelf(hen.getVertex());
        n++;
        he=he.getNextInVertex();
      }
 while (he != start);
      he=he.getPrevInVertex();
      hen=new HE_Halfedge();
      faceHalfedges.add(hen);
      result.setFace(hen,nf);
      key=faceVertexCorrelation.get(he.getPair().key());
      result.setVertex(hen,result.getVertexWithKey(key));
      p.addSelf(hen.getVertex());
      n++;
      p.divSelf(n);
      centers.add(p);
      result.cycleHalfedges(faceHalfedges);
      result.addHalfedges(faceHalfedges);
      result.add(nf);
    }
  }
  result.pairHalfedges();
  result.capHalfedges();
  if (setCenter) {
    result.moveTo(source.getCenter());
  }
  result.flipAllFaces();
  final List<HE_Face> faces=result.getFaces();
  final int fs=faces.size();
  for (int i=0; i < fs; i++) {
    if (!faces.get(i).isPlanar() && fixNonPlanarFaces) {
      HEM_TriSplit.splitFaceTri(result,faces.get(i),centers.get(i));
    }
  }
  return result;
}","@Override public HE_Mesh createBase(){
  final HE_Mesh result=new HE_Mesh();
  if ((source == null) || (source.getNumberOfFaces() < 3)) {
    return result;
  }
  final HashMap<Long,Long> faceVertexCorrelation=new HashMap<Long,Long>();
  final Iterator<HE_Face> fItr=source.fItr();
  HE_Face f;
  while (fItr.hasNext()) {
    f=fItr.next();
    final HE_Vertex cv=new HE_Vertex(f.getFaceCenter());
    faceVertexCorrelation.put(f.key(),cv.key());
    result.add(cv);
  }
  HE_Halfedge he;
  if (keepBoundary) {
    final Iterator<HE_Halfedge> heItr=source.heItr();
    while (heItr.hasNext()) {
      he=heItr.next();
      if (he.isOuterBoundary()) {
        HE_Vertex cv=new HE_Vertex(he.getEdgeCenter());
        faceVertexCorrelation.put(he.key(),cv.key());
        result.add(cv);
        cv=new HE_Vertex(he.getVertex());
        faceVertexCorrelation.put(he.getVertex().key(),cv.key());
        result.add(cv);
      }
    }
  }
  final Iterator<HE_Vertex> vItr=source.vItr();
  HE_Vertex v;
  final List<WB_Point> centers=new ArrayList<WB_Point>();
  while (vItr.hasNext()) {
    v=vItr.next();
    if (!v.isBoundary()) {
      he=v.getHalfedge();
      final List<HE_Halfedge> faceHalfedges=new ArrayList<HE_Halfedge>();
      final HE_Face nf=new HE_Face();
      final WB_Point p=new WB_Point();
      int n=0;
      do {
        final HE_Halfedge hen=new HE_Halfedge();
        faceHalfedges.add(hen);
        result.setFace(hen,nf);
        final Long key=faceVertexCorrelation.get(he.getFace().key());
        result.setVertex(hen,result.getVertexWithKey(key));
        p.addSelf(hen.getVertex());
        n++;
        if (hen.getVertex().getHalfedge() == null) {
          result.setHalfedge(hen.getVertex(),hen);
        }
        if (nf.getHalfedge() == null) {
          result.setHalfedge(nf,hen);
        }
        he=he.getNextInVertex();
      }
 while (he != v.getHalfedge());
      p.divSelf(n);
      centers.add(p);
      result.cycleHalfedges(faceHalfedges);
      result.addHalfedges(faceHalfedges);
      result.add(nf);
    }
 else     if (keepBoundary) {
      he=v.getHalfedge();
      while (!he.isOuterBoundary()) {
        he=he.getNextInVertex();
      }
      HE_Halfedge start=he;
      final List<HE_Halfedge> faceHalfedges=new ArrayList<HE_Halfedge>();
      final HE_Face nf=new HE_Face();
      final WB_Point p=new WB_Point();
      int n=0;
      HE_Halfedge hen=new HE_Halfedge();
      faceHalfedges.add(hen);
      result.setFace(hen,nf);
      Long key=faceVertexCorrelation.get(v.key());
      result.setVertex(hen,result.getVertexWithKey(key));
      p.addSelf(hen.getVertex());
      n++;
      hen=new HE_Halfedge();
      faceHalfedges.add(hen);
      result.setFace(hen,nf);
      key=faceVertexCorrelation.get(he.key());
      result.setVertex(hen,result.getVertexWithKey(key));
      p.addSelf(hen.getVertex());
      n++;
      result.setHalfedge(hen.getVertex(),hen);
      result.setHalfedge(nf,hen);
      he=he.getNextInVertex();
      do {
        hen=new HE_Halfedge();
        faceHalfedges.add(hen);
        result.setFace(hen,nf);
        key=(he.isOuterBoundary()) ? faceVertexCorrelation.get(he.key()) : faceVertexCorrelation.get(he.getFace().key());
        result.setVertex(hen,result.getVertexWithKey(key));
        p.addSelf(hen.getVertex());
        n++;
        he=he.getNextInVertex();
      }
 while (he != start);
      he=he.getPrevInVertex();
      hen=new HE_Halfedge();
      faceHalfedges.add(hen);
      result.setFace(hen,nf);
      key=faceVertexCorrelation.get(he.getPair().key());
      result.setVertex(hen,result.getVertexWithKey(key));
      p.addSelf(hen.getVertex());
      n++;
      p.divSelf(n);
      centers.add(p);
      result.cycleHalfedges(faceHalfedges);
      result.addHalfedges(faceHalfedges);
      result.add(nf);
    }
  }
  result.pairHalfedges();
  result.capHalfedges();
  if (setCenter) {
    result.moveTo(source.getCenter());
  }
  result.flipFaces();
  final List<HE_Face> faces=result.getFaces();
  final int fs=faces.size();
  for (int i=0; i < fs; i++) {
    if (!faces.get(i).isPlanar() && fixNonPlanarFaces) {
      HEM_TriSplit.splitFaceTri(result,faces.get(i),centers.get(i));
    }
  }
  return result;
}",0.9996452642781128
29971,"@Override protected HE_Mesh createBase(){
  final HE_Mesh mesh=new HE_Mesh();
  if ((faces != null) && (vertices != null)) {
    if (faces.length == 0) {
      return mesh;
    }
    final boolean useUVW=(uvws != null) && (uvws.length == vertices.length);
    final HE_Vertex[] uniqueVertices=new HE_Vertex[vertices.length];
    final boolean[] duplicated=new boolean[vertices.length];
    if (duplicate) {
      final WB_KDTree<WB_Coord,Integer> kdtree=new WB_KDTree<WB_Coord,Integer>();
      WB_KDEntry<WB_Coord,Integer>[] neighbors;
      HE_Vertex v=new HE_Vertex(vertices[0]);
      if (useUVW) {
        v.setUVW(uvws[0]);
      }
      kdtree.add(v,0);
      uniqueVertices[0]=v;
      duplicated[0]=false;
      mesh.add(v);
      for (int i=1; i < vertices.length; i++) {
        v=new HE_Vertex(vertices[i]);
        if (useUVW) {
          v.setUVW(uvws[i]);
        }
        neighbors=kdtree.getNearestNeighbors(v,1);
        if (neighbors[0].d2 < WB_Epsilon.SQEPSILON) {
          uniqueVertices[i]=uniqueVertices[neighbors[0].value];
          duplicated[i]=true;
        }
 else {
          kdtree.add(v,i);
          uniqueVertices[i]=v;
          mesh.add(uniqueVertices[i]);
          duplicated[i]=false;
        }
      }
    }
 else {
      HE_Vertex v;
      for (int i=0; i < vertices.length; i++) {
        v=new HE_Vertex(vertices[i]);
        if (useUVW) {
          v.setUVW(uvws[i]);
        }
        v.setTemporaryLabel(i);
        uniqueVertices[i]=v;
        duplicated[i]=false;
        mesh.add(uniqueVertices[i]);
      }
    }
    int id=0;
    HE_Halfedge he;
    final List<Long> nmedges=new ArrayList<Long>();
    if (normalcheck) {
      final FastMap<Long,int[]> edges=new FastMap<Long,int[]>();
      for (int i=0; i < faces.length; i++) {
        final int[] face=faces[i];
        final int fl=face.length;
        for (int j=0; j < fl; j++) {
          final long ohash=ohash(face[j],face[(j + 1) % fl]);
          final int[] faces=edges.get(ohash);
          if (faces == null) {
            edges.put(ohash,new int[]{i,-1});
          }
 else {
            if (faces[1] > -1) {
              nmedges.add(ohash);
            }
            faces[1]=i;
          }
        }
      }
      final boolean[] visited=new boolean[faces.length];
      final LinkedList<Integer> queue=new LinkedList<Integer>();
      boolean facesleft=false;
      int starti=0;
      do {
        queue.add(starti);
        int temp;
        while (!queue.isEmpty()) {
          final Integer index=queue.poll();
          final int[] face=faces[index];
          final int fl=face.length;
          visited[index]=true;
          for (int j=0; j < fl; j++) {
            final long ohash=ohash(face[j],face[(j + 1) % fl]);
            final int[] ns=edges.get(ohash);
            if (ns != null) {
              edges.remove(ohash);
              Integer neighbor;
              if (ns[0] == index) {
                neighbor=ns[1];
              }
 else {
                neighbor=ns[0];
              }
              if (neighbor > -1) {
                if (visited[neighbor] == false) {
                  if (!queue.contains(neighbor)) {
                    queue.add(neighbor);
                  }
                  if (consistentOrder(j,(j + 1) % fl,face,faces[neighbor]) == -1) {
                    final int fln=faces[neighbor].length;
                    for (int k=0; k < (fln / 2); k++) {
                      temp=faces[neighbor][k];
                      faces[neighbor][k]=faces[neighbor][fln - k - 1];
                      faces[neighbor][fln - k - 1]=temp;
                    }
                  }
                  visited[neighbor]=true;
                }
              }
            }
          }
        }
        facesleft=false;
        for (; starti < faces.length; starti++) {
          if (!visited[starti]) {
            facesleft=true;
            break;
          }
        }
      }
 while (facesleft);
    }
    final boolean useFaceTextures=(faceTextureIds != null) && (faceTextureIds.length == faces.length);
    for (    final int[] face : faces) {
      final ArrayList<HE_Halfedge> faceEdges=new ArrayList<HE_Halfedge>();
      final HE_Face hef=new HE_Face();
      hef.setTemporaryLabel(id);
      if (useFaceTextures) {
        hef.setTextureId(faceTextureIds[id]);
      }
      id++;
      final int fl=face.length;
      final int[] locface=new int[fl];
      int li=0;
      locface[li++]=face[0];
      for (int i=1; i < (fl - 1); i++) {
        if (uniqueVertices[face[i]] != uniqueVertices[face[i - 1]]) {
          locface[li++]=face[i];
        }
      }
      if ((uniqueVertices[face[fl - 1]] != uniqueVertices[face[fl - 2]]) && (uniqueVertices[face[fl - 1]] != uniqueVertices[face[0]])) {
        locface[li++]=face[fl - 1];
      }
      if (li > 2) {
        for (int i=0; i < li; i++) {
          he=new HE_Halfedge();
          faceEdges.add(he);
          mesh.setFace(he,hef);
          if (hef.getHalfedge() == null) {
            mesh.setHalfedge(hef,he);
          }
          mesh.setVertex(he,uniqueVertices[locface[i]]);
          if (useUVW) {
            if (duplicated[locface[i]]) {
              final HE_TextureCoordinate uvw=uniqueVertices[locface[i]].getVertexUVW();
              if ((uvw.ud() != uvws[locface[i]].xd()) || (uvw.vd() != uvws[locface[i]].yd()) || (uvw.wd() != uvws[locface[i]].zd())) {
                he.setUVW(uvws[locface[i]]);
              }
            }
          }
          mesh.setHalfedge(he.getVertex(),he);
        }
        mesh.add(hef);
        mesh.cycleHalfedges(faceEdges);
        mesh.addHalfedges(faceEdges);
      }
    }
    mesh.pairHalfedges();
    mesh.capHalfedges();
    if (normalcheck) {
      final HE_FaceIterator fitr=mesh.fItr();
      HE_Face f;
      HE_Face left=null;
      WB_Coord fcleft=new WB_Point(Double.MAX_VALUE,Double.MAX_VALUE,Double.MAX_VALUE);
      while (fitr.hasNext()) {
        f=fitr.next();
        if (f.getFaceCenter().xd() < fcleft.xd()) {
          left=f;
          fcleft=left.getFaceCenter();
        }
      }
      final WB_Coord leftn=left.getFaceNormal();
      if (leftn.xd() > 0) {
        mesh.flipAllFaces();
      }
    }
  }
  return mesh;
}","@Override protected HE_Mesh createBase(){
  final HE_Mesh mesh=new HE_Mesh();
  if ((faces != null) && (vertices != null)) {
    if (faces.length == 0) {
      return mesh;
    }
    final boolean useUVW=(uvws != null) && (uvws.length == vertices.length);
    final HE_Vertex[] uniqueVertices=new HE_Vertex[vertices.length];
    final boolean[] duplicated=new boolean[vertices.length];
    if (duplicate) {
      final WB_KDTree<WB_Coord,Integer> kdtree=new WB_KDTree<WB_Coord,Integer>();
      WB_KDEntry<WB_Coord,Integer>[] neighbors;
      HE_Vertex v=new HE_Vertex(vertices[0]);
      if (useUVW) {
        v.setUVW(uvws[0]);
      }
      kdtree.add(v,0);
      uniqueVertices[0]=v;
      duplicated[0]=false;
      mesh.add(v);
      for (int i=1; i < vertices.length; i++) {
        v=new HE_Vertex(vertices[i]);
        if (useUVW) {
          v.setUVW(uvws[i]);
        }
        neighbors=kdtree.getNearestNeighbors(v,1);
        if (neighbors[0].d2 < WB_Epsilon.SQEPSILON) {
          uniqueVertices[i]=uniqueVertices[neighbors[0].value];
          duplicated[i]=true;
        }
 else {
          kdtree.add(v,i);
          uniqueVertices[i]=v;
          mesh.add(uniqueVertices[i]);
          duplicated[i]=false;
        }
      }
    }
 else {
      HE_Vertex v;
      for (int i=0; i < vertices.length; i++) {
        v=new HE_Vertex(vertices[i]);
        if (useUVW) {
          v.setUVW(uvws[i]);
        }
        v.setInternalLabel(i);
        uniqueVertices[i]=v;
        duplicated[i]=false;
        mesh.add(uniqueVertices[i]);
      }
    }
    int id=0;
    HE_Halfedge he;
    final List<Long> nmedges=new ArrayList<Long>();
    if (normalcheck) {
      final FastMap<Long,int[]> edges=new FastMap<Long,int[]>();
      for (int i=0; i < faces.length; i++) {
        final int[] face=faces[i];
        final int fl=face.length;
        for (int j=0; j < fl; j++) {
          final long ohash=ohash(face[j],face[(j + 1) % fl]);
          final int[] faces=edges.get(ohash);
          if (faces == null) {
            edges.put(ohash,new int[]{i,-1});
          }
 else {
            if (faces[1] > -1) {
              nmedges.add(ohash);
            }
            faces[1]=i;
          }
        }
      }
      final boolean[] visited=new boolean[faces.length];
      final LinkedList<Integer> queue=new LinkedList<Integer>();
      boolean facesleft=false;
      int starti=0;
      do {
        queue.add(starti);
        int temp;
        while (!queue.isEmpty()) {
          final Integer index=queue.poll();
          final int[] face=faces[index];
          final int fl=face.length;
          visited[index]=true;
          for (int j=0; j < fl; j++) {
            final long ohash=ohash(face[j],face[(j + 1) % fl]);
            final int[] ns=edges.get(ohash);
            if (ns != null) {
              edges.remove(ohash);
              Integer neighbor;
              if (ns[0] == index) {
                neighbor=ns[1];
              }
 else {
                neighbor=ns[0];
              }
              if (neighbor > -1) {
                if (visited[neighbor] == false) {
                  if (!queue.contains(neighbor)) {
                    queue.add(neighbor);
                  }
                  if (consistentOrder(j,(j + 1) % fl,face,faces[neighbor]) == -1) {
                    final int fln=faces[neighbor].length;
                    for (int k=0; k < (fln / 2); k++) {
                      temp=faces[neighbor][k];
                      faces[neighbor][k]=faces[neighbor][fln - k - 1];
                      faces[neighbor][fln - k - 1]=temp;
                    }
                  }
                  visited[neighbor]=true;
                }
              }
            }
          }
        }
        facesleft=false;
        for (; starti < faces.length; starti++) {
          if (!visited[starti]) {
            facesleft=true;
            break;
          }
        }
      }
 while (facesleft);
    }
    final boolean useFaceTextures=(faceTextureIds != null) && (faceTextureIds.length == faces.length);
    for (    final int[] face : faces) {
      final ArrayList<HE_Halfedge> faceEdges=new ArrayList<HE_Halfedge>();
      final HE_Face hef=new HE_Face();
      hef.setInternalLabel(id);
      if (useFaceTextures) {
        hef.setTextureId(faceTextureIds[id]);
      }
      id++;
      final int fl=face.length;
      final int[] locface=new int[fl];
      int li=0;
      locface[li++]=face[0];
      for (int i=1; i < (fl - 1); i++) {
        if (uniqueVertices[face[i]] != uniqueVertices[face[i - 1]]) {
          locface[li++]=face[i];
        }
      }
      if ((uniqueVertices[face[fl - 1]] != uniqueVertices[face[fl - 2]]) && (uniqueVertices[face[fl - 1]] != uniqueVertices[face[0]])) {
        locface[li++]=face[fl - 1];
      }
      if (li > 2) {
        for (int i=0; i < li; i++) {
          he=new HE_Halfedge();
          faceEdges.add(he);
          mesh.setFace(he,hef);
          if (hef.getHalfedge() == null) {
            mesh.setHalfedge(hef,he);
          }
          mesh.setVertex(he,uniqueVertices[locface[i]]);
          if (useUVW) {
            if (duplicated[locface[i]]) {
              final HE_TextureCoordinate uvw=uniqueVertices[locface[i]].getVertexUVW();
              if ((uvw.ud() != uvws[locface[i]].xd()) || (uvw.vd() != uvws[locface[i]].yd()) || (uvw.wd() != uvws[locface[i]].zd())) {
                he.setUVW(uvws[locface[i]]);
              }
            }
          }
          mesh.setHalfedge(he.getVertex(),he);
        }
        mesh.add(hef);
        mesh.cycleHalfedges(faceEdges);
        mesh.addHalfedges(faceEdges);
      }
    }
    mesh.pairHalfedges();
    mesh.capHalfedges();
    if (normalcheck) {
      final HE_FaceIterator fitr=mesh.fItr();
      HE_Face f;
      HE_Face left=null;
      WB_Coord fcleft=new WB_Point(Double.MAX_VALUE,Double.MAX_VALUE,Double.MAX_VALUE);
      while (fitr.hasNext()) {
        f=fitr.next();
        if (f.getFaceCenter().xd() < fcleft.xd()) {
          left=f;
          fcleft=left.getFaceCenter();
        }
      }
      final WB_Coord leftn=left.getFaceNormal();
      if (leftn.xd() > 0) {
        mesh.flipFaces();
      }
    }
  }
  return mesh;
}",0.9970297824516337
29972,"/** 
 */
private void createVertices(){
  final double da=(2 * Math.PI) / strutFacets;
  for (int id=0; id < (frame.getNumberOfStruts() * 2); id++) {
    final double sr=strutNodeConnections[id].radius;
    final double sgn=(strutNodeConnections[id].node == strutNodeConnections[id].strut.start()) ? 1 : -1;
    final double so=strutNodeConnections[id].maxoffset;
    final WB_Vector v=strutNodeConnections[id].strut.toVector();
    v.normalizeSelf();
    v.mulSelf(sgn);
    strutNodeConnections[id].dir=v.get();
    final WB_Plane P=strutNodeConnections[id].strut.toPlane();
    final WB_Vector u=P.getU();
    for (int j=0; j < strutFacets; j++) {
      final WB_Point p=new WB_Point(strutNodeConnections[id].node);
      final double af=angleFactor.evaluate(strutNodeConnections[id].node.xd(),strutNodeConnections[id].node.yd(),strutNodeConnections[id].node.zd());
      p.addMulSelf(so,v);
      final WB_Vector localu=u.mul(sr);
      localu.rotateAboutAxisSelf((j + af) * da,new WB_Point(),P.getNormal());
      p.addSelf(localu);
      final HE_Vertex vrtx=new HE_Vertex(p);
      vrtx.setTemporaryLabel(strutNodeConnections[id].node.getIndex());
      strutNodeConnections[id].vertices.add(vrtx);
      mesh.add(vrtx);
    }
  }
}","/** 
 */
private void createVertices(){
  final double da=(2 * Math.PI) / strutFacets;
  for (int id=0; id < (frame.getNumberOfStruts() * 2); id++) {
    final double sr=strutNodeConnections[id].radius;
    final double sgn=(strutNodeConnections[id].node == strutNodeConnections[id].strut.start()) ? 1 : -1;
    final double so=strutNodeConnections[id].maxoffset;
    final WB_Vector v=strutNodeConnections[id].strut.toVector();
    v.normalizeSelf();
    v.mulSelf(sgn);
    strutNodeConnections[id].dir=v.get();
    final WB_Plane P=strutNodeConnections[id].strut.toPlane();
    final WB_Vector u=P.getU();
    for (int j=0; j < strutFacets; j++) {
      final WB_Point p=new WB_Point(strutNodeConnections[id].node);
      final double af=angleFactor.evaluate(strutNodeConnections[id].node.xd(),strutNodeConnections[id].node.yd(),strutNodeConnections[id].node.zd());
      p.addMulSelf(so,v);
      final WB_Vector localu=u.mul(sr);
      localu.rotateAboutAxisSelf((j + af) * da,new WB_Point(),P.getNormal());
      p.addSelf(localu);
      final HE_Vertex vrtx=new HE_Vertex(p);
      vrtx.setInternalLabel(strutNodeConnections[id].node.getIndex());
      strutNodeConnections[id].vertices.add(vrtx);
      mesh.add(vrtx);
    }
  }
}",0.8986677432377876
29973,"/** 
 */
private void createStruts(){
  int i=0;
  for (  final WB_FrameStrut strut : frame.getStruts()) {
    final int offsets=i * 2;
    final int offsete=(i * 2) + 1;
    int ns=(int)Math.round(strut.getLength() / maximumStrutLength);
    ns=Math.max(ns,1);
    final ArrayList<HE_Halfedge> hes=new ArrayList<HE_Halfedge>();
    final HE_Vertex[][] extraVertices=new HE_Vertex[strutFacets][ns - 1];
    for (int j=0; j < strutFacets; j++) {
      for (int k=0; k < (ns - 1); k++) {
        extraVertices[j][k]=new HE_Vertex(gf.createInterpolatedPoint(strutNodeConnections[offsets].vertices.get(j),strutNodeConnections[offsete].vertices.get(j),(k + 1) / (double)ns));
        mesh.add(extraVertices[j][k]);
      }
    }
    for (int j=0; j < strutFacets; j++) {
      final int jp=(j + 1) % strutFacets;
      final HE_Vertex s0=strutNodeConnections[offsets].vertices.get(j);
      final HE_Vertex s1=strutNodeConnections[offsets].vertices.get(jp);
      final HE_Vertex e2=strutNodeConnections[offsete].vertices.get(jp);
      final HE_Vertex e3=strutNodeConnections[offsete].vertices.get(j);
      for (int k=0; k < ns; k++) {
        final HE_Face f=new HE_Face();
        final HE_Halfedge he0=new HE_Halfedge();
        final HE_Halfedge he1=new HE_Halfedge();
        final HE_Halfedge he2=new HE_Halfedge();
        final HE_Halfedge he3=new HE_Halfedge();
        mesh.setVertex(he0,(k == 0) ? s0 : extraVertices[j][k - 1]);
        mesh.setVertex(he1,(k == 0) ? s1 : extraVertices[jp][k - 1]);
        mesh.setVertex(he2,(k == (ns - 1)) ? e2 : extraVertices[jp][k]);
        mesh.setVertex(he3,(k == (ns - 1)) ? e3 : extraVertices[j][k]);
        mesh.setNext(he0,he1);
        mesh.setNext(he1,he2);
        mesh.setNext(he2,he3);
        mesh.setNext(he3,he0);
        mesh.setFace(he0,f);
        mesh.setHalfedge(f,he0);
        f.setTemporaryLabel(1);
        mesh.setFace(he1,f);
        mesh.setFace(he2,f);
        mesh.setFace(he3,f);
        mesh.setHalfedge(he0.getVertex(),he0);
        mesh.setHalfedge(he1.getVertex(),he1);
        mesh.setHalfedge(he2.getVertex(),he2);
        mesh.setHalfedge(he3.getVertex(),he3);
        mesh.add(f);
        mesh.add(he0);
        mesh.add(he1);
        mesh.add(he2);
        mesh.add(he3);
        hes.add(he1);
        hes.add(he3);
        if ((k < (ns - 1)) && (k > 0)) {
          hes.add(he0);
          hes.add(he2);
        }
      }
    }
    i++;
  }
}","/** 
 */
private void createStruts(){
  int i=0;
  for (  final WB_FrameStrut strut : frame.getStruts()) {
    final int offsets=i * 2;
    final int offsete=(i * 2) + 1;
    int ns=(int)Math.round(strut.getLength() / maximumStrutLength);
    ns=Math.max(ns,1);
    final ArrayList<HE_Halfedge> hes=new ArrayList<HE_Halfedge>();
    final HE_Vertex[][] extraVertices=new HE_Vertex[strutFacets][ns - 1];
    for (int j=0; j < strutFacets; j++) {
      for (int k=0; k < (ns - 1); k++) {
        extraVertices[j][k]=new HE_Vertex(gf.createInterpolatedPoint(strutNodeConnections[offsets].vertices.get(j),strutNodeConnections[offsete].vertices.get(j),(k + 1) / (double)ns));
        mesh.add(extraVertices[j][k]);
      }
    }
    for (int j=0; j < strutFacets; j++) {
      final int jp=(j + 1) % strutFacets;
      final HE_Vertex s0=strutNodeConnections[offsets].vertices.get(j);
      final HE_Vertex s1=strutNodeConnections[offsets].vertices.get(jp);
      final HE_Vertex e2=strutNodeConnections[offsete].vertices.get(jp);
      final HE_Vertex e3=strutNodeConnections[offsete].vertices.get(j);
      for (int k=0; k < ns; k++) {
        final HE_Face f=new HE_Face();
        final HE_Halfedge he0=new HE_Halfedge();
        final HE_Halfedge he1=new HE_Halfedge();
        final HE_Halfedge he2=new HE_Halfedge();
        final HE_Halfedge he3=new HE_Halfedge();
        mesh.setVertex(he0,(k == 0) ? s0 : extraVertices[j][k - 1]);
        mesh.setVertex(he1,(k == 0) ? s1 : extraVertices[jp][k - 1]);
        mesh.setVertex(he2,(k == (ns - 1)) ? e2 : extraVertices[jp][k]);
        mesh.setVertex(he3,(k == (ns - 1)) ? e3 : extraVertices[j][k]);
        mesh.setNext(he0,he1);
        mesh.setNext(he1,he2);
        mesh.setNext(he2,he3);
        mesh.setNext(he3,he0);
        mesh.setFace(he0,f);
        mesh.setHalfedge(f,he0);
        f.setInternalLabel(1);
        mesh.setFace(he1,f);
        mesh.setFace(he2,f);
        mesh.setFace(he3,f);
        mesh.setHalfedge(he0.getVertex(),he0);
        mesh.setHalfedge(he1.getVertex(),he1);
        mesh.setHalfedge(he2.getVertex(),he2);
        mesh.setHalfedge(he3.getVertex(),he3);
        mesh.add(f);
        mesh.add(he0);
        mesh.add(he1);
        mesh.add(he2);
        mesh.add(he3);
        hes.add(he1);
        hes.add(he3);
        if ((k < (ns - 1)) && (k > 0)) {
          hes.add(he0);
          hes.add(he2);
        }
      }
    }
    i++;
  }
}",0.9964998970557958
29974,"/** 
 */
private void createNodes(){
  int i=0;
  for (  WB_FrameNode node : frame.getNodes()) {
    node=frame.getNode(i);
    final ArrayList<WB_FrameStrut> struts=node.getStruts();
    final ArrayList<HE_Vertex> hullPoints=new ArrayList<HE_Vertex>();
    if (nodeTypes[i] == NodeType.ENDPOINT) {
      if (cap) {
        int offset;
        if (node == struts.get(0).start()) {
          offset=struts.get(0).getIndex() * 2;
        }
 else {
          offset=(struts.get(0).getIndex() * 2) + 1;
        }
        final ArrayList<HE_Halfedge> hes=new ArrayList<HE_Halfedge>(strutFacets);
        final HE_Face f=new HE_Face();
        mesh.add(f);
        for (int k=0; k < strutFacets; k++) {
          final HE_Halfedge he=new HE_Halfedge();
          mesh.setVertex(he,strutNodeConnections[offset].vertices.get(k));
          mesh.setFace(he,f);
          hes.add(he);
          mesh.add(he);
        }
        mesh.setHalfedge(f,hes.get(0));
        f.setTemporaryLabel(3);
        if (node == struts.get(0).start()) {
          for (int k=0, j=strutFacets - 1; k < strutFacets; j=k, k++) {
            mesh.setNext(hes.get(k),hes.get(j));
          }
        }
 else {
          for (int k=0, j=strutFacets - 1; k < strutFacets; j=k, k++) {
            mesh.setNext(hes.get(j),hes.get(k));
          }
        }
      }
    }
 else {
      if ((nodeTypes[i] != NodeType.ISOLATED) || createIsolatedNodes) {
        double br=strutRadius.evaluate(node.xd(),node.yd(),node.zd());
        for (int j=0; j < struts.size(); j++) {
          int offset;
          if (node == struts.get(j).start()) {
            offset=struts.get(j).getIndex() * 2;
          }
 else {
            offset=(struts.get(j).getIndex() * 2) + 1;
          }
          for (int k=0; k < strutFacets; k++) {
            hullPoints.add(strutNodeConnections[offset].vertices.get(k));
            br=Math.min(br,strutNodeConnections[offset].radius);
          }
        }
        br*=fillfactor;
        final int n=hullPoints.size();
        if ((nodeTypes[i] != NodeType.STRAIGHT) && (nodeTypes[i] != NodeType.BEND) && (!suppressBalljoint)) {
          final HE_Mesh ball=new HE_Mesh(new HEC_Sphere().setRadius(br).setUFacets(strutFacets).setVFacets(strutFacets).setCenter(node));
          hullPoints.addAll(ball.getVerticesAsList());
        }
        final HEC_ConvexHull ch=new HEC_ConvexHull().setPointsFromVertices(hullPoints);
        try {
          final HE_Mesh tmp=new HE_Mesh(ch);
          final Map<Long,Integer> vertexToPointIndex=ch.vertexToPointIndex;
          final Iterator<HE_Face> tmpfItr=tmp.fItr();
          HE_Face f;
          HE_Halfedge tmphe;
          final ArrayList<HE_Face> facesToRemove=new ArrayList<HE_Face>();
          while (tmpfItr.hasNext()) {
            f=tmpfItr.next();
            f.setTemporaryLabel(2);
            tmphe=f.getHalfedge();
            int initid=vertexToPointIndex.get(tmphe.getVertex().key());
            boolean endface=(initid < n);
            initid=initid / strutFacets;
            do {
              final int id=vertexToPointIndex.get(tmphe.getVertex().key());
              endface=((id / strutFacets) == initid) && (id < n);
              if (!endface) {
                break;
              }
              tmphe=tmphe.getNextInFace();
            }
 while (tmphe != f.getHalfedge());
            if (endface) {
              facesToRemove.add(f);
            }
          }
          for (int j=0; j < facesToRemove.size(); j++) {
            tmp.deleteFace(facesToRemove.get(j));
          }
          tmp.cleanUnusedElementsByFace();
          tmp.uncapBoundaryHalfedges();
          for (int j=0; j < struts.size(); j++) {
            int offset;
            if (node == struts.get(j).start()) {
              offset=struts.get(j).getIndex() * 2;
            }
 else {
              offset=(struts.get(j).getIndex() * 2) + 1;
            }
            final WB_Vector v=strutNodeConnections[offset].dir;
            v.mulSelf(strutNodeConnections[offset].offset - strutNodeConnections[offset].maxoffset);
            for (int k=0; k < strutFacets; k++) {
              strutNodeConnections[offset].vertices.get(k).addSelf(v);
            }
          }
          final Iterator<HE_Halfedge> tmpheItr=tmp.heItr();
          HE_Vertex tmpv;
          while (tmpheItr.hasNext()) {
            tmphe=tmpheItr.next();
            tmpv=tmphe.getVertex();
            final int j=vertexToPointIndex.get(tmpv.key());
            mesh.setVertex(tmphe,hullPoints.get(j));
            if (j >= n) {
              mesh.setHalfedge(hullPoints.get(j),tmphe);
            }
          }
          tmp.cleanUnusedElementsByFace();
          mesh.add(tmp);
        }
 catch (        final Exception e) {
        }
      }
    }
    i++;
  }
}","/** 
 */
private void createNodes(){
  int i=0;
  for (  WB_FrameNode node : frame.getNodes()) {
    node=frame.getNode(i);
    final ArrayList<WB_FrameStrut> struts=node.getStruts();
    final ArrayList<HE_Vertex> hullPoints=new ArrayList<HE_Vertex>();
    if (nodeTypes[i] == NodeType.ENDPOINT) {
      if (cap) {
        int offset;
        if (node == struts.get(0).start()) {
          offset=struts.get(0).getIndex() * 2;
        }
 else {
          offset=(struts.get(0).getIndex() * 2) + 1;
        }
        final ArrayList<HE_Halfedge> hes=new ArrayList<HE_Halfedge>(strutFacets);
        final HE_Face f=new HE_Face();
        mesh.add(f);
        for (int k=0; k < strutFacets; k++) {
          final HE_Halfedge he=new HE_Halfedge();
          mesh.setVertex(he,strutNodeConnections[offset].vertices.get(k));
          mesh.setFace(he,f);
          hes.add(he);
          mesh.add(he);
        }
        mesh.setHalfedge(f,hes.get(0));
        f.setInternalLabel(3);
        if (node == struts.get(0).start()) {
          for (int k=0, j=strutFacets - 1; k < strutFacets; j=k, k++) {
            mesh.setNext(hes.get(k),hes.get(j));
          }
        }
 else {
          for (int k=0, j=strutFacets - 1; k < strutFacets; j=k, k++) {
            mesh.setNext(hes.get(j),hes.get(k));
          }
        }
      }
    }
 else {
      if ((nodeTypes[i] != NodeType.ISOLATED) || createIsolatedNodes) {
        double br=strutRadius.evaluate(node.xd(),node.yd(),node.zd());
        for (int j=0; j < struts.size(); j++) {
          int offset;
          if (node == struts.get(j).start()) {
            offset=struts.get(j).getIndex() * 2;
          }
 else {
            offset=(struts.get(j).getIndex() * 2) + 1;
          }
          for (int k=0; k < strutFacets; k++) {
            hullPoints.add(strutNodeConnections[offset].vertices.get(k));
            br=Math.min(br,strutNodeConnections[offset].radius);
          }
        }
        br*=fillfactor;
        final int n=hullPoints.size();
        if ((nodeTypes[i] != NodeType.STRAIGHT) && (nodeTypes[i] != NodeType.BEND) && (!suppressBalljoint)) {
          final HE_Mesh ball=new HE_Mesh(new HEC_Sphere().setRadius(br).setUFacets(strutFacets).setVFacets(strutFacets).setCenter(node));
          hullPoints.addAll(ball.getVerticesAsList());
        }
        final HEC_ConvexHull ch=new HEC_ConvexHull().setPointsFromVertices(hullPoints);
        try {
          final HE_Mesh tmp=new HE_Mesh(ch);
          final Map<Long,Integer> vertexToPointIndex=ch.vertexToPointIndex;
          final Iterator<HE_Face> tmpfItr=tmp.fItr();
          HE_Face f;
          HE_Halfedge tmphe;
          final ArrayList<HE_Face> facesToRemove=new ArrayList<HE_Face>();
          while (tmpfItr.hasNext()) {
            f=tmpfItr.next();
            f.setInternalLabel(2);
            tmphe=f.getHalfedge();
            int initid=vertexToPointIndex.get(tmphe.getVertex().key());
            boolean endface=(initid < n);
            initid=initid / strutFacets;
            do {
              final int id=vertexToPointIndex.get(tmphe.getVertex().key());
              endface=((id / strutFacets) == initid) && (id < n);
              if (!endface) {
                break;
              }
              tmphe=tmphe.getNextInFace();
            }
 while (tmphe != f.getHalfedge());
            if (endface) {
              facesToRemove.add(f);
            }
          }
          for (int j=0; j < facesToRemove.size(); j++) {
            tmp.deleteFace(facesToRemove.get(j));
          }
          tmp.cleanUnusedElementsByFace();
          tmp.uncapBoundaryHalfedges();
          for (int j=0; j < struts.size(); j++) {
            int offset;
            if (node == struts.get(j).start()) {
              offset=struts.get(j).getIndex() * 2;
            }
 else {
              offset=(struts.get(j).getIndex() * 2) + 1;
            }
            final WB_Vector v=strutNodeConnections[offset].dir;
            v.mulSelf(strutNodeConnections[offset].offset - strutNodeConnections[offset].maxoffset);
            for (int k=0; k < strutFacets; k++) {
              strutNodeConnections[offset].vertices.get(k).addSelf(v);
            }
          }
          final Iterator<HE_Halfedge> tmpheItr=tmp.heItr();
          HE_Vertex tmpv;
          while (tmpheItr.hasNext()) {
            tmphe=tmpheItr.next();
            tmpv=tmphe.getVertex();
            final int j=vertexToPointIndex.get(tmpv.key());
            mesh.setVertex(tmphe,hullPoints.get(j));
            if (j >= n) {
              mesh.setHalfedge(hullPoints.get(j),tmphe);
            }
          }
          tmp.cleanUnusedElementsByFace();
          mesh.add(tmp);
        }
 catch (        final Exception e) {
        }
      }
    }
    i++;
  }
}",0.99644277045407
29975,"/** 
 * @param mesh
 * @return
 */
private List<HE_Vertex> getUniqueVertices(final HE_Mesh mesh){
  final List<HE_Vertex> uniqueVertices=new FastTable<HE_Vertex>();
  if (duplicate) {
    final WB_KDTree<WB_Coord,Integer> kdtree=new WB_KDTree<WB_Coord,Integer>();
    WB_KDEntry<WB_Coord,Integer> neighbor;
    HE_Vertex v=new HE_Vertex(source.getVertex(0));
    kdtree.add(source.getVertex(0),0);
    uniqueVertices.add(v);
    mesh.add(v);
    for (int i=1; i < source.getNumberOfVertices(); i++) {
      v=new HE_Vertex(source.getVertex(i));
      v.setTemporaryLabel(i);
      neighbor=kdtree.getNearestNeighbor(v);
      if (neighbor.d2 < WB_Epsilon.SQEPSILON) {
        uniqueVertices.add(uniqueVertices.get(neighbor.value));
      }
 else {
        kdtree.add(source.getVertex(i),i);
        uniqueVertices.add(v);
        mesh.add(uniqueVertices.get(i));
      }
    }
  }
 else {
    HE_Vertex v;
    for (int i=0; i < source.getNumberOfVertices(); i++) {
      v=new HE_Vertex(source.getVertex(i));
      v.setTemporaryLabel(i);
      uniqueVertices.add(v);
      mesh.add(v);
    }
  }
  return uniqueVertices;
}","/** 
 * @param mesh
 * @return
 */
private List<HE_Vertex> getUniqueVertices(final HE_Mesh mesh){
  final List<HE_Vertex> uniqueVertices=new FastTable<HE_Vertex>();
  if (duplicate) {
    final WB_KDTree<WB_Coord,Integer> kdtree=new WB_KDTree<WB_Coord,Integer>();
    WB_KDEntry<WB_Coord,Integer> neighbor;
    HE_Vertex v=new HE_Vertex(source.getVertex(0));
    kdtree.add(source.getVertex(0),0);
    uniqueVertices.add(v);
    mesh.add(v);
    for (int i=1; i < source.getNumberOfVertices(); i++) {
      v=new HE_Vertex(source.getVertex(i));
      v.setInternalLabel(i);
      neighbor=kdtree.getNearestNeighbor(v);
      if (neighbor.d2 < WB_Epsilon.SQEPSILON) {
        uniqueVertices.add(uniqueVertices.get(neighbor.value));
      }
 else {
        kdtree.add(source.getVertex(i),i);
        uniqueVertices.add(v);
        mesh.add(uniqueVertices.get(i));
      }
    }
  }
 else {
    HE_Vertex v;
    for (int i=0; i < source.getNumberOfVertices(); i++) {
      v=new HE_Vertex(source.getVertex(i));
      v.setInternalLabel(i);
      uniqueVertices.add(v);
      mesh.add(v);
    }
  }
  return uniqueVertices;
}",0.9162210338680928
29976,"@Override protected HE_Mesh createBase(){
  final HE_Mesh mesh=new HE_Mesh();
  if (source == null) {
    return mesh;
  }
  final int[][] faces=source.getFacesAsInt();
  final List<HE_Vertex> uniqueVertices=getUniqueVertices(mesh);
  if (normalcheck) {
    unifyNormals(faces);
  }
  int id=0;
  HE_Halfedge he;
  for (  final int[] face : faces) {
    final ArrayList<HE_Halfedge> faceEdges=new ArrayList<HE_Halfedge>();
    final HE_Face hef=new HE_Face();
    hef.setTemporaryLabel(id);
    id++;
    final int fl=face.length;
    final int[] locface=new int[fl];
    int li=0;
    locface[li++]=face[0];
    for (int i=1; i < (fl - 1); i++) {
      if (uniqueVertices.get(face[i]) != uniqueVertices.get(face[i - 1])) {
        locface[li++]=face[i];
      }
    }
    if ((uniqueVertices.get(face[fl - 1]) != uniqueVertices.get(face[fl - 2])) && (uniqueVertices.get(face[fl - 1]) != uniqueVertices.get(face[0]))) {
      locface[li++]=face[fl - 1];
    }
    if (li > 2) {
      for (int i=0; i < li; i++) {
        he=new HE_Halfedge();
        faceEdges.add(he);
        mesh.setFace(he,hef);
        if (hef.getHalfedge() == null) {
          mesh.setHalfedge(hef,he);
        }
        mesh.setVertex(he,uniqueVertices.get(locface[i]));
        mesh.setHalfedge(he.getVertex(),he);
      }
      mesh.add(hef);
      mesh.cycleHalfedges(faceEdges);
      mesh.addHalfedges(faceEdges);
    }
  }
  mesh.pairHalfedges();
  mesh.capHalfedges();
  return mesh;
}","@Override protected HE_Mesh createBase(){
  final HE_Mesh mesh=new HE_Mesh();
  if (source == null) {
    return mesh;
  }
  final int[][] faces=source.getFacesAsInt();
  final List<HE_Vertex> uniqueVertices=getUniqueVertices(mesh);
  if (normalcheck) {
    unifyNormals(faces);
  }
  int id=0;
  HE_Halfedge he;
  for (  final int[] face : faces) {
    final ArrayList<HE_Halfedge> faceEdges=new ArrayList<HE_Halfedge>();
    final HE_Face hef=new HE_Face();
    hef.setInternalLabel(id);
    id++;
    final int fl=face.length;
    final int[] locface=new int[fl];
    int li=0;
    locface[li++]=face[0];
    for (int i=1; i < (fl - 1); i++) {
      if (uniqueVertices.get(face[i]) != uniqueVertices.get(face[i - 1])) {
        locface[li++]=face[i];
      }
    }
    if ((uniqueVertices.get(face[fl - 1]) != uniqueVertices.get(face[fl - 2])) && (uniqueVertices.get(face[fl - 1]) != uniqueVertices.get(face[0]))) {
      locface[li++]=face[fl - 1];
    }
    if (li > 2) {
      for (int i=0; i < li; i++) {
        he=new HE_Halfedge();
        faceEdges.add(he);
        mesh.setFace(he,hef);
        if (hef.getHalfedge() == null) {
          mesh.setHalfedge(hef,he);
        }
        mesh.setVertex(he,uniqueVertices.get(locface[i]));
        mesh.setHalfedge(he.getVertex(),he);
      }
      mesh.add(hef);
      mesh.cycleHalfedges(faceEdges);
      mesh.addHalfedges(faceEdges);
    }
  }
  mesh.pairHalfedges();
  mesh.capHalfedges();
  return mesh;
}",0.9942038868053188
29977,"@Override protected HE_Mesh createBase(){
  if (cells == null) {
    return new HE_Mesh();
  }
  if (on == null) {
    return new HE_Mesh();
  }
  if (on.length > cells.size()) {
    return new HE_Mesh();
  }
  final int n=on.length;
  final FastTable<HE_Face> tmpfaces=new FastTable<HE_Face>();
  int nv=0;
  for (int i=0; i < n; i++) {
    final HE_Mesh m=cells.getMesh(i);
    if (on[i]) {
      final Iterator<HE_Face> fItr=m.fItr();
      while (fItr.hasNext()) {
        final HE_Face f=fItr.next();
        if (f.getTemporaryLabel() == -1) {
          tmpfaces.add(f);
          nv+=f.getFaceOrder();
        }
 else         if (!on[f.getTemporaryLabel()] || membrane) {
          tmpfaces.add(f);
          nv+=f.getFaceOrder();
        }
      }
    }
  }
  final WB_Coord[] vertices=new WB_Coord[nv];
  final int[][] faces=new int[tmpfaces.size()][];
  final int[] labels=new int[tmpfaces.size()];
  final int[] intlabels=new int[tmpfaces.size()];
  final int[] colors=new int[tmpfaces.size()];
  int cid=0;
  for (int i=0; i < tmpfaces.size(); i++) {
    final HE_Face f=tmpfaces.get(i);
    faces[i]=new int[f.getFaceOrder()];
    labels[i]=f.getLabel();
    intlabels[i]=f.getTemporaryLabel();
    colors[i]=f.getColor();
    HE_Halfedge he=f.getHalfedge();
    for (int j=0; j < f.getFaceOrder(); j++) {
      vertices[cid]=he.getVertex();
      faces[i][j]=cid;
      he=he.getNextInFace();
      cid++;
    }
  }
  final HEC_FromFacelist ffl=new HEC_FromFacelist().setVertices(vertices).setFaces(faces).setDuplicate(true);
  final HE_Mesh result=ffl.createBase();
  final Iterator<HE_Face> fItr=result.fItr();
  int i=0;
  HE_Face f;
  while (fItr.hasNext()) {
    f=fItr.next();
    f.setLabel(labels[i]);
    f.setTemporaryLabel(intlabels[i]);
    f.setColor(colors[i]);
    i++;
  }
  result.fixNonManifoldVertices();
  if (!capBoundaries) {
    final HE_Selection sel=HE_Selection.selectFacesWithTemporaryLabel(result,-1);
    final HE_FaceIterator fitr=sel.fItr();
    while (fitr.hasNext()) {
      result.deleteFace(fitr.next());
    }
    result.cleanUnusedElementsByFace();
    result.capHalfedges();
  }
  return result;
}","@Override protected HE_Mesh createBase(){
  if (cells == null) {
    return new HE_Mesh();
  }
  if (on == null) {
    return new HE_Mesh();
  }
  if (on.length > cells.size()) {
    return new HE_Mesh();
  }
  final int n=on.length;
  final FastTable<HE_Face> tmpfaces=new FastTable<HE_Face>();
  int nv=0;
  for (int i=0; i < n; i++) {
    final HE_Mesh m=cells.getMesh(i);
    if (on[i]) {
      final Iterator<HE_Face> fItr=m.fItr();
      while (fItr.hasNext()) {
        final HE_Face f=fItr.next();
        if (f.getInternalLabel() == -1) {
          tmpfaces.add(f);
          nv+=f.getFaceOrder();
        }
 else         if (!on[f.getInternalLabel()] || membrane) {
          tmpfaces.add(f);
          nv+=f.getFaceOrder();
        }
      }
    }
  }
  final WB_Coord[] vertices=new WB_Coord[nv];
  final int[][] faces=new int[tmpfaces.size()][];
  final int[] labels=new int[tmpfaces.size()];
  final int[] intlabels=new int[tmpfaces.size()];
  final int[] colors=new int[tmpfaces.size()];
  int cid=0;
  for (int i=0; i < tmpfaces.size(); i++) {
    final HE_Face f=tmpfaces.get(i);
    faces[i]=new int[f.getFaceOrder()];
    labels[i]=f.getLabel();
    intlabels[i]=f.getInternalLabel();
    colors[i]=f.getColor();
    HE_Halfedge he=f.getHalfedge();
    for (int j=0; j < f.getFaceOrder(); j++) {
      vertices[cid]=he.getVertex();
      faces[i][j]=cid;
      he=he.getNextInFace();
      cid++;
    }
  }
  final HEC_FromFacelist ffl=new HEC_FromFacelist().setVertices(vertices).setFaces(faces).setDuplicate(true);
  final HE_Mesh result=ffl.createBase();
  final Iterator<HE_Face> fItr=result.fItr();
  int i=0;
  HE_Face f;
  while (fItr.hasNext()) {
    f=fItr.next();
    f.setLabel(labels[i]);
    f.setInternalLabel(intlabels[i]);
    f.setColor(colors[i]);
    i++;
  }
  result.fixNonManifoldVertices();
  if (!capBoundaries) {
    final HE_Selection sel=HE_Selection.selectFacesWithInternalLabel(result,-1);
    final HE_FaceIterator fitr=sel.fItr();
    while (fitr.hasNext()) {
      result.deleteFace(fitr.next());
    }
    result.cleanUnusedElementsByFace();
    result.capHalfedges();
  }
  return result;
}",0.9671405266837568
29978,"@Override protected HE_Mesh createBase(){
  if (polygon == null) {
    return null;
  }
  final WB_Vector norm=polygon.getPlane().getNormal();
  final int n=polygon.getNumberOfPoints();
  final boolean surf=WB_Epsilon.isZero(thickness);
  final WB_Coord[] points=new WB_Coord[surf ? n : 2 * n];
  for (int i=0; i < n; i++) {
    points[i]=polygon.getPoint(i);
  }
  if (!surf) {
    for (int i=0; i < n; i++) {
      points[n + i]=new WB_Point(points[i]).addMulSelf(thickness,norm);
    }
  }
  int[][] faces;
  if (surf) {
    faces=new int[1][n];
    for (int i=0; i < n; i++) {
      faces[0][i]=i;
    }
  }
 else {
    faces=new int[n + 2][];
    faces[n]=new int[n];
    faces[n + 1]=new int[n];
    for (int i=0; i < n; i++) {
      faces[n][i]=i;
      faces[n + 1][i]=(2 * n) - 1 - i;
      faces[i]=new int[4];
      faces[i][0]=i;
      faces[i][3]=(i + 1) % n;
      faces[i][2]=n + ((i + 1) % n);
      faces[i][1]=n + i;
    }
  }
  final HEC_FromFacelist fl=new HEC_FromFacelist();
  fl.setVertices(points).setFaces(faces).setDuplicate(false);
  return fl.createBase().flipAllFaces();
}","@Override protected HE_Mesh createBase(){
  if (polygon == null) {
    return null;
  }
  final WB_Vector norm=polygon.getPlane().getNormal();
  final int n=polygon.getNumberOfPoints();
  final boolean surf=WB_Epsilon.isZero(thickness);
  final WB_Coord[] points=new WB_Coord[surf ? n : 2 * n];
  for (int i=0; i < n; i++) {
    points[i]=polygon.getPoint(i);
  }
  if (!surf) {
    for (int i=0; i < n; i++) {
      points[n + i]=new WB_Point(points[i]).addMulSelf(thickness,norm);
    }
  }
  int[][] faces;
  if (surf) {
    faces=new int[1][n];
    for (int i=0; i < n; i++) {
      faces[0][i]=i;
    }
  }
 else {
    faces=new int[n + 2][];
    faces[n]=new int[n];
    faces[n + 1]=new int[n];
    for (int i=0; i < n; i++) {
      faces[n][i]=i;
      faces[n + 1][i]=(2 * n) - 1 - i;
      faces[i]=new int[4];
      faces[i][0]=i;
      faces[i][3]=(i + 1) % n;
      faces[i][2]=n + ((i + 1) % n);
      faces[i][1]=n + i;
    }
  }
  final HEC_FromFacelist fl=new HEC_FromFacelist();
  fl.setVertices(points).setFaces(faces).setDuplicate(false);
  return fl.createBase().flipFaces();
}",0.9986357435197816
29979,"@Override protected HE_Mesh createBase(){
  if ((facets < 3) || (WB_Epsilon.isZero(radius))) {
    return null;
  }
  final WB_Point[] ppoints=new WB_Point[facets];
  for (int i=0; i < facets; i++) {
    final double x=radius * Math.cos(((Math.PI * 2.0) / facets) * i);
    final double y=radius * Math.sin(((Math.PI * 2.0) / facets) * i);
    ppoints[i]=new WB_Point(x,y,0.0);
  }
  final WB_Polygon polygon=gf.createSimplePolygon(ppoints);
  final WB_Vector norm=polygon.getPlane().getNormal();
  final int n=polygon.getNumberOfPoints();
  final boolean surf=WB_Epsilon.isZero(thickness);
  final WB_Coord[] points=new WB_Coord[surf ? n : 2 * n];
  for (int i=0; i < n; i++) {
    points[i]=polygon.getPoint(i);
  }
  if (!surf) {
    for (int i=0; i < n; i++) {
      points[n + i]=new WB_Point(points[i]).addMulSelf(thickness,norm);
    }
  }
  int[][] faces;
  if (surf) {
    faces=new int[1][n];
    for (int i=0; i < n; i++) {
      faces[0][i]=i;
    }
  }
 else {
    faces=new int[n + 2][];
    faces[n]=new int[n];
    faces[n + 1]=new int[n];
    for (int i=0; i < n; i++) {
      faces[n][i]=i;
      faces[n + 1][i]=(2 * n) - 1 - i;
      faces[i]=new int[4];
      faces[i][0]=i;
      faces[i][3]=(i + 1) % n;
      faces[i][2]=n + ((i + 1) % n);
      faces[i][1]=n + i;
    }
  }
  final HEC_FromFacelist fl=new HEC_FromFacelist();
  fl.setVertices(points).setFaces(faces).setDuplicate(false);
  return fl.createBase().flipAllFaces();
}","@Override protected HE_Mesh createBase(){
  if ((facets < 3) || (WB_Epsilon.isZero(radius))) {
    return null;
  }
  final WB_Point[] ppoints=new WB_Point[facets];
  for (int i=0; i < facets; i++) {
    final double x=radius * Math.cos(((Math.PI * 2.0) / facets) * i);
    final double y=radius * Math.sin(((Math.PI * 2.0) / facets) * i);
    ppoints[i]=new WB_Point(x,y,0.0);
  }
  final WB_Polygon polygon=gf.createSimplePolygon(ppoints);
  final WB_Vector norm=polygon.getPlane().getNormal();
  final int n=polygon.getNumberOfPoints();
  final boolean surf=WB_Epsilon.isZero(thickness);
  final WB_Coord[] points=new WB_Coord[surf ? n : 2 * n];
  for (int i=0; i < n; i++) {
    points[i]=polygon.getPoint(i);
  }
  if (!surf) {
    for (int i=0; i < n; i++) {
      points[n + i]=new WB_Point(points[i]).addMulSelf(thickness,norm);
    }
  }
  int[][] faces;
  if (surf) {
    faces=new int[1][n];
    for (int i=0; i < n; i++) {
      faces[0][i]=i;
    }
  }
 else {
    faces=new int[n + 2][];
    faces[n]=new int[n];
    faces[n + 1]=new int[n];
    for (int i=0; i < n; i++) {
      faces[n][i]=i;
      faces[n + 1][i]=(2 * n) - 1 - i;
      faces[i]=new int[4];
      faces[i][0]=i;
      faces[i][3]=(i + 1) % n;
      faces[i][2]=n + ((i + 1) % n);
      faces[i][1]=n + i;
    }
  }
  final HEC_FromFacelist fl=new HEC_FromFacelist();
  fl.setVertices(points).setFaces(faces).setDuplicate(false);
  return fl.createBase().flipFaces();
}",0.998968008255934
29980,"/** 
 * @param P
 * @param p
 * @return
 */
public static WB_Classification classifyPointToPlane3D(final WB_Plane P,final WB_Coord p){
  if (WB_Epsilon.isZero(WB_GeometryOp.getDistanceToPlane3D(p,P))) {
    return WB_Classification.ON;
  }
  final WB_Predicates predicates=new WB_Predicates();
  final double signp=predicates.orientTetra(P.getOrigin(),P.getOrigin().addMul(100,P.getU()),P.getOrigin().addMul(100,P.getV()),p);
  if (signp == 0) {
    return WB_Classification.ON;
  }
  if (signp < 0) {
    return WB_Classification.FRONT;
  }
  return WB_Classification.BACK;
}","/** 
 * @param P
 * @param p
 * @return WB_Classification.ON,WB_Classification.FRONT or WB_Classification.BACK
 */
public static WB_Classification classifyPointToPlane3D(final WB_Plane P,final WB_Coord p){
  if (WB_Epsilon.isZero(WB_GeometryOp.getDistanceToPlane3D(p,P))) {
    return WB_Classification.ON;
  }
  final WB_Predicates predicates=new WB_Predicates();
  final double signp=predicates.orientTetra(P.getOrigin(),P.getOrigin().addMul(100,P.getU()),P.getOrigin().addMul(100,P.getV()),p);
  if (signp == 0) {
    return WB_Classification.ON;
  }
  if (signp < 0) {
    return WB_Classification.FRONT;
  }
  return WB_Classification.BACK;
}",0.9419460343417824
29981,"/** 
 * @return 
 */
protected List<WB_Point> getPoints(){
  return points;
}","/** 
 * @return
 */
public List<WB_Point> getPoints(){
  return points;
}",0.92
29982,"@Override protected HE_Mesh createBase(){
  final double oW=-0.5 * W;
  final double oH=-0.5 * H;
  final double oD=-0.5 * D;
  final double dW=(W * 1.0) / L;
  final double dH=(H * 1.0) / M;
  final double dD=(D * 1.0) / N;
  final double di=1.0 / L;
  final double dj=1.0 / M;
  final double dk=1.0 / N;
  final double[][] vertices=new double[(2 * (L + 1) * (M + 1)) + (2 * (L + 1) * (N + 1)) + (2 * (M + 1) * (N + 1))][3];
  final double[][] uvws=new double[(2 * (L + 1) * (M + 1)) + (2 * (L + 1) * (N + 1)) + (2 * (M + 1) * (N + 1))][3];
  final int[][] faces=new int[(2 * M * L) + (2 * L * N) + (2 * M * N)][4];
  final int[] faceTextureIds=new int[(2 * M * L) + (2 * L * N) + (2 * M * N)];
  int idv=0;
  int idf=0;
  final int LMv=(L + 1) * (M + 1);
  final int LMf=L * M;
  final int LNv=(L + 1) * (N + 1);
  final int LNf=L * N;
  final int MNv=(M + 1) * (N + 1);
  final int MNf=M * N;
  for (int v=0; v < (M + 1); v++) {
    for (int u=0; u < (L + 1); u++) {
      vertices[idv][0]=vertices[idv + LMv][0]=oW + (u * dW);
      vertices[idv][1]=vertices[idv + LMv][1]=oH + (v * dH);
      vertices[idv][2]=oD;
      vertices[idv + LMv][2]=-oD;
      uvws[idv][0]=di * u;
      uvws[idv + LMv][1]=uvws[idv][1]=dj * v;
      uvws[idv + LMv][0]=1 - uvws[idv][0];
      uvws[idv][2]=uvws[idv + LMv][2]=0;
      idv++;
    }
  }
  for (int j=0; j < M; j++) {
    for (int i=0; i < L; i++) {
      faces[idf][3]=i + (j * (L + 1));
      faces[idf][2]=i + 1 + (j * (L + 1));
      faces[idf][1]=i + 1 + ((j + 1) * (L + 1));
      faces[idf][0]=i + ((j + 1) * (L + 1));
      faces[idf + LMf][0]=i + (j * (L + 1)) + LMv;
      faces[idf + LMf][1]=i + 1 + (j * (L + 1))+ LMv;
      faces[idf + LMf][2]=i + 1 + ((j + 1) * (L + 1))+ LMv;
      faces[idf + LMf][3]=i + ((j + 1) * (L + 1)) + LMv;
      faceTextureIds[idf]=0;
      faceTextureIds[idf + LMf]=1;
      idf++;
    }
  }
  int offset=2 * LMv;
  idv=offset;
  for (int v=0; v < (N + 1); v++) {
    for (int u=0; u < (L + 1); u++) {
      vertices[idv][0]=vertices[idv + LNv][0]=oW + (u * dW);
      vertices[idv][2]=vertices[idv + LNv][2]=oD + (v * dD);
      vertices[idv][1]=oH;
      vertices[idv + LNv][1]=-oH;
      uvws[idv][0]=uvws[idv + LMv][0]=di * u;
      uvws[idv + LMv][1]=dk * v;
      uvws[idv][1]=1 - uvws[idv + LMv][1];
      uvws[idv][2]=uvws[idv + LMv][2]=0;
      idv++;
    }
  }
  idf=2 * LMf;
  for (int j=0; j < N; j++) {
    for (int i=0; i < L; i++) {
      faces[idf][0]=i + (j * (L + 1)) + offset;
      faces[idf][1]=i + 1 + (j * (L + 1))+ offset;
      faces[idf][2]=i + 1 + ((j + 1) * (L + 1))+ offset;
      faces[idf][3]=i + ((j + 1) * (L + 1)) + offset;
      faces[idf + LNf][3]=i + (j * (L + 1)) + LNv+ offset;
      faces[idf + LNf][2]=i + 1 + (j * (L + 1))+ LNv+ offset;
      faces[idf + LNf][1]=i + 1 + ((j + 1) * (L + 1))+ LNv+ offset;
      faces[idf + LNf][0]=i + ((j + 1) * (L + 1)) + LNv+ offset;
      faceTextureIds[idf]=2;
      faceTextureIds[idf + LNf]=3;
      idf++;
    }
  }
  offset=(2 * LMv) + (2 * LNv);
  idv=offset;
  for (int u=0; u < (N + 1); u++) {
    for (int v=0; v < (M + 1); v++) {
      vertices[idv][1]=vertices[idv + MNv][1]=oH + (v * dH);
      vertices[idv][2]=vertices[idv + MNv][2]=oD + (u * dD);
      vertices[idv][0]=oW;
      vertices[idv + MNv][0]=-oW;
      uvws[idv + LMv][0]=dk * u;
      uvws[idv][0]=1 - uvws[idv + LMv][0];
      uvws[idv + LMv][1]=uvws[idv][1]=v * dj;
      uvws[idv + LMv][2]=uvws[idv][2]=0;
      idv++;
    }
  }
  idf=(2 * LMf) + (2 * LNf);
  for (int j=0; j < N; j++) {
    for (int i=0; i < M; i++) {
      faces[idf][3]=i + (j * (M + 1)) + offset;
      faces[idf][2]=i + 1 + (j * (M + 1))+ offset;
      faces[idf][1]=i + 1 + ((j + 1) * (M + 1))+ offset;
      faces[idf][0]=i + ((j + 1) * (M + 1)) + offset;
      faces[idf + MNf][0]=i + (j * (M + 1)) + MNv+ offset;
      faces[idf + MNf][1]=i + 1 + (j * (M + 1))+ MNv+ offset;
      faces[idf + MNf][2]=i + 1 + ((j + 1) * (M + 1))+ MNv+ offset;
      faces[idf + MNf][3]=i + ((j + 1) * (M + 1)) + MNv+ offset;
      faceTextureIds[idf]=4;
      faceTextureIds[idf + MNf]=5;
      idf++;
    }
  }
  final HEC_FromFacelist fl=new HEC_FromFacelist();
  fl.setVertices(vertices).setFaces(faces).setDuplicate(true).setUVW(uvws).setFaceTextureIds(faceTextureIds);
  return fl.createBase();
}","@Override protected HE_Mesh createBase(){
  final double oW=-0.5 * W;
  final double oH=-0.5 * H;
  final double oD=-0.5 * D;
  final double dW=(W * 1.0) / L;
  final double dH=(H * 1.0) / M;
  final double dD=(D * 1.0) / N;
  final double di=1.0 / L;
  final double dj=1.0 / M;
  final double dk=1.0 / N;
  final double[][] vertices=new double[(2 * (L + 1) * (M + 1)) + (2 * (L + 1) * (N + 1)) + (2 * (M + 1) * (N + 1))][3];
  final double[][] uvws=new double[(2 * (L + 1) * (M + 1)) + (2 * (L + 1) * (N + 1)) + (2 * (M + 1) * (N + 1))][3];
  final int[][] faces=new int[(2 * M * L) + (2 * L * N) + (2 * M * N)][4];
  final int[] faceTextureIds=new int[(2 * M * L) + (2 * L * N) + (2 * M * N)];
  int idv=0;
  int idf=0;
  final int LMv=(L + 1) * (M + 1);
  final int LMf=L * M;
  final int LNv=(L + 1) * (N + 1);
  final int LNf=L * N;
  final int MNv=(M + 1) * (N + 1);
  final int MNf=M * N;
  for (int v=0; v < (M + 1); v++) {
    for (int u=0; u < (L + 1); u++) {
      vertices[idv][0]=vertices[idv + LMv][0]=oW + (u * dW);
      vertices[idv][1]=vertices[idv + LMv][1]=oH + (v * dH);
      vertices[idv][2]=oD;
      vertices[idv + LMv][2]=-oD;
      uvws[idv][0]=di * u;
      uvws[idv + LMv][1]=uvws[idv][1]=dj * v;
      uvws[idv + LMv][0]=1 - uvws[idv][0];
      uvws[idv][2]=uvws[idv + LMv][2]=0;
      idv++;
    }
  }
  for (int j=0; j < M; j++) {
    for (int i=0; i < L; i++) {
      faces[idf][3]=i + (j * (L + 1));
      faces[idf][2]=i + 1 + (j * (L + 1));
      faces[idf][1]=i + 1 + ((j + 1) * (L + 1));
      faces[idf][0]=i + ((j + 1) * (L + 1));
      faces[idf + LMf][0]=i + (j * (L + 1)) + LMv;
      faces[idf + LMf][1]=i + 1 + (j * (L + 1))+ LMv;
      faces[idf + LMf][2]=i + 1 + ((j + 1) * (L + 1))+ LMv;
      faces[idf + LMf][3]=i + ((j + 1) * (L + 1)) + LMv;
      faceTextureIds[idf]=0;
      faceTextureIds[idf + LMf]=1;
      idf++;
    }
  }
  int offset=2 * LMv;
  idv=offset;
  for (int v=0; v < (N + 1); v++) {
    for (int u=0; u < (L + 1); u++) {
      vertices[idv][0]=vertices[idv + LNv][0]=oW + (u * dW);
      vertices[idv][2]=vertices[idv + LNv][2]=oD + (v * dD);
      vertices[idv][1]=oH;
      vertices[idv + LNv][1]=-oH;
      uvws[idv][0]=uvws[idv + LNv][0]=di * u;
      uvws[idv + LNv][1]=dk * v;
      uvws[idv][1]=1 - uvws[idv + LNv][1];
      uvws[idv][2]=uvws[idv + LNv][2]=0;
      idv++;
    }
  }
  idf=2 * LMf;
  for (int j=0; j < N; j++) {
    for (int i=0; i < L; i++) {
      faces[idf][0]=i + (j * (L + 1)) + offset;
      faces[idf][1]=i + 1 + (j * (L + 1))+ offset;
      faces[idf][2]=i + 1 + ((j + 1) * (L + 1))+ offset;
      faces[idf][3]=i + ((j + 1) * (L + 1)) + offset;
      faces[idf + LNf][3]=i + (j * (L + 1)) + LNv+ offset;
      faces[idf + LNf][2]=i + 1 + (j * (L + 1))+ LNv+ offset;
      faces[idf + LNf][1]=i + 1 + ((j + 1) * (L + 1))+ LNv+ offset;
      faces[idf + LNf][0]=i + ((j + 1) * (L + 1)) + LNv+ offset;
      faceTextureIds[idf]=2;
      faceTextureIds[idf + LNf]=3;
      idf++;
    }
  }
  offset=(2 * LMv) + (2 * LNv);
  idv=offset;
  for (int u=0; u < (N + 1); u++) {
    for (int v=0; v < (M + 1); v++) {
      vertices[idv][1]=vertices[idv + MNv][1]=oH + (v * dH);
      vertices[idv][2]=vertices[idv + MNv][2]=oD + (u * dD);
      vertices[idv][0]=oW;
      vertices[idv + MNv][0]=-oW;
      uvws[idv + MNv][0]=dk * u;
      uvws[idv][0]=1 - uvws[idv + MNv][0];
      uvws[idv + MNv][1]=uvws[idv][1]=v * dj;
      uvws[idv + MNv][2]=uvws[idv][2]=0;
      idv++;
    }
  }
  idf=(2 * LMf) + (2 * LNf);
  for (int j=0; j < N; j++) {
    for (int i=0; i < M; i++) {
      faces[idf][3]=i + (j * (M + 1)) + offset;
      faces[idf][2]=i + 1 + (j * (M + 1))+ offset;
      faces[idf][1]=i + 1 + ((j + 1) * (M + 1))+ offset;
      faces[idf][0]=i + ((j + 1) * (M + 1)) + offset;
      faces[idf + MNf][0]=i + (j * (M + 1)) + MNv+ offset;
      faces[idf + MNf][1]=i + 1 + (j * (M + 1))+ MNv+ offset;
      faces[idf + MNf][2]=i + 1 + ((j + 1) * (M + 1))+ MNv+ offset;
      faces[idf + MNf][3]=i + ((j + 1) * (M + 1)) + MNv+ offset;
      faceTextureIds[idf]=4;
      faceTextureIds[idf + MNf]=5;
      idf++;
    }
  }
  final HEC_FromFacelist fl=new HEC_FromFacelist();
  fl.setVertices(vertices).setFaces(faces).setDuplicate(true).setUVW(uvws).setFaceTextureIds(faceTextureIds);
  return fl.createBase();
}",0.99721383793824
29983,"/** 
 * @param tuples
 */
protected WB_CoordinateSequence(final double[][] tuples){
  ordinates=new TDoubleArrayList(tuples.length,Double.NaN);
  n=tuples.length;
  for (  final double[] p : tuples) {
    ordinates.add(p[0]);
    ordinates.add(p[1]);
    ordinates.add(p[2]);
    ordinates.add(p[3]);
  }
}","/** 
 * @param tuples
 */
public WB_CoordinateSequence(final double[][] tuples){
  ordinates=new TDoubleArrayList(tuples.length,Double.NaN);
  n=tuples.length;
  for (  final double[] p : tuples) {
    ordinates.add(p[0]);
    ordinates.add(p[1]);
    ordinates.add(p[2]);
    ordinates.add(p[3]);
  }
  revision=0;
}",0.9598715890850722
29984,"/** 
 * @return 
 */
public WB_Point getCenter(){
  final double[] center=new double[3];
  for (int i=0; i < 3; i++) {
    center[i]=0.5 * (_min[i] + _max[i]);
  }
  return new WB_Point(center);
}","/** 
 * @return
 */
public WB_Point getCenter(){
  final double[] center=new double[3];
  for (int i=0; i < 3; i++) {
    center[i]=0.5 * (_min[i] + _max[i]);
  }
  return new WB_Point(center);
}",0.9974424552429668
29985,"/** 
 * @param other 
 */
public void expandToInclude(final WB_AABB other){
  expandToInclude(other._min);
  expandToInclude(other._max);
}","/** 
 * @param other
 */
public void expandToInclude(final WB_AABB other){
  expandToInclude(other._min);
  expandToInclude(other._max);
}",0.9963898916967509
29986,"/** 
 * @param x 
 * @param y 
 * @param z 
 */
public void translate(final double x,final double y,final double z){
  if (isNull()) {
    return;
  }
  _min[0]+=x;
  _max[0]+=x;
  _min[1]+=y;
  _max[1]+=y;
  _min[2]+=z;
  _max[2]+=z;
}","/** 
 * @param x
 * @param y
 * @param z
 */
public void translate(final double x,final double y,final double z){
  if (isNull()) {
    return;
  }
  _min[0]+=x;
  _max[0]+=x;
  _min[1]+=y;
  _max[1]+=y;
  _min[2]+=z;
  _max[2]+=z;
}",0.9936034115138592
29987,"/** 
 * @param factor 
 */
public void pad(final double factor){
  final WB_Point c=getCenter();
  for (int i=0; i < 3; i++) {
    _min[i]=c.getd(i) + ((factor + 1.0) * (_min[i] - c.getd(i)));
    _max[i]=c.getd(i) + ((factor + 1.0) * (_max[i] - c.getd(i)));
  }
}","/** 
 * @param factor
 */
public void pad(final double factor){
  final WB_Point c=getCenter();
  for (int i=0; i < 3; i++) {
    _min[i]=c.getd(i) + ((factor + 1.0) * (_min[i] - c.getd(i)));
    _max[i]=c.getd(i) + ((factor + 1.0) * (_max[i] - c.getd(i)));
  }
}",0.9981024667931688
29988,"/** 
 * @return 
 */
public WB_Point getMin(){
  return new WB_Point(_min);
}","/** 
 * @return
 */
public WB_Point getMin(){
  return new WB_Point(_min);
}",0.9934640522875816
29989,"/** 
 * @param other 
 * @return 
 */
public WB_AABB intersection(final WB_AABB other){
  if (isNull() || other.isNull() || !intersects(other)) {
    return null;
  }
  final double[] newmin=new double[3];
  final double[] newmax=new double[3];
  for (int i=0; i < 3; i++) {
    newmin[i]=Math.max(_min[i],other._min[i]);
    newmax[i]=Math.min(_max[i],other._max[i]);
  }
  return new WB_AABB(newmin,newmax);
}","/** 
 * @param other
 * @return
 */
public WB_AABB intersection(final WB_AABB other){
  if (isNull() || other.isNull() || !intersects(other)) {
    return null;
  }
  final double[] newmin=new double[3];
  final double[] newmax=new double[3];
  for (int i=0; i < 3; i++) {
    newmin[i]=Math.max(_min[i],other._min[i]);
    newmax[i]=Math.min(_max[i],other._max[i]);
  }
  return new WB_AABB(newmin,newmax);
}",0.997560975609756
29990,"/** 
 * @param id 
 */
public void setId(final int id){
  _id=id;
}","/** 
 * @param id
 */
public void setId(final int id){
  _id=id;
}",0.9924812030075189
29991,"/** 
 * @return 
 */
public double getCenterZ(){
  return 0.5 * (_min[2] + _max[2]);
}","/** 
 * @return
 */
public double getCenterZ(){
  return 0.5 * (_min[2] + _max[2]);
}",0.9941520467836256
29992,"/** 
 * @return 
 */
public double getCenterY(){
  return 0.5 * (_min[1] + _max[1]);
}","/** 
 * @return
 */
public double getCenterY(){
  return 0.5 * (_min[1] + _max[1]);
}",0.9941520467836256
29993,"/** 
 * @return 
 */
public double getCenterX(){
  return 0.5 * (_min[0] + _max[0]);
}","/** 
 * @return
 */
public double getCenterX(){
  return 0.5 * (_min[0] + _max[0]);
}",0.9941520467836256
29994,"/** 
 * @return 
 */
public WB_Point getMax(){
  return new WB_Point(_max);
}","/** 
 * @return
 */
public WB_Point getMax(){
  return new WB_Point(_max);
}",0.9934640522875816
29995,"/** 
 * @return 
 */
public int getTrueDim(){
  if (!isValid()) {
    return -1;
  }
  int dim=0;
  for (int i=0; i < 3; i++) {
    if ((_max[i] - _min[i]) >= WB_Epsilon.EPSILON) {
      dim++;
    }
  }
  return dim;
}","/** 
 * @return
 */
public int getTrueDim(){
  if (!isValid()) {
    return -1;
  }
  int dim=0;
  for (int i=0; i < 3; i++) {
    if ((_max[i] - _min[i]) >= WB_Epsilon.EPSILON) {
      dim++;
    }
  }
  return dim;
}",0.9977116704805492
29996,"/** 
 * @param x 
 * @return 
 */
public boolean contains(final double[] x){
  return covers(x);
}","/** 
 * @param x
 * @return
 */
public boolean contains(final double[] x){
  return covers(x);
}",0.9896907216494846
29997,"/** 
 * @return 
 */
public double getMinZ(){
  return _min[2];
}","/** 
 * @return
 */
public double getMinZ(){
  return _min[2];
}",0.992248062015504
29998,"/** 
 * @return 
 */
public double getMinX(){
  return _min[0];
}","/** 
 * @return
 */
public double getMinX(){
  return _min[0];
}",0.992248062015504
29999,"/** 
 * @return 
 */
public double getMinY(){
  return _min[1];
}","/** 
 * @return
 */
public double getMinY(){
  return _min[1];
}",0.992248062015504
30000,"/** 
 * @return 
 */
public List<double[]> getCoords(){
  if (isNull()) {
    return null;
  }
  final int n=numberOfPoints();
  final List<double[]> points=new ArrayList<double[]>(n);
  double[] values;
  for (int i=0; i < n; i++) {
    values=new double[3];
    int disc=1;
    for (int j=0; j < 3; j++) {
      if (((i / disc) % 2) == 0) {
        values[j]=_min[j];
      }
 else {
        values[j]=_max[j];
      }
      disc*=2;
    }
    points.add(values);
  }
  return points;
}","/** 
 * @return
 */
public List<double[]> getCoords(){
  if (isNull()) {
    return null;
  }
  final int n=numberOfPoints();
  final List<double[]> points=new ArrayList<double[]>(n);
  double[] values;
  for (int i=0; i < n; i++) {
    values=new double[3];
    int disc=1;
    for (int j=0; j < 3; j++) {
      if (((i / disc) % 2) == 0) {
        values[j]=_min[j];
      }
 else {
        values[j]=_max[j];
      }
      disc*=2;
    }
    points.add(values);
  }
  return points;
}",0.9989743589743588
