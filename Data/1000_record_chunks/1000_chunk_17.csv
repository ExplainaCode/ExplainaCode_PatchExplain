record_number,buggy_code,fixed_code,code_similarity
16001,"/** 
 * Dump the contents of the file.
 * @param fileName the name of the file
 * @param writer the print writer
 */
public static void dump(String fileName,PrintWriter writer){
  if (!FileUtils.exists(fileName)) {
    writer.println(""String_Node_Str"" + fileName);
    return;
  }
  FileChannel file=null;
  try {
    file=FilePath.get(fileName).open(""String_Node_Str"");
    long fileLength=file.size();
    file.position(0);
    byte[] header=new byte[blockSize];
    file.read(ByteBuffer.wrap(header));
    Properties prop=new Properties();
    prop.load(new ByteArrayInputStream(header));
    prop.load(new StringReader(new String(header,""String_Node_Str"")));
    writer.println(""String_Node_Str"" + fileName);
    writer.println(""String_Node_Str"" + fileLength);
    writer.println(""String_Node_Str"" + prop);
    ByteBuffer block=ByteBuffer.wrap(new byte[32]);
    for (long pos=0; pos < fileLength; ) {
      file.position(pos);
      block.rewind();
      FileUtils.readFully(file,block);
      block.rewind();
      if (block.get() != 'c') {
        pos+=blockSize;
        continue;
      }
      int chunkLength=block.getInt();
      int chunkId=block.getInt();
      long metaRootPos=block.getLong();
      writer.println(""String_Node_Str"" + chunkId + ""String_Node_Str""+ pos+ ""String_Node_Str""+ chunkLength+ ""String_Node_Str""+ metaRootPos);
      ByteBuffer chunk=ByteBuffer.allocate(chunkLength);
      file.position(pos);
      FileUtils.readFully(file,chunk);
      int p=block.position();
      pos=(pos + chunkLength + blockSize) / blockSize * blockSize;
      chunkLength-=p;
      while (chunkLength > 0) {
        chunk.position(p);
        int pageLength=chunk.getInt();
        chunk.getShort();
        long mapId=DataUtils.readVarInt(chunk);
        int len=DataUtils.readVarInt(chunk);
        int type=chunk.get();
        boolean compressed=(type & 2) != 0;
        boolean node=(type & 1) != 0;
        writer.println(""String_Node_Str"" + mapId + ""String_Node_Str""+ p+ ""String_Node_Str""+ (node ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ (compressed ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ pageLength+ ""String_Node_Str""+ len);
        p+=pageLength;
        chunkLength-=pageLength;
      }
    }
  }
 catch (  IOException e) {
    writer.println(""String_Node_Str"" + e);
  }
 finally {
    try {
      file.close();
    }
 catch (    IOException e) {
    }
  }
  writer.println();
  writer.flush();
}","/** 
 * Dump the contents of the file.
 * @param fileName the name of the file
 * @param writer the print writer
 */
public static void dump(String fileName,PrintWriter writer){
  if (!FileUtils.exists(fileName)) {
    writer.println(""String_Node_Str"" + fileName);
    return;
  }
  FileChannel file=null;
  try {
    file=FilePath.get(fileName).open(""String_Node_Str"");
    long fileLength=file.size();
    file.position(0);
    byte[] header=new byte[blockSize];
    file.read(ByteBuffer.wrap(header));
    Properties prop=new Properties();
    prop.load(new ByteArrayInputStream(header));
    prop.load(new StringReader(new String(header,""String_Node_Str"")));
    writer.println(""String_Node_Str"" + fileName);
    writer.println(""String_Node_Str"" + fileLength);
    writer.println(""String_Node_Str"" + prop);
    ByteBuffer block=ByteBuffer.wrap(new byte[32]);
    for (long pos=0; pos < fileLength; ) {
      file.position(pos);
      block.rewind();
      FileUtils.readFully(file,block);
      block.rewind();
      if (block.get() != 'c') {
        pos+=blockSize;
        continue;
      }
      int chunkLength=block.getInt();
      int chunkId=block.getInt();
      long metaRootPos=block.getLong();
      writer.println(""String_Node_Str"" + chunkId + ""String_Node_Str""+ pos+ ""String_Node_Str""+ chunkLength+ ""String_Node_Str""+ metaRootPos);
      ByteBuffer chunk=ByteBuffer.allocate(chunkLength);
      file.position(pos);
      FileUtils.readFully(file,chunk);
      int p=block.position();
      pos=(pos + chunkLength + blockSize) / blockSize * blockSize;
      chunkLength-=p;
      while (chunkLength > 0) {
        chunk.position(p);
        int pageLength=chunk.getInt();
        chunk.getShort();
        long mapId=DataUtils.readVarInt(chunk);
        int len=DataUtils.readVarInt(chunk);
        int type=chunk.get();
        boolean compressed=(type & 2) != 0;
        boolean node=(type & 1) != 0;
        writer.println(""String_Node_Str"" + mapId + ""String_Node_Str""+ p+ ""String_Node_Str""+ (node ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ (compressed ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ pageLength+ ""String_Node_Str""+ len);
        p+=pageLength;
        chunkLength-=pageLength;
      }
    }
  }
 catch (  IOException e) {
    writer.println(""String_Node_Str"" + e);
  }
 finally {
    if (file != null) {
      try {
        file.close();
      }
 catch (      IOException e) {
      }
    }
  }
  writer.println();
  writer.flush();
}",0.9864
16002,"public InputStream newInputStream() throws IOException {
  if (name.indexOf(':') > 1) {
    if (name.startsWith(CLASSPATH_PREFIX)) {
      String fileName=name.substring(CLASSPATH_PREFIX.length());
      if (!fileName.startsWith(""String_Node_Str"")) {
        fileName=""String_Node_Str"" + fileName;
      }
      InputStream in=getClass().getResourceAsStream(fileName);
      if (in == null) {
        Thread.currentThread().getContextClassLoader().getResourceAsStream(fileName);
      }
      if (in == null) {
        throw new FileNotFoundException(""String_Node_Str"" + fileName);
      }
      return in;
    }
    URL url=new URL(name);
    InputStream in=url.openStream();
    return in;
  }
  FileInputStream in=new FileInputStream(name);
  IOUtils.trace(""String_Node_Str"",name,in);
  return in;
}","public InputStream newInputStream() throws IOException {
  if (name.indexOf(':') > 1) {
    if (name.startsWith(CLASSPATH_PREFIX)) {
      String fileName=name.substring(CLASSPATH_PREFIX.length());
      if (!fileName.startsWith(""String_Node_Str"")) {
        fileName=""String_Node_Str"" + fileName;
      }
      InputStream in=getClass().getResourceAsStream(fileName);
      if (in == null) {
        in=Thread.currentThread().getContextClassLoader().getResourceAsStream(fileName);
      }
      if (in == null) {
        throw new FileNotFoundException(""String_Node_Str"" + fileName);
      }
      return in;
    }
    URL url=new URL(name);
    InputStream in=url.openStream();
    return in;
  }
  FileInputStream in=new FileInputStream(name);
  IOUtils.trace(""String_Node_Str"",name,in);
  return in;
}",0.9981331673926572
16003,"public boolean autoComplete(Sentence sentence){
  sentence.stopIfRequired();
  String query=sentence.getQuery();
  String s=query;
switch (type) {
case YMD:
    while (s.length() > 0 && ""String_Node_Str"".indexOf(s.charAt(0)) >= 0) {
      s=s.substring(1);
    }
  if (s.length() == 0) {
    sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
  }
break;
case HMS:
while (s.length() > 0 && ""String_Node_Str"".indexOf(s.charAt(0)) >= 0) {
s=s.substring(1);
}
if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case NANOS:
while (s.length() > 0 && Character.isDigit(s.charAt(0))) {
s=s.substring(1);
}
if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case ANY_EXCEPT_SINGLE_QUOTE:
while (true) {
while (s.length() > 0 && s.charAt(0) != '\'') {
s=s.substring(1);
}
if (s.startsWith(""String_Node_Str"")) {
s=s.substring(2);
}
 else {
break;
}
}
if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case ANY_EXCEPT_2_DOLLAR:
while (s.length() > 0 && !s.startsWith(""String_Node_Str"")) {
s=s.substring(1);
}
if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case ANY_EXCEPT_DOUBLE_QUOTE:
while (true) {
while (s.length() > 0 && s.charAt(0) != '\""') {
s=s.substring(1);
}
if (s.startsWith(""String_Node_Str"")) {
s=s.substring(2);
}
 else {
break;
}
}
if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case ANY_WORD:
while (s.length() > 0 && !Character.isSpaceChar(s.charAt(0))) {
s=s.substring(1);
}
if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case HEX_START:
if (s.startsWith(""String_Node_Str"") || s.startsWith(""String_Node_Str"")) {
s=s.substring(2);
}
 else if (""String_Node_Str"".equals(s)) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
 else if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case CONCAT:
if (s.equals(""String_Node_Str"")) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
 else if (s.startsWith(""String_Node_Str"")) {
s=s.substring(2);
}
 else if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case AZ_UNDERSCORE:
if (s.length() > 0 && (Character.isLetter(s.charAt(0)) || s.charAt(0) == '_')) {
s=s.substring(1);
}
if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case AF:
if (s.length() > 0) {
char ch=Character.toUpperCase(s.charAt(0));
if (ch >= 'A' && ch <= 'F') {
s=s.substring(1);
}
}
if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case DIGIT:
if (s.length() > 0 && Character.isDigit(s.charAt(0))) {
s=s.substring(1);
}
if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case OPEN_BRACKET:
if (s.startsWith(""String_Node_Str"")) {
s=s.substring(1);
}
 else if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case CLOSE_BRACKET:
if (s.startsWith(""String_Node_Str"")) {
s=s.substring(1);
}
 else if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case ANY_UNTIL_EOL:
case ANY_UNTIL_END:
default :
throw new AssertionError(""String_Node_Str"" + type);
}
if (!s.equals(query)) {
while (s.length() > 0 && Character.isSpaceChar(s.charAt(0))) {
s=s.substring(1);
}
sentence.setQuery(s);
return true;
}
return false;
}","public boolean autoComplete(Sentence sentence){
  sentence.stopIfRequired();
  String query=sentence.getQuery();
  String s=query;
switch (type) {
case YMD:
    while (s.length() > 0 && ""String_Node_Str"".indexOf(s.charAt(0)) >= 0) {
      s=s.substring(1);
    }
  if (s.length() == 0) {
    sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
  }
break;
case HMS:
while (s.length() > 0 && ""String_Node_Str"".indexOf(s.charAt(0)) >= 0) {
s=s.substring(1);
}
if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case NANOS:
while (s.length() > 0 && Character.isDigit(s.charAt(0))) {
s=s.substring(1);
}
if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case ANY_EXCEPT_SINGLE_QUOTE:
while (true) {
while (s.length() > 0 && s.charAt(0) != '\'') {
s=s.substring(1);
}
if (s.startsWith(""String_Node_Str"")) {
s=s.substring(2);
}
 else {
break;
}
}
if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case ANY_EXCEPT_2_DOLLAR:
while (s.length() > 0 && !s.startsWith(""String_Node_Str"")) {
s=s.substring(1);
}
if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case ANY_EXCEPT_DOUBLE_QUOTE:
while (true) {
while (s.length() > 0 && s.charAt(0) != '\""') {
s=s.substring(1);
}
if (s.startsWith(""String_Node_Str"")) {
s=s.substring(2);
}
 else {
break;
}
}
if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case ANY_WORD:
while (s.length() > 0 && !Character.isSpaceChar(s.charAt(0))) {
s=s.substring(1);
}
if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case HEX_START:
if (s.startsWith(""String_Node_Str"") || s.startsWith(""String_Node_Str"")) {
s=s.substring(2);
}
 else if (""String_Node_Str"".equals(s)) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
 else if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case CONCAT:
if (s.equals(""String_Node_Str"")) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
 else if (s.startsWith(""String_Node_Str"")) {
s=s.substring(2);
}
 else if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case AZ_UNDERSCORE:
if (s.length() > 0 && (Character.isLetter(s.charAt(0)) || s.charAt(0) == '_')) {
s=s.substring(1);
}
if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case AF:
if (s.length() > 0) {
char ch=Character.toUpperCase(s.charAt(0));
if (ch >= 'A' && ch <= 'F') {
s=s.substring(1);
}
}
if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case DIGIT:
if (s.length() > 0 && Character.isDigit(s.charAt(0))) {
s=s.substring(1);
}
if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
break;
case OPEN_BRACKET:
if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
 else if (s.charAt(0) == '[') {
s=s.substring(1);
}
break;
case CLOSE_BRACKET:
if (s.length() == 0) {
sentence.add(""String_Node_Str"",""String_Node_Str"",Sentence.KEYWORD);
}
 else if (s.charAt(0) == ']') {
s=s.substring(1);
}
break;
case ANY_UNTIL_EOL:
case ANY_UNTIL_END:
default :
throw new AssertionError(""String_Node_Str"" + type);
}
if (!s.equals(query)) {
while (s.length() > 0 && Character.isSpaceChar(s.charAt(0))) {
s=s.substring(1);
}
sentence.setQuery(s);
return true;
}
return false;
}",0.969427750195976
16004,"public String getPlanSQL(){
  StringBuilder buff=new StringBuilder();
  buff.append(""String_Node_Str"");
  buff.append(""String_Node_Str"").append(tableFilter.getPlanSQL(false));
  if (condition != null) {
    buff.append(""String_Node_Str"").append(StringUtils.unEnclose(condition.getSQL()));
  }
  if (limitExpr != null) {
    buff.append(""String_Node_Str"").append(StringUtils.unEnclose(limitExpr.getSQL())).append(""String_Node_Str"");
  }
  return buff.toString();
}","public String getPlanSQL(){
  StringBuilder buff=new StringBuilder();
  buff.append(""String_Node_Str"");
  buff.append(""String_Node_Str"").append(tableFilter.getPlanSQL(false));
  if (condition != null) {
    buff.append(""String_Node_Str"").append(StringUtils.unEnclose(condition.getSQL()));
  }
  if (limitExpr != null) {
    buff.append(""String_Node_Str"").append(StringUtils.unEnclose(limitExpr.getSQL())).append(')');
  }
  return buff.toString();
}",0.9780701754385964
16005,"public String getPlanSQL(){
  StatementBuilder buff=new StatementBuilder(""String_Node_Str"");
  buff.append(table.getSQL()).append('(');
  for (  Column c : columns) {
    buff.appendExceptFirst(""String_Node_Str"");
    buff.append(c.getSQL());
  }
  buff.append(""String_Node_Str"");
  if (insertFromSelect) {
    buff.append(""String_Node_Str"");
  }
  if (sortedInsertMode) {
    buff.append(""String_Node_Str"");
  }
  if (list.size() > 0) {
    buff.append(""String_Node_Str"");
    int row=0;
    if (list.size() > 1) {
      buff.append(""String_Node_Str"");
    }
    for (    Expression[] expr : list) {
      if (row++ > 0) {
        buff.append(""String_Node_Str"");
      }
      buff.append('(');
      buff.resetCount();
      for (      Expression e : expr) {
        buff.appendExceptFirst(""String_Node_Str"");
        if (e == null) {
          buff.append(""String_Node_Str"");
        }
 else {
          buff.append(e.getSQL());
        }
      }
      buff.append(')');
    }
  }
 else {
    buff.append(query.getPlanSQL());
  }
  return buff.toString();
}","public String getPlanSQL(){
  StatementBuilder buff=new StatementBuilder(""String_Node_Str"");
  buff.append(table.getSQL()).append('(');
  for (  Column c : columns) {
    buff.appendExceptFirst(""String_Node_Str"");
    buff.append(c.getSQL());
  }
  buff.append(""String_Node_Str"");
  if (insertFromSelect) {
    buff.append(""String_Node_Str"");
  }
  if (sortedInsertMode) {
    buff.append(""String_Node_Str"");
  }
  if (list.size() > 0) {
    buff.append(""String_Node_Str"");
    int row=0;
    if (list.size() > 1) {
      buff.append('\n');
    }
    for (    Expression[] expr : list) {
      if (row++ > 0) {
        buff.append(""String_Node_Str"");
      }
      buff.append('(');
      buff.resetCount();
      for (      Expression e : expr) {
        buff.appendExceptFirst(""String_Node_Str"");
        if (e == null) {
          buff.append(""String_Node_Str"");
        }
 else {
          buff.append(e.getSQL());
        }
      }
      buff.append(')');
    }
  }
 else {
    buff.append(query.getPlanSQL());
  }
  return buff.toString();
}",0.9900332225913622
16006,"public String getPlanSQL(){
  Expression[] exprList=expressions.toArray(new Expression[expressions.size()]);
  StatementBuilder buff=new StatementBuilder(""String_Node_Str"");
  if (distinct) {
    buff.append(""String_Node_Str"");
  }
  for (int i=0; i < visibleColumnCount; i++) {
    buff.appendExceptFirst(""String_Node_Str"");
    buff.append(""String_Node_Str"");
    buff.append(StringUtils.indent(exprList[i].getSQL(),4,false));
  }
  buff.append(""String_Node_Str"");
  TableFilter filter=topTableFilter;
  if (filter != null) {
    buff.resetCount();
    int i=0;
    do {
      buff.appendExceptFirst(""String_Node_Str"");
      buff.append(filter.getPlanSQL(i++ > 0));
      filter=filter.getJoin();
    }
 while (filter != null);
  }
 else {
    buff.resetCount();
    int i=0;
    for (    TableFilter f : topFilters) {
      do {
        buff.appendExceptFirst(""String_Node_Str"");
        buff.append(f.getPlanSQL(i++ > 0));
        f=f.getJoin();
      }
 while (f != null);
    }
  }
  if (condition != null) {
    buff.append(""String_Node_Str"").append(StringUtils.unEnclose(condition.getSQL()));
  }
  if (groupIndex != null) {
    buff.append(""String_Node_Str"");
    buff.resetCount();
    for (    int gi : groupIndex) {
      Expression g=exprList[gi];
      g=g.getNonAliasExpression();
      buff.appendExceptFirst(""String_Node_Str"");
      buff.append(StringUtils.unEnclose(g.getSQL()));
    }
  }
  if (group != null) {
    buff.append(""String_Node_Str"");
    buff.resetCount();
    for (    Expression g : group) {
      buff.appendExceptFirst(""String_Node_Str"");
      buff.append(StringUtils.unEnclose(g.getSQL()));
    }
  }
  if (having != null) {
    Expression h=having;
    buff.append(""String_Node_Str"").append(StringUtils.unEnclose(h.getSQL()));
  }
 else   if (havingIndex >= 0) {
    Expression h=exprList[havingIndex];
    buff.append(""String_Node_Str"").append(StringUtils.unEnclose(h.getSQL()));
  }
  if (sort != null) {
    buff.append(""String_Node_Str"").append(sort.getSQL(exprList,visibleColumnCount));
  }
  if (orderList != null) {
    buff.append(""String_Node_Str"");
    buff.resetCount();
    for (    SelectOrderBy o : orderList) {
      buff.appendExceptFirst(""String_Node_Str"");
      buff.append(StringUtils.unEnclose(o.getSQL()));
    }
  }
  if (limitExpr != null) {
    buff.append(""String_Node_Str"").append(StringUtils.unEnclose(limitExpr.getSQL()));
    if (offsetExpr != null) {
      buff.append(""String_Node_Str"").append(StringUtils.unEnclose(offsetExpr.getSQL()));
    }
  }
  if (sampleSize != 0) {
    buff.append(""String_Node_Str"").append(sampleSize);
  }
  if (isForUpdate) {
    buff.append(""String_Node_Str"");
  }
  if (isQuickAggregateQuery) {
    buff.append(""String_Node_Str"");
  }
  if (isDistinctQuery) {
    buff.append(""String_Node_Str"");
  }
  if (sortUsingIndex) {
    buff.append(""String_Node_Str"");
  }
  if (isGroupQuery) {
    if (isGroupSortedQuery) {
      buff.append(""String_Node_Str"");
    }
  }
  return buff.toString();
}","public String getPlanSQL(){
  Expression[] exprList=expressions.toArray(new Expression[expressions.size()]);
  StatementBuilder buff=new StatementBuilder(""String_Node_Str"");
  if (distinct) {
    buff.append(""String_Node_Str"");
  }
  for (int i=0; i < visibleColumnCount; i++) {
    buff.appendExceptFirst(""String_Node_Str"");
    buff.append('\n');
    buff.append(StringUtils.indent(exprList[i].getSQL(),4,false));
  }
  buff.append(""String_Node_Str"");
  TableFilter filter=topTableFilter;
  if (filter != null) {
    buff.resetCount();
    int i=0;
    do {
      buff.appendExceptFirst(""String_Node_Str"");
      buff.append(filter.getPlanSQL(i++ > 0));
      filter=filter.getJoin();
    }
 while (filter != null);
  }
 else {
    buff.resetCount();
    int i=0;
    for (    TableFilter f : topFilters) {
      do {
        buff.appendExceptFirst(""String_Node_Str"");
        buff.append(f.getPlanSQL(i++ > 0));
        f=f.getJoin();
      }
 while (f != null);
    }
  }
  if (condition != null) {
    buff.append(""String_Node_Str"").append(StringUtils.unEnclose(condition.getSQL()));
  }
  if (groupIndex != null) {
    buff.append(""String_Node_Str"");
    buff.resetCount();
    for (    int gi : groupIndex) {
      Expression g=exprList[gi];
      g=g.getNonAliasExpression();
      buff.appendExceptFirst(""String_Node_Str"");
      buff.append(StringUtils.unEnclose(g.getSQL()));
    }
  }
  if (group != null) {
    buff.append(""String_Node_Str"");
    buff.resetCount();
    for (    Expression g : group) {
      buff.appendExceptFirst(""String_Node_Str"");
      buff.append(StringUtils.unEnclose(g.getSQL()));
    }
  }
  if (having != null) {
    Expression h=having;
    buff.append(""String_Node_Str"").append(StringUtils.unEnclose(h.getSQL()));
  }
 else   if (havingIndex >= 0) {
    Expression h=exprList[havingIndex];
    buff.append(""String_Node_Str"").append(StringUtils.unEnclose(h.getSQL()));
  }
  if (sort != null) {
    buff.append(""String_Node_Str"").append(sort.getSQL(exprList,visibleColumnCount));
  }
  if (orderList != null) {
    buff.append(""String_Node_Str"");
    buff.resetCount();
    for (    SelectOrderBy o : orderList) {
      buff.appendExceptFirst(""String_Node_Str"");
      buff.append(StringUtils.unEnclose(o.getSQL()));
    }
  }
  if (limitExpr != null) {
    buff.append(""String_Node_Str"").append(StringUtils.unEnclose(limitExpr.getSQL()));
    if (offsetExpr != null) {
      buff.append(""String_Node_Str"").append(StringUtils.unEnclose(offsetExpr.getSQL()));
    }
  }
  if (sampleSize != 0) {
    buff.append(""String_Node_Str"").append(sampleSize);
  }
  if (isForUpdate) {
    buff.append(""String_Node_Str"");
  }
  if (isQuickAggregateQuery) {
    buff.append(""String_Node_Str"");
  }
  if (isDistinctQuery) {
    buff.append(""String_Node_Str"");
  }
  if (sortUsingIndex) {
    buff.append(""String_Node_Str"");
  }
  if (isGroupQuery) {
    if (isGroupSortedQuery) {
      buff.append(""String_Node_Str"");
    }
  }
  return buff.toString();
}",0.9964865317048688
16007,"private static void createOrDropTrigger(Connection conn,String schema,String table,boolean create) throws SQLException {
  Statement stat=conn.createStatement();
  String trigger=StringUtils.quoteIdentifier(schema) + ""String_Node_Str"" + StringUtils.quoteIdentifier(TRIGGER_PREFIX + table);
  stat.execute(""String_Node_Str"" + trigger);
  if (create) {
    StringBuilder buff=new StringBuilder(""String_Node_Str"");
    buff.append(trigger).append(""String_Node_Str"").append(StringUtils.quoteIdentifier(schema)).append('.').append(StringUtils.quoteIdentifier(table)).append(""String_Node_Str"").append(FullText.FullTextTrigger.class.getName()).append(""String_Node_Str"");
    stat.execute(buff.toString());
  }
}","private static void createOrDropTrigger(Connection conn,String schema,String table,boolean create) throws SQLException {
  Statement stat=conn.createStatement();
  String trigger=StringUtils.quoteIdentifier(schema) + ""String_Node_Str"" + StringUtils.quoteIdentifier(TRIGGER_PREFIX + table);
  stat.execute(""String_Node_Str"" + trigger);
  if (create) {
    StringBuilder buff=new StringBuilder(""String_Node_Str"");
    buff.append(trigger).append(""String_Node_Str"").append(StringUtils.quoteIdentifier(schema)).append('.').append(StringUtils.quoteIdentifier(table)).append(""String_Node_Str"").append(FullText.FullTextTrigger.class.getName()).append('\""');
    stat.execute(buff.toString());
  }
}",0.9849462365591398
16008,"/** 
 * Create the trigger.
 * @param conn the database connection
 * @param schema the schema name
 * @param table the table name
 */
protected static void createTrigger(Connection conn,String schema,String table) throws SQLException {
  Statement stat=conn.createStatement();
  String trigger=StringUtils.quoteIdentifier(schema) + ""String_Node_Str"" + StringUtils.quoteIdentifier(TRIGGER_PREFIX + table);
  stat.execute(""String_Node_Str"" + trigger);
  StringBuilder buff=new StringBuilder(""String_Node_Str"");
  buff.append(trigger).append(""String_Node_Str"").append(StringUtils.quoteIdentifier(schema)).append('.').append(StringUtils.quoteIdentifier(table)).append(""String_Node_Str"").append(FullTextLucene.FullTextTrigger.class.getName()).append(""String_Node_Str"");
  stat.execute(buff.toString());
}","/** 
 * Create the trigger.
 * @param conn the database connection
 * @param schema the schema name
 * @param table the table name
 */
protected static void createTrigger(Connection conn,String schema,String table) throws SQLException {
  Statement stat=conn.createStatement();
  String trigger=StringUtils.quoteIdentifier(schema) + ""String_Node_Str"" + StringUtils.quoteIdentifier(TRIGGER_PREFIX + table);
  stat.execute(""String_Node_Str"" + trigger);
  StringBuilder buff=new StringBuilder(""String_Node_Str"");
  buff.append(trigger).append(""String_Node_Str"").append(StringUtils.quoteIdentifier(schema)).append('.').append(StringUtils.quoteIdentifier(table)).append(""String_Node_Str"").append(FullTextLucene.FullTextTrigger.class.getName()).append('\""');
  stat.execute(buff.toString());
}",0.9867674858223062
16009,"/** 
 * Call the fire method of the user-defined trigger class if required. This method does nothing if the trigger is not defined for the given action. This method is called before or after a row is processed, possibly many times for each statement.
 * @param session the session
 * @param oldRow the old row
 * @param newRow the new row
 * @param beforeAction true if this method is called before the operation isapplied
 * @param rollback when the operation occurred within a rollback
 * @return true if no further action is required (for 'instead of' triggers)
 */
public boolean fireRow(Session session,Row oldRow,Row newRow,boolean beforeAction,boolean rollback){
  if (!rowBased || before != beforeAction) {
    return false;
  }
  if (rollback && !onRollback) {
    return false;
  }
  load();
  Object[] oldList;
  Object[] newList;
  boolean fire=false;
  if ((typeMask & Trigger.INSERT) != 0) {
    if (oldRow == null && newRow != null) {
      fire=true;
    }
  }
  if ((typeMask & Trigger.UPDATE) != 0) {
    if (oldRow != null && newRow != null) {
      fire=true;
    }
  }
  if ((typeMask & Trigger.DELETE) != 0) {
    if (oldRow != null && newRow == null) {
      fire=true;
    }
  }
  if (!fire) {
    return false;
  }
  oldList=convertToObjectList(oldRow);
  newList=convertToObjectList(newRow);
  Object[] newListBackup;
  if (before && newList != null) {
    newListBackup=new Object[newList.length];
    for (int i=0; i < newList.length; i++) {
      newListBackup[i]=newList[i];
    }
  }
 else {
    newListBackup=null;
  }
  Connection c2=session.createConnection(false);
  boolean old=session.getAutoCommit();
  boolean oldDisabled=session.setCommitOrRollbackDisabled(true);
  Value identity=session.getScopeIdentity();
  try {
    session.setAutoCommit(false);
    triggerCallback.fire(c2,oldList,newList);
    if (newListBackup != null) {
      for (int i=0; i < newList.length; i++) {
        Object o=newList[i];
        if (o != newListBackup[i]) {
          Value v=DataType.convertToValue(session,o,Value.UNKNOWN);
          newRow.setValue(i,v);
        }
      }
    }
  }
 catch (  Exception e) {
    if (onRollback) {
    }
 else {
      throw DbException.convert(e);
    }
  }
 finally {
    session.setScopeIdentity(identity);
    session.setCommitOrRollbackDisabled(oldDisabled);
    session.setAutoCommit(old);
  }
  return insteadOf;
}","/** 
 * Call the fire method of the user-defined trigger class if required. This method does nothing if the trigger is not defined for the given action. This method is called before or after a row is processed, possibly many times for each statement.
 * @param session the session
 * @param oldRow the old row
 * @param newRow the new row
 * @param beforeAction true if this method is called before the operation isapplied
 * @param rollback when the operation occurred within a rollback
 * @return true if no further action is required (for 'instead of' triggers)
 */
public boolean fireRow(Session session,Row oldRow,Row newRow,boolean beforeAction,boolean rollback){
  if (!rowBased || before != beforeAction) {
    return false;
  }
  if (rollback && !onRollback) {
    return false;
  }
  load();
  Object[] oldList;
  Object[] newList;
  boolean fire=false;
  if ((typeMask & Trigger.INSERT) != 0) {
    if (oldRow == null && newRow != null) {
      fire=true;
    }
  }
  if ((typeMask & Trigger.UPDATE) != 0) {
    if (oldRow != null && newRow != null) {
      fire=true;
    }
  }
  if ((typeMask & Trigger.DELETE) != 0) {
    if (oldRow != null && newRow == null) {
      fire=true;
    }
  }
  if (!fire) {
    return false;
  }
  oldList=convertToObjectList(oldRow);
  newList=convertToObjectList(newRow);
  Object[] newListBackup;
  if (before && newList != null) {
    newListBackup=new Object[newList.length];
    System.arraycopy(newList,0,newListBackup,0,newList.length);
  }
 else {
    newListBackup=null;
  }
  Connection c2=session.createConnection(false);
  boolean old=session.getAutoCommit();
  boolean oldDisabled=session.setCommitOrRollbackDisabled(true);
  Value identity=session.getScopeIdentity();
  try {
    session.setAutoCommit(false);
    triggerCallback.fire(c2,oldList,newList);
    if (newListBackup != null) {
      for (int i=0; i < newList.length; i++) {
        Object o=newList[i];
        if (o != newListBackup[i]) {
          Value v=DataType.convertToValue(session,o,Value.UNKNOWN);
          newRow.setValue(i,v);
        }
      }
    }
  }
 catch (  Exception e) {
    if (onRollback) {
    }
 else {
      throw DbException.convert(e);
    }
  }
 finally {
    session.setScopeIdentity(identity);
    session.setCommitOrRollbackDisabled(oldDisabled);
    session.setAutoCommit(old);
  }
  return insteadOf;
}",0.9767834529337271
16010,"public void listen(){
  listenerThread=Thread.currentThread();
  String threadName=listenerThread.getName();
  try {
    while (!stop) {
      Socket s=serverSocket.accept();
      TcpServerThread c=new TcpServerThread(s,this,nextThreadId++);
      running.add(c);
      Thread thread=new Thread(c);
      thread.setDaemon(isDaemon);
      thread.setName(threadName + ""String_Node_Str"");
      c.setThread(thread);
      thread.start();
    }
    serverSocket=NetUtils.closeSilently(serverSocket);
  }
 catch (  Exception e) {
    if (!stop) {
      TraceSystem.traceThrowable(e);
    }
  }
  stopManagementDb();
}","public void listen(){
  listenerThread=Thread.currentThread();
  String threadName=listenerThread.getName();
  try {
    while (!stop) {
      Socket s=serverSocket.accept();
      TcpServerThread c=new TcpServerThread(s,this,nextThreadId++);
      running.add(c);
      Thread thread=new Thread(c,threadName + ""String_Node_Str"");
      thread.setDaemon(isDaemon);
      c.setThread(thread);
      thread.start();
    }
    serverSocket=NetUtils.closeSilently(serverSocket);
  }
 catch (  Exception e) {
    if (!stop) {
      TraceSystem.traceThrowable(e);
    }
  }
  stopManagementDb();
}",0.9228215767634856
16011,"public void listen(){
  String threadName=Thread.currentThread().getName();
  try {
    while (!stop) {
      Socket s=serverSocket.accept();
      if (!allow(s)) {
        trace(""String_Node_Str"");
        s.close();
      }
 else {
        PgServerThread c=new PgServerThread(s,this);
        running.add(c);
        c.setProcessId(running.size());
        Thread thread=new Thread(c);
        thread.setDaemon(isDaemon);
        thread.setName(threadName + ""String_Node_Str"");
        c.setThread(thread);
        thread.start();
      }
    }
  }
 catch (  Exception e) {
    if (!stop) {
      e.printStackTrace();
    }
  }
}","public void listen(){
  String threadName=Thread.currentThread().getName();
  try {
    while (!stop) {
      Socket s=serverSocket.accept();
      if (!allow(s)) {
        trace(""String_Node_Str"");
        s.close();
      }
 else {
        PgServerThread c=new PgServerThread(s,this);
        running.add(c);
        c.setProcessId(running.size());
        Thread thread=new Thread(c,threadName + ""String_Node_Str"");
        thread.setDaemon(isDaemon);
        c.setThread(thread);
        thread.start();
      }
    }
  }
 catch (  Exception e) {
    if (!stop) {
      e.printStackTrace();
    }
  }
}",0.919967663702506
16012,"private static String getComboBox(String[][] elements,String selected){
  StringBuilder buff=new StringBuilder();
  for (  String[] n : elements) {
    buff.append(""String_Node_Str"").append(PageParser.escapeHtmlData(n[0])).append(""String_Node_Str"");
    if (n[0].equals(selected)) {
      buff.append(""String_Node_Str"");
    }
    buff.append('>').append(PageParser.escapeHtml(n[1])).append(""String_Node_Str"");
  }
  return buff.toString();
}","private static String getComboBox(String[][] elements,String selected){
  StringBuilder buff=new StringBuilder();
  for (  String[] n : elements) {
    buff.append(""String_Node_Str"").append(PageParser.escapeHtmlData(n[0])).append('\""');
    if (n[0].equals(selected)) {
      buff.append(""String_Node_Str"");
    }
    buff.append('>').append(PageParser.escapeHtml(n[1])).append(""String_Node_Str"");
  }
  return buff.toString();
}",0.9758897818599312
16013,"private void lockFile(){
  method=FILE;
  properties=new SortedProperties();
  properties.setProperty(""String_Node_Str"",String.valueOf(method));
  setUniqueId();
  fs.createDirs(fileName);
  if (!fs.createNewFile(fileName)) {
    waitUntilOld();
    String m2=load().getProperty(""String_Node_Str"",FILE);
    if (!m2.equals(FILE)) {
      throw getExceptionFatal(""String_Node_Str"" + m2,null);
    }
    save();
    sleep(2 * sleep);
    if (!load().equals(properties)) {
      throw getExceptionAlreadyInUse(""String_Node_Str"");
    }
    fs.delete(fileName);
    if (!fs.createNewFile(fileName)) {
      throw getExceptionFatal(""String_Node_Str"",null);
    }
  }
  save();
  sleep(SLEEP_GAP);
  if (!load().equals(properties)) {
    fileName=null;
    throw getExceptionFatal(""String_Node_Str"",null);
  }
  watchdog=new Thread(this);
  watchdog.setName(""String_Node_Str"" + fileName);
  watchdog.setDaemon(true);
  watchdog.setPriority(Thread.MAX_PRIORITY - 1);
  watchdog.start();
}","private void lockFile(){
  method=FILE;
  properties=new SortedProperties();
  properties.setProperty(""String_Node_Str"",String.valueOf(method));
  setUniqueId();
  fs.createDirs(fileName);
  if (!fs.createNewFile(fileName)) {
    waitUntilOld();
    String m2=load().getProperty(""String_Node_Str"",FILE);
    if (!m2.equals(FILE)) {
      throw getExceptionFatal(""String_Node_Str"" + m2,null);
    }
    save();
    sleep(2 * sleep);
    if (!load().equals(properties)) {
      throw getExceptionAlreadyInUse(""String_Node_Str"");
    }
    fs.delete(fileName);
    if (!fs.createNewFile(fileName)) {
      throw getExceptionFatal(""String_Node_Str"",null);
    }
  }
  save();
  sleep(SLEEP_GAP);
  if (!load().equals(properties)) {
    fileName=null;
    throw getExceptionFatal(""String_Node_Str"",null);
  }
  watchdog=new Thread(this,""String_Node_Str"" + fileName);
  watchdog.setDaemon(true);
  watchdog.setPriority(Thread.MAX_PRIORITY - 1);
  watchdog.start();
}",0.9881504379185988
16014,"private void lockSocket(){
  method=SOCKET;
  properties=new SortedProperties();
  properties.setProperty(""String_Node_Str"",String.valueOf(method));
  setUniqueId();
  ipAddress=NetUtils.getLocalAddress();
  fs.createDirs(fileName);
  if (!fs.createNewFile(fileName)) {
    waitUntilOld();
    long read=fs.getLastModified(fileName);
    Properties p2=load();
    String m2=p2.getProperty(""String_Node_Str"",SOCKET);
    if (m2.equals(FILE)) {
      lockFile();
      return;
    }
 else     if (!m2.equals(SOCKET)) {
      throw getExceptionFatal(""String_Node_Str"" + m2,null);
    }
    String ip=p2.getProperty(""String_Node_Str"",ipAddress);
    if (!ipAddress.equals(ip)) {
      throw getExceptionAlreadyInUse(""String_Node_Str"" + ip);
    }
    String port=p2.getProperty(""String_Node_Str"",""String_Node_Str"");
    int portId=Integer.parseInt(port);
    InetAddress address;
    try {
      address=InetAddress.getByName(ip);
    }
 catch (    UnknownHostException e) {
      throw getExceptionFatal(""String_Node_Str"" + ip,e);
    }
    for (int i=0; i < 3; i++) {
      try {
        Socket s=new Socket(address,portId);
        s.close();
        throw getExceptionAlreadyInUse(""String_Node_Str"");
      }
 catch (      BindException e) {
        throw getExceptionFatal(""String_Node_Str"",null);
      }
catch (      ConnectException e) {
        trace.debug(e,""String_Node_Str"" + port);
      }
catch (      IOException e) {
        throw getExceptionFatal(""String_Node_Str"",null);
      }
    }
    if (read != fs.getLastModified(fileName)) {
      throw getExceptionFatal(""String_Node_Str"",null);
    }
    fs.delete(fileName);
    if (!fs.createNewFile(fileName)) {
      throw getExceptionFatal(""String_Node_Str"",null);
    }
  }
  try {
    serverSocket=NetUtils.createServerSocket(0,false);
    int port=serverSocket.getLocalPort();
    properties.setProperty(""String_Node_Str"",ipAddress);
    properties.setProperty(""String_Node_Str"",String.valueOf(port));
  }
 catch (  Exception e) {
    trace.debug(e,""String_Node_Str"");
    serverSocket=null;
    lockFile();
    return;
  }
  save();
  watchdog=new Thread(this);
  watchdog.setDaemon(true);
  watchdog.setName(""String_Node_Str"" + fileName);
  watchdog.start();
}","private void lockSocket(){
  method=SOCKET;
  properties=new SortedProperties();
  properties.setProperty(""String_Node_Str"",String.valueOf(method));
  setUniqueId();
  ipAddress=NetUtils.getLocalAddress();
  fs.createDirs(fileName);
  if (!fs.createNewFile(fileName)) {
    waitUntilOld();
    long read=fs.getLastModified(fileName);
    Properties p2=load();
    String m2=p2.getProperty(""String_Node_Str"",SOCKET);
    if (m2.equals(FILE)) {
      lockFile();
      return;
    }
 else     if (!m2.equals(SOCKET)) {
      throw getExceptionFatal(""String_Node_Str"" + m2,null);
    }
    String ip=p2.getProperty(""String_Node_Str"",ipAddress);
    if (!ipAddress.equals(ip)) {
      throw getExceptionAlreadyInUse(""String_Node_Str"" + ip);
    }
    String port=p2.getProperty(""String_Node_Str"",""String_Node_Str"");
    int portId=Integer.parseInt(port);
    InetAddress address;
    try {
      address=InetAddress.getByName(ip);
    }
 catch (    UnknownHostException e) {
      throw getExceptionFatal(""String_Node_Str"" + ip,e);
    }
    for (int i=0; i < 3; i++) {
      try {
        Socket s=new Socket(address,portId);
        s.close();
        throw getExceptionAlreadyInUse(""String_Node_Str"");
      }
 catch (      BindException e) {
        throw getExceptionFatal(""String_Node_Str"",null);
      }
catch (      ConnectException e) {
        trace.debug(e,""String_Node_Str"" + port);
      }
catch (      IOException e) {
        throw getExceptionFatal(""String_Node_Str"",null);
      }
    }
    if (read != fs.getLastModified(fileName)) {
      throw getExceptionFatal(""String_Node_Str"",null);
    }
    fs.delete(fileName);
    if (!fs.createNewFile(fileName)) {
      throw getExceptionFatal(""String_Node_Str"",null);
    }
  }
  try {
    serverSocket=NetUtils.createServerSocket(0,false);
    int port=serverSocket.getLocalPort();
    properties.setProperty(""String_Node_Str"",ipAddress);
    properties.setProperty(""String_Node_Str"",String.valueOf(port));
  }
 catch (  Exception e) {
    trace.debug(e,""String_Node_Str"");
    serverSocket=null;
    lockFile();
    return;
  }
  save();
  watchdog=new Thread(this,""String_Node_Str"" + fileName);
  watchdog.setDaemon(true);
  watchdog.start();
}",0.9821871476888387
16015,"/** 
 * Create and start a new writer thread for the given database. If the thread can't be created, this method returns null.
 * @param database the database
 * @param writeDelay the delay
 * @return the writer thread object or null
 */
public static WriterThread create(Database database,int writeDelay){
  try {
    WriterThread writer=new WriterThread(database,writeDelay);
    writer.thread=new Thread(writer);
    writer.thread.setName(""String_Node_Str"" + database.getShortName());
    writer.thread.setDaemon(true);
    return writer;
  }
 catch (  AccessControlException e) {
    return null;
  }
}","/** 
 * Create and start a new writer thread for the given database. If the thread can't be created, this method returns null.
 * @param database the database
 * @param writeDelay the delay
 * @return the writer thread object or null
 */
public static WriterThread create(Database database,int writeDelay){
  try {
    WriterThread writer=new WriterThread(database,writeDelay);
    writer.thread=new Thread(writer,""String_Node_Str"" + database.getShortName());
    writer.thread.setDaemon(true);
    return writer;
  }
 catch (  AccessControlException e) {
    return null;
  }
}",0.9746621621621622
16016,"public String getCreateSQL(){
  StatementBuilder buff=new StatementBuilder(""String_Node_Str"");
  if (isTemporary()) {
    if (isGlobalTemporary()) {
      buff.append(""String_Node_Str"");
    }
 else {
      buff.append(""String_Node_Str"");
    }
    buff.append(""String_Node_Str"");
  }
 else   if (isPersistIndexes()) {
    buff.append(""String_Node_Str"");
  }
 else {
    buff.append(""String_Node_Str"");
  }
  buff.append(""String_Node_Str"");
  if (isHidden) {
    buff.append(""String_Node_Str"");
  }
  buff.append(getSQL());
  if (comment != null) {
    buff.append(""String_Node_Str"").append(StringUtils.quoteStringSQL(comment));
  }
  buff.append(""String_Node_Str"");
  for (  Column column : columns) {
    buff.appendExceptFirst(""String_Node_Str"");
    buff.append(column.getCreateSQL());
  }
  buff.append(""String_Node_Str"");
  if (tableEngine != null) {
    buff.append(""String_Node_Str"");
    buff.append(tableEngine);
    buff.append(""String_Node_Str"");
  }
  if (!isPersistIndexes() && !isPersistData()) {
    buff.append(""String_Node_Str"");
  }
  if (isHidden) {
    buff.append(""String_Node_Str"");
  }
  return buff.toString();
}","public String getCreateSQL(){
  StatementBuilder buff=new StatementBuilder(""String_Node_Str"");
  if (isTemporary()) {
    if (isGlobalTemporary()) {
      buff.append(""String_Node_Str"");
    }
 else {
      buff.append(""String_Node_Str"");
    }
    buff.append(""String_Node_Str"");
  }
 else   if (isPersistIndexes()) {
    buff.append(""String_Node_Str"");
  }
 else {
    buff.append(""String_Node_Str"");
  }
  buff.append(""String_Node_Str"");
  if (isHidden) {
    buff.append(""String_Node_Str"");
  }
  buff.append(getSQL());
  if (comment != null) {
    buff.append(""String_Node_Str"").append(StringUtils.quoteStringSQL(comment));
  }
  buff.append(""String_Node_Str"");
  for (  Column column : columns) {
    buff.appendExceptFirst(""String_Node_Str"");
    buff.append(column.getCreateSQL());
  }
  buff.append(""String_Node_Str"");
  if (tableEngine != null) {
    buff.append(""String_Node_Str"");
    buff.append(tableEngine);
    buff.append('\""');
  }
  if (!isPersistIndexes() && !isPersistData()) {
    buff.append(""String_Node_Str"");
  }
  if (isHidden) {
    buff.append(""String_Node_Str"");
  }
  return buff.toString();
}",0.9907120743034056
16017,"/** 
 * Get the query execution plan text to use for this table filter.
 * @param isJoin if this is a joined table
 * @return the SQL statement snippet
 */
public String getPlanSQL(boolean isJoin){
  StringBuilder buff=new StringBuilder();
  if (isJoin) {
    if (joinOuter) {
      buff.append(""String_Node_Str"");
    }
 else {
      buff.append(""String_Node_Str"");
    }
  }
  if (nestedJoin != null) {
    StringBuffer buffNested=new StringBuffer();
    TableFilter n=nestedJoin;
    do {
      buffNested.append(n.getPlanSQL(n != nestedJoin));
      buffNested.append(""String_Node_Str"");
      n=n.getJoin();
    }
 while (n != null);
    buff.append(""String_Node_Str"");
    buff.append(StringUtils.indent(buffNested.toString(),4,false));
    buff.append(""String_Node_Str"");
    if (isJoin) {
      buff.append(""String_Node_Str"");
      if (joinCondition == null) {
        buff.append(""String_Node_Str"");
      }
 else {
        buff.append(StringUtils.unEnclose(joinCondition.getSQL()));
      }
    }
    return buff.toString();
  }
  buff.append(table.getSQL());
  if (alias != null) {
    buff.append(' ').append(Parser.quoteIdentifier(alias));
  }
  if (index != null) {
    buff.append(""String_Node_Str"");
    StatementBuilder planBuff=new StatementBuilder();
    planBuff.append(index.getPlanSQL());
    if (indexConditions.size() > 0) {
      planBuff.append(""String_Node_Str"");
      for (      IndexCondition condition : indexConditions) {
        planBuff.appendExceptFirst(""String_Node_Str"");
        planBuff.append(condition.getSQL());
      }
    }
    String plan=StringUtils.quoteRemarkSQL(planBuff.toString());
    if (plan.indexOf('\n') >= 0) {
      plan+=""String_Node_Str"";
    }
    buff.append(StringUtils.indent(""String_Node_Str"" + plan + ""String_Node_Str"",4,false));
  }
  if (isJoin) {
    buff.append(""String_Node_Str"");
    if (joinCondition == null) {
      buff.append(""String_Node_Str"");
    }
 else {
      buff.append(StringUtils.unEnclose(joinCondition.getSQL()));
    }
  }
  if (filterCondition != null) {
    buff.append(""String_Node_Str"");
    String condition=StringUtils.unEnclose(filterCondition.getSQL());
    condition=""String_Node_Str"" + StringUtils.quoteRemarkSQL(condition) + ""String_Node_Str"";
    buff.append(StringUtils.indent(condition,4,false));
  }
  if (scanCount > 0) {
    buff.append(""String_Node_Str"").append(scanCount).append(""String_Node_Str"");
  }
  return buff.toString();
}","/** 
 * Get the query execution plan text to use for this table filter.
 * @param isJoin if this is a joined table
 * @return the SQL statement snippet
 */
public String getPlanSQL(boolean isJoin){
  StringBuilder buff=new StringBuilder();
  if (isJoin) {
    if (joinOuter) {
      buff.append(""String_Node_Str"");
    }
 else {
      buff.append(""String_Node_Str"");
    }
  }
  if (nestedJoin != null) {
    StringBuffer buffNested=new StringBuffer();
    TableFilter n=nestedJoin;
    do {
      buffNested.append(n.getPlanSQL(n != nestedJoin));
      buffNested.append('\n');
      n=n.getJoin();
    }
 while (n != null);
    buff.append(""String_Node_Str"");
    buff.append(StringUtils.indent(buffNested.toString(),4,false));
    buff.append(')');
    if (isJoin) {
      buff.append(""String_Node_Str"");
      if (joinCondition == null) {
        buff.append(""String_Node_Str"");
      }
 else {
        buff.append(StringUtils.unEnclose(joinCondition.getSQL()));
      }
    }
    return buff.toString();
  }
  buff.append(table.getSQL());
  if (alias != null) {
    buff.append(' ').append(Parser.quoteIdentifier(alias));
  }
  if (index != null) {
    buff.append('\n');
    StatementBuilder planBuff=new StatementBuilder();
    planBuff.append(index.getPlanSQL());
    if (indexConditions.size() > 0) {
      planBuff.append(""String_Node_Str"");
      for (      IndexCondition condition : indexConditions) {
        planBuff.appendExceptFirst(""String_Node_Str"");
        planBuff.append(condition.getSQL());
      }
    }
    String plan=StringUtils.quoteRemarkSQL(planBuff.toString());
    if (plan.indexOf('\n') >= 0) {
      plan+=""String_Node_Str"";
    }
    buff.append(StringUtils.indent(""String_Node_Str"" + plan + ""String_Node_Str"",4,false));
  }
  if (isJoin) {
    buff.append(""String_Node_Str"");
    if (joinCondition == null) {
      buff.append(""String_Node_Str"");
    }
 else {
      buff.append(StringUtils.unEnclose(joinCondition.getSQL()));
    }
  }
  if (filterCondition != null) {
    buff.append('\n');
    String condition=StringUtils.unEnclose(filterCondition.getSQL());
    condition=""String_Node_Str"" + StringUtils.quoteRemarkSQL(condition) + ""String_Node_Str"";
    buff.append(StringUtils.indent(condition,4,false));
  }
  if (scanCount > 0) {
    buff.append(""String_Node_Str"").append(scanCount).append(""String_Node_Str"");
  }
  return buff.toString();
}",0.9828050548995236
16018,"/** 
 * Converts a trace file to a Java class file and a script file.
 * @param traceFileName
 * @param javaClassName
 * @throws IOException
 */
private void convertFile(String traceFileName,String javaClassName,String script) throws IOException {
  LineNumberReader reader=new LineNumberReader(IOUtils.getBufferedReader(IOUtils.openFileInputStream(traceFileName)));
  PrintWriter javaWriter=new PrintWriter(IOUtils.getBufferedWriter(IOUtils.openFileOutputStream(javaClassName + ""String_Node_Str"",false)));
  PrintWriter scriptWriter=new PrintWriter(IOUtils.getBufferedWriter(IOUtils.openFileOutputStream(script,false)));
  javaWriter.println(""String_Node_Str"");
  javaWriter.println(""String_Node_Str"");
  javaWriter.println(""String_Node_Str"");
  javaWriter.println(""String_Node_Str"");
  String cn=javaClassName.replace('\\','/');
  int idx=cn.lastIndexOf('/');
  if (idx > 0) {
    cn=cn.substring(idx + 1);
  }
  javaWriter.println(""String_Node_Str"" + cn + ""String_Node_Str"");
  javaWriter.println(""String_Node_Str"");
  javaWriter.println(""String_Node_Str"");
  while (true) {
    String line=reader.readLine();
    if (line == null) {
      break;
    }
    if (line.startsWith(""String_Node_Str"")) {
      line=""String_Node_Str"" + line.substring(4);
      javaWriter.println(line);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      int end=line.indexOf(""String_Node_Str"");
      String sql=line.substring(end + ""String_Node_Str"".length());
      sql=StringUtils.javaDecode(sql);
      line=line.substring(""String_Node_Str"".length(),end);
      if (line.length() > 0) {
        String statement=sql;
        int count=0;
        int time=0;
        line=line.trim();
        if (line.length() > 0) {
          StringTokenizer tk=new StringTokenizer(line,""String_Node_Str"");
          while (tk.hasMoreElements()) {
            String token=tk.nextToken();
            if (""String_Node_Str"".equals(token)) {
              int len=Integer.parseInt(tk.nextToken());
              statement=sql.substring(0,len) + ""String_Node_Str"";
            }
 else             if (""String_Node_Str"".equals(token)) {
              count=Integer.parseInt(tk.nextToken());
            }
 else             if (""String_Node_Str"".equals(token)) {
              time=Integer.parseInt(tk.nextToken());
            }
          }
        }
        addToStats(statement,count,time);
      }
      scriptWriter.println(sql);
    }
  }
  javaWriter.println(""String_Node_Str"");
  javaWriter.println(""String_Node_Str"");
  reader.close();
  javaWriter.close();
  if (stats.size() > 0) {
    scriptWriter.println(""String_Node_Str"");
    scriptWriter.println(""String_Node_Str"");
    scriptWriter.println(""String_Node_Str"");
    scriptWriter.println(""String_Node_Str"");
    scriptWriter.println(""String_Node_Str"");
    scriptWriter.println(""String_Node_Str"");
    scriptWriter.println(""String_Node_Str"");
    int accumTime=0;
    ArrayList<Stat> list=New.arrayList(stats.values());
    Collections.sort(list);
    if (timeTotal == 0) {
      timeTotal=1;
    }
    for (    Stat stat : list) {
      accumTime+=stat.time;
      StringBuilder buff=new StringBuilder(100);
      buff.append(""String_Node_Str"").append(padNumberLeft(100 * stat.time / timeTotal,3)).append(""String_Node_Str"").append(padNumberLeft(100 * accumTime / timeTotal,3)).append('%').append(padNumberLeft(stat.time,8)).append(padNumberLeft(stat.executeCount,8)).append(padNumberLeft(stat.resultCount,8)).append(' ').append(removeNewlines(stat.sql));
      scriptWriter.println(buff.toString());
    }
  }
  scriptWriter.close();
}","/** 
 * Converts a trace file to a Java class file and a script file.
 * @param traceFileName
 * @param javaClassName
 * @throws IOException
 */
private void convertFile(String traceFileName,String javaClassName,String script) throws IOException {
  LineNumberReader reader=new LineNumberReader(IOUtils.getBufferedReader(IOUtils.openFileInputStream(traceFileName)));
  PrintWriter javaWriter=new PrintWriter(IOUtils.getBufferedWriter(IOUtils.openFileOutputStream(javaClassName + ""String_Node_Str"",false)));
  PrintWriter scriptWriter=new PrintWriter(IOUtils.getBufferedWriter(IOUtils.openFileOutputStream(script,false)));
  javaWriter.println(""String_Node_Str"");
  javaWriter.println(""String_Node_Str"");
  javaWriter.println(""String_Node_Str"");
  javaWriter.println(""String_Node_Str"");
  String cn=javaClassName.replace('\\','/');
  int idx=cn.lastIndexOf('/');
  if (idx > 0) {
    cn=cn.substring(idx + 1);
  }
  javaWriter.println(""String_Node_Str"" + cn + ""String_Node_Str"");
  javaWriter.println(""String_Node_Str"");
  javaWriter.println(""String_Node_Str"");
  while (true) {
    String line=reader.readLine();
    if (line == null) {
      break;
    }
    if (line.startsWith(""String_Node_Str"")) {
      line=""String_Node_Str"" + line.substring(4);
      javaWriter.println(line);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      int end=line.indexOf(""String_Node_Str"");
      String sql=line.substring(end + ""String_Node_Str"".length());
      sql=StringUtils.javaDecode(sql);
      line=line.substring(""String_Node_Str"".length(),end);
      if (line.length() > 0) {
        String statement=sql;
        int count=0;
        int time=0;
        line=line.trim();
        if (line.length() > 0) {
          StringTokenizer tk=new StringTokenizer(line,""String_Node_Str"");
          while (tk.hasMoreElements()) {
            String token=tk.nextToken();
            if (""String_Node_Str"".equals(token)) {
              int len=Integer.parseInt(tk.nextToken());
              statement=sql.substring(0,len) + ""String_Node_Str"";
            }
 else             if (""String_Node_Str"".equals(token)) {
              count=Integer.parseInt(tk.nextToken());
            }
 else             if (""String_Node_Str"".equals(token)) {
              time=Integer.parseInt(tk.nextToken());
            }
          }
        }
        addToStats(statement,count,time);
      }
      scriptWriter.println(sql);
    }
  }
  javaWriter.println(""String_Node_Str"");
  javaWriter.println('}');
  reader.close();
  javaWriter.close();
  if (stats.size() > 0) {
    scriptWriter.println(""String_Node_Str"");
    scriptWriter.println(""String_Node_Str"");
    scriptWriter.println(""String_Node_Str"");
    scriptWriter.println(""String_Node_Str"");
    scriptWriter.println(""String_Node_Str"");
    scriptWriter.println(""String_Node_Str"");
    scriptWriter.println(""String_Node_Str"");
    int accumTime=0;
    ArrayList<Stat> list=New.arrayList(stats.values());
    Collections.sort(list);
    if (timeTotal == 0) {
      timeTotal=1;
    }
    for (    Stat stat : list) {
      accumTime+=stat.time;
      StringBuilder buff=new StringBuilder(100);
      buff.append(""String_Node_Str"").append(padNumberLeft(100 * stat.time / timeTotal,3)).append(""String_Node_Str"").append(padNumberLeft(100 * accumTime / timeTotal,3)).append('%').append(padNumberLeft(stat.time,8)).append(padNumberLeft(stat.executeCount,8)).append(padNumberLeft(stat.resultCount,8)).append(' ').append(removeNewlines(stat.sql));
      scriptWriter.println(buff.toString());
    }
  }
  scriptWriter.close();
}",0.9971996639596752
16019,"private String readPassword() throws IOException {
  try {
    Object console=Utils.callStaticMethod(""String_Node_Str"");
    print(""String_Node_Str"");
    char[] password=(char[])Utils.callMethod(console,""String_Node_Str"");
    return password == null ? null : new String(password);
  }
 catch (  Exception e) {
  }
  Thread passwordHider=new Thread(this);
  stopHide=false;
  passwordHider.start();
  print(""String_Node_Str"");
  String p=readLine();
  stopHide=true;
  try {
    passwordHider.join();
  }
 catch (  InterruptedException e) {
  }
  print(""String_Node_Str"");
  return p;
}","private String readPassword() throws IOException {
  try {
    Object console=Utils.callStaticMethod(""String_Node_Str"");
    print(""String_Node_Str"");
    char[] password=(char[])Utils.callMethod(console,""String_Node_Str"");
    return password == null ? null : new String(password);
  }
 catch (  Exception e) {
  }
  Thread passwordHider=new Thread(this,""String_Node_Str"");
  stopHide=false;
  passwordHider.start();
  print(""String_Node_Str"");
  String p=readLine();
  stopHide=true;
  try {
    passwordHider.join();
  }
 catch (  InterruptedException e) {
  }
  print(""String_Node_Str"");
  return p;
}",0.9848993288590604
16020,"private static synchronized SecureRandom getSecureRandom(){
  if (cachedSecureRandom != null) {
    return cachedSecureRandom;
  }
  try {
    cachedSecureRandom=SecureRandom.getInstance(""String_Node_Str"");
    Runnable runnable=new Runnable(){
      public void run(){
        try {
          SecureRandom sr=SecureRandom.getInstance(""String_Node_Str"");
          byte[] seed=sr.generateSeed(20);
synchronized (cachedSecureRandom) {
            cachedSecureRandom.setSeed(seed);
            seeded=true;
          }
        }
 catch (        Exception e) {
          warn(""String_Node_Str"",e);
        }
      }
    }
;
    try {
      Thread t=new Thread(runnable);
      t.setDaemon(true);
      t.start();
      Thread.yield();
      try {
        t.join(400);
      }
 catch (      InterruptedException e) {
        warn(""String_Node_Str"",e);
      }
      if (!seeded) {
        byte[] seed=generateAlternativeSeed();
synchronized (cachedSecureRandom) {
          cachedSecureRandom.setSeed(seed);
        }
      }
    }
 catch (    SecurityException e) {
      runnable.run();
      generateAlternativeSeed();
    }
  }
 catch (  Exception e) {
    warn(""String_Node_Str"",e);
    cachedSecureRandom=new SecureRandom();
  }
  return cachedSecureRandom;
}","private static synchronized SecureRandom getSecureRandom(){
  if (cachedSecureRandom != null) {
    return cachedSecureRandom;
  }
  try {
    cachedSecureRandom=SecureRandom.getInstance(""String_Node_Str"");
    Runnable runnable=new Runnable(){
      public void run(){
        try {
          SecureRandom sr=SecureRandom.getInstance(""String_Node_Str"");
          byte[] seed=sr.generateSeed(20);
synchronized (cachedSecureRandom) {
            cachedSecureRandom.setSeed(seed);
            seeded=true;
          }
        }
 catch (        Exception e) {
          warn(""String_Node_Str"",e);
        }
      }
    }
;
    try {
      Thread t=new Thread(runnable,""String_Node_Str"");
      t.setDaemon(true);
      t.start();
      Thread.yield();
      try {
        t.join(400);
      }
 catch (      InterruptedException e) {
        warn(""String_Node_Str"",e);
      }
      if (!seeded) {
        byte[] seed=generateAlternativeSeed();
synchronized (cachedSecureRandom) {
          cachedSecureRandom.setSeed(seed);
        }
      }
    }
 catch (    SecurityException e) {
      runnable.run();
      generateAlternativeSeed();
    }
  }
 catch (  Exception e) {
    warn(""String_Node_Str"",e);
    cachedSecureRandom=new SecureRandom();
  }
  return cachedSecureRandom;
}",0.9929133858267716
16021,"/** 
 * Start collecting profiling data.
 */
public void startCollecting(){
  thread=new Thread(this);
  thread.setName(""String_Node_Str"");
  thread.setDaemon(true);
  thread.start();
}","/** 
 * Start collecting profiling data.
 */
public void startCollecting(){
  thread=new Thread(this,""String_Node_Str"");
  thread.setDaemon(true);
  thread.start();
}",0.9401709401709402
16022,"/** 
 * Start the thread.
 * @return this
 */
public Task execute(){
  thread=new Thread(this);
  thread.setDaemon(true);
  thread.setName(getClass().getName());
  thread.start();
  return this;
}","/** 
 * Start the thread.
 * @return this
 */
public Task execute(){
  thread=new Thread(this,getClass().getName());
  thread.setDaemon(true);
  thread.start();
  return this;
}",0.8364611260053619
16023,"public void setFileLength(long newLength) throws IOException {
  checkFileSizeLimit(newLength);
  int oldPos=pos;
  unMap();
  IOUtils.setLength(file,newLength);
  reMap();
  pos=(int)Math.min(newLength,oldPos);
}","public void setFileLength(long newLength) throws IOException {
  checkFileSizeLimit(newLength);
  int oldPos=pos;
  unMap();
  for (int i=0; ; i++) {
    try {
      IOUtils.setLength(file,newLength);
      break;
    }
 catch (    IOException e) {
      if (i > 16 || e.toString().indexOf(""String_Node_Str"") < 0) {
        throw e;
      }
    }
    System.gc();
  }
  reMap();
  pos=(int)Math.min(newLength,oldPos);
}",0.6740506329113924
16024,"/** 
 * Get the value type for the given Java class.
 * @param x the Java class
 * @return the value type
 */
public static int getTypeFromClass(Class<?> x){
  if (x == null) {
    return Value.NULL;
  }
  if (x.isPrimitive()) {
    x=Utils.getNonPrimitiveClass(x);
  }
  if (ResultSet.class.isAssignableFrom(x)) {
    return Value.RESULT_SET;
  }
 else   if (Value.ValueBlob.class.isAssignableFrom(x)) {
    return Value.BLOB;
  }
 else   if (Value.ValueClob.class.isAssignableFrom(x)) {
    return Value.CLOB;
  }
 else   if (String.class.isAssignableFrom(x)) {
    return Value.STRING;
  }
 else   if (BigDecimal.class.isAssignableFrom(x)) {
    return Value.DECIMAL;
  }
 else   if (Boolean.class == x) {
    return Value.BOOLEAN;
  }
 else   if (Byte.class == x) {
    return Value.BYTE;
  }
 else   if (Short.class == x) {
    return Value.SHORT;
  }
 else   if (Integer.class == x) {
    return Value.INT;
  }
 else   if (Character.class == x) {
    throw DbException.get(ErrorCode.DATA_CONVERSION_ERROR_1,""String_Node_Str"");
  }
 else   if (Long.class == x) {
    return Value.LONG;
  }
 else   if (Float.class == x) {
    return Value.FLOAT;
  }
 else   if (Double.class == x) {
    return Value.DOUBLE;
  }
 else   if (byte[].class.isAssignableFrom(x)) {
    return Value.BYTES;
  }
 else   if (Date.class.isAssignableFrom(x)) {
    return Value.DATE;
  }
 else   if (Time.class.isAssignableFrom(x)) {
    return Value.TIME;
  }
 else   if (Timestamp.class.isAssignableFrom(x)) {
    return Value.TIMESTAMP;
  }
 else   if (java.util.Date.class.isAssignableFrom(x)) {
    return Value.TIMESTAMP;
  }
 else   if (java.io.Reader.class.isAssignableFrom(x)) {
    return Value.CLOB;
  }
 else   if (java.sql.Clob.class.isAssignableFrom(x)) {
    return Value.CLOB;
  }
 else   if (java.io.InputStream.class.isAssignableFrom(x)) {
    return Value.BLOB;
  }
 else   if (java.sql.Blob.class.isAssignableFrom(x)) {
    return Value.BLOB;
  }
 else   if (UUID.class.isAssignableFrom(x)) {
    return Value.UUID;
  }
 else   if (Object[].class.isAssignableFrom(x)) {
    return Value.ARRAY;
  }
 else   if (Void.TYPE == x) {
    return Value.NULL;
  }
 else {
    return Value.JAVA_OBJECT;
  }
}","/** 
 * Get the value type for the given Java class.
 * @param x the Java class
 * @return the value type
 */
public static int getTypeFromClass(Class<?> x){
  if (x == null || Void.TYPE == x) {
    return Value.NULL;
  }
  if (x.isPrimitive()) {
    x=Utils.getNonPrimitiveClass(x);
  }
  if (ResultSet.class.isAssignableFrom(x)) {
    return Value.RESULT_SET;
  }
 else   if (Value.ValueBlob.class.isAssignableFrom(x)) {
    return Value.BLOB;
  }
 else   if (Value.ValueClob.class.isAssignableFrom(x)) {
    return Value.CLOB;
  }
 else   if (String.class.isAssignableFrom(x)) {
    return Value.STRING;
  }
 else   if (BigDecimal.class.isAssignableFrom(x)) {
    return Value.DECIMAL;
  }
 else   if (Boolean.class == x) {
    return Value.BOOLEAN;
  }
 else   if (Byte.class == x) {
    return Value.BYTE;
  }
 else   if (Short.class == x) {
    return Value.SHORT;
  }
 else   if (Integer.class == x) {
    return Value.INT;
  }
 else   if (Character.class == x) {
    throw DbException.get(ErrorCode.DATA_CONVERSION_ERROR_1,""String_Node_Str"");
  }
 else   if (Long.class == x) {
    return Value.LONG;
  }
 else   if (Float.class == x) {
    return Value.FLOAT;
  }
 else   if (Double.class == x) {
    return Value.DOUBLE;
  }
 else   if (byte[].class.isAssignableFrom(x)) {
    return Value.BYTES;
  }
 else   if (Date.class.isAssignableFrom(x)) {
    return Value.DATE;
  }
 else   if (Time.class.isAssignableFrom(x)) {
    return Value.TIME;
  }
 else   if (Timestamp.class.isAssignableFrom(x)) {
    return Value.TIMESTAMP;
  }
 else   if (java.util.Date.class.isAssignableFrom(x)) {
    return Value.TIMESTAMP;
  }
 else   if (java.io.Reader.class.isAssignableFrom(x)) {
    return Value.CLOB;
  }
 else   if (java.sql.Clob.class.isAssignableFrom(x)) {
    return Value.CLOB;
  }
 else   if (java.io.InputStream.class.isAssignableFrom(x)) {
    return Value.BLOB;
  }
 else   if (java.sql.Blob.class.isAssignableFrom(x)) {
    return Value.BLOB;
  }
 else   if (UUID.class.isAssignableFrom(x)) {
    return Value.UUID;
  }
 else   if (Object[].class.isAssignableFrom(x)) {
    return Value.ARRAY;
  }
 else   if (Void.TYPE == x) {
    return Value.NULL;
  }
 else {
    return Value.JAVA_OBJECT;
  }
}",0.9959183673469388
16025,"/** 
 * Convert primitive class names to java.lang.* class names.
 * @param clazz the class (for example: int)
 * @return the non-primitive class (for example: java.lang.Integer)
 */
public static Class<?> getNonPrimitiveClass(Class<?> clazz){
  if (!clazz.isPrimitive()) {
    return clazz;
  }
 else   if (clazz == boolean.class) {
    return Boolean.class;
  }
 else   if (clazz == byte.class) {
    return Byte.class;
  }
 else   if (clazz == char.class) {
    return Character.class;
  }
 else   if (clazz == double.class) {
    return Double.class;
  }
 else   if (clazz == float.class) {
    return Character.class;
  }
 else   if (clazz == int.class) {
    return Integer.class;
  }
 else   if (clazz == long.class) {
    return Long.class;
  }
 else   if (clazz == short.class) {
    return Short.class;
  }
 else   if (clazz == void.class) {
    return Void.class;
  }
  return clazz;
}","/** 
 * Convert primitive class names to java.lang.* class names.
 * @param clazz the class (for example: int)
 * @return the non-primitive class (for example: java.lang.Integer)
 */
public static Class<?> getNonPrimitiveClass(Class<?> clazz){
  if (!clazz.isPrimitive()) {
    return clazz;
  }
 else   if (clazz == boolean.class) {
    return Boolean.class;
  }
 else   if (clazz == byte.class) {
    return Byte.class;
  }
 else   if (clazz == char.class) {
    return Character.class;
  }
 else   if (clazz == double.class) {
    return Double.class;
  }
 else   if (clazz == float.class) {
    return Float.class;
  }
 else   if (clazz == int.class) {
    return Integer.class;
  }
 else   if (clazz == long.class) {
    return Long.class;
  }
 else   if (clazz == short.class) {
    return Short.class;
  }
 else   if (clazz == void.class) {
    return Void.class;
  }
  return clazz;
}",0.9921700223713646
16026,"/** 
 * Ensure all rows are read in memory.
 */
protected void readAllRows() throws SQLException {
  for (int i=0; i < entryCount; i++) {
    getRow(i);
  }
}","/** 
 * Ensure all rows are read in memory.
 */
protected void readAllRows() throws SQLException {
  for (int i=0; i < entryCount; i++) {
    SearchRow row=rows[i];
    if (row == null) {
      row=index.readRow(data,offsets[i],onlyPosition,false);
      rows[i]=row;
    }
  }
}",0.6864988558352403
16027,"/** 
 * Get the row at this position.
 * @param at the index
 * @return the row
 */
SearchRow getRow(int at) throws SQLException {
  SearchRow row=rows[at];
  if (row == null) {
    row=index.readRow(data,offsets[at],onlyPosition);
    rows[at]=row;
  }
  return row;
}","/** 
 * Get the row at this position.
 * @param at the index
 * @return the row
 */
SearchRow getRow(int at) throws SQLException {
  SearchRow row=rows[at];
  if (row == null) {
    row=index.readRow(data,offsets[at],onlyPosition,true);
    rows[at]=row;
  }
 else   if (!index.hasData(row)) {
    row=index.readRow(row.getKey());
    rows[at]=row;
  }
  return row;
}",0.8445839874411303
16028,"/** 
 * Change the parent page id.
 * @param id the new parent page id
 */
void setParentPageId(int id) throws SQLException {
  index.getPageStore().logUndo(this,data);
  written=false;
  parentPageId=id;
}","/** 
 * Change the parent page id.
 * @param id the new parent page id
 */
void setParentPageId(int id) throws SQLException {
  index.getPageStore().logUndo(this,data);
  changeCount=index.getPageStore().getChangeCount();
  written=false;
  parentPageId=id;
}",0.886021505376344
16029,"/** 
 * Change the page id.
 * @param id the new page id
 */
void setPageId(int id) throws SQLException {
  written=false;
  index.getPageStore().removeRecord(getPos());
  setPos(id);
  index.getPageStore().logUndo(this,null);
  remapChildren();
}","/** 
 * Change the page id.
 * @param id the new page id
 */
void setPageId(int id) throws SQLException {
  changeCount=index.getPageStore().getChangeCount();
  written=false;
  index.getPageStore().removeRecord(getPos());
  setPos(id);
  index.getPageStore().logUndo(this,null);
  remapChildren();
}",0.903107861060329
16030,"/** 
 * Read a row from the data page at the given offset.
 * @param data the data
 * @param offset the offset
 * @param onlyPosition whether only the position of the row is stored
 * @return the row
 */
SearchRow readRow(Data data,int offset,boolean onlyPosition) throws SQLException {
  data.setPos(offset);
  long key=data.readVarLong();
  if (onlyPosition) {
    return tableData.getRow(null,key);
  }
  SearchRow row=table.getTemplateSimpleRow(columns.length == 1);
  row.setKey(key);
  for (  Column col : columns) {
    int idx=col.getColumnId();
    row.setValue(idx,data.readValue());
  }
  return row;
}","/** 
 * Get the complete row from the data index.
 * @param key the key
 * @return the row
 */
SearchRow readRow(long key) throws SQLException {
  return tableData.getRow(null,key);
}",0.3969849246231156
16031,"private void removeAllRows() throws SQLException {
  PageBtree root=getPage(rootPageId);
  root.freeRecursive();
  root=PageBtreeLeaf.create(this,rootPageId,PageBtree.ROOT);
  store.removeRecord(rootPageId);
  store.update(root);
  rowCount=0;
}","private void removeAllRows() throws SQLException {
  try {
    PageBtree root=getPage(rootPageId);
    root.freeRecursive();
    root=PageBtreeLeaf.create(this,rootPageId,PageBtree.ROOT);
    store.removeRecord(rootPageId);
    store.update(root);
    rowCount=0;
  }
  finally {
    store.incrementChangeCount();
  }
}",0.8687943262411347
16032,"public void close(Session session) throws SQLException {
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"");
  }
  writeRowCount();
}","public void close(Session session) throws SQLException {
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"");
  }
  try {
    writeRowCount();
  }
  finally {
    store.incrementChangeCount();
  }
}",0.8176795580110497
16033,"public void add(Session session,Row row) throws SQLException {
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"" + row.getKey());
  }
  SearchRow newRow=getSearchRow(row);
  while (true) {
    PageBtree root=getPage(rootPageId);
    int splitPoint=root.addRowTry(newRow);
    if (splitPoint == -1) {
      break;
    }
    if (trace.isDebugEnabled()) {
      trace.debug(""String_Node_Str"" + splitPoint);
    }
    SearchRow pivot=root.getRow(splitPoint - 1);
    store.logUndo(root,root.data);
    PageBtree page1=root;
    PageBtree page2=root.split(splitPoint);
    store.logUndo(page2,null);
    int rootPageId=root.getPos();
    int id=store.allocatePage();
    page1.setPageId(id);
    page1.setParentPageId(rootPageId);
    page2.setParentPageId(rootPageId);
    PageBtreeNode newRoot=PageBtreeNode.create(this,rootPageId,PageBtree.ROOT);
    store.logUndo(newRoot,null);
    newRoot.init(page1,pivot,page2);
    store.update(page1);
    store.update(page2);
    store.update(newRoot);
    root=newRoot;
  }
  invalidateRowCount();
  rowCount++;
}","public void add(Session session,Row row) throws SQLException {
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"" + row.getKey());
  }
  SearchRow newRow=getSearchRow(row);
  try {
    addRow(newRow);
  }
  finally {
    store.incrementChangeCount();
  }
}",0.2970149253731343
16034,"private int addRow(SearchRow row,boolean tryOnly) throws SQLException {
  int rowLength=index.getRowSize(data,row,onlyPosition);
  int pageSize=index.getPageStore().getPageSize();
  int last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
  if (last - rowLength < start + OFFSET_LENGTH) {
    if (tryOnly && entryCount > 1) {
      int x=find(row,false,true,true);
      if (entryCount < 5) {
        return entryCount / 2;
      }
      int third=entryCount / 3;
      return x < third ? third : x >= 2 * third ? 2 * third : x;
    }
    readAllRows();
    onlyPosition=true;
    int o=pageSize;
    for (int i=0; i < entryCount; i++) {
      o-=index.getRowSize(data,getRow(i),true);
      offsets[i]=o;
    }
    last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
    rowLength=index.getRowSize(data,row,true);
    if (SysProperties.CHECK && last - rowLength < start + OFFSET_LENGTH) {
      throw Message.throwInternalError();
    }
  }
  index.getPageStore().logUndo(this,data);
  written=false;
  int offset=last - rowLength;
  int[] newOffsets=new int[entryCount + 1];
  SearchRow[] newRows=new SearchRow[entryCount + 1];
  int x;
  if (entryCount == 0) {
    x=0;
  }
 else {
    readAllRows();
    x=find(row,false,true,true);
    System.arraycopy(offsets,0,newOffsets,0,x);
    System.arraycopy(rows,0,newRows,0,x);
    if (x < entryCount) {
      for (int j=x; j < entryCount; j++) {
        newOffsets[j + 1]=offsets[j] - rowLength;
      }
      offset=(x == 0 ? pageSize : offsets[x - 1]) - rowLength;
      System.arraycopy(rows,x,newRows,x + 1,entryCount - x);
    }
  }
  entryCount++;
  start+=OFFSET_LENGTH;
  newOffsets[x]=offset;
  newRows[x]=row;
  offsets=newOffsets;
  rows=newRows;
  index.getPageStore().update(this);
  return -1;
}","private int addRow(SearchRow row,boolean tryOnly) throws SQLException {
  int rowLength=index.getRowSize(data,row,onlyPosition);
  int pageSize=index.getPageStore().getPageSize();
  int last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
  if (last - rowLength < start + OFFSET_LENGTH) {
    if (tryOnly && entryCount > 1) {
      int x=find(row,false,true,true);
      if (entryCount < 5) {
        return entryCount / 2;
      }
      int third=entryCount / 3;
      return x < third ? third : x >= 2 * third ? 2 * third : x;
    }
    readAllRows();
    onlyPosition=true;
    int o=pageSize;
    for (int i=0; i < entryCount; i++) {
      o-=index.getRowSize(data,getRow(i),true);
      offsets[i]=o;
    }
    last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
    rowLength=index.getRowSize(data,row,true);
    if (SysProperties.CHECK && last - rowLength < start + OFFSET_LENGTH) {
      throw Message.throwInternalError();
    }
  }
  index.getPageStore().logUndo(this,data);
  readAllRows();
  changeCount=index.getPageStore().getChangeCount();
  written=false;
  int offset=last - rowLength;
  int[] newOffsets=new int[entryCount + 1];
  SearchRow[] newRows=new SearchRow[entryCount + 1];
  int x;
  if (entryCount == 0) {
    x=0;
  }
 else {
    x=find(row,false,true,true);
    System.arraycopy(offsets,0,newOffsets,0,x);
    System.arraycopy(rows,0,newRows,0,x);
    if (x < entryCount) {
      for (int j=x; j < entryCount; j++) {
        newOffsets[j + 1]=offsets[j] - rowLength;
      }
      offset=(x == 0 ? pageSize : offsets[x - 1]) - rowLength;
      System.arraycopy(rows,x,newRows,x + 1,entryCount - x);
    }
  }
  entryCount++;
  start+=OFFSET_LENGTH;
  newOffsets[x]=offset;
  newRows[x]=row;
  offsets=newOffsets;
  rows=newRows;
  index.getPageStore().update(this);
  return -1;
}",0.9752433936022252
16035,"private void removeRow(int at) throws SQLException {
  readAllRows();
  index.getPageStore().logUndo(this,data);
  entryCount--;
  written=false;
  if (entryCount <= 0) {
    Message.throwInternalError();
  }
  int[] newOffsets=new int[entryCount];
  SearchRow[] newRows=new SearchRow[entryCount];
  System.arraycopy(offsets,0,newOffsets,0,at);
  System.arraycopy(rows,0,newRows,0,at);
  int startNext=at > 0 ? offsets[at - 1] : index.getPageStore().getPageSize();
  int rowLength=startNext - offsets[at];
  for (int j=at; j < entryCount; j++) {
    newOffsets[j]=offsets[j + 1] + rowLength;
  }
  System.arraycopy(rows,at + 1,newRows,at,entryCount - at);
  start-=OFFSET_LENGTH;
  offsets=newOffsets;
  rows=newRows;
}","private void removeRow(int at) throws SQLException {
  readAllRows();
  index.getPageStore().logUndo(this,data);
  entryCount--;
  written=false;
  changeCount=index.getPageStore().getChangeCount();
  if (entryCount <= 0) {
    Message.throwInternalError();
  }
  int[] newOffsets=new int[entryCount];
  SearchRow[] newRows=new SearchRow[entryCount];
  System.arraycopy(offsets,0,newOffsets,0,at);
  System.arraycopy(rows,0,newRows,0,at);
  int startNext=at > 0 ? offsets[at - 1] : index.getPageStore().getPageSize();
  int rowLength=startNext - offsets[at];
  for (int j=at; j < entryCount; j++) {
    newOffsets[j]=offsets[j + 1] + rowLength;
  }
  System.arraycopy(rows,at + 1,newRows,at,entryCount - at);
  start-=OFFSET_LENGTH;
  offsets=newOffsets;
  rows=newRows;
}",0.9644533869885984
16036,"private void removeChild(int i) throws SQLException {
  readAllRows();
  entryCount--;
  written=false;
  if (entryCount < 0) {
    Message.throwInternalError();
  }
  SearchRow[] newRows=PageStore.newSearchRows(entryCount);
  int[] newOffsets=MemoryUtils.newIntArray(entryCount);
  int[] newChildPageIds=new int[entryCount + 1];
  System.arraycopy(offsets,0,newOffsets,0,Math.min(entryCount,i));
  System.arraycopy(rows,0,newRows,0,Math.min(entryCount,i));
  System.arraycopy(childPageIds,0,newChildPageIds,0,i);
  if (entryCount > i) {
    System.arraycopy(rows,i + 1,newRows,i,entryCount - i);
    int startNext=i > 0 ? offsets[i - 1] : index.getPageStore().getPageSize();
    int rowLength=startNext - offsets[i];
    for (int j=i; j < entryCount; j++) {
      newOffsets[j]=offsets[j + 1] + rowLength;
    }
  }
  System.arraycopy(childPageIds,i + 1,newChildPageIds,i,entryCount - i + 1);
  offsets=newOffsets;
  rows=newRows;
  childPageIds=newChildPageIds;
  start-=CHILD_OFFSET_PAIR_LENGTH;
}","private void removeChild(int i) throws SQLException {
  readAllRows();
  entryCount--;
  if (SysProperties.PAGE_STORE_INTERNAL_COUNT) {
    updateRowCount(-index.getPage(childPageIds[i]).getRowCount());
  }
  written=false;
  changeCount=index.getPageStore().getChangeCount();
  if (entryCount < 0) {
    Message.throwInternalError();
  }
  SearchRow[] newRows=PageStore.newSearchRows(entryCount);
  int[] newOffsets=MemoryUtils.newIntArray(entryCount);
  int[] newChildPageIds=new int[entryCount + 1];
  System.arraycopy(offsets,0,newOffsets,0,Math.min(entryCount,i));
  System.arraycopy(rows,0,newRows,0,Math.min(entryCount,i));
  System.arraycopy(childPageIds,0,newChildPageIds,0,i);
  if (entryCount > i) {
    System.arraycopy(rows,i + 1,newRows,i,entryCount - i);
    int startNext=i > 0 ? offsets[i - 1] : index.getPageStore().getPageSize();
    int rowLength=startNext - offsets[i];
    for (int j=i; j < entryCount; j++) {
      newOffsets[j]=offsets[j + 1] + rowLength;
    }
  }
  System.arraycopy(childPageIds,i + 1,newChildPageIds,i,entryCount - i + 1);
  offsets=newOffsets;
  rows=newRows;
  childPageIds=newChildPageIds;
  start-=CHILD_OFFSET_PAIR_LENGTH;
}",0.9084215370455592
16037,"SearchRow remove(SearchRow row) throws SQLException {
  int at=find(row,false,false,true);
  PageBtree page=index.getPage(childPageIds[at]);
  SearchRow last=page.remove(row);
  index.getPageStore().logUndo(this,data);
  updateRowCount(-1);
  written=false;
  if (last == null) {
    return null;
  }
 else   if (last == row) {
    index.getPageStore().free(page.getPos());
    if (entryCount < 1) {
      return row;
    }
    if (at == entryCount) {
      last=getRow(at - 1);
    }
 else {
      last=null;
    }
    removeChild(at);
    index.getPageStore().update(this);
    return last;
  }
  if (at == entryCount) {
    return last;
  }
  int child=childPageIds[at];
  removeChild(at);
  addChild(at,child,last);
  int temp=childPageIds[at];
  childPageIds[at]=childPageIds[at + 1];
  childPageIds[at + 1]=temp;
  index.getPageStore().update(this);
  return null;
}","SearchRow remove(SearchRow row) throws SQLException {
  int at=find(row,false,false,true);
  PageBtree page=index.getPage(childPageIds[at]);
  SearchRow last=page.remove(row);
  index.getPageStore().logUndo(this,data);
  updateRowCount(-1);
  written=false;
  changeCount=index.getPageStore().getChangeCount();
  if (last == null) {
    return null;
  }
 else   if (last == row) {
    index.getPageStore().free(page.getPos());
    if (entryCount < 1) {
      return row;
    }
    if (at == entryCount) {
      last=getRow(at - 1);
    }
 else {
      last=null;
    }
    removeChild(at);
    index.getPageStore().update(this);
    return last;
  }
  if (at == entryCount) {
    return last;
  }
  int child=childPageIds[at];
  removeChild(at);
  addChild(at,child,last);
  int temp=childPageIds[at];
  childPageIds[at]=childPageIds[at + 1];
  childPageIds[at + 1]=temp;
  index.getPageStore().update(this);
  return null;
}",0.9705063995548135
16038,"int addRowTry(SearchRow row) throws SQLException {
  while (true) {
    int x=find(row,false,true,true);
    PageBtree page=index.getPage(childPageIds[x]);
    int splitPoint=page.addRowTry(row);
    if (splitPoint == -1) {
      break;
    }
    SearchRow pivot=page.getRow(splitPoint - 1);
    index.getPageStore().logUndo(this,data);
    int splitPoint2=addChildTry(pivot);
    if (splitPoint2 != -1) {
      return splitPoint2;
    }
    PageBtree page2=page.split(splitPoint);
    readAllRows();
    addChild(x,page2.getPos(),pivot);
    index.getPageStore().update(page);
    index.getPageStore().update(page2);
    index.getPageStore().update(this);
  }
  updateRowCount(1);
  written=false;
  return -1;
}","int addRowTry(SearchRow row) throws SQLException {
  while (true) {
    int x=find(row,false,true,true);
    PageBtree page=index.getPage(childPageIds[x]);
    int splitPoint=page.addRowTry(row);
    if (splitPoint == -1) {
      break;
    }
    SearchRow pivot=page.getRow(splitPoint - 1);
    index.getPageStore().logUndo(this,data);
    int splitPoint2=addChildTry(pivot);
    if (splitPoint2 != -1) {
      return splitPoint2;
    }
    PageBtree page2=page.split(splitPoint);
    readAllRows();
    addChild(x,page2.getPos(),pivot);
    index.getPageStore().update(page);
    index.getPageStore().update(page2);
    index.getPageStore().update(this);
  }
  updateRowCount(1);
  written=false;
  changeCount=index.getPageStore().getChangeCount();
  return -1;
}",0.9641649763353616
16039,"PageBtree split(int splitPoint) throws SQLException {
  int newPageId=index.getPageStore().allocatePage();
  PageBtreeNode p2=PageBtreeNode.create(index,newPageId,parentPageId);
  index.getPageStore().logUndo(this,data);
  if (onlyPosition) {
    p2.onlyPosition=true;
  }
  int firstChild=childPageIds[splitPoint];
  readAllRows();
  for (int i=splitPoint; i < entryCount; ) {
    p2.addChild(p2.entryCount,childPageIds[splitPoint + 1],rows[splitPoint]);
    removeChild(splitPoint);
  }
  int lastChild=childPageIds[splitPoint - 1];
  removeChild(splitPoint - 1);
  childPageIds[splitPoint - 1]=lastChild;
  if (p2.childPageIds == null) {
    p2.childPageIds=new int[1];
  }
  p2.childPageIds[0]=firstChild;
  p2.remapChildren();
  return p2;
}","PageBtree split(int splitPoint) throws SQLException {
  int newPageId=index.getPageStore().allocatePage();
  PageBtreeNode p2=PageBtreeNode.create(index,newPageId,parentPageId);
  index.getPageStore().logUndo(this,data);
  if (onlyPosition) {
    p2.onlyPosition=true;
  }
  int firstChild=childPageIds[splitPoint];
  readAllRows();
  for (int i=splitPoint; i < entryCount; ) {
    p2.addChild(p2.entryCount,childPageIds[splitPoint + 1],getRow(splitPoint));
    removeChild(splitPoint);
  }
  int lastChild=childPageIds[splitPoint - 1];
  removeChild(splitPoint - 1);
  childPageIds[splitPoint - 1]=lastChild;
  if (p2.childPageIds == null) {
    p2.childPageIds=new int[1];
  }
  p2.childPageIds[0]=firstChild;
  p2.remapChildren();
  return p2;
}",0.9799196787148594
16040,"void freeRecursive() throws SQLException {
  index.getPageStore().logUndo(this,data);
  for (  int childPageId : childPageIds) {
    index.getPage(childPageId).freeRecursive();
  }
}","void freeRecursive() throws SQLException {
  index.getPageStore().logUndo(this,data);
  index.getPageStore().free(getPos());
  for (  int childPageId : childPageIds) {
    index.getPage(childPageId).freeRecursive();
  }
}",0.9032258064516128
16041,"/** 
 * One of the children has moved to a new page.
 * @param oldPos the old position
 * @param newPos the new position
 */
void moveChild(int oldPos,int newPos) throws SQLException {
  for (int i=0; i < childPageIds.length; i++) {
    if (childPageIds[i] == oldPos) {
      index.getPageStore().logUndo(this,data);
      written=false;
      childPageIds[i]=newPos;
      index.getPageStore().update(this);
      return;
    }
  }
  throw Message.throwInternalError();
}","/** 
 * One of the children has moved to a new page.
 * @param oldPos the old position
 * @param newPos the new position
 */
void moveChild(int oldPos,int newPos) throws SQLException {
  for (int i=0; i < childPageIds.length; i++) {
    if (childPageIds[i] == oldPos) {
      index.getPageStore().logUndo(this,data);
      written=false;
      changeCount=index.getPageStore().getChangeCount();
      childPageIds[i]=newPos;
      index.getPageStore().update(this);
      return;
    }
  }
  throw Message.throwInternalError();
}",0.9430569430569432
16042,"/** 
 * Add a row. If it is possible this method returns -1, otherwise the split point. It is always possible to two rows.
 * @param row the now to add
 * @return the split point of this page, or -1 if no split is required
 */
private int addChildTry(SearchRow row) throws SQLException {
  if (entryCount < 2) {
    return -1;
  }
  int rowLength=index.getRowSize(data,row,onlyPosition);
  int pageSize=index.getPageStore().getPageSize();
  int last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
  if (last - rowLength < start + CHILD_OFFSET_PAIR_LENGTH) {
    return entryCount / 2;
  }
  return -1;
}","/** 
 * Add a row. If it is possible this method returns -1, otherwise the split point. It is always possible to two rows.
 * @param row the now to add
 * @return the split point of this page, or -1 if no split is required
 */
private int addChildTry(SearchRow row) throws SQLException {
  if (entryCount < 3) {
    return -1;
  }
  int rowLength=index.getRowSize(data,row,onlyPosition);
  int pageSize=index.getPageStore().getPageSize();
  int last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
  if (last - rowLength < start + CHILD_OFFSET_PAIR_LENGTH) {
    return entryCount / 2;
  }
  return -1;
}",0.9983606557377048
16043,"/** 
 * Create a new b-tree node page.
 * @param index the index
 * @param pageId the page id
 * @param parentPageId the parent page id
 * @return the page
 */
static PageBtreeNode create(PageBtreeIndex index,int pageId,int parentPageId) throws SQLException {
  PageBtreeNode p=new PageBtreeNode(index,pageId,index.getPageStore().createData());
  index.getPageStore().logUndo(p,null);
  p.parentPageId=parentPageId;
  p.writeHead();
  p.start=p.data.length() + 4;
  return p;
}","/** 
 * Create a new b-tree node page.
 * @param index the index
 * @param pageId the page id
 * @param parentPageId the parent page id
 * @return the page
 */
static PageBtreeNode create(PageBtreeIndex index,int pageId,int parentPageId) throws SQLException {
  PageBtreeNode p=new PageBtreeNode(index,pageId,index.getPageStore().createData());
  index.getPageStore().logUndo(p,null);
  p.parentPageId=parentPageId;
  p.writeHead();
  p.start=p.data.length() + 4;
  if (SysProperties.PAGE_STORE_INTERNAL_COUNT) {
    p.rowCount=0;
  }
  return p;
}",0.9131707317073172
16044,"/** 
 * Initialize the page.
 * @param page1 the first child page
 * @param pivot the pivot key
 * @param page2 the last child page
 */
void init(PageBtree page1,SearchRow pivot,PageBtree page2) throws SQLException {
  entryCount=0;
  childPageIds=new int[]{page1.getPos()};
  rows=new SearchRow[0];
  offsets=MemoryUtils.EMPTY_INT_ARRAY;
  addChild(0,page2.getPos(),pivot);
  rowCount=page1.getRowCount() + page2.getRowCount();
  check();
}","/** 
 * Initialize the page.
 * @param page1 the first child page
 * @param pivot the pivot key
 * @param page2 the last child page
 */
void init(PageBtree page1,SearchRow pivot,PageBtree page2) throws SQLException {
  entryCount=0;
  childPageIds=new int[]{page1.getPos()};
  rows=new SearchRow[0];
  offsets=MemoryUtils.EMPTY_INT_ARRAY;
  addChild(0,page2.getPos(),pivot);
  if (SysProperties.PAGE_STORE_INTERNAL_COUNT) {
    rowCount=page1.getRowCount() + page2.getRowCount();
  }
  check();
}",0.9413020277481324
16045,"void setRowCountStored(int rowCount) throws SQLException {
  this.rowCount=rowCount;
  if (rowCountStored != rowCount) {
    rowCountStored=rowCount;
    index.getPageStore().logUndo(this,data);
    if (written) {
      writeHead();
    }
    index.getPageStore().update(this);
  }
}","void setRowCountStored(int rowCount) throws SQLException {
  if (rowCount < 0 && SysProperties.PAGE_STORE_INTERNAL_COUNT) {
    return;
  }
  this.rowCount=rowCount;
  if (rowCountStored != rowCount) {
    rowCountStored=rowCount;
    index.getPageStore().logUndo(this,data);
    if (written) {
      changeCount=index.getPageStore().getChangeCount();
      writeHead();
    }
    index.getPageStore().update(this);
  }
}",0.8039772727272727
16046,"/** 
 * Add a child at the given position.
 * @param x the position
 * @param childPageId the child
 * @param row the row smaller than the first row of the child and its children
 */
private void addChild(int x,int childPageId,SearchRow row) throws SQLException {
  int rowLength=index.getRowSize(data,row,onlyPosition);
  int pageSize=index.getPageStore().getPageSize();
  int last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
  if (last - rowLength < start + CHILD_OFFSET_PAIR_LENGTH) {
    readAllRows();
    onlyPosition=true;
    int o=pageSize;
    for (int i=0; i < entryCount; i++) {
      o-=index.getRowSize(data,getRow(i),true);
      offsets[i]=o;
    }
    last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
    rowLength=index.getRowSize(data,row,true);
    if (SysProperties.CHECK && last - rowLength < start + CHILD_OFFSET_PAIR_LENGTH) {
      throw Message.throwInternalError();
    }
  }
  int offset=last - rowLength;
  int[] newOffsets=new int[entryCount + 1];
  SearchRow[] newRows=new SearchRow[entryCount + 1];
  int[] newChildPageIds=new int[entryCount + 2];
  if (childPageIds != null) {
    System.arraycopy(childPageIds,0,newChildPageIds,0,x + 1);
  }
  if (entryCount > 0) {
    System.arraycopy(offsets,0,newOffsets,0,x);
    System.arraycopy(rows,0,newRows,0,x);
    if (x < entryCount) {
      for (int j=x; j < entryCount; j++) {
        newOffsets[j + 1]=offsets[j] - rowLength;
      }
      offset=(x == 0 ? pageSize : offsets[x - 1]) - rowLength;
      System.arraycopy(rows,x,newRows,x + 1,entryCount - x);
      System.arraycopy(childPageIds,x + 1,newChildPageIds,x + 2,entryCount - x);
    }
  }
  newOffsets[x]=offset;
  newRows[x]=row;
  newChildPageIds[x + 1]=childPageId;
  start+=CHILD_OFFSET_PAIR_LENGTH;
  offsets=newOffsets;
  rows=newRows;
  childPageIds=newChildPageIds;
  entryCount++;
  written=false;
}","/** 
 * Add a child at the given position.
 * @param x the position
 * @param childPageId the child
 * @param row the row smaller than the first row of the child and its children
 */
private void addChild(int x,int childPageId,SearchRow row) throws SQLException {
  int rowLength=index.getRowSize(data,row,onlyPosition);
  int pageSize=index.getPageStore().getPageSize();
  int last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
  if (last - rowLength < start + CHILD_OFFSET_PAIR_LENGTH) {
    readAllRows();
    onlyPosition=true;
    int o=pageSize;
    for (int i=0; i < entryCount; i++) {
      o-=index.getRowSize(data,getRow(i),true);
      offsets[i]=o;
    }
    last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
    rowLength=index.getRowSize(data,row,true);
    if (SysProperties.CHECK && last - rowLength < start + CHILD_OFFSET_PAIR_LENGTH) {
      throw Message.throwInternalError();
    }
  }
  int offset=last - rowLength;
  int[] newOffsets=new int[entryCount + 1];
  SearchRow[] newRows=new SearchRow[entryCount + 1];
  int[] newChildPageIds=new int[entryCount + 2];
  if (childPageIds != null) {
    System.arraycopy(childPageIds,0,newChildPageIds,0,x + 1);
  }
  if (entryCount > 0) {
    System.arraycopy(offsets,0,newOffsets,0,x);
    System.arraycopy(rows,0,newRows,0,x);
    if (x < entryCount) {
      for (int j=x; j < entryCount; j++) {
        newOffsets[j + 1]=offsets[j] - rowLength;
      }
      offset=(x == 0 ? pageSize : offsets[x - 1]) - rowLength;
      System.arraycopy(rows,x,newRows,x + 1,entryCount - x);
      System.arraycopy(childPageIds,x + 1,newChildPageIds,x + 2,entryCount - x);
    }
  }
  newOffsets[x]=offset;
  newRows[x]=row;
  newChildPageIds[x + 1]=childPageId;
  start+=CHILD_OFFSET_PAIR_LENGTH;
  offsets=newOffsets;
  rows=newRows;
  childPageIds=newChildPageIds;
  if (SysProperties.PAGE_STORE_INTERNAL_COUNT) {
    if (rowCount != UNKNOWN_ROWCOUNT) {
      rowCount+=offset;
    }
  }
  entryCount++;
  written=false;
  changeCount=index.getPageStore().getChangeCount();
}",0.955079122001021
16047,"public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  store.logUndo(this,data);
  PageBtreeNode p2=PageBtreeNode.create(index,newPos,parentPageId);
  readAllRows();
  p2.rowCountStored=rowCountStored;
  p2.rowCount=rowCount;
  p2.childPageIds=childPageIds;
  p2.rows=rows;
  p2.entryCount=entryCount;
  p2.offsets=offsets;
  p2.onlyPosition=onlyPosition;
  p2.parentPageId=parentPageId;
  p2.start=start;
  store.update(p2);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageBtreeNode p=(PageBtreeNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
  for (  int childPageId : childPageIds) {
    PageBtree p=index.getPage(childPageId);
    p.setParentPageId(newPos);
    store.update(p);
  }
  store.free(getPos());
}","public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  store.logUndo(this,data);
  PageBtreeNode p2=PageBtreeNode.create(index,newPos,parentPageId);
  readAllRows();
  p2.rowCountStored=rowCountStored;
  p2.rowCount=rowCount;
  p2.childPageIds=childPageIds;
  p2.rows=rows;
  p2.entryCount=entryCount;
  p2.offsets=offsets;
  p2.onlyPosition=onlyPosition;
  p2.parentPageId=parentPageId;
  p2.start=start;
  store.update(p2);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    Page p=store.getPage(parentPageId);
    if (!(p instanceof PageBtreeNode)) {
      throw Message.throwInternalError();
    }
    PageBtreeNode n=(PageBtreeNode)p;
    n.moveChild(getPos(),newPos);
  }
  for (  int childPageId : childPageIds) {
    PageBtree p=index.getPage(childPageId);
    p.setParentPageId(newPos);
    store.update(p);
  }
  store.free(getPos());
}",0.8979131415679639
16048,"/** 
 * Change the parent page id.
 * @param id the new parent page id
 */
void setParentPageId(int id) throws SQLException {
  index.getPageStore().logUndo(this,data);
  parentPageId=id;
  if (written) {
    data.setInt(START_PARENT,parentPageId);
  }
}","/** 
 * Change the parent page id.
 * @param id the new parent page id
 */
void setParentPageId(int id) throws SQLException {
  index.getPageStore().logUndo(this,data);
  parentPageId=id;
  if (written) {
    changeCount=index.getPageStore().getChangeCount();
    data.setInt(START_PARENT,parentPageId);
  }
}",0.9023090586145648
16049,"public void remove(Session session) throws SQLException {
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"");
  }
  removeAllRows();
  store.free(rootPageId,true);
  store.removeMeta(this,session);
}","public void remove(Session session) throws SQLException {
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"");
  }
  removeAllRows();
  store.free(rootPageId);
  store.removeMeta(this,session);
}",0.8658823529411764
16050,"private void removeAllRows() throws SQLException {
  PageBtree root=getPage(rootPageId);
  store.logUndo(root,root.data);
  root.freeChildren();
  root=PageBtreeLeaf.create(this,rootPageId,PageBtree.ROOT);
  store.removeRecord(rootPageId);
  store.update(root);
  rowCount=0;
}","private void removeAllRows() throws SQLException {
  PageBtree root=getPage(rootPageId);
  root.freeRecursive();
  root=PageBtreeLeaf.create(this,rootPageId,PageBtree.ROOT);
  store.removeRecord(rootPageId);
  store.update(root);
  rowCount=0;
}",0.9042145593869731
16051,"public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  readAllRows();
  PageBtreeLeaf p2=PageBtreeLeaf.create(index,newPos,parentPageId);
  store.logUndo(this,data);
  store.logUndo(p2,null);
  p2.rows=rows;
  p2.entryCount=entryCount;
  p2.offsets=offsets;
  p2.onlyPosition=onlyPosition;
  p2.parentPageId=parentPageId;
  p2.start=start;
  store.update(p2);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageBtreeNode p=(PageBtreeNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
  store.free(getPos(),true);
}","public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  readAllRows();
  PageBtreeLeaf p2=PageBtreeLeaf.create(index,newPos,parentPageId);
  store.logUndo(this,data);
  store.logUndo(p2,null);
  p2.rows=rows;
  p2.entryCount=entryCount;
  p2.offsets=offsets;
  p2.onlyPosition=onlyPosition;
  p2.parentPageId=parentPageId;
  p2.start=start;
  store.update(p2);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageBtreeNode p=(PageBtreeNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
  store.free(getPos());
}",0.996022275258552
16052,"SearchRow remove(SearchRow row) throws SQLException {
  int at=find(row,false,false,true);
  PageBtree page=index.getPage(childPageIds[at]);
  SearchRow last=page.remove(row);
  index.getPageStore().logUndo(this,data);
  updateRowCount(-1);
  written=false;
  if (last == null) {
    return null;
  }
 else   if (last == row) {
    index.getPageStore().free(page.getPos(),true);
    if (entryCount < 1) {
      return row;
    }
    if (at == entryCount) {
      last=getRow(at - 1);
    }
 else {
      last=null;
    }
    removeChild(at);
    index.getPageStore().update(this);
    return last;
  }
  if (at == entryCount) {
    return last;
  }
  int child=childPageIds[at];
  removeChild(at);
  addChild(at,child,last);
  int temp=childPageIds[at];
  childPageIds[at]=childPageIds[at + 1];
  childPageIds[at + 1]=temp;
  index.getPageStore().update(this);
  return null;
}","SearchRow remove(SearchRow row) throws SQLException {
  int at=find(row,false,false,true);
  PageBtree page=index.getPage(childPageIds[at]);
  SearchRow last=page.remove(row);
  index.getPageStore().logUndo(this,data);
  updateRowCount(-1);
  written=false;
  if (last == null) {
    return null;
  }
 else   if (last == row) {
    index.getPageStore().free(page.getPos());
    if (entryCount < 1) {
      return row;
    }
    if (at == entryCount) {
      last=getRow(at - 1);
    }
 else {
      last=null;
    }
    removeChild(at);
    index.getPageStore().update(this);
    return last;
  }
  if (at == entryCount) {
    return last;
  }
  int child=childPageIds[at];
  removeChild(at);
  addChild(at,child,last);
  int temp=childPageIds[at];
  childPageIds[at]=childPageIds[at + 1];
  childPageIds[at + 1]=temp;
  index.getPageStore().update(this);
  return null;
}",0.9971412235563178
16053,"public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  store.logUndo(this,data);
  PageBtreeNode p2=PageBtreeNode.create(index,newPos,parentPageId);
  readAllRows();
  p2.rowCountStored=rowCountStored;
  p2.rowCount=rowCount;
  p2.childPageIds=childPageIds;
  p2.rows=rows;
  p2.entryCount=entryCount;
  p2.offsets=offsets;
  p2.onlyPosition=onlyPosition;
  p2.parentPageId=parentPageId;
  p2.start=start;
  store.update(p2);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageBtreeNode p=(PageBtreeNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
  for (int i=0; i < childPageIds.length; i++) {
    PageBtree p=(PageBtree)store.getPage(childPageIds[i]);
    p.setParentPageId(newPos);
    store.update(p);
  }
  store.free(getPos(),true);
}","public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  store.logUndo(this,data);
  PageBtreeNode p2=PageBtreeNode.create(index,newPos,parentPageId);
  readAllRows();
  p2.rowCountStored=rowCountStored;
  p2.rowCount=rowCount;
  p2.childPageIds=childPageIds;
  p2.rows=rows;
  p2.entryCount=entryCount;
  p2.offsets=offsets;
  p2.onlyPosition=onlyPosition;
  p2.parentPageId=parentPageId;
  p2.start=start;
  store.update(p2);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageBtreeNode p=(PageBtreeNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
  for (  int childPageId : childPageIds) {
    PageBtree p=index.getPage(childPageId);
    p.setParentPageId(newPos);
    store.update(p);
  }
  store.free(getPos());
}",0.9227138643067848
16054,"public void remove(Session session) throws SQLException {
  if (trace.isDebugEnabled()) {
    trace.debug(this + ""String_Node_Str"");
  }
  removeAllRows();
  store.free(rootPageId,true);
  store.removeMeta(this,session);
}","public void remove(Session session) throws SQLException {
  if (trace.isDebugEnabled()) {
    trace.debug(this + ""String_Node_Str"");
  }
  removeAllRows();
  store.free(rootPageId);
  store.removeMeta(this,session);
}",0.8701594533029613
16055,"private void removeAllRows() throws SQLException {
  PageData root=getPage(rootPageId,0);
  store.logUndo(root,root.data);
  root.freeChildren();
  root=PageDataLeaf.create(this,rootPageId,PageData.ROOT);
  store.removeRecord(rootPageId);
  store.update(root);
  rowCount=0;
  lastKey=0;
}","private void removeAllRows() throws SQLException {
  PageData root=getPage(rootPageId,0);
  root.freeRecursive();
  root=PageDataLeaf.create(this,rootPageId,PageData.ROOT);
  store.removeRecord(rootPageId);
  store.update(root);
  rowCount=0;
  lastKey=0;
}",0.9084249084249084
16056,"/** 
 * Read an overflow page page.
 * @param id the page id
 * @return the page
 */
PageDataOverflow getPageOverflow(int id) throws SQLException {
  return (PageDataOverflow)store.getPage(id);
}","/** 
 * Read an overflow page page.
 * @param id the page id
 * @return the page
 */
PageDataOverflow getPageOverflow(int id) throws SQLException {
  Page p=store.getPage(id);
  if (p instanceof PageDataOverflow) {
    return (PageDataOverflow)p;
  }
  throw Message.getSQLException(ErrorCode.FILE_CORRUPTED_1,p.toString());
}",0.6833013435700576
16057,"boolean remove(long key) throws SQLException {
  int i=find(key);
  if (keys[i] != key) {
    throw Message.getSQLException(ErrorCode.ROW_NOT_FOUND_WHEN_DELETING_1,index.getSQL() + ""String_Node_Str"" + key);
  }
  index.getPageStore().logUndo(this,data);
  if (entryCount == 1) {
    freeChildren();
    return true;
  }
  removeRow(i);
  index.getPageStore().update(this);
  return false;
}","boolean remove(long key) throws SQLException {
  int i=find(key);
  if (keys[i] != key) {
    throw Message.getSQLException(ErrorCode.ROW_NOT_FOUND_WHEN_DELETING_1,index.getSQL() + ""String_Node_Str"" + key);
  }
  index.getPageStore().logUndo(this,data);
  if (entryCount == 1) {
    freeRecursive();
    return true;
  }
  removeRow(i);
  index.getPageStore().update(this);
  return false;
}",0.7451984635083226
16058,"int addRowTry(Row row) throws SQLException {
  index.getPageStore().logUndo(this,data);
  int rowLength=getRowLength(row);
  int pageSize=index.getPageStore().getPageSize();
  int last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
  int keyOffsetPairLen=2 + data.getVarLongLen(row.getKey());
  if (entryCount > 0 && last - rowLength < start + keyOffsetPairLen) {
    int x=find(row.getKey());
    if (entryCount > 1) {
      if (entryCount < 5) {
        return entryCount / 2;
      }
      if (index.isSortedInsertMode()) {
        return x < 2 ? 1 : x > entryCount - 1 ? entryCount - 1 : x;
      }
      int third=entryCount / 3;
      return x < third ? third : x >= 2 * third ? 2 * third : x;
    }
    return x;
  }
  index.getPageStore().logUndo(this,data);
  int offset=last - rowLength;
  int[] newOffsets=new int[entryCount + 1];
  long[] newKeys=new long[entryCount + 1];
  Row[] newRows=new Row[entryCount + 1];
  int x;
  if (entryCount == 0) {
    x=0;
  }
 else {
    readAllRows();
    x=find(row.getKey());
    if (x < keys.length && keys[x] == row.getKey()) {
      throw index.getDuplicateKeyException();
    }
    System.arraycopy(offsets,0,newOffsets,0,x);
    System.arraycopy(keys,0,newKeys,0,x);
    System.arraycopy(rows,0,newRows,0,x);
    if (x < entryCount) {
      for (int j=x; j < entryCount; j++) {
        newOffsets[j + 1]=offsets[j] - rowLength;
      }
      System.arraycopy(keys,x,newKeys,x + 1,entryCount - x);
      System.arraycopy(rows,x,newRows,x + 1,entryCount - x);
    }
  }
  written=false;
  last=x == 0 ? pageSize : offsets[x - 1];
  offset=last - rowLength;
  entryCount++;
  start+=keyOffsetPairLen;
  newOffsets[x]=offset;
  newKeys[x]=row.getKey();
  newRows[x]=row;
  memorySize+=row.getMemorySize();
  offsets=newOffsets;
  keys=newKeys;
  rows=newRows;
  index.getPageStore().update(this);
  if (offset < start) {
    if (entryCount > 1) {
      Message.throwInternalError();
    }
    start+=4;
    int remaining=rowLength - (pageSize - start);
    offset=start;
    offsets[x]=offset;
    int previous=getPos();
    int dataOffset=pageSize;
    int page=index.getPageStore().allocatePage();
    firstOverflowPageId=page;
    this.overflowRowSize=pageSize + rowLength;
    write();
    rowRef=new SoftReference<Row>(rows[0]);
    rows[0]=null;
    Data all=index.getPageStore().createData();
    all.checkCapacity(data.length());
    all.write(data.getBytes(),0,data.length());
    data.truncate(index.getPageStore().getPageSize());
    do {
      int type, size, next;
      if (remaining <= pageSize - PageDataOverflow.START_LAST) {
        type=Page.TYPE_DATA_OVERFLOW | Page.FLAG_LAST;
        size=remaining;
        next=0;
      }
 else {
        type=Page.TYPE_DATA_OVERFLOW;
        size=pageSize - PageDataOverflow.START_MORE;
        next=index.getPageStore().allocatePage();
      }
      PageDataOverflow overflow=PageDataOverflow.create(index.getPageStore(),page,type,previous,next,all,dataOffset,size);
      index.getPageStore().update(overflow);
      dataOffset+=size;
      remaining-=size;
      previous=page;
      page=next;
    }
 while (remaining > 0);
  }
  return -1;
}","int addRowTry(Row row) throws SQLException {
  index.getPageStore().logUndo(this,data);
  int rowLength=getRowLength(row);
  int pageSize=index.getPageStore().getPageSize();
  int last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
  int keyOffsetPairLen=2 + data.getVarLongLen(row.getKey());
  if (entryCount > 0 && last - rowLength < start + keyOffsetPairLen) {
    int x=findInsertionPoint(row.getKey());
    if (entryCount > 1) {
      if (entryCount < 5) {
        return entryCount / 2;
      }
      if (index.isSortedInsertMode()) {
        return x < 2 ? 1 : x > entryCount - 1 ? entryCount - 1 : x;
      }
      int third=entryCount / 3;
      return x < third ? third : x >= 2 * third ? 2 * third : x;
    }
    return x;
  }
  index.getPageStore().logUndo(this,data);
  int offset=last - rowLength;
  int[] newOffsets=new int[entryCount + 1];
  long[] newKeys=new long[entryCount + 1];
  Row[] newRows=new Row[entryCount + 1];
  int x;
  if (entryCount == 0) {
    x=0;
  }
 else {
    readAllRows();
    x=findInsertionPoint(row.getKey());
    System.arraycopy(offsets,0,newOffsets,0,x);
    System.arraycopy(keys,0,newKeys,0,x);
    System.arraycopy(rows,0,newRows,0,x);
    if (x < entryCount) {
      for (int j=x; j < entryCount; j++) {
        newOffsets[j + 1]=offsets[j] - rowLength;
      }
      System.arraycopy(keys,x,newKeys,x + 1,entryCount - x);
      System.arraycopy(rows,x,newRows,x + 1,entryCount - x);
    }
  }
  written=false;
  last=x == 0 ? pageSize : offsets[x - 1];
  offset=last - rowLength;
  entryCount++;
  start+=keyOffsetPairLen;
  newOffsets[x]=offset;
  newKeys[x]=row.getKey();
  newRows[x]=row;
  memorySize+=row.getMemorySize();
  offsets=newOffsets;
  keys=newKeys;
  rows=newRows;
  index.getPageStore().update(this);
  if (offset < start) {
    if (entryCount > 1) {
      Message.throwInternalError();
    }
    start+=4;
    int remaining=rowLength - (pageSize - start);
    offset=start;
    offsets[x]=offset;
    int previous=getPos();
    int dataOffset=pageSize;
    int page=index.getPageStore().allocatePage();
    firstOverflowPageId=page;
    this.overflowRowSize=pageSize + rowLength;
    write();
    rowRef=new SoftReference<Row>(rows[0]);
    rows[0]=null;
    Data all=index.getPageStore().createData();
    all.checkCapacity(data.length());
    all.write(data.getBytes(),0,data.length());
    data.truncate(index.getPageStore().getPageSize());
    do {
      int type, size, next;
      if (remaining <= pageSize - PageDataOverflow.START_LAST) {
        type=Page.TYPE_DATA_OVERFLOW | Page.FLAG_LAST;
        size=remaining;
        next=0;
      }
 else {
        type=Page.TYPE_DATA_OVERFLOW;
        size=pageSize - PageDataOverflow.START_MORE;
        next=index.getPageStore().allocatePage();
      }
      PageDataOverflow overflow=PageDataOverflow.create(index.getPageStore(),page,type,previous,next,all,dataOffset,size);
      index.getPageStore().update(overflow);
      dataOffset+=size;
      remaining-=size;
      previous=page;
      page=next;
    }
 while (remaining > 0);
  }
  return -1;
}",0.978546269612552
16059,"private void removeRow(int i) throws SQLException {
  index.getPageStore().logUndo(this,data);
  written=false;
  readAllRows();
  Row r=rows[i];
  if (r != null) {
    memorySize+=r.getMemorySize();
  }
  entryCount--;
  if (entryCount < 0) {
    Message.throwInternalError();
  }
  freeChildren();
  firstOverflowPageId=0;
  overflowRowSize=0;
  rowRef=null;
  int keyOffsetPairLen=2 + data.getVarLongLen(keys[i]);
  int[] newOffsets=new int[entryCount];
  long[] newKeys=new long[entryCount];
  Row[] newRows=new Row[entryCount];
  System.arraycopy(offsets,0,newOffsets,0,i);
  System.arraycopy(keys,0,newKeys,0,i);
  System.arraycopy(rows,0,newRows,0,i);
  int startNext=i > 0 ? offsets[i - 1] : index.getPageStore().getPageSize();
  int rowLength=startNext - offsets[i];
  int clearStart=offsets[entryCount];
  Arrays.fill(data.getBytes(),clearStart,clearStart + rowLength,(byte)0);
  for (int j=i; j < entryCount; j++) {
    newOffsets[j]=offsets[j + 1] + rowLength;
  }
  System.arraycopy(keys,i + 1,newKeys,i,entryCount - i);
  System.arraycopy(rows,i + 1,newRows,i,entryCount - i);
  start-=keyOffsetPairLen;
  offsets=newOffsets;
  keys=newKeys;
  rows=newRows;
}","private void removeRow(int i) throws SQLException {
  index.getPageStore().logUndo(this,data);
  written=false;
  readAllRows();
  Row r=rows[i];
  if (r != null) {
    memorySize+=r.getMemorySize();
  }
  entryCount--;
  if (entryCount < 0) {
    Message.throwInternalError();
  }
  freeOverflow();
  firstOverflowPageId=0;
  overflowRowSize=0;
  rowRef=null;
  int keyOffsetPairLen=2 + data.getVarLongLen(keys[i]);
  int[] newOffsets=new int[entryCount];
  long[] newKeys=new long[entryCount];
  Row[] newRows=new Row[entryCount];
  System.arraycopy(offsets,0,newOffsets,0,i);
  System.arraycopy(keys,0,newKeys,0,i);
  System.arraycopy(rows,0,newRows,0,i);
  int startNext=i > 0 ? offsets[i - 1] : index.getPageStore().getPageSize();
  int rowLength=startNext - offsets[i];
  int clearStart=offsets[entryCount];
  Arrays.fill(data.getBytes(),clearStart,clearStart + rowLength,(byte)0);
  for (int j=i; j < entryCount; j++) {
    newOffsets[j]=offsets[j + 1] + rowLength;
  }
  System.arraycopy(keys,i + 1,newKeys,i,entryCount - i);
  System.arraycopy(rows,i + 1,newRows,i,entryCount - i);
  start-=keyOffsetPairLen;
  offsets=newOffsets;
  keys=newKeys;
  rows=newRows;
}",0.9931798806479112
16060,"/** 
 * Get the row at the given index.
 * @param at the index
 * @return the row
 */
Row getRowAt(int at) throws SQLException {
  Row r=rows[at];
  if (r == null) {
    if (firstOverflowPageId == 0) {
      data.setPos(offsets[at]);
      r=index.readRow(data,columnCount);
    }
 else {
      if (rowRef != null) {
        r=rowRef.get();
        if (r != null) {
          return r;
        }
      }
      PageStore store=index.getPageStore();
      Data buff=store.createData();
      int pageSize=store.getPageSize();
      int offset=offsets[at];
      buff.write(data.getBytes(),offset,pageSize - offset);
      int next=firstOverflowPageId;
      do {
        PageDataOverflow page=index.getPageOverflow(next);
        if (page == null) {
          page=index.getPageOverflow(next);
          System.out.println(""String_Node_Str"");
        }
        next=page.readInto(buff);
      }
 while (next != 0);
      overflowRowSize=pageSize + buff.length();
      buff.setPos(0);
      r=index.readRow(buff,columnCount);
    }
    r.setKey(keys[at]);
    if (firstOverflowPageId != 0) {
      rowRef=new SoftReference<Row>(r);
    }
 else {
      rows[at]=r;
      memorySize+=r.getMemorySize();
    }
  }
  return r;
}","/** 
 * Get the row at the given index.
 * @param at the index
 * @return the row
 */
Row getRowAt(int at) throws SQLException {
  Row r=rows[at];
  if (r == null) {
    if (firstOverflowPageId == 0) {
      data.setPos(offsets[at]);
      r=index.readRow(data,columnCount);
    }
 else {
      if (rowRef != null) {
        r=rowRef.get();
        if (r != null) {
          return r;
        }
      }
      PageStore store=index.getPageStore();
      Data buff=store.createData();
      int pageSize=store.getPageSize();
      int offset=offsets[at];
      buff.write(data.getBytes(),offset,pageSize - offset);
      int next=firstOverflowPageId;
      do {
        PageDataOverflow page=index.getPageOverflow(next);
        next=page.readInto(buff);
      }
 while (next != 0);
      overflowRowSize=pageSize + buff.length();
      buff.setPos(0);
      r=index.readRow(buff,columnCount);
    }
    r.setKey(keys[at]);
    if (firstOverflowPageId != 0) {
      rowRef=new SoftReference<Row>(r);
    }
 else {
      rows[at]=r;
      memorySize+=r.getMemorySize();
    }
  }
  return r;
}",0.7764807609165586
16061,"public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  store.logUndo(this,data);
  PageDataLeaf p2=PageDataLeaf.create(index,newPos,parentPageId);
  readAllRows();
  p2.keys=keys;
  p2.overflowRowSize=overflowRowSize;
  p2.firstOverflowPageId=firstOverflowPageId;
  p2.rowRef=rowRef;
  p2.rows=rows;
  if (firstOverflowPageId != 0) {
    p2.rows[0]=getRowAt(0);
  }
  p2.entryCount=entryCount;
  p2.offsets=offsets;
  p2.start=start;
  p2.remapChildren(getPos());
  p2.write();
  p2.data.truncate(index.getPageStore().getPageSize());
  store.update(p2);
  store.free(getPos(),true);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageDataNode p=(PageDataNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
}","public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  store.logUndo(this,data);
  PageDataLeaf p2=PageDataLeaf.create(index,newPos,parentPageId);
  readAllRows();
  p2.keys=keys;
  p2.overflowRowSize=overflowRowSize;
  p2.firstOverflowPageId=firstOverflowPageId;
  p2.rowRef=rowRef;
  p2.rows=rows;
  if (firstOverflowPageId != 0) {
    p2.rows[0]=getRowAt(0);
  }
  p2.entryCount=entryCount;
  p2.offsets=offsets;
  p2.start=start;
  p2.remapChildren(getPos());
  p2.write();
  p2.data.truncate(index.getPageStore().getPageSize());
  store.update(p2);
  store.free(getPos());
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageDataNode p=(PageDataNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
}",0.9969530773918344
16062,"boolean remove(long key) throws SQLException {
  int at=find(key);
  PageData page=index.getPage(childPageIds[at],getPos());
  boolean empty=page.remove(key);
  index.getPageStore().logUndo(this,data);
  updateRowCount(-1);
  if (!empty) {
    return false;
  }
  index.getPageStore().free(page.getPos(),true);
  if (entryCount < 1) {
    return true;
  }
  removeChild(at);
  index.getPageStore().update(this);
  return false;
}","boolean remove(long key) throws SQLException {
  int at=find(key);
  PageData page=index.getPage(childPageIds[at],getPos());
  boolean empty=page.remove(key);
  index.getPageStore().logUndo(this,data);
  updateRowCount(-1);
  if (!empty) {
    return false;
  }
  index.getPageStore().free(page.getPos());
  if (entryCount < 1) {
    return true;
  }
  removeChild(at);
  index.getPageStore().update(this);
  return false;
}",0.9941383352872216
16063,"public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  store.logUndo(this,data);
  PageDataNode p2=PageDataNode.create(index,newPos,parentPageId);
  p2.rowCountStored=rowCountStored;
  p2.rowCount=rowCount;
  p2.childPageIds=childPageIds;
  p2.keys=keys;
  p2.entryCount=entryCount;
  p2.length=length;
  store.update(p2);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageDataNode p=(PageDataNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
  for (int i=0; i < childPageIds.length; i++) {
    PageData p=(PageData)store.getPage(childPageIds[i]);
    p.setParentPageId(newPos);
    store.update(p);
  }
  store.free(getPos(),true);
}","public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  store.logUndo(this,data);
  PageDataNode p2=PageDataNode.create(index,newPos,parentPageId);
  p2.rowCountStored=rowCountStored;
  p2.rowCount=rowCount;
  p2.childPageIds=childPageIds;
  p2.keys=keys;
  p2.entryCount=entryCount;
  p2.length=length;
  store.update(p2);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageDataNode p=(PageDataNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
  for (int i=0; i < childPageIds.length; i++) {
    PageData p=(PageData)store.getPage(childPageIds[i]);
    p.setParentPageId(newPos);
    store.update(p);
  }
  store.free(getPos());
}",0.9966688874083944
16064,"public void moveTo(Session session,int newPos) throws SQLException {
  store.logUndo(this,data);
  PageDataOverflow p2=PageDataOverflow.create(store,newPos,type,parentPageId,nextPage,data,start,size);
  store.update(p2);
  if (nextPage != 0) {
    PageDataOverflow p3=(PageDataOverflow)store.getPage(nextPage);
    p3.setParentPageId(newPos);
    store.update(p3);
  }
  Page p=store.getPage(parentPageId);
  if (p == null) {
    throw Message.throwInternalError();
  }
  if (p instanceof PageDataOverflow) {
    PageDataOverflow p1=(PageDataOverflow)p;
    p1.setNext(getPos(),newPos);
  }
 else {
    PageDataLeaf p1=(PageDataLeaf)p;
    p1.setOverflow(getPos(),newPos);
  }
  store.update(p);
  store.free(getPos(),true);
}","public void moveTo(Session session,int newPos) throws SQLException {
  store.logUndo(this,data);
  PageDataOverflow p2=PageDataOverflow.create(store,newPos,type,parentPageId,nextPage,data,start,size);
  store.update(p2);
  if (nextPage != 0) {
    PageDataOverflow p3=(PageDataOverflow)store.getPage(nextPage);
    p3.setParentPageId(newPos);
    store.update(p3);
  }
  Page p=store.getPage(parentPageId);
  if (p == null) {
    throw Message.throwInternalError();
  }
  if (p instanceof PageDataOverflow) {
    PageDataOverflow p1=(PageDataOverflow)p;
    p1.setNext(getPos(),newPos);
  }
 else {
    PageDataLeaf p1=(PageDataLeaf)p;
    p1.setOverflow(getPos(),newPos);
  }
  store.update(p);
  store.free(getPos());
}",0.9965445749827228
16065,"/** 
 * Add a page to the free list.
 * @param pageId the page id
 * @param undo if the undo record must have been written
 */
public void free(int pageId,boolean undo) throws SQLException {
  if (trace.isDebugEnabled()) {
  }
synchronized (database) {
    cache.remove(pageId);
    if (SysProperties.CHECK && !recoveryRunning && undo) {
      log.addUndo(pageId,null);
    }
    freePage(pageId);
    if (recoveryRunning) {
      writePage(pageId,createData());
    }
  }
}","/** 
 * Add a page to the free list.
 * @param pageId the page id
 * @param undo if the undo record must have been written
 */
void free(int pageId,boolean undo) throws SQLException {
  if (trace.isDebugEnabled()) {
  }
synchronized (database) {
    cache.remove(pageId);
    if (SysProperties.CHECK && !recoveryRunning && undo) {
      log.addUndo(pageId,null);
    }
    freePage(pageId);
    if (recoveryRunning) {
      writePage(pageId,createData());
    }
  }
}",0.9925611052072264
16066,"/** 
 * Run recovery.
 */
private void recover() throws SQLException {
  trace.debug(""String_Node_Str"");
  recoveryRunning=true;
  log.recover(PageLog.RECOVERY_STAGE_UNDO);
  if (reservedPages != null) {
    for (    int r : reservedPages.keySet()) {
      if (trace.isDebugEnabled()) {
        trace.debug(""String_Node_Str"" + r);
      }
      allocatePage(r);
    }
  }
  log.recover(PageLog.RECOVERY_STAGE_ALLOCATE);
  openMetaIndex();
  readMetaData();
  log.recover(PageLog.RECOVERY_STAGE_REDO);
  boolean setReadOnly=false;
  if (!database.isReadOnly()) {
    if (log.getInDoubtTransactions().size() == 0) {
      log.recoverEnd();
      switchLog();
    }
 else {
      setReadOnly=true;
    }
  }
  PageDataIndex systemTable=(PageDataIndex)metaObjects.get(0);
  if (systemTable == null) {
    systemTableHeadPos=Index.EMPTY_HEAD;
  }
 else {
    systemTableHeadPos=systemTable.getHeadPos();
  }
  for (  Index openIndex : metaObjects.values()) {
    if (openIndex.getTable().isTemporary()) {
      openIndex.truncate(systemSession);
      openIndex.remove(systemSession);
      removeMetaIndex(openIndex,systemSession);
    }
    openIndex.close(systemSession);
  }
  allocatePage(PAGE_ID_META_ROOT);
  recoveryRunning=false;
  reservedPages=null;
  writeIndexRowCounts();
  writeBack();
  cache.clear();
  freeLists.clear();
  metaObjects.clear();
  metaObjects.put(-1,metaIndex);
  if (setReadOnly) {
    database.setReadOnly(true);
  }
  trace.debug(""String_Node_Str"");
}","/** 
 * Run recovery.
 */
private void recover() throws SQLException {
  trace.debug(""String_Node_Str"");
  recoveryRunning=true;
  log.recover(PageLog.RECOVERY_STAGE_UNDO);
  if (reservedPages != null) {
    for (    int r : reservedPages.keySet()) {
      if (trace.isDebugEnabled()) {
        trace.debug(""String_Node_Str"" + r);
      }
      allocatePage(r);
    }
  }
  log.recover(PageLog.RECOVERY_STAGE_ALLOCATE);
  openMetaIndex();
  readMetaData();
  log.recover(PageLog.RECOVERY_STAGE_REDO);
  boolean setReadOnly=false;
  if (!database.isReadOnly()) {
    if (log.getInDoubtTransactions().size() == 0) {
      log.recoverEnd();
      switchLog();
    }
 else {
      setReadOnly=true;
    }
  }
  PageDataIndex systemTable=(PageDataIndex)metaObjects.get(0);
  if (systemTable == null) {
    systemTableHeadPos=Index.EMPTY_HEAD;
  }
 else {
    systemTableHeadPos=systemTable.getHeadPos();
  }
  for (  Index openIndex : metaObjects.values()) {
    if (openIndex.getTable().isTemporary()) {
      openIndex.truncate(systemSession);
      openIndex.remove(systemSession);
      removeMetaIndex(openIndex,systemSession);
    }
    openIndex.close(systemSession);
  }
  allocatePage(PAGE_ID_META_ROOT);
  writeIndexRowCounts();
  recoveryRunning=false;
  reservedPages=null;
  writeBack();
  cache.clear();
  freeLists.clear();
  metaObjects.clear();
  metaObjects.put(-1,metaIndex);
  if (setReadOnly) {
    database.setReadOnly(true);
  }
  trace.debug(""String_Node_Str"");
}",0.9831309041835358
16067,"/** 
 * Open a database connection with the given connection information.
 * @param ci the connection information
 * @return the session
 */
public Session getSession(ConnectionInfo ci) throws SQLException {
  try {
    ConnectionInfo backup=null;
    String lockMethodName=ci.getProperty(""String_Node_Str"",null);
    int fileLockMethod=FileLock.getFileLockMethod(lockMethodName);
    if (fileLockMethod == FileLock.LOCK_SERIALIZED) {
      try {
        backup=(ConnectionInfo)ci.clone();
      }
 catch (      CloneNotSupportedException e) {
        throw Message.getInternalError(""String_Node_Str"",e);
      }
    }
    Session session=openSession(ci);
    validateUserAndPassword(true);
    if (backup != null) {
      session.setConnectionInfo(backup);
    }
    return session;
  }
 catch (  SQLException e) {
    if (e.getErrorCode() == ErrorCode.WRONG_USER_OR_PASSWORD) {
      validateUserAndPassword(false);
    }
    throw e;
  }
}","/** 
 * Open a database connection with the given connection information.
 * @param ci the connection information
 * @return the session
 */
public Session getSession(ConnectionInfo ci) throws SQLException {
  try {
    ConnectionInfo backup=null;
    String lockMethodName=ci.getProperty(""String_Node_Str"",null);
    int fileLockMethod=FileLock.getFileLockMethod(lockMethodName);
    if (fileLockMethod == FileLock.LOCK_SERIALIZED) {
      ci.setProperty(""String_Node_Str"",""String_Node_Str"");
      try {
        backup=(ConnectionInfo)ci.clone();
      }
 catch (      CloneNotSupportedException e) {
        throw Message.getInternalError(""String_Node_Str"",e);
      }
    }
    Session session=openSession(ci);
    validateUserAndPassword(true);
    if (backup != null) {
      session.setConnectionInfo(backup);
    }
    return session;
  }
 catch (  SQLException e) {
    if (e.getErrorCode() == ErrorCode.WRONG_USER_OR_PASSWORD) {
      validateUserAndPassword(false);
    }
    throw e;
  }
}",0.9696345856922284
16068,"public SessionInterface reconnect(boolean write) throws SQLException {
  readSessionState();
  close();
  Session newSession=Engine.getInstance().getSession(connectionInfo);
  newSession.sessionState=sessionState;
  newSession.recreateSessionState();
  database.clearCaches();
  if (write) {
    while (!database.beforeWriting()) {
    }
  }
  return newSession;
}","public SessionInterface reconnect(boolean write) throws SQLException {
  readSessionState();
  close();
  Session newSession=Engine.getInstance().getSession(connectionInfo);
  newSession.sessionState=sessionState;
  newSession.recreateSessionState();
  if (write) {
    while (!database.beforeWriting()) {
    }
  }
  return newSession;
}",0.9629629629629628
16069,"public void test() throws Exception {
  println(""String_Node_Str"");
  testCache();
  println(""String_Node_Str"");
  testBigDatabase(false);
  println(""String_Node_Str"");
  testBigDatabase(true);
  println(""String_Node_Str"");
  testCheckpointInUpdateRaceCondition();
  println(""String_Node_Str"");
  testConcurrentUpdates();
  println(""String_Node_Str"");
  testThreeMostlyReaders(true);
  println(""String_Node_Str"");
  testThreeMostlyReaders(false);
  println(""String_Node_Str"");
  testTwoReaders();
  println(""String_Node_Str"");
  testTwoWriters();
  println(""String_Node_Str"");
  testPendingWrite();
  println(""String_Node_Str"");
  testKillWriter();
  println(""String_Node_Str"");
  testConcurrentReadWrite();
}","public void test() throws Exception {
  println(""String_Node_Str"");
  testWrongDatabaseInstanceOnReconnect();
  println(""String_Node_Str"");
  testCache(false);
  println(""String_Node_Str"");
  testCache(true);
  println(""String_Node_Str"");
  testBigDatabase(false);
  println(""String_Node_Str"");
  testBigDatabase(true);
  println(""String_Node_Str"");
  testCheckpointInUpdateRaceCondition();
  println(""String_Node_Str"");
  testConcurrentUpdates();
  println(""String_Node_Str"");
  testThreeMostlyReaders(true);
  println(""String_Node_Str"");
  testThreeMostlyReaders(false);
  println(""String_Node_Str"");
  testTwoReaders();
  println(""String_Node_Str"");
  testTwoWriters();
  println(""String_Node_Str"");
  testPendingWrite();
  println(""String_Node_Str"");
  testKillWriter();
  println(""String_Node_Str"");
  testConcurrentReadWrite();
}",0.9183937823834196
16070,"/** 
 * Caches must be cleared. Session.reconnect only closes the DiskFile (which is associated with the cache) if there is one session
 * @throws Exception
 */
private void testCache() throws Exception {
  deleteDb(""String_Node_Str"");
  String urlShared=""String_Node_Str"" + baseDir + ""String_Node_Str"";
  String urlForNew=urlShared + ""String_Node_Str"";
  Connection connShared1=DriverManager.getConnection(urlShared);
  Connection connShared2=DriverManager.getConnection(urlShared);
  Connection connNew=DriverManager.getConnection(urlForNew);
  connShared1.createStatement().execute(""String_Node_Str"");
  connShared1.createStatement().execute(""String_Node_Str"");
  ResultSet rs=connShared1.createStatement().executeQuery(""String_Node_Str"");
  rs.close();
  connNew.createStatement().execute(""String_Node_Str"");
  Thread.sleep(500);
  rs=connShared1.createStatement().executeQuery(""String_Node_Str"");
  assertTrue(rs.next());
  assertEquals(2,rs.getInt(1));
  rs.close();
  connShared1.close();
  connShared2.close();
  connNew.close();
  deleteDb(""String_Node_Str"");
}","/** 
 * Caches must be cleared. Session.reconnect only closes the DiskFile (which is associated with the cache) if there is one session
 * @throws Exception
 */
private void testCache(boolean reconnectClearCache) throws Exception {
  deleteDb(""String_Node_Str"");
  String urlShared=""String_Node_Str"" + baseDir + ""String_Node_Str"";
  Connection connShared1=DriverManager.getConnection(urlShared);
  Statement statement1=connShared1.createStatement();
  Connection connShared2=DriverManager.getConnection(urlShared);
  Statement statement2=connShared2.createStatement();
  statement1.execute(""String_Node_Str"");
  statement1.execute(""String_Node_Str"");
  ResultSet rs=statement1.executeQuery(""String_Node_Str"");
  rs.close();
  rs=statement2.executeQuery(""String_Node_Str"");
  rs.close();
  statement1.execute(""String_Node_Str"");
  Thread.sleep(500);
  rs=statement2.executeQuery(""String_Node_Str"");
  assertTrue(rs.next());
  assertEquals(2,rs.getInt(1));
  rs.close();
  connShared1.close();
  connShared2.close();
  deleteDb(""String_Node_Str"");
}",0.6405290505432215
16071,"/** 
 * Mark a page as used.
 * @param pageId the page id
 * @return the page id, or -1
 */
int allocate(int pageId) throws SQLException {
  int idx=pageId - getPos();
  if (idx >= 0 && !used.get(idx)) {
    store.logUndo(this,data);
    used.set(idx);
    store.update(this);
  }
  return pageId;
}","/** 
 * Mark a page as used.
 * @param pageId the page id
 * @return the page id, or -1
 */
int allocate(int pageId) throws SQLException {
  int idx=pageId - getPos();
  if (idx >= 0 && !used.get(idx)) {
    used.set(idx);
    store.logUndo(this,data);
    store.update(this);
  }
  return pageId;
}",0.9364548494983278
16072,"private void removeMetaIndex(Index index,Session session) throws SQLException {
  Row row=metaIndex.getRow(session,index.getId() + 1);
  metaIndex.remove(session,row);
}","private void removeMetaIndex(Index index,Session session) throws SQLException {
  int key=index.getId() + 1;
  Row row=metaIndex.getRow(session,key);
  if (row.getKey() != key) {
    Message.throwInternalError();
  }
  metaIndex.remove(session,row);
}",0.7142857142857143
16073,"/** 
 * Run recovery.
 */
private void recover() throws SQLException {
  trace.debug(""String_Node_Str"");
  recoveryRunning=true;
  log.recover(PageLog.RECOVERY_STAGE_UNDO);
  if (reservedPages != null) {
    for (    int r : reservedPages.keySet()) {
      if (trace.isDebugEnabled()) {
        trace.debug(""String_Node_Str"" + r);
      }
      allocatePage(r);
    }
  }
  log.recover(PageLog.RECOVERY_STAGE_ALLOCATE);
  openMetaIndex();
  readMetaData();
  log.recover(PageLog.RECOVERY_STAGE_REDO);
  boolean setReadOnly=false;
  if (!database.isReadOnly()) {
    if (log.getInDoubtTransactions().size() == 0) {
      log.recoverEnd();
      switchLog();
    }
 else {
      setReadOnly=true;
    }
  }
  PageDataIndex systemTable=(PageDataIndex)metaObjects.get(0);
  if (systemTable == null) {
    systemTableHeadPos=Index.EMPTY_HEAD;
  }
 else {
    systemTableHeadPos=systemTable.getHeadPos();
  }
  for (  Index openIndex : metaObjects.values()) {
    if (openIndex.getTable().isTemporary()) {
      openIndex.remove(systemSession);
      this.removeMetaIndex(openIndex,systemSession);
    }
    openIndex.close(systemSession);
  }
  recoveryRunning=false;
  reservedPages=null;
  writeBack();
  cache.clear();
  freeLists.clear();
  if (setReadOnly) {
    database.setReadOnly(true);
  }
  trace.debug(""String_Node_Str"");
}","/** 
 * Run recovery.
 */
private void recover() throws SQLException {
  trace.debug(""String_Node_Str"");
  recoveryRunning=true;
  log.recover(PageLog.RECOVERY_STAGE_UNDO);
  if (reservedPages != null) {
    for (    int r : reservedPages.keySet()) {
      if (trace.isDebugEnabled()) {
        trace.debug(""String_Node_Str"" + r);
      }
      allocatePage(r);
    }
  }
  log.recover(PageLog.RECOVERY_STAGE_ALLOCATE);
  openMetaIndex();
  readMetaData();
  log.recover(PageLog.RECOVERY_STAGE_REDO);
  boolean setReadOnly=false;
  if (!database.isReadOnly()) {
    if (log.getInDoubtTransactions().size() == 0) {
      log.recoverEnd();
      switchLog();
    }
 else {
      setReadOnly=true;
    }
  }
  PageDataIndex systemTable=(PageDataIndex)metaObjects.get(0);
  if (systemTable == null) {
    systemTableHeadPos=Index.EMPTY_HEAD;
  }
 else {
    systemTableHeadPos=systemTable.getHeadPos();
  }
  for (  Index openIndex : metaObjects.values()) {
    if (openIndex.getTable().isTemporary()) {
      openIndex.truncate(systemSession);
      openIndex.remove(systemSession);
      removeMetaIndex(openIndex,systemSession);
    }
    openIndex.close(systemSession);
  }
  recoveryRunning=false;
  reservedPages=null;
  writeBack();
  cache.clear();
  freeLists.clear();
  if (setReadOnly) {
    database.setReadOnly(true);
  }
  trace.debug(""String_Node_Str"");
}",0.9643916913946587
16074,"private void removeAllRows() throws SQLException {
  PageData root=getPage(rootPageId,0);
  root.freeChildren();
  root=PageDataLeaf.create(this,rootPageId,PageData.ROOT);
  store.removeRecord(rootPageId);
  store.update(root);
  rowCount=0;
  lastKey=0;
}","private void removeAllRows() throws SQLException {
  PageData root=getPage(rootPageId,0);
  store.logUndo(root,root.data);
  root.freeChildren();
  root=PageDataLeaf.create(this,rootPageId,PageData.ROOT);
  store.removeRecord(rootPageId);
  store.update(root);
  rowCount=0;
  lastKey=0;
}",0.9394495412844036
16075,"/** 
 * Add a page to the free list.
 * @param page the page
 * @param undo if the undo record must have been written
 */
public void free(int pageId,boolean undo) throws SQLException {
  if (trace.isDebugEnabled()) {
  }
synchronized (database) {
    cache.remove(pageId);
    if (SysProperties.CHECK && !recoveryRunning && undo) {
      log.addUndo(pageId,null);
    }
    freePage(pageId);
    if (recoveryRunning) {
      writePage(pageId,createData());
    }
  }
}","/** 
 * Add a page to the free list.
 * @param pageId the page id
 * @param undo if the undo record must have been written
 */
public void free(int pageId,boolean undo) throws SQLException {
  if (trace.isDebugEnabled()) {
  }
synchronized (database) {
    cache.remove(pageId);
    if (SysProperties.CHECK && !recoveryRunning && undo) {
      log.addUndo(pageId,null);
    }
    freePage(pageId);
    if (recoveryRunning) {
      writePage(pageId,createData());
    }
  }
}",0.975609756097561
16076,"/** 
 * Add an object to this schema.
 * @param obj the object to add
 */
public void add(SchemaObject obj){
  if (SysProperties.CHECK && obj.getSchema() != this) {
    Message.throwInternalError(""String_Node_Str"");
  }
  String name=obj.getName();
  HashMap<String,SchemaObject> map=getMap(obj.getType());
  if (SysProperties.CHECK && map.get(name) != null) {
    Message.throwInternalError(""String_Node_Str"");
  }
  map.put(name,obj);
  freeUniqueName(name);
}","/** 
 * Add an object to this schema.
 * @param obj the object to add
 */
public void add(SchemaObject obj){
  if (SysProperties.CHECK && obj.getSchema() != this) {
    Message.throwInternalError(""String_Node_Str"");
  }
  String name=obj.getName();
  HashMap<String,SchemaObject> map=getMap(obj.getType());
  if (SysProperties.CHECK && map.get(name) != null) {
    Message.throwInternalError(""String_Node_Str"" + name);
  }
  map.put(name,obj);
  freeUniqueName(name);
}",0.9924812030075189
16077,"private void test(String... args){
  for (int i=0; i < args.length; i++) {
    if (""String_Node_Str"".equals(args[i])) {
      url=args[++i];
    }
 else     if (""String_Node_Str"".equals(args[i])) {
      driver=args[++i];
    }
 else     if (""String_Node_Str"".equals(args[i])) {
      user=args[++i];
    }
 else     if (""String_Node_Str"".equals(args[i])) {
      password=args[++i];
    }
  }
  System.out.println(""String_Node_Str"" + driver + ""String_Node_Str""+ url+ ""String_Node_Str""+ user+ ""String_Node_Str""+ password);
  try {
    System.out.println(""String_Node_Str"");
    Random random=new Random();
    boolean wasRunning=false;
    for (int i=0; i < 3000; i++) {
      if (i > 1000 && connections.size() > 1 && tables.size() > 1) {
        System.out.println(""String_Node_Str"" + connections.size() + ""String_Node_Str""+ tables.size());
        wasRunning=true;
      }
      if (connections.size() < 1) {
        openConnection();
      }
      if (tables.size() < 1) {
        createTable(random);
      }
      int p=random.nextInt(100);
      if ((p-=2) <= 0) {
        if (connections.size() < 5) {
          openConnection();
        }
      }
 else       if ((p-=1) <= 0) {
        if (connections.size() > 1) {
          Connection conn=connections.remove(random.nextInt(connections.size()));
          if (random.nextBoolean()) {
            conn.close();
          }
        }
      }
 else       if ((p-=10) <= 0) {
        createTable(random);
      }
 else       if ((p-=20) <= 0) {
        if (tables.size() > 0) {
          Connection conn=connections.get(random.nextInt(connections.size()));
          Statement stat=conn.createStatement();
          String table=tables.get(random.nextInt(tables.size()));
          if (random.nextBoolean()) {
            stat.execute(""String_Node_Str"" + table + ""String_Node_Str"");
          }
 else           if (random.nextBoolean()) {
            stat.execute(""String_Node_Str"" + table + ""String_Node_Str"");
          }
 else {
            stat.execute(""String_Node_Str"" + table);
          }
        }
      }
 else       if ((p-=5) < 0) {
        if (tables.size() > 0) {
          Connection conn=connections.get(random.nextInt(connections.size()));
          Statement stat=conn.createStatement();
          String table=tables.get(random.nextInt(tables.size()));
          if (random.nextBoolean()) {
            stat.execute(""String_Node_Str"" + table);
          }
 else {
            stat.execute(""String_Node_Str"" + table);
            System.out.println(""String_Node_Str"" + table);
            tables.remove(table);
          }
        }
      }
 else       if ((p-=30) <= 0) {
        if (tables.size() > 0) {
          Connection conn=connections.get(random.nextInt(connections.size()));
          Statement stat=conn.createStatement();
          String table=tables.get(random.nextInt(tables.size()));
          stat.execute(""String_Node_Str"" + table + ""String_Node_Str"");
        }
      }
 else {
        if (tables.size() > 0) {
          Connection conn=connections.get(random.nextInt(connections.size()));
          Statement stat=conn.createStatement();
          String table=tables.get(random.nextInt(tables.size()));
          stat.execute(""String_Node_Str"" + table + ""String_Node_Str""+ table);
        }
      }
    }
    System.out.println(""String_Node_Str"" + wasRunning);
    System.out.println(""String_Node_Str"");
  }
 catch (  Throwable e) {
    System.out.println(""String_Node_Str"" + openCount + ""String_Node_Str""+ url+ ""String_Node_Str""+ e.toString());
    e.printStackTrace(System.out);
    System.out.println(""String_Node_Str"");
  }
}","private void test(String... args){
  for (int i=0; i < args.length; i++) {
    if (""String_Node_Str"".equals(args[i])) {
      url=args[++i];
    }
 else     if (""String_Node_Str"".equals(args[i])) {
      driver=args[++i];
    }
 else     if (""String_Node_Str"".equals(args[i])) {
      user=args[++i];
    }
 else     if (""String_Node_Str"".equals(args[i])) {
      password=args[++i];
    }
  }
  System.out.println(""String_Node_Str"" + driver + ""String_Node_Str""+ url+ ""String_Node_Str""+ user+ ""String_Node_Str""+ password);
  try {
    System.out.println(""String_Node_Str"");
    Random random=new Random();
    boolean wasRunning=false;
    for (int i=0; i < 200; i++) {
      if (connections.size() > 1 && tables.size() > 1) {
        System.out.println(""String_Node_Str"" + connections.size() + ""String_Node_Str""+ tables.size());
        wasRunning=true;
      }
      if (connections.size() < 1) {
        openConnection();
      }
      if (tables.size() < 1) {
        createTable(random);
      }
      int p=random.nextInt(100);
      if ((p-=2) <= 0) {
        if (connections.size() < 5) {
          openConnection();
        }
      }
 else       if ((p-=1) <= 0) {
        if (connections.size() > 1) {
          Connection conn=connections.remove(random.nextInt(connections.size()));
          if (random.nextBoolean()) {
            conn.close();
          }
        }
      }
 else       if ((p-=10) <= 0) {
        createTable(random);
      }
 else       if ((p-=20) <= 0) {
        if (tables.size() > 0) {
          Connection conn=connections.get(random.nextInt(connections.size()));
          Statement stat=conn.createStatement();
          String table=tables.get(random.nextInt(tables.size()));
          if (random.nextBoolean()) {
            stat.execute(""String_Node_Str"" + table + ""String_Node_Str"");
          }
 else           if (random.nextBoolean()) {
            stat.execute(""String_Node_Str"" + table + ""String_Node_Str"");
          }
 else {
            stat.execute(""String_Node_Str"" + table);
          }
        }
      }
 else       if ((p-=5) < 0) {
        if (tables.size() > 0) {
          Connection conn=connections.get(random.nextInt(connections.size()));
          Statement stat=conn.createStatement();
          String table=tables.get(random.nextInt(tables.size()));
          if (random.nextBoolean()) {
            stat.execute(""String_Node_Str"" + table);
          }
 else {
            stat.execute(""String_Node_Str"" + table);
            System.out.println(""String_Node_Str"" + table);
            tables.remove(table);
          }
        }
      }
 else       if ((p-=30) <= 0) {
        if (tables.size() > 0) {
          Connection conn=connections.get(random.nextInt(connections.size()));
          Statement stat=conn.createStatement();
          String table=tables.get(random.nextInt(tables.size()));
          stat.execute(""String_Node_Str"" + table + ""String_Node_Str"");
        }
      }
 else {
        if (tables.size() > 0) {
          Connection conn=connections.get(random.nextInt(connections.size()));
          Statement stat=conn.createStatement();
          String table=tables.get(random.nextInt(tables.size()));
          stat.execute(""String_Node_Str"" + table + ""String_Node_Str""+ table);
        }
      }
    }
    System.out.println(""String_Node_Str"" + wasRunning);
    System.out.println(""String_Node_Str"");
  }
 catch (  Throwable e) {
    System.out.println(""String_Node_Str"" + openCount + ""String_Node_Str""+ url+ ""String_Node_Str""+ e.toString());
    e.printStackTrace(System.out);
    System.out.println(""String_Node_Str"");
  }
}",0.9979273179494266
16078,"public void add(Session session,Row row) throws SQLException {
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"" + row.getKey());
  }
  SearchRow newRow=getSearchRow(row);
  while (true) {
    PageBtree root=getPage(rootPageId);
    int splitPoint=root.addRowTry(newRow);
    if (splitPoint == -1) {
      break;
    }
    if (trace.isDebugEnabled()) {
      trace.debug(""String_Node_Str"" + splitPoint);
    }
    SearchRow pivot=root.getRow(splitPoint - 1);
    store.logUndo(root,root.data);
    PageBtree page1=root;
    PageBtree page2=root.split(splitPoint);
    store.logUndo(page2,null);
    int rootPageId=root.getPos();
    int id=store.allocatePage();
    page1.setPageId(id);
    page1.setParentPageId(rootPageId);
    page2.setParentPageId(rootPageId);
    PageBtreeNode newRoot=PageBtreeNode.create(this,rootPageId,PageBtree.ROOT);
    store.logUndo(newRoot,null);
    newRoot.init(page1,pivot,page2);
    store.updateRecord(page1);
    store.updateRecord(page2);
    store.updateRecord(newRoot);
    root=newRoot;
  }
  rowCount++;
}","public void add(Session session,Row row) throws SQLException {
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"" + row.getKey());
  }
  SearchRow newRow=getSearchRow(row);
  while (true) {
    PageBtree root=getPage(rootPageId);
    int splitPoint=root.addRowTry(newRow);
    if (splitPoint == -1) {
      break;
    }
    if (trace.isDebugEnabled()) {
      trace.debug(""String_Node_Str"" + splitPoint);
    }
    SearchRow pivot=root.getRow(splitPoint - 1);
    store.logUndo(root,root.data);
    PageBtree page1=root;
    PageBtree page2=root.split(splitPoint);
    store.logUndo(page2,null);
    int rootPageId=root.getPos();
    int id=store.allocatePage();
    page1.setPageId(id);
    page1.setParentPageId(rootPageId);
    page2.setParentPageId(rootPageId);
    PageBtreeNode newRoot=PageBtreeNode.create(this,rootPageId,PageBtree.ROOT);
    store.logUndo(newRoot,null);
    newRoot.init(page1,pivot,page2);
    store.update(page1);
    store.update(page2);
    store.update(newRoot);
    root=newRoot;
  }
  rowCount++;
}",0.99146110056926
16079,"public PageBtreeIndex(TableData table,int id,String indexName,IndexColumn[] columns,IndexType indexType,int headPos,Session session) throws SQLException {
  initBaseIndex(table,id,indexName,columns,indexType);
  tableData=table;
  if (!database.isPersistent() || id < 0) {
    throw Message.throwInternalError(""String_Node_Str"" + indexName);
  }
  this.store=database.getPageStore();
  store.addIndex(this);
  if (headPos == Index.EMPTY_HEAD) {
    rootPageId=store.allocatePage();
    needRebuild=true;
    store.addMeta(this,session);
    PageBtreeLeaf root=PageBtreeLeaf.create(this,rootPageId,PageBtree.ROOT);
    store.logUndo(root,null);
    store.updateRecord(root);
  }
 else {
    rootPageId=store.getRootPageId(id);
    PageBtree root=getPage(rootPageId);
    rowCount=root.getRowCount();
    if (rowCount == 0 && store.isRecoveryRunning()) {
      needRebuild=true;
    }
  }
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"" + getName() + ""String_Node_Str""+ rowCount);
  }
}","public PageBtreeIndex(TableData table,int id,String indexName,IndexColumn[] columns,IndexType indexType,int headPos,Session session) throws SQLException {
  initBaseIndex(table,id,indexName,columns,indexType);
  tableData=table;
  if (!database.isPersistent() || id < 0) {
    throw Message.throwInternalError(""String_Node_Str"" + indexName);
  }
  this.store=database.getPageStore();
  store.addIndex(this);
  if (headPos == Index.EMPTY_HEAD) {
    rootPageId=store.allocatePage();
    needRebuild=true;
    store.addMeta(this,session);
    PageBtreeLeaf root=PageBtreeLeaf.create(this,rootPageId,PageBtree.ROOT);
    store.logUndo(root,null);
    store.update(root);
  }
 else {
    rootPageId=store.getRootPageId(id);
    PageBtree root=getPage(rootPageId);
    rowCount=root.getRowCount();
    if (rowCount == 0 && store.isRecoveryRunning()) {
      needRebuild=true;
    }
  }
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"" + getName() + ""String_Node_Str""+ rowCount);
  }
}",0.996996996996997
16080,"/** 
 * Read the given page.
 * @param id the page id
 * @return the page
 */
PageBtree getPage(int id) throws SQLException {
  PageBtree p=(PageBtree)store.getPage(id);
  if (p == null) {
    PageBtreeLeaf empty=PageBtreeLeaf.create(this,id,PageBtree.ROOT);
    store.logUndo(empty,null);
    store.updateRecord(empty);
    return empty;
  }
  return p;
}","/** 
 * Read the given page.
 * @param id the page id
 * @return the page
 */
PageBtree getPage(int id) throws SQLException {
  PageBtree p=(PageBtree)store.getPage(id);
  if (p == null) {
    PageBtreeLeaf empty=PageBtreeLeaf.create(this,id,PageBtree.ROOT);
    store.logUndo(empty,null);
    store.update(empty);
    return empty;
  }
  return p;
}",0.9915014164305948
16081,"public void remove(Session session) throws SQLException {
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"");
  }
  removeAllRows();
  store.freePage(rootPageId,false,null);
  store.removeMeta(this,session);
}","public void remove(Session session) throws SQLException {
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"");
  }
  removeAllRows();
  store.free(rootPageId,true);
  store.removeMeta(this,session);
}",0.8181818181818182
16082,"private void removeAllRows() throws SQLException {
  PageBtree root=getPage(rootPageId);
  store.logUndo(root,root.data);
  root.freeChildren();
  root=PageBtreeLeaf.create(this,rootPageId,PageBtree.ROOT);
  store.removeRecord(rootPageId);
  store.updateRecord(root);
  rowCount=0;
}","private void removeAllRows() throws SQLException {
  PageBtree root=getPage(rootPageId);
  store.logUndo(root,root.data);
  root.freeChildren();
  root=PageBtreeLeaf.create(this,rootPageId,PageBtree.ROOT);
  store.removeRecord(rootPageId);
  store.update(root);
  rowCount=0;
}",0.9892857142857144
16083,"SearchRow remove(SearchRow row) throws SQLException {
  int at=find(row,false,false,true);
  SearchRow delete=getRow(at);
  if (index.compareRows(row,delete) != 0 || delete.getKey() != row.getKey()) {
    throw Message.getSQLException(ErrorCode.ROW_NOT_FOUND_WHEN_DELETING_1,index.getSQL() + ""String_Node_Str"" + row);
  }
  if (entryCount == 1) {
    return row;
  }
  index.getPageStore().logUndo(this,data);
  removeRow(at);
  index.getPageStore().updateRecord(this);
  if (at == entryCount) {
    return getRow(at - 1);
  }
  return null;
}","SearchRow remove(SearchRow row) throws SQLException {
  int at=find(row,false,false,true);
  SearchRow delete=getRow(at);
  if (index.compareRows(row,delete) != 0 || delete.getKey() != row.getKey()) {
    throw Message.getSQLException(ErrorCode.ROW_NOT_FOUND_WHEN_DELETING_1,index.getSQL() + ""String_Node_Str"" + row);
  }
  index.getPageStore().logUndo(this,data);
  if (entryCount == 1) {
    return row;
  }
  removeRow(at);
  index.getPageStore().update(this);
  if (at == entryCount) {
    return getRow(at - 1);
  }
  return null;
}",0.8833333333333333
16084,"int addRowTry(SearchRow row) throws SQLException {
  int rowLength=index.getRowSize(data,row,onlyPosition);
  int pageSize=index.getPageStore().getPageSize();
  int last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
  if (last - rowLength < start + OFFSET_LENGTH) {
    if (entryCount > 1) {
      int x=find(row,false,true,true);
      if (entryCount < 5) {
        return entryCount / 2;
      }
      int third=entryCount / 3;
      return x < third ? third : x >= 2 * third ? 2 * third : x;
    }
    onlyPosition=true;
    int o=pageSize;
    for (int i=0; i < entryCount; i++) {
      o-=index.getRowSize(data,getRow(i),true);
      offsets[i]=o;
    }
    last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
    rowLength=index.getRowSize(data,row,true);
    if (SysProperties.CHECK && last - rowLength < start + OFFSET_LENGTH) {
      throw Message.throwInternalError();
    }
  }
  index.getPageStore().logUndo(this,data);
  written=false;
  int offset=last - rowLength;
  int[] newOffsets=new int[entryCount + 1];
  SearchRow[] newRows=new SearchRow[entryCount + 1];
  int x;
  if (entryCount == 0) {
    x=0;
  }
 else {
    readAllRows();
    x=find(row,false,true,true);
    System.arraycopy(offsets,0,newOffsets,0,x);
    System.arraycopy(rows,0,newRows,0,x);
    if (x < entryCount) {
      for (int j=x; j < entryCount; j++) {
        newOffsets[j + 1]=offsets[j] - rowLength;
      }
      offset=(x == 0 ? pageSize : offsets[x - 1]) - rowLength;
      System.arraycopy(rows,x,newRows,x + 1,entryCount - x);
    }
  }
  entryCount++;
  start+=OFFSET_LENGTH;
  newOffsets[x]=offset;
  newRows[x]=row;
  offsets=newOffsets;
  rows=newRows;
  index.getPageStore().updateRecord(this);
  return -1;
}","int addRowTry(SearchRow row) throws SQLException {
  int rowLength=index.getRowSize(data,row,onlyPosition);
  int pageSize=index.getPageStore().getPageSize();
  int last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
  if (last - rowLength < start + OFFSET_LENGTH) {
    if (entryCount > 1) {
      int x=find(row,false,true,true);
      if (entryCount < 5) {
        return entryCount / 2;
      }
      int third=entryCount / 3;
      return x < third ? third : x >= 2 * third ? 2 * third : x;
    }
    onlyPosition=true;
    int o=pageSize;
    for (int i=0; i < entryCount; i++) {
      o-=index.getRowSize(data,getRow(i),true);
      offsets[i]=o;
    }
    last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
    rowLength=index.getRowSize(data,row,true);
    if (SysProperties.CHECK && last - rowLength < start + OFFSET_LENGTH) {
      throw Message.throwInternalError();
    }
  }
  index.getPageStore().logUndo(this,data);
  written=false;
  int offset=last - rowLength;
  int[] newOffsets=new int[entryCount + 1];
  SearchRow[] newRows=new SearchRow[entryCount + 1];
  int x;
  if (entryCount == 0) {
    x=0;
  }
 else {
    readAllRows();
    x=find(row,false,true,true);
    System.arraycopy(offsets,0,newOffsets,0,x);
    System.arraycopy(rows,0,newRows,0,x);
    if (x < entryCount) {
      for (int j=x; j < entryCount; j++) {
        newOffsets[j + 1]=offsets[j] - rowLength;
      }
      offset=(x == 0 ? pageSize : offsets[x - 1]) - rowLength;
      System.arraycopy(rows,x,newRows,x + 1,entryCount - x);
    }
  }
  entryCount++;
  start+=OFFSET_LENGTH;
  newOffsets[x]=offset;
  newRows[x]=row;
  offsets=newOffsets;
  rows=newRows;
  index.getPageStore().update(this);
  return -1;
}",0.9982598607888632
16085,"public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  readAllRows();
  PageBtreeLeaf p2=PageBtreeLeaf.create(index,newPos,parentPageId);
  store.logUndo(this,data);
  store.logUndo(p2,null);
  p2.rows=rows;
  p2.entryCount=entryCount;
  p2.offsets=offsets;
  p2.onlyPosition=onlyPosition;
  p2.parentPageId=parentPageId;
  p2.start=start;
  store.updateRecord(p2);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageBtreeNode p=(PageBtreeNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
  store.freePage(getPos(),true,data);
}","public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  readAllRows();
  PageBtreeLeaf p2=PageBtreeLeaf.create(index,newPos,parentPageId);
  store.logUndo(this,data);
  store.logUndo(p2,null);
  p2.rows=rows;
  p2.entryCount=entryCount;
  p2.offsets=offsets;
  p2.onlyPosition=onlyPosition;
  p2.parentPageId=parentPageId;
  p2.start=start;
  store.update(p2);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageBtreeNode p=(PageBtreeNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
  store.free(getPos(),true);
}",0.9882537196554424
16086,"SearchRow remove(SearchRow row) throws SQLException {
  int at=find(row,false,false,true);
  PageBtree page=index.getPage(childPageIds[at]);
  SearchRow last=page.remove(row);
  index.getPageStore().logUndo(this,data);
  updateRowCount(-1);
  written=false;
  if (last == null) {
    return null;
  }
 else   if (last == row) {
    index.getPageStore().freePage(page.getPos(),true,page.data);
    if (entryCount < 1) {
      return row;
    }
    if (at == entryCount) {
      last=getRow(at - 1);
    }
 else {
      last=null;
    }
    removeChild(at);
    index.getPageStore().updateRecord(this);
    return last;
  }
  if (at == entryCount) {
    return last;
  }
  int child=childPageIds[at];
  removeChild(at);
  addChild(at,child,last);
  int temp=childPageIds[at];
  childPageIds[at]=childPageIds[at + 1];
  childPageIds[at + 1]=temp;
  index.getPageStore().updateRecord(this);
  return null;
}","SearchRow remove(SearchRow row) throws SQLException {
  int at=find(row,false,false,true);
  PageBtree page=index.getPage(childPageIds[at]);
  SearchRow last=page.remove(row);
  index.getPageStore().logUndo(this,data);
  updateRowCount(-1);
  written=false;
  if (last == null) {
    return null;
  }
 else   if (last == row) {
    index.getPageStore().free(page.getPos(),true);
    if (entryCount < 1) {
      return row;
    }
    if (at == entryCount) {
      last=getRow(at - 1);
    }
 else {
      last=null;
    }
    removeChild(at);
    index.getPageStore().update(this);
    return last;
  }
  if (at == entryCount) {
    return last;
  }
  int child=childPageIds[at];
  removeChild(at);
  addChild(at,child,last);
  int temp=childPageIds[at];
  childPageIds[at]=childPageIds[at + 1];
  childPageIds[at + 1]=temp;
  index.getPageStore().update(this);
  return null;
}",0.9853932584269663
16087,"int addRowTry(SearchRow row) throws SQLException {
  while (true) {
    int x=find(row,false,true,true);
    PageBtree page=index.getPage(childPageIds[x]);
    int splitPoint=page.addRowTry(row);
    if (splitPoint == -1) {
      break;
    }
    SearchRow pivot=page.getRow(splitPoint - 1);
    index.getPageStore().logUndo(this,data);
    int splitPoint2=addChildTry(pivot);
    if (splitPoint2 != -1) {
      return splitPoint2;
    }
    PageBtree page2=page.split(splitPoint);
    readAllRows();
    addChild(x,page2.getPos(),pivot);
    index.getPageStore().updateRecord(page);
    index.getPageStore().updateRecord(page2);
    index.getPageStore().updateRecord(this);
  }
  updateRowCount(1);
  written=false;
  return -1;
}","int addRowTry(SearchRow row) throws SQLException {
  while (true) {
    int x=find(row,false,true,true);
    PageBtree page=index.getPage(childPageIds[x]);
    int splitPoint=page.addRowTry(row);
    if (splitPoint == -1) {
      break;
    }
    SearchRow pivot=page.getRow(splitPoint - 1);
    index.getPageStore().logUndo(this,data);
    int splitPoint2=addChildTry(pivot);
    if (splitPoint2 != -1) {
      return splitPoint2;
    }
    PageBtree page2=page.split(splitPoint);
    readAllRows();
    addChild(x,page2.getPos(),pivot);
    index.getPageStore().update(page);
    index.getPageStore().update(page2);
    index.getPageStore().update(this);
  }
  updateRowCount(1);
  written=false;
  return -1;
}",0.9875346260387812
16088,"/** 
 * One of the children has moved to a new page.
 * @param oldPos the old position
 * @param newPos the new position
 */
void moveChild(int oldPos,int newPos) throws SQLException {
  for (int i=0; i < childPageIds.length; i++) {
    if (childPageIds[i] == oldPos) {
      index.getPageStore().logUndo(this,data);
      written=false;
      childPageIds[i]=newPos;
      index.getPageStore().updateRecord(this);
      return;
    }
  }
  throw Message.throwInternalError();
}","/** 
 * One of the children has moved to a new page.
 * @param oldPos the old position
 * @param newPos the new position
 */
void moveChild(int oldPos,int newPos) throws SQLException {
  for (int i=0; i < childPageIds.length; i++) {
    if (childPageIds[i] == oldPos) {
      index.getPageStore().logUndo(this,data);
      written=false;
      childPageIds[i]=newPos;
      index.getPageStore().update(this);
      return;
    }
  }
  throw Message.throwInternalError();
}",0.9936842105263158
16089,"void freeChildren() throws SQLException {
  for (int i=0; i <= entryCount; i++) {
    int childPageId=childPageIds[i];
    PageBtree child=index.getPage(childPageId);
    index.getPageStore().freePage(childPageId,false,null);
    child.freeChildren();
  }
}","void freeChildren() throws SQLException {
  for (int i=0; i <= entryCount; i++) {
    int childPageId=childPageIds[i];
    PageBtree child=index.getPage(childPageId);
    index.getPageStore().free(childPageId,false);
    child.freeChildren();
  }
}",0.9821782178217822
16090,"protected void remapChildren() throws SQLException {
  for (  int child : childPageIds) {
    PageBtree p=index.getPage(child);
    p.setParentPageId(getPos());
    index.getPageStore().updateRecord(p);
  }
}","protected void remapChildren() throws SQLException {
  for (  int child : childPageIds) {
    PageBtree p=index.getPage(child);
    p.setParentPageId(getPos());
    index.getPageStore().update(p);
  }
}",0.9853658536585366
16091,"public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  store.logUndo(this,data);
  PageBtreeNode p2=PageBtreeNode.create(index,newPos,parentPageId);
  readAllRows();
  p2.childPageIds=childPageIds;
  p2.rows=rows;
  p2.entryCount=entryCount;
  p2.offsets=offsets;
  p2.onlyPosition=onlyPosition;
  p2.parentPageId=parentPageId;
  p2.start=start;
  store.updateRecord(p2);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageBtreeNode p=(PageBtreeNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
  for (int i=0; i < childPageIds.length; i++) {
    PageBtree p=(PageBtree)store.getPage(childPageIds[i]);
    p.setParentPageId(newPos);
    store.updateRecord(p);
  }
  store.freePage(getPos(),true,data);
}","public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  store.logUndo(this,data);
  PageBtreeNode p2=PageBtreeNode.create(index,newPos,parentPageId);
  readAllRows();
  p2.childPageIds=childPageIds;
  p2.rows=rows;
  p2.entryCount=entryCount;
  p2.offsets=offsets;
  p2.onlyPosition=onlyPosition;
  p2.parentPageId=parentPageId;
  p2.start=start;
  store.update(p2);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageBtreeNode p=(PageBtreeNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
  for (int i=0; i < childPageIds.length; i++) {
    PageBtree p=(PageBtree)store.getPage(childPageIds[i]);
    p.setParentPageId(newPos);
    store.update(p);
  }
  store.free(getPos(),true);
}",0.987045033929673
16092,"/** 
 * Read the given page.
 * @param id the page id
 * @param parent the parent, or -1 if unknown
 * @return the page
 */
PageData getPage(int id,int parent) throws SQLException {
  PageData p=(PageData)store.getPage(id);
  if (p == null) {
    PageDataLeaf empty=PageDataLeaf.create(this,id,parent);
    store.logUndo(empty,null);
    store.updateRecord(empty);
    return empty;
  }
  if (p.index.rootPageId != rootPageId) {
    throw Message.throwInternalError(""String_Node_Str"" + p.index.getName() + ""String_Node_Str""+ p.index.rootPageId+ ""String_Node_Str""+ getName()+ ""String_Node_Str""+ rootPageId);
  }
  if (parent != -1) {
    if (p.getParentPageId() != parent) {
      throw Message.throwInternalError(p + ""String_Node_Str"" + p.getParentPageId()+ ""String_Node_Str""+ parent);
    }
  }
  return p;
}","/** 
 * Read the given page.
 * @param id the page id
 * @param parent the parent, or -1 if unknown
 * @return the page
 */
PageData getPage(int id,int parent) throws SQLException {
  PageData p=(PageData)store.getPage(id);
  if (p == null) {
    PageDataLeaf empty=PageDataLeaf.create(this,id,parent);
    store.logUndo(empty,null);
    store.update(empty);
    return empty;
  }
  if (p.index.rootPageId != rootPageId) {
    throw Message.throwInternalError(""String_Node_Str"" + p.index.getName() + ""String_Node_Str""+ p.index.rootPageId+ ""String_Node_Str""+ getName()+ ""String_Node_Str""+ rootPageId);
  }
  if (parent != -1) {
    if (p.getParentPageId() != parent) {
      throw Message.throwInternalError(p + ""String_Node_Str"" + p.getParentPageId()+ ""String_Node_Str""+ parent);
    }
  }
  return p;
}",0.9962779156327544
16093,"public void remove(Session session) throws SQLException {
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"");
  }
  removeAllRows();
  store.freePage(rootPageId,false,null);
  store.removeMeta(this,session);
}","public void remove(Session session) throws SQLException {
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"");
  }
  removeAllRows();
  store.free(rootPageId,true);
  store.removeMeta(this,session);
}",0.8181818181818182
16094,"private void removeAllRows() throws SQLException {
  PageData root=getPage(rootPageId,0);
  root.freeChildren();
  root=PageDataLeaf.create(this,rootPageId,PageData.ROOT);
  store.removeRecord(rootPageId);
  store.updateRecord(root);
  rowCount=0;
  lastKey=0;
}","private void removeAllRows() throws SQLException {
  PageData root=getPage(rootPageId,0);
  root.freeChildren();
  root=PageDataLeaf.create(this,rootPageId,PageData.ROOT);
  store.removeRecord(rootPageId);
  store.update(root);
  rowCount=0;
  lastKey=0;
}",0.9884169884169884
16095,"public PageDataIndex(TableData table,int id,IndexColumn[] columns,IndexType indexType,int headPos,Session session) throws SQLException {
  initBaseIndex(table,id,table.getName() + ""String_Node_Str"",columns,indexType);
  if (database.isMultiVersion()) {
    sessionRowCount=New.hashMap();
    isMultiVersion=true;
  }
  tableData=table;
  this.store=database.getPageStore();
  store.addIndex(this);
  if (!database.isPersistent()) {
    throw Message.throwInternalError(table.getName());
  }
  if (headPos == Index.EMPTY_HEAD) {
    rootPageId=store.allocatePage();
    store.addMeta(this,session);
    PageDataLeaf root=PageDataLeaf.create(this,rootPageId,PageData.ROOT);
    store.updateRecord(root);
  }
 else {
    rootPageId=store.getRootPageId(id);
    PageData root=getPage(rootPageId,0);
    lastKey=root.getLastKey();
    rowCount=root.getRowCount();
  }
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"" + getName() + ""String_Node_Str""+ rowCount);
  }
  table.setRowCount(rowCount);
  fastDuplicateKeyException=super.getDuplicateKeyException();
  memorySizePerPage=store.getPageSize();
  int estimatedRowsPerPage=store.getPageSize() / ((1 + columns.length) * 8);
  memorySizePerPage+=estimatedRowsPerPage * 64;
}","public PageDataIndex(TableData table,int id,IndexColumn[] columns,IndexType indexType,int headPos,Session session) throws SQLException {
  initBaseIndex(table,id,table.getName() + ""String_Node_Str"",columns,indexType);
  if (database.isMultiVersion()) {
    sessionRowCount=New.hashMap();
    isMultiVersion=true;
  }
  tableData=table;
  this.store=database.getPageStore();
  store.addIndex(this);
  if (!database.isPersistent()) {
    throw Message.throwInternalError(table.getName());
  }
  if (headPos == Index.EMPTY_HEAD) {
    rootPageId=store.allocatePage();
    store.addMeta(this,session);
    PageDataLeaf root=PageDataLeaf.create(this,rootPageId,PageData.ROOT);
    store.update(root);
  }
 else {
    rootPageId=store.getRootPageId(id);
    PageData root=getPage(rootPageId,0);
    lastKey=root.getLastKey();
    rowCount=root.getRowCount();
  }
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"" + getName() + ""String_Node_Str""+ rowCount);
  }
  table.setRowCount(rowCount);
  fastDuplicateKeyException=super.getDuplicateKeyException();
  memorySizePerPage=store.getPageSize();
  int estimatedRowsPerPage=store.getPageSize() / ((1 + columns.length) * 8);
  memorySizePerPage+=estimatedRowsPerPage * 64;
}",0.9975688816855752
16096,"private void addTry(Session session,Row row) throws SQLException {
  while (true) {
    PageData root=getPage(rootPageId,0);
    int splitPoint=root.addRowTry(row);
    if (splitPoint == -1) {
      break;
    }
    if (trace.isDebugEnabled()) {
      trace.debug(""String_Node_Str"" + splitPoint);
    }
    long pivot=splitPoint == 0 ? row.getKey() : root.getKey(splitPoint - 1);
    PageData page1=root;
    PageData page2=root.split(splitPoint);
    int rootPageId=root.getPos();
    int id=store.allocatePage();
    page1.setPageId(id);
    page1.setParentPageId(rootPageId);
    page2.setParentPageId(rootPageId);
    PageDataNode newRoot=PageDataNode.create(this,rootPageId,PageData.ROOT);
    newRoot.init(page1,pivot,page2);
    store.updateRecord(page1);
    store.updateRecord(page2);
    store.updateRecord(newRoot);
    root=newRoot;
  }
  row.setDeleted(false);
  if (database.isMultiVersion()) {
    if (delta == null) {
      delta=New.hashSet();
    }
    boolean wasDeleted=delta.remove(row);
    if (!wasDeleted) {
      delta.add(row);
    }
    incrementRowCount(session.getId(),1);
  }
  invalidateRowCount();
  rowCount++;
  store.logAddOrRemoveRow(session,tableData.getId(),row,true);
}","private void addTry(Session session,Row row) throws SQLException {
  while (true) {
    PageData root=getPage(rootPageId,0);
    int splitPoint=root.addRowTry(row);
    if (splitPoint == -1) {
      break;
    }
    if (trace.isDebugEnabled()) {
      trace.debug(""String_Node_Str"" + splitPoint);
    }
    long pivot=splitPoint == 0 ? row.getKey() : root.getKey(splitPoint - 1);
    PageData page1=root;
    PageData page2=root.split(splitPoint);
    int rootPageId=root.getPos();
    int id=store.allocatePage();
    page1.setPageId(id);
    page1.setParentPageId(rootPageId);
    page2.setParentPageId(rootPageId);
    PageDataNode newRoot=PageDataNode.create(this,rootPageId,PageData.ROOT);
    newRoot.init(page1,pivot,page2);
    store.update(page1);
    store.update(page2);
    store.update(newRoot);
    root=newRoot;
  }
  row.setDeleted(false);
  if (database.isMultiVersion()) {
    if (delta == null) {
      delta=New.hashSet();
    }
    boolean wasDeleted=delta.remove(row);
    if (!wasDeleted) {
      delta.add(row);
    }
    incrementRowCount(session.getId(),1);
  }
  invalidateRowCount();
  rowCount++;
  store.logAddOrRemoveRow(session,tableData.getId(),row,true);
}",0.9924937447873228
16097,"boolean remove(long key) throws SQLException {
  int i=find(key);
  if (keys[i] != key) {
    throw Message.getSQLException(ErrorCode.ROW_NOT_FOUND_WHEN_DELETING_1,index.getSQL() + ""String_Node_Str"" + key);
  }
  index.getPageStore().logUndo(this,data);
  if (entryCount == 1) {
    freeChildren();
    return true;
  }
  removeRow(i);
  index.getPageStore().updateRecord(this);
  return false;
}","boolean remove(long key) throws SQLException {
  int i=find(key);
  if (keys[i] != key) {
    throw Message.getSQLException(ErrorCode.ROW_NOT_FOUND_WHEN_DELETING_1,index.getSQL() + ""String_Node_Str"" + key);
  }
  index.getPageStore().logUndo(this,data);
  if (entryCount == 1) {
    freeChildren();
    return true;
  }
  removeRow(i);
  index.getPageStore().update(this);
  return false;
}",0.9923664122137404
16098,"int addRowTry(Row row) throws SQLException {
  index.getPageStore().logUndo(this,data);
  int rowLength=getRowLength(row);
  int pageSize=index.getPageStore().getPageSize();
  int last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
  int keyOffsetPairLen=2 + data.getVarLongLen(row.getKey());
  if (entryCount > 0 && last - rowLength < start + keyOffsetPairLen) {
    int x=find(row.getKey());
    if (entryCount > 1) {
      if (entryCount < 5) {
        return entryCount / 2;
      }
      int third=entryCount / 3;
      return x < third ? third : x >= 2 * third ? 2 * third : x;
    }
    return x;
  }
  index.getPageStore().logUndo(this,data);
  int offset=last - rowLength;
  int[] newOffsets=new int[entryCount + 1];
  long[] newKeys=new long[entryCount + 1];
  Row[] newRows=new Row[entryCount + 1];
  int x;
  if (entryCount == 0) {
    x=0;
  }
 else {
    readAllRows();
    x=find(row.getKey());
    if (x < keys.length && keys[x] == row.getKey()) {
      throw index.getDuplicateKeyException();
    }
    System.arraycopy(offsets,0,newOffsets,0,x);
    System.arraycopy(keys,0,newKeys,0,x);
    System.arraycopy(rows,0,newRows,0,x);
    if (x < entryCount) {
      for (int j=x; j < entryCount; j++) {
        newOffsets[j + 1]=offsets[j] - rowLength;
      }
      System.arraycopy(keys,x,newKeys,x + 1,entryCount - x);
      System.arraycopy(rows,x,newRows,x + 1,entryCount - x);
    }
  }
  written=false;
  last=x == 0 ? pageSize : offsets[x - 1];
  offset=last - rowLength;
  entryCount++;
  start+=keyOffsetPairLen;
  newOffsets[x]=offset;
  newKeys[x]=row.getKey();
  newRows[x]=row;
  memorySize+=row.getMemorySize();
  offsets=newOffsets;
  keys=newKeys;
  rows=newRows;
  index.getPageStore().updateRecord(this);
  if (offset < start) {
    if (entryCount > 1) {
      Message.throwInternalError();
    }
    start+=4;
    int remaining=rowLength - (pageSize - start);
    offset=start;
    offsets[x]=offset;
    int previous=getPos();
    int dataOffset=pageSize;
    int page=index.getPageStore().allocatePage();
    firstOverflowPageId=page;
    this.overflowRowSize=pageSize + rowLength;
    write();
    rowRef=new SoftReference<Row>(rows[0]);
    rows[0]=null;
    Data all=index.getPageStore().createData();
    all.checkCapacity(data.length());
    all.write(data.getBytes(),0,data.length());
    data.truncate(index.getPageStore().getPageSize());
    do {
      int type, size, next;
      if (remaining <= pageSize - PageDataOverflow.START_LAST) {
        type=Page.TYPE_DATA_OVERFLOW | Page.FLAG_LAST;
        size=remaining;
        next=0;
      }
 else {
        type=Page.TYPE_DATA_OVERFLOW;
        size=pageSize - PageDataOverflow.START_MORE;
        next=index.getPageStore().allocatePage();
      }
      PageDataOverflow overflow=PageDataOverflow.create(index.getPageStore(),page,type,previous,next,all,dataOffset,size);
      index.getPageStore().updateRecord(overflow);
      dataOffset+=size;
      remaining-=size;
      previous=page;
      page=next;
    }
 while (remaining > 0);
  }
  return -1;
}","int addRowTry(Row row) throws SQLException {
  index.getPageStore().logUndo(this,data);
  int rowLength=getRowLength(row);
  int pageSize=index.getPageStore().getPageSize();
  int last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
  int keyOffsetPairLen=2 + data.getVarLongLen(row.getKey());
  if (entryCount > 0 && last - rowLength < start + keyOffsetPairLen) {
    int x=find(row.getKey());
    if (entryCount > 1) {
      if (entryCount < 5) {
        return entryCount / 2;
      }
      int third=entryCount / 3;
      return x < third ? third : x >= 2 * third ? 2 * third : x;
    }
    return x;
  }
  index.getPageStore().logUndo(this,data);
  int offset=last - rowLength;
  int[] newOffsets=new int[entryCount + 1];
  long[] newKeys=new long[entryCount + 1];
  Row[] newRows=new Row[entryCount + 1];
  int x;
  if (entryCount == 0) {
    x=0;
  }
 else {
    readAllRows();
    x=find(row.getKey());
    if (x < keys.length && keys[x] == row.getKey()) {
      throw index.getDuplicateKeyException();
    }
    System.arraycopy(offsets,0,newOffsets,0,x);
    System.arraycopy(keys,0,newKeys,0,x);
    System.arraycopy(rows,0,newRows,0,x);
    if (x < entryCount) {
      for (int j=x; j < entryCount; j++) {
        newOffsets[j + 1]=offsets[j] - rowLength;
      }
      System.arraycopy(keys,x,newKeys,x + 1,entryCount - x);
      System.arraycopy(rows,x,newRows,x + 1,entryCount - x);
    }
  }
  written=false;
  last=x == 0 ? pageSize : offsets[x - 1];
  offset=last - rowLength;
  entryCount++;
  start+=keyOffsetPairLen;
  newOffsets[x]=offset;
  newKeys[x]=row.getKey();
  newRows[x]=row;
  memorySize+=row.getMemorySize();
  offsets=newOffsets;
  keys=newKeys;
  rows=newRows;
  index.getPageStore().update(this);
  if (offset < start) {
    if (entryCount > 1) {
      Message.throwInternalError();
    }
    start+=4;
    int remaining=rowLength - (pageSize - start);
    offset=start;
    offsets[x]=offset;
    int previous=getPos();
    int dataOffset=pageSize;
    int page=index.getPageStore().allocatePage();
    firstOverflowPageId=page;
    this.overflowRowSize=pageSize + rowLength;
    write();
    rowRef=new SoftReference<Row>(rows[0]);
    rows[0]=null;
    Data all=index.getPageStore().createData();
    all.checkCapacity(data.length());
    all.write(data.getBytes(),0,data.length());
    data.truncate(index.getPageStore().getPageSize());
    do {
      int type, size, next;
      if (remaining <= pageSize - PageDataOverflow.START_LAST) {
        type=Page.TYPE_DATA_OVERFLOW | Page.FLAG_LAST;
        size=remaining;
        next=0;
      }
 else {
        type=Page.TYPE_DATA_OVERFLOW;
        size=pageSize - PageDataOverflow.START_MORE;
        next=index.getPageStore().allocatePage();
      }
      PageDataOverflow overflow=PageDataOverflow.create(index.getPageStore(),page,type,previous,next,all,dataOffset,size);
      index.getPageStore().update(overflow);
      dataOffset+=size;
      remaining-=size;
      previous=page;
      page=next;
    }
 while (remaining > 0);
  }
  return -1;
}",0.9980340760157274
16099,"void freeChildren() throws SQLException {
  if (firstOverflowPageId != 0) {
    PageStore store=index.getPageStore();
    int next=firstOverflowPageId;
    do {
      PageDataOverflow page=index.getPageOverflow(next);
      store.freePage(next,false,null);
      next=page.getNextOverflow();
    }
 while (next != 0);
  }
}","void freeChildren() throws SQLException {
  if (firstOverflowPageId != 0) {
    PageStore store=index.getPageStore();
    int next=firstOverflowPageId;
    do {
      PageDataOverflow page=index.getPageOverflow(next);
      store.free(next,false);
      next=page.getNextOverflow();
    }
 while (next != 0);
  }
}",0.9858712715855572
16100,"void setOverflow(int overflow) throws SQLException {
  index.getPageStore().logUndo(this,data);
  firstOverflowPageId=overflow;
  if (written) {
    writeHead();
    data.writeInt(firstOverflowPageId);
  }
  index.getPageStore().updateRecord(this);
}","void setOverflow(int overflow) throws SQLException {
  index.getPageStore().logUndo(this,data);
  firstOverflowPageId=overflow;
  if (written) {
    writeHead();
    data.writeInt(firstOverflowPageId);
  }
  index.getPageStore().update(this);
}",0.9878542510121456
16101,"protected void remapChildren() throws SQLException {
  if (firstOverflowPageId == 0) {
    return;
  }
  PageDataOverflow overflow=index.getPageOverflow(firstOverflowPageId);
  overflow.setParentPageId(getPos());
  index.getPageStore().updateRecord(overflow);
}","protected void remapChildren() throws SQLException {
  if (firstOverflowPageId == 0) {
    return;
  }
  PageDataOverflow overflow=index.getPageOverflow(firstOverflowPageId);
  overflow.setParentPageId(getPos());
  index.getPageStore().update(overflow);
}",0.9883720930232558
16102,"public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  store.logUndo(this,data);
  PageDataLeaf p2=PageDataLeaf.create(index,newPos,parentPageId);
  readAllRows();
  p2.keys=keys;
  p2.overflowRowSize=overflowRowSize;
  p2.firstOverflowPageId=firstOverflowPageId;
  p2.rowRef=rowRef;
  p2.rows=rows;
  if (firstOverflowPageId != 0) {
    p2.rows[0]=getRowAt(0);
  }
  p2.entryCount=entryCount;
  p2.offsets=offsets;
  p2.parentPageId=parentPageId;
  p2.start=start;
  p2.remapChildren();
  p2.write();
  p2.data.truncate(index.getPageStore().getPageSize());
  store.updateRecord(p2);
  store.freePage(getPos(),true,data);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageDataNode p=(PageDataNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
}","public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  store.logUndo(this,data);
  PageDataLeaf p2=PageDataLeaf.create(index,newPos,parentPageId);
  readAllRows();
  p2.keys=keys;
  p2.overflowRowSize=overflowRowSize;
  p2.firstOverflowPageId=firstOverflowPageId;
  p2.rowRef=rowRef;
  p2.rows=rows;
  if (firstOverflowPageId != 0) {
    p2.rows[0]=getRowAt(0);
  }
  p2.entryCount=entryCount;
  p2.offsets=offsets;
  p2.parentPageId=parentPageId;
  p2.start=start;
  p2.remapChildren();
  p2.write();
  p2.data.truncate(index.getPageStore().getPageSize());
  store.update(p2);
  store.free(getPos(),true);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageDataNode p=(PageDataNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
}",0.9713282621416032
16103,"boolean remove(long key) throws SQLException {
  int at=find(key);
  PageData page=index.getPage(childPageIds[at],getPos());
  boolean empty=page.remove(key);
  updateRowCount(-1);
  if (!empty) {
    return false;
  }
  index.getPageStore().freePage(page.getPos(),true,page.data);
  if (entryCount < 1) {
    return true;
  }
  removeChild(at);
  index.getPageStore().updateRecord(this);
  return false;
}","boolean remove(long key) throws SQLException {
  int at=find(key);
  PageData page=index.getPage(childPageIds[at],getPos());
  boolean empty=page.remove(key);
  index.getPageStore().logUndo(this,data);
  updateRowCount(-1);
  if (!empty) {
    return false;
  }
  index.getPageStore().free(page.getPos(),true);
  if (entryCount < 1) {
    return true;
  }
  removeChild(at);
  index.getPageStore().update(this);
  return false;
}",0.9245508982035928
16104,"int addRowTry(Row row) throws SQLException {
  index.getPageStore().logUndo(this,data);
  int keyOffsetPairLen=4 + data.getVarLongLen(row.getKey());
  while (true) {
    int x=find(row.getKey());
    PageData page=index.getPage(childPageIds[x],getPos());
    int splitPoint=page.addRowTry(row);
    if (splitPoint == -1) {
      break;
    }
    if (length + keyOffsetPairLen > index.getPageStore().getPageSize()) {
      return entryCount / 2;
    }
    long pivot=splitPoint == 0 ? row.getKey() : page.getKey(splitPoint - 1);
    PageData page2=page.split(splitPoint);
    index.getPageStore().updateRecord(page);
    index.getPageStore().updateRecord(page2);
    addChild(x,page2.getPos(),pivot);
    index.getPageStore().updateRecord(this);
  }
  updateRowCount(1);
  return -1;
}","int addRowTry(Row row) throws SQLException {
  index.getPageStore().logUndo(this,data);
  int keyOffsetPairLen=4 + data.getVarLongLen(row.getKey());
  while (true) {
    int x=find(row.getKey());
    PageData page=index.getPage(childPageIds[x],getPos());
    int splitPoint=page.addRowTry(row);
    if (splitPoint == -1) {
      break;
    }
    if (length + keyOffsetPairLen > index.getPageStore().getPageSize()) {
      return entryCount / 2;
    }
    long pivot=splitPoint == 0 ? row.getKey() : page.getKey(splitPoint - 1);
    PageData page2=page.split(splitPoint);
    index.getPageStore().update(page);
    index.getPageStore().update(page2);
    addChild(x,page2.getPos(),pivot);
    index.getPageStore().update(this);
  }
  updateRowCount(1);
  return -1;
}",0.9883870967741936
16105,"private void updateRowCount(int offset) throws SQLException {
  if (rowCount != UNKNOWN_ROWCOUNT) {
    rowCount+=offset;
  }
  if (rowCountStored != UNKNOWN_ROWCOUNT) {
    rowCountStored=UNKNOWN_ROWCOUNT;
    index.getPageStore().logUndo(this,data);
    if (written) {
      writeHead();
    }
    index.getPageStore().updateRecord(this);
  }
}","private void updateRowCount(int offset) throws SQLException {
  if (rowCount != UNKNOWN_ROWCOUNT) {
    rowCount+=offset;
  }
  if (rowCountStored != UNKNOWN_ROWCOUNT) {
    rowCountStored=UNKNOWN_ROWCOUNT;
    index.getPageStore().logUndo(this,data);
    if (written) {
      writeHead();
    }
    index.getPageStore().update(this);
  }
}",0.9912536443148688
16106,"/** 
 * One of the children has moved to another page.
 * @param oldPos the old position
 * @param newPos the new position
 */
void moveChild(int oldPos,int newPos) throws SQLException {
  for (int i=0; i < childPageIds.length; i++) {
    if (childPageIds[i] == oldPos) {
      index.getPageStore().logUndo(this,data);
      written=false;
      childPageIds[i]=newPos;
      index.getPageStore().updateRecord(this);
      return;
    }
  }
  throw Message.throwInternalError();
}","/** 
 * One of the children has moved to another page.
 * @param oldPos the old position
 * @param newPos the new position
 */
void moveChild(int oldPos,int newPos) throws SQLException {
  for (int i=0; i < childPageIds.length; i++) {
    if (childPageIds[i] == oldPos) {
      index.getPageStore().logUndo(this,data);
      written=false;
      childPageIds[i]=newPos;
      index.getPageStore().update(this);
      return;
    }
  }
  throw Message.throwInternalError();
}",0.9937106918238994
16107,"void freeChildren() throws SQLException {
  for (int i=0; i <= entryCount; i++) {
    int childPageId=childPageIds[i];
    PageData child=index.getPage(childPageId,getPos());
    index.getPageStore().freePage(childPageId,false,null);
    child.freeChildren();
  }
}","void freeChildren() throws SQLException {
  for (int i=0; i <= entryCount; i++) {
    int childPageId=childPageIds[i];
    PageData child=index.getPage(childPageId,getPos());
    index.getPageStore().free(childPageId,false);
    child.freeChildren();
  }
}",0.982725527831094
16108,"void setRowCountStored(int rowCount) throws SQLException {
  this.rowCount=rowCount;
  if (rowCountStored != rowCount) {
    rowCountStored=rowCount;
    index.getPageStore().logUndo(this,data);
    if (written) {
      writeHead();
    }
    index.getPageStore().updateRecord(this);
  }
}","void setRowCountStored(int rowCount) throws SQLException {
  this.rowCount=rowCount;
  if (rowCountStored != rowCount) {
    rowCountStored=rowCount;
    index.getPageStore().logUndo(this,data);
    if (written) {
      writeHead();
    }
    index.getPageStore().update(this);
  }
}",0.9895104895104896
16109,"protected void remapChildren() throws SQLException {
  for (  int child : childPageIds) {
    PageData p=index.getPage(child,-1);
    p.setParentPageId(getPos());
    index.getPageStore().updateRecord(p);
  }
}","protected void remapChildren() throws SQLException {
  for (  int child : childPageIds) {
    PageData p=index.getPage(child,-1);
    p.setParentPageId(getPos());
    index.getPageStore().update(p);
  }
}",0.9855072463768116
16110,"public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  store.logUndo(this,data);
  PageDataNode p2=PageDataNode.create(index,newPos,parentPageId);
  p2.rowCountStored=rowCountStored;
  p2.rowCount=rowCount;
  p2.childPageIds=childPageIds;
  p2.keys=keys;
  p2.entryCount=entryCount;
  p2.length=length;
  store.updateRecord(p2);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageDataNode p=(PageDataNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
  for (int i=0; i < childPageIds.length; i++) {
    PageData p=(PageData)store.getPage(childPageIds[i]);
    p.setParentPageId(newPos);
    store.updateRecord(p);
  }
  store.freePage(getPos(),true,data);
}","public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  store.logUndo(this,data);
  PageDataNode p2=PageDataNode.create(index,newPos,parentPageId);
  p2.rowCountStored=rowCountStored;
  p2.rowCount=rowCount;
  p2.childPageIds=childPageIds;
  p2.keys=keys;
  p2.entryCount=entryCount;
  p2.length=length;
  store.update(p2);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageDataNode p=(PageDataNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
  for (int i=0; i < childPageIds.length; i++) {
    PageData p=(PageData)store.getPage(childPageIds[i]);
    p.setParentPageId(newPos);
    store.update(p);
  }
  store.free(getPos(),true);
}",0.986247544204322
16111,"/** 
 * Change the parent page id.
 * @param id the new parent page id
 */
void setParentPageId(int id){
  written=false;
  parentPageId=id;
}","/** 
 * Change the parent page id.
 * @param id the new parent page id
 */
void setParentPageId(int id) throws SQLException {
  index.getPageStore().logUndo(this,data);
  written=false;
  parentPageId=id;
}",0.8160919540229885
16112,"public void add(Session session,Row row) throws SQLException {
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"" + row.getKey());
  }
  SearchRow newRow=getSearchRow(row);
  while (true) {
    PageBtree root=getPage(rootPageId);
    int splitPoint=root.addRowTry(newRow);
    if (splitPoint == -1) {
      break;
    }
    if (trace.isDebugEnabled()) {
      trace.debug(""String_Node_Str"" + splitPoint);
    }
    SearchRow pivot=root.getRow(splitPoint - 1);
    PageBtree page1=root;
    PageBtree page2=root.split(splitPoint);
    int rootPageId=root.getPos();
    int id=store.allocatePage();
    page1.setPageId(id);
    page1.setParentPageId(rootPageId);
    page2.setParentPageId(rootPageId);
    PageBtreeNode newRoot=PageBtreeNode.create(this,rootPageId,PageBtree.ROOT);
    newRoot.init(page1,pivot,page2);
    store.updateRecord(page1,true,page1.data);
    store.updateRecord(page2,true,page2.data);
    store.updateRecord(newRoot,true,null);
    root=newRoot;
  }
  rowCount++;
}","public void add(Session session,Row row) throws SQLException {
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"" + row.getKey());
  }
  SearchRow newRow=getSearchRow(row);
  while (true) {
    PageBtree root=getPage(rootPageId);
    int splitPoint=root.addRowTry(newRow);
    if (splitPoint == -1) {
      break;
    }
    if (trace.isDebugEnabled()) {
      trace.debug(""String_Node_Str"" + splitPoint);
    }
    SearchRow pivot=root.getRow(splitPoint - 1);
    store.logUndo(root,root.data);
    PageBtree page1=root;
    PageBtree page2=root.split(splitPoint);
    store.logUndo(page2,null);
    int rootPageId=root.getPos();
    int id=store.allocatePage();
    page1.setPageId(id);
    page1.setParentPageId(rootPageId);
    page2.setParentPageId(rootPageId);
    PageBtreeNode newRoot=PageBtreeNode.create(this,rootPageId,PageBtree.ROOT);
    store.logUndo(newRoot,null);
    newRoot.init(page1,pivot,page2);
    store.updateRecord(page1);
    store.updateRecord(page2);
    store.updateRecord(newRoot);
    root=newRoot;
  }
  rowCount++;
}",0.8999516674722088
16113,"public PageBtreeIndex(TableData table,int id,String indexName,IndexColumn[] columns,IndexType indexType,int headPos,Session session) throws SQLException {
  initBaseIndex(table,id,indexName,columns,indexType);
  tableData=table;
  if (!database.isPersistent() || id < 0) {
    throw Message.throwInternalError(""String_Node_Str"" + indexName);
  }
  this.store=database.getPageStore();
  store.addIndex(this);
  if (headPos == Index.EMPTY_HEAD) {
    rootPageId=store.allocatePage();
    needRebuild=true;
    store.addMeta(this,session);
    PageBtreeLeaf root=PageBtreeLeaf.create(this,rootPageId,PageBtree.ROOT);
    store.updateRecord(root,true,root.data);
  }
 else {
    rootPageId=store.getRootPageId(id);
    PageBtree root=getPage(rootPageId);
    rowCount=root.getRowCount();
    if (rowCount == 0 && store.isRecoveryRunning()) {
      needRebuild=true;
    }
    if (!database.isReadOnly()) {
      store.updateRecord(root,false,null);
    }
  }
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"" + getName() + ""String_Node_Str""+ rowCount);
  }
}","public PageBtreeIndex(TableData table,int id,String indexName,IndexColumn[] columns,IndexType indexType,int headPos,Session session) throws SQLException {
  initBaseIndex(table,id,indexName,columns,indexType);
  tableData=table;
  if (!database.isPersistent() || id < 0) {
    throw Message.throwInternalError(""String_Node_Str"" + indexName);
  }
  this.store=database.getPageStore();
  store.addIndex(this);
  if (headPos == Index.EMPTY_HEAD) {
    rootPageId=store.allocatePage();
    needRebuild=true;
    store.addMeta(this,session);
    PageBtreeLeaf root=PageBtreeLeaf.create(this,rootPageId,PageBtree.ROOT);
    store.logUndo(root,null);
    store.updateRecord(root);
  }
 else {
    rootPageId=store.getRootPageId(id);
    PageBtree root=getPage(rootPageId);
    rowCount=root.getRowCount();
    if (rowCount == 0 && store.isRecoveryRunning()) {
      needRebuild=true;
    }
  }
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"" + getName() + ""String_Node_Str""+ rowCount);
  }
}",0.9382239382239382
16114,"/** 
 * Read the given page.
 * @param id the page id
 * @return the page
 */
PageBtree getPage(int id) throws SQLException {
  PageBtree p=(PageBtree)store.getPage(id);
  if (p == null) {
    PageBtreeLeaf empty=PageBtreeLeaf.create(this,id,PageBtree.ROOT);
    return empty;
  }
  return p;
}","/** 
 * Read the given page.
 * @param id the page id
 * @return the page
 */
PageBtree getPage(int id) throws SQLException {
  PageBtree p=(PageBtree)store.getPage(id);
  if (p == null) {
    PageBtreeLeaf empty=PageBtreeLeaf.create(this,id,PageBtree.ROOT);
    store.logUndo(empty,null);
    store.updateRecord(empty);
    return empty;
  }
  return p;
}",0.8830769230769231
16115,"private void removeAllRows() throws SQLException {
  PageBtree root=getPage(rootPageId);
  root.freeChildren();
  root=PageBtreeLeaf.create(this,rootPageId,PageBtree.ROOT);
  store.removeRecord(rootPageId);
  store.updateRecord(root,true,null);
  rowCount=0;
}","private void removeAllRows() throws SQLException {
  PageBtree root=getPage(rootPageId);
  store.logUndo(root,root.data);
  root.freeChildren();
  root=PageBtreeLeaf.create(this,rootPageId,PageBtree.ROOT);
  store.removeRecord(rootPageId);
  store.updateRecord(root);
  rowCount=0;
}",0.9208103130755064
16116,"/** 
 * Get the size of a row (only the part that is stored in the index).
 * @param dummy a dummy data page to calculate the size
 * @param row the row
 * @param onlyPosition whether only the position of the row is stored
 * @return the number of bytes
 */
int getRowSize(Data dummy,SearchRow row,boolean onlyPosition) throws SQLException {
  int rowsize=DataPage.LENGTH_INT;
  if (!onlyPosition) {
    for (    Column col : columns) {
      Value v=row.getValue(col.getColumnId());
      rowsize+=dummy.getValueLen(v);
    }
  }
  return rowsize;
}","/** 
 * Get the size of a row (only the part that is stored in the index).
 * @param dummy a dummy data page to calculate the size
 * @param row the row
 * @param onlyPosition whether only the position of the row is stored
 * @return the number of bytes
 */
int getRowSize(Data dummy,SearchRow row,boolean onlyPosition) throws SQLException {
  int rowsize=dummy.getVarLongLen(row.getKey());
  if (!onlyPosition) {
    for (    Column col : columns) {
      Value v=row.getValue(col.getColumnId());
      rowsize+=dummy.getValueLen(v);
    }
  }
  return rowsize;
}",0.9569120287253142
16117,"SearchRow remove(SearchRow row) throws SQLException {
  int at=find(row,false,false,true);
  SearchRow delete=getRow(at);
  if (index.compareRows(row,delete) != 0 || delete.getKey() != row.getKey()) {
    throw Message.getSQLException(ErrorCode.ROW_NOT_FOUND_WHEN_DELETING_1,index.getSQL() + ""String_Node_Str"" + row);
  }
  if (entryCount == 1) {
    return row;
  }
  removeRow(at);
  index.getPageStore().updateRecord(this,true,data);
  if (at == entryCount) {
    return getRow(at - 1);
  }
  return null;
}","SearchRow remove(SearchRow row) throws SQLException {
  int at=find(row,false,false,true);
  SearchRow delete=getRow(at);
  if (index.compareRows(row,delete) != 0 || delete.getKey() != row.getKey()) {
    throw Message.getSQLException(ErrorCode.ROW_NOT_FOUND_WHEN_DELETING_1,index.getSQL() + ""String_Node_Str"" + row);
  }
  if (entryCount == 1) {
    return row;
  }
  index.getPageStore().logUndo(this,data);
  removeRow(at);
  index.getPageStore().updateRecord(this);
  if (at == entryCount) {
    return getRow(at - 1);
  }
  return null;
}",0.949667616334283
16118,"int addRowTry(SearchRow row) throws SQLException {
  int rowLength=index.getRowSize(data,row,onlyPosition);
  int pageSize=index.getPageStore().getPageSize();
  int last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
  if (last - rowLength < start + OFFSET_LENGTH) {
    if (entryCount > 1) {
      int x=find(row,false,true,true);
      if (entryCount < 5) {
        return entryCount / 2;
      }
      int third=entryCount / 3;
      return x < third ? third : x >= 2 * third ? 2 * third : x;
    }
    onlyPosition=true;
    int o=pageSize;
    for (int i=0; i < entryCount; i++) {
      o-=index.getRowSize(data,getRow(i),true);
      offsets[i]=o;
    }
    last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
    rowLength=index.getRowSize(data,row,true);
    if (SysProperties.CHECK && last - rowLength < start + OFFSET_LENGTH) {
      throw Message.throwInternalError();
    }
  }
  written=false;
  int offset=last - rowLength;
  int[] newOffsets=new int[entryCount + 1];
  SearchRow[] newRows=new SearchRow[entryCount + 1];
  int x;
  if (entryCount == 0) {
    x=0;
  }
 else {
    readAllRows();
    x=find(row,false,true,true);
    System.arraycopy(offsets,0,newOffsets,0,x);
    System.arraycopy(rows,0,newRows,0,x);
    if (x < entryCount) {
      for (int j=x; j < entryCount; j++) {
        newOffsets[j + 1]=offsets[j] - rowLength;
      }
      offset=(x == 0 ? pageSize : offsets[x - 1]) - rowLength;
      System.arraycopy(rows,x,newRows,x + 1,entryCount - x);
    }
  }
  entryCount++;
  start+=OFFSET_LENGTH;
  newOffsets[x]=offset;
  newRows[x]=row;
  offsets=newOffsets;
  rows=newRows;
  index.getPageStore().updateRecord(this,true,data);
  return -1;
}","int addRowTry(SearchRow row) throws SQLException {
  int rowLength=index.getRowSize(data,row,onlyPosition);
  int pageSize=index.getPageStore().getPageSize();
  int last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
  if (last - rowLength < start + OFFSET_LENGTH) {
    if (entryCount > 1) {
      int x=find(row,false,true,true);
      if (entryCount < 5) {
        return entryCount / 2;
      }
      int third=entryCount / 3;
      return x < third ? third : x >= 2 * third ? 2 * third : x;
    }
    onlyPosition=true;
    int o=pageSize;
    for (int i=0; i < entryCount; i++) {
      o-=index.getRowSize(data,getRow(i),true);
      offsets[i]=o;
    }
    last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
    rowLength=index.getRowSize(data,row,true);
    if (SysProperties.CHECK && last - rowLength < start + OFFSET_LENGTH) {
      throw Message.throwInternalError();
    }
  }
  index.getPageStore().logUndo(this,data);
  written=false;
  int offset=last - rowLength;
  int[] newOffsets=new int[entryCount + 1];
  SearchRow[] newRows=new SearchRow[entryCount + 1];
  int x;
  if (entryCount == 0) {
    x=0;
  }
 else {
    readAllRows();
    x=find(row,false,true,true);
    System.arraycopy(offsets,0,newOffsets,0,x);
    System.arraycopy(rows,0,newRows,0,x);
    if (x < entryCount) {
      for (int j=x; j < entryCount; j++) {
        newOffsets[j + 1]=offsets[j] - rowLength;
      }
      offset=(x == 0 ? pageSize : offsets[x - 1]) - rowLength;
      System.arraycopy(rows,x,newRows,x + 1,entryCount - x);
    }
  }
  entryCount++;
  start+=OFFSET_LENGTH;
  newOffsets[x]=offset;
  newRows[x]=row;
  offsets=newOffsets;
  rows=newRows;
  index.getPageStore().updateRecord(this);
  return -1;
}",0.9845074539608302
16119,"PageBtree split(int splitPoint) throws SQLException {
  int newPageId=index.getPageStore().allocatePage();
  PageBtreeLeaf p2=new PageBtreeLeaf(index,newPageId,index.getPageStore().createData());
  p2.parentPageId=parentPageId;
  for (int i=splitPoint; i < entryCount; ) {
    p2.addRowTry(getRow(splitPoint));
    removeRow(splitPoint);
  }
  return p2;
}","PageBtree split(int splitPoint) throws SQLException {
  int newPageId=index.getPageStore().allocatePage();
  PageBtreeLeaf p2=PageBtreeLeaf.create(index,newPageId,parentPageId);
  for (int i=splitPoint; i < entryCount; ) {
    p2.addRowTry(getRow(splitPoint));
    removeRow(splitPoint);
  }
  return p2;
}",0.5075528700906344
16120,"/** 
 * Create a new page.
 * @param index the index
 * @param pageId the page id
 * @param parentPageId the parent
 * @return the page
 */
static PageBtreeLeaf create(PageBtreeIndex index,int pageId,int parentPageId){
  PageBtreeLeaf p=new PageBtreeLeaf(index,pageId,index.getPageStore().createData());
  p.parentPageId=parentPageId;
  p.writeHead();
  p.start=p.data.length();
  return p;
}","/** 
 * Create a new page.
 * @param index the index
 * @param pageId the page id
 * @param parentPageId the parent
 * @return the page
 */
static PageBtreeLeaf create(PageBtreeIndex index,int pageId,int parentPageId) throws SQLException {
  PageBtreeLeaf p=new PageBtreeLeaf(index,pageId,index.getPageStore().createData());
  index.getPageStore().logUndo(p,p.data);
  p.parentPageId=parentPageId;
  p.writeHead();
  p.start=p.data.length();
  return p;
}",0.9256198347107438
16121,"private void removeRow(int i) throws SQLException {
  readAllRows();
  entryCount--;
  written=false;
  if (entryCount <= 0) {
    Message.throwInternalError();
  }
  int[] newOffsets=new int[entryCount];
  SearchRow[] newRows=new SearchRow[entryCount];
  System.arraycopy(offsets,0,newOffsets,0,i);
  System.arraycopy(rows,0,newRows,0,i);
  int startNext=i > 0 ? offsets[i - 1] : index.getPageStore().getPageSize();
  int rowLength=startNext - offsets[i];
  for (int j=i; j < entryCount; j++) {
    newOffsets[j]=offsets[j + 1] + rowLength;
  }
  System.arraycopy(rows,i + 1,newRows,i,entryCount - i);
  start-=OFFSET_LENGTH;
  offsets=newOffsets;
  rows=newRows;
}","private void removeRow(int i) throws SQLException {
  readAllRows();
  index.getPageStore().logUndo(this,data);
  entryCount--;
  written=false;
  if (entryCount <= 0) {
    Message.throwInternalError();
  }
  int[] newOffsets=new int[entryCount];
  SearchRow[] newRows=new SearchRow[entryCount];
  System.arraycopy(offsets,0,newOffsets,0,i);
  System.arraycopy(rows,0,newRows,0,i);
  int startNext=i > 0 ? offsets[i - 1] : index.getPageStore().getPageSize();
  int rowLength=startNext - offsets[i];
  for (int j=i; j < entryCount; j++) {
    newOffsets[j]=offsets[j + 1] + rowLength;
  }
  System.arraycopy(rows,i + 1,newRows,i,entryCount - i);
  start-=OFFSET_LENGTH;
  offsets=newOffsets;
  rows=newRows;
}",0.9687272727272728
16122,"public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  PageBtreeLeaf p2=new PageBtreeLeaf(index,newPos,store.createData());
  readAllRows();
  p2.rows=rows;
  p2.entryCount=entryCount;
  p2.offsets=offsets;
  p2.onlyPosition=onlyPosition;
  p2.parentPageId=parentPageId;
  p2.start=start;
  store.updateRecord(p2,false,null);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageBtreeNode p=(PageBtreeNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
  store.freePage(getPos(),true,data);
}","public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  readAllRows();
  PageBtreeLeaf p2=PageBtreeLeaf.create(index,newPos,parentPageId);
  store.logUndo(this,data);
  store.logUndo(p2,null);
  p2.rows=rows;
  p2.entryCount=entryCount;
  p2.offsets=offsets;
  p2.onlyPosition=onlyPosition;
  p2.parentPageId=parentPageId;
  p2.start=start;
  store.updateRecord(p2);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageBtreeNode p=(PageBtreeNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
  store.freePage(getPos(),true,data);
}",0.8881789137380192
16123,"SearchRow remove(SearchRow row) throws SQLException {
  int at=find(row,false,false,true);
  PageBtree page=index.getPage(childPageIds[at]);
  SearchRow last=page.remove(row);
  updateRowCount(-1);
  written=false;
  if (last == null) {
    return null;
  }
 else   if (last == row) {
    index.getPageStore().freePage(page.getPos(),true,page.data);
    if (entryCount < 1) {
      return row;
    }
    if (at == entryCount) {
      last=getRow(at - 1);
    }
 else {
      last=null;
    }
    removeChild(at);
    index.getPageStore().updateRecord(this,true,data);
    return last;
  }
  if (at == entryCount) {
    return last;
  }
  int child=childPageIds[at];
  removeChild(at);
  addChild(at,child,last);
  int temp=childPageIds[at];
  childPageIds[at]=childPageIds[at + 1];
  childPageIds[at + 1]=temp;
  index.getPageStore().updateRecord(this,true,data);
  return null;
}","SearchRow remove(SearchRow row) throws SQLException {
  int at=find(row,false,false,true);
  PageBtree page=index.getPage(childPageIds[at]);
  SearchRow last=page.remove(row);
  index.getPageStore().logUndo(this,data);
  updateRowCount(-1);
  written=false;
  if (last == null) {
    return null;
  }
 else   if (last == row) {
    index.getPageStore().freePage(page.getPos(),true,page.data);
    if (entryCount < 1) {
      return row;
    }
    if (at == entryCount) {
      last=getRow(at - 1);
    }
 else {
      last=null;
    }
    removeChild(at);
    index.getPageStore().updateRecord(this);
    return last;
  }
  if (at == entryCount) {
    return last;
  }
  int child=childPageIds[at];
  removeChild(at);
  addChild(at,child,last);
  int temp=childPageIds[at];
  childPageIds[at]=childPageIds[at + 1];
  childPageIds[at + 1]=temp;
  index.getPageStore().updateRecord(this);
  return null;
}",0.9646662927650028
16124,"int addRowTry(SearchRow row) throws SQLException {
  while (true) {
    int x=find(row,false,true,true);
    PageBtree page=index.getPage(childPageIds[x]);
    int splitPoint=page.addRowTry(row);
    if (splitPoint == -1) {
      break;
    }
    SearchRow pivot=page.getRow(splitPoint - 1);
    int splitPoint2=addChildTry(pivot);
    if (splitPoint2 != -1) {
      return splitPoint2;
    }
    PageBtree page2=page.split(splitPoint);
    readAllRows();
    addChild(x,page2.getPos(),pivot);
    index.getPageStore().updateRecord(page,true,page.data);
    index.getPageStore().updateRecord(page2,true,page2.data);
    index.getPageStore().updateRecord(this,true,data);
  }
  updateRowCount(1);
  written=false;
  return -1;
}","int addRowTry(SearchRow row) throws SQLException {
  while (true) {
    int x=find(row,false,true,true);
    PageBtree page=index.getPage(childPageIds[x]);
    int splitPoint=page.addRowTry(row);
    if (splitPoint == -1) {
      break;
    }
    SearchRow pivot=page.getRow(splitPoint - 1);
    index.getPageStore().logUndo(this,data);
    int splitPoint2=addChildTry(pivot);
    if (splitPoint2 != -1) {
      return splitPoint2;
    }
    PageBtree page2=page.split(splitPoint);
    readAllRows();
    addChild(x,page2.getPos(),pivot);
    index.getPageStore().updateRecord(page);
    index.getPageStore().updateRecord(page2);
    index.getPageStore().updateRecord(this);
  }
  updateRowCount(1);
  written=false;
  return -1;
}",0.9410150891632372
16125,"PageBtree split(int splitPoint) throws SQLException {
  int newPageId=index.getPageStore().allocatePage();
  PageBtreeNode p2=new PageBtreeNode(index,newPageId,index.getPageStore().createData());
  p2.parentPageId=parentPageId;
  if (onlyPosition) {
    p2.onlyPosition=true;
  }
  int firstChild=childPageIds[splitPoint];
  readAllRows();
  for (int i=splitPoint; i < entryCount; ) {
    p2.addChild(p2.entryCount,childPageIds[splitPoint + 1],rows[splitPoint]);
    removeChild(splitPoint);
  }
  int lastChild=childPageIds[splitPoint - 1];
  removeChild(splitPoint - 1);
  childPageIds[splitPoint - 1]=lastChild;
  if (p2.childPageIds == null) {
    p2.childPageIds=new int[1];
  }
  p2.childPageIds[0]=firstChild;
  p2.remapChildren();
  return p2;
}","PageBtree split(int splitPoint) throws SQLException {
  int newPageId=index.getPageStore().allocatePage();
  PageBtreeNode p2=PageBtreeNode.create(index,newPageId,parentPageId);
  index.getPageStore().logUndo(this,data);
  if (onlyPosition) {
    p2.onlyPosition=true;
  }
  int firstChild=childPageIds[splitPoint];
  readAllRows();
  for (int i=splitPoint; i < entryCount; ) {
    p2.addChild(p2.entryCount,childPageIds[splitPoint + 1],rows[splitPoint]);
    removeChild(splitPoint);
  }
  int lastChild=childPageIds[splitPoint - 1];
  removeChild(splitPoint - 1);
  childPageIds[splitPoint - 1]=lastChild;
  if (p2.childPageIds == null) {
    p2.childPageIds=new int[1];
  }
  p2.childPageIds[0]=firstChild;
  p2.remapChildren();
  return p2;
}",0.9392928619079386
16126,"/** 
 * One of the children has moved to a new page.
 * @param oldPos the old position
 * @param newPos the new position
 */
void moveChild(int oldPos,int newPos) throws SQLException {
  for (int i=0; i < childPageIds.length; i++) {
    if (childPageIds[i] == oldPos) {
      written=false;
      childPageIds[i]=newPos;
      index.getPageStore().updateRecord(this,true,data);
      return;
    }
  }
  throw Message.throwInternalError();
}","/** 
 * One of the children has moved to a new page.
 * @param oldPos the old position
 * @param newPos the new position
 */
void moveChild(int oldPos,int newPos) throws SQLException {
  for (int i=0; i < childPageIds.length; i++) {
    if (childPageIds[i] == oldPos) {
      index.getPageStore().logUndo(this,data);
      written=false;
      childPageIds[i]=newPos;
      index.getPageStore().updateRecord(this);
      return;
    }
  }
  throw Message.throwInternalError();
}",0.911860718171926
16127,"/** 
 * Create a new b-tree node page.
 * @param index the index
 * @param pageId the page id
 * @param parentPageId the parent page id
 * @return the page
 */
static PageBtreeNode create(PageBtreeIndex index,int pageId,int parentPageId){
  PageBtreeNode p=new PageBtreeNode(index,pageId,index.getPageStore().createData());
  p.parentPageId=parentPageId;
  p.writeHead();
  p.start=p.data.length() + 4;
  return p;
}","/** 
 * Create a new b-tree node page.
 * @param index the index
 * @param pageId the page id
 * @param parentPageId the parent page id
 * @return the page
 */
static PageBtreeNode create(PageBtreeIndex index,int pageId,int parentPageId) throws SQLException {
  PageBtreeNode p=new PageBtreeNode(index,pageId,index.getPageStore().createData());
  index.getPageStore().logUndo(p,p.data);
  p.parentPageId=parentPageId;
  p.writeHead();
  p.start=p.data.length() + 4;
  return p;
}",0.929608938547486
16128,"protected void remapChildren() throws SQLException {
  for (  int child : childPageIds) {
    PageBtree p=index.getPage(child);
    p.setParentPageId(getPos());
    index.getPageStore().updateRecord(p,true,p.data);
  }
}","protected void remapChildren() throws SQLException {
  for (  int child : childPageIds) {
    PageBtree p=index.getPage(child);
    p.setParentPageId(getPos());
    index.getPageStore().updateRecord(p);
  }
}",0.97196261682243
16129,"public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  PageBtreeNode p2=new PageBtreeNode(index,newPos,store.createData());
  readAllRows();
  p2.childPageIds=childPageIds;
  p2.rows=rows;
  p2.entryCount=entryCount;
  p2.offsets=offsets;
  p2.onlyPosition=onlyPosition;
  p2.parentPageId=parentPageId;
  p2.start=start;
  store.updateRecord(p2,false,null);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageBtreeNode p=(PageBtreeNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
  for (int i=0; i < childPageIds.length; i++) {
    PageBtree p=(PageBtree)store.getPage(childPageIds[i]);
    p.setParentPageId(newPos);
    store.updateRecord(p,true,p.data);
  }
  store.freePage(getPos(),true,data);
}","public void moveTo(Session session,int newPos) throws SQLException {
  PageStore store=index.getPageStore();
  store.logUndo(this,data);
  PageBtreeNode p2=PageBtreeNode.create(index,newPos,parentPageId);
  readAllRows();
  p2.childPageIds=childPageIds;
  p2.rows=rows;
  p2.entryCount=entryCount;
  p2.offsets=offsets;
  p2.onlyPosition=onlyPosition;
  p2.parentPageId=parentPageId;
  p2.start=start;
  store.updateRecord(p2);
  if (parentPageId == ROOT) {
    index.setRootPageId(session,newPos);
  }
 else {
    PageBtreeNode p=(PageBtreeNode)store.getPage(parentPageId);
    p.moveChild(getPos(),newPos);
  }
  for (int i=0; i < childPageIds.length; i++) {
    PageBtree p=(PageBtree)store.getPage(childPageIds[i]);
    p.setParentPageId(newPos);
    store.updateRecord(p);
  }
  store.freePage(getPos(),true,data);
}",0.8963414634146342
16130,"/** 
 * Change the parent page id.
 * @param id the new parent page id
 */
void setParentPageId(int id){
  parentPageId=id;
  if (written) {
    data.setInt(START_PARENT,parentPageId);
  }
}","/** 
 * Change the parent page id.
 * @param id the new parent page id
 */
void setParentPageId(int id) throws SQLException {
  index.getPageStore().logUndo(this,data);
  parentPageId=id;
  if (written) {
    data.setInt(START_PARENT,parentPageId);
  }
}",0.8558558558558559
16131,"/** 
 * Read the given page.
 * @param id the page id
 * @param parent the parent, or -1 if unknown
 * @return the page
 */
PageData getPage(int id,int parent) throws SQLException {
  PageData p=(PageData)store.getPage(id);
  if (p == null) {
    PageDataLeaf empty=PageDataLeaf.create(this,id,parent);
    return empty;
  }
  if (p.index.rootPageId != rootPageId) {
    throw Message.throwInternalError(""String_Node_Str"" + p.index.getName() + ""String_Node_Str""+ p.index.rootPageId+ ""String_Node_Str""+ getName()+ ""String_Node_Str""+ rootPageId);
  }
  if (parent != -1) {
    if (p.getParentPageId() != parent) {
      throw Message.throwInternalError(p + ""String_Node_Str"" + p.getParentPageId()+ ""String_Node_Str""+ parent);
    }
  }
  return p;
}","/** 
 * Read the given page.
 * @param id the page id
 * @param parent the parent, or -1 if unknown
 * @return the page
 */
PageData getPage(int id,int parent) throws SQLException {
  PageData p=(PageData)store.getPage(id);
  if (p == null) {
    PageDataLeaf empty=PageDataLeaf.create(this,id,parent);
    store.logUndo(empty,null);
    store.updateRecord(empty);
    return empty;
  }
  if (p.index.rootPageId != rootPageId) {
    throw Message.throwInternalError(""String_Node_Str"" + p.index.getName() + ""String_Node_Str""+ p.index.rootPageId+ ""String_Node_Str""+ getName()+ ""String_Node_Str""+ rootPageId);
  }
  if (parent != -1) {
    if (p.getParentPageId() != parent) {
      throw Message.throwInternalError(p + ""String_Node_Str"" + p.getParentPageId()+ ""String_Node_Str""+ parent);
    }
  }
  return p;
}",0.9601542416452442
16132,"private void removeAllRows() throws SQLException {
  PageData root=getPage(rootPageId,0);
  root.freeChildren();
  root=PageDataLeaf.create(this,rootPageId,PageData.ROOT);
  store.removeRecord(rootPageId);
  store.updateRecord(root,true,null);
  rowCount=0;
  lastKey=0;
}","private void removeAllRows() throws SQLException {
  PageData root=getPage(rootPageId,0);
  root.freeChildren();
  root=PageDataLeaf.create(this,rootPageId,PageData.ROOT);
  store.removeRecord(rootPageId);
  store.updateRecord(root);
  rowCount=0;
  lastKey=0;
}",0.9812734082397004
16133,"public PageDataIndex(TableData table,int id,IndexColumn[] columns,IndexType indexType,int headPos,Session session) throws SQLException {
  initBaseIndex(table,id,table.getName() + ""String_Node_Str"",columns,indexType);
  if (database.isMultiVersion()) {
    sessionRowCount=New.hashMap();
    isMultiVersion=true;
  }
  tableData=table;
  this.store=database.getPageStore();
  store.addIndex(this);
  if (!database.isPersistent()) {
    throw Message.throwInternalError(table.getName());
  }
  if (headPos == Index.EMPTY_HEAD) {
    rootPageId=store.allocatePage();
    store.addMeta(this,session);
    PageDataLeaf root=PageDataLeaf.create(this,rootPageId,PageData.ROOT);
    store.updateRecord(root,true,root.data);
  }
 else {
    rootPageId=store.getRootPageId(id);
    PageData root=getPage(rootPageId,0);
    lastKey=root.getLastKey();
    rowCount=root.getRowCount();
    if (!database.isReadOnly()) {
      store.updateRecord(root,false,null);
    }
  }
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"" + getName() + ""String_Node_Str""+ rowCount);
  }
  table.setRowCount(rowCount);
  fastDuplicateKeyException=super.getDuplicateKeyException();
  memorySizePerPage=store.getPageSize();
  int estimatedRowsPerPage=store.getPageSize() / ((1 + columns.length) * 8);
  memorySizePerPage+=estimatedRowsPerPage * 64;
}","public PageDataIndex(TableData table,int id,IndexColumn[] columns,IndexType indexType,int headPos,Session session) throws SQLException {
  initBaseIndex(table,id,table.getName() + ""String_Node_Str"",columns,indexType);
  if (database.isMultiVersion()) {
    sessionRowCount=New.hashMap();
    isMultiVersion=true;
  }
  tableData=table;
  this.store=database.getPageStore();
  store.addIndex(this);
  if (!database.isPersistent()) {
    throw Message.throwInternalError(table.getName());
  }
  if (headPos == Index.EMPTY_HEAD) {
    rootPageId=store.allocatePage();
    store.addMeta(this,session);
    PageDataLeaf root=PageDataLeaf.create(this,rootPageId,PageData.ROOT);
    store.updateRecord(root);
  }
 else {
    rootPageId=store.getRootPageId(id);
    PageData root=getPage(rootPageId,0);
    lastKey=root.getLastKey();
    rowCount=root.getRowCount();
  }
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"" + getName() + ""String_Node_Str""+ rowCount);
  }
  table.setRowCount(rowCount);
  fastDuplicateKeyException=super.getDuplicateKeyException();
  memorySizePerPage=store.getPageSize();
  int estimatedRowsPerPage=store.getPageSize() / ((1 + columns.length) * 8);
  memorySizePerPage+=estimatedRowsPerPage * 64;
}",0.9618973561430794
16134,"private void addTry(Session session,Row row) throws SQLException {
  while (true) {
    PageData root=getPage(rootPageId,0);
    int splitPoint=root.addRowTry(row);
    if (splitPoint == -1) {
      break;
    }
    if (trace.isDebugEnabled()) {
      trace.debug(""String_Node_Str"" + splitPoint);
    }
    long pivot=splitPoint == 0 ? row.getKey() : root.getKey(splitPoint - 1);
    PageData page1=root;
    PageData page2=root.split(splitPoint);
    int rootPageId=root.getPos();
    int id=store.allocatePage();
    page1.setPageId(id);
    page1.setParentPageId(rootPageId);
    page2.setParentPageId(rootPageId);
    PageDataNode newRoot=PageDataNode.create(this,rootPageId,PageData.ROOT);
    newRoot.init(page1,pivot,page2);
    store.updateRecord(page1,true,page1.data);
    store.updateRecord(page2,true,page2.data);
    store.updateRecord(newRoot,true,null);
    root=newRoot;
  }
  row.setDeleted(false);
  if (database.isMultiVersion()) {
    if (delta == null) {
      delta=New.hashSet();
    }
    boolean wasDeleted=delta.remove(row);
    if (!wasDeleted) {
      delta.add(row);
    }
    incrementRowCount(session.getId(),1);
  }
  invalidateRowCount();
  rowCount++;
  store.logAddOrRemoveRow(session,tableData.getId(),row,true);
}","private void addTry(Session session,Row row) throws SQLException {
  while (true) {
    PageData root=getPage(rootPageId,0);
    int splitPoint=root.addRowTry(row);
    if (splitPoint == -1) {
      break;
    }
    if (trace.isDebugEnabled()) {
      trace.debug(""String_Node_Str"" + splitPoint);
    }
    long pivot=splitPoint == 0 ? row.getKey() : root.getKey(splitPoint - 1);
    PageData page1=root;
    PageData page2=root.split(splitPoint);
    int rootPageId=root.getPos();
    int id=store.allocatePage();
    page1.setPageId(id);
    page1.setParentPageId(rootPageId);
    page2.setParentPageId(rootPageId);
    PageDataNode newRoot=PageDataNode.create(this,rootPageId,PageData.ROOT);
    newRoot.init(page1,pivot,page2);
    store.updateRecord(page1);
    store.updateRecord(page2);
    store.updateRecord(newRoot);
    root=newRoot;
  }
  row.setDeleted(false);
  if (database.isMultiVersion()) {
    if (delta == null) {
      delta=New.hashSet();
    }
    boolean wasDeleted=delta.remove(row);
    if (!wasDeleted) {
      delta.add(row);
    }
    incrementRowCount(session.getId(),1);
  }
  invalidateRowCount();
  rowCount++;
  store.logAddOrRemoveRow(session,tableData.getId(),row,true);
}",0.9528071602929212
16135,"private void test(String... args){
  for (int i=0; i < args.length; i++) {
    if (""String_Node_Str"".equals(args[i])) {
      url=args[++i];
    }
 else     if (""String_Node_Str"".equals(args[i])) {
      driver=args[++i];
    }
 else     if (""String_Node_Str"".equals(args[i])) {
      user=args[++i];
    }
 else     if (""String_Node_Str"".equals(args[i])) {
      password=args[++i];
    }
  }
  System.out.println(""String_Node_Str"" + driver + ""String_Node_Str""+ url+ ""String_Node_Str""+ user+ ""String_Node_Str""+ password);
  try {
    System.out.println(""String_Node_Str"");
    Random random=new Random();
    boolean wasRunning=false;
    for (int i=0; i < 200; i++) {
      if (connections.size() > 1 && tables.size() > 1) {
        System.out.println(""String_Node_Str"" + connections.size() + ""String_Node_Str""+ tables.size());
        wasRunning=true;
      }
      if (connections.size() < 1) {
        openConnection();
      }
      if (tables.size() < 1) {
        createTable(random);
      }
      int p=random.nextInt(100);
      if ((p-=2) <= 0) {
        if (connections.size() < 5) {
          openConnection();
        }
      }
 else       if ((p-=1) <= 0) {
        if (connections.size() > 1) {
          Connection conn=connections.remove(random.nextInt(connections.size()));
          if (random.nextBoolean()) {
            conn.close();
          }
        }
      }
 else       if ((p-=10) <= 0) {
        createTable(random);
      }
 else       if ((p-=20) <= 0) {
        if (tables.size() > 0) {
          Connection conn=connections.get(random.nextInt(connections.size()));
          Statement stat=conn.createStatement();
          String table=tables.get(random.nextInt(tables.size()));
          if (random.nextBoolean()) {
            stat.execute(""String_Node_Str"" + table + ""String_Node_Str"");
          }
 else           if (random.nextBoolean()) {
            stat.execute(""String_Node_Str"" + table + ""String_Node_Str"");
          }
 else {
            stat.execute(""String_Node_Str"" + table);
          }
        }
      }
 else       if ((p-=5) < 0) {
        if (tables.size() > 0) {
          Connection conn=connections.get(random.nextInt(connections.size()));
          Statement stat=conn.createStatement();
          String table=tables.get(random.nextInt(tables.size()));
          if (random.nextBoolean()) {
            stat.execute(""String_Node_Str"" + table);
          }
 else {
            stat.execute(""String_Node_Str"" + table);
            System.out.println(""String_Node_Str"" + table);
            tables.remove(table);
          }
        }
      }
 else       if ((p-=30) <= 0) {
        if (tables.size() > 0) {
          Connection conn=connections.get(random.nextInt(connections.size()));
          Statement stat=conn.createStatement();
          String table=tables.get(random.nextInt(tables.size()));
          stat.execute(""String_Node_Str"" + table + ""String_Node_Str"");
        }
      }
 else {
        if (tables.size() > 0) {
          Connection conn=connections.get(random.nextInt(connections.size()));
          Statement stat=conn.createStatement();
          String table=tables.get(random.nextInt(tables.size()));
          stat.execute(""String_Node_Str"" + table + ""String_Node_Str""+ table);
        }
      }
    }
    System.out.println(""String_Node_Str"" + wasRunning);
    System.out.println(""String_Node_Str"");
  }
 catch (  Throwable e) {
    System.out.println(""String_Node_Str"" + openCount + ""String_Node_Str""+ url+ ""String_Node_Str""+ e.toString());
    e.printStackTrace(System.out);
    System.out.println(""String_Node_Str"");
  }
}","private void test(String... args){
  for (int i=0; i < args.length; i++) {
    if (""String_Node_Str"".equals(args[i])) {
      url=args[++i];
    }
 else     if (""String_Node_Str"".equals(args[i])) {
      driver=args[++i];
    }
 else     if (""String_Node_Str"".equals(args[i])) {
      user=args[++i];
    }
 else     if (""String_Node_Str"".equals(args[i])) {
      password=args[++i];
    }
  }
  System.out.println(""String_Node_Str"" + driver + ""String_Node_Str""+ url+ ""String_Node_Str""+ user+ ""String_Node_Str""+ password);
  try {
    System.out.println(""String_Node_Str"");
    Random random=new Random();
    boolean wasRunning=false;
    for (int i=0; i < 3000; i++) {
      if (i > 1000 && connections.size() > 1 && tables.size() > 1) {
        System.out.println(""String_Node_Str"" + connections.size() + ""String_Node_Str""+ tables.size());
        wasRunning=true;
      }
      if (connections.size() < 1) {
        openConnection();
      }
      if (tables.size() < 1) {
        createTable(random);
      }
      int p=random.nextInt(100);
      if ((p-=2) <= 0) {
        if (connections.size() < 5) {
          openConnection();
        }
      }
 else       if ((p-=1) <= 0) {
        if (connections.size() > 1) {
          Connection conn=connections.remove(random.nextInt(connections.size()));
          if (random.nextBoolean()) {
            conn.close();
          }
        }
      }
 else       if ((p-=10) <= 0) {
        createTable(random);
      }
 else       if ((p-=20) <= 0) {
        if (tables.size() > 0) {
          Connection conn=connections.get(random.nextInt(connections.size()));
          Statement stat=conn.createStatement();
          String table=tables.get(random.nextInt(tables.size()));
          if (random.nextBoolean()) {
            stat.execute(""String_Node_Str"" + table + ""String_Node_Str"");
          }
 else           if (random.nextBoolean()) {
            stat.execute(""String_Node_Str"" + table + ""String_Node_Str"");
          }
 else {
            stat.execute(""String_Node_Str"" + table);
          }
        }
      }
 else       if ((p-=5) < 0) {
        if (tables.size() > 0) {
          Connection conn=connections.get(random.nextInt(connections.size()));
          Statement stat=conn.createStatement();
          String table=tables.get(random.nextInt(tables.size()));
          if (random.nextBoolean()) {
            stat.execute(""String_Node_Str"" + table);
          }
 else {
            stat.execute(""String_Node_Str"" + table);
            System.out.println(""String_Node_Str"" + table);
            tables.remove(table);
          }
        }
      }
 else       if ((p-=30) <= 0) {
        if (tables.size() > 0) {
          Connection conn=connections.get(random.nextInt(connections.size()));
          Statement stat=conn.createStatement();
          String table=tables.get(random.nextInt(tables.size()));
          stat.execute(""String_Node_Str"" + table + ""String_Node_Str"");
        }
      }
 else {
        if (tables.size() > 0) {
          Connection conn=connections.get(random.nextInt(connections.size()));
          Statement stat=conn.createStatement();
          String table=tables.get(random.nextInt(tables.size()));
          stat.execute(""String_Node_Str"" + table + ""String_Node_Str""+ table);
        }
      }
    }
    System.out.println(""String_Node_Str"" + wasRunning);
    System.out.println(""String_Node_Str"");
  }
 catch (  Throwable e) {
    System.out.println(""String_Node_Str"" + openCount + ""String_Node_Str""+ url+ ""String_Node_Str""+ e.toString());
    e.printStackTrace(System.out);
    System.out.println(""String_Node_Str"");
  }
}",0.9979273179494266
16136,"/** 
 * Get all sessions that are currently connected to the database.
 * @param includingSystemSession if the system session should also beincluded
 * @return the list of sessions
 */
public Session[] getSessions(boolean includingSystemSession){
  ArrayList<Session> list=New.arrayList(userSessions);
  Session sys=systemSession;
  if (includingSystemSession && sys != null) {
    list.add(sys);
  }
  Session[] array=new Session[list.size()];
  list.toArray(array);
  return array;
}","/** 
 * Get all sessions that are currently connected to the database.
 * @param includingSystemSession if the system session should also beincluded
 * @return the list of sessions
 */
public Session[] getSessions(boolean includingSystemSession){
  ArrayList<Session> list;
synchronized (userSessions) {
    list=New.arrayList(userSessions);
  }
  Session sys=systemSession;
  if (includingSystemSession && sys != null) {
    list.add(sys);
  }
  Session[] array=new Session[list.size()];
  list.toArray(array);
  return array;
}",0.9566074950690336
16137,"private void removeOld() throws SQLException {
  int i=0;
  ObjectArray<CacheObject> changed=ObjectArray.newInstance();
  int si=sizeIn, sm=sizeMain, rc=recordCount;
  CacheObject inNext=headIn.next, mainNext=headMain.next;
  while (((si * 4 > maxIn * 3) || (sm * 4 > maxMain * 3)) && rc > Constants.CACHE_MIN_RECORDS) {
    i++;
    if (i == rc) {
      writer.flushLog();
    }
    if (i >= rc * 2) {
      writer.getTrace().info(""String_Node_Str"");
      break;
    }
    if (si > maxIn) {
      CacheObject r=inNext;
      inNext=r.next;
      if (!r.canRemove()) {
        removeFromList(r);
        addToFront(headIn,r);
        continue;
      }
      rc--;
      si-=r.getMemorySize();
      if (r.isChanged()) {
        changed.add(r);
      }
 else {
        remove(r);
      }
    }
 else     if (sm > 0) {
      CacheObject r=mainNext;
      mainNext=r.next;
      if (!r.canRemove() && !(r instanceof CacheHead)) {
        removeFromList(r);
        addToFront(headMain,r);
        continue;
      }
      rc--;
      sm-=r.getMemorySize();
      if (r.isChanged()) {
        changed.add(r);
      }
 else {
        remove(r);
      }
    }
  }
  if (changed.size() > 0) {
    int mm=maxMain;
    int mi=maxIn;
    try {
      maxMain=Integer.MAX_VALUE;
      maxIn=Integer.MAX_VALUE;
      CacheObject.sort(changed);
      for (i=0; i < changed.size(); i++) {
        CacheObject rec=changed.get(i);
        writer.writeBack(rec);
      }
    }
  finally {
      maxMain=mm;
      maxIn=mi;
    }
    for (i=0; i < changed.size(); i++) {
      CacheObject rec=changed.get(i);
      remove(rec);
    }
  }
}","private void removeOld() throws SQLException {
  int i=0;
  ObjectArray<CacheObject> changed=ObjectArray.newInstance();
  int si=sizeIn, sm=sizeMain, rc=recordCount;
  CacheObject inNext=headIn.next, mainNext=headMain.next;
  while (((si * 4 > maxIn * 3) || (sm * 4 > maxMain * 3)) && rc > Constants.CACHE_MIN_RECORDS) {
    i++;
    if (i == rc) {
      writer.flushLog();
    }
    if (i >= rc * 2) {
      writer.getTrace().info(""String_Node_Str"");
      break;
    }
    if (si > maxIn) {
      CacheObject r=inNext;
      inNext=r.next;
      if (!r.canRemove()) {
        if (r != headIn) {
          removeFromList(r);
          addToFront(headIn,r);
        }
        continue;
      }
      rc--;
      si-=r.getMemorySize();
      if (r.isChanged()) {
        changed.add(r);
      }
 else {
        remove(r);
      }
    }
 else     if (sm > 0) {
      CacheObject r=mainNext;
      mainNext=r.next;
      if (!r.canRemove() && !(r instanceof CacheHead)) {
        removeFromList(r);
        addToFront(headMain,r);
        continue;
      }
      rc--;
      sm-=r.getMemorySize();
      if (r.isChanged()) {
        changed.add(r);
      }
 else {
        remove(r);
      }
    }
  }
  if (changed.size() > 0) {
    int mm=maxMain;
    int mi=maxIn;
    try {
      maxMain=Integer.MAX_VALUE;
      maxIn=Integer.MAX_VALUE;
      CacheObject.sort(changed);
      for (i=0; i < changed.size(); i++) {
        CacheObject rec=changed.get(i);
        writer.writeBack(rec);
      }
    }
  finally {
      maxMain=mm;
      maxIn=mi;
    }
    for (i=0; i < changed.size(); i++) {
      CacheObject rec=changed.get(i);
      remove(rec);
    }
  }
}",0.987503809814081
16138,"int addRowTry(Row row) throws SQLException {
  int rowLength=getRowLength(row);
  int pageSize=index.getPageStore().getPageSize();
  int last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
  int keyOffsetPairLen=2 + data.getVarLongLen(row.getKey());
  if (entryCount > 0 && last - rowLength < start + keyOffsetPairLen) {
    int x=find(row.getKey());
    if (entryCount > 1) {
      if (entryCount < 5) {
        return entryCount / 2;
      }
      int third=entryCount / 3;
      return x < third ? third : x >= 2 * third ? 2 * third : x;
    }
    return x;
  }
  int offset=last - rowLength;
  int[] newOffsets=new int[entryCount + 1];
  long[] newKeys=new long[entryCount + 1];
  Row[] newRows=new Row[entryCount + 1];
  int x;
  if (entryCount == 0) {
    x=0;
  }
 else {
    readAllRows();
    x=find(row.getKey());
    if (x < keys.length && keys[x] == row.getKey()) {
      throw index.getDuplicateKeyException();
    }
    System.arraycopy(offsets,0,newOffsets,0,x);
    System.arraycopy(keys,0,newKeys,0,x);
    System.arraycopy(rows,0,newRows,0,x);
    if (x < entryCount) {
      for (int j=x; j < entryCount; j++) {
        newOffsets[j + 1]=offsets[j] - rowLength;
      }
      System.arraycopy(keys,x,newKeys,x + 1,entryCount - x);
      System.arraycopy(rows,x,newRows,x + 1,entryCount - x);
    }
  }
  written=false;
  last=x == 0 ? pageSize : offsets[x - 1];
  offset=last - rowLength;
  entryCount++;
  start+=keyOffsetPairLen;
  newOffsets[x]=offset;
  newKeys[x]=row.getKey();
  newRows[x]=row;
  memorySize+=row.getMemorySize();
  offsets=newOffsets;
  keys=newKeys;
  rows=newRows;
  index.getPageStore().updateRecord(this,true,data);
  if (offset < start) {
    if (entryCount > 1) {
      Message.throwInternalError();
    }
    start+=4;
    int remaining=rowLength - (pageSize - start);
    offset=start;
    offsets[x]=offset;
    int previous=getPos();
    int dataOffset=pageSize;
    int page=index.getPageStore().allocatePage();
    firstOverflowPageId=page;
    this.overflowRowSize=pageSize + rowLength;
    write();
    rowRef=new SoftReference<Row>(rows[0]);
    rows[0]=null;
    Data all=index.getPageStore().createData();
    all.checkCapacity(data.length());
    all.write(data.getBytes(),0,data.length());
    data.truncate(index.getPageStore().getPageSize());
    write(null);
    do {
      int type, size, next;
      if (remaining <= pageSize - PageDataOverflow.START_LAST) {
        type=Page.TYPE_DATA_OVERFLOW | Page.FLAG_LAST;
        size=remaining;
        next=0;
      }
 else {
        type=Page.TYPE_DATA_OVERFLOW;
        size=pageSize - PageDataOverflow.START_MORE;
        next=index.getPageStore().allocatePage();
      }
      PageDataOverflow overflow=PageDataOverflow.create(index.getPageStore(),page,type,previous,next,all,dataOffset,size);
      index.getPageStore().updateRecord(overflow,true,null);
      dataOffset+=size;
      remaining-=size;
      previous=page;
      page=next;
    }
 while (remaining > 0);
  }
  return -1;
}","int addRowTry(Row row) throws SQLException {
  int rowLength=getRowLength(row);
  int pageSize=index.getPageStore().getPageSize();
  int last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
  int keyOffsetPairLen=2 + data.getVarLongLen(row.getKey());
  if (entryCount > 0 && last - rowLength < start + keyOffsetPairLen) {
    int x=find(row.getKey());
    if (entryCount > 1) {
      if (entryCount < 5) {
        return entryCount / 2;
      }
      int third=entryCount / 3;
      return x < third ? third : x >= 2 * third ? 2 * third : x;
    }
    return x;
  }
  int offset=last - rowLength;
  int[] newOffsets=new int[entryCount + 1];
  long[] newKeys=new long[entryCount + 1];
  Row[] newRows=new Row[entryCount + 1];
  int x;
  if (entryCount == 0) {
    x=0;
  }
 else {
    readAllRows();
    x=find(row.getKey());
    if (x < keys.length && keys[x] == row.getKey()) {
      throw index.getDuplicateKeyException();
    }
    System.arraycopy(offsets,0,newOffsets,0,x);
    System.arraycopy(keys,0,newKeys,0,x);
    System.arraycopy(rows,0,newRows,0,x);
    if (x < entryCount) {
      for (int j=x; j < entryCount; j++) {
        newOffsets[j + 1]=offsets[j] - rowLength;
      }
      System.arraycopy(keys,x,newKeys,x + 1,entryCount - x);
      System.arraycopy(rows,x,newRows,x + 1,entryCount - x);
    }
  }
  written=false;
  last=x == 0 ? pageSize : offsets[x - 1];
  offset=last - rowLength;
  entryCount++;
  start+=keyOffsetPairLen;
  newOffsets[x]=offset;
  newKeys[x]=row.getKey();
  newRows[x]=row;
  memorySize+=row.getMemorySize();
  offsets=newOffsets;
  keys=newKeys;
  rows=newRows;
  index.getPageStore().updateRecord(this,true,data);
  if (offset < start) {
    if (entryCount > 1) {
      Message.throwInternalError();
    }
    start+=4;
    int remaining=rowLength - (pageSize - start);
    offset=start;
    offsets[x]=offset;
    int previous=getPos();
    int dataOffset=pageSize;
    int page=index.getPageStore().allocatePage();
    firstOverflowPageId=page;
    this.overflowRowSize=pageSize + rowLength;
    write();
    rowRef=new SoftReference<Row>(rows[0]);
    rows[0]=null;
    Data all=index.getPageStore().createData();
    all.checkCapacity(data.length());
    all.write(data.getBytes(),0,data.length());
    data.truncate(index.getPageStore().getPageSize());
    do {
      int type, size, next;
      if (remaining <= pageSize - PageDataOverflow.START_LAST) {
        type=Page.TYPE_DATA_OVERFLOW | Page.FLAG_LAST;
        size=remaining;
        next=0;
      }
 else {
        type=Page.TYPE_DATA_OVERFLOW;
        size=pageSize - PageDataOverflow.START_MORE;
        next=index.getPageStore().allocatePage();
      }
      PageDataOverflow overflow=PageDataOverflow.create(index.getPageStore(),page,type,previous,next,all,dataOffset,size);
      index.getPageStore().updateRecord(overflow,true,null);
      dataOffset+=size;
      remaining-=size;
      previous=page;
      page=next;
    }
 while (remaining > 0);
  }
  return -1;
}",0.9971671388101984
16139,"/** 
 * Create a new overflow page.
 * @param store the page store
 * @param page the page id
 * @param type the page type
 * @param parentPageId the parent page id
 * @param next the next page or 0
 * @param all the data
 * @param offset the offset within the data
 * @param size the number of bytes
 * @return the page
 */
static PageDataOverflow create(PageStore store,int page,int type,int parentPageId,int next,Data all,int offset,int size){
  Data data=store.createData();
  PageDataOverflow p=new PageDataOverflow(store,page,data);
  data.writeByte((byte)type);
  data.writeInt(parentPageId);
  if (type == Page.TYPE_DATA_OVERFLOW) {
    data.writeInt(next);
  }
 else {
    data.writeShortInt(size);
  }
  p.start=data.length();
  data.write(all.getBytes(),offset,size);
  p.type=type;
  p.parentPageId=parentPageId;
  p.nextPage=next;
  p.size=size;
  return p;
}","/** 
 * Create a new overflow page.
 * @param store the page store
 * @param page the page id
 * @param type the page type
 * @param parentPageId the parent page id
 * @param next the next page or 0
 * @param all the data
 * @param offset the offset within the data
 * @param size the number of bytes
 * @return the page
 */
static PageDataOverflow create(PageStore store,int page,int type,int parentPageId,int next,Data all,int offset,int size){
  Data data=store.createData();
  PageDataOverflow p=new PageDataOverflow(store,page,data);
  data.writeByte((byte)type);
  data.writeShortInt(0);
  data.writeInt(parentPageId);
  if (type == Page.TYPE_DATA_OVERFLOW) {
    data.writeInt(next);
  }
 else {
    data.writeShortInt(size);
  }
  p.start=data.length();
  data.write(all.getBytes(),offset,size);
  p.type=type;
  p.parentPageId=parentPageId;
  p.nextPage=next;
  p.size=size;
  return p;
}",0.9858677218767664
16140,"private void removeOld() throws SQLException {
  int i=0;
  ObjectArray<CacheObject> changed=ObjectArray.newInstance();
  while (sizeMemory * 4 > maxSize * 3 && recordCount > Constants.CACHE_MIN_RECORDS) {
    i++;
    if (i == recordCount) {
      writer.flushLog();
    }
    if (i >= recordCount * 2) {
      writer.getTrace().info(""String_Node_Str"");
      break;
    }
    CacheObject last=head.next;
    if (SysProperties.CHECK && last == head) {
      Message.throwInternalError(""String_Node_Str"");
    }
    if (!last.canRemove()) {
      removeFromLinkedList(last);
      addToFront(last);
      continue;
    }
    remove(last.getPos());
    if (last.isChanged()) {
      changed.add(last);
    }
  }
  if (changed.size() > 0) {
    CacheObject.sort(changed);
    for (i=0; i < changed.size(); i++) {
      CacheObject rec=changed.get(i);
      writer.writeBack(rec);
    }
  }
}","private void removeOld() throws SQLException {
  int i=0;
  int todoImplementInOtherCachesAsWell;
  ObjectArray<CacheObject> changed=ObjectArray.newInstance();
  int mem=sizeMemory;
  int rc=recordCount;
  while (mem * 4 > maxSize * 3 && rc > Constants.CACHE_MIN_RECORDS) {
    i++;
    if (i == recordCount) {
      writer.flushLog();
    }
    if (i >= recordCount * 2) {
      writer.getTrace().info(""String_Node_Str"");
      break;
    }
    CacheObject last=head.next;
    if (SysProperties.CHECK && last == head) {
      Message.throwInternalError(""String_Node_Str"");
    }
    if (!last.canRemove()) {
      removeFromLinkedList(last);
      addToFront(last);
      continue;
    }
    if (last.isChanged()) {
      changed.add(last);
    }
 else {
      remove(last.getPos());
    }
    rc--;
    mem-=last.getMemorySize();
  }
  if (changed.size() > 0) {
    CacheObject.sort(changed);
    for (i=0; i < changed.size(); i++) {
      CacheObject rec=changed.get(i);
      writer.writeBack(rec);
    }
    for (i=0; i < changed.size(); i++) {
      CacheObject rec=changed.get(i);
      remove(rec.getPos());
    }
  }
}",0.8095238095238095
16141,"private String getDeadlockDetails(ObjectArray<Session> sessions){
  StatementBuilder buff=new StatementBuilder();
  for (  Session s : sessions) {
    Table lock=s.getWaitForLock();
    buff.append(""String_Node_Str"").append(s.toString()).append(""String_Node_Str"").append(lock.toString()).append(""String_Node_Str"");
    for (    Table t : s.getLocks()) {
      buff.appendExceptFirst(""String_Node_Str"");
      buff.append(t.toString());
      if (t instanceof TableData) {
        if (((TableData)t).lockExclusive == s) {
          buff.append(""String_Node_Str"");
        }
 else {
          buff.append(""String_Node_Str"");
        }
      }
    }
    buff.append('.');
  }
  return buff.toString();
}","private String getDeadlockDetails(ObjectArray<Session> sessions){
  StringBuilder buff=new StringBuilder();
  for (  Session s : sessions) {
    Table lock=s.getWaitForLock();
    buff.append(""String_Node_Str"").append(s.toString()).append(""String_Node_Str"").append(lock.toString()).append(""String_Node_Str"");
    int i=0;
    for (    Table t : s.getLocks()) {
      if (i++ > 0) {
        buff.append(""String_Node_Str"");
      }
      buff.append(t.toString());
      if (t instanceof TableData) {
        if (((TableData)t).lockExclusive == s) {
          buff.append(""String_Node_Str"");
        }
 else {
          buff.append(""String_Node_Str"");
        }
      }
    }
    buff.append('.');
  }
  return buff.toString();
}",0.9306236860546602
16142,"int addRowTry(Row row) throws SQLException {
  int rowLength=row.getByteCount(data);
  int pageSize=index.getPageStore().getPageSize();
  int last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
  if (entryCount > 0 && last - rowLength < start + KEY_OFFSET_PAIR_LENGTH) {
    if (entryCount > 1) {
      return entryCount / 2;
    }
    int todoIncorrect;
    if (find(row.getPos()) != 1) {
      System.out.println(""String_Node_Str"" + find(row.getPos()));
    }
    return 1;
  }
  int offset=last - rowLength;
  int[] newOffsets=new int[entryCount + 1];
  int[] newKeys=new int[entryCount + 1];
  Row[] newRows=new Row[entryCount + 1];
  int x;
  if (entryCount == 0) {
    x=0;
  }
 else {
    readAllRows();
    x=find(row.getPos());
    if (SysProperties.CHECK && x < keys.length && keys[x] == row.getPos()) {
      throw Message.throwInternalError(""String_Node_Str"" + row.getPos());
    }
    System.arraycopy(offsets,0,newOffsets,0,x);
    System.arraycopy(keys,0,newKeys,0,x);
    System.arraycopy(rows,0,newRows,0,x);
    if (x < entryCount) {
      for (int j=x; j < entryCount; j++) {
        newOffsets[j + 1]=offsets[j] - rowLength;
      }
      System.arraycopy(keys,x,newKeys,x + 1,entryCount - x);
      System.arraycopy(rows,x,newRows,x + 1,entryCount - x);
    }
  }
  written=false;
  last=x == 0 ? pageSize : offsets[x - 1];
  offset=last - rowLength;
  entryCount++;
  start+=KEY_OFFSET_PAIR_LENGTH;
  newOffsets[x]=offset;
  newKeys[x]=row.getPos();
  newRows[x]=row;
  offsets=newOffsets;
  keys=newKeys;
  rows=newRows;
  index.getPageStore().updateRecord(this,true,data);
  if (offset < start) {
    if (entryCount > 1) {
      Message.throwInternalError();
    }
    start+=4;
    int remaining=rowLength - (pageSize - start);
    offset=start;
    offsets[x]=offset;
    int previous=getPos();
    int dataOffset=pageSize;
    int page=index.getPageStore().allocatePage();
    firstOverflowPageId=page;
    this.overflowRowSize=pageSize + rowLength;
    write();
    rowRef=new SoftReference<Row>(rows[0]);
    rows[0]=null;
    do {
      int type, size, next;
      if (remaining <= pageSize - PageDataOverflow.START_LAST) {
        type=Page.TYPE_DATA_OVERFLOW | Page.FLAG_LAST;
        size=remaining;
        next=0;
      }
 else {
        type=Page.TYPE_DATA_OVERFLOW;
        size=pageSize - PageDataOverflow.START_MORE;
        next=index.getPageStore().allocatePage();
      }
      PageDataOverflow overflow=new PageDataOverflow(this,page,type,previous,next,data,dataOffset,size);
      index.getPageStore().updateRecord(overflow,true,null);
      dataOffset+=size;
      remaining-=size;
      previous=page;
      page=next;
    }
 while (remaining > 0);
    data.truncate(index.getPageStore().getPageSize());
  }
  return -1;
}","int addRowTry(Row row) throws SQLException {
  int rowLength=row.getByteCount(data);
  int pageSize=index.getPageStore().getPageSize();
  int last=entryCount == 0 ? pageSize : offsets[entryCount - 1];
  if (entryCount > 0 && last - rowLength < start + KEY_OFFSET_PAIR_LENGTH) {
    if (entryCount > 1) {
      return entryCount / 2;
    }
    return find(row.getPos());
  }
  int offset=last - rowLength;
  int[] newOffsets=new int[entryCount + 1];
  int[] newKeys=new int[entryCount + 1];
  Row[] newRows=new Row[entryCount + 1];
  int x;
  if (entryCount == 0) {
    x=0;
  }
 else {
    readAllRows();
    x=find(row.getPos());
    if (SysProperties.CHECK && x < keys.length && keys[x] == row.getPos()) {
      throw Message.throwInternalError(""String_Node_Str"" + row.getPos());
    }
    System.arraycopy(offsets,0,newOffsets,0,x);
    System.arraycopy(keys,0,newKeys,0,x);
    System.arraycopy(rows,0,newRows,0,x);
    if (x < entryCount) {
      for (int j=x; j < entryCount; j++) {
        newOffsets[j + 1]=offsets[j] - rowLength;
      }
      System.arraycopy(keys,x,newKeys,x + 1,entryCount - x);
      System.arraycopy(rows,x,newRows,x + 1,entryCount - x);
    }
  }
  written=false;
  last=x == 0 ? pageSize : offsets[x - 1];
  offset=last - rowLength;
  entryCount++;
  start+=KEY_OFFSET_PAIR_LENGTH;
  newOffsets[x]=offset;
  newKeys[x]=row.getPos();
  newRows[x]=row;
  offsets=newOffsets;
  keys=newKeys;
  rows=newRows;
  index.getPageStore().updateRecord(this,true,data);
  if (offset < start) {
    if (entryCount > 1) {
      Message.throwInternalError();
    }
    start+=4;
    int remaining=rowLength - (pageSize - start);
    offset=start;
    offsets[x]=offset;
    int previous=getPos();
    int dataOffset=pageSize;
    int page=index.getPageStore().allocatePage();
    firstOverflowPageId=page;
    this.overflowRowSize=pageSize + rowLength;
    write();
    rowRef=new SoftReference<Row>(rows[0]);
    rows[0]=null;
    do {
      int type, size, next;
      if (remaining <= pageSize - PageDataOverflow.START_LAST) {
        type=Page.TYPE_DATA_OVERFLOW | Page.FLAG_LAST;
        size=remaining;
        next=0;
      }
 else {
        type=Page.TYPE_DATA_OVERFLOW;
        size=pageSize - PageDataOverflow.START_MORE;
        next=index.getPageStore().allocatePage();
      }
      PageDataOverflow overflow=new PageDataOverflow(this,page,type,previous,next,data,dataOffset,size);
      index.getPageStore().updateRecord(overflow,true,null);
      dataOffset+=size;
      remaining-=size;
      previous=page;
      page=next;
    }
 while (remaining > 0);
    data.truncate(index.getPageStore().getPageSize());
  }
  return -1;
}",0.9703880816626816
16143,"private void removeRow(int i) throws SQLException {
  written=false;
  readAllRows();
  entryCount--;
  if (entryCount <= 0) {
    Message.throwInternalError();
  }
  int[] newOffsets=new int[entryCount];
  int[] newKeys=new int[entryCount];
  Row[] newRows=new Row[entryCount];
  System.arraycopy(offsets,0,newOffsets,0,i);
  System.arraycopy(keys,0,newKeys,0,i);
  System.arraycopy(rows,0,newRows,0,i);
  int startNext=i > 0 ? offsets[i - 1] : index.getPageStore().getPageSize();
  int rowLength=startNext - offsets[i];
  for (int j=i; j < entryCount; j++) {
    newOffsets[j]=offsets[j + 1] + rowLength;
  }
  System.arraycopy(keys,i + 1,newKeys,i,entryCount - i);
  System.arraycopy(rows,i + 1,newRows,i,entryCount - i);
  start-=KEY_OFFSET_PAIR_LENGTH;
  offsets=newOffsets;
  keys=newKeys;
  rows=newRows;
}","private void removeRow(int i) throws SQLException {
  written=false;
  readAllRows();
  entryCount--;
  if (entryCount < 0) {
    Message.throwInternalError();
  }
  int[] newOffsets=new int[entryCount];
  int[] newKeys=new int[entryCount];
  Row[] newRows=new Row[entryCount];
  System.arraycopy(offsets,0,newOffsets,0,i);
  System.arraycopy(keys,0,newKeys,0,i);
  System.arraycopy(rows,0,newRows,0,i);
  int startNext=i > 0 ? offsets[i - 1] : index.getPageStore().getPageSize();
  int rowLength=startNext - offsets[i];
  for (int j=i; j < entryCount; j++) {
    newOffsets[j]=offsets[j + 1] + rowLength;
  }
  System.arraycopy(keys,i + 1,newKeys,i,entryCount - i);
  System.arraycopy(rows,i + 1,newRows,i,entryCount - i);
  start-=KEY_OFFSET_PAIR_LENGTH;
  offsets=newOffsets;
  keys=newKeys;
  rows=newRows;
}",0.9993846153846154
16144,"/** 
 * Set all pages as 'allocated' in the page store.
 */
void allocateAllPages() throws SQLException {
  int trunkPage=trunkNext;
  while (trunkPage != 0) {
    store.allocatePage(trunkPage);
    PageStreamTrunk t=new PageStreamTrunk(store,trunkPage);
    t.read();
    while (true) {
      int n=t.getNextPageData();
      if (n == -1) {
        break;
      }
      store.allocatePage(n);
    }
    trunkPage=t.getNextTrunk();
  }
}","/** 
 * Set all pages as 'allocated' in the page store.
 * @return the bit set
 */
BitField allocateAllPages() throws SQLException {
  BitField pages=new BitField();
  int trunkPage=trunkNext;
  while (trunkPage != 0) {
    pages.set(trunkPage);
    store.allocatePage(trunkPage);
    PageStreamTrunk t=new PageStreamTrunk(store,trunkPage);
    t.read();
    while (true) {
      int n=t.getNextPageData();
      if (n == -1) {
        break;
      }
      pages.set(n);
      store.allocatePage(n);
    }
    trunkPage=t.getNextTrunk();
  }
  return pages;
}",0.8714859437751004
16145,"/** 
 * Switch to a new log id.
 */
void checkpoint() throws SQLException {
  try {
    out.write(CHECKPOINT);
    flushOut();
  }
 catch (  IOException e) {
    throw Message.convertIOException(e,null);
  }
  undo=new BitField();
  logId++;
  pageOut.fillPage();
  int currentDataPage=pageOut.getCurrentDataPageId();
  logIdPageMap.put(logId,currentDataPage);
}","/** 
 * Switch to a new log id.
 */
void checkpoint() throws SQLException {
  try {
    out.write(CHECKPOINT);
    flushOut();
  }
 catch (  IOException e) {
    throw Message.convertIOException(e,null);
  }
  undo=new BitField();
  logSectionId++;
  pageOut.fillPage();
  int currentDataPage=pageOut.getCurrentDataPageId();
  logSectionPageMap.put(logSectionId,currentDataPage);
}",0.9690444145356664
16146,"/** 
 * Open the log for writing. For an existing database, the recovery must be run first.
 * @param firstTrunkPage the first trunk page
 */
void openForWriting(int firstTrunkPage) throws SQLException {
  trace.debug(""String_Node_Str"" + firstTrunkPage);
  this.firstTrunkPage=firstTrunkPage;
  pageOut=new PageOutputStream(store,firstTrunkPage);
  pageOut.reserve(1);
  store.setLogFirstPage(firstTrunkPage,pageOut.getCurrentDataPageId());
  buffer=new ByteArrayOutputStream();
  out=new DataOutputStream(buffer);
}","/** 
 * Open the log for writing. For an existing database, the recovery must be run first.
 * @param firstTrunkPage the first trunk page
 */
void openForWriting(int firstTrunkPage) throws SQLException {
  trace.debug(""String_Node_Str"" + firstTrunkPage);
  this.firstTrunkPage=firstTrunkPage;
  pageOut=new PageOutputStream(store,firstTrunkPage,undoAll);
  pageOut.reserve(1);
  store.setLogFirstPage(firstTrunkPage,pageOut.getCurrentDataPageId());
  buffer=new ByteArrayOutputStream();
  out=new DataOutputStream(buffer);
}",0.9923076923076924
16147,"/** 
 * A table is truncated.
 * @param session the session
 * @param tableId the table id
 */
void logTruncate(Session session,int tableId) throws SQLException {
  try {
    if (trace.isDebugEnabled()) {
      trace.debug(""String_Node_Str"" + session.getId() + ""String_Node_Str""+ tableId);
    }
    session.addLogPos(logId,logPos);
    data.reset();
    out.write(TRUNCATE);
    out.writeInt(session.getId());
    out.writeInt(tableId);
    flushOut();
  }
 catch (  IOException e) {
    throw Message.convertIOException(e,null);
  }
}","/** 
 * A table is truncated.
 * @param session the session
 * @param tableId the table id
 */
void logTruncate(Session session,int tableId) throws SQLException {
  try {
    if (trace.isDebugEnabled()) {
      trace.debug(""String_Node_Str"" + session.getId() + ""String_Node_Str""+ tableId);
    }
    session.addLogPos(logSectionId,logPos);
    data.reset();
    out.write(TRUNCATE);
    out.writeInt(session.getId());
    out.writeInt(tableId);
    flushOut();
  }
 catch (  IOException e) {
    throw Message.convertIOException(e,null);
  }
}",0.9935125115848008
16148,"/** 
 * Run one recovery stage. There are three recovery stages: 0: only the undo steps are run (restoring the state before the last checkpoint). 1: the pages that are used by the transaction log are allocated. 2: the committed operations are re-applied.
 * @param stage the recovery stage
 */
void recover(int stage) throws SQLException {
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"" + stage);
  }
  if (stage == RECOVERY_STAGE_ALLOCATE) {
    PageInputStream in=new PageInputStream(store,firstTrunkPage,firstDataPage);
    in.allocateAllPages();
    return;
  }
  pageIn=new PageInputStream(store,firstTrunkPage,firstDataPage);
  in=new DataInputStream(pageIn);
  int logId=0;
  Data data=store.createData();
  try {
    pos=0;
    while (true) {
      int x=in.read();
      if (x < 0) {
        break;
      }
      pos++;
      if (x == UNDO) {
        int pageId=in.readInt();
        in.readFully(data.getBytes(),0,store.getPageSize());
        if (stage == RECOVERY_STAGE_UNDO) {
          if (!undo.get(pageId)) {
            if (trace.isDebugEnabled()) {
              trace.debug(""String_Node_Str"" + pageId);
            }
            store.writePage(pageId,data);
            undo.set(pageId);
          }
        }
      }
 else       if (x == ADD || x == REMOVE) {
        int sessionId=in.readInt();
        int tableId=in.readInt();
        Row row=readRow(in,data);
        if (stage == RECOVERY_STAGE_UNDO && x == ADD) {
          store.allocateIfHead(pos,tableId,row);
        }
 else         if (stage == RECOVERY_STAGE_REDO) {
          if (isSessionCommitted(sessionId,logId,pos)) {
            if (trace.isDebugEnabled()) {
              trace.debug(""String_Node_Str"" + (x == ADD ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ tableId+ ""String_Node_Str""+ row);
            }
            store.redo(pos,tableId,row,x == ADD);
          }
 else {
            if (trace.isDebugEnabled()) {
              trace.debug(""String_Node_Str"" + sessionId + ""String_Node_Str""+ (x == ADD ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ tableId+ ""String_Node_Str""+ row);
            }
          }
        }
      }
 else       if (x == TRUNCATE) {
        int sessionId=in.readInt();
        int tableId=in.readInt();
        if (stage == RECOVERY_STAGE_REDO) {
          if (isSessionCommitted(sessionId,logId,pos)) {
            if (trace.isDebugEnabled()) {
              trace.debug(""String_Node_Str"" + tableId);
            }
            store.redoTruncate(tableId);
          }
 else {
            if (trace.isDebugEnabled()) {
              trace.debug(""String_Node_Str"" + sessionId + ""String_Node_Str""+ tableId);
            }
          }
        }
      }
 else       if (x == PREPARE_COMMIT) {
        int sessionId=in.readInt();
        int len=in.readInt();
        byte[] t=new byte[len];
        in.readFully(t);
        String transaction=StringUtils.utf8Decode(t);
        if (trace.isDebugEnabled()) {
          trace.debug(""String_Node_Str"" + sessionId + ""String_Node_Str""+ transaction+ ""String_Node_Str""+ pos);
        }
        if (stage == RECOVERY_STAGE_UNDO) {
          int page=pageIn.getDataPage();
          setPrepareCommit(sessionId,page,transaction);
        }
      }
 else       if (x == ROLLBACK) {
        int sessionId=in.readInt();
        if (trace.isDebugEnabled()) {
          trace.debug(""String_Node_Str"" + sessionId + ""String_Node_Str""+ pos);
        }
      }
 else       if (x == COMMIT) {
        int sessionId=in.readInt();
        if (trace.isDebugEnabled()) {
          trace.debug(""String_Node_Str"" + sessionId + ""String_Node_Str""+ pos);
        }
        if (stage == RECOVERY_STAGE_UNDO) {
          setLastCommitForSession(sessionId,logId,pos);
        }
      }
 else       if (x == NOOP) {
      }
 else       if (x == CHECKPOINT) {
        logId++;
      }
 else       if (x == FREE_LOG) {
        int count=in.readInt();
        for (int i=0; i < count; i++) {
          int pageId=in.readInt();
          if (stage == RECOVERY_STAGE_REDO) {
            store.freePage(pageId,false,null);
          }
        }
      }
 else {
        if (trace.isDebugEnabled()) {
          trace.debug(""String_Node_Str"");
          break;
        }
      }
    }
  }
 catch (  EOFException e) {
    trace.debug(""String_Node_Str"" + e.toString());
  }
catch (  IOException e) {
    throw Message.convertIOException(e,""String_Node_Str"");
  }
  undo=new BitField();
}","/** 
 * Run one recovery stage. There are three recovery stages: 0: only the undo steps are run (restoring the state before the last checkpoint). 1: the pages that are used by the transaction log are allocated. 2: the committed operations are re-applied.
 * @param stage the recovery stage
 */
void recover(int stage) throws SQLException {
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"" + stage);
  }
  if (stage == RECOVERY_STAGE_ALLOCATE) {
    PageInputStream in=new PageInputStream(store,firstTrunkPage,firstDataPage);
    usedLogPages=in.allocateAllPages();
    return;
  }
  pageIn=new PageInputStream(store,firstTrunkPage,firstDataPage);
  in=new DataInputStream(pageIn);
  int logId=0;
  Data data=store.createData();
  try {
    pos=0;
    while (true) {
      int x=in.read();
      if (x < 0) {
        break;
      }
      pos++;
      if (x == UNDO) {
        int pageId=in.readInt();
        in.readFully(data.getBytes(),0,store.getPageSize());
        if (stage == RECOVERY_STAGE_UNDO) {
          if (!undo.get(pageId)) {
            if (trace.isDebugEnabled()) {
              trace.debug(""String_Node_Str"" + pageId);
            }
            store.writePage(pageId,data);
            undo.set(pageId);
            undoAll.set(pageId);
          }
        }
      }
 else       if (x == ADD || x == REMOVE) {
        int sessionId=in.readInt();
        int tableId=in.readInt();
        Row row=readRow(in,data);
        if (stage == RECOVERY_STAGE_UNDO && x == ADD) {
          store.allocateIfHead(pos,tableId,row);
        }
 else         if (stage == RECOVERY_STAGE_REDO) {
          if (isSessionCommitted(sessionId,logId,pos)) {
            if (trace.isDebugEnabled()) {
              trace.debug(""String_Node_Str"" + (x == ADD ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ tableId+ ""String_Node_Str""+ row);
            }
            store.redo(pos,tableId,row,x == ADD);
          }
 else {
            if (trace.isDebugEnabled()) {
              trace.debug(""String_Node_Str"" + sessionId + ""String_Node_Str""+ (x == ADD ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ tableId+ ""String_Node_Str""+ row);
            }
          }
        }
      }
 else       if (x == TRUNCATE) {
        int sessionId=in.readInt();
        int tableId=in.readInt();
        if (stage == RECOVERY_STAGE_REDO) {
          if (isSessionCommitted(sessionId,logId,pos)) {
            if (trace.isDebugEnabled()) {
              trace.debug(""String_Node_Str"" + tableId);
            }
            store.redoTruncate(tableId);
          }
 else {
            if (trace.isDebugEnabled()) {
              trace.debug(""String_Node_Str"" + sessionId + ""String_Node_Str""+ tableId);
            }
          }
        }
      }
 else       if (x == PREPARE_COMMIT) {
        int sessionId=in.readInt();
        int len=in.readInt();
        byte[] t=new byte[len];
        in.readFully(t);
        String transaction=StringUtils.utf8Decode(t);
        if (trace.isDebugEnabled()) {
          trace.debug(""String_Node_Str"" + sessionId + ""String_Node_Str""+ transaction+ ""String_Node_Str""+ pos);
        }
        if (stage == RECOVERY_STAGE_UNDO) {
          int page=pageIn.getDataPage();
          setPrepareCommit(sessionId,page,transaction);
        }
      }
 else       if (x == ROLLBACK) {
        int sessionId=in.readInt();
        if (trace.isDebugEnabled()) {
          trace.debug(""String_Node_Str"" + sessionId + ""String_Node_Str""+ pos);
        }
      }
 else       if (x == COMMIT) {
        int sessionId=in.readInt();
        if (trace.isDebugEnabled()) {
          trace.debug(""String_Node_Str"" + sessionId + ""String_Node_Str""+ pos);
        }
        if (stage == RECOVERY_STAGE_UNDO) {
          setLastCommitForSession(sessionId,logId,pos);
        }
      }
 else       if (x == NOOP) {
      }
 else       if (x == CHECKPOINT) {
        logId++;
      }
 else       if (x == FREE_LOG) {
        int count=in.readInt();
        for (int i=0; i < count; i++) {
          int pageId=in.readInt();
          if (stage == RECOVERY_STAGE_REDO) {
            if (!usedLogPages.get(pageId)) {
              store.freePage(pageId,false,null);
            }
          }
        }
      }
 else {
        if (trace.isDebugEnabled()) {
          trace.debug(""String_Node_Str"");
          break;
        }
      }
    }
  }
 catch (  EOFException e) {
    trace.debug(""String_Node_Str"" + e.toString());
  }
catch (  IOException e) {
    throw Message.convertIOException(e,""String_Node_Str"");
  }
  undo=new BitField();
  if (stage == RECOVERY_STAGE_REDO) {
    usedLogPages=null;
  }
}",0.9810864306135914
16149,"/** 
 * A record is added to a table, or removed from a table.
 * @param session the session
 * @param tableId the table id
 * @param row the row to add
 * @param add true if the row is added, false if it is removed
 */
void logAddOrRemoveRow(Session session,int tableId,Row row,boolean add) throws SQLException {
  try {
    if (trace.isDebugEnabled()) {
      trace.debug(""String_Node_Str"" + (add ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ session.getId()+ ""String_Node_Str""+ tableId+ ""String_Node_Str""+ row);
    }
    session.addLogPos(logId,logPos);
    row.setLastLog(logId,logPos);
    data.reset();
    data.checkCapacity(row.getByteCount(data));
    row.write(data);
    out.write(add ? ADD : REMOVE);
    out.writeInt(session.getId());
    out.writeInt(tableId);
    out.writeInt(row.getPos());
    out.writeInt(data.length());
    out.write(data.getBytes(),0,data.length());
    flushOut();
  }
 catch (  IOException e) {
    throw Message.convertIOException(e,null);
  }
}","/** 
 * A record is added to a table, or removed from a table.
 * @param session the session
 * @param tableId the table id
 * @param row the row to add
 * @param add true if the row is added, false if it is removed
 */
void logAddOrRemoveRow(Session session,int tableId,Row row,boolean add) throws SQLException {
  try {
    if (trace.isDebugEnabled()) {
      trace.debug(""String_Node_Str"" + (add ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ session.getId()+ ""String_Node_Str""+ tableId+ ""String_Node_Str""+ row);
    }
    session.addLogPos(logSectionId,logPos);
    row.setLastLog(logSectionId,logPos);
    data.reset();
    data.checkCapacity(row.getByteCount(data));
    row.write(data);
    out.write(add ? ADD : REMOVE);
    out.writeInt(session.getId());
    out.writeInt(tableId);
    out.writeInt(row.getPos());
    out.writeInt(data.length());
    out.write(data.getBytes(),0,data.length());
    flushOut();
  }
 catch (  IOException e) {
    throw Message.convertIOException(e,null);
  }
}",0.9930693069306932
16150,"/** 
 * Add an undo entry to the log. The page data is only written once until the next checkpoint.
 * @param pageId the page id
 * @param page the old page data
 */
void addUndo(int pageId,Data page) throws SQLException {
  try {
    if (undo.get(pageId)) {
      return;
    }
    if (trace.isDebugEnabled()) {
      trace.debug(""String_Node_Str"" + pageId);
    }
    undo.set(pageId);
    out.write(UNDO);
    out.writeInt(pageId);
    out.write(page.getBytes(),0,store.getPageSize());
    flushOut();
  }
 catch (  IOException e) {
    throw Message.convertIOException(e,null);
  }
}","/** 
 * Add an undo entry to the log. The page data is only written once until the next checkpoint.
 * @param pageId the page id
 * @param page the old page data
 */
void addUndo(int pageId,Data page) throws SQLException {
  try {
    if (undo.get(pageId)) {
      return;
    }
    if (trace.isDebugEnabled()) {
      trace.debug(""String_Node_Str"" + pageId);
    }
    undo.set(pageId);
    undoAll.set(pageId);
    out.write(UNDO);
    out.writeInt(pageId);
    out.write(page.getBytes(),0,store.getPageSize());
    flushOut();
  }
 catch (  IOException e) {
    throw Message.convertIOException(e,null);
  }
}",0.9791492910758964
16151,"/** 
 * Allocate the required pages so that no pages need to be allocated while writing.
 * @param minBuffer the number of bytes to allocate
 */
void reserve(int minBuffer) throws SQLException {
  if (reserved < minBuffer) {
    int pageSize=store.getPageSize();
    int capacityPerPage=PageStreamData.getCapacity(pageSize);
    int pages=PageStreamTrunk.getPagesAddressed(pageSize);
    int pagesToAllocate=pages;
    int totalCapacity=pages * capacityPerPage;
    while (totalCapacity < minBuffer) {
      pagesToAllocate+=pagesToAllocate;
      totalCapacity+=totalCapacity;
    }
    pagesToAllocate++;
    for (int i=0; i < pagesToAllocate; i++) {
      int page=store.allocatePage();
      reservedPages.add(page);
    }
    reserved+=totalCapacity;
    if (data == null) {
      initNextData();
    }
  }
}","/** 
 * Allocate the required pages so that no pages need to be allocated while writing.
 * @param minBuffer the number of bytes to allocate
 */
void reserve(int minBuffer) throws SQLException {
  if (reserved < minBuffer) {
    int pageSize=store.getPageSize();
    int capacityPerPage=PageStreamData.getCapacity(pageSize);
    int pages=PageStreamTrunk.getPagesAddressed(pageSize);
    int pagesToAllocate=pages;
    int totalCapacity=pages * capacityPerPage;
    while (totalCapacity < minBuffer) {
      pagesToAllocate+=pagesToAllocate;
      totalCapacity+=totalCapacity;
    }
    pagesToAllocate++;
    store.allocatePages(reservedPages,pagesToAllocate,exclude);
    reserved+=totalCapacity;
    if (data == null) {
      initNextData();
    }
  }
}",0.8318471337579618
16152,"/** 
 * Create a new page output stream.
 * @param store the page store
 * @param trunkPage the first trunk page (already allocated)
 */
public PageOutputStream(PageStore store,int trunkPage){
  this.trace=store.getTrace();
  this.store=store;
  this.trunkPageId=trunkPage;
}","/** 
 * Create a new page output stream.
 * @param store the page store
 * @param trunkPage the first trunk page (already allocated)
 */
public PageOutputStream(PageStore store,int trunkPage,BitField exclude){
  this.trace=store.getTrace();
  this.store=store;
  this.trunkPageId=trunkPage;
  this.exclude=exclude;
}",0.9306260575296108
16153,"private void process(File file) throws IOException {
  String name=file.getCanonicalPath();
  if (name.endsWith(""String_Node_Str"")) {
    return;
  }
  if (name.indexOf(""String_Node_Str"") > 0 && name.indexOf(""String_Node_Str"") < 0) {
    return;
  }
  if (file.isDirectory()) {
    for (    File f : file.listFiles()) {
      process(f);
    }
  }
 else {
    String fileName=file.getAbsolutePath();
    int idx=fileName.lastIndexOf('.');
    String suffix;
    if (idx < 0) {
      suffix=""String_Node_Str"";
    }
 else {
      suffix=fileName.substring(idx + 1);
    }
    boolean ignore=false;
    for (    String s : IGNORE) {
      if (s.equals(suffix)) {
        ignore=true;
        break;
      }
    }
    if (fileName.endsWith(IGNORE_FILE)) {
      ignore=true;
    }
    if (ignore) {
      return;
    }
    boolean ok=false;
    for (    String s : SUFFIX) {
      if (s.equals(suffix)) {
        ok=true;
        break;
      }
    }
    if (!ok) {
      throw new IOException(""String_Node_Str"" + suffix + ""String_Node_Str""+ fileName);
    }
    String text=new String(BuildBase.readFile(file));
    if (fileName.endsWith(""String_Node_Str"")) {
      addToDictionary=true;
    }
 else {
      addToDictionary=false;
    }
    scan(fileName,text);
  }
}","/** 
 * Searches for spelling errors in the source and documentation 
 */
private void process(File file) throws IOException {
  String name=file.getCanonicalPath();
  if (name.endsWith(""String_Node_Str"")) {
    return;
  }
  if (file.getCanonicalFile().getName().startsWith(""String_Node_Str"") && name.indexOf(""String_Node_Str"") < 0) {
    return;
  }
  if (file.isDirectory()) {
    for (    File f : file.listFiles()) {
      process(f);
    }
  }
 else {
    String fileName=file.getAbsolutePath();
    int idx=fileName.lastIndexOf('.');
    String suffix;
    if (idx < 0) {
      suffix=""String_Node_Str"";
    }
 else {
      suffix=fileName.substring(idx + 1);
    }
    boolean ignore=false;
    for (    String s : IGNORE) {
      if (s.equals(suffix)) {
        ignore=true;
        break;
      }
    }
    for (int i=0; i < IGNORE_FILES.length; i++) {
      if (fileName.endsWith(IGNORE_FILES[i])) {
        ignore=true;
        break;
      }
    }
    if (ignore) {
      return;
    }
    boolean ok=false;
    for (    String s : SUFFIX) {
      if (s.equals(suffix)) {
        ok=true;
        break;
      }
    }
    if (!ok) {
      throw new IOException(""String_Node_Str"" + suffix + ""String_Node_Str""+ fileName);
    }
    String text=new String(BuildBase.readFile(file));
    if (fileName.endsWith(""String_Node_Str"")) {
      addToDictionary=true;
    }
 else {
      addToDictionary=false;
    }
    scan(fileName,text);
  }
}",0.903059343899742
16154,"int addRowTry(SearchRow row) throws SQLException {
  while (true) {
    int x=find(row,false,false);
    PageBtree page=index.getPage(childPageIds[x]);
    int splitPoint=page.addRowTry(row);
    if (splitPoint == 0) {
      break;
    }
    SearchRow pivot=page.getRow(splitPoint - 1);
    int splitPoint2=addChildTry(pivot);
    if (splitPoint2 != 0) {
      return splitPoint2;
    }
    PageBtree page2=page.split(splitPoint);
    addChild(x,page2.getPos(),pivot);
    index.getPageStore().updateRecord(page,true,page.data);
    index.getPageStore().updateRecord(page2,true,page2.data);
    index.getPageStore().updateRecord(this,true,data);
  }
  updateRowCount(1);
  written=false;
  return 0;
}","int addRowTry(SearchRow row) throws SQLException {
  while (true) {
    int x=find(row,false,false);
    PageBtree page=index.getPage(childPageIds[x]);
    int splitPoint=page.addRowTry(row);
    if (splitPoint == 0) {
      break;
    }
    SearchRow pivot=page.getRow(splitPoint - 1);
    int splitPoint2=addChildTry(pivot);
    if (splitPoint2 != 0) {
      return splitPoint2;
    }
    PageBtree page2=page.split(splitPoint);
    readAllRows();
    addChild(x,page2.getPos(),pivot);
    index.getPageStore().updateRecord(page,true,page.data);
    index.getPageStore().updateRecord(page2,true,page2.data);
    index.getPageStore().updateRecord(this,true,data);
  }
  updateRowCount(1);
  written=false;
  return 0;
}",0.9866291344123856
16155,"private void fillBuffer() throws SQLException {
  if (remaining > 0 || endOfFile) {
    return;
  }
  if (trunkNext == 0) {
    endOfFile=true;
    return;
  }
  if (trunk == null) {
    trunk=new PageStreamTrunk(store,trunkNext);
    trunk.read();
    trunkNext=trunk.getNextTrunk();
  }
  int next;
  while (true) {
    next=trunk.getNextPageData();
    if (dataPage == -1 || dataPage == next) {
      if (next != -1) {
        break;
      }
      trunk=new PageStreamTrunk(store,trunkNext);
      trunk.read();
      trunkNext=trunk.getNextTrunk();
    }
  }
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"" + next);
  }
  dataPage=-1;
  data=new PageStreamData(store,next,0);
  data.read();
  remaining=data.getLength();
}","private void fillBuffer() throws SQLException {
  if (remaining > 0 || endOfFile) {
    return;
  }
  if (trunkNext == 0) {
    endOfFile=true;
    return;
  }
  int next;
  while (true) {
    if (trunk == null) {
      trunk=new PageStreamTrunk(store,trunkNext);
      trunk.read();
      trunkNext=trunk.getNextTrunk();
    }
    if (trunk != null) {
      next=trunk.getNextPageData();
      if (next == -1) {
        trunk=null;
      }
 else       if (dataPage == -1 || dataPage == next) {
        break;
      }
    }
  }
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"" + next);
  }
  dataPage=-1;
  data=new PageStreamData(store,next,0);
  data.read();
  remaining=data.getLength();
}",0.755677907777013
16156,"public void test() throws Exception {
  testUniqueIndex();
  testCreateIndexLater();
  testFuzzOperations();
}","public void test() throws Exception {
  testLargeIndex();
  testUniqueIndex();
  testCreateIndexLater();
  testFuzzOperations();
}",0.9166666666666666
16157,"boolean remove(SearchRow row) throws SQLException {
  int at=find(row,false,false);
  PageBtree page=index.getPage(childPageIds[at]);
  boolean empty=page.remove(row);
  updateRowCount(-1);
  if (!empty) {
    return false;
  }
  index.getPageStore().freePage(page.getPos(),true,page.data);
  if (entryCount < 1) {
    return true;
  }
  written=false;
  removeChild(at);
  index.getPageStore().updateRecord(this,true,data);
  return false;
}","boolean remove(SearchRow row) throws SQLException {
  int at=find(row,false,false);
  PageBtree page=index.getPage(childPageIds[at]);
  boolean empty=page.remove(row);
  updateRowCount(-1);
  if (!empty) {
    return false;
  }
  index.getPageStore().freePage(page.getPos(),true,page.data);
  if (entryCount < 1) {
    return true;
  }
  removeChild(at);
  index.getPageStore().updateRecord(this,true,data);
  return false;
}",0.9803921568627452
16158,"PageBtree split(int splitPoint) throws SQLException {
  int newPageId=index.getPageStore().allocatePage();
  PageBtreeNode p2=new PageBtreeNode(index,newPageId,parentPageId,index.getPageStore().createData());
  if (onlyPosition) {
    p2.onlyPosition=true;
  }
  int firstChild=childPageIds[splitPoint];
  for (int i=splitPoint; i < entryCount; ) {
    p2.addChild(p2.entryCount,childPageIds[splitPoint + 1],rows[splitPoint]);
    removeChild(splitPoint);
  }
  int lastChild=childPageIds[splitPoint - 1];
  removeChild(splitPoint - 1);
  childPageIds[splitPoint - 1]=lastChild;
  if (p2.childPageIds == null) {
    p2.childPageIds=new int[1];
  }
  p2.childPageIds[0]=firstChild;
  p2.remapChildren();
  return p2;
}","PageBtree split(int splitPoint) throws SQLException {
  int newPageId=index.getPageStore().allocatePage();
  PageBtreeNode p2=new PageBtreeNode(index,newPageId,parentPageId,index.getPageStore().createData());
  if (onlyPosition) {
    p2.onlyPosition=true;
  }
  int firstChild=childPageIds[splitPoint];
  readAllRows();
  for (int i=splitPoint; i < entryCount; ) {
    p2.addChild(p2.entryCount,childPageIds[splitPoint + 1],rows[splitPoint]);
    removeChild(splitPoint);
  }
  int lastChild=childPageIds[splitPoint - 1];
  removeChild(splitPoint - 1);
  childPageIds[splitPoint - 1]=lastChild;
  if (p2.childPageIds == null) {
    p2.childPageIds=new int[1];
  }
  p2.childPageIds[0]=firstChild;
  p2.remapChildren();
  return p2;
}",0.9882839421088904
16159,"private void removeChild(int i){
  entryCount--;
  if (entryCount < 0) {
    Message.throwInternalError();
  }
  int[] newKeys=MemoryUtils.newInts(entryCount);
  int[] newChildPageIds=new int[entryCount + 1];
  System.arraycopy(keys,0,newKeys,0,Math.min(entryCount,i));
  System.arraycopy(childPageIds,0,newChildPageIds,0,i);
  if (entryCount > i) {
    System.arraycopy(keys,i + 1,newKeys,i,entryCount - i);
  }
  System.arraycopy(childPageIds,i + 1,newChildPageIds,i,entryCount - i + 1);
  keys=newKeys;
  childPageIds=newChildPageIds;
}","private void removeChild(int i){
  written=false;
  entryCount--;
  if (entryCount < 0) {
    Message.throwInternalError();
  }
  int[] newKeys=MemoryUtils.newInts(entryCount);
  int[] newChildPageIds=new int[entryCount + 1];
  System.arraycopy(keys,0,newKeys,0,Math.min(entryCount,i));
  System.arraycopy(childPageIds,0,newChildPageIds,0,i);
  if (entryCount > i) {
    System.arraycopy(keys,i + 1,newKeys,i,entryCount - i);
  }
  System.arraycopy(childPageIds,i + 1,newChildPageIds,i,entryCount - i + 1);
  keys=newKeys;
  childPageIds=newChildPageIds;
}",0.9844748858447488
16160,"private void addChild(int x,int childPageId,int key){
  int[] newKeys=new int[entryCount + 1];
  int[] newChildPageIds=new int[entryCount + 2];
  if (childPageIds != null) {
    System.arraycopy(childPageIds,0,newChildPageIds,0,x + 1);
  }
  if (entryCount > 0) {
    System.arraycopy(keys,0,newKeys,0,x);
    if (x < entryCount) {
      System.arraycopy(keys,x,newKeys,x + 1,entryCount - x);
      System.arraycopy(childPageIds,x,newChildPageIds,x + 1,entryCount - x + 1);
    }
  }
  newKeys[x]=key;
  newChildPageIds[x + 1]=childPageId;
  keys=newKeys;
  childPageIds=newChildPageIds;
  entryCount++;
}","private void addChild(int x,int childPageId,int key){
  written=false;
  int[] newKeys=new int[entryCount + 1];
  int[] newChildPageIds=new int[entryCount + 2];
  if (childPageIds != null) {
    System.arraycopy(childPageIds,0,newChildPageIds,0,x + 1);
  }
  if (entryCount > 0) {
    System.arraycopy(keys,0,newKeys,0,x);
    if (x < entryCount) {
      System.arraycopy(keys,x,newKeys,x + 1,entryCount - x);
      System.arraycopy(childPageIds,x,newChildPageIds,x + 1,entryCount - x + 1);
    }
  }
  newKeys[x]=key;
  newChildPageIds[x + 1]=childPageId;
  keys=newKeys;
  childPageIds=newChildPageIds;
  entryCount++;
}",0.9861450692746536
16161,"public void write(DataPage buff) throws SQLException {
  check();
  data.reset();
  data.writeInt(parentPageId);
  data.writeByte((byte)Page.TYPE_DATA_NODE);
  data.writeShortInt(entryCount);
  data.writeInt(rowCountStored);
  data.writeInt(childPageIds[entryCount]);
  for (int i=0; i < entryCount; i++) {
    data.writeInt(childPageIds[i]);
    data.writeInt(keys[i]);
  }
  index.getPageStore().writePage(getPos(),data);
}","private void write(){
  if (written) {
    return;
  }
  check();
  data.reset();
  data.writeInt(parentPageId);
  data.writeByte((byte)Page.TYPE_DATA_NODE);
  data.writeShortInt(entryCount);
  data.writeInt(rowCountStored);
  data.writeInt(childPageIds[entryCount]);
  for (int i=0; i < entryCount; i++) {
    data.writeInt(childPageIds[i]);
    data.writeInt(keys[i]);
  }
  written=true;
}",0.8102815177478581
16162,"/** 
 * Read the given page.
 * @param id the page id
 * @param parent the parent, or -1 if unknown
 * @return the page
 */
PageData getPage(int id,int parent) throws SQLException {
  Record rec=store.getRecord(id);
  if (rec != null) {
    if (SysProperties.CHECK) {
      PageData result=(PageData)rec;
      if (result.index.headPos != headPos) {
        throw Message.throwInternalError(""String_Node_Str"" + result.index.getName() + ""String_Node_Str""+ result.index.headPos+ ""String_Node_Str""+ getName()+ ""String_Node_Str""+ headPos);
      }
    }
    return (PageData)rec;
  }
  Data data=store.readPage(id);
  data.reset();
  int parentPageId=data.readInt();
  int type=data.readByte() & 255;
  PageData result;
switch (type & ~Page.FLAG_LAST) {
case Page.TYPE_DATA_LEAF:
    result=new PageDataLeaf(this,id,parentPageId,data);
  break;
case Page.TYPE_DATA_NODE:
result=new PageDataNode(this,id,parentPageId,data);
break;
case Page.TYPE_EMPTY:
PageDataLeaf empty=new PageDataLeaf(this,id,parentPageId,data);
return empty;
default :
throw Message.getSQLException(ErrorCode.FILE_CORRUPTED_1,""String_Node_Str"" + id + ""String_Node_Str""+ type);
}
result.read();
if (parent != -1) {
if (result.getParentPageId() != parent) {
throw Message.throwInternalError(result.getParentPageId() + ""String_Node_Str"" + parent+ ""String_Node_Str""+ result);
}
}
return result;
}","/** 
 * Read the given page.
 * @param id the page id
 * @param parent the parent, or -1 if unknown
 * @return the page
 */
PageData getPage(int id,int parent) throws SQLException {
  Record rec=store.getRecord(id);
  if (rec != null) {
    if (SysProperties.CHECK) {
      PageData result=(PageData)rec;
      if (result.index.headPos != headPos) {
        throw Message.throwInternalError(""String_Node_Str"" + result.index.getName() + ""String_Node_Str""+ result.index.headPos+ ""String_Node_Str""+ getName()+ ""String_Node_Str""+ headPos);
      }
    }
    return (PageData)rec;
  }
  Data data=store.readPage(id);
  data.reset();
  int parentPageId=data.readInt();
  int type=data.readByte() & 255;
  PageData result;
switch (type & ~Page.FLAG_LAST) {
case Page.TYPE_DATA_LEAF:
    result=new PageDataLeaf(this,id,parentPageId,data);
  break;
case Page.TYPE_DATA_NODE:
result=new PageDataNode(this,id,parentPageId,data);
break;
case Page.TYPE_EMPTY:
PageDataLeaf empty=new PageDataLeaf(this,id,parentPageId,data);
return empty;
default :
throw Message.getSQLException(ErrorCode.FILE_CORRUPTED_1,""String_Node_Str"" + id + ""String_Node_Str""+ type);
}
result.read();
if (parent != -1) {
if (result.getParentPageId() != parent) {
throw Message.throwInternalError(result + ""String_Node_Str"" + result.getParentPageId()+ ""String_Node_Str""+ parent);
}
}
return result;
}",0.9786607799852832
16163,"private void fillBuffer() throws SQLException {
  if (remaining > 0 || endOfFile) {
    return;
  }
  if (trunkNext == 0) {
    endOfFile=true;
    return;
  }
  if (trunk == null) {
    trunk=new PageStreamTrunk(store,trunkNext);
    trunk.read();
  }
  int next;
  while (true) {
    next=trunk.getNextPageData();
    if (dataPage == -1 || dataPage == next) {
      if (next != 0) {
        break;
      }
      trunk=new PageStreamTrunk(store,trunkNext);
      trunk.read();
    }
  }
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"" + next);
  }
  dataPage=-1;
  data=new PageStreamData(store,next,0);
  data.read();
  remaining=data.getLength();
}","private void fillBuffer() throws SQLException {
  if (remaining > 0 || endOfFile) {
    return;
  }
  if (trunkNext == 0) {
    endOfFile=true;
    return;
  }
  if (trunk == null) {
    trunk=new PageStreamTrunk(store,trunkNext);
    trunk.read();
    trunkNext=trunk.getNextTrunk();
  }
  int next;
  while (true) {
    next=trunk.getNextPageData();
    if (dataPage == -1 || dataPage == next) {
      if (next != -1) {
        break;
      }
      trunk=new PageStreamTrunk(store,trunkNext);
      trunk.read();
      trunkNext=trunk.getNextTrunk();
    }
  }
  if (trace.isDebugEnabled()) {
    trace.debug(""String_Node_Str"" + next);
  }
  dataPage=-1;
  data=new PageStreamData(store,next,0);
  data.read();
  remaining=data.getLength();
}",0.9455060155697098
16164,"/** 
 * Read a page.
 * @param pos the page id
 * @param page the page
 */
void readPage(int pos,Data page) throws SQLException {
synchronized (database) {
    if (pos >= pageCount) {
      throw Message.getSQLException(ErrorCode.FILE_CORRUPTED_1,pos + ""String_Node_Str"" + pageCount);
    }
    file.seek((long)pos << pageSizeShift);
    file.readFully(page.getBytes(),0,pageSize);
  }
}","/** 
 * Read a page.
 * @param pos the page id
 * @param page the page
 */
void readPage(int pos,Data page) throws SQLException {
synchronized (database) {
    if (pos >= pageCount) {
      throw Message.getSQLException(ErrorCode.FILE_CORRUPTED_1,pos + ""String_Node_Str"" + pageCount);
    }
 else     if (pos < 0) {
      throw Message.throwInternalError(""String_Node_Str"" + pos);
    }
    file.seek((long)pos << pageSizeShift);
    file.readFully(page.getBytes(),0,pageSize);
  }
}",0.8896551724137931
16165,"/** 
 * Drop and remove the given local temporary constraint from this session.
 * @param constraint the constraint
 */
public void removeLocalTempTableConstraint(Constraint constraint) throws SQLException {
  if (localTempTableConstraints != null) {
    localTempTableConstraints.remove(constraint.getName());
    constraint.removeChildrenAndResources(this);
  }
}","/** 
 * Drop and remove the given local temporary constraint from this session.
 * @param constraint the constraint
 */
public void removeLocalTempTableConstraint(Constraint constraint) throws SQLException {
  if (localTempTableConstraints != null) {
    localTempTableConstraints.remove(constraint.getName());
synchronized (database) {
      constraint.removeChildrenAndResources(this);
    }
  }
}",0.9554973821989527
16166,"/** 
 * Drop and remove the given local temporary index from this session.
 * @param index the index
 */
public void removeLocalTempTableIndex(Index index) throws SQLException {
  if (localTempTableIndexes != null) {
    localTempTableIndexes.remove(index.getName());
    index.removeChildrenAndResources(this);
  }
}","/** 
 * Drop and remove the given local temporary index from this session.
 * @param index the index
 */
public void removeLocalTempTableIndex(Index index) throws SQLException {
  if (localTempTableIndexes != null) {
    localTempTableIndexes.remove(index.getName());
synchronized (database) {
      index.removeChildrenAndResources(this);
    }
  }
}",0.9491017964071856
16167,"private void cleanTempTables(boolean closeSession) throws SQLException {
  if (localTempTables != null && localTempTables.size() > 0) {
    for (    Table table : ObjectArray.newInstance(localTempTables.values())) {
      if (closeSession || table.getOnCommitDrop()) {
        modificationId++;
        table.setModified();
        localTempTables.remove(table.getName());
        table.removeChildrenAndResources(this);
      }
 else       if (table.getOnCommitTruncate()) {
        table.truncate(this);
      }
    }
  }
}","private void cleanTempTables(boolean closeSession) throws SQLException {
  if (localTempTables != null && localTempTables.size() > 0) {
synchronized (database) {
      for (      Table table : ObjectArray.newInstance(localTempTables.values())) {
        if (closeSession || table.getOnCommitDrop()) {
          modificationId++;
          table.setModified();
          localTempTables.remove(table.getName());
          table.removeChildrenAndResources(this);
        }
 else         if (table.getOnCommitTruncate()) {
          table.truncate(this);
        }
      }
    }
  }
}",0.9493670886075948
16168,"/** 
 * Drop and remove the given local temporary table from this session.
 * @param table the table
 */
public void removeLocalTempTable(Table table) throws SQLException {
  modificationId++;
  localTempTables.remove(table.getName());
  table.removeChildrenAndResources(this);
}","/** 
 * Drop and remove the given local temporary table from this session.
 * @param table the table
 */
public void removeLocalTempTable(Table table) throws SQLException {
  modificationId++;
  localTempTables.remove(table.getName());
synchronized (database) {
    table.removeChildrenAndResources(this);
  }
}",0.9457627118644067
16169,"/** 
 * Add a table to the schema.
 * @param tableName the table name
 * @param id the object id
 * @param columns the column list
 * @param persistIndexes if indexes of the table should be persistent
 * @param persistData if data of the table should be persistent
 * @param clustered if a clustered table should be created
 * @param headPos the position (page number) of the head
 * @param session the session
 * @return the created {@link TableData} object
 */
public TableData createTable(String tableName,int id,ObjectArray<Column> columns,boolean persistIndexes,boolean persistData,boolean clustered,int headPos,Session session) throws SQLException {
  return new TableData(this,tableName,id,columns,persistIndexes,persistData,clustered,headPos,session);
}","/** 
 * Add a table to the schema.
 * @param tableName the table name
 * @param id the object id
 * @param columns the column list
 * @param persistIndexes if indexes of the table should be persistent
 * @param persistData if data of the table should be persistent
 * @param clustered if a clustered table should be created
 * @param headPos the position (page number) of the head
 * @param session the session
 * @return the created {@link TableData} object
 */
public TableData createTable(String tableName,int id,ObjectArray<Column> columns,boolean persistIndexes,boolean persistData,boolean clustered,int headPos,Session session) throws SQLException {
synchronized (database) {
    return new TableData(this,tableName,id,columns,persistIndexes,persistData,clustered,headPos,session);
  }
}",0.9794079794079794
16170,"/** 
 * Add a linked table to the schema.
 * @param id the object id
 * @param tableName the table name of the alias
 * @param driver the driver class name
 * @param url the database URL
 * @param user the user name
 * @param password the password
 * @param originalSchema the schema name of the target table
 * @param originalTable the table name of the target table
 * @param emitUpdates if updates should be emitted instead of delete/insert
 * @param force create the object even if the database can not be accessed
 * @return the {@link TableLink} object
 */
public TableLink createTableLink(int id,String tableName,String driver,String url,String user,String password,String originalSchema,String originalTable,boolean emitUpdates,boolean force) throws SQLException {
  return new TableLink(this,id,tableName,driver,url,user,password,originalSchema,originalTable,emitUpdates,force);
}","/** 
 * Add a linked table to the schema.
 * @param id the object id
 * @param tableName the table name of the alias
 * @param driver the driver class name
 * @param url the database URL
 * @param user the user name
 * @param password the password
 * @param originalSchema the schema name of the target table
 * @param originalTable the table name of the target table
 * @param emitUpdates if updates should be emitted instead of delete/insert
 * @param force create the object even if the database can not be accessed
 * @return the {@link TableLink} object
 */
public TableLink createTableLink(int id,String tableName,String driver,String url,String user,String password,String originalSchema,String originalTable,boolean emitUpdates,boolean force) throws SQLException {
synchronized (database) {
    return new TableLink(this,id,tableName,driver,url,user,password,originalSchema,originalTable,emitUpdates,force);
  }
}",0.9823204419889504
16171,"/** 
 * Set the owner of a page.
 * @param page the page id
 * @param storageId the storage id of this page
 */
public void setPageOwner(int page,int storageId) throws SQLException {
  int old=pageOwners.get(page);
  if (old == storageId) {
    return;
  }
  if (SysProperties.CHECK && old >= 0 && storageId >= 0 && old != storageId) {
    for (int i=0; i < BLOCKS_PER_PAGE; i++) {
      if (used.get(i + page * BLOCKS_PER_PAGE)) {
        Message.throwInternalError(""String_Node_Str"" + fileName + ""String_Node_Str""+ page+ ""String_Node_Str""+ (BLOCKS_PER_PAGE * page)+ ""String_Node_Str""+ (BLOCKS_PER_PAGE * (page + 1) - 1));
      }
    }
  }
  if (old >= 0) {
    database.getStorage(old,this).removePage(page);
    if (!logChanges) {
      writeDirectDeleted(page * BLOCKS_PER_PAGE,BLOCKS_PER_PAGE);
    }
  }
  if (storageId >= 0) {
    database.getStorage(storageId,this).addPage(page);
    if (SysProperties.REUSE_SPACE_QUICKLY) {
      potentiallyFreePages.remove(page);
    }
  }
 else {
    firstFreePage=Math.min(firstFreePage,page);
  }
  pageOwners.set(page,storageId);
}","/** 
 * Set the owner of a page.
 * @param page the page id
 * @param storageId the storage id of this page
 */
public void setPageOwner(int page,int storageId) throws SQLException {
  int old=pageOwners.get(page);
  if (old == storageId) {
    return;
  }
  if (SysProperties.CHECK && old >= 0 && storageId >= 0 && old != storageId) {
    for (int i=0; i < BLOCKS_PER_PAGE; i++) {
      if (used.get(i + page * BLOCKS_PER_PAGE)) {
        Message.throwInternalError(""String_Node_Str"" + fileName + ""String_Node_Str""+ page+ ""String_Node_Str""+ (BLOCKS_PER_PAGE * page)+ ""String_Node_Str""+ (BLOCKS_PER_PAGE * (page + 1) - 1));
      }
    }
  }
  if (old >= 0) {
    database.getStorage(old,this).removePage(page);
    if (!logChanges) {
      writeDirectDeleted(page * BLOCKS_PER_PAGE,BLOCKS_PER_PAGE);
    }
  }
  if (storageId >= 0) {
    database.getStorage(storageId,this).addPage(page);
    if (SysProperties.REUSE_SPACE_QUICKLY) {
synchronized (potentiallyFreePages) {
        potentiallyFreePages.remove(page);
      }
    }
  }
 else {
    firstFreePage=Math.min(firstFreePage,page);
  }
  pageOwners.set(page,storageId);
}",0.9728506787330315
16172,"/** 
 * Free a page, that is, reset the page owner.
 * @param page the page
 */
void freePage(int page) throws SQLException {
  if (!logChanges) {
    setPageOwner(page,FREE_PAGE);
  }
 else {
    if (SysProperties.REUSE_SPACE_QUICKLY) {
      potentiallyFreePages.add(page);
    }
  }
}","/** 
 * Free a page, that is, reset the page owner.
 * @param page the page
 */
void freePage(int page) throws SQLException {
  if (!logChanges) {
    setPageOwner(page,FREE_PAGE);
  }
 else {
    if (SysProperties.REUSE_SPACE_QUICKLY) {
synchronized (potentiallyFreePages) {
        potentiallyFreePages.add(page);
      }
    }
  }
}",0.8810289389067524
16173,"private void reuseSpace() throws SQLException {
  if (SysProperties.REUSE_SPACE_QUICKLY) {
    if (potentiallyFreePages.size() >= SysProperties.REUSE_SPACE_AFTER) {
      Session[] sessions=database.getSessions(true);
      int oldest=0;
      for (int i=0; i < sessions.length; i++) {
        int deleteId=sessions[i].getLastUncommittedDelete();
        if (oldest == 0 || (deleteId != 0 && deleteId < oldest)) {
          oldest=deleteId;
        }
      }
      for (Iterator<Integer> it=potentiallyFreePages.iterator(); it.hasNext(); ) {
        int p=it.next();
        if (oldest == 0) {
          if (isPageFree(p)) {
            setPageOwner(p,FREE_PAGE);
          }
          it.remove();
        }
      }
    }
  }
}","private void reuseSpace() throws SQLException {
  if (SysProperties.REUSE_SPACE_QUICKLY) {
synchronized (potentiallyFreePages) {
      if (potentiallyFreePages.size() >= SysProperties.REUSE_SPACE_AFTER) {
        Session[] sessions=database.getSessions(true);
        int oldest=0;
        for (int i=0; i < sessions.length; i++) {
          int deleteId=sessions[i].getLastUncommittedDelete();
          if (oldest == 0 || (deleteId != 0 && deleteId < oldest)) {
            oldest=deleteId;
          }
        }
        for (Iterator<Integer> it=potentiallyFreePages.iterator(); it.hasNext(); ) {
          int p=it.next();
          if (oldest == 0) {
            if (isPageFree(p)) {
              setPageOwner(p,FREE_PAGE);
            }
            it.remove();
          }
        }
      }
    }
  }
}",0.9466840052015604
16174,"/** 
 * Run all tests with the current settings.
 */
private void test() throws SQLException {
  System.out.println();
  System.out.println(""String_Node_Str"" + toString() + ""String_Node_Str""+ MemoryUtils.getMemoryUsed()+ ""String_Node_Str"");
  beforeTest();
  new TestScriptSimple().runTest(this);
  new TestScript().runTest(this);
  new TestAlter().runTest(this);
  new TestAutoRecompile().runTest(this);
  new TestBackup().runTest(this);
  new TestBigDb().runTest(this);
  new TestBigResult().runTest(this);
  new TestCases().runTest(this);
  new TestCheckpoint().runTest(this);
  new TestCluster().runTest(this);
  new TestCompatibility().runTest(this);
  new TestCsv().runTest(this);
  new TestDeadlock().runTest(this);
  new TestEncryptedDb().runTest(this);
  new TestExclusive().runTest(this);
  new TestFullText().runTest(this);
  new TestFunctions().runTest(this);
  new TestFunctionOverload().runTest(this);
  new TestIndex().runTest(this);
  new TestLinkedTable().runTest(this);
  new TestListener().runTest(this);
  new TestLob().runTest(this);
  new TestLogFile().runTest(this);
  new TestMemoryUsage().runTest(this);
  new TestMultiConn().runTest(this);
  new TestMultiDimension().runTest(this);
  new TestMultiThread().runTest(this);
  new TestOpenClose().runTest(this);
  new TestOptimizations().runTest(this);
  new TestOutOfMemory().runTest(this);
  new TestPowerOff().runTest(this);
  new TestReadOnly().runTest(this);
  new TestRights().runTest(this);
  new TestRunscript().runTest(this);
  new TestSQLInjection().runTest(this);
  new TestSessionsLocks().runTest(this);
  new TestSequence().runTest(this);
  new TestSpaceReuse().runTest(this);
  new TestSpeed().runTest(this);
  new TestTempTables().runTest(this);
  new TestTransaction().runTest(this);
  new TestTriggersConstraints().runTest(this);
  new TestTwoPhaseCommit().runTest(this);
  new TestView().runTest(this);
  new SamplesTest().runTest(this);
  new TestBatchUpdates().runTest(this);
  new TestCallableStatement().runTest(this);
  new TestCancel().runTest(this);
  new TestDatabaseEventListener().runTest(this);
  new TestDriver().runTest(this);
  new TestManyJdbcObjects().runTest(this);
  new TestMetaData().runTest(this);
  new TestNativeSQL().runTest(this);
  new TestPreparedStatement().runTest(this);
  new TestResultSet().runTest(this);
  new TestStatement().runTest(this);
  new TestTransactionIsolation().runTest(this);
  new TestUpdatableResultSet().runTest(this);
  new TestZloty().runTest(this);
  new TestConnectionPool().runTest(this);
  new TestDataSource().runTest(this);
  new TestXA().runTest(this);
  new TestXASimple().runTest(this);
  new TestAutoServer().runTest(this);
  new TestNestedLoop().runTest(this);
  new TestWeb().runTest(this);
  new TestMvcc1().runTest(this);
  new TestMvcc2().runTest(this);
  new TestMvcc3().runTest(this);
  new TestMvccMultiThreaded().runTest(this);
  new TestRowLocks().runTest(this);
  new TestBtreeIndex().runTest(this);
  new TestCrashAPI().runTest(this);
  new TestFuzzOptimizations().runTest(this);
  new TestRandomSQL().runTest(this);
  new TestKillRestart().runTest(this);
  new TestKillRestartMulti().runTest(this);
  new TestMultiThreaded().runTest(this);
  afterTest();
}","/** 
 * Run all tests with the current settings.
 */
private void test() throws SQLException {
  System.out.println();
  System.out.println(""String_Node_Str"" + toString() + ""String_Node_Str""+ MemoryUtils.getMemoryUsed()+ ""String_Node_Str"");
  beforeTest();
  new TestScriptSimple().runTest(this);
  new TestScript().runTest(this);
  new TestAlter().runTest(this);
  new TestAutoRecompile().runTest(this);
  new TestBackup().runTest(this);
  new TestBigDb().runTest(this);
  new TestBigResult().runTest(this);
  new TestCases().runTest(this);
  new TestCheckpoint().runTest(this);
  new TestCluster().runTest(this);
  new TestCompatibility().runTest(this);
  new TestCsv().runTest(this);
  new TestDeadlock().runTest(this);
  new TestEncryptedDb().runTest(this);
  new TestExclusive().runTest(this);
  new TestFullText().runTest(this);
  new TestFunctions().runTest(this);
  new TestFunctionOverload().runTest(this);
  new TestIndex().runTest(this);
  new TestLinkedTable().runTest(this);
  new TestListener().runTest(this);
  new TestLob().runTest(this);
  new TestLogFile().runTest(this);
  new TestMemoryUsage().runTest(this);
  new TestMultiConn().runTest(this);
  new TestMultiDimension().runTest(this);
  new TestMultiThread().runTest(this);
  new TestMultiThreadedKernel().runTest(this);
  new TestOpenClose().runTest(this);
  new TestOptimizations().runTest(this);
  new TestOutOfMemory().runTest(this);
  new TestPowerOff().runTest(this);
  new TestReadOnly().runTest(this);
  new TestRights().runTest(this);
  new TestRunscript().runTest(this);
  new TestSQLInjection().runTest(this);
  new TestSessionsLocks().runTest(this);
  new TestSequence().runTest(this);
  new TestSpaceReuse().runTest(this);
  new TestSpeed().runTest(this);
  new TestTempTables().runTest(this);
  new TestTransaction().runTest(this);
  new TestTriggersConstraints().runTest(this);
  new TestTwoPhaseCommit().runTest(this);
  new TestView().runTest(this);
  new SamplesTest().runTest(this);
  new TestBatchUpdates().runTest(this);
  new TestCallableStatement().runTest(this);
  new TestCancel().runTest(this);
  new TestDatabaseEventListener().runTest(this);
  new TestDriver().runTest(this);
  new TestManyJdbcObjects().runTest(this);
  new TestMetaData().runTest(this);
  new TestNativeSQL().runTest(this);
  new TestPreparedStatement().runTest(this);
  new TestResultSet().runTest(this);
  new TestStatement().runTest(this);
  new TestTransactionIsolation().runTest(this);
  new TestUpdatableResultSet().runTest(this);
  new TestZloty().runTest(this);
  new TestConnectionPool().runTest(this);
  new TestDataSource().runTest(this);
  new TestXA().runTest(this);
  new TestXASimple().runTest(this);
  new TestAutoServer().runTest(this);
  new TestNestedLoop().runTest(this);
  new TestWeb().runTest(this);
  new TestMvcc1().runTest(this);
  new TestMvcc2().runTest(this);
  new TestMvcc3().runTest(this);
  new TestMvccMultiThreaded().runTest(this);
  new TestRowLocks().runTest(this);
  new TestBtreeIndex().runTest(this);
  new TestCrashAPI().runTest(this);
  new TestFuzzOptimizations().runTest(this);
  new TestRandomSQL().runTest(this);
  new TestKillRestart().runTest(this);
  new TestKillRestartMulti().runTest(this);
  new TestMultiThreaded().runTest(this);
  afterTest();
}",0.9927569733394976
16175,"private synchronized void open(int traceLevelFile,int traceLevelSystemOut) throws SQLException {
  if (persistent) {
    String pageFileName=databaseName + Constants.SUFFIX_PAGE_FILE;
    boolean exists=FileUtils.exists(pageFileName);
    if (exists) {
      usePageStore=true;
    }
    if (usePageStore) {
      if (exists && FileUtils.isReadOnly(pageFileName)) {
        readOnly=true;
      }
    }
 else {
      String dataFileName=databaseName + Constants.SUFFIX_DATA_FILE;
      exists=FileUtils.exists(dataFileName);
      if (FileUtils.exists(dataFileName)) {
        readOnly=readOnly | FileUtils.isReadOnly(dataFileName);
      }
    }
    if (readOnly) {
      traceSystem=new TraceSystem(null,false);
    }
 else {
      traceSystem=new TraceSystem(databaseName + Constants.SUFFIX_TRACE_FILE,true);
    }
    traceSystem.setLevelFile(traceLevelFile);
    traceSystem.setLevelSystemOut(traceLevelSystemOut);
    traceSystem.getTrace(Trace.DATABASE).info(""String_Node_Str"" + databaseName + ""String_Node_Str""+ Constants.BUILD_ID+ ""String_Node_Str"");
    if (autoServerMode) {
      if (readOnly || fileLockMethod == FileLock.LOCK_NO) {
        throw Message.getUnsupportedException(""String_Node_Str"");
      }
    }
    if (!readOnly && fileLockMethod != FileLock.LOCK_NO) {
      lock=new FileLock(traceSystem,databaseName + Constants.SUFFIX_LOCK_FILE,Constants.LOCK_SLEEP);
      lock.lock(fileLockMethod);
      if (autoServerMode) {
        startServer(lock.getUniqueId());
      }
    }
    isReconnectNeeded();
    while (!beforeWriting()) {
    }
    if (exists) {
      lobFilesInDirectories&=!ValueLob.existsLobFile(getDatabasePath());
      lobFilesInDirectories|=FileUtils.exists(databaseName + Constants.SUFFIX_LOBS_DIRECTORY);
    }
    dummy=DataPage.create(this,0);
    deleteOldTempFiles();
    if (usePageStore) {
      starting=true;
      getPageStore();
      starting=false;
    }
    log=new LogSystem(this,databaseName,readOnly,accessModeLog,pageStore);
    if (pageStore == null) {
      openFileData();
      log.open();
      openFileIndex();
      log.recover();
      fileData.init();
      try {
        fileIndex.init();
      }
 catch (      Exception e) {
        if (recovery) {
          traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
          for (          Storage s : New.arrayList(storageMap.values())) {
            if (s.getDiskFile() == fileIndex) {
              removeStorage(s.getId(),fileIndex);
            }
          }
          fileIndex.delete();
          openFileIndex();
        }
 else {
          throw Message.convert(e);
        }
      }
    }
    reserveLobFileObjectIds();
    writer=WriterThread.create(this,writeDelay);
  }
 else {
    traceSystem=new TraceSystem(null,false);
    log=new LogSystem(null,null,false,null,null);
  }
  systemUser=new User(this,0,Constants.DBA_NAME,true);
  mainSchema=new Schema(this,0,Constants.SCHEMA_MAIN,systemUser,true);
  infoSchema=new Schema(this,-1,Constants.SCHEMA_INFORMATION,systemUser,true);
  schemas.put(mainSchema.getName(),mainSchema);
  schemas.put(infoSchema.getName(),infoSchema);
  publicRole=new Role(this,0,Constants.PUBLIC_ROLE_NAME,true);
  roles.put(Constants.PUBLIC_ROLE_NAME,publicRole);
  systemUser.setAdmin(true);
  systemSession=new Session(this,systemUser,++nextSessionId);
  ObjectArray<Column> cols=ObjectArray.newInstance();
  Column columnId=new Column(""String_Node_Str"",Value.INT);
  columnId.setNullable(false);
  cols.add(columnId);
  cols.add(new Column(""String_Node_Str"",Value.INT));
  cols.add(new Column(""String_Node_Str"",Value.INT));
  cols.add(new Column(""String_Node_Str"",Value.STRING));
  int headPos=0;
  if (pageStore != null) {
    headPos=pageStore.getSystemTableHeadPos();
  }
  meta=mainSchema.createTable(""String_Node_Str"",0,cols,persistent,persistent,false,headPos,systemSession);
  IndexColumn[] pkCols=IndexColumn.wrap(new Column[]{columnId});
  metaIdIndex=meta.addIndex(systemSession,""String_Node_Str"",0,pkCols,IndexType.createPrimaryKey(false,false),Index.EMPTY_HEAD,null);
  objectIds.set(0);
  for (int i=0; i < MetaTable.getMetaTableTypeCount(); i++) {
    addMetaData(i);
  }
  starting=true;
  Cursor cursor=metaIdIndex.find(systemSession,null,null);
  ObjectArray<MetaRecord> records=ObjectArray.newInstance();
  while (cursor.next()) {
    MetaRecord rec=new MetaRecord(cursor.get());
    objectIds.set(rec.getId());
    records.add(rec);
  }
  MetaRecord.sort(records);
  for (  MetaRecord rec : records) {
    rec.execute(this,systemSession,eventListener);
  }
  recompileInvalidViews(systemSession);
  starting=false;
  addDefaultSetting(systemSession,SetTypes.DEFAULT_LOCK_TIMEOUT,null,Constants.INITIAL_LOCK_TIMEOUT);
  addDefaultSetting(systemSession,SetTypes.DEFAULT_TABLE_TYPE,null,Constants.DEFAULT_TABLE_TYPE);
  addDefaultSetting(systemSession,SetTypes.CACHE_SIZE,null,SysProperties.CACHE_SIZE_DEFAULT);
  addDefaultSetting(systemSession,SetTypes.CLUSTER,Constants.CLUSTERING_DISABLED,0);
  addDefaultSetting(systemSession,SetTypes.WRITE_DELAY,null,Constants.DEFAULT_WRITE_DELAY);
  addDefaultSetting(systemSession,SetTypes.CREATE_BUILD,null,Constants.BUILD_ID);
  if (!readOnly) {
    removeUnusedStorages(systemSession);
  }
  systemSession.commit(true);
  traceSystem.getTrace(Trace.DATABASE).info(""String_Node_Str"" + databaseName);
}","private synchronized void open(int traceLevelFile,int traceLevelSystemOut) throws SQLException {
  if (persistent) {
    String pageFileName=databaseName + Constants.SUFFIX_PAGE_FILE;
    boolean exists=FileUtils.exists(pageFileName);
    if (exists) {
      usePageStore=true;
    }
    if (usePageStore) {
      if (exists && FileUtils.isReadOnly(pageFileName)) {
        readOnly=true;
      }
    }
 else {
      String dataFileName=databaseName + Constants.SUFFIX_DATA_FILE;
      exists=FileUtils.exists(dataFileName);
      if (FileUtils.exists(dataFileName)) {
        readOnly=readOnly | FileUtils.isReadOnly(dataFileName);
      }
    }
    if (readOnly) {
      traceSystem=new TraceSystem(null,false);
    }
 else {
      traceSystem=new TraceSystem(databaseName + Constants.SUFFIX_TRACE_FILE,true);
    }
    traceSystem.setLevelFile(traceLevelFile);
    traceSystem.setLevelSystemOut(traceLevelSystemOut);
    traceSystem.getTrace(Trace.DATABASE).info(""String_Node_Str"" + databaseName + ""String_Node_Str""+ Constants.BUILD_ID+ ""String_Node_Str"");
    if (autoServerMode) {
      if (readOnly || fileLockMethod == FileLock.LOCK_NO) {
        throw Message.getUnsupportedException(""String_Node_Str"");
      }
    }
    if (!readOnly && fileLockMethod != FileLock.LOCK_NO) {
      lock=new FileLock(traceSystem,databaseName + Constants.SUFFIX_LOCK_FILE,Constants.LOCK_SLEEP);
      lock.lock(fileLockMethod);
      if (autoServerMode) {
        startServer(lock.getUniqueId());
      }
    }
    while (isReconnectNeeded() && !beforeWriting()) {
    }
    if (exists) {
      lobFilesInDirectories&=!ValueLob.existsLobFile(getDatabasePath());
      lobFilesInDirectories|=FileUtils.exists(databaseName + Constants.SUFFIX_LOBS_DIRECTORY);
    }
    dummy=DataPage.create(this,0);
    deleteOldTempFiles();
    if (usePageStore) {
      starting=true;
      getPageStore();
      starting=false;
    }
    log=new LogSystem(this,databaseName,readOnly,accessModeLog,pageStore);
    if (pageStore == null) {
      openFileData();
      log.open();
      openFileIndex();
      log.recover();
      fileData.init();
      try {
        fileIndex.init();
      }
 catch (      Exception e) {
        if (recovery) {
          traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
          for (          Storage s : New.arrayList(storageMap.values())) {
            if (s.getDiskFile() == fileIndex) {
              removeStorage(s.getId(),fileIndex);
            }
          }
          fileIndex.delete();
          openFileIndex();
        }
 else {
          throw Message.convert(e);
        }
      }
    }
    reserveLobFileObjectIds();
    writer=WriterThread.create(this,writeDelay);
  }
 else {
    traceSystem=new TraceSystem(null,false);
    log=new LogSystem(null,null,false,null,null);
  }
  systemUser=new User(this,0,Constants.DBA_NAME,true);
  mainSchema=new Schema(this,0,Constants.SCHEMA_MAIN,systemUser,true);
  infoSchema=new Schema(this,-1,Constants.SCHEMA_INFORMATION,systemUser,true);
  schemas.put(mainSchema.getName(),mainSchema);
  schemas.put(infoSchema.getName(),infoSchema);
  publicRole=new Role(this,0,Constants.PUBLIC_ROLE_NAME,true);
  roles.put(Constants.PUBLIC_ROLE_NAME,publicRole);
  systemUser.setAdmin(true);
  systemSession=new Session(this,systemUser,++nextSessionId);
  ObjectArray<Column> cols=ObjectArray.newInstance();
  Column columnId=new Column(""String_Node_Str"",Value.INT);
  columnId.setNullable(false);
  cols.add(columnId);
  cols.add(new Column(""String_Node_Str"",Value.INT));
  cols.add(new Column(""String_Node_Str"",Value.INT));
  cols.add(new Column(""String_Node_Str"",Value.STRING));
  int headPos=0;
  if (pageStore != null) {
    headPos=pageStore.getSystemTableHeadPos();
  }
  meta=mainSchema.createTable(""String_Node_Str"",0,cols,persistent,persistent,false,headPos,systemSession);
  IndexColumn[] pkCols=IndexColumn.wrap(new Column[]{columnId});
  metaIdIndex=meta.addIndex(systemSession,""String_Node_Str"",0,pkCols,IndexType.createPrimaryKey(false,false),Index.EMPTY_HEAD,null);
  objectIds.set(0);
  for (int i=0; i < MetaTable.getMetaTableTypeCount(); i++) {
    addMetaData(i);
  }
  starting=true;
  Cursor cursor=metaIdIndex.find(systemSession,null,null);
  ObjectArray<MetaRecord> records=ObjectArray.newInstance();
  while (cursor.next()) {
    MetaRecord rec=new MetaRecord(cursor.get());
    objectIds.set(rec.getId());
    records.add(rec);
  }
  MetaRecord.sort(records);
  for (  MetaRecord rec : records) {
    rec.execute(this,systemSession,eventListener);
  }
  recompileInvalidViews(systemSession);
  starting=false;
  addDefaultSetting(systemSession,SetTypes.DEFAULT_LOCK_TIMEOUT,null,Constants.INITIAL_LOCK_TIMEOUT);
  addDefaultSetting(systemSession,SetTypes.DEFAULT_TABLE_TYPE,null,Constants.DEFAULT_TABLE_TYPE);
  addDefaultSetting(systemSession,SetTypes.CACHE_SIZE,null,SysProperties.CACHE_SIZE_DEFAULT);
  addDefaultSetting(systemSession,SetTypes.CLUSTER,Constants.CLUSTERING_DISABLED,0);
  addDefaultSetting(systemSession,SetTypes.WRITE_DELAY,null,Constants.DEFAULT_WRITE_DELAY);
  addDefaultSetting(systemSession,SetTypes.CREATE_BUILD,null,Constants.BUILD_ID);
  if (!readOnly) {
    removeUnusedStorages(systemSession);
  }
  systemSession.commit(true);
  traceSystem.getTrace(Trace.DATABASE).info(""String_Node_Str"" + databaseName);
}",0.995503091624508
16176,"/** 
 * Check if the contents of the database was changed and therefore it is required to re-connect. This method waits until pending changes are completed. If a pending change takes too long (more than 2 seconds), the pending change is broken.
 * @return true if reconnecting is required
 */
public boolean isReconnectNeeded(){
  if (fileLockMethod != FileLock.LOCK_SERIALIZED) {
    return false;
  }
  if (reconnectChangePending) {
    return false;
  }
  long now=System.currentTimeMillis();
  if (now < reconnectCheckNext) {
    return false;
  }
  reconnectCheckNext=now + SysProperties.RECONNECT_CHECK_DELAY;
  if (lock == null) {
    lock=new FileLock(traceSystem,databaseName + Constants.SUFFIX_LOCK_FILE,Constants.LOCK_SLEEP);
  }
  try {
    Properties prop=lock.load(), first=prop;
    while (true) {
      if (prop.equals(reconnectLastLock)) {
        return false;
      }
      if (prop.getProperty(""String_Node_Str"",null) == null) {
        break;
      }
      if (System.currentTimeMillis() > now + SysProperties.RECONNECT_CHECK_DELAY * 10) {
        if (first.equals(prop)) {
          lock.setProperty(""String_Node_Str"",null);
          lock.save();
          break;
        }
      }
      getTrace().debug(""String_Node_Str"");
      Thread.sleep(SysProperties.RECONNECT_CHECK_DELAY);
      prop=lock.load();
    }
    reconnectLastLock=prop;
  }
 catch (  Exception e) {
    getTrace().error(""String_Node_Str"" + readOnly,e);
  }
  return true;
}","/** 
 * Check if the contents of the database was changed and therefore it is required to re-connect. This method waits until pending changes are completed. If a pending change takes too long (more than 2 seconds), the pending change is broken (removed from the properties file).
 * @return true if reconnecting is required
 */
public boolean isReconnectNeeded(){
  if (fileLockMethod != FileLock.LOCK_SERIALIZED) {
    return false;
  }
  if (reconnectChangePending) {
    return false;
  }
  long now=System.currentTimeMillis();
  if (now < reconnectCheckNext) {
    return false;
  }
  reconnectCheckNext=now + SysProperties.RECONNECT_CHECK_DELAY;
  if (lock == null) {
    lock=new FileLock(traceSystem,databaseName + Constants.SUFFIX_LOCK_FILE,Constants.LOCK_SLEEP);
  }
  try {
    Properties prop=lock.load(), first=prop;
    while (true) {
      if (prop.equals(reconnectLastLock)) {
        return false;
      }
      if (prop.getProperty(""String_Node_Str"",null) == null) {
        break;
      }
      if (System.currentTimeMillis() > now + SysProperties.RECONNECT_CHECK_DELAY * 10) {
        if (first.equals(prop)) {
          lock.setProperty(""String_Node_Str"",null);
          lock.save();
          break;
        }
      }
      getTrace().debug(""String_Node_Str"");
      Thread.sleep(SysProperties.RECONNECT_CHECK_DELAY);
      prop=lock.load();
    }
    reconnectLastLock=prop;
  }
 catch (  Exception e) {
    getTrace().error(""String_Node_Str"" + readOnly,e);
  }
  return true;
}",0.9882035726322884
16177,"private synchronized void closeOpenFilesAndUnlock(boolean checkpoint) throws SQLException {
  if (log != null) {
    stopWriter();
    try {
      log.close(checkpoint);
    }
 catch (    Throwable e) {
      traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
    }
    log=null;
  }
  if (pageStore != null) {
    if (checkpoint) {
      try {
        pageStore.checkpoint();
      }
 catch (      Throwable e) {
        traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
      }
    }
  }
  reconnectModified(false);
  closeFiles();
  if (persistent && lock == null && fileLockMethod != FileLock.LOCK_NO) {
    return;
  }
  if (persistent) {
    deleteOldTempFiles();
  }
  if (systemSession != null) {
    systemSession.close();
    systemSession=null;
  }
  if (lock != null) {
    if (fileLockMethod != FileLock.LOCK_SERIALIZED) {
      lock.unlock();
    }
    lock=null;
  }
}","/** 
 * Close all open files and unlock the database.
 * @param flush whether writing is allowed
 */
private synchronized void closeOpenFilesAndUnlock(boolean flush) throws SQLException {
  if (log != null) {
    stopWriter();
    try {
      log.close(flush);
    }
 catch (    Throwable e) {
      traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
    }
    log=null;
  }
  if (pageStore != null) {
    if (flush) {
      try {
        pageStore.checkpoint();
      }
 catch (      Throwable e) {
        traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
      }
    }
  }
  reconnectModified(false);
  closeFiles();
  if (persistent && lock == null && fileLockMethod != FileLock.LOCK_NO) {
    return;
  }
  if (persistent) {
    deleteOldTempFiles();
  }
  if (systemSession != null) {
    systemSession.close();
    systemSession=null;
  }
  if (lock != null) {
    if (fileLockMethod != FileLock.LOCK_SERIALIZED) {
      lock.unlock();
    }
    lock=null;
  }
}",0.9235602094240838
16178,"/** 
 * Set or reset the pending change flag in the .lock.db file.
 * @param pending the new value of the flag
 * @return true if the call was successful,false if another connection was faster
 */
synchronized boolean reconnectModified(boolean pending){
  if (readOnly || lock == null || fileLockMethod != FileLock.LOCK_SERIALIZED) {
    return true;
  }
  try {
    if (pending == reconnectChangePending) {
      long now=System.currentTimeMillis();
      if (now > reconnectCheckNext) {
        if (pending) {
          String pos=log == null ? null : log.getWritePos();
          lock.setProperty(""String_Node_Str"",pos);
          lock.save();
        }
        reconnectCheckNext=now + SysProperties.RECONNECT_CHECK_DELAY;
      }
      return true;
    }
    Properties old=lock.load();
    if (pending) {
      getTrace().debug(""String_Node_Str"");
      Thread.sleep((int)(SysProperties.RECONNECT_CHECK_DELAY * 1.1));
      Properties now=lock.load();
      if (!now.equals(old)) {
        return false;
      }
    }
    String pos=log == null ? null : log.getWritePos();
    lock.setProperty(""String_Node_Str"",pos);
    lock.setProperty(""String_Node_Str"",pending ? ""String_Node_Str"" : null);
    reconnectCheckNext=System.currentTimeMillis() + 2 * SysProperties.RECONNECT_CHECK_DELAY;
    old=lock.save();
    if (pending) {
      getTrace().debug(""String_Node_Str"");
      Thread.sleep((int)(SysProperties.RECONNECT_CHECK_DELAY * 1.1));
      Properties now=lock.load();
      if (!now.equals(old)) {
        return false;
      }
    }
    reconnectLastLock=old;
    reconnectChangePending=pending;
    reconnectCheckNext=System.currentTimeMillis() + SysProperties.RECONNECT_CHECK_DELAY;
    return true;
  }
 catch (  Exception e) {
    getTrace().error(""String_Node_Str"" + pending,e);
    return false;
  }
}","/** 
 * Set or reset the pending change flag in the .lock.db file.
 * @param pending the new value of the flag
 * @return true if the call was successful,false if another connection was faster
 */
synchronized boolean reconnectModified(boolean pending){
  if (readOnly || lock == null || fileLockMethod != FileLock.LOCK_SERIALIZED) {
    return true;
  }
  try {
    if (pending == reconnectChangePending) {
      long now=System.currentTimeMillis();
      if (now > reconnectCheckNext) {
        if (pending) {
          String pos=log == null ? null : log.getWritePos();
          lock.setProperty(""String_Node_Str"",pos);
          lock.save();
        }
        reconnectCheckNext=now + SysProperties.RECONNECT_CHECK_DELAY;
      }
      return true;
    }
    Properties old=lock.load();
    if (pending) {
      if (old.getProperty(""String_Node_Str"") != null) {
        return false;
      }
      getTrace().debug(""String_Node_Str"");
      Thread.sleep((int)(SysProperties.RECONNECT_CHECK_DELAY * 1.1));
      Properties now=lock.load();
      if (!now.equals(old)) {
        return false;
      }
    }
    String pos=log == null ? null : log.getWritePos();
    lock.setProperty(""String_Node_Str"",pos);
    lock.setProperty(""String_Node_Str"",pending ? ""String_Node_Str"" : null);
    reconnectCheckNext=System.currentTimeMillis() + 2 * SysProperties.RECONNECT_CHECK_DELAY;
    old=lock.save();
    if (pending) {
      getTrace().debug(""String_Node_Str"");
      Thread.sleep((int)(SysProperties.RECONNECT_CHECK_DELAY * 1.1));
      Properties now=lock.load();
      if (!now.equals(old)) {
        return false;
      }
    }
 else {
      Thread.sleep(1);
    }
    reconnectLastLock=old;
    reconnectChangePending=pending;
    reconnectCheckNext=System.currentTimeMillis() + SysProperties.RECONNECT_CHECK_DELAY;
    return true;
  }
 catch (  Exception e) {
    getTrace().error(""String_Node_Str"" + pending,e);
    return false;
  }
}",0.967313313845336
16179,"public void test() throws Exception {
  Class.forName(""String_Node_Str"");
  testThreeMostlyReaders(true);
  testThreeMostlyReaders(false);
  testTwoReaders();
  testTwoWriters();
  testPendingWrite();
  testKillWriter();
  testConcurrentReadWrite();
}","public void test() throws Exception {
  println(""String_Node_Str"");
  testThreeMostlyReaders(true);
  println(""String_Node_Str"");
  testThreeMostlyReaders(false);
  println(""String_Node_Str"");
  testTwoReaders();
  println(""String_Node_Str"");
  testTwoWriters();
  println(""String_Node_Str"");
  testPendingWrite();
  println(""String_Node_Str"");
  testKillWriter();
  println(""String_Node_Str"");
  testConcurrentReadWrite();
}",0.7041420118343196
16180,"private void testPendingWrite() throws Exception {
  deleteDb(""String_Node_Str"");
  String url=""String_Node_Str"" + baseDir + ""String_Node_Str"";
  String writeUrl=url + ""String_Node_Str"";
  Connection conn=DriverManager.getConnection(writeUrl,""String_Node_Str"",""String_Node_Str"");
  Statement stat=conn.createStatement();
  stat.execute(""String_Node_Str"");
  Thread.sleep(500);
  String propFile=baseDir + ""String_Node_Str"";
  SortedProperties p=SortedProperties.loadProperties(propFile);
  p.setProperty(""String_Node_Str"",""String_Node_Str"");
  p.setProperty(""String_Node_Str"",""String_Node_Str"");
  OutputStream out=new FileOutputStream(propFile,false);
  try {
    p.store(out,""String_Node_Str"");
  }
  finally {
    out.close();
  }
  Thread.sleep(500);
  stat.execute(""String_Node_Str"");
  conn.close();
}","private void testPendingWrite() throws Exception {
  deleteDb(""String_Node_Str"");
  String url=""String_Node_Str"" + baseDir + ""String_Node_Str"";
  String writeUrl=url + ""String_Node_Str"";
  Connection conn=DriverManager.getConnection(writeUrl,""String_Node_Str"",""String_Node_Str"");
  Statement stat=conn.createStatement();
  stat.execute(""String_Node_Str"");
  Thread.sleep(100);
  String propFile=baseDir + ""String_Node_Str"";
  SortedProperties p=SortedProperties.loadProperties(propFile);
  p.setProperty(""String_Node_Str"",""String_Node_Str"");
  p.setProperty(""String_Node_Str"",""String_Node_Str"");
  OutputStream out=new FileOutputStream(propFile,false);
  try {
    p.store(out,""String_Node_Str"");
  }
  finally {
    out.close();
  }
  Thread.sleep(100);
  stat.execute(""String_Node_Str"");
  conn.close();
}",0.9975216852540272
16181,"private void testTwoWriters() throws Exception {
  deleteDb(""String_Node_Str"");
  String url=""String_Node_Str"" + baseDir + ""String_Node_Str"";
  final String writeUrl=url + ""String_Node_Str"";
  final boolean[] stop=new boolean[1];
  Connection conn=DriverManager.getConnection(writeUrl,""String_Node_Str"",""String_Node_Str"");
  conn.createStatement().execute(""String_Node_Str"");
  conn.close();
  new Thread(){
    public void run(){
      while (!stop[0]) {
        try {
          Connection conn=DriverManager.getConnection(writeUrl,""String_Node_Str"",""String_Node_Str"");
          conn.createStatement().execute(""String_Node_Str"");
          conn.close();
        }
 catch (        SQLException e) {
        }
      }
    }
  }
.start();
  Thread.sleep(100);
  for (int i=0; i < 3; i++) {
    conn=DriverManager.getConnection(writeUrl,""String_Node_Str"",""String_Node_Str"");
    Statement stat=conn.createStatement();
    stat.execute(""String_Node_Str"");
    stat.execute(""String_Node_Str"");
    conn.createStatement().execute(""String_Node_Str"");
    conn.close();
  }
  stop[0]=true;
  Thread.sleep(100);
  conn=DriverManager.getConnection(writeUrl,""String_Node_Str"",""String_Node_Str"");
  conn.createStatement().execute(""String_Node_Str"");
  conn.close();
}","private void testTwoWriters() throws Exception {
  deleteDb(""String_Node_Str"");
  String url=""String_Node_Str"" + baseDir + ""String_Node_Str"";
  final String writeUrl=url + ""String_Node_Str"";
  final boolean[] stop=new boolean[1];
  Connection conn=DriverManager.getConnection(writeUrl,""String_Node_Str"",""String_Node_Str"");
  conn.createStatement().execute(""String_Node_Str"");
  conn.close();
  new Thread(){
    public void run(){
      while (!stop[0]) {
        try {
          Thread.sleep(10);
          Connection conn=DriverManager.getConnection(writeUrl,""String_Node_Str"",""String_Node_Str"");
          conn.createStatement().execute(""String_Node_Str"");
          conn.close();
        }
 catch (        Exception e) {
        }
      }
    }
  }
.start();
  Thread.sleep(20);
  for (int i=0; i < 2; i++) {
    conn=DriverManager.getConnection(writeUrl,""String_Node_Str"",""String_Node_Str"");
    Statement stat=conn.createStatement();
    stat.execute(""String_Node_Str"");
    stat.execute(""String_Node_Str"");
    conn.createStatement().execute(""String_Node_Str"");
    conn.close();
  }
  stop[0]=true;
  Thread.sleep(100);
  conn=DriverManager.getConnection(writeUrl,""String_Node_Str"",""String_Node_Str"");
  conn.createStatement().execute(""String_Node_Str"");
  conn.close();
}",0.9858044164037856
16182,"private void testThreeMostlyReaders(final boolean write) throws Exception {
  deleteDb(""String_Node_Str"");
  String url=""String_Node_Str"" + baseDir + ""String_Node_Str"";
  int len=3;
  final Exception[] ex=new Exception[1];
  final Connection[] conn=new Connection[len];
  final boolean[] stop=new boolean[1];
  Thread[] threads=new Thread[len];
  for (int i=0; i < len; i++) {
    final Connection c=DriverManager.getConnection(url);
    conn[i]=c;
    if (i == 0) {
      conn[i].createStatement().execute(""String_Node_Str"");
    }
    Thread t=new Thread(new Runnable(){
      public void run(){
        try {
          PreparedStatement p=c.prepareStatement(""String_Node_Str"");
          while (!stop[0]) {
            if (write) {
              if (Math.random() > 0.9) {
                c.createStatement().execute(""String_Node_Str"");
              }
            }
            p.setInt(1,1);
            Thread.sleep(10);
            p.executeQuery();
            p.clearParameters();
          }
          c.close();
        }
 catch (        Exception e) {
          ex[0]=e;
        }
      }
    }
);
    t.start();
    threads[i]=t;
  }
  Thread.sleep(1000);
  stop[0]=true;
  for (int i=0; i < len; i++) {
    threads[i].join();
  }
  if (ex[0] != null) {
    throw ex[0];
  }
  DriverManager.getConnection(url).close();
}","private void testThreeMostlyReaders(final boolean write) throws Exception {
  deleteDb(""String_Node_Str"");
  String url=""String_Node_Str"" + baseDir + ""String_Node_Str"";
  int len=3;
  final Exception[] ex=new Exception[1];
  final Connection[] conn=new Connection[len];
  final boolean[] stop=new boolean[1];
  Thread[] threads=new Thread[len];
  for (int i=0; i < len; i++) {
    final Connection c=DriverManager.getConnection(url);
    conn[i]=c;
    if (i == 0) {
      conn[i].createStatement().execute(""String_Node_Str"");
    }
    Thread t=new Thread(new Runnable(){
      public void run(){
        try {
          PreparedStatement p=c.prepareStatement(""String_Node_Str"");
          while (!stop[0]) {
            Thread.sleep(100);
            if (write) {
              if (Math.random() > 0.9) {
                c.createStatement().execute(""String_Node_Str"");
              }
            }
            p.setInt(1,1);
            p.executeQuery();
            p.clearParameters();
          }
          c.close();
        }
 catch (        Exception e) {
          ex[0]=e;
        }
      }
    }
);
    t.start();
    threads[i]=t;
  }
  Thread.sleep(400);
  stop[0]=true;
  for (int i=0; i < len; i++) {
    threads[i].join();
  }
  if (ex[0] != null) {
    throw ex[0];
  }
  DriverManager.getConnection(url).close();
}",0.9759939984996248
16183,"public void run(){
  while (!stop[0]) {
    try {
      Connection conn=DriverManager.getConnection(writeUrl,""String_Node_Str"",""String_Node_Str"");
      conn.createStatement().execute(""String_Node_Str"");
      conn.close();
    }
 catch (    SQLException e) {
    }
  }
}","public void run(){
  while (!stop[0]) {
    try {
      Thread.sleep(10);
      Connection conn=DriverManager.getConnection(writeUrl,""String_Node_Str"",""String_Node_Str"");
      conn.createStatement().execute(""String_Node_Str"");
      conn.close();
    }
 catch (    Exception e) {
    }
  }
}",0.9520426287744228
16184,"/** 
 * Flush all changes when using the serialized mode, and if there are pending changes, and some time has passed. This switches to a new transaction log and resets the change pending flag in the .lock.db file.
 */
public void checkpointIfRequired() throws SQLException {
  if (fileLockMethod != FileLock.LOCK_SERIALIZED || readOnly || !reconnectChangePending) {
    return;
  }
  long now=System.currentTimeMillis();
  if (now > reconnectCheckNext + SysProperties.RECONNECT_CHECK_DELAY) {
    getTrace().debug(""String_Node_Str"");
    flushIndexes(0);
    checkpoint();
    reconnectModified(false);
  }
}","/** 
 * Flush all changes when using the serialized mode, and if there are pending changes, and some time has passed. This switches to a new transaction log and resets the change pending flag in the .lock.db file.
 */
public void checkpointIfRequired() throws SQLException {
  if (fileLockMethod != FileLock.LOCK_SERIALIZED || readOnly || !reconnectChangePending || closing) {
    return;
  }
  long now=System.currentTimeMillis();
  if (now > reconnectCheckNext + SysProperties.RECONNECT_CHECK_DELAY) {
    getTrace().debug(""String_Node_Str"");
    flushIndexes(0);
    checkpoint();
    reconnectModified(false);
  }
}",0.991035044824776
16185,"/** 
 * Close the database.
 * @param fromShutdownHook true if this method is called from the shutdownhook
 */
synchronized void close(boolean fromShutdownHook){
  if (closing) {
    return;
  }
  if (fileLockMethod == FileLock.LOCK_SERIALIZED && !reconnectChangePending) {
    try {
      log.setReadOnly(true);
      closeOpenFilesAndUnlock(false);
    }
 catch (    SQLException e) {
    }
    traceSystem.close();
    Engine.getInstance().close(databaseName);
    return;
  }
  closing=true;
  stopServer();
  if (userSessions.size() > 0) {
    if (!fromShutdownHook) {
      return;
    }
    traceSystem.getTrace(Trace.DATABASE).info(""String_Node_Str"" + databaseName + ""String_Node_Str"");
    Session[] all=new Session[userSessions.size()];
    userSessions.toArray(all);
    for (    Session s : all) {
      try {
        s.rollback();
        s.close();
      }
 catch (      SQLException e) {
        traceSystem.getTrace(Trace.SESSION).error(""String_Node_Str"" + s.getId(),e);
      }
    }
  }
  if (log != null) {
    log.setDisabled(false);
  }
  traceSystem.getTrace(Trace.DATABASE).info(""String_Node_Str"" + databaseName);
  if (eventListener != null) {
    closing=false;
    DatabaseEventListener e=eventListener;
    eventListener=null;
    e.closingDatabase();
    if (userSessions.size() > 0) {
      return;
    }
    closing=true;
  }
  try {
    if (systemSession != null) {
      for (      Table table : getAllTablesAndViews()) {
        table.close(systemSession);
      }
      for (      SchemaObject obj : getAllSchemaObjects(DbObject.SEQUENCE)) {
        Sequence sequence=(Sequence)obj;
        sequence.close();
      }
      for (      SchemaObject obj : getAllSchemaObjects(DbObject.TRIGGER)) {
        TriggerObject trigger=(TriggerObject)obj;
        trigger.close();
      }
      meta.close(systemSession);
      systemSession.commit(true);
      indexSummaryValid=true;
    }
  }
 catch (  SQLException e) {
    traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
  }
  if (persistent) {
    try {
      ValueLob.removeAllForTable(this,ValueLob.TABLE_ID_SESSION_VARIABLE);
    }
 catch (    SQLException e) {
      traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
    }
  }
  tempFileDeleter.deleteAll();
  try {
    closeOpenFilesAndUnlock(true);
  }
 catch (  SQLException e) {
    traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
  }
  traceSystem.getTrace(Trace.DATABASE).info(""String_Node_Str"");
  traceSystem.close();
  if (closeOnExit != null) {
    closeOnExit.reset();
    try {
      Runtime.getRuntime().removeShutdownHook(closeOnExit);
    }
 catch (    IllegalStateException e) {
    }
catch (    SecurityException e) {
    }
    closeOnExit=null;
  }
  Engine.getInstance().close(databaseName);
  if (deleteFilesOnDisconnect && persistent) {
    deleteFilesOnDisconnect=false;
    try {
      String directory=FileUtils.getParent(databaseName);
      String name=FileUtils.getFileName(databaseName);
      DeleteDbFiles.execute(directory,name,true);
    }
 catch (    Exception e) {
    }
  }
}","/** 
 * Close the database.
 * @param fromShutdownHook true if this method is called from the shutdownhook
 */
synchronized void close(boolean fromShutdownHook){
  if (closing) {
    return;
  }
  if (fileLockMethod == FileLock.LOCK_SERIALIZED && !reconnectChangePending) {
    try {
      if (log != null) {
        log.setReadOnly(true);
      }
      closeOpenFilesAndUnlock(false);
    }
 catch (    SQLException e) {
    }
    traceSystem.close();
    Engine.getInstance().close(databaseName);
    return;
  }
  closing=true;
  stopServer();
  if (userSessions.size() > 0) {
    if (!fromShutdownHook) {
      return;
    }
    traceSystem.getTrace(Trace.DATABASE).info(""String_Node_Str"" + databaseName + ""String_Node_Str"");
    Session[] all=new Session[userSessions.size()];
    userSessions.toArray(all);
    for (    Session s : all) {
      try {
        s.rollback();
        s.close();
      }
 catch (      SQLException e) {
        traceSystem.getTrace(Trace.SESSION).error(""String_Node_Str"" + s.getId(),e);
      }
    }
  }
  if (log != null) {
    log.setDisabled(false);
  }
  traceSystem.getTrace(Trace.DATABASE).info(""String_Node_Str"" + databaseName);
  if (eventListener != null) {
    closing=false;
    DatabaseEventListener e=eventListener;
    eventListener=null;
    e.closingDatabase();
    if (userSessions.size() > 0) {
      return;
    }
    closing=true;
  }
  try {
    if (systemSession != null) {
      for (      Table table : getAllTablesAndViews()) {
        table.close(systemSession);
      }
      for (      SchemaObject obj : getAllSchemaObjects(DbObject.SEQUENCE)) {
        Sequence sequence=(Sequence)obj;
        sequence.close();
      }
      for (      SchemaObject obj : getAllSchemaObjects(DbObject.TRIGGER)) {
        TriggerObject trigger=(TriggerObject)obj;
        trigger.close();
      }
      meta.close(systemSession);
      systemSession.commit(true);
      indexSummaryValid=true;
    }
  }
 catch (  SQLException e) {
    traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
  }
  if (persistent) {
    try {
      ValueLob.removeAllForTable(this,ValueLob.TABLE_ID_SESSION_VARIABLE);
    }
 catch (    SQLException e) {
      traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
    }
  }
  tempFileDeleter.deleteAll();
  try {
    closeOpenFilesAndUnlock(true);
  }
 catch (  SQLException e) {
    traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
  }
  traceSystem.getTrace(Trace.DATABASE).info(""String_Node_Str"");
  traceSystem.close();
  if (closeOnExit != null) {
    closeOnExit.reset();
    try {
      Runtime.getRuntime().removeShutdownHook(closeOnExit);
    }
 catch (    IllegalStateException e) {
    }
catch (    SecurityException e) {
    }
    closeOnExit=null;
  }
  Engine.getInstance().close(databaseName);
  if (deleteFilesOnDisconnect && persistent) {
    deleteFilesOnDisconnect=false;
    try {
      String directory=FileUtils.getParent(databaseName);
      String name=FileUtils.getFileName(databaseName);
      DeleteDbFiles.execute(directory,name,true);
    }
 catch (    Exception e) {
    }
  }
}",0.994370275052276
16186,"/** 
 * Flush all changes when using the serialized mode, and if there are pending changes, and some time has passed. This switches to a new transaction log and resets the change pending flag in the .lock.db file.
 */
public void checkpointIfRequired() throws SQLException {
  if (fileLockMethod != FileLock.LOCK_SERIALIZED || readOnly || !reconnectChangePending || closing) {
    return;
  }
  long now=System.currentTimeMillis();
  if (now > reconnectCheckNext + SysProperties.RECONNECT_CHECK_DELAY) {
    getTrace().debug(""String_Node_Str"");
    flushIndexes(0);
    checkpoint();
    reconnectModified(false);
  }
}","/** 
 * Flush all changes when using the serialized mode, and if there are pending changes, and some time has passed. This switches to a new transaction log and resets the change pending flag in the .lock.db file.
 */
public void checkpointIfRequired() throws SQLException {
  if (fileLockMethod != FileLock.LOCK_SERIALIZED || readOnly || !reconnectChangePending || closing) {
    return;
  }
synchronized (this) {
    long now=System.currentTimeMillis();
    if (now > reconnectCheckNext + SysProperties.RECONNECT_CHECK_DELAY) {
      getTrace().debug(""String_Node_Str"");
      flushIndexes(0);
      checkpoint();
      reconnectModified(false);
    }
  }
}",0.9687010954616588
16187,"/** 
 * Delete an unused log file. It is deleted immediately if no writer thread is running, or deleted later on if one is running. Deleting is delayed because the hard drive otherwise may delete the file a bit before the data is written to the new file, which can cause problems when recovering.
 * @param fileName the name of the file to be deleted
 */
public void deleteLogFileLater(String fileName) throws SQLException {
  if (writer != null) {
    writer.deleteLogFileLater(fileName);
  }
 else {
    FileUtils.delete(fileName);
  }
}","/** 
 * Delete an unused log file. It is deleted immediately if no writer thread is running, or deleted later on if one is running. Deleting is delayed because the hard drive otherwise may delete the file a bit before the data is written to the new file, which can cause problems when recovering.
 * @param fileName the name of the file to be deleted
 */
public void deleteLogFileLater(String fileName) throws SQLException {
  if (fileLockMethod == FileLock.LOCK_SERIALIZED) {
    try {
      FileSystem.getInstance(fileName).openFileObject(fileName,""String_Node_Str"").setFileLength(0);
    }
 catch (    IOException e) {
      throw Message.convertIOException(e,""String_Node_Str"" + fileName);
    }
  }
  if (writer != null) {
    writer.deleteLogFileLater(fileName);
  }
 else {
    FileUtils.delete(fileName);
  }
}",0.7943994104642594
16188,"/** 
 * Set or reset the pending change flag in the .lock.db file.
 * @param pending the new value of the flag
 * @return true if the call was successful,false if another connection was faster
 */
synchronized boolean reconnectModified(boolean pending){
  if (readOnly || lock == null || fileLockMethod != FileLock.LOCK_SERIALIZED) {
    return true;
  }
  try {
    if (pending == reconnectChangePending) {
      long now=System.currentTimeMillis();
      if (now > reconnectCheckNext) {
        if (pending) {
          String pos=log == null ? null : log.getWritePos();
          lock.setProperty(""String_Node_Str"",pos);
          lock.save();
        }
        reconnectCheckNext=now + SysProperties.RECONNECT_CHECK_DELAY;
      }
      return true;
    }
    Properties old=lock.load();
    if (pending) {
      getTrace().debug(""String_Node_Str"");
      Thread.sleep((int)(SysProperties.RECONNECT_CHECK_DELAY * 1.1));
      Properties now=lock.load();
      if (!now.equals(old)) {
        return false;
      }
    }
    String pos=log == null ? null : log.getWritePos();
    lock.setProperty(""String_Node_Str"",pos);
    lock.setProperty(""String_Node_Str"",pending ? ""String_Node_Str"" : null);
    old=lock.save();
    if (pending) {
      getTrace().debug(""String_Node_Str"");
      Thread.sleep((int)(SysProperties.RECONNECT_CHECK_DELAY * 1.1));
      Properties now=lock.load();
      if (!now.equals(old)) {
        return false;
      }
    }
    reconnectLastLock=old;
    reconnectChangePending=pending;
    reconnectCheckNext=System.currentTimeMillis() + SysProperties.RECONNECT_CHECK_DELAY;
    return true;
  }
 catch (  Exception e) {
    getTrace().error(""String_Node_Str"" + pending,e);
    return false;
  }
}","/** 
 * Set or reset the pending change flag in the .lock.db file.
 * @param pending the new value of the flag
 * @return true if the call was successful,false if another connection was faster
 */
synchronized boolean reconnectModified(boolean pending){
  if (readOnly || lock == null || fileLockMethod != FileLock.LOCK_SERIALIZED) {
    return true;
  }
  try {
    if (pending == reconnectChangePending) {
      long now=System.currentTimeMillis();
      if (now > reconnectCheckNext) {
        if (pending) {
          String pos=log == null ? null : log.getWritePos();
          lock.setProperty(""String_Node_Str"",pos);
          lock.save();
        }
        reconnectCheckNext=now + SysProperties.RECONNECT_CHECK_DELAY;
      }
      return true;
    }
    Properties old=lock.load();
    if (pending) {
      getTrace().debug(""String_Node_Str"");
      Thread.sleep((int)(SysProperties.RECONNECT_CHECK_DELAY * 1.1));
      Properties now=lock.load();
      if (!now.equals(old)) {
        return false;
      }
    }
    String pos=log == null ? null : log.getWritePos();
    lock.setProperty(""String_Node_Str"",pos);
    lock.setProperty(""String_Node_Str"",pending ? ""String_Node_Str"" : null);
    reconnectCheckNext=System.currentTimeMillis() + 2 * SysProperties.RECONNECT_CHECK_DELAY;
    old=lock.save();
    if (pending) {
      getTrace().debug(""String_Node_Str"");
      Thread.sleep((int)(SysProperties.RECONNECT_CHECK_DELAY * 1.1));
      Properties now=lock.load();
      if (!now.equals(old)) {
        return false;
      }
    }
    reconnectLastLock=old;
    reconnectChangePending=pending;
    reconnectCheckNext=System.currentTimeMillis() + SysProperties.RECONNECT_CHECK_DELAY;
    return true;
  }
 catch (  Exception e) {
    getTrace().error(""String_Node_Str"" + pending,e);
    return false;
  }
}",0.7843247815054976
16189,"/** 
 * Flush all changes when using the serialized mode, and if there are pending changes.
 */
public void checkpointIfRequired() throws SQLException {
  if (fileLockMethod != FileLock.LOCK_SERIALIZED || readOnly || !reconnectChangePending) {
    return;
  }
  long now=System.currentTimeMillis();
  if (now > reconnectCheckNext) {
    getTrace().debug(""String_Node_Str"");
    checkpoint();
    reconnectModified(false);
  }
}","/** 
 * Flush all changes when using the serialized mode, and if there are pending changes, and some time has passed. This switches to a new transaction log and resets the change pending flag in the .lock.db file.
 */
public void checkpointIfRequired() throws SQLException {
  if (fileLockMethod != FileLock.LOCK_SERIALIZED || readOnly || !reconnectChangePending) {
    return;
  }
  long now=System.currentTimeMillis();
  if (now > reconnectCheckNext + SysProperties.RECONNECT_CHECK_DELAY) {
    getTrace().debug(""String_Node_Str"");
    flushIndexes(0);
    checkpoint();
    reconnectModified(false);
  }
}",0.8251207729468599
16190,"/** 
 * This method is called before writing to the log file.
 */
public void beforeWriting(){
  if (fileLockMethod == FileLock.LOCK_SERIALIZED) {
    reconnectModified(true);
  }
}","/** 
 * This method is called before writing to the log file.
 * @return true if the call was successful,false if another connection was faster
 */
public boolean beforeWriting(){
  if (fileLockMethod == FileLock.LOCK_SERIALIZED) {
    return reconnectModified(true);
  }
  return true;
}",0.7547974413646056
16191,"/** 
 * Close the database.
 * @param fromShutdownHook true if this method is called from the shutdownhook
 */
synchronized void close(boolean fromShutdownHook){
  if (closing) {
    return;
  }
  if (isReconnectNeeded()) {
    try {
      closeOpenFilesAndUnlock(false);
    }
 catch (    SQLException e) {
    }
    traceSystem.close();
    Engine.getInstance().close(databaseName);
    return;
  }
  closing=true;
  stopServer();
  if (userSessions.size() > 0) {
    if (!fromShutdownHook) {
      return;
    }
    traceSystem.getTrace(Trace.DATABASE).info(""String_Node_Str"" + databaseName + ""String_Node_Str"");
    Session[] all=new Session[userSessions.size()];
    userSessions.toArray(all);
    for (int i=0; i < all.length; i++) {
      Session s=all[i];
      try {
        s.rollback();
        s.close();
      }
 catch (      SQLException e) {
        traceSystem.getTrace(Trace.SESSION).error(""String_Node_Str"" + s.getId(),e);
      }
    }
  }
  if (log != null) {
    log.setDisabled(false);
  }
  traceSystem.getTrace(Trace.DATABASE).info(""String_Node_Str"" + databaseName);
  if (eventListener != null) {
    closing=false;
    DatabaseEventListener e=eventListener;
    eventListener=null;
    e.closingDatabase();
    if (userSessions.size() > 0) {
      return;
    }
    closing=true;
  }
  try {
    if (systemSession != null) {
      ObjectArray tablesAndViews=getAllSchemaObjects(DbObject.TABLE_OR_VIEW);
      for (int i=0; i < tablesAndViews.size(); i++) {
        Table table=(Table)tablesAndViews.get(i);
        table.close(systemSession);
      }
      ObjectArray sequences=getAllSchemaObjects(DbObject.SEQUENCE);
      for (int i=0; i < sequences.size(); i++) {
        Sequence sequence=(Sequence)sequences.get(i);
        sequence.close();
      }
      ObjectArray triggers=getAllSchemaObjects(DbObject.TRIGGER);
      for (int i=0; i < triggers.size(); i++) {
        TriggerObject trigger=(TriggerObject)triggers.get(i);
        trigger.close();
      }
      meta.close(systemSession);
      systemSession.commit(true);
      indexSummaryValid=true;
    }
  }
 catch (  SQLException e) {
    traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
  }
  if (persistent) {
    try {
      ValueLob.removeAllForTable(this,ValueLob.TABLE_ID_SESSION_VARIABLE);
    }
 catch (    SQLException e) {
      traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
    }
  }
  tempFileDeleter.deleteAll();
  try {
    closeOpenFilesAndUnlock(true);
  }
 catch (  SQLException e) {
    traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
  }
  traceSystem.getTrace(Trace.DATABASE).info(""String_Node_Str"");
  traceSystem.close();
  if (closeOnExit != null) {
    closeOnExit.reset();
    try {
      Runtime.getRuntime().removeShutdownHook(closeOnExit);
    }
 catch (    IllegalStateException e) {
    }
catch (    SecurityException e) {
    }
    closeOnExit=null;
  }
  Engine.getInstance().close(databaseName);
  if (deleteFilesOnDisconnect && persistent) {
    deleteFilesOnDisconnect=false;
    try {
      String directory=FileUtils.getParent(databaseName);
      String name=FileUtils.getFileName(databaseName);
      DeleteDbFiles.execute(directory,name,true);
    }
 catch (    Exception e) {
    }
  }
}","/** 
 * Close the database.
 * @param fromShutdownHook true if this method is called from the shutdownhook
 */
synchronized void close(boolean fromShutdownHook){
  if (closing) {
    return;
  }
  if (fileLockMethod == FileLock.LOCK_SERIALIZED && !reconnectChangePending) {
    try {
      log.setReadOnly(true);
      closeOpenFilesAndUnlock(false);
    }
 catch (    SQLException e) {
    }
    traceSystem.close();
    Engine.getInstance().close(databaseName);
    return;
  }
  closing=true;
  stopServer();
  if (userSessions.size() > 0) {
    if (!fromShutdownHook) {
      return;
    }
    traceSystem.getTrace(Trace.DATABASE).info(""String_Node_Str"" + databaseName + ""String_Node_Str"");
    Session[] all=new Session[userSessions.size()];
    userSessions.toArray(all);
    for (int i=0; i < all.length; i++) {
      Session s=all[i];
      try {
        s.rollback();
        s.close();
      }
 catch (      SQLException e) {
        traceSystem.getTrace(Trace.SESSION).error(""String_Node_Str"" + s.getId(),e);
      }
    }
  }
  if (log != null) {
    log.setDisabled(false);
  }
  traceSystem.getTrace(Trace.DATABASE).info(""String_Node_Str"" + databaseName);
  if (eventListener != null) {
    closing=false;
    DatabaseEventListener e=eventListener;
    eventListener=null;
    e.closingDatabase();
    if (userSessions.size() > 0) {
      return;
    }
    closing=true;
  }
  try {
    if (systemSession != null) {
      ObjectArray tablesAndViews=getAllSchemaObjects(DbObject.TABLE_OR_VIEW);
      for (int i=0; i < tablesAndViews.size(); i++) {
        Table table=(Table)tablesAndViews.get(i);
        table.close(systemSession);
      }
      ObjectArray sequences=getAllSchemaObjects(DbObject.SEQUENCE);
      for (int i=0; i < sequences.size(); i++) {
        Sequence sequence=(Sequence)sequences.get(i);
        sequence.close();
      }
      ObjectArray triggers=getAllSchemaObjects(DbObject.TRIGGER);
      for (int i=0; i < triggers.size(); i++) {
        TriggerObject trigger=(TriggerObject)triggers.get(i);
        trigger.close();
      }
      meta.close(systemSession);
      systemSession.commit(true);
      indexSummaryValid=true;
    }
  }
 catch (  SQLException e) {
    traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
  }
  if (persistent) {
    try {
      ValueLob.removeAllForTable(this,ValueLob.TABLE_ID_SESSION_VARIABLE);
    }
 catch (    SQLException e) {
      traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
    }
  }
  tempFileDeleter.deleteAll();
  try {
    closeOpenFilesAndUnlock(true);
  }
 catch (  SQLException e) {
    traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
  }
  traceSystem.getTrace(Trace.DATABASE).info(""String_Node_Str"");
  traceSystem.close();
  if (closeOnExit != null) {
    closeOnExit.reset();
    try {
      Runtime.getRuntime().removeShutdownHook(closeOnExit);
    }
 catch (    IllegalStateException e) {
    }
catch (    SecurityException e) {
    }
    closeOnExit=null;
  }
  Engine.getInstance().close(databaseName);
  if (deleteFilesOnDisconnect && persistent) {
    deleteFilesOnDisconnect=false;
    try {
      String directory=FileUtils.getParent(databaseName);
      String name=FileUtils.getFileName(databaseName);
      DeleteDbFiles.execute(directory,name,true);
    }
 catch (    Exception e) {
    }
  }
}",0.9826310225041536
16192,"private synchronized void open(int traceLevelFile,int traceLevelSystemOut) throws SQLException {
  if (persistent) {
    if (SysProperties.PAGE_STORE) {
      String pageFileName=databaseName + Constants.SUFFIX_PAGE_FILE;
      if (FileUtils.exists(pageFileName) && FileUtils.isReadOnly(pageFileName)) {
        readOnly=true;
      }
    }
    String dataFileName=databaseName + Constants.SUFFIX_DATA_FILE;
    if (FileUtils.exists(dataFileName)) {
      readOnly=readOnly | FileUtils.isReadOnly(dataFileName);
    }
    if (readOnly) {
      traceSystem=new TraceSystem(null,false);
    }
 else {
      traceSystem=new TraceSystem(databaseName + Constants.SUFFIX_TRACE_FILE,true);
    }
    traceSystem.setLevelFile(traceLevelFile);
    traceSystem.setLevelSystemOut(traceLevelSystemOut);
    traceSystem.getTrace(Trace.DATABASE).info(""String_Node_Str"" + databaseName + ""String_Node_Str""+ Constants.BUILD_ID+ ""String_Node_Str"");
    if (autoServerMode) {
      if (readOnly || fileLockMethod == FileLock.LOCK_NO) {
        throw Message.getUnsupportedException(""String_Node_Str"");
      }
    }
    if (!readOnly && fileLockMethod != FileLock.LOCK_NO) {
      lock=new FileLock(traceSystem,databaseName + Constants.SUFFIX_LOCK_FILE,Constants.LOCK_SLEEP);
      lock.lock(fileLockMethod);
      if (autoServerMode) {
        startServer(lock.getUniqueId());
      }
    }
    isReconnectNeeded();
    beforeWriting();
    if (SysProperties.PAGE_STORE) {
      starting=true;
      getPageStore();
      starting=false;
    }
    if (FileUtils.exists(dataFileName)) {
      lobFilesInDirectories&=!ValueLob.existsLobFile(getDatabasePath());
      lobFilesInDirectories|=FileUtils.exists(databaseName + Constants.SUFFIX_LOBS_DIRECTORY);
    }
    dummy=DataPage.create(this,0);
    deleteOldTempFiles();
    log=new LogSystem(this,databaseName,readOnly,accessModeLog,pageStore);
    if (pageStore == null) {
      openFileData();
      log.open();
      openFileIndex();
      log.recover();
      fileData.init();
      try {
        fileIndex.init();
      }
 catch (      Exception e) {
        if (recovery) {
          traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
          ArrayList list=new ArrayList(storageMap.values());
          for (int i=0; i < list.size(); i++) {
            Storage s=(Storage)list.get(i);
            if (s.getDiskFile() == fileIndex) {
              removeStorage(s.getId(),fileIndex);
            }
          }
          fileIndex.delete();
          openFileIndex();
        }
 else {
          throw Message.convert(e);
        }
      }
    }
    reserveLobFileObjectIds();
    writer=WriterThread.create(this,writeDelay);
  }
 else {
    traceSystem=new TraceSystem(null,false);
    log=new LogSystem(null,null,false,null,null);
  }
  systemUser=new User(this,0,Constants.DBA_NAME,true);
  mainSchema=new Schema(this,0,Constants.SCHEMA_MAIN,systemUser,true);
  infoSchema=new Schema(this,-1,Constants.SCHEMA_INFORMATION,systemUser,true);
  schemas.put(mainSchema.getName(),mainSchema);
  schemas.put(infoSchema.getName(),infoSchema);
  publicRole=new Role(this,0,Constants.PUBLIC_ROLE_NAME,true);
  roles.put(Constants.PUBLIC_ROLE_NAME,publicRole);
  systemUser.setAdmin(true);
  systemSession=new Session(this,systemUser,++nextSessionId);
  ObjectArray cols=new ObjectArray();
  Column columnId=new Column(""String_Node_Str"",Value.INT);
  columnId.setNullable(false);
  cols.add(columnId);
  cols.add(new Column(""String_Node_Str"",Value.INT));
  cols.add(new Column(""String_Node_Str"",Value.INT));
  cols.add(new Column(""String_Node_Str"",Value.STRING));
  int headPos=0;
  if (pageStore != null) {
    headPos=pageStore.getSystemTableHeadPos();
  }
  meta=mainSchema.createTable(""String_Node_Str"",0,cols,persistent,persistent,false,headPos);
  IndexColumn[] pkCols=IndexColumn.wrap(new Column[]{columnId});
  metaIdIndex=meta.addIndex(systemSession,""String_Node_Str"",0,pkCols,IndexType.createPrimaryKey(false,false),Index.EMPTY_HEAD,null);
  objectIds.set(0);
  for (int i=0; i < MetaTable.getMetaTableTypeCount(); i++) {
    addMetaData(i);
  }
  starting=true;
  Cursor cursor=metaIdIndex.find(systemSession,null,null);
  ObjectArray records=new ObjectArray();
  while (cursor.next()) {
    MetaRecord rec=new MetaRecord(cursor.get());
    objectIds.set(rec.getId());
    records.add(rec);
  }
  MetaRecord.sort(records);
  for (int i=0; i < records.size(); i++) {
    MetaRecord rec=(MetaRecord)records.get(i);
    rec.execute(this,systemSession,eventListener);
  }
  recompileInvalidViews(systemSession);
  starting=false;
  addDefaultSetting(systemSession,SetTypes.DEFAULT_LOCK_TIMEOUT,null,Constants.INITIAL_LOCK_TIMEOUT);
  addDefaultSetting(systemSession,SetTypes.DEFAULT_TABLE_TYPE,null,Constants.DEFAULT_TABLE_TYPE);
  addDefaultSetting(systemSession,SetTypes.CACHE_SIZE,null,SysProperties.CACHE_SIZE_DEFAULT);
  addDefaultSetting(systemSession,SetTypes.CLUSTER,Constants.CLUSTERING_DISABLED,0);
  addDefaultSetting(systemSession,SetTypes.WRITE_DELAY,null,Constants.DEFAULT_WRITE_DELAY);
  addDefaultSetting(systemSession,SetTypes.CREATE_BUILD,null,Constants.BUILD_ID);
  if (!readOnly) {
    removeUnusedStorages(systemSession);
  }
  systemSession.commit(true);
  traceSystem.getTrace(Trace.DATABASE).info(""String_Node_Str"" + databaseName);
  afterWriting();
}","private synchronized void open(int traceLevelFile,int traceLevelSystemOut) throws SQLException {
  if (persistent) {
    if (SysProperties.PAGE_STORE) {
      String pageFileName=databaseName + Constants.SUFFIX_PAGE_FILE;
      if (FileUtils.exists(pageFileName) && FileUtils.isReadOnly(pageFileName)) {
        readOnly=true;
      }
    }
    String dataFileName=databaseName + Constants.SUFFIX_DATA_FILE;
    if (FileUtils.exists(dataFileName)) {
      readOnly=readOnly | FileUtils.isReadOnly(dataFileName);
    }
    if (readOnly) {
      traceSystem=new TraceSystem(null,false);
    }
 else {
      traceSystem=new TraceSystem(databaseName + Constants.SUFFIX_TRACE_FILE,true);
    }
    traceSystem.setLevelFile(traceLevelFile);
    traceSystem.setLevelSystemOut(traceLevelSystemOut);
    traceSystem.getTrace(Trace.DATABASE).info(""String_Node_Str"" + databaseName + ""String_Node_Str""+ Constants.BUILD_ID+ ""String_Node_Str"");
    if (autoServerMode) {
      if (readOnly || fileLockMethod == FileLock.LOCK_NO) {
        throw Message.getUnsupportedException(""String_Node_Str"");
      }
    }
    if (!readOnly && fileLockMethod != FileLock.LOCK_NO) {
      lock=new FileLock(traceSystem,databaseName + Constants.SUFFIX_LOCK_FILE,Constants.LOCK_SLEEP);
      lock.lock(fileLockMethod);
      if (autoServerMode) {
        startServer(lock.getUniqueId());
      }
    }
    isReconnectNeeded();
    while (!beforeWriting()) {
    }
    if (SysProperties.PAGE_STORE) {
      starting=true;
      getPageStore();
      starting=false;
    }
    if (FileUtils.exists(dataFileName)) {
      lobFilesInDirectories&=!ValueLob.existsLobFile(getDatabasePath());
      lobFilesInDirectories|=FileUtils.exists(databaseName + Constants.SUFFIX_LOBS_DIRECTORY);
    }
    dummy=DataPage.create(this,0);
    deleteOldTempFiles();
    log=new LogSystem(this,databaseName,readOnly,accessModeLog,pageStore);
    if (pageStore == null) {
      openFileData();
      log.open();
      openFileIndex();
      log.recover();
      fileData.init();
      try {
        fileIndex.init();
      }
 catch (      Exception e) {
        if (recovery) {
          traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
          ArrayList list=new ArrayList(storageMap.values());
          for (int i=0; i < list.size(); i++) {
            Storage s=(Storage)list.get(i);
            if (s.getDiskFile() == fileIndex) {
              removeStorage(s.getId(),fileIndex);
            }
          }
          fileIndex.delete();
          openFileIndex();
        }
 else {
          throw Message.convert(e);
        }
      }
    }
    reserveLobFileObjectIds();
    writer=WriterThread.create(this,writeDelay);
  }
 else {
    traceSystem=new TraceSystem(null,false);
    log=new LogSystem(null,null,false,null,null);
  }
  systemUser=new User(this,0,Constants.DBA_NAME,true);
  mainSchema=new Schema(this,0,Constants.SCHEMA_MAIN,systemUser,true);
  infoSchema=new Schema(this,-1,Constants.SCHEMA_INFORMATION,systemUser,true);
  schemas.put(mainSchema.getName(),mainSchema);
  schemas.put(infoSchema.getName(),infoSchema);
  publicRole=new Role(this,0,Constants.PUBLIC_ROLE_NAME,true);
  roles.put(Constants.PUBLIC_ROLE_NAME,publicRole);
  systemUser.setAdmin(true);
  systemSession=new Session(this,systemUser,++nextSessionId);
  ObjectArray cols=new ObjectArray();
  Column columnId=new Column(""String_Node_Str"",Value.INT);
  columnId.setNullable(false);
  cols.add(columnId);
  cols.add(new Column(""String_Node_Str"",Value.INT));
  cols.add(new Column(""String_Node_Str"",Value.INT));
  cols.add(new Column(""String_Node_Str"",Value.STRING));
  int headPos=0;
  if (pageStore != null) {
    headPos=pageStore.getSystemTableHeadPos();
  }
  meta=mainSchema.createTable(""String_Node_Str"",0,cols,persistent,persistent,false,headPos);
  IndexColumn[] pkCols=IndexColumn.wrap(new Column[]{columnId});
  metaIdIndex=meta.addIndex(systemSession,""String_Node_Str"",0,pkCols,IndexType.createPrimaryKey(false,false),Index.EMPTY_HEAD,null);
  objectIds.set(0);
  for (int i=0; i < MetaTable.getMetaTableTypeCount(); i++) {
    addMetaData(i);
  }
  starting=true;
  Cursor cursor=metaIdIndex.find(systemSession,null,null);
  ObjectArray records=new ObjectArray();
  while (cursor.next()) {
    MetaRecord rec=new MetaRecord(cursor.get());
    objectIds.set(rec.getId());
    records.add(rec);
  }
  MetaRecord.sort(records);
  for (int i=0; i < records.size(); i++) {
    MetaRecord rec=(MetaRecord)records.get(i);
    rec.execute(this,systemSession,eventListener);
  }
  recompileInvalidViews(systemSession);
  starting=false;
  addDefaultSetting(systemSession,SetTypes.DEFAULT_LOCK_TIMEOUT,null,Constants.INITIAL_LOCK_TIMEOUT);
  addDefaultSetting(systemSession,SetTypes.DEFAULT_TABLE_TYPE,null,Constants.DEFAULT_TABLE_TYPE);
  addDefaultSetting(systemSession,SetTypes.CACHE_SIZE,null,SysProperties.CACHE_SIZE_DEFAULT);
  addDefaultSetting(systemSession,SetTypes.CLUSTER,Constants.CLUSTERING_DISABLED,0);
  addDefaultSetting(systemSession,SetTypes.WRITE_DELAY,null,Constants.DEFAULT_WRITE_DELAY);
  addDefaultSetting(systemSession,SetTypes.CREATE_BUILD,null,Constants.BUILD_ID);
  if (!readOnly) {
    removeUnusedStorages(systemSession);
  }
  systemSession.commit(true);
  traceSystem.getTrace(Trace.DATABASE).info(""String_Node_Str"" + databaseName);
}",0.9966209874225644
16193,"public boolean isReconnectNeeded(){
  if (fileLockMethod != FileLock.LOCK_SERIALIZED) {
    return false;
  }
  long now=System.currentTimeMillis();
  if (now < reconnectCheckNext) {
    return false;
  }
  reconnectCheckNext=now + SysProperties.RECONNECT_CHECK_DELAY;
  if (lock == null) {
    lock=new FileLock(traceSystem,databaseName + Constants.SUFFIX_LOCK_FILE,Constants.LOCK_SLEEP);
  }
  Properties prop;
  try {
    while (true) {
      prop=lock.load();
      if (prop.equals(reconnectLastLock)) {
        return false;
      }
      if (prop.getProperty(""String_Node_Str"",null) == null) {
        break;
      }
      if (System.currentTimeMillis() > now + SysProperties.RECONNECT_CHECK_DELAY * 4) {
        lock.setProperty(""String_Node_Str"",null);
        lock.save();
        break;
      }
      getTrace().debug(""String_Node_Str"");
      Thread.sleep(SysProperties.RECONNECT_CHECK_DELAY);
    }
    reconnectLastLock=prop;
  }
 catch (  Exception e) {
    getTrace().error(""String_Node_Str"" + readOnly,e);
  }
  return true;
}","/** 
 * Check if the contents of the database was changed and therefore it is required to re-connect. This method waits until pending changes are completed. If a pending change takes too long (more than 2 seconds), the pending change is broken.
 * @return true if reconnecting is required
 */
public boolean isReconnectNeeded(){
  if (fileLockMethod != FileLock.LOCK_SERIALIZED) {
    return false;
  }
  if (reconnectChangePending) {
    return false;
  }
  long now=System.currentTimeMillis();
  if (now < reconnectCheckNext) {
    return false;
  }
  reconnectCheckNext=now + SysProperties.RECONNECT_CHECK_DELAY;
  if (lock == null) {
    lock=new FileLock(traceSystem,databaseName + Constants.SUFFIX_LOCK_FILE,Constants.LOCK_SLEEP);
  }
  try {
    Properties prop=lock.load(), first=prop;
    while (true) {
      if (prop.equals(reconnectLastLock)) {
        return false;
      }
      if (prop.getProperty(""String_Node_Str"",null) == null) {
        break;
      }
      if (System.currentTimeMillis() > now + SysProperties.RECONNECT_CHECK_DELAY * 10) {
        if (first.equals(prop)) {
          lock.setProperty(""String_Node_Str"",null);
          lock.save();
          break;
        }
      }
      getTrace().debug(""String_Node_Str"");
      Thread.sleep(SysProperties.RECONNECT_CHECK_DELAY);
      prop=lock.load();
    }
    reconnectLastLock=prop;
  }
 catch (  Exception e) {
    getTrace().error(""String_Node_Str"" + readOnly,e);
  }
  return true;
}",0.7902711323763956
16194,"private synchronized void closeOpenFilesAndUnlock(boolean checkpoint) throws SQLException {
  if (log != null) {
    stopWriter();
    try {
      log.close(checkpoint);
    }
 catch (    Throwable e) {
      traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
    }
    log=null;
  }
  if (pageStore != null) {
    if (checkpoint) {
      pageStore.checkpoint();
    }
  }
  closeFiles();
  if (persistent && lock == null && fileLockMethod != FileLock.LOCK_NO) {
    return;
  }
  if (persistent) {
    deleteOldTempFiles();
  }
  if (systemSession != null) {
    systemSession.close();
    systemSession=null;
  }
  if (lock != null) {
    if (fileLockMethod != FileLock.LOCK_SERIALIZED) {
      lock.unlock();
    }
    lock=null;
  }
}","private synchronized void closeOpenFilesAndUnlock(boolean checkpoint) throws SQLException {
  if (log != null) {
    stopWriter();
    try {
      log.close(checkpoint);
    }
 catch (    Throwable e) {
      traceSystem.getTrace(Trace.DATABASE).error(""String_Node_Str"",e);
    }
    log=null;
  }
  if (pageStore != null) {
    if (checkpoint) {
      pageStore.checkpoint();
    }
  }
  reconnectModified(false);
  closeFiles();
  if (persistent && lock == null && fileLockMethod != FileLock.LOCK_NO) {
    return;
  }
  if (persistent) {
    deleteOldTempFiles();
  }
  if (systemSession != null) {
    systemSession.close();
    systemSession=null;
  }
  if (lock != null) {
    if (fileLockMethod != FileLock.LOCK_SERIALIZED) {
      lock.unlock();
    }
    lock=null;
  }
}",0.9817232375979112
16195,"public void checkWritingAllowed() throws SQLException {
  if (readOnly) {
    throw Message.getSQLException(ErrorCode.DATABASE_IS_READ_ONLY);
  }
  if (noDiskSpace) {
    throw Message.getSQLException(ErrorCode.NO_DISK_SPACE_AVAILABLE);
  }
}","public void checkWritingAllowed() throws SQLException {
  if (readOnly) {
    throw Message.getSQLException(ErrorCode.DATABASE_IS_READ_ONLY);
  }
  if (noDiskSpace) {
    throw Message.getSQLException(ErrorCode.NO_DISK_SPACE_AVAILABLE);
  }
  if (fileLockMethod == FileLock.LOCK_SERIALIZED) {
    if (!reconnectChangePending) {
      throw Message.getSQLException(ErrorCode.DATABASE_IS_READ_ONLY);
    }
  }
}",0.7434715821812596
16196,"private void reconnectModified(boolean pending){
  if (readOnly || lock == null) {
    return;
  }
  try {
    if (pending == reconnectChangePending) {
      long now=System.currentTimeMillis();
      if (now > reconnectCheckNext) {
        lock.save();
        reconnectCheckNext=now + SysProperties.RECONNECT_CHECK_DELAY;
      }
      return;
    }
    if (pending) {
      getTrace().debug(""String_Node_Str"");
      Thread.sleep((int)(SysProperties.RECONNECT_CHECK_DELAY * 1.1));
    }
    lock.setProperty(""String_Node_Str"",Long.toString(modificationDataId));
    lock.setProperty(""String_Node_Str"",Long.toString(modificationMetaId));
    lock.setProperty(""String_Node_Str"",pending ? ""String_Node_Str"" : null);
    lock.save();
    reconnectLastLock=lock.load();
    reconnectChangePending=pending;
    reconnectCheckNext=System.currentTimeMillis() + SysProperties.RECONNECT_CHECK_DELAY;
  }
 catch (  Exception e) {
    getTrace().error(""String_Node_Str"" + pending,e);
  }
}","/** 
 * Set or reset the pending change flag in the .lock.db file.
 * @param pending the new value of the flag
 * @return true if the call was successful,false if another connection was faster
 */
synchronized boolean reconnectModified(boolean pending){
  if (readOnly || lock == null || fileLockMethod != FileLock.LOCK_SERIALIZED) {
    return true;
  }
  try {
    if (pending == reconnectChangePending) {
      long now=System.currentTimeMillis();
      if (now > reconnectCheckNext) {
        if (pending) {
          String pos=log == null ? null : log.getWritePos();
          lock.setProperty(""String_Node_Str"",pos);
          lock.save();
        }
        reconnectCheckNext=now + SysProperties.RECONNECT_CHECK_DELAY;
      }
      return true;
    }
    Properties old=lock.load();
    if (pending) {
      getTrace().debug(""String_Node_Str"");
      Thread.sleep((int)(SysProperties.RECONNECT_CHECK_DELAY * 1.1));
      Properties now=lock.load();
      if (!now.equals(old)) {
        return false;
      }
    }
    String pos=log == null ? null : log.getWritePos();
    lock.setProperty(""String_Node_Str"",pos);
    lock.setProperty(""String_Node_Str"",pending ? ""String_Node_Str"" : null);
    old=lock.save();
    if (pending) {
      getTrace().debug(""String_Node_Str"");
      Thread.sleep((int)(SysProperties.RECONNECT_CHECK_DELAY * 1.1));
      Properties now=lock.load();
      if (!now.equals(old)) {
        return false;
      }
    }
    reconnectLastLock=old;
    reconnectChangePending=pending;
    reconnectCheckNext=System.currentTimeMillis() + SysProperties.RECONNECT_CHECK_DELAY;
    return true;
  }
 catch (  Exception e) {
    getTrace().error(""String_Node_Str"" + pending,e);
    return false;
  }
}",0.5164388622090875
16197,"private void unlockAll() throws SQLException {
  if (SysProperties.CHECK) {
    if (undoLog.size() > 0) {
      Message.throwInternalError();
    }
  }
  database.afterWriting();
  if (locks.size() > 0) {
synchronized (database) {
      for (int i=0; i < locks.size(); i++) {
        Table t=(Table)locks.get(i);
        t.unlock(this);
      }
      locks.clear();
    }
  }
  savepoints=null;
  if (modificationIdState != modificationId) {
    sessionStateChanged=true;
  }
}","private void unlockAll() throws SQLException {
  if (SysProperties.CHECK) {
    if (undoLog.size() > 0) {
      Message.throwInternalError();
    }
  }
  if (locks.size() > 0) {
synchronized (database) {
      for (int i=0; i < locks.size(); i++) {
        Table t=(Table)locks.get(i);
        t.unlock(this);
      }
      locks.clear();
    }
  }
  savepoints=null;
  if (modificationIdState != modificationId) {
    sessionStateChanged=true;
  }
}",0.970873786407767
16198,"public boolean isReconnectNeeded(){
  return database.isReconnectNeeded();
}","public boolean isReconnectNeeded(boolean write){
  while (true) {
    boolean reconnect=database.isReconnectNeeded();
    if (reconnect) {
      return true;
    }
    if (write) {
      if (database.beforeWriting()) {
        return false;
      }
    }
 else {
      return false;
    }
  }
}",0.3405405405405405
16199,"/** 
 * Check if the database changed and therefore reconnecting is required.
 * @return true if reconnecting is required
 */
boolean isReconnectNeeded();","/** 
 * Check if the database changed and therefore reconnecting is required.
 * @param write if the next operation may be writing
 * @return true if reconnecting is required
 */
boolean isReconnectNeeded(boolean write);",0.8235294117647058
16200,"public boolean isReconnectNeeded(){
  return false;
}","public boolean isReconnectNeeded(boolean write){
  return false;
}",0.8907563025210085
16201,"private void mapAndAddFilter(Expression on) throws SQLException {
  on.mapColumns(this,0);
  addFilterCondition(on,true);
  on.createIndexConditions(session,this);
  if (join != null) {
    join.mapAndAddFilter(on);
  }
}","/** 
 * Map the columns and add the join condition.
 * @param on the condition
 */
public void mapAndAddFilter(Expression on) throws SQLException {
  on.mapColumns(this,0);
  addFilterCondition(on,true);
  on.createIndexConditions(session,this);
  if (join != null) {
    join.mapAndAddFilter(on);
  }
}",0.816793893129771
16202,"private void reconnectModified(boolean pending){
  if (readOnly || pending == reconnectChangePending || lock == null) {
    return;
  }
  try {
    if (pending) {
      getTrace().debug(""String_Node_Str"");
      Thread.sleep((int)(SysProperties.RECONNECT_CHECK_DELAY * 1.1));
    }
    lock.setProperty(""String_Node_Str"",Long.toString(modificationDataId));
    lock.setProperty(""String_Node_Str"",Long.toString(modificationMetaId));
    lock.setProperty(""String_Node_Str"",pending ? ""String_Node_Str"" : null);
    lock.save();
    reconnectChangePending=pending;
  }
 catch (  Exception e) {
    getTrace().error(""String_Node_Str"" + pending,e);
  }
}","private void reconnectModified(boolean pending){
  if (readOnly || pending == reconnectChangePending || lock == null) {
    return;
  }
  try {
    if (pending) {
      getTrace().debug(""String_Node_Str"");
      Thread.sleep((int)(SysProperties.RECONNECT_CHECK_DELAY * 1.1));
    }
    lock.setProperty(""String_Node_Str"",Long.toString(modificationDataId));
    lock.setProperty(""String_Node_Str"",Long.toString(modificationMetaId));
    lock.setProperty(""String_Node_Str"",pending ? ""String_Node_Str"" : null);
    lock.save();
    reconnectLastLock=lock.load();
    reconnectChangePending=pending;
  }
 catch (  Exception e) {
    getTrace().error(""String_Node_Str"" + pending,e);
  }
}",0.9737039819684448
16203,"public SessionInterface reconnect() throws SQLException {
  readSessionState();
  Session newSession=Engine.getInstance().getSession(connectionInfo);
  newSession.sessionState=sessionState;
  newSession.recreateSessionState();
  return newSession;
}","public SessionInterface reconnect() throws SQLException {
  readSessionState();
  close();
  Session newSession=Engine.getInstance().getSession(connectionInfo);
  newSession.sessionState=sessionState;
  newSession.recreateSessionState();
  return newSession;
}",0.9783889980353636
16204,"/** 
 * Close the log file.
 * @param delete if the file should be deleted shortly afterwards
 */
void close(boolean delete) throws SQLException {
  SQLException closeException=null;
  try {
    flush();
  }
 catch (  SQLException e) {
    closeException=e;
  }
  if (file != null) {
    try {
      file.close();
      file=null;
      if (delete) {
        database.deleteLogFileLater(fileName);
      }
    }
 catch (    IOException e) {
      if (closeException == null) {
        closeException=Message.convertIOException(e,fileName);
      }
    }
    file=null;
    fileNamePrefix=null;
  }
  if (closeException != null) {
    throw closeException;
  }
}","/** 
 * Close the log file.
 * @param delete if the file should be deleted shortly afterwards
 */
void close(boolean delete) throws SQLException {
  SQLException closeException=null;
  try {
    flush();
  }
 catch (  SQLException e) {
    closeException=e;
  }
  if (file != null) {
    try {
      file.close();
      file=null;
      if (delete) {
        try {
          database.deleteLogFileLater(fileName);
        }
 catch (        SQLException e) {
        }
      }
    }
 catch (    IOException e) {
      if (closeException == null) {
        closeException=Message.convertIOException(e,fileName);
      }
    }
    file=null;
    fileNamePrefix=null;
  }
  if (closeException != null) {
    throw closeException;
  }
}",0.9497126436781608
16205,"/** 
 * Get the index of the next bit that is not set.
 * @param fromIndex where to start searching
 * @return the index of the next disabled bit
 */
public int nextClearBit(int fromIndex){
  int i=fromIndex >> ADDRESS_BITS;
  int max=data.length;
  for (; i < max; i++) {
    if (data[i] == -1) {
      continue;
    }
    int j=Math.max(fromIndex,i << ADDRESS_BITS);
    for (int end=j + 64; j < end; j++) {
      if (!get(j)) {
        return j;
      }
    }
  }
  return fromIndex;
}","/** 
 * Get the index of the next bit that is not set.
 * @param fromIndex where to start searching
 * @return the index of the next disabled bit
 */
public int nextClearBit(int fromIndex){
  int i=fromIndex >> ADDRESS_BITS;
  int max=data.length;
  for (; i < max; i++) {
    if (data[i] == -1) {
      continue;
    }
    int j=Math.max(fromIndex,i << ADDRESS_BITS);
    for (int end=j + 64; j < end; j++) {
      if (!get(j)) {
        return j;
      }
    }
  }
  return max << ADDRESS_BITS;
}",0.9716024340770792
16206,"/** 
 * Get the index of the last bit that is set.
 * @return the index of the last enabled bit
 */
public int getLastSetBit(){
  int i=(data.length << ADDRESS_BITS) - 1;
  while (i >= 0) {
    if (get(i)) {
      return i;
    }
    i--;
  }
  return -1;
}","/** 
 * Get the index of the last bit that is set.
 * @return the index of the last enabled bit, or -1
 */
public int getLastSetBit(){
  int i=(data.length << ADDRESS_BITS) - 1;
  while (i >= 0) {
    if (get(i)) {
      return i;
    }
    i--;
  }
  return -1;
}",0.9865642994241842
16207,"private Expression readCondition() throws SQLException {
  if (readIf(""String_Node_Str"")) {
    return new ConditionNot(readCondition());
  }
  if (readIf(""String_Node_Str"")) {
    read(""String_Node_Str"");
    Query query=parseSelect();
    read(""String_Node_Str"");
    return new ConditionExists(query);
  }
  Expression r=readConcat();
  while (true) {
    int backup=parseIndex;
    boolean not=false;
    if (readIf(""String_Node_Str"")) {
      not=true;
      if (isToken(""String_Node_Str"")) {
        parseIndex=backup;
        currentToken=""String_Node_Str"";
        break;
      }
    }
    if (readIf(""String_Node_Str"")) {
      Expression b=readConcat();
      Expression esc=null;
      if (readIf(""String_Node_Str"")) {
        esc=readConcat();
      }
      recompileAlways=true;
      r=new CompareLike(database.getCompareMode(),r,b,esc,false);
    }
 else     if (readIf(""String_Node_Str"")) {
      Expression b=readConcat();
      r=new CompareLike(database.getCompareMode(),r,b,null,true);
    }
 else     if (readIf(""String_Node_Str"")) {
      int type;
      if (readIf(""String_Node_Str"")) {
        type=Comparison.IS_NOT_NULL;
      }
 else {
        type=Comparison.IS_NULL;
      }
      read(""String_Node_Str"");
      r=new Comparison(session,type,r,null);
    }
 else     if (readIf(""String_Node_Str"")) {
      if (SysProperties.OPTIMIZE_IN) {
        recompileAlways=true;
      }
      read(""String_Node_Str"");
      if (readIf(""String_Node_Str"")) {
        r=ValueExpression.get(ValueBoolean.get(false));
      }
 else {
        if (isToken(""String_Node_Str"") || isToken(""String_Node_Str"")) {
          Query query=parseSelect();
          r=new ConditionInSelect(database,r,query,false,Comparison.EQUAL);
        }
 else {
          ObjectArray v=new ObjectArray();
          Expression last;
          do {
            last=readExpression();
            v.add(last);
          }
 while (readIf(""String_Node_Str""));
          if (v.size() == 1 && (last instanceof Subquery)) {
            Subquery s=(Subquery)last;
            Query q=s.getQuery();
            r=new ConditionInSelect(database,r,q,false,Comparison.EQUAL);
          }
 else {
            r=new ConditionIn(database,r,v);
          }
        }
        read(""String_Node_Str"");
      }
    }
 else     if (readIf(""String_Node_Str"")) {
      Expression low=readConcat();
      read(""String_Node_Str"");
      Expression high=readConcat();
      Expression condLow=new Comparison(session,Comparison.SMALLER_EQUAL,low,r);
      Expression condHigh=new Comparison(session,Comparison.BIGGER_EQUAL,high,r);
      r=new ConditionAndOr(ConditionAndOr.AND,condLow,condHigh);
    }
 else {
      int compareType=getCompareType(currentTokenType);
      if (compareType < 0) {
        break;
      }
      read();
      if (readIf(""String_Node_Str"")) {
        read(""String_Node_Str"");
        Query query=parseSelect();
        r=new ConditionInSelect(database,r,query,true,compareType);
        read(""String_Node_Str"");
      }
 else       if (readIf(""String_Node_Str"") || readIf(""String_Node_Str"")) {
        read(""String_Node_Str"");
        Query query=parseSelect();
        r=new ConditionInSelect(database,r,query,false,compareType);
        read(""String_Node_Str"");
      }
 else {
        Expression right=readConcat();
        if (readIf(""String_Node_Str"") && readIf(""String_Node_Str"") && readIf(""String_Node_Str"")) {
          if (r instanceof ExpressionColumn && right instanceof ExpressionColumn) {
            ExpressionColumn leftCol=(ExpressionColumn)r;
            ExpressionColumn rightCol=(ExpressionColumn)right;
            ObjectArray filters=currentSelect.getTopFilters();
            for (int i=0; filters != null && i < filters.size(); i++) {
              TableFilter f=(TableFilter)filters.get(i);
              while (f != null) {
                leftCol.mapColumns(f,0);
                rightCol.mapColumns(f,0);
                f=f.getJoin();
              }
            }
            TableFilter leftFilter=leftCol.getTableFilter();
            TableFilter rightFilter=rightCol.getTableFilter();
            r=new Comparison(session,compareType,r,right);
            if (leftFilter != null && rightFilter != null) {
              filters.remove(filters.indexOf(rightFilter));
              leftFilter.addJoin(rightFilter,true,r);
              r=ValueExpression.get(ValueBoolean.get(true));
            }
          }
        }
 else {
          r=new Comparison(session,compareType,r,right);
        }
      }
    }
    if (not) {
      r=new ConditionNot(r);
    }
  }
  return r;
}","private Expression readCondition() throws SQLException {
  if (readIf(""String_Node_Str"")) {
    return new ConditionNot(readCondition());
  }
  if (readIf(""String_Node_Str"")) {
    read(""String_Node_Str"");
    Query query=parseSelect();
    read(""String_Node_Str"");
    return new ConditionExists(query);
  }
  Expression r=readConcat();
  while (true) {
    int backup=parseIndex;
    boolean not=false;
    if (readIf(""String_Node_Str"")) {
      not=true;
      if (isToken(""String_Node_Str"")) {
        parseIndex=backup;
        currentToken=""String_Node_Str"";
        break;
      }
    }
    if (readIf(""String_Node_Str"")) {
      Expression b=readConcat();
      Expression esc=null;
      if (readIf(""String_Node_Str"")) {
        esc=readConcat();
      }
      recompileAlways=true;
      r=new CompareLike(database.getCompareMode(),r,b,esc,false);
    }
 else     if (readIf(""String_Node_Str"")) {
      Expression b=readConcat();
      r=new CompareLike(database.getCompareMode(),r,b,null,true);
    }
 else     if (readIf(""String_Node_Str"")) {
      int type;
      if (readIf(""String_Node_Str"")) {
        type=Comparison.IS_NOT_NULL;
      }
 else {
        type=Comparison.IS_NULL;
      }
      read(""String_Node_Str"");
      r=new Comparison(session,type,r,null);
    }
 else     if (readIf(""String_Node_Str"")) {
      if (SysProperties.OPTIMIZE_IN) {
        recompileAlways=true;
      }
      read(""String_Node_Str"");
      if (readIf(""String_Node_Str"")) {
        r=ValueExpression.get(ValueBoolean.get(false));
      }
 else {
        if (isToken(""String_Node_Str"") || isToken(""String_Node_Str"")) {
          Query query=parseSelect();
          r=new ConditionInSelect(database,r,query,false,Comparison.EQUAL);
        }
 else {
          ObjectArray v=new ObjectArray();
          Expression last;
          do {
            last=readExpression();
            v.add(last);
          }
 while (readIf(""String_Node_Str""));
          if (v.size() == 1 && (last instanceof Subquery)) {
            Subquery s=(Subquery)last;
            Query q=s.getQuery();
            r=new ConditionInSelect(database,r,q,false,Comparison.EQUAL);
          }
 else {
            r=new ConditionIn(database,r,v);
          }
        }
        read(""String_Node_Str"");
      }
    }
 else     if (readIf(""String_Node_Str"")) {
      Expression low=readConcat();
      read(""String_Node_Str"");
      Expression high=readConcat();
      Expression condLow=new Comparison(session,Comparison.SMALLER_EQUAL,low,r);
      Expression condHigh=new Comparison(session,Comparison.BIGGER_EQUAL,high,r);
      r=new ConditionAndOr(ConditionAndOr.AND,condLow,condHigh);
    }
 else {
      int compareType=getCompareType(currentTokenType);
      if (compareType < 0) {
        break;
      }
      read();
      if (readIf(""String_Node_Str"")) {
        read(""String_Node_Str"");
        Query query=parseSelect();
        r=new ConditionInSelect(database,r,query,true,compareType);
        read(""String_Node_Str"");
      }
 else       if (readIf(""String_Node_Str"") || readIf(""String_Node_Str"")) {
        read(""String_Node_Str"");
        Query query=parseSelect();
        r=new ConditionInSelect(database,r,query,false,compareType);
        read(""String_Node_Str"");
      }
 else {
        Expression right=readConcat();
        if (readIf(""String_Node_Str"") && readIf(""String_Node_Str"") && readIf(""String_Node_Str"")) {
          if (r instanceof ExpressionColumn && right instanceof ExpressionColumn) {
            ExpressionColumn leftCol=(ExpressionColumn)r;
            ExpressionColumn rightCol=(ExpressionColumn)right;
            ObjectArray filters=currentSelect.getTopFilters();
            for (int i=0; filters != null && i < filters.size(); i++) {
              TableFilter f=(TableFilter)filters.get(i);
              while (f != null) {
                leftCol.mapColumns(f,0);
                rightCol.mapColumns(f,0);
                f=f.getJoin();
              }
            }
            TableFilter leftFilter=leftCol.getTableFilter();
            TableFilter rightFilter=rightCol.getTableFilter();
            r=new Comparison(session,compareType,r,right);
            if (leftFilter != null && rightFilter != null) {
              int idx=filters.indexOf(rightFilter);
              if (idx >= 0) {
                filters.remove(idx);
                leftFilter.addJoin(rightFilter,true,r);
              }
 else {
                rightFilter.mapAndAddFilter(r);
              }
              r=ValueExpression.get(ValueBoolean.get(true));
            }
          }
        }
 else {
          r=new Comparison(session,compareType,r,right);
        }
      }
    }
    if (not) {
      r=new ConditionNot(r);
    }
  }
  return r;
}",0.9801905985651568
16208,"private void initialize(String sql) throws SQLException {
  if (sql == null) {
    sql=""String_Node_Str"";
  }
  originalSQL=sql;
  sqlCommand=sql;
  int len=sql.length() + 1;
  char[] command=new char[len];
  int[] types=new int[len];
  len--;
  sql.getChars(0,len,command,0);
  boolean changed=false;
  command[len]=' ';
  int startLoop=0;
  for (int i=0; i < len; i++) {
    char c=command[i];
    int type=0;
switch (c) {
case '/':
      if (command[i + 1] == '*') {
        changed=true;
        command[i]=' ';
        command[i + 1]=' ';
        startLoop=i;
        i+=2;
        checkRunOver(i,len,startLoop);
        while (command[i] != '*' || command[i + 1] != '/') {
          command[i++]=' ';
          checkRunOver(i,len,startLoop);
        }
        command[i]=' ';
        command[i + 1]=' ';
        i++;
      }
 else       if (command[i + 1] == '/') {
        changed=true;
        startLoop=i;
        while (true) {
          c=command[i];
          if (c == '\n' || c == '\r' || i >= len - 1) {
            break;
          }
          command[i++]=' ';
          checkRunOver(i,len,startLoop);
        }
      }
 else {
        type=CHAR_SPECIAL_1;
      }
    break;
case '-':
  if (command[i + 1] == '-') {
    changed=true;
    startLoop=i;
    while (true) {
      c=command[i];
      if (c == '\n' || c == '\r' || i >= len - 1) {
        break;
      }
      command[i++]=' ';
      checkRunOver(i,len,startLoop);
    }
  }
 else {
    type=CHAR_SPECIAL_1;
  }
break;
case '$':
if (SysProperties.DOLLAR_QUOTING && command[i + 1] == '$' && (i == 0 || command[i - 1] <= ' ')) {
changed=true;
command[i]=' ';
command[i + 1]=' ';
startLoop=i;
i+=2;
checkRunOver(i,len,startLoop);
while (command[i] != '$' || command[i + 1] != '$') {
  types[i++]=CHAR_DOLLAR_QUOTED_STRING;
  checkRunOver(i,len,startLoop);
}
command[i]=' ';
command[i + 1]=' ';
i++;
}
 else {
type=CHAR_SPECIAL_1;
}
break;
case '(':
case ')':
case '{':
case '}':
case '*':
case ',':
case ';':
case '+':
case '%':
case '?':
case '@':
case ']':
type=CHAR_SPECIAL_1;
break;
case '!':
case '<':
case '>':
case '|':
case '=':
case ':':
case '~':
type=CHAR_SPECIAL_2;
break;
case '.':
type=CHAR_DECIMAL;
break;
case '\'':
type=types[i]=CHAR_STRING;
startLoop=i;
while (command[++i] != '\'') {
checkRunOver(i,len,startLoop);
}
break;
case '[':
if (database.getMode().squareBracketQuotedNames) {
command[i]='""';
changed=true;
type=types[i]=CHAR_QUOTED;
startLoop=i;
while (command[++i] != ']') {
checkRunOver(i,len,startLoop);
}
command[i]='""';
}
 else {
type=CHAR_SPECIAL_1;
}
break;
case '`':
command[i]='""';
changed=true;
type=types[i]=CHAR_QUOTED;
startLoop=i;
while (command[++i] != '`') {
checkRunOver(i,len,startLoop);
c=command[i];
command[i]=Character.toUpperCase(c);
}
command[i]='""';
break;
case '\""':
type=types[i]=CHAR_QUOTED;
startLoop=i;
while (command[++i] != '\""') {
checkRunOver(i,len,startLoop);
}
break;
case '_':
type=CHAR_NAME;
break;
default :
if (c >= 'a' && c <= 'z') {
command[i]=(char)(c - ('a' - 'A'));
changed=true;
type=CHAR_NAME;
}
 else if (c >= 'A' && c <= 'Z') {
type=CHAR_NAME;
}
 else if (c >= '0' && c <= '9') {
type=CHAR_VALUE;
}
 else {
if (Character.isJavaIdentifierPart(c)) {
type=CHAR_NAME;
char u=Character.toUpperCase(c);
if (u != c) {
command[i]=u;
changed=true;
}
}
}
}
types[i]=(byte)type;
}
sqlCommandChars=command;
types[len]=CHAR_END;
characterTypes=types;
if (changed) {
sqlCommand=new String(command);
}
parseIndex=0;
}","private void initialize(String sql) throws SQLException {
  if (sql == null) {
    sql=""String_Node_Str"";
  }
  originalSQL=sql;
  sqlCommand=sql;
  int len=sql.length() + 1;
  char[] command=new char[len];
  int[] types=new int[len];
  len--;
  sql.getChars(0,len,command,0);
  boolean changed=false;
  command[len]=' ';
  int startLoop=0;
  for (int i=0; i < len; i++) {
    char c=command[i];
    int type=0;
switch (c) {
case '/':
      if (command[i + 1] == '*') {
        changed=true;
        command[i]=' ';
        command[i + 1]=' ';
        startLoop=i;
        i+=2;
        checkRunOver(i,len,startLoop);
        while (command[i] != '*' || command[i + 1] != '/') {
          command[i++]=' ';
          checkRunOver(i,len,startLoop);
        }
        command[i]=' ';
        command[i + 1]=' ';
        i++;
      }
 else       if (command[i + 1] == '/') {
        changed=true;
        startLoop=i;
        while (true) {
          c=command[i];
          if (c == '\n' || c == '\r' || i >= len - 1) {
            break;
          }
          command[i++]=' ';
          checkRunOver(i,len,startLoop);
        }
      }
 else {
        type=CHAR_SPECIAL_1;
      }
    break;
case '-':
  if (command[i + 1] == '-') {
    changed=true;
    startLoop=i;
    while (true) {
      c=command[i];
      if (c == '\n' || c == '\r' || i >= len - 1) {
        break;
      }
      command[i++]=' ';
      checkRunOver(i,len,startLoop);
    }
  }
 else {
    type=CHAR_SPECIAL_1;
  }
break;
case '$':
if (SysProperties.DOLLAR_QUOTING && command[i + 1] == '$' && (i == 0 || command[i - 1] <= ' ')) {
changed=true;
command[i]=' ';
command[i + 1]=' ';
startLoop=i;
i+=2;
checkRunOver(i,len,startLoop);
while (command[i] != '$' || command[i + 1] != '$') {
  types[i++]=CHAR_DOLLAR_QUOTED_STRING;
  checkRunOver(i,len,startLoop);
}
command[i]=' ';
command[i + 1]=' ';
i++;
}
 else {
type=CHAR_NAME;
}
break;
case '(':
case ')':
case '{':
case '}':
case '*':
case ',':
case ';':
case '+':
case '%':
case '?':
case '@':
case ']':
type=CHAR_SPECIAL_1;
break;
case '!':
case '<':
case '>':
case '|':
case '=':
case ':':
case '~':
type=CHAR_SPECIAL_2;
break;
case '.':
type=CHAR_DECIMAL;
break;
case '\'':
type=types[i]=CHAR_STRING;
startLoop=i;
while (command[++i] != '\'') {
checkRunOver(i,len,startLoop);
}
break;
case '[':
if (database.getMode().squareBracketQuotedNames) {
command[i]='""';
changed=true;
type=types[i]=CHAR_QUOTED;
startLoop=i;
while (command[++i] != ']') {
checkRunOver(i,len,startLoop);
}
command[i]='""';
}
 else {
type=CHAR_SPECIAL_1;
}
break;
case '`':
command[i]='""';
changed=true;
type=types[i]=CHAR_QUOTED;
startLoop=i;
while (command[++i] != '`') {
checkRunOver(i,len,startLoop);
c=command[i];
command[i]=Character.toUpperCase(c);
}
command[i]='""';
break;
case '\""':
type=types[i]=CHAR_QUOTED;
startLoop=i;
while (command[++i] != '\""') {
checkRunOver(i,len,startLoop);
}
break;
case '_':
type=CHAR_NAME;
break;
default :
if (c >= 'a' && c <= 'z') {
command[i]=(char)(c - ('a' - 'A'));
changed=true;
type=CHAR_NAME;
}
 else if (c >= 'A' && c <= 'Z') {
type=CHAR_NAME;
}
 else if (c >= '0' && c <= '9') {
type=CHAR_VALUE;
}
 else {
if (Character.isJavaIdentifierPart(c)) {
type=CHAR_NAME;
char u=Character.toUpperCase(c);
if (u != c) {
command[i]=u;
changed=true;
}
}
}
}
types[i]=(byte)type;
}
sqlCommandChars=command;
types[len]=CHAR_END;
characterTypes=types;
if (changed) {
sqlCommand=new String(command);
}
parseIndex=0;
}",0.9984064899319136
16209,"/** 
 * tests in the Chemical Component Dictionary, if this group is a polymeric group
 * @return true if a polymeric group
 */
public boolean isPolymeric();","/** 
 * Check if this group is a polymeric group, from the definition in Chemical Component Dictionary
 * @return true if a polymeric group
 */
public boolean isPolymeric();",0.7151515151515152
16210,"/** 
 * Test if this group has alternate locations.
 * @return boolean flag if there are alternate locations.
 */
public boolean hasAltLoc();","/** 
 * Check if this group has alternate location groups.
 * @return boolean flag if there are alternate locations.
 * @see #getAltLocs()
 */
public boolean hasAltLoc();",0.887459807073955
16211,"/** 
 * get an Atom Iterator.
 * @return an Iterator object
 */
public Iterator<Atom> iterator();","/** 
 * Get an Atom Iterator.
 * @return an Iterator object
 */
public Iterator<Atom> iterator();",0.9896907216494846
16212,"/** 
 * returns a dynamically created ResidueNumber for the group - this contains the chainId, resNum and insCode of the group.
 * @see ResidueNumber
 * @return ResidueNumber for the group.
 * @since 3.0
 */
public ResidueNumber getResidueNumber();","/** 
 * Returns a dynamically created ResidueNumber for the group - this contains the chainId, resNum and insCode of the group.
 * @see ResidueNumber
 * @return ResidueNumber for the group.
 * @since 3.0
 */
public ResidueNumber getResidueNumber();",0.995967741935484
16213,"/** 
 * Get the list of alternate locations.
 * @return List of other groups that are on alternate locations
 */
public List<Group> getAltLocs();","/** 
 * Get the list of other alternate location groups. <p> The main group (this group) will contain the first altloc (be it the default '.' or 'A' or a mix of '.' and 'A'). <p> This method will return the altloc groups that are not the main group, e.g.: <li> if '.' (default), 'A' and 'B' altlocs are present in file, the main group will contain the default '.' and this method will return 2 altloc groups </li> <li> if 'A' and 'B' are present in file without a default '.' group, then the main group will contain the 'A' location whilst this method will return only 1 altloc group with the 'B' location </li> <p> Note that all groups (main and altlocs) will contain all atoms, thus atoms from the default group can appear duplicated in main and altloc groups. <p> Thus it can happen that an altloc group duplicate the contents of the main group.
 * @return List of other groups that are on alternate locations
 */
public List<Group> getAltLocs();",0.2303473491773309
16214,"/** 
 * get a single property .
 * @param key  a String
 * @return an Object
 * @see #setProperty
 */
public Object getProperty(String key);","/** 
 * Get a single property .
 * @param key  a String
 * @return an Object
 * @see #setProperty
 */
public Object getProperty(String key);",0.9928571428571428
16215,"/** 
 * attempts to reduce the memory imprint of this group by trimming all internal Collection objects to the required size.
 */
public void trimToSize();","/** 
 * Attempts to reduce the memory imprint of this group by trimming all internal Collection objects to the required size.
 */
public void trimToSize();",0.9935483870967742
16216,"/** 
 * return properties.
 * @see #setProperties
 * @return a HashMap object representing the properties value
 */
public Map<String,Object> getProperties();","/** 
 * Return properties.
 * @see #setProperties
 * @return a HashMap object representing the properties value
 */
public Map<String,Object> getProperties();",0.9936708860759492
16217,"/** 
 * Determines if this group is water.
 * @see {@link GroupType#WATERNAMES}
 * @return true if it's water, false otherwise.
 */
public boolean isWater();","/** 
 * Determines if this group is water.
 * @see GroupType#WATERNAMES
 * @return true if it's water, false otherwise.
 */
public boolean isWater();",0.9738562091503268
16218,"/** 
 * set a single property .
 * @param key    a String
 * @param value  an Object
 * @see #getProperty
 */
public void setProperty(String key,Object value);","/** 
 * Set a single property .
 * @param key    a String
 * @param value  an Object
 * @see #getProperty
 */
public void setProperty(String key,Object value);",0.9937106918238994
16219,"/** 
 * returns and identical copy of this Group object .
 * @return  and identical copy of this Group object
 */
public Object clone();","/** 
 * Returns and identical copy of this Group object .
 * @return  and identical copy of this Group object
 */
public Object clone();",0.9926470588235294
16220,"/** 
 * Tests in the Chemical Component Dictionary, if this group is an amino acid
 * @return true if an amino acid
 */
public boolean isAminoAcid();","/** 
 * Check if this group is an aminoacid group, from the definition in Chemical Component Dictionary
 * @return true if an amino acid
 */
public boolean isAminoAcid();",0.7210031347962382
16221,"/** 
 * Tests in the Chemical Component Dictionary, if this group is a nucleotide
 * @return true if a nucleotide
 */
public boolean isNucleotide();","/** 
 * Check if this group is a nucleotide group, from the definition in Chemical Component Dictionary
 * @return true if a nucleotide
 */
public boolean isNucleotide();",0.7232704402515723
16222,"/** 
 * Add a group that is an alternate location for this group.
 */
public void addAltLoc(Group g);","/** 
 * Add a group that is an alternate location for this group.
 * @param g the altloc group to add
 */
public void addAltLoc(Group g);",0.8487394957983193
16223,"/** 
 * Cleans up the structure's alternate location groups. All alternate location groups should have all atoms (except in the case of microheterogenity) or when a deuetuim exiss. Ensure that all the alt loc groups have all the atoms in the main group
 * @param structure The Structure to be cleaned up
 */
public static void cleanUpAltLocs(Structure structure){
  for (int i=0; i < structure.nrModels(); i++) {
    for (    Chain chain : structure.getModel(i)) {
      for (      Group group : chain.getAtomGroups()) {
        for (        Group altLocGroup : group.getAltLocs()) {
          for (          Atom groupAtom : group.getAtoms()) {
            if (!altLocGroup.hasAtom(groupAtom.getName())) {
              if (altLocGroup.getPDBName().equals(group.getPDBName())) {
                if (hasDeuteratedEquiv(groupAtom,altLocGroup)) {
                }
 else {
                  altLocGroup.addAtom(groupAtom);
                }
              }
            }
          }
        }
      }
    }
  }
}","/** 
 * Cleans up the structure's alternate location (altloc) groups. All alternate location groups should have all atoms (except in the case of microheterogenity) or when a deuterium exists. Ensure that all the alt loc groups have all the atoms in the main group.
 * @param structure The Structure to be cleaned up
 */
public static void cleanUpAltLocs(Structure structure){
  for (int i=0; i < structure.nrModels(); i++) {
    for (    Chain chain : structure.getModel(i)) {
      for (      Group group : chain.getAtomGroups()) {
        for (        Group altLocGroup : group.getAltLocs()) {
          for (          Atom groupAtom : group.getAtoms()) {
            if (!altLocGroup.hasAtom(groupAtom.getName())) {
              if (altLocGroup.getPDBName().equals(group.getPDBName())) {
                if (!hasDeuteratedEquiv(groupAtom,altLocGroup)) {
                  altLocGroup.addAtom(groupAtom);
                }
              }
            }
          }
        }
      }
    }
  }
}",0.9765819631290484
16224,"/** 
 * Check to see if a Hydorgen has a  Deuterated brother in the group.
 * @param atom the input atom that is putatively hydorgen
 * @param currentGroup the group the atom is in
 * @return true if the atom is hydrogen and it's Deuterium equiv exists.
 */
public static boolean hasDeuteratedEquiv(Atom atom,Group currentGroup){
  if (atom.getElement() == Element.H && currentGroup.hasAtom(replaceFirstChar(atom.getName(),'H','D'))) {
    return true;
  }
  return false;
}","/** 
 * Check to see if a Hydrogen has a  Deuterated brother in the group.
 * @param atom the input atom that is putatively hydorgen
 * @param currentGroup the group the atom is in
 * @return true if the atom is hydrogen and it's Deuterium equiv exists.
 */
public static boolean hasDeuteratedEquiv(Atom atom,Group currentGroup){
  if (atom.getElement() == Element.H && currentGroup.hasAtom(replaceFirstChar(atom.getName(),'H','D'))) {
    return true;
  }
  return false;
}",0.9957805907172996
16225,"/** 
 * Converts a Group into a List of   {@link AtomSite} objects
 * @param g
 * @param model
 * @param chainId
 * @param internalChainId
 * @return
 */
private static List<AtomSite> convertGroupToAtomSites(Group g,int model,String chainId,String internalChainId){
  List<AtomSite> list=new ArrayList<AtomSite>();
  int groupsize=g.size();
  for (int atompos=0; atompos < groupsize; atompos++) {
    Atom a=null;
    a=g.getAtom(atompos);
    if (a == null)     continue;
    list.add(convertAtomToAtomSite(a,model,chainId,internalChainId));
  }
  if (g.hasAltLoc()) {
    for (    Group alt : g.getAltLocs()) {
      list.addAll(convertGroupToAtomSites(alt,model,chainId,internalChainId));
    }
  }
  return list;
}","/** 
 * Converts a Group into a List of   {@link AtomSite} objects
 * @param g
 * @param model
 * @param chainId
 * @param internalChainId
 * @return
 */
private static List<AtomSite> convertGroupToAtomSites(Group g,int model,String chainId,String internalChainId){
  Map<Integer,AtomSite> uniqueAtomSites=new LinkedHashMap<>();
  int groupsize=g.size();
  for (int atompos=0; atompos < groupsize; atompos++) {
    Atom a=g.getAtom(atompos);
    if (a == null)     continue;
    uniqueAtomSites.put(a.getPDBserial(),convertAtomToAtomSite(a,model,chainId,internalChainId));
  }
  if (g.hasAltLoc()) {
    for (    Group alt : g.getAltLocs()) {
      for (      AtomSite atomSite : convertGroupToAtomSites(alt,model,chainId,internalChainId)) {
        uniqueAtomSites.put(Integer.parseInt(atomSite.getId()),atomSite);
      }
    }
  }
  return new ArrayList<>(uniqueAtomSites.values());
}",0.7912772585669782
16226,"@Test public void testMmcifWritingPartialAltlocs() throws IOException {
  String mmcifData=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  SimpleMMcifParser parser=new SimpleMMcifParser();
  SimpleMMcifConsumer consumer=new SimpleMMcifConsumer();
  parser.addMMcifConsumer(consumer);
  BufferedReader buf=new BufferedReader(new StringReader(mmcifData));
  parser.parse(buf);
  buf.close();
  Structure s=consumer.getStructure();
  Chain c=s.getPolyChains().get(0);
  assertEquals(1,c.getAtomGroups().size());
  Group g=c.getAtomGroup(0);
  assertEquals(11,g.size());
  assertEquals(1,g.getAltLocs().size());
  for (  Atom a : g.getAtoms()) {
    if (a.getName().equals(""String_Node_Str"") || a.getName().equals(""String_Node_Str"") || a.getName().equals(""String_Node_Str"")|| a.getName().equals(""String_Node_Str"")|| a.getName().equals(""String_Node_Str""))     assertEquals(' ',a.getAltLoc().charValue());
 else     assertEquals('A',a.getAltLoc().charValue());
  }
  assertEquals(11,g.getAltLocs().get(0).size());
  for (  Atom a : g.getAltLocs().get(0).getAtoms()) {
    if (a.getName().equals(""String_Node_Str"") || a.getName().equals(""String_Node_Str"") || a.getName().equals(""String_Node_Str"")|| a.getName().equals(""String_Node_Str"")|| a.getName().equals(""String_Node_Str""))     assertEquals(' ',a.getAltLoc().charValue());
 else     assertEquals('B',a.getAltLoc().charValue());
  }
  List<AtomSite> atomSites=MMCIFFileTools.convertChainToAtomSites(c,1,""String_Node_Str"",""String_Node_Str"");
  assertEquals(17,atomSites.size());
}","@Test public void testMmcifWritingPartialAltlocs() throws IOException {
  String mmcifData=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  SimpleMMcifParser parser=new SimpleMMcifParser();
  SimpleMMcifConsumer consumer=new SimpleMMcifConsumer();
  parser.addMMcifConsumer(consumer);
  BufferedReader buf=new BufferedReader(new StringReader(mmcifData));
  parser.parse(buf);
  buf.close();
  Structure s=consumer.getStructure();
  Chain c=s.getPolyChains().get(0);
  assertEquals(1,c.getAtomGroups().size());
  Group g=c.getAtomGroup(0);
  assertEquals(11,g.size());
  assertEquals(2,g.getAltLocs().size());
  for (  Atom a : g.getAtoms()) {
    if (a.getName().equals(""String_Node_Str"") || a.getName().equals(""String_Node_Str"") || a.getName().equals(""String_Node_Str"")|| a.getName().equals(""String_Node_Str"")|| a.getName().equals(""String_Node_Str""))     assertEquals(' ',a.getAltLoc().charValue());
 else     assertEquals('A',a.getAltLoc().charValue());
  }
  assertEquals(11,g.getAltLocs().get(0).size());
  for (  Atom a : g.getAltLocs().get(0).getAtoms()) {
    if (a.getName().equals(""String_Node_Str"") || a.getName().equals(""String_Node_Str"") || a.getName().equals(""String_Node_Str"")|| a.getName().equals(""String_Node_Str"")|| a.getName().equals(""String_Node_Str""))     assertEquals(' ',a.getAltLoc().charValue());
 else     assertEquals('A',a.getAltLoc().charValue());
  }
  assertEquals(11,g.getAltLocs().get(1).size());
  for (  Atom a : g.getAltLocs().get(1).getAtoms()) {
    if (a.getName().equals(""String_Node_Str"") || a.getName().equals(""String_Node_Str"") || a.getName().equals(""String_Node_Str"")|| a.getName().equals(""String_Node_Str"")|| a.getName().equals(""String_Node_Str""))     assertEquals(' ',a.getAltLoc().charValue());
 else     assertEquals('B',a.getAltLoc().charValue());
  }
  List<AtomSite> atomSites=MMCIFFileTools.convertChainToAtomSites(c,1,""String_Node_Str"",""String_Node_Str"");
  assertEquals(17,atomSites.size());
}",0.9139126886984904
16227,"/** 
 * Get the maximum height of any of the traces. The data is persisted for performance in the event of multiple calls, but it initialized lazily.
 * @return - maximum height of any of the traces
 */
private int getMaximum(){
  if (maximum > 0)   return maximum;
  int max=0;
  for (int x=0; x <= T.length - 1; x++) {
    if (T[x] > max)     max=T[x];
    if (A[x] > max)     max=A[x];
    if (C[x] > max)     max=C[x];
    if (G[x] > max)     max=G[x];
  }
  return max;
}","/** 
 * Get the maximum height of any of the traces. The data is persisted for performance in the event of multiple calls, but it initialized lazily.
 * @return - maximum height of any of the traces
 */
private int getMaximum(){
  int max=0;
  for (int x=0; x <= T.length - 1; x++) {
    if (T[x] > max)     max=T[x];
    if (A[x] > max)     max=A[x];
    if (C[x] > max)     max=C[x];
    if (G[x] > max)     max=G[x];
  }
  return max;
}",0.9595628415300548
16228,"/** 
 * Sets up all of the initial pointers to the important records in TraceData.
 */
private void setIndex(){
  int DataCounter, PBASCounter, PLOCCounter, PCONCounter, NumRecords;
  byte[] RecNameArray=new byte[4];
  String RecName;
  DataCounter=0;
  PBASCounter=0;
  PLOCCounter=0;
  PCONCounter=0;
  IndexBase=getIntAt(absIndexBase + macJunk);
  NumRecords=getIntAt(absIndexBase - 8 + macJunk);
  for (int record=0; record <= NumRecords - 1; record++) {
    getSubArray(RecNameArray,(IndexBase + (record * 28)));
    RecName=new String(RecNameArray);
    if (RecName.equals(""String_Node_Str""))     FWO=IndexBase + (record * 28) + 20;
    if (RecName.equals(""String_Node_Str"")) {
      ++DataCounter;
      if (DataCounter == 9)       DATA9=IndexBase + (record * 28) + 20;
      if (DataCounter == 10)       DATA10=IndexBase + (record * 28) + 20;
      if (DataCounter == 11)       DATA11=IndexBase + (record * 28) + 20;
      if (DataCounter == 12)       DATA12=IndexBase + (record * 28) + 20;
    }
    if (RecName.equals(""String_Node_Str"")) {
      ++PBASCounter;
      if (PBASCounter == 2)       PBAS2=IndexBase + (record * 28) + 20;
    }
    if (RecName.equals(""String_Node_Str"")) {
      ++PLOCCounter;
      if (PLOCCounter == 2)       PLOC=IndexBase + (record * 28) + 20;
    }
    if (RecName.equals(""String_Node_Str"")) {
      ++PCONCounter;
      if (PCONCounter == 2)       PCON=IndexBase + (record * 28) + 20;
    }
  }
  traceLength=getIntAt(DATA12 - 8);
  seqLength=getIntAt(PBAS2 - 4);
  PLOC=getIntAt(PLOC) + macJunk;
  DATA9=getIntAt(DATA9) + macJunk;
  DATA10=getIntAt(DATA10) + macJunk;
  DATA11=getIntAt(DATA11) + macJunk;
  DATA12=getIntAt(DATA12) + macJunk;
  PBAS2=getIntAt(PBAS2) + macJunk;
  PCON=getIntAt(PCON) + macJunk;
}","/** 
 * Sets up all of the initial pointers to the important records in TraceData.
 */
private void setIndex(){
  int DataCounter, PBASCounter, PLOCCounter, PCONCounter, NumRecords, indexBase;
  byte[] RecNameArray=new byte[4];
  String RecName;
  DataCounter=0;
  PBASCounter=0;
  PLOCCounter=0;
  PCONCounter=0;
  indexBase=getIntAt(absIndexBase + macJunk);
  NumRecords=getIntAt(absIndexBase - 8 + macJunk);
  for (int record=0; record <= NumRecords - 1; record++) {
    getSubArray(RecNameArray,(indexBase + (record * 28)));
    RecName=new String(RecNameArray);
    if (RecName.equals(""String_Node_Str""))     FWO=indexBase + (record * 28) + 20;
    if (RecName.equals(""String_Node_Str"")) {
      ++DataCounter;
      if (DataCounter == 9)       DATA9=indexBase + (record * 28) + 20;
      if (DataCounter == 10)       DATA10=indexBase + (record * 28) + 20;
      if (DataCounter == 11)       DATA11=indexBase + (record * 28) + 20;
      if (DataCounter == 12)       DATA12=indexBase + (record * 28) + 20;
    }
    if (RecName.equals(""String_Node_Str"")) {
      ++PBASCounter;
      if (PBASCounter == 2)       PBAS2=indexBase + (record * 28) + 20;
    }
    if (RecName.equals(""String_Node_Str"")) {
      ++PLOCCounter;
      if (PLOCCounter == 2)       PLOC=indexBase + (record * 28) + 20;
    }
    if (RecName.equals(""String_Node_Str"")) {
      ++PCONCounter;
      if (PCONCounter == 2)       PCON=indexBase + (record * 28) + 20;
    }
  }
  traceLength=getIntAt(DATA12 - 8);
  seqLength=getIntAt(PBAS2 - 4);
  PLOC=getIntAt(PLOC) + macJunk;
  DATA9=getIntAt(DATA9) + macJunk;
  DATA10=getIntAt(DATA10) + macJunk;
  DATA11=getIntAt(DATA11) + macJunk;
  DATA12=getIntAt(DATA12) + macJunk;
  PBAS2=getIntAt(PBAS2) + macJunk;
  PCON=getIntAt(PCON) + macJunk;
}",0.9912006812375816
16229,"/** 
 * Handler for CRYST1 Record Format The CRYST1 record presents the unit cell parameters, space group, and Z value. If the entry describes a structure determined by a technique other than X-ray crystallography, CRYST1 contains a = b = c = 1.0, alpha = beta = gamma = 90 degrees, space group = P 1, and Z =1. <pre> COLUMNS DATA TYPE    FIELD          DEFINITION ------------------------------------------------------------- 1 - 6  Record name  ""CRYST1"" 7 - 15 Real(9.3)    a              a (Angstroms). 16 - 24 Real(9.3)    b              b (Angstroms). 25 - 33 Real(9.3)    c              c (Angstroms). 34 - 40 Real(7.2)    alpha          alpha (degrees). 41 - 47 Real(7.2)    beta           beta (degrees). 48 - 54 Real(7.2)    gamma          gamma (degrees). 56 - 66 LString      sGroup         Space group. 67 - 70 Integer      z              Z value. </pre>
 */
private void pdb_CRYST1_Handler(String line){
  if (line.length() < 63) {
    logger.warn(""String_Node_Str"");
    return;
  }
  float a;
  float b;
  float c;
  float alpha;
  float beta;
  float gamma;
  String spaceGroup=""String_Node_Str"";
  try {
    a=Float.parseFloat(line.substring(6,15).trim());
    b=Float.parseFloat(line.substring(15,24).trim());
    c=Float.parseFloat(line.substring(24,33).trim());
    alpha=Float.parseFloat(line.substring(33,40).trim());
    beta=Float.parseFloat(line.substring(40,47).trim());
    gamma=Float.parseFloat(line.substring(47,54).trim());
  }
 catch (  NumberFormatException e) {
    logger.info(""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ line);
    return;
  }
  if (line.length() >= 66) {
    spaceGroup=line.substring(55,66).trim();
  }
 else {
    spaceGroup=line.substring(55,line.length()).trim();
  }
  CrystalCell xtalCell=new CrystalCell();
  xtalCell.setA(a);
  xtalCell.setB(b);
  xtalCell.setC(c);
  xtalCell.setAlpha(alpha);
  xtalCell.setBeta(beta);
  xtalCell.setGamma(gamma);
  if (!xtalCell.isCellReasonable()) {
    logger.debug(""String_Node_Str"",CrystalCell.MIN_VALID_CELL_SIZE);
  }
 else {
    crystallographicInfo.setCrystalCell(xtalCell);
  }
  SpaceGroup sg=SymoplibParser.getSpaceGroup(spaceGroup);
  if (sg == null) {
    logger.warn(""String_Node_Str"" + spaceGroup + ""String_Node_Str"");
    crystallographicInfo.setNonStandardSg(true);
  }
 else {
    crystallographicInfo.setSpaceGroup(sg);
    crystallographicInfo.setNonStandardSg(false);
  }
}","/** 
 * Handler for CRYST1 Record Format The CRYST1 record presents the unit cell parameters, space group, and Z value. If the entry describes a structure determined by a technique other than X-ray crystallography, CRYST1 contains a = b = c = 1.0, alpha = beta = gamma = 90 degrees, space group = P 1, and Z =1. <pre> COLUMNS DATA TYPE    FIELD          DEFINITION ------------------------------------------------------------- 1 - 6  Record name  ""CRYST1"" 7 - 15 Real(9.3)    a              a (Angstroms). 16 - 24 Real(9.3)    b              b (Angstroms). 25 - 33 Real(9.3)    c              c (Angstroms). 34 - 40 Real(7.2)    alpha          alpha (degrees). 41 - 47 Real(7.2)    beta           beta (degrees). 48 - 54 Real(7.2)    gamma          gamma (degrees). 56 - 66 LString      sGroup         Space group. 67 - 70 Integer      z              Z value. </pre>
 */
private void pdb_CRYST1_Handler(String line){
  if (line.length() < 58) {
    logger.warn(""String_Node_Str"");
    return;
  }
  float a;
  float b;
  float c;
  float alpha;
  float beta;
  float gamma;
  String spaceGroup=""String_Node_Str"";
  try {
    a=Float.parseFloat(line.substring(6,15).trim());
    b=Float.parseFloat(line.substring(15,24).trim());
    c=Float.parseFloat(line.substring(24,33).trim());
    alpha=Float.parseFloat(line.substring(33,40).trim());
    beta=Float.parseFloat(line.substring(40,47).trim());
    gamma=Float.parseFloat(line.substring(47,54).trim());
  }
 catch (  NumberFormatException e) {
    logger.info(""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ line);
    return;
  }
  if (line.length() >= 66) {
    spaceGroup=line.substring(55,66).trim();
  }
 else {
    spaceGroup=line.substring(55,line.length()).trim();
  }
  CrystalCell xtalCell=new CrystalCell();
  xtalCell.setA(a);
  xtalCell.setB(b);
  xtalCell.setC(c);
  xtalCell.setAlpha(alpha);
  xtalCell.setBeta(beta);
  xtalCell.setGamma(gamma);
  if (!xtalCell.isCellReasonable()) {
    logger.debug(""String_Node_Str"",CrystalCell.MIN_VALID_CELL_SIZE);
  }
 else {
    crystallographicInfo.setCrystalCell(xtalCell);
  }
  SpaceGroup sg=SymoplibParser.getSpaceGroup(spaceGroup);
  if (sg == null) {
    logger.warn(""String_Node_Str"" + spaceGroup + ""String_Node_Str"");
    crystallographicInfo.setNonStandardSg(true);
  }
 else {
    crystallographicInfo.setSpaceGroup(sg);
    crystallographicInfo.setNonStandardSg(false);
  }
}",0.9991673605328892
16230,"public static String getOneLetterCode(ChemComp cc){
  String oneLetter=cc.getOne_letter_code();
  if (oneLetter == null || oneLetter.equals(""String_Node_Str"") || oneLetter.equals(""String_Node_Str"")) {
    String parentId=cc.getMon_nstd_parent_comp_id();
    if (parentId == null)     return oneLetter;
    ChemComp parentCC=ChemCompGroupFactory.getChemComp(parentId);
    if (parentCC == null)     return oneLetter;
    oneLetter=parentCC.getOne_letter_code();
  }
  return oneLetter;
}","public static String getOneLetterCode(ChemComp cc){
  String oneLetter=cc.getOne_letter_code();
  if (oneLetter == null || oneLetter.equals(""String_Node_Str"") || oneLetter.equals(""String_Node_Str"")) {
    String parentId=cc.getMon_nstd_parent_comp_id();
    if (parentId == null)     return oneLetter;
    if (parentId.length() > 3)     return oneLetter;
    ChemComp parentCC=ChemCompGroupFactory.getChemComp(parentId);
    if (parentCC == null)     return oneLetter;
    oneLetter=parentCC.getOne_letter_code();
  }
  return oneLetter;
}",0.9151219512195122
16231,"/** 
 * Get the length of the coding sequence
 * @param exonStarts
 * @param exonEnds
 * @param cdsStart
 * @param cdsEnd
 * @return
 */
public static int getCDSLengthReverse(List<Integer> exonStarts,List<Integer> exonEnds,int cdsStart,int cdsEnd){
  boolean inCoding=false;
  int codingLength=0;
  if (cdsEnd < cdsStart) {
    int tmp=cdsEnd;
    cdsEnd=cdsStart;
    cdsStart=tmp;
  }
  int lengthExons=0;
  for (int i=exonStarts.size() - 1; i >= 0; i--) {
    int end=exonStarts.get(i);
    int start=exonEnds.get(i);
    if (end < start) {
      int tmp=end;
      end=start;
      start=tmp;
    }
    lengthExons+=end - start;
    if (start <= cdsEnd && end >= cdsEnd) {
      inCoding=true;
      int tmpstart=start;
      if (start < cdsStart) {
        tmpstart=cdsStart;
      }
      codingLength+=(cdsEnd - tmpstart);
      boolean debug=logger.isDebugEnabled();
      if (debug) {
        StringBuffer b=new StringBuffer();
        b.append(""String_Node_Str"" + (cdsEnd + 1) + ""String_Node_Str""+ (end)+ newline);
        if (tmpstart == start)         b.append(""String_Node_Str"");
 else         b.append(""String_Node_Str"");
        b.append(""String_Node_Str"" + tmpstart + ""String_Node_Str""+ cdsEnd+ ""String_Node_Str""+ (cdsEnd - tmpstart)+ ""String_Node_Str""+ codingLength+ ""String_Node_Str""+ (codingLength % 3)+ newline);
        if (tmpstart != start)         b.append(""String_Node_Str"" + (cdsStart - 1) + ""String_Node_Str""+ start+ newline);
        logger.debug(b.toString());
      }
    }
 else     if (start <= cdsStart && end >= cdsStart) {
      inCoding=false;
      codingLength+=(end - cdsStart);
      logger.debug(""String_Node_Str"" + (cdsStart + 1) + ""String_Node_Str""+ end+ ""String_Node_Str""+ (end - cdsStart)+ ""String_Node_Str""+ (codingLength - 3)+ ""String_Node_Str""+ (codingLength % 3));
      logger.debug(""String_Node_Str"" + start + ""String_Node_Str""+ (cdsStart));
    }
 else     if (inCoding) {
      codingLength+=(end - start);
      logger.debug(""String_Node_Str"" + start + ""String_Node_Str""+ end+ ""String_Node_Str""+ (end - start)+ ""String_Node_Str""+ codingLength+ ""String_Node_Str""+ (codingLength % 3));
    }
 else {
      logger.debug(""String_Node_Str"");
    }
  }
  logger.debug(""String_Node_Str"" + lengthExons + ""String_Node_Str""+ (codingLength - 3));
  return codingLength - 3;
}","/** 
 * Get the length of the coding sequence
 * @param exonStarts
 * @param exonEnds
 * @param cdsStart
 * @param cdsEnd
 * @return
 */
public static int getCDSLengthReverse(List<Integer> exonStarts,List<Integer> exonEnds,int cdsStart,int cdsEnd){
  int codingLength=0;
  if (cdsEnd < cdsStart) {
    int tmp=cdsEnd;
    cdsEnd=cdsStart;
    cdsStart=tmp;
  }
  for (int i=exonStarts.size() - 1; i >= 0; i--) {
    int end=exonStarts.get(i);
    int start=exonEnds.get(i);
    if (end < start) {
      int tmp=end;
      end=start;
      start=tmp;
    }
    if ((start < cdsStart && end < cdsStart) || (start > cdsEnd && end > cdsEnd))     continue;
    if (start < cdsStart)     start=cdsStart;
    if (end > cdsEnd)     end=cdsEnd;
    codingLength+=(end - start + 1);
  }
  return codingLength;
}",0.4161590253286309
16232,"/** 
 * Get the length of the coding sequence
 * @param exonStarts
 * @param exonEnds
 * @param cdsStart
 * @param cdsEnd
 * @return
 */
public static int getCDSLengthForward(List<Integer> exonStarts,List<Integer> exonEnds,int cdsStart,int cdsEnd){
  boolean inCoding=false;
  int codingLength=0;
  int lengthExons=0;
  for (int i=0; i < exonStarts.size(); i++) {
    int start=exonStarts.get(i);
    int end=exonEnds.get(i);
    lengthExons+=end - start;
    logger.debug(""String_Node_Str"" + (start + 1) + ""String_Node_Str""+ end+ ""String_Node_Str""+ (end - start));
    if (start + 1 <= cdsStart + 1 && end >= cdsStart + 1) {
      inCoding=true;
      codingLength+=(end - cdsStart);
      logger.debug(""String_Node_Str"" + start + ""String_Node_Str""+ (cdsStart));
      logger.debug(""String_Node_Str"" + (cdsStart + 1) + ""String_Node_Str""+ end+ ""String_Node_Str""+ (end - cdsStart + 1)+ ""String_Node_Str""+ codingLength+ ""String_Node_Str""+ (codingLength % 3));
    }
 else     if (start + 1 <= cdsEnd && end >= cdsEnd) {
      inCoding=false;
      codingLength+=(cdsEnd - start);
      logger.debug(""String_Node_Str"" + (start + 1) + ""String_Node_Str""+ cdsEnd+ ""String_Node_Str""+ (cdsEnd - start + 1)+ ""String_Node_Str""+ codingLength+ ""String_Node_Str""+ (codingLength % 3));
      logger.debug(""String_Node_Str"" + cdsEnd + 1+ ""String_Node_Str""+ end);
    }
 else     if (inCoding) {
      codingLength+=(end - start);
      logger.debug(""String_Node_Str"" + (start + 1) + ""String_Node_Str""+ end+ ""String_Node_Str""+ (end - start + 1)+ ""String_Node_Str""+ codingLength+ ""String_Node_Str""+ (codingLength % 3));
    }
  }
  logger.debug(""String_Node_Str"" + Integer.toString(lengthExons));
  logger.debug(""String_Node_Str"" + Integer.toString((codingLength - 3)));
  return codingLength - 3;
}","/** 
 * Get the length of the coding sequence
 * @param exonStarts
 * @param exonEnds
 * @param cdsStart
 * @param cdsEnd
 * @return
 */
public static int getCDSLengthForward(List<Integer> exonStarts,List<Integer> exonEnds,int cdsStart,int cdsEnd){
  int codingLength=0;
  for (int i=0; i < exonStarts.size(); i++) {
    int start=exonStarts.get(i);
    int end=exonEnds.get(i);
    if ((start < cdsStart && end < cdsStart) || (start > cdsEnd && end > cdsEnd))     continue;
    if (start < cdsStart)     start=cdsStart;
    if (end > cdsEnd)     end=cdsEnd;
    codingLength+=(end - start + 1);
  }
  return codingLength;
}",0.3574397339983375
16233,"/** 
 * Get the length of the coding sequence
 * @param exonStarts
 * @param exonEnds
 * @param cdsStart
 * @param cdsEnd
 * @return
 */
public static int getCDSLengthReverse(List<Integer> exonStarts,List<Integer> exonEnds,int cdsStart,int cdsEnd){
  boolean inCoding=false;
  int codingLength=0;
  if (cdsEnd < cdsStart) {
    int tmp=cdsEnd;
    cdsEnd=cdsStart;
    cdsStart=tmp;
  }
  int lengthExons=0;
  for (int i=exonStarts.size() - 1; i >= 0; i--) {
    int end=exonStarts.get(i);
    int start=exonEnds.get(i);
    if (end < start) {
      int tmp=end;
      end=start;
      start=tmp;
    }
    lengthExons+=end - start;
    if (start <= cdsEnd && end >= cdsEnd) {
      inCoding=true;
      int tmpstart=start;
      if (start < cdsStart) {
        tmpstart=cdsStart;
      }
      codingLength+=(cdsEnd - tmpstart);
      boolean debug=logger.isDebugEnabled();
      if (debug) {
        StringBuffer b=new StringBuffer();
        b.append(""String_Node_Str"" + (cdsEnd + 1) + ""String_Node_Str""+ (end)+ newline);
        if (tmpstart == start)         b.append(""String_Node_Str"");
 else         b.append(""String_Node_Str"");
        b.append(""String_Node_Str"" + tmpstart + ""String_Node_Str""+ cdsEnd+ ""String_Node_Str""+ (cdsEnd - tmpstart)+ ""String_Node_Str""+ codingLength+ ""String_Node_Str""+ (codingLength % 3)+ newline);
        if (tmpstart != start)         b.append(""String_Node_Str"" + (cdsStart - 1) + ""String_Node_Str""+ start+ newline);
        logger.debug(b.toString());
      }
    }
 else     if (start <= cdsStart && end >= cdsStart) {
      inCoding=false;
      codingLength+=(end - cdsStart);
      logger.debug(""String_Node_Str"" + (cdsStart + 1) + ""String_Node_Str""+ end+ ""String_Node_Str""+ (end - cdsStart)+ ""String_Node_Str""+ (codingLength - 3)+ ""String_Node_Str""+ (codingLength % 3));
      logger.debug(""String_Node_Str"" + start + ""String_Node_Str""+ (cdsStart));
    }
 else     if (inCoding) {
      codingLength+=(end - start);
      logger.debug(""String_Node_Str"" + start + ""String_Node_Str""+ end+ ""String_Node_Str""+ (end - start)+ ""String_Node_Str""+ codingLength+ ""String_Node_Str""+ (codingLength % 3));
    }
 else {
      logger.debug(""String_Node_Str"");
    }
  }
  logger.debug(""String_Node_Str"" + lengthExons + ""String_Node_Str""+ (codingLength - 3));
  return codingLength - 3;
}","/** 
 * Get the length of the coding sequence
 * @param exonStarts
 * @param exonEnds
 * @param cdsStart
 * @param cdsEnd
 * @return
 */
public static int getCDSLengthReverse(List<Integer> exonStarts,List<Integer> exonEnds,int cdsStart,int cdsEnd){
  int codingLength=0;
  if (cdsEnd < cdsStart) {
    int tmp=cdsEnd;
    cdsEnd=cdsStart;
    cdsStart=tmp;
  }
  cdsStart=cdsStart + base;
  for (int i=exonStarts.size() - 1; i >= 0; i--) {
    int end=exonStarts.get(i);
    int start=exonEnds.get(i);
    if (end < start) {
      int tmp=end;
      end=start;
      start=tmp;
    }
    start=start + base;
    if ((start < cdsStart && end < cdsStart) || (start > cdsEnd && end > cdsEnd))     continue;
    if (start < cdsStart)     start=cdsStart;
    if (end > cdsEnd)     end=cdsEnd;
    codingLength+=(end - start + 1);
  }
  return codingLength - 3;
}",0.4100787401574803
16234,"/** 
 * Converts the genetic coordinate to the position of the nucleotide on the mRNA sequence for a gene  living on the reverse DNA strand.
 * @param chromPos The genetic coordinate on a chromosome 
 * @param exonStarts The list holding the genetic coordinates pointing to the start positions of the exons (including UTR regions)  
 * @param exonEnds The list holding the genetic coordinates pointing to the end positions of the exons (including UTR regions)
 * @param cdsStart The start position of a coding region
 * @param cdsEnd The end position of a coding region
 * @return the position of the nucleotide base on the mRNA sequence corresponding to the input genetic coordinate (base 1)
 * @author Yana Valasatava
 */
public static int getCDSPosReverse(int chromPos,List<Integer> exonStarts,List<Integer> exonEnds,int cdsStart,int cdsEnd){
  if ((chromPos < (cdsStart + 1)) || (chromPos > (cdsEnd + 1))) {
    logger.debug(""String_Node_Str"" + format(chromPos) + ""String_Node_Str"");
    return -1;
  }
  logger.debug(""String_Node_Str"" + format(chromPos));
  List<Range<Integer>> cdsRegions=getCDSRegions(exonStarts,exonEnds,cdsStart,cdsEnd);
  int codingLength=0;
  int lengthExon=0;
  for (int i=cdsRegions.size() - 1; i >= 0; i--) {
    int start=cdsRegions.get(i).lowerEndpoint();
    int end=cdsRegions.get(i).upperEndpoint();
    lengthExon=end - start;
    if (start + 1 <= chromPos && end >= chromPos) {
      return codingLength + (end - chromPos + 1);
    }
 else {
      codingLength+=lengthExon;
    }
  }
  return -1;
}","/** 
 * Converts the genetic coordinate to the position of the nucleotide on the mRNA sequence for a gene  living on the reverse DNA strand.
 * @param chromPos The genetic coordinate on a chromosome 
 * @param exonStarts The list holding the genetic coordinates pointing to the start positions of the exons (including UTR regions)  
 * @param exonEnds The list holding the genetic coordinates pointing to the end positions of the exons (including UTR regions)
 * @param cdsStart The start position of a coding region
 * @param cdsEnd The end position of a coding region
 * @return the position of the nucleotide base on the mRNA sequence corresponding to the input genetic coordinate (base 1)
 * @author Yana Valasatava
 */
public static int getCDSPosReverse(int chromPos,List<Integer> exonStarts,List<Integer> exonEnds,int cdsStart,int cdsEnd){
  if ((chromPos < (cdsStart + base)) || (chromPos > (cdsEnd + base))) {
    logger.debug(""String_Node_Str"" + format(chromPos) + ""String_Node_Str"");
    return -1;
  }
  logger.debug(""String_Node_Str"" + format(chromPos));
  List<Range<Integer>> cdsRegions=getCDSRegions(exonStarts,exonEnds,cdsStart,cdsEnd);
  int codingLength=0;
  int lengthExon=0;
  for (int i=cdsRegions.size() - 1; i >= 0; i--) {
    int start=cdsRegions.get(i).lowerEndpoint();
    int end=cdsRegions.get(i).upperEndpoint();
    lengthExon=end - start;
    if (start + base <= chromPos && end >= chromPos) {
      return codingLength + (end - chromPos + 1);
    }
 else {
      codingLength+=lengthExon;
    }
  }
  return -1;
}",0.9951314508276532
16235,"/** 
 * Get the length of the CDS in nucleotides.
 * @param chromPos
 * @return length of the CDS in nucleotides.
 */
public static int getCDSLength(GeneChromosomePosition chromPos){
  logger.debug(chromPos.toString());
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"" + chromPos.getGeneName());
  logger.debug(""String_Node_Str"" + chromPos.getTranscriptionStart() + ""String_Node_Str""+ chromPos.getTranscriptionEnd()+ ""String_Node_Str""+ (chromPos.getTranscriptionEnd() - chromPos.getTranscriptionStart())+ ""String_Node_Str"");
  logger.debug(""String_Node_Str"" + chromPos.getOrientation());
  logger.debug(""String_Node_Str"" + (chromPos.getCdsStart()) + ""String_Node_Str""+ chromPos.getCdsEnd()+ ""String_Node_Str""+ (chromPos.getCdsEnd() - chromPos.getCdsStart())+ ""String_Node_Str"");
  List<Integer> exonStarts=chromPos.getExonStarts();
  List<Integer> exonEnds=chromPos.getExonEnds();
  logger.debug(""String_Node_Str"" + exonStarts.size());
  int cdsStart=chromPos.getCdsStart();
  int cdsEnd=chromPos.getCdsEnd();
  int codingLength;
  if (chromPos.getOrientation().equals('+'))   codingLength=ChromosomeMappingTools.getCDSLengthForward(exonStarts,exonEnds,cdsStart,cdsEnd);
 else   codingLength=ChromosomeMappingTools.getCDSLengthReverse(exonStarts,exonEnds,cdsStart,cdsEnd);
  return codingLength;
}","/** 
 * Get the length of the CDS in nucleotides.
 * @param chromPos
 * @return length of the CDS in nucleotides.
 */
public static int getCDSLength(GeneChromosomePosition chromPos){
  List<Integer> exonStarts=chromPos.getExonStarts();
  List<Integer> exonEnds=chromPos.getExonEnds();
  int cdsStart=chromPos.getCdsStart();
  int cdsEnd=chromPos.getCdsEnd();
  int codingLength;
  if (chromPos.getOrientation().equals('+'))   codingLength=ChromosomeMappingTools.getCDSLengthForward(exonStarts,exonEnds,cdsStart,cdsEnd);
 else   codingLength=ChromosomeMappingTools.getCDSLengthReverse(exonStarts,exonEnds,cdsStart,cdsEnd);
  return codingLength;
}",0.6585117227319062
16236,"/** 
 * Converts the genetic coordinate to the position of the nucleotide on the mRNA sequence for a gene  living on the forward DNA strand.
 * @param chromPos The genetic coordinate on a chromosome 
 * @param exonStarts The list holding the genetic coordinates pointing to the start positions of the exons (including UTR regions)  
 * @param exonEnds The list holding the genetic coordinates pointing to the end positions of the exons (including UTR regions)
 * @param cdsStart The start position of a coding region
 * @param cdsEnd The end position of a coding region
 * @return the position of the nucleotide base on the mRNA sequence corresponding to the input genetic coordinate (base 1)
 * @author Yana Valasatava
 */
public static int getCDSPosForward(int chromPos,List<Integer> exonStarts,List<Integer> exonEnds,int cdsStart,int cdsEnd){
  if ((chromPos < (cdsStart + 1)) || (chromPos > (cdsEnd + 1))) {
    logger.debug(""String_Node_Str"" + format(chromPos) + ""String_Node_Str"");
    return -1;
  }
  logger.debug(""String_Node_Str"" + format(chromPos));
  List<Range<Integer>> cdsRegions=getCDSRegions(exonStarts,exonEnds,cdsStart,cdsEnd);
  int codingLength=0;
  int lengthExon=0;
  for (  Range<Integer> range : cdsRegions) {
    int start=range.lowerEndpoint();
    int end=range.upperEndpoint();
    lengthExon=end - start;
    if (start + 1 <= chromPos && end >= chromPos) {
      return codingLength + (chromPos - start);
    }
 else {
      codingLength+=lengthExon;
    }
  }
  return -1;
}","/** 
 * Converts the genetic coordinate to the position of the nucleotide on the mRNA sequence for a gene  living on the forward DNA strand.
 * @param chromPos The genetic coordinate on a chromosome 
 * @param exonStarts The list holding the genetic coordinates pointing to the start positions of the exons (including UTR regions)  
 * @param exonEnds The list holding the genetic coordinates pointing to the end positions of the exons (including UTR regions)
 * @param cdsStart The start position of a coding region
 * @param cdsEnd The end position of a coding region
 * @return the position of the nucleotide base on the mRNA sequence corresponding to the input genetic coordinate (base 1)
 * @author Yana Valasatava
 */
public static int getCDSPosForward(int chromPos,List<Integer> exonStarts,List<Integer> exonEnds,int cdsStart,int cdsEnd){
  if ((chromPos < (cdsStart + base)) || (chromPos > (cdsEnd + base))) {
    logger.debug(""String_Node_Str"" + format(chromPos) + ""String_Node_Str"");
    return -1;
  }
  logger.debug(""String_Node_Str"" + format(chromPos));
  List<Range<Integer>> cdsRegions=getCDSRegions(exonStarts,exonEnds,cdsStart,cdsEnd);
  int codingLength=0;
  int lengthExon=0;
  for (  Range<Integer> range : cdsRegions) {
    int start=range.lowerEndpoint();
    int end=range.upperEndpoint();
    lengthExon=end - start;
    if (start + base <= chromPos && end >= chromPos) {
      return codingLength + (chromPos - start);
    }
 else {
      codingLength+=lengthExon;
    }
  }
  return -1;
}",0.9950314673733024
16237,"/** 
 * Get the length of the coding sequence
 * @param exonStarts
 * @param exonEnds
 * @param cdsStart
 * @param cdsEnd
 * @return
 */
public static int getCDSLengthForward(List<Integer> exonStarts,List<Integer> exonEnds,int cdsStart,int cdsEnd){
  boolean inCoding=false;
  int codingLength=0;
  int lengthExons=0;
  for (int i=0; i < exonStarts.size(); i++) {
    int start=exonStarts.get(i);
    int end=exonEnds.get(i);
    lengthExons+=end - start;
    logger.debug(""String_Node_Str"" + (start + 1) + ""String_Node_Str""+ end+ ""String_Node_Str""+ (end - start));
    if (start + 1 <= cdsStart + 1 && end >= cdsStart + 1) {
      inCoding=true;
      codingLength+=(end - cdsStart);
      logger.debug(""String_Node_Str"" + start + ""String_Node_Str""+ (cdsStart));
      logger.debug(""String_Node_Str"" + (cdsStart + 1) + ""String_Node_Str""+ end+ ""String_Node_Str""+ (end - cdsStart + 1)+ ""String_Node_Str""+ codingLength+ ""String_Node_Str""+ (codingLength % 3));
    }
 else     if (start + 1 <= cdsEnd && end >= cdsEnd) {
      inCoding=false;
      codingLength+=(cdsEnd - start);
      logger.debug(""String_Node_Str"" + (start + 1) + ""String_Node_Str""+ cdsEnd+ ""String_Node_Str""+ (cdsEnd - start + 1)+ ""String_Node_Str""+ codingLength+ ""String_Node_Str""+ (codingLength % 3));
      logger.debug(""String_Node_Str"" + cdsEnd + 1+ ""String_Node_Str""+ end);
    }
 else     if (inCoding) {
      codingLength+=(end - start);
      logger.debug(""String_Node_Str"" + (start + 1) + ""String_Node_Str""+ end+ ""String_Node_Str""+ (end - start + 1)+ ""String_Node_Str""+ codingLength+ ""String_Node_Str""+ (codingLength % 3));
    }
  }
  logger.debug(""String_Node_Str"" + Integer.toString(lengthExons));
  logger.debug(""String_Node_Str"" + Integer.toString((codingLength - 3)));
  return codingLength - 3;
}","/** 
 * Get the length of the coding sequence
 * @param exonStarts
 * @param exonEnds
 * @param cdsStart
 * @param cdsEnd
 * @return
 */
public static int getCDSLengthForward(List<Integer> exonStarts,List<Integer> exonEnds,int cdsStart,int cdsEnd){
  int codingLength=0;
  for (int i=0; i < exonStarts.size(); i++) {
    int start=exonStarts.get(i) + base;
    int end=exonEnds.get(i);
    if ((start < cdsStart + base && end < cdsStart) || (start > cdsEnd && end > cdsEnd))     continue;
    if (start < cdsStart + base)     start=cdsStart + base;
    if (end > cdsEnd)     end=cdsEnd;
    codingLength+=(end - start + 1);
  }
  return codingLength - 3;
}",0.2813781788351107
16238,"/** 
 * This method sets the maximum stretch allowed for a base pair, prior to analyze() call.
 * @param maxStretch The maximum stretch (in Å) allowed to consider two bases paired
 */
public static void setMaxStretch(double maxStretch){
  maxStretch=maxStretch;
}","/** 
 * This method sets the maximum stretch allowed for a base pair, prior to analyze() call.
 * @param maxStretch The maximum stretch (in Å) allowed to consider two bases paired
 */
public void setMaxStretch(double maxStretch){
  this.maxStretch=maxStretch;
}",0.9770992366412212
16239,"/** 
 * This method sets the maximum stagger allowed for a base pair, prior to analyze() call
 * @param maxStagger The maximum propeller (in Å) allowed to consider two bases paired
 */
public void setMaxStagger(double maxStagger){
  maxStagger=maxStagger;
}","/** 
 * This method sets the maximum stagger allowed for a base pair, prior to analyze() call
 * @param maxStagger The maximum propeller (in Å) allowed to consider two bases paired
 */
public void setMaxStagger(double maxStagger){
  this.maxStagger=maxStagger;
}",0.9903660886319846
16240,"/** 
 * This method sets the maximum shear allowed for a base pair, prior to analyze() call
 * @param maxShear The maximum shear (in Å) allowed to consider two bases paired
 */
public void setMaxShear(double maxShear){
  maxShear=maxShear;
}","/** 
 * This method sets the maximum shear allowed for a base pair, prior to analyze() call
 * @param maxShear The maximum shear (in Å) allowed to consider two bases paired
 */
public void setMaxShear(double maxShear){
  this.maxShear=maxShear;
}",0.9897330595482546
16241,"/** 
 * This method sets the maximum propeller allowed for a base pair, prior to analyze() call
 * @param maxPropeller The maximum propeller (""propeller-twist"", in degrees) allowed to consider two bases paired
 */
public void setMaxPropeller(double maxPropeller){
  maxPropeller=maxPropeller;
}","/** 
 * This method sets the maximum propeller allowed for a base pair, prior to analyze() call
 * @param maxPropeller The maximum propeller (""propeller-twist"", in degrees) allowed to consider two bases paired
 */
public void setMaxPropeller(double maxPropeller){
  this.maxPropeller=maxPropeller;
}",0.9915682967959528
16242,"/** 
 * This method sets the maximum stagger allowed for a base pair, prior to analyze() call
 * @param maxStagger The maximum stagger (in Å) allowed to consider two bases paired
 */
public void setMaxStagger(double maxStagger){
  maxStagger=maxStagger;
}","/** 
 * This method sets the maximum stagger allowed for a base pair, prior to analyze() call
 * @param maxStagger The maximum stagger (in Å) allowed to consider two bases paired
 */
public void setMaxStagger(double maxStagger){
  this.maxStagger=maxStagger;
}",0.9902912621359224
16243,"/** 
 * This method sets the maximum propeller allowed for a base pair, prior to analyze() call
 * @param maxPropeller The maximum propeller (""propeller-twist"", in degrees) allowed to consider two bases paired
 */
public void setMaxPropeller(double maxPropeller){
  maxPropeller=maxPropeller;
}","/** 
 * This method sets the maximum propeller allowed for a base pair, prior to analyze() call
 * @param maxPropeller The maximum propeller (""propeller-twist"", in degrees) allowed to consider two bases paired
 */
public void setMaxPropeller(double maxPropeller){
  this.maxPropeller=maxPropeller;
}",0.9915682967959528
16244,"/** 
 * This method tries to parse maximum <code>max</code> records from the open File or InputStream, and leaves the underlying resource open.<br> Subsequent calls to the same method continue parsing the rest of the file.<br> This is particularly useful when dealing with very big data files, (e.g. NCBI nr database), which can't fit into memory and will take long time before the first result is available.<br> <b>N.B.</b> <ul> <li>This method can't be called after calling its NO-ARGUMENT twin.</li> <li>remember to close the underlying resource when you are done.</li> </ul>
 * @see #process()
 * @author Amr AL-Hossary
 * @since 3.0.6
 * @param max maximum number of records to return, <code>-1</code> for infinity.
 * @return {@link HashMap} containing maximum <code>max</code> parsed fasta recordspresent, starting current fileIndex onwards.
 * @throws IOException if an error occurs reading the input file
 */
public LinkedHashMap<String,S> process(int max) throws IOException {
  String line=""String_Node_Str"";
  if (this.line != null && this.line.length() > 0) {
    line=this.line;
  }
  String header=""String_Node_Str"";
  if (this.header != null && this.header.length() > 0) {
    header=this.header;
  }
  StringBuilder sb=new StringBuilder();
  int processedSequences=0;
  boolean keepGoing=true;
  LinkedHashMap<String,S> sequences=new LinkedHashMap<String,S>();
  do {
    line=line.trim();
    if (line.length() != 0) {
      if (line.startsWith(""String_Node_Str"")) {
        if (sb.length() > 0) {
          try {
            @SuppressWarnings(""String_Node_Str"") S sequence=(S)sequenceCreator.getSequence(sb.toString(),sequenceIndex);
            headerParser.parseHeader(header,sequence);
            sequences.put(sequence.getAccession().getID(),sequence);
            processedSequences++;
          }
 catch (          CompoundNotFoundException e) {
            logger.warn(""String_Node_Str"",header,e.getMessage());
          }
          sb.setLength(0);
        }
        header=line.substring(1);
      }
 else       if (line.startsWith(""String_Node_Str"")) {
      }
 else {
        if (sb.length() == 0) {
          sequenceIndex=fileIndex;
        }
        sb.append(line);
      }
    }
    fileIndex=br.getBytesRead();
    line=br.readLine();
    if (line == null) {
      if (sequences.size() == 0 && max != -1) {
        return null;
      }
      String seq=sb.toString();
      if (seq.length() == 0) {
        logger.warn(""String_Node_Str"",sequenceIndex);
        logger.warn(""String_Node_Str"",header);
      }
      try {
        @SuppressWarnings(""String_Node_Str"") S sequence=(S)sequenceCreator.getSequence(seq,sequenceIndex);
        headerParser.parseHeader(header,sequence);
        sequences.put(sequence.getAccession().getID(),sequence);
        processedSequences++;
      }
 catch (      CompoundNotFoundException e) {
        logger.warn(""String_Node_Str"",header,e.getMessage());
      }
      keepGoing=false;
    }
    if (max > -1 && processedSequences >= max) {
      keepGoing=false;
    }
    if (this.line == null)     keepGoing=false;
  }
 while (keepGoing);
  this.line=line;
  this.header=header;
  return sequences;
}","/** 
 * This method tries to parse maximum <code>max</code> records from the open File or InputStream, and leaves the underlying resource open.<br> Subsequent calls to the same method continue parsing the rest of the file.<br> This is particularly useful when dealing with very big data files, (e.g. NCBI nr database), which can't fit into memory and will take long time before the first result is available.<br> <b>N.B.</b> <ul> <li>This method can't be called after calling its NO-ARGUMENT twin.</li> <li>remember to close the underlying resource when you are done.</li> <li>This method always return non-null hash map. When end-of-file is reached, the number of sequences returned will be smaller than the number requested.</li> </ul>
 * @see #process()
 * @author Amr AL-Hossary
 * @since 3.0.6
 * @param max maximum number of records to return, <code>-1</code> for infinity.
 * @return {@link HashMap} containing maximum <code>max</code> parsed fasta recordspresent, starting current fileIndex onwards.
 * @throws IOException if an error occurs reading the input file
 */
public LinkedHashMap<String,S> process(int max) throws IOException {
  String line=""String_Node_Str"";
  if (this.line != null && this.line.length() > 0) {
    line=this.line;
  }
  String header=""String_Node_Str"";
  if (this.header != null && this.header.length() > 0) {
    header=this.header;
  }
  StringBuilder sb=new StringBuilder();
  int processedSequences=0;
  boolean keepGoing=true;
  LinkedHashMap<String,S> sequences=new LinkedHashMap<String,S>();
  do {
    line=line.trim();
    if (line.length() != 0) {
      if (line.startsWith(""String_Node_Str"")) {
        if (sb.length() > 0) {
          try {
            @SuppressWarnings(""String_Node_Str"") S sequence=(S)sequenceCreator.getSequence(sb.toString(),sequenceIndex);
            headerParser.parseHeader(header,sequence);
            sequences.put(sequence.getAccession().getID(),sequence);
            processedSequences++;
          }
 catch (          CompoundNotFoundException e) {
            logger.warn(""String_Node_Str"",header,e.getMessage());
          }
          sb.setLength(0);
        }
        header=line.substring(1);
      }
 else       if (line.startsWith(""String_Node_Str"")) {
      }
 else {
        if (sb.length() == 0) {
          sequenceIndex=fileIndex;
        }
        sb.append(line);
      }
    }
    fileIndex=br.getBytesRead();
    line=br.readLine();
    if (line == null) {
      if (sb.length() == 0 && header.length() != 0) {
        logger.warn(""String_Node_Str"",sequenceIndex);
        logger.warn(""String_Node_Str"",header);
        header=null;
      }
 else       if (sb.length() > 0) {
        try {
          @SuppressWarnings(""String_Node_Str"") S sequence=(S)sequenceCreator.getSequence(sb.toString(),sequenceIndex);
          headerParser.parseHeader(header,sequence);
          sequences.put(sequence.getAccession().getID(),sequence);
          processedSequences++;
          header=null;
        }
 catch (        CompoundNotFoundException e) {
          logger.warn(""String_Node_Str"",header,e.getMessage());
        }
      }
      keepGoing=false;
    }
    if (max > -1 && processedSequences >= max) {
      keepGoing=false;
    }
  }
 while (keepGoing);
  this.line=line;
  this.header=header;
  return sequences;
}",0.7301880974406414
16245,"@Override public void setHeaderInfo(float rFree,float rWork,float resolution,String title,String depositionDate,String releaseDate,String[] experimentalMethods){
  SimpleDateFormat formatter=new SimpleDateFormat(""String_Node_Str"");
  PDBHeader pdbHeader=structure.getPDBHeader();
  pdbHeader.setTitle(title);
  pdbHeader.setResolution(resolution);
  pdbHeader.setRfree(rFree);
  pdbHeader.setRwork(rWork);
  for (  String techniqueStr : experimentalMethods) {
    pdbHeader.setExperimentalTechnique(techniqueStr);
  }
  if (depositionDate != null) {
    try {
      Date depDate=formatter.parse(depositionDate);
      pdbHeader.setDepDate(depDate);
    }
 catch (    ParseException e) {
      logger.warn(""String_Node_Str"",depositionDate);
    }
  }
 else {
    pdbHeader.setDepDate(new Date(0));
  }
  if (releaseDate != null) {
    try {
      Date relDate=formatter.parse(releaseDate);
      pdbHeader.setModDate(relDate);
    }
 catch (    ParseException e) {
      logger.warn(""String_Node_Str"",releaseDate);
    }
  }
 else {
    pdbHeader.setModDate(new Date(0));
  }
}","@Override public void setHeaderInfo(float rFree,float rWork,float resolution,String title,String depositionDate,String releaseDate,String[] experimentalMethods){
  SimpleDateFormat formatter=new SimpleDateFormat(""String_Node_Str"");
  PDBHeader pdbHeader=structure.getPDBHeader();
  pdbHeader.setTitle(title);
  pdbHeader.setResolution(resolution);
  pdbHeader.setRfree(rFree);
  pdbHeader.setRwork(rWork);
  if (experimentalMethods != null) {
    for (    String techniqueStr : experimentalMethods) {
      pdbHeader.setExperimentalTechnique(techniqueStr);
    }
  }
  if (depositionDate != null) {
    try {
      Date depDate=formatter.parse(depositionDate);
      pdbHeader.setDepDate(depDate);
    }
 catch (    ParseException e) {
      logger.warn(""String_Node_Str"",depositionDate);
    }
  }
 else {
    pdbHeader.setDepDate(new Date(0));
  }
  if (releaseDate != null) {
    try {
      Date relDate=formatter.parse(releaseDate);
      pdbHeader.setModDate(relDate);
    }
 catch (    ParseException e) {
      logger.warn(""String_Node_Str"",releaseDate);
    }
  }
 else {
    pdbHeader.setModDate(new Date(0));
  }
}",0.9741026805997274
16246,"/** 
 * Fetch and parse the DSSP file of the specified pdb code from the PDB web server and return the secondary structure annotation as a List of   {@link SecStrucState} objects.
 * @param pdb path to the DSSP file to parse
 * @param structure Structure object associated to the dssp
 * @param assign assigns the SS to the structure if true
 * @return a List of SS annotation objects
 * @throws StructureException
 * @throws IOException
 */
public static List<SecStrucState> fetch(String pdb,Structure structure,boolean assign) throws IOException, StructureException {
  URL url=new URL(""String_Node_Str"" + pdb.toLowerCase().substring(1,3) + ""String_Node_Str""+ pdb.toLowerCase()+ ""String_Node_Str""+ pdb+ ""String_Node_Str"");
  InputStream in=new GZIPInputStream(url.openStream());
  Reader read=new InputStreamReader(in);
  BufferedReader reader=new BufferedReader(read);
  return generalParse(reader,structure,assign);
}","/** 
 * Fetch and parse the DSSP file of the specified pdb code from the PDB web server and return the secondary structure annotation as a List of   {@link SecStrucState} objects.
 * @param pdb path to the DSSP file to parse
 * @param structure Structure object associated to the dssp
 * @param assign assigns the SS to the structure if true
 * @return a List of SS annotation objects
 * @throws StructureException
 * @throws IOException
 */
public static List<SecStrucState> fetch(String pdb,Structure structure,boolean assign) throws IOException, StructureException {
  URL url=new URL(""String_Node_Str"" + pdb.toLowerCase().substring(1,3) + ""String_Node_Str""+ pdb.toLowerCase()+ ""String_Node_Str""+ pdb.toLowerCase()+ ""String_Node_Str"");
  InputStream in=new GZIPInputStream(url.openStream());
  Reader read=new InputStreamReader(in);
  BufferedReader reader=new BufferedReader(read);
  return generalParse(reader,structure,assign);
}",0.992456896551724
16247,"/** 
 * Scans a protein sequence for Pfam profile matches.
 * @param sequence
 * @param serviceLocation
 * @return
 * @throws IOException
 */
public SortedSet<HmmerResult> scan(ProteinSequence sequence,URL serviceLocation) throws IOException {
  StringBuffer postContent=new StringBuffer();
  postContent.append(""String_Node_Str"");
  postContent.append(""String_Node_Str"");
  postContent.append(sequence.getSequenceAsString());
  HttpURLConnection connection=(HttpURLConnection)serviceLocation.openConnection();
  connection.setDoOutput(true);
  connection.setDoInput(true);
  connection.setConnectTimeout(15000);
  connection.setInstanceFollowRedirects(false);
  connection.setRequestMethod(""String_Node_Str"");
  connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + Integer.toString(postContent.toString().getBytes().length));
  DataOutputStream wr=new DataOutputStream(connection.getOutputStream());
  wr.write(postContent.toString().getBytes());
  wr.flush();
  wr.close();
  URL respUrl=new URL(connection.getHeaderField(""String_Node_Str""));
  int responseCode=connection.getResponseCode();
  if (responseCode == 500) {
    System.err.println(""String_Node_Str"" + serviceLocation);
    System.err.println(connection.getResponseMessage());
  }
  HttpURLConnection connection2=(HttpURLConnection)respUrl.openConnection();
  connection2.setRequestMethod(""String_Node_Str"");
  connection2.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  connection2.setConnectTimeout(60000);
  BufferedReader in=new BufferedReader(new InputStreamReader(connection2.getInputStream()));
  String inputLine;
  StringBuffer result=new StringBuffer();
  while ((inputLine=in.readLine()) != null) {
    result.append(inputLine);
  }
  in.close();
  SortedSet<HmmerResult> results=new TreeSet<HmmerResult>();
  try {
    JSONObject json=JSONObject.fromObject(result.toString());
    JSONObject hmresults=json.getJSONObject(""String_Node_Str"");
    JSONArray hits=hmresults.getJSONArray(""String_Node_Str"");
    for (int i=0; i < hits.size(); i++) {
      JSONObject hit=hits.getJSONObject(i);
      HmmerResult hmmResult=new HmmerResult();
      Object dclO=hit.get(""String_Node_Str"");
      Integer dcl=-1;
      if (dclO instanceof Long) {
        Long dclL=(Long)dclO;
        dcl=dclL.intValue();
      }
 else       if (dclO instanceof Integer) {
        dcl=(Integer)dclO;
      }
      hmmResult.setAcc((String)hit.get(""String_Node_Str""));
      hmmResult.setDcl(dcl);
      hmmResult.setDesc((String)hit.get(""String_Node_Str""));
      hmmResult.setEvalue(Float.parseFloat((String)hit.get(""String_Node_Str"")));
      hmmResult.setName((String)hit.get(""String_Node_Str""));
      hmmResult.setNdom((Integer)hit.get(""String_Node_Str""));
      hmmResult.setNreported((Integer)hit.get(""String_Node_Str""));
      hmmResult.setPvalue((Double)hit.get(""String_Node_Str""));
      hmmResult.setScore(Float.parseFloat((String)hit.get(""String_Node_Str"")));
      JSONArray hmmdomains=hit.getJSONArray(""String_Node_Str"");
      SortedSet<HmmerDomain> domains=new TreeSet<HmmerDomain>();
      for (int j=0; j < hmmdomains.size(); j++) {
        JSONObject d=hmmdomains.getJSONObject(j);
        Integer is_included=getInteger(d.get(""String_Node_Str""));
        if (is_included == 0) {
          continue;
        }
        Integer outcompeted=getInteger(d.get(""String_Node_Str""));
        if (outcompeted != null && outcompeted == 1) {
          continue;
        }
        Integer significant=getInteger(d.get(""String_Node_Str""));
        if (significant != 1) {
          continue;
        }
        HmmerDomain dom=new HmmerDomain();
        dom.setAliLenth((Integer)d.get(""String_Node_Str""));
        dom.setHmmAcc((String)d.get(""String_Node_Str""));
        dom.setHmmDesc((String)d.get(""String_Node_Str""));
        dom.setHmmFrom(getInteger(d.get(""String_Node_Str"")));
        dom.setHmmTo(getInteger(d.get(""String_Node_Str"")));
        dom.setSimCount((Integer)d.get(""String_Node_Str""));
        dom.setSqFrom(getInteger(d.get(""String_Node_Str"")));
        dom.setSqTo(getInteger(d.get(""String_Node_Str"")));
        dom.setHmmName((String)d.get(""String_Node_Str""));
        dom.setEvalue(Float.parseFloat((String)d.get(""String_Node_Str"")));
        domains.add(dom);
      }
      hmmResult.setDomains(domains);
      results.add(hmmResult);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return results;
}","/** 
 * Scans a protein sequence for Pfam profile matches.
 * @param sequence
 * @param serviceLocation
 * @return
 * @throws IOException
 */
public SortedSet<HmmerResult> scan(ProteinSequence sequence,URL serviceLocation) throws IOException {
  StringBuffer postContent=new StringBuffer();
  postContent.append(""String_Node_Str"");
  postContent.append(""String_Node_Str"");
  postContent.append(sequence.getSequenceAsString());
  HttpURLConnection connection=(HttpURLConnection)serviceLocation.openConnection();
  connection.setDoOutput(true);
  connection.setDoInput(true);
  connection.setConnectTimeout(15000);
  connection.setInstanceFollowRedirects(false);
  connection.setRequestMethod(""String_Node_Str"");
  connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + Integer.toString(postContent.toString().getBytes().length));
  DataOutputStream wr=new DataOutputStream(connection.getOutputStream());
  wr.write(postContent.toString().getBytes());
  wr.flush();
  wr.close();
  URL respUrl=new URL(connection.getHeaderField(""String_Node_Str""));
  int responseCode=connection.getResponseCode();
  if (responseCode == 500) {
    LOGGER.warn(""String_Node_Str"",serviceLocation,connection.getResponseMessage());
  }
  HttpURLConnection connection2=(HttpURLConnection)respUrl.openConnection();
  connection2.setRequestMethod(""String_Node_Str"");
  connection2.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  connection2.setConnectTimeout(60000);
  BufferedReader in=new BufferedReader(new InputStreamReader(connection2.getInputStream()));
  String inputLine;
  StringBuffer result=new StringBuffer();
  while ((inputLine=in.readLine()) != null) {
    result.append(inputLine);
  }
  in.close();
  SortedSet<HmmerResult> results=new TreeSet<HmmerResult>();
  try {
    JSONObject json=JSONObject.fromObject(result.toString());
    JSONObject hmresults=json.getJSONObject(""String_Node_Str"");
    JSONArray hits=hmresults.getJSONArray(""String_Node_Str"");
    for (int i=0; i < hits.size(); i++) {
      JSONObject hit=hits.getJSONObject(i);
      HmmerResult hmmResult=new HmmerResult();
      Object dclO=hit.get(""String_Node_Str"");
      Integer dcl=-1;
      if (dclO instanceof Long) {
        Long dclL=(Long)dclO;
        dcl=dclL.intValue();
      }
 else       if (dclO instanceof Integer) {
        dcl=(Integer)dclO;
      }
      hmmResult.setAcc((String)hit.get(""String_Node_Str""));
      hmmResult.setDcl(dcl);
      hmmResult.setDesc((String)hit.get(""String_Node_Str""));
      hmmResult.setEvalue(Float.parseFloat((String)hit.get(""String_Node_Str"")));
      hmmResult.setName((String)hit.get(""String_Node_Str""));
      hmmResult.setNdom((Integer)hit.get(""String_Node_Str""));
      hmmResult.setNreported((Integer)hit.get(""String_Node_Str""));
      hmmResult.setPvalue((Double)hit.get(""String_Node_Str""));
      hmmResult.setScore(Float.parseFloat((String)hit.get(""String_Node_Str"")));
      JSONArray hmmdomains=hit.getJSONArray(""String_Node_Str"");
      SortedSet<HmmerDomain> domains=new TreeSet<HmmerDomain>();
      for (int j=0; j < hmmdomains.size(); j++) {
        JSONObject d=hmmdomains.getJSONObject(j);
        Integer is_included=getInteger(d.get(""String_Node_Str""));
        if (is_included == 0) {
          continue;
        }
        Integer outcompeted=getInteger(d.get(""String_Node_Str""));
        if (outcompeted != null && outcompeted == 1) {
          continue;
        }
        Integer significant=getInteger(d.get(""String_Node_Str""));
        if (significant != 1) {
          continue;
        }
        HmmerDomain dom=new HmmerDomain();
        dom.setAliLenth((Integer)d.get(""String_Node_Str""));
        dom.setHmmAcc((String)d.get(""String_Node_Str""));
        dom.setHmmDesc((String)d.get(""String_Node_Str""));
        dom.setHmmFrom(getInteger(d.get(""String_Node_Str"")));
        dom.setHmmTo(getInteger(d.get(""String_Node_Str"")));
        dom.setSimCount((Integer)d.get(""String_Node_Str""));
        dom.setSqFrom(getInteger(d.get(""String_Node_Str"")));
        dom.setSqTo(getInteger(d.get(""String_Node_Str"")));
        dom.setHmmName((String)d.get(""String_Node_Str""));
        dom.setEvalue(Float.parseFloat((String)d.get(""String_Node_Str"")));
        domains.add(dom);
      }
      hmmResult.setDomains(domains);
      results.add(hmmResult);
    }
  }
 catch (  NumberFormatException e) {
    LOGGER.warn(""String_Node_Str"",e.getMessage());
  }
  return results;
}",0.981375985977213
16248,"private List<Integer> getPermutation(){
  List<Integer> permutation=new ArrayList<Integer>(transformedCoords.length);
  double sum=0.0f;
  for (  Point3d t : transformedCoords) {
    List<Integer> neighbors=box.getNeighborsWithCache(t);
    int closest=-1;
    double minDist=Double.MAX_VALUE;
    for (    int j : neighbors) {
      double dist=t.distanceSquared(originalCoords[j]);
      if (dist < minDist) {
        closest=j;
        minDist=dist;
      }
    }
    sum+=minDist;
    if (closest == -1) {
      break;
    }
    permutation.add(closest);
  }
  double rmsd=Math.sqrt(sum / transformedCoords.length);
  if (rmsd > distanceThreshold || permutation.size() != transformedCoords.length) {
    permutation.clear();
    return permutation;
  }
  Set<Integer> set=new HashSet<Integer>(permutation);
  if (set.size() != originalCoords.length) {
    permutation.clear();
  }
  return permutation;
}","/** 
 * Compare this.transformedCoords with the original coords. For each subunit, return the transformed subunit with the closest position.
 * @return A list mapping each subunit to the closest transformed subunit
 */
private List<Integer> getPermutation(){
  List<Integer> permutation=new ArrayList<Integer>(transformedCoords.length);
  double sum=0.0f;
  for (  Point3d t : transformedCoords) {
    List<Integer> neighbors=box.getNeighborsWithCache(t);
    int closest=-1;
    double minDist=Double.MAX_VALUE;
    for (    int j : neighbors) {
      double dist=t.distanceSquared(originalCoords[j]);
      if (dist < minDist) {
        closest=j;
        minDist=dist;
      }
    }
    sum+=minDist;
    if (closest == -1) {
      break;
    }
    permutation.add(closest);
  }
  double rmsd=Math.sqrt(sum / transformedCoords.length);
  if (rmsd > distanceThreshold || permutation.size() != transformedCoords.length) {
    permutation.clear();
    return permutation;
  }
  Set<Integer> set=new HashSet<Integer>(permutation);
  if (set.size() != originalCoords.length) {
    permutation.clear();
  }
  return permutation;
}",0.8923832923832924
16249,"private void completeRotationGroup(){
  PermutationGroup g=new PermutationGroup();
  for (int i=0; i < rotations.getOrder(); i++) {
    Rotation s=rotations.getRotation(i);
    g.addPermutation(s.getPermutation());
  }
  g.completeGroup();
  if (g.getOrder() == rotations.getOrder()) {
    return;
  }
  for (int i=0; i < g.getOrder(); i++) {
    List<Integer> permutation=g.getPermutation(i);
    boolean isValidPermutation=isValidPermutation(permutation);
    if (isValidPermutation) {
      evaluatePermutation(permutation);
    }
  }
}","/** 
 * Combine current rotations to make all possible permutations. If these are all valid, add them to the rotations
 * @param additionalRots Additional rotations we are considering adding to this.rotations
 * @return whether the rotations were valid and added
 */
private boolean completeRotationGroup(Rotation... additionalRots){
}",0.0732265446224256
16250,"private boolean isValidPermutation(List<Integer> permutation){
  if (permutation.size() == 0) {
    return false;
  }
  if (hashCodes.contains(permutation)) {
    return false;
  }
  if (!isAllowedPermutation(permutation)) {
    return false;
  }
  return hashCodes.add(permutation);
}","/** 
 * Checks if a particular permutation is allowed and superimposes well. Caches results.
 * @param permutation
 * @return null if invalid, or a rotation if valid
 */
private Rotation isValidPermutation(List<Integer> permutation){
  if (permutation.size() == 0) {
    return null;
  }
  if (evaluatedPermutations.containsKey(permutation)) {
    return evaluatedPermutations.get(permutation);
  }
  if (!isAllowedPermutation(permutation)) {
    evaluatedPermutations.put(permutation,null);
    return null;
  }
  Rotation rot=superimposePermutation(permutation);
  return rot;
}",0.3976878612716763
16251,"private List<Double> getAngles(){
  int n=subunits.getSubunitCount();
  if (n % 60 == 0 && isSpherical()) {
    n=60;
  }
  List<Integer> folds=subunits.getFolds();
  List<Double> angles=new ArrayList<Double>(folds.size() - 1);
  for (  int fold : folds) {
    if (fold > 0 && fold <= n) {
      angles.add(2 * Math.PI / fold);
    }
  }
  return angles;
}","/** 
 * Get valid rotation angles given the number of subunits
 * @return The rotation angle corresponding to each fold of {@link Subunits#getFolds()}
 */
private List<Double> getAngles(){
  int n=subunits.getSubunitCount();
  if (n % 60 == 0 && isSpherical()) {
    n=60;
  }
  List<Integer> folds=subunits.getFolds();
  List<Double> angles=new ArrayList<Double>(folds.size() - 1);
  for (  int fold : folds) {
    if (fold > 0 && fold <= n) {
      angles.add(2 * Math.PI / fold);
    }
  }
  return angles;
}",0.8212226066897347
16252,"/** 
 * The permutation must map all subunits onto an equivalent subunit and no subunit onto itself
 * @param permutation
 * @return
 */
private boolean isAllowedPermutation(List<Integer> permutation){
  List<Integer> seqClusterId=subunits.getSequenceClusterIds();
  for (int i=0; i < permutation.size(); i++) {
    int j=permutation.get(i);
    if (i == j || seqClusterId.get(i) != seqClusterId.get(j)) {
      return false;
    }
  }
  return true;
}","/** 
 * The permutation must map all subunits onto an equivalent subunit and no subunit onto itself
 * @param permutation
 * @return
 */
private boolean isAllowedPermutation(List<Integer> permutation){
  List<Integer> seqClusterId=subunits.getSequenceClusterIds();
  int selfaligned=0;
  for (int i=0; i < permutation.size(); i++) {
    int j=permutation.get(i);
    if (seqClusterId.get(i) != seqClusterId.get(j)) {
      return false;
    }
    if (i == j) {
      selfaligned++;
    }
  }
  return selfaligned == 0 || selfaligned == permutation.size();
}",0.711595639246779
16253,"private void solve(){
  initialize();
  int maxSymOps=subunits.getSubunitCount();
  boolean isSpherical=isSpherical();
  if (maxSymOps % 60 == 0 && isSpherical) {
    maxSymOps=60;
  }
  AxisAngle4d sphereAngle=new AxisAngle4d();
  Matrix4d transformation=new Matrix4d();
  int n=subunits.getSubunitCount();
  int sphereCount=SphereSampler.getSphereCount();
  List<Double> angles=getAngles();
  for (int i=0; i < sphereCount; i++) {
    SphereSampler.getAxisAngle(i,sphereAngle);
    for (    double angle : angles) {
      sphereAngle.angle=angle;
      transformation.set(sphereAngle);
      transformation.setElement(3,3,1.0);
      for (int j=0; j < n; j++) {
        transformedCoords[j].set(originalCoords[j]);
        transformation.transform(transformedCoords[j]);
      }
      List<Integer> permutation=getPermutation();
      boolean isValidPermuation=isValidPermutation(permutation);
      if (!isValidPermuation) {
        continue;
      }
      boolean newPermutation=evaluatePermutation(permutation);
      if (newPermutation) {
        completeRotationGroup();
      }
      if (rotations.getOrder() >= maxSymOps) {
        return;
      }
    }
  }
}","private void solve(){
  initialize();
  int maxSymOps=subunits.getSubunitCount();
  boolean isSpherical=isSpherical();
  if (maxSymOps % 60 == 0 && isSpherical) {
    maxSymOps=60;
  }
  AxisAngle4d sphereAngle=new AxisAngle4d();
  Matrix4d transformation=new Matrix4d();
  int n=subunits.getSubunitCount();
  int sphereCount=SphereSampler.getSphereCount();
  List<Double> angles=getAngles();
  for (int i=0; i < sphereCount; i++) {
    SphereSampler.getAxisAngle(i,sphereAngle);
    for (    double angle : angles) {
      sphereAngle.angle=angle;
      transformation.set(sphereAngle);
      transformation.setElement(3,3,1.0);
      for (int j=0; j < n; j++) {
        transformedCoords[j].set(originalCoords[j]);
        transformation.transform(transformedCoords[j]);
      }
      List<Integer> permutation=getPermutation();
      if (evaluatedPermutations.containsKey(permutation)) {
        continue;
      }
      Rotation newPermutation=isValidPermutation(permutation);
      if (newPermutation != null) {
        completeRotationGroup(newPermutation);
      }
      if (rotations.getOrder() >= maxSymOps) {
        return;
      }
    }
  }
}",0.9246014648858252
16254,"private Rotation createSymmetryOperation(List<Integer> permutation,Matrix4d transformation,AxisAngle4d axisAngle,int fold,QuatSymmetryScores scores){
  Rotation s=new Rotation();
  s.setPermutation(new ArrayList<Integer>(permutation));
  s.setTransformation(new Matrix4d(transformation));
  s.setAxisAngle(new AxisAngle4d(axisAngle));
  s.setFold(fold);
  s.setScores(scores);
  return s;
}","private static Rotation createSymmetryOperation(List<Integer> permutation,Matrix4d transformation,AxisAngle4d axisAngle,int fold,QuatSymmetryScores scores){
  Rotation s=new Rotation();
  s.setPermutation(new ArrayList<Integer>(permutation));
  s.setTransformation(new Matrix4d(transformation));
  s.setAxisAngle(new AxisAngle4d(axisAngle));
  s.setFold(fold);
  s.setScores(scores);
  return s;
}",0.9911054637865312
16255,"/** 
 * Create and set a new structure from a given atom array.
 * @param atoms
 */
public void setAtoms(Atom[] atoms){
  Structure s=new StructureImpl();
  Chain c=new ChainImpl();
  c.setId(""String_Node_Str"");
  for (  Atom a : atoms) {
    c.addGroup(a.getGroup());
  }
  s.addChain(c);
  setStructure(s);
}","/** 
 * Create and set a new structure from a given atom array.
 * @param atoms
 */
public void setAtoms(Atom[] atoms){
  Structure s=new StructureImpl();
  Chain c=new ChainImpl();
  c.setChainID(""String_Node_Str"");
  for (  Atom a : atoms) {
    c.addGroup(a.getGroup());
  }
  s.addChain(c);
  setStructure(s);
}",0.9888
16256,"/** 
 * Returns the centroid of the set of atoms.
 * @param atomSet a set of Atoms
 * @return an Atom representing the Centroid of the set of atoms
 */
public static final Atom getCentroid(Atom[] atomSet){
  if (atomSet.length == 0)   throw new IllegalArgumentException(""String_Node_Str"");
  double[] coords=new double[3];
  coords[0]=0;
  coords[1]=0;
  coords[2]=0;
  for (  Atom a : atomSet) {
    coords[0]+=a.getX();
    coords[1]+=a.getY();
    coords[2]+=a.getZ();
  }
  int n=atomSet.length;
  coords[0]=coords[0] / n;
  coords[1]=coords[1] / n;
  coords[2]=coords[2] / n;
  Atom vec=new AtomImpl();
  vec.setCoords(coords);
  return vec;
}","/** 
 * Returns the centroid of the set of atoms.
 * @param atomSet a set of Atoms
 * @return an Atom representing the Centroid of the set of atoms
 */
public static final Atom getCentroid(Atom[] atomSet){
  if (atomSet.length == 0)   throw new IllegalArgumentException(""String_Node_Str"");
  if (atomSet.length == 0)   throw new IllegalArgumentException(""String_Node_Str"");
  double[] coords=new double[3];
  coords[0]=0;
  coords[1]=0;
  coords[2]=0;
  for (  Atom a : atomSet) {
    coords[0]+=a.getX();
    coords[1]+=a.getY();
    coords[2]+=a.getZ();
  }
  int n=atomSet.length;
  coords[0]=coords[0] / n;
  coords[1]=coords[1] / n;
  coords[2]=coords[2] / n;
  Atom vec=new AtomImpl();
  vec.setCoords(coords);
  return vec;
}",0.9391304347826088
16257,"private Vector3d orthogonalize(Vector3d vector1,Vector3d vector2){
  double dot=vector1.dot(vector2);
  Vector3d ref=new Vector3d(vector2);
  if (dot < 0) {
    vector2.negate();
  }
  if (Math.abs(dot) < 0.00001) {
    System.out.println(""String_Node_Str"");
  }
  vector2.cross(vector1,vector2);
  vector2.normalize();
  vector2.cross(vector1,vector2);
  vector2.normalize();
  if (ref.dot(vector2) < 0) {
    vector2.negate();
  }
  return vector2;
}","private Vector3d orthogonalize(Vector3d vector1,Vector3d vector2){
  double dot=vector1.dot(vector2);
  Vector3d ref=new Vector3d(vector2);
  if (dot < 0) {
    vector2.negate();
  }
  if (Math.abs(dot) < 0.00001) {
    logger.info(""String_Node_Str"");
  }
  vector2.cross(vector1,vector2);
  vector2.normalize();
  vector2.cross(vector1,vector2);
  vector2.normalize();
  if (ref.dot(vector2) < 0) {
    vector2.negate();
  }
  return vector2;
}",0.9698996655518396
16258,"/** 
 * Returns a vector perpendicular to the principal rotation vector for the alignment of structures in the xy-plane
 * @return reference vector
 */
private void calcReferenceVector(){
  referenceVector=getReferenceAxisCylic();
  if (referenceVector == null) {
    System.err.println(""String_Node_Str"");
    referenceVector=new Vector3d(Y_AXIS);
  }
  referenceVector=orthogonalize(principalRotationVector,referenceVector);
}","/** 
 * Returns a vector perpendicular to the principal rotation vector for the alignment of structures in the xy-plane
 * @return reference vector
 */
private void calcReferenceVector(){
  referenceVector=getReferenceAxisCylic();
  if (referenceVector == null) {
    logger.warn(""String_Node_Str"");
    referenceVector=new Vector3d(Y_AXIS);
  }
  referenceVector=orthogonalize(principalRotationVector,referenceVector);
}",0.9705535924617196
16259,"/** 
 * Returns an ordered list of subunit ids (orbit) in such a way that the subunit indices start at the 12 o-clock (+y axis) and proceed in a clockwise direction to the 11 o-clock position to close the ""orbit"".
 * @param orbit list of subunit indices that are transformed into each other by a rotation
 * @return list of subunit indices ordered in a clockwise direction
 */
private List<Integer> alignWithReferenceAxis(List<Integer> orbit){
  int n=subunits.getSubunitCount();
  int fold=rotationGroup.getRotation(0).getFold();
  if (fold < 2) {
    return orbit;
  }
  Vector3d probe=new Vector3d();
  double dotMin1=Double.MIN_VALUE;
  double dotMin2=Double.MIN_VALUE;
  int index1=0;
  int index2=0;
  Vector3d Y1=new Vector3d(0,1,0);
  Vector3d Y2=new Vector3d(0,1,0);
  Matrix3d m=new Matrix3d();
  double angle=-2 * Math.PI / fold;
  m.rotZ(0.1 * angle);
  m.transform(Y1);
  m.rotZ(1.1 * angle);
  m.transform(Y2);
  for (  int i : orbit) {
    Point3d p=subunits.getCenters().get(i);
    probe.set(p);
    transformationMatrix.transform(probe);
    double dot1=Y1.dot(probe);
    if (dot1 > dotMin1) {
      dotMin1=dot1;
      index1=i;
    }
    double dot2=Y2.dot(probe);
    if (dot2 > dotMin2) {
      dotMin2=dot2;
      index2=i;
    }
  }
  for (int i=0; i < n; i++) {
    if (orbit.get(0) == index1) {
      break;
    }
    Collections.rotate(orbit,1);
  }
  if (orbit.get(1) == index2) {
    return orbit;
  }
  Collections.reverse(orbit.subList(1,orbit.size()));
  if (orbit.get(1) != index2) {
    System.err.println(""String_Node_Str"");
  }
  return orbit;
}","/** 
 * Returns an ordered list of subunit ids (orbit) in such a way that the subunit indices start at the 12 o-clock (+y axis) and proceed in a clockwise direction to the 11 o-clock position to close the ""orbit"".
 * @param orbit list of subunit indices that are transformed into each other by a rotation
 * @return list of subunit indices ordered in a clockwise direction
 */
private List<Integer> alignWithReferenceAxis(List<Integer> orbit){
  int n=subunits.getSubunitCount();
  int fold=rotationGroup.getRotation(0).getFold();
  if (fold < 2) {
    return orbit;
  }
  Vector3d probe=new Vector3d();
  double dotMin1=Double.MIN_VALUE;
  double dotMin2=Double.MIN_VALUE;
  int index1=0;
  int index2=0;
  Vector3d Y1=new Vector3d(0,1,0);
  Vector3d Y2=new Vector3d(0,1,0);
  Matrix3d m=new Matrix3d();
  double angle=-2 * Math.PI / fold;
  m.rotZ(0.1 * angle);
  m.transform(Y1);
  m.rotZ(1.1 * angle);
  m.transform(Y2);
  for (  int i : orbit) {
    Point3d p=subunits.getCenters().get(i);
    probe.set(p);
    transformationMatrix.transform(probe);
    double dot1=Y1.dot(probe);
    if (dot1 > dotMin1) {
      dotMin1=dot1;
      index1=i;
    }
    double dot2=Y2.dot(probe);
    if (dot2 > dotMin2) {
      dotMin2=dot2;
      index2=i;
    }
  }
  for (int i=0; i < n; i++) {
    if (orbit.get(0) == index1) {
      break;
    }
    Collections.rotate(orbit,1);
  }
  if (orbit.get(1) == index2) {
    return orbit;
  }
  Collections.reverse(orbit.subList(1,orbit.size()));
  if (orbit.get(1) != index2) {
    logger.warn(""String_Node_Str"");
  }
  return orbit;
}",0.9914475768134304
16260,"private List<Integer> deconvolute(List<Integer> orbit){
  if (rotationGroup.getOrder() < 2) {
    return orbit;
  }
  List<Integer> p0=rotationGroup.getRotation(0).getPermutation();
  List<Integer> p1=rotationGroup.getRotation(1).getPermutation();
  List<Integer> inRotationOrder=new ArrayList<Integer>(orbit.size());
  inRotationOrder.add(orbit.get(0));
  for (int i=1; i < orbit.size(); i++) {
    int current=inRotationOrder.get(i - 1);
    int index=p0.indexOf(current);
    int next=p1.get(index);
    if (!orbit.contains(next)) {
      System.err.println(""String_Node_Str"");
      return orbit;
    }
    inRotationOrder.add(next);
  }
  return inRotationOrder;
}","private List<Integer> deconvolute(List<Integer> orbit){
  if (rotationGroup.getOrder() < 2) {
    return orbit;
  }
  List<Integer> p0=rotationGroup.getRotation(0).getPermutation();
  List<Integer> p1=rotationGroup.getRotation(1).getPermutation();
  List<Integer> inRotationOrder=new ArrayList<Integer>(orbit.size());
  inRotationOrder.add(orbit.get(0));
  for (int i=1; i < orbit.size(); i++) {
    int current=inRotationOrder.get(i - 1);
    int index=p0.indexOf(current);
    int next=p1.get(index);
    if (!orbit.contains(next)) {
      logger.warn(""String_Node_Str"");
      return orbit;
    }
    inRotationOrder.add(next);
  }
  return inRotationOrder;
}",0.9812171299774606
16261,"/** 
 * Returns a vector perpendicular to the principal rotation vector for the alignment of structures in the xy-plane
 * @return reference vector
 */
private void calcReferenceVector(){
  referenceVector=null;
  if (rotationGroup.getPointGroup().startsWith(""String_Node_Str"")) {
    referenceVector=getReferenceAxisCylic();
  }
 else   if (rotationGroup.getPointGroup().startsWith(""String_Node_Str"")) {
    referenceVector=getReferenceAxisDihedral();
  }
 else   if (rotationGroup.getPointGroup().equals(""String_Node_Str"")) {
    referenceVector=getReferenceAxisTetrahedral();
  }
 else   if (rotationGroup.getPointGroup().equals(""String_Node_Str"")) {
    referenceVector=getReferenceAxisOctahedral();
  }
 else   if (rotationGroup.getPointGroup().equals(""String_Node_Str"")) {
    referenceVector=getReferenceAxisIcosahedral();
  }
 else   if (rotationGroup.getPointGroup().equals(""String_Node_Str"")) {
    referenceVector=getReferenceAxisCylic();
  }
  if (referenceVector == null) {
    System.err.println(""String_Node_Str"");
    referenceVector=new Vector3d(Y_AXIS);
  }
  referenceVector=orthogonalize(principalRotationVector,referenceVector);
}","/** 
 * Returns a vector perpendicular to the principal rotation vector for the alignment of structures in the xy-plane
 * @return reference vector
 */
private void calcReferenceVector(){
  referenceVector=null;
  if (rotationGroup.getPointGroup().startsWith(""String_Node_Str"")) {
    referenceVector=getReferenceAxisCylic();
  }
 else   if (rotationGroup.getPointGroup().startsWith(""String_Node_Str"")) {
    referenceVector=getReferenceAxisDihedral();
  }
 else   if (rotationGroup.getPointGroup().equals(""String_Node_Str"")) {
    referenceVector=getReferenceAxisTetrahedral();
  }
 else   if (rotationGroup.getPointGroup().equals(""String_Node_Str"")) {
    referenceVector=getReferenceAxisOctahedral();
  }
 else   if (rotationGroup.getPointGroup().equals(""String_Node_Str"")) {
    referenceVector=getReferenceAxisIcosahedral();
  }
 else   if (rotationGroup.getPointGroup().equals(""String_Node_Str"")) {
    referenceVector=getReferenceAxisCylic();
  }
  if (referenceVector == null) {
    logger.warn(""String_Node_Str"");
    referenceVector=new Vector3d(Y_AXIS);
  }
  referenceVector=orthogonalize(principalRotationVector,referenceVector);
}",0.9882352941176472
16262,"/** 
 * Get the chromosome position mapped onto the mRNA CDS transcript position (needs to be divided by 3 to get protein coordinate)
 * @param exonStarts
 * @param exonEnds
 * @param cdsStart
 * @param cdsEnd
 * @return
 */
public static int getCDSPosForward(int chromPos,List<Integer> exonStarts,List<Integer> exonEnds,int cdsStart,int cdsEnd){
  boolean inCoding=false;
  int codingLength=0;
  logger.debug(""String_Node_Str"" + chromPos);
  int lengthExons=0;
  for (int i=0; i < exonStarts.size(); i++) {
    int start=exonStarts.get(i);
    int end=exonEnds.get(i);
    lengthExons+=end - start;
    logger.debug(""String_Node_Str"" + (start + 1) + ""String_Node_Str""+ end+ ""String_Node_Str""+ (end - start)+ ""String_Node_Str""+ format(chromPos));
    if (start + 1 <= cdsStart + 1 && end >= cdsStart + 1) {
      if (end >= chromPos) {
        int tmp=chromPos - cdsStart - 1;
        logger.debug(""String_Node_Str"" + codingLength + ""String_Node_Str""+ tmp);
        logger.debug(""String_Node_Str"" + chromPos + ""String_Node_Str""+ format(start)+ ""String_Node_Str""+ format(tmp)+ ""String_Node_Str""+ cdsStart+ ""String_Node_Str""+ codingLength);
        return codingLength + tmp;
      }
      inCoding=true;
      codingLength+=(end - cdsStart);
      logger.debug(""String_Node_Str"" + format(start) + ""String_Node_Str""+ (cdsStart));
      logger.debug(""String_Node_Str"" + format(cdsStart + 1) + ""String_Node_Str""+ format(end)+ ""String_Node_Str""+ format(end - cdsStart)+ ""String_Node_Str""+ codingLength+ ""String_Node_Str""+ (codingLength % 3));
    }
 else     if (start <= cdsEnd && end >= cdsEnd) {
      inCoding=false;
      if (cdsEnd >= chromPos && (start + 1 <= chromPos)) {
        int tmp=chromPos - start - 1;
        logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ chromPos+ ""String_Node_Str""+ format(start + 1)+ ""String_Node_Str""+ format(tmp)+ ""String_Node_Str""+ cdsStart+ ""String_Node_Str""+ codingLength);
        return codingLength + tmp;
      }
      codingLength+=(cdsEnd - start);
      logger.debug(""String_Node_Str"" + format(start + 1) + ""String_Node_Str""+ format(cdsEnd)+ ""String_Node_Str""+ format(cdsEnd - start + 1)+ ""String_Node_Str""+ codingLength+ ""String_Node_Str""+ (codingLength % 3));
      logger.debug(""String_Node_Str"" + format(cdsEnd + 1) + ""String_Node_Str""+ format(end));
    }
 else     if (inCoding) {
      if (end >= chromPos && (start + 1 <= chromPos)) {
        int tmp=chromPos - start - 1;
        logger.debug(codingLength + ""String_Node_Str"" + tmp);
        logger.debug(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ format(chromPos)+ ""String_Node_Str""+ format(start + 1)+ ""String_Node_Str""+ format(tmp)+ ""String_Node_Str""+ cdsStart+ ""String_Node_Str""+ codingLength);
        return codingLength + tmp;
      }
      codingLength+=(end - start);
      logger.debug(""String_Node_Str"" + format(start) + ""String_Node_Str""+ format(end)+ ""String_Node_Str""+ format(end - start)+ ""String_Node_Str""+ codingLength+ ""String_Node_Str""+ (codingLength % 3));
    }
  }
  return -1;
}","/** 
 * Get the chromosome position mapped onto the mRNA CDS transcript position (needs to be divided by 3 to get protein coordinate)
 * @param exonStarts
 * @param exonEnds
 * @param cdsStart
 * @param cdsEnd
 * @return
 */
public static int getCDSPosForward(int chromPos,List<Integer> exonStarts,List<Integer> exonEnds,int cdsStart,int cdsEnd){
  boolean inCoding=false;
  int codingLength=0;
  logger.debug(""String_Node_Str"" + chromPos);
  if (chromPos < cdsStart + 1) {
    logger.debug(chromPos + ""String_Node_Str"" + cdsStart+ 1);
    return -1;
  }
  if (chromPos > cdsEnd + 1) {
    logger.debug(chromPos + ""String_Node_Str"" + cdsEnd+ 1);
    return -1;
  }
  int lengthExons=0;
  for (int i=0; i < exonStarts.size(); i++) {
    int start=exonStarts.get(i);
    int end=exonEnds.get(i);
    lengthExons+=end - start;
    logger.debug(""String_Node_Str"" + (start + 1) + ""String_Node_Str""+ end+ ""String_Node_Str""+ (end - start)+ ""String_Node_Str""+ format(chromPos));
    if (start + 1 <= cdsStart + 1 && end >= cdsStart + 1) {
      if (end >= chromPos) {
        int tmp=chromPos - cdsStart - 1;
        logger.debug(""String_Node_Str"" + codingLength + ""String_Node_Str""+ tmp);
        logger.debug(""String_Node_Str"" + chromPos + ""String_Node_Str""+ format(start)+ ""String_Node_Str""+ format(tmp)+ ""String_Node_Str""+ cdsStart+ ""String_Node_Str""+ codingLength);
        return codingLength + tmp;
      }
      inCoding=true;
      codingLength+=(end - cdsStart);
      logger.debug(""String_Node_Str"" + format(start) + ""String_Node_Str""+ (cdsStart));
      logger.debug(""String_Node_Str"" + format(cdsStart + 1) + ""String_Node_Str""+ format(end)+ ""String_Node_Str""+ format(end - cdsStart)+ ""String_Node_Str""+ codingLength+ ""String_Node_Str""+ (codingLength % 3));
    }
 else     if (start <= cdsEnd && end >= cdsEnd) {
      inCoding=false;
      if (cdsEnd >= chromPos && (start + 1 <= chromPos)) {
        int tmp=chromPos - start - 1;
        logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ chromPos+ ""String_Node_Str""+ format(start + 1)+ ""String_Node_Str""+ format(tmp)+ ""String_Node_Str""+ cdsStart+ ""String_Node_Str""+ codingLength);
        return codingLength + tmp;
      }
      codingLength+=(cdsEnd - start);
      logger.debug(""String_Node_Str"" + format(start + 1) + ""String_Node_Str""+ format(cdsEnd)+ ""String_Node_Str""+ format(cdsEnd - start + 1)+ ""String_Node_Str""+ codingLength+ ""String_Node_Str""+ (codingLength % 3));
      logger.debug(""String_Node_Str"" + format(cdsEnd + 1) + ""String_Node_Str""+ format(end));
    }
 else     if (inCoding) {
      if (end >= chromPos && (start + 1 <= chromPos)) {
        int tmp=chromPos - start - 1;
        logger.debug(codingLength + ""String_Node_Str"" + tmp);
        logger.debug(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ format(chromPos)+ ""String_Node_Str""+ format(start + 1)+ ""String_Node_Str""+ format(tmp)+ ""String_Node_Str""+ cdsStart+ ""String_Node_Str""+ codingLength);
        return codingLength + tmp;
      }
      codingLength+=(end - start);
      logger.debug(""String_Node_Str"" + format(start) + ""String_Node_Str""+ format(end)+ ""String_Node_Str""+ format(end - start)+ ""String_Node_Str""+ codingLength+ ""String_Node_Str""+ (codingLength % 3));
    }
  }
  logger.debug(""String_Node_Str"" + lengthExons);
  return -1;
}",0.9567421961654254
16263,"private List<Integer> getPermutation(){
  List<Integer> permutation=new ArrayList<Integer>(transformedCoords.length);
  double sum=0.0f;
  for (  Point3d t : transformedCoords) {
    List<Integer> neighbors=box.getNeighborsWithCache(t);
    int closest=-1;
    double minDist=Double.MAX_VALUE;
    for (    int j : neighbors) {
      double dist=t.distanceSquared(originalCoords[j]);
      if (dist < minDist) {
        closest=j;
        minDist=dist;
      }
    }
    sum+=minDist;
    if (closest == -1) {
      break;
    }
    permutation.add(closest);
  }
  double rmsd=Math.sqrt(sum / transformedCoords.length);
  if (rmsd > distanceThreshold || permutation.size() != transformedCoords.length) {
    permutation.clear();
    return permutation;
  }
  Set<Integer> set=new HashSet<Integer>(permutation);
  if (set.size() != originalCoords.length) {
    permutation.clear();
  }
  return permutation;
}","/** 
 * Compare this.transformedCoords with the original coords. For each subunit, return the transformed subunit with the closest position.
 * @return A list mapping each subunit to the closest transformed subunit
 */
private List<Integer> getPermutation(){
  List<Integer> permutation=new ArrayList<Integer>(transformedCoords.length);
  double sum=0.0f;
  for (  Point3d t : transformedCoords) {
    List<Integer> neighbors=box.getNeighborsWithCache(t);
    int closest=-1;
    double minDist=Double.MAX_VALUE;
    for (    int j : neighbors) {
      double dist=t.distanceSquared(originalCoords[j]);
      if (dist < minDist) {
        closest=j;
        minDist=dist;
      }
    }
    sum+=minDist;
    if (closest == -1) {
      break;
    }
    permutation.add(closest);
  }
  double rmsd=Math.sqrt(sum / transformedCoords.length);
  if (rmsd > distanceThreshold || permutation.size() != transformedCoords.length) {
    permutation.clear();
    return permutation;
  }
  Set<Integer> set=new HashSet<Integer>(permutation);
  if (set.size() != originalCoords.length) {
    permutation.clear();
  }
  return permutation;
}",0.8923832923832924
16264,"private void completeRotationGroup(){
  PermutationGroup g=new PermutationGroup();
  for (int i=0; i < rotations.getOrder(); i++) {
    Rotation s=rotations.getRotation(i);
    g.addPermutation(s.getPermutation());
  }
  g.completeGroup();
  if (g.getOrder() == rotations.getOrder()) {
    return;
  }
  for (int i=0; i < g.getOrder(); i++) {
    List<Integer> permutation=g.getPermutation(i);
    boolean isValidPermutation=isValidPermutation(permutation);
    if (isValidPermutation) {
      evaluatePermutation(permutation);
    }
  }
}","/** 
 * Combine current rotations to make all possible permutations. If these are all valid, add them to the rotations
 * @param additionalRots Additional rotations we are considering adding to this.rotations
 * @return whether the rotations were valid and added
 */
private boolean completeRotationGroup(Rotation... additionalRots){
}",0.0732265446224256
16265,"private boolean isValidPermutation(List<Integer> permutation){
  if (permutation.size() == 0) {
    return false;
  }
  if (hashCodes.contains(permutation)) {
    return false;
  }
  if (!isAllowedPermutation(permutation)) {
    return false;
  }
  int fold=PermutationGroup.getOrder(permutation);
  if (rotations.getOrder() > 1 && fold == 1) {
    return false;
  }
  if (fold == 0 || subunits.getSubunitCount() % fold != 0) {
    return false;
  }
  return hashCodes.add(permutation);
}","/** 
 * Checks if a particular permutation is allowed and superimposes well. Caches results.
 * @param permutation
 * @return null if invalid, or a rotation if valid
 */
private Rotation isValidPermutation(List<Integer> permutation){
  if (permutation.size() == 0) {
    return null;
  }
  if (evaluatedPermutations.containsKey(permutation)) {
    return evaluatedPermutations.get(permutation);
  }
  if (!isAllowedPermutation(permutation)) {
    evaluatedPermutations.put(permutation,null);
    return null;
  }
  Rotation rot=superimposePermutation(permutation);
  return rot;
}",0.348314606741573
16266,"private List<Double> getAngles(){
  int n=subunits.getSubunitCount();
  if (n % 60 == 0 && isSpherical()) {
    n=60;
  }
  List<Integer> folds=subunits.getFolds();
  List<Double> angles=new ArrayList<Double>(folds.size() - 1);
  for (  int fold : folds) {
    if (fold > 0 && fold <= n) {
      angles.add(2 * Math.PI / fold);
    }
  }
  return angles;
}","/** 
 * Get valid rotation angles given the number of subunits
 * @return The rotation angle corresponding to each fold of {@link Subunits#getFolds()}
 */
private List<Double> getAngles(){
  int n=subunits.getSubunitCount();
  if (n % 60 == 0 && isSpherical()) {
    n=60;
  }
  List<Integer> folds=subunits.getFolds();
  List<Double> angles=new ArrayList<Double>(folds.size() - 1);
  for (  int fold : folds) {
    if (fold > 0 && fold <= n) {
      angles.add(2 * Math.PI / fold);
    }
  }
  return angles;
}",0.8212226066897347
16267,"private boolean isAllowedPermutation(List<Integer> permutation){
  List<Integer> seqClusterId=subunits.getSequenceClusterIds();
  for (int i=0; i < permutation.size(); i++) {
    int j=permutation.get(i);
    if (seqClusterId.get(i) != seqClusterId.get(j)) {
      return false;
    }
  }
  return true;
}","/** 
 * The permutation must map all subunits onto an equivalent subunit and no subunit onto itself
 * @param permutation
 * @return
 */
private boolean isAllowedPermutation(List<Integer> permutation){
  List<Integer> seqClusterId=subunits.getSequenceClusterIds();
  int selfaligned=0;
  for (int i=0; i < permutation.size(); i++) {
    int j=permutation.get(i);
    if (seqClusterId.get(i) != seqClusterId.get(j)) {
      return false;
    }
    if (i == j) {
      selfaligned++;
    }
  }
  return selfaligned == 0 || selfaligned == permutation.size();
}",0.6774941995359629
16268,"private void solve(){
  initialize();
  int maxSymOps=subunits.getSubunitCount();
  boolean isSpherical=isSpherical();
  if (maxSymOps % 60 == 0 && isSpherical) {
    maxSymOps=60;
  }
  AxisAngle4d sphereAngle=new AxisAngle4d();
  Matrix4d transformation=new Matrix4d();
  int n=subunits.getSubunitCount();
  int sphereCount=SphereSampler.getSphereCount();
  List<Double> angles=getAngles();
  for (int i=0; i < sphereCount; i++) {
    SphereSampler.getAxisAngle(i,sphereAngle);
    for (    double angle : angles) {
      sphereAngle.angle=angle;
      transformation.set(sphereAngle);
      transformation.setElement(3,3,1.0);
      for (int j=0; j < n; j++) {
        transformedCoords[j].set(originalCoords[j]);
        transformation.transform(transformedCoords[j]);
      }
      List<Integer> permutation=getPermutation();
      boolean isValidPermuation=isValidPermutation(permutation);
      if (!isValidPermuation) {
        continue;
      }
      boolean newPermutation=evaluatePermutation(permutation);
      if (newPermutation) {
        completeRotationGroup();
      }
      if (rotations.getOrder() >= maxSymOps) {
        return;
      }
    }
  }
}","private void solve(){
  initialize();
  int maxSymOps=subunits.getSubunitCount();
  boolean isSpherical=isSpherical();
  if (maxSymOps % 60 == 0 && isSpherical) {
    maxSymOps=60;
  }
  AxisAngle4d sphereAngle=new AxisAngle4d();
  Matrix4d transformation=new Matrix4d();
  int n=subunits.getSubunitCount();
  int sphereCount=SphereSampler.getSphereCount();
  List<Double> angles=getAngles();
  for (int i=0; i < sphereCount; i++) {
    SphereSampler.getAxisAngle(i,sphereAngle);
    for (    double angle : angles) {
      sphereAngle.angle=angle;
      transformation.set(sphereAngle);
      transformation.setElement(3,3,1.0);
      for (int j=0; j < n; j++) {
        transformedCoords[j].set(originalCoords[j]);
        transformation.transform(transformedCoords[j]);
      }
      List<Integer> permutation=getPermutation();
      if (evaluatedPermutations.containsKey(permutation)) {
        continue;
      }
      Rotation newPermutation=isValidPermutation(permutation);
      if (newPermutation != null) {
        completeRotationGroup(newPermutation);
      }
      if (rotations.getOrder() >= maxSymOps) {
        return;
      }
    }
  }
}",0.9246014648858252
16269,"private Rotation createSymmetryOperation(List<Integer> permutation,Matrix4d transformation,AxisAngle4d axisAngle,int fold,QuatSymmetryScores scores){
  Rotation s=new Rotation();
  s.setPermutation(new ArrayList<Integer>(permutation));
  s.setTransformation(new Matrix4d(transformation));
  s.setAxisAngle(new AxisAngle4d(axisAngle));
  s.setFold(fold);
  s.setScores(scores);
  return s;
}","private static Rotation createSymmetryOperation(List<Integer> permutation,Matrix4d transformation,AxisAngle4d axisAngle,int fold,QuatSymmetryScores scores){
  Rotation s=new Rotation();
  s.setPermutation(new ArrayList<Integer>(permutation));
  s.setTransformation(new Matrix4d(transformation));
  s.setAxisAngle(new AxisAngle4d(axisAngle));
  s.setFold(fold);
  s.setScores(scores);
  return s;
}",0.9911054637865312
16270,"private void downloadFile(URL u,File localFile) throws IOException {
  System.out.println(""String_Node_Str"" + u);
  File tmp=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  InputStream is=u.openStream();
  BufferedInputStream in=new BufferedInputStream(is);
  FileOutputStream w=new FileOutputStream(tmp);
  int i=0;
  byte[] bytesIn=new byte[300000];
  while ((i=in.read(bytesIn)) >= 0) {
    w.write(bytesIn,0,i);
  }
  in.close();
  w.close();
  copyFile(tmp,localFile);
}","public void downloadFile(URL u,File localFile) throws IOException {
  logger.info(""String_Node_Str"" + u);
  File tmp=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  InputStream is=u.openStream();
  BufferedInputStream in=new BufferedInputStream(is);
  FileOutputStream w=new FileOutputStream(tmp);
  int i=0;
  byte[] bytesIn=new byte[300000];
  while ((i=in.read(bytesIn)) >= 0) {
    w.write(bytesIn,0,i);
  }
  in.close();
  w.close();
  copyFile(tmp,localFile);
}",0.958592132505176
16271,"public static void copyFile(File src,File dst) throws IOException {
  long p=0, dp, size;
  FileChannel in=null, out=null;
  try {
    if (!dst.exists())     dst.createNewFile();
    in=new FileInputStream(src).getChannel();
    out=new FileOutputStream(dst).getChannel();
    size=in.size();
    while ((dp=out.transferFrom(in,p,size)) > 0) {
      p+=dp;
    }
  }
  finally {
    try {
      if (out != null)       out.close();
    }
  finally {
      if (in != null)       in.close();
    }
  }
}","public static void copyFile(File src,File dst) throws IOException {
  Files.copy(src.toPath(),dst.toPath(),StandardCopyOption.REPLACE_EXISTING);
}",0.2817337461300309
16272,"public void download(){
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  File dir=getLocalDir();
  if (!dir.exists()) {
    dir.mkdir();
  }
  String[] files=getRemoteFiles();
  for (  String f : files) {
    try {
      int slashIndex=f.lastIndexOf(""String_Node_Str"");
      String fileName=f.substring(slashIndex);
      File localFile=new File(dir + ""String_Node_Str"" + fileName);
      if (!localFile.exists()) {
        URL u=new URL(f);
        downloadFile(u,localFile);
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}","public void download(){
  logger.warn(""String_Node_Str"");
  logger.warn(""String_Node_Str"");
  File dir=getLocalDir();
  if (!dir.exists()) {
    dir.mkdir();
  }
  String[] files=getRemoteFiles();
  for (  String f : files) {
    try {
      int slashIndex=f.lastIndexOf(""String_Node_Str"");
      String fileName=f.substring(slashIndex);
      File localFile=new File(dir + ""String_Node_Str"" + fileName);
      if (!localFile.exists()) {
        URL u=new URL(f);
        downloadFile(u,localFile);
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}",0.953846153846154
16273,"public static void main(String[] args){
  Dataset ds=new Dataset();
  ds.download();
  try {
    for (    File f : ds.getLocalFiles()) {
      System.out.println(f.getAbsoluteFile());
      List<Site> sites=Site.parseSites(f);
      for (      Site s : sites) {
        if (s.getUniprot().equals(""String_Node_Str"") || s.getUniprot().equals(""String_Node_Str"")) {
          System.out.println(s);
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public static void main(String[] args){
  Dataset ds=new Dataset();
  ds.download();
  try {
    for (    File f : ds.getLocalFiles()) {
      logger.info(f.getAbsolutePath());
      List<Site> sites=Site.parseSites(f);
      logger.info(""String_Node_Str"" + sites.size() + ""String_Node_Str"");
      for (      Site s : sites) {
        if (s.getUniprot().equals(""String_Node_Str"") || s.getUniprot().equals(""String_Node_Str"")) {
          logger.info(s.toString());
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.8499025341130604
16274,"public static List<Site> parseSites(File f) throws IOException {
  InputStream inStream=new FileInputStream(f);
  InputStream gzipStream=new GZIPInputStream(inStream);
  Reader decoder=new InputStreamReader(gzipStream);
  BufferedReader buf=new BufferedReader(decoder);
  String line=null;
  List<Site> data=new ArrayList<Site>();
  List<String> headerFields=null;
  int proteinIndex=-1;
  int uniprotIndex=-1;
  int modTypeIndex=-1;
  int residueIndex=-1;
  int orgIndex=-1;
  int groupIndex=-1;
  boolean inHeader=true;
  while ((line=buf.readLine()) != null) {
    if (line.startsWith(""String_Node_Str"")) {
      headerFields=parseHeaderFields(line);
      proteinIndex=headerFields.indexOf(""String_Node_Str"");
      uniprotIndex=headerFields.indexOf(""String_Node_Str"");
      modTypeIndex=headerFields.indexOf(""String_Node_Str"");
      residueIndex=headerFields.indexOf(""String_Node_Str"");
      orgIndex=headerFields.indexOf(""String_Node_Str"");
      groupIndex=headerFields.indexOf(""String_Node_Str"");
      inHeader=false;
      continue;
    }
    if (inHeader)     continue;
    if (line.trim().length() == 0)     continue;
    String[] spl=line.split(""String_Node_Str"");
    if (spl.length < 5) {
      logger.info(""String_Node_Str"" + line);
      continue;
    }
    String protein=spl[proteinIndex];
    String uniprot=spl[uniprotIndex];
    String modType=spl[modTypeIndex];
    String residue=spl[residueIndex];
    String group=spl[groupIndex];
    String organism=spl[orgIndex];
    Site s=new Site();
    s.setProtein(protein);
    s.setUniprot(uniprot);
    s.setModType(modType);
    s.setResidue(residue);
    s.setGroup(group);
    s.setOrganism(organism);
    data.add(s);
  }
  buf.close();
  return data;
}","public static List<Site> parseSites(File f) throws IOException {
  InputStream inStream=new FileInputStream(f);
  InputStream gzipStream=new GZIPInputStream(inStream);
  Reader decoder=new InputStreamReader(gzipStream);
  BufferedReader buf=new BufferedReader(decoder);
  String line=null;
  List<Site> data=new ArrayList<Site>();
  List<String> headerFields=null;
  int proteinIndex=-1;
  int uniprotIndex=-1;
  int residueIndex=-1;
  int orgIndex=-1;
  int groupIndex=-1;
  int geneIndex=-1;
  boolean inHeader=true;
  while ((line=buf.readLine()) != null) {
    if (line.startsWith(""String_Node_Str"") || line.startsWith(""String_Node_Str"")) {
      headerFields=parseHeaderFields(line);
      proteinIndex=headerFields.indexOf(""String_Node_Str"");
      uniprotIndex=headerFields.indexOf(""String_Node_Str"");
      residueIndex=headerFields.indexOf(""String_Node_Str"");
      orgIndex=headerFields.indexOf(""String_Node_Str"");
      groupIndex=headerFields.indexOf(""String_Node_Str"");
      geneIndex=headerFields.indexOf(""String_Node_Str"");
      inHeader=false;
      continue;
    }
    if (inHeader)     continue;
    if (line.trim().length() == 0)     continue;
    String[] spl=line.split(""String_Node_Str"");
    if (spl.length < 5) {
      logger.info(""String_Node_Str"" + line);
      continue;
    }
    String protein=spl[proteinIndex];
    String uniprot=spl[uniprotIndex];
    String residue=spl[residueIndex];
    String[] resSpl=residue.split(""String_Node_Str"");
    String modType=null;
    if (resSpl.length == 2) {
      modType=resSpl[1];
    }
    String group=spl[groupIndex];
    String organism=spl[orgIndex];
    String geneSymb=spl[geneIndex];
    Site s=new Site();
    s.setProtein(protein);
    s.setUniprot(uniprot);
    s.setGeneSymb(geneSymb);
    s.setModType(modType);
    s.setResidue(residue);
    s.setGroup(group);
    s.setOrganism(organism);
    data.add(s);
  }
  buf.close();
  return data;
}",0.301721781907625
16275,"/** 
 * Calculate the HBonds between different groups. see Creighton page 147 f Modified to use only the contact map
 */
private void calculateHBonds(){
  if (groups.length < 5)   return;
  Iterator<AtomContact> otu=contactSet.iterator();
  while (otu.hasNext()) {
    AtomContact ac=otu.next();
    Pair<Atom> pair=ac.getPair();
    Group g1=pair.getFirst().getGroup();
    Group g2=pair.getSecond().getGroup();
    int i=indResMap.get(g1.getResidueNumber().getChainName() + g1.getResidueNumber().getSeqNum());
    int j=indResMap.get(g2.getResidueNumber().getChainName() + g2.getResidueNumber().getSeqNum());
    checkAddHBond(i,j);
    if (j != (i + 1))     checkAddHBond(j,i);
  }
}","/** 
 * Calculate the HBonds between different groups. see Creighton page 147 f Modified to use only the contact map
 */
private void calculateHBonds(){
  if (groups.length < 5)   return;
  Iterator<AtomContact> otu=contactSet.iterator();
  while (otu.hasNext()) {
    AtomContact ac=otu.next();
    Pair<Atom> pair=ac.getPair();
    Group g1=pair.getFirst().getGroup();
    Group g2=pair.getSecond().getGroup();
    int i=indResMap.get(g1.getResidueNumber());
    int j=indResMap.get(g2.getResidueNumber());
    checkAddHBond(i,j);
    if (j != (i + 1))     checkAddHBond(j,i);
  }
}",0.8740157480314961
16276,"/** 
 * Two nonoverlapping stretches of three residues each, i-1,i,i+1 and j-1,j,j+1, form either a parallel or antiparallel bridge, depending on which of two basic patterns is matched. We assign a bridge between residues i and j if there are two H bonds characteristic of beta- structure; in particular: <p> Parallel Bridge(i,j) =: [Hbond(i-1,j) and Hbond(j,i+1)] or [Hbond(j-1,i) and Hbond(i,j+1)] <p> Antiparallel Bridge(i,j) =: [Hbond(i,j) and Hbond(j,i)] or [Hbond(i-1,j+1) and Hbond(j-1,i+1)] Optimised to use the contact set
 */
private void findBridges(){
  Iterator<AtomContact> myIter=contactSet.iterator();
  List<Pair<Integer>> outList=new ArrayList<Pair<Integer>>();
  while (myIter.hasNext()) {
    AtomContact ac=myIter.next();
    Group g1=ac.getPair().getFirst().getGroup();
    Group g2=ac.getPair().getSecond().getGroup();
    int i=indResMap.get(g1.getResidueNumber().getChainName() + g1.getResidueNumber().getSeqNum());
    int j=indResMap.get(g2.getResidueNumber().getChainName() + g2.getResidueNumber().getSeqNum());
    if (i > j) {
      int old=i;
      i=j;
      j=old;
    }
    if (j < i + 3) {
      continue;
    }
    if (i == 0) {
      continue;
    }
    if (j == 0) {
      continue;
    }
    if (i == groups.length - 1) {
      continue;
    }
    if (j == groups.length - 1) {
      continue;
    }
    Pair<Integer> thisPair=new Pair<Integer>(i,j);
    outList.add(thisPair);
  }
  Collections.sort(outList,new Comparator<Pair<Integer>>(){
    @Override public int compare(    Pair<Integer> o1,    Pair<Integer> o2){
      if (o1.getFirst() < o2.getFirst()) {
        return -1;
      }
 else       if (o1.getFirst() > o2.getFirst()) {
        return +1;
      }
 else {
        if (o1.getSecond() < o2.getSecond()) {
          return -1;
        }
 else         if (o1.getSecond() > o2.getSecond()) {
          return 1;
        }
 else {
          return 0;
        }
      }
    }
  }
);
  for (  Pair<Integer> p : outList) {
    int i=p.getFirst();
    int j=p.getSecond();
    BridgeType btype=null;
    if ((isBonded(i - 1,j) && isBonded(j,i + 1)) || (isBonded(j - 1,i) && isBonded(i,j + 1))) {
      btype=BridgeType.parallel;
    }
 else     if ((isBonded(i,j) && isBonded(j,i)) || (isBonded(i - 1,j + 1) && (isBonded(j - 1,i + 1)))) {
      btype=BridgeType.antiparallel;
    }
    if (btype != null) {
      registerBridge(i,j,btype);
    }
  }
}","/** 
 * Two nonoverlapping stretches of three residues each, i-1,i,i+1 and j-1,j,j+1, form either a parallel or antiparallel bridge, depending on which of two basic patterns is matched. We assign a bridge between residues i and j if there are two H bonds characteristic of beta- structure; in particular: <p> Parallel Bridge(i,j) =: [Hbond(i-1,j) and Hbond(j,i+1)] or [Hbond(j-1,i) and Hbond(i,j+1)] <p> Antiparallel Bridge(i,j) =: [Hbond(i,j) and Hbond(j,i)] or [Hbond(i-1,j+1) and Hbond(j-1,i+1)] Optimised to use the contact set
 */
private void findBridges(){
  Iterator<AtomContact> myIter=contactSet.iterator();
  List<Pair<Integer>> outList=new ArrayList<Pair<Integer>>();
  while (myIter.hasNext()) {
    AtomContact ac=myIter.next();
    Group g1=ac.getPair().getFirst().getGroup();
    Group g2=ac.getPair().getSecond().getGroup();
    int i=indResMap.get(g1.getResidueNumber());
    int j=indResMap.get(g2.getResidueNumber());
    if (i > j) {
      int old=i;
      i=j;
      j=old;
    }
    if (j < i + 3) {
      continue;
    }
    if (i == 0) {
      continue;
    }
    if (j == 0) {
      continue;
    }
    if (i == groups.length - 1) {
      continue;
    }
    if (j == groups.length - 1) {
      continue;
    }
    Pair<Integer> thisPair=new Pair<Integer>(i,j);
    outList.add(thisPair);
  }
  Collections.sort(outList,new Comparator<Pair<Integer>>(){
    @Override public int compare(    Pair<Integer> o1,    Pair<Integer> o2){
      if (o1.getFirst() < o2.getFirst()) {
        return -1;
      }
 else       if (o1.getFirst() > o2.getFirst()) {
        return +1;
      }
 else {
        if (o1.getSecond() < o2.getSecond()) {
          return -1;
        }
 else         if (o1.getSecond() > o2.getSecond()) {
          return 1;
        }
 else {
          return 0;
        }
      }
    }
  }
);
  for (  Pair<Integer> p : outList) {
    int i=p.getFirst();
    int j=p.getSecond();
    BridgeType btype=null;
    if ((isBonded(i - 1,j) && isBonded(j,i + 1)) || (isBonded(j - 1,i) && isBonded(i,j + 1))) {
      btype=BridgeType.parallel;
    }
 else     if ((isBonded(i,j) && isBonded(j,i)) || (isBonded(i - 1,j + 1) && (isBonded(j - 1,i + 1)))) {
      btype=BridgeType.antiparallel;
    }
    if (btype != null) {
      registerBridge(i,j,btype);
    }
  }
}",0.9658994032395568
16277,"/** 
 * Function to generate the contact sets
 */
private void initContactSet(){
  atoms=new Atom[groups.length];
  indResMap=new HashMap<String,Integer>();
  for (int i=0; i < groups.length; i++) {
    SecStrucGroup one=groups[i];
    indResMap.put(one.getResidueNumber().getChainName() + one.getResidueNumber().getSeqNum(),i);
    atoms[i]=one.getCA();
  }
  Grid grid=new Grid(CA_MIN_DIST);
  if (atoms.length == 0) {
    contactSet=new AtomContactSet(CA_MIN_DIST);
  }
 else {
    grid.addAtoms(atoms);
    contactSet=grid.getAtomContacts();
  }
}","/** 
 * Function to generate the contact sets
 */
private void initContactSet(){
  atoms=new Atom[groups.length];
  indResMap=new HashMap<>();
  for (int i=0; i < groups.length; i++) {
    SecStrucGroup one=groups[i];
    indResMap.put(one.getResidueNumber(),i);
    atoms[i]=one.getCA();
  }
  Grid grid=new Grid(CA_MIN_DIST);
  if (atoms.length == 0) {
    contactSet=new AtomContactSet(CA_MIN_DIST);
  }
 else {
    grid.addAtoms(atoms);
    contactSet=grid.getAtomContacts();
  }
}",0.9362934362934364
16278,"@Test public void testSecStrucPred() throws StructureException, IOException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  SecStrucCalc sec=new SecStrucCalc();
  for (  String name : names) {
    AtomCache cache=new AtomCache();
    Structure structure=cache.getStructure(name);
    List<SecStrucState> biojava=sec.calculate(structure,true);
    List<SecStrucState> dssp=DSSPParser.fetch(name,structure,false);
    assertEquals(""String_Node_Str"",biojava.size(),dssp.size() * structure.nrModels());
    for (int i=0; i < dssp.size(); i++) {
      assertEquals(""String_Node_Str"" + (i + 1) + ""String_Node_Str"",biojava.get(i),dssp.get(i));
    }
  }
}","@Test public void testSecStrucPred() throws StructureException, IOException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  SecStrucCalc sec=new SecStrucCalc();
  for (  String name : names) {
    AtomCache cache=new AtomCache();
    Structure structure=cache.getStructure(name);
    List<SecStrucState> biojava=sec.calculate(structure,true);
    List<SecStrucState> dssp=DSSPParser.fetch(name,structure,false);
    assertEquals(""String_Node_Str"",biojava.size(),dssp.size() * structure.nrModels());
    for (int i=0; i < dssp.size(); i++) {
      assertEquals(""String_Node_Str"" + (i + 1) + ""String_Node_Str"",biojava.get(i),dssp.get(i));
    }
  }
}",0.9881266490765171
16279,"public PDBFileParser(){
  params=new FileParsingParameters();
  allModels=new ArrayList<>();
  structure=null;
  currentModel=null;
  currentChain=null;
  currentGroup=null;
  startOfMolecule=true;
  startOfModel=true;
  pdbHeader=new PDBHeader();
  crystallographicInfo=new PDBCrystallographicInfo();
  connects=new ArrayList<Map<String,Integer>>();
  helixList=new ArrayList<Map<String,String>>();
  strandList=new ArrayList<Map<String,String>>();
  turnList=new ArrayList<Map<String,String>>();
  current_compound=null;
  dbrefs=new ArrayList<DBRef>();
  siteMap=null;
  dateFormat=new SimpleDateFormat(""String_Node_Str"",Locale.US);
  atomCount=0;
  atomOverflow=false;
  parseCAonly=false;
  loadMaxAtoms=params.getMaxAtoms();
  atomCAThreshold=params.getAtomCaThreshold();
  blankChainIdsPresent=false;
}","public PDBFileParser(){
  params=new FileParsingParameters();
  allModels=new ArrayList<>();
  structure=null;
  currentModel=null;
  currentChain=null;
  currentGroup=null;
  startOfMolecule=true;
  startOfModel=true;
  pdbHeader=new PDBHeader();
  crystallographicInfo=new PDBCrystallographicInfo();
  connects=new ArrayList<Map<String,Integer>>();
  helixList=new ArrayList<Map<String,String>>();
  strandList=new ArrayList<Map<String,String>>();
  turnList=new ArrayList<Map<String,String>>();
  current_compound=null;
  dbrefs=new ArrayList<DBRef>();
  siteMap=null;
  dateFormat=new SimpleDateFormat(""String_Node_Str"",Locale.US);
  atomCount=0;
  atomOverflow=false;
  parseCAonly=false;
  loadMaxAtoms=params.getMaxAtoms();
  atomCAThreshold=params.getAtomCaThreshold();
  linkRecords=new ArrayList<LinkRecord>();
  blankChainIdsPresent=false;
}",0.9741119807344972
16280,"/** 
 * Handler for the SITE records.  <pre> COLUMNS	DATA TYPE 		FIELD 		DEFINITION --------------------------------------------------------------------------------- 1 - 6	Record name 	""SITE "" 8 - 10 	Integer 		seqNum 		Sequence number. 12 - 14 	LString(3)		siteID 		Site name. 16 - 17 	Integer 		numRes 		Number of residues that compose the siteResidues. 19 - 21 	Residue name	resName1	Residue name for first residue that creates the siteResidues. 23 		Character 		chainID1 	Chain identifier for first residue of siteResidues. 24 - 27 	Integer 		seq1 		Residue sequence number for first residue of the siteResidues. 28 		AChar 			iCode1 		Insertion code for first residue of the siteResidues. example: 1         2         3         4         5         6         7         8 12345678901234567890123456789012345678901234567890123456789012345678901234567890 SITE     1 AC1  3 HIS A  94 HIS A   96  HIS A 119 SITE     1 AC2  5 ASN A  62 GLY A   63  HIS A  64  HOH A 328 SITE     2 AC2  5 HOH A 634 SITE     1 AC3  5 GLN A 136 GLN A  137  PRO A 138  GLU A 205 SITE     2 AC3  5 CYS A 206 SITE     1 AC4 11 HIS A  64 HIS A   94  HIS A  96  HIS A 119 SITE     2 AC4 11 LEU A 198 THR A  199  THR A 200  TRP A 209 SITE     3 AC4 11 HOH A 572 HOH A  582  HOH A 635 </pre>
 * @param line the SITE line record being currently read
 * @author Amr AL-Hossary
 * @author Jules Jacobsen
 */
private void pdb_SITE_Handler(String line){
  if (params.isHeaderOnly())   return;
  logger.debug(""String_Node_Str"" + line);
  String siteID=line.substring(11,14);
  List<ResidueNumber> siteResidues=siteToResidueMap.get(siteID);
  if (siteResidues == null || !siteToResidueMap.containsKey(siteID.trim())) {
    siteResidues=new ArrayList<ResidueNumber>();
    siteToResidueMap.put(siteID.trim(),siteResidues);
    logger.debug(String.format(""String_Node_Str"",siteID,siteResidues));
    logger.debug(""String_Node_Str"" + siteMap.size() + ""String_Node_Str"");
  }
  logger.debug(String.format(""String_Node_Str"",siteID));
  line=line.substring(18);
  String groupString=null;
  while (!(groupString=line.substring(0,10)).equals(""String_Node_Str"")) {
    logger.debug(""String_Node_Str"" + groupString + ""String_Node_Str"");
    String residueName=groupString.substring(0,3);
    Character aminoCode1=StructureTools.get1LetterCode(residueName);
    if (aminoCode1 != null) {
      if (aminoCode1.equals(StructureTools.UNKNOWN_GROUP_LABEL)) {
        aminoCode1=null;
      }
    }
    String chainId=groupString.substring(4,5);
    Integer resNum=Integer.valueOf(groupString.substring(5,9).trim());
    Character insCode=groupString.substring(9,10).charAt(0);
    logger.debug(String.format(""String_Node_Str"",siteID,residueName,resNum,insCode));
    ResidueNumber residueNumber=new ResidueNumber();
    logger.debug(""String_Node_Str"" + resNum + insCode+ ""String_Node_Str"");
    residueNumber.setChainName(chainId);
    residueNumber.setSeqNum(resNum);
    residueNumber.setInsCode(insCode);
    siteResidues.add(residueNumber);
    logger.debug(""String_Node_Str"" + residueNumber + ""String_Node_Str""+ siteID);
    line=line.substring(11);
  }
  logger.debug(""String_Node_Str"" + siteToResidueMap.keySet().size() + ""String_Node_Str"");
  for (  String key : siteToResidueMap.keySet()) {
    logger.debug(key + ""String_Node_Str"" + siteToResidueMap.get(key));
  }
}","/** 
 * Handler for the SITE records. <br> <pre> COLUMNS	DATA TYPE 		FIELD 		DEFINITION --------------------------------------------------------------------------------- 1 - 6	Record name 	""SITE "" 8 - 10 	Integer 		seqNum 		Sequence number. 12 - 14 	LString(3)		siteID 		Site name. 16 - 17 	Integer 		numRes 		Number of residues that compose the siteResidues. 19 - 21 	Residue name	resName1	Residue name for first residue that creates the siteResidues. 23 		Character 		chainID1 	Chain identifier for first residue of siteResidues. 24 - 27 	Integer 		seq1 		Residue sequence number for first residue of the siteResidues. 28 		AChar 			iCode1 		Insertion code for first residue of the siteResidues. example: 1         2         3         4         5         6         7         8 12345678901234567890123456789012345678901234567890123456789012345678901234567890 SITE     1 AC1  3 HIS A  94 HIS A   96  HIS A 119 SITE     1 AC2  5 ASN A  62 GLY A   63  HIS A  64  HOH A 328 SITE     2 AC2  5 HOH A 634 SITE     1 AC3  5 GLN A 136 GLN A  137  PRO A 138  GLU A 205 SITE     2 AC3  5 CYS A 206 SITE     1 AC4 11 HIS A  64 HIS A   94  HIS A  96  HIS A 119 SITE     2 AC4 11 LEU A 198 THR A  199  THR A 200  TRP A 209 SITE     3 AC4 11 HOH A 572 HOH A  582  HOH A 635 </pre>
 * @param line the SITE line record being currently read
 * @author Amr AL-Hossary
 * @author Jules Jacobsen
 */
private void pdb_SITE_Handler(String line){
  if (params.isHeaderOnly())   return;
  logger.debug(""String_Node_Str"" + line);
  String siteID=line.substring(11,14);
  List<ResidueNumber> siteResidues=siteToResidueMap.get(siteID);
  if (siteResidues == null || !siteToResidueMap.containsKey(siteID.trim())) {
    siteResidues=new ArrayList<ResidueNumber>();
    siteToResidueMap.put(siteID.trim(),siteResidues);
    logger.debug(String.format(""String_Node_Str"",siteID,siteResidues));
    logger.debug(""String_Node_Str"" + siteMap.size() + ""String_Node_Str"");
  }
  logger.debug(String.format(""String_Node_Str"",siteID));
  line=line.substring(18);
  String groupString=null;
  while (!(groupString=line.substring(0,10)).equals(""String_Node_Str"")) {
    logger.debug(""String_Node_Str"" + groupString + ""String_Node_Str"");
    String residueName=groupString.substring(0,3);
    Character aminoCode1=StructureTools.get1LetterCode(residueName);
    if (aminoCode1 != null) {
      if (aminoCode1.equals(StructureTools.UNKNOWN_GROUP_LABEL)) {
        aminoCode1=null;
      }
    }
    String chainId=groupString.substring(4,5);
    Integer resNum=Integer.valueOf(groupString.substring(5,9).trim());
    Character insCode=groupString.substring(9,10).charAt(0);
    logger.debug(String.format(""String_Node_Str"",siteID,residueName,resNum,insCode));
    ResidueNumber residueNumber=new ResidueNumber();
    logger.debug(""String_Node_Str"" + resNum + insCode+ ""String_Node_Str"");
    residueNumber.setChainName(chainId);
    residueNumber.setSeqNum(resNum);
    residueNumber.setInsCode(insCode);
    siteResidues.add(residueNumber);
    logger.debug(""String_Node_Str"" + residueNumber + ""String_Node_Str""+ siteID);
    line=line.substring(11);
  }
  logger.debug(""String_Node_Str"" + siteToResidueMap.keySet().size() + ""String_Node_Str"");
  for (  String key : siteToResidueMap.keySet()) {
    logger.debug(key + ""String_Node_Str"" + siteToResidueMap.get(key));
  }
}",0.9993990384615384
16281,"/** 
 * Parse a PDB file and return a datastructure implementing PDBStructure interface.
 * @param buf  a BufferedReader object
 * @return the Structure object
 * @throws IOException ...
 */
public Structure parsePDBFile(BufferedReader buf) throws IOException {
  loadMaxAtoms=params.getMaxAtoms();
  atomCAThreshold=params.getAtomCaThreshold();
  allModels=new ArrayList<>();
  structure=new StructureImpl();
  currentModel=null;
  currentChain=null;
  currentGroup=null;
  startOfMolecule=true;
  startOfModel=true;
  seqResChains=new ArrayList<Chain>();
  siteMap=new LinkedHashMap<String,Site>();
  pdbHeader=new PDBHeader();
  connects=new ArrayList<Map<String,Integer>>();
  previousContinuationField=""String_Node_Str"";
  continuationField=""String_Node_Str"";
  continuationString=""String_Node_Str"";
  current_compound=null;
  sourceLines.clear();
  compndLines.clear();
  isLastCompndLine=false;
  isLastSourceLine=false;
  prevMolId=-1;
  entities.clear();
  helixList.clear();
  strandList.clear();
  turnList.clear();
  lengthCheck=-1;
  atomCount=0;
  atomOverflow=false;
  siteToResidueMap.clear();
  blankChainIdsPresent=false;
  parseCAonly=params.isParseCAOnly();
  String line=null;
  while ((line=buf.readLine()) != null) {
    if (line.equals(""String_Node_Str"") || (line.equals(NEWLINE))) {
      continue;
    }
    if (line.startsWith(""String_Node_Str"")) {
      continue;
    }
    if (line.length() < 6 && !line.startsWith(""String_Node_Str"")) {
      logger.info(""String_Node_Str"" + line + ""String_Node_Str"");
      continue;
    }
    String recordName=null;
    if (line.length() < 6)     recordName=line.trim();
 else     recordName=line.substring(0,6).trim();
    if (recordName.equals(""String_Node_Str""))     pdb_ATOM_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_SEQRES_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_ATOM_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_MODEL_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_TER_Handler();
 else     if (recordName.equals(""String_Node_Str""))     pdb_HEADER_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_AUTHOR_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_TITLE_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     sourceLines.add(line);
 else     if (recordName.equals(""String_Node_Str""))     compndLines.add(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_JRNL_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_EXPDTA_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_CRYST1_Handler(line);
 else     if (recordName.startsWith(""String_Node_Str""))     pdb_MTRIXn_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_REMARK_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_CONECT_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_REVDAT_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_DBREF_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_SITE_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_SSBOND_Handler(line);
 else     if (params.isParseSecStruc()) {
      if (recordName.equals(""String_Node_Str""))       pdb_HELIX_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_SHEET_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_TURN_Handler(line);
    }
 else {
    }
  }
  makeCompounds(compndLines,sourceLines);
  triggerEndFileChecks();
  if (params.shouldCreateAtomBonds()) {
    formBonds();
  }
  if (params.shouldCreateAtomCharges()) {
    addCharges();
  }
  if (params.isParseSecStruc() && !params.isHeaderOnly())   setSecStruc();
  StructureTools.cleanUpAltLocs(structure);
  return structure;
}","/** 
 * Parse a PDB file and return a datastructure implementing PDBStructure interface.
 * @param buf  a BufferedReader object
 * @return the Structure object
 * @throws IOException ...
 */
public Structure parsePDBFile(BufferedReader buf) throws IOException {
  loadMaxAtoms=params.getMaxAtoms();
  atomCAThreshold=params.getAtomCaThreshold();
  allModels=new ArrayList<>();
  structure=new StructureImpl();
  currentModel=null;
  currentChain=null;
  currentGroup=null;
  startOfMolecule=true;
  startOfModel=true;
  seqResChains=new ArrayList<Chain>();
  siteMap=new LinkedHashMap<String,Site>();
  pdbHeader=new PDBHeader();
  connects=new ArrayList<Map<String,Integer>>();
  previousContinuationField=""String_Node_Str"";
  continuationField=""String_Node_Str"";
  continuationString=""String_Node_Str"";
  current_compound=null;
  sourceLines.clear();
  compndLines.clear();
  isLastCompndLine=false;
  isLastSourceLine=false;
  prevMolId=-1;
  entities.clear();
  helixList.clear();
  strandList.clear();
  turnList.clear();
  lengthCheck=-1;
  atomCount=0;
  atomOverflow=false;
  linkRecords=new ArrayList<LinkRecord>();
  siteToResidueMap.clear();
  blankChainIdsPresent=false;
  parseCAonly=params.isParseCAOnly();
  String line=null;
  while ((line=buf.readLine()) != null) {
    if (line.equals(""String_Node_Str"") || (line.equals(NEWLINE))) {
      continue;
    }
    if (line.startsWith(""String_Node_Str"")) {
      continue;
    }
    if (line.length() < 6 && !line.startsWith(""String_Node_Str"")) {
      logger.info(""String_Node_Str"" + line + ""String_Node_Str"");
      continue;
    }
    String recordName=null;
    if (line.length() < 6)     recordName=line.trim();
 else     recordName=line.substring(0,6).trim();
    try {
      if (recordName.equals(""String_Node_Str""))       pdb_ATOM_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_SEQRES_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_ATOM_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_MODEL_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_TER_Handler();
 else       if (recordName.equals(""String_Node_Str""))       pdb_HEADER_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_AUTHOR_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_TITLE_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       sourceLines.add(line);
 else       if (recordName.equals(""String_Node_Str""))       compndLines.add(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_JRNL_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_EXPDTA_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_CRYST1_Handler(line);
 else       if (recordName.startsWith(""String_Node_Str""))       pdb_MTRIXn_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_REMARK_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_CONECT_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_REVDAT_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_DBREF_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_SITE_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_SSBOND_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_LINK_Handler(line);
 else       if (params.isParseSecStruc()) {
        if (recordName.equals(""String_Node_Str""))         pdb_HELIX_Handler(line);
 else         if (recordName.equals(""String_Node_Str""))         pdb_SHEET_Handler(line);
 else         if (recordName.equals(""String_Node_Str""))         pdb_TURN_Handler(line);
      }
    }
 catch (    StringIndexOutOfBoundsException|NullPointerException ex) {
      logger.info(""String_Node_Str"" + line + ""String_Node_Str"");
    }
  }
  makeCompounds(compndLines,sourceLines);
  triggerEndFileChecks();
  if (params.shouldCreateAtomBonds()) {
    formBonds();
  }
  if (params.shouldCreateAtomCharges()) {
    addCharges();
  }
  if (params.isParseSecStruc() && !params.isHeaderOnly())   setSecStruc();
  StructureTools.cleanUpAltLocs(structure);
  return structure;
}",0.9545949872865964
16282,"/** 
 * safes repeating a few lines ... 
 */
private Integer conect_helper(String line,int start,int end){
  String sbond=line.substring(start,end).trim();
  int bond=-1;
  Integer b=null;
  if (!sbond.equals(""String_Node_Str"")) {
    bond=Integer.parseInt(sbond);
    b=new Integer(bond);
  }
  return b;
}","/** 
 * safes repeating a few lines ... 
 */
private Integer conect_helper(String line,int start,int end){
  if (line.length() < end)   return null;
  String sbond=line.substring(start,end).trim();
  int bond=-1;
  Integer b=null;
  if (!sbond.equals(""String_Node_Str"")) {
    bond=Integer.parseInt(sbond);
    b=new Integer(bond);
  }
  return b;
}",0.9359756097560976
16283,"/** 
 * Handles creation of all bonds. Looks at LINK records, SSBOND (Disulfide bonds), peptide bonds, and intra-residue bonds. <p> Note: the current implementation only looks at the first model of each structure. This may need to be fixed in the future.
 */
private void formBonds(){
  BondMaker maker=new BondMaker(structure,params);
  maker.formDisulfideBonds(ssbonds);
  maker.makeBonds();
}","/** 
 * Handles creation of all bonds. Looks at LINK records, SSBOND (Disulfide bonds), peptide bonds, and intra-residue bonds. <p> Note: the current implementation only looks at the first model of each structure. This may need to be fixed in the future.
 */
private void formBonds(){
  BondMaker maker=new BondMaker(structure,params);
  for (  LinkRecord linkRecord : linkRecords) {
    maker.formLinkRecordBond(linkRecord);
  }
  maker.formDisulfideBonds(ssbonds);
  maker.makeBonds();
}",0.8936651583710408
16284,"public CrystalBuilder(Structure structure){
  this.structure=structure;
  this.crystallographicInfo=structure.getCrystallographicInfo();
  this.numChainsAu=structure.getChains().size();
  this.numOperatorsSg=1;
  if (structure.isCrystallographic()) {
    this.isCrystallographic=true;
    if (this.crystallographicInfo.isNonStandardSg()) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
    }
 else     if (this.crystallographicInfo.getSpaceGroup() == null) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
    }
 else {
      this.numOperatorsSg=this.crystallographicInfo.getSpaceGroup().getMultiplicity();
    }
    if (this.crystallographicInfo.getCrystalCell() == null) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
    }
    if (this.crystallographicInfo.isNonStandardCoordFrameConvention()) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
    }
  }
 else {
    this.isCrystallographic=false;
  }
  this.numCells=DEF_NUM_CELLS;
}","public CrystalBuilder(Structure structure){
  this.structure=structure;
  this.crystallographicInfo=structure.getCrystallographicInfo();
  this.numChainsAu=structure.getChains().size();
  this.numOperatorsSg=1;
  if (structure.isCrystallographic()) {
    this.isCrystallographic=true;
    if (this.crystallographicInfo.isNonStandardSg()) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
    }
 else     if (this.crystallographicInfo.getSpaceGroup() == null) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
    }
 else {
      this.numOperatorsSg=this.crystallographicInfo.getSpaceGroup().getMultiplicity();
    }
    if (this.crystallographicInfo.getCrystalCell() == null) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
    }
    if (this.crystallographicInfo.isNonStandardCoordFrameConvention()) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
      this.numOperatorsSg=1;
    }
  }
 else {
    this.isCrystallographic=false;
  }
  this.numCells=DEF_NUM_CELLS;
}",0.986378581493659
16285,"public CrystalBuilder(Structure structure){
  this.structure=structure;
  this.crystallographicInfo=structure.getCrystallographicInfo();
  this.numPolyChainsAu=structure.getPolyChains().size();
  this.numOperatorsSg=1;
  if (structure.isCrystallographic()) {
    this.isCrystallographic=true;
    if (this.crystallographicInfo.isNonStandardSg()) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
    }
 else     if (this.crystallographicInfo.getSpaceGroup() == null) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
    }
 else {
      this.numOperatorsSg=this.crystallographicInfo.getSpaceGroup().getMultiplicity();
    }
    if (this.crystallographicInfo.getCrystalCell() == null) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
    }
    if (this.crystallographicInfo.isNonStandardCoordFrameConvention()) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
    }
  }
 else {
    this.isCrystallographic=false;
  }
  this.numCells=DEF_NUM_CELLS;
}","public CrystalBuilder(Structure structure){
  this.structure=structure;
  this.crystallographicInfo=structure.getCrystallographicInfo();
  this.numPolyChainsAu=structure.getPolyChains().size();
  this.numOperatorsSg=1;
  if (structure.isCrystallographic()) {
    this.isCrystallographic=true;
    if (this.crystallographicInfo.isNonStandardSg()) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
    }
 else     if (this.crystallographicInfo.getSpaceGroup() == null) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
    }
 else {
      this.numOperatorsSg=this.crystallographicInfo.getSpaceGroup().getMultiplicity();
    }
    if (this.crystallographicInfo.getCrystalCell() == null) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
    }
    if (this.crystallographicInfo.isNonStandardCoordFrameConvention()) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
      this.numOperatorsSg=1;
    }
  }
 else {
    this.isCrystallographic=false;
  }
  this.numCells=DEF_NUM_CELLS;
}",0.9864801864801864
16286,"@Test public void testSuperpositionQuat(){
  SuperPosition sup=new SuperPositionQuat(false);
  Point3d[] points1=clonePoints(chain1);
  Point3d[] points2=clonePoints(chain2);
  double rmsd=sup.getRmsd(points1,points2);
  assertEquals(0.0,rmsd,0.0001);
}","@Test public void testSuperpositionQuat(){
  SuperPosition sup=new SuperPositionQuat(false);
  double rmsd=sup.getRmsd(chain1,chain2);
  assertEquals(0.0,rmsd,0.0001);
}",0.7725118483412322
16287,"@Test public void testSuperpositionQCP(){
  SuperPosition sup=new SuperPositionQCP(false);
  Point3d[] points1=clonePoints(chain1);
  Point3d[] points2=clonePoints(chain2);
  double rmsd=sup.getRmsd(points1,points2);
  assertEquals(0.0,rmsd,0.0001);
}","@Test public void testSuperpositionQCP(){
  SuperPosition sup=new SuperPositionQCP(false);
  double rmsd=sup.getRmsd(chain1,chain2);
  assertEquals(0.0,rmsd,0.0001);
}",0.7703349282296651
16288,"@Test public void testSuperpositionSVD(){
  SuperPosition sup=new SuperPositionSVD(false);
  Point3d[] points1=clonePoints(chain1);
  Point3d[] points2=clonePoints(chain2);
  double rmsd=sup.getRmsd(points1,points2);
  assertEquals(0.0,rmsd,0.0001);
}","@Test public void testSuperpositionSVD(){
  SuperPosition sup=new SuperPositionSVD(false);
  double rmsd=sup.getRmsd(chain1,chain2);
  assertEquals(0.0,rmsd,0.0001);
}",0.7703349282296651
16289,"@Override public Matrix4d superpose(Point3d[] fixed,Point3d[] moved){
  checkInput(fixed,moved);
  Point3d cena=CalcPoint.centroid(fixed);
  Point3d cenb=CalcPoint.centroid(moved);
  double[][] centAcoords=new double[][]{{cena.x,cena.y,cena.z}};
  Matrix centroidA=new Matrix(centAcoords);
  double[][] centBcoords=new double[][]{{cenb.x,cenb.x,cenb.x}};
  Matrix centroidB=new Matrix(centBcoords);
  cena.negate();
  cenb.negate();
  Point3d[] ats1=CalcPoint.clonePoint3dArray(fixed);
  CalcPoint.translate(cena,ats1);
  Point3d[] ats2=CalcPoint.clonePoint3dArray(moved);
  CalcPoint.translate(cenb,ats2);
  double[][] coordSet1=new double[ats1.length][3];
  double[][] coordSet2=new double[ats2.length][3];
  for (int i=0; i < ats1.length; i++) {
    coordSet1[i]=new double[3];
    ats1[i].get(coordSet1[i]);
    coordSet2[i]=new double[3];
    ats2[i].get(coordSet2[i]);
  }
  Matrix a=new Matrix(coordSet1);
  Matrix b=new Matrix(coordSet2);
  Matrix b_trans=b.transpose();
  Matrix corr=b_trans.times(a);
  SingularValueDecomposition svd=corr.svd();
  Matrix u=svd.getU();
  Matrix vt=svd.getV();
  Matrix vt_orig=(Matrix)vt.clone();
  Matrix u_transp=u.transpose();
  Matrix rot_nottrans=vt.times(u_transp);
  Matrix rot=rot_nottrans.transpose();
  double det=rot.det();
  if (det < 0) {
    vt=vt_orig.transpose();
    vt.set(2,0,(0 - vt.get(2,0)));
    vt.set(2,1,(0 - vt.get(2,1)));
    vt.set(2,2,(0 - vt.get(2,2)));
    Matrix nv_transp=vt.transpose();
    rot_nottrans=nv_transp.times(u_transp);
    rot=rot_nottrans.transpose();
  }
  Matrix cb_tmp=centroidB.times(rot);
  Matrix tran=centroidA.minus(cb_tmp);
  return Matrices.getTransformation(rot,tran);
}","@Override public Matrix4d superpose(Point3d[] fixed,Point3d[] moved){
  checkInput(fixed,moved);
  Point3d cena=CalcPoint.centroid(fixed);
  Point3d cenb=CalcPoint.centroid(moved);
  double[][] centAcoords=new double[][]{{cena.x,cena.y,cena.z}};
  Matrix centroidA=new Matrix(centAcoords);
  double[][] centBcoords=new double[][]{{cenb.x,cenb.y,cenb.z}};
  Matrix centroidB=new Matrix(centBcoords);
  cena.negate();
  cenb.negate();
  Point3d[] ats1=CalcPoint.clonePoint3dArray(fixed);
  CalcPoint.translate(cena,ats1);
  Point3d[] ats2=CalcPoint.clonePoint3dArray(moved);
  CalcPoint.translate(cenb,ats2);
  double[][] coordSet1=new double[ats1.length][3];
  double[][] coordSet2=new double[ats2.length][3];
  for (int i=0; i < ats1.length; i++) {
    coordSet1[i]=new double[3];
    ats1[i].get(coordSet1[i]);
    coordSet2[i]=new double[3];
    ats2[i].get(coordSet2[i]);
  }
  Matrix a=new Matrix(coordSet1);
  Matrix b=new Matrix(coordSet2);
  Matrix b_trans=b.transpose();
  Matrix corr=b_trans.times(a);
  SingularValueDecomposition svd=corr.svd();
  Matrix u=svd.getU();
  Matrix vt=svd.getV();
  Matrix vt_orig=(Matrix)vt.clone();
  Matrix u_transp=u.transpose();
  Matrix rot_nottrans=vt.times(u_transp);
  Matrix rot=rot_nottrans.transpose();
  double det=rot.det();
  if (det < 0) {
    vt=vt_orig.transpose();
    vt.set(2,0,(0 - vt.get(2,0)));
    vt.set(2,1,(0 - vt.get(2,1)));
    vt.set(2,2,(0 - vt.get(2,2)));
    Matrix nv_transp=vt.transpose();
    rot_nottrans=nv_transp.times(u_transp);
    rot=rot_nottrans.transpose();
  }
  Matrix cb_tmp=centroidB.times(rot);
  Matrix tran=centroidA.minus(cb_tmp);
  return Matrices.getTransformation(rot,tran);
}",0.9952153110047848
16290,"/** 
 * Test method to obtain the transformation matrix from superpositions.
 */
@Test public void testSuperposition(){
  for (int c=0; c < cloud1.size(); c++) {
    SuperPosition svd=new SuperPositionSVD(false);
    long svdStart=System.nanoTime();
    Matrix4d svdTransform=svd.superpose(cloud1.get(c),cloud2.get(c));
    long svdTime=(System.nanoTime() - svdStart) / 1000;
    SuperPosition quat=new SuperPositionQuat(false);
    long quatStart=System.nanoTime();
    Matrix4d quatTransform=quat.superpose(cloud1.get(c),cloud2.get(c));
    long quatTime=(System.nanoTime() - quatStart) / 1000;
    SuperPosition qcp=new SuperPositionQCP(false);
    long qcpStart=System.nanoTime();
    Matrix4d qcpTransform=qcp.superpose(cloud1.get(c),cloud2.get(c));
    long qcpTime=(System.nanoTime() - qcpStart) / 1000;
    logger.error(String.format(""String_Node_Str"" + ""String_Node_Str"",cloud1.get(c).length,svdTime,quatTime,qcpTime));
    assertTrue(transform.epsilonEquals(svdTransform,0.01));
    assertTrue(transform.epsilonEquals(quatTransform,0.01));
    assertTrue(transform.epsilonEquals(qcpTransform,0.01));
  }
}","/** 
 * Test method to obtain the transformation matrix from superpositions.
 */
@Test public void testSuperposition(){
  for (int c=0; c < cloud1.size(); c++) {
    SuperPosition svd=new SuperPositionSVD(false);
    long svdStart=System.nanoTime();
    Matrix4d svdTransform=svd.superpose(cloud1.get(c),cloud2.get(c));
    long svdTime=(System.nanoTime() - svdStart) / 1000;
    SuperPosition quat=new SuperPositionQuat(false);
    long quatStart=System.nanoTime();
    Matrix4d quatTransform=quat.superpose(cloud1.get(c),cloud2.get(c));
    long quatTime=(System.nanoTime() - quatStart) / 1000;
    SuperPosition qcp=new SuperPositionQCP(false);
    long qcpStart=System.nanoTime();
    Matrix4d qcpTransform=qcp.superpose(cloud1.get(c),cloud2.get(c));
    long qcpTime=(System.nanoTime() - qcpStart) / 1000;
    logger.error(String.format(""String_Node_Str"" + ""String_Node_Str"",cloud1.get(c).length,svdTime,quatTime,qcpTime));
    assertTrue(transform.epsilonEquals(svdTransform,0.05));
    assertTrue(transform.epsilonEquals(quatTransform,0.05));
    assertTrue(transform.epsilonEquals(qcpTransform,0.05));
  }
}",0.9973094170403588
16291,"/** 
 * Use the   {@link SuperPosition#superposeAndTransform(Point3d[],Point3d[])}method of the default static SuperPosition algorithm contained in this Class.
 */
public static Matrix4d superposeAndTransform(Point3d[] fixed,Point3d[] moved){
  superposer.setCentered(false);
  return superposer.superpose(fixed,moved);
}","/** 
 * Use the   {@link SuperPosition#superposeAndTransform(Point3d[],Point3d[])}method of the default static SuperPosition algorithm contained in this Class.
 */
public static Matrix4d superposeAndTransform(Point3d[] fixed,Point3d[] moved){
  superposer.setCentered(false);
  return superposer.superposeAndTransform(fixed,moved);
}",0.981651376146789
16292,"/** 
 * Use the   {@link SuperPosition#superposeAndTransform(Point3d[],Point3d[])}method of the default static SuperPosition algorithm contained in this Class, assuming that the point arrays are centered at the origin.
 */
public static Matrix4d superposeAndTransformAtOrigin(Point3d[] fixed,Point3d[] moved){
  superposer.setCentered(true);
  return superposer.superpose(fixed,moved);
}","/** 
 * Use the   {@link SuperPosition#superposeAndTransform(Point3d[],Point3d[])}method of the default static SuperPosition algorithm contained in this Class, assuming that the point arrays are centered at the origin.
 */
public static Matrix4d superposeAndTransformAtOrigin(Point3d[] fixed,Point3d[] moved){
  superposer.setCentered(true);
  return superposer.superposeAndTransform(fixed,moved);
}",0.9847328244274808
16293,"/** 
 * Hemoglobin has both symmetry and pseudosymmetry: 4HHB
 * @throws StructureException
 * @throws IOException
 */
@Test public void testPseudosymmetry() throws IOException, StructureException {
  Structure pdb=StructureIO.getStructure(""String_Node_Str"");
  SubunitClustererParameters clusterParams=new SubunitClustererParameters();
  clusterParams.setClustererMethod(SubunitClustererMethod.SEQUENCE);
  QuatSymmetryParameters symmParams=new QuatSymmetryParameters();
  QuatSymmetryResults symmetry=QuatSymmetryDetector.calcGlobalSymmetry(pdb,symmParams,clusterParams);
  assertEquals(""String_Node_Str"",symmetry.getSymmetry());
  assertEquals(""String_Node_Str"",symmetry.getStoichiometry());
  clusterParams.setClustererMethod(SubunitClustererMethod.STRUCTURE);
  symmetry=QuatSymmetryDetector.calcGlobalSymmetry(pdb,symmParams,clusterParams);
  assertEquals(""String_Node_Str"",symmetry.getSymmetry());
  assertEquals(""String_Node_Str"",symmetry.getStoichiometry());
}","/** 
 * Hemoglobin has both symmetry and pseudosymmetry: 4HHB TODO pseudosymmetry in hemoglobin fails
 * @throws StructureException
 * @throws IOException
 */
@Test public void testPseudosymmetry() throws IOException, StructureException {
  Structure pdb=StructureIO.getStructure(""String_Node_Str"");
  SubunitClustererParameters clusterParams=new SubunitClustererParameters();
  clusterParams.setClustererMethod(SubunitClustererMethod.SEQUENCE);
  QuatSymmetryParameters symmParams=new QuatSymmetryParameters();
  QuatSymmetryResults symmetry=QuatSymmetryDetector.calcGlobalSymmetry(pdb,symmParams,clusterParams);
  assertEquals(""String_Node_Str"",symmetry.getSymmetry());
  assertEquals(""String_Node_Str"",symmetry.getStoichiometry());
  clusterParams.setClustererMethod(SubunitClustererMethod.STRUCTURE);
  symmetry=QuatSymmetryDetector.calcGlobalSymmetry(pdb,symmParams,clusterParams);
  assertEquals(""String_Node_Str"",symmetry.getSymmetry());
  assertEquals(""String_Node_Str"",symmetry.getStoichiometry());
}",0.9797775530839232
16294,"private void solve(){
  initialize();
  Vector3d trans=new Vector3d(subunits.getCentroid());
  trans.negate();
  List<Point3d[]> traces=subunits.getTraces();
  Point3d[] x=CalcPoint.clonePoint3dArray(traces.get(0));
  CalcPoint.translate(new Point3d(trans),x);
  Point3d[] y=CalcPoint.clonePoint3dArray(traces.get(1));
  CalcPoint.translate(new Point3d(trans),y);
  Matrix4d transformation=SuperPositions.superposeAndTransformAtOrigin(y,x);
  AxisAngle4d axisAngle=new AxisAngle4d();
  axisAngle.set(transformation);
  Vector3d axis=new Vector3d(axisAngle.x,axisAngle.y,axisAngle.z);
  if (axis.lengthSquared() < 1.0E-6) {
    axisAngle.x=0;
    axisAngle.y=0;
    axisAngle.z=1;
    axisAngle.angle=0;
  }
 else {
    axis.normalize();
    axisAngle.x=axis.x;
    axisAngle.y=axis.y;
    axisAngle.z=axis.z;
  }
  double angleThresholdRadians=Math.toRadians(parameters.getAngleThreshold());
  double deltaAngle=Math.abs(Math.PI - axisAngle.angle);
  if (deltaAngle > angleThresholdRadians) {
    rotations.setC1(subunits.getSubunitCount());
    return;
  }
  addEOperation();
  int fold=2;
  combineWithTranslation(transformation);
  List<Integer> permutation=Arrays.asList(1,0);
  QuatSymmetryScores scores=QuatSuperpositionScorer.calcScores(subunits,transformation,permutation);
  scores.setRmsdCenters(0.0);
  if (scores.getRmsd() > parameters.getRmsdThreshold() || deltaAngle > angleThresholdRadians) {
    rotations.setC1(subunits.getSubunitCount());
    return;
  }
  Rotation symmetryOperation=createSymmetryOperation(permutation,transformation,axisAngle,fold,scores);
  rotations.addRotation(symmetryOperation);
}","private void solve(){
  initialize();
  Vector3d trans=new Vector3d(subunits.getCentroid());
  trans.negate();
  List<Point3d[]> traces=subunits.getTraces();
  Point3d[] x=CalcPoint.clonePoint3dArray(traces.get(0));
  CalcPoint.translate(new Point3d(trans),x);
  Point3d[] y=CalcPoint.clonePoint3dArray(traces.get(1));
  CalcPoint.translate(new Point3d(trans),y);
  Quat4d quat=UnitQuaternions.relativeOrientation(x,y);
  AxisAngle4d axisAngle=new AxisAngle4d();
  Matrix4d transformation=new Matrix4d();
  transformation.set(quat);
  axisAngle.set(quat);
  Vector3d axis=new Vector3d(axisAngle.x,axisAngle.y,axisAngle.z);
  if (axis.lengthSquared() < 1.0E-6) {
    axisAngle.x=0;
    axisAngle.y=0;
    axisAngle.z=1;
    axisAngle.angle=0;
  }
 else {
    axis.normalize();
    axisAngle.x=axis.x;
    axisAngle.y=axis.y;
    axisAngle.z=axis.z;
  }
  CalcPoint.transform(transformation,y);
  double angleThresholdRadians=Math.toRadians(parameters.getAngleThreshold());
  double deltaAngle=Math.abs(Math.PI - axisAngle.angle);
  if (deltaAngle > angleThresholdRadians) {
    rotations.setC1(subunits.getSubunitCount());
    return;
  }
  addEOperation();
  int fold=2;
  combineWithTranslation(transformation);
  List<Integer> permutation=Arrays.asList(1,0);
  QuatSymmetryScores scores=QuatSuperpositionScorer.calcScores(subunits,transformation,permutation);
  scores.setRmsdCenters(0.0);
  if (scores.getRmsd() > parameters.getRmsdThreshold() || deltaAngle > angleThresholdRadians) {
    rotations.setC1(subunits.getSubunitCount());
    return;
  }
  Rotation symmetryOperation=createSymmetryOperation(permutation,transformation,axisAngle,fold,scores);
  rotations.addRotation(symmetryOperation);
}",0.9061371841155236
16295,"private boolean evaluatePermutation(List<Integer> permutation){
  for (int j=0, n=subunits.getSubunitCount(); j < n; j++) {
    transformedCoords[j].set(originalCoords[permutation.get(j)]);
  }
  int fold=PermutationGroup.getOrder(permutation);
  Matrix4d transformation=SuperPositions.superposeAndTransformAtOrigin(originalCoords,transformedCoords);
  AxisAngle4d axisAngle=new AxisAngle4d();
  axisAngle.set(transformation);
  Vector3d axis=new Vector3d(axisAngle.x,axisAngle.y,axisAngle.z);
  if (axis.lengthSquared() < 1.0E-6) {
    axisAngle.x=0;
    axisAngle.y=0;
    axisAngle.z=1;
    axisAngle.angle=0;
  }
 else {
    axis.normalize();
    axisAngle.x=axis.x;
    axisAngle.y=axis.y;
    axisAngle.z=axis.z;
  }
  double subunitRmsd=CalcPoint.rmsd(transformedCoords,originalCoords);
  if (subunitRmsd < parameters.getRmsdThreshold()) {
    combineWithTranslation(transformation);
    QuatSymmetryScores scores=QuatSuperpositionScorer.calcScores(subunits,transformation,permutation);
    if (scores.getRmsd() < 0.0 || scores.getRmsd() > parameters.getRmsdThreshold()) {
      return false;
    }
    scores.setRmsdCenters(subunitRmsd);
    Rotation symmetryOperation=createSymmetryOperation(permutation,transformation,axisAngle,fold,scores);
    rotations.addRotation(symmetryOperation);
    return true;
  }
  return false;
}","private boolean evaluatePermutation(List<Integer> permutation){
  for (int j=0, n=subunits.getSubunitCount(); j < n; j++) {
    transformedCoords[j].set(originalCoords[permutation.get(j)]);
  }
  int fold=PermutationGroup.getOrder(permutation);
  Quat4d quat=UnitQuaternions.relativeOrientation(originalCoords,transformedCoords);
  AxisAngle4d axisAngle=new AxisAngle4d();
  Matrix4d transformation=new Matrix4d();
  transformation.set(quat);
  axisAngle.set(quat);
  Vector3d axis=new Vector3d(axisAngle.x,axisAngle.y,axisAngle.z);
  if (axis.lengthSquared() < 1.0E-6) {
    axisAngle.x=0;
    axisAngle.y=0;
    axisAngle.z=1;
    axisAngle.angle=0;
  }
 else {
    axis.normalize();
    axisAngle.x=axis.x;
    axisAngle.y=axis.y;
    axisAngle.z=axis.z;
  }
  CalcPoint.transform(transformation,transformedCoords);
  double subunitRmsd=CalcPoint.rmsd(transformedCoords,originalCoords);
  if (subunitRmsd < parameters.getRmsdThreshold()) {
    combineWithTranslation(transformation);
    QuatSymmetryScores scores=QuatSuperpositionScorer.calcScores(subunits,transformation,permutation);
    if (scores.getRmsd() < 0.0 || scores.getRmsd() > parameters.getRmsdThreshold()) {
      return false;
    }
    scores.setRmsdCenters(subunitRmsd);
    Rotation symmetryOperation=createSymmetryOperation(permutation,transformation,axisAngle,fold,scores);
    rotations.addRotation(symmetryOperation);
    return true;
  }
  return false;
}",0.8562138728323699
16296,"/** 
 * Adds translational component to rotation matrix
 * @param rotTrans
 * @param rotation
 * @return
 */
private void combineWithTranslation(Matrix4d rotation){
  rotation.setTranslation(centroid);
  rotation.mul(rotation,centroidInverse);
}","/** 
 * Adds translational component to rotation matrix
 * @param rotation
 * @return
 */
private void combineWithTranslation(Matrix4d rotation){
  rotation.setTranslation(centroid);
  rotation.mul(rotation,centroidInverse);
}",0.9596602972399152
16297,"private boolean evaluatePermutation(List<Integer> permutation){
  for (int j=0, n=subunits.getSubunitCount(); j < n; j++) {
    transformedCoords[j].set(originalCoords[permutation.get(j)]);
  }
  int fold=PermutationGroup.getOrder(permutation);
  Matrix4d transformation=SuperPositions.superposeAndTransformAtOrigin(originalCoords,transformedCoords);
  AxisAngle4d axisAngle=new AxisAngle4d();
  axisAngle.set(transformation);
  Vector3d axis=new Vector3d(axisAngle.x,axisAngle.y,axisAngle.z);
  if (axis.lengthSquared() < 1.0E-6) {
    axisAngle.x=0;
    axisAngle.y=0;
    axisAngle.z=1;
    axisAngle.angle=0;
  }
 else {
    axis.normalize();
    axisAngle.x=axis.x;
    axisAngle.y=axis.y;
    axisAngle.z=axis.z;
  }
  double subunitRmsd=CalcPoint.rmsd(transformedCoords,originalCoords);
  if (subunitRmsd < parameters.getRmsdThreshold()) {
    combineWithTranslation(transformation);
    QuatSymmetryScores scores=QuatSuperpositionScorer.calcScores(subunits,transformation,permutation);
    if (scores.getRmsd() < 0.0 || scores.getRmsd() > parameters.getRmsdThreshold()) {
      return false;
    }
    scores.setRmsdCenters(subunitRmsd);
    Rotation symmetryOperation=createSymmetryOperation(permutation,transformation,axisAngle,fold,scores);
    rotations.addRotation(symmetryOperation);
    return true;
  }
  return false;
}","private boolean evaluatePermutation(List<Integer> permutation){
  for (int j=0, n=subunits.getSubunitCount(); j < n; j++) {
    transformedCoords[j].set(originalCoords[permutation.get(j)]);
  }
  int fold=PermutationGroup.getOrder(permutation);
  Quat4d quat=UnitQuaternions.relativeOrientation(originalCoords,transformedCoords);
  AxisAngle4d axisAngle=new AxisAngle4d();
  Matrix4d transformation=new Matrix4d();
  transformation.set(quat);
  axisAngle.set(quat);
  Vector3d axis=new Vector3d(axisAngle.x,axisAngle.y,axisAngle.z);
  if (axis.lengthSquared() < 1.0E-6) {
    axisAngle.x=0;
    axisAngle.y=0;
    axisAngle.z=1;
    axisAngle.angle=0;
  }
 else {
    axis.normalize();
    axisAngle.x=axis.x;
    axisAngle.y=axis.y;
    axisAngle.z=axis.z;
  }
  CalcPoint.transform(transformation,transformedCoords);
  double subunitRmsd=CalcPoint.rmsd(transformedCoords,originalCoords);
  if (subunitRmsd < parameters.getRmsdThreshold()) {
    combineWithTranslation(transformation);
    QuatSymmetryScores scores=QuatSuperpositionScorer.calcScores(subunits,transformation,permutation);
    if (scores.getRmsd() < 0.0 || scores.getRmsd() > parameters.getRmsdThreshold()) {
      return false;
    }
    scores.setRmsdCenters(subunitRmsd);
    Rotation symmetryOperation=createSymmetryOperation(permutation,transformation,axisAngle,fold,scores);
    rotations.addRotation(symmetryOperation);
    return true;
  }
  return false;
}",0.8562138728323699
16298,"@Test public void testMutation() throws Exception {
  Group g1=(Group)structure.getChainByIndex(0).getAtomGroup(21).clone();
  assertTrue(g1 != null);
  Group g2=(Group)structure.getChainByIndex(0).getAtomGroup(53).clone();
  assertTrue(g2 != null);
  assertEquals(""String_Node_Str"",""String_Node_Str"",g1.getPDBName());
  assertEquals(""String_Node_Str"",""String_Node_Str"",g1.getResidueNumber().toString());
  assertEquals(""String_Node_Str"",""String_Node_Str"",g2.getPDBName());
  assertEquals(""String_Node_Str"",""String_Node_Str"",g2.getResidueNumber().toString());
  Atom[] atoms1=new Atom[3];
  Atom[] atoms2=new Atom[3];
  atoms1[0]=g1.getAtom(""String_Node_Str"");
  atoms1[1]=g1.getAtom(""String_Node_Str"");
  atoms1[2]=g1.getAtom(""String_Node_Str"");
  atoms2[0]=g2.getAtom(""String_Node_Str"");
  atoms2[1]=g2.getAtom(""String_Node_Str"");
  atoms2[2]=g2.getAtom(""String_Node_Str"");
  SuperPositionSVD svds=new SuperPositionSVD(atoms1,atoms2);
  Matrix rotMatrix=svds.getRotation();
  Atom tran=svds.getTranslation();
  Group newGroup=(Group)g2.clone();
  Calc.rotate(newGroup,rotMatrix);
  Calc.shift(newGroup,tran);
  Atom ca1=g1.getAtom(""String_Node_Str"");
  Atom oldca2=g2.getAtom(""String_Node_Str"");
  Atom newca2=newGroup.getAtom(""String_Node_Str"");
  Element e1=ca1.getElement();
  assertEquals(Element.C,e1);
  double olddistance=Calc.getDistance(ca1,oldca2);
  assertTrue(olddistance > 10);
  double newdistance=Calc.getDistance(ca1,newca2);
  assertTrue(newdistance < 0.1);
}","@Test public void testMutation() throws Exception {
  Group g1=(Group)structure.getChainByIndex(0).getAtomGroup(21).clone();
  assertTrue(g1 != null);
  Group g2=(Group)structure.getChainByIndex(0).getAtomGroup(53).clone();
  assertTrue(g2 != null);
  assertEquals(""String_Node_Str"",""String_Node_Str"",g1.getPDBName());
  assertEquals(""String_Node_Str"",""String_Node_Str"",g1.getResidueNumber().toString());
  assertEquals(""String_Node_Str"",""String_Node_Str"",g2.getPDBName());
  assertEquals(""String_Node_Str"",""String_Node_Str"",g2.getResidueNumber().toString());
  Atom[] atoms1=new Atom[3];
  Atom[] atoms2=new Atom[3];
  atoms1[0]=g1.getAtom(""String_Node_Str"");
  atoms1[1]=g1.getAtom(""String_Node_Str"");
  atoms1[2]=g1.getAtom(""String_Node_Str"");
  atoms2[0]=g2.getAtom(""String_Node_Str"");
  atoms2[1]=g2.getAtom(""String_Node_Str"");
  atoms2[2]=g2.getAtom(""String_Node_Str"");
  Matrix4d transform=SuperPositions.superpose(Calc.atomsToPoints(atoms1),Calc.atomsToPoints(atoms2));
  Group newGroup=(Group)g2.clone();
  Calc.transform(newGroup,transform);
  Atom ca1=g1.getAtom(""String_Node_Str"");
  Atom oldca2=g2.getAtom(""String_Node_Str"");
  Atom newca2=newGroup.getAtom(""String_Node_Str"");
  Element e1=ca1.getElement();
  assertEquals(Element.C,e1);
  double olddistance=Calc.getDistance(ca1,oldca2);
  assertTrue(olddistance > 10);
  double newdistance=Calc.getDistance(ca1,newca2);
  assertTrue(newdistance < 0.1);
}",0.8408698653779773
16299,"/** 
 * get the RMSD between the aligned positions
 * @param afpChain
 * @param ca1
 * @param ca2
 * @return
 */
private double getRMSD(AFPChain afpChain,Atom[] ca1,Atom[] ca2) throws StructureException {
  Atom[] ca2clone=StructureTools.cloneAtomArray(ca2);
  rotateAtoms2(afpChain,ca2clone);
  Atom[] catmp1=AFPAlignmentDisplay.getAlignedAtoms1(afpChain,ca1);
  Atom[] catmp2=AFPAlignmentDisplay.getAlignedAtoms2(afpChain,ca2clone);
  assertTrue(catmp1.length == catmp2.length);
  assertTrue(catmp1.length == afpChain.getNrEQR());
  return SuperPositionSVD.getRMS(catmp1,catmp2);
}","/** 
 * get the RMSD between the aligned positions
 * @param afpChain
 * @param ca1
 * @param ca2
 * @return
 */
private double getRMSD(AFPChain afpChain,Atom[] ca1,Atom[] ca2) throws StructureException {
  Atom[] ca2clone=StructureTools.cloneAtomArray(ca2);
  rotateAtoms2(afpChain,ca2clone);
  Atom[] catmp1=AFPAlignmentDisplay.getAlignedAtoms1(afpChain,ca1);
  Atom[] catmp2=AFPAlignmentDisplay.getAlignedAtoms2(afpChain,ca2clone);
  assertTrue(catmp1.length == catmp2.length);
  assertTrue(catmp1.length == afpChain.getNrEQR());
  return Calc.rmsd(catmp1,catmp2);
}",0.9722222222222222
16300,"/** 
 * get the RMSD between the aligned positions
 * @param afpChain
 * @param ca1
 * @param ca2
 * @return
 */
private double getRMSD(AFPChain afpChain,Atom[] ca1,Atom[] ca2) throws StructureException {
  Atom[] ca2clone=StructureTools.cloneAtomArray(ca2);
  rotateAtoms2(afpChain,ca2clone);
  Atom[] catmp1=AFPAlignmentDisplay.getAlignedAtoms1(afpChain,ca1);
  Atom[] catmp2=AFPAlignmentDisplay.getAlignedAtoms2(afpChain,ca2clone);
  assertTrue(catmp1.length == catmp2.length);
  assertTrue(catmp1.length == afpChain.getNrEQR());
  return SuperPositionSVD.getRMS(catmp1,catmp2);
}","/** 
 * get the RMSD between the aligned positions
 * @param afpChain
 * @param ca1
 * @param ca2
 * @return
 */
private double getRMSD(AFPChain afpChain,Atom[] ca1,Atom[] ca2) throws StructureException {
  Atom[] ca2clone=StructureTools.cloneAtomArray(ca2);
  rotateAtoms2(afpChain,ca2clone);
  Atom[] catmp1=AFPAlignmentDisplay.getAlignedAtoms1(afpChain,ca1);
  Atom[] catmp2=AFPAlignmentDisplay.getAlignedAtoms2(afpChain,ca2clone);
  assertTrue(catmp1.length == catmp2.length);
  assertTrue(catmp1.length == afpChain.getNrEQR());
  return Calc.rmsd(catmp1,catmp2);
}",0.9722222222222222
16301,"private void compareBlock(int blockNr,AFPChain afpChain,AFPChain newChain,Atom[] ca1,Atom[] ca2) throws StructureException {
  Atom[] ca1Copy=StructureTools.cloneAtomArray(ca1);
  Atom[] ca2Copy=StructureTools.cloneAtomArray(ca2);
  Atom[] ca2Copy2=StructureTools.cloneAtomArray(ca2);
  int[][][] blocks2=newChain.getOptAln();
  Matrix[] maxs2=newChain.getBlockRotationMatrix();
  Atom[] shifts2=newChain.getBlockShiftVector();
  int[] optLen=afpChain.getOptLen();
  List<Atom> eqrPos1=new ArrayList<Atom>();
  List<Atom> eqrPos2=new ArrayList<Atom>();
  List<Atom> eqrPos2copy=new ArrayList<Atom>();
  for (int z=0; z < blocks2[blockNr][0].length && z < optLen[blockNr]; z++) {
    int pos1=blocks2[blockNr][0][z];
    int pos2=blocks2[blockNr][1][z];
    Atom c1=ca1Copy[pos1];
    Atom c2=ca2Copy[pos2];
    Atom c3=ca2Copy2[pos2];
    eqrPos1.add(c1);
    eqrPos2.add(c2);
    eqrPos2copy.add(c3);
  }
  assertTrue(""String_Node_Str"" + blockNr + ""String_Node_Str""+ afpChain.getOptLen()[blockNr]+ ""String_Node_Str""+ eqrPos2.size(),eqrPos2.size() == afpChain.getOptLen()[blockNr]);
  Atom[] blockSet1=eqrPos1.toArray(new Atom[eqrPos1.size()]);
  Atom[] blockSet2=eqrPos2.toArray(new Atom[eqrPos2.size()]);
  Atom[] blockSet2copy=eqrPos2copy.toArray(new Atom[eqrPos2copy.size()]);
  for (  Atom a : blockSet2) {
    for (int i=0; i <= blockNr; i++) {
      Matrix max=maxs2[i];
      Atom shift=shifts2[i];
      Calc.rotate(a,max);
      Calc.shift(a,shift);
    }
  }
  double rmsdFile=SuperPositionSVD.getRMS(blockSet1,blockSet2);
  SuperPositionSVD svd=new SuperPositionSVD(blockSet1,blockSet2copy);
  Matrix m=svd.getRotation();
  Atom s=svd.getTranslation();
  Matrix max=maxs2[blockNr];
  Atom shift=shifts2[blockNr];
  compareMatrices(max,m);
  if (blockNr == 0) {
    compareVectors(shift,s);
  }
 else {
    System.err.println(""String_Node_Str"");
  }
  for (  Atom a : ca2Copy2) {
    Calc.rotate(a,m);
    Calc.shift(a,s);
  }
  double rmsd3=SuperPositionSVD.getRMS(blockSet1,blockSet2copy);
  assertTrue(""String_Node_Str"" + blockNr + ""String_Node_Str""+ rmsd3+ ""String_Node_Str""+ rmsdFile,compareRmsd(rmsd3,rmsdFile));
}","private void compareBlock(int blockNr,AFPChain afpChain,AFPChain newChain,Atom[] ca1,Atom[] ca2) throws StructureException {
  Atom[] ca1Copy=StructureTools.cloneAtomArray(ca1);
  Atom[] ca2Copy=StructureTools.cloneAtomArray(ca2);
  Atom[] ca2Copy2=StructureTools.cloneAtomArray(ca2);
  int[][][] blocks2=newChain.getOptAln();
  Matrix[] maxs2=newChain.getBlockRotationMatrix();
  Atom[] shifts2=newChain.getBlockShiftVector();
  int[] optLen=afpChain.getOptLen();
  List<Atom> eqrPos1=new ArrayList<Atom>();
  List<Atom> eqrPos2=new ArrayList<Atom>();
  List<Atom> eqrPos2copy=new ArrayList<Atom>();
  for (int z=0; z < blocks2[blockNr][0].length && z < optLen[blockNr]; z++) {
    int pos1=blocks2[blockNr][0][z];
    int pos2=blocks2[blockNr][1][z];
    Atom c1=ca1Copy[pos1];
    Atom c2=ca2Copy[pos2];
    Atom c3=ca2Copy2[pos2];
    eqrPos1.add(c1);
    eqrPos2.add(c2);
    eqrPos2copy.add(c3);
  }
  assertTrue(""String_Node_Str"" + blockNr + ""String_Node_Str""+ afpChain.getOptLen()[blockNr]+ ""String_Node_Str""+ eqrPos2.size(),eqrPos2.size() == afpChain.getOptLen()[blockNr]);
  Atom[] blockSet1=eqrPos1.toArray(new Atom[eqrPos1.size()]);
  Atom[] blockSet2=eqrPos2.toArray(new Atom[eqrPos2.size()]);
  Atom[] blockSet2copy=eqrPos2copy.toArray(new Atom[eqrPos2copy.size()]);
  for (  Atom a : blockSet2) {
    for (int i=0; i <= blockNr; i++) {
      Matrix max=maxs2[i];
      Atom shift=shifts2[i];
      Calc.rotate(a,max);
      Calc.shift(a,shift);
    }
  }
  double rmsdFile=Calc.rmsd(blockSet1,blockSet2);
  Matrix4d transform=SuperPositions.superpose(Calc.atomsToPoints(blockSet1),Calc.atomsToPoints(blockSet2copy));
  Matrix m=Matrices.getRotationJAMA(transform);
  Atom s=Calc.getTranslationVector(transform);
  Matrix max=maxs2[blockNr];
  Atom shift=shifts2[blockNr];
  compareMatrices(max,m);
  if (blockNr == 0) {
    compareVectors(shift,s);
  }
 else {
    System.err.println(""String_Node_Str"");
  }
  for (  Atom a : ca2Copy2) {
    Calc.rotate(a,m);
    Calc.shift(a,s);
  }
  double rmsd3=Calc.rmsd(blockSet1,blockSet2copy);
  assertTrue(""String_Node_Str"" + blockNr + ""String_Node_Str""+ rmsd3+ ""String_Node_Str""+ rmsdFile,compareRmsd(rmsd3,rmsdFile));
}",0.9155452436194896
16302,"/** 
 * Creates a new AtomCache object based on the provided UserConfiguration.
 * @param config the UserConfiguration to use for this cache.
 */
public AtomCache(UserConfiguration config){
  this(config.getPdbFilePath(),config.getCacheFilePath());
  fetchBehavior=config.getFetchBehavior();
  obsoleteBehavior=config.getObsoleteBehavior();
  useMmCif=config.getFileFormat().equals(UserConfiguration.MMCIF_FORMAT);
}","/** 
 * Creates a new AtomCache object based on the provided UserConfiguration.
 * @param config the UserConfiguration to use for this cache.
 */
public AtomCache(UserConfiguration config){
  this(config.getPdbFilePath(),config.getCacheFilePath());
  fetchBehavior=config.getFetchBehavior();
  obsoleteBehavior=config.getObsoleteBehavior();
  useMmCif=config.getFileFormat().equals(UserConfiguration.MMCIF_FORMAT);
  if (useMmCif)   useMmtf=false;
}",0.9618497109826588
16303,"/** 
 * Loads a structure directly by PDB ID
 * @param pdbId
 * @return
 * @throws IOException
 * @throws StructureException
 */
public Structure getStructureForPdbId(String pdbId) throws IOException, StructureException {
  if (pdbId == null)   return null;
  if (pdbId.length() != 4) {
    throw new StructureException(""String_Node_Str"" + pdbId);
  }
  while (checkLoading(pdbId)) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage());
    }
  }
  Structure s;
  if (useMmtf) {
    s=loadStructureFromMmtfByPdbId(pdbId);
  }
 else   if (useMmCif) {
    s=loadStructureFromCifByPdbId(pdbId);
  }
 else {
    s=loadStructureFromPdbByPdbId(pdbId);
  }
  return s;
}","/** 
 * Loads a structure directly by PDB ID
 * @param pdbId
 * @return
 * @throws IOException
 * @throws StructureException
 */
public Structure getStructureForPdbId(String pdbId) throws IOException, StructureException {
  if (pdbId == null)   return null;
  if (pdbId.length() != 4) {
    throw new StructureException(""String_Node_Str"" + pdbId);
  }
  while (checkLoading(pdbId)) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage());
    }
  }
  Structure s;
  if (useMmtf) {
    logger.debug(""String_Node_Str"");
    s=loadStructureFromMmtfByPdbId(pdbId);
  }
 else   if (useMmCif) {
    logger.debug(""String_Node_Str"");
    s=loadStructureFromCifByPdbId(pdbId);
  }
 else {
    logger.debug(""String_Node_Str"");
    s=loadStructureFromPdbByPdbId(pdbId);
  }
  return s;
}",0.928891736066624
16304,"/** 
 * Default UserConfiguration: <ul> <li>split directory</li> <li>autofetch files</li> <li>default download location. This is the first specified of: <ol><li>  {@value #PDB_DIR} system property (for instance, -D{@value #PDB_DIR}=/tmp)</li> <li>  {@value #PDB_DIR} environment variable</li><li>System temp directory (java.io.tmpdir property)</li> </ol> if the provided path is not a directory then the system's temp directory is used. A non-writable path is allowed, only a warning will be logged. </li> <li>default cache location. This is the first specified of: <ol><li> {@value #PDB_CACHE_DIR} system property (for instance, -D{@value #PDB_CACHE_DIR}=/tmp)</li> <li>  {@value #PDB_CACHE_DIR} environment variable</li><li>the value set for  {@value #PDB_DIR}</li> </ol> if the provided path is not a directory or is not writable then the system's temp directory is used. </li> </ul>
 */
public UserConfiguration(){
  fetchBehavior=FetchBehavior.DEFAULT;
  obsoleteBehavior=ObsoleteBehavior.DEFAULT;
  pdbFilePath=initPdbFilePath();
  cacheFilePath=initCacheFilePath();
  fileFormat=MMCIF_FORMAT;
}","/** 
 * Default UserConfiguration: <ul> <li>split directory</li> <li>autofetch files</li> <li>default download location. This is the first specified of: <ol><li>  {@value #PDB_DIR} system property (for instance, -D{@value #PDB_DIR}=/tmp)</li> <li>  {@value #PDB_DIR} environment variable</li><li>System temp directory (java.io.tmpdir property)</li> </ol> if the provided path is not a directory then the system's temp directory is used. A non-writable path is allowed, only a warning will be logged. </li> <li>default cache location. This is the first specified of: <ol><li> {@value #PDB_CACHE_DIR} system property (for instance, -D{@value #PDB_CACHE_DIR}=/tmp)</li> <li>  {@value #PDB_CACHE_DIR} environment variable</li><li>the value set for  {@value #PDB_DIR}</li> </ol> if the provided path is not a directory or is not writable then the system's temp directory is used. </li> </ul>
 */
public UserConfiguration(){
  fetchBehavior=FetchBehavior.DEFAULT;
  obsoleteBehavior=ObsoleteBehavior.DEFAULT;
  pdbFilePath=initPdbFilePath();
  cacheFilePath=initCacheFilePath();
  fileFormat=MMTF_FORMAT;
}",0.9986369831894594
16305,"/** 
 * Create and set a new structure from a given atom array.
 * @param atoms
 */
public void setAtoms(Atom[] atoms){
  Structure s=new StructureImpl();
  Chain c=new ChainImpl();
  c.setId(""String_Node_Str"");
  for (  Atom a : atoms) {
    c.addGroup(a.getGroup());
  }
  s.addChain(c);
  setStructure(s);
}","/** 
 * Create and set a new structure from a given atom array.
 * @param atoms
 */
public void setAtoms(Atom[] atoms){
  Structure s=new StructureImpl();
  Chain c=new ChainImpl();
  c.setChainID(""String_Node_Str"");
  for (  Atom a : atoms) {
    c.addGroup(a.getGroup());
  }
  s.addChain(c);
  setStructure(s);
}",0.9888
16306,"/** 
 * Creates bond objects from a LinkRecord as parsed from a PDB file
 * @param linkRecord
 */
public void formLinkRecordBond(LinkRecord linkRecord){
  if (linkRecord.getAltLoc1().equals(""String_Node_Str"") || linkRecord.getAltLoc2().equals(""String_Node_Str""))   return;
  try {
    Atom a=getAtomFromRecord(linkRecord.getName1(),linkRecord.getAltLoc1(),linkRecord.getResName1(),linkRecord.getChainID1(),linkRecord.getResSeq1(),linkRecord.getiCode1());
    Atom b=getAtomFromRecord(linkRecord.getName2(),linkRecord.getAltLoc2(),linkRecord.getResName2(),linkRecord.getChainID2(),linkRecord.getResSeq2(),linkRecord.getiCode2());
    new BondImpl(a,b,1);
  }
 catch (  StructureException e) {
    if (!params.isParseCAOnly()) {
      logger.warn(""String_Node_Str"",linkRecord.toString());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
  }
}","/** 
 * Creates bond objects from a LinkRecord as parsed from a PDB file
 * @param linkRecord
 */
public void formLinkRecordBond(LinkRecord linkRecord){
  if (linkRecord.getAltLoc1().equals(""String_Node_Str"") || linkRecord.getAltLoc2().equals(""String_Node_Str""))   return;
  try {
    Map<Integer,Atom> a=getAtomFromRecord(linkRecord.getName1(),linkRecord.getAltLoc1(),linkRecord.getResName1(),linkRecord.getChainID1(),linkRecord.getResSeq1(),linkRecord.getiCode1());
    Map<Integer,Atom> b=getAtomFromRecord(linkRecord.getName2(),linkRecord.getAltLoc2(),linkRecord.getResName2(),linkRecord.getChainID2(),linkRecord.getResSeq2(),linkRecord.getiCode2());
    for (int i=0; i < structure.nrModels(); i++) {
      if (a.containsKey(i) && b.containsKey(i)) {
        new BondImpl(a.get(i),b.get(i),1);
      }
    }
  }
 catch (  StructureException e) {
    if (!params.isParseCAOnly()) {
      logger.warn(""String_Node_Str"",linkRecord.toString());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
  }
}",0.9145620634067706
16307,"public void formBondsFromStructConn(List<StructConn> structConn){
  final String symop=""String_Node_Str"";
  List<Bond> ssbonds=new ArrayList<>();
  for (  StructConn conn : structConn) {
    if (!BOND_TYPES_TO_PARSE.contains(conn.getConn_type_id()))     continue;
    String chainId1;
    String chainId2;
    chainId1=conn.getPtnr1_label_asym_id();
    chainId2=conn.getPtnr2_label_asym_id();
    String insCode1=""String_Node_Str"";
    if (!conn.getPdbx_ptnr1_PDB_ins_code().equals(""String_Node_Str""))     insCode1=conn.getPdbx_ptnr1_PDB_ins_code();
    String insCode2=""String_Node_Str"";
    if (!conn.getPdbx_ptnr2_PDB_ins_code().equals(""String_Node_Str""))     insCode2=conn.getPdbx_ptnr2_PDB_ins_code();
    String seqId1=conn.getPtnr1_auth_seq_id();
    String seqId2=conn.getPtnr2_auth_seq_id();
    String resName1=conn.getPtnr1_label_comp_id();
    String resName2=conn.getPtnr2_label_comp_id();
    String atomName1=conn.getPtnr1_label_atom_id();
    String atomName2=conn.getPtnr2_label_atom_id();
    String altLoc1=""String_Node_Str"";
    if (!conn.getPdbx_ptnr1_label_alt_id().equals(""String_Node_Str""))     altLoc1=conn.getPdbx_ptnr1_label_alt_id();
    String altLoc2=""String_Node_Str"";
    if (!conn.getPdbx_ptnr2_label_alt_id().equals(""String_Node_Str""))     altLoc2=conn.getPdbx_ptnr2_label_alt_id();
    if (!conn.getPtnr1_symmetry().equals(symop) || !conn.getPtnr2_symmetry().equals(symop)) {
      logger.info(""String_Node_Str"",atomName1,seqId1,insCode1,atomName2,seqId2,insCode2);
      continue;
    }
    String altLocStr1=altLoc1.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + altLoc1 + ""String_Node_Str"";
    String altLocStr2=altLoc2.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + altLoc2 + ""String_Node_Str"";
    Atom a1=null;
    Atom a2=null;
    try {
      a1=getAtomFromRecord(atomName1,altLoc1,resName1,chainId1,seqId1,insCode1);
    }
 catch (    StructureException e) {
      logger.warn(""String_Node_Str"",seqId1,insCode1,resName1,chainId1,atomName1,altLocStr1);
      continue;
    }
    try {
      a2=getAtomFromRecord(atomName2,altLoc2,resName2,chainId2,seqId2,insCode2);
    }
 catch (    StructureException e) {
      logger.warn(""String_Node_Str"",seqId2,insCode2,resName2,chainId2,atomName2,altLocStr2);
      continue;
    }
    if (a1 == null) {
      logger.warn(""String_Node_Str"",atomName1,altLocStr1,seqId1,insCode1,resName1,chainId1);
      continue;
    }
    if (a2 == null) {
      logger.warn(""String_Node_Str"",atomName2,altLocStr2,seqId2,insCode2,resName2,chainId2);
      continue;
    }
    Bond bond=new BondImpl(a1,a2,1);
    if (conn.getConn_type_id().equals(""String_Node_Str"")) {
      ssbonds.add(bond);
    }
  }
  structure.setSSBonds(ssbonds);
}","public void formBondsFromStructConn(List<StructConn> structConn){
  final String symop=""String_Node_Str"";
  List<Bond> ssbonds=new ArrayList<>();
  for (  StructConn conn : structConn) {
    if (!BOND_TYPES_TO_PARSE.contains(conn.getConn_type_id()))     continue;
    String chainId1;
    String chainId2;
    chainId1=conn.getPtnr1_label_asym_id();
    chainId2=conn.getPtnr2_label_asym_id();
    String insCode1=""String_Node_Str"";
    if (!conn.getPdbx_ptnr1_PDB_ins_code().equals(""String_Node_Str""))     insCode1=conn.getPdbx_ptnr1_PDB_ins_code();
    String insCode2=""String_Node_Str"";
    if (!conn.getPdbx_ptnr2_PDB_ins_code().equals(""String_Node_Str""))     insCode2=conn.getPdbx_ptnr2_PDB_ins_code();
    String seqId1=conn.getPtnr1_auth_seq_id();
    String seqId2=conn.getPtnr2_auth_seq_id();
    String resName1=conn.getPtnr1_label_comp_id();
    String resName2=conn.getPtnr2_label_comp_id();
    String atomName1=conn.getPtnr1_label_atom_id();
    String atomName2=conn.getPtnr2_label_atom_id();
    String altLoc1=""String_Node_Str"";
    if (!conn.getPdbx_ptnr1_label_alt_id().equals(""String_Node_Str""))     altLoc1=conn.getPdbx_ptnr1_label_alt_id();
    String altLoc2=""String_Node_Str"";
    if (!conn.getPdbx_ptnr2_label_alt_id().equals(""String_Node_Str""))     altLoc2=conn.getPdbx_ptnr2_label_alt_id();
    if (!conn.getPtnr1_symmetry().equals(symop) || !conn.getPtnr2_symmetry().equals(symop)) {
      logger.info(""String_Node_Str"",atomName1,seqId1,insCode1,atomName2,seqId2,insCode2);
      continue;
    }
    String altLocStr1=altLoc1.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + altLoc1 + ""String_Node_Str"";
    String altLocStr2=altLoc2.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + altLoc2 + ""String_Node_Str"";
    Map<Integer,Atom> a1=null;
    Map<Integer,Atom> a2=null;
    try {
      a1=getAtomFromRecord(atomName1,altLoc1,resName1,chainId1,seqId1,insCode1);
    }
 catch (    StructureException e) {
      logger.warn(""String_Node_Str"",seqId1,insCode1,resName1,chainId1,atomName1,altLocStr1);
      continue;
    }
    try {
      a2=getAtomFromRecord(atomName2,altLoc2,resName2,chainId2,seqId2,insCode2);
    }
 catch (    StructureException e) {
      logger.warn(""String_Node_Str"",seqId2,insCode2,resName2,chainId2,atomName2,altLocStr2);
      continue;
    }
    if (a1 == null) {
      logger.warn(""String_Node_Str"",atomName1,altLocStr1,seqId1,insCode1,resName1,chainId1);
      continue;
    }
    if (a2 == null) {
      logger.warn(""String_Node_Str"",atomName2,altLocStr2,seqId2,insCode2,resName2,chainId2);
      continue;
    }
    for (int i=0; i < structure.nrModels(); i++) {
      Bond bond=null;
      if (a1.containsKey(i) && a2.containsKey(i)) {
        bond=new BondImpl(a1.get(i),a2.get(i),1);
      }
      if (bond != null) {
        if (conn.getConn_type_id().equals(""String_Node_Str"")) {
          ssbonds.add(bond);
        }
      }
    }
  }
  structure.setSSBonds(ssbonds);
}",0.9526501766784452
16308,"/** 
 * Creates disulfide bond objects and references in the corresponding Atoms objects, given a list of   {@link SSBondImpl}s parsed from a PDB/mmCIF file.
 * @param disulfideBonds
 */
public void formDisulfideBonds(List<SSBondImpl> disulfideBonds){
  List<Bond> bonds=new ArrayList<>();
  for (  SSBondImpl disulfideBond : disulfideBonds) {
    Bond bond=formDisulfideBond(disulfideBond);
    if (bond != null)     bonds.add(bond);
  }
  structure.setSSBonds(bonds);
}","/** 
 * Creates disulfide bond objects and references in the corresponding Atoms objects, given a list of   {@link SSBondImpl}s parsed from a PDB/mmCIF file.
 * @param disulfideBonds
 */
public void formDisulfideBonds(List<SSBondImpl> disulfideBonds){
  for (  SSBondImpl disulfideBond : disulfideBonds) {
    formDisulfideBond(disulfideBond);
  }
}",0.6414634146341464
16309,"private Atom getAtomFromRecord(String name,String altLoc,String resName,String chainID,String resSeq,String iCode) throws StructureException {
  if (iCode == null || iCode.isEmpty()) {
    iCode=""String_Node_Str"";
  }
  Chain chain=structure.getChain(chainID);
  ResidueNumber resNum=new ResidueNumber(chainID,Integer.parseInt(resSeq),iCode.charAt(0));
  Group group=chain.getGroupByPDB(resNum);
  Group g=group;
  if (!altLoc.isEmpty()) {
    g=group.getAltLocGroup(altLoc.charAt(0));
    if (g == null)     throw new StructureException(""String_Node_Str"" + altLoc + ""String_Node_Str""+ resSeq+ iCode+ ""String_Node_Str""+ chainID);
  }
  return g.getAtom(name);
}","private Map<Integer,Atom> getAtomFromRecord(String name,String altLoc,String resName,String chainID,String resSeq,String iCode) throws StructureException {
  if (iCode == null || iCode.isEmpty()) {
    iCode=""String_Node_Str"";
  }
  Map<Integer,Atom> outMap=new HashMap<>();
  ResidueNumber resNum=new ResidueNumber(chainID,Integer.parseInt(resSeq),iCode.charAt(0));
  for (int i=0; i < structure.nrModels(); i++) {
    Chain chain=structure.getChain(chainID,i);
    Group group=chain.getGroupByPDB(resNum);
    Group g=group;
    if (!altLoc.isEmpty()) {
      g=group.getAltLocGroup(altLoc.charAt(0));
      if (g == null)       throw new StructureException(""String_Node_Str"" + altLoc + ""String_Node_Str""+ resSeq+ iCode+ ""String_Node_Str""+ chainID);
    }
    outMap.put(i,g.getAtom(name));
  }
  return outMap;
}",0.7262872628726287
16310,"private Bond formDisulfideBond(SSBondImpl disulfideBond){
  try {
    Atom a=getAtomFromRecord(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",disulfideBond.getChainID1(),disulfideBond.getResnum1(),disulfideBond.getInsCode1());
    Atom b=getAtomFromRecord(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",disulfideBond.getChainID2(),disulfideBond.getResnum2(),disulfideBond.getInsCode2());
    Bond ssbond=new BondImpl(a,b,1);
    structure.addSSBond(ssbond);
    return ssbond;
  }
 catch (  StructureException e) {
    if (!params.isParseCAOnly()) {
      logger.warn(""String_Node_Str"",disulfideBond.toString());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    return null;
  }
}","private void formDisulfideBond(SSBondImpl disulfideBond){
  try {
    Map<Integer,Atom> a=getAtomFromRecord(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",disulfideBond.getChainID1(),disulfideBond.getResnum1(),disulfideBond.getInsCode1());
    Map<Integer,Atom> b=getAtomFromRecord(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",disulfideBond.getChainID2(),disulfideBond.getResnum2(),disulfideBond.getInsCode2());
    for (int i=0; i < structure.nrModels(); i++) {
      if (a.containsKey(i) && b.containsKey(i)) {
        Bond ssbond=new BondImpl(a.get(i),b.get(i),1);
        structure.addSSBond(ssbond);
      }
    }
  }
 catch (  StructureException e) {
    if (!params.isParseCAOnly()) {
      logger.warn(""String_Node_Str"",disulfideBond.toString());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
  }
}",0.864549578742709
16311,"/** 
 * The constructor displays the Mutltiple Alignment in a new JmolPanel Frame.
 * @param msa : contains the aligned residues.
 * @param rotatedAtoms : contains the transformed Atom coordinates.
 */
public MultipleAlignmentJmol(MultipleAlignment msa,List<Atom[]> rotatedAtoms){
  AligUIManager.setLookAndFeel();
  nrOpenWindows++;
  jmolPanel=new JmolPanel();
  frame=new JFrame();
  JMenuBar menu=MenuCreator.initJmolMenu(frame,this,null,msa);
  frame.setJMenuBar(menu);
  this.multAln=msa;
  this.transformedAtoms=rotatedAtoms;
  this.selectedStructures=new ArrayList<JCheckBox>();
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      nrOpenWindows--;
      destroy();
      if (nrOpenWindows > 0)       frame.dispose();
 else {
        MultipleAlignmentGUI gui=MultipleAlignmentGUI.getInstanceNoVisibilityChange();
        if (gui.isVisible()) {
          frame.dispose();
          gui.requestFocus();
        }
 else         System.exit(0);
      }
    }
  }
);
  Container contentPane=frame.getContentPane();
  Box vBox=Box.createVerticalBox();
  jmolPanel.addMouseMotionListener(this);
  jmolPanel.addMouseListener(this);
  jmolPanel.setPreferredSize(new Dimension(DEFAULT_WIDTH,DEFAULT_HEIGHT));
  vBox.add(jmolPanel);
  JTextField field=new JTextField();
  field.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  field.setText(COMMAND_LINE_HELP);
  RasmolCommandListener listener=new RasmolCommandListener(jmolPanel,field);
  field.addActionListener(listener);
  field.addMouseListener(listener);
  field.addKeyListener(listener);
  vBox.add(field);
  if (multAln != null) {
    Box hBox00=Box.createHorizontalBox();
    hBox00.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
    JButton show=new JButton(""String_Node_Str"");
    show.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        jmolPanel.evalString(""String_Node_Str"");
        String cmd=getJmolString(multAln,transformedAtoms,colorPalette,colorByBlocks.isSelected());
        cmd+=""String_Node_Str"";
        for (int st=0; st < multAln.size(); st++) {
          if (selectedStructures.get(st).isSelected()) {
            cmd+=""String_Node_Str"" + (st + 1) + ""String_Node_Str"";
          }
        }
        cmd+=""String_Node_Str"";
        jmolPanel.executeCmd(cmd + ""String_Node_Str"");
      }
    }
);
    hBox00.add(show);
    hBox00.add(Box.createGlue());
    vBox.add(hBox00);
    for (int line=0; line < 1 + (multAln.size() / 5); line++) {
      Box hBox0=Box.createHorizontalBox();
      hBox0.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
      for (int str=line * 5; str < Math.min((line + 1) * 5,multAln.size()); str++) {
        JCheckBox structureSelection=new JCheckBox(multAln.getEnsemble().getStructureIdentifiers().get(str).getIdentifier());
        hBox0.add(structureSelection);
        hBox0.add(Box.createGlue());
        structureSelection.setSelected(true);
        selectedStructures.add(structureSelection);
      }
      vBox.add(hBox0);
    }
  }
  Box hBox1=Box.createHorizontalBox();
  hBox1.add(Box.createGlue());
  String[] styles=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox style=new JComboBox(styles);
  hBox1.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(style);
  vBox.add(hBox1);
  contentPane.add(vBox);
  style.addActionListener(jmolPanel);
  String[] colorModes=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox jcolors=new JComboBox(colorModes);
  jcolors.addActionListener(jmolPanel);
  hBox1.add(Box.createGlue());
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(jcolors);
  String[] cPalette={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox palette=new JComboBox(cPalette);
  palette.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      JComboBox source=(JComboBox)e.getSource();
      String value=source.getSelectedItem().toString();
      evalString(""String_Node_Str"" + ""String_Node_Str"");
      if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Set1;
      }
 else       if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Set2;
      }
 else       if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Spectral;
      }
 else       if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Pastel1;
      }
      String script=getJmolString(multAln,transformedAtoms,colorPalette,colorByBlocks.isSelected());
      evalString(script + ""String_Node_Str"");
    }
  }
);
  hBox1.add(Box.createGlue());
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(palette);
  Box hBox2=Box.createHorizontalBox();
  JButton resetDisplay=new JButton(""String_Node_Str"");
  resetDisplay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      logger.info(""String_Node_Str"");
      jmolPanel.executeCmd(""String_Node_Str"");
    }
  }
);
  hBox2.add(resetDisplay);
  hBox2.add(Box.createGlue());
  JCheckBox toggleSelection=new JCheckBox(""String_Node_Str"");
  toggleSelection.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      boolean showSelection=(e.getStateChange() == ItemEvent.SELECTED);
      if (showSelection) {
        jmolPanel.executeCmd(""String_Node_Str"");
      }
 else       jmolPanel.executeCmd(""String_Node_Str"");
    }
  }
);
  hBox2.add(toggleSelection);
  hBox2.add(Box.createGlue());
  colorByBlocks=new JCheckBox(""String_Node_Str"");
  colorByBlocks.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      evalString(""String_Node_Str"" + getJmolString(multAln,transformedAtoms,colorPalette,colorByBlocks.isSelected()) + ""String_Node_Str"");
    }
  }
);
  hBox2.add(colorByBlocks);
  hBox2.add(Box.createGlue());
  vBox.add(hBox2);
  Box hBox=Box.createHorizontalBox();
  status=new JTextField();
  status.setBackground(Color.white);
  status.setEditable(false);
  status.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  status.setPreferredSize(new Dimension(DEFAULT_WIDTH / 2,30));
  status.setMinimumSize(new Dimension(DEFAULT_WIDTH / 2,30));
  hBox.add(status);
  text=new JTextField();
  text.setBackground(Color.white);
  text.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  text.setPreferredSize(new Dimension(DEFAULT_WIDTH / 2,30));
  text.setMinimumSize(new Dimension(DEFAULT_WIDTH / 2,30));
  text.setText(""String_Node_Str"");
  text.setEditable(false);
  hBox.add(text);
  vBox.add(hBox);
  contentPane.add(vBox);
  MyJmolStatusListener li=(MyJmolStatusListener)jmolPanel.getStatusListener();
  li.setTextField(status);
  frame.pack();
  frame.setVisible(true);
  initCoords();
  resetDisplay();
}","/** 
 * The constructor displays the Mutltiple Alignment in a new JmolPanel Frame.
 * @param msa : contains the aligned residues.
 * @param rotatedAtoms : contains the transformed Atom coordinates.
 */
public MultipleAlignmentJmol(MultipleAlignment msa,List<Atom[]> rotatedAtoms){
  AligUIManager.setLookAndFeel();
  nrOpenWindows++;
  jmolPanel=new JmolPanel();
  frame=new JFrame();
  JMenuBar menu=MenuCreator.initJmolMenu(frame,this,null,msa);
  frame.setJMenuBar(menu);
  this.multAln=msa;
  this.transformedAtoms=rotatedAtoms;
  this.selectedStructures=new ArrayList<JCheckBox>();
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      nrOpenWindows--;
      destroy();
      if (nrOpenWindows > 0)       frame.dispose();
 else {
        MultipleAlignmentGUI gui=MultipleAlignmentGUI.getInstanceNoVisibilityChange();
        if (gui.isVisible()) {
          frame.dispose();
          gui.requestFocus();
        }
 else         System.exit(0);
      }
    }
  }
);
  Container contentPane=frame.getContentPane();
  jmolPanel.addMouseMotionListener(this);
  jmolPanel.addMouseListener(this);
  jmolPanel.setPreferredSize(new Dimension(DEFAULT_WIDTH,DEFAULT_HEIGHT));
  contentPane.add(jmolPanel,BorderLayout.CENTER);
  Box vBox=Box.createVerticalBox();
  JTextField field=new JTextField();
  field.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  field.setText(COMMAND_LINE_HELP);
  RasmolCommandListener listener=new RasmolCommandListener(jmolPanel,field);
  field.addActionListener(listener);
  field.addMouseListener(listener);
  field.addKeyListener(listener);
  vBox.add(field);
  if (multAln != null) {
    JPanel modelSelection=new JPanel();
    modelSelection.setLayout(new WrapLayout(WrapLayout.LEFT));
    modelSelection.setSize(new Dimension(DEFAULT_WIDTH,30));
    vBox.add(modelSelection);
    JButton show=new JButton(""String_Node_Str"");
    show.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        jmolPanel.evalString(""String_Node_Str"");
        String cmd=getJmolString(multAln,transformedAtoms,colorPalette,colorByBlocks.isSelected());
        cmd+=""String_Node_Str"";
        for (int st=0; st < multAln.size(); st++) {
          if (selectedStructures.get(st).isSelected()) {
            cmd+=""String_Node_Str"" + (st + 1) + ""String_Node_Str"";
          }
        }
        cmd+=""String_Node_Str"";
        jmolPanel.executeCmd(cmd + ""String_Node_Str"");
      }
    }
);
    modelSelection.add(show);
    for (int str=0; str < multAln.size(); str++) {
      JCheckBox structureSelection=new JCheckBox(multAln.getEnsemble().getStructureIdentifiers().get(str).getIdentifier());
      modelSelection.add(structureSelection);
      structureSelection.setSelected(true);
      selectedStructures.add(structureSelection);
    }
  }
  Box hBox1=Box.createHorizontalBox();
  hBox1.add(Box.createGlue());
  String[] styles=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox<String> style=new JComboBox<>(styles);
  hBox1.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(style);
  vBox.add(hBox1);
  style.addActionListener(jmolPanel);
  String[] colorModes=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox<String> jcolors=new JComboBox<>(colorModes);
  jcolors.addActionListener(jmolPanel);
  hBox1.add(Box.createGlue());
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(jcolors);
  String[] cPalette={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox<String> palette=new JComboBox<>(cPalette);
  palette.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      @SuppressWarnings(""String_Node_Str"") JComboBox<String> source=(JComboBox<String>)e.getSource();
      String value=source.getSelectedItem().toString();
      evalString(""String_Node_Str"" + ""String_Node_Str"");
      if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Set1;
      }
 else       if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Set2;
      }
 else       if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Spectral;
      }
 else       if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Pastel1;
      }
      String script=getJmolString(multAln,transformedAtoms,colorPalette,colorByBlocks.isSelected());
      evalString(script + ""String_Node_Str"");
    }
  }
);
  hBox1.add(Box.createGlue());
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(palette);
  Box hBox2=Box.createHorizontalBox();
  hBox2.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  JButton resetDisplay=new JButton(""String_Node_Str"");
  resetDisplay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      logger.info(""String_Node_Str"");
      jmolPanel.executeCmd(""String_Node_Str"");
    }
  }
);
  hBox2.add(resetDisplay);
  hBox2.add(Box.createGlue());
  JCheckBox toggleSelection=new JCheckBox(""String_Node_Str"");
  toggleSelection.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      boolean showSelection=(e.getStateChange() == ItemEvent.SELECTED);
      if (showSelection) {
        jmolPanel.executeCmd(""String_Node_Str"");
      }
 else       jmolPanel.executeCmd(""String_Node_Str"");
    }
  }
);
  hBox2.add(toggleSelection);
  hBox2.add(Box.createGlue());
  colorByBlocks=new JCheckBox(""String_Node_Str"");
  colorByBlocks.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      evalString(""String_Node_Str"" + getJmolString(multAln,transformedAtoms,colorPalette,colorByBlocks.isSelected()) + ""String_Node_Str"");
    }
  }
);
  hBox2.add(colorByBlocks);
  hBox2.add(Box.createGlue());
  vBox.add(hBox2);
  Box hBox=Box.createHorizontalBox();
  status=new JTextField();
  status.setBackground(Color.white);
  status.setEditable(false);
  status.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  status.setPreferredSize(new Dimension(DEFAULT_WIDTH / 2,30));
  status.setMinimumSize(new Dimension(DEFAULT_WIDTH / 2,30));
  hBox.add(status);
  text=new JTextField();
  text.setBackground(Color.white);
  text.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  text.setPreferredSize(new Dimension(DEFAULT_WIDTH / 2,30));
  text.setMinimumSize(new Dimension(DEFAULT_WIDTH / 2,30));
  text.setText(""String_Node_Str"");
  text.setEditable(false);
  hBox.add(text);
  vBox.add(hBox);
  contentPane.add(vBox,BorderLayout.SOUTH);
  MyJmolStatusListener li=(MyJmolStatusListener)jmolPanel.getStatusListener();
  li.setTextField(status);
  frame.pack();
  frame.setVisible(true);
  initCoords();
  resetDisplay();
}",0.3687063186421337
16312,"/** 
 * The constructor displays the Mutltiple Alignment in a new JmolPanel Frame.
 * @param msa : contains the aligned residues.
 * @param rotatedAtoms : contains the transformed Atom coordinates.
 */
public MultipleAlignmentJmol(MultipleAlignment msa,List<Atom[]> rotatedAtoms){
  AligUIManager.setLookAndFeel();
  nrOpenWindows++;
  jmolPanel=new JmolPanel();
  frame=new JFrame();
  JMenuBar menu=MenuCreator.initJmolMenu(frame,this,null,msa);
  frame.setJMenuBar(menu);
  this.multAln=msa;
  this.transformedAtoms=rotatedAtoms;
  this.selectedStructures=new ArrayList<JCheckBox>();
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      nrOpenWindows--;
      destroy();
      if (nrOpenWindows > 0)       frame.dispose();
 else {
        MultipleAlignmentGUI gui=MultipleAlignmentGUI.getInstanceNoVisibilityChange();
        if (gui.isVisible()) {
          frame.dispose();
          gui.requestFocus();
        }
 else         System.exit(0);
      }
    }
  }
);
  Container contentPane=frame.getContentPane();
  Box vBox=Box.createVerticalBox();
  jmolPanel.addMouseMotionListener(this);
  jmolPanel.addMouseListener(this);
  jmolPanel.setPreferredSize(new Dimension(DEFAULT_WIDTH,DEFAULT_HEIGHT));
  vBox.add(jmolPanel);
  JTextField field=new JTextField();
  field.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  field.setText(COMMAND_LINE_HELP);
  RasmolCommandListener listener=new RasmolCommandListener(jmolPanel,field);
  field.addActionListener(listener);
  field.addMouseListener(listener);
  field.addKeyListener(listener);
  vBox.add(field);
  if (multAln != null) {
    Box hBox00=Box.createHorizontalBox();
    hBox00.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
    JButton show=new JButton(""String_Node_Str"");
    show.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        jmolPanel.evalString(""String_Node_Str"");
        String cmd=getJmolString(multAln,transformedAtoms,colorPalette,colorByBlocks.isSelected());
        cmd+=""String_Node_Str"";
        for (int st=0; st < multAln.size(); st++) {
          if (selectedStructures.get(st).isSelected()) {
            cmd+=""String_Node_Str"" + (st + 1) + ""String_Node_Str"";
          }
        }
        cmd+=""String_Node_Str"";
        jmolPanel.executeCmd(cmd + ""String_Node_Str"");
      }
    }
);
    hBox00.add(show);
    hBox00.add(Box.createGlue());
    vBox.add(hBox00);
    for (int line=0; line < 1 + (multAln.size() / 5); line++) {
      Box hBox0=Box.createHorizontalBox();
      hBox0.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
      for (int str=line * 5; str < Math.min((line + 1) * 5,multAln.size()); str++) {
        JCheckBox structureSelection=new JCheckBox(multAln.getEnsemble().getStructureIdentifiers().get(str).getIdentifier());
        hBox0.add(structureSelection);
        hBox0.add(Box.createGlue());
        structureSelection.setSelected(true);
        selectedStructures.add(structureSelection);
      }
      vBox.add(hBox0);
    }
  }
  Box hBox1=Box.createHorizontalBox();
  hBox1.add(Box.createGlue());
  String[] styles=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox style=new JComboBox(styles);
  hBox1.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(style);
  vBox.add(hBox1);
  contentPane.add(vBox);
  style.addActionListener(jmolPanel);
  String[] colorModes=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox jcolors=new JComboBox(colorModes);
  jcolors.addActionListener(jmolPanel);
  hBox1.add(Box.createGlue());
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(jcolors);
  String[] cPalette={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox palette=new JComboBox(cPalette);
  palette.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      JComboBox source=(JComboBox)e.getSource();
      String value=source.getSelectedItem().toString();
      evalString(""String_Node_Str"" + ""String_Node_Str"");
      if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Set1;
      }
 else       if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Set2;
      }
 else       if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Spectral;
      }
 else       if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Pastel1;
      }
      String script=getJmolString(multAln,transformedAtoms,colorPalette,colorByBlocks.isSelected());
      evalString(script + ""String_Node_Str"");
    }
  }
);
  hBox1.add(Box.createGlue());
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(palette);
  Box hBox2=Box.createHorizontalBox();
  JButton resetDisplay=new JButton(""String_Node_Str"");
  resetDisplay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      logger.info(""String_Node_Str"");
      jmolPanel.executeCmd(""String_Node_Str"");
    }
  }
);
  hBox2.add(resetDisplay);
  hBox2.add(Box.createGlue());
  JCheckBox toggleSelection=new JCheckBox(""String_Node_Str"");
  toggleSelection.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      boolean showSelection=(e.getStateChange() == ItemEvent.SELECTED);
      if (showSelection) {
        jmolPanel.executeCmd(""String_Node_Str"");
      }
 else       jmolPanel.executeCmd(""String_Node_Str"");
    }
  }
);
  hBox2.add(toggleSelection);
  hBox2.add(Box.createGlue());
  colorByBlocks=new JCheckBox(""String_Node_Str"");
  colorByBlocks.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      evalString(""String_Node_Str"" + getJmolString(multAln,transformedAtoms,colorPalette,colorByBlocks.isSelected()) + ""String_Node_Str"");
    }
  }
);
  hBox2.add(colorByBlocks);
  hBox2.add(Box.createGlue());
  vBox.add(hBox2);
  Box hBox=Box.createHorizontalBox();
  status=new JTextField();
  status.setBackground(Color.white);
  status.setEditable(false);
  status.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  status.setPreferredSize(new Dimension(DEFAULT_WIDTH / 2,30));
  status.setMinimumSize(new Dimension(DEFAULT_WIDTH / 2,30));
  hBox.add(status);
  text=new JTextField();
  text.setBackground(Color.white);
  text.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  text.setPreferredSize(new Dimension(DEFAULT_WIDTH / 2,30));
  text.setMinimumSize(new Dimension(DEFAULT_WIDTH / 2,30));
  text.setText(""String_Node_Str"");
  text.setEditable(false);
  hBox.add(text);
  vBox.add(hBox);
  contentPane.add(vBox);
  MyJmolStatusListener li=(MyJmolStatusListener)jmolPanel.getStatusListener();
  li.setTextField(status);
  frame.pack();
  frame.setVisible(true);
  initCoords();
  resetDisplay();
}","/** 
 * The constructor displays the Mutltiple Alignment in a new JmolPanel Frame.
 * @param msa : contains the aligned residues.
 * @param rotatedAtoms : contains the transformed Atom coordinates.
 */
public MultipleAlignmentJmol(MultipleAlignment msa,List<Atom[]> rotatedAtoms){
  AligUIManager.setLookAndFeel();
  nrOpenWindows++;
  jmolPanel=new JmolPanel();
  frame=new JFrame();
  JMenuBar menu=MenuCreator.initJmolMenu(frame,this,null,msa);
  frame.setJMenuBar(menu);
  this.multAln=msa;
  this.transformedAtoms=rotatedAtoms;
  this.selectedStructures=new ArrayList<JCheckBox>();
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      nrOpenWindows--;
      destroy();
      if (nrOpenWindows > 0)       frame.dispose();
 else {
        MultipleAlignmentGUI gui=MultipleAlignmentGUI.getInstanceNoVisibilityChange();
        if (gui.isVisible()) {
          frame.dispose();
          gui.requestFocus();
        }
 else         System.exit(0);
      }
    }
  }
);
  Container contentPane=frame.getContentPane();
  jmolPanel.addMouseMotionListener(this);
  jmolPanel.addMouseListener(this);
  jmolPanel.setPreferredSize(new Dimension(DEFAULT_WIDTH,DEFAULT_HEIGHT));
  contentPane.add(jmolPanel,BorderLayout.CENTER);
  Box vBox=Box.createVerticalBox();
  JTextField field=new JTextField();
  field.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  field.setText(COMMAND_LINE_HELP);
  RasmolCommandListener listener=new RasmolCommandListener(jmolPanel,field);
  field.addActionListener(listener);
  field.addMouseListener(listener);
  field.addKeyListener(listener);
  vBox.add(field);
  if (multAln != null) {
    JPanel modelSelection=new JPanel();
    modelSelection.setLayout(new WrapLayout(WrapLayout.LEFT));
    modelSelection.setSize(new Dimension(DEFAULT_WIDTH,30));
    vBox.add(modelSelection);
    JButton show=new JButton(""String_Node_Str"");
    show.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        jmolPanel.evalString(""String_Node_Str"");
        String cmd=getJmolString(multAln,transformedAtoms,colorPalette,colorByBlocks.isSelected());
        cmd+=""String_Node_Str"";
        for (int st=0; st < multAln.size(); st++) {
          if (selectedStructures.get(st).isSelected()) {
            cmd+=""String_Node_Str"" + (st + 1) + ""String_Node_Str"";
          }
        }
        cmd+=""String_Node_Str"";
        jmolPanel.executeCmd(cmd + ""String_Node_Str"");
      }
    }
);
    modelSelection.add(show);
    for (int str=0; str < multAln.size(); str++) {
      JCheckBox structureSelection=new JCheckBox(multAln.getEnsemble().getStructureIdentifiers().get(str).getIdentifier());
      modelSelection.add(structureSelection);
      structureSelection.setSelected(true);
      selectedStructures.add(structureSelection);
    }
  }
  Box hBox1=Box.createHorizontalBox();
  hBox1.add(Box.createGlue());
  String[] styles=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox<String> style=new JComboBox<>(styles);
  hBox1.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(style);
  vBox.add(hBox1);
  style.addActionListener(jmolPanel);
  String[] colorModes=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox<String> jcolors=new JComboBox<>(colorModes);
  jcolors.addActionListener(jmolPanel);
  hBox1.add(Box.createGlue());
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(jcolors);
  String[] cPalette={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox<String> palette=new JComboBox<>(cPalette);
  palette.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      @SuppressWarnings(""String_Node_Str"") JComboBox<String> source=(JComboBox<String>)e.getSource();
      String value=source.getSelectedItem().toString();
      evalString(""String_Node_Str"" + ""String_Node_Str"");
      if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Set1;
      }
 else       if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Set2;
      }
 else       if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Spectral;
      }
 else       if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Pastel1;
      }
      String script=getJmolString(multAln,transformedAtoms,colorPalette,colorByBlocks.isSelected());
      evalString(script + ""String_Node_Str"");
    }
  }
);
  hBox1.add(Box.createGlue());
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(palette);
  Box hBox2=Box.createHorizontalBox();
  hBox2.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  JButton resetDisplay=new JButton(""String_Node_Str"");
  resetDisplay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      logger.info(""String_Node_Str"");
      jmolPanel.executeCmd(""String_Node_Str"");
    }
  }
);
  hBox2.add(resetDisplay);
  hBox2.add(Box.createGlue());
  JCheckBox toggleSelection=new JCheckBox(""String_Node_Str"");
  toggleSelection.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      boolean showSelection=(e.getStateChange() == ItemEvent.SELECTED);
      if (showSelection) {
        jmolPanel.executeCmd(""String_Node_Str"");
      }
 else       jmolPanel.executeCmd(""String_Node_Str"");
    }
  }
);
  hBox2.add(toggleSelection);
  hBox2.add(Box.createGlue());
  colorByBlocks=new JCheckBox(""String_Node_Str"");
  colorByBlocks.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      evalString(""String_Node_Str"" + getJmolString(multAln,transformedAtoms,colorPalette,colorByBlocks.isSelected()) + ""String_Node_Str"");
    }
  }
);
  hBox2.add(colorByBlocks);
  hBox2.add(Box.createGlue());
  vBox.add(hBox2);
  Box hBox=Box.createHorizontalBox();
  status=new JTextField();
  status.setBackground(Color.white);
  status.setEditable(false);
  status.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  status.setPreferredSize(new Dimension(DEFAULT_WIDTH / 2,30));
  status.setMinimumSize(new Dimension(DEFAULT_WIDTH / 2,30));
  hBox.add(status);
  text=new JTextField();
  text.setBackground(Color.white);
  text.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  text.setPreferredSize(new Dimension(DEFAULT_WIDTH / 2,30));
  text.setMinimumSize(new Dimension(DEFAULT_WIDTH / 2,30));
  text.setText(""String_Node_Str"");
  text.setEditable(false);
  hBox.add(text);
  vBox.add(hBox);
  contentPane.add(vBox,BorderLayout.SOUTH);
  MyJmolStatusListener li=(MyJmolStatusListener)jmolPanel.getStatusListener();
  li.setTextField(status);
  frame.pack();
  frame.setVisible(true);
  initCoords();
  resetDisplay();
}",0.3687063186421337
16313,"@Override public void documentEnd(){
  if (currentChain != null) {
    currentChain.addGroup(currentGroup);
    if (isKnownChain(currentChain.getId(),currentModel) == null) {
      currentModel.add(currentChain);
    }
  }
 else   if (!params.isHeaderOnly()) {
    logger.warn(""String_Node_Str"");
  }
  allModels.add(currentModel);
  initMaps();
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setId(asym.getId());
    if (asymId2authorId.get(asym.getId()) != null) {
      seqres.setName(asymId2authorId.get(asym.getId()));
    }
 else {
      seqres.setName(asym.getId());
    }
    EntityType type=null;
    try {
      Entity ent=getEntity(Integer.parseInt(asym.getEntity_id()));
      type=EntityType.entityTypeFromString(ent.getType());
    }
 catch (    NumberFormatException e) {
      logger.debug(""String_Node_Str"",asym.getEntity_id());
    }
    if (type == null || (type != null && type == EntityType.POLYMER)) {
      seqResChains.add(seqres);
    }
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    addEntities(asym);
  }
  if (structAsyms.isEmpty()) {
    logger.warn(""String_Node_Str"");
  }
  linkEntities();
  for (  List<Chain> model : allModels) {
    structure.addModel(model);
  }
  if (params.isAlignSeqRes() && !params.isHeaderOnly()) {
    logger.debug(""String_Node_Str"");
    alignSeqRes();
  }
 else {
    logger.debug(""String_Node_Str"");
    SeqRes2AtomAligner.storeUnAlignedSeqRes(structure,seqResChains,params.isHeaderOnly());
  }
  StructureTools.cleanUpAltLocs(structure);
  if (!params.isHeaderOnly()) {
    if (params.shouldCreateAtomBonds()) {
      addBonds();
    }
    if (params.shouldCreateAtomCharges()) {
      addCharges();
    }
  }
  if (!params.isHeaderOnly()) {
    addSites();
  }
  if (params.isParseBioAssembly()) {
    Map<Integer,BioAssemblyInfo> bioAssemblies=new HashMap<Integer,BioAssemblyInfo>();
    for (    PdbxStructAssembly psa : strucAssemblies) {
      List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
      for (      PdbxStructAssemblyGen psag : strucAssemblyGens) {
        if (psag.getAssembly_id().equals(psa.getId())) {
          psags.add(psag);
        }
      }
      BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
      List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
      int bioAssemblyId=-1;
      try {
        bioAssemblyId=Integer.parseInt(psa.getId());
      }
 catch (      NumberFormatException e) {
        logger.info(""String_Node_Str"",psa.getId());
      }
      if (bioAssemblyId != -1) {
        int mmSize=0;
        for (        BiologicalAssemblyTransformation transf : transformations) {
          Chain c=structure.getChain(transf.getChainId());
          if (c == null) {
            logger.warn(""String_Node_Str"",transf.getChainId());
            continue;
          }
          if (c.getEntityType() == EntityType.POLYMER && !c.getEntityInfo().getDescription().contains(""String_Node_Str"")) {
            mmSize++;
          }
        }
        BioAssemblyInfo bioAssembly=new BioAssemblyInfo();
        bioAssembly.setId(bioAssemblyId);
        bioAssembly.setMacromolecularSize(mmSize);
        bioAssembly.setTransforms(transformations);
        bioAssemblies.put(bioAssemblyId,bioAssembly);
      }
    }
    structure.getPDBHeader().setBioAssemblies(bioAssemblies);
  }
  setStructNcsOps();
  Map<String,List<SeqMisMatch>> misMatchMap=new HashMap<String,List<SeqMisMatch>>();
  for (  StructRefSeqDif sdif : sequenceDifs) {
    SeqMisMatch misMatch=new SeqMisMatchImpl();
    misMatch.setDetails(sdif.getDetails());
    String insCode=sdif.getPdbx_pdb_ins_code();
    if (insCode != null && insCode.equals(""String_Node_Str""))     insCode=null;
    misMatch.setInsCode(insCode);
    misMatch.setOrigGroup(sdif.getDb_mon_id());
    misMatch.setPdbGroup(sdif.getMon_id());
    misMatch.setPdbResNum(sdif.getPdbx_auth_seq_num());
    misMatch.setUniProtId(sdif.getPdbx_seq_db_accession_code());
    misMatch.setSeqNum(sdif.getSeq_num());
    List<SeqMisMatch> mms=misMatchMap.get(sdif.getPdbx_pdb_strand_id());
    if (mms == null) {
      mms=new ArrayList<SeqMisMatch>();
      misMatchMap.put(sdif.getPdbx_pdb_strand_id(),mms);
    }
    mms.add(misMatch);
  }
  for (  String chainId : misMatchMap.keySet()) {
    Chain chain=structure.getPolyChainByPDB(chainId);
    if (chain == null) {
      logger.warn(""String_Node_Str"" + chainId);
      continue;
    }
    chain.setSeqMisMatches(misMatchMap.get(chainId));
  }
}","@Override public void documentEnd(){
  if (currentChain != null) {
    currentChain.addGroup(currentGroup);
    if (isKnownChain(currentChain.getId(),currentModel) == null) {
      currentModel.add(currentChain);
    }
  }
 else   if (!params.isHeaderOnly()) {
    logger.warn(""String_Node_Str"");
  }
  allModels.add(currentModel);
  initMaps();
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setId(asym.getId());
    if (asymId2authorId.get(asym.getId()) != null) {
      seqres.setName(asymId2authorId.get(asym.getId()));
    }
 else {
      seqres.setName(asym.getId());
    }
    EntityType type=null;
    try {
      Entity ent=getEntity(Integer.parseInt(asym.getEntity_id()));
      type=EntityType.entityTypeFromString(ent.getType());
    }
 catch (    NumberFormatException e) {
      logger.debug(""String_Node_Str"",asym.getEntity_id());
    }
    if (type == null || type == EntityType.POLYMER) {
      seqResChains.add(seqres);
    }
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    addEntities(asym);
  }
  if (structAsyms.isEmpty()) {
    logger.warn(""String_Node_Str"");
  }
  linkEntities();
  for (  List<Chain> model : allModels) {
    structure.addModel(model);
  }
  if (params.isAlignSeqRes() && !params.isHeaderOnly()) {
    logger.debug(""String_Node_Str"");
    alignSeqRes();
  }
 else {
    logger.debug(""String_Node_Str"");
    SeqRes2AtomAligner.storeUnAlignedSeqRes(structure,seqResChains,params.isHeaderOnly());
  }
  StructureTools.cleanUpAltLocs(structure);
  if (!params.isHeaderOnly()) {
    if (params.shouldCreateAtomBonds()) {
      addBonds();
    }
    if (params.shouldCreateAtomCharges()) {
      addCharges();
    }
  }
  if (!params.isHeaderOnly()) {
    addSites();
  }
  if (params.isParseBioAssembly()) {
    Map<Integer,BioAssemblyInfo> bioAssemblies=new HashMap<Integer,BioAssemblyInfo>();
    for (    PdbxStructAssembly psa : strucAssemblies) {
      List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
      for (      PdbxStructAssemblyGen psag : strucAssemblyGens) {
        if (psag.getAssembly_id().equals(psa.getId())) {
          psags.add(psag);
        }
      }
      BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
      List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
      int bioAssemblyId=-1;
      try {
        bioAssemblyId=Integer.parseInt(psa.getId());
      }
 catch (      NumberFormatException e) {
        logger.info(""String_Node_Str"",psa.getId());
      }
      if (bioAssemblyId != -1) {
        int mmSize=0;
        for (        BiologicalAssemblyTransformation transf : transformations) {
          Chain c=structure.getChain(transf.getChainId());
          if (c == null) {
            logger.warn(""String_Node_Str"",transf.getChainId());
            continue;
          }
          if (c.getEntityType() == EntityType.POLYMER && !c.getEntityInfo().getDescription().contains(""String_Node_Str"")) {
            mmSize++;
          }
        }
        BioAssemblyInfo bioAssembly=new BioAssemblyInfo();
        bioAssembly.setId(bioAssemblyId);
        bioAssembly.setMacromolecularSize(mmSize);
        bioAssembly.setTransforms(transformations);
        bioAssemblies.put(bioAssemblyId,bioAssembly);
      }
    }
    structure.getPDBHeader().setBioAssemblies(bioAssemblies);
  }
  setStructNcsOps();
  Map<String,List<SeqMisMatch>> misMatchMap=new HashMap<String,List<SeqMisMatch>>();
  for (  StructRefSeqDif sdif : sequenceDifs) {
    SeqMisMatch misMatch=new SeqMisMatchImpl();
    misMatch.setDetails(sdif.getDetails());
    String insCode=sdif.getPdbx_pdb_ins_code();
    if (insCode != null && insCode.equals(""String_Node_Str""))     insCode=null;
    misMatch.setInsCode(insCode);
    misMatch.setOrigGroup(sdif.getDb_mon_id());
    misMatch.setPdbGroup(sdif.getMon_id());
    misMatch.setPdbResNum(sdif.getPdbx_auth_seq_num());
    misMatch.setUniProtId(sdif.getPdbx_seq_db_accession_code());
    misMatch.setSeqNum(sdif.getSeq_num());
    List<SeqMisMatch> mms=misMatchMap.get(sdif.getPdbx_pdb_strand_id());
    if (mms == null) {
      mms=new ArrayList<SeqMisMatch>();
      misMatchMap.put(sdif.getPdbx_pdb_strand_id(),mms);
    }
    mms.add(misMatch);
  }
  for (  String chainId : misMatchMap.keySet()) {
    Chain chain=structure.getPolyChainByPDB(chainId);
    if (chain == null) {
      logger.warn(""String_Node_Str"" + chainId);
      continue;
    }
    chain.setSeqMisMatches(misMatchMap.get(chainId));
  }
}",0.9981171548117156
16314,"/** 
 * Use DownloadChemCompProvider to grab a gzipped cif record from the PDB. Zip all downloaded cif.gz files into the dictionary.
 * @param recordName is the three-letter chemical component code (i.e. residue name).
 * @return ChemComp matching recordName
 */
private ChemComp downloadAndAdd(String recordName){
  final ChemComp cc=m_dlProvider.getChemComp(recordName);
  final File[] files=new File[1];
  Path cif=m_tempDir.resolve(""String_Node_Str"").resolve(recordName + ""String_Node_Str"");
  files[0]=cif.toFile();
  if (files != null) {
    addToZipFileSystem(m_zipFile,files,m_zipRootDir);
    if (m_removeCif)     for (    File f : files)     f.delete();
  }
  return cc;
}","/** 
 * Use DownloadChemCompProvider to grab a gzipped cif record from the PDB. Zip all downloaded cif.gz files into the dictionary.
 * @param recordName is the three-letter chemical component code (i.e. residue name).
 * @return ChemComp matching recordName
 */
private ChemComp downloadAndAdd(String recordName){
  final ChemComp cc=m_dlProvider.getChemComp(recordName);
  final File[] files=new File[1];
  Path cif=m_tempDir.resolve(""String_Node_Str"").resolve(recordName + ""String_Node_Str"");
  files[0]=cif.toFile();
  if (files[0] != null) {
    addToZipFileSystem(m_zipFile,files,m_zipRootDir);
    if (m_removeCif)     for (    File f : files)     f.delete();
  }
  return cc;
}",0.997805413313826
16315,"/** 
 * Creates bond objects from a LinkRecord as parsed from a PDB file
 * @param linkRecord
 */
public void formLinkRecordBond(LinkRecord linkRecord){
  if (linkRecord.getAltLoc1().equals(""String_Node_Str"") || linkRecord.getAltLoc2().equals(""String_Node_Str""))   return;
  try {
    Map<Integer,Atom> a=getAtomFromRecord(linkRecord.getName1(),linkRecord.getAltLoc1(),linkRecord.getResName1(),linkRecord.getChainID1(),linkRecord.getResSeq1(),linkRecord.getiCode1());
    Map<Integer,Atom> b=getAtomFromRecord(linkRecord.getName2(),linkRecord.getAltLoc2(),linkRecord.getResName2(),linkRecord.getChainID2(),linkRecord.getResSeq2(),linkRecord.getiCode2());
    for (int i=0; i < structure.nrModels(); i++) {
      if (a.containsKey(i) && b.containsKey(i)) {
        new BondImpl(a.get(i),b.get(i),1);
      }
    }
  }
 catch (  StructureException e) {
    if (!params.isParseCAOnly()) {
      logger.warn(""String_Node_Str"",linkRecord.toString());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
  }
}","/** 
 * Creates bond objects from a LinkRecord as parsed from a PDB file
 * @param linkRecord
 */
public void formLinkRecordBond(LinkRecord linkRecord){
  if (linkRecord.getAltLoc1().equals(""String_Node_Str"") || linkRecord.getAltLoc2().equals(""String_Node_Str""))   return;
  try {
    Map<Integer,Atom> a=getAtomFromRecord(linkRecord.getName1(),linkRecord.getAltLoc1(),linkRecord.getResName1(),linkRecord.getChainID1(),linkRecord.getResSeq1(),linkRecord.getiCode1());
    Map<Integer,Atom> b=getAtomFromRecord(linkRecord.getName2(),linkRecord.getAltLoc2(),linkRecord.getResName2(),linkRecord.getChainID2(),linkRecord.getResSeq2(),linkRecord.getiCode2());
    for (int i=0; i < structure.nrModels(); i++) {
      if (a.containsKey(i) && b.containsKey(i)) {
        if (!a.get(i).equals(b.get(i))) {
          new BondImpl(a.get(i),b.get(i),1);
        }
      }
    }
  }
 catch (  StructureException e) {
    if (!params.isParseCAOnly()) {
      logger.warn(""String_Node_Str"",linkRecord.toString());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
  }
}",0.973963355834137
16316,"public void formBondsFromStructConn(List<StructConn> structConn){
  final String symop=""String_Node_Str"";
  List<Bond> ssbonds=new ArrayList<>();
  for (  StructConn conn : structConn) {
    if (!BOND_TYPES_TO_PARSE.contains(conn.getConn_type_id()))     continue;
    String chainId1;
    String chainId2;
    chainId1=conn.getPtnr1_label_asym_id();
    chainId2=conn.getPtnr2_label_asym_id();
    String insCode1=""String_Node_Str"";
    if (!conn.getPdbx_ptnr1_PDB_ins_code().equals(""String_Node_Str""))     insCode1=conn.getPdbx_ptnr1_PDB_ins_code();
    String insCode2=""String_Node_Str"";
    if (!conn.getPdbx_ptnr2_PDB_ins_code().equals(""String_Node_Str""))     insCode2=conn.getPdbx_ptnr2_PDB_ins_code();
    String seqId1=conn.getPtnr1_auth_seq_id();
    String seqId2=conn.getPtnr2_auth_seq_id();
    String resName1=conn.getPtnr1_label_comp_id();
    String resName2=conn.getPtnr2_label_comp_id();
    String atomName1=conn.getPtnr1_label_atom_id();
    String atomName2=conn.getPtnr2_label_atom_id();
    String altLoc1=""String_Node_Str"";
    if (!conn.getPdbx_ptnr1_label_alt_id().equals(""String_Node_Str""))     altLoc1=conn.getPdbx_ptnr1_label_alt_id();
    String altLoc2=""String_Node_Str"";
    if (!conn.getPdbx_ptnr2_label_alt_id().equals(""String_Node_Str""))     altLoc2=conn.getPdbx_ptnr2_label_alt_id();
    if (!conn.getPtnr1_symmetry().equals(symop) || !conn.getPtnr2_symmetry().equals(symop)) {
      logger.info(""String_Node_Str"",atomName1,seqId1,insCode1,atomName2,seqId2,insCode2);
      continue;
    }
    String altLocStr1=altLoc1.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + altLoc1 + ""String_Node_Str"";
    String altLocStr2=altLoc2.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + altLoc2 + ""String_Node_Str"";
    Map<Integer,Atom> a1=null;
    Map<Integer,Atom> a2=null;
    try {
      a1=getAtomFromRecord(atomName1,altLoc1,resName1,chainId1,seqId1,insCode1);
    }
 catch (    StructureException e) {
      logger.warn(""String_Node_Str"",seqId1,insCode1,resName1,chainId1,atomName1,altLocStr1);
      continue;
    }
    try {
      a2=getAtomFromRecord(atomName2,altLoc2,resName2,chainId2,seqId2,insCode2);
    }
 catch (    StructureException e) {
      logger.warn(""String_Node_Str"",seqId2,insCode2,resName2,chainId2,atomName2,altLocStr2);
      continue;
    }
    if (a1 == null) {
      logger.warn(""String_Node_Str"",atomName1,altLocStr1,seqId1,insCode1,resName1,chainId1);
      continue;
    }
    if (a2 == null) {
      logger.warn(""String_Node_Str"",atomName2,altLocStr2,seqId2,insCode2,resName2,chainId2);
      continue;
    }
    for (int i=0; i < structure.nrModels(); i++) {
      Bond bond=null;
      if (a1.containsKey(i) && a2.containsKey(i)) {
        bond=new BondImpl(a1.get(i),a2.get(i),1);
      }
      if (bond != null) {
        if (conn.getConn_type_id().equals(""String_Node_Str"")) {
          ssbonds.add(bond);
        }
      }
    }
  }
  structure.setSSBonds(ssbonds);
}","public void formBondsFromStructConn(List<StructConn> structConn){
  final String symop=""String_Node_Str"";
  List<Bond> ssbonds=new ArrayList<>();
  for (  StructConn conn : structConn) {
    if (!BOND_TYPES_TO_PARSE.contains(conn.getConn_type_id()))     continue;
    String chainId1;
    String chainId2;
    chainId1=conn.getPtnr1_label_asym_id();
    chainId2=conn.getPtnr2_label_asym_id();
    String insCode1=""String_Node_Str"";
    if (!conn.getPdbx_ptnr1_PDB_ins_code().equals(""String_Node_Str""))     insCode1=conn.getPdbx_ptnr1_PDB_ins_code();
    String insCode2=""String_Node_Str"";
    if (!conn.getPdbx_ptnr2_PDB_ins_code().equals(""String_Node_Str""))     insCode2=conn.getPdbx_ptnr2_PDB_ins_code();
    String seqId1=conn.getPtnr1_auth_seq_id();
    String seqId2=conn.getPtnr2_auth_seq_id();
    String resName1=conn.getPtnr1_label_comp_id();
    String resName2=conn.getPtnr2_label_comp_id();
    String atomName1=conn.getPtnr1_label_atom_id();
    String atomName2=conn.getPtnr2_label_atom_id();
    String altLoc1=""String_Node_Str"";
    if (!conn.getPdbx_ptnr1_label_alt_id().equals(""String_Node_Str""))     altLoc1=conn.getPdbx_ptnr1_label_alt_id();
    String altLoc2=""String_Node_Str"";
    if (!conn.getPdbx_ptnr2_label_alt_id().equals(""String_Node_Str""))     altLoc2=conn.getPdbx_ptnr2_label_alt_id();
    if (!conn.getPtnr1_symmetry().equals(symop) || !conn.getPtnr2_symmetry().equals(symop)) {
      logger.info(""String_Node_Str"",atomName1,seqId1,insCode1,atomName2,seqId2,insCode2);
      continue;
    }
    String altLocStr1=altLoc1.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + altLoc1 + ""String_Node_Str"";
    String altLocStr2=altLoc2.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + altLoc2 + ""String_Node_Str"";
    Map<Integer,Atom> a1=null;
    Map<Integer,Atom> a2=null;
    try {
      a1=getAtomFromRecord(atomName1,altLoc1,resName1,chainId1,seqId1,insCode1);
    }
 catch (    StructureException e) {
      logger.warn(""String_Node_Str"",seqId1,insCode1,resName1,chainId1,atomName1,altLocStr1);
      continue;
    }
    try {
      a2=getAtomFromRecord(atomName2,altLoc2,resName2,chainId2,seqId2,insCode2);
    }
 catch (    StructureException e) {
      logger.warn(""String_Node_Str"",seqId2,insCode2,resName2,chainId2,atomName2,altLocStr2);
      continue;
    }
    if (a1 == null) {
      logger.warn(""String_Node_Str"",atomName1,altLocStr1,seqId1,insCode1,resName1,chainId1);
      continue;
    }
    if (a2 == null) {
      logger.warn(""String_Node_Str"",atomName2,altLocStr2,seqId2,insCode2,resName2,chainId2);
      continue;
    }
    for (int i=0; i < structure.nrModels(); i++) {
      Bond bond=null;
      if (a1.containsKey(i) && a2.containsKey(i)) {
        if (!a1.get(i).equals(a2.get(i))) {
          bond=new BondImpl(a1.get(i),a2.get(i),1);
        }
      }
      if (bond != null) {
        if (conn.getConn_type_id().equals(""String_Node_Str"")) {
          ssbonds.add(bond);
        }
      }
    }
  }
  structure.setSSBonds(ssbonds);
}",0.9905723905723904
16317,"private void formDisulfideBond(SSBondImpl disulfideBond){
  try {
    Map<Integer,Atom> a=getAtomFromRecord(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",disulfideBond.getChainID1(),disulfideBond.getResnum1(),disulfideBond.getInsCode1());
    Map<Integer,Atom> b=getAtomFromRecord(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",disulfideBond.getChainID2(),disulfideBond.getResnum2(),disulfideBond.getInsCode2());
    for (int i=0; i < structure.nrModels(); i++) {
      if (a.containsKey(i) && b.containsKey(i)) {
        Bond ssbond=new BondImpl(a.get(i),b.get(i),1);
        structure.addSSBond(ssbond);
      }
    }
  }
 catch (  StructureException e) {
    if (!params.isParseCAOnly()) {
      logger.warn(""String_Node_Str"",disulfideBond.toString());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
  }
}","private void formDisulfideBond(SSBondImpl disulfideBond){
  try {
    Map<Integer,Atom> a=getAtomFromRecord(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",disulfideBond.getChainID1(),disulfideBond.getResnum1(),disulfideBond.getInsCode1());
    Map<Integer,Atom> b=getAtomFromRecord(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",disulfideBond.getChainID2(),disulfideBond.getResnum2(),disulfideBond.getInsCode2());
    for (int i=0; i < structure.nrModels(); i++) {
      if (a.containsKey(i) && b.containsKey(i)) {
        if (!a.get(i).equals(b.get(i))) {
          Bond ssbond=new BondImpl(a.get(i),b.get(i),1);
          structure.addSSBond(ssbond);
        }
      }
    }
  }
 catch (  StructureException e) {
    if (!params.isParseCAOnly()) {
      logger.warn(""String_Node_Str"",disulfideBond.toString());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
  }
}",0.9594438006952491
16318,"@Override public void setAtomInfo(String atomName,int serialNumber,char alternativeLocationId,float x,float y,float z,float occupancy,float temperatureFactor,String element,int charge){
  Atom atom=new AtomImpl();
  Group altGroup=null;
  atom.setPDBserial(serialNumber);
  atom.setName(atomName.trim());
  atom.setElement(Element.valueOfIgnoreCase(element));
  if (alternativeLocationId == MmtfStructure.UNAVAILABLE_CHAR_VALUE) {
    alternativeLocationId=' ';
  }
  if (alternativeLocationId != ' ') {
    altGroup=getCorrectAltLocGroup(alternativeLocationId);
    atom.setAltLoc(alternativeLocationId);
  }
 else {
    atom.setAltLoc(Character.valueOf(' '));
  }
  atom.setX(x);
  atom.setY(y);
  atom.setZ(z);
  atom.setOccupancy(occupancy);
  atom.setTempFactor(temperatureFactor);
  atom.setCharge((short)charge);
  if (altGroup == null) {
    group.addAtom(atom);
  }
 else {
    altGroup.setChain(chain);
    altGroup.addAtom(atom);
  }
  if (!group.hasAtom(atom.getName())) {
    if (group.getPDBName().equals(atom.getGroup().getPDBName())) {
      group.addAtom(atom);
    }
  }
  atomsInGroup.add(atom);
  allAtoms[atomCounter]=atom;
  atomCounter++;
}","@Override public void setAtomInfo(String atomName,int serialNumber,char alternativeLocationId,float x,float y,float z,float occupancy,float temperatureFactor,String element,int charge){
  Atom atom=new AtomImpl();
  Group altGroup=null;
  atom.setPDBserial(serialNumber);
  atom.setName(atomName.trim());
  atom.setElement(Element.valueOfIgnoreCase(element));
  if (alternativeLocationId == MmtfStructure.UNAVAILABLE_CHAR_VALUE) {
    alternativeLocationId=' ';
  }
  if (alternativeLocationId != ' ') {
    altGroup=getCorrectAltLocGroup(alternativeLocationId);
    atom.setAltLoc(alternativeLocationId);
  }
 else {
    atom.setAltLoc(Character.valueOf(' '));
  }
  atom.setX(x);
  atom.setY(y);
  atom.setZ(z);
  atom.setOccupancy(occupancy);
  atom.setTempFactor(temperatureFactor);
  atom.setCharge((short)charge);
  if (altGroup == null) {
    group.addAtom(atom);
  }
 else {
    altGroup.setChain(chain);
    altGroup.addAtom(atom);
  }
  if (!group.hasAtom(atom.getName())) {
    if (group.getPDBName().equals(atom.getGroup().getPDBName())) {
      if (StructureTools.hasNonDeuteratedEquiv(atom,group)) {
      }
 else {
        group.addAtom(atom);
      }
    }
  }
  atomsInGroup.add(atom);
  allAtoms[atomCounter]=atom;
  atomCounter++;
}",0.9469759734879868
16319,"private int calcRotationMatrix(){
  double a11=SxxpSyy + Szz - mxEigenV;
  double a12=SyzmSzy;
  double a13=-SxzmSzx;
  double a14=SxymSyx;
  double a21=SyzmSzy;
  double a22=SxxmSyy - Szz - mxEigenV;
  double a23=SxypSyx;
  double a24=SxzpSzx;
  double a31=a13;
  double a32=a23;
  double a33=Syy - Sxx - Szz- mxEigenV;
  double a34=SyzpSzy;
  double a41=a14;
  double a42=a24;
  double a43=a34;
  double a44=Szz - SxxpSyy - mxEigenV;
  double a3344_4334=a33 * a44 - a43 * a34;
  double a3244_4234=a32 * a44 - a42 * a34;
  double a3243_4233=a32 * a43 - a42 * a33;
  double a3143_4133=a31 * a43 - a41 * a33;
  double a3144_4134=a31 * a44 - a41 * a34;
  double a3142_4132=a31 * a42 - a41 * a32;
  double q1=a22 * a3344_4334 - a23 * a3244_4234 + a24 * a3243_4233;
  double q2=-a21 * a3344_4334 + a23 * a3144_4134 - a24 * a3143_4133;
  double q3=a21 * a3244_4234 - a22 * a3144_4134 + a24 * a3142_4132;
  double q4=-a21 * a3243_4233 + a22 * a3143_4133 - a23 * a3142_4132;
  double qsqr=q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;
  if (qsqr < evecprec) {
    q1=a12 * a3344_4334 - a13 * a3244_4234 + a14 * a3243_4233;
    q2=-a11 * a3344_4334 + a13 * a3144_4134 - a14 * a3143_4133;
    q3=a11 * a3244_4234 - a12 * a3144_4134 + a14 * a3142_4132;
    q4=-a11 * a3243_4233 + a12 * a3143_4133 - a13 * a3142_4132;
    qsqr=q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;
    if (qsqr < evecprec) {
      double a1324_1423=a13 * a24 - a14 * a23, a1224_1422=a12 * a24 - a14 * a22;
      double a1223_1322=a12 * a23 - a13 * a22, a1124_1421=a11 * a24 - a14 * a21;
      double a1123_1321=a11 * a23 - a13 * a21, a1122_1221=a11 * a22 - a12 * a21;
      q1=a42 * a1324_1423 - a43 * a1224_1422 + a44 * a1223_1322;
      q2=-a41 * a1324_1423 + a43 * a1124_1421 - a44 * a1123_1321;
      q3=a41 * a1224_1422 - a42 * a1124_1421 + a44 * a1122_1221;
      q4=-a41 * a1223_1322 + a42 * a1123_1321 - a43 * a1122_1221;
      qsqr=q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;
      if (qsqr < evecprec) {
        q1=a32 * a1324_1423 - a33 * a1224_1422 + a34 * a1223_1322;
        q2=-a31 * a1324_1423 + a33 * a1124_1421 - a34 * a1123_1321;
        q3=a31 * a1224_1422 - a32 * a1124_1421 + a34 * a1122_1221;
        q4=-a31 * a1223_1322 + a32 * a1123_1321 - a33 * a1122_1221;
        qsqr=q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;
        if (qsqr < evecprec) {
          rotmat.setIdentity();
          return 0;
        }
      }
    }
  }
  double normq=Math.sqrt(qsqr);
  q1/=normq;
  q2/=normq;
  q3/=normq;
  q4/=normq;
  double a2=q1 * q1;
  double x2=q2 * q2;
  double y2=q3 * q3;
  double z2=q4 * q4;
  double xy=q2 * q3;
  double az=q1 * q4;
  double zx=q4 * q2;
  double ay=q1 * q3;
  double yz=q3 * q4;
  double ax=q1 * q2;
  rotmat.m00=a2 + x2 - y2 - z2;
  rotmat.m01=2 * (xy + az);
  rotmat.m02=2 * (zx - ay);
  rotmat.m10=2 * (xy - az);
  rotmat.m11=a2 - x2 + y2 - z2;
  rotmat.m12=2 * (yz + ax);
  rotmat.m20=2 * (zx + ay);
  rotmat.m21=2 * (yz - ax);
  rotmat.m22=a2 - x2 - y2 + z2;
  return 1;
}","private int calcRotationMatrix(){
  double a11=SxxpSyy + Szz - mxEigenV;
  double a12=SyzmSzy;
  double a13=-SxzmSzx;
  double a14=SxymSyx;
  double a21=SyzmSzy;
  double a22=SxxmSyy - Szz - mxEigenV;
  double a23=SxypSyx;
  double a24=SxzpSzx;
  double a31=a13;
  double a32=a23;
  double a33=Syy - Sxx - Szz- mxEigenV;
  double a34=SyzpSzy;
  double a41=a14;
  double a42=a24;
  double a43=a34;
  double a44=Szz - SxxpSyy - mxEigenV;
  double a3344_4334=a33 * a44 - a43 * a34;
  double a3244_4234=a32 * a44 - a42 * a34;
  double a3243_4233=a32 * a43 - a42 * a33;
  double a3143_4133=a31 * a43 - a41 * a33;
  double a3144_4134=a31 * a44 - a41 * a34;
  double a3142_4132=a31 * a42 - a41 * a32;
  double q1=a22 * a3344_4334 - a23 * a3244_4234 + a24 * a3243_4233;
  double q2=-a21 * a3344_4334 + a23 * a3144_4134 - a24 * a3143_4133;
  double q3=a21 * a3244_4234 - a22 * a3144_4134 + a24 * a3142_4132;
  double q4=-a21 * a3243_4233 + a22 * a3143_4133 - a23 * a3142_4132;
  double qsqr=q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;
  if (qsqr < evecprec) {
    q1=a12 * a3344_4334 - a13 * a3244_4234 + a14 * a3243_4233;
    q2=-a11 * a3344_4334 + a13 * a3144_4134 - a14 * a3143_4133;
    q3=a11 * a3244_4234 - a12 * a3144_4134 + a14 * a3142_4132;
    q4=-a11 * a3243_4233 + a12 * a3143_4133 - a13 * a3142_4132;
    qsqr=q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;
    if (qsqr < evecprec) {
      double a1324_1423=a13 * a24 - a14 * a23, a1224_1422=a12 * a24 - a14 * a22;
      double a1223_1322=a12 * a23 - a13 * a22, a1124_1421=a11 * a24 - a14 * a21;
      double a1123_1321=a11 * a23 - a13 * a21, a1122_1221=a11 * a22 - a12 * a21;
      q1=a42 * a1324_1423 - a43 * a1224_1422 + a44 * a1223_1322;
      q2=-a41 * a1324_1423 + a43 * a1124_1421 - a44 * a1123_1321;
      q3=a41 * a1224_1422 - a42 * a1124_1421 + a44 * a1122_1221;
      q4=-a41 * a1223_1322 + a42 * a1123_1321 - a43 * a1122_1221;
      qsqr=q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;
      if (qsqr < evecprec) {
        q1=a32 * a1324_1423 - a33 * a1224_1422 + a34 * a1223_1322;
        q2=-a31 * a1324_1423 + a33 * a1124_1421 - a34 * a1123_1321;
        q3=a31 * a1224_1422 - a32 * a1124_1421 + a34 * a1122_1221;
        q4=-a31 * a1223_1322 + a32 * a1123_1321 - a33 * a1122_1221;
        qsqr=q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;
        if (qsqr < evecprec) {
          rotmat.setIdentity();
          return 0;
        }
      }
    }
  }
  double normq=Math.sqrt(qsqr);
  q1/=normq;
  q2/=normq;
  q3/=normq;
  q4/=normq;
  logger.debug(""String_Node_Str"" + q1 + ""String_Node_Str""+ q2+ ""String_Node_Str""+ q3+ ""String_Node_Str""+ q4);
  double a2=q1 * q1;
  double x2=q2 * q2;
  double y2=q3 * q3;
  double z2=q4 * q4;
  double xy=q2 * q3;
  double az=q1 * q4;
  double zx=q4 * q2;
  double ay=q1 * q3;
  double yz=q3 * q4;
  double ax=q1 * q2;
  rotmat.m00=a2 + x2 - y2 - z2;
  rotmat.m01=2 * (xy + az);
  rotmat.m02=2 * (zx - ay);
  rotmat.m10=2 * (xy - az);
  rotmat.m11=a2 - x2 + y2 - z2;
  rotmat.m12=2 * (yz + ax);
  rotmat.m20=2 * (zx + ay);
  rotmat.m21=2 * (yz - ax);
  rotmat.m22=a2 - x2 - y2 + z2;
  return 1;
}",0.9817760106030484
16320,"private int calcRmsd(int len){
  double Sxx2=Sxx * Sxx;
  double Syy2=Syy * Syy;
  double Szz2=Szz * Szz;
  double Sxy2=Sxy * Sxy;
  double Syz2=Syz * Syz;
  double Sxz2=Sxz * Sxz;
  double Syx2=Syx * Syx;
  double Szy2=Szy * Szy;
  double Szx2=Szx * Szx;
  double SyzSzymSyySzz2=2.0 * (Syz * Szy - Syy * Szz);
  double Sxx2Syy2Szz2Syz2Szy2=Syy2 + Szz2 - Sxx2 + Syz2 + Szy2;
  double c2=-2.0 * (Sxx2 + Syy2 + Szz2+ Sxy2+ Syx2+ Sxz2+ Szx2+ Syz2+ Szy2);
  double c1=8.0 * (Sxx * Syz * Szy + Syy * Szx * Sxz + Szz * Sxy * Syx - Sxx * Syy * Szz - Syz * Szx * Sxy - Szy * Syx * Sxz);
  SxzpSzx=Sxz + Szx;
  SyzpSzy=Syz + Szy;
  SxypSyx=Sxy + Syx;
  SyzmSzy=Syz - Szy;
  SxzmSzx=Sxz - Szx;
  SxymSyx=Sxy - Syx;
  SxxpSyy=Sxx + Syy;
  SxxmSyy=Sxx - Syy;
  double Sxy2Sxz2Syx2Szx2=Sxy2 + Sxz2 - Syx2 - Szx2;
  double c0=Sxy2Sxz2Syx2Szx2 * Sxy2Sxz2Syx2Szx2 + (Sxx2Syy2Szz2Syz2Szy2 + SyzSzymSyySzz2) * (Sxx2Syy2Szz2Syz2Szy2 - SyzSzymSyySzz2) + (-(SxzpSzx) * (SyzmSzy) + (SxymSyx) * (SxxmSyy - Szz)) * (-(SxzmSzx) * (SyzpSzy) + (SxymSyx) * (SxxmSyy + Szz)) + (-(SxzpSzx) * (SyzpSzy) - (SxypSyx) * (SxxpSyy - Szz)) * (-(SxzmSzx) * (SyzmSzy) - (SxypSyx) * (SxxpSyy + Szz)) + (+(SxypSyx) * (SyzpSzy) + (SxzpSzx) * (SxxmSyy + Szz)) * (-(SxymSyx) * (SyzmSzy) + (SxzpSzx) * (SxxpSyy + Szz)) + (+(SxypSyx) * (SyzmSzy) + (SxzmSzx) * (SxxmSyy - Szz)) * (-(SxymSyx) * (SyzpSzy) + (SxzmSzx) * (SxxpSyy - Szz));
  mxEigenV=e0;
  int i;
  for (i=0; i < 50; ++i) {
    double oldg=mxEigenV;
    double x2=mxEigenV * mxEigenV;
    double b=(x2 + c2) * mxEigenV;
    double a=b + c1;
    double delta=((a * mxEigenV + c0) / (2.0 * x2 * mxEigenV + b + a));
    mxEigenV-=delta;
    if (Math.abs(mxEigenV - oldg) < Math.abs(evalprec * mxEigenV))     break;
  }
  if (i == 50)   System.err.println(""String_Node_Str"" + i);
  rmsd=Math.sqrt(Math.abs(2.0 * (e0 - mxEigenV) / len));
  return 1;
}","private int calcRmsd(int len){
  double Sxx2=Sxx * Sxx;
  double Syy2=Syy * Syy;
  double Szz2=Szz * Szz;
  double Sxy2=Sxy * Sxy;
  double Syz2=Syz * Syz;
  double Sxz2=Sxz * Sxz;
  double Syx2=Syx * Syx;
  double Szy2=Szy * Szy;
  double Szx2=Szx * Szx;
  double SyzSzymSyySzz2=2.0 * (Syz * Szy - Syy * Szz);
  double Sxx2Syy2Szz2Syz2Szy2=Syy2 + Szz2 - Sxx2 + Syz2 + Szy2;
  double c2=-2.0 * (Sxx2 + Syy2 + Szz2+ Sxy2+ Syx2+ Sxz2+ Szx2+ Syz2+ Szy2);
  double c1=8.0 * (Sxx * Syz * Szy + Syy * Szx * Sxz + Szz * Sxy * Syx - Sxx * Syy * Szz - Syz * Szx * Sxy - Szy * Syx * Sxz);
  SxzpSzx=Sxz + Szx;
  SyzpSzy=Syz + Szy;
  SxypSyx=Sxy + Syx;
  SyzmSzy=Syz - Szy;
  SxzmSzx=Sxz - Szx;
  SxymSyx=Sxy - Syx;
  SxxpSyy=Sxx + Syy;
  SxxmSyy=Sxx - Syy;
  double Sxy2Sxz2Syx2Szx2=Sxy2 + Sxz2 - Syx2 - Szx2;
  double c0=Sxy2Sxz2Syx2Szx2 * Sxy2Sxz2Syx2Szx2 + (Sxx2Syy2Szz2Syz2Szy2 + SyzSzymSyySzz2) * (Sxx2Syy2Szz2Syz2Szy2 - SyzSzymSyySzz2) + (-(SxzpSzx) * (SyzmSzy) + (SxymSyx) * (SxxmSyy - Szz)) * (-(SxzmSzx) * (SyzpSzy) + (SxymSyx) * (SxxmSyy + Szz)) + (-(SxzpSzx) * (SyzpSzy) - (SxypSyx) * (SxxpSyy - Szz)) * (-(SxzmSzx) * (SyzmSzy) - (SxypSyx) * (SxxpSyy + Szz)) + (+(SxypSyx) * (SyzpSzy) + (SxzpSzx) * (SxxmSyy + Szz)) * (-(SxymSyx) * (SyzmSzy) + (SxzpSzx) * (SxxpSyy + Szz)) + (+(SxypSyx) * (SyzmSzy) + (SxzmSzx) * (SxxmSyy - Szz)) * (-(SxymSyx) * (SyzpSzy) + (SxzmSzx) * (SxxpSyy - Szz));
  mxEigenV=e0;
  int i;
  for (i=1; i < 51; ++i) {
    double oldg=mxEigenV;
    double x2=mxEigenV * mxEigenV;
    double b=(x2 + c2) * mxEigenV;
    double a=b + c1;
    double delta=((a * mxEigenV + c0) / (2.0 * x2 * mxEigenV + b + a));
    mxEigenV-=delta;
    if (Math.abs(mxEigenV - oldg) < evalprec)     break;
  }
  if (i == 50) {
    logger.warn(String.format(""String_Node_Str"",i));
  }
 else {
    logger.info(String.format(""String_Node_Str"",i));
  }
  rmsd=Math.sqrt(Math.abs(2.0 * (e0 - mxEigenV) / len));
  return 1;
}",0.9386567953463776
16321,"@Before public void setUp() throws StructureException {
  int size=50;
  Random rnd=new Random();
  cloud1=new Atom[size];
  cloud2=new Atom[size];
  cloud2noise=new Atom[size];
  axis=new AxisAngle4d(0.440,0.302,0.845,1.570);
  translation=new Vector3d(0.345,2.453,5.324);
  transform=new Matrix4d();
  transform.set(axis);
  transform.setTranslation(translation);
  for (int p=0; p < size; p++) {
    Atom a=new AtomImpl();
    a.setCoords(new double[]{rnd.nextInt(100),rnd.nextInt(50),rnd.nextInt(150)});
    cloud1[p]=a;
    cloud2[p]=(Atom)a.clone();
    Atom b=new AtomImpl();
    b.setCoords(new double[]{a.getX() + rnd.nextDouble(),a.getY() + rnd.nextDouble(),a.getZ() + rnd.nextDouble()});
    cloud2noise[p]=b;
  }
  cloud1=Calc.centerAtoms(cloud1);
  cloud2=Calc.centerAtoms(cloud2);
  cloud2noise=Calc.centerAtoms(cloud2noise);
  Calc.transform(cloud2,transform);
  Calc.transform(cloud2noise,transform);
}","@Before public void setUp() throws StructureException {
  int size=500;
  Random rnd=new Random();
  cloud1=new Atom[size];
  cloud2=new Atom[size];
  cloud2noise=new Atom[size];
  axis=new AxisAngle4d(0.440,0.302,0.845,1.570);
  translation=new Vector3d(0.345,2.453,5.324);
  transform=new Matrix4d();
  transform.set(axis);
  transform.setTranslation(translation);
  for (int p=0; p < size; p++) {
    Atom a=new AtomImpl();
    a.setCoords(new double[]{rnd.nextInt(100),rnd.nextInt(50),rnd.nextInt(150)});
    cloud1[p]=a;
    cloud2[p]=(Atom)a.clone();
    Atom b=new AtomImpl();
    b.setCoords(new double[]{a.getX() + rnd.nextDouble(),a.getY() + rnd.nextDouble(),a.getZ() + rnd.nextDouble()});
    cloud2noise[p]=b;
  }
  cloud1=Calc.centerAtoms(cloud1);
  cloud2=Calc.centerAtoms(cloud2);
  cloud2noise=Calc.centerAtoms(cloud2noise);
  Calc.transform(cloud2,transform);
  Calc.transform(cloud2noise,transform);
}",0.9994556341861732
16322,"/** 
 * returns and identical copy of this Group object .
 * @return  and identical copy of this Group object
 */
@Override public Object clone(){
  AminoAcidImpl n=new AminoAcidImpl();
  n.setPDBFlag(has3D());
  n.setResidueNumber(getResidueNumber());
  n.setPDBName(getPDBName());
  n.setAminoType(getAminoType());
  n.setRecordType(recordType);
  for (  Atom atom1 : atoms) {
    Atom atom=(Atom)atom1.clone();
    n.addAtom(atom);
    atom.setGroup(n);
  }
  if (getAltLocs() != null && !getAltLocs().isEmpty()) {
    for (    Group altLocGroup : this.getAltLocs()) {
      Group nAltLocGroup=(Group)altLocGroup.clone();
      n.addAltLoc(nAltLocGroup);
    }
  }
  return n;
}","/** 
 * returns and identical copy of this Group object .
 * @return  and identical copy of this Group object
 */
@Override public Object clone(){
  AminoAcidImpl n=new AminoAcidImpl();
  n.setPDBFlag(has3D());
  n.setResidueNumber(getResidueNumber());
  n.setPDBName(getPDBName());
  n.setAminoType(getAminoType());
  n.setRecordType(recordType);
  for (  Atom atom1 : atoms) {
    Atom atom=(Atom)atom1.clone();
    n.addAtom(atom);
    atom.setGroup(n);
  }
  if (getAltLocs() != null && !getAltLocs().isEmpty()) {
    for (    Group altLocGroup : this.getAltLocs()) {
      Group nAltLocGroup=(Group)altLocGroup.clone();
      n.addAltLoc(nAltLocGroup);
    }
  }
  if (chemComp != null)   n.setChemComp(chemComp);
  return n;
}",0.9639065817409768
16323,"/** 
 * returns and identical copy of this Group object .
 * @return  and identical copy of this Group object
 */
@Override public Object clone(){
  HetatomImpl n=new HetatomImpl();
  n.setPDBFlag(has3D());
  n.setResidueNumber(residueNumber);
  n.setPDBName(getPDBName());
  for (  Atom atom1 : atoms) {
    Atom atom=(Atom)atom1.clone();
    n.addAtom(atom);
    atom.setGroup(n);
  }
  if (altLocs != null) {
    for (    Group altLocGroup : this.altLocs) {
      Group nAltLocGroup=(Group)altLocGroup.clone();
      n.addAltLoc(nAltLocGroup);
    }
  }
  return n;
}","/** 
 * returns and identical copy of this Group object .
 * @return  and identical copy of this Group object
 */
@Override public Object clone(){
  HetatomImpl n=new HetatomImpl();
  n.setPDBFlag(has3D());
  n.setResidueNumber(residueNumber);
  n.setPDBName(getPDBName());
  for (  Atom atom1 : atoms) {
    Atom atom=(Atom)atom1.clone();
    n.addAtom(atom);
    atom.setGroup(n);
  }
  if (altLocs != null) {
    for (    Group altLocGroup : this.altLocs) {
      Group nAltLocGroup=(Group)altLocGroup.clone();
      n.addAltLoc(nAltLocGroup);
    }
  }
  if (chemComp != null)   n.setChemComp(chemComp);
  return n;
}",0.9571788413098236
16324,"/** 
 * Handler for ATOM. Record Format: <pre> ATOM      1  N   ASP A  15     110.964  24.941  59.191  1.00 83.44           N COLUMNS        DATA TYPE       FIELD         DEFINITION --------------------------------------------------------------------------------- 1 -  6        Record name     ""ATOM  "" 7 - 11        Integer         serial        Atom serial number. 13 - 16        Atom            name          Atom name. 17             Character       altLoc        Alternate location indicator. 18 - 20        Residue name    resName       Residue name. 22             Character       chainID       Chain identifier. 23 - 26        Integer         resSeq        Residue sequence number. 27             AChar           iCode         Code for insertion of residues. 31 - 38        Real(8.3)       x             Orthogonal coordinates for X in Angstroms. 39 - 46        Real(8.3)       y             Orthogonal coordinates for Y in Angstroms. 47 - 54        Real(8.3)       z             Orthogonal coordinates for Z in Angstroms. 55 - 60        Real(6.2)       occupancy     Occupancy. 61 - 66        Real(6.2)       tempFactor    Temperature factor. 73 - 76        LString(4)      segID         Segment identifier, left-justified. 77 - 78        LString(2)      element       Element symbol, right-justified. 79 - 80        LString(2)      charge        Charge on the atom. </pre>
 */
private void pdb_ATOM_Handler(String line){
  if (params.isHeaderOnly())   return;
  String chainName=line.substring(21,22);
  if (chainName.equals(""String_Node_Str"")) {
    blankChainIdsPresent=true;
  }
  if (currentChain != null && !currentChain.getName().equals(chainName)) {
    startOfMolecule=true;
  }
  if (startOfMolecule) {
    if (currentChain != null) {
      currentModel.add(currentChain);
      if (currentGroup != null) {
        currentChain.addGroup(currentGroup);
      }
    }
    currentChain=new ChainImpl();
    currentChain.setId(chainName);
    currentChain.setName(chainName);
  }
  if (startOfModel) {
    if (currentModel != null) {
      allModels.add(currentModel);
    }
    currentModel=new ArrayList<>();
  }
  String groupCode3=line.substring(17,20).trim();
  String resNum=line.substring(22,26).trim();
  Character iCode=line.substring(26,27).charAt(0);
  if (iCode == ' ')   iCode=null;
  ResidueNumber residueNumber=new ResidueNumber(chainName,Integer.valueOf(resNum),iCode);
  Character aminoCode1=StructureTools.get1LetterCode(groupCode3);
  String recordName=line.substring(0,6).trim();
  boolean isHetAtomInFile=false;
  if (recordName.equals(""String_Node_Str"")) {
    if (aminoCode1 != null && aminoCode1.equals(StructureTools.UNKNOWN_GROUP_LABEL))     aminoCode1=null;
    isHetAtomInFile=true;
  }
  if (startOfMolecule) {
    currentGroup=getNewGroup(recordName,aminoCode1,groupCode3);
    currentGroup.setPDBName(groupCode3);
    currentGroup.setResidueNumber(residueNumber);
    currentGroup.setHetAtomInFile(isHetAtomInFile);
  }
  startOfModel=false;
  startOfMolecule=false;
  Character altLoc=new Character(line.substring(16,17).charAt(0));
  Group altGroup=null;
  if (!residueNumber.equals(currentGroup.getResidueNumber())) {
    currentChain.addGroup(currentGroup);
    currentGroup.trimToSize();
    currentGroup=getNewGroup(recordName,aminoCode1,groupCode3);
    currentGroup.setPDBName(groupCode3);
    currentGroup.setResidueNumber(residueNumber);
    currentGroup.setHetAtomInFile(isHetAtomInFile);
  }
 else {
    if (!altLoc.equals(' ')) {
      logger.debug(""String_Node_Str"" + currentGroup + ""String_Node_Str""+ altGroup);
      altGroup=getCorrectAltLocGroup(altLoc,recordName,aminoCode1,groupCode3);
      if (altGroup.getChain() == null) {
        altGroup.setChain(currentChain);
      }
    }
  }
  atomCount++;
  if (atomCount == atomCAThreshold) {
    logger.warn(""String_Node_Str"" + atomCAThreshold + ""String_Node_Str"");
    seqResChains.clear();
    switchCAOnly();
  }
  if (atomCount == loadMaxAtoms) {
    logger.warn(""String_Node_Str"",loadMaxAtoms,line);
    return;
  }
  if (atomCount > loadMaxAtoms) {
    return;
  }
  String fullname=line.substring(12,16);
  if (parseCAonly) {
    if (!fullname.equals(""String_Node_Str"")) {
      atomCount--;
      return;
    }
  }
  if (params.getAcceptedAtomNames() != null) {
    boolean found=false;
    for (    String ok : params.getAcceptedAtomNames()) {
      if (ok.equals(fullname.trim())) {
        found=true;
        break;
      }
    }
    if (!found) {
      atomCount--;
      return;
    }
  }
  int pdbnumber=Integer.parseInt(line.substring(6,11).trim());
  AtomImpl atom=new AtomImpl();
  atom.setPDBserial(pdbnumber);
  atom.setAltLoc(altLoc);
  atom.setName(fullname.trim());
  double x=Double.parseDouble(line.substring(30,38).trim());
  double y=Double.parseDouble(line.substring(38,46).trim());
  double z=Double.parseDouble(line.substring(46,54).trim());
  double[] coords=new double[3];
  coords[0]=x;
  coords[1]=y;
  coords[2]=z;
  atom.setCoords(coords);
  float occu=1.0f;
  if (line.length() > 59) {
    try {
      occu=Float.parseFloat(line.substring(54,60).trim());
    }
 catch (    NumberFormatException e) {
    }
  }
  float tempf=0.0f;
  if (line.length() > 65) {
    try {
      tempf=Float.parseFloat(line.substring(60,66).trim());
    }
 catch (    NumberFormatException e) {
    }
  }
  atom.setOccupancy(occu);
  atom.setTempFactor(tempf);
  Element element=Element.R;
  boolean guessElement=true;
  if (line.length() > 77) {
    String elementSymbol=line.substring(76,78).trim();
    if (elementSymbol.isEmpty()) {
      logger.warn(""String_Node_Str"" + ""String_Node_Str"",fullname.trim(),pdbnumber);
    }
 else {
      try {
        element=Element.valueOfIgnoreCase(elementSymbol);
        guessElement=false;
      }
 catch (      IllegalArgumentException e) {
        logger.warn(""String_Node_Str"" + ""String_Node_Str"",elementSymbol,fullname.trim(),pdbnumber);
      }
    }
  }
 else {
    logger.warn(""String_Node_Str"" + ""String_Node_Str"",fullname.trim(),pdbnumber);
  }
  if (guessElement) {
    String elementSymbol=null;
    if (currentGroup.getChemComp() != null) {
      for (      ChemCompAtom a : currentGroup.getChemComp().getAtoms()) {
        if (a.getAtom_id().equals(fullname.trim())) {
          elementSymbol=a.getType_symbol();
          break;
        }
      }
      if (elementSymbol == null) {
        logger.warn(""String_Node_Str"" + ""String_Node_Str"",fullname.trim(),currentGroup.getPDBName());
      }
 else {
        element=Element.valueOfIgnoreCase(elementSymbol);
      }
    }
 else {
      logger.warn(""String_Node_Str"" + ""String_Node_Str"",fullname.trim());
    }
  }
  atom.setElement(element);
  if (altGroup != null) {
    altGroup.addAtom(atom);
    altGroup=null;
  }
 else {
    currentGroup.addAtom(atom);
  }
  if (!currentGroup.hasAtom(atom.getName())) {
    currentGroup.addAtom(atom);
  }
}","/** 
 * Handler for ATOM. Record Format: <pre> ATOM      1  N   ASP A  15     110.964  24.941  59.191  1.00 83.44           N COLUMNS        DATA TYPE       FIELD         DEFINITION --------------------------------------------------------------------------------- 1 -  6        Record name     ""ATOM  "" 7 - 11        Integer         serial        Atom serial number. 13 - 16        Atom            name          Atom name. 17             Character       altLoc        Alternate location indicator. 18 - 20        Residue name    resName       Residue name. 22             Character       chainID       Chain identifier. 23 - 26        Integer         resSeq        Residue sequence number. 27             AChar           iCode         Code for insertion of residues. 31 - 38        Real(8.3)       x             Orthogonal coordinates for X in Angstroms. 39 - 46        Real(8.3)       y             Orthogonal coordinates for Y in Angstroms. 47 - 54        Real(8.3)       z             Orthogonal coordinates for Z in Angstroms. 55 - 60        Real(6.2)       occupancy     Occupancy. 61 - 66        Real(6.2)       tempFactor    Temperature factor. 73 - 76        LString(4)      segID         Segment identifier, left-justified. 77 - 78        LString(2)      element       Element symbol, right-justified. 79 - 80        LString(2)      charge        Charge on the atom. </pre>
 */
private void pdb_ATOM_Handler(String line){
  if (params.isHeaderOnly())   return;
  String chainName=line.substring(21,22);
  if (chainName.equals(""String_Node_Str"")) {
    blankChainIdsPresent=true;
  }
  if (currentChain != null && !currentChain.getName().equals(chainName)) {
    startOfMolecule=true;
  }
  if (startOfMolecule) {
    if (currentChain != null) {
      currentModel.add(currentChain);
      if (currentGroup != null) {
        currentChain.addGroup(currentGroup);
      }
    }
    currentChain=new ChainImpl();
    currentChain.setId(chainName);
    currentChain.setName(chainName);
  }
  if (startOfModel) {
    if (currentModel != null) {
      allModels.add(currentModel);
    }
    currentModel=new ArrayList<>();
  }
  String groupCode3=line.substring(17,20).trim();
  String resNum=line.substring(22,26).trim();
  Character iCode=line.substring(26,27).charAt(0);
  if (iCode == ' ')   iCode=null;
  ResidueNumber residueNumber=new ResidueNumber(chainName,Integer.valueOf(resNum),iCode);
  Character aminoCode1=StructureTools.get1LetterCode(groupCode3);
  String recordName=line.substring(0,6).trim();
  boolean isHetAtomInFile=false;
  if (recordName.equals(""String_Node_Str"")) {
    if (aminoCode1 != null && aminoCode1.equals(StructureTools.UNKNOWN_GROUP_LABEL))     aminoCode1=null;
    isHetAtomInFile=true;
  }
  if (startOfMolecule) {
    currentGroup=getNewGroup(recordName,aminoCode1,groupCode3);
    currentGroup.setPDBName(groupCode3);
    currentGroup.setResidueNumber(residueNumber);
    currentGroup.setHetAtomInFile(isHetAtomInFile);
  }
  startOfModel=false;
  startOfMolecule=false;
  Character altLoc=new Character(line.substring(16,17).charAt(0));
  Group altGroup=null;
  if (!residueNumber.equals(currentGroup.getResidueNumber())) {
    currentChain.addGroup(currentGroup);
    currentGroup.trimToSize();
    currentGroup=getNewGroup(recordName,aminoCode1,groupCode3);
    currentGroup.setPDBName(groupCode3);
    currentGroup.setResidueNumber(residueNumber);
    currentGroup.setHetAtomInFile(isHetAtomInFile);
  }
 else {
    if (!altLoc.equals(' ')) {
      logger.debug(""String_Node_Str"" + currentGroup + ""String_Node_Str""+ altGroup);
      altGroup=getCorrectAltLocGroup(altLoc,recordName,aminoCode1,groupCode3);
      if (altGroup.getChain() == null) {
        altGroup.setChain(currentChain);
      }
    }
  }
  atomCount++;
  if (atomCount == atomCAThreshold) {
    logger.warn(""String_Node_Str"" + atomCAThreshold + ""String_Node_Str"");
    seqResChains.clear();
    switchCAOnly();
  }
  if (atomCount == loadMaxAtoms) {
    logger.warn(""String_Node_Str"",loadMaxAtoms,line);
    return;
  }
  if (atomCount > loadMaxAtoms) {
    return;
  }
  String fullname=line.substring(12,16);
  if (parseCAonly) {
    if (!fullname.equals(""String_Node_Str"")) {
      atomCount--;
      return;
    }
  }
  if (params.getAcceptedAtomNames() != null) {
    boolean found=false;
    for (    String ok : params.getAcceptedAtomNames()) {
      if (ok.equals(fullname.trim())) {
        found=true;
        break;
      }
    }
    if (!found) {
      atomCount--;
      return;
    }
  }
  int pdbnumber=Integer.parseInt(line.substring(6,11).trim());
  AtomImpl atom=new AtomImpl();
  atom.setPDBserial(pdbnumber);
  atom.setAltLoc(altLoc);
  atom.setName(fullname.trim());
  double x=Double.parseDouble(line.substring(30,38).trim());
  double y=Double.parseDouble(line.substring(38,46).trim());
  double z=Double.parseDouble(line.substring(46,54).trim());
  double[] coords=new double[3];
  coords[0]=x;
  coords[1]=y;
  coords[2]=z;
  atom.setCoords(coords);
  float occu=1.0f;
  if (line.length() > 59) {
    try {
      occu=Float.parseFloat(line.substring(54,60).trim());
    }
 catch (    NumberFormatException e) {
    }
  }
  float tempf=0.0f;
  if (line.length() > 65) {
    try {
      tempf=Float.parseFloat(line.substring(60,66).trim());
    }
 catch (    NumberFormatException e) {
    }
  }
  atom.setOccupancy(occu);
  atom.setTempFactor(tempf);
  Element element=Element.R;
  boolean guessElement=true;
  if (line.length() > 77) {
    String elementSymbol=line.substring(76,78).trim();
    if (elementSymbol.isEmpty()) {
      logger.warn(""String_Node_Str"" + ""String_Node_Str"",fullname.trim(),pdbnumber);
    }
 else {
      try {
        element=Element.valueOfIgnoreCase(elementSymbol);
        guessElement=false;
      }
 catch (      IllegalArgumentException e) {
        logger.warn(""String_Node_Str"" + ""String_Node_Str"",elementSymbol,fullname.trim(),pdbnumber);
      }
    }
  }
 else {
    logger.warn(""String_Node_Str"" + ""String_Node_Str"",fullname.trim(),pdbnumber);
  }
  if (guessElement) {
    String elementSymbol=null;
    if (currentGroup.getChemComp() != null) {
      for (      ChemCompAtom a : currentGroup.getChemComp().getAtoms()) {
        if (a.getAtom_id().equals(fullname.trim())) {
          elementSymbol=a.getType_symbol();
          break;
        }
      }
      if (elementSymbol == null) {
        logger.warn(""String_Node_Str"" + ""String_Node_Str"",fullname.trim(),currentGroup.getPDBName());
      }
 else {
        try {
          element=Element.valueOfIgnoreCase(elementSymbol);
        }
 catch (        IllegalArgumentException e) {
          logger.warn(""String_Node_Str"" + ""String_Node_Str"",elementSymbol,fullname.trim(),pdbnumber);
        }
      }
    }
 else {
      logger.warn(""String_Node_Str"" + ""String_Node_Str"",fullname.trim());
    }
  }
  atom.setElement(element);
  if (altGroup != null) {
    altGroup.addAtom(atom);
    altGroup=null;
  }
 else {
    currentGroup.addAtom(atom);
  }
  if (!currentGroup.hasAtom(atom.getName())) {
    currentGroup.addAtom(atom);
  }
}",0.9853742472039002
16325,"private static void showResults(Structure s,String name,QuatSymmetryResults results){
  String title=name + ""String_Node_Str"" + results.getSubunits().getStoichiometry()+ ""String_Node_Str""+ results.getSymmetry();
  if (results.getSubunits().isPseudoSymmetric())   title+=""String_Node_Str"";
  if (results.isLocal())   title+=""String_Node_Str"";
  String script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  AxisAligner aligner=AxisAligner.getInstance(results);
  JmolSymmetryScriptGenerator scriptGenerator=JmolSymmetryScriptGeneratorPointGroup.getInstance(aligner,""String_Node_Str"");
  script+=scriptGenerator.getOrientationWithZoom(0);
  script+=scriptGenerator.drawPolyhedron();
  script+=scriptGenerator.drawAxes();
  script+=scriptGenerator.colorBySymmetry();
  title+=""String_Node_Str"" + results.getMethod();
  script+=""String_Node_Str"";
  BiojavaJmol jmol=new BiojavaJmol();
  jmol.setStructure(s);
  jmol.setTitle(title);
  jmol.evalString(script);
}","private static void showResults(Structure s,String name,QuatSymmetryResults results){
  String title=name + ""String_Node_Str"" + results.getStoichiometry()+ ""String_Node_Str""+ results.getSymmetry();
  if (results.isPseudosymmetric())   title+=""String_Node_Str"";
  if (results.isLocal())   title+=""String_Node_Str"";
  String script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  AxisAligner aligner=AxisAligner.getInstance(results);
  JmolSymmetryScriptGenerator scriptGenerator=JmolSymmetryScriptGeneratorPointGroup.getInstance(aligner,""String_Node_Str"");
  script+=scriptGenerator.getOrientationWithZoom(0);
  script+=scriptGenerator.drawPolyhedron();
  script+=scriptGenerator.drawAxes();
  script+=scriptGenerator.colorBySymmetry();
  title+=""String_Node_Str"" + results.getMethod();
  script+=""String_Node_Str"";
  BiojavaJmol jmol=new BiojavaJmol();
  jmol.setStructure(s);
  jmol.setTitle(title);
  jmol.evalString(script);
}",0.9843096234309624
16326,"/** 
 * Returns a Jmol script that colors subunits to highlight the symmetry within a structure Different subunits should have a consistent color scheme or different shade of the same colors
 * @return Jmol script
 */
@Override public String colorBySymmetry(){
  List<List<Integer>> units=helixAxisAligner.getHelixLayers().getByLargestContacts().getLayerLines();
  units=orientLayerLines(units);
  Subunits subunits=helixAxisAligner.getSubunits();
  List<Integer> modelNumbers=subunits.getModelNumbers();
  List<String> chainIds=subunits.getChainIds();
  List<Integer> clusterIds=subunits.getSequenceClusterIds();
  int clusterCount=Collections.max(clusterIds) + 1;
  Map<Color4f,List<String>> colorMap=new HashMap<Color4f,List<String>>();
  int maxLen=0;
  for (  List<Integer> unit : units) {
    maxLen=Math.max(maxLen,unit.size());
  }
  Color4f[] colors=getSymmetryColors(subunits.getSubunitCount());
  int count=0;
  for (int i=0; i < maxLen; i++) {
    for (int j=0; j < units.size(); j++) {
      int m=units.get(j).size();
      if (i < m) {
        int subunit=units.get(j).get(i);
        int cluster=clusterIds.get(subunit);
        float scale=0.3f + 0.7f * (cluster + 1) / clusterCount;
        Color4f c=new Color4f(colors[count]);
        count++;
        c.scale(scale);
        List<String> ids=colorMap.get(c);
        if (ids == null) {
          ids=new ArrayList<String>();
          colorMap.put(c,ids);
        }
        String id=getChainSpecification(modelNumbers,chainIds,subunit);
        ids.add(id);
      }
    }
  }
  String coloring=defaultColoring + getJmolColorScript(colorMap);
  return coloring;
}","/** 
 * Returns a Jmol script that colors subunits to highlight the symmetry within a structure Different subunits should have a consistent color scheme or different shade of the same colors
 * @return Jmol script
 */
@Override public String colorBySymmetry(){
  List<List<Integer>> units=helixAxisAligner.getHelixLayers().getByLargestContacts().getLayerLines();
  units=orientLayerLines(units);
  QuatSymmetrySubunits subunits=helixAxisAligner.getSubunits();
  List<Integer> modelNumbers=subunits.getModelNumbers();
  List<String> chainIds=subunits.getChainIds();
  List<Integer> clusterIds=subunits.getSequenceClusterIds();
  int clusterCount=Collections.max(clusterIds) + 1;
  Map<Color4f,List<String>> colorMap=new HashMap<Color4f,List<String>>();
  int maxLen=0;
  for (  List<Integer> unit : units) {
    maxLen=Math.max(maxLen,unit.size());
  }
  Color4f[] colors=getSymmetryColors(subunits.getSubunitCount());
  int count=0;
  for (int i=0; i < maxLen; i++) {
    for (int j=0; j < units.size(); j++) {
      int m=units.get(j).size();
      if (i < m) {
        int subunit=units.get(j).get(i);
        int cluster=clusterIds.get(subunit);
        float scale=0.3f + 0.7f * (cluster + 1) / clusterCount;
        Color4f c=new Color4f(colors[count]);
        count++;
        c.scale(scale);
        List<String> ids=colorMap.get(c);
        if (ids == null) {
          ids=new ArrayList<String>();
          colorMap.put(c,ids);
        }
        String id=getChainSpecification(modelNumbers,chainIds,subunit);
        ids.add(id);
      }
    }
  }
  String coloring=defaultColoring + getJmolColorScript(colorMap);
  return coloring;
}",0.996341463414634
16327,"/** 
 * Returns a Jmol script that colors the subunits of a structure by different colors
 * @return
 */
@Override public String colorBySubunit(){
  Subunits subunits=helixAxisAligner.getSubunits();
  List<Integer> modelNumbers=subunits.getModelNumbers();
  List<String> chainIds=subunits.getChainIds();
  List<List<Integer>> orbits=helixAxisAligner.getOrbits();
  Color[] col=ColorBrewer.Spectral.getColorPalette(orbits.size());
  Color4f[] colors=ColorConverter.convertColor4f(col);
  int half=colors.length / 2;
  for (int i=0; i < half; i++) {
    if (i % 2 != 0) {
      Color4f temp=colors[i];
      colors[i]=colors[half + i];
      colors[half + i]=temp;
    }
  }
  Map<Color4f,List<String>> colorMap=new HashMap<Color4f,List<String>>();
  for (int i=0; i < orbits.size(); i++) {
    for (    Integer j : orbits.get(i)) {
      Color4f c=colors[i];
      List<String> ids=colorMap.get(c);
      if (ids == null) {
        ids=new ArrayList<String>();
        colorMap.put(c,ids);
      }
      String id=getChainSpecification(modelNumbers,chainIds,j);
      ids.add(id);
    }
  }
  String coloring=defaultColoring + getJmolColorScript(colorMap);
  return coloring;
}","/** 
 * Returns a Jmol script that colors the subunits of a structure by different colors
 * @return
 */
@Override public String colorBySubunit(){
  QuatSymmetrySubunits subunits=helixAxisAligner.getSubunits();
  List<Integer> modelNumbers=subunits.getModelNumbers();
  List<String> chainIds=subunits.getChainIds();
  List<List<Integer>> orbits=helixAxisAligner.getOrbits();
  Color[] col=ColorBrewer.Spectral.getColorPalette(orbits.size());
  Color4f[] colors=ColorConverter.convertColor4f(col);
  int half=colors.length / 2;
  for (int i=0; i < half; i++) {
    if (i % 2 != 0) {
      Color4f temp=colors[i];
      colors[i]=colors[half + i];
      colors[half + i]=temp;
    }
  }
  Map<Color4f,List<String>> colorMap=new HashMap<Color4f,List<String>>();
  for (int i=0; i < orbits.size(); i++) {
    for (    Integer j : orbits.get(i)) {
      Color4f c=colors[i];
      List<String> ids=colorMap.get(c);
      if (ids == null) {
        ids=new ArrayList<String>();
        colorMap.put(c,ids);
      }
      String id=getChainSpecification(modelNumbers,chainIds,j);
      ids.add(id);
    }
  }
  String coloring=defaultColoring + getJmolColorScript(colorMap);
  return coloring;
}",0.9949238578680204
16328,"/** 
 * Returns a Jmol script that colors subunits by their sequence cluster ids.
 * @return Jmol script
 */
@Override public String colorBySequenceCluster(){
  Subunits subunits=helixAxisAligner.getSubunits();
  int n=subunits.getSubunitCount();
  List<Integer> modelNumbers=subunits.getModelNumbers();
  List<String> chainIds=subunits.getChainIds();
  List<Integer> seqClusterIds=subunits.getSequenceClusterIds();
  int clusters=Collections.max(seqClusterIds) + 1;
  Color[] col=ColorBrewer.BrBG.getColorPalette(clusters);
  Color4f[] colors=ColorConverter.convertColor4f(col);
  Map<Color4f,List<String>> colorMap=new HashMap<Color4f,List<String>>();
  for (int i=0; i < n; i++) {
    Color4f c=colors[seqClusterIds.get(i)];
    List<String> ids=colorMap.get(c);
    if (ids == null) {
      ids=new ArrayList<String>();
      colorMap.put(c,ids);
    }
    String id=getChainSpecification(modelNumbers,chainIds,i);
    ids.add(id);
  }
  String coloring=defaultColoring + getJmolColorScript(colorMap);
  return coloring;
}","/** 
 * Returns a Jmol script that colors subunits by their sequence cluster ids.
 * @return Jmol script
 */
@Override public String colorBySequenceCluster(){
  QuatSymmetrySubunits subunits=helixAxisAligner.getSubunits();
  int n=subunits.getSubunitCount();
  List<Integer> modelNumbers=subunits.getModelNumbers();
  List<String> chainIds=subunits.getChainIds();
  List<Integer> seqClusterIds=subunits.getSequenceClusterIds();
  int clusters=Collections.max(seqClusterIds) + 1;
  Color[] col=ColorBrewer.BrBG.getColorPalette(clusters);
  Color4f[] colors=ColorConverter.convertColor4f(col);
  Map<Color4f,List<String>> colorMap=new HashMap<Color4f,List<String>>();
  for (int i=0; i < n; i++) {
    Color4f c=colors[seqClusterIds.get(i)];
    List<String> ids=colorMap.get(c);
    if (ids == null) {
      ids=new ArrayList<String>();
      colorMap.put(c,ids);
    }
    String id=getChainSpecification(modelNumbers,chainIds,i);
    ids.add(id);
  }
  String coloring=defaultColoring + getJmolColorScript(colorMap);
  return coloring;
}",0.994186046511628
16329,"@Override public String colorBySymmetry(){
  String pointGroup=rotationGroup.getPointGroup();
  Subunits subunits=rotationAxisAligner.getSubunits();
  List<Integer> modelNumbers=subunits.getModelNumbers();
  List<String> chainIds=subunits.getChainIds();
  List<List<Integer>> orbits=rotationAxisAligner.getOrbits();
  int n=subunits.getSubunitCount();
  int fold=rotationGroup.getRotation(0).getFold();
  Map<Color4f,List<String>> colorMap=new HashMap<Color4f,List<String>>();
  if (pointGroup.startsWith(""String_Node_Str"") && n == fold) {
    colorMap=getCnColorMap();
  }
 else   if ((pointGroup.startsWith(""String_Node_Str"") && orbits.size() > 2) || pointGroup.equals(""String_Node_Str"") || pointGroup.equals(""String_Node_Str"")|| pointGroup.equals(""String_Node_Str"")) {
    int nColor=0;
    if (orbits.size() % 2 == 0) {
      nColor=orbits.size() / 2;
    }
 else {
      nColor=(orbits.size() + 1) / 2;
    }
    Color4f[] colors=getSymmetryColors(nColor);
    for (int i=0; i < orbits.size(); i++) {
      int colorIndex=i;
      if (i >= nColor) {
        colorIndex=orbits.size() - 1 - i;
      }
      Color4f c=colors[colorIndex];
      List<String> ids=colorMap.get(c);
      if (ids == null) {
        ids=new ArrayList<String>();
        colorMap.put(c,ids);
      }
      for (      int subunit : orbits.get(i)) {
        String id=getChainSpecification(modelNumbers,chainIds,subunit);
        ids.add(id);
      }
    }
  }
 else {
    Color4f[] colors=getSymmetryColors(orbits.size());
    for (int i=0; i < orbits.size(); i++) {
      Color4f c=new Color4f(colors[i]);
      List<String> ids=colorMap.get(c);
      if (ids == null) {
        ids=new ArrayList<String>();
        colorMap.put(c,ids);
      }
      List<Integer> orbit=orbits.get(i);
      for (int j=0; j < orbit.size(); j++) {
        String id=getChainSpecification(modelNumbers,chainIds,orbit.get(j));
        ids.add(id);
      }
    }
  }
  return defaultColoring + getJmolColorScript(colorMap) + getJmolLigandScript();
}","@Override public String colorBySymmetry(){
  String pointGroup=rotationGroup.getPointGroup();
  QuatSymmetrySubunits subunits=rotationAxisAligner.getSubunits();
  List<Integer> modelNumbers=subunits.getModelNumbers();
  List<String> chainIds=subunits.getChainIds();
  List<List<Integer>> orbits=rotationAxisAligner.getOrbits();
  int n=subunits.getSubunitCount();
  int fold=rotationGroup.getRotation(0).getFold();
  Map<Color4f,List<String>> colorMap=new HashMap<Color4f,List<String>>();
  if (pointGroup.startsWith(""String_Node_Str"") && n == fold) {
    colorMap=getCnColorMap();
  }
 else   if ((pointGroup.startsWith(""String_Node_Str"") && orbits.size() > 2) || pointGroup.equals(""String_Node_Str"") || pointGroup.equals(""String_Node_Str"")|| pointGroup.equals(""String_Node_Str"")) {
    int nColor=0;
    if (orbits.size() % 2 == 0) {
      nColor=orbits.size() / 2;
    }
 else {
      nColor=(orbits.size() + 1) / 2;
    }
    Color4f[] colors=getSymmetryColors(nColor);
    for (int i=0; i < orbits.size(); i++) {
      int colorIndex=i;
      if (i >= nColor) {
        colorIndex=orbits.size() - 1 - i;
      }
      Color4f c=colors[colorIndex];
      List<String> ids=colorMap.get(c);
      if (ids == null) {
        ids=new ArrayList<String>();
        colorMap.put(c,ids);
      }
      for (      int subunit : orbits.get(i)) {
        String id=getChainSpecification(modelNumbers,chainIds,subunit);
        ids.add(id);
      }
    }
  }
 else {
    Color4f[] colors=getSymmetryColors(orbits.size());
    for (int i=0; i < orbits.size(); i++) {
      Color4f c=new Color4f(colors[i]);
      List<String> ids=colorMap.get(c);
      if (ids == null) {
        ids=new ArrayList<String>();
        colorMap.put(c,ids);
      }
      List<Integer> orbit=orbits.get(i);
      for (int j=0; j < orbit.size(); j++) {
        String id=getChainSpecification(modelNumbers,chainIds,orbit.get(j));
        ids.add(id);
      }
    }
  }
  return defaultColoring + getJmolColorScript(colorMap) + getJmolLigandScript();
}",0.343424317617866
16330,"private Map<Color4f,List<String>> getCnColorMap(){
  Subunits subunits=rotationAxisAligner.getSubunits();
  List<Integer> modelNumbers=subunits.getModelNumbers();
  List<String> chainIds=subunits.getChainIds();
  List<List<Integer>> orbits=rotationAxisAligner.getOrbits();
  int fold=rotationGroup.getRotation(0).getFold();
  Map<Color4f,List<String>> colorMap=new HashMap<Color4f,List<String>>();
  Color4f[] colors=getSymmetryColors(fold);
  for (  List<Integer> orbit : orbits) {
    for (int i=0; i < fold; i++) {
      int subunit=orbit.get(i);
      String id=null;
      id=getChainSpecification(modelNumbers,chainIds,subunit);
      Color4f c=colors[i];
      List<String> ids=colorMap.get(c);
      if (ids == null) {
        ids=new ArrayList<String>();
        colorMap.put(c,ids);
      }
      ids.add(id);
    }
  }
  return colorMap;
}","private Map<Color4f,List<String>> getCnColorMap(){
  QuatSymmetrySubunits subunits=rotationAxisAligner.getSubunits();
  List<Integer> modelNumbers=subunits.getModelNumbers();
  List<String> chainIds=subunits.getChainIds();
  List<List<Integer>> orbits=rotationAxisAligner.getOrbits();
  int fold=rotationGroup.getRotation(0).getFold();
  Map<Color4f,List<String>> colorMap=new HashMap<Color4f,List<String>>();
  Color4f[] colors=getSymmetryColors(fold);
  for (  List<Integer> orbit : orbits) {
    for (int i=0; i < fold; i++) {
      int subunit=orbit.get(i);
      String id=null;
      id=getChainSpecification(modelNumbers,chainIds,subunit);
      Color4f c=colors[i];
      List<String> ids=colorMap.get(c);
      if (ids == null) {
        ids=new ArrayList<String>();
        colorMap.put(c,ids);
      }
      ids.add(id);
    }
  }
  return colorMap;
}",0.5654205607476636
16331,"@Override public String colorBySubunit(){
  Subunits subunits=rotationAxisAligner.getSubunits();
  List<Integer> modelNumbers=subunits.getModelNumbers();
  List<String> chainIds=subunits.getChainIds();
  List<List<Integer>> orbits=rotationAxisAligner.getOrbits();
  int fold=rotationGroup.getRotation(0).getFold();
  Color[] col=null;
  Color4f[] colors=null;
  if (fold > 1) {
    col=ColorBrewer.Spectral.getColorPalette(2 * fold);
    colors=ColorConverter.convertColor4f(col);
  }
 else {
    col=ColorBrewer.Spectral.getColorPalette(orbits.size());
    colors=ColorConverter.convertColor4f(col);
  }
  int half=colors.length / 2;
  for (int i=0; i < half; i++) {
    if (i % 2 != 0) {
      Color4f temp=colors[i];
      colors[i]=colors[half + i];
      colors[half + i]=temp;
    }
  }
  Map<Color4f,List<String>> colorMap=new HashMap<Color4f,List<String>>();
  for (int i=0; i < orbits.size(); i++) {
    for (int j=0; j < fold; j++) {
      int colorIndex=i;
      if (fold > 1) {
        if (i % 2 == 0) {
          colorIndex=j;
        }
 else {
          colorIndex=fold + j;
        }
      }
      int subunit=orbits.get(i).get(j);
      Color4f c=colors[colorIndex];
      List<String> ids=colorMap.get(c);
      if (ids == null) {
        ids=new ArrayList<String>();
        colorMap.put(c,ids);
      }
      String id=getChainSpecification(modelNumbers,chainIds,subunit);
      ids.add(id);
    }
  }
  return defaultColoring + getJmolColorScript(colorMap) + getJmolLigandScript();
}","@Override public String colorBySubunit(){
  QuatSymmetrySubunits subunits=rotationAxisAligner.getSubunits();
  List<Integer> modelNumbers=subunits.getModelNumbers();
  List<String> chainIds=subunits.getChainIds();
  List<List<Integer>> orbits=rotationAxisAligner.getOrbits();
  int fold=rotationGroup.getRotation(0).getFold();
  Color[] col=null;
  Color4f[] colors=null;
  if (fold > 1) {
    col=ColorBrewer.Spectral.getColorPalette(2 * fold);
    colors=ColorConverter.convertColor4f(col);
  }
 else {
    col=ColorBrewer.Spectral.getColorPalette(orbits.size());
    colors=ColorConverter.convertColor4f(col);
  }
  int half=colors.length / 2;
  for (int i=0; i < half; i++) {
    if (i % 2 != 0) {
      Color4f temp=colors[i];
      colors[i]=colors[half + i];
      colors[half + i]=temp;
    }
  }
  Map<Color4f,List<String>> colorMap=new HashMap<Color4f,List<String>>();
  for (int i=0; i < orbits.size(); i++) {
    for (int j=0; j < fold; j++) {
      int colorIndex=i;
      if (fold > 1) {
        if (i % 2 == 0) {
          colorIndex=j;
        }
 else {
          colorIndex=fold + j;
        }
      }
      int subunit=orbits.get(i).get(j);
      Color4f c=colors[colorIndex];
      List<String> ids=colorMap.get(c);
      if (ids == null) {
        ids=new ArrayList<String>();
        colorMap.put(c,ids);
      }
      String id=getChainSpecification(modelNumbers,chainIds,subunit);
      ids.add(id);
    }
  }
  return defaultColoring + getJmolColorScript(colorMap) + getJmolLigandScript();
}",0.9960238568588468
16332,"@Override public String colorBySequenceCluster(){
  Subunits subunits=rotationAxisAligner.getSubunits();
  int n=subunits.getSubunitCount();
  List<Integer> modelNumbers=subunits.getModelNumbers();
  List<String> chainIds=subunits.getChainIds();
  List<Integer> seqClusterIds=subunits.getSequenceClusterIds();
  int clusters=Collections.max(seqClusterIds) + 1;
  Color[] col=ColorBrewer.BrBG.getColorPalette(clusters);
  Color4f[] colors=ColorConverter.convertColor4f(col);
  Map<Color4f,List<String>> colorMap=new HashMap<Color4f,List<String>>();
  for (int i=0; i < n; i++) {
    Color4f c=colors[seqClusterIds.get(i)];
    List<String> ids=colorMap.get(c);
    if (ids == null) {
      ids=new ArrayList<String>();
      colorMap.put(c,ids);
    }
    String id=getChainSpecification(modelNumbers,chainIds,i);
    ids.add(id);
  }
  return defaultColoring + getJmolColorScript(colorMap) + getJmolLigandScript();
}","@Override public String colorBySequenceCluster(){
  QuatSymmetrySubunits subunits=rotationAxisAligner.getSubunits();
  int n=subunits.getSubunitCount();
  List<Integer> modelNumbers=subunits.getModelNumbers();
  List<String> chainIds=subunits.getChainIds();
  List<Integer> seqClusterIds=subunits.getClusterIds();
  int clusters=Collections.max(seqClusterIds) + 1;
  Color[] col=ColorBrewer.BrBG.getColorPalette(clusters);
  Color4f[] colors=ColorConverter.convertColor4f(col);
  Map<Color4f,List<String>> colorMap=new HashMap<Color4f,List<String>>();
  for (int i=0; i < n; i++) {
    Color4f c=colors[seqClusterIds.get(i)];
    List<String> ids=colorMap.get(c);
    if (ids == null) {
      ids=new ArrayList<String>();
      colorMap.put(c,ids);
    }
    String id=getChainSpecification(modelNumbers,chainIds,i);
    ids.add(id);
  }
  return defaultColoring + getJmolColorScript(colorMap) + getJmolLigandScript();
}",0.989106753812636
16333,public abstract Subunits getSubunits();,public abstract QuatSymmetrySubunits getSubunits();,0.8666666666666667
16334,"@Override public Subunits getSubunits(){
  return subunits;
}","@Override public QuatSymmetrySubunits getSubunits(){
  return subunits;
}",0.9104477611940298
16335,"public RotationAxisAligner(QuatSymmetryResults results){
  this.subunits=results.getSubunits();
  this.rotationGroup=results.getRotationGroup();
  if (subunits == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (rotationGroup == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (subunits.getSubunitCount() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (rotationGroup.getOrder() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","public RotationAxisAligner(QuatSymmetryResults results){
  this.subunits=new QuatSymmetrySubunits(results.getSubunitClusters());
  this.rotationGroup=results.getRotationGroup();
  if (subunits == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (rotationGroup == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (subunits.getSubunitCount() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (rotationGroup.getOrder() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.9675153643546972
16336,"@Override public Subunits getSubunits(){
  return subunits;
}","@Override public QuatSymmetrySubunits getSubunits(){
  return subunits;
}",0.9104477611940298
16337,"public C2RotationSolver(Subunits subunits,QuatSymmetryParameters parameters){
  if (subunits.getSubunitCount() != 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.subunits=subunits;
  this.parameters=parameters;
}","public C2RotationSolver(QuatSymmetrySubunits subunits,QuatSymmetryParameters parameters){
  if (subunits.getSubunitCount() != 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.subunits=subunits;
  this.parameters=parameters;
}",0.9755102040816328
16338,"private List<Point3d[]> calcRepeatUnits(){
  Set<Integer> uniqueModels=new HashSet<Integer>(subunits.getModelNumbers());
  int modelCount=uniqueModels.size();
  List<Integer> folds=this.subunits.getFolds();
  int maxFold=folds.get(folds.size() - 1);
  List<Point3d[]> repeatTraces=new ArrayList<Point3d[]>();
  List<Integer> models=subunits.getModelNumbers();
  List<Point3d[]> traces=subunits.getTraces();
  if (maxFold % modelCount == 0 && modelCount > 1 && subunits.getSubunitCount() > 3) {
    for (int i=0; i < modelCount; i++) {
      List<Point3d> coords=new ArrayList<Point3d>();
      for (int j=0; j < models.size(); j++) {
        if (models.get(j) == i) {
          coords.addAll(Arrays.asList(traces.get(j)));
        }
      }
      Point3d[] x=new Point3d[coords.size()];
      coords.toArray(x);
      repeatTraces.add(SuperPosition.clonePoint3dArray(x));
    }
  }
 else {
    List<Integer> sequenceClusterIds=subunits.getSequenceClusterIds();
    for (int i=0; i < subunits.getSubunitCount(); i++) {
      if (sequenceClusterIds.get(i) == 0) {
        Point3d[] x=subunits.getTraces().get(i);
        repeatTraces.add(SuperPosition.clonePoint3dArray(x));
      }
    }
  }
  return repeatTraces;
}","private List<Point3d[]> calcRepeatUnits(){
  Set<Integer> uniqueModels=new HashSet<Integer>(subunits.getModelNumbers());
  int modelCount=uniqueModels.size();
  List<Integer> folds=this.subunits.getFolds();
  int maxFold=folds.get(folds.size() - 1);
  List<Point3d[]> repeatTraces=new ArrayList<Point3d[]>();
  List<Integer> models=subunits.getModelNumbers();
  List<Point3d[]> traces=subunits.getTraces();
  if (maxFold % modelCount == 0 && modelCount > 1 && subunits.getSubunitCount() > 3) {
    for (int i=0; i < modelCount; i++) {
      List<Point3d> coords=new ArrayList<Point3d>();
      for (int j=0; j < models.size(); j++) {
        if (models.get(j) == i) {
          coords.addAll(Arrays.asList(traces.get(j)));
        }
      }
      Point3d[] x=new Point3d[coords.size()];
      coords.toArray(x);
      repeatTraces.add(SuperPosition.clonePoint3dArray(x));
    }
  }
 else {
    List<Integer> sequenceClusterIds=subunits.getClusterIds();
    for (int i=0; i < subunits.getSubunitCount(); i++) {
      if (sequenceClusterIds.get(i) == 0) {
        Point3d[] x=subunits.getTraces().get(i);
        repeatTraces.add(SuperPosition.clonePoint3dArray(x));
      }
    }
  }
  return repeatTraces;
}",0.9966969446738232
16339,"public HelicalRepeatUnit(Subunits subunits){
  this.subunits=subunits;
}","public HelicalRepeatUnit(QuatSymmetrySubunits subunits){
  this.subunits=subunits;
}",0.9230769230769232
16340,"private List<Point3d> calcRepeatUnitCenters(){
  Set<Integer> uniqueModels=new HashSet<Integer>(subunits.getModelNumbers());
  int modelCount=uniqueModels.size();
  List<Integer> folds=this.subunits.getFolds();
  int maxFold=folds.get(folds.size() - 1);
  List<Point3d> repeatCenters=new ArrayList<Point3d>();
  List<Point3d> centers=subunits.getCenters();
  List<Integer> models=subunits.getModelNumbers();
  if (maxFold % modelCount == 0 && modelCount > 1 && subunits.getSubunitCount() > 3) {
    for (int i=0; i < modelCount; i++) {
      List<Integer> subunitIndices=new ArrayList<Integer>();
      Point3d p=new Point3d();
      int count=0;
      for (int j=0; j < models.size(); j++) {
        if (models.get(j) == i) {
          p.add(centers.get(j));
          subunitIndices.add(j);
          count++;
        }
      }
      p.scale(1.0 / count);
      repeatCenters.add(p);
      repeatUnitIndices.add(subunitIndices);
    }
  }
 else {
    List<Integer> sequenceClusterIds=subunits.getSequenceClusterIds();
    for (int i=0; i < subunits.getSubunitCount(); i++) {
      List<Integer> subunitIndices=new ArrayList<Integer>(1);
      if (sequenceClusterIds.get(i) == 0) {
        repeatCenters.add(new Point3d(centers.get(i)));
        subunitIndices.add(i);
        repeatUnitIndices.add(subunitIndices);
      }
    }
  }
  if (repeatCenters.size() < 3) {
    repeatCenters.clear();
  }
  return repeatCenters;
}","private List<Point3d> calcRepeatUnitCenters(){
  Set<Integer> uniqueModels=new HashSet<Integer>(subunits.getModelNumbers());
  int modelCount=uniqueModels.size();
  List<Integer> folds=this.subunits.getFolds();
  int maxFold=folds.get(folds.size() - 1);
  List<Point3d> repeatCenters=new ArrayList<Point3d>();
  List<Point3d> centers=subunits.getCenters();
  List<Integer> models=subunits.getModelNumbers();
  if (maxFold % modelCount == 0 && modelCount > 1 && subunits.getSubunitCount() > 3) {
    for (int i=0; i < modelCount; i++) {
      List<Integer> subunitIndices=new ArrayList<Integer>();
      Point3d p=new Point3d();
      int count=0;
      for (int j=0; j < models.size(); j++) {
        if (models.get(j) == i) {
          p.add(centers.get(j));
          subunitIndices.add(j);
          count++;
        }
      }
      p.scale(1.0 / count);
      repeatCenters.add(p);
      repeatUnitIndices.add(subunitIndices);
    }
  }
 else {
    List<Integer> sequenceClusterIds=subunits.getClusterIds();
    for (int i=0; i < subunits.getSubunitCount(); i++) {
      List<Integer> subunitIndices=new ArrayList<Integer>(1);
      if (sequenceClusterIds.get(i) == 0) {
        repeatCenters.add(new Point3d(centers.get(i)));
        subunitIndices.add(i);
        repeatUnitIndices.add(subunitIndices);
      }
    }
  }
  if (repeatCenters.size() < 3) {
    repeatCenters.clear();
  }
  return repeatCenters;
}",0.9971850809289232
16341,"public HelixExtender(Subunits subunits,Helix helix){
  this.subunits=subunits;
  this.helix=helix;
}","public HelixExtender(QuatSymmetrySubunits subunits,Helix helix){
  this.subunits=subunits;
  this.helix=helix;
}",0.9433962264150944
16342,"/** 
 * Returns a permutation of subunit indices for the given helix transformation. An index of -1 is used to indicate subunits that do not superpose onto any other subunit.
 * @param transformation
 * @return
 */
private List<Integer> getPermutation(Matrix4d transformation){
  double rmsdThresholdSq=Math.pow(this.parameters.getRmsdThreshold(),2);
  List<Point3d> centers=subunits.getOriginalCenters();
  List<Integer> seqClusterId=subunits.getSequenceClusterIds();
  List<Integer> permutations=new ArrayList<Integer>(centers.size());
  double[] dSqs=new double[centers.size()];
  boolean[] used=new boolean[centers.size()];
  Arrays.fill(used,false);
  for (int i=0; i < centers.size(); i++) {
    Point3d tCenter=new Point3d(centers.get(i));
    transformation.transform(tCenter);
    int permutation=-1;
    double minDistSq=Double.MAX_VALUE;
    for (int j=0; j < centers.size(); j++) {
      if (seqClusterId.get(i) == seqClusterId.get(j)) {
        if (!used[j]) {
          double dSq=tCenter.distanceSquared(centers.get(j));
          if (dSq < minDistSq && dSq <= rmsdThresholdSq) {
            minDistSq=dSq;
            permutation=j;
            dSqs[j]=dSq;
          }
        }
      }
    }
    if (permutations.size() == permutation) {
      permutation=-1;
    }
    if (permutation != -1) {
      used[permutation]=true;
    }
    permutations.add(permutation);
  }
  return permutations;
}","/** 
 * Returns a permutation of subunit indices for the given helix transformation. An index of -1 is used to indicate subunits that do not superpose onto any other subunit.
 * @param transformation
 * @return
 */
private List<Integer> getPermutation(Matrix4d transformation){
  double rmsdThresholdSq=Math.pow(this.parameters.getRmsdThreshold(),2);
  List<Point3d> centers=subunits.getOriginalCenters();
  List<Integer> seqClusterId=subunits.getClusterIds();
  List<Integer> permutations=new ArrayList<Integer>(centers.size());
  double[] dSqs=new double[centers.size()];
  boolean[] used=new boolean[centers.size()];
  Arrays.fill(used,false);
  for (int i=0; i < centers.size(); i++) {
    Point3d tCenter=new Point3d(centers.get(i));
    transformation.transform(tCenter);
    int permutation=-1;
    double minDistSq=Double.MAX_VALUE;
    for (int j=0; j < centers.size(); j++) {
      if (seqClusterId.get(i) == seqClusterId.get(j)) {
        if (!used[j]) {
          double dSq=tCenter.distanceSquared(centers.get(j));
          if (dSq < minDistSq && dSq <= rmsdThresholdSq) {
            minDistSq=dSq;
            permutation=j;
            dSqs[j]=dSq;
          }
        }
      }
    }
    if (permutations.size() == permutation) {
      permutation=-1;
    }
    if (permutation != -1) {
      used[permutation]=true;
    }
    permutations.add(permutation);
  }
  return permutations;
}",0.9971590909090908
16343,"public HelixSolver(Subunits subunits,int fold,QuatSymmetryParameters parameters){
  this.subunits=subunits;
  this.fold=fold;
  this.parameters=parameters;
}","public HelixSolver(QuatSymmetrySubunits subunits,int fold,QuatSymmetryParameters parameters){
  this.subunits=subunits;
  this.fold=fold;
  this.parameters=parameters;
}",0.9631901840490796
16344,"private void solve(){
  if (!preCheck()) {
    return;
  }
  HelicalRepeatUnit unit=new HelicalRepeatUnit(subunits);
  List<Point3d> repeatUnitCenters=unit.getRepeatUnitCenters();
  List<Point3d[]> repeatUnits=unit.getRepeatUnits();
  Set<List<Integer>> permutations=new HashSet<List<Integer>>();
  double minRise=parameters.getMinimumHelixRise() * fold;
  Map<Integer[],Integer> interactionMap=unit.getInteractingRepeatUnits();
  int maxLayerLineLength=0;
  for (  Entry<Integer[],Integer> entry : interactionMap.entrySet()) {
    Integer[] pair=entry.getKey();
    logger.debug(""String_Node_Str"" + Arrays.toString(pair));
    int contacts=entry.getValue();
    Point3d[] h1=null;
    Point3d[] h2=null;
    h1=SuperPosition.clonePoint3dArray(repeatUnits.get(pair[0]));
    h2=SuperPosition.clonePoint3dArray(repeatUnits.get(pair[1]));
    Matrix4d transformation=SuperPosition.superposeWithTranslation(h1,h2);
    double rmsd=SuperPosition.rmsd(h1,h2);
    double rise=getRise(transformation,repeatUnitCenters.get(pair[0]),repeatUnitCenters.get(pair[1]));
    double angle=getAngle(transformation);
    logger.debug(""String_Node_Str"",rmsd,rise,Math.toDegrees(angle));
    if (rmsd > parameters.getRmsdThreshold()) {
      continue;
    }
    if (Math.abs(rise) < minRise) {
      continue;
    }
    List<Integer> permutation=getPermutation(transformation);
    if (permutations.contains(permutation)) {
      continue;
    }
    permutations.add(permutation);
    logger.debug(""String_Node_Str"" + permutation);
    Set<Integer> permSet=new HashSet<Integer>();
    int count=0;
    boolean valid=true;
    for (int i=0; i < permutation.size(); i++) {
      if (permutation.get(i) == i) {
        valid=false;
        break;
      }
      if (permutation.get(i) != -1) {
        permSet.add(permutation.get(i));
        permSet.add(i);
        count++;
      }
    }
    if (!valid) {
      logger.debug(""String_Node_Str"");
      continue;
    }
    if (permSet.size() != subunits.getSubunitCount()) {
      logger.debug(""String_Node_Str"");
      continue;
    }
    if (count == permutation.size()) {
      continue;
    }
    List<Point3d> point1=new ArrayList<Point3d>();
    List<Point3d> point2=new ArrayList<Point3d>();
    List<Point3d> centers=subunits.getOriginalCenters();
    for (int j=0; j < permutation.size(); j++) {
      if (permutation.get(j) != -1) {
        point1.add(new Point3d(centers.get(j)));
        point2.add(new Point3d(centers.get(permutation.get(j))));
      }
    }
    h1=new Point3d[point1.size()];
    h2=new Point3d[point2.size()];
    point1.toArray(h1);
    point2.toArray(h2);
    double subunitRmsd=0;
    if (point1.size() > 2) {
      transformation=SuperPosition.superposeWithTranslation(h1,h2);
      subunitRmsd=SuperPosition.rmsd(h1,h2);
      rise=getRise(transformation,repeatUnitCenters.get(pair[0]),repeatUnitCenters.get(pair[1]));
      angle=getAngle(transformation);
      logger.debug(""String_Node_Str"",subunitRmsd,rise,Math.toDegrees(angle));
      if (subunitRmsd > parameters.getRmsdThreshold()) {
        continue;
      }
      if (Math.abs(rise) < minRise) {
        continue;
      }
      if (subunitRmsd > parameters.getHelixRmsdToRiseRatio() * Math.abs(rise)) {
        continue;
      }
    }
    point1.clear();
    point2.clear();
    List<Point3d[]> traces=subunits.getTraces();
    for (int j=0; j < permutation.size(); j++) {
      if (permutation.get(j) == -1) {
        continue;
      }
      for (      Point3d p : traces.get(j)) {
        point1.add(new Point3d(p));
      }
      for (      Point3d p : traces.get(permutation.get(j))) {
        point2.add(new Point3d(p));
      }
    }
    h1=new Point3d[point1.size()];
    h2=new Point3d[point2.size()];
    point1.toArray(h1);
    point2.toArray(h2);
    Point3d[] h3=SuperPosition.clonePoint3dArray(h1);
    transformation=SuperPosition.superposeWithTranslation(h1,h2);
    Point3d xtrans=SuperPosition.centroid(h3);
    xtrans.negate();
    double traceRmsd=SuperPosition.rmsd(h1,h2);
    rise=getRise(transformation,repeatUnitCenters.get(pair[0]),repeatUnitCenters.get(pair[1]));
    angle=getAngle(transformation);
    logger.debug(""String_Node_Str"" + traceRmsd);
    logger.debug(""String_Node_Str"" + rise);
    logger.debug(""String_Node_Str"" + Math.toDegrees(angle));
    logger.debug(""String_Node_Str"" + permutation);
    if (traceRmsd > parameters.getRmsdThreshold()) {
      continue;
    }
    if (Math.abs(rise) < minRise) {
      continue;
    }
    if (angle < Math.toRadians(parameters.getMinimumHelixAngle())) {
      continue;
    }
    if (traceRmsd > parameters.getHelixRmsdToRiseRatio() * Math.abs(rise)) {
      continue;
    }
    AxisAngle4d a1=new AxisAngle4d();
    a1.set(transformation);
    Helix helix=new Helix();
    helix.setTransformation(transformation);
    helix.setPermutation(permutation);
    helix.setRise(rise);
    transformation.setElement(3,3,1.0);
    transformation.invert();
    QuatSymmetryScores scores=QuatSuperpositionScorer.calcScores(subunits,transformation,permutation);
    scores.setRmsdCenters(subunitRmsd);
    helix.setScores(scores);
    helix.setFold(fold);
    helix.setContacts(contacts);
    helix.setRepeatUnits(unit.getRepeatUnitIndices());
    logger.debug(""String_Node_Str"" + helix.getLayerLines());
    for (    List<Integer> line : helix.getLayerLines()) {
      maxLayerLineLength=Math.max(maxLayerLineLength,line.size());
    }
    helixLayers.addHelix(helix);
  }
  if (maxLayerLineLength < 3) {
    helixLayers.clear();
  }
  return;
}","private void solve(){
  if (!preCheck()) {
    return;
  }
  HelicalRepeatUnit unit=new HelicalRepeatUnit(subunits);
  List<Point3d> repeatUnitCenters=unit.getRepeatUnitCenters();
  List<Point3d[]> repeatUnits=unit.getRepeatUnits();
  Set<List<Integer>> permutations=new HashSet<List<Integer>>();
  double minRise=parameters.getMinimumHelixRise() * fold;
  Map<Integer[],Integer> interactionMap=unit.getInteractingRepeatUnits();
  int maxLayerLineLength=0;
  for (  Entry<Integer[],Integer> entry : interactionMap.entrySet()) {
    Integer[] pair=entry.getKey();
    logger.debug(""String_Node_Str"" + Arrays.toString(pair));
    int contacts=entry.getValue();
    Point3d[] h1=null;
    Point3d[] h2=null;
    h1=SuperPosition.clonePoint3dArray(repeatUnits.get(pair[0]));
    h2=SuperPosition.clonePoint3dArray(repeatUnits.get(pair[1]));
    Matrix4d transformation=SuperPosition.superposeWithTranslation(h1,h2);
    double rmsd=SuperPosition.rmsd(h1,h2);
    double rise=getRise(transformation,repeatUnitCenters.get(pair[0]),repeatUnitCenters.get(pair[1]));
    double angle=getAngle(transformation);
    logger.debug(""String_Node_Str"",rmsd,rise,Math.toDegrees(angle));
    if (rmsd > parameters.getRmsdThreshold()) {
      continue;
    }
    if (Math.abs(rise) < minRise) {
      continue;
    }
    List<Integer> permutation=getPermutation(transformation);
    if (permutations.contains(permutation)) {
      continue;
    }
    permutations.add(permutation);
    logger.debug(""String_Node_Str"" + permutation);
    Set<Integer> permSet=new HashSet<Integer>();
    int count=0;
    boolean valid=true;
    for (int i=0; i < permutation.size(); i++) {
      if (permutation.get(i) == i) {
        valid=false;
        break;
      }
      if (permutation.get(i) != -1) {
        permSet.add(permutation.get(i));
        permSet.add(i);
        count++;
      }
    }
    if (!valid) {
      logger.debug(""String_Node_Str"");
      continue;
    }
    if (permSet.size() != subunits.getSubunitCount()) {
      logger.debug(""String_Node_Str"");
      continue;
    }
    if (count == permutation.size()) {
      continue;
    }
    List<Point3d> point1=new ArrayList<Point3d>();
    List<Point3d> point2=new ArrayList<Point3d>();
    List<Point3d> centers=subunits.getOriginalCenters();
    for (int j=0; j < permutation.size(); j++) {
      if (permutation.get(j) != -1) {
        point1.add(new Point3d(centers.get(j)));
        point2.add(new Point3d(centers.get(permutation.get(j))));
      }
    }
    h1=new Point3d[point1.size()];
    h2=new Point3d[point2.size()];
    point1.toArray(h1);
    point2.toArray(h2);
    double subunitRmsd=0;
    if (point1.size() > 2) {
      transformation=SuperPosition.superposeWithTranslation(h1,h2);
      subunitRmsd=SuperPosition.rmsd(h1,h2);
      rise=getRise(transformation,repeatUnitCenters.get(pair[0]),repeatUnitCenters.get(pair[1]));
      angle=getAngle(transformation);
      logger.debug(""String_Node_Str"",subunitRmsd,rise,Math.toDegrees(angle));
      if (subunitRmsd > parameters.getRmsdThreshold()) {
        continue;
      }
      if (Math.abs(rise) < minRise) {
        continue;
      }
      if (subunitRmsd > parameters.getHelixRmsdToRiseRatio() * Math.abs(rise)) {
        continue;
      }
    }
    point1.clear();
    point2.clear();
    List<Point3d[]> traces=subunits.getTraces();
    for (int j=0; j < permutation.size(); j++) {
      if (permutation.get(j) == -1) {
        continue;
      }
      for (      Point3d p : traces.get(j)) {
        point1.add(new Point3d(p));
      }
      for (      Point3d p : traces.get(permutation.get(j))) {
        point2.add(new Point3d(p));
      }
    }
    h1=new Point3d[point1.size()];
    h2=new Point3d[point2.size()];
    point1.toArray(h1);
    point2.toArray(h2);
    Point3d[] h3=SuperPosition.clonePoint3dArray(h1);
    transformation=SuperPosition.superposeWithTranslation(h1,h2);
    Point3d xtrans=Calc.getCentroid(h3);
    xtrans.negate();
    double traceRmsd=SuperPosition.rmsd(h1,h2);
    rise=getRise(transformation,repeatUnitCenters.get(pair[0]),repeatUnitCenters.get(pair[1]));
    angle=getAngle(transformation);
    logger.debug(""String_Node_Str"" + traceRmsd);
    logger.debug(""String_Node_Str"" + rise);
    logger.debug(""String_Node_Str"" + Math.toDegrees(angle));
    logger.debug(""String_Node_Str"" + permutation);
    if (traceRmsd > parameters.getRmsdThreshold()) {
      continue;
    }
    if (Math.abs(rise) < minRise) {
      continue;
    }
    if (angle < Math.toRadians(parameters.getMinimumHelixAngle())) {
      continue;
    }
    if (traceRmsd > parameters.getHelixRmsdToRiseRatio() * Math.abs(rise)) {
      continue;
    }
    AxisAngle4d a1=new AxisAngle4d();
    a1.set(transformation);
    Helix helix=new Helix();
    helix.setTransformation(transformation);
    helix.setPermutation(permutation);
    helix.setRise(rise);
    transformation.setElement(3,3,1.0);
    transformation.invert();
    QuatSymmetryScores scores=QuatSuperpositionScorer.calcScores(subunits,transformation,permutation);
    scores.setRmsdCenters(subunitRmsd);
    helix.setScores(scores);
    helix.setFold(fold);
    helix.setContacts(contacts);
    helix.setRepeatUnits(unit.getRepeatUnitIndices());
    logger.debug(""String_Node_Str"" + helix.getLayerLines());
    for (    List<Integer> line : helix.getLayerLines()) {
      maxLayerLineLength=Math.max(maxLayerLineLength,line.size());
    }
    helixLayers.addHelix(helix);
  }
  if (maxLayerLineLength < 3) {
    helixLayers.clear();
  }
  return;
}",0.9978323699421964
16345,"/** 
 * Returns minimum, mean, and maximum RMSD and TM-Score for two superimposed sets of subunits TM score: Yang Zhang and Jeffrey Skolnick, PROTEINS: Structure, Function, and Bioinformatics 57:702–710 (2004)
 * @param subunits subunits to be scored
 * @param transformation transformation matrix
 * @param permutations permutation that determines which subunits are superposed
 * @return
 */
public static QuatSymmetryScores calcScores(Subunits subunits,Matrix4d transformation,List<Integer> permutation){
  QuatSymmetryScores scores=new QuatSymmetryScores();
  double minTm=Double.MAX_VALUE;
  double maxTm=Double.MIN_VALUE;
  double minRmsd=Double.MAX_VALUE;
  double maxRmsd=Double.MIN_VALUE;
  double totalSumTm=0;
  double totalSumDsq=0;
  double totalLength=0;
  Point3d t=new Point3d();
  List<Point3d[]> traces=subunits.getTraces();
  for (int i=0; i < traces.size(); i++) {
    if (permutation.get(i) == -1) {
      continue;
    }
    Point3d[] orig=traces.get(i);
    totalLength+=orig.length;
    Point3d[] perm=traces.get(permutation.get(i));
    int tmLen=Math.max(orig.length,17);
    double d0=1.24 * Math.cbrt(tmLen - 15.0) - 1.8;
    double d0Sq=d0 * d0;
    double sumTm=0;
    double sumDsq=0;
    for (int j=0; j < orig.length; j++) {
      t.set(perm[j]);
      transformation.transform(t);
      double dSq=orig[j].distanceSquared(t);
      sumTm+=1.0 / (1.0 + dSq / d0Sq);
      sumDsq+=dSq;
    }
    double sTm=sumTm / tmLen;
    minTm=Math.min(minTm,sTm);
    maxTm=Math.max(maxTm,sTm);
    double sRmsd=Math.sqrt(sumDsq / orig.length);
    minRmsd=Math.min(minRmsd,sRmsd);
    maxRmsd=Math.max(maxRmsd,sRmsd);
    totalSumTm+=sumTm;
    totalSumDsq+=sumDsq;
  }
  scores.setMinRmsd(minRmsd);
  scores.setMaxRmsd(maxRmsd);
  scores.setMinTm(minTm);
  scores.setMaxTm(maxTm);
  scores.setTm(totalSumTm / totalLength);
  scores.setRmsd(Math.sqrt(totalSumDsq / totalLength));
  calcIntrasubunitScores(subunits,transformation,permutation,scores);
  return scores;
}","/** 
 * Returns minimum, mean, and maximum RMSD and TM-Score for two superimposed sets of subunits TM score: Yang Zhang and Jeffrey Skolnick, PROTEINS: Structure, Function, and Bioinformatics 57:702–710 (2004)
 * @param subunits subunits to be scored
 * @param transformation transformation matrix
 * @param permutations permutation that determines which subunits are superposed
 * @return
 */
public static QuatSymmetryScores calcScores(QuatSymmetrySubunits subunits,Matrix4d transformation,List<Integer> permutation){
  QuatSymmetryScores scores=new QuatSymmetryScores();
  double minTm=Double.MAX_VALUE;
  double maxTm=Double.MIN_VALUE;
  double minRmsd=Double.MAX_VALUE;
  double maxRmsd=Double.MIN_VALUE;
  double totalSumTm=0;
  double totalSumDsq=0;
  double totalLength=0;
  Point3d t=new Point3d();
  List<Point3d[]> traces=subunits.getTraces();
  for (int i=0; i < traces.size(); i++) {
    if (permutation.get(i) == -1) {
      continue;
    }
    Point3d[] orig=traces.get(i);
    totalLength+=orig.length;
    Point3d[] perm=traces.get(permutation.get(i));
    int tmLen=Math.max(orig.length,17);
    double d0=1.24 * Math.cbrt(tmLen - 15.0) - 1.8;
    double d0Sq=d0 * d0;
    double sumTm=0;
    double sumDsq=0;
    for (int j=0; j < orig.length; j++) {
      t.set(perm[j]);
      transformation.transform(t);
      double dSq=orig[j].distanceSquared(t);
      sumTm+=1.0 / (1.0 + dSq / d0Sq);
      sumDsq+=dSq;
    }
    double sTm=sumTm / tmLen;
    minTm=Math.min(minTm,sTm);
    maxTm=Math.max(maxTm,sTm);
    double sRmsd=Math.sqrt(sumDsq / orig.length);
    minRmsd=Math.min(minRmsd,sRmsd);
    maxRmsd=Math.max(maxRmsd,sRmsd);
    totalSumTm+=sumTm;
    totalSumDsq+=sumDsq;
  }
  scores.setMinRmsd(minRmsd);
  scores.setMaxRmsd(maxRmsd);
  scores.setMinTm(minTm);
  scores.setMaxTm(maxTm);
  scores.setTm(totalSumTm / totalLength);
  scores.setRmsd(Math.sqrt(totalSumDsq / totalLength));
  calcIntrasubunitScores(subunits,transformation,permutation,scores);
  return scores;
}",0.996993987975952
16346,"private static void calcIntrasubunitScores(Subunits subunits,Matrix4d transformation,List<Integer> permutation,QuatSymmetryScores scores){
  double totalSumTm=0;
  double totalSumDsq=0;
  double totalLength=0;
  List<Point3d[]> traces=subunits.getTraces();
  for (int i=0; i < traces.size(); i++) {
    if (permutation.get(i) == -1) {
      continue;
    }
    Point3d[] orig=traces.get(i);
    totalLength+=orig.length;
    Point3d[] perm=traces.get(permutation.get(i));
    int tmLen=Math.max(orig.length,17);
    double d0=1.24 * Math.cbrt(tmLen - 15.0) - 1.8;
    double d0Sq=d0 * d0;
    double sumTm=0;
    double sumDsq=0;
    Point3d[] trans=new Point3d[orig.length];
    for (int j=0; j < orig.length; j++) {
      trans[j]=new Point3d(perm[j]);
    }
    SuperPosition.superposeWithTranslation(trans,orig);
    for (int j=0; j < orig.length; j++) {
      double dSq=orig[j].distanceSquared(trans[j]);
      sumTm+=1.0 / (1.0 + dSq / d0Sq);
      sumDsq+=dSq;
    }
    totalSumTm+=sumTm;
    totalSumDsq+=sumDsq;
  }
  scores.setRmsdIntra(Math.sqrt(totalSumDsq / totalLength));
  scores.setTmIntra(totalSumTm / totalLength);
}","private static void calcIntrasubunitScores(QuatSymmetrySubunits subunits,Matrix4d transformation,List<Integer> permutation,QuatSymmetryScores scores){
  double totalSumTm=0;
  double totalSumDsq=0;
  double totalLength=0;
  List<Point3d[]> traces=subunits.getTraces();
  for (int i=0; i < traces.size(); i++) {
    if (permutation.get(i) == -1) {
      continue;
    }
    Point3d[] orig=traces.get(i);
    totalLength+=orig.length;
    Point3d[] perm=traces.get(permutation.get(i));
    int tmLen=Math.max(orig.length,17);
    double d0=1.24 * Math.cbrt(tmLen - 15.0) - 1.8;
    double d0Sq=d0 * d0;
    double sumTm=0;
    double sumDsq=0;
    Point3d[] trans=new Point3d[orig.length];
    for (int j=0; j < orig.length; j++) {
      trans[j]=new Point3d(perm[j]);
    }
    SuperPosition.superposeWithTranslation(trans,orig);
    for (int j=0; j < orig.length; j++) {
      double dSq=orig[j].distanceSquared(trans[j]);
      sumTm+=1.0 / (1.0 + dSq / d0Sq);
      sumDsq+=dSq;
    }
    totalSumTm+=sumTm;
    totalSumDsq+=sumDsq;
  }
  scores.setRmsdIntra(Math.sqrt(totalSumDsq / totalLength));
  scores.setTmIntra(totalSumTm / totalLength);
}",0.9947460595446584
16347,"/** 
 * This method is provisional and should only be used for coloring Subunits. A new coloring schema has to be implemented to allow the coloring of Subunits, without implying one Subunit = one Chain.
 * @return A List of the Chain Ids of each Subunit
 */
public List<String> getChainIds(){
  return clusters.stream().map(c -> c.getSubunits().get(0).getRepresentativeAtoms()[0].getGroup().getChainId()).collect(Collectors.toList());
}","/** 
 * This method is provisional and should only be used for coloring Subunits. A new coloring schema has to be implemented to allow the coloring of Subunits, without implying one Subunit = one Chain.
 * @return A List of the Chain Ids of each Subunit
 */
public List<String> getChainIds(){
  List<String> chains=new ArrayList<String>(getSubunitCount());
  for (int c=0; c < clusters.size(); c++) {
    for (int s=0; s < clusters.get(c).size(); s++)     chains.add(clusters.get(c).getSubunits().get(s).getName());
  }
  return chains;
}",0.6119096509240246
16348,"/** 
 * This method is provisional and should only be used for coloring Subunits. A new coloring schema has to be implemented to allow the coloring of Subunits, without implying one Subunit = one Chain.
 * @return A List of the Model number of each Subunit
 */
public List<Integer> getModelNumbers(){
  List<Integer> models=new ArrayList<Integer>(clusterIds.size());
  for (int c=0; c < clusters.size(); c++) {
    for (int s=0; s < clusters.get(c).size(); s++) {
      Atom[] atoms=clusters.get(c).getAlignedAtomsSubunit(s);
      Chain chain=atoms[0].getGroup().getChain();
      int model=0;
      for (int m=0; m < chain.getStructure().nrModels(); m++) {
        if (chain.getStructure().getModel(m).contains(chain)) {
          model=m;
          break;
        }
      }
      models.add(model);
    }
  }
  return models;
}","/** 
 * This method is provisional and should only be used for coloring Subunits. A new coloring schema has to be implemented to allow the coloring of Subunits, without implying one Subunit = one Chain.
 * @return A List of the Model number of each Subunit
 */
public List<Integer> getModelNumbers(){
  List<Integer> models=new ArrayList<Integer>(getSubunitCount());
  for (int c=0; c < clusters.size(); c++) {
    for (int s=0; s < clusters.get(c).size(); s++) {
      Atom[] atoms=clusters.get(c).getAlignedAtomsSubunit(s);
      Chain chain=atoms[0].getGroup().getChain();
      int model=0;
      for (int m=0; m < chain.getStructure().nrModels(); m++) {
        if (chain.getStructure().getModel(m).contains(chain)) {
          model=m;
          break;
        }
      }
      models.add(model);
    }
  }
  return models;
}",0.9819277108433736
16349,"@Override protected void initCoords(){
  try {
    if (ca1 == null || ca2 == null) {
      if (structure != null)       setStructure(structure);
 else {
        return;
      }
    }
    Structure artificial=DisplayAFP.getAlignedStructure(ca1,ca2);
    PDBHeader header=new PDBHeader();
    String title=afpChain.getAlgorithmName() + ""String_Node_Str"" + afpChain.getVersion()+ ""String_Node_Str""+ afpChain.getName1()+ ""String_Node_Str""+ afpChain.getName2();
    header.setTitle(title);
    artificial.setPDBHeader(header);
    setStructure(artificial);
  }
 catch (  StructureException e) {
    e.printStackTrace();
  }
}","@Override protected void initCoords(){
  try {
    if (ca1 == null || ca2 == null) {
      if (structure != null)       setStructure(structure);
 else {
        return;
      }
    }
    Structure artificial=AlignmentTools.getAlignedStructure(ca1,ca2);
    PDBHeader header=new PDBHeader();
    String title=afpChain.getAlgorithmName() + ""String_Node_Str"" + afpChain.getVersion()+ ""String_Node_Str""+ afpChain.getName1()+ ""String_Node_Str""+ afpChain.getName2();
    header.setTitle(title);
    artificial.setPDBHeader(header);
    setStructure(artificial);
  }
 catch (  StructureException e) {
    e.printStackTrace();
  }
}",0.9823151125401928
16350,"/** 
 * Recursive helper
 * @param symmAxes output list
 * @param prior transformation aligning the first repeat of this axis with the first overall
 * @param level current level
 */
private void getSymmetryAxes(List<Axis> symmAxes,Matrix4d prior,int level,int firstRepeat){
  if (level >= getNumLevels()) {
    return;
  }
  Axis elem=axes.get(level);
  Matrix4d elemOp=elem.getOperator();
  Matrix4d currAxisOp=new Matrix4d(prior);
  currAxisOp.invert();
  currAxisOp.mul(elemOp);
  currAxisOp.mul(prior);
  Axis currAxis=new Axis(currAxisOp,elem.getOrder(),elem.getSymmType(),level,firstRepeat);
  symmAxes.add(currAxis);
  getSymmetryAxes(symmAxes,prior,level + 1,0);
  Matrix4d newPrior=new Matrix4d(elemOp);
  newPrior.mul(prior);
  int childSize=getNumRepeats(level + 1);
  getSymmetryAxes(symmAxes,newPrior,level + 1,childSize);
  for (int d=2; d < elem.getOrder(); d++) {
    newPrior.mul(elemOp,newPrior);
    getSymmetryAxes(symmAxes,newPrior,level + 1,childSize * d);
  }
}","/** 
 * Recursive helper
 * @param symmAxes output list
 * @param prior transformation aligning the first repeat of this axis with the first overall
 * @param level current level
 */
private void getSymmetryAxes(List<Axis> symmAxes,Matrix4d prior,int level,int firstRepeat){
  if (level >= getNumLevels()) {
    return;
  }
  Axis elem=axes.get(level);
  Matrix4d elemOp=elem.getOperator();
  Matrix4d currAxisOp=new Matrix4d(prior);
  currAxisOp.invert();
  currAxisOp.mul(elemOp);
  currAxisOp.mul(prior);
  Axis currAxis=new Axis(currAxisOp,elem.getOrder(),elem.getSymmType(),level,firstRepeat);
  symmAxes.add(currAxis);
  getSymmetryAxes(symmAxes,prior,level + 1,firstRepeat,concat(priorCounts,0));
  Matrix4d newPrior=new Matrix4d(elemOp);
  newPrior.mul(prior);
  int childSize=getNumRepeats(level + 1);
  getSymmetryAxes(symmAxes,newPrior,level + 1,firstRepeat + childSize,concat(priorCounts,1));
  for (int d=2; d < elem.getOrder(); d++) {
    newPrior.mul(elemOp,newPrior);
    getSymmetryAxes(symmAxes,newPrior,level + 1,firstRepeat + childSize * d,concat(priorCounts,d));
  }
}",0.9498553519768564
16351,"/** 
 * Assembly the matched linkages.
 * @param matchedAtomsOfLinkages
 * @param mod
 * @param condition
 * @param ret ModifiedCompound will be stored here.
 */
private void assembleLinkages(List<List<Atom[]>> matchedAtomsOfLinkages,ProteinModification mod,List<ModifiedCompound> ret){
  ModificationCondition condition=mod.getCondition();
  List<ModificationLinkage> modLinks=condition.getLinkages();
  int nLink=matchedAtomsOfLinkages.size();
  int[] indices=new int[nLink];
  Set<ModifiedCompound> identifiedCompounds=new HashSet<ModifiedCompound>();
  while (indices[0] < matchedAtomsOfLinkages.get(0).size()) {
    List<Atom[]> atomLinkages=new ArrayList<Atom[]>(nLink);
    for (int iLink=0; iLink < nLink; iLink++) {
      Atom[] atoms=matchedAtomsOfLinkages.get(iLink).get(indices[iLink]);
      atomLinkages.add(atoms);
    }
    if (matchLinkages(modLinks,atomLinkages)) {
      int n=atomLinkages.size();
      List<StructureAtomLinkage> linkages=new ArrayList<StructureAtomLinkage>(n);
      for (int i=0; i < n; i++) {
        Atom[] linkage=atomLinkages.get(i);
        StructureAtomLinkage link=StructureUtil.getStructureAtomLinkage(linkage[0],residues.contains(linkage[0].getGroup()),linkage[1],residues.contains(linkage[1].getGroup()));
        linkages.add(link);
      }
      ModifiedCompound mc=new ModifiedCompoundImpl(mod,linkages);
      if (!identifiedCompounds.contains(mc)) {
        ret.add(mc);
        identifiedCompounds.add(mc);
      }
    }
    int i=nLink - 1;
    while (i >= 0) {
      if (i == 0 || indices[i] < matchedAtomsOfLinkages.get(i).size() - 1) {
        indices[i]++;
        break;
      }
 else {
        indices[i]=0;
        i--;
      }
    }
  }
}","/** 
 * Assembly the matched linkages
 * @param matchedAtomsOfLinkages
 * @param mod
 * @param ret ModifiedCompound will be stored here
 */
private void assembleLinkages(List<List<Atom[]>> matchedAtomsOfLinkages,ProteinModification mod,List<ModifiedCompound> ret){
  ModificationCondition condition=mod.getCondition();
  List<ModificationLinkage> modLinks=condition.getLinkages();
  int nLink=matchedAtomsOfLinkages.size();
  int[] indices=new int[nLink];
  Set<ModifiedCompound> identifiedCompounds=new HashSet<ModifiedCompound>();
  while (indices[0] < matchedAtomsOfLinkages.get(0).size()) {
    List<Atom[]> atomLinkages=new ArrayList<Atom[]>(nLink);
    for (int iLink=0; iLink < nLink; iLink++) {
      Atom[] atoms=matchedAtomsOfLinkages.get(iLink).get(indices[iLink]);
      atomLinkages.add(atoms);
    }
    if (matchLinkages(modLinks,atomLinkages)) {
      int n=atomLinkages.size();
      List<StructureAtomLinkage> linkages=new ArrayList<StructureAtomLinkage>(n);
      for (int i=0; i < n; i++) {
        Atom[] linkage=atomLinkages.get(i);
        StructureAtomLinkage link=StructureUtil.getStructureAtomLinkage(linkage[0],residues.contains(linkage[0].getGroup()),linkage[1],residues.contains(linkage[1].getGroup()));
        linkages.add(link);
      }
      ModifiedCompound mc=new ModifiedCompoundImpl(mod,linkages);
      if (!identifiedCompounds.contains(mc)) {
        ret.add(mc);
        identifiedCompounds.add(mc);
      }
    }
    int i=nLink - 1;
    while (i >= 0) {
      if (i == 0 || indices[i] < matchedAtomsOfLinkages.get(i).size() - 1) {
        indices[i]++;
        break;
      }
 else {
        indices[i]=0;
        i--;
      }
    }
  }
}",0.9846244825547014
16352,"/** 
 * Identify a set of modifications in a a list of chains.
 * @param chains query {@link Chain}s.
 * @param potentialModifications query {@link ProteinModification}s.
 */
public void identify(final List<Chain> chains,final Set<ProteinModification> potentialModifications){
  if (chains == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (potentialModifications == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  reset();
  if (potentialModifications.isEmpty()) {
    return;
  }
  Map<String,Chain> mapChainIdChain=new HashMap<String,Chain>(chains.size());
  residues=new ArrayList<Group>();
  List<Group> ligands=new ArrayList<Group>();
  Map<Component,Set<Group>> mapCompGroups=new HashMap<Component,Set<Group>>();
  for (  Chain chain : chains) {
    mapChainIdChain.put(chain.getChainID(),chain);
    List<Group> ress=StructureUtil.getAminoAcids(chain);
    List<Group> ligs=StructureTools.filterLigands(chain.getAtomGroups());
    residues.addAll(ress);
    residues.removeAll(ligs);
    ligands.addAll(ligs);
    addModificationGroups(potentialModifications,ress,ligs,mapCompGroups);
  }
  if (residues.isEmpty()) {
    String pdbId=""String_Node_Str"";
    if (chains.size() > 0) {
      Structure struc=chains.get(0).getParent();
      if (struc != null)       pdbId=struc.getPDBCode();
    }
    logger.warn(""String_Node_Str"",pdbId);
  }
  List<ModifiedCompound> modComps=new ArrayList<ModifiedCompound>();
  for (  ProteinModification mod : potentialModifications) {
    ModificationCondition condition=mod.getCondition();
    List<Component> components=condition.getComponents();
    if (!mapCompGroups.keySet().containsAll(components)) {
      continue;
    }
    int sizeComps=components.size();
    if (sizeComps == 1) {
      processCrosslink1(mapCompGroups,modComps,mod,components);
    }
 else {
      processMultiCrosslink(mapCompGroups,modComps,mod,condition);
    }
  }
  if (recordAdditionalAttachments) {
    for (    ModifiedCompound mc : modComps) {
      identifyAdditionalAttachments(mc,ligands,mapChainIdChain);
    }
  }
  mergeModComps(modComps);
  identifiedModifiedCompounds.addAll(modComps);
  if (recordUnidentifiableModifiedCompounds) {
    recordUnidentifiableAtomLinkages(modComps,ligands);
    recordUnidentifiableModifiedResidues(modComps);
  }
}","/** 
 * Identify a set of modifications in a a list of chains.
 * @param chains query {@link Chain}s.
 * @param potentialModifications query {@link ProteinModification}s.
 */
public void identify(final List<Chain> chains,final Set<ProteinModification> potentialModifications){
  if (chains == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (potentialModifications == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  reset();
  if (potentialModifications.isEmpty()) {
    return;
  }
  residues=new ArrayList<Group>();
  List<Group> ligands=new ArrayList<Group>();
  Map<Component,Set<Group>> mapCompGroups=new HashMap<Component,Set<Group>>();
  for (  Chain chain : chains) {
    List<Group> ress=StructureUtil.getAminoAcids(chain);
    List<Group> ligs=StructureTools.filterLigands(chain.getAtomGroups());
    residues.addAll(ress);
    residues.removeAll(ligs);
    ligands.addAll(ligs);
    addModificationGroups(potentialModifications,ress,ligs,mapCompGroups);
  }
  if (residues.isEmpty()) {
    String pdbId=""String_Node_Str"";
    if (chains.size() > 0) {
      Structure struc=chains.get(0).getParent();
      if (struc != null)       pdbId=struc.getPDBCode();
    }
    logger.warn(""String_Node_Str"",pdbId);
  }
  List<ModifiedCompound> modComps=new ArrayList<ModifiedCompound>();
  for (  ProteinModification mod : potentialModifications) {
    ModificationCondition condition=mod.getCondition();
    List<Component> components=condition.getComponents();
    if (!mapCompGroups.keySet().containsAll(components)) {
      continue;
    }
    int sizeComps=components.size();
    if (sizeComps == 1) {
      processCrosslink1(mapCompGroups,modComps,mod,components);
    }
 else {
      processMultiCrosslink(mapCompGroups,modComps,mod,condition);
    }
  }
  if (recordAdditionalAttachments) {
    for (    ModifiedCompound mc : modComps) {
      identifyAdditionalAttachments(mc,ligands,chains);
    }
  }
  mergeModComps(modComps);
  identifiedModifiedCompounds.addAll(modComps);
  if (recordUnidentifiableModifiedCompounds) {
    recordUnidentifiableAtomLinkages(modComps,ligands);
    recordUnidentifiableModifiedResidues(modComps);
  }
}",0.9044052863436124
16353,"private void recordUnidentifiableModifiedResidues(List<ModifiedCompound> modComps){
  Set<StructureGroup> identifiedComps=new HashSet<StructureGroup>();
  for (  ModifiedCompound mc : modComps) {
    identifiedComps.addAll(mc.getGroups(true));
  }
  for (  Group group : residues) {
    if (group.getType().equals(GroupType.HETATM)) {
      StructureGroup strucGroup=StructureUtil.getStructureGroup(group,true);
      if (!identifiedComps.contains(strucGroup)) {
        unidentifiableModifiedResidues.add(strucGroup);
      }
    }
  }
}","private void recordUnidentifiableModifiedResidues(List<ModifiedCompound> modComps){
  Set<StructureGroup> identifiedComps=new HashSet<StructureGroup>();
  for (  ModifiedCompound mc : modComps) {
    identifiedComps.addAll(mc.getGroups(true));
  }
  for (  Group group : residues) {
    if (group.getType().equals(GroupType.HETATM)) {
      StructureGroup strucGroup=StructureUtil.getStructureGroup(group,true);
      strucGroup.setChainId(group.getChainId());
      if (!identifiedComps.contains(strucGroup)) {
        unidentifiableModifiedResidues.add(strucGroup);
      }
    }
  }
}",0.9564444444444444
16354,"/** 
 * identify additional groups that are not directly attached to amino acids.
 * @param mc {@link ModifiedCompound}.
 * @param chain a {@link Chain}.
 * @return a list of added groups.
 */
private void identifyAdditionalAttachments(ModifiedCompound mc,List<Group> ligands,Map<String,Chain> mapChainIdChain){
  if (ligands.isEmpty()) {
    return;
  }
  List<Group> identifiedGroups=new ArrayList<Group>();
  for (  StructureGroup num : mc.getGroups(false)) {
    Group group;
    try {
      ResidueNumber resNum=new ResidueNumber();
      resNum.setChainId(num.getChainId());
      resNum.setSeqNum(num.getResidueNumber());
      resNum.setInsCode(num.getInsCode());
      group=mapChainIdChain.get(num.getChainId()).getGroupByPDB(resNum);
    }
 catch (    StructureException e) {
      logger.error(""String_Node_Str"",e);
      continue;
    }
    identifiedGroups.add(group);
  }
  int start=0;
  int n=identifiedGroups.size();
  while (n > start) {
    for (    Group group1 : ligands) {
      for (int i=start; i < n; i++) {
        Group group2=identifiedGroups.get(i);
        if (!identifiedGroups.contains(group1)) {
          List<Atom[]> linkedAtoms=StructureUtil.findAtomLinkages(group1,group2,false,bondLengthTolerance);
          if (!linkedAtoms.isEmpty()) {
            for (            Atom[] atoms : linkedAtoms) {
              mc.addAtomLinkage(StructureUtil.getStructureAtomLinkage(atoms[0],false,atoms[1],false));
            }
            identifiedGroups.add(group1);
            break;
          }
        }
      }
    }
    start=n;
    n=identifiedGroups.size();
  }
}","/** 
 * identify additional groups that are not directly attached to amino acids.
 * @param mc {@link ModifiedCompound}
 * @param ligands {@link Group}
 * @param chains List of {@link Chain}s
 * @return a list of added groups
 */
private void identifyAdditionalAttachments(ModifiedCompound mc,List<Group> ligands,List<Chain> chains){
  if (ligands.isEmpty()) {
    return;
  }
  List<Group> identifiedGroups=new ArrayList<Group>();
  for (  StructureGroup num : mc.getGroups(false)) {
    Group group;
    try {
      ResidueNumber resNum=new ResidueNumber();
      resNum.setChainId(num.getChainId());
      resNum.setSeqNum(num.getResidueNumber());
      resNum.setInsCode(num.getInsCode());
      group=getGroup(num,chains);
    }
 catch (    StructureException e) {
      logger.error(""String_Node_Str"",e);
      continue;
    }
    identifiedGroups.add(group);
  }
  int start=0;
  int n=identifiedGroups.size();
  while (n > start) {
    for (    Group group1 : ligands) {
      for (int i=start; i < n; i++) {
        Group group2=identifiedGroups.get(i);
        if (!identifiedGroups.contains(group1)) {
          List<Atom[]> linkedAtoms=StructureUtil.findAtomLinkages(group1,group2,false,bondLengthTolerance);
          if (!linkedAtoms.isEmpty()) {
            for (            Atom[] atoms : linkedAtoms) {
              mc.addAtomLinkage(StructureUtil.getStructureAtomLinkage(atoms[0],false,atoms[1],false));
            }
            identifiedGroups.add(group1);
            break;
          }
        }
      }
    }
    start=n;
    n=identifiedGroups.size();
  }
}",0.7904492617027961
16355,"/** 
 * @param recordUnidentifiableAtomLinkages true if choosing to record unidentifiableatoms; false, otherwise.
 * @see #getRecordUnidentifiableCompounds
 * @see #getUnidentifiableModifiedResidues
 * @see #getUnidentifiableAtomLinkages
 */
public void setRecordUnidentifiableCompounds(boolean recordUnidentifiableModifiedCompounds){
  this.recordUnidentifiableModifiedCompounds=recordUnidentifiableModifiedCompounds;
}","/** 
 * @param recordUnidentifiableModifiedCompounds true if choosing to record unidentifiableatoms; false, otherwise.
 * @see #getRecordUnidentifiableCompounds
 * @see #getUnidentifiableModifiedResidues
 * @see #getUnidentifiableAtomLinkages
 */
public void setRecordUnidentifiableCompounds(boolean recordUnidentifiableModifiedCompounds){
  this.recordUnidentifiableModifiedCompounds=recordUnidentifiableModifiedCompounds;
}",0.9680473372781064
16356,"/** 
 * @param atom a {@link Atom} in structure.
 * @param isParentAminoAcid true if the containing group is an amino acid.
 * @return the {@link StructureAtom} of the atom.
 */
public static StructureAtom getStructureAtom(Atom atom,boolean isParentAminoAcid){
  StructureGroup strucGroup=getStructureGroup(atom.getGroup(),isParentAminoAcid);
  return new StructureAtom(strucGroup,atom.getName());
}","/** 
 * @param atom a {@link Atom} in structure.
 * @param isParentAminoAcid true if the containing group is an amino acid.
 * @return the {@link StructureAtom} of the atom.
 */
public static StructureAtom getStructureAtom(Atom atom,boolean isParentAminoAcid){
  Group g=atom.getGroup();
  String chainId=g.getChainId();
  StructureGroup strucGroup=getStructureGroup(g,isParentAminoAcid);
  strucGroup.setChainId(chainId);
  return new StructureAtom(strucGroup,atom.getName());
}",0.7767653758542141
16357,"/** 
 * Find a linkage between two groups within tolerance of bond length.
 * @param group1 the first {@link Group}.
 * @param group2 the second {@link Group}.
 * @param nameOfAtomOnGroup1 atom name of the first group.
 * @param nameOfAtomOnGroup2 atom name of the second group.
 * @param bondLengthTolerance bond length error tolerance.
 * @return an array of two Atoms that form bond between each otherif found; null, otherwise.
 */
public static Atom[] findLinkage(final Group group1,final Group group2,String nameOfAtomOnGroup1,String nameOfAtomOnGroup2,double bondLengthTolerance){
  Atom[] ret=new Atom[2];
  double distance;
  ret[0]=group1.getAtom(nameOfAtomOnGroup1);
  ret[1]=group2.getAtom(nameOfAtomOnGroup2);
  if (ret[0] == null || ret[1] == null) {
    return null;
  }
  distance=Calc.getDistance(ret[0],ret[1]);
  float radiusOfAtom1=ret[0].getElement().getCovalentRadius();
  float radiusOfAtom2=ret[1].getElement().getCovalentRadius();
  if (Math.abs(distance - radiusOfAtom1 - radiusOfAtom2) > bondLengthTolerance) {
    return null;
  }
  return ret;
}","/** 
 * Find a linkage between two groups within tolerance of bond length.
 * @param group1 the first {@link Group}.
 * @param group2 the second {@link Group}.
 * @param nameOfAtomOnGroup1 atom name of the first group.
 * @param nameOfAtomOnGroup2 atom name of the second group.
 * @param bondLengthTolerance bond length error tolerance.
 * @return an array of two Atoms that form bond between each otherif found; null, otherwise.
 */
public static Atom[] findLinkage(final Group group1,final Group group2,String nameOfAtomOnGroup1,String nameOfAtomOnGroup2,double bondLengthTolerance){
  Atom[] ret=new Atom[2];
  ret[0]=group1.getAtom(nameOfAtomOnGroup1);
  ret[1]=group2.getAtom(nameOfAtomOnGroup2);
  if (ret[0] == null || ret[1] == null) {
    return null;
  }
  Atom a1=ret[0];
  Atom a2=ret[1];
  boolean hasBond=a1.hasBond(a2);
  if (hasBond) {
    return ret;
  }
  double distance=Calc.getDistance(a1,a2);
  float radiusOfAtom1=ret[0].getElement().getCovalentRadius();
  float radiusOfAtom2=ret[1].getElement().getCovalentRadius();
  if (Math.abs(distance - radiusOfAtom1 - radiusOfAtom2) > bondLengthTolerance) {
    return null;
  }
  return ret;
}",0.915360501567398
16358,"public List<ModifiedCompound> testXMLSerialization(String pdbId){
  String xml=null;
  ModifiedCompound currentMC=null;
  List<ModifiedCompound> all=new ArrayList<ModifiedCompound>();
  try {
    Structure struc=TmpAtomCache.cache.getStructure(pdbId);
    ProteinModificationIdentifier parser=new ProteinModificationIdentifier();
    for (    Chain c : struc.getChains()) {
      parser.identify(c,ProteinModificationRegistry.allModifications());
      Set<ModifiedCompound> mcs=parser.getIdentifiedModifiedCompound();
      for (      ModifiedCompound mc : mcs) {
        currentMC=mc;
        xml=doXMLSerialization(mc);
        ModifiedCompound newMC=getModifiedCompoundFromXML(xml);
        String xml2=doXMLSerialization(newMC);
        assertEquals(xml,xml2);
        all.add(mc);
      }
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",pdbId);
    logger.error(currentMC.getDescription());
    logger.error(xml,e);
    fail(e.getMessage());
  }
  xml=null;
  currentMC=null;
  return all;
}","public List<ModifiedCompound> testXMLSerialization(String pdbId){
  String xml=null;
  ModifiedCompound currentMC=null;
  List<ModifiedCompound> all=new ArrayList<ModifiedCompound>();
  try {
    Structure struc=TmpAtomCache.cache.getStructure(pdbId);
    ProteinModificationIdentifier parser=new ProteinModificationIdentifier();
    for (    Chain c : struc.getChains()) {
      parser.identify(c,ProteinModificationRegistry.allModifications());
      Set<ModifiedCompound> mcs=parser.getIdentifiedModifiedCompound();
      for (      ModifiedCompound mc : mcs) {
        currentMC=mc;
        xml=doXMLSerialization(mc);
        ModifiedCompound newMC=getModifiedCompoundFromXML(xml);
        String xml2=doXMLSerialization(newMC);
        assertEquals(xml,xml2);
        all.add(mc);
      }
    }
  }
 catch (  Exception e) {
    logger.error(e.getMessage(),e);
    logger.error(""String_Node_Str"",pdbId);
    logger.error(currentMC.getDescription());
    logger.error(xml,e);
    fail(e.getMessage());
  }
  xml=null;
  currentMC=null;
  return all;
}",0.982642237222758
16359,"public static String[][] setUpLongTest(){
  String[][] strucs=new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",null}};
  return strucs;
}","public static String[][] setUpLongTest(){
  String[][] strucs=new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",null},{""String_Node_Str"",null},{""String_Node_Str"",null},{""String_Node_Str"",null},{""String_Node_Str"",null},{""String_Node_Str"",null},{""String_Node_Str"",null}};
  return strucs;
}",0.9878306019795554
16360,"private void printResult(String pdbId,ProteinModificationIdentifier parser,boolean recordUnidentifiable){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(pdbId);
  sb.append(""String_Node_Str"");
  Set<ModifiedCompound> mcs=parser.getIdentifiedModifiedCompound();
  int i=0;
  for (  ModifiedCompound mc : mcs) {
    sb.append(""String_Node_Str"");
    sb.append(++i);
    sb.append(""String_Node_Str"");
    sb.append(mc);
    sb.append('\n');
  }
  if (recordUnidentifiable) {
    Set<StructureGroup> unidentifiedModifiedResidues=parser.getUnidentifiableModifiedResidues();
    i=0;
    for (    StructureGroup group : unidentifiedModifiedResidues) {
      sb.append(""String_Node_Str"");
      sb.append(++i);
      sb.append(""String_Node_Str"");
      sb.append(group);
      sb.append('\n');
    }
    Set<StructureAtomLinkage> unidentifiedLinkages=parser.getUnidentifiableAtomLinkages();
    i=0;
    for (    StructureAtomLinkage link : unidentifiedLinkages) {
      sb.append(""String_Node_Str"");
      sb.append(++i);
      sb.append(""String_Node_Str"");
      sb.append(link);
      sb.append('\n');
    }
  }
  logger.info(sb.toString());
}","private void printResult(String pdbId,ProteinModificationIdentifier parser,boolean recordUnidentifiable){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(pdbId);
  sb.append(""String_Node_Str"");
  Set<ModifiedCompound> mcs=parser.getIdentifiedModifiedCompound();
  int i=0;
  for (  ModifiedCompound mc : mcs) {
    sb.append(""String_Node_Str"");
    sb.append(++i);
    sb.append(""String_Node_Str"");
    sb.append(mc.getAtomLinkages());
    sb.append('\n');
  }
  if (recordUnidentifiable) {
    Set<StructureGroup> unidentifiedModifiedResidues=parser.getUnidentifiableModifiedResidues();
    i=0;
    for (    StructureGroup group : unidentifiedModifiedResidues) {
      sb.append(""String_Node_Str"");
      sb.append(++i);
      sb.append(""String_Node_Str"");
      sb.append(group);
      sb.append('\n');
    }
    Set<StructureAtomLinkage> unidentifiedLinkages=parser.getUnidentifiableAtomLinkages();
    i=0;
    for (    StructureAtomLinkage link : unidentifiedLinkages) {
      sb.append(""String_Node_Str"");
      sb.append(++i);
      sb.append(""String_Node_Str"");
      sb.append(link);
      sb.append('\n');
    }
  }
  logger.info(sb.toString());
}",0.9924050632911392
16361,"public static String[][] setUpShortTest(){
  String[][] strucs=new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",null}};
  return strucs;
}","public static String[][] setUpShortTest(){
  String[][] strucs=new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",null},{""String_Node_Str"",null}};
  return strucs;
}",0.9831876260928044
16362,"private void parserTest(String pdbId,Set<ProteinModification> mods) throws IOException, StructureException {
  Structure struc=TmpAtomCache.cache.getStructure(pdbId);
  ProteinModificationIdentifier parser=new ProteinModificationIdentifier();
  boolean recordUnidentifiable=false;
  parser.setRecordUnidentifiableCompounds(recordUnidentifiable);
  assertFalse(mods.isEmpty());
  parser.identify(struc,mods);
  if (!parser.getIdentifiedModifiedCompound().isEmpty()) {
    logger.warn(""String_Node_Str"",pdbId);
  }
  assertFalse(""String_Node_Str"" + pdbId,parser.getIdentifiedModifiedCompound().isEmpty());
  boolean print=false;
  if (print)   printResult(pdbId,parser,recordUnidentifiable);
}","private void parserTest(String pdbId,Set<ProteinModification> mods) throws IOException, StructureException {
  Structure struc=TmpAtomCache.cache.getStructure(pdbId);
  ProteinModificationIdentifier parser=new ProteinModificationIdentifier();
  boolean recordUnidentifiable=false;
  parser.setRecordUnidentifiableCompounds(recordUnidentifiable);
  assertFalse(mods.isEmpty());
  parser.identify(struc,mods);
  if (parser.getIdentifiedModifiedCompound().isEmpty()) {
    String msg=""String_Node_Str"" + pdbId;
    logger.warn(msg);
    fail(msg);
  }
  assertFalse(""String_Node_Str"" + pdbId,parser.getIdentifiedModifiedCompound().isEmpty());
  boolean print=false;
  if (print)   printResult(pdbId,parser,recordUnidentifiable);
}",0.9478138222849084
16363,"/** 
 * Recursive helper
 * @param symmAxes output list
 * @param prior transformation aligning the first repeat of this axis with the first overall
 * @param level current level
 */
private void getSymmetryAxes(List<Axis> symmAxes,Matrix4d prior,int level,int firstRepeat){
  if (level >= getNumLevels()) {
    return;
  }
  Axis elem=axes.get(level);
  Matrix4d elemOp=elem.getOperator();
  Matrix4d currAxisOp=new Matrix4d(prior);
  currAxisOp.invert();
  currAxisOp.mul(elemOp);
  currAxisOp.mul(prior);
  Axis currAxis=new Axis(currAxisOp,elem.getOrder(),elem.getSymmType(),level,firstRepeat);
  symmAxes.add(currAxis);
  getSymmetryAxes(symmAxes,prior,level + 1,firstRepeat,concat(priorCounts,0));
  Matrix4d newPrior=new Matrix4d(elemOp);
  newPrior.mul(prior);
  int childSize=getNumRepeats(level + 1);
  getSymmetryAxes(symmAxes,newPrior,level + 1,firstRepeat + childSize,concat(priorCounts,1));
  for (int d=2; d < elem.getOrder(); d++) {
    newPrior.mul(elemOp,newPrior);
    getSymmetryAxes(symmAxes,newPrior,level + 1,firstRepeat + childSize * d,concat(priorCounts,d));
  }
}","/** 
 * Recursive helper
 * @param symmAxes output list
 * @param prior transformation aligning the first repeat of this axis with the first overall
 * @param level current level
 */
private void getSymmetryAxes(List<Axis> symmAxes,Matrix4d prior,int level,int firstRepeat){
  if (level >= getNumLevels()) {
    return;
  }
  Axis elem=axes.get(level);
  Matrix4d elemOp=elem.getOperator();
  Matrix4d currAxisOp=new Matrix4d(prior);
  currAxisOp.invert();
  currAxisOp.mul(elemOp);
  currAxisOp.mul(prior);
  Axis currAxis=new Axis(currAxisOp,elem.getOrder(),elem.getSymmType(),level,firstRepeat);
  symmAxes.add(currAxis);
  getSymmetryAxes(symmAxes,prior,level + 1,firstRepeat);
  Matrix4d newPrior=new Matrix4d(elemOp);
  newPrior.mul(prior);
  int childSize=getNumRepeats(level + 1);
  getSymmetryAxes(symmAxes,newPrior,level + 1,firstRepeat + childSize);
  for (int d=2; d < elem.getOrder(); d++) {
    newPrior.mul(elemOp,newPrior);
    getSymmetryAxes(symmAxes,newPrior,level + 1,firstRepeat + childSize * d);
  }
}",0.96875
16364,"/** 
 * Assembly the matched linkages.
 * @param matchedAtomsOfLinkages
 * @param mod
 * @param condition
 * @param ret ModifiedCompound will be stored here.
 */
private void assembleLinkages(List<List<Atom[]>> matchedAtomsOfLinkages,ProteinModification mod,List<ModifiedCompound> ret){
  ModificationCondition condition=mod.getCondition();
  List<ModificationLinkage> modLinks=condition.getLinkages();
  int nLink=matchedAtomsOfLinkages.size();
  int[] indices=new int[nLink];
  Set<ModifiedCompound> identifiedCompounds=new HashSet<ModifiedCompound>();
  while (indices[0] < matchedAtomsOfLinkages.get(0).size()) {
    List<Atom[]> atomLinkages=new ArrayList<Atom[]>(nLink);
    for (int iLink=0; iLink < nLink; iLink++) {
      Atom[] atoms=matchedAtomsOfLinkages.get(iLink).get(indices[iLink]);
      atomLinkages.add(atoms);
    }
    if (matchLinkages(modLinks,atomLinkages)) {
      int n=atomLinkages.size();
      List<StructureAtomLinkage> linkages=new ArrayList<StructureAtomLinkage>(n);
      for (int i=0; i < n; i++) {
        Atom[] linkage=atomLinkages.get(i);
        StructureAtomLinkage link=StructureUtil.getStructureAtomLinkage(linkage[0],residues.contains(linkage[0].getGroup()),linkage[1],residues.contains(linkage[1].getGroup()));
        linkages.add(link);
      }
      ModifiedCompound mc=new ModifiedCompoundImpl(mod,linkages);
      if (!identifiedCompounds.contains(mc)) {
        ret.add(mc);
        identifiedCompounds.add(mc);
      }
    }
    int i=nLink - 1;
    while (i >= 0) {
      if (i == 0 || indices[i] < matchedAtomsOfLinkages.get(i).size() - 1) {
        indices[i]++;
        break;
      }
 else {
        indices[i]=0;
        i--;
      }
    }
  }
}","/** 
 * Assembly the matched linkages
 * @param matchedAtomsOfLinkages
 * @param mod
 * @param ret ModifiedCompound will be stored here
 */
private void assembleLinkages(List<List<Atom[]>> matchedAtomsOfLinkages,ProteinModification mod,List<ModifiedCompound> ret){
  ModificationCondition condition=mod.getCondition();
  List<ModificationLinkage> modLinks=condition.getLinkages();
  int nLink=matchedAtomsOfLinkages.size();
  int[] indices=new int[nLink];
  Set<ModifiedCompound> identifiedCompounds=new HashSet<ModifiedCompound>();
  while (indices[0] < matchedAtomsOfLinkages.get(0).size()) {
    List<Atom[]> atomLinkages=new ArrayList<Atom[]>(nLink);
    for (int iLink=0; iLink < nLink; iLink++) {
      Atom[] atoms=matchedAtomsOfLinkages.get(iLink).get(indices[iLink]);
      atomLinkages.add(atoms);
    }
    if (matchLinkages(modLinks,atomLinkages)) {
      int n=atomLinkages.size();
      List<StructureAtomLinkage> linkages=new ArrayList<StructureAtomLinkage>(n);
      for (int i=0; i < n; i++) {
        Atom[] linkage=atomLinkages.get(i);
        StructureAtomLinkage link=StructureUtil.getStructureAtomLinkage(linkage[0],residues.contains(linkage[0].getGroup()),linkage[1],residues.contains(linkage[1].getGroup()));
        linkages.add(link);
      }
      ModifiedCompound mc=new ModifiedCompoundImpl(mod,linkages);
      if (!identifiedCompounds.contains(mc)) {
        ret.add(mc);
        identifiedCompounds.add(mc);
      }
    }
    int i=nLink - 1;
    while (i >= 0) {
      if (i == 0 || indices[i] < matchedAtomsOfLinkages.get(i).size() - 1) {
        indices[i]++;
        break;
      }
 else {
        indices[i]=0;
        i--;
      }
    }
  }
}",0.9846244825547014
16365,"/** 
 * identify additional groups that are not directly attached to amino acids.
 * @param mc {@link ModifiedCompound}.
 * @param chain a {@link Chain}.
 * @return a list of added groups.
 */
private void identifyAdditionalAttachments(ModifiedCompound mc,List<Group> ligands,Map<String,Chain> mapChainIdChain){
  if (ligands.isEmpty()) {
    return;
  }
  List<Group> identifiedGroups=new ArrayList<Group>();
  for (  StructureGroup num : mc.getGroups(false)) {
    Group group;
    try {
      ResidueNumber resNum=new ResidueNumber();
      resNum.setChainId(num.getChainId());
      resNum.setSeqNum(num.getResidueNumber());
      resNum.setInsCode(num.getInsCode());
      group=mapChainIdChain.get(num.getChainId()).getGroupByPDB(resNum);
    }
 catch (    StructureException e) {
      logger.error(""String_Node_Str"",e);
      continue;
    }
    identifiedGroups.add(group);
  }
  int start=0;
  int n=identifiedGroups.size();
  while (n > start) {
    for (    Group group1 : ligands) {
      for (int i=start; i < n; i++) {
        Group group2=identifiedGroups.get(i);
        if (!identifiedGroups.contains(group1)) {
          List<Atom[]> linkedAtoms=StructureUtil.findAtomLinkages(group1,group2,false,bondLengthTolerance);
          if (!linkedAtoms.isEmpty()) {
            for (            Atom[] atoms : linkedAtoms) {
              mc.addAtomLinkage(StructureUtil.getStructureAtomLinkage(atoms[0],false,atoms[1],false));
            }
            identifiedGroups.add(group1);
            break;
          }
        }
      }
    }
    start=n;
    n=identifiedGroups.size();
  }
}","/** 
 * identify additional groups that are not directly attached to amino acids.
 * @param mc {@link ModifiedCompound}
 * @param ligands {@link Group}
 * @param chains List of {@link Chain}s
 * @return a list of added groups
 */
private void identifyAdditionalAttachments(ModifiedCompound mc,List<Group> ligands,Map<String,Chain> mapChainIdChain){
  if (ligands.isEmpty()) {
    return;
  }
  List<Group> identifiedGroups=new ArrayList<Group>();
  for (  StructureGroup num : mc.getGroups(false)) {
    Group group;
    try {
      ResidueNumber resNum=new ResidueNumber();
      resNum.setChainId(num.getChainId());
      resNum.setSeqNum(num.getResidueNumber());
      resNum.setInsCode(num.getInsCode());
      group=mapChainIdChain.get(num.getChainId()).getGroupByPDB(resNum);
    }
 catch (    StructureException e) {
      logger.error(""String_Node_Str"",e);
      continue;
    }
    identifiedGroups.add(group);
  }
  int start=0;
  int n=identifiedGroups.size();
  while (n > start) {
    for (    Group group1 : ligands) {
      for (int i=start; i < n; i++) {
        Group group2=identifiedGroups.get(i);
        if (!identifiedGroups.contains(group1)) {
          List<Atom[]> linkedAtoms=StructureUtil.findAtomLinkages(group1,group2,false,bondLengthTolerance);
          if (!linkedAtoms.isEmpty()) {
            for (            Atom[] atoms : linkedAtoms) {
              mc.addAtomLinkage(StructureUtil.getStructureAtomLinkage(atoms[0],false,atoms[1],false));
            }
            identifiedGroups.add(group1);
            break;
          }
        }
      }
    }
    start=n;
    n=identifiedGroups.size();
  }
}",0.9823911028730306
16366,"/** 
 * @param recordUnidentifiableAtomLinkages true if choosing to record unidentifiableatoms; false, otherwise.
 * @see #getRecordUnidentifiableCompounds
 * @see #getUnidentifiableModifiedResidues
 * @see #getUnidentifiableAtomLinkages
 */
public void setRecordUnidentifiableCompounds(boolean recordUnidentifiableModifiedCompounds){
  this.recordUnidentifiableModifiedCompounds=recordUnidentifiableModifiedCompounds;
}","/** 
 * @param recordUnidentifiableModifiedCompounds true if choosing to record unidentifiableatoms; false, otherwise.
 * @see #getRecordUnidentifiableCompounds
 * @see #getUnidentifiableModifiedResidues
 * @see #getUnidentifiableAtomLinkages
 */
public void setRecordUnidentifiableCompounds(boolean recordUnidentifiableModifiedCompounds){
  this.recordUnidentifiableModifiedCompounds=recordUnidentifiableModifiedCompounds;
}",0.9680473372781064
16367,"/** 
 * @param atom a {@link Atom} in structure.
 * @param isParentAminoAcid true if the containing group is an amino acid.
 * @return the {@link StructureAtom} of the atom.
 */
public static StructureAtom getStructureAtom(Atom atom,boolean isParentAminoAcid){
  StructureGroup strucGroup=getStructureGroup(atom.getGroup(),isParentAminoAcid);
  return new StructureAtom(strucGroup,atom.getName());
}","/** 
 * @param atom a {@link Atom} in structure.
 * @param isParentAminoAcid true if the containing group is an amino acid.
 * @return the {@link StructureAtom} of the atom.
 */
public static StructureAtom getStructureAtom(Atom atom,boolean isParentAminoAcid){
  Group g=atom.getGroup();
  String chainId=g.getChainId();
  StructureGroup strucGroup=getStructureGroup(g,isParentAminoAcid);
  strucGroup.setChainId(chainId);
  return new StructureAtom(strucGroup,atom.getName());
}",0.7767653758542141
16368,"/** 
 * Find a linkage between two groups within tolerance of bond length.
 * @param group1 the first {@link Group}.
 * @param group2 the second {@link Group}.
 * @param nameOfAtomOnGroup1 atom name of the first group.
 * @param nameOfAtomOnGroup2 atom name of the second group.
 * @param bondLengthTolerance bond length error tolerance.
 * @return an array of two Atoms that form bond between each otherif found; null, otherwise.
 */
public static Atom[] findLinkage(final Group group1,final Group group2,String nameOfAtomOnGroup1,String nameOfAtomOnGroup2,double bondLengthTolerance){
  Atom[] ret=new Atom[2];
  double distance;
  ret[0]=group1.getAtom(nameOfAtomOnGroup1);
  ret[1]=group2.getAtom(nameOfAtomOnGroup2);
  if (ret[0] == null || ret[1] == null) {
    return null;
  }
  distance=Calc.getDistance(ret[0],ret[1]);
  float radiusOfAtom1=ret[0].getElement().getCovalentRadius();
  float radiusOfAtom2=ret[1].getElement().getCovalentRadius();
  if (Math.abs(distance - radiusOfAtom1 - radiusOfAtom2) > bondLengthTolerance) {
    return null;
  }
  return ret;
}","/** 
 * Find a linkage between two groups within tolerance of bond length.
 * @param group1 the first {@link Group}.
 * @param group2 the second {@link Group}.
 * @param nameOfAtomOnGroup1 atom name of the first group.
 * @param nameOfAtomOnGroup2 atom name of the second group.
 * @param bondLengthTolerance bond length error tolerance.
 * @return an array of two Atoms that form bond between each otherif found; null, otherwise.
 */
public static Atom[] findLinkage(final Group group1,final Group group2,String nameOfAtomOnGroup1,String nameOfAtomOnGroup2,double bondLengthTolerance){
  Atom[] ret=new Atom[2];
  ret[0]=group1.getAtom(nameOfAtomOnGroup1);
  ret[1]=group2.getAtom(nameOfAtomOnGroup2);
  if (ret[0] == null || ret[1] == null) {
    return null;
  }
  Atom a1=ret[0];
  Atom a2=ret[1];
  boolean hasBond=a1.hasBond(a2);
  if (hasBond) {
    return ret;
  }
  if (a1.getElement().isMetal() || a2.getElement().isMetal()) {
    MetalBondDistance defined=getMetalDistanceCutoff(a1.getElement().name(),a2.getElement().name());
    if (defined != null) {
      if (hasMetalBond(a1,a2,defined))       return ret;
 else       return null;
    }
  }
  double distance=Calc.getDistance(a1,a2);
  float radiusOfAtom1=ret[0].getElement().getCovalentRadius();
  float radiusOfAtom2=ret[1].getElement().getCovalentRadius();
  if (Math.abs(distance - radiusOfAtom1 - radiusOfAtom2) > bondLengthTolerance) {
    return null;
  }
  return ret;
}",0.8128724672228844
16369,"/** 
 * Recursive helper
 * @param symmAxes output list
 * @param prior transformation aligning the first repeat of this axis with the first overall
 * @param level current level
 */
private void getSymmetryAxes(List<Axis> symmAxes,Matrix4d prior,int level,int firstRepeat){
  if (level >= getNumLevels()) {
    return;
  }
  Axis elem=axes.get(level);
  Matrix4d elemOp=elem.getOperator();
  Matrix4d invPrior=new Matrix4d(prior);
  invPrior.invert();
  Matrix4d currAxisOp=new Matrix4d(prior);
  currAxisOp.mul(elemOp);
  Matrix4d newPrior=new Matrix4d(currAxisOp);
  currAxisOp.mul(invPrior);
  Axis currAxis=new Axis(currAxisOp,elem.getOrder(),elem.getSymmType());
  currAxis.setLevel(level);
  currAxis.setFirstRepeat(firstRepeat);
  symmAxes.add(currAxis);
  getSymmetryAxes(symmAxes,prior,level + 1,0);
  int childSize=getNumRepeats(level + 1);
  getSymmetryAxes(symmAxes,newPrior,level + 1,childSize);
  for (int d=2; d < elem.getOrder(); d++) {
    newPrior.mul(elemOp);
    getSymmetryAxes(symmAxes,newPrior,level + 1,childSize * d);
  }
}","/** 
 * Recursive helper
 * @param symmAxes output list
 * @param prior transformation aligning the first repeat of this axis with the first overall
 * @param level current level
 */
private void getSymmetryAxes(List<Axis> symmAxes,Matrix4d prior,int level,int firstRepeat){
  if (level >= getNumLevels()) {
    return;
  }
  Axis elem=axes.get(level);
  Matrix4d elemOp=elem.getOperator();
  Matrix4d currAxisOp=new Matrix4d(prior);
  currAxisOp.invert();
  currAxisOp.mul(elemOp);
  currAxisOp.mul(prior);
  Axis currAxis=new Axis(currAxisOp,elem.getOrder(),elem.getSymmType());
  currAxis.setLevel(level);
  currAxis.setFirstRepeat(firstRepeat);
  symmAxes.add(currAxis);
  getSymmetryAxes(symmAxes,prior,level + 1,0);
  Matrix4d newPrior=new Matrix4d(elemOp);
  newPrior.mul(prior);
  int childSize=getNumRepeats(level + 1);
  getSymmetryAxes(symmAxes,newPrior,level + 1,childSize);
  for (int d=2; d < elem.getOrder(); d++) {
    newPrior.mul(elemOp,newPrior);
    getSymmetryAxes(symmAxes,newPrior,level + 1,childSize * d);
  }
}",0.581573896353167
16370,"/** 
 * Test that the deprecated addAxis still works
 */
@SuppressWarnings(""String_Node_Str"") @Test public void testOpenCaseOld(){
  SymmetryAxes axes=new SymmetryAxes();
  Matrix4d t10=new Matrix4d();
  t10.set(1,new Vector3d(1,0,0));
  List<Integer> repeats=Arrays.asList(0,0,1,1,2,2,3,3);
  List<List<Integer>> superposition=Arrays.asList(Arrays.asList(0,1,2,3,4,5),Arrays.asList(2,3,4,5,6,7));
  axes.addAxis(t10,superposition,repeats,4);
  Matrix4d r180=new Matrix4d();
  r180.set(new AxisAngle4d(1,0,0,Math.PI));
  repeats=Arrays.asList(0,1,0,1,0,1,0,1);
  superposition=Arrays.asList(Arrays.asList(0,1),Arrays.asList(1,0));
  axes.addAxis(r180,superposition,repeats,2);
  assertEquals(2,axes.getElementaryAxes().size());
  Matrix4d expectedEven=new Matrix4d();
  expectedEven.set(1);
  Matrix4d expectedOdd=new Matrix4d(r180);
  assertEquals(expectedEven,axes.getRepeatTransform(0));
  assertEquals(expectedOdd,axes.getRepeatTransform(1));
  expectedEven.mul(t10);
  expectedOdd.mul(r180,expectedEven);
  assertEquals(expectedEven,axes.getRepeatTransform(2));
  assertEquals(expectedOdd,axes.getRepeatTransform(3));
  expectedEven.mul(t10);
  expectedOdd.mul(r180,expectedEven);
  assertEquals(expectedEven,axes.getRepeatTransform(4));
  assertEquals(expectedOdd,axes.getRepeatTransform(5));
  expectedEven.mul(t10);
  expectedOdd.mul(r180,expectedEven);
  assertEquals(expectedEven,axes.getRepeatTransform(6));
  assertEquals(expectedOdd,axes.getRepeatTransform(7));
  List<List<Integer>> relation=Arrays.asList(Arrays.asList(0,1,2,3,4,5),Arrays.asList(2,3,4,5,6,7));
  assertEquals(relation,axes.getRepeatRelation(0));
  relation=Arrays.asList(Arrays.asList(0,1),Arrays.asList(1,0));
  assertEquals(relation,axes.getRepeatRelation(1));
  try {
    axes.getRepeatRelation(2);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
}","/** 
 * Test that the deprecated addAxis still works
 */
@SuppressWarnings(""String_Node_Str"") @Test public void testOpenCaseOld(){
  SymmetryAxes axes=new SymmetryAxes();
  Matrix4d t10=new Matrix4d();
  t10.set(1,new Vector3d(1,0,0));
  List<Integer> repeats=Arrays.asList(0,0,1,1,2,2,3,3);
  List<List<Integer>> superposition=Arrays.asList(Arrays.asList(0,1,2,3,4,5),Arrays.asList(2,3,4,5,6,7));
  axes.addAxis(t10,superposition,repeats,4);
  Matrix4d r180=new Matrix4d();
  r180.set(new AxisAngle4d(1,0,0,Math.PI));
  repeats=Arrays.asList(0,1,0,1,0,1,0,1);
  superposition=Arrays.asList(Arrays.asList(0,1),Arrays.asList(1,0));
  axes.addAxis(r180,superposition,repeats,2);
  assertEquals(2,axes.getElementaryAxes().size());
  Matrix4d expectedEven=new Matrix4d();
  expectedEven.setIdentity();
  Matrix4d expectedOdd=new Matrix4d(r180);
  assertEquals(expectedEven,axes.getRepeatTransform(0));
  assertEquals(expectedOdd,axes.getRepeatTransform(1));
  expectedEven.mul(t10);
  expectedOdd.mul(r180,expectedEven);
  assertEquals(expectedEven,axes.getRepeatTransform(2));
  assertEquals(expectedOdd,axes.getRepeatTransform(3));
  expectedEven.mul(t10);
  expectedOdd.mul(r180,expectedEven);
  assertEquals(expectedEven,axes.getRepeatTransform(4));
  assertEquals(expectedOdd,axes.getRepeatTransform(5));
  expectedEven.mul(t10);
  expectedOdd.mul(r180,expectedEven);
  assertEquals(expectedEven,axes.getRepeatTransform(6));
  assertEquals(expectedOdd,axes.getRepeatTransform(7));
  List<List<Integer>> relation=Arrays.asList(Arrays.asList(0,1,2,3,4,5),Arrays.asList(2,3,4,5,6,7));
  assertEquals(relation,axes.getRepeatRelation(0));
  relation=Arrays.asList(Arrays.asList(0,1),Arrays.asList(1,0));
  assertEquals(relation,axes.getRepeatRelation(1));
  try {
    axes.getRepeatRelation(2);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
}",0.997053308331101
16371,"@Test public void testOpenCase(){
  SymmetryAxes axes=new SymmetryAxes();
  Matrix4d t10=new Matrix4d();
  t10.set(1,new Vector3d(-10,0,0));
  axes.addAxis(t10,4,SymmetryType.OPEN);
  Matrix4d r180=new Matrix4d();
  r180.set(new AxisAngle4d(1,0,0,Math.PI));
  axes.addAxis(r180,2,SymmetryType.CLOSED);
  assertEquals(2,axes.getElementaryAxes().size());
  Matrix4d expectedEven=new Matrix4d();
  expectedEven.set(1);
  Matrix4d expectedOdd=new Matrix4d(r180);
  assertEquals(expectedEven,axes.getRepeatTransform(0));
  assertEquals(expectedOdd,axes.getRepeatTransform(1));
  expectedEven.mul(t10);
  expectedOdd.mul(r180,expectedEven);
  assertEquals(expectedEven,axes.getRepeatTransform(2));
  assertEquals(expectedOdd,axes.getRepeatTransform(3));
  expectedEven.mul(t10);
  expectedOdd.mul(r180,expectedEven);
  assertEquals(expectedEven,axes.getRepeatTransform(4));
  assertEquals(expectedOdd,axes.getRepeatTransform(5));
  expectedEven.mul(t10);
  expectedOdd.mul(r180,expectedEven);
  assertEquals(expectedEven,axes.getRepeatTransform(6));
  assertEquals(expectedOdd,axes.getRepeatTransform(7));
  List<List<Integer>> relation=Arrays.asList(Arrays.asList(0,1,2,3,4,5),Arrays.asList(2,3,4,5,6,7));
  assertEquals(relation,axes.getRepeatRelation(0));
  relation=Arrays.asList(Arrays.asList(0,1),Arrays.asList(1,0));
  assertEquals(relation,axes.getRepeatRelation(1));
  try {
    axes.getRepeatRelation(2);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  relation=Arrays.asList(Arrays.asList(0,2,4,6),Arrays.asList(1,3,5,7));
  assertEquals(relation,axes.getRepeatsCyclicForm(0));
  relation=Arrays.asList(Arrays.asList(0,1));
  assertEquals(relation,axes.getRepeatsCyclicForm(1));
  relation=Arrays.asList(Arrays.asList(2,3));
  assertEquals(relation,axes.getRepeatsCyclicForm(1,2));
  try {
    axes.getRepeatsCyclicForm(2);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    axes.getRepeatsCyclicForm(1,1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  Point3d[] repeats=new Point3d[]{new Point3d(-15,1,1),new Point3d(-15,-1,-1),new Point3d(-5,1,1),new Point3d(-5,-1,-1),new Point3d(5,1,1),new Point3d(5,-1,-1),new Point3d(15,1,1),new Point3d(15,-1,-1)};
  for (int i=0; i < 8; i++) {
    Matrix4d m=axes.getRepeatTransform(i);
    m.invert();
    Point3d x=new Point3d(repeats[0]);
    m.transform(x);
    assertTrue(""String_Node_Str"" + i + ""String_Node_Str""+ repeats[0]+ ""String_Node_Str""+ x+ ""String_Node_Str""+ repeats[i],x.epsilonEquals(repeats[i],1e-5));
  }
  for (int i=0; i < 8; i++) {
    Matrix4d m=axes.getRepeatTransform(i);
    Point3d x=new Point3d(repeats[i]);
    m.transform(x);
    assertTrue(""String_Node_Str"" + i + ""String_Node_Str""+ repeats[i]+ ""String_Node_Str""+ x+ ""String_Node_Str""+ repeats[0],x.epsilonEquals(repeats[0],1e-5));
  }
  Point3d x;
  List<Axis> symmetryAxes=axes.getSymmetryAxes();
  assertEquals(5,symmetryAxes.size());
  int axisNum=0;
  x=new Point3d(repeats[2]);
  symmetryAxes.get(axisNum).getOperator().transform(x);
  assertTrue(String.format(""String_Node_Str"",axisNum,round(repeats[2]),round(x),round(repeats[0])),x.epsilonEquals(repeats[0],1e-5));
  axisNum++;
  x=new Point3d(repeats[1]);
  symmetryAxes.get(axisNum).getOperator().transform(x);
  assertTrue(String.format(""String_Node_Str"",axisNum,round(repeats[1]),round(x),round(repeats[0])),x.epsilonEquals(repeats[0],1e-5));
  axisNum++;
  x=new Point3d(repeats[3]);
  symmetryAxes.get(axisNum).getOperator().transform(x);
  assertTrue(String.format(""String_Node_Str"",axisNum,round(repeats[3]),round(x),round(repeats[2])),x.epsilonEquals(repeats[2],1e-5));
  axisNum++;
  x=new Point3d(repeats[5]);
  symmetryAxes.get(axisNum).getOperator().transform(x);
  assertTrue(String.format(""String_Node_Str"",axisNum,round(repeats[5]),round(x),round(repeats[4])),x.epsilonEquals(repeats[4],1e-5));
  axisNum++;
  x=new Point3d(repeats[7]);
  symmetryAxes.get(axisNum).getOperator().transform(x);
  assertTrue(String.format(""String_Node_Str"",axisNum,round(repeats[7]),round(x),round(repeats[6])),x.epsilonEquals(repeats[6],1e-5));
  axisNum++;
}","@Test public void testOpenCase(){
  SymmetryAxes axes=new SymmetryAxes();
  Matrix4d t10=new Matrix4d();
  t10.set(1,new Vector3d(-10,0,0));
  axes.addAxis(t10,4,SymmetryType.OPEN);
  Matrix4d r180=new Matrix4d();
  r180.set(new AxisAngle4d(1,0,0,Math.PI));
  axes.addAxis(r180,2,SymmetryType.CLOSED);
  assertEquals(2,axes.getElementaryAxes().size());
  Matrix4d expectedEven=new Matrix4d();
  expectedEven.setIdentity();
  Matrix4d expectedOdd=new Matrix4d(r180);
  assertEquals(expectedEven,axes.getRepeatTransform(0));
  assertEquals(expectedOdd,axes.getRepeatTransform(1));
  expectedEven.mul(t10);
  expectedOdd.mul(r180,expectedEven);
  assertEquals(expectedEven,axes.getRepeatTransform(2));
  assertEquals(expectedOdd,axes.getRepeatTransform(3));
  expectedEven.mul(t10);
  expectedOdd.mul(r180,expectedEven);
  assertEquals(expectedEven,axes.getRepeatTransform(4));
  assertEquals(expectedOdd,axes.getRepeatTransform(5));
  expectedEven.mul(t10);
  expectedOdd.mul(r180,expectedEven);
  assertEquals(expectedEven,axes.getRepeatTransform(6));
  assertEquals(expectedOdd,axes.getRepeatTransform(7));
  List<List<Integer>> relation=Arrays.asList(Arrays.asList(0,1,2,3,4,5),Arrays.asList(2,3,4,5,6,7));
  assertEquals(relation,axes.getRepeatRelation(0));
  relation=Arrays.asList(Arrays.asList(0,1),Arrays.asList(1,0));
  assertEquals(relation,axes.getRepeatRelation(1));
  try {
    axes.getRepeatRelation(2);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  relation=Arrays.asList(Arrays.asList(0,2,4,6),Arrays.asList(1,3,5,7));
  assertEquals(relation,axes.getRepeatsCyclicForm(0));
  relation=Arrays.asList(Arrays.asList(0,1));
  assertEquals(relation,axes.getRepeatsCyclicForm(1));
  relation=Arrays.asList(Arrays.asList(2,3));
  assertEquals(relation,axes.getRepeatsCyclicForm(1,2));
  try {
    axes.getRepeatsCyclicForm(2);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    axes.getRepeatsCyclicForm(1,1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  Point3d[] repeats=new Point3d[]{new Point3d(-15,1,1),new Point3d(-15,-1,-1),new Point3d(-5,1,1),new Point3d(-5,-1,-1),new Point3d(5,1,1),new Point3d(5,-1,-1),new Point3d(15,1,1),new Point3d(15,-1,-1)};
  for (int i=0; i < 8; i++) {
    Matrix4d m=axes.getRepeatTransform(i);
    m.invert();
    Point3d x=new Point3d(repeats[0]);
    m.transform(x);
    assertTrue(""String_Node_Str"" + i + ""String_Node_Str""+ repeats[0]+ ""String_Node_Str""+ x+ ""String_Node_Str""+ repeats[i],x.epsilonEquals(repeats[i],1e-5));
  }
  for (int i=0; i < 8; i++) {
    Matrix4d m=axes.getRepeatTransform(i);
    Point3d x=new Point3d(repeats[i]);
    m.transform(x);
    assertTrue(""String_Node_Str"" + i + ""String_Node_Str""+ repeats[i]+ ""String_Node_Str""+ x+ ""String_Node_Str""+ repeats[0],x.epsilonEquals(repeats[0],1e-5));
  }
  Point3d x;
  List<Axis> symmetryAxes=axes.getSymmetryAxes();
  assertEquals(5,symmetryAxes.size());
  int axisNum=0;
  x=new Point3d(repeats[2]);
  symmetryAxes.get(axisNum).getOperator().transform(x);
  assertTrue(String.format(""String_Node_Str"",axisNum,round(repeats[2]),round(x),round(repeats[0])),x.epsilonEquals(repeats[0],1e-5));
  axisNum++;
  x=new Point3d(repeats[1]);
  symmetryAxes.get(axisNum).getOperator().transform(x);
  assertTrue(String.format(""String_Node_Str"",axisNum,round(repeats[1]),round(x),round(repeats[0])),x.epsilonEquals(repeats[0],1e-5));
  axisNum++;
  x=new Point3d(repeats[3]);
  symmetryAxes.get(axisNum).getOperator().transform(x);
  assertTrue(String.format(""String_Node_Str"",axisNum,round(repeats[3]),round(x),round(repeats[2])),x.epsilonEquals(repeats[2],1e-5));
  axisNum++;
  x=new Point3d(repeats[5]);
  symmetryAxes.get(axisNum).getOperator().transform(x);
  assertTrue(String.format(""String_Node_Str"",axisNum,round(repeats[5]),round(x),round(repeats[4])),x.epsilonEquals(repeats[4],1e-5));
  axisNum++;
  x=new Point3d(repeats[7]);
  symmetryAxes.get(axisNum).getOperator().transform(x);
  assertTrue(String.format(""String_Node_Str"",axisNum,round(repeats[7]),round(x),round(repeats[6])),x.epsilonEquals(repeats[6],1e-5));
  axisNum++;
}",0.9986745391010964
16372,"@Test public void testClosedCase(){
  SymmetryAxes axes=new SymmetryAxes();
  Matrix4d r90=new Matrix4d();
  r90.set(new AxisAngle4d(0,0,1,-Math.PI / 2));
  axes.addAxis(r90,4,SymmetryType.CLOSED);
  Matrix4d r180=new Matrix4d();
  r180.set(new AxisAngle4d(1,0,0,Math.PI));
  axes.addAxis(r180,2,SymmetryType.CLOSED);
  assertEquals(2,axes.getElementaryAxes().size());
  Matrix4d expectedEven=new Matrix4d();
  expectedEven.set(1);
  Matrix4d expectedOdd=new Matrix4d(r180);
  assertEquals(expectedEven,axes.getRepeatTransform(0));
  assertEquals(expectedOdd,axes.getRepeatTransform(1));
  expectedEven.mul(r90);
  expectedOdd.mul(r180,expectedEven);
  assertEquals(expectedEven,axes.getRepeatTransform(2));
  assertEquals(expectedOdd,axes.getRepeatTransform(3));
  expectedEven.mul(r90);
  expectedOdd.mul(r180,expectedEven);
  assertEquals(expectedEven,axes.getRepeatTransform(4));
  assertEquals(expectedOdd,axes.getRepeatTransform(5));
  expectedEven.mul(r90);
  expectedOdd.mul(r180,expectedEven);
  assertEquals(expectedEven,axes.getRepeatTransform(6));
  assertEquals(expectedOdd,axes.getRepeatTransform(7));
  List<List<Integer>> relation=Arrays.asList(Arrays.asList(0,1,2,3,4,5,6,7),Arrays.asList(2,3,4,5,6,7,0,1));
  assertEquals(relation,axes.getRepeatRelation(0));
  relation=Arrays.asList(Arrays.asList(0,1),Arrays.asList(1,0));
  assertEquals(relation,axes.getRepeatRelation(1));
  relation=Arrays.asList(Arrays.asList(2,3),Arrays.asList(3,2));
  assertEquals(relation,axes.getRepeatRelation(1,2));
  try {
    axes.getRepeatRelation(2);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    axes.getRepeatRelation(1,1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  relation=Arrays.asList(Arrays.asList(0,2,4,6),Arrays.asList(1,3,5,7));
  assertEquals(relation,axes.getRepeatsCyclicForm(0));
  relation=Arrays.asList(Arrays.asList(0,1));
  assertEquals(relation,axes.getRepeatsCyclicForm(1));
  relation=Arrays.asList(Arrays.asList(2,3));
  assertEquals(relation,axes.getRepeatsCyclicForm(1,2));
  try {
    axes.getRepeatsCyclicForm(2);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    axes.getRepeatsCyclicForm(1,1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  Point3d[] repeats=new Point3d[]{new Point3d(1,1,1),new Point3d(1,-1,-1),new Point3d(-1,1,1),new Point3d(1,1,-1),new Point3d(-1,-1,1),new Point3d(-1,1,-1),new Point3d(1,-1,1),new Point3d(-1,-1,-1)};
  for (int i=0; i < 8; i++) {
    Matrix4d m=axes.getRepeatTransform(i);
    m.invert();
    Point3d x=new Point3d(repeats[0]);
    m.transform(x);
    assertTrue(""String_Node_Str"" + i + ""String_Node_Str""+ repeats[0]+ ""String_Node_Str""+ x+ ""String_Node_Str""+ repeats[i],x.epsilonEquals(repeats[i],1e-5));
  }
  for (int i=0; i < 8; i++) {
    Matrix4d m=axes.getRepeatTransform(i);
    Point3d x=new Point3d(repeats[i]);
    m.transform(x);
    assertTrue(""String_Node_Str"" + i + ""String_Node_Str""+ repeats[i]+ ""String_Node_Str""+ x+ ""String_Node_Str"",x.epsilonEquals(repeats[0],1e-5));
  }
  Point3d x;
  List<Axis> symmetryAxes=axes.getSymmetryAxes();
  assertEquals(5,symmetryAxes.size());
  int axisNum=0;
  x=new Point3d(repeats[2]);
  symmetryAxes.get(axisNum).getOperator().transform(x);
  assertTrue(String.format(""String_Node_Str"",axisNum,round(repeats[2]),round(x),round(repeats[0])),x.epsilonEquals(repeats[0],1e-5));
  assertEquals(0,symmetryAxes.get(axisNum).getFirstRepeat());
  axisNum++;
  x=new Point3d(repeats[1]);
  symmetryAxes.get(axisNum).getOperator().transform(x);
  assertTrue(String.format(""String_Node_Str"",axisNum,round(repeats[1]),round(x),round(repeats[0])),x.epsilonEquals(repeats[0],1e-5));
  assertEquals(0,symmetryAxes.get(axisNum).getFirstRepeat());
  axisNum++;
  x=new Point3d(repeats[3]);
  symmetryAxes.get(axisNum).getOperator().transform(x);
  assertTrue(String.format(""String_Node_Str"",axisNum,round(repeats[3]),round(x),round(repeats[2])),x.epsilonEquals(repeats[2],1e-5));
  assertEquals(2,symmetryAxes.get(axisNum).getFirstRepeat());
  axisNum++;
  x=new Point3d(repeats[5]);
  symmetryAxes.get(axisNum).getOperator().transform(x);
  assertTrue(String.format(""String_Node_Str"",axisNum,round(repeats[5]),round(x),round(repeats[4])),x.epsilonEquals(repeats[4],1e-5));
  assertEquals(4,symmetryAxes.get(axisNum).getFirstRepeat());
  axisNum++;
  x=new Point3d(repeats[7]);
  symmetryAxes.get(axisNum).getOperator().transform(x);
  assertTrue(String.format(""String_Node_Str"",axisNum,round(repeats[7]),round(x),round(repeats[6])),x.epsilonEquals(repeats[6],1e-5));
  assertEquals(6,symmetryAxes.get(axisNum).getFirstRepeat());
  axisNum++;
}","@Test public void testClosedCase(){
  SymmetryAxes axes=new SymmetryAxes();
  Matrix4d r90=new Matrix4d();
  r90.set(new AxisAngle4d(0,0,1,-Math.PI / 2));
  axes.addAxis(r90,4,SymmetryType.CLOSED);
  Matrix4d r180=new Matrix4d();
  r180.set(new AxisAngle4d(1,0,0,Math.PI));
  axes.addAxis(r180,2,SymmetryType.CLOSED);
  assertEquals(2,axes.getElementaryAxes().size());
  Matrix4d expectedEven=new Matrix4d();
  expectedEven.setIdentity();
  Matrix4d expectedOdd=new Matrix4d(r180);
  assertEquals(expectedEven,axes.getRepeatTransform(0));
  assertEquals(expectedOdd,axes.getRepeatTransform(1));
  expectedEven.mul(r90);
  expectedOdd.mul(r180,expectedEven);
  assertEquals(expectedEven,axes.getRepeatTransform(2));
  assertEquals(expectedOdd,axes.getRepeatTransform(3));
  expectedEven.mul(r90);
  expectedOdd.mul(r180,expectedEven);
  assertEquals(expectedEven,axes.getRepeatTransform(4));
  assertEquals(expectedOdd,axes.getRepeatTransform(5));
  expectedEven.mul(r90);
  expectedOdd.mul(r180,expectedEven);
  assertEquals(expectedEven,axes.getRepeatTransform(6));
  assertEquals(expectedOdd,axes.getRepeatTransform(7));
  List<List<Integer>> relation=Arrays.asList(Arrays.asList(0,1,2,3,4,5,6,7),Arrays.asList(2,3,4,5,6,7,0,1));
  assertEquals(relation,axes.getRepeatRelation(0));
  relation=Arrays.asList(Arrays.asList(0,1),Arrays.asList(1,0));
  assertEquals(relation,axes.getRepeatRelation(1));
  relation=Arrays.asList(Arrays.asList(2,3),Arrays.asList(3,2));
  assertEquals(relation,axes.getRepeatRelation(1,2));
  try {
    axes.getRepeatRelation(2);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    axes.getRepeatRelation(1,1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  relation=Arrays.asList(Arrays.asList(0,2,4,6),Arrays.asList(1,3,5,7));
  assertEquals(relation,axes.getRepeatsCyclicForm(0));
  relation=Arrays.asList(Arrays.asList(0,1));
  assertEquals(relation,axes.getRepeatsCyclicForm(1));
  relation=Arrays.asList(Arrays.asList(2,3));
  assertEquals(relation,axes.getRepeatsCyclicForm(1,2));
  try {
    axes.getRepeatsCyclicForm(2);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    axes.getRepeatsCyclicForm(1,1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  Point3d[] repeats=new Point3d[]{new Point3d(1,1,1),new Point3d(1,-1,-1),new Point3d(-1,1,1),new Point3d(1,1,-1),new Point3d(-1,-1,1),new Point3d(-1,1,-1),new Point3d(1,-1,1),new Point3d(-1,-1,-1)};
  for (int i=0; i < 8; i++) {
    Matrix4d m=axes.getRepeatTransform(i);
    m.invert();
    Point3d x=new Point3d(repeats[0]);
    m.transform(x);
    assertTrue(""String_Node_Str"" + i + ""String_Node_Str""+ repeats[0]+ ""String_Node_Str""+ x+ ""String_Node_Str""+ repeats[i],x.epsilonEquals(repeats[i],1e-5));
  }
  for (int i=0; i < 8; i++) {
    Matrix4d m=axes.getRepeatTransform(i);
    Point3d x=new Point3d(repeats[i]);
    m.transform(x);
    assertTrue(""String_Node_Str"" + i + ""String_Node_Str""+ repeats[i]+ ""String_Node_Str""+ x+ ""String_Node_Str"",x.epsilonEquals(repeats[0],1e-5));
  }
  Point3d x;
  List<Axis> symmetryAxes=axes.getSymmetryAxes();
  assertEquals(5,symmetryAxes.size());
  int axisNum=0;
  x=new Point3d(repeats[2]);
  symmetryAxes.get(axisNum).getOperator().transform(x);
  assertTrue(String.format(""String_Node_Str"",axisNum,round(repeats[2]),round(x),round(repeats[0])),x.epsilonEquals(repeats[0],1e-5));
  assertEquals(0,symmetryAxes.get(axisNum).getFirstRepeat());
  axisNum++;
  x=new Point3d(repeats[1]);
  symmetryAxes.get(axisNum).getOperator().transform(x);
  assertTrue(String.format(""String_Node_Str"",axisNum,round(repeats[1]),round(x),round(repeats[0])),x.epsilonEquals(repeats[0],1e-5));
  assertEquals(0,symmetryAxes.get(axisNum).getFirstRepeat());
  axisNum++;
  x=new Point3d(repeats[3]);
  symmetryAxes.get(axisNum).getOperator().transform(x);
  assertTrue(String.format(""String_Node_Str"",axisNum,round(repeats[3]),round(x),round(repeats[2])),x.epsilonEquals(repeats[2],1e-5));
  assertEquals(2,symmetryAxes.get(axisNum).getFirstRepeat());
  axisNum++;
  x=new Point3d(repeats[5]);
  symmetryAxes.get(axisNum).getOperator().transform(x);
  assertTrue(String.format(""String_Node_Str"",axisNum,round(repeats[5]),round(x),round(repeats[4])),x.epsilonEquals(repeats[4],1e-5));
  assertEquals(4,symmetryAxes.get(axisNum).getFirstRepeat());
  axisNum++;
  x=new Point3d(repeats[7]);
  symmetryAxes.get(axisNum).getOperator().transform(x);
  assertTrue(String.format(""String_Node_Str"",axisNum,round(repeats[7]),round(x),round(repeats[6])),x.epsilonEquals(repeats[6],1e-5));
  assertEquals(6,symmetryAxes.get(axisNum).getFirstRepeat());
  axisNum++;
}",0.9988309065788076
16373,"/** 
 * Generates a String that displays the symmetry axes of a structure.
 * @param symm CeSymmResult
 * @param allAxes Indicates whether all axes should be displayed or justthe elemenatary ones
 * @return
 * @throws StructureException
 */
public static String printSymmetryAxes(CeSymmResult symm,boolean allAxes) throws StructureException {
  int id=0;
  String script=""String_Node_Str"";
  SymmetryAxes axes=symm.getAxes();
  List<Atom[]> repeats=SymmetryTools.toRepeatsAlignment(symm).getAtomArrays();
  List<Axis> symmAxes;
  if (allAxes) {
    symmAxes=axes.getSymmetryAxes();
  }
 else {
    symmAxes=axes.getElementaryAxesObjects();
  }
  for (  Axis a : symmAxes) {
    RotationAxis rot=a.getRotationAxis();
    Set<Integer> repIndex=new TreeSet<Integer>(axes.getRepeatRelation(a).get(0));
    repIndex.addAll(axes.getRepeatRelation(a).get(1));
    List<Atom> repAtoms=new ArrayList<Atom>();
    for (    Integer r : repIndex)     repAtoms.addAll(Arrays.asList(repeats.get(r)));
    script+=rot.getJmolScript(repAtoms.toArray(new Atom[repAtoms.size()]),id);
    id++;
  }
  return script;
}","/** 
 * Generates a String that displays the symmetry axes of a structure.
 * @param symm CeSymmResult
 * @param allAxes Indicates whether all axes should be displayed or justthe elemenatary ones
 * @return
 * @throws StructureException
 */
public static String printSymmetryAxes(CeSymmResult symm,boolean allAxes) throws StructureException {
  int id=0;
  String script=""String_Node_Str"";
  SymmetryAxes axes=symm.getAxes();
  List<Atom[]> repeats=SymmetryTools.toRepeatsAlignment(symm).getAtomArrays();
  List<Axis> symmAxes;
  if (allAxes) {
    symmAxes=axes.getSymmetryAxes();
  }
 else {
    symmAxes=axes.getElementaryAxesObjects();
  }
  for (  Axis a : symmAxes) {
    RotationAxis rot=a.getRotationAxis();
    List<List<Integer>> cyclicForm=axes.getRepeatsCyclicForm(a);
    List<Atom> repAtoms=new ArrayList<Atom>();
    for (    List<Integer> cycle : cyclicForm) {
      for (      Integer repeat : cycle) {
        repAtoms.addAll(Arrays.asList(repeats.get(repeat)));
      }
    }
    script+=rot.getJmolScript(repAtoms.toArray(new Atom[repAtoms.size()]),id);
    id++;
  }
  return script;
}",0.7903811252268602
16374,"/** 
 * Adds a new axis of symmetry to the bottom level of the tree
 * @param axis the new axis of symmetry found
 * @param order number of parts that this axis divides the structure in
 * @param type indicates whether the axis has OPEN or CLOSED symmetry
 */
public void addAxis(Matrix4d axis,int order,SymmetryType type){
  axes.add(new Axis(axis,order,type));
}","/** 
 * Adds a new axis of symmetry to the bottom level of the tree
 * @param axis the new axis of symmetry found
 * @param order number of parts that this axis divides the structure in
 * @param type indicates whether the axis has OPEN or CLOSED symmetry
 */
public void addAxis(Matrix4d axis,int order,SymmetryType type){
  axes.add(new Axis(axis,order,type,axes.size(),0));
}",0.981132075471698
16375,"public List<List<Integer>> getRepeatRelation(int level,int firstRepeat){
  Axis axis=axes.get(level);
  int m=getNumRepeats(level + 1);
  int d=axis.getOrder();
  int n=m * d;
  if (axis.getSymmType() == SymmetryType.OPEN) {
    n-=m;
  }
  if (firstRepeat % n != 0) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",firstRepeat,level));
  }
  List<Integer> repeats=new ArrayList<>(n);
  List<Integer> equiv=new ArrayList<>(n);
  for (int i=0; i < n; i++) {
    repeats.add(i + firstRepeat);
    equiv.add((i + m) % (m * d) + firstRepeat);
  }
  return Arrays.asList(repeats,equiv);
}","public List<List<Integer>> getRepeatRelation(int level,int firstRepeat){
  Axis axis=axes.get(level);
  int m=getNumRepeats(level + 1);
  int d=axis.getOrder();
  int n=m * d;
  if (firstRepeat % n != 0) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",firstRepeat,level));
  }
  if (axis.getSymmType() == SymmetryType.OPEN) {
    n-=m;
  }
  List<Integer> repeats=new ArrayList<>(n);
  List<Integer> equiv=new ArrayList<>(n);
  for (int i=0; i < n; i++) {
    repeats.add(i + firstRepeat);
    equiv.add((i + m) % (m * d) + firstRepeat);
  }
  return Arrays.asList(repeats,equiv);
}",0.7924217462932455
16376,"/** 
 * Recursive helper
 * @param symmAxes output list
 * @param prior transformation aligning the first repeat of this axis with the first overall
 * @param level current level
 */
private void getSymmetryAxes(List<Axis> symmAxes,Matrix4d prior,int level,int firstRepeat){
  if (level >= getNumLevels()) {
    return;
  }
  Axis elem=axes.get(level);
  Matrix4d elemOp=elem.getOperator();
  Matrix4d currAxisOp=new Matrix4d(prior);
  currAxisOp.invert();
  currAxisOp.mul(elemOp);
  currAxisOp.mul(prior);
  Axis currAxis=new Axis(currAxisOp,elem.getOrder(),elem.getSymmType());
  currAxis.setLevel(level);
  currAxis.setFirstRepeat(firstRepeat);
  symmAxes.add(currAxis);
  getSymmetryAxes(symmAxes,prior,level + 1,0);
  Matrix4d newPrior=new Matrix4d(elemOp);
  newPrior.mul(prior);
  int childSize=getNumRepeats(level + 1);
  getSymmetryAxes(symmAxes,newPrior,level + 1,childSize);
  for (int d=2; d < elem.getOrder(); d++) {
    newPrior.mul(elemOp,newPrior);
    getSymmetryAxes(symmAxes,newPrior,level + 1,childSize * d);
  }
}","/** 
 * Recursive helper
 * @param symmAxes output list
 * @param prior transformation aligning the first repeat of this axis with the first overall
 * @param level current level
 */
private void getSymmetryAxes(List<Axis> symmAxes,Matrix4d prior,int level,int firstRepeat){
  if (level >= getNumLevels()) {
    return;
  }
  Axis elem=axes.get(level);
  Matrix4d elemOp=elem.getOperator();
  Matrix4d currAxisOp=new Matrix4d(prior);
  currAxisOp.invert();
  currAxisOp.mul(elemOp);
  currAxisOp.mul(prior);
  Axis currAxis=new Axis(currAxisOp,elem.getOrder(),elem.getSymmType(),level,firstRepeat);
  symmAxes.add(currAxis);
  getSymmetryAxes(symmAxes,prior,level + 1,0);
  Matrix4d newPrior=new Matrix4d(elemOp);
  newPrior.mul(prior);
  int childSize=getNumRepeats(level + 1);
  getSymmetryAxes(symmAxes,newPrior,level + 1,childSize);
  for (int d=2; d < elem.getOrder(); d++) {
    newPrior.mul(elemOp,newPrior);
    getSymmetryAxes(symmAxes,newPrior,level + 1,childSize * d);
  }
}",0.9683168316831684
16377,"public Axis(Matrix4d operator,int order,SymmetryType type){
  if (order < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (type != SymmetryType.OPEN && type != SymmetryType.CLOSED) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.operator=operator;
  this.order=order;
  this.symmType=type;
  this.level=-1;
  this.firstRepeat=-1;
  rotAxis=null;
}","public Axis(Matrix4d operator,int order,SymmetryType type,int level,int firstRepeat){
  if (order < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (type != SymmetryType.OPEN && type != SymmetryType.CLOSED) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.operator=operator;
  this.order=order;
  this.symmType=type;
  setLevel(level);
  setFirstRepeat(firstRepeat);
  rotAxis=null;
}",0.9057971014492754
16378,"/** 
 * Method that converts a symmetry alignment into an alignment of the repeats only, as new independent structures. <p> This method changes the structure identifiers, the Atom arrays and re-scles the aligned residues in the Blocks corresponding to those changes. <p> Application: display superimposed repeats in Jmol.
 * @param result CeSymmResult of symmetry
 * @return MultipleAlignment of the repeats
 * @throws StructureException
 */
public static MultipleAlignment toRepeatsAlignment(CeSymmResult result) throws StructureException {
  if (!result.isRefined())   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  MultipleAlignment msa=result.getMultipleAlignment();
  MultipleAlignmentEnsemble newEnsemble=msa.getEnsemble().clone();
  newEnsemble.setStructureIdentifiers(result.getRepeatsID());
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  Structure divided=SymmetryTools.getQuaternaryStructure(result);
  MultipleAlignment repeats=newEnsemble.getMultipleAlignment(0);
  Block block=repeats.getBlock(0);
  for (int i=0; i < result.getMultipleAlignment().size(); i++) {
    Structure newStr=new StructureImpl();
    Chain newCh=divided.getChain(i);
    newStr.addChain(newCh);
    Atom[] repeat=StructureTools.getRepresentativeAtomArray(newCh);
    atomArrays.add(repeat);
  }
  newEnsemble.setAtomArrays(atomArrays);
  for (int su=0; su < block.size(); su++) {
    Integer start=block.getStartResidue(su);
    for (int res=0; res < block.length(); res++) {
      Integer residue=block.getAlignRes().get(su).get(res);
      if (residue != null)       residue-=start;
      block.getAlignRes().get(su).set(res,residue);
    }
  }
  return repeats;
}","/** 
 * Method that converts a symmetry alignment into an alignment of the repeats only, as new independent structures. <p> This method changes the structure identifiers, the Atom arrays and re-scles the aligned residues in the Blocks corresponding to those changes. <p> Application: display superimposed repeats in Jmol.
 * @param result CeSymmResult of symmetry
 * @return MultipleAlignment of the repeats
 * @throws StructureException
 */
public static MultipleAlignment toRepeatsAlignment(CeSymmResult result) throws StructureException {
  if (!result.isRefined())   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  MultipleAlignment msa=result.getMultipleAlignment();
  MultipleAlignmentEnsemble newEnsemble=msa.getEnsemble().clone();
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  Structure divided=SymmetryTools.getQuaternaryStructure(result);
  MultipleAlignment repeats=newEnsemble.getMultipleAlignment(0);
  Block block=repeats.getBlock(0);
  for (int i=0; i < result.getMultipleAlignment().size(); i++) {
    Structure newStr=new StructureImpl();
    Chain newCh=divided.getChain(i);
    newStr.addChain(newCh);
    Atom[] repeat=StructureTools.getRepresentativeAtomArray(newCh);
    atomArrays.add(repeat);
  }
  newEnsemble.setAtomArrays(atomArrays);
  for (int su=0; su < block.size(); su++) {
    Integer start=block.getStartResidue(su);
    for (int res=0; res < block.length(); res++) {
      Integer residue=block.getAlignRes().get(su).get(res);
      if (residue != null)       residue-=start;
      block.getAlignRes().get(su).set(res,residue);
    }
  }
  return repeats;
}",0.981314044605184
16379,"/** 
 * Method that converts the symmetric units of a structure into different chains, so that internal symmetry can be translated into quaternary. <p> Application: obtain the internal symmetry axis with the quaternary symmetry code in biojava or calculate independent repeat properties.
 * @param symmetry CeSymmResult
 * @return Structure with different chains for every symmetric unit
 */
public static Structure getQuaternaryStructure(CeSymmResult symmetry){
  if (!symmetry.isRefined())   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  Atom[] atoms=symmetry.getAtoms();
  Structure symm=new StructureImpl();
  symm.setStructureIdentifier(symmetry.getStructureId());
  symm.setChains(new ArrayList<Chain>());
  char chainID='A';
  for (int i=0; i < symmetry.getMultipleAlignment().size(); i++) {
    Chain newCh=new ChainImpl();
    Block align=symmetry.getMultipleAlignment().getBlock(0);
    int res1=align.getStartResidue(i);
    int res2=align.getFinalResidue(i);
    Atom[] repeat=Arrays.copyOfRange(atoms,res1,res2 + 1);
    for (int k=0; k < repeat.length; k++) {
      Group g=(Group)repeat[k].getGroup().clone();
      newCh.addGroup(g);
    }
    newCh.setChainID(chainID + ""String_Node_Str"");
    chainID++;
    symm.addChain(newCh);
  }
  return symm;
}","/** 
 * Method that converts the symmetric units of a structure into different chains, so that internal symmetry can be translated into quaternary. <p> Application: obtain the internal symmetry axis with the quaternary symmetry code in biojava or calculate independent repeat properties.
 * @param symmetry CeSymmResult
 * @return Structure with different chains for every symmetric unit
 */
public static Structure getQuaternaryStructure(CeSymmResult symmetry){
  if (!symmetry.isRefined())   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  Atom[] atoms=StructureTools.cloneAtomArray(symmetry.getAtoms());
  Structure symm=new StructureImpl();
  symm.setStructureIdentifier(symmetry.getStructureId());
  symm.setChains(new ArrayList<Chain>());
  char chainID='A';
  for (int i=0; i < symmetry.getMultipleAlignment().size(); i++) {
    Chain newCh=new ChainImpl();
    Block align=symmetry.getMultipleAlignment().getBlock(0);
    int res1=align.getStartResidue(i);
    int res2=align.getFinalResidue(i);
    Atom[] repeat=Arrays.copyOfRange(atoms,res1,res2 + 1);
    for (int k=0; k < repeat.length; k++) {
      Group g=(Group)repeat[k].getGroup().clone();
      newCh.addGroup(g);
    }
    newCh.setChainID(chainID + ""String_Node_Str"");
    chainID++;
    symm.addChain(newCh);
  }
  return symm;
}",0.9775580068467098
16380,"/** 
 * Builds a Structure object containing the quaternary structure built from given asymUnit and transformations, by adding symmetry partners as new models. The output Structure will be different depending on the multiModel parameter: <li> the symmetry-expanded chains are added as new models, one per transformId. All original models but  the first one are discarded. </li> <li> as original with symmetry-expanded chains added with renamed chain ids and names (in the form  originalAsymId_transformId and originalAuthId_transformId) </li>
 * @param asymUnit
 * @param transformations
 * @param useAsymIds if true use {@link Chain#getId()} to match the ids in the BiologicalAssemblyTransformation (needed if data read from mmCIF), if false use  {@link Chain#getName()} for the chain matching (needed if data read from PDB).
 * @param multiModel if true the output Structure will be a multi-model one with one transformId per model, if false the outputStructure will be as the original with added chains with renamed asymIds (in the form originalAsymId_transformId and originalAuthId_transformId). 
 * @return
 */
public Structure rebuildQuaternaryStructure(Structure asymUnit,List<BiologicalAssemblyTransformation> transformations,boolean useAsymIds,boolean multiModel){
  orderTransformationsByChainId(asymUnit,transformations);
  Structure s=asymUnit.clone();
  s.resetModels();
  for (  BiologicalAssemblyTransformation transformation : transformations) {
    List<Chain> chainsToTransform=new ArrayList<>();
    if (useAsymIds) {
      Chain c=asymUnit.getChain(transformation.getChainId());
      chainsToTransform.add(c);
    }
 else {
      Chain polyC=asymUnit.getPolyChainByPDB(transformation.getChainId());
      List<Chain> nonPolyCs=asymUnit.getNonPolyChainsByPDB(transformation.getChainId());
      Chain waterC=asymUnit.getWaterChainByPDB(transformation.getChainId());
      if (polyC != null)       chainsToTransform.add(polyC);
      if (!nonPolyCs.isEmpty())       chainsToTransform.addAll(nonPolyCs);
      if (waterC != null)       chainsToTransform.add(waterC);
    }
    for (    Chain c : chainsToTransform) {
      Chain chain=(Chain)c.clone();
      for (      Group g : chain.getAtomGroups()) {
        for (        Atom a : g.getAtoms()) {
          transformation.transformPoint(a.getCoords());
        }
      }
      String transformId=transformation.getId();
      if (multiModel)       addChainMultiModel(s,chain,transformId);
 else       addChainFlattened(s,chain,transformId);
    }
  }
  s.setBiologicalAssembly(true);
  return s;
}","/** 
 * Builds a Structure object containing the quaternary structure built from given asymUnit and transformations, by adding symmetry partners as new models. The output Structure will be different depending on the multiModel parameter: <li> the symmetry-expanded chains are added as new models, one per transformId. All original models but  the first one are discarded. </li> <li> as original with symmetry-expanded chains added with renamed chain ids and names (in the form  originalAsymId_transformId and originalAuthId_transformId) </li>
 * @param asymUnit
 * @param transformations
 * @param useAsymIds if true use {@link Chain#getId()} to match the ids in the BiologicalAssemblyTransformation (needed if data read from mmCIF), if false use  {@link Chain#getName()} for the chain matching (needed if data read from PDB).
 * @param multiModel if true the output Structure will be a multi-model one with one transformId per model, if false the outputStructure will be as the original with added chains with renamed asymIds (in the form originalAsymId_transformId and originalAuthId_transformId). 
 * @return
 */
public Structure rebuildQuaternaryStructure(Structure asymUnit,List<BiologicalAssemblyTransformation> transformations,boolean useAsymIds,boolean multiModel){
  orderTransformationsByChainId(asymUnit,transformations);
  Structure s=asymUnit.clone();
  s.resetModels();
  for (  BiologicalAssemblyTransformation transformation : transformations) {
    List<Chain> chainsToTransform=new ArrayList<>();
    if (useAsymIds) {
      Chain c=asymUnit.getChain(transformation.getChainId());
      chainsToTransform.add(c);
    }
 else {
      Chain polyC=asymUnit.getPolyChainByPDB(transformation.getChainId());
      List<Chain> nonPolyCs=asymUnit.getNonPolyChainsByPDB(transformation.getChainId());
      Chain waterC=asymUnit.getWaterChainByPDB(transformation.getChainId());
      if (polyC != null)       chainsToTransform.add(polyC);
      if (!nonPolyCs.isEmpty())       chainsToTransform.addAll(nonPolyCs);
      if (waterC != null)       chainsToTransform.add(waterC);
    }
    for (    Chain c : chainsToTransform) {
      Chain chain=(Chain)c.clone();
      Calc.transform(chain,transformation.getTransformationMatrix());
      String transformId=transformation.getId();
      if (multiModel)       addChainMultiModel(s,chain,transformId);
 else       addChainFlattened(s,chain,transformId);
    }
  }
  s.setBiologicalAssembly(true);
  return s;
}",0.8677521842732328
16381,"@Test public void test1STP() throws IOException, StructureException {
  testID(""String_Node_Str"",1,4);
}","@Test public void test1STP() throws IOException, StructureException {
  comparePdbVsMmcif(""String_Node_Str"",1,4);
}",0.91324200913242
16382,"@Test public void test3NTU() throws IOException, StructureException {
  testID(""String_Node_Str"",1,6);
}","@Test public void test3NTU() throws IOException, StructureException {
  comparePdbVsMmcif(""String_Node_Str"",1,6);
}",0.91324200913242
16383,"@Test public void test5LDH() throws IOException, StructureException {
  testID(""String_Node_Str"",1,4);
  boolean gotException=false;
  try {
    AtomCache cache=new AtomCache();
    cache.setUseMmCif(true);
    StructureIO.setAtomCache(cache);
    StructureIO.getBiologicalAssembly(""String_Node_Str"",3);
  }
 catch (  StructureException e) {
    gotException=true;
  }
  assertTrue(""String_Node_Str"",gotException);
  gotException=false;
  try {
    AtomCache cache=new AtomCache();
    cache.setUseMmCif(true);
    StructureIO.setAtomCache(cache);
    StructureIO.getBiologicalAssembly(""String_Node_Str"",2);
  }
 catch (  StructureException e) {
    gotException=true;
  }
  assertTrue(""String_Node_Str"",!gotException);
}","@Test public void test5LDH() throws IOException, StructureException {
  comparePdbVsMmcif(""String_Node_Str"",1,4);
  boolean gotException=false;
  try {
    AtomCache cache=new AtomCache();
    cache.setUseMmCif(true);
    StructureIO.setAtomCache(cache);
    StructureIO.getBiologicalAssembly(""String_Node_Str"",3);
  }
 catch (  StructureException e) {
    gotException=true;
  }
  assertTrue(""String_Node_Str"",gotException);
  gotException=false;
  try {
    AtomCache cache=new AtomCache();
    cache.setUseMmCif(true);
    StructureIO.setAtomCache(cache);
    StructureIO.getBiologicalAssembly(""String_Node_Str"",2);
  }
 catch (  StructureException e) {
    gotException=true;
  }
  assertTrue(""String_Node_Str"",!gotException);
}",0.9841706813489332
16384,"@Test public void test3FAD() throws IOException, StructureException {
  testID(""String_Node_Str"",1,1);
  testID(""String_Node_Str"",2,2);
}","@Test public void test3FAD() throws IOException, StructureException {
  comparePdbVsMmcif(""String_Node_Str"",1,1);
  comparePdbVsMmcif(""String_Node_Str"",2,2);
}",0.8716216216216216
16385,"@Test public void test1A29() throws IOException, StructureException {
  testID(""String_Node_Str"",1,1);
}","@Test public void test1A29() throws IOException, StructureException {
  comparePdbVsMmcif(""String_Node_Str"",1,1);
}",0.91324200913242
16386,"@Override public void run(){
  CESymmParameters params=parent.getParameters();
  try {
    Atom[] atoms=StructureTools.getRepresentativeAtomArray(structure);
    CeSymmResult result=CeSymm.analyze(atoms,params);
    SymmetryDisplay.display(result);
  }
 catch (  StructureException e) {
    logger.warn(e.getMessage());
  }
  parent.notifyCalcFinished();
}","@Override public void run(){
  CESymmParameters params=parent.getParameters();
  try {
    Atom[] atoms=SymmetryTools.getRepresentativeAtoms(structure);
    CeSymmResult result=CeSymm.analyze(atoms,params);
    SymmetryDisplay.display(result);
  }
 catch (  StructureException e) {
    logger.warn(e.getMessage());
  }
  parent.notifyCalcFinished();
}",0.9702970297029704
16387,"/** 
 * Displays a single structure in a cartoon representation with each symmetric repeat colored differently.
 * @param msa the symmetry multiple alignment obtained from CeSymm
 * @throws StructureException
 */
public static AbstractAlignmentJmol display(CeSymmResult symmResult) throws StructureException {
  if (symmResult.isSignificant() && symmResult.isRefined()) {
    MultipleAlignment msa=symmResult.getMultipleAlignment();
    List<Atom[]> atoms=msa.getAtomArrays();
    MultipleAlignmentJmol jmol=new MultipleAlignmentJmol(msa,atoms);
    jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());
    addSymmetryMenu(jmol,symmResult);
    jmol.evalString(printSymmetryGroup(symmResult));
    jmol.evalString(printSymmetryAxes(symmResult));
    jmol.setTitle(getSymmTitle(symmResult));
    return jmol;
  }
 else {
    logger.info(""String_Node_Str"");
    Atom[] cloned=StructureTools.cloneAtomArray(symmResult.getAtoms());
    AbstractAlignmentJmol jmol=StructureAlignmentDisplay.display(symmResult.getSelfAlignment(),symmResult.getAtoms(),cloned);
    RotationAxis axis=new RotationAxis(symmResult.getSelfAlignment());
    jmol.evalString(axis.getJmolScript(symmResult.getAtoms()));
    return jmol;
  }
}","/** 
 * Displays a single structure in a cartoon representation with each symmetric repeat colored differently.
 * @param msa the symmetry multiple alignment obtained from CeSymm
 * @throws StructureException
 */
public static AbstractAlignmentJmol display(CeSymmResult symmResult) throws StructureException {
  if (symmResult.isSignificant() && symmResult.isRefined()) {
    MultipleAlignment msa=symmResult.getMultipleAlignment();
    List<Atom[]> atoms=msa.getAtomArrays();
    Atom[] allAtoms=atoms.get(0);
    List<Group> hetatms=StructureTools.getUnalignedGroups(allAtoms);
    allAtoms=Arrays.copyOf(allAtoms,allAtoms.length + hetatms.size());
    for (int h=0; h < hetatms.size(); h++) {
      int index=(allAtoms.length - hetatms.size()) + h;
      allAtoms[index]=hetatms.get(h).getAtom(0);
    }
    for (int s=0; s < msa.size(); s++)     atoms.set(s,allAtoms);
    MultipleAlignmentJmol jmol=new MultipleAlignmentJmol(msa,atoms);
    jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());
    addSymmetryMenu(jmol,symmResult);
    jmol.evalString(printSymmetryGroup(symmResult));
    jmol.evalString(printSymmetryAxes(symmResult));
    jmol.setTitle(getSymmTitle(symmResult));
    return jmol;
  }
 else {
    logger.info(""String_Node_Str"");
    Atom[] cloned=StructureTools.cloneAtomArray(symmResult.getAtoms());
    AbstractAlignmentJmol jmol=StructureAlignmentDisplay.display(symmResult.getSelfAlignment(),symmResult.getAtoms(),cloned);
    RotationAxis axis=new RotationAxis(symmResult.getSelfAlignment());
    jmol.evalString(axis.getJmolScript(symmResult.getAtoms()));
    return jmol;
  }
}",0.8603667136812412
16388,"/** 
 * Generates a String that displays the symmetry axes of a structure.
 * @param symm CeSymmResult
 * @return
 * @throws StructureException 
 */
public static String printSymmetryAxes(CeSymmResult symm) throws StructureException {
  int id=0;
  String script=""String_Node_Str"";
  SymmetryAxes axes=symm.getAxes();
  List<Atom[]> repeats=SymmetryTools.toRepeatsAlignment(symm).getAtomArrays();
  List<Matrix4d> symmAxes=axes.getElementaryAxes();
  for (int a=0; a < symmAxes.size(); a++) {
    RotationAxis rot=new RotationAxis(symmAxes.get(a));
    Set<Integer> repIndex=new TreeSet<Integer>(axes.getRepeatRelation(a).get(0));
    repIndex.addAll(axes.getRepeatRelation(a).get(1));
    List<Atom> repAtoms=new ArrayList<Atom>();
    for (    Integer r : repIndex)     repAtoms.addAll(Arrays.asList(repeats.get(r)));
    script+=rot.getJmolScript(repAtoms.toArray(new Atom[repAtoms.size()]),id);
    id++;
  }
  return script;
}","/** 
 * Generates a String that displays the symmetry axes of a structure.
 * @param symm CeSymmResult
 * @return
 * @throws StructureException
 */
public static String printSymmetryAxes(CeSymmResult symm) throws StructureException {
  int id=0;
  String script=""String_Node_Str"";
  SymmetryAxes axes=symm.getAxes();
  List<Atom[]> repeats=SymmetryTools.toRepeatsAlignment(symm).getAtomArrays();
  List<Matrix4d> symmAxes=axes.getElementaryAxes();
  for (int a=0; a < symmAxes.size(); a++) {
    RotationAxis rot=new RotationAxis(symmAxes.get(a));
    Set<Integer> repIndex=new TreeSet<Integer>(axes.getRepeatRelation(a).get(0));
    repIndex.addAll(axes.getRepeatRelation(a).get(1));
    List<Atom> repAtoms=new ArrayList<Atom>();
    for (    Integer r : repIndex)     repAtoms.addAll(Arrays.asList(repeats.get(r)));
    script+=rot.getJmolScript(repAtoms.toArray(new Atom[repAtoms.size()]),id);
    id++;
  }
  return script;
}",0.999462654486835
16389,"/** 
 * New structures are downloaded if they were not cached in the alignment and they are entirely transformed here with the superposition information in the Multiple Alignment.
 * @param multAln
 * @return list of transformed AtomArrays
 * @throws StructureException
 */
public static List<Atom[]> getRotatedAtoms(MultipleAlignment multAln) throws StructureException {
  int size=multAln.size();
  List<Atom[]> atomArrays=multAln.getAtomArrays();
  for (int i=0; i < size; i++) {
    if (atomArrays.get(i).length < 1)     throw new StructureException(""String_Node_Str"" + atomArrays.get(i).length);
  }
  List<Atom[]> rotatedAtoms=new ArrayList<Atom[]>();
  List<Matrix4d> transf=multAln.getBlockSet(0).getTransformations();
  if (transf == null) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"");
    multAln=multAln.clone();
    MultipleSuperimposer imposer=new ReferenceSuperimposer();
    imposer.superimpose(multAln);
    transf=multAln.getBlockSet(0).getTransformations();
    assert(transf != null);
  }
  for (int i=0; i < size; i++) {
    Structure displayS=atomArrays.get(i)[0].getGroup().getChain().getStructure().clone();
    Atom[] rotCA=StructureTools.getRepresentativeAtomArray(displayS);
    List<Group> hetatms=StructureTools.getUnalignedGroups(rotCA);
    for (    Group g : hetatms) {
      rotCA=Arrays.copyOf(rotCA,rotCA.length + 1);
      rotCA[rotCA.length - 1]=g.getAtom(0);
    }
    Calc.transform(displayS,transf.get(i));
    rotatedAtoms.add(rotCA);
  }
  return rotatedAtoms;
}","/** 
 * New structures are downloaded if they were not cached in the alignment and they are entirely transformed here with the superposition information in the Multiple Alignment.
 * @param multAln
 * @return list of transformed AtomArrays
 * @throws StructureException
 */
public static List<Atom[]> getRotatedAtoms(MultipleAlignment multAln) throws StructureException {
  int size=multAln.size();
  List<Atom[]> atomArrays=multAln.getAtomArrays();
  for (int i=0; i < size; i++) {
    if (atomArrays.get(i).length < 1)     throw new StructureException(""String_Node_Str"" + atomArrays.get(i).length);
  }
  List<Atom[]> rotatedAtoms=new ArrayList<Atom[]>();
  List<Matrix4d> transf=multAln.getBlockSet(0).getTransformations();
  if (transf == null) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"");
    multAln=multAln.clone();
    MultipleSuperimposer imposer=new ReferenceSuperimposer();
    imposer.superimpose(multAln);
    transf=multAln.getBlockSet(0).getTransformations();
    assert(transf != null);
  }
  for (int i=0; i < size; i++) {
    Structure displayS=atomArrays.get(i)[0].getGroup().getChain().getStructure().clone();
    Atom[] rotCA=StructureTools.getRepresentativeAtomArray(displayS);
    List<Group> hetatms=StructureTools.getUnalignedGroups(rotCA);
    int index=rotCA.length;
    rotCA=Arrays.copyOf(rotCA,rotCA.length + hetatms.size());
    for (    Group g : hetatms) {
      rotCA[index]=g.getAtom(0);
      index++;
    }
    Calc.transform(displayS,transf.get(i));
    rotatedAtoms.add(rotCA);
  }
  return rotatedAtoms;
}",0.8780487804878049
16390,"public static void main(String[] args){
  try {
    BioUnitDataProviderFactory.setBioUnitDataProvider(BioUnitDataProviderFactory.pdbProviderClassName);
    Structure bioAssembly=StructureIO.getBiologicalAssembly(""String_Node_Str"",1);
    StructureAlignmentJmol jmolPanel=new StructureAlignmentJmol();
    jmolPanel.setStructure(bioAssembly);
    jmolPanel.evalString(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public static void main(String[] args){
  try {
    Structure bioAssembly=StructureIO.getBiologicalAssembly(""String_Node_Str"",1);
    StructureAlignmentJmol jmolPanel=new StructureAlignmentJmol();
    jmolPanel.setStructure(bioAssembly);
    jmolPanel.evalString(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.8810068649885584
16391,"/** 
 * An example demonstrating how to directly use the mmCif file parsing classes. This could potentially be used to use the parser to populate a data-structure that is different from the biojava-structure data model.
 */
public void loadFromDirectAccess(){
  String pdbId=""String_Node_Str"";
  StructureProvider pdbreader=new MMCIFFileReader();
  try {
    Structure s=pdbreader.getStructureById(pdbId);
    List<Chain> hs=s.getNonPolyChainsByPDB(""String_Node_Str"");
    Chain h=hs.get(0);
    List<Group> ligands=h.getAtomLigands();
    System.out.println(""String_Node_Str"" + h.getName());
    for (    Group l : ligands) {
      System.out.println(l);
    }
    System.out.println(""String_Node_Str"");
    Group qwe=h.getGroupByPDB(new ResidueNumber(""String_Node_Str"",373,null));
    System.out.println(qwe.getChemComp());
    System.out.println(h.getSeqResSequence());
    System.out.println(h.getAtomSequence());
    System.out.println(h.getAtomGroups(GroupType.HETATM));
    System.out.println(""String_Node_Str"" + s.getEntityInfos());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 * An example demonstrating how to directly use the mmCif file parsing classes. This could potentially be used to use the parser to populate a data-structure that is different from the biojava-structure data model.
 */
public void loadFromDirectAccess(){
  String pdbId=""String_Node_Str"";
  StructureProvider pdbreader=new MMCIFFileReader();
  try {
    Structure s=pdbreader.getStructureById(pdbId);
    List<Chain> hs=s.getNonPolyChainsByPDB(""String_Node_Str"");
    Chain h=hs.get(0);
    List<Group> ligands=h.getAtomGroups();
    System.out.println(""String_Node_Str"" + h.getName());
    for (    Group l : ligands) {
      System.out.println(l);
    }
    System.out.println(""String_Node_Str"");
    Group qwe=h.getGroupByPDB(new ResidueNumber(""String_Node_Str"",373,null));
    System.out.println(qwe.getChemComp());
    System.out.println(h.getSeqResSequence());
    System.out.println(h.getAtomSequence());
    System.out.println(h.getAtomGroups(GroupType.HETATM));
    System.out.println(""String_Node_Str"" + s.getEntityInfos());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9949977262391996
16392,"/** 
 * Returns the macromolecular size of this biological assembly, i.e. the number of polymeric chains (protein or nucleotide chains) in the biological  assembly.
 * @return
 */
public int getMacromolecularSize(){
  for (  BiologicalAssemblyTransformation bat : getTransforms()) {
  }
  return macromolecularSize;
}","/** 
 * Returns the macromolecular size of this biological assembly, i.e. the number of polymeric chains (protein or nucleotide chains) in the biological  assembly.
 * @return
 */
public int getMacromolecularSize(){
  return macromolecularSize;
}",0.7779751332149201
16393,"/** 
 * Builds a Structure object containing the quaternary structure built from given asymUnit and transformations, by adding symmetry partners as new models. If the input Structure is multi-model, then only model 1 is retained and the quaternary structure is built in the same way with additional models.
 * @param asymUnit
 * @param transformations
 * @param useAsymIds if true use {@link Chain#getId()} to match the ids in the BiologicalAssemblyTransformation (needed if data read from mmCIF), if false use  {@link Chain#getName()} for the chain matching (needed if data read from PDB).
 * @return
 */
public Structure rebuildQuaternaryStructure(Structure asymUnit,List<BiologicalAssemblyTransformation> transformations,boolean useAsymIds){
  orderTransformationsByChainId(asymUnit,transformations);
  Structure s=asymUnit.clone();
  s.resetModels();
  for (  BiologicalAssemblyTransformation transformation : transformations) {
    List<Chain> chainsToTransform=new ArrayList<>();
    if (useAsymIds) {
      Chain c=asymUnit.getChain(transformation.getChainId());
      chainsToTransform.add(c);
    }
 else {
      Chain polyC=asymUnit.getPolyChainByPDB(transformation.getChainId());
      List<Chain> nonPolyCs=asymUnit.getNonPolyChainsByPDB(transformation.getChainId());
      chainsToTransform.add(polyC);
      chainsToTransform.addAll(nonPolyCs);
    }
    for (    Chain c : chainsToTransform) {
      Chain chain=(Chain)c.clone();
      for (      Group g : chain.getAtomGroups()) {
        for (        Atom a : g.getAtoms()) {
          transformation.transformPoint(a.getCoords());
        }
      }
      String transformId=transformation.getId();
      addChainAndModel(s,chain,transformId);
    }
  }
  s.setBiologicalAssembly(true);
  return s;
}","/** 
 * Builds a Structure object containing the quaternary structure built from given asymUnit and transformations, by adding symmetry partners as new models. If the input Structure is multi-model, then only model 1 is retained and the quaternary structure is built in the same way with additional models.
 * @param asymUnit
 * @param transformations
 * @param useAsymIds if true use {@link Chain#getId()} to match the ids in the BiologicalAssemblyTransformation (needed if data read from mmCIF), if false use  {@link Chain#getName()} for the chain matching (needed if data read from PDB).
 * @return
 */
public Structure rebuildQuaternaryStructure(Structure asymUnit,List<BiologicalAssemblyTransformation> transformations,boolean useAsymIds){
  orderTransformationsByChainId(asymUnit,transformations);
  Structure s=asymUnit.clone();
  s.resetModels();
  for (  BiologicalAssemblyTransformation transformation : transformations) {
    List<Chain> chainsToTransform=new ArrayList<>();
    if (useAsymIds) {
      Chain c=asymUnit.getChain(transformation.getChainId());
      chainsToTransform.add(c);
    }
 else {
      Chain polyC=asymUnit.getPolyChainByPDB(transformation.getChainId());
      List<Chain> nonPolyCs=asymUnit.getNonPolyChainsByPDB(transformation.getChainId());
      Chain waterC=asymUnit.getWaterChainByPDB(transformation.getChainId());
      if (polyC != null)       chainsToTransform.add(polyC);
      if (!nonPolyCs.isEmpty())       chainsToTransform.addAll(nonPolyCs);
      if (waterC != null)       chainsToTransform.add(waterC);
    }
    for (    Chain c : chainsToTransform) {
      Chain chain=(Chain)c.clone();
      for (      Group g : chain.getAtomGroups()) {
        for (        Atom a : g.getAtoms()) {
          transformation.transformPoint(a.getCoords());
        }
      }
      String transformId=transformation.getId();
      addChainAndModel(s,chain,transformId);
    }
  }
  s.setBiologicalAssembly(true);
  return s;
}",0.9471991423210936
16394,"/** 
 * @return
 */
private Group getGroupWithSameResNumButDiffPDBName(){
  for (  Group g : chain.getAtomGroups()) {
    if (g.getResidueNumber().getSeqNum() == group.getResidueNumber().getSeqNum()) {
      if (!g.getPDBName().equals(group.getPDBName())) {
        return g;
      }
    }
  }
  return null;
}","/** 
 * @return
 */
private Group getGroupWithSameResNumButDiffPDBName(){
  for (  Group g : chain.getAtomGroups()) {
    if (g.getResidueNumber().equals(group.getResidueNumber())) {
      if (!g.getPDBName().equals(group.getPDBName())) {
        return g;
      }
    }
  }
  return null;
}",0.8153078202995009
16395,"@Override public void setHeaderInfo(float rFree,float rWork,float resolution,String title,String depositionDate,String releaseDate,String[] experimnetalMethods){
  SimpleDateFormat formatter=new SimpleDateFormat(""String_Node_Str"");
  PDBHeader pdbHeader=structure.getPDBHeader();
  pdbHeader.setTitle(title);
  pdbHeader.setResolution(resolution);
  pdbHeader.setRfree(rFree);
  pdbHeader.setRwork(rWork);
  for (  String techniqueStr : experimnetalMethods) {
    pdbHeader.setExperimentalTechnique(techniqueStr);
  }
  try {
    Date depDate=formatter.parse(depositionDate);
    pdbHeader.setDepDate(depDate);
  }
 catch (  ParseException e) {
    logger.warn(""String_Node_Str"",depositionDate);
  }
  try {
    Date relDate=formatter.parse(releaseDate);
    pdbHeader.setModDate(relDate);
  }
 catch (  ParseException e) {
    logger.warn(""String_Node_Str"",releaseDate);
  }
}","@Override public void setHeaderInfo(float rFree,float rWork,float resolution,String title,String depositionDate,String releaseDate,String[] experimnetalMethods){
  SimpleDateFormat formatter=new SimpleDateFormat(""String_Node_Str"");
  PDBHeader pdbHeader=structure.getPDBHeader();
  pdbHeader.setTitle(title);
  pdbHeader.setResolution(resolution);
  pdbHeader.setRfree(rFree);
  pdbHeader.setRwork(rWork);
  for (  String techniqueStr : experimnetalMethods) {
    pdbHeader.setExperimentalTechnique(techniqueStr);
  }
  if (depositionDate != null) {
    try {
      Date depDate=formatter.parse(depositionDate);
      pdbHeader.setDepDate(depDate);
    }
 catch (    ParseException e) {
      logger.warn(""String_Node_Str"",depositionDate);
    }
  }
 else {
    pdbHeader.setDepDate(new Date(0));
  }
  if (releaseDate != null) {
    try {
      Date relDate=formatter.parse(releaseDate);
      pdbHeader.setModDate(relDate);
    }
 catch (    ParseException e) {
      logger.warn(""String_Node_Str"",releaseDate);
    }
  }
 else {
    pdbHeader.setModDate(new Date(0));
  }
}",0.8981054787506401
16396,"/** 
 * Parse a PDB file and return a datastructure implementing PDBStructure interface.
 * @param buf  a BufferedReader object
 * @return the Structure object
 * @throws IOException ...
 */
public Structure parsePDBFile(BufferedReader buf) throws IOException {
  loadMaxAtoms=params.getMaxAtoms();
  atomCAThreshold=params.getAtomCaThreshold();
  allModels=new ArrayList<>();
  structure=new StructureImpl();
  currentModel=null;
  currentChain=null;
  currentGroup=null;
  startOfMolecule=true;
  startOfModel=true;
  seqResChains=new ArrayList<Chain>();
  siteMap=new LinkedHashMap<String,Site>();
  pdbHeader=new PDBHeader();
  connects=new ArrayList<Map<String,Integer>>();
  previousContinuationField=""String_Node_Str"";
  continuationField=""String_Node_Str"";
  continuationString=""String_Node_Str"";
  current_compound=null;
  sourceLines.clear();
  compndLines.clear();
  isLastCompndLine=false;
  isLastSourceLine=false;
  prevMolId=-1;
  entities.clear();
  helixList.clear();
  strandList.clear();
  turnList.clear();
  lengthCheck=-1;
  atomCount=0;
  atomOverflow=false;
  siteToResidueMap.clear();
  parseCAonly=params.isParseCAOnly();
  String line=null;
  while ((line=buf.readLine()) != null) {
    if (line.equals(""String_Node_Str"") || (line.equals(NEWLINE))) {
      continue;
    }
    if (line.startsWith(""String_Node_Str"")) {
      continue;
    }
    if (line.length() < 6) {
      logger.info(""String_Node_Str"" + line + ""String_Node_Str"");
      continue;
    }
    String recordName=line.substring(0,6).trim();
    if (recordName.equals(""String_Node_Str""))     pdb_ATOM_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_SEQRES_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_ATOM_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_MODEL_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_TER_Handler();
 else     if (recordName.equals(""String_Node_Str""))     pdb_HEADER_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_AUTHOR_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_TITLE_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     sourceLines.add(line);
 else     if (recordName.equals(""String_Node_Str""))     compndLines.add(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_JRNL_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_EXPDTA_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_CRYST1_Handler(line);
 else     if (recordName.startsWith(""String_Node_Str""))     pdb_MTRIXn_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_REMARK_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_CONECT_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_REVDAT_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_DBREF_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_SITE_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_SSBOND_Handler(line);
 else     if (params.isParseSecStruc()) {
      if (recordName.equals(""String_Node_Str""))       pdb_HELIX_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_SHEET_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_TURN_Handler(line);
    }
 else {
    }
  }
  makeCompounds(compndLines,sourceLines);
  triggerEndFileChecks();
  if (params.shouldCreateAtomBonds()) {
    formBonds();
  }
  if (params.shouldCreateAtomCharges()) {
    addCharges();
  }
  if (params.isParseSecStruc() && !params.isHeaderOnly())   setSecStruc();
  StructureTools.cleanUpAltLocs(structure);
  return structure;
}","/** 
 * Parse a PDB file and return a datastructure implementing PDBStructure interface.
 * @param buf  a BufferedReader object
 * @return the Structure object
 * @throws IOException ...
 */
public Structure parsePDBFile(BufferedReader buf) throws IOException {
  loadMaxAtoms=params.getMaxAtoms();
  atomCAThreshold=params.getAtomCaThreshold();
  allModels=new ArrayList<>();
  structure=new StructureImpl();
  currentModel=null;
  currentChain=null;
  currentGroup=null;
  startOfMolecule=true;
  startOfModel=true;
  seqResChains=new ArrayList<Chain>();
  siteMap=new LinkedHashMap<String,Site>();
  pdbHeader=new PDBHeader();
  connects=new ArrayList<Map<String,Integer>>();
  previousContinuationField=""String_Node_Str"";
  continuationField=""String_Node_Str"";
  continuationString=""String_Node_Str"";
  current_compound=null;
  sourceLines.clear();
  compndLines.clear();
  isLastCompndLine=false;
  isLastSourceLine=false;
  prevMolId=-1;
  entities.clear();
  helixList.clear();
  strandList.clear();
  turnList.clear();
  lengthCheck=-1;
  atomCount=0;
  atomOverflow=false;
  siteToResidueMap.clear();
  parseCAonly=params.isParseCAOnly();
  String line=null;
  while ((line=buf.readLine()) != null) {
    if (line.equals(""String_Node_Str"") || (line.equals(NEWLINE))) {
      continue;
    }
    if (line.startsWith(""String_Node_Str"")) {
      continue;
    }
    if (line.length() < 6 && !line.startsWith(""String_Node_Str"")) {
      logger.info(""String_Node_Str"" + line + ""String_Node_Str"");
      continue;
    }
    String recordName=null;
    if (line.length() < 6)     recordName=line.trim();
 else     recordName=line.substring(0,6).trim();
    if (recordName.equals(""String_Node_Str""))     pdb_ATOM_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_SEQRES_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_ATOM_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_MODEL_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_TER_Handler();
 else     if (recordName.equals(""String_Node_Str""))     pdb_HEADER_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_AUTHOR_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_TITLE_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     sourceLines.add(line);
 else     if (recordName.equals(""String_Node_Str""))     compndLines.add(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_JRNL_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_EXPDTA_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_CRYST1_Handler(line);
 else     if (recordName.startsWith(""String_Node_Str""))     pdb_MTRIXn_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_REMARK_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_CONECT_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_REVDAT_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_DBREF_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_SITE_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_SSBOND_Handler(line);
 else     if (params.isParseSecStruc()) {
      if (recordName.equals(""String_Node_Str""))       pdb_HELIX_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_SHEET_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_TURN_Handler(line);
    }
 else {
    }
  }
  makeCompounds(compndLines,sourceLines);
  triggerEndFileChecks();
  if (params.shouldCreateAtomBonds()) {
    formBonds();
  }
  if (params.shouldCreateAtomCharges()) {
    addCharges();
  }
  if (params.isParseSecStruc() && !params.isHeaderOnly())   setSecStruc();
  StructureTools.cleanUpAltLocs(structure);
  return structure;
}",0.9843081312410842
16397,"@Test public void testZipChemCompProvider() throws IOException {
  InputStream testPDB=new ByteArrayInputStream(DNAexample.getBytes());
  UserConfiguration config=new UserConfiguration();
  String cachePath=config.getCacheFilePath();
  Path pdbdir=Paths.get(cachePath);
  Path chemComp=pdbdir.resolve(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + pdbdir.toString() + ""String_Node_Str"");
  ZipChemCompProvider zp=new ZipChemCompProvider(chemComp.toString(),pdbdir.toString());
  zp.setRemoveCif(false);
  ChemCompGroupFactory.setChemCompProvider(zp);
  FileParsingParameters params=new FileParsingParameters();
  PDBFileReader pdbreader=new PDBFileReader();
  pdbreader.setFileParsingParameters(params);
  Structure s=pdbreader.getStructure(testPDB);
  assertEquals(5,s.getChain(0).getAtomGroups().size());
}","@Test public void testZipChemCompProvider() throws IOException {
  InputStream testPDB=new ByteArrayInputStream(DNAexample.getBytes());
  UserConfiguration config=new UserConfiguration();
  String cachePath=config.getCacheFilePath();
  Path pdbdir=Paths.get(cachePath);
  Path chemComp=pdbdir.resolve(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + pdbdir.toString() + ""String_Node_Str"");
  ZipChemCompProvider zp=new ZipChemCompProvider(chemComp.toString(),pdbdir.toString());
  zp.setRemoveCif(false);
  ChemCompGroupFactory.setChemCompProvider(zp);
  FileParsingParameters params=new FileParsingParameters();
  PDBFileReader pdbreader=new PDBFileReader();
  pdbreader.setFileParsingParameters(params);
  Structure s=pdbreader.getStructure(testPDB);
  assertEquals(3,s.getChain(0).getAtomGroups().size());
}",0.9987834549878344
16398,"@Test public void testSeqResParsing(){
  List<Chain> chains=structure.getChains(0);
  assertEquals(""String_Node_Str"",2,chains.size());
  Chain c=chains.get(0);
  List<Group> seqResGroups=c.getSeqResGroups();
  assertEquals(""String_Node_Str"",58,seqResGroups.size());
  List<Group> atomGroups=c.getAtomGroups();
  Group g3=seqResGroups.get(2);
  int indexAtom=atomGroups.indexOf(g3);
  assertEquals(""String_Node_Str"",2,indexAtom);
  Group g5=atomGroups.get(5);
  assertEquals(""String_Node_Str"",5,seqResGroups.indexOf(g5));
  Chain c2=chains.get(1);
  List<Group> atomGroups2=c2.getAtomGroups();
  Group g58=atomGroups2.get(0);
  assertEquals(""String_Node_Str"",""String_Node_Str"",g58.getPDBName());
  assertEquals(""String_Node_Str"",-1,seqResGroups.indexOf(g58));
}","@Test public void testSeqResParsing(){
  List<Chain> chains=structure.getChains(0);
  assertEquals(""String_Node_Str"",4,chains.size());
  Chain c=chains.get(0);
  List<Group> seqResGroups=c.getSeqResGroups();
  assertEquals(""String_Node_Str"",58,seqResGroups.size());
  List<Group> atomGroups=c.getAtomGroups();
  Group g3=seqResGroups.get(2);
  int indexAtom=atomGroups.indexOf(g3);
  assertEquals(""String_Node_Str"",2,indexAtom);
  Group g5=atomGroups.get(5);
  assertEquals(""String_Node_Str"",5,seqResGroups.indexOf(g5));
  Chain c2=chains.get(1);
  List<Group> atomGroups2=c2.getAtomGroups();
  Group g58=atomGroups2.get(0);
  assertEquals(""String_Node_Str"",""String_Node_Str"",g58.getPDBName());
  assertEquals(""String_Node_Str"",-1,seqResGroups.indexOf(g58));
}",0.9986842105263158
16399,"/** 
 * Tests if a PDB file can be parsed
 * @throws Exception
 */
@Test public void testReadPDBFile() throws Exception {
  assertEquals(""String_Node_Str"",""String_Node_Str"",structure.getPDBCode());
  Chain c=structure.getChain(0);
  assertEquals(""String_Node_Str"",58,c.getAtomGroups(GroupType.AMINOACID).size());
  assertEquals(0,c.getAtomGroups(GroupType.HETATM).size());
  Chain c2=structure.getChain(1);
  assertEquals(64,c2.getAtomGroups(GroupType.HETATM).size());
  assertEquals(0,c2.getAtomGroups(GroupType.NUCLEOTIDE).size());
  List<EntityInfo> compounds=structure.getEntityInfos();
  EntityInfo mol=compounds.get(0);
  assertTrue(mol.getDescription().startsWith(""String_Node_Str""));
}","/** 
 * Tests if a PDB file can be parsed
 * @throws Exception
 */
@Test public void testReadPDBFile() throws Exception {
  assertEquals(""String_Node_Str"",""String_Node_Str"",structure.getPDBCode());
  Chain c=structure.getChain(0);
  assertEquals(""String_Node_Str"",58,c.getAtomGroups(GroupType.AMINOACID).size());
  assertEquals(0,c.getAtomGroups(GroupType.HETATM).size());
  Chain c4=structure.getChain(3);
  assertEquals(63,c4.getAtomGroups(GroupType.HETATM).size());
  assertEquals(0,c4.getAtomGroups(GroupType.NUCLEOTIDE).size());
  List<EntityInfo> compounds=structure.getEntityInfos();
  assertEquals(4,compounds.size());
  EntityInfo mol=compounds.get(0);
  assertTrue(mol.getDescription().startsWith(""String_Node_Str""));
}",0.9662447257383966
16400,"@BeforeClass public static void setUp() throws IOException {
  InputStream inStream=StructureTest.class.getResourceAsStream(""String_Node_Str"");
  assertNotNull(inStream);
  PDBFileParser pdbpars=new PDBFileParser();
  FileParsingParameters params=new FileParsingParameters();
  params.setAlignSeqRes(true);
  params.setCreateAtomBonds(true);
  pdbpars.setFileParsingParameters(params);
  structure=pdbpars.parsePDBFile(inStream);
  assertNotNull(structure);
  assertEquals(""String_Node_Str"",2,structure.size());
}","@BeforeClass public static void setUp() throws IOException {
  InputStream inStream=StructureTest.class.getResourceAsStream(""String_Node_Str"");
  assertNotNull(inStream);
  PDBFileParser pdbpars=new PDBFileParser();
  FileParsingParameters params=new FileParsingParameters();
  params.setAlignSeqRes(true);
  params.setCreateAtomBonds(true);
  pdbpars.setFileParsingParameters(params);
  structure=pdbpars.parsePDBFile(inStream);
  assertNotNull(structure);
  assertEquals(""String_Node_Str"",1,structure.size());
}",0.9980506822612084
16401,"/** 
 * Returns true if the given chain is composed of non-polymeric groups only
 * @param c
 * @return
 */
public static boolean isChainPureNonPolymer(Chain c){
  for (  Group g : c.getAtomGroups()) {
    if (g.getType() == GroupType.AMINOACID || g.getType() == GroupType.NUCLEOTIDE)     return false;
  }
  return true;
}","/** 
 * Returns true if the given chain is composed of non-polymeric (including water) groups only.  To be used at parsing time only.
 * @param c
 * @return
 */
public static boolean isChainPureNonPolymer(Chain c){
  for (  Group g : c.getAtomGroups()) {
    ChemComp cc=g.getChemComp();
    ResidueType resType=cc.getResidueType();
    PolymerType polType=cc.getPolymerType();
    if ((resType == ResidueType.lPeptideLinking || PolymerType.PROTEIN_ONLY.contains(polType) || PolymerType.POLYNUCLEOTIDE_ONLY.contains(polType)) && !g.isHetAtomInFile()) {
      return false;
    }
  }
  return true;
}",0.561822125813449
16402,"/** 
 * Get the predominant   {@link GroupType} for a given Chain, following theserules: <li>if the ratio of number of residues of a certain {@link GroupType} to total non-water residues is above the threshold{@value #RATIO_RESIDUES_TO_TOTAL}, then that   {@link GroupType} isreturned</li> <li>if there is no  {@link GroupType} that is above thethreshold then the  {@link GroupType} with most members is chosen, loggingit</li> <p> See also  {@link ChemComp#getPolymerType()} and{@link ChemComp#getResidueType()} which follow the PDB chemical componentdictionary and provide a much more accurate description of groups and their linking. </p>
 * @param c
 * @return
 */
public static GroupType getPredominantGroupType(Chain c){
  int sizeAminos=c.getAtomGroups(GroupType.AMINOACID).size();
  int sizeNucleotides=c.getAtomGroups(GroupType.NUCLEOTIDE).size();
  List<Group> hetAtoms=c.getAtomGroups(GroupType.HETATM);
  int sizeHetatoms=hetAtoms.size();
  int sizeWaters=0;
  for (  Group g : hetAtoms) {
    if (g.isWater())     sizeWaters++;
  }
  int sizeHetatomsWithoutWater=sizeHetatoms - sizeWaters;
  int fullSize=sizeAminos + sizeNucleotides + sizeHetatomsWithoutWater;
  if ((double)sizeAminos / (double)fullSize > RATIO_RESIDUES_TO_TOTAL)   return GroupType.AMINOACID;
  if ((double)sizeNucleotides / (double)fullSize > RATIO_RESIDUES_TO_TOTAL)   return GroupType.NUCLEOTIDE;
  if ((double)(sizeHetatomsWithoutWater) / (double)fullSize > RATIO_RESIDUES_TO_TOTAL)   return GroupType.HETATM;
  GroupType max;
  if (sizeNucleotides > sizeAminos) {
    if (sizeNucleotides > sizeHetatomsWithoutWater) {
      max=GroupType.NUCLEOTIDE;
    }
 else {
      max=GroupType.HETATM;
    }
  }
 else {
    if (sizeAminos > sizeHetatomsWithoutWater) {
      max=GroupType.AMINOACID;
    }
 else {
      max=GroupType.HETATM;
    }
  }
  logger.debug(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",c.getChainID(),RATIO_RESIDUES_TO_TOTAL,max,sizeAminos,sizeNucleotides,sizeHetatomsWithoutWater,sizeWaters,(double)sizeAminos / (double)fullSize,(double)sizeNucleotides / (double)fullSize);
  return max;
}","/** 
 * Get the predominant   {@link GroupType} for a given Chain, following theserules: <li>if the ratio of number of residues of a certain {@link GroupType} to total non-water residues is above the threshold{@value #RATIO_RESIDUES_TO_TOTAL}, then that   {@link GroupType} isreturned</li> <li>if there is no  {@link GroupType} that is above thethreshold then the  {@link GroupType} with most members is chosen, loggingit</li> <p> See also  {@link ChemComp#getPolymerType()} and{@link ChemComp#getResidueType()} which follow the PDB chemical componentdictionary and provide a much more accurate description of groups and their linking. </p>
 * @param c
 * @return
 */
public static GroupType getPredominantGroupType(Chain c){
  int sizeAminos=c.getAtomGroups(GroupType.AMINOACID).size();
  int sizeNucleotides=c.getAtomGroups(GroupType.NUCLEOTIDE).size();
  List<Group> hetAtoms=c.getAtomGroups(GroupType.HETATM);
  int sizeHetatoms=hetAtoms.size();
  int sizeWaters=0;
  for (  Group g : hetAtoms) {
    if (g.isWater())     sizeWaters++;
  }
  int sizeHetatomsWithoutWater=sizeHetatoms - sizeWaters;
  int fullSize=sizeAminos + sizeNucleotides + sizeHetatomsWithoutWater;
  if ((double)sizeAminos / (double)fullSize > RATIO_RESIDUES_TO_TOTAL)   return GroupType.AMINOACID;
  if ((double)sizeNucleotides / (double)fullSize > RATIO_RESIDUES_TO_TOTAL)   return GroupType.NUCLEOTIDE;
  if ((double)(sizeHetatomsWithoutWater) / (double)fullSize > RATIO_RESIDUES_TO_TOTAL)   return GroupType.HETATM;
  GroupType max;
  if (sizeNucleotides > sizeAminos) {
    if (sizeNucleotides > sizeHetatomsWithoutWater) {
      max=GroupType.NUCLEOTIDE;
    }
 else {
      max=GroupType.HETATM;
    }
  }
 else {
    if (sizeAminos > sizeHetatomsWithoutWater) {
      max=GroupType.AMINOACID;
    }
 else {
      max=GroupType.HETATM;
    }
  }
  logger.debug(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",c.getId(),RATIO_RESIDUES_TO_TOTAL,max,sizeAminos,sizeNucleotides,sizeHetatomsWithoutWater,sizeWaters,(double)sizeAminos / (double)fullSize,(double)sizeNucleotides / (double)fullSize);
  return max;
}",0.9983361064891848
16403,"/** 
 * Returns the RNASequence or null if one can't be created
 * @param str
 * @return
 */
private RNASequence getRNASequence(String str){
  try {
    RNASequence s=new RNASequence(str);
    return s;
  }
 catch (  CompoundNotFoundException e) {
    logger.error(""String_Node_Str"",e);
  }
  return null;
}","/** 
 * Returns the RNASequence or null if one can't be created
 * @param str
 * @return
 */
private static RNASequence getRNASequence(String str){
  try {
    RNASequence s=new RNASequence(str);
    return s;
  }
 catch (  CompoundNotFoundException e) {
    logger.error(""String_Node_Str"",e);
  }
  return null;
}",0.9887278582930756
16404,"private boolean isRNASequence(String str){
  try {
    new RNASequence(str);
  }
 catch (  CompoundNotFoundException e) {
    return false;
  }
  return true;
}","private static boolean isRNASequence(String str){
  try {
    new RNASequence(str);
  }
 catch (  CompoundNotFoundException e) {
    return false;
  }
  return true;
}",0.9785932721712538
16405,"private SequencePair<DNASequence,NucleotideCompound> alignDNA(DNASequence s1,DNASequence s2){
  SubstitutionMatrix<NucleotideCompound> matrix=SubstitutionMatrixHelper.getNuc4_4();
  GapPenalty penalty=new SimpleGapPenalty(8,1);
  PairwiseSequenceAligner<DNASequence,NucleotideCompound> nw=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.GLOBAL,penalty,matrix);
  return nw.getPair();
}","private static SequencePair<DNASequence,NucleotideCompound> alignDNA(DNASequence s1,DNASequence s2){
  SubstitutionMatrix<NucleotideCompound> matrix=SubstitutionMatrixHelper.getNuc4_4();
  GapPenalty penalty=new SimpleGapPenalty(8,1);
  PairwiseSequenceAligner<DNASequence,NucleotideCompound> nw=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.GLOBAL,penalty,matrix);
  return nw.getPair();
}",0.9913473423980222
16406,"/** 
 * Utility method that employs some heuristics to find the   {@link EntityInfo}s for the polymeric chains given in constructor.  To be used in case the information is missing in PDB/mmCIF file 
 * @return
 */
public List<EntityInfo> findPolyEntities(){
  TreeMap<String,EntityInfo> chainIds2entities=findEntitiesFromAlignment();
  List<EntityInfo> entities=findUniqueEntities(chainIds2entities);
  return entities;
}","/** 
 * Utility method that employs some heuristics to find the   {@link EntityInfo}s for the polymeric chains given in constructor.  To be used in case the information is missing in PDB/mmCIF file 
 * @return
 */
public static List<EntityInfo> findPolyEntities(List<List<Chain>> polyModels){
  TreeMap<String,EntityInfo> chainIds2entities=findEntitiesFromAlignment(polyModels);
  List<EntityInfo> entities=findUniqueEntities(chainIds2entities);
  return entities;
}",0.9492671927846674
16407,"/** 
 * Returns the ProteinSequence or null if one can't be created
 * @param str
 * @return
 */
private ProteinSequence getProteinSequence(String str){
  try {
    ProteinSequence s=new ProteinSequence(str);
    return s;
  }
 catch (  CompoundNotFoundException e) {
    logger.error(""String_Node_Str"",e);
  }
  return null;
}","/** 
 * Returns the ProteinSequence or null if one can't be created
 * @param str
 * @return
 */
private static ProteinSequence getProteinSequence(String str){
  try {
    ProteinSequence s=new ProteinSequence(str);
    return s;
  }
 catch (  CompoundNotFoundException e) {
    logger.error(""String_Node_Str"",e);
  }
  return null;
}",0.989409984871407
16408,"private TreeMap<String,EntityInfo> findEntitiesFromAlignment(){
  TreeMap<String,EntityInfo> chainIds2entities=new TreeMap<String,EntityInfo>();
  if (polyModels.isEmpty())   return chainIds2entities;
  Set<Integer> polyChainIndices=new TreeSet<Integer>();
  for (int i=0; i < polyModels.get(0).size(); i++) {
    polyChainIndices.add(i);
  }
  int molId=1;
  outer:   for (  int i : polyChainIndices) {
    for (    int j : polyChainIndices) {
      if (j <= i)       continue;
      Chain c1=polyModels.get(0).get(i);
      Chain c2=polyModels.get(0).get(j);
      Map<Integer,Integer> positionIndex1=new HashMap<Integer,Integer>();
      Map<Integer,Integer> positionIndex2=new HashMap<Integer,Integer>();
      String str1=SeqRes2AtomAligner.getFullAtomSequence(c1.getAtomGroups(),positionIndex1,false);
      String str2=SeqRes2AtomAligner.getFullAtomSequence(c2.getAtomGroups(),positionIndex2,false);
      int seq1Length=0;
      int seq2Length=0;
      SequencePair<?,?> pair=null;
      if (isProteinSequence(str1) && isProteinSequence(str2)) {
        ProteinSequence s1=getProteinSequence(str1);
        ProteinSequence s2=getProteinSequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignProtein(s1,s2);
      }
 else       if (isDNASequence(str1) && isDNASequence(str2)) {
        DNASequence s1=getDNASequence(str1);
        DNASequence s2=getDNASequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignDNA(s1,s2);
      }
 else       if (isRNASequence(str1) && isRNASequence(str2)) {
        RNASequence s1=getRNASequence(str1);
        RNASequence s2=getRNASequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignRNA(s1,s2);
      }
 else {
        logger.debug(""String_Node_Str"");
        continue;
      }
      int numGaps=getNumGaps(pair);
      int numGaps1=getNumGapsQuery(pair);
      int numGaps2=getNumGapsTarget(pair);
      int nonGaps=pair.getLength() - numGaps;
      double identity=(double)pair.getNumIdenticals() / (double)nonGaps;
      double gapCov1=(double)numGaps1 / (double)seq1Length;
      double gapCov2=(double)numGaps2 / (double)seq2Length;
      logger.debug(""String_Node_Str"",c1.getId(),c2.getId(),String.format(""String_Node_Str"",identity),String.format(""String_Node_Str"",gapCov1),String.format(""String_Node_Str"",gapCov2));
      logger.debug(""String_Node_Str"" + pair.toString(100));
      if (identity > IDENTITY_THRESHOLD && gapCov1 < GAP_COVERAGE_THRESHOLD && gapCov2 < GAP_COVERAGE_THRESHOLD) {
        if (!chainIds2entities.containsKey(c1.getId()) && !chainIds2entities.containsKey(c2.getId())) {
          logger.debug(""String_Node_Str"",c1.getId(),c2.getId());
          EntityInfo ent=new EntityInfo();
          ent.addChain(c1);
          ent.addChain(c2);
          ent.setMolId(molId++);
          ent.setType(EntityType.POLYMER);
          c1.setEntityInfo(ent);
          c2.setEntityInfo(ent);
          chainIds2entities.put(c1.getId(),ent);
          chainIds2entities.put(c2.getId(),ent);
        }
 else {
          EntityInfo ent=chainIds2entities.get(c1.getId());
          if (ent == null) {
            logger.debug(""String_Node_Str"",c1.getId(),c2.getId());
            ent=chainIds2entities.get(c2.getId());
            ent.addChain(c1);
            c1.setEntityInfo(ent);
            chainIds2entities.put(c1.getId(),ent);
          }
 else {
            logger.debug(""String_Node_Str"",c2.getId(),c1.getId());
            ent.addChain(c2);
            c2.setEntityInfo(ent);
            chainIds2entities.put(c2.getId(),ent);
          }
        }
        if (!areResNumbersAligned(c1,c2)) {
          logger.warn(""String_Node_Str"",c1.getId(),c2.getId());
        }
      }
      if (identity > 1) {
        logger.warn(""String_Node_Str"",c1.getId(),c2.getId(),pair.getNumIdenticals(),nonGaps,identity);
        logger.warn(""String_Node_Str"" + pair.toString(100));
      }
      if (chainIds2entities.size() == polyChainIndices.size())       break outer;
    }
  }
  for (  int i : polyChainIndices) {
    Chain c=polyModels.get(0).get(i);
    if (!chainIds2entities.containsKey(c.getId())) {
      logger.debug(""String_Node_Str"",c.getId());
      EntityInfo ent=new EntityInfo();
      ent.addChain(c);
      ent.setMolId(molId++);
      c.setEntityInfo(ent);
      chainIds2entities.put(c.getId(),ent);
    }
  }
  for (int i=1; i < polyModels.size(); i++) {
    for (    Chain chain : polyModels.get(i)) {
      EntityInfo e=chainIds2entities.get(chain.getId());
      chain.setEntityInfo(e);
      e.addChain(chain);
    }
  }
  return chainIds2entities;
}","private static TreeMap<String,EntityInfo> findEntitiesFromAlignment(List<List<Chain>> polyModels){
  TreeMap<String,EntityInfo> chainIds2entities=new TreeMap<String,EntityInfo>();
  if (polyModels.isEmpty())   return chainIds2entities;
  Set<Integer> polyChainIndices=new TreeSet<Integer>();
  for (int i=0; i < polyModels.get(0).size(); i++) {
    polyChainIndices.add(i);
  }
  int molId=1;
  outer:   for (  int i : polyChainIndices) {
    for (    int j : polyChainIndices) {
      if (j <= i)       continue;
      Chain c1=polyModels.get(0).get(i);
      Chain c2=polyModels.get(0).get(j);
      Map<Integer,Integer> positionIndex1=new HashMap<Integer,Integer>();
      Map<Integer,Integer> positionIndex2=new HashMap<Integer,Integer>();
      String str1=SeqRes2AtomAligner.getFullAtomSequence(c1.getAtomGroups(),positionIndex1,false);
      String str2=SeqRes2AtomAligner.getFullAtomSequence(c2.getAtomGroups(),positionIndex2,false);
      int seq1Length=0;
      int seq2Length=0;
      SequencePair<?,?> pair=null;
      if (isProteinSequence(str1) && isProteinSequence(str2)) {
        ProteinSequence s1=getProteinSequence(str1);
        ProteinSequence s2=getProteinSequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignProtein(s1,s2);
      }
 else       if (isDNASequence(str1) && isDNASequence(str2)) {
        DNASequence s1=getDNASequence(str1);
        DNASequence s2=getDNASequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignDNA(s1,s2);
      }
 else       if (isRNASequence(str1) && isRNASequence(str2)) {
        RNASequence s1=getRNASequence(str1);
        RNASequence s2=getRNASequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignRNA(s1,s2);
      }
 else {
        logger.debug(""String_Node_Str"");
        continue;
      }
      int numGaps=getNumGaps(pair);
      int numGaps1=getNumGapsQuery(pair);
      int numGaps2=getNumGapsTarget(pair);
      int nonGaps=pair.getLength() - numGaps;
      double identity=(double)pair.getNumIdenticals() / (double)nonGaps;
      double gapCov1=(double)numGaps1 / (double)seq1Length;
      double gapCov2=(double)numGaps2 / (double)seq2Length;
      logger.debug(""String_Node_Str"",c1.getId(),c2.getId(),String.format(""String_Node_Str"",identity),String.format(""String_Node_Str"",gapCov1),String.format(""String_Node_Str"",gapCov2));
      logger.debug(""String_Node_Str"" + pair.toString(100));
      if (identity > IDENTITY_THRESHOLD && gapCov1 < GAP_COVERAGE_THRESHOLD && gapCov2 < GAP_COVERAGE_THRESHOLD) {
        if (!chainIds2entities.containsKey(c1.getId()) && !chainIds2entities.containsKey(c2.getId())) {
          logger.debug(""String_Node_Str"",c1.getId(),c2.getId());
          EntityInfo ent=new EntityInfo();
          ent.addChain(c1);
          ent.addChain(c2);
          ent.setMolId(molId++);
          ent.setType(EntityType.POLYMER);
          c1.setEntityInfo(ent);
          c2.setEntityInfo(ent);
          chainIds2entities.put(c1.getId(),ent);
          chainIds2entities.put(c2.getId(),ent);
        }
 else {
          EntityInfo ent=chainIds2entities.get(c1.getId());
          if (ent == null) {
            logger.debug(""String_Node_Str"",c1.getId(),c2.getId());
            ent=chainIds2entities.get(c2.getId());
            ent.addChain(c1);
            c1.setEntityInfo(ent);
            chainIds2entities.put(c1.getId(),ent);
          }
 else {
            logger.debug(""String_Node_Str"",c2.getId(),c1.getId());
            ent.addChain(c2);
            c2.setEntityInfo(ent);
            chainIds2entities.put(c2.getId(),ent);
          }
        }
        if (!areResNumbersAligned(c1,c2)) {
          logger.warn(""String_Node_Str"",c1.getId(),c2.getId());
        }
      }
      if (identity > 1) {
        logger.warn(""String_Node_Str"",c1.getId(),c2.getId(),pair.getNumIdenticals(),nonGaps,identity);
        logger.warn(""String_Node_Str"" + pair.toString(100));
      }
      if (chainIds2entities.size() == polyChainIndices.size())       break outer;
    }
  }
  for (  int i : polyChainIndices) {
    Chain c=polyModels.get(0).get(i);
    if (!chainIds2entities.containsKey(c.getId())) {
      logger.debug(""String_Node_Str"",c.getId());
      EntityInfo ent=new EntityInfo();
      ent.addChain(c);
      ent.setMolId(molId++);
      c.setEntityInfo(ent);
      chainIds2entities.put(c.getId(),ent);
    }
  }
  for (int i=1; i < polyModels.size(); i++) {
    for (    Chain chain : polyModels.get(i)) {
      EntityInfo e=chainIds2entities.get(chain.getId());
      chain.setEntityInfo(e);
      e.addChain(chain);
    }
  }
  return chainIds2entities;
}",0.9962682588762128
16409,"/** 
 * Returns the DNASequence or null if one can't be created
 * @param str
 * @return
 */
private DNASequence getDNASequence(String str){
  try {
    DNASequence s=new DNASequence(str);
    return s;
  }
 catch (  CompoundNotFoundException e) {
    logger.error(""String_Node_Str"",e);
  }
  return null;
}","/** 
 * Returns the DNASequence or null if one can't be created
 * @param str
 * @return
 */
private static DNASequence getDNASequence(String str){
  try {
    DNASequence s=new DNASequence(str);
    return s;
  }
 catch (  CompoundNotFoundException e) {
    logger.error(""String_Node_Str"",e);
  }
  return null;
}",0.9887278582930756
16410,"private boolean isProteinSequence(String str){
  try {
    new ProteinSequence(str);
  }
 catch (  CompoundNotFoundException e) {
    return false;
  }
  return true;
}","private static boolean isProteinSequence(String str){
  try {
    new ProteinSequence(str);
  }
 catch (  CompoundNotFoundException e) {
    return false;
  }
  return true;
}",0.979591836734694
16411,"private boolean isDNASequence(String str){
  try {
    new DNASequence(str);
  }
 catch (  CompoundNotFoundException e) {
    return false;
  }
  return true;
}","private static boolean isDNASequence(String str){
  try {
    new DNASequence(str);
  }
 catch (  CompoundNotFoundException e) {
    return false;
  }
  return true;
}",0.9785932721712538
16412,"private SequencePair<RNASequence,NucleotideCompound> alignRNA(RNASequence s1,RNASequence s2){
  SubstitutionMatrix<NucleotideCompound> matrix=SubstitutionMatrixHelper.getNuc4_4();
  GapPenalty penalty=new SimpleGapPenalty(8,1);
  PairwiseSequenceAligner<RNASequence,NucleotideCompound> nw=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.GLOBAL,penalty,matrix);
  return nw.getPair();
}","private static SequencePair<RNASequence,NucleotideCompound> alignRNA(RNASequence s1,RNASequence s2){
  SubstitutionMatrix<NucleotideCompound> matrix=SubstitutionMatrixHelper.getNuc4_4();
  GapPenalty penalty=new SimpleGapPenalty(8,1);
  PairwiseSequenceAligner<RNASequence,NucleotideCompound> nw=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.GLOBAL,penalty,matrix);
  return nw.getPair();
}",0.9913473423980222
16413,"private SequencePair<ProteinSequence,AminoAcidCompound> alignProtein(ProteinSequence s1,ProteinSequence s2){
  SubstitutionMatrix<AminoAcidCompound> matrix=SubstitutionMatrixHelper.getIdentity();
  GapPenalty penalty=new SimpleGapPenalty(8,1);
  PairwiseSequenceAligner<ProteinSequence,AminoAcidCompound> nw=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.GLOBAL,penalty,matrix);
  return nw.getPair();
}","private static SequencePair<ProteinSequence,AminoAcidCompound> alignProtein(ProteinSequence s1,ProteinSequence s2){
  SubstitutionMatrix<AminoAcidCompound> matrix=SubstitutionMatrixHelper.getIdentity();
  GapPenalty penalty=new SimpleGapPenalty(8,1);
  PairwiseSequenceAligner<ProteinSequence,AminoAcidCompound> nw=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.GLOBAL,penalty,matrix);
  return nw.getPair();
}",0.9917355371900828
16414,"private void comparePDB2cif(String id,String chainId) throws IOException {
  String fileName=""String_Node_Str"" + id + ""String_Node_Str"";
  InputStream inStream=this.getClass().getResourceAsStream(fileName);
  assertNotNull(""String_Node_Str"" + fileName + ""String_Node_Str"",inStream);
  MMcifParser parser=new SimpleMMcifParser();
  SimpleMMcifConsumer consumer=new SimpleMMcifConsumer();
  FileParsingParameters params=new FileParsingParameters();
  params.setHeaderOnly(headerOnly);
  consumer.setFileParsingParameters(params);
  parser.addMMcifConsumer(consumer);
  try {
    parser.parse(new BufferedReader(new InputStreamReader(inStream)));
  }
 catch (  IOException e) {
    fail(e.getMessage());
  }
  parser.clearConsumers();
  Structure cifStructure=consumer.getStructure();
  assertNotNull(cifStructure);
  Structure pdbStructure=null;
  InputStream pinStream=this.getClass().getResourceAsStream(""String_Node_Str"" + id + ""String_Node_Str"");
  assertNotNull(inStream);
  PDBFileParser pdbpars=new PDBFileParser();
  pdbpars.setFileParsingParameters(params);
  pdbStructure=pdbpars.parsePDBFile(pinStream);
  assertNotNull(pdbStructure);
  try {
    assertEquals(id + ""String_Node_Str"",pdbStructure.isNmr(),cifStructure.isNmr());
    if (pdbStructure.isNmr()) {
      assertEquals(id + ""String_Node_Str"",pdbStructure.nrModels(),pdbStructure.nrModels());
      checkNMR(pdbStructure);
      checkNMR(cifStructure);
    }
    Chain a_pdb=pdbStructure.getChainByPDB(chainId);
    Chain a_cif=cifStructure.getChainByPDB(chainId);
    String pdb_SEQseq=a_pdb.getSeqResSequence();
    String cif_SEQseq=a_cif.getSeqResSequence();
    assertEquals(id + ""String_Node_Str"",pdb_SEQseq,cif_SEQseq);
    assertEquals(id + ""String_Node_Str"",a_pdb.getAtomGroups(GroupType.AMINOACID).size(),a_cif.getAtomGroups(GroupType.AMINOACID).size());
    for (int i=0; i < a_pdb.getAtomGroups(GroupType.AMINOACID).size(); i++) {
      Group gp=a_pdb.getAtomGroups(GroupType.AMINOACID).get(i);
      List<Group> cifGroups=a_cif.getAtomGroups(GroupType.AMINOACID);
      Group gc=cifGroups.get(i);
      checkGroups(gp,gc);
    }
    String pdb_seq=a_pdb.getAtomSequence();
    String cif_seq=a_cif.getAtomSequence();
    assertEquals(""String_Node_Str"",pdb_seq,cif_seq);
    List<DBRef> pdb_dbrefs=pdbStructure.getDBRefs();
    List<DBRef> cif_dbrefs=cifStructure.getDBRefs();
    assertEquals(""String_Node_Str"",pdb_dbrefs.size(),cif_dbrefs.size());
    DBRef p=pdb_dbrefs.get(0);
    DBRef c=cif_dbrefs.get(0);
    String pdb_dbref=p.toPDB();
    String cif_dbref=c.toPDB();
    assertEquals(""String_Node_Str"",pdb_dbref,cif_dbref);
    PDBHeader h1=pdbStructure.getPDBHeader();
    PDBHeader h2=cifStructure.getPDBHeader();
    if (!h1.toPDB().toUpperCase().equals(h2.toPDB().toUpperCase())) {
      System.err.println(h1.toPDB());
      System.err.println(h2.toPDB());
      compareString(h1.toPDB(),h2.toPDB());
    }
    assertEquals(""String_Node_Str"",h1.toPDB().toUpperCase(),h2.toPDB().toUpperCase());
  }
 catch (  StructureException ex) {
    fail(ex.getMessage() + ""String_Node_Str"" + id);
  }
}","private void comparePDB2cif(String id,String chainId) throws IOException {
  String fileName=""String_Node_Str"" + id + ""String_Node_Str"";
  InputStream inStream=this.getClass().getResourceAsStream(fileName);
  assertNotNull(""String_Node_Str"" + fileName + ""String_Node_Str"",inStream);
  MMcifParser parser=new SimpleMMcifParser();
  SimpleMMcifConsumer consumer=new SimpleMMcifConsumer();
  FileParsingParameters params=new FileParsingParameters();
  params.setHeaderOnly(headerOnly);
  consumer.setFileParsingParameters(params);
  parser.addMMcifConsumer(consumer);
  parser.parse(new BufferedReader(new InputStreamReader(inStream)));
  parser.clearConsumers();
  Structure cifStructure=consumer.getStructure();
  assertNotNull(cifStructure);
  Structure pdbStructure=null;
  InputStream pinStream=this.getClass().getResourceAsStream(""String_Node_Str"" + id + ""String_Node_Str"");
  assertNotNull(inStream);
  PDBFileParser pdbpars=new PDBFileParser();
  pdbpars.setFileParsingParameters(params);
  pdbStructure=pdbpars.parsePDBFile(pinStream);
  assertNotNull(pdbStructure);
  assertEquals(id + ""String_Node_Str"",pdbStructure.isNmr(),cifStructure.isNmr());
  if (pdbStructure.isNmr()) {
    assertEquals(id + ""String_Node_Str"",pdbStructure.nrModels(),pdbStructure.nrModels());
    checkNMR(pdbStructure);
    checkNMR(cifStructure);
  }
  Chain a_pdb=pdbStructure.getPolyChainByPDB(chainId);
  Chain a_cif=cifStructure.getPolyChainByPDB(chainId);
  String pdb_SEQseq=a_pdb.getSeqResSequence();
  String cif_SEQseq=a_cif.getSeqResSequence();
  assertEquals(id + ""String_Node_Str"",pdb_SEQseq,cif_SEQseq);
  assertEquals(id + ""String_Node_Str"",a_pdb.getAtomGroups(GroupType.AMINOACID).size(),a_cif.getAtomGroups(GroupType.AMINOACID).size());
  for (int i=0; i < a_pdb.getAtomGroups(GroupType.AMINOACID).size(); i++) {
    Group gp=a_pdb.getAtomGroups(GroupType.AMINOACID).get(i);
    List<Group> cifGroups=a_cif.getAtomGroups(GroupType.AMINOACID);
    Group gc=cifGroups.get(i);
    checkGroups(gp,gc);
  }
  String pdb_seq=a_pdb.getAtomSequence();
  String cif_seq=a_cif.getAtomSequence();
  assertEquals(""String_Node_Str"",pdb_seq,cif_seq);
  List<DBRef> pdb_dbrefs=pdbStructure.getDBRefs();
  List<DBRef> cif_dbrefs=cifStructure.getDBRefs();
  assertEquals(""String_Node_Str"",pdb_dbrefs.size(),cif_dbrefs.size());
  DBRef p=pdb_dbrefs.get(0);
  DBRef c=cif_dbrefs.get(0);
  String pdb_dbref=p.toPDB();
  String cif_dbref=c.toPDB();
  assertEquals(""String_Node_Str"",pdb_dbref,cif_dbref);
  PDBHeader h1=pdbStructure.getPDBHeader();
  PDBHeader h2=cifStructure.getPDBHeader();
  if (!h1.toPDB().toUpperCase().equals(h2.toPDB().toUpperCase())) {
    System.err.println(h1.toPDB());
    System.err.println(h2.toPDB());
    compareString(h1.toPDB(),h2.toPDB());
  }
  assertEquals(""String_Node_Str"",h1.toPDB().toUpperCase(),h2.toPDB().toUpperCase());
}",0.95680053999325
16415,"/** 
 * Start the parsing
 */
@Override public void documentStart(){
  structure=new StructureImpl();
  currentChain=null;
  currentGroup=null;
  currentNmrModelNumber=null;
  allModels=new ArrayList<List<Chain>>();
  currentModel=new ArrayList<Chain>();
  entities=new ArrayList<Entity>();
  strucRefs=new ArrayList<StructRef>();
  seqResChains=new ArrayList<Chain>();
  entityChains=new ArrayList<Chain>();
  structAsyms=new ArrayList<StructAsym>();
  asymId2entityId=new HashMap<String,String>();
  structOpers=new ArrayList<PdbxStructOperList>();
  strucAssemblies=new ArrayList<PdbxStructAssembly>();
  strucAssemblyGens=new ArrayList<PdbxStructAssemblyGen>();
  entitySrcGens=new ArrayList<EntitySrcGen>();
  entitySrcNats=new ArrayList<EntitySrcNat>();
  entitySrcSyns=new ArrayList<EntitySrcSyn>();
  structConn=new ArrayList<StructConn>();
  structNcsOper=new ArrayList<StructNcsOper>();
  sequenceDifs=new ArrayList<StructRefSeqDif>();
  structSiteGens=new ArrayList<StructSiteGen>();
}","/** 
 * Start the parsing
 */
@Override public void documentStart(){
  structure=new StructureImpl();
  currentChain=null;
  currentGroup=null;
  currentNmrModelNumber=null;
  allModels=new ArrayList<List<Chain>>();
  currentModel=new ArrayList<Chain>();
  entities=new ArrayList<Entity>();
  entityPolys=new ArrayList<>();
  strucRefs=new ArrayList<StructRef>();
  seqResChains=new ArrayList<Chain>();
  entityChains=new ArrayList<Chain>();
  structAsyms=new ArrayList<StructAsym>();
  asymId2entityId=new HashMap<String,String>();
  asymId2authorId=new HashMap<>();
  structOpers=new ArrayList<PdbxStructOperList>();
  strucAssemblies=new ArrayList<PdbxStructAssembly>();
  strucAssemblyGens=new ArrayList<PdbxStructAssemblyGen>();
  entitySrcGens=new ArrayList<EntitySrcGen>();
  entitySrcNats=new ArrayList<EntitySrcNat>();
  entitySrcSyns=new ArrayList<EntitySrcSyn>();
  structConn=new ArrayList<StructConn>();
  structNcsOper=new ArrayList<StructNcsOper>();
  sequenceDifs=new ArrayList<StructRefSeqDif>();
  structSiteGens=new ArrayList<StructSiteGen>();
}",0.966990291262136
16416,"@Override public void documentEnd(){
  if (currentChain != null) {
    currentChain.addGroup(currentGroup);
    if (isKnownChain(currentChain.getId(),currentModel) == null) {
      currentModel.add(currentChain);
    }
  }
 else   if (!params.isHeaderOnly()) {
    logger.warn(""String_Node_Str"");
  }
  allModels.add(currentModel);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    asymId2entityId.put(asym.getId(),asym.getEntity_id());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setId(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    addEntities(asym);
  }
  if (structAsyms.isEmpty()) {
    logger.warn(""String_Node_Str"");
  }
  linkEntities();
  for (  List<Chain> model : allModels) {
    structure.addModel(model);
  }
  if (params.isAlignSeqRes() && !params.isHeaderOnly()) {
    logger.debug(""String_Node_Str"");
    alignSeqRes();
  }
 else {
    logger.debug(""String_Node_Str"");
    SeqRes2AtomAligner.storeUnAlignedSeqRes(structure,seqResChains,params.isHeaderOnly());
  }
  StructureTools.cleanUpAltLocs(structure);
  if (!params.isHeaderOnly()) {
    if (params.shouldCreateAtomBonds()) {
      addBonds();
    }
    if (params.shouldCreateAtomCharges()) {
      addCharges();
    }
  }
  if (!params.isHeaderOnly()) {
    addSites();
  }
  if (params.isParseBioAssembly()) {
    Map<Integer,BioAssemblyInfo> bioAssemblies=new HashMap<Integer,BioAssemblyInfo>();
    for (    PdbxStructAssembly psa : strucAssemblies) {
      List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
      for (      PdbxStructAssemblyGen psag : strucAssemblyGens) {
        if (psag.getAssembly_id().equals(psa.getId())) {
          psags.add(psag);
        }
      }
      BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
      List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
      int mmSize=0;
      int bioAssemblyId=-1;
      try {
        bioAssemblyId=Integer.parseInt(psa.getId());
      }
 catch (      NumberFormatException e) {
        logger.info(""String_Node_Str"",psa.getId());
      }
      try {
        mmSize=Integer.parseInt(psa.getOligomeric_count());
      }
 catch (      NumberFormatException e) {
        if (bioAssemblyId != -1)         logger.warn(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
 else         logger.info(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
      }
      if (bioAssemblyId != -1) {
        BioAssemblyInfo bioAssembly=new BioAssemblyInfo();
        bioAssembly.setId(bioAssemblyId);
        bioAssembly.setMacromolecularSize(mmSize);
        bioAssembly.setTransforms(transformations);
        bioAssemblies.put(bioAssemblyId,bioAssembly);
      }
    }
    structure.getPDBHeader().setBioAssemblies(bioAssemblies);
  }
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators(ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
  Map<String,List<SeqMisMatch>> misMatchMap=new HashMap<String,List<SeqMisMatch>>();
  for (  StructRefSeqDif sdif : sequenceDifs) {
    SeqMisMatch misMatch=new SeqMisMatchImpl();
    misMatch.setDetails(sdif.getDetails());
    String insCode=sdif.getPdbx_pdb_ins_code();
    if (insCode != null && insCode.equals(""String_Node_Str""))     insCode=null;
    misMatch.setInsCode(insCode);
    misMatch.setOrigGroup(sdif.getDb_mon_id());
    misMatch.setPdbGroup(sdif.getMon_id());
    misMatch.setPdbResNum(sdif.getPdbx_auth_seq_num());
    misMatch.setUniProtId(sdif.getPdbx_seq_db_accession_code());
    misMatch.setSeqNum(sdif.getSeq_num());
    List<SeqMisMatch> mms=misMatchMap.get(sdif.getPdbx_pdb_strand_id());
    if (mms == null) {
      mms=new ArrayList<SeqMisMatch>();
      misMatchMap.put(sdif.getPdbx_pdb_strand_id(),mms);
    }
    mms.add(misMatch);
  }
  for (  String chainId : misMatchMap.keySet()) {
    Chain c=structure.getPolyChainByPDB(chainId);
    if (c == null) {
      logger.warn(""String_Node_Str"" + chainId);
      continue;
    }
    c.setSeqMisMatches(misMatchMap.get(chainId));
  }
}","@Override public void documentEnd(){
  if (currentChain != null) {
    currentChain.addGroup(currentGroup);
    if (isKnownChain(currentChain.getId(),currentModel) == null) {
      currentModel.add(currentChain);
    }
  }
 else   if (!params.isHeaderOnly()) {
    logger.warn(""String_Node_Str"");
  }
  allModels.add(currentModel);
  initMaps();
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setId(asym.getId());
    if (asymId2authorId.get(asym.getId()) != null) {
      seqres.setName(asymId2authorId.get(asym.getId()));
    }
 else {
      seqres.setName(asym.getId());
    }
    EntityType type=null;
    try {
      Entity ent=getEntity(Integer.parseInt(asym.getEntity_id()));
      type=EntityType.entityTypeFromString(ent.getType());
    }
 catch (    NumberFormatException e) {
      logger.debug(""String_Node_Str"",asym.getEntity_id());
    }
    if (type == null || (type != null && type == EntityType.POLYMER)) {
      seqResChains.add(seqres);
    }
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    addEntities(asym);
  }
  if (structAsyms.isEmpty()) {
    logger.warn(""String_Node_Str"");
  }
  linkEntities();
  for (  List<Chain> model : allModels) {
    structure.addModel(model);
  }
  if (params.isAlignSeqRes() && !params.isHeaderOnly()) {
    logger.debug(""String_Node_Str"");
    alignSeqRes();
  }
 else {
    logger.debug(""String_Node_Str"");
    SeqRes2AtomAligner.storeUnAlignedSeqRes(structure,seqResChains,params.isHeaderOnly());
  }
  StructureTools.cleanUpAltLocs(structure);
  if (!params.isHeaderOnly()) {
    if (params.shouldCreateAtomBonds()) {
      addBonds();
    }
    if (params.shouldCreateAtomCharges()) {
      addCharges();
    }
  }
  if (!params.isHeaderOnly()) {
    addSites();
  }
  if (params.isParseBioAssembly()) {
    Map<Integer,BioAssemblyInfo> bioAssemblies=new HashMap<Integer,BioAssemblyInfo>();
    for (    PdbxStructAssembly psa : strucAssemblies) {
      List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
      for (      PdbxStructAssemblyGen psag : strucAssemblyGens) {
        if (psag.getAssembly_id().equals(psa.getId())) {
          psags.add(psag);
        }
      }
      BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
      List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
      int mmSize=0;
      int bioAssemblyId=-1;
      try {
        bioAssemblyId=Integer.parseInt(psa.getId());
      }
 catch (      NumberFormatException e) {
        logger.info(""String_Node_Str"",psa.getId());
      }
      try {
        mmSize=Integer.parseInt(psa.getOligomeric_count());
      }
 catch (      NumberFormatException e) {
        if (bioAssemblyId != -1)         logger.warn(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
 else         logger.info(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
      }
      if (bioAssemblyId != -1) {
        BioAssemblyInfo bioAssembly=new BioAssemblyInfo();
        bioAssembly.setId(bioAssemblyId);
        bioAssembly.setMacromolecularSize(mmSize);
        bioAssembly.setTransforms(transformations);
        bioAssemblies.put(bioAssemblyId,bioAssembly);
      }
    }
    structure.getPDBHeader().setBioAssemblies(bioAssemblies);
  }
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators(ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
  Map<String,List<SeqMisMatch>> misMatchMap=new HashMap<String,List<SeqMisMatch>>();
  for (  StructRefSeqDif sdif : sequenceDifs) {
    SeqMisMatch misMatch=new SeqMisMatchImpl();
    misMatch.setDetails(sdif.getDetails());
    String insCode=sdif.getPdbx_pdb_ins_code();
    if (insCode != null && insCode.equals(""String_Node_Str""))     insCode=null;
    misMatch.setInsCode(insCode);
    misMatch.setOrigGroup(sdif.getDb_mon_id());
    misMatch.setPdbGroup(sdif.getMon_id());
    misMatch.setPdbResNum(sdif.getPdbx_auth_seq_num());
    misMatch.setUniProtId(sdif.getPdbx_seq_db_accession_code());
    misMatch.setSeqNum(sdif.getSeq_num());
    List<SeqMisMatch> mms=misMatchMap.get(sdif.getPdbx_pdb_strand_id());
    if (mms == null) {
      mms=new ArrayList<SeqMisMatch>();
      misMatchMap.put(sdif.getPdbx_pdb_strand_id(),mms);
    }
    mms.add(misMatch);
  }
  for (  String chainId : misMatchMap.keySet()) {
    Chain c=structure.getPolyChainByPDB(chainId);
    if (c == null) {
      logger.warn(""String_Node_Str"" + chainId);
      continue;
    }
    c.setSeqMisMatches(misMatchMap.get(chainId));
  }
}",0.9382509664611848
16417,"private void endLineChecks(String category,List<String> loopFields,List<String> lineData,Set<String> loopWarnings) throws IOException {
  logger.debug(""String_Node_Str"",category,loopFields.toString());
  if (loopFields.size() != lineData.size()) {
    logger.warn(""String_Node_Str"");
    throw new IOException(""String_Node_Str"" + lineData.size() + ""String_Node_Str""+ loopFields.size()+ ""String_Node_Str""+ category+ ""String_Node_Str""+ loopFields+ ""String_Node_Str""+ lineData);
  }
  if (category.equals(""String_Node_Str"")) {
    Entity e=(Entity)buildObject(Entity.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewEntity(e);
  }
 else   if (category.equals(""String_Node_Str"")) {
    struct=(Struct)buildObject(Struct.class.getName(),loopFields,lineData,loopWarnings);
  }
 else   if (category.equals(""String_Node_Str"")) {
    AtomSite a=(AtomSite)buildObject(AtomSite.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewAtomSite(a);
  }
 else   if (category.equals(""String_Node_Str"")) {
    DatabasePDBrev dbrev=(DatabasePDBrev)buildObject(DatabasePDBrev.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewDatabasePDBrev(dbrev);
  }
 else   if (category.equals(""String_Node_Str"")) {
    DatabasePdbrevRecord dbrev=(DatabasePdbrevRecord)buildObject(DatabasePdbrevRecord.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewDatabasePDBrevRecord(dbrev);
  }
 else   if (category.equals(""String_Node_Str"")) {
    DatabasePDBremark remark=(DatabasePDBremark)buildObject(DatabasePDBremark.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewDatabasePDBremark(remark);
  }
 else   if (category.equals(""String_Node_Str"")) {
    Exptl exptl=(Exptl)buildObject(Exptl.class.getName(),loopFields,lineData,loopWarnings);
    triggerExptl(exptl);
  }
 else   if (category.equals(""String_Node_Str"")) {
    Cell cell=(Cell)buildObject(Cell.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewCell(cell);
  }
 else   if (category.equals(""String_Node_Str"")) {
    Symmetry symmetry=(Symmetry)buildObject(Symmetry.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewSymmetry(symmetry);
  }
 else   if (category.equals(""String_Node_Str"")) {
    StructNcsOper sNcsOper=null;
    try {
      sNcsOper=getStructNcsOper(loopFields,lineData);
    }
 catch (    NumberFormatException e) {
      logger.warn(""String_Node_Str"");
    }
    if (sNcsOper != null) {
      triggerNewStructNcsOper(sNcsOper);
    }
  }
 else   if (category.equals(""String_Node_Str"")) {
    StructRef sref=(StructRef)buildObject(StructRef.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewStrucRef(sref);
  }
 else   if (category.equals(""String_Node_Str"")) {
    StructRefSeq sref=(StructRefSeq)buildObject(StructRefSeq.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewStrucRefSeq(sref);
  }
 else   if (category.equals(""String_Node_Str"")) {
    StructRefSeqDif sref=(StructRefSeqDif)buildObject(StructRefSeqDif.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewStrucRefSeqDif(sref);
  }
 else   if (category.equals(""String_Node_Str"")) {
    StructSiteGen sref=(StructSiteGen)buildObject(StructSiteGen.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewStructSiteGen(sref);
  }
 else   if (category.equals(""String_Node_Str"")) {
    StructSite sref=(StructSite)buildObject(StructSite.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewStructSite(sref);
  }
 else   if (category.equals(""String_Node_Str"")) {
    EntityPolySeq exptl=(EntityPolySeq)buildObject(EntityPolySeq.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewEntityPolySeq(exptl);
  }
 else   if (category.equals(""String_Node_Str"")) {
    EntitySrcGen entitySrcGen=(EntitySrcGen)buildObject(EntitySrcGen.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewEntitySrcGen(entitySrcGen);
  }
 else   if (category.equals(""String_Node_Str"")) {
    EntitySrcNat entitySrcNat=(EntitySrcNat)buildObject(EntitySrcNat.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewEntitySrcNat(entitySrcNat);
  }
 else   if (category.equals(""String_Node_Str"")) {
    EntitySrcSyn entitySrcSyn=(EntitySrcSyn)buildObject(EntitySrcSyn.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewEntitySrcSyn(entitySrcSyn);
  }
 else   if (category.equals(""String_Node_Str"")) {
    StructAsym sasym=(StructAsym)buildObject(StructAsym.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewStructAsym(sasym);
  }
 else   if (category.equals(""String_Node_Str"")) {
    PdbxPolySeqScheme ppss=(PdbxPolySeqScheme)buildObject(PdbxPolySeqScheme.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewPdbxPolySeqScheme(ppss);
  }
 else   if (category.equals(""String_Node_Str"")) {
    PdbxNonPolyScheme ppss=(PdbxNonPolyScheme)buildObject(PdbxNonPolyScheme.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewPdbxNonPolyScheme(ppss);
  }
 else   if (category.equals(""String_Node_Str"")) {
    PdbxEntityNonPoly pen=(PdbxEntityNonPoly)buildObject(PdbxEntityNonPoly.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewPdbxEntityNonPoly(pen);
  }
 else   if (category.equals(""String_Node_Str"")) {
    StructKeywords kw=(StructKeywords)buildObject(StructKeywords.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewStructKeywords(kw);
  }
 else   if (category.equals(""String_Node_Str"")) {
    Refine r=(Refine)buildObject(Refine.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewRefine(r);
  }
 else   if (category.equals(""String_Node_Str"")) {
    ChemComp c=(ChemComp)buildObject(ChemComp.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewChemComp(c);
  }
 else   if (category.equals(""String_Node_Str"")) {
    AuditAuthor aa=(AuditAuthor)buildObject(AuditAuthor.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewAuditAuthor(aa);
  }
 else   if (category.equals(""String_Node_Str"")) {
    ChemCompDescriptor ccd=(ChemCompDescriptor)buildObject(ChemCompDescriptor.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewChemCompDescriptor(ccd);
  }
 else   if (category.equals(""String_Node_Str"")) {
    PdbxStructOperList structOper=getPdbxStructOperList(loopFields,lineData);
    triggerNewPdbxStructOper(structOper);
  }
 else   if (category.equals(""String_Node_Str"")) {
    PdbxStructAssembly sa=(PdbxStructAssembly)buildObject(PdbxStructAssembly.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewPdbxStructAssembly(sa);
  }
 else   if (category.equals(""String_Node_Str"")) {
    PdbxStructAssemblyGen sa=(PdbxStructAssemblyGen)buildObject(PdbxStructAssemblyGen.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewPdbxStructAssemblyGen(sa);
  }
 else   if (category.equals(""String_Node_Str"")) {
    ChemCompAtom atom=(ChemCompAtom)buildObject(ChemCompAtom.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewChemCompAtom(atom);
  }
 else   if (category.equals(""String_Node_Str"")) {
    ChemCompBond bond=(ChemCompBond)buildObject(ChemCompBond.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewChemCompBond(bond);
  }
 else   if (category.equals(""String_Node_Str"")) {
    PdbxChemCompIdentifier id=(PdbxChemCompIdentifier)buildObject(PdbxChemCompIdentifier.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewPdbxChemCompIdentifier(id);
  }
 else   if (category.equals(""String_Node_Str"")) {
    PdbxChemCompDescriptor id=(PdbxChemCompDescriptor)buildObject(PdbxChemCompDescriptor.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewPdbxChemCompDescriptor(id);
  }
 else   if (category.equals(""String_Node_Str"")) {
    StructConn id=(StructConn)buildObject(StructConn.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewStructConn(id);
  }
 else {
    logger.debug(""String_Node_Str"",category);
    triggerGeneric(category,loopFields,lineData);
  }
}","private void endLineChecks(String category,List<String> loopFields,List<String> lineData,Set<String> loopWarnings) throws IOException {
  logger.debug(""String_Node_Str"",category,loopFields.toString());
  if (loopFields.size() != lineData.size()) {
    logger.warn(""String_Node_Str"");
    throw new IOException(""String_Node_Str"" + lineData.size() + ""String_Node_Str""+ loopFields.size()+ ""String_Node_Str""+ category+ ""String_Node_Str""+ loopFields+ ""String_Node_Str""+ lineData);
  }
  if (category.equals(""String_Node_Str"")) {
    Entity e=(Entity)buildObject(Entity.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewEntity(e);
  }
 else   if (category.equals(""String_Node_Str"")) {
    EntityPoly ep=(EntityPoly)buildObject(EntityPoly.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewEntityPoly(ep);
  }
 else   if (category.equals(""String_Node_Str"")) {
    struct=(Struct)buildObject(Struct.class.getName(),loopFields,lineData,loopWarnings);
  }
 else   if (category.equals(""String_Node_Str"")) {
    AtomSite a=(AtomSite)buildObject(AtomSite.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewAtomSite(a);
  }
 else   if (category.equals(""String_Node_Str"")) {
    DatabasePDBrev dbrev=(DatabasePDBrev)buildObject(DatabasePDBrev.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewDatabasePDBrev(dbrev);
  }
 else   if (category.equals(""String_Node_Str"")) {
    DatabasePdbrevRecord dbrev=(DatabasePdbrevRecord)buildObject(DatabasePdbrevRecord.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewDatabasePDBrevRecord(dbrev);
  }
 else   if (category.equals(""String_Node_Str"")) {
    DatabasePDBremark remark=(DatabasePDBremark)buildObject(DatabasePDBremark.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewDatabasePDBremark(remark);
  }
 else   if (category.equals(""String_Node_Str"")) {
    Exptl exptl=(Exptl)buildObject(Exptl.class.getName(),loopFields,lineData,loopWarnings);
    triggerExptl(exptl);
  }
 else   if (category.equals(""String_Node_Str"")) {
    Cell cell=(Cell)buildObject(Cell.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewCell(cell);
  }
 else   if (category.equals(""String_Node_Str"")) {
    Symmetry symmetry=(Symmetry)buildObject(Symmetry.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewSymmetry(symmetry);
  }
 else   if (category.equals(""String_Node_Str"")) {
    StructNcsOper sNcsOper=null;
    try {
      sNcsOper=getStructNcsOper(loopFields,lineData);
    }
 catch (    NumberFormatException e) {
      logger.warn(""String_Node_Str"");
    }
    if (sNcsOper != null) {
      triggerNewStructNcsOper(sNcsOper);
    }
  }
 else   if (category.equals(""String_Node_Str"")) {
    StructRef sref=(StructRef)buildObject(StructRef.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewStrucRef(sref);
  }
 else   if (category.equals(""String_Node_Str"")) {
    StructRefSeq sref=(StructRefSeq)buildObject(StructRefSeq.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewStrucRefSeq(sref);
  }
 else   if (category.equals(""String_Node_Str"")) {
    StructRefSeqDif sref=(StructRefSeqDif)buildObject(StructRefSeqDif.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewStrucRefSeqDif(sref);
  }
 else   if (category.equals(""String_Node_Str"")) {
    StructSiteGen sref=(StructSiteGen)buildObject(StructSiteGen.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewStructSiteGen(sref);
  }
 else   if (category.equals(""String_Node_Str"")) {
    StructSite sref=(StructSite)buildObject(StructSite.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewStructSite(sref);
  }
 else   if (category.equals(""String_Node_Str"")) {
    EntityPolySeq exptl=(EntityPolySeq)buildObject(EntityPolySeq.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewEntityPolySeq(exptl);
  }
 else   if (category.equals(""String_Node_Str"")) {
    EntitySrcGen entitySrcGen=(EntitySrcGen)buildObject(EntitySrcGen.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewEntitySrcGen(entitySrcGen);
  }
 else   if (category.equals(""String_Node_Str"")) {
    EntitySrcNat entitySrcNat=(EntitySrcNat)buildObject(EntitySrcNat.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewEntitySrcNat(entitySrcNat);
  }
 else   if (category.equals(""String_Node_Str"")) {
    EntitySrcSyn entitySrcSyn=(EntitySrcSyn)buildObject(EntitySrcSyn.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewEntitySrcSyn(entitySrcSyn);
  }
 else   if (category.equals(""String_Node_Str"")) {
    StructAsym sasym=(StructAsym)buildObject(StructAsym.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewStructAsym(sasym);
  }
 else   if (category.equals(""String_Node_Str"")) {
    PdbxPolySeqScheme ppss=(PdbxPolySeqScheme)buildObject(PdbxPolySeqScheme.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewPdbxPolySeqScheme(ppss);
  }
 else   if (category.equals(""String_Node_Str"")) {
    PdbxNonPolyScheme ppss=(PdbxNonPolyScheme)buildObject(PdbxNonPolyScheme.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewPdbxNonPolyScheme(ppss);
  }
 else   if (category.equals(""String_Node_Str"")) {
    PdbxEntityNonPoly pen=(PdbxEntityNonPoly)buildObject(PdbxEntityNonPoly.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewPdbxEntityNonPoly(pen);
  }
 else   if (category.equals(""String_Node_Str"")) {
    StructKeywords kw=(StructKeywords)buildObject(StructKeywords.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewStructKeywords(kw);
  }
 else   if (category.equals(""String_Node_Str"")) {
    Refine r=(Refine)buildObject(Refine.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewRefine(r);
  }
 else   if (category.equals(""String_Node_Str"")) {
    ChemComp c=(ChemComp)buildObject(ChemComp.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewChemComp(c);
  }
 else   if (category.equals(""String_Node_Str"")) {
    AuditAuthor aa=(AuditAuthor)buildObject(AuditAuthor.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewAuditAuthor(aa);
  }
 else   if (category.equals(""String_Node_Str"")) {
    ChemCompDescriptor ccd=(ChemCompDescriptor)buildObject(ChemCompDescriptor.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewChemCompDescriptor(ccd);
  }
 else   if (category.equals(""String_Node_Str"")) {
    PdbxStructOperList structOper=getPdbxStructOperList(loopFields,lineData);
    triggerNewPdbxStructOper(structOper);
  }
 else   if (category.equals(""String_Node_Str"")) {
    PdbxStructAssembly sa=(PdbxStructAssembly)buildObject(PdbxStructAssembly.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewPdbxStructAssembly(sa);
  }
 else   if (category.equals(""String_Node_Str"")) {
    PdbxStructAssemblyGen sa=(PdbxStructAssemblyGen)buildObject(PdbxStructAssemblyGen.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewPdbxStructAssemblyGen(sa);
  }
 else   if (category.equals(""String_Node_Str"")) {
    ChemCompAtom atom=(ChemCompAtom)buildObject(ChemCompAtom.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewChemCompAtom(atom);
  }
 else   if (category.equals(""String_Node_Str"")) {
    ChemCompBond bond=(ChemCompBond)buildObject(ChemCompBond.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewChemCompBond(bond);
  }
 else   if (category.equals(""String_Node_Str"")) {
    PdbxChemCompIdentifier id=(PdbxChemCompIdentifier)buildObject(PdbxChemCompIdentifier.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewPdbxChemCompIdentifier(id);
  }
 else   if (category.equals(""String_Node_Str"")) {
    PdbxChemCompDescriptor id=(PdbxChemCompDescriptor)buildObject(PdbxChemCompDescriptor.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewPdbxChemCompDescriptor(id);
  }
 else   if (category.equals(""String_Node_Str"")) {
    StructConn id=(StructConn)buildObject(StructConn.class.getName(),loopFields,lineData,loopWarnings);
    triggerNewStructConn(id);
  }
 else {
    logger.debug(""String_Node_Str"",category);
    triggerGeneric(category,loopFields,lineData);
  }
}",0.9882982696377444
16418,"@After public void printInfo(){
  if (pdbId != null)   System.out.println(""String_Node_Str"" + pdbId);
}","@After public void printInfo(){
  if (pdbId != null)   System.out.println(""String_Node_Str"" + pdbId + ""String_Node_Str""+ countTested+ ""String_Node_Str"");
}",0.7984496124031008
16419,"private void testChains(Structure sPdb,Structure sCif) throws StructureException {
  assertNotNull(sPdb.getChains());
  assertNotNull(sCif.getChains());
  assertEquals(sPdb.getPolyChains().size(),sCif.getPolyChains().size());
  assertEquals(sPdb.getNonPolyChains().size(),sCif.getNonPolyChains().size());
  assertEquals(sPdb.getWaterChains().size(),sCif.getWaterChains().size());
  assertEquals(sPdb.getChains().size(),sCif.getChains().size());
  List<String> chainIds=new ArrayList<String>();
  for (  Chain chain : sPdb.getChains()) {
    chainIds.add(chain.getName());
  }
  for (  String chainId : chainIds) {
    testSingleChain(sPdb.getPolyChainByPDB(chainId),sCif.getPolyChainByPDB(chainId));
  }
}","private void testChains(Structure sPdb,Structure sCif) throws StructureException {
  assertNotNull(sPdb.getChains());
  assertNotNull(sCif.getChains());
  if (!containsSugar(sCif)) {
    assertEquals(sPdb.getPolyChains().size(),sCif.getPolyChains().size());
    if (!containsUNL(sCif)) {
      assertEquals(sPdb.getNonPolyChains().size(),sCif.getNonPolyChains().size());
    }
    assertEquals(sPdb.getWaterChains().size(),sCif.getWaterChains().size());
    if (!containsUNL(sCif)) {
      assertEquals(sPdb.getChains().size(),sCif.getChains().size());
    }
  }
  Set<String> chainIds=new TreeSet<String>();
  for (  Chain chain : sPdb.getPolyChains()) {
    chainIds.add(chain.getName());
  }
  for (  String chainId : chainIds) {
    testSingleChain(sPdb.getPolyChainByPDB(chainId),sCif.getPolyChainByPDB(chainId));
  }
}",0.8515369522563767
16420,"private void testAll(List<String> pdbIds) throws IOException, StructureException {
  pdbIdsWithMismatchingMolIds=new HashSet<String>();
  long start=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + pdbIds.size() + ""String_Node_Str"");
  for (int i=0; i < pdbIds.size(); i++) {
    pdbId=pdbIds.get(i);
    System.out.print(""String_Node_Str"");
    testSingleEntry(pdbId);
    if (((i + 1) % DOTS_PER_LINE) == 0)     System.out.println();
  }
  pdbId=null;
  long end=System.currentTimeMillis();
  checkWarnings();
  System.out.printf(""String_Node_Str"",(end - start) / 60000.0);
}","private void testAll(List<String> pdbIds) throws IOException, StructureException {
  pdbIdsWithMismatchingMolIds=new HashSet<String>();
  long start=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + pdbIds.size() + ""String_Node_Str"");
  for (int i=0; i < pdbIds.size(); i++) {
    pdbId=pdbIds.get(i);
    countTested=i + 1;
    System.out.print(""String_Node_Str"");
    testSingleEntry(pdbId);
    if (((i + 1) % DOTS_PER_LINE) == 0)     System.out.println();
  }
  pdbId=null;
  long end=System.currentTimeMillis();
  checkWarnings();
  System.out.printf(""String_Node_Str"",(end - start) / 60000.0);
}",0.981101068200493
16421,"/** 
 * Returns true if the given chain is composed of water molecules only
 * @param c
 * @return
 */
public static boolean isChainWaterOnly(Chain c){
  boolean waterOnly=true;
  for (  Group g : c.getAtomGroups()) {
    if (!g.isWater())     waterOnly=false;
    break;
  }
  return waterOnly;
}","/** 
 * Returns true if the given chain is composed of water molecules only
 * @param c
 * @return
 */
public static boolean isChainWaterOnly(Chain c){
  for (  Group g : c.getAtomGroups()) {
    if (!g.isWater())     return false;
  }
  return true;
}",0.5938069216757741
16422,"/** 
 * Split the given chain (containing non-polymer groups and water groups only)  into individual chains per non-polymer group and individual chains per contiguous sets of water groups. 
 * @param chain
 * @return a list of lists of size 2: first list is the split non-poly chains, second list is the split water chains 
 */
private static List<List<Chain>> splitNonPolyChain(Chain chain){
  List<Chain> splitNonPolys=new ArrayList<>();
  List<Chain> waterChains=new ArrayList<>();
  Chain split=null;
  boolean previousGroupIsWater=false;
  for (  Group g : chain.getAtomGroups()) {
    if (!previousGroupIsWater) {
      if (split != null) {
        splitNonPolys.add(split);
      }
      split=new ChainImpl();
      split.setName(chain.getName());
    }
 else     if (!g.isWater()) {
      waterChains.add(split);
    }
    if (g.isWater()) {
      previousGroupIsWater=true;
    }
 else {
      previousGroupIsWater=false;
    }
    split.addGroup(g);
  }
  if (split != null) {
    if (previousGroupIsWater)     waterChains.add(split);
 else     splitNonPolys.add(split);
  }
  List<List<Chain>> all=new ArrayList<>(2);
  all.add(splitNonPolys);
  all.add(waterChains);
  return all;
}","/** 
 * Split the given chain (containing non-polymer groups and water groups only)  into individual chains per non-polymer group and individual chains per contiguous sets of water groups. 
 * @param chain
 * @return a list of lists of size 2: first list is the split non-poly chains, second list is the split water chains 
 */
private static List<List<Chain>> splitNonPolyChain(Chain chain){
  List<Chain> splitNonPolys=new ArrayList<>();
  List<Chain> waterChains=new ArrayList<>();
  Chain split=null;
  boolean previousGroupIsWater=false;
  for (  Group g : chain.getAtomGroups()) {
    if (!previousGroupIsWater) {
      if (split != null) {
        splitNonPolys.add(split);
      }
      split=new ChainImpl();
      split.setName(chain.getName());
    }
 else     if (!g.isWater()) {
      waterChains.add(split);
      split=new ChainImpl();
      split.setName(chain.getName());
    }
    if (g.isWater()) {
      previousGroupIsWater=true;
    }
 else {
      previousGroupIsWater=false;
    }
    split.addGroup(g);
  }
  if (split != null) {
    if (previousGroupIsWater)     waterChains.add(split);
 else     splitNonPolys.add(split);
  }
  List<List<Chain>> all=new ArrayList<>(2);
  all.add(splitNonPolys);
  all.add(waterChains);
  return all;
}",0.9727309727309728
16423,"/** 
 * Handler for ATOM. Record Format: <pre> ATOM      1  N   ASP A  15     110.964  24.941  59.191  1.00 83.44           N COLUMNS        DATA TYPE       FIELD         DEFINITION --------------------------------------------------------------------------------- 1 -  6        Record name     ""ATOM  "" 7 - 11        Integer         serial        Atom serial number. 13 - 16        Atom            name          Atom name. 17             Character       altLoc        Alternate location indicator. 18 - 20        Residue name    resName       Residue name. 22             Character       chainID       Chain identifier. 23 - 26        Integer         resSeq        Residue sequence number. 27             AChar           iCode         Code for insertion of residues. 31 - 38        Real(8.3)       x             Orthogonal coordinates for X in Angstroms. 39 - 46        Real(8.3)       y             Orthogonal coordinates for Y in Angstroms. 47 - 54        Real(8.3)       z             Orthogonal coordinates for Z in Angstroms. 55 - 60        Real(6.2)       occupancy     Occupancy. 61 - 66        Real(6.2)       tempFactor    Temperature factor. 73 - 76        LString(4)      segID         Segment identifier, left-justified. 77 - 78        LString(2)      element       Element symbol, right-justified. 79 - 80        LString(2)      charge        Charge on the atom. </pre>
 */
private void pdb_ATOM_Handler(String line){
  if (params.isHeaderOnly())   return;
  String chainName=line.substring(21,22);
  if (chainName.equals(""String_Node_Str"")) {
    blankChainIdsPresent=true;
  }
  if (currentChain != null && !currentChain.getName().equals(chainName)) {
    startOfMolecule=true;
  }
  if (startOfMolecule) {
    if (currentChain != null) {
      currentModel.add(currentChain);
      if (currentGroup != null) {
        currentChain.addGroup(currentGroup);
      }
    }
    currentChain=new ChainImpl();
    currentChain.setId(chainName);
    currentChain.setName(chainName);
  }
  if (startOfModel) {
    if (currentModel != null) {
      allModels.add(currentModel);
    }
    currentModel=new ArrayList<>();
  }
  String groupCode3=line.substring(17,20).trim();
  String resNum=line.substring(22,26).trim();
  Character iCode=line.substring(26,27).charAt(0);
  if (iCode == ' ')   iCode=null;
  ResidueNumber residueNumber=new ResidueNumber(chainName,Integer.valueOf(resNum),iCode);
  Character aminoCode1=StructureTools.get1LetterCode(groupCode3);
  String recordName=line.substring(0,6).trim();
  boolean isHetAtomInFile=false;
  if (recordName.equals(""String_Node_Str"")) {
    if (aminoCode1 != null && aminoCode1.equals(StructureTools.UNKNOWN_GROUP_LABEL))     aminoCode1=null;
    isHetAtomInFile=true;
  }
  if (startOfMolecule) {
    currentGroup=getNewGroup(recordName,aminoCode1,groupCode3);
    currentGroup.setPDBName(groupCode3);
    currentGroup.setResidueNumber(residueNumber);
  }
  startOfModel=false;
  startOfMolecule=false;
  Character altLoc=new Character(line.substring(16,17).charAt(0));
  Group altGroup=null;
  if (!residueNumber.equals(currentGroup.getResidueNumber())) {
    currentChain.addGroup(currentGroup);
    currentGroup.trimToSize();
    currentGroup=getNewGroup(recordName,aminoCode1,groupCode3);
    currentGroup.setPDBName(groupCode3);
    currentGroup.setResidueNumber(residueNumber);
    currentGroup.setHetAtomInFile(isHetAtomInFile);
  }
 else {
    if (!altLoc.equals(' ')) {
      logger.debug(""String_Node_Str"" + currentGroup + ""String_Node_Str""+ altGroup);
      altGroup=getCorrectAltLocGroup(altLoc,recordName,aminoCode1,groupCode3);
      if (altGroup.getChain() == null) {
        altGroup.setChain(currentChain);
      }
    }
  }
  atomCount++;
  if (atomCount == atomCAThreshold) {
    logger.warn(""String_Node_Str"" + atomCAThreshold + ""String_Node_Str"");
    seqResChains.clear();
    switchCAOnly();
  }
  if (atomCount == loadMaxAtoms) {
    logger.warn(""String_Node_Str"",loadMaxAtoms,line);
    return;
  }
  if (atomCount > loadMaxAtoms) {
    return;
  }
  String fullname=line.substring(12,16);
  if (parseCAonly) {
    if (!fullname.equals(""String_Node_Str"")) {
      atomCount--;
      return;
    }
  }
  if (params.getAcceptedAtomNames() != null) {
    boolean found=false;
    for (    String ok : params.getAcceptedAtomNames()) {
      if (ok.equals(fullname.trim())) {
        found=true;
        break;
      }
    }
    if (!found) {
      atomCount--;
      return;
    }
  }
  int pdbnumber=Integer.parseInt(line.substring(6,11).trim());
  AtomImpl atom=new AtomImpl();
  atom.setPDBserial(pdbnumber);
  atom.setAltLoc(altLoc);
  atom.setName(fullname.trim());
  double x=Double.parseDouble(line.substring(30,38).trim());
  double y=Double.parseDouble(line.substring(38,46).trim());
  double z=Double.parseDouble(line.substring(46,54).trim());
  double[] coords=new double[3];
  coords[0]=x;
  coords[1]=y;
  coords[2]=z;
  atom.setCoords(coords);
  float occu=1.0f;
  if (line.length() > 59) {
    try {
      occu=Float.parseFloat(line.substring(54,60).trim());
    }
 catch (    NumberFormatException e) {
    }
  }
  float tempf=0.0f;
  if (line.length() > 65) {
    try {
      tempf=Float.parseFloat(line.substring(60,66).trim());
    }
 catch (    NumberFormatException e) {
    }
  }
  atom.setOccupancy(occu);
  atom.setTempFactor(tempf);
  Element element=Element.R;
  if (line.length() > 77) {
    try {
      element=Element.valueOfIgnoreCase(line.substring(76,78).trim());
    }
 catch (    IllegalArgumentException e) {
    }
  }
 else {
    String elementSymbol=null;
    if (fullname.trim().length() == 4) {
      elementSymbol=fullname.substring(0,1);
    }
 else     if (fullname.trim().length() > 1) {
      elementSymbol=fullname.substring(0,2).trim();
    }
    try {
      if (elementSymbol != null)       element=Element.valueOfIgnoreCase(elementSymbol);
    }
 catch (    IllegalArgumentException e) {
      logger.warn(""String_Node_Str"",elementSymbol);
    }
  }
  atom.setElement(element);
  if (altGroup != null) {
    altGroup.addAtom(atom);
    altGroup=null;
  }
 else {
    currentGroup.addAtom(atom);
  }
  if (!currentGroup.hasAtom(atom.getName())) {
    currentGroup.addAtom(atom);
  }
}","/** 
 * Handler for ATOM. Record Format: <pre> ATOM      1  N   ASP A  15     110.964  24.941  59.191  1.00 83.44           N COLUMNS        DATA TYPE       FIELD         DEFINITION --------------------------------------------------------------------------------- 1 -  6        Record name     ""ATOM  "" 7 - 11        Integer         serial        Atom serial number. 13 - 16        Atom            name          Atom name. 17             Character       altLoc        Alternate location indicator. 18 - 20        Residue name    resName       Residue name. 22             Character       chainID       Chain identifier. 23 - 26        Integer         resSeq        Residue sequence number. 27             AChar           iCode         Code for insertion of residues. 31 - 38        Real(8.3)       x             Orthogonal coordinates for X in Angstroms. 39 - 46        Real(8.3)       y             Orthogonal coordinates for Y in Angstroms. 47 - 54        Real(8.3)       z             Orthogonal coordinates for Z in Angstroms. 55 - 60        Real(6.2)       occupancy     Occupancy. 61 - 66        Real(6.2)       tempFactor    Temperature factor. 73 - 76        LString(4)      segID         Segment identifier, left-justified. 77 - 78        LString(2)      element       Element symbol, right-justified. 79 - 80        LString(2)      charge        Charge on the atom. </pre>
 */
private void pdb_ATOM_Handler(String line){
  if (params.isHeaderOnly())   return;
  String chainName=line.substring(21,22);
  if (chainName.equals(""String_Node_Str"")) {
    blankChainIdsPresent=true;
  }
  if (currentChain != null && !currentChain.getName().equals(chainName)) {
    startOfMolecule=true;
  }
  if (startOfMolecule) {
    if (currentChain != null) {
      currentModel.add(currentChain);
      if (currentGroup != null) {
        currentChain.addGroup(currentGroup);
      }
    }
    currentChain=new ChainImpl();
    currentChain.setId(chainName);
    currentChain.setName(chainName);
  }
  if (startOfModel) {
    if (currentModel != null) {
      allModels.add(currentModel);
    }
    currentModel=new ArrayList<>();
  }
  String groupCode3=line.substring(17,20).trim();
  String resNum=line.substring(22,26).trim();
  Character iCode=line.substring(26,27).charAt(0);
  if (iCode == ' ')   iCode=null;
  ResidueNumber residueNumber=new ResidueNumber(chainName,Integer.valueOf(resNum),iCode);
  Character aminoCode1=StructureTools.get1LetterCode(groupCode3);
  String recordName=line.substring(0,6).trim();
  boolean isHetAtomInFile=false;
  if (recordName.equals(""String_Node_Str"")) {
    if (aminoCode1 != null && aminoCode1.equals(StructureTools.UNKNOWN_GROUP_LABEL))     aminoCode1=null;
    isHetAtomInFile=true;
  }
  if (startOfMolecule) {
    currentGroup=getNewGroup(recordName,aminoCode1,groupCode3);
    currentGroup.setPDBName(groupCode3);
    currentGroup.setResidueNumber(residueNumber);
    currentGroup.setHetAtomInFile(isHetAtomInFile);
  }
  startOfModel=false;
  startOfMolecule=false;
  Character altLoc=new Character(line.substring(16,17).charAt(0));
  Group altGroup=null;
  if (!residueNumber.equals(currentGroup.getResidueNumber())) {
    currentChain.addGroup(currentGroup);
    currentGroup.trimToSize();
    currentGroup=getNewGroup(recordName,aminoCode1,groupCode3);
    currentGroup.setPDBName(groupCode3);
    currentGroup.setResidueNumber(residueNumber);
    currentGroup.setHetAtomInFile(isHetAtomInFile);
  }
 else {
    if (!altLoc.equals(' ')) {
      logger.debug(""String_Node_Str"" + currentGroup + ""String_Node_Str""+ altGroup);
      altGroup=getCorrectAltLocGroup(altLoc,recordName,aminoCode1,groupCode3);
      if (altGroup.getChain() == null) {
        altGroup.setChain(currentChain);
      }
    }
  }
  atomCount++;
  if (atomCount == atomCAThreshold) {
    logger.warn(""String_Node_Str"" + atomCAThreshold + ""String_Node_Str"");
    seqResChains.clear();
    switchCAOnly();
  }
  if (atomCount == loadMaxAtoms) {
    logger.warn(""String_Node_Str"",loadMaxAtoms,line);
    return;
  }
  if (atomCount > loadMaxAtoms) {
    return;
  }
  String fullname=line.substring(12,16);
  if (parseCAonly) {
    if (!fullname.equals(""String_Node_Str"")) {
      atomCount--;
      return;
    }
  }
  if (params.getAcceptedAtomNames() != null) {
    boolean found=false;
    for (    String ok : params.getAcceptedAtomNames()) {
      if (ok.equals(fullname.trim())) {
        found=true;
        break;
      }
    }
    if (!found) {
      atomCount--;
      return;
    }
  }
  int pdbnumber=Integer.parseInt(line.substring(6,11).trim());
  AtomImpl atom=new AtomImpl();
  atom.setPDBserial(pdbnumber);
  atom.setAltLoc(altLoc);
  atom.setName(fullname.trim());
  double x=Double.parseDouble(line.substring(30,38).trim());
  double y=Double.parseDouble(line.substring(38,46).trim());
  double z=Double.parseDouble(line.substring(46,54).trim());
  double[] coords=new double[3];
  coords[0]=x;
  coords[1]=y;
  coords[2]=z;
  atom.setCoords(coords);
  float occu=1.0f;
  if (line.length() > 59) {
    try {
      occu=Float.parseFloat(line.substring(54,60).trim());
    }
 catch (    NumberFormatException e) {
    }
  }
  float tempf=0.0f;
  if (line.length() > 65) {
    try {
      tempf=Float.parseFloat(line.substring(60,66).trim());
    }
 catch (    NumberFormatException e) {
    }
  }
  atom.setOccupancy(occu);
  atom.setTempFactor(tempf);
  Element element=Element.R;
  if (line.length() > 77) {
    try {
      element=Element.valueOfIgnoreCase(line.substring(76,78).trim());
    }
 catch (    IllegalArgumentException e) {
    }
  }
 else {
    String elementSymbol=null;
    if (fullname.trim().length() == 4) {
      elementSymbol=fullname.substring(0,1);
    }
 else     if (fullname.trim().length() > 1) {
      elementSymbol=fullname.substring(0,2).trim();
    }
    try {
      if (elementSymbol != null)       element=Element.valueOfIgnoreCase(elementSymbol);
    }
 catch (    IllegalArgumentException e) {
      logger.warn(""String_Node_Str"",elementSymbol);
    }
  }
  atom.setElement(element);
  if (altGroup != null) {
    altGroup.addAtom(atom);
    altGroup=null;
  }
 else {
    currentGroup.addAtom(atom);
  }
  if (!currentGroup.hasAtom(atom.getName())) {
    currentGroup.addAtom(atom);
  }
}",0.995830660679923
16424,"@Test public void testSITE() throws IOException {
  String remark800Test=""String_Node_Str"" + newline + ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline;
  String sitesTest=""String_Node_Str"" + newline + ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline;
  InputStream inStream=this.getClass().getResourceAsStream(""String_Node_Str"");
  Structure s=parser.parsePDBFile(inStream);
  Chain chain=new ChainImpl();
  chain.setChainID(""String_Node_Str"");
  for (  Site site : s.getSites()) {
    for (    Group group : site.getGroups()) {
      group.setChain(chain);
    }
  }
  StringBuilder remark800=new StringBuilder();
  StringBuilder sites=new StringBuilder();
  for (  Site site : s.getSites()) {
    remark800.append(site.remark800toPDB());
    sites.append(site.toPDB());
  }
  if (!remark800.toString().equals(remark800Test)) {
  }
  assertTrue(""String_Node_Str"",remark800.toString().equals(remark800Test));
  if (!sites.toString().equals(sitesTest)) {
    System.out.println(""String_Node_Str"");
    System.out.println(sitesTest);
    System.out.println(""String_Node_Str"");
    System.out.println(sites.toString());
  }
  assertEquals(""String_Node_Str"",sites.toString(),sitesTest);
}","@Test public void testSITE() throws IOException {
  String remark800Test=""String_Node_Str"" + newline + ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline;
  String sitesTest=""String_Node_Str"" + newline + ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline+ ""String_Node_Str""+ newline;
  InputStream inStream=this.getClass().getResourceAsStream(""String_Node_Str"");
  Structure s=parser.parsePDBFile(inStream);
  Chain chain=new ChainImpl();
  chain.setName(""String_Node_Str"");
  for (  Site site : s.getSites()) {
    for (    Group group : site.getGroups()) {
      group.setChain(chain);
    }
  }
  StringBuilder remark800=new StringBuilder();
  StringBuilder sites=new StringBuilder();
  for (  Site site : s.getSites()) {
    remark800.append(site.remark800toPDB());
    sites.append(site.toPDB());
  }
  if (!remark800.toString().equals(remark800Test)) {
  }
  assertTrue(""String_Node_Str"",remark800.toString().equals(remark800Test));
  if (!sites.toString().equals(sitesTest)) {
    System.out.println(""String_Node_Str"");
    System.out.println(sitesTest);
    System.out.println(""String_Node_Str"");
    System.out.println(sites.toString());
  }
  assertEquals(""String_Node_Str"",sites.toString(),sitesTest);
}",0.997181655137074
16425,"@Test public void test3th3() throws StructureException, IOException {
  AtomCache cache=new AtomCache();
  StructureIO.setAtomCache(cache);
  Structure s=StructureIO.getStructure(""String_Node_Str"");
  Chain c=s.getChainByPDB(""String_Node_Str"");
  ResidueNumber rn=ResidueNumber.fromString(""String_Node_Str"");
  rn.setChainName(""String_Node_Str"");
  Group g=c.getGroupByPDB(rn);
  assertEquals(""String_Node_Str"",g.getPDBName());
  int count=0;
  for (  Group gr : c.getAtomGroups()) {
    if (gr.getResidueNumber().equals(rn))     count++;
  }
  assertEquals(2,count);
}","@Test public void test3th3() throws StructureException, IOException {
  AtomCache cache=new AtomCache();
  StructureIO.setAtomCache(cache);
  Structure s=StructureIO.getStructure(""String_Node_Str"");
  Chain c=s.getPolyChainByPDB(""String_Node_Str"");
  ResidueNumber rn=ResidueNumber.fromString(""String_Node_Str"");
  rn.setChainName(""String_Node_Str"");
  Group g=c.getGroupByPDB(rn);
  assertEquals(""String_Node_Str"",g.getPDBName());
  int count=0;
  for (  Group gr : c.getAtomGroups()) {
    if (gr.getResidueNumber().equals(rn))     count++;
  }
  assertEquals(1,count);
  c=s.getNonPolyChainByPDB(""String_Node_Str"");
  g=c.getGroupByPDB(rn);
  assertNotNull(g);
  assertEquals(""String_Node_Str"",g.getPDBName());
}",0.8847352024922118
16426,"private void printStructure(Structure struc){
  System.out.println(struc);
  String pdbid=struc.getPDBCode();
  for (int i=0; i < struc.nrModels(); i++) {
    for (    Chain ch : struc.getModel(i)) {
      if (!ch.getChainID().equals(""String_Node_Str""))       continue;
      System.out.println(pdbid + ""String_Node_Str"" + ch.getChainID()+ ""String_Node_Str""+ ch.getAtomSequence());
      System.out.println(pdbid + ""String_Node_Str"" + ch.getChainID()+ ""String_Node_Str""+ ch.getSeqResSequence());
      List<Group> group=ch.getSeqResGroups();
      int seqPos=0;
      for (      Group gp : group) {
        System.out.println(ch.getChainID() + ""String_Node_Str"" + seqPos+ ""String_Node_Str""+ gp.getResidueNumber()+ ""String_Node_Str""+ gp.getPDBName()+ ""String_Node_Str""+ gp.getType());
        seqPos++;
      }
    }
  }
}","private void printStructure(Structure struc){
  System.out.println(struc);
  String pdbid=struc.getPDBCode();
  for (int i=0; i < struc.nrModels(); i++) {
    for (    Chain ch : struc.getModel(i)) {
      if (!ch.getName().equals(""String_Node_Str""))       continue;
      System.out.println(pdbid + ""String_Node_Str"" + ch.getName()+ ""String_Node_Str""+ ch.getAtomSequence());
      System.out.println(pdbid + ""String_Node_Str"" + ch.getName()+ ""String_Node_Str""+ ch.getSeqResSequence());
      List<Group> group=ch.getSeqResGroups();
      int seqPos=0;
      for (      Group gp : group) {
        System.out.println(ch.getName() + ""String_Node_Str"" + seqPos+ ""String_Node_Str""+ gp.getResidueNumber()+ ""String_Node_Str""+ gp.getPDBName()+ ""String_Node_Str""+ gp.getType());
        seqPos++;
      }
    }
  }
}",0.849079754601227
16427,"private static void demoContacts(String pdbCode) throws IOException, StructureException {
  AtomCache cache=new AtomCache();
  cache.setUseMmCif(true);
  StructureIO.setAtomCache(cache);
  Structure structure=StructureIO.getStructure(pdbCode);
  Chain chain=structure.getChainByPDB(""String_Node_Str"");
  String[] atoms={""String_Node_Str""};
  AtomContactSet contacts=StructureTools.getAtomsInContact(chain,atoms,8.0);
  System.out.println(""String_Node_Str"");
  for (  AtomContact contact : contacts) {
    Atom atom1=contact.getPair().getFirst();
    Atom atom2=contact.getPair().getSecond();
    System.out.printf(""String_Node_Str"",atom1.getGroup().getResidueNumber(),atom1.getGroup().getPDBName(),atom2.getGroup().getResidueNumber(),atom2.getGroup().getPDBName(),contact.getDistance());
  }
  System.out.println(""String_Node_Str"" + contacts.size());
  GroupContactSet groupContacts=new GroupContactSet(contacts);
  System.out.println(""String_Node_Str"" + groupContacts.size());
  contacts=StructureTools.getAtomsInContact(structure.getChain(0),structure.getChain(1),5.5,false);
  System.out.println(""String_Node_Str"");
  for (  AtomContact contact : contacts) {
    Atom atom1=contact.getPair().getFirst();
    Atom atom2=contact.getPair().getSecond();
    System.out.printf(""String_Node_Str"",atom1.getGroup().getResidueNumber(),atom1.getGroup().getChainId(),atom1.getGroup().getPDBName(),atom1.getName(),atom2.getGroup().getResidueNumber(),atom2.getGroup().getChainId(),atom2.getGroup().getPDBName(),atom2.getName(),contact.getDistance());
  }
  System.out.println(""String_Node_Str"" + contacts.size());
  groupContacts=new GroupContactSet(contacts);
  System.out.println(""String_Node_Str"" + groupContacts.size());
}","private static void demoContacts(String pdbCode) throws IOException, StructureException {
  AtomCache cache=new AtomCache();
  cache.setUseMmCif(true);
  StructureIO.setAtomCache(cache);
  Structure structure=StructureIO.getStructure(pdbCode);
  Chain chain=structure.getPolyChainByPDB(""String_Node_Str"");
  String[] atoms={""String_Node_Str""};
  AtomContactSet contacts=StructureTools.getAtomsInContact(chain,atoms,8.0);
  System.out.println(""String_Node_Str"");
  for (  AtomContact contact : contacts) {
    Atom atom1=contact.getPair().getFirst();
    Atom atom2=contact.getPair().getSecond();
    System.out.printf(""String_Node_Str"",atom1.getGroup().getResidueNumber(),atom1.getGroup().getPDBName(),atom2.getGroup().getResidueNumber(),atom2.getGroup().getPDBName(),contact.getDistance());
  }
  System.out.println(""String_Node_Str"" + contacts.size());
  GroupContactSet groupContacts=new GroupContactSet(contacts);
  System.out.println(""String_Node_Str"" + groupContacts.size());
  contacts=StructureTools.getAtomsInContact(structure.getChain(0),structure.getChain(1),5.5,false);
  System.out.println(""String_Node_Str"");
  for (  AtomContact contact : contacts) {
    Atom atom1=contact.getPair().getFirst();
    Atom atom2=contact.getPair().getSecond();
    System.out.printf(""String_Node_Str"",atom1.getGroup().getResidueNumber(),atom1.getGroup().getChainId(),atom1.getGroup().getPDBName(),atom1.getName(),atom2.getGroup().getResidueNumber(),atom2.getGroup().getChainId(),atom2.getGroup().getPDBName(),atom2.getName(),contact.getDistance());
  }
  System.out.println(""String_Node_Str"" + contacts.size());
  groupContacts=new GroupContactSet(contacts);
  System.out.println(""String_Node_Str"" + groupContacts.size());
}",0.9988358556461
16428,"public static void main(String[] args) throws IOException, StructureException {
  String pdbID=""String_Node_Str"";
  FileParsingParameters params=new FileParsingParameters();
  params.setParseSecStruc(true);
  AtomCache cache=new AtomCache();
  cache.setFileParsingParams(params);
  cache.setUseMmCif(false);
  Structure s=cache.getStructure(pdbID);
  System.out.println(""String_Node_Str"");
  List<SecStrucInfo> ssi=SecStrucTools.getSecStrucInfo(s);
  for (  SecStrucInfo ss : ssi) {
    System.out.println(ss.getGroup().getChain().getChainID() + ""String_Node_Str"" + ss.getGroup().getResidueNumber()+ ""String_Node_Str""+ ss.getGroup().getPDBName()+ ""String_Node_Str""+ ss.toString());
  }
  DSSPParser.fetch(pdbID,s,true);
  System.out.println(""String_Node_Str"");
  ssi=SecStrucTools.getSecStrucInfo(s);
  for (  SecStrucInfo ss : ssi) {
    System.out.println(ss.getGroup().getChain().getChainID() + ""String_Node_Str"" + ss.getGroup().getResidueNumber()+ ""String_Node_Str""+ ss.getGroup().getPDBName()+ ""String_Node_Str""+ ss.toString());
  }
}","public static void main(String[] args) throws IOException, StructureException {
  String pdbID=""String_Node_Str"";
  FileParsingParameters params=new FileParsingParameters();
  params.setParseSecStruc(true);
  AtomCache cache=new AtomCache();
  cache.setFileParsingParams(params);
  cache.setUseMmCif(false);
  Structure s=cache.getStructure(pdbID);
  System.out.println(""String_Node_Str"");
  List<SecStrucInfo> ssi=SecStrucTools.getSecStrucInfo(s);
  for (  SecStrucInfo ss : ssi) {
    System.out.println(ss.getGroup().getChain().getName() + ""String_Node_Str"" + ss.getGroup().getResidueNumber()+ ""String_Node_Str""+ ss.getGroup().getPDBName()+ ""String_Node_Str""+ ss.toString());
  }
  DSSPParser.fetch(pdbID,s,true);
  System.out.println(""String_Node_Str"");
  ssi=SecStrucTools.getSecStrucInfo(s);
  for (  SecStrucInfo ss : ssi) {
    System.out.println(ss.getGroup().getChain().getName() + ""String_Node_Str"" + ss.getGroup().getResidueNumber()+ ""String_Node_Str""+ ss.getGroup().getPDBName()+ ""String_Node_Str""+ ss.toString());
  }
}",0.9893822393822392
16429,"public void basicLoad(){
  try {
    PDBFileReader reader=new PDBFileReader();
    reader.setPath(""String_Node_Str"");
    FileParsingParameters params=new FileParsingParameters();
    params.setAlignSeqRes(true);
    params.setParseSecStruc(false);
    reader.setFileParsingParameters(params);
    Structure structure=reader.getStructureById(""String_Node_Str"");
    System.out.println(structure);
    Chain c=structure.getChainByPDB(""String_Node_Str"");
    System.out.print(c);
    System.out.println(c.getEntityInfo());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void basicLoad(){
  try {
    PDBFileReader reader=new PDBFileReader();
    reader.setPath(""String_Node_Str"");
    FileParsingParameters params=new FileParsingParameters();
    params.setAlignSeqRes(true);
    params.setParseSecStruc(false);
    reader.setFileParsingParameters(params);
    Structure structure=reader.getStructureById(""String_Node_Str"");
    System.out.println(structure);
    Chain c=structure.getPolyChainByPDB(""String_Node_Str"");
    System.out.print(c);
    System.out.println(c.getEntityInfo());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9965635738831616
16430,"public void loadStructureIO(){
  try {
    Structure s1=StructureIO.getStructure(""String_Node_Str"");
    System.out.println(s1.getPDBCode() + ""String_Node_Str"");
    System.out.println(StructureTools.getNrAtoms(s1));
    Chain chain1=s1.getChain(0);
    System.out.println(""String_Node_Str"" + chain1);
    System.out.println(""String_Node_Str"" + chain1.getChainID() + ""String_Node_Str"");
    for (    SeqMisMatch mm : chain1.getSeqMisMatches()) {
      System.out.println(mm);
    }
    Structure s2=StructureIO.getBiologicalAssembly(""String_Node_Str"");
    System.out.println(s2.getPDBCode() + ""String_Node_Str"");
    System.out.println(StructureTools.getNrAtoms(s2));
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void loadStructureIO(){
  try {
    Structure s1=StructureIO.getStructure(""String_Node_Str"");
    System.out.println(s1.getPDBCode() + ""String_Node_Str"");
    System.out.println(StructureTools.getNrAtoms(s1));
    Chain chain1=s1.getChain(0);
    System.out.println(""String_Node_Str"" + chain1);
    System.out.println(""String_Node_Str"" + chain1.getName() + ""String_Node_Str"");
    for (    SeqMisMatch mm : chain1.getSeqMisMatches()) {
      System.out.println(mm);
    }
    Structure s2=StructureIO.getBiologicalAssembly(""String_Node_Str"");
    System.out.println(s2.getPDBCode() + ""String_Node_Str"");
    System.out.println(StructureTools.getNrAtoms(s2));
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.992429456297316
16431,"/** 
 * An example demonstrating how to directly use the mmCif file parsing classes. This could potentially be used to use the parser to populate a data-structure that is different from the biojava-structure data model.
 */
public void loadFromDirectAccess(){
  String pdbId=""String_Node_Str"";
  StructureProvider pdbreader=new MMCIFFileReader();
  try {
    Structure s=pdbreader.getStructureById(pdbId);
    Chain h=s.getChainByPDB(""String_Node_Str"");
    List<Group> ligands=h.getAtomLigands();
    System.out.println(""String_Node_Str"" + h.getChainID());
    for (    Group l : ligands) {
      System.out.println(l);
    }
    System.out.println(""String_Node_Str"");
    Group qwe=h.getGroupByPDB(new ResidueNumber(""String_Node_Str"",373,null));
    System.out.println(qwe.getChemComp());
    System.out.println(h.getSeqResSequence());
    System.out.println(h.getAtomSequence());
    System.out.println(h.getAtomGroups(GroupType.HETATM));
    System.out.println(""String_Node_Str"" + s.getEntityInfos());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 * An example demonstrating how to directly use the mmCif file parsing classes. This could potentially be used to use the parser to populate a data-structure that is different from the biojava-structure data model.
 */
public void loadFromDirectAccess(){
  String pdbId=""String_Node_Str"";
  StructureProvider pdbreader=new MMCIFFileReader();
  try {
    Structure s=pdbreader.getStructureById(pdbId);
    Chain h=s.getNonPolyChainByPDB(""String_Node_Str"");
    List<Group> ligands=h.getAtomLigands();
    System.out.println(""String_Node_Str"" + h.getName());
    for (    Group l : ligands) {
      System.out.println(l);
    }
    System.out.println(""String_Node_Str"");
    Group qwe=h.getGroupByPDB(new ResidueNumber(""String_Node_Str"",373,null));
    System.out.println(qwe.getChemComp());
    System.out.println(h.getSeqResSequence());
    System.out.println(h.getAtomSequence());
    System.out.println(h.getAtomGroups(GroupType.HETATM));
    System.out.println(""String_Node_Str"" + s.getEntityInfos());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9915651358950328
16432,"/** 
 * Retrieve a non-polymeric Chain based on the 'public' chain name (authId) for the given model index
 * @param authId the author id (chainName, public chain id)
 * @param modelIdx the index of the required model (0-based)
 * @return a non-polymeric Chain or null if it can't be found
 */
Chain getNonPolyChainByPDB(String authId,int modelIdx);","/** 
 * Retrieve the first non-polymeric Chain corresponding to the 'public' chain name (authId) and the given model index. <p> Note that other non-polymeric chains might still exist with the same authId, due to the one-to-many relationship between public chain ids (authIds) and the stored non-polymeric  chains that follow the mmCIF data model.  If the user is interested in non-polymeric chains different from first one, he/she would need to go through   {@link #getNonPolyChains(int)} to find them all.
 * @param authId the author id (chainName, public chain id)
 * @param modelIdx the index of the required model (0-based)
 * @return a non-polymeric Chain or null if it can't be found
 */
Chain getNonPolyChainByPDB(String authId,int modelIdx);",0.5391621129326047
16433,"/** 
 * Request a particular chain from a particular model
 * @param modelnr the number of the model to use
 * @param authId the name of a chain that should be returned
 * @return Chain the requested chain
 * @throws StructureException
 * @Deprecated use {@link #getChainByPDB(String,int)} instead
 */
@Deprecated Chain findChain(String authId,int modelnr) throws StructureException ;","/** 
 * Request a particular chain from a particular model
 * @param authId the name of a chain that should be returned
 * @param modelnr the number of the model to use
 * @return Chain the requested chain
 * @throws StructureException
 * @Deprecated use {@link #getPolyChainByPDB(String,int)} or {@link #getNonPolyChainByPDB(String,int)} instead
 */
@Deprecated Chain findChain(String authId,int modelnr) throws StructureException ;",0.6609547123623011
16434,"/** 
 * Prints the connections in PDB style Rewritten since 5.0 to use   {@link Bond}s Will produce strictly one CONECT record per bond (won't group several bonds in one line)
 */
private String printPDBConnections(){
  StringBuilder str=new StringBuilder();
  for (  Chain c : structure.getChains()) {
    for (    Group g : c.getAtomGroups()) {
      for (      Atom a : g.getAtoms()) {
        for (        Bond b : a.getBonds()) {
          str.append(String.format(""String_Node_Str"" + newline,b.getAtomA().getPDBserial(),b.getAtomB().getPDBserial()));
        }
      }
    }
  }
  return str.toString();
}","/** 
 * Prints the connections in PDB style Rewritten since 5.0 to use   {@link Bond}s Will produce strictly one CONECT record per bond (won't group several bonds in one line)
 */
private String printPDBConnections(){
  StringBuilder str=new StringBuilder();
  for (  Chain c : structure.getChains()) {
    for (    Group g : c.getAtomGroups()) {
      for (      Atom a : g.getAtoms()) {
        if (a.getBonds() != null) {
          for (          Bond b : a.getBonds()) {
            str.append(String.format(""String_Node_Str"" + newline,b.getAtomA().getPDBserial(),b.getAtomB().getPDBserial()));
          }
        }
      }
    }
  }
  return str.toString();
}",0.95141065830721
16435,"public static void toPDB(Atom a,StringBuffer str){
  toPDB(a,str,a.getGroup().getChainId());
}","public static void toPDB(Atom a,StringBuffer str){
  toPDB(a,str,a.getGroup().getChain().getName());
}",0.9387755102040816
16436,"/** 
 * Calculate interfaces between original asymmetric unit and neighboring whole unit cells, including the original full unit cell i.e. i=0,j=0,k=0
 * @param set
 * @param cutoff
 */
private void calcInterfacesCrystal(StructureInterfaceList set,double cutoff){
  long start=-1;
  long end=-1;
  int trialCount=0;
  int skippedRedundant=0;
  int skippedAUsNoOverlap=0;
  int skippedChainsNoOverlap=0;
  int skippedSelfEquivalent=0;
  Matrix4d[] ops=null;
  if (isCrystallographic) {
    ops=structure.getCrystallographicInfo().getTransformationsOrthonormal();
  }
 else {
    ops=new Matrix4d[1];
    ops[0]=new Matrix4d(IDENTITY);
  }
  UnitCellBoundingBox bbGrid=new UnitCellBoundingBox(numOperatorsSg,numChainsAu);
  ;
  bbGrid.setBbs(structure,ops,INCLUDE_HETATOMS);
  if (!isCrystallographic)   numCells=0;
  boolean verbose=logger.isDebugEnabled();
  if (verbose) {
    trialCount=0;
    start=System.currentTimeMillis();
    int neighbors=(2 * numCells + 1) * (2 * numCells + 1) * (2 * numCells + 1) - 1;
    int auTrials=(numChainsAu * (numChainsAu - 1)) / 2;
    int trials=numChainsAu * numOperatorsSg * numChainsAu* neighbors;
    logger.debug(""String_Node_Str"" + auTrials);
    logger.debug(""String_Node_Str"" + neighbors + ""String_Node_Str""+ numCells+ ""String_Node_Str""+ ""String_Node_Str""+ numChainsAu+ ""String_Node_Str""+ numOperatorsSg+ ""String_Node_Str""+ neighbors+ ""String_Node_Str""+ trials);
    logger.debug(""String_Node_Str"" + (auTrials + trials));
  }
  for (int a=-numCells; a <= numCells; a++) {
    for (int b=-numCells; b <= numCells; b++) {
      for (int c=-numCells; c <= numCells; c++) {
        Point3i trans=new Point3i(a,b,c);
        Vector3d transOrth=new Vector3d(a,b,c);
        if (a != 0 || b != 0 || c != 0)         this.crystallographicInfo.getCrystalCell().transfToOrthonormal(transOrth);
        UnitCellBoundingBox bbGridTrans=bbGrid.getTranslatedBbs(transOrth);
        for (int n=0; n < numOperatorsSg; n++) {
          if (!bbGrid.getAuBoundingBox(0).overlaps(bbGridTrans.getAuBoundingBox(n),cutoff)) {
            skippedAUsNoOverlap++;
            continue;
          }
          CrystalTransform tt=new CrystalTransform(this.crystallographicInfo.getSpaceGroup(),n);
          tt.translate(trans);
          if (isRedundant(tt)) {
            skippedRedundant++;
            continue;
          }
          addVisited(tt);
          boolean selfEquivalent=false;
          if (tt.isEquivalent(tt)) {
            logger.debug(""String_Node_Str"" + tt + ""String_Node_Str"");
            selfEquivalent=true;
          }
          StringBuilder builder=null;
          if (verbose)           builder=new StringBuilder(tt + ""String_Node_Str"");
          int contactsFound=0;
          for (int j=0; j < numChainsAu; j++) {
            for (int i=0; i < numChainsAu; i++) {
              if (selfEquivalent && (j > i)) {
                skippedSelfEquivalent++;
                continue;
              }
              if (n == 0 && a == 0 && b == 0 && c == 0 && i == j)               continue;
              if (!bbGrid.getChainBoundingBox(0,i).overlaps(bbGridTrans.getChainBoundingBox(n,j),cutoff)) {
                skippedChainsNoOverlap++;
                if (verbose) {
                  builder.append(""String_Node_Str"");
                }
                continue;
              }
              trialCount++;
              Chain chainj=null;
              Chain chaini=structure.getChain(i);
              if (n == 0 && a == 0 && b == 0 && c == 0) {
                chainj=structure.getChain(j);
              }
 else {
                chainj=(Chain)structure.getChain(j).clone();
                Matrix4d m=new Matrix4d(ops[n]);
                translate(m,transOrth);
                Calc.transform(chainj,m);
              }
              StructureInterface interf=calcContacts(chaini,chainj,cutoff,tt,builder);
              if (interf != null) {
                contactsFound++;
                set.add(interf);
              }
            }
          }
          if (verbose) {
            if (a == 0 && b == 0 && c == 0 && n == 0)             builder.append(""String_Node_Str"" + contactsFound + ""String_Node_Str""+ (numChainsAu * (numChainsAu - 1)) / 2 + ""String_Node_Str"");
 else             if (selfEquivalent)             builder.append(""String_Node_Str"" + contactsFound + ""String_Node_Str""+ (numChainsAu * (numChainsAu + 1)) / 2 + ""String_Node_Str"");
 else             builder.append(""String_Node_Str"" + contactsFound + ""String_Node_Str""+ numChainsAu * numChainsAu + ""String_Node_Str"");
            logger.debug(builder.toString());
          }
        }
      }
    }
  }
  end=System.currentTimeMillis();
  logger.debug(""String_Node_Str"" + trialCount + ""String_Node_Str""+ (end - start) / 1000 + ""String_Node_Str"");
  logger.debug(""String_Node_Str"" + skippedAUsNoOverlap);
  logger.debug(""String_Node_Str"" + skippedChainsNoOverlap);
  logger.debug(""String_Node_Str"" + skippedRedundant);
  logger.debug(""String_Node_Str"" + skippedSelfEquivalent);
  logger.debug(""String_Node_Str"" + set.size() + ""String_Node_Str"");
}","/** 
 * Calculate interfaces between original asymmetric unit and neighboring whole unit cells, including the original full unit cell i.e. i=0,j=0,k=0
 * @param set
 * @param cutoff
 */
private void calcInterfacesCrystal(StructureInterfaceList set,double cutoff){
  long start=-1;
  long end=-1;
  int trialCount=0;
  int skippedRedundant=0;
  int skippedAUsNoOverlap=0;
  int skippedChainsNoOverlap=0;
  int skippedSelfEquivalent=0;
  Matrix4d[] ops=null;
  if (isCrystallographic) {
    ops=structure.getCrystallographicInfo().getTransformationsOrthonormal();
  }
 else {
    ops=new Matrix4d[1];
    ops[0]=new Matrix4d(IDENTITY);
  }
  UnitCellBoundingBox bbGrid=new UnitCellBoundingBox(numOperatorsSg,numPolyChainsAu);
  ;
  bbGrid.setBbs(structure,ops,INCLUDE_HETATOMS);
  if (!isCrystallographic)   numCells=0;
  boolean verbose=logger.isDebugEnabled();
  if (verbose) {
    trialCount=0;
    start=System.currentTimeMillis();
    int neighbors=(2 * numCells + 1) * (2 * numCells + 1) * (2 * numCells + 1) - 1;
    int auTrials=(numPolyChainsAu * (numPolyChainsAu - 1)) / 2;
    int trials=numPolyChainsAu * numOperatorsSg * numPolyChainsAu* neighbors;
    logger.debug(""String_Node_Str"" + auTrials);
    logger.debug(""String_Node_Str"" + neighbors + ""String_Node_Str""+ numCells+ ""String_Node_Str""+ ""String_Node_Str""+ numPolyChainsAu+ ""String_Node_Str""+ numOperatorsSg+ ""String_Node_Str""+ neighbors+ ""String_Node_Str""+ trials);
    logger.debug(""String_Node_Str"" + (auTrials + trials));
  }
  for (int a=-numCells; a <= numCells; a++) {
    for (int b=-numCells; b <= numCells; b++) {
      for (int c=-numCells; c <= numCells; c++) {
        Point3i trans=new Point3i(a,b,c);
        Vector3d transOrth=new Vector3d(a,b,c);
        if (a != 0 || b != 0 || c != 0)         this.crystallographicInfo.getCrystalCell().transfToOrthonormal(transOrth);
        UnitCellBoundingBox bbGridTrans=bbGrid.getTranslatedBbs(transOrth);
        for (int n=0; n < numOperatorsSg; n++) {
          if (!bbGrid.getAuBoundingBox(0).overlaps(bbGridTrans.getAuBoundingBox(n),cutoff)) {
            skippedAUsNoOverlap++;
            continue;
          }
          CrystalTransform tt=new CrystalTransform(this.crystallographicInfo.getSpaceGroup(),n);
          tt.translate(trans);
          if (isRedundant(tt)) {
            skippedRedundant++;
            continue;
          }
          addVisited(tt);
          boolean selfEquivalent=false;
          if (tt.isEquivalent(tt)) {
            logger.debug(""String_Node_Str"" + tt + ""String_Node_Str"");
            selfEquivalent=true;
          }
          StringBuilder builder=null;
          if (verbose)           builder=new StringBuilder(tt + ""String_Node_Str"");
          int contactsFound=0;
          List<Chain> polyChains=structure.getPolyChains();
          for (int j=0; j < numPolyChainsAu; j++) {
            for (int i=0; i < numPolyChainsAu; i++) {
              if (selfEquivalent && (j > i)) {
                skippedSelfEquivalent++;
                continue;
              }
              if (n == 0 && a == 0 && b == 0 && c == 0 && i == j)               continue;
              if (!bbGrid.getChainBoundingBox(0,i).overlaps(bbGridTrans.getChainBoundingBox(n,j),cutoff)) {
                skippedChainsNoOverlap++;
                if (verbose) {
                  builder.append(""String_Node_Str"");
                }
                continue;
              }
              trialCount++;
              Chain chainj=null;
              Chain chaini=polyChains.get(i);
              if (n == 0 && a == 0 && b == 0 && c == 0) {
                chainj=polyChains.get(j);
              }
 else {
                chainj=(Chain)polyChains.get(j).clone();
                Matrix4d m=new Matrix4d(ops[n]);
                translate(m,transOrth);
                Calc.transform(chainj,m);
              }
              StructureInterface interf=calcContacts(chaini,chainj,cutoff,tt,builder);
              if (interf != null) {
                contactsFound++;
                set.add(interf);
              }
            }
          }
          if (verbose) {
            if (a == 0 && b == 0 && c == 0 && n == 0)             builder.append(""String_Node_Str"" + contactsFound + ""String_Node_Str""+ (numPolyChainsAu * (numPolyChainsAu - 1)) / 2 + ""String_Node_Str"");
 else             if (selfEquivalent)             builder.append(""String_Node_Str"" + contactsFound + ""String_Node_Str""+ (numPolyChainsAu * (numPolyChainsAu + 1)) / 2 + ""String_Node_Str"");
 else             builder.append(""String_Node_Str"" + contactsFound + ""String_Node_Str""+ numPolyChainsAu * numPolyChainsAu + ""String_Node_Str"");
            logger.debug(builder.toString());
          }
        }
      }
    }
  }
  end=System.currentTimeMillis();
  logger.debug(""String_Node_Str"" + trialCount + ""String_Node_Str""+ (end - start) / 1000 + ""String_Node_Str"");
  logger.debug(""String_Node_Str"" + skippedAUsNoOverlap);
  logger.debug(""String_Node_Str"" + skippedChainsNoOverlap);
  logger.debug(""String_Node_Str"" + skippedRedundant);
  logger.debug(""String_Node_Str"" + skippedSelfEquivalent);
  logger.debug(""String_Node_Str"" + set.size() + ""String_Node_Str"");
}",0.9816549570647932
16437,"/** 
 * Returns the list of unique interfaces that the given Structure has upon generation of all crystal symmetry mates. An interface is defined as any pair of chains that contact, i.e. for which there is at least a pair of atoms (one from each chain) within the given cutoff distance.
 * @param cutoff the distance cutoff for 2 chains to be considered in contact
 * @return
 */
public StructureInterfaceList getUniqueInterfaces(double cutoff){
  StructureInterfaceList set=new StructureInterfaceList();
  if (structure.getChains().size() == 0) {
    logger.warn(""String_Node_Str"");
    return set;
  }
  initialiseVisited();
  calcInterfacesCrystal(set,cutoff);
  return set;
}","/** 
 * Returns the list of unique interfaces that the given Structure has upon generation of all crystal symmetry mates. An interface is defined as any pair of chains that contact, i.e. for which there is at least a pair of atoms (one from each chain) within the given cutoff distance.
 * @param cutoff the distance cutoff for 2 chains to be considered in contact
 * @return
 */
public StructureInterfaceList getUniqueInterfaces(double cutoff){
  StructureInterfaceList set=new StructureInterfaceList();
  if (numPolyChainsAu == 0) {
    logger.warn(""String_Node_Str"");
    return set;
  }
  initialiseVisited();
  calcInterfacesCrystal(set,cutoff);
  return set;
}",0.9769516728624535
16438,"public CrystalBuilder(Structure structure){
  this.structure=structure;
  this.crystallographicInfo=structure.getCrystallographicInfo();
  this.numChainsAu=structure.getChains().size();
  this.numOperatorsSg=1;
  if (structure.isCrystallographic()) {
    this.isCrystallographic=true;
    if (this.crystallographicInfo.getSpaceGroup() == null) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
    }
 else {
      this.numOperatorsSg=this.crystallographicInfo.getSpaceGroup().getMultiplicity();
    }
    if (this.crystallographicInfo.getCrystalCell() == null) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
    }
  }
 else {
    this.isCrystallographic=false;
  }
  this.numCells=DEF_NUM_CELLS;
}","public CrystalBuilder(Structure structure){
  this.structure=structure;
  this.crystallographicInfo=structure.getCrystallographicInfo();
  this.numPolyChainsAu=structure.getPolyChains().size();
  this.numOperatorsSg=1;
  if (structure.isCrystallographic()) {
    this.isCrystallographic=true;
    if (this.crystallographicInfo.getSpaceGroup() == null) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
    }
 else {
      this.numOperatorsSg=this.crystallographicInfo.getSpaceGroup().getMultiplicity();
    }
    if (this.crystallographicInfo.getCrystalCell() == null) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
    }
  }
 else {
    this.isCrystallographic=false;
  }
  this.numCells=DEF_NUM_CELLS;
}",0.9947229551451188
16439,"private StructureInterface calcContacts(Chain chaini,Chain chainj,double cutoff,CrystalTransform tt,StringBuilder builder){
  AtomContactSet graph=StructureTools.getAtomsInContact(chaini,chainj,cutoff,INCLUDE_HETATOMS);
  if (graph.size() > 0) {
    if (builder != null)     builder.append(""String_Node_Str"");
    CrystalTransform transf=new CrystalTransform(this.crystallographicInfo.getSpaceGroup());
    StructureInterface interf=new StructureInterface(StructureTools.getAllAtomArray(chaini),StructureTools.getAllAtomArray(chainj),chaini.getChainID(),chainj.getChainID(),graph,transf,tt);
    return interf;
  }
 else {
    if (builder != null)     builder.append(""String_Node_Str"");
    return null;
  }
}","private StructureInterface calcContacts(Chain chaini,Chain chainj,double cutoff,CrystalTransform tt,StringBuilder builder){
  AtomContactSet graph=StructureTools.getAtomsInContact(chaini,chainj,cutoff,INCLUDE_HETATOMS);
  if (graph.size() > 0) {
    if (builder != null)     builder.append(""String_Node_Str"");
    CrystalTransform transf=new CrystalTransform(this.crystallographicInfo.getSpaceGroup());
    StructureInterface interf=new StructureInterface(StructureTools.getAllAtomArray(chaini),StructureTools.getAllAtomArray(chainj),chaini.getName(),chainj.getName(),graph,transf,tt);
    return interf;
  }
 else {
    if (builder != null)     builder.append(""String_Node_Str"");
    return null;
  }
}",0.9844192634560908
16440,"private void setBb(Structure s,boolean includeHetAtoms,int i){
  chainBbs[i]=new BoundingBox[numChainsAu];
  for (int j=0; j < numChainsAu; j++) {
    System.out.println(s.getChain(j));
    chainBbs[i][j]=new BoundingBox(StructureTools.getAllNonHAtomArray(s.getChain(j),includeHetAtoms));
  }
  auBbs[i]=new BoundingBox(chainBbs[i]);
}","private void setBb(Structure s,boolean includeHetAtoms,int i){
  chainBbs[i]=new BoundingBox[numPolyChainsAu];
  List<Chain> polyChains=s.getPolyChains();
  int j=0;
  for (  Chain polyChain : polyChains) {
    chainBbs[i][j]=new BoundingBox(StructureTools.getAllNonHAtomArray(polyChain,includeHetAtoms));
    j++;
  }
  auBbs[i]=new BoundingBox(chainBbs[i]);
}",0.3735632183908046
16441,"public UnitCellBoundingBox(int numOperatorsSg,int numChainsAu){
  this.numOperatorsSg=numOperatorsSg;
  this.numChainsAu=numChainsAu;
  this.chainBbs=new BoundingBox[numOperatorsSg][numChainsAu];
  this.auBbs=new BoundingBox[numOperatorsSg];
}","public UnitCellBoundingBox(int numOperatorsSg,int numPolyChainsAu){
  this.numOperatorsSg=numOperatorsSg;
  this.numPolyChainsAu=numPolyChainsAu;
  this.chainBbs=new BoundingBox[numOperatorsSg][numPolyChainsAu];
  this.auBbs=new BoundingBox[numOperatorsSg];
}",0.9203187250996016
16442,"/** 
 * Returns a new BoundingBoxes object containing the same bounds as this BoundingBoxes object translated by the given translation
 * @param translation
 * @return
 */
public UnitCellBoundingBox getTranslatedBbs(Vector3d translation){
  UnitCellBoundingBox translatedBbs=new UnitCellBoundingBox(numOperatorsSg,numChainsAu);
  for (int i=0; i < numOperatorsSg; i++) {
    for (int j=0; j < numChainsAu; j++) {
      translatedBbs.chainBbs[i][j]=new BoundingBox(this.chainBbs[i][j]);
      translatedBbs.chainBbs[i][j].translate(translation);
    }
    translatedBbs.auBbs[i]=new BoundingBox(translatedBbs.chainBbs[i]);
  }
  return translatedBbs;
}","/** 
 * Returns a new BoundingBoxes object containing the same bounds as this BoundingBoxes object translated by the given translation
 * @param translation
 * @return
 */
public UnitCellBoundingBox getTranslatedBbs(Vector3d translation){
  UnitCellBoundingBox translatedBbs=new UnitCellBoundingBox(numOperatorsSg,numPolyChainsAu);
  for (int i=0; i < numOperatorsSg; i++) {
    for (int j=0; j < numPolyChainsAu; j++) {
      translatedBbs.chainBbs[i][j]=new BoundingBox(this.chainBbs[i][j]);
      translatedBbs.chainBbs[i][j].translate(translation);
    }
    translatedBbs.auBbs[i]=new BoundingBox(translatedBbs.chainBbs[i]);
  }
  return translatedBbs;
}",0.9938931297709924
16443,"/** 
 * {@inheritDoc} 
 */
@Override public List<Chain> getChains(){
  return getChains(0);
}","/** 
 * {@inheritDoc} 
 */
@Override public List<Chain> getChains(){
  if (models.size() == 0) {
    return new ArrayList<>(0);
  }
  return getChains(0);
}",0.7469879518072289
16444,"/** 
 * Given all chains of all models find entities for the nonpolymers and water chains within them, assigning entity ids, types and descriptions to them. The result is written back to the passed entities List.
 * @param nonPolyModels
 * @param waterModels
 * @param entities
 */
public static void createPurelyNonPolyEntities(List<List<Chain>> nonPolyModels,List<List<Chain>> waterModels,List<EntityInfo> entities){
  int maxMolId=0;
  if (!entities.isEmpty()) {
    maxMolId=Collections.max(entities,new Comparator<EntityInfo>(){
      @Override public int compare(      EntityInfo o1,      EntityInfo o2){
        return new Integer(o1.getMolId()).compareTo(o2.getMolId());
      }
    }
).getMolId();
  }
  int molId=maxMolId + 1;
  if (!nonPolyModels.get(0).isEmpty()) {
    List<EntityInfo> nonPolyEntities=new ArrayList<>();
    for (    List<Chain> model : nonPolyModels) {
      for (      Chain c : model) {
        String molecPdbName=c.getAtomGroup(0).getPDBName();
        EntityInfo nonPolyEntity=findNonPolyEntityWithDescription(molecPdbName,nonPolyEntities);
        if (nonPolyEntity == null) {
          nonPolyEntity=new EntityInfo();
          nonPolyEntity.setDescription(molecPdbName);
          nonPolyEntity.setType(EntityType.NONPOLYMER);
          nonPolyEntity.setMolId(molId++);
          nonPolyEntities.add(nonPolyEntity);
        }
        nonPolyEntity.addChain(c);
        c.setEntityInfo(nonPolyEntity);
      }
    }
    entities.addAll(nonPolyEntities);
  }
  if (!waterModels.get(0).isEmpty()) {
    EntityInfo waterEntity=new EntityInfo();
    waterEntity.setType(EntityType.WATER);
    waterEntity.setDescription(""String_Node_Str"");
    waterEntity.setMolId(molId);
    for (    List<Chain> model : waterModels) {
      for (      Chain waterChain : model) {
        waterEntity.addChain(waterChain);
        waterChain.setEntityInfo(waterEntity);
      }
    }
    entities.add(waterEntity);
  }
}","/** 
 * Given all chains of all models find entities for the nonpolymers and water chains within them, assigning entity ids, types and descriptions to them. The result is written back to the passed entities List.
 * @param nonPolyModels
 * @param waterModels
 * @param entities
 */
public static void createPurelyNonPolyEntities(List<List<Chain>> nonPolyModels,List<List<Chain>> waterModels,List<EntityInfo> entities){
  if (nonPolyModels.isEmpty())   return;
  int maxMolId=0;
  if (!entities.isEmpty()) {
    maxMolId=Collections.max(entities,new Comparator<EntityInfo>(){
      @Override public int compare(      EntityInfo o1,      EntityInfo o2){
        return new Integer(o1.getMolId()).compareTo(o2.getMolId());
      }
    }
).getMolId();
  }
  int molId=maxMolId + 1;
  if (!nonPolyModels.get(0).isEmpty()) {
    List<EntityInfo> nonPolyEntities=new ArrayList<>();
    for (    List<Chain> model : nonPolyModels) {
      for (      Chain c : model) {
        String molecPdbName=c.getAtomGroup(0).getPDBName();
        EntityInfo nonPolyEntity=findNonPolyEntityWithDescription(molecPdbName,nonPolyEntities);
        if (nonPolyEntity == null) {
          nonPolyEntity=new EntityInfo();
          nonPolyEntity.setDescription(molecPdbName);
          nonPolyEntity.setType(EntityType.NONPOLYMER);
          nonPolyEntity.setMolId(molId++);
          nonPolyEntities.add(nonPolyEntity);
        }
        nonPolyEntity.addChain(c);
        c.setEntityInfo(nonPolyEntity);
      }
    }
    entities.addAll(nonPolyEntities);
  }
  if (!waterModels.get(0).isEmpty()) {
    EntityInfo waterEntity=new EntityInfo();
    waterEntity.setType(EntityType.WATER);
    waterEntity.setDescription(""String_Node_Str"");
    waterEntity.setMolId(molId);
    for (    List<Chain> model : waterModels) {
      for (      Chain waterChain : model) {
        waterEntity.addChain(waterChain);
        waterChain.setEntityInfo(waterEntity);
      }
    }
    entities.add(waterEntity);
  }
}",0.9895381474866036
16445,"private TreeMap<String,EntityInfo> findEntitiesFromAlignment(){
  Set<Integer> polyChainIndices=new TreeSet<Integer>();
  for (int i=0; i < polyModels.get(0).size(); i++) {
    polyChainIndices.add(i);
  }
  TreeMap<String,EntityInfo> chainIds2entities=new TreeMap<String,EntityInfo>();
  int molId=1;
  outer:   for (  int i : polyChainIndices) {
    for (    int j : polyChainIndices) {
      if (j <= i)       continue;
      Chain c1=polyModels.get(0).get(i);
      Chain c2=polyModels.get(0).get(j);
      Map<Integer,Integer> positionIndex1=new HashMap<Integer,Integer>();
      Map<Integer,Integer> positionIndex2=new HashMap<Integer,Integer>();
      String str1=SeqRes2AtomAligner.getFullAtomSequence(c1.getAtomGroups(),positionIndex1,false);
      String str2=SeqRes2AtomAligner.getFullAtomSequence(c2.getAtomGroups(),positionIndex2,false);
      int seq1Length=0;
      int seq2Length=0;
      SequencePair<?,?> pair=null;
      if (isProteinSequence(str1) && isProteinSequence(str2)) {
        ProteinSequence s1=getProteinSequence(str1);
        ProteinSequence s2=getProteinSequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignProtein(s1,s2);
      }
 else       if (isDNASequence(str1) && isDNASequence(str2)) {
        DNASequence s1=getDNASequence(str1);
        DNASequence s2=getDNASequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignDNA(s1,s2);
      }
 else       if (isRNASequence(str1) && isRNASequence(str2)) {
        RNASequence s1=getRNASequence(str1);
        RNASequence s2=getRNASequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignRNA(s1,s2);
      }
 else {
        logger.debug(""String_Node_Str"");
        continue;
      }
      int numGaps=getNumGaps(pair);
      int numGaps1=getNumGapsQuery(pair);
      int numGaps2=getNumGapsTarget(pair);
      int nonGaps=pair.getLength() - numGaps;
      double identity=(double)pair.getNumIdenticals() / (double)nonGaps;
      double gapCov1=(double)numGaps1 / (double)seq1Length;
      double gapCov2=(double)numGaps2 / (double)seq2Length;
      logger.debug(""String_Node_Str"",c1.getId(),c2.getId(),String.format(""String_Node_Str"",identity),String.format(""String_Node_Str"",gapCov1),String.format(""String_Node_Str"",gapCov2));
      logger.debug(""String_Node_Str"" + pair.toString(100));
      if (identity > IDENTITY_THRESHOLD && gapCov1 < GAP_COVERAGE_THRESHOLD && gapCov2 < GAP_COVERAGE_THRESHOLD) {
        if (!chainIds2entities.containsKey(c1.getId()) && !chainIds2entities.containsKey(c2.getId())) {
          logger.debug(""String_Node_Str"",c1.getId(),c2.getId());
          EntityInfo ent=new EntityInfo();
          ent.addChain(c1);
          ent.addChain(c2);
          ent.setMolId(molId++);
          ent.setType(EntityType.POLYMER);
          c1.setEntityInfo(ent);
          c2.setEntityInfo(ent);
          chainIds2entities.put(c1.getId(),ent);
          chainIds2entities.put(c2.getId(),ent);
        }
 else {
          EntityInfo ent=chainIds2entities.get(c1.getId());
          if (ent == null) {
            logger.debug(""String_Node_Str"",c1.getId(),c2.getId());
            ent=chainIds2entities.get(c2.getId());
            ent.addChain(c1);
            c1.setEntityInfo(ent);
            chainIds2entities.put(c1.getId(),ent);
          }
 else {
            logger.debug(""String_Node_Str"",c2.getId(),c1.getId());
            ent.addChain(c2);
            c2.setEntityInfo(ent);
            chainIds2entities.put(c2.getId(),ent);
          }
        }
        if (!areResNumbersAligned(c1,c2)) {
          logger.warn(""String_Node_Str"",c1.getId(),c2.getId());
        }
      }
      if (identity > 1) {
        logger.warn(""String_Node_Str"",c1.getId(),c2.getId(),pair.getNumIdenticals(),nonGaps,identity);
        logger.warn(""String_Node_Str"" + pair.toString(100));
      }
      if (chainIds2entities.size() == polyChainIndices.size())       break outer;
    }
  }
  for (  int i : polyChainIndices) {
    Chain c=polyModels.get(0).get(i);
    if (!chainIds2entities.containsKey(c.getId())) {
      logger.debug(""String_Node_Str"",c.getId());
      EntityInfo ent=new EntityInfo();
      ent.addChain(c);
      ent.setMolId(molId++);
      c.setEntityInfo(ent);
      chainIds2entities.put(c.getId(),ent);
    }
  }
  for (int i=1; i < polyModels.size(); i++) {
    for (    Chain chain : polyModels.get(i)) {
      EntityInfo e=chainIds2entities.get(chain.getId());
      chain.setEntityInfo(e);
      e.addChain(chain);
    }
  }
  return chainIds2entities;
}","private TreeMap<String,EntityInfo> findEntitiesFromAlignment(){
  TreeMap<String,EntityInfo> chainIds2entities=new TreeMap<String,EntityInfo>();
  if (polyModels.isEmpty())   return chainIds2entities;
  Set<Integer> polyChainIndices=new TreeSet<Integer>();
  for (int i=0; i < polyModels.get(0).size(); i++) {
    polyChainIndices.add(i);
  }
  int molId=1;
  outer:   for (  int i : polyChainIndices) {
    for (    int j : polyChainIndices) {
      if (j <= i)       continue;
      Chain c1=polyModels.get(0).get(i);
      Chain c2=polyModels.get(0).get(j);
      Map<Integer,Integer> positionIndex1=new HashMap<Integer,Integer>();
      Map<Integer,Integer> positionIndex2=new HashMap<Integer,Integer>();
      String str1=SeqRes2AtomAligner.getFullAtomSequence(c1.getAtomGroups(),positionIndex1,false);
      String str2=SeqRes2AtomAligner.getFullAtomSequence(c2.getAtomGroups(),positionIndex2,false);
      int seq1Length=0;
      int seq2Length=0;
      SequencePair<?,?> pair=null;
      if (isProteinSequence(str1) && isProteinSequence(str2)) {
        ProteinSequence s1=getProteinSequence(str1);
        ProteinSequence s2=getProteinSequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignProtein(s1,s2);
      }
 else       if (isDNASequence(str1) && isDNASequence(str2)) {
        DNASequence s1=getDNASequence(str1);
        DNASequence s2=getDNASequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignDNA(s1,s2);
      }
 else       if (isRNASequence(str1) && isRNASequence(str2)) {
        RNASequence s1=getRNASequence(str1);
        RNASequence s2=getRNASequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignRNA(s1,s2);
      }
 else {
        logger.debug(""String_Node_Str"");
        continue;
      }
      int numGaps=getNumGaps(pair);
      int numGaps1=getNumGapsQuery(pair);
      int numGaps2=getNumGapsTarget(pair);
      int nonGaps=pair.getLength() - numGaps;
      double identity=(double)pair.getNumIdenticals() / (double)nonGaps;
      double gapCov1=(double)numGaps1 / (double)seq1Length;
      double gapCov2=(double)numGaps2 / (double)seq2Length;
      logger.debug(""String_Node_Str"",c1.getId(),c2.getId(),String.format(""String_Node_Str"",identity),String.format(""String_Node_Str"",gapCov1),String.format(""String_Node_Str"",gapCov2));
      logger.debug(""String_Node_Str"" + pair.toString(100));
      if (identity > IDENTITY_THRESHOLD && gapCov1 < GAP_COVERAGE_THRESHOLD && gapCov2 < GAP_COVERAGE_THRESHOLD) {
        if (!chainIds2entities.containsKey(c1.getId()) && !chainIds2entities.containsKey(c2.getId())) {
          logger.debug(""String_Node_Str"",c1.getId(),c2.getId());
          EntityInfo ent=new EntityInfo();
          ent.addChain(c1);
          ent.addChain(c2);
          ent.setMolId(molId++);
          ent.setType(EntityType.POLYMER);
          c1.setEntityInfo(ent);
          c2.setEntityInfo(ent);
          chainIds2entities.put(c1.getId(),ent);
          chainIds2entities.put(c2.getId(),ent);
        }
 else {
          EntityInfo ent=chainIds2entities.get(c1.getId());
          if (ent == null) {
            logger.debug(""String_Node_Str"",c1.getId(),c2.getId());
            ent=chainIds2entities.get(c2.getId());
            ent.addChain(c1);
            c1.setEntityInfo(ent);
            chainIds2entities.put(c1.getId(),ent);
          }
 else {
            logger.debug(""String_Node_Str"",c2.getId(),c1.getId());
            ent.addChain(c2);
            c2.setEntityInfo(ent);
            chainIds2entities.put(c2.getId(),ent);
          }
        }
        if (!areResNumbersAligned(c1,c2)) {
          logger.warn(""String_Node_Str"",c1.getId(),c2.getId());
        }
      }
      if (identity > 1) {
        logger.warn(""String_Node_Str"",c1.getId(),c2.getId(),pair.getNumIdenticals(),nonGaps,identity);
        logger.warn(""String_Node_Str"" + pair.toString(100));
      }
      if (chainIds2entities.size() == polyChainIndices.size())       break outer;
    }
  }
  for (  int i : polyChainIndices) {
    Chain c=polyModels.get(0).get(i);
    if (!chainIds2entities.containsKey(c.getId())) {
      logger.debug(""String_Node_Str"",c.getId());
      EntityInfo ent=new EntityInfo();
      ent.addChain(c);
      ent.setMolId(molId++);
      c.setEntityInfo(ent);
      chainIds2entities.put(c.getId(),ent);
    }
  }
  for (int i=1; i < polyModels.size(); i++) {
    for (    Chain chain : polyModels.get(i)) {
      EntityInfo e=chainIds2entities.get(chain.getId());
      chain.setEntityInfo(e);
      e.addChain(chain);
    }
  }
  return chainIds2entities;
}",0.9765288544358312
16446,"private void triggerEndFileChecks(){
  currentChain.addGroup(currentGroup);
  currentModel.add(currentChain);
  allModels.add(currentModel);
  assignChainsAndEntities();
  structure.setEntityInfos(entities);
  Date modDate=pdbHeader.getModDate();
  if (modDate.equals(new Date(0))) {
    Date depositionDate=pdbHeader.getDepDate();
    if (!depositionDate.equals(modDate)) {
      pdbHeader.setDepDate(depositionDate);
    }
  }
  structure.setPDBHeader(pdbHeader);
  structure.setCrystallographicInfo(crystallographicInfo);
  if (!journalLines.isEmpty()) {
    buildjournalArticle();
    pdbHeader.setJournalArticle(journalArticle);
  }
  structure.setDBRefs(dbrefs);
  if (params.isAlignSeqRes() && !params.isHeaderOnly()) {
    logger.debug(""String_Node_Str"");
    SeqRes2AtomAligner aligner=new SeqRes2AtomAligner();
    aligner.align(structure,seqResChains);
  }
 else {
    logger.debug(""String_Node_Str"");
    SeqRes2AtomAligner.storeUnAlignedSeqRes(structure,seqResChains,params.isHeaderOnly());
  }
  if (!params.isHeaderOnly()) {
    linkSitesToGroups();
  }
  if (bioAssemblyParser != null) {
    pdbHeader.setBioAssemblies(bioAssemblyParser.getTransformationMap());
  }
  if (ncsOperators != null && ncsOperators.size() > 0) {
    crystallographicInfo.setNcsOperators(ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
  if (rfreeNoCutoffLine > 0 && rfreeStandardLine < 0) {
    pdbHeader.setRfree(rfreeNoCutoffLine);
  }
 else   if (rfreeNoCutoffLine > 0 && rfreeStandardLine > 0) {
    pdbHeader.setRfree(rfreeStandardLine);
  }
 else   if (rfreeNoCutoffLine < 0 && rfreeStandardLine > 0) {
    pdbHeader.setRfree(rfreeStandardLine);
  }
}","private void triggerEndFileChecks(){
  if (currentChain != null && currentGroup != null) {
    currentChain.addGroup(currentGroup);
  }
  if (currentModel != null && currentChain != null) {
    currentModel.add(currentChain);
  }
  if (currentModel != null) {
    allModels.add(currentModel);
  }
  assignChainsAndEntities();
  structure.setEntityInfos(entities);
  Date modDate=pdbHeader.getModDate();
  if (modDate.equals(new Date(0))) {
    Date depositionDate=pdbHeader.getDepDate();
    if (!depositionDate.equals(modDate)) {
      pdbHeader.setDepDate(depositionDate);
    }
  }
  structure.setPDBHeader(pdbHeader);
  structure.setCrystallographicInfo(crystallographicInfo);
  if (!journalLines.isEmpty()) {
    buildjournalArticle();
    pdbHeader.setJournalArticle(journalArticle);
  }
  structure.setDBRefs(dbrefs);
  if (params.isAlignSeqRes() && !params.isHeaderOnly() && !seqResChains.isEmpty()) {
    logger.debug(""String_Node_Str"");
    SeqRes2AtomAligner aligner=new SeqRes2AtomAligner();
    aligner.align(structure,seqResChains);
  }
 else {
    logger.debug(""String_Node_Str"");
    SeqRes2AtomAligner.storeUnAlignedSeqRes(structure,seqResChains,params.isHeaderOnly());
  }
  if (!params.isHeaderOnly()) {
    linkSitesToGroups();
  }
  if (bioAssemblyParser != null) {
    pdbHeader.setBioAssemblies(bioAssemblyParser.getTransformationMap());
  }
  if (ncsOperators != null && ncsOperators.size() > 0) {
    crystallographicInfo.setNcsOperators(ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
  if (rfreeNoCutoffLine > 0 && rfreeStandardLine < 0) {
    pdbHeader.setRfree(rfreeNoCutoffLine);
  }
 else   if (rfreeNoCutoffLine > 0 && rfreeStandardLine > 0) {
    pdbHeader.setRfree(rfreeStandardLine);
  }
 else   if (rfreeNoCutoffLine < 0 && rfreeStandardLine > 0) {
    pdbHeader.setRfree(rfreeStandardLine);
  }
}",0.916547992025064
16447,"private List<Chain> getFirstModelChains(){
  List<Chain> firstModel=new ArrayList<>();
  for (  String id : getChainIds()) {
    for (    Chain chain : chains) {
      if (chain.getId().equals(id)) {
        firstModel.add(chain);
        break;
      }
    }
  }
  return firstModel;
}","private List<Chain> getFirstModelChains(){
  List<Chain> firstModel=new ArrayList<>();
  outer:   for (  String id : getChainIds()) {
    for (    Chain chain : chains) {
      if (chain.getId().equals(id)) {
        firstModel.add(chain);
        break outer;
      }
    }
  }
  return firstModel;
}",0.9744463373083476
16448,"public void align(Structure s,List<Chain> seqResList){
  List<Chain> atomList=s.getModel(0);
  for (  Chain seqRes : seqResList) {
    Chain atomRes=getMatchingAtomRes(seqRes,atomList);
    if (atomRes == null)     continue;
    mapSeqresRecords(atomRes,seqRes);
  }
}","public void align(Structure s,List<Chain> seqResList){
  List<Chain> atomList=s.getModel(0);
  for (  Chain seqRes : seqResList) {
    Chain atomRes=getMatchingAtomRes(seqRes,atomList,false);
    if (atomRes == null)     continue;
    mapSeqresRecords(atomRes,seqRes);
  }
}",0.988929889298893
16449,"/** 
 * Storing unaligned SEQRES groups in a Structure.
 * @param structure
 * @param seqResChains
 */
public static void storeUnAlignedSeqRes(Structure structure,List<Chain> seqResChains,boolean headerOnly){
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> atomChains=structure.getModel(i);
    for (    Chain seqRes : seqResChains) {
      Chain atomRes;
      if (headerOnly) {
        seqRes.setSeqResGroups(seqRes.getAtomGroups());
        seqRes.setAtomGroups(new ArrayList<Group>());
        atomChains.add(seqRes);
      }
 else {
        atomRes=SeqRes2AtomAligner.getMatchingAtomRes(seqRes,atomChains);
        if (atomRes != null)         atomRes.setSeqResGroups(seqRes.getAtomGroups());
 else         logger.warn(""String_Node_Str"" + seqRes.getId());
      }
    }
    if (headerOnly) {
      structure.setChains(i,atomChains);
    }
  }
}","/** 
 * Storing unaligned SEQRES groups in a Structure.
 * @param structure
 * @param seqResChains
 */
public static void storeUnAlignedSeqRes(Structure structure,List<Chain> seqResChains,boolean headerOnly){
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> atomChains=structure.getModel(i);
    for (    Chain seqRes : seqResChains) {
      Chain atomRes;
      if (headerOnly) {
        seqRes.setSeqResGroups(seqRes.getAtomGroups());
        seqRes.setAtomGroups(new ArrayList<Group>());
        atomChains.add(seqRes);
      }
 else {
        atomRes=SeqRes2AtomAligner.getMatchingAtomRes(seqRes,atomChains,true);
        if (atomRes != null)         atomRes.setSeqResGroups(seqRes.getAtomGroups());
 else         logger.warn(""String_Node_Str"" + seqRes.getId());
      }
    }
    if (headerOnly) {
      structure.setChains(i,atomChains);
    }
  }
}",0.9971214738054116
16450,"public static Chain getMatchingAtomRes(Chain seqRes,List<Chain> atomList){
  Iterator<Chain> iter=atomList.iterator();
  while (iter.hasNext()) {
    Chain atomChain=iter.next();
    if (atomChain.getName().equals(seqRes.getName())) {
      return atomChain;
    }
  }
  logger.info(""String_Node_Str"" + seqRes.getId() + ""String_Node_Str""+ seqRes.getName()+ ""String_Node_Str""+ atomList.size());
  return null;
}","/** 
 * @param seqRes
 * @param atomList
 * @param useChainId if true chainId (Chain.getId) is used for matching, if false chainName (Chain.getName) is used 
 * @return
 */
public static Chain getMatchingAtomRes(Chain seqRes,List<Chain> atomList,boolean useChainId){
  Iterator<Chain> iter=atomList.iterator();
  while (iter.hasNext()) {
    Chain atomChain=iter.next();
    String atomChainId=null;
    String seqResChainId=null;
    if (useChainId) {
      atomChainId=atomChain.getId();
      seqResChainId=seqRes.getId();
    }
 else {
      atomChainId=atomChain.getName();
      seqResChainId=seqRes.getName();
    }
    if (atomChainId.equals(seqResChainId)) {
      return atomChain;
    }
  }
  logger.info(""String_Node_Str"" + seqRes.getId() + ""String_Node_Str""+ seqRes.getName()+ ""String_Node_Str""+ atomList.size());
  return null;
}",0.641660015961692
16451,"private void alignSeqRes(){
  logger.debug(""String_Node_Str"");
  for (int model=0; model < structure.nrModels(); model++) {
    List<Chain> atomList=structure.getModel(model);
    for (    Chain seqResChain : seqResChains) {
      Chain atomChain=SeqRes2AtomAligner.getMatchingAtomRes(seqResChain,atomList);
      if (atomChain == null) {
        logger.warn(""String_Node_Str"",seqResChain.getId());
        continue;
      }
      List<Group> seqResGroups=new ArrayList<Group>();
      for (int i=0; i < seqResChain.getAtomGroups().size(); i++) {
        seqResGroups.add((Group)seqResChain.getAtomGroups().get(i).clone());
      }
      for (int seqResPos=0; seqResPos < seqResGroups.size(); seqResPos++) {
        Group seqresG=seqResGroups.get(seqResPos);
        boolean found=false;
        for (        Group atomG : atomChain.getAtomGroups()) {
          int internalNr=getInternalNr(atomG);
          if (seqresG.getResidueNumber().getSeqNum() == internalNr) {
            seqResGroups.set(seqResPos,atomG);
            found=true;
            break;
          }
        }
        if (!found)         seqresG.setResidueNumber(null);
      }
      atomChain.setSeqResGroups(seqResGroups);
    }
  }
}","private void alignSeqRes(){
  logger.debug(""String_Node_Str"");
  for (int model=0; model < structure.nrModels(); model++) {
    List<Chain> atomList=structure.getModel(model);
    for (    Chain seqResChain : seqResChains) {
      Chain atomChain=SeqRes2AtomAligner.getMatchingAtomRes(seqResChain,atomList,true);
      if (atomChain == null) {
        logger.warn(""String_Node_Str"",seqResChain.getId());
        continue;
      }
      List<Group> seqResGroups=new ArrayList<Group>();
      for (int i=0; i < seqResChain.getAtomGroups().size(); i++) {
        seqResGroups.add((Group)seqResChain.getAtomGroups().get(i).clone());
      }
      for (int seqResPos=0; seqResPos < seqResGroups.size(); seqResPos++) {
        Group seqresG=seqResGroups.get(seqResPos);
        boolean found=false;
        for (        Group atomG : atomChain.getAtomGroups()) {
          int internalNr=getInternalNr(atomG);
          if (seqresG.getResidueNumber().getSeqNum() == internalNr) {
            seqResGroups.set(seqResPos,atomG);
            found=true;
            break;
          }
        }
        if (!found)         seqresG.setResidueNumber(null);
      }
      atomChain.setSeqResGroups(seqResGroups);
    }
  }
}",0.9979330301777594
16452,"private ResidueNumber findResNumInOtherChains(int i,Chain chain){
  for (  Chain c : getChains()) {
    if (c == chain)     continue;
    Group seqResGroup=c.getSeqResGroup(i);
    if (seqResGroup == null) {
      logger.warn(""String_Node_Str"",i,c.getId(),chain.getId());
      continue;
    }
    if (seqResGroup.getResidueNumber() != null)     return seqResGroup.getResidueNumber();
  }
  return null;
}","private ResidueNumber findResNumInOtherChains(int i,Chain chain){
  for (  Chain c : getFirstModelChains()) {
    if (c == chain)     continue;
    Group seqResGroup=c.getSeqResGroup(i);
    if (seqResGroup == null) {
      logger.warn(""String_Node_Str"",i,c.getId(),chain.getId());
      continue;
    }
    if (seqResGroup.getResidueNumber() != null)     return seqResGroup.getResidueNumber();
  }
  return null;
}",0.9878048780487804
16453,"public static Chain getMatchingAtomRes(Chain seqRes,List<Chain> atomList){
  Iterator<Chain> iter=atomList.iterator();
  while (iter.hasNext()) {
    Chain atomChain=iter.next();
    if (atomChain.getId().equals(seqRes.getId())) {
      return atomChain;
    }
  }
  logger.info(""String_Node_Str"" + seqRes.getId() + ""String_Node_Str""+ seqRes.getName()+ ""String_Node_Str""+ atomList.size());
  return null;
}","public static Chain getMatchingAtomRes(Chain seqRes,List<Chain> atomList){
  Iterator<Chain> iter=atomList.iterator();
  while (iter.hasNext()) {
    Chain atomChain=iter.next();
    if (atomChain.getName().equals(seqRes.getName())) {
      return atomChain;
    }
  }
  logger.info(""String_Node_Str"" + seqRes.getId() + ""String_Node_Str""+ seqRes.getName()+ ""String_Node_Str""+ atomList.size());
  return null;
}",0.5563725490196079
16454,"@Test public void test3C5FWithSeqresPdb() throws IOException, StructureException {
  InputStream inStream=new GZIPInputStream(this.getClass().getResourceAsStream(""String_Node_Str""));
  assertNotNull(inStream);
  PDBFileParser pdbpars=new PDBFileParser();
  FileParsingParameters params=new FileParsingParameters();
  params.setAlignSeqRes(true);
  pdbpars.setFileParsingParameters(params);
  Structure s=pdbpars.parsePDBFile(inStream);
  assertNotNull(s);
  assertEquals(8,s.getChains().size());
  assertEquals(4,s.getEntityInfos().size());
  CrystalBuilder cb=new CrystalBuilder(s);
  StructureInterfaceList interfaces=cb.getUniqueInterfaces(5.5);
  interfaces.calcAsas(100,1,0);
  interfaces.removeInterfacesBelowArea();
  List<StructureInterfaceCluster> clusters=interfaces.getClusters();
  assertEquals(23,interfaces.size());
  assertTrue(""String_Node_Str"",clusters.size() < 23);
  assertEquals(""String_Node_Str"",2,clusters.get(2).getMembers().size());
  assertTrue(""String_Node_Str"",interfaces.get(3).isIsologous());
}","@Test public void test3C5FWithSeqresPdb() throws IOException, StructureException {
  InputStream inStream=new GZIPInputStream(this.getClass().getResourceAsStream(""String_Node_Str""));
  assertNotNull(inStream);
  PDBFileParser pdbpars=new PDBFileParser();
  FileParsingParameters params=new FileParsingParameters();
  params.setAlignSeqRes(true);
  pdbpars.setFileParsingParameters(params);
  Structure s=pdbpars.parsePDBFile(inStream);
  assertNotNull(s);
  assertEquals(8,s.getPolyChains().size());
  assertEquals(6,s.getEntityInfos().size());
  CrystalBuilder cb=new CrystalBuilder(s);
  StructureInterfaceList interfaces=cb.getUniqueInterfaces(5.5);
  interfaces.calcAsas(100,1,0);
  interfaces.removeInterfacesBelowArea();
  List<StructureInterfaceCluster> clusters=interfaces.getClusters();
  assertEquals(23,interfaces.size());
  assertTrue(""String_Node_Str"",clusters.size() < 23);
  assertEquals(""String_Node_Str"",2,clusters.get(2).getMembers().size());
  assertTrue(""String_Node_Str"",interfaces.get(3).isIsologous());
}",0.9970731707317072
16455,"private Atom getAtomFromRecord(String name,String altLoc,String resName,String chainID,String resSeq,String iCode) throws StructureException {
  if (iCode == null || iCode.isEmpty()) {
    iCode=""String_Node_Str"";
  }
  Chain chain=structure.getChainByPDB(chainID);
  ResidueNumber resNum=new ResidueNumber(chainID,Integer.parseInt(resSeq),iCode.charAt(0));
  Group group=chain.getGroupByPDB(resNum);
  Group g=group;
  if (!altLoc.isEmpty()) {
    g=group.getAltLocGroup(altLoc.charAt(0));
    if (g == null)     throw new StructureException(""String_Node_Str"" + altLoc + ""String_Node_Str""+ resSeq+ iCode+ ""String_Node_Str""+ chainID);
  }
  return g.getAtom(name);
}","private Atom getAtomFromRecord(String name,String altLoc,String resName,String chainID,String resSeq,String iCode) throws StructureException {
  if (iCode == null || iCode.isEmpty()) {
    iCode=""String_Node_Str"";
  }
  Chain chain=structure.getChain(chainID);
  ResidueNumber resNum=new ResidueNumber(chainID,Integer.parseInt(resSeq),iCode.charAt(0));
  Group group=chain.getGroupByPDB(resNum);
  Group g=group;
  if (!altLoc.isEmpty()) {
    g=group.getAltLocGroup(altLoc.charAt(0));
    if (g == null)     throw new StructureException(""String_Node_Str"" + altLoc + ""String_Node_Str""+ resSeq+ iCode+ ""String_Node_Str""+ chainID);
  }
  return g.getAtom(name);
}",0.4084400904295403
16456,"/** 
 * Test that the bonds we are finding is consistenty.
 * @throws IOException
 * @throws StructureException
 */
@Test public void testInterGroupBonds() throws IOException, StructureException {
  assertEquals(getInterBonds(""String_Node_Str""),2236);
  assertEquals(getInterBonds(""String_Node_Str""),956);
  assertEquals(getInterBonds(""String_Node_Str""),2290);
  assertEquals(getInterBonds(""String_Node_Str""),22);
}","/** 
 * Test that the bonds we are finding is consistenty.
 * @throws IOException
 * @throws StructureException
 */
@Test public void testInterGroupBonds() throws IOException, StructureException {
  assertEquals(2236,getInterBonds(""String_Node_Str""));
  assertEquals(956,getInterBonds(""String_Node_Str""));
  assertEquals(2294,getInterBonds(""String_Node_Str""));
  assertEquals(22,getInterBonds(""String_Node_Str""));
}",0.7036144578313253
16457,"/** 
 * Find all of the inter group bonds in a structure
 * @param pdbId the pdb id of the structure to determine
 * @return the number of inter group bonds (dobule counted) in a structure
 * @throws IOException
 * @throws StructureException
 */
public int getInterBonds(String pdbId) throws IOException, StructureException {
  AtomCache cache=new AtomCache();
  cache.setUseMmCif(true);
  cache.setFetchBehavior(FetchBehavior.FETCH_FILES);
  FileParsingParameters params=cache.getFileParsingParams();
  params.setCreateAtomBonds(true);
  params.setAlignSeqRes(true);
  params.setParseBioAssembly(true);
  DownloadChemCompProvider dcc=new DownloadChemCompProvider();
  ChemCompGroupFactory.setChemCompProvider(dcc);
  dcc.checkDoFirstInstall();
  cache.setFileParsingParams(params);
  StructureIO.setAtomCache(cache);
  int counter=0;
  Structure newStruc=StructureIO.getStructure(pdbId);
  for (  Chain c : newStruc.getChains()) {
    for (    Group g : c.getAtomGroups()) {
      List<Atom> theseAtoms=g.getAtoms();
      for (      Atom a : theseAtoms) {
        List<Bond> theseBonds=a.getBonds();
        if (theseBonds != null) {
          for (          Bond b : a.getBonds()) {
            Atom other=b.getOther(a);
            int indexOther=theseAtoms.indexOf(other);
            if (indexOther < 0 || indexOther >= theseAtoms.size()) {
              counter++;
            }
          }
        }
      }
    }
  }
  return counter;
}","/** 
 * Find all of the inter group bonds in a structure
 * @param pdbId the pdb id of the structure to determine
 * @return the number of inter group bonds (double counted) in a structure
 * @throws IOException
 * @throws StructureException
 */
public int getInterBonds(String pdbId) throws IOException, StructureException {
  AtomCache cache=new AtomCache();
  cache.setUseMmCif(true);
  cache.setFetchBehavior(FetchBehavior.FETCH_FILES);
  FileParsingParameters params=cache.getFileParsingParams();
  params.setCreateAtomBonds(true);
  params.setAlignSeqRes(true);
  params.setParseBioAssembly(true);
  DownloadChemCompProvider dcc=new DownloadChemCompProvider();
  ChemCompGroupFactory.setChemCompProvider(dcc);
  dcc.checkDoFirstInstall();
  cache.setFileParsingParams(params);
  StructureIO.setAtomCache(cache);
  int counter=0;
  Structure newStruc=StructureIO.getStructure(pdbId);
  for (  Chain c : newStruc.getChains()) {
    for (    Group g : c.getAtomGroups()) {
      List<Atom> theseAtoms=g.getAtoms();
      for (      Atom a : theseAtoms) {
        List<Bond> theseBonds=a.getBonds();
        if (theseBonds != null) {
          for (          Bond b : a.getBonds()) {
            Atom other=b.getOther(a);
            int indexOther=theseAtoms.indexOf(other);
            if (indexOther < 0 || indexOther >= theseAtoms.size()) {
              counter++;
            }
          }
        }
      }
    }
  }
  return counter;
}",0.9993079584775086
16458,"public void addCharges(){
  for (  Chain c : structure.getChains()) {
    for (    Group g : c.getAtomGroups()) {
      ChemComp thisChemComp=ChemCompGroupFactory.getChemComp(g.getPDBName());
      List<ChemCompAtom> chemAtoms=thisChemComp.getAtoms();
      List<Atom> protAtoms=g.getAtoms();
      if (protAtoms.size() != chemAtoms.size()) {
        continue;
      }
      for (int i=0; i < protAtoms.size(); i++) {
        ChemCompAtom cca=chemAtoms.get(i);
        Atom a=protAtoms.get(i);
        try {
          short charge=Short.parseShort(cca.getCharge());
          a.setCharge(charge);
        }
 catch (        NumberFormatException e) {
          logger.info(""String_Node_Str"",a.getName(),g.getPDBName());
          a.setCharge((short)0);
        }
      }
    }
  }
}","/** 
 * Function to add the charges to a given structure.
 */
public static void addCharges(Structure structure){
  for (int i=0; i < structure.nrModels(); i++) {
    for (    Chain c : structure.getChains(i)) {
      for (      Group g : c.getAtomGroups()) {
        ChemComp thisChemComp=ChemCompGroupFactory.getChemComp(g.getPDBName());
        List<ChemCompAtom> chemAtoms=thisChemComp.getAtoms();
        for (        ChemCompAtom chemCompAtom : chemAtoms) {
          Atom atom=g.getAtom(chemCompAtom.getAtom_id());
          String stringCharge=chemCompAtom.getCharge();
          short shortCharge=0;
          if (stringCharge != null) {
            shortCharge=Short.parseShort(stringCharge);
          }
 else {
            logger.warn(""String_Node_Str"" + chemCompAtom.getAtom_id() + ""String_Node_Str""+ thisChemComp.getId());
          }
          if (atom != null) {
            atom.setCharge(shortCharge);
          }
          for (          Group altLoc : g.getAltLocs()) {
            Atom altAtom=altLoc.getAtom(chemCompAtom.getAtom_id());
            if (altAtom != null) {
              altAtom.setCharge(shortCharge);
            }
          }
        }
      }
    }
  }
}",0.4050632911392405
16459,"private void addCharges(){
  ChargeAdder adder=new ChargeAdder(structure);
  adder.addCharges();
}","private void addCharges(){
  ChargeAdder.addCharges(structure);
}",0.7730061349693251
16460,"private void addCharges(){
  ChargeAdder adder=new ChargeAdder(structure);
  adder.addCharges();
}","private void addCharges(){
  ChargeAdder.addCharges(structure);
}",0.7730061349693251
16461,"public void addCharges(){
  for (  Chain c : structure.getChains()) {
    for (    Group g : c.getAtomGroups()) {
      ChemComp thisChemComp=ChemCompGroupFactory.getChemComp(g.getPDBName());
      List<ChemCompAtom> chemAtoms=thisChemComp.getAtoms();
      List<Atom> protAtoms=g.getAtoms();
      if (protAtoms.size() != chemAtoms.size()) {
        continue;
      }
      for (int i=0; i < protAtoms.size(); i++) {
        ChemCompAtom cca=chemAtoms.get(i);
        Atom a=protAtoms.get(i);
        try {
          short charge=Short.parseShort(cca.getCharge());
          a.setCharge(charge);
        }
 catch (        NumberFormatException e) {
          logger.info(""String_Node_Str"",a.getName(),g.getPDBName());
          a.setCharge((short)0);
        }
      }
    }
  }
}","/** 
 * Function to add the charges to a given structure.
 */
public static void addCharges(Structure structure){
  for (int i=0; i < structure.nrModels(); i++) {
    for (    Chain c : structure.getChains(i)) {
      for (      Group g : c.getAtomGroups()) {
        ChemComp thisChemComp=ChemCompGroupFactory.getChemComp(g.getPDBName());
        List<ChemCompAtom> chemAtoms=thisChemComp.getAtoms();
        for (        ChemCompAtom chemCompAtom : chemAtoms) {
          Atom atom=g.getAtom(chemCompAtom.getAtom_id());
          String stringCharge=chemCompAtom.getCharge();
          short shortCharge=0;
          if (stringCharge != null) {
            shortCharge=Short.parseShort(stringCharge);
          }
 else {
            logger.warn(""String_Node_Str"" + chemCompAtom.getAtom_id() + ""String_Node_Str""+ thisChemComp.getId());
          }
          if (atom != null) {
            atom.setCharge(shortCharge);
          }
          for (          Group altLoc : g.getAltLocs()) {
            Atom altAtom=altLoc.getAtom(chemCompAtom.getAtom_id());
            if (altAtom != null) {
              altAtom.setCharge(shortCharge);
            }
          }
        }
      }
    }
  }
}",0.4050632911392405
16462,"/** 
 * Add the charges to the Structure
 */
private void addCharges(){
  ChargeAdder adder=new ChargeAdder(structure);
  adder.addCharges();
}","/** 
 * Add the charges to the Structure
 */
private void addCharges(){
  ChargeAdder.addCharges(structure);
}",0.8537549407114624
16463,"private void addCharges(){
  ChargeAdder adder=new ChargeAdder(structure);
  adder.addCharges();
}","private void addCharges(){
  ChargeAdder.addCharges(structure);
}",0.7730061349693251
16464,"@Override protected void setUp() throws Exception {
  super.setUp();
  AtomCache cache=new AtomCache();
  cache.setUseMmCif(true);
  cache.setFetchBehavior(FetchBehavior.FETCH_FILES);
  FileParsingParameters params=cache.getFileParsingParams();
  params.setUseInternalChainId(true);
  cache.setFileParsingParams(params);
  StructureIO.setAtomCache(cache);
  String pdbId=""String_Node_Str"";
  structure=StructureIO.getStructure(pdbId);
}","@Override protected void setUp() throws Exception {
  super.setUp();
  AtomCache cache=new AtomCache();
  cache.setUseMmCif(true);
  cache.setFetchBehavior(FetchBehavior.FETCH_FILES);
  StructureIO.setAtomCache(cache);
  String pdbId=""String_Node_Str"";
  structure=StructureIO.getStructure(pdbId);
}",0.8136054421768707
16465,"private static int testVersion(String ecodVersion) throws IOException {
  EcodDatabase ecod=EcodFactory.getEcodDatabase(ecodVersion);
  AtomCache cache=new AtomCache();
  cache.setObsoleteBehavior(ObsoleteBehavior.FETCH_OBSOLETE);
  List<EcodDomain> domains=ecod.getAllDomains();
  int errors=0;
  for (  EcodDomain d : domains) {
    Atom[] ca1;
    Structure struct;
    try {
      struct=cache.getStructure(d.getPdbId());
      ca1=StructureTools.getRepresentativeAtomArray(struct);
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + d.getDomainId(),e);
      errors++;
      continue;
    }
catch (    StructureException e) {
      logger.error(""String_Node_Str"" + d.getDomainId(),e);
      errors++;
      continue;
    }
    String rangeStr=d.getRange();
    AtomPositionMap map=new AtomPositionMap(ca1);
    List<? extends ResidueRange> ranges;
    try {
      ranges=ResidueRange.parseMultiple(rangeStr);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"" + d.getPdbId() + ""String_Node_Str""+ d.getRange(),e);
      errors++;
      continue;
    }
    boolean clean=true;
    for (    ResidueRange r : ranges) {
      if (r == null) {
        clean=false;
      }
    }
    if (!clean) {
      logger.error(""String_Node_Str"",d.getPdbId(),d.getRange());
      errors++;
      continue;
    }
    for (    ResidueRange range : ranges) {
      try {
        Integer start=map.getPosition(range.getStart());
        if (start == null) {
          Group g=struct.getChainByPDB(range.getStart().getChainId()).getGroupByPDB(range.getStart());
          if (g != null) {
            logger.warn(""String_Node_Str"" + d.getDomainId() + ""String_Node_Str""+ range);
            clean=false;
          }
 else {
            logger.error(""String_Node_Str"" + d.getDomainId() + ""String_Node_Str""+ range.toString());
            clean=false;
          }
        }
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + d.getDomainId() + ""String_Node_Str""+ range.toString(),e);
        clean=false;
      }
      try {
        Integer end=map.getPosition(range.getEnd());
        if (end == null) {
          Group g=null;
          try {
            g=struct.getChainByPDB(range.getEnd().getChainId()).getGroupByPDB(range.getEnd());
          }
 catch (          StructureException e) {
          }
          if (g != null) {
            logger.warn(""String_Node_Str"" + d.getDomainId() + ""String_Node_Str""+ range);
            clean=false;
          }
 else {
            logger.error(""String_Node_Str"" + d.getDomainId() + ""String_Node_Str""+ range.toString());
            clean=false;
          }
        }
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + d.getDomainId() + ""String_Node_Str""+ range.toString(),e);
        clean=false;
      }
    }
    try {
      ranges=ResidueRangeAndLength.parseMultiple(rangeStr,map);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"" + d.getPdbId() + ""String_Node_Str""+ d.getRange(),e);
      errors++;
      continue;
    }
    clean=true;
    for (    ResidueRange r : ranges) {
      if (r == null) {
        clean=false;
      }
    }
    if (!clean) {
      logger.error(""String_Node_Str"",d.getPdbId(),d.getRange());
      errors++;
      continue;
    }
    String pdbRangeStr=String.format(""String_Node_Str"",d.getPdbId(),d.getRange());
    try {
      cache.getStructure(pdbRangeStr);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"" + pdbRangeStr,e);
      errors++;
      continue;
    }
    logger.info(""String_Node_Str"" + d.getDomainId());
  }
  return errors;
}","private static int testVersion(String ecodVersion) throws IOException {
  EcodDatabase ecod=EcodFactory.getEcodDatabase(ecodVersion);
  AtomCache cache=new AtomCache();
  cache.setObsoleteBehavior(ObsoleteBehavior.FETCH_OBSOLETE);
  List<EcodDomain> domains=ecod.getAllDomains();
  int errors=0;
  for (  EcodDomain d : domains) {
    Atom[] ca1;
    Structure struct;
    try {
      struct=cache.getStructure(d.getPdbId());
      ca1=StructureTools.getRepresentativeAtomArray(struct);
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + d.getDomainId(),e);
      errors++;
      continue;
    }
catch (    StructureException e) {
      logger.error(""String_Node_Str"" + d.getDomainId(),e);
      errors++;
      continue;
    }
    String rangeStr=d.getRange();
    AtomPositionMap map=new AtomPositionMap(ca1);
    List<? extends ResidueRange> ranges;
    try {
      ranges=ResidueRange.parseMultiple(rangeStr);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"" + d.getPdbId() + ""String_Node_Str""+ d.getRange(),e);
      errors++;
      continue;
    }
    boolean clean=true;
    for (    ResidueRange r : ranges) {
      if (r == null) {
        clean=false;
      }
    }
    if (!clean) {
      logger.error(""String_Node_Str"",d.getPdbId(),d.getRange());
      errors++;
      continue;
    }
    for (    ResidueRange range : ranges) {
      try {
        Integer start=map.getPosition(range.getStart());
        if (start == null) {
          Group g=struct.getChainByPDB(range.getStart().getChainName()).getGroupByPDB(range.getStart());
          if (g != null) {
            logger.warn(""String_Node_Str"" + d.getDomainId() + ""String_Node_Str""+ range);
            clean=false;
          }
 else {
            logger.error(""String_Node_Str"" + d.getDomainId() + ""String_Node_Str""+ range.toString());
            clean=false;
          }
        }
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + d.getDomainId() + ""String_Node_Str""+ range.toString(),e);
        clean=false;
      }
      try {
        Integer end=map.getPosition(range.getEnd());
        if (end == null) {
          Group g=null;
          try {
            g=struct.getChainByPDB(range.getEnd().getChainName()).getGroupByPDB(range.getEnd());
          }
 catch (          StructureException e) {
          }
          if (g != null) {
            logger.warn(""String_Node_Str"" + d.getDomainId() + ""String_Node_Str""+ range);
            clean=false;
          }
 else {
            logger.error(""String_Node_Str"" + d.getDomainId() + ""String_Node_Str""+ range.toString());
            clean=false;
          }
        }
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + d.getDomainId() + ""String_Node_Str""+ range.toString(),e);
        clean=false;
      }
    }
    try {
      ranges=ResidueRangeAndLength.parseMultiple(rangeStr,map);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"" + d.getPdbId() + ""String_Node_Str""+ d.getRange(),e);
      errors++;
      continue;
    }
    clean=true;
    for (    ResidueRange r : ranges) {
      if (r == null) {
        clean=false;
      }
    }
    if (!clean) {
      logger.error(""String_Node_Str"",d.getPdbId(),d.getRange());
      errors++;
      continue;
    }
    String pdbRangeStr=String.format(""String_Node_Str"",d.getPdbId(),d.getRange());
    try {
      cache.getStructure(pdbRangeStr);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"" + pdbRangeStr,e);
      errors++;
      continue;
    }
    logger.info(""String_Node_Str"" + d.getDomainId());
  }
  return errors;
}",0.998351195383347
16466,"@Test public void test3th3() throws StructureException, IOException {
  AtomCache cache=new AtomCache();
  FileParsingParameters params=cache.getFileParsingParams();
  params.setUseInternalChainId(false);
  params.setCreateAtomBonds(true);
  StructureIO.setAtomCache(cache);
  Structure s=StructureIO.getStructure(""String_Node_Str"");
  Chain c=s.getChainByPDB(""String_Node_Str"");
  ResidueNumber rn=ResidueNumber.fromString(""String_Node_Str"");
  rn.setChainId(""String_Node_Str"");
  Group g=c.getGroupByPDB(rn);
  assertEquals(""String_Node_Str"",g.getPDBName());
  int count=0;
  for (  Group gr : c.getAtomGroups()) {
    if (gr.getResidueNumber().equals(rn))     count++;
  }
  assertEquals(2,count);
}","@Test public void test3th3() throws StructureException, IOException {
  AtomCache cache=new AtomCache();
  StructureIO.setAtomCache(cache);
  Structure s=StructureIO.getStructure(""String_Node_Str"");
  Chain c=s.getChainByPDB(""String_Node_Str"");
  ResidueNumber rn=ResidueNumber.fromString(""String_Node_Str"");
  rn.setChainName(""String_Node_Str"");
  Group g=c.getGroupByPDB(rn);
  assertEquals(""String_Node_Str"",g.getPDBName());
  int count=0;
  for (  Group gr : c.getAtomGroups()) {
    if (gr.getResidueNumber().equals(rn))     count++;
  }
  assertEquals(2,count);
}",0.8890637293469709
16467,"@Test @Ignore public void test4v5a() throws StructureException, IOException {
  AtomCache cache=new AtomCache();
  FileParsingParameters params=cache.getFileParsingParams();
  params.setUseInternalChainId(false);
  params.setCreateAtomBonds(true);
  StructureIO.setAtomCache(cache);
  StructureIO.getStructure(""String_Node_Str"");
}","@Test @Ignore public void test4v5a() throws StructureException, IOException {
  AtomCache cache=new AtomCache();
  FileParsingParameters params=cache.getFileParsingParams();
  params.setCreateAtomBonds(true);
  StructureIO.setAtomCache(cache);
  StructureIO.getStructure(""String_Node_Str"");
}",0.9373996789727128
16468,"@Test @Ignore public void test4v5aInternalChainIds() throws StructureException, IOException {
  AtomCache cache=new AtomCache();
  FileParsingParameters params=cache.getFileParsingParams();
  params.setUseInternalChainId(true);
  params.setCreateAtomBonds(true);
  StructureIO.setAtomCache(cache);
  StructureIO.getStructure(""String_Node_Str"");
}","@Test @Ignore public void test4v5aInternalChainIds() throws StructureException, IOException {
  AtomCache cache=new AtomCache();
  FileParsingParameters params=cache.getFileParsingParams();
  params.setCreateAtomBonds(true);
  StructureIO.setAtomCache(cache);
  StructureIO.getStructure(""String_Node_Str"");
}",0.9418960244648318
16469,"public static StructureGroup fromXML(Node n){
  String chainID=getAttribute(n,""String_Node_Str"");
  String pdbName=getAttribute(n,""String_Node_Str"");
  String insCode=getAttribute(n,""String_Node_Str"");
  String resN=getAttribute(n,""String_Node_Str"");
  String isAminoAcid=getAttribute(n,""String_Node_Str"");
  ResidueNumber resNum=new ResidueNumber();
  resNum.setChainId(chainID);
  if ((insCode != null) && (!insCode.equals(""String_Node_Str"")) && insCode.length() == 1)   resNum.setInsCode(insCode.charAt(0));
  resNum.setSeqNum(Integer.parseInt(resN));
  StructureGroup g=new StructureGroup(resNum,pdbName,Boolean.valueOf(isAminoAcid));
  return g;
}","public static StructureGroup fromXML(Node n){
  String chainID=getAttribute(n,""String_Node_Str"");
  String pdbName=getAttribute(n,""String_Node_Str"");
  String insCode=getAttribute(n,""String_Node_Str"");
  String resN=getAttribute(n,""String_Node_Str"");
  String isAminoAcid=getAttribute(n,""String_Node_Str"");
  ResidueNumber resNum=new ResidueNumber();
  resNum.setChainName(chainID);
  if ((insCode != null) && (!insCode.equals(""String_Node_Str"")) && insCode.length() == 1)   resNum.setInsCode(insCode.charAt(0));
  resNum.setSeqNum(Integer.parseInt(resN));
  StructureGroup g=new StructureGroup(resNum,pdbName,Boolean.valueOf(isAminoAcid));
  return g;
}",0.9954058192955588
16470,"/** 
 * identify additional groups that are not directly attached to amino acids.
 * @param mc {@link ModifiedCompound}.
 * @param chain a {@link Chain}.
 * @return a list of added groups.
 */
private void identifyAdditionalAttachments(ModifiedCompound mc,List<Group> ligands,Map<String,Chain> mapChainIdChain){
  if (ligands.isEmpty()) {
    return;
  }
  List<Group> identifiedGroups=new ArrayList<Group>();
  for (  StructureGroup num : mc.getGroups(false)) {
    Group group;
    try {
      ResidueNumber resNum=new ResidueNumber();
      resNum.setChainId(num.getChainId());
      resNum.setSeqNum(num.getResidueNumber());
      resNum.setInsCode(num.getInsCode());
      group=mapChainIdChain.get(num.getChainId()).getGroupByPDB(resNum);
    }
 catch (    StructureException e) {
      logger.error(""String_Node_Str"",e);
      continue;
    }
    identifiedGroups.add(group);
  }
  int start=0;
  int n=identifiedGroups.size();
  while (n > start) {
    for (    Group group1 : ligands) {
      for (int i=start; i < n; i++) {
        Group group2=identifiedGroups.get(i);
        if (!identifiedGroups.contains(group1)) {
          List<Atom[]> linkedAtoms=StructureUtil.findAtomLinkages(group1,group2,false,bondLengthTolerance);
          if (!linkedAtoms.isEmpty()) {
            for (            Atom[] atoms : linkedAtoms) {
              mc.addAtomLinkage(StructureUtil.getStructureAtomLinkage(atoms[0],false,atoms[1],false));
            }
            identifiedGroups.add(group1);
            break;
          }
        }
      }
    }
    start=n;
    n=identifiedGroups.size();
  }
}","/** 
 * identify additional groups that are not directly attached to amino acids.
 * @param mc {@link ModifiedCompound}.
 * @param chain a {@link Chain}.
 * @return a list of added groups.
 */
private void identifyAdditionalAttachments(ModifiedCompound mc,List<Group> ligands,Map<String,Chain> mapChainIdChain){
  if (ligands.isEmpty()) {
    return;
  }
  List<Group> identifiedGroups=new ArrayList<Group>();
  for (  StructureGroup num : mc.getGroups(false)) {
    Group group;
    try {
      ResidueNumber resNum=new ResidueNumber();
      resNum.setChainName(num.getChainId());
      resNum.setSeqNum(num.getResidueNumber());
      resNum.setInsCode(num.getInsCode());
      group=mapChainIdChain.get(num.getChainId()).getGroupByPDB(resNum);
    }
 catch (    StructureException e) {
      logger.error(""String_Node_Str"",e);
      continue;
    }
    identifiedGroups.add(group);
  }
  int start=0;
  int n=identifiedGroups.size();
  while (n > start) {
    for (    Group group1 : ligands) {
      for (int i=start; i < n; i++) {
        Group group2=identifiedGroups.get(i);
        if (!identifiedGroups.contains(group1)) {
          List<Atom[]> linkedAtoms=StructureUtil.findAtomLinkages(group1,group2,false,bondLengthTolerance);
          if (!linkedAtoms.isEmpty()) {
            for (            Atom[] atoms : linkedAtoms) {
              mc.addAtomLinkage(StructureUtil.getStructureAtomLinkage(atoms[0],false,atoms[1],false));
            }
            identifiedGroups.add(group1);
            break;
          }
        }
      }
    }
    start=n;
    n=identifiedGroups.size();
  }
}",0.9981261711430356
16471,"public String getChainId(){
  return resNum.getChainId();
}","public String getChainId(){
  return resNum.getChainName();
}",0.95
16472,"@Override public String toString(){
  StringBuilder sb=new StringBuilder();
  sb.append(pdbName);
  sb.append('\t');
  sb.append(resNum.getChainId());
  sb.append('\t');
  sb.append(resNum.getSeqNum());
  if (resNum.getInsCode() != null)   sb.append(resNum.getInsCode());
  sb.append('\t');
  return sb.toString();
}","@Override public String toString(){
  StringBuilder sb=new StringBuilder();
  sb.append(pdbName);
  sb.append('\t');
  sb.append(resNum.getChainName());
  sb.append('\t');
  sb.append(resNum.getSeqNum());
  if (resNum.getInsCode() != null)   sb.append(resNum.getInsCode());
  sb.append('\t');
  return sb.toString();
}",0.9905362776025236
16473,"public void setChainId(String chainId){
  if (resNum == null)   resNum=new ResidueNumber();
  resNum.setChainId(chainId);
}","public void setChainId(String chainId){
  if (resNum == null)   resNum=new ResidueNumber();
  resNum.setChainName(chainId);
}",0.9758064516129032
16474,"/** 
 * Converts an array of ResidueNumbers into a jMol selection. <p>For example, ""select 11^ :A.CA or 12^ :A.CA;"" would select the CA atoms of residues 11-12 on chain A.
 * @param residues Residues to include in the selection. Nulls are ignored.
 * @return
 */
private static String buildJmolSelection(ResidueNumber[] residues){
  StringBuilder cmd=new StringBuilder(""String_Node_Str"");
  for (  ResidueNumber res : residues) {
    if (res != null) {
      cmd.append(String.format(""String_Node_Str"",res.getSeqNum(),res.getInsCode() == null ? ""String_Node_Str"" : res.getInsCode(),res.getChainId()));
    }
  }
  cmd.append(""String_Node_Str"");
  return cmd.toString();
}","/** 
 * Converts an array of ResidueNumbers into a jMol selection. <p>For example, ""select 11^ :A.CA or 12^ :A.CA;"" would select the CA atoms of residues 11-12 on chain A.
 * @param residues Residues to include in the selection. Nulls are ignored.
 * @return
 */
private static String buildJmolSelection(ResidueNumber[] residues){
  StringBuilder cmd=new StringBuilder(""String_Node_Str"");
  for (  ResidueNumber res : residues) {
    if (res != null) {
      cmd.append(String.format(""String_Node_Str"",res.getSeqNum(),res.getInsCode() == null ? ""String_Node_Str"" : res.getInsCode(),res.getChainName()));
    }
  }
  cmd.append(""String_Node_Str"");
  return cmd.toString();
}",0.9955357142857144
16475,"/** 
 * After all the analysis iteratives have finished, the final MultipleAlignment object is constructed using the alignment graph.
 * @return true if the MultipleAlignment could be reconstructed, falseotherwise
 * @throws StructureException
 */
private boolean buildAlignment() throws StructureException {
  if (levels.size() == 1)   return false;
  MultipleAlignment msa=new MultipleAlignmentImpl();
  msa.getEnsemble().setAtomArrays(new ArrayList<Atom[]>());
  msa.getEnsemble().setStructureIdentifiers(new ArrayList<StructureIdentifier>());
  msa.getEnsemble().setAlgorithmName(CeSymm.algorithmName);
  msa.getEnsemble().setVersion(CeSymm.version);
  BlockSet bs=new BlockSetImpl(msa);
  Block b=new BlockImpl(bs);
  b.setAlignRes(new ArrayList<List<Integer>>());
  ConnectivityInspector<Integer,DefaultEdge> inspector=new ConnectivityInspector<Integer,DefaultEdge>(alignGraph);
  List<Set<Integer>> comps=inspector.connectedSets();
  List<ResidueGroup> groups=new ArrayList<ResidueGroup>(comps.size());
  for (  Set<Integer> comp : comps)   groups.add(new ResidueGroup(comp));
  int order=1;
  for (  MultipleAlignment m : levels)   order*=m.size();
  for (int su=0; su < order; su++)   b.getAlignRes().add(new ArrayList<Integer>());
  for (  ResidueGroup group : groups) {
    if (group.order() != order)     continue;
    group.combineWith(b.getAlignRes());
  }
  if (b.length() == 0)   return false;
  for (int su=0; su < order; su++) {
    Collections.sort(b.getAlignRes().get(su));
    msa.getEnsemble().getAtomArrays().add(allAtoms);
    msa.getEnsemble().getStructureIdentifiers().add(result.getStructureId());
  }
  result.setMultipleAlignment(msa);
  result.setRefined(true);
  result.setSymmOrder(order);
  result.setSymmLevels(levels.size());
  return true;
}","/** 
 * After all the analysis iteratives have finished, the final MultipleAlignment object is constructed using the alignment graph.
 * @return true if the MultipleAlignment could be reconstructed, falseotherwise
 * @throws StructureException
 */
private boolean buildAlignment() throws StructureException {
  if (levels.size() == 1) {
    result.setSymmLevels(1);
    return false;
  }
  MultipleAlignment msa=new MultipleAlignmentImpl();
  msa.getEnsemble().setAtomArrays(new ArrayList<Atom[]>());
  msa.getEnsemble().setStructureIdentifiers(new ArrayList<StructureIdentifier>());
  msa.getEnsemble().setAlgorithmName(CeSymm.algorithmName);
  msa.getEnsemble().setVersion(CeSymm.version);
  BlockSet bs=new BlockSetImpl(msa);
  Block b=new BlockImpl(bs);
  b.setAlignRes(new ArrayList<List<Integer>>());
  ConnectivityInspector<Integer,DefaultEdge> inspector=new ConnectivityInspector<Integer,DefaultEdge>(alignGraph);
  List<Set<Integer>> comps=inspector.connectedSets();
  List<ResidueGroup> groups=new ArrayList<ResidueGroup>(comps.size());
  for (  Set<Integer> comp : comps)   groups.add(new ResidueGroup(comp));
  int order=1;
  for (  MultipleAlignment m : levels)   order*=m.size();
  for (int su=0; su < order; su++)   b.getAlignRes().add(new ArrayList<Integer>());
  for (  ResidueGroup group : groups) {
    if (group.order() != order)     continue;
    group.combineWith(b.getAlignRes());
  }
  if (b.length() == 0)   return false;
  for (int su=0; su < order; su++) {
    Collections.sort(b.getAlignRes().get(su));
    msa.getEnsemble().getAtomArrays().add(allAtoms);
    msa.getEnsemble().getStructureIdentifiers().add(result.getStructureId());
  }
  result.setMultipleAlignment(msa);
  result.setRefined(true);
  result.setSymmOrder(order);
  result.setSymmLevels(levels.size());
  return true;
}",0.9813422445001392
16476,"/** 
 * After all the analysis iteratives have finished, the final MultipleAlignment object is constructed using the alignment graph.
 * @return true if the MultipleAlignment could be reconstructed, falseotherwise
 * @throws StructureException
 */
private boolean buildAlignment() throws StructureException {
  if (levels.size() == 1)   return false;
  MultipleAlignment msa=new MultipleAlignmentImpl();
  msa.getEnsemble().setAtomArrays(new ArrayList<Atom[]>());
  msa.getEnsemble().setStructureIdentifiers(new ArrayList<StructureIdentifier>());
  msa.getEnsemble().setAlgorithmName(CeSymm.algorithmName);
  msa.getEnsemble().setVersion(CeSymm.version);
  BlockSet bs=new BlockSetImpl(msa);
  Block b=new BlockImpl(bs);
  b.setAlignRes(new ArrayList<List<Integer>>());
  ConnectivityInspector<Integer,DefaultEdge> inspector=new ConnectivityInspector<Integer,DefaultEdge>(alignGraph);
  List<Set<Integer>> comps=inspector.connectedSets();
  List<ResidueGroup> groups=new ArrayList<ResidueGroup>(comps.size());
  for (  Set<Integer> comp : comps)   groups.add(new ResidueGroup(comp));
  int order=1;
  for (  MultipleAlignment m : levels)   order*=m.size();
  for (int su=0; su < order; su++)   b.getAlignRes().add(new ArrayList<Integer>());
  for (  ResidueGroup group : groups) {
    if (group.order() != order)     continue;
    group.combineWith(b.getAlignRes());
  }
  if (b.length() == 0)   return false;
  for (int su=0; su < order; su++) {
    Collections.sort(b.getAlignRes().get(su));
    msa.getEnsemble().getAtomArrays().add(allAtoms);
    msa.getEnsemble().getStructureIdentifiers().add(result.getStructureId());
  }
  result.setMultipleAlignment(msa);
  result.setRefined(true);
  result.setSymmOrder(order);
  result.setSymmLevels(levels.size());
  return true;
}","/** 
 * After all the analysis iteratives have finished, the final MultipleAlignment object is constructed using the alignment graph.
 * @return true if the MultipleAlignment could be reconstructed, falseotherwise
 * @throws StructureException
 */
private boolean buildAlignment() throws StructureException {
  if (levels.size() == 1) {
    result.setSymmLevels(1);
    return false;
  }
  MultipleAlignment msa=new MultipleAlignmentImpl();
  msa.getEnsemble().setAtomArrays(new ArrayList<Atom[]>());
  msa.getEnsemble().setStructureIdentifiers(new ArrayList<StructureIdentifier>());
  msa.getEnsemble().setAlgorithmName(CeSymm.algorithmName);
  msa.getEnsemble().setVersion(CeSymm.version);
  BlockSet bs=new BlockSetImpl(msa);
  Block b=new BlockImpl(bs);
  b.setAlignRes(new ArrayList<List<Integer>>());
  ConnectivityInspector<Integer,DefaultEdge> inspector=new ConnectivityInspector<Integer,DefaultEdge>(alignGraph);
  List<Set<Integer>> comps=inspector.connectedSets();
  List<ResidueGroup> groups=new ArrayList<ResidueGroup>(comps.size());
  for (  Set<Integer> comp : comps)   groups.add(new ResidueGroup(comp));
  int order=1;
  for (  MultipleAlignment m : levels)   order*=m.size();
  for (int su=0; su < order; su++)   b.getAlignRes().add(new ArrayList<Integer>());
  for (  ResidueGroup group : groups) {
    if (group.order() != order)     continue;
    group.combineWith(b.getAlignRes());
  }
  if (b.length() == 0)   return false;
  for (int su=0; su < order; su++) {
    Collections.sort(b.getAlignRes().get(su));
    msa.getEnsemble().getAtomArrays().add(allAtoms);
    msa.getEnsemble().getStructureIdentifiers().add(result.getStructureId());
  }
  result.setMultipleAlignment(msa);
  result.setRefined(true);
  result.setSymmOrder(order);
  result.setSymmLevels(levels.size());
  return true;
}",0.9813422445001392
16477,"/** 
 * Converts an Atom object to an   {@link AtomSite} object.
 * @param a
 * @param model
 * @param chainId
 * @param internalChainId
 * @param atomId the atom id to be written to AtomSite
 * @return
 */
public static AtomSite convertAtomToAtomSite(Atom a,int model,String chainId,String internalChainId,int atomId){
  Group g=a.getGroup();
  String record;
  if (g.getType().equals(GroupType.HETATM)) {
    record=""String_Node_Str"";
  }
 else {
    record=""String_Node_Str"";
  }
  String entityId=""String_Node_Str"";
  String labelSeqId=Integer.toString(g.getResidueNumber().getSeqNum());
  if (g.getChain() != null && g.getChain().getEntityInfo() != null) {
    entityId=Integer.toString(g.getChain().getEntityInfo().getMolId());
    labelSeqId=Integer.toString(g.getChain().getEntityInfo().getAlignedResIndex(g,g.getChain()));
  }
  Character altLoc=a.getAltLoc();
  String altLocStr=altLoc.toString();
  if (altLoc == null || altLoc == ' ') {
    altLocStr=MMCIF_DEFAULT_VALUE;
  }
  Element e=a.getElement();
  String eString=e.toString().toUpperCase();
  if (e.equals(Element.R)) {
    eString=""String_Node_Str"";
  }
  String insCode=MMCIF_MISSING_VALUE;
  if (g.getResidueNumber().getInsCode() != null) {
    insCode=Integer.toString(g.getResidueNumber().getInsCode());
  }
  AtomSite atomSite=new AtomSite();
  atomSite.setGroup_PDB(record);
  atomSite.setId(Integer.toString(atomId));
  atomSite.setType_symbol(eString);
  atomSite.setLabel_atom_id(a.getName());
  atomSite.setLabel_alt_id(altLocStr);
  atomSite.setLabel_comp_id(g.getPDBName());
  atomSite.setLabel_asym_id(internalChainId);
  atomSite.setLabel_entity_id(entityId);
  atomSite.setLabel_seq_id(labelSeqId);
  atomSite.setPdbx_PDB_ins_code(insCode);
  atomSite.setCartn_x(FileConvert.d3.format(a.getX()));
  atomSite.setCartn_y(FileConvert.d3.format(a.getY()));
  atomSite.setCartn_z(FileConvert.d3.format(a.getZ()));
  atomSite.setOccupancy(FileConvert.d2.format(a.getOccupancy()));
  atomSite.setB_iso_or_equiv(FileConvert.d2.format(a.getTempFactor()));
  atomSite.setAuth_seq_id(Integer.toString(g.getResidueNumber().getSeqNum()));
  atomSite.setAuth_comp_id(g.getPDBName());
  atomSite.setAuth_asym_id(chainId);
  atomSite.setAuth_atom_id(a.getName());
  atomSite.setPdbx_PDB_model_num(Integer.toString(model));
  return atomSite;
}","/** 
 * Converts an Atom object to an   {@link AtomSite} object.
 * @param a
 * @param model
 * @param chainId
 * @param internalChainId
 * @param atomId the atom id to be written to AtomSite
 * @return
 */
public static AtomSite convertAtomToAtomSite(Atom a,int model,String chainId,String internalChainId,int atomId){
  Group g=a.getGroup();
  String record;
  if (g.getType().equals(GroupType.HETATM)) {
    record=""String_Node_Str"";
  }
 else {
    record=""String_Node_Str"";
  }
  String entityId=""String_Node_Str"";
  String labelSeqId=Integer.toString(g.getResidueNumber().getSeqNum());
  if (g.getChain() != null && g.getChain().getEntityInfo() != null) {
    entityId=Integer.toString(g.getChain().getEntityInfo().getMolId());
    labelSeqId=Integer.toString(g.getChain().getEntityInfo().getAlignedResIndex(g,g.getChain()));
  }
  Character altLoc=a.getAltLoc();
  String altLocStr=altLoc.toString();
  if (altLoc == null || altLoc == ' ') {
    altLocStr=MMCIF_DEFAULT_VALUE;
  }
  Element e=a.getElement();
  String eString=e.toString().toUpperCase();
  if (e.equals(Element.R)) {
    eString=""String_Node_Str"";
  }
  String insCode=MMCIF_MISSING_VALUE;
  if (g.getResidueNumber().getInsCode() != null) {
    insCode=Character.toString(g.getResidueNumber().getInsCode());
  }
  AtomSite atomSite=new AtomSite();
  atomSite.setGroup_PDB(record);
  atomSite.setId(Integer.toString(atomId));
  atomSite.setType_symbol(eString);
  atomSite.setLabel_atom_id(a.getName());
  atomSite.setLabel_alt_id(altLocStr);
  atomSite.setLabel_comp_id(g.getPDBName());
  atomSite.setLabel_asym_id(internalChainId);
  atomSite.setLabel_entity_id(entityId);
  atomSite.setLabel_seq_id(labelSeqId);
  atomSite.setPdbx_PDB_ins_code(insCode);
  atomSite.setCartn_x(FileConvert.d3.format(a.getX()));
  atomSite.setCartn_y(FileConvert.d3.format(a.getY()));
  atomSite.setCartn_z(FileConvert.d3.format(a.getZ()));
  atomSite.setOccupancy(FileConvert.d2.format(a.getOccupancy()));
  atomSite.setB_iso_or_equiv(FileConvert.d2.format(a.getTempFactor()));
  atomSite.setAuth_seq_id(Integer.toString(g.getResidueNumber().getSeqNum()));
  atomSite.setAuth_comp_id(g.getPDBName());
  atomSite.setAuth_asym_id(chainId);
  atomSite.setAuth_atom_id(a.getName());
  atomSite.setPdbx_PDB_model_num(Integer.toString(model));
  return atomSite;
}",0.9974070872947276
16478,"/** 
 * Instantiates a new bio java structure decoder.
 */
public MmtfStructureReader(){
  structure=new StructureImpl();
  modelNumber=0;
  chemicalComponentGroup=new ChemComp();
  allAtoms=new ArrayList<>();
  entityInfoList=new ArrayList<>();
  chainList=new ArrayList<>();
}","/** 
 * Instantiates a new bio java structure decoder.
 */
public MmtfStructureReader(){
  structure=new StructureImpl();
  modelNumber=0;
  allAtoms=new ArrayList<>();
  entityInfoList=new ArrayList<>();
  chainList=new ArrayList<>();
}",0.920388349514563
16479,"@Override public void setEntityInfo(int[] chainIndices,String sequence,String description,String title){
  EntityInfo entityInfo=new EntityInfo();
  entityInfo.setDescription(description);
  entityInfo.setTitle(title);
  List<Chain> chains=new ArrayList<>();
  for (  int index : chainIndices) {
    chains.add(chainList.get(index));
  }
  entityInfo.setChains(chains);
  entityInfoList.add(entityInfo);
}","@Override public void setEntityInfo(int[] chainIndices,String sequence,String description,String type){
  EntityInfo entityInfo=new EntityInfo();
  entityInfo.setDescription(description);
  entityInfo.setType(EntityType.entityTypeFromString(type));
  List<Chain> chains=new ArrayList<>();
  for (  int index : chainIndices) {
    chains.add(chainList.get(index));
  }
  entityInfo.setChains(chains);
  entityInfoList.add(entityInfo);
}",0.9333333333333332
16480,"@Override public void setGroupInfo(String groupName,int groupNumber,char insertionCode,String chemCompType,int atomCount,int bondCount,char singleLetterCode,int sequenceIndexId,int secStructType){
  int polymerType=getGroupTypIndicator(chemCompType);
switch (polymerType) {
case 1:
    AminoAcid aa=new AminoAcidImpl();
  aa.setAminoType(StructureTools.get1LetterCodeAmino(groupName));
group=aa;
break;
case 2:
group=new NucleotideImpl();
break;
default :
group=new HetatomImpl();
}
atomsInGroup=new ArrayList<Atom>();
group.setChemComp(chemicalComponentGroup);
group.setPDBName(groupName);
if (insertionCode == MmtfBean.UNAVAILABLE_CHAR_VALUE) {
group.setResidueNumber(chain.getChainID().trim(),groupNumber,null);
}
 else {
group.setResidueNumber(chain.getChainID().trim(),groupNumber,insertionCode);
}
group.setAtoms(new ArrayList<Atom>(atomCount));
if (polymerType != 0) {
chain.getSeqResGroups().add(group);
}
if (atomCount > 0) {
chain.addGroup(group);
}
MmtfUtils.setSecStructType(group,secStructType);
}","@Override public void setGroupInfo(String groupName,int groupNumber,char insertionCode,String chemCompType,int atomCount,int bondCount,char singleLetterCode,int sequenceIndexId,int secStructType){
  int polymerType=getGroupTypIndicator(chemCompType);
switch (polymerType) {
case 1:
    AminoAcid aa=new AminoAcidImpl();
  aa.setAminoType(StructureTools.get1LetterCodeAmino(groupName));
group=aa;
break;
case 2:
group=new NucleotideImpl();
break;
default :
group=new HetatomImpl();
}
atomsInGroup=new ArrayList<Atom>();
ChemComp chemComp=new ChemComp();
if (singleLetterCode == 'X') {
chemComp.setOne_letter_code(""String_Node_Str"");
}
 else {
chemComp.setOne_letter_code(""String_Node_Str"" + singleLetterCode);
}
group.setChemComp(chemComp);
group.setPDBName(groupName);
if (insertionCode == MmtfBean.UNAVAILABLE_CHAR_VALUE) {
group.setResidueNumber(chain.getChainID().trim(),groupNumber,null);
}
 else {
group.setResidueNumber(chain.getChainID().trim(),groupNumber,insertionCode);
}
group.setAtoms(new ArrayList<Atom>(atomCount));
if (polymerType != 0) {
chain.getSeqResGroups().add(group);
}
if (atomCount > 0) {
chain.addGroup(group);
}
MmtfUtils.setSecStructType(group,secStructType);
}",0.8835304822565969
16481,"/** 
 * Function to pass data from Biojava structure  to another generic output type.Loops through the data  structure and calls all the set functions.
 * @param dataTransferInterface the generic interface that implements all the set methods.
 */
public MmtfStructureWriter(Structure data,StructureAdapterInterface dataTransferInterface){
  this.mmtfDecoderInterface=dataTransferInterface;
  MmtfUtils.fixMicroheterogenity(structure);
  MmtfSummaryDataBean mmtfSummaryDataBean=MmtfUtils.getStructureInfo(structure);
  Map<String,Integer> chainIdToIndexMap=mmtfSummaryDataBean.getChainIdToIndexMap();
  List<Atom> allAtoms=mmtfSummaryDataBean.getAllAtoms();
  int numBonds=mmtfSummaryDataBean.getNumBonds();
  List<Chain> allChains=mmtfSummaryDataBean.getAllChains();
  mmtfDecoderInterface.initStructure(numBonds,allAtoms.size(),MmtfUtils.getNumGroups(structure),allChains.size(),structure.nrModels(),structure.getPDBCode());
  MmtfUtils.calculateDsspSecondaryStructure(structure);
  PDBHeader pdbHeader=structure.getPDBHeader();
  PDBCrystallographicInfo xtalInfo=pdbHeader.getCrystallographicInfo();
  String releaseDate=null;
  mmtfDecoderInterface.setHeaderInfo(pdbHeader.getRfree(),1.0f,pdbHeader.getResolution(),pdbHeader.getTitle(),MmtfUtils.dateToIsoString(pdbHeader.getDepDate()),releaseDate,MmtfUtils.techniquesToStringArray(pdbHeader.getExperimentalTechniques()));
  mmtfDecoderInterface.setXtalInfo(MmtfUtils.getSpaceGroupAsString(xtalInfo.getSpaceGroup()),MmtfUtils.getUnitCellAsArray(xtalInfo));
  storeBioassemblyInformation(chainIdToIndexMap,pdbHeader.getBioAssemblies());
  storeEntityInformation(allChains,structure.getEntityInfos());
  for (int modelIndex=0; modelIndex < structure.nrModels(); modelIndex++) {
    List<Chain> modelChains=structure.getChains(modelIndex);
    mmtfDecoderInterface.setModelInfo(modelIndex,modelChains.size());
    for (int chainInModelIndex=0; chainInModelIndex < modelChains.size(); chainInModelIndex++) {
      Chain chain=modelChains.get(chainInModelIndex);
      List<Group> groups=chain.getAtomGroups();
      List<Group> sequenceGroups=chain.getSeqResGroups();
      mmtfDecoderInterface.setChainInfo(chain.getChainID(),chain.getInternalChainID(),groups.size());
      for (int groupInChainIndex=0; groupInChainIndex < groups.size(); groupInChainIndex++) {
        Group group=groups.get(groupInChainIndex);
        List<Atom> atomsInGroup=MmtfUtils.getAtomsForGroup(group);
        ChemComp chemComp=group.getChemComp();
        Character insCode=group.getResidueNumber().getInsCode();
        if (insCode == null) {
          insCode=MmtfBean.UNAVAILABLE_CHAR_VALUE;
        }
        char singleLetterCode='X';
        if (chemComp.getOne_letter_code().charAt(0) != '?') {
          singleLetterCode=chemComp.getOne_letter_code().charAt(0);
        }
        mmtfDecoderInterface.setGroupInfo(group.getPDBName(),group.getResidueNumber().getSeqNum(),insCode.charValue(),chemComp.getType(),atomsInGroup.size(),MmtfUtils.getNumBondsInGroup(atomsInGroup),singleLetterCode,sequenceGroups.indexOf(group),MmtfUtils.getSecStructType(group));
        for (        Atom atom : atomsInGroup) {
          char altLoc=MmtfBean.UNAVAILABLE_CHAR_VALUE;
          if (atom.getAltLoc() != null) {
            altLoc=atom.getAltLoc().charValue();
          }
          mmtfDecoderInterface.setAtomInfo(atom.getName(),atom.getPDBserial(),altLoc,(float)atom.getX(),(float)atom.getY(),(float)atom.getZ(),atom.getOccupancy(),atom.getTempFactor(),atom.getElement().toString(),atom.getCharge());
          addBonds(atom,atomsInGroup,allAtoms);
        }
      }
    }
  }
  mmtfDecoderInterface.finalizeStructure();
}","/** 
 * Function to pass data from Biojava structure  to another generic output type.Loops through the data  structure and calls all the set functions.
 * @param dataTransferInterface the generic interface that implements all the set methods.
 */
public MmtfStructureWriter(Structure data,StructureAdapterInterface dataTransferInterface){
  this.mmtfDecoderInterface=dataTransferInterface;
  this.structure=data;
  MmtfUtils.fixMicroheterogenity(structure);
  MmtfSummaryDataBean mmtfSummaryDataBean=MmtfUtils.getStructureInfo(structure);
  Map<String,Integer> chainIdToIndexMap=mmtfSummaryDataBean.getChainIdToIndexMap();
  List<Atom> allAtoms=mmtfSummaryDataBean.getAllAtoms();
  int numBonds=mmtfSummaryDataBean.getNumBonds();
  List<Chain> allChains=mmtfSummaryDataBean.getAllChains();
  mmtfDecoderInterface.initStructure(numBonds,allAtoms.size(),MmtfUtils.getNumGroups(structure),allChains.size(),structure.nrModels(),structure.getPDBCode());
  MmtfUtils.calculateDsspSecondaryStructure(structure);
  PDBHeader pdbHeader=structure.getPDBHeader();
  PDBCrystallographicInfo xtalInfo=pdbHeader.getCrystallographicInfo();
  String releaseDate=null;
  mmtfDecoderInterface.setHeaderInfo(pdbHeader.getRfree(),1.0f,pdbHeader.getResolution(),pdbHeader.getTitle(),MmtfUtils.dateToIsoString(pdbHeader.getDepDate()),releaseDate,MmtfUtils.techniquesToStringArray(pdbHeader.getExperimentalTechniques()));
  mmtfDecoderInterface.setXtalInfo(MmtfUtils.getSpaceGroupAsString(xtalInfo.getSpaceGroup()),MmtfUtils.getUnitCellAsArray(xtalInfo));
  storeBioassemblyInformation(chainIdToIndexMap,pdbHeader.getBioAssemblies());
  storeEntityInformation(allChains,structure.getEntityInfos());
  for (int modelIndex=0; modelIndex < structure.nrModels(); modelIndex++) {
    List<Chain> modelChains=structure.getChains(modelIndex);
    mmtfDecoderInterface.setModelInfo(modelIndex,modelChains.size());
    for (int chainInModelIndex=0; chainInModelIndex < modelChains.size(); chainInModelIndex++) {
      Chain chain=modelChains.get(chainInModelIndex);
      List<Group> groups=chain.getAtomGroups();
      List<Group> sequenceGroups=chain.getSeqResGroups();
      mmtfDecoderInterface.setChainInfo(chain.getChainID(),chain.getInternalChainID(),groups.size());
      for (int groupInChainIndex=0; groupInChainIndex < groups.size(); groupInChainIndex++) {
        Group group=groups.get(groupInChainIndex);
        List<Atom> atomsInGroup=MmtfUtils.getAtomsForGroup(group);
        ChemComp chemComp=group.getChemComp();
        Character insCode=group.getResidueNumber().getInsCode();
        if (insCode == null) {
          insCode=MmtfBean.UNAVAILABLE_CHAR_VALUE;
        }
        char singleLetterCode='X';
        if (chemComp.getOne_letter_code().charAt(0) != '?') {
          singleLetterCode=chemComp.getOne_letter_code().charAt(0);
        }
        mmtfDecoderInterface.setGroupInfo(group.getPDBName(),group.getResidueNumber().getSeqNum(),insCode.charValue(),chemComp.getType(),atomsInGroup.size(),MmtfUtils.getNumBondsInGroup(atomsInGroup),singleLetterCode,sequenceGroups.indexOf(group),MmtfUtils.getSecStructType(group));
        for (        Atom atom : atomsInGroup) {
          char altLoc=MmtfBean.UNAVAILABLE_CHAR_VALUE;
          if (atom.getAltLoc() != null) {
            altLoc=atom.getAltLoc().charValue();
          }
          mmtfDecoderInterface.setAtomInfo(atom.getName(),atom.getPDBserial(),altLoc,(float)atom.getX(),(float)atom.getY(),(float)atom.getZ(),atom.getOccupancy(),atom.getTempFactor(),atom.getElement().toString(),atom.getCharge());
          addBonds(atom,atomsInGroup,allAtoms);
        }
      }
    }
  }
  mmtfDecoderInterface.finalizeStructure();
}",0.9968609253446158
16482,"/** 
 * Add the bonds for a given atom.
 * @param atom the atom for which bonds are to be formed
 * @param atomsInGroup the list of atoms in the group
 * @param allAtoms the list of atoms in the whole structure
 */
private void addBonds(Atom atom,List<Atom> atomsInGroup,List<Atom> allAtoms){
  if (atom.getBonds() == null) {
    return;
  }
  for (  Bond bond : atom.getBonds()) {
    Atom other=bond.getOther(atom);
    if (atomsInGroup.indexOf(other) != -1) {
      Integer firstBondIndex=atomsInGroup.indexOf(atom);
      Integer secondBondIndex=atomsInGroup.indexOf(other);
      if (firstBondIndex < secondBondIndex) {
        int bondOrder=bond.getBondOrder();
        mmtfDecoderInterface.setGroupBond(firstBondIndex,secondBondIndex,bondOrder);
      }
    }
 else {
      Integer firstBondIndex=allAtoms.indexOf(atom);
      Integer secondBondIndex=allAtoms.indexOf(other);
      if (firstBondIndex < secondBondIndex) {
        int bondOrder=bond.getBondOrder();
        mmtfDecoderInterface.setInterGroupBond(firstBondIndex,secondBondIndex,bondOrder);
      }
    }
  }
}","/** 
 * Add the bonds for a given atom.
 * @param atom the atom for which bonds are to be formed
 * @param atomsInGroup the list of atoms in the group
 * @param allAtoms the list of atoms in the whole structure
 */
private void addBonds(Atom atom,List<Atom> atomsInGroup,List<Atom> allAtoms){
  if (atom.getBonds() == null) {
    return;
  }
  for (  Bond bond : atom.getBonds()) {
    Atom other=bond.getOther(atom);
    if (atomsInGroup.indexOf(other) != -1) {
      Integer firstBondIndex=atomsInGroup.indexOf(atom);
      Integer secondBondIndex=atomsInGroup.indexOf(other);
      if (firstBondIndex > secondBondIndex) {
        int bondOrder=bond.getBondOrder();
        mmtfDecoderInterface.setGroupBond(firstBondIndex,secondBondIndex,bondOrder);
      }
    }
 else {
      Integer firstBondIndex=allAtoms.indexOf(atom);
      Integer secondBondIndex=allAtoms.indexOf(other);
      if (firstBondIndex < secondBondIndex) {
        int bondOrder=bond.getBondOrder();
        mmtfDecoderInterface.setInterGroupBond(firstBondIndex,secondBondIndex,bondOrder);
      }
    }
  }
}",0.9990749306197964
16483,"public void write(MmtfDecoderInterface decoder){
  this.mmtfDecoderInterface=decoder;
  MmtfUtils.fixMicroheterogenity(structure);
  MmtfUtils.calculateDsspSecondaryStructure(structure);
  Map<String,Integer> chainIdToIndexMap=MmtfUtils.getChainIdToIndexMap(structure);
  List<Chain> allChains=MmtfUtils.getAllChains(structure);
  List<Atom> allAtoms=MmtfUtils.getAllAtoms(structure);
  int numBonds=MmtfUtils.getNumBonds(allAtoms);
  mmtfDecoderInterface.initStructure(numBonds,allAtoms.size(),MmtfUtils.getNumGroups(structure),allChains.size(),structure.nrModels(),structure.getPDBCode());
  PDBHeader pdbHeader=structure.getPDBHeader();
  PDBCrystallographicInfo xtalInfo=pdbHeader.getCrystallographicInfo();
  mmtfDecoderInterface.setHeaderInfo(pdbHeader.getRfree(),1.0f,pdbHeader.getResolution(),pdbHeader.getTitle(),MmtfUtils.dateToIsoString(pdbHeader.getDepDate()),MmtfUtils.techniquesToStringArray(pdbHeader.getExperimentalTechniques()));
  mmtfDecoderInterface.setXtalInfo(MmtfUtils.getSpaceGroupAsString(xtalInfo.getSpaceGroup()),MmtfUtils.getUnitCellAsArray(xtalInfo));
  storeBioassemblyInformation(chainIdToIndexMap,pdbHeader.getBioAssemblies());
  storeEntityInformation(allChains,structure.getEntityInfos());
  for (int modelIndex=0; modelIndex < structure.nrModels(); modelIndex++) {
    List<Chain> modelChains=structure.getChains(modelIndex);
    mmtfDecoderInterface.setModelInfo(modelIndex,modelChains.size());
    for (int chainInModelIndex=0; chainInModelIndex < modelChains.size(); chainInModelIndex++) {
      Chain chain=modelChains.get(chainInModelIndex);
      List<Group> groups=chain.getAtomGroups();
      List<Group> sequenceGroups=chain.getSeqResGroups();
      mmtfDecoderInterface.setChainInfo(chain.getChainID(),chain.getInternalChainID(),groups.size());
      for (int groupInChainIndex=0; groupInChainIndex < groups.size(); groupInChainIndex++) {
        Group group=groups.get(groupInChainIndex);
        List<Atom> atomsInGroup=MmtfUtils.getAtomsForGroup(group);
        ChemComp chemComp=group.getChemComp();
        Character insCode=group.getResidueNumber().getInsCode();
        if (insCode == null) {
          insCode=MmtfBean.UNAVAILABLE_CHAR_VALUE;
        }
        mmtfDecoderInterface.setGroupInfo(group.getPDBName(),group.getResidueNumber().getSeqNum(),insCode.charValue(),chemComp.getPdbx_type(),atomsInGroup.size(),chemComp.getBonds().size(),chemComp.getOne_letter_code().charAt(0),sequenceGroups.indexOf(group));
        for (        Atom atom : atomsInGroup) {
          mmtfDecoderInterface.setAtomInfo(atom.getName(),atom.getPDBserial(),atom.getAltLoc().charValue(),(float)atom.getX(),(float)atom.getY(),(float)atom.getZ(),atom.getOccupancy(),atom.getTempFactor(),atom.getElement().toString(),atom.getCharge());
          addBonds(atom,atomsInGroup,allAtoms);
        }
      }
    }
  }
  mmtfDecoderInterface.finalizeStructure();
}","public void write(MmtfDecoderInterface decoder){
  this.mmtfDecoderInterface=decoder;
  MmtfUtils.fixMicroheterogenity(structure);
  MmtfUtils.calculateDsspSecondaryStructure(structure);
  Map<String,Integer> chainIdToIndexMap=MmtfUtils.getChainIdToIndexMap(structure);
  List<Chain> allChains=MmtfUtils.getAllChains(structure);
  List<Atom> allAtoms=MmtfUtils.getAllAtoms(structure);
  int numBonds=MmtfUtils.getNumBonds(allAtoms);
  mmtfDecoderInterface.initStructure(numBonds,allAtoms.size(),MmtfUtils.getNumGroups(structure),allChains.size(),structure.nrModels(),structure.getPDBCode());
  PDBHeader pdbHeader=structure.getPDBHeader();
  PDBCrystallographicInfo xtalInfo=pdbHeader.getCrystallographicInfo();
  mmtfDecoderInterface.setHeaderInfo(pdbHeader.getRfree(),1.0f,pdbHeader.getResolution(),pdbHeader.getTitle(),MmtfUtils.dateToIsoString(pdbHeader.getDepDate()),MmtfUtils.techniquesToStringArray(pdbHeader.getExperimentalTechniques()));
  mmtfDecoderInterface.setXtalInfo(MmtfUtils.getSpaceGroupAsString(xtalInfo.getSpaceGroup()),MmtfUtils.getUnitCellAsArray(xtalInfo));
  storeBioassemblyInformation(chainIdToIndexMap,pdbHeader.getBioAssemblies());
  storeEntityInformation(allChains,structure.getEntityInfos());
  for (int modelIndex=0; modelIndex < structure.nrModels(); modelIndex++) {
    List<Chain> modelChains=structure.getChains(modelIndex);
    mmtfDecoderInterface.setModelInfo(modelIndex,modelChains.size());
    for (int chainInModelIndex=0; chainInModelIndex < modelChains.size(); chainInModelIndex++) {
      Chain chain=modelChains.get(chainInModelIndex);
      List<Group> groups=chain.getAtomGroups();
      List<Group> sequenceGroups=chain.getSeqResGroups();
      mmtfDecoderInterface.setChainInfo(chain.getChainID(),chain.getInternalChainID(),groups.size());
      for (int groupInChainIndex=0; groupInChainIndex < groups.size(); groupInChainIndex++) {
        Group group=groups.get(groupInChainIndex);
        List<Atom> atomsInGroup=MmtfUtils.getAtomsForGroup(group);
        ChemComp chemComp=group.getChemComp();
        Character insCode=group.getResidueNumber().getInsCode();
        if (insCode == null) {
          insCode=MmtfBean.UNAVAILABLE_CHAR_VALUE;
        }
        mmtfDecoderInterface.setGroupInfo(group.getPDBName(),group.getResidueNumber().getSeqNum(),insCode.charValue(),chemComp.getType(),atomsInGroup.size(),MmtfUtils.getNumBondsInGroup(atomsInGroup),chemComp.getOne_letter_code().charAt(0),sequenceGroups.indexOf(group));
        for (        Atom atom : atomsInGroup) {
          mmtfDecoderInterface.setAtomInfo(atom.getName(),atom.getPDBserial(),atom.getAltLoc().charValue(),(float)atom.getX(),(float)atom.getY(),(float)atom.getZ(),atom.getOccupancy(),atom.getTempFactor(),atom.getElement().toString(),atom.getCharge());
          addBonds(atom,atomsInGroup,allAtoms);
        }
      }
    }
  }
  mmtfDecoderInterface.finalizeStructure();
}",0.989121049905025
16484,"/** 
 * Generate pas the bioassembly information on in the desired form.
 * @param bioJavaStruct the Biojava structure
 * @param header the header
 */
private void storeBioassemblyInformation(Map<String,Integer> chainIdToIndexMap,Map<Integer,BioAssemblyInfo> inputBioAss){
  int bioAssemblyIndex=0;
  for (  Entry<Integer,BioAssemblyInfo> entry : inputBioAss.entrySet()) {
    Map<double[],int[]> transformMap=MmtfUtils.getTransformMap(entry.getValue(),chainIdToIndexMap);
    for (    Entry<double[],int[]> transformEntry : transformMap.entrySet()) {
      mmtfDecoderInterface.setBioAssemblyTrans(bioAssemblyIndex,transformEntry.getValue(),transformEntry.getKey());
    }
  }
}","/** 
 * Generate the bioassembly information on in the desired form.
 * @param bioJavaStruct the Biojava structure
 * @param header the header
 */
private void storeBioassemblyInformation(Map<String,Integer> chainIdToIndexMap,Map<Integer,BioAssemblyInfo> inputBioAss){
  int bioAssemblyIndex=0;
  for (  Entry<Integer,BioAssemblyInfo> entry : inputBioAss.entrySet()) {
    Map<double[],int[]> transformMap=MmtfUtils.getTransformMap(entry.getValue(),chainIdToIndexMap);
    for (    Entry<double[],int[]> transformEntry : transformMap.entrySet()) {
      mmtfDecoderInterface.setBioAssemblyTrans(bioAssemblyIndex,transformEntry.getValue(),transformEntry.getKey());
    }
    bioAssemblyIndex+=1;
  }
}",0.9789702683103698
16485,"/** 
 * Converts an Atom object to an   {@link AtomSite} object.
 * @param a
 * @param model
 * @param chainId
 * @param internalChainId
 * @param atomId the atom id to be written to AtomSite
 * @return
 */
public static AtomSite convertAtomToAtomSite(Atom a,int model,String chainId,String internalChainId,int atomId){
  Group g=a.getGroup();
  String record;
  if (g.getType().equals(GroupType.HETATM)) {
    record=""String_Node_Str"";
  }
 else {
    record=""String_Node_Str"";
  }
  String entityId=""String_Node_Str"";
  String labelSeqId=Integer.toString(g.getResidueNumber().getSeqNum());
  if (g.getChain() != null && g.getChain().getCompound() != null) {
    entityId=Integer.toString(g.getChain().getCompound().getMolId());
    labelSeqId=Integer.toString(g.getChain().getCompound().getAlignedResIndex(g,g.getChain()));
  }
  Character altLoc=a.getAltLoc();
  String altLocStr=altLoc.toString();
  if (altLoc == null || altLoc == ' ') {
    altLocStr=MMCIF_DEFAULT_VALUE;
  }
  Element e=a.getElement();
  String eString=e.toString().toUpperCase();
  if (e.equals(Element.R)) {
    eString=""String_Node_Str"";
  }
  String insCode=MMCIF_MISSING_VALUE;
  if (g.getResidueNumber().getInsCode() != null) {
    insCode=Integer.toString(g.getResidueNumber().getInsCode());
  }
  AtomSite atomSite=new AtomSite();
  atomSite.setGroup_PDB(record);
  atomSite.setId(Integer.toString(atomId));
  atomSite.setType_symbol(eString);
  atomSite.setLabel_atom_id(a.getName());
  atomSite.setLabel_alt_id(altLocStr);
  atomSite.setLabel_comp_id(g.getPDBName());
  atomSite.setLabel_asym_id(internalChainId);
  atomSite.setLabel_entity_id(entityId);
  atomSite.setLabel_seq_id(labelSeqId);
  atomSite.setPdbx_PDB_ins_code(insCode);
  atomSite.setCartn_x(FileConvert.d3.format(a.getX()));
  atomSite.setCartn_y(FileConvert.d3.format(a.getY()));
  atomSite.setCartn_z(FileConvert.d3.format(a.getZ()));
  atomSite.setOccupancy(FileConvert.d2.format(a.getOccupancy()));
  atomSite.setB_iso_or_equiv(FileConvert.d2.format(a.getTempFactor()));
  atomSite.setAuth_seq_id(Integer.toString(g.getResidueNumber().getSeqNum()));
  atomSite.setAuth_comp_id(g.getPDBName());
  atomSite.setAuth_asym_id(chainId);
  atomSite.setAuth_atom_id(a.getName());
  atomSite.setPdbx_PDB_model_num(Integer.toString(model));
  return atomSite;
}","/** 
 * Converts an Atom object to an   {@link AtomSite} object.
 * @param a
 * @param model
 * @param chainId
 * @param internalChainId
 * @param atomId the atom id to be written to AtomSite
 * @return
 */
public static AtomSite convertAtomToAtomSite(Atom a,int model,String chainId,String internalChainId,int atomId){
  Group g=a.getGroup();
  String record;
  if (g.getType().equals(GroupType.HETATM)) {
    record=""String_Node_Str"";
  }
 else {
    record=""String_Node_Str"";
  }
  String entityId=""String_Node_Str"";
  String labelSeqId=Integer.toString(g.getResidueNumber().getSeqNum());
  if (g.getChain() != null && g.getChain().getCompound() != null) {
    entityId=Integer.toString(g.getChain().getCompound().getMolId());
    labelSeqId=Integer.toString(g.getChain().getCompound().getAlignedResIndex(g,g.getChain()));
  }
  Character altLoc=a.getAltLoc();
  String altLocStr=altLoc.toString();
  if (altLoc == null || altLoc == ' ') {
    altLocStr=MMCIF_DEFAULT_VALUE;
  }
  Element e=a.getElement();
  String eString=e.toString().toUpperCase();
  if (e.equals(Element.R)) {
    eString=""String_Node_Str"";
  }
  String insCode=MMCIF_MISSING_VALUE;
  if (g.getResidueNumber().getInsCode() != null) {
    insCode=Character.toString(g.getResidueNumber().getInsCode());
  }
  AtomSite atomSite=new AtomSite();
  atomSite.setGroup_PDB(record);
  atomSite.setId(Integer.toString(atomId));
  atomSite.setType_symbol(eString);
  atomSite.setLabel_atom_id(a.getName());
  atomSite.setLabel_alt_id(altLocStr);
  atomSite.setLabel_comp_id(g.getPDBName());
  atomSite.setLabel_asym_id(internalChainId);
  atomSite.setLabel_entity_id(entityId);
  atomSite.setLabel_seq_id(labelSeqId);
  atomSite.setPdbx_PDB_ins_code(insCode);
  atomSite.setCartn_x(FileConvert.d3.format(a.getX()));
  atomSite.setCartn_y(FileConvert.d3.format(a.getY()));
  atomSite.setCartn_z(FileConvert.d3.format(a.getZ()));
  atomSite.setOccupancy(FileConvert.d2.format(a.getOccupancy()));
  atomSite.setB_iso_or_equiv(FileConvert.d2.format(a.getTempFactor()));
  atomSite.setAuth_seq_id(Integer.toString(g.getResidueNumber().getSeqNum()));
  atomSite.setAuth_comp_id(g.getPDBName());
  atomSite.setAuth_asym_id(chainId);
  atomSite.setAuth_atom_id(a.getName());
  atomSite.setPdbx_PDB_model_num(Integer.toString(model));
  return atomSite;
}",0.9974003466204506
16486,"/** 
 * @param recordName : three-letter name
 * @return true if successful download
 */
private static boolean downloadChemCompRecord(String recordName){
  String localName=getLocalFileName(recordName);
  File newFile;
  try {
    newFile=File.createTempFile(""String_Node_Str"" + recordName,""String_Node_Str"");
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"",System.getProperty(""String_Node_Str""));
    return false;
  }
  String u=SERVER_LOCATION + recordName + ""String_Node_Str"";
  logger.debug(""String_Node_Str"" + u);
  URL url=null;
  try {
    url=new URL(u);
    HttpURLConnection uconn=HTTPConnectionTools.openHttpURLConnection(url);
    try (PrintWriter pw=new PrintWriter(new GZIPOutputStream(new FileOutputStream(newFile)));BufferedReader fileBuffer=new BufferedReader(new InputStreamReader(uconn.getInputStream()))){
      String line;
      while ((line=fileBuffer.readLine()) != null) {
        pw.println(line);
      }
      pw.flush();
      boolean couldRename=newFile.renameTo(new File(localName));
      if (!couldRename) {
        throw new IOException(""String_Node_Str"" + newFile.toString() + ""String_Node_Str""+ localName);
      }
      return true;
    }
   }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + url.toString() + ""String_Node_Str""+ localName+ ""String_Node_Str""+ e.getMessage());
    newFile.delete();
  }
  return false;
}","/** 
 * @param recordName : three-letter name
 * @return true if successful download
 */
private static boolean downloadChemCompRecord(String recordName){
  String localName=getLocalFileName(recordName);
  File newFile;
  try {
    newFile=File.createTempFile(""String_Node_Str"" + recordName,""String_Node_Str"");
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"",System.getProperty(""String_Node_Str""));
    return false;
  }
  String u=SERVER_LOCATION + recordName + ""String_Node_Str"";
  logger.debug(""String_Node_Str"" + u);
  URL url=null;
  try {
    url=new URL(u);
    HttpURLConnection uconn=HTTPConnectionTools.openHttpURLConnection(url);
    try (PrintWriter pw=new PrintWriter(new GZIPOutputStream(new FileOutputStream(newFile)));BufferedReader fileBuffer=new BufferedReader(new InputStreamReader(uconn.getInputStream()))){
      String line;
      while ((line=fileBuffer.readLine()) != null) {
        pw.println(line);
      }
      pw.flush();
    }
     Files.move(newFile.toPath(),Paths.get(localName),StandardCopyOption.REPLACE_EXISTING);
    return true;
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + url.toString() + ""String_Node_Str""+ localName+ ""String_Node_Str""+ e.getMessage());
    newFile.delete();
  }
  return false;
}",0.8674157303370786
16487,"/** 
 * StructureName wraps another StructureIdentifier. The type of the base identifier depends on the   {@link #getSource() source}. Most StructureName methods deligate to the base identifier. <p>It is possible that future versions of StructureName might change the return type. Except for some specialized uses, it is probably better to create the correct type of identifier directly, rather than creating a StructureName and casting the result of this method.
 * @return A Str
 * @throws StructureException Wraps exceptions that may be thrown byindividual implementations. For example, a SCOP identifier may require that the domain definitions be available for download.
 */
public StructureIdentifier getBaseIdentifier() throws StructureException {
  if (base == null) {
switch (mySource) {
case CATH:
      base=CathFactory.getCathDatabase().getDescriptionByCathId(getIdentifier());
    break;
case ECOD:
  try {
    base=EcodFactory.getEcodDatabase().getDomainsById(name);
  }
 catch (  IOException e) {
    throw new StructureException(""String_Node_Str"" + name,e);
  }
break;
case SCOP:
base=guessScopDomain(getIdentifier(),ScopFactory.getSCOP());
if (base == null) {
if (chainId.equals(""String_Node_Str"")) {
base=new SubstructureIdentifier(pdbId);
}
 else {
base=new SubstructureIdentifier(pdbId,ResidueRange.parseMultiple(chainId));
}
logger.error(""String_Node_Str"",name,base);
}
break;
case FILE:
try {
String[] prefix=name.split(""String_Node_Str"",2);
String filename;
if (prefix.length > 1) {
filename=prefix[1];
}
 else {
filename=name;
}
filename=FileDownloadUtils.expandUserHome(filename);
base=new URLIdentifier(new File(filename).toURI().toURL());
}
 catch (MalformedURLException e) {
throw new StructureException(""String_Node_Str"" + name,e);
}
break;
case URL:
try {
base=new URLIdentifier(name);
}
 catch (MalformedURLException e) {
throw new StructureException(""String_Node_Str"" + name,e);
}
break;
case PDP:
try {
PDPProvider provider=new RemotePDPProvider(false);
base=provider.getPDPDomain(name);
}
 catch (IOException e) {
throw new StructureException(""String_Node_Str"" + name,e);
}
break;
case BIO:
base=new BioAssemblyIdentifier(name);
case PDB:
base=new SubstructureIdentifier(getIdentifier());
break;
default :
throw new IllegalStateException(""String_Node_Str"" + mySource);
}
}
return base;
}","/** 
 * StructureName wraps another StructureIdentifier. The type of the base identifier depends on the   {@link #getSource() source}. Most StructureName methods deligate to the base identifier. <p>It is possible that future versions of StructureName might change the return type. Except for some specialized uses, it is probably better to create the correct type of identifier directly, rather than creating a StructureName and casting the result of this method.
 * @return A Str
 * @throws StructureException Wraps exceptions that may be thrown byindividual implementations. For example, a SCOP identifier may require that the domain definitions be available for download.
 */
public StructureIdentifier getBaseIdentifier() throws StructureException {
  if (base == null) {
switch (mySource) {
case CATH:
      base=CathFactory.getCathDatabase().getDescriptionByCathId(getIdentifier());
    break;
case ECOD:
  try {
    base=EcodFactory.getEcodDatabase().getDomainsById(name);
  }
 catch (  IOException e) {
    throw new StructureException(""String_Node_Str"" + name,e);
  }
break;
case SCOP:
base=guessScopDomain(getIdentifier(),ScopFactory.getSCOP());
if (base == null) {
if (chainId.equals(""String_Node_Str"")) {
base=new SubstructureIdentifier(pdbId);
}
 else {
base=new SubstructureIdentifier(pdbId,ResidueRange.parseMultiple(chainId));
}
logger.error(""String_Node_Str"",name,base);
}
break;
case FILE:
try {
String[] prefix=name.split(""String_Node_Str"",2);
String filename;
if (prefix.length > 1) {
filename=prefix[1];
}
 else {
filename=name;
}
filename=FileDownloadUtils.expandUserHome(filename);
base=new URLIdentifier(new File(filename).toURI().toURL());
}
 catch (MalformedURLException e) {
throw new StructureException(""String_Node_Str"" + name,e);
}
break;
case URL:
try {
base=new URLIdentifier(name);
}
 catch (MalformedURLException e) {
throw new StructureException(""String_Node_Str"" + name,e);
}
break;
case PDP:
try {
PDPProvider provider=new RemotePDPProvider(false);
base=provider.getPDPDomain(name);
}
 catch (IOException e) {
throw new StructureException(""String_Node_Str"" + name,e);
}
break;
case BIO:
base=new BioAssemblyIdentifier(name);
break;
case PDB:
base=new SubstructureIdentifier(getIdentifier());
break;
default :
throw new IllegalStateException(""String_Node_Str"" + mySource);
}
}
return base;
}",0.9984936518183776
16488,"/** 
 * Set all the member variables to null.
 */
public void destroy(){
  System.err.println(""String_Node_Str"");
  jmolPanel.removeMouseListener(this);
  jmolPanel.removeMouseMotionListener(this);
  jmolPanel.destroy();
}","/** 
 * Set all the member variables to null.
 */
public void destroy(){
  logger.debug(""String_Node_Str"");
  jmolPanel.removeMouseListener(this);
  jmolPanel.removeMouseMotionListener(this);
  jmolPanel.destroy();
}",0.9315068493150684
16489,"/** 
 * Set a new Structure to visualize in the AlignmentJmol window.
 * @param s
 */
public void setStructure(Structure s){
  if (jmolPanel == null) {
    System.err.println(""String_Node_Str"");
    return;
  }
  setTitle(s.getPDBCode());
  jmolPanel.setStructure(s);
  structure=s;
}","/** 
 * Set a new Structure to visualize in the AlignmentJmol window.
 * @param s
 */
public void setStructure(Structure s){
  if (jmolPanel == null) {
    logger.error(""String_Node_Str"");
    return;
  }
  setTitle(s.getPDBCode());
  jmolPanel.setStructure(s);
  structure=s;
}",0.9466192170818504
16490,"/** 
 * Execute a command String in the current Jmol panel.
 * @param rasmolScript
 */
public void evalString(String rasmolScript){
  if (jmolPanel == null) {
    System.err.println(""String_Node_Str"");
    return;
  }
  jmolPanel.evalString(rasmolScript);
}","/** 
 * Execute a command String in the current Jmol panel.
 * @param rasmolScript
 */
public void evalString(String rasmolScript){
  if (jmolPanel == null) {
    logger.error(""String_Node_Str"");
    return;
  }
  jmolPanel.evalString(rasmolScript);
}",0.9566929133858268
16491,"/** 
 * StructureName wraps another StructureIdentifier. The type of the base identifier depends on the   {@link #getSource() source}. Most StructureName methods deligate to the base identifier. <p>It is possible that future versions of StructureName might change the return type. Except for some specialized uses, it is probably better to create the correct type of identifier directly, rather than creating a StructureName and casting the result of this method.
 * @return A Str
 * @throws StructureException Wraps exceptions that may be thrown byindividual implementations. For example, a SCOP identifier may require that the domain definitions be available for download.
 */
public StructureIdentifier getBaseIdentifier() throws StructureException {
  if (base == null) {
switch (mySource) {
case CATH:
      base=CathFactory.getCathDatabase().getDescriptionByCathId(getIdentifier());
    break;
case ECOD:
  try {
    base=EcodFactory.getEcodDatabase().getDomainsById(name);
  }
 catch (  IOException e) {
    throw new StructureException(""String_Node_Str"" + name,e);
  }
break;
case SCOP:
base=guessScopDomain(getIdentifier(),ScopFactory.getSCOP());
if (base == null) {
if (chainId.equals(""String_Node_Str"")) {
base=new SubstructureIdentifier(pdbId);
}
 else {
base=new SubstructureIdentifier(pdbId,ResidueRange.parseMultiple(chainId));
}
logger.error(""String_Node_Str"",name,base);
}
break;
case FILE:
try {
String[] prefix=name.split(""String_Node_Str"",2);
String filename;
if (prefix.length > 1) {
filename=prefix[1];
}
 else {
filename=name;
}
filename=FileDownloadUtils.expandUserHome(filename);
base=new URLIdentifier(new File(filename).toURI().toURL());
}
 catch (MalformedURLException e) {
throw new StructureException(""String_Node_Str"" + name,e);
}
break;
case URL:
try {
base=new URLIdentifier(name);
}
 catch (MalformedURLException e) {
throw new StructureException(""String_Node_Str"" + name,e);
}
break;
case PDP:
try {
PDPProvider provider=new RemotePDPProvider(false);
base=provider.getPDPDomain(name);
}
 catch (IOException e) {
throw new StructureException(""String_Node_Str"" + name,e);
}
break;
case BIO:
base=new BioAssemblyIdentifier(name);
case PDB:
base=new SubstructureIdentifier(getIdentifier());
break;
default :
throw new IllegalStateException(""String_Node_Str"" + mySource);
}
}
return base;
}","/** 
 * StructureName wraps another StructureIdentifier. The type of the base identifier depends on the   {@link #getSource() source}. Most StructureName methods deligate to the base identifier. <p>It is possible that future versions of StructureName might change the return type. Except for some specialized uses, it is probably better to create the correct type of identifier directly, rather than creating a StructureName and casting the result of this method.
 * @return A Str
 * @throws StructureException Wraps exceptions that may be thrown byindividual implementations. For example, a SCOP identifier may require that the domain definitions be available for download.
 */
public StructureIdentifier getBaseIdentifier() throws StructureException {
  if (base == null) {
switch (mySource) {
case CATH:
      base=CathFactory.getCathDatabase().getDescriptionByCathId(getIdentifier());
    break;
case ECOD:
  try {
    base=EcodFactory.getEcodDatabase().getDomainsById(name);
  }
 catch (  IOException e) {
    throw new StructureException(""String_Node_Str"" + name,e);
  }
break;
case SCOP:
base=guessScopDomain(getIdentifier(),ScopFactory.getSCOP());
if (base == null) {
if (chainId.equals(""String_Node_Str"")) {
base=new SubstructureIdentifier(pdbId);
}
 else {
base=new SubstructureIdentifier(pdbId,ResidueRange.parseMultiple(chainId));
}
logger.error(""String_Node_Str"",name,base);
}
break;
case FILE:
try {
String[] prefix=name.split(""String_Node_Str"",2);
String filename;
if (prefix.length > 1) {
filename=prefix[1];
}
 else {
filename=name;
}
filename=FileDownloadUtils.expandUserHome(filename);
base=new URLIdentifier(new File(filename).toURI().toURL());
}
 catch (MalformedURLException e) {
throw new StructureException(""String_Node_Str"" + name,e);
}
break;
case URL:
try {
base=new URLIdentifier(name);
}
 catch (MalformedURLException e) {
throw new StructureException(""String_Node_Str"" + name,e);
}
break;
case PDP:
try {
PDPProvider provider=new RemotePDPProvider(false);
base=provider.getPDPDomain(name);
}
 catch (IOException e) {
throw new StructureException(""String_Node_Str"" + name,e);
}
break;
case BIO:
base=new BioAssemblyIdentifier(name);
break;
case PDB:
base=new SubstructureIdentifier(getIdentifier());
break;
default :
throw new IllegalStateException(""String_Node_Str"" + mySource);
}
}
return base;
}",0.9984936518183776
16492,"@Override public List<String> getUserConfigHelp(){
  List<String> params=super.getUserConfigHelp();
  params.add(""String_Node_Str"");
  params.add(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  StringBuilder symmTypes=new StringBuilder(""String_Node_Str"");
  SymmetryType[] vals=SymmetryType.values();
  if (vals.length == 1) {
    symmTypes.append(vals[0].name());
  }
 else   if (vals.length > 1) {
    for (int i=0; i < vals.length - 1; i++) {
      symmTypes.append(vals[i].name());
      symmTypes.append(""String_Node_Str"");
    }
    symmTypes.append(""String_Node_Str"");
    symmTypes.append(vals[vals.length - 1].name());
  }
  params.add(symmTypes.toString());
  StringBuilder orderTypes=new StringBuilder(""String_Node_Str"");
  OrderDetectorMethod[] vals2=OrderDetectorMethod.values();
  if (vals2.length == 1) {
    orderTypes.append(vals2[0].name());
  }
 else   if (vals2.length > 1) {
    for (int i=0; i < vals2.length - 1; i++) {
      orderTypes.append(vals2[i].name());
      orderTypes.append(""String_Node_Str"");
    }
    orderTypes.append(""String_Node_Str"");
    orderTypes.append(vals[vals.length - 1].name());
  }
  params.add(orderTypes.toString());
  StringBuilder refineTypes=new StringBuilder(""String_Node_Str"");
  RefineMethod[] values=RefineMethod.values();
  if (values.length == 1) {
    refineTypes.append(values[0].name());
  }
 else   if (values.length > 1) {
    for (int i=0; i < values.length - 1; i++) {
      refineTypes.append(values[i].name());
      refineTypes.append(""String_Node_Str"");
    }
    refineTypes.append(""String_Node_Str"");
    refineTypes.append(values[values.length - 1].name());
  }
  params.add(refineTypes.toString());
  params.add(""String_Node_Str"");
  params.add(""String_Node_Str"" + ""String_Node_Str"");
  params.add(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  params.add(""String_Node_Str"" + ""String_Node_Str"");
  params.add(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  params.add(""String_Node_Str"" + ""String_Node_Str"");
  params.add(""String_Node_Str"" + ""String_Node_Str"");
  params.add(""String_Node_Str"");
  params.add(""String_Node_Str"" + ""String_Node_Str"");
  return params;
}","@Override public List<String> getUserConfigHelp(){
  List<String> params=super.getUserConfigHelp();
  params.add(""String_Node_Str"");
  params.add(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  StringBuilder symmTypes=new StringBuilder(""String_Node_Str"");
  SymmetryType[] vals=SymmetryType.values();
  if (vals.length == 1) {
    symmTypes.append(vals[0].name());
  }
 else   if (vals.length > 1) {
    for (int i=0; i < vals.length - 1; i++) {
      symmTypes.append(vals[i].name());
      symmTypes.append(""String_Node_Str"");
    }
    symmTypes.append(""String_Node_Str"");
    symmTypes.append(vals[vals.length - 1].name());
  }
  params.add(symmTypes.toString());
  StringBuilder orderTypes=new StringBuilder(""String_Node_Str"");
  OrderDetectorMethod[] vals2=OrderDetectorMethod.values();
  if (vals2.length == 1) {
    orderTypes.append(vals2[0].name());
  }
 else   if (vals2.length > 1) {
    for (int i=0; i < vals2.length - 1; i++) {
      orderTypes.append(vals2[i].name());
      orderTypes.append(""String_Node_Str"");
    }
    orderTypes.append(""String_Node_Str"");
    orderTypes.append(vals[vals.length - 1].name());
  }
  params.add(orderTypes.toString());
  StringBuilder refineTypes=new StringBuilder(""String_Node_Str"");
  RefineMethod[] values=RefineMethod.values();
  if (values.length == 1) {
    refineTypes.append(values[0].name());
  }
 else   if (values.length > 1) {
    for (int i=0; i < values.length - 1; i++) {
      refineTypes.append(values[i].name());
      refineTypes.append(""String_Node_Str"");
    }
    refineTypes.append(""String_Node_Str"");
    refineTypes.append(values[values.length - 1].name());
  }
  params.add(refineTypes.toString());
  params.add(""String_Node_Str"");
  params.add(""String_Node_Str"" + ""String_Node_Str"");
  params.add(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  params.add(""String_Node_Str"" + ""String_Node_Str"");
  params.add(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  params.add(""String_Node_Str"" + ""String_Node_Str"");
  params.add(""String_Node_Str"" + ""String_Node_Str"");
  params.add(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  params.add(""String_Node_Str"" + ""String_Node_Str"");
  return params;
}",0.976774758983348
16493,"/** 
 * Displays a single structure in a cartoon representation with each symmetric repeat colored differently.
 * @param msa the symmetry multiple alignment obtained from CeSymm
 * @throws StructureException
 */
public static AbstractAlignmentJmol display(CeSymmResult symmResult) throws StructureException {
  if (symmResult.isSignificant() && symmResult.isRefined()) {
    MultipleAlignment msa=symmResult.getMultipleAlignment();
    List<Atom[]> atoms=msa.getAtomArrays();
    MultipleAlignmentJmol jmol=new MultipleAlignmentJmol(msa,atoms);
    jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());
    addSymmetryMenu(jmol,symmResult);
    jmol.evalString(printSymmetryGroup(symmResult));
    jmol.evalString(printSymmetryAxes(symmResult,false));
    jmol.setTitle(getSymmTitle(symmResult));
    return jmol;
  }
 else {
    Logger.info(""String_Node_Str"");
    Atom[] cloned=StructureTools.cloneAtomArray(symmResult.getAtoms());
    AbstractAlignmentJmol jmol=StructureAlignmentDisplay.display(symmResult.getSelfAlignment(),symmResult.getAtoms(),cloned);
    RotationAxis axis=new RotationAxis(symmResult.getSelfAlignment());
    jmol.evalString(axis.getJmolScript(symmResult.getAtoms()));
    return jmol;
  }
}","/** 
 * Displays a single structure in a cartoon representation with each symmetric repeat colored differently.
 * @param msa the symmetry multiple alignment obtained from CeSymm
 * @throws StructureException
 */
public static AbstractAlignmentJmol display(CeSymmResult symmResult) throws StructureException {
  if (symmResult.isSignificant() && symmResult.isRefined()) {
    MultipleAlignment msa=symmResult.getMultipleAlignment();
    List<Atom[]> atoms=msa.getAtomArrays();
    MultipleAlignmentJmol jmol=new MultipleAlignmentJmol(msa,atoms);
    jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());
    addSymmetryMenu(jmol,symmResult);
    jmol.evalString(printSymmetryGroup(symmResult));
    jmol.evalString(printSymmetryAxes(symmResult));
    jmol.setTitle(getSymmTitle(symmResult));
    return jmol;
  }
 else {
    logger.info(""String_Node_Str"");
    Atom[] cloned=StructureTools.cloneAtomArray(symmResult.getAtoms());
    AbstractAlignmentJmol jmol=StructureAlignmentDisplay.display(symmResult.getSelfAlignment(),symmResult.getAtoms(),cloned);
    RotationAxis axis=new RotationAxis(symmResult.getSelfAlignment());
    jmol.evalString(axis.getJmolScript(symmResult.getAtoms()));
    return jmol;
  }
}",0.9967293540474244
16494,"/** 
 * Generates a String that displays the symmetry axes of a structure.
 * @param msa
 * @param axes
 * @param elementary only print elementary axes if true
 * @return
 */
public static String printSymmetryAxes(CeSymmResult symm,boolean elementary){
  int id=0;
  String script=""String_Node_Str"";
  Atom[] atoms=symm.getAtoms();
  List<Matrix4d> symmAxes=null;
  if (elementary) {
    symmAxes=symm.getAxes().getElementaryAxes();
  }
 else {
    symmAxes=symm.getAxes().getSymmetryAxes();
  }
  for (  Matrix4d axis : symmAxes) {
    RotationAxis rot=new RotationAxis(axis);
    script+=rot.getJmolScript(atoms,id);
    id++;
  }
  return script;
}","/** 
 * Generates a String that displays the symmetry axes of a structure.
 * @param symm CeSymmResult
 * @return
 * @throws StructureException 
 */
public static String printSymmetryAxes(CeSymmResult symm) throws StructureException {
  int id=0;
  String script=""String_Node_Str"";
  SymmetryAxes axes=symm.getAxes();
  List<Atom[]> repeats=SymmetryTools.toRepeatsAlignment(symm).getAtomArrays();
  List<Matrix4d> symmAxes=axes.getElementaryAxes();
  for (int a=0; a < symmAxes.size(); a++) {
    RotationAxis rot=new RotationAxis(symmAxes.get(a));
    Set<Integer> repIndex=new TreeSet<Integer>(axes.getRepeatRelation(a).get(0));
    repIndex.addAll(axes.getRepeatRelation(a).get(1));
    List<Atom> repAtoms=new ArrayList<Atom>();
    for (    Integer r : repIndex)     repAtoms.addAll(Arrays.asList(repeats.get(r)));
    script+=rot.getJmolScript(repAtoms.toArray(new Atom[repAtoms.size()]),id);
    id++;
  }
  return script;
}",0.4298356510745891
16495,"@Override public void actionPerformed(ActionEvent ae){
  String cmd=ae.getActionCommand();
  if (cmd.equals(""String_Node_Str""))   SymmetryGui.getInstance();
  if (symm == null)   logger.error(""String_Node_Str"");
  try {
    if (cmd.equals(""String_Node_Str"")) {
      MultipleAlignmentJmol j=SymmetryDisplay.displayRepeats(symm);
      String s=SymmetryDisplay.printSymmetryAxes(symm,true);
      j.evalString(s);
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      MultipleAlignmentJmol j=SymmetryDisplay.displayFull(symm);
      String s=SymmetryDisplay.printSymmetryAxes(symm,false);
      j.evalString(s);
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      Atom[] cloned=StructureTools.cloneAtomArray(symm.getAtoms());
      AbstractAlignmentJmol jmol=StructureAlignmentDisplay.display(symm.getSelfAlignment(),symm.getAtoms(),cloned);
      RotationAxis axis=new RotationAxis(symm.getSelfAlignment());
      jmol.evalString(axis.getJmolScript(symm.getAtoms()));
      jmol.setTitle(SymmetryDisplay.getSymmTitle(symm));
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      String script=SymmetryDisplay.printSymmetryGroup(symm);
      jmol.evalString(script);
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      String s=SymmetryDisplay.printSymmetryAxes(symm,false);
      jmol.evalString(s);
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
}","@Override public void actionPerformed(ActionEvent ae){
  String cmd=ae.getActionCommand();
  if (cmd.equals(""String_Node_Str""))   SymmetryGui.getInstance();
  if (symm == null)   logger.error(""String_Node_Str"");
  try {
    if (cmd.equals(""String_Node_Str"")) {
      MultipleAlignmentJmol j=SymmetryDisplay.displayRepeats(symm);
      String s=SymmetryDisplay.printSymmetryAxes(symm);
      j.evalString(s);
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      MultipleAlignmentJmol j=SymmetryDisplay.displayFull(symm);
      String s=SymmetryDisplay.printSymmetryAxes(symm);
      j.evalString(s);
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      Atom[] cloned=StructureTools.cloneAtomArray(symm.getAtoms());
      AbstractAlignmentJmol jmol=StructureAlignmentDisplay.display(symm.getSelfAlignment(),symm.getAtoms(),cloned);
      RotationAxis axis=new RotationAxis(symm.getSelfAlignment());
      jmol.evalString(axis.getJmolScript(symm.getAtoms()));
      jmol.setTitle(SymmetryDisplay.getSymmTitle(symm));
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      String script=SymmetryDisplay.printSymmetryGroup(symm);
      jmol.evalString(script);
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      String s=SymmetryDisplay.printSymmetryAxes(symm);
      jmol.evalString(s);
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
}",0.9939046253137324
16496,"@Override public void clear(){
  super.clear();
  coreLength=-1;
}","@Override public void clear(){
  super.clear();
  coreLength=-1;
  alignResCounts=null;
}",0.8516129032258064
16497,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static void showAlignmentImage(AFPChain afpChain,Atom[] ca1,Atom[] ca2,Object jmol) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {
  Class structureAlignmentJmol=Class.forName(strucAligJmol);
  Class c=Class.forName(displayAFP);
  Method show=c.getMethod(""String_Node_Str"",new Class[]{AFPChain.class,Atom[].class,Atom[].class,structureAlignmentJmol});
  show.invoke(null,afpChain,ca1,ca2,jmol);
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static void showAlignmentImage(AFPChain afpChain,Atom[] ca1,Atom[] ca2,Object jmol) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {
  Class abstractAligJmolC=Class.forName(abstractAligJmol);
  Class c=Class.forName(displayAFP);
  Method show=c.getMethod(""String_Node_Str"",new Class[]{AFPChain.class,Atom[].class,Atom[].class,abstractAligJmolC});
  show.invoke(null,afpChain,ca1,ca2,jmol);
}",0.92725509214355
16498,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static void showAlignmentImage(AFPChain afpChain,Atom[] ca1,Atom[] ca2,Object jmol) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {
  Class structureAlignmentJmol=Class.forName(strucAligJmol);
  Class c=Class.forName(displayAFP);
  Method show=c.getMethod(""String_Node_Str"",new Class[]{AFPChain.class,Atom[].class,Atom[].class,structureAlignmentJmol});
  show.invoke(null,afpChain,ca1,ca2,jmol);
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static void showAlignmentImage(AFPChain afpChain,Atom[] ca1,Atom[] ca2,Object jmol) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {
  Class abstractAligJmolC=Class.forName(abstractAligJmol);
  Class c=Class.forName(displayAFP);
  Method show=c.getMethod(""String_Node_Str"",new Class[]{AFPChain.class,Atom[].class,Atom[].class,abstractAligJmolC});
  show.invoke(null,afpChain,ca1,ca2,jmol);
}",0.92725509214355
16499,"/** 
 * Displays a single structure in a cartoon representation with each symmetric repeat colored differently.
 * @param msa the symmetry multiple alignment obtained from CeSymm
 * @throws StructureException
 */
public static AbstractAlignmentJmol display(CeSymmResult symmResult) throws StructureException {
  if (symmResult.isSignificant() && symmResult.isRefined()) {
    MultipleAlignment msa=symmResult.getMultipleAlignment();
    List<Atom[]> atoms=msa.getAtomArrays();
    MultipleAlignmentJmol jmol=new MultipleAlignmentJmol(msa,atoms);
    jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());
    addSymmetryMenu(jmol,symmResult);
    jmol.evalString(printSymmetryGroup(symmResult));
    jmol.evalString(printSymmetryAxes(symmResult,false));
    jmol.setTitle(getSymmTitle(symmResult));
    return jmol;
  }
 else {
    Logger.info(""String_Node_Str"");
    Atom[] cloned=StructureTools.cloneAtomArray(symmResult.getAtoms());
    AbstractAlignmentJmol jmol=StructureAlignmentDisplay.display(symmResult.getSelfAlignment(),symmResult.getAtoms(),cloned);
    RotationAxis axis=new RotationAxis(symmResult.getSelfAlignment());
    jmol.evalString(axis.getJmolScript(symmResult.getAtoms()));
    jmol.setTitle(getSymmTitle(symmResult));
    return jmol;
  }
}","/** 
 * Displays a single structure in a cartoon representation with each symmetric repeat colored differently.
 * @param msa the symmetry multiple alignment obtained from CeSymm
 * @throws StructureException
 */
public static AbstractAlignmentJmol display(CeSymmResult symmResult) throws StructureException {
  if (symmResult.isSignificant() && symmResult.isRefined()) {
    MultipleAlignment msa=symmResult.getMultipleAlignment();
    List<Atom[]> atoms=msa.getAtomArrays();
    MultipleAlignmentJmol jmol=new MultipleAlignmentJmol(msa,atoms);
    jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());
    addSymmetryMenu(jmol,symmResult);
    jmol.evalString(printSymmetryGroup(symmResult));
    jmol.evalString(printSymmetryAxes(symmResult,false));
    jmol.setTitle(getSymmTitle(symmResult));
    return jmol;
  }
 else {
    Logger.info(""String_Node_Str"");
    Atom[] cloned=StructureTools.cloneAtomArray(symmResult.getAtoms());
    AbstractAlignmentJmol jmol=StructureAlignmentDisplay.display(symmResult.getSelfAlignment(),symmResult.getAtoms(),cloned);
    RotationAxis axis=new RotationAxis(symmResult.getSelfAlignment());
    jmol.evalString(axis.getJmolScript(symmResult.getAtoms()));
    return jmol;
  }
}",0.9763716459751702
16500,"/** 
 * Displays a single structure in a cartoon representation with each symmetric repeat colored differently.
 * @param msa the symmetry multiple alignment obtained from CeSymm
 * @throws StructureException
 */
public static AbstractAlignmentJmol display(CeSymmResult symmResult) throws StructureException {
  if (symmResult.isSignificant() && symmResult.isRefined()) {
    MultipleAlignment msa=symmResult.getMultipleAlignment();
    List<Atom[]> atoms=msa.getAtomArrays();
    MultipleAlignmentJmol jmol=new MultipleAlignmentJmol(msa,atoms);
    jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());
    addSymmetryMenu(jmol,symmResult);
    jmol.evalString(printSymmetryGroup(symmResult));
    jmol.evalString(printSymmetryAxes(symmResult,false));
    jmol.setTitle(getSymmTitle(symmResult));
    return jmol;
  }
 else {
    Logger.info(""String_Node_Str"");
    Atom[] cloned=StructureTools.cloneAtomArray(symmResult.getAtoms());
    AbstractAlignmentJmol jmol=StructureAlignmentDisplay.display(symmResult.getSelfAlignment(),symmResult.getAtoms(),cloned);
    RotationAxis axis=new RotationAxis(symmResult.getSelfAlignment());
    jmol.evalString(axis.getJmolScript(symmResult.getAtoms()));
    jmol.setTitle(getSymmTitle(symmResult));
    return jmol;
  }
}","/** 
 * Displays a single structure in a cartoon representation with each symmetric repeat colored differently.
 * @param msa the symmetry multiple alignment obtained from CeSymm
 * @throws StructureException
 */
public static AbstractAlignmentJmol display(CeSymmResult symmResult) throws StructureException {
  if (symmResult.isSignificant() && symmResult.isRefined()) {
    MultipleAlignment msa=symmResult.getMultipleAlignment();
    List<Atom[]> atoms=msa.getAtomArrays();
    MultipleAlignmentJmol jmol=new MultipleAlignmentJmol(msa,atoms);
    jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());
    addSymmetryMenu(jmol,symmResult);
    jmol.evalString(printSymmetryGroup(symmResult));
    jmol.evalString(printSymmetryAxes(symmResult,false));
    jmol.setTitle(getSymmTitle(symmResult));
    return jmol;
  }
 else {
    Logger.info(""String_Node_Str"");
    Atom[] cloned=StructureTools.cloneAtomArray(symmResult.getAtoms());
    AbstractAlignmentJmol jmol=StructureAlignmentDisplay.display(symmResult.getSelfAlignment(),symmResult.getAtoms(),cloned);
    RotationAxis axis=new RotationAxis(symmResult.getSelfAlignment());
    jmol.evalString(axis.getJmolScript(symmResult.getAtoms()));
    return jmol;
  }
}",0.9763716459751702
16501,"private void formNucleotideBonds(){
  for (  Chain chain : structure.getChains()) {
    List<Group> groups=chain.getSeqResGroups();
    for (int i=0; i < groups.size() - 1; i++) {
      if (!(groups.get(i) instanceof NucleotideImpl) || !(groups.get(i + 1) instanceof NucleotideImpl))       continue;
      NucleotideImpl tail=(NucleotideImpl)groups.get(i);
      NucleotideImpl head=(NucleotideImpl)groups.get(i + 1);
      if (tail.getResidueNumber() == null || head.getResidueNumber() == null) {
        continue;
      }
      Atom phosphorous=tail.getP();
      Atom oThreePrime=head.getO3Prime();
      if (phosphorous == null || oThreePrime == null) {
        continue;
      }
      if (Calc.getDistance(phosphorous,oThreePrime) < MAX_NUCLEOTIDE_BOND_LENGTH) {
        new BondImpl(phosphorous,oThreePrime,1);
      }
    }
  }
}","private void formNucleotideBonds(){
  for (  Chain chain : structure.getChains()) {
    List<Group> groups=chain.getSeqResGroups();
    for (int i=0; i < groups.size() - 1; i++) {
      if (!(groups.get(i) instanceof NucleotideImpl) || !(groups.get(i + 1) instanceof NucleotideImpl))       continue;
      NucleotideImpl tail=(NucleotideImpl)groups.get(i);
      NucleotideImpl head=(NucleotideImpl)groups.get(i + 1);
      if (tail.getResidueNumber() == null || head.getResidueNumber() == null) {
        continue;
      }
      Atom phosphorous=head.getP();
      Atom oThreePrime=tail.getO3Prime();
      if (phosphorous == null || oThreePrime == null) {
        continue;
      }
      if (Calc.getDistance(phosphorous,oThreePrime) < MAX_NUCLEOTIDE_BOND_LENGTH) {
        new BondImpl(phosphorous,oThreePrime,1);
      }
    }
  }
}",0.9904306220095692
16502,"/** 
 * Provides an equivalent copy of Atoms in a new array. Clones everything, starting with parent groups and chains. The chain will only contain groups that are part of the input array.
 * @param ca array of representative atoms, e.g. CA atoms
 * @return Atom array
 * @since Biojava 4.1.0
 */
public static final Atom[] cloneAtomArray(Atom[] ca){
  Atom[] newCA=new Atom[ca.length];
  List<Chain> model=new ArrayList<Chain>();
  int apos=-1;
  for (  Atom a : ca) {
    apos++;
    Group parentG=a.getGroup();
    Chain parentC=parentG.getChain();
    Chain newChain=null;
    for (    Chain c : model) {
      if (c.getChainID().equals(parentC.getChainID())) {
        newChain=c;
        break;
      }
    }
    if (newChain == null) {
      newChain=new ChainImpl();
      newChain.setChainID(parentC.getChainID());
      model.add(newChain);
    }
    Group parentN=(Group)parentG.clone();
    newCA[apos]=parentN.getAtom(a.getName());
    newChain.addGroup(parentN);
  }
  return newCA;
}","/** 
 * Provides an equivalent copy of Atoms in a new array. Clones everything, starting with parent groups and chains. The chain will only contain groups that are part of the input array.
 * @param ca array of representative atoms, e.g. CA atoms
 * @return Atom array
 * @since Biojava 4.1.0
 */
public static final Atom[] cloneAtomArray(Atom[] ca){
  Atom[] newCA=new Atom[ca.length];
  List<Chain> model=new ArrayList<Chain>();
  int apos=-1;
  for (  Atom a : ca) {
    apos++;
    Group parentG=a.getGroup();
    Chain parentC=parentG.getChain();
    Chain newChain=null;
    for (    Chain c : model) {
      if (c.getChainID().equals(parentC.getChainID())) {
        newChain=c;
        break;
      }
    }
    if (newChain == null) {
      newChain=new ChainImpl();
      newChain.setChainID(parentC.getChainID());
      model.add(newChain);
    }
    Group parentN=(Group)parentG.clone();
    newCA[apos]=parentN.getAtom(a.getName());
    try {
      newChain.getGroupByPDB(parentN.getResidueNumber());
    }
 catch (    StructureException e) {
      newChain.addGroup(parentN);
    }
  }
  return newCA;
}",0.9309366130558184
16503,"private void formNucleotideBonds(){
  for (  Chain chain : structure.getChains()) {
    List<Group> groups=chain.getSeqResGroups();
    for (int i=0; i < groups.size() - 1; i++) {
      if (!(groups.get(i) instanceof NucleotideImpl) || !(groups.get(i + 1) instanceof NucleotideImpl))       continue;
      NucleotideImpl tail=(NucleotideImpl)groups.get(i);
      NucleotideImpl head=(NucleotideImpl)groups.get(i + 1);
      if (tail.getResidueNumber() == null || head.getResidueNumber() == null) {
        continue;
      }
      Atom phosphorous=tail.getP();
      Atom oThreePrime=head.getO3Prime();
      if (phosphorous == null || oThreePrime == null) {
        continue;
      }
      if (Calc.getDistance(phosphorous,oThreePrime) < MAX_NUCLEOTIDE_BOND_LENGTH) {
        new BondImpl(phosphorous,oThreePrime,1);
      }
    }
  }
}","private void formNucleotideBonds(){
  for (  Chain chain : structure.getChains()) {
    List<Group> groups=chain.getSeqResGroups();
    for (int i=0; i < groups.size() - 1; i++) {
      if (!(groups.get(i) instanceof NucleotideImpl) || !(groups.get(i + 1) instanceof NucleotideImpl))       continue;
      NucleotideImpl tail=(NucleotideImpl)groups.get(i);
      NucleotideImpl head=(NucleotideImpl)groups.get(i + 1);
      if (tail.getResidueNumber() == null || head.getResidueNumber() == null) {
        continue;
      }
      Atom phosphorous=head.getP();
      Atom oThreePrime=tail.getO3Prime();
      if (phosphorous == null || oThreePrime == null) {
        continue;
      }
      if (Calc.getDistance(phosphorous,oThreePrime) < MAX_NUCLEOTIDE_BOND_LENGTH) {
        new BondImpl(phosphorous,oThreePrime,1);
      }
    }
  }
}",0.9904306220095692
16504,"/** 
 * {@inheritDoc}
 */
@Override public void addGroup(Group group){
  group.setChain(this);
  for (  Group g : group.getAltLocs()) {
    g.setChain(this);
  }
  groups.add(group);
  String pdbResnum=null;
  ResidueNumber resNum=group.getResidueNumber();
  if (resNum != null)   pdbResnum=resNum.toString();
  if (pdbResnum != null) {
    Integer pos=groups.size() - 1;
    if (pdbResnumMap.containsKey(pdbResnum)) {
      if (group instanceof AminoAcid)       pdbResnumMap.put(pdbResnum,pos);
    }
 else     pdbResnumMap.put(pdbResnum,pos);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void addGroup(Group group){
  group.setChain(this);
  for (  Group g : group.getAltLocs()) {
    g.setChain(this);
  }
  groups.add(group);
  String pdbResnum=null;
  ResidueNumber resNum=group.getResidueNumber();
  if (resNum != null)   pdbResnum=resNum.toString();
  if (pdbResnum != null) {
    Integer pos=groups.size() - 1;
    if (pdbResnumMap.containsKey(pdbResnum)) {
      logger.warn(""String_Node_Str"",pdbResnum,group.getPDBName(),getChainID(),groups.get(pdbResnumMap.get(pdbResnum)).getResidueNumber(),groups.get(pdbResnumMap.get(pdbResnum)).getPDBName());
      if (group instanceof AminoAcid)       pdbResnumMap.put(pdbResnum,pos);
    }
 else     pdbResnumMap.put(pdbResnum,pos);
  }
}",0.8513931888544891
16505,"public void formBondsFromStructConn(List<StructConn> structConn){
  final String symop=""String_Node_Str"";
  List<Bond> ssbonds=new ArrayList<>();
  for (  StructConn conn : structConn) {
    if (!BOND_TYPES_TO_PARSE.contains(conn.getConn_type_id()))     continue;
    String chainId1;
    String chainId2;
    if (params.isUseInternalChainId()) {
      chainId1=conn.getPtnr1_label_asym_id();
      chainId2=conn.getPtnr2_label_asym_id();
    }
 else {
      chainId1=conn.getPtnr1_auth_asym_id();
      chainId2=conn.getPtnr2_auth_asym_id();
    }
    String insCode1=""String_Node_Str"";
    if (!conn.getPdbx_ptnr1_PDB_ins_code().equals(""String_Node_Str""))     insCode1=conn.getPdbx_ptnr1_PDB_ins_code();
    String insCode2=""String_Node_Str"";
    if (!conn.getPdbx_ptnr2_PDB_ins_code().equals(""String_Node_Str""))     insCode2=conn.getPdbx_ptnr2_PDB_ins_code();
    String seqId1=conn.getPtnr1_auth_seq_id();
    String seqId2=conn.getPtnr2_auth_seq_id();
    String resName1=conn.getPtnr1_label_comp_id();
    String resName2=conn.getPtnr2_label_comp_id();
    String atomName1=conn.getPtnr1_label_atom_id();
    String atomName2=conn.getPtnr2_label_atom_id();
    String altLoc1=""String_Node_Str"";
    if (!conn.getPdbx_ptnr1_label_alt_id().equals(""String_Node_Str""))     altLoc1=conn.getPdbx_ptnr1_label_alt_id();
    String altLoc2=""String_Node_Str"";
    if (!conn.getPdbx_ptnr2_label_alt_id().equals(""String_Node_Str""))     altLoc2=conn.getPdbx_ptnr2_label_alt_id();
    Atom a1=null;
    Atom a2=null;
    try {
      a1=getAtomFromRecord(atomName1,altLoc1,resName1,chainId1,seqId1,insCode1);
    }
 catch (    StructureException e) {
      String altLocStr1=altLoc1.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + altLoc1 + ""String_Node_Str"";
      logger.warn(""String_Node_Str"",seqId1,insCode1,resName1,chainId1,atomName1,altLocStr1);
      continue;
    }
    try {
      a2=getAtomFromRecord(atomName2,altLoc2,resName2,chainId2,seqId2,insCode2);
    }
 catch (    StructureException e) {
      String altLocStr2=altLoc2.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + altLoc2 + ""String_Node_Str"";
      logger.warn(""String_Node_Str"",seqId2,insCode2,resName2,chainId2,atomName2,altLocStr2);
      continue;
    }
    if (!conn.getPtnr1_symmetry().equals(symop) || !conn.getPtnr2_symmetry().equals(symop)) {
      logger.info(""String_Node_Str"",a1.getPDBserial(),a1.getName(),a2.getPDBserial(),a2.getName());
      continue;
    }
    Bond bond=new BondImpl(a1,a2,1);
    if (conn.getConn_type_id().equals(""String_Node_Str"")) {
      ssbonds.add(bond);
    }
  }
  structure.setSSBonds(ssbonds);
}","public void formBondsFromStructConn(List<StructConn> structConn){
  final String symop=""String_Node_Str"";
  List<Bond> ssbonds=new ArrayList<>();
  for (  StructConn conn : structConn) {
    if (!BOND_TYPES_TO_PARSE.contains(conn.getConn_type_id()))     continue;
    String chainId1;
    String chainId2;
    if (params.isUseInternalChainId()) {
      chainId1=conn.getPtnr1_label_asym_id();
      chainId2=conn.getPtnr2_label_asym_id();
    }
 else {
      chainId1=conn.getPtnr1_auth_asym_id();
      chainId2=conn.getPtnr2_auth_asym_id();
    }
    String insCode1=""String_Node_Str"";
    if (!conn.getPdbx_ptnr1_PDB_ins_code().equals(""String_Node_Str""))     insCode1=conn.getPdbx_ptnr1_PDB_ins_code();
    String insCode2=""String_Node_Str"";
    if (!conn.getPdbx_ptnr2_PDB_ins_code().equals(""String_Node_Str""))     insCode2=conn.getPdbx_ptnr2_PDB_ins_code();
    String seqId1=conn.getPtnr1_auth_seq_id();
    String seqId2=conn.getPtnr2_auth_seq_id();
    String resName1=conn.getPtnr1_label_comp_id();
    String resName2=conn.getPtnr2_label_comp_id();
    String atomName1=conn.getPtnr1_label_atom_id();
    String atomName2=conn.getPtnr2_label_atom_id();
    String altLoc1=""String_Node_Str"";
    if (!conn.getPdbx_ptnr1_label_alt_id().equals(""String_Node_Str""))     altLoc1=conn.getPdbx_ptnr1_label_alt_id();
    String altLoc2=""String_Node_Str"";
    if (!conn.getPdbx_ptnr2_label_alt_id().equals(""String_Node_Str""))     altLoc2=conn.getPdbx_ptnr2_label_alt_id();
    if (!conn.getPtnr1_symmetry().equals(symop) || !conn.getPtnr2_symmetry().equals(symop)) {
      logger.info(""String_Node_Str"",atomName1,seqId1,insCode1,atomName2,seqId2,insCode2);
      continue;
    }
    String altLocStr1=altLoc1.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + altLoc1 + ""String_Node_Str"";
    String altLocStr2=altLoc2.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + altLoc2 + ""String_Node_Str"";
    Atom a1=null;
    Atom a2=null;
    try {
      a1=getAtomFromRecord(atomName1,altLoc1,resName1,chainId1,seqId1,insCode1);
    }
 catch (    StructureException e) {
      logger.warn(""String_Node_Str"",seqId1,insCode1,resName1,chainId1,atomName1,altLocStr1);
      continue;
    }
    try {
      a2=getAtomFromRecord(atomName2,altLoc2,resName2,chainId2,seqId2,insCode2);
    }
 catch (    StructureException e) {
      logger.warn(""String_Node_Str"",seqId2,insCode2,resName2,chainId2,atomName2,altLocStr2);
      continue;
    }
    if (a1 == null) {
      logger.warn(""String_Node_Str"",atomName1,altLocStr1,seqId1,insCode1,resName1,chainId1);
      continue;
    }
    if (a2 == null) {
      logger.warn(""String_Node_Str"",atomName2,altLocStr2,seqId2,insCode2,resName2,chainId2);
      continue;
    }
    Bond bond=new BondImpl(a1,a2,1);
    if (conn.getConn_type_id().equals(""String_Node_Str"")) {
      ssbonds.add(bond);
    }
  }
  structure.setSSBonds(ssbonds);
}",0.7710535909588042
16506,"@Override public void documentEnd(){
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
 else   if (!params.isHeaderOnly()) {
    logger.warn(""String_Node_Str"");
  }
  structure.addModel(current_model);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    asymId2entityId.put(asym.getId(),asym.getEntity_id());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setChainID(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    addCompounds(asym);
  }
  if (structAsyms.isEmpty()) {
    logger.warn(""String_Node_Str"");
  }
  if (params.isAlignSeqRes() && !params.isHeaderOnly()) {
    logger.debug(""String_Node_Str"");
    alignSeqRes();
  }
 else {
    logger.debug(""String_Node_Str"");
    SeqRes2AtomAligner.storeUnAlignedSeqRes(structure,seqResChains,params.isHeaderOnly());
  }
  if (!params.isHeaderOnly()) {
    if (params.shouldCreateAtomBonds()) {
      addBonds();
    }
    if (params.shouldCreateAtomCharges()) {
      addCharges();
    }
  }
  if (asymStrandId.isEmpty()) {
    logger.warn(""String_Node_Str"");
    asymStrandId=asymId2StrandIdFromAtomSites;
  }
  if (asymId2StrandIdFromAtomSites.isEmpty()) {
    logger.warn(""String_Node_Str"");
    asymId2StrandIdFromAtomSites=asymStrandId;
  }
  if (params.isUseInternalChainId() == false) {
    for (int i=0; i < structure.nrModels(); i++) {
      List<Chain> model=structure.getModel(i);
      List<Chain> pdbChains=new ArrayList<Chain>();
      for (      Chain chain : model) {
        for (        String asym : asymId2StrandIdFromAtomSites.keySet()) {
          if (chain.getChainID().equals(asym)) {
            String newChainId=asymId2StrandIdFromAtomSites.get(asym);
            logger.debug(""String_Node_Str"",asym,chain.getAtomGroups().size(),newChainId);
            chain.setChainID(newChainId);
            chain.setInternalChainID(asym);
            for (            Group g : chain.getAtomGroups()) {
              ResidueNumber resNum=g.getResidueNumber();
              if (resNum != null)               resNum.setChainId(newChainId);
            }
            for (            Group g : chain.getSeqResGroups()) {
              ResidueNumber resNum=g.getResidueNumber();
              if (resNum != null)               resNum.setChainId(newChainId);
            }
            Chain known=isKnownChain(chain.getChainID(),pdbChains);
            if (known == null) {
              pdbChains.add(chain);
            }
 else {
              for (              Group g : chain.getAtomGroups()) {
                known.addGroup(g);
              }
            }
            break;
          }
        }
      }
      structure.setModel(i,pdbChains);
    }
  }
 else {
    for (int i=0; i < structure.nrModels(); i++) {
      List<Chain> model=structure.getModel(i);
      for (      Chain chain : model) {
        for (        String asym : asymId2StrandIdFromAtomSites.keySet()) {
          if (chain.getChainID().equals(asym)) {
            String authChainId=asymId2StrandIdFromAtomSites.get(asym);
            chain.setInternalChainID(authChainId);
            break;
          }
        }
      }
    }
  }
  linkCompounds();
  if (!params.isHeaderOnly()) {
    addSites();
  }
  if (params.isParseBioAssembly()) {
    Map<Integer,BioAssemblyInfo> bioAssemblies=new HashMap<Integer,BioAssemblyInfo>();
    for (    PdbxStructAssembly psa : strucAssemblies) {
      List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
      for (      PdbxStructAssemblyGen psag : strucAssemblyGens) {
        if (psag.getAssembly_id().equals(psa.getId())) {
          psags.add(psag);
        }
      }
      BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
      List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
      int mmSize=0;
      int bioAssemblyId=-1;
      try {
        bioAssemblyId=Integer.parseInt(psa.getId());
      }
 catch (      NumberFormatException e) {
        logger.info(""String_Node_Str"",psa.getId());
      }
      try {
        mmSize=Integer.parseInt(psa.getOligomeric_count());
      }
 catch (      NumberFormatException e) {
        if (bioAssemblyId != -1)         logger.warn(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
 else         logger.info(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
      }
      if (bioAssemblyId != -1) {
        BioAssemblyInfo bioAssembly=new BioAssemblyInfo();
        bioAssembly.setId(bioAssemblyId);
        bioAssembly.setMacromolecularSize(mmSize);
        bioAssembly.setTransforms(transformations);
        bioAssemblies.put(bioAssemblyId,bioAssembly);
      }
    }
    structure.getPDBHeader().setBioAssemblies(bioAssemblies);
  }
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators(ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
  Map<String,List<SeqMisMatch>> misMatchMap=new HashMap<String,List<SeqMisMatch>>();
  for (  StructRefSeqDif sdif : sequenceDifs) {
    SeqMisMatch misMatch=new SeqMisMatchImpl();
    misMatch.setDetails(sdif.getDetails());
    String insCode=sdif.getPdbx_pdb_ins_code();
    if (insCode != null && insCode.equals(""String_Node_Str""))     insCode=null;
    misMatch.setInsCode(insCode);
    misMatch.setOrigGroup(sdif.getDb_mon_id());
    misMatch.setPdbGroup(sdif.getMon_id());
    misMatch.setPdbResNum(sdif.getPdbx_auth_seq_num());
    misMatch.setUniProtId(sdif.getPdbx_seq_db_accession_code());
    misMatch.setSeqNum(sdif.getSeq_num());
    List<SeqMisMatch> mms=misMatchMap.get(sdif.getPdbx_pdb_strand_id());
    if (mms == null) {
      mms=new ArrayList<SeqMisMatch>();
      misMatchMap.put(sdif.getPdbx_pdb_strand_id(),mms);
    }
    mms.add(misMatch);
  }
  for (  String chainId : misMatchMap.keySet()) {
    try {
      Chain c=structure.getChainByPDB(chainId);
      c.setSeqMisMatches(misMatchMap.get(chainId));
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + chainId);
    }
  }
}","@Override public void documentEnd(){
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
 else   if (!params.isHeaderOnly()) {
    logger.warn(""String_Node_Str"");
  }
  structure.addModel(current_model);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    asymId2entityId.put(asym.getId(),asym.getEntity_id());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setChainID(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    addCompounds(asym);
  }
  if (structAsyms.isEmpty()) {
    logger.warn(""String_Node_Str"");
  }
  if (params.isAlignSeqRes() && !params.isHeaderOnly()) {
    logger.debug(""String_Node_Str"");
    alignSeqRes();
  }
 else {
    logger.debug(""String_Node_Str"");
    SeqRes2AtomAligner.storeUnAlignedSeqRes(structure,seqResChains,params.isHeaderOnly());
  }
  if (asymStrandId.isEmpty()) {
    logger.warn(""String_Node_Str"");
    asymStrandId=asymId2StrandIdFromAtomSites;
  }
  if (asymId2StrandIdFromAtomSites.isEmpty()) {
    logger.warn(""String_Node_Str"");
    asymId2StrandIdFromAtomSites=asymStrandId;
  }
  if (params.isUseInternalChainId() == false) {
    for (int i=0; i < structure.nrModels(); i++) {
      List<Chain> model=structure.getModel(i);
      List<Chain> pdbChains=new ArrayList<Chain>();
      for (      Chain chain : model) {
        for (        String asym : asymId2StrandIdFromAtomSites.keySet()) {
          if (chain.getChainID().equals(asym)) {
            String newChainId=asymId2StrandIdFromAtomSites.get(asym);
            logger.debug(""String_Node_Str"",asym,chain.getAtomGroups().size(),newChainId);
            chain.setChainID(newChainId);
            chain.setInternalChainID(asym);
            for (            Group g : chain.getAtomGroups()) {
              ResidueNumber resNum=g.getResidueNumber();
              if (resNum != null)               resNum.setChainId(newChainId);
            }
            for (            Group g : chain.getSeqResGroups()) {
              ResidueNumber resNum=g.getResidueNumber();
              if (resNum != null)               resNum.setChainId(newChainId);
            }
            Chain known=isKnownChain(chain.getChainID(),pdbChains);
            if (known == null) {
              pdbChains.add(chain);
            }
 else {
              for (              Group g : chain.getAtomGroups()) {
                known.addGroup(g);
              }
            }
            break;
          }
        }
      }
      structure.setModel(i,pdbChains);
    }
  }
 else {
    for (int i=0; i < structure.nrModels(); i++) {
      List<Chain> model=structure.getModel(i);
      for (      Chain chain : model) {
        for (        String asym : asymId2StrandIdFromAtomSites.keySet()) {
          if (chain.getChainID().equals(asym)) {
            String authChainId=asymId2StrandIdFromAtomSites.get(asym);
            chain.setInternalChainID(authChainId);
            break;
          }
        }
      }
    }
  }
  if (!params.isHeaderOnly()) {
    if (params.shouldCreateAtomBonds()) {
      addBonds();
    }
    if (params.shouldCreateAtomCharges()) {
      addCharges();
    }
  }
  linkCompounds();
  if (!params.isHeaderOnly()) {
    addSites();
  }
  if (params.isParseBioAssembly()) {
    Map<Integer,BioAssemblyInfo> bioAssemblies=new HashMap<Integer,BioAssemblyInfo>();
    for (    PdbxStructAssembly psa : strucAssemblies) {
      List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
      for (      PdbxStructAssemblyGen psag : strucAssemblyGens) {
        if (psag.getAssembly_id().equals(psa.getId())) {
          psags.add(psag);
        }
      }
      BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
      List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
      int mmSize=0;
      int bioAssemblyId=-1;
      try {
        bioAssemblyId=Integer.parseInt(psa.getId());
      }
 catch (      NumberFormatException e) {
        logger.info(""String_Node_Str"",psa.getId());
      }
      try {
        mmSize=Integer.parseInt(psa.getOligomeric_count());
      }
 catch (      NumberFormatException e) {
        if (bioAssemblyId != -1)         logger.warn(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
 else         logger.info(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
      }
      if (bioAssemblyId != -1) {
        BioAssemblyInfo bioAssembly=new BioAssemblyInfo();
        bioAssembly.setId(bioAssemblyId);
        bioAssembly.setMacromolecularSize(mmSize);
        bioAssembly.setTransforms(transformations);
        bioAssemblies.put(bioAssemblyId,bioAssembly);
      }
    }
    structure.getPDBHeader().setBioAssemblies(bioAssemblies);
  }
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators(ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
  Map<String,List<SeqMisMatch>> misMatchMap=new HashMap<String,List<SeqMisMatch>>();
  for (  StructRefSeqDif sdif : sequenceDifs) {
    SeqMisMatch misMatch=new SeqMisMatchImpl();
    misMatch.setDetails(sdif.getDetails());
    String insCode=sdif.getPdbx_pdb_ins_code();
    if (insCode != null && insCode.equals(""String_Node_Str""))     insCode=null;
    misMatch.setInsCode(insCode);
    misMatch.setOrigGroup(sdif.getDb_mon_id());
    misMatch.setPdbGroup(sdif.getMon_id());
    misMatch.setPdbResNum(sdif.getPdbx_auth_seq_num());
    misMatch.setUniProtId(sdif.getPdbx_seq_db_accession_code());
    misMatch.setSeqNum(sdif.getSeq_num());
    List<SeqMisMatch> mms=misMatchMap.get(sdif.getPdbx_pdb_strand_id());
    if (mms == null) {
      mms=new ArrayList<SeqMisMatch>();
      misMatchMap.put(sdif.getPdbx_pdb_strand_id(),mms);
    }
    mms.add(misMatch);
  }
  for (  String chainId : misMatchMap.keySet()) {
    try {
      Chain c=structure.getChainByPDB(chainId);
      c.setSeqMisMatches(misMatchMap.get(chainId));
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + chainId);
    }
  }
}",0.9739156809220504
16507,"/** 
 * COLUMNS       DATA TYPE          FIELD          DEFINITION ---------------------------------------------------------------- 1 - 6        Record name        ""DBREF "" 8 - 11       IDcode             idCode         ID code of this entry. 13            Character          chainID        Chain identifier. 15 - 18       Integer            seqBegin       Initial sequence number of the PDB sequence segment. 19            AChar              insertBegin    Initial insertion code of the PDB sequence segment. 21 - 24       Integer            seqEnd         Ending sequence number of the PDB sequence segment. 25            AChar              insertEnd      Ending insertion code of the PDB sequence segment. 27 - 32       LString            database       Sequence database name. 34 - 41       LString            dbAccession    Sequence database accession code. 43 - 54      LString            dbIdCode        Sequence database identification code. 56 - 60      Integer            dbseqBegin      Initial sequence number of the database seqment. 61           AChar              idbnsBeg        Insertion code of initial residue of the segment, if PDB is the reference. 63 - 67      Integer            dbseqEnd        Ending sequence number of the database segment. 68           AChar              dbinsEnd        Insertion code of the ending residue of the segment, if PDB is the reference.
 */
private void pdb_DBREF_Handler(String line){
  logger.debug(""String_Node_Str"" + line);
  DBRef dbref=new DBRef();
  String idCode=line.substring(7,11);
  String chainId=line.substring(12,13);
  String seqBegin=line.substring(14,18);
  String insertBegin=line.substring(18,19);
  String seqEnd=line.substring(20,24);
  String insertEnd=line.substring(24,25);
  String database=line.substring(26,32);
  String dbAccession=line.substring(33,41);
  String dbIdCode=line.substring(42,54);
  String dbseqBegin=line.substring(55,60);
  String idbnsBeg=line.substring(60,61);
  String dbseqEnd=line.substring(62,67);
  String dbinsEnd=line.substring(67,68);
  dbref.setIdCode(idCode);
  dbref.setChainId(chainId);
  dbref.setSeqBegin(intFromString(seqBegin));
  dbref.setInsertBegin(insertBegin.charAt(0));
  dbref.setSeqEnd(intFromString(seqEnd));
  dbref.setInsertEnd(insertEnd.charAt(0));
  dbref.setDatabase(database.trim());
  dbref.setDbAccession(dbAccession.trim());
  dbref.setDbIdCode(dbIdCode.trim());
  dbref.setDbSeqBegin(intFromString(dbseqBegin));
  dbref.setIdbnsBegin(idbnsBeg.charAt(0));
  dbref.setDbSeqEnd(intFromString(dbseqEnd));
  dbref.setIdbnsEnd(dbinsEnd.charAt(0));
  dbrefs.add(dbref);
}","/** 
 * COLUMNS       DATA TYPE          FIELD          DEFINITION ---------------------------------------------------------------- 1 - 6        Record name        ""DBREF "" 8 - 11       IDcode             idCode         ID code of this entry. 13            Character          chainID        Chain identifier. 15 - 18       Integer            seqBegin       Initial sequence number of the PDB sequence segment. 19            AChar              insertBegin    Initial insertion code of the PDB sequence segment. 21 - 24       Integer            seqEnd         Ending sequence number of the PDB sequence segment. 25            AChar              insertEnd      Ending insertion code of the PDB sequence segment. 27 - 32       LString            database       Sequence database name. 34 - 41       LString            dbAccession    Sequence database accession code. 43 - 54      LString            dbIdCode        Sequence database identification code. 56 - 60      Integer            dbseqBegin      Initial sequence number of the database seqment. 61           AChar              idbnsBeg        Insertion code of initial residue of the segment, if PDB is the reference. 63 - 67      Integer            dbseqEnd        Ending sequence number of the database segment. 68           AChar              dbinsEnd        Insertion code of the ending residue of the segment, if PDB is the reference.
 */
private void pdb_DBREF_Handler(String line){
  logger.debug(""String_Node_Str"" + line);
  DBRef dbref=new DBRef();
  String idCode=line.substring(7,11);
  String chainId=line.substring(12,13);
  String seqBegin=line.substring(14,18);
  String insertBegin=line.substring(18,19);
  String seqEnd=line.substring(20,24);
  String insertEnd=line.substring(24,25);
  String database=line.substring(26,32);
  String dbAccession=line.substring(33,41);
  String dbIdCode=line.substring(42,54);
  String dbseqBegin=line.substring(55,60);
  String idbnsBeg=line.substring(60,61);
  String dbseqEnd=line.substring(62,67);
  String dbinsEnd;
  if (line.length() >= 68)   dbinsEnd=line.substring(67,68);
 else   dbinsEnd=""String_Node_Str"";
  dbref.setIdCode(idCode);
  dbref.setChainId(chainId);
  dbref.setSeqBegin(intFromString(seqBegin));
  dbref.setInsertBegin(insertBegin.charAt(0));
  dbref.setSeqEnd(intFromString(seqEnd));
  dbref.setInsertEnd(insertEnd.charAt(0));
  dbref.setDatabase(database.trim());
  dbref.setDbAccession(dbAccession.trim());
  dbref.setDbIdCode(dbIdCode.trim());
  dbref.setDbSeqBegin(intFromString(dbseqBegin));
  dbref.setIdbnsBegin(idbnsBeg.charAt(0));
  dbref.setDbSeqEnd(intFromString(dbseqEnd));
  dbref.setIdbnsEnd(dbinsEnd.charAt(0));
  dbrefs.add(dbref);
}",0.9857927637810192
16508,"@Test public void testShortLine() throws IOException, StructureException {
  String shortLine=""String_Node_Str"";
  InputStream is=new ByteArrayInputStream(shortLine.getBytes());
  PDBFileParser pdbPars=new PDBFileParser();
  Structure s;
  try {
    s=pdbPars.parsePDBFile(is);
  }
 catch (  Exception e) {
    is.close();
    throw new AssertionError(""String_Node_Str"");
  }
  is=new ByteArrayInputStream(String.format(""String_Node_Str"",shortLine).getBytes());
  Structure ref=pdbPars.parsePDBFile(is);
  is.close();
  assertEquals(ref.getDBRefs().get(0),s.getDBRefs().get(0));
}","@Test public void testShortLine() throws IOException, StructureException {
  Structure s, ref;
  PDBFileParser pdbPars=new PDBFileParser();
  String shortLine=""String_Node_Str"";
  try (InputStream is=new ByteArrayInputStream(shortLine.getBytes())){
    s=pdbPars.parsePDBFile(is);
  }
   String longline=String.format(""String_Node_Str"",shortLine);
  try (InputStream is=new ByteArrayInputStream(longline.getBytes())){
    ref=pdbPars.parsePDBFile(is);
  }
   assertEquals(ref.getDBRefs().get(0),s.getDBRefs().get(0));
}",0.5241128298453139
16509,"@Test public void testToPdbLength() throws IOException {
  String shortLine=""String_Node_Str"";
  InputStream is=new ByteArrayInputStream(shortLine.getBytes());
  PDBFileParser pdbPars=new PDBFileParser();
  Structure s;
  try {
    s=pdbPars.parsePDBFile(is);
  }
 catch (  Exception e) {
    is.close();
    throw new AssertionError(""String_Node_Str"");
  }
  assertEquals(shortLine,s.getDBRefs().get(0).toPDB().trim());
  assertEquals(80,s.getDBRefs().get(0).toPDB().length());
}","@Test public void testToPdbLength() throws IOException {
  Structure s;
  String shortLine=""String_Node_Str"";
  PDBFileParser pdbPars=new PDBFileParser();
  try (InputStream is=new ByteArrayInputStream(shortLine.getBytes())){
    s=pdbPars.parsePDBFile(is);
  }
   assertEquals(shortLine,s.getDBRefs().get(0).toPDB().trim());
  assertEquals(80,s.getDBRefs().get(0).toPDB().length());
}",0.6890173410404624
16510,"/** 
 * Factory method which constructs a pairwise sequence aligner.
 * @param < S > each {@link Sequence} of an alignment pair is of type S
 * @param < C > each element of an {@link AlignedSequence} is a {@link Compound} of type C
 * @param query the first {@link Sequence} to align
 * @param target the second {@link Sequence} to align
 * @param type chosen type from list of pairwise sequence alignment routines
 * @param gapPenalty the gap penalties used during alignment
 * @param subMatrix the set of substitution scores used during alignment
 * @return pairwise sequence aligner
 */
public static <S extends Sequence<C>,C extends Compound>PairwiseSequenceAligner<S,C> getPairwiseAligner(S query,S target,PairwiseSequenceAlignerType type,GapPenalty gapPenalty,SubstitutionMatrix<C> subMatrix){
  if (!query.getCompoundSet().equals(target.getCompoundSet())) {
    System.err.println(query.getCompoundSet().getClass().getName() + ""String_Node_Str"" + target.getCompoundSet().getClass().getName());
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (type) {
default :
case GLOBAL:
    return new NeedlemanWunsch<S,C>(query,target,gapPenalty,subMatrix);
case LOCAL:
  return new SmithWaterman<S,C>(query,target,gapPenalty,subMatrix);
case GLOBAL_LINEAR_SPACE:
case LOCAL_LINEAR_SPACE:
throw new UnsupportedOperationException(Alignments.class.getSimpleName() + ""String_Node_Str"" + type+ ""String_Node_Str"");
}
}","/** 
 * Factory method which constructs a pairwise sequence aligner.
 * @param < S > each {@link Sequence} of an alignment pair is of type S
 * @param < C > each element of an {@link AlignedSequence} is a {@link Compound} of type C
 * @param query the first {@link Sequence} to align
 * @param target the second {@link Sequence} to align
 * @param type chosen type from list of pairwise sequence alignment routines
 * @param gapPenalty the gap penalties used during alignment
 * @param subMatrix the set of substitution scores used during alignment
 * @return pairwise sequence aligner
 */
public static <S extends Sequence<C>,C extends Compound>PairwiseSequenceAligner<S,C> getPairwiseAligner(S query,S target,PairwiseSequenceAlignerType type,GapPenalty gapPenalty,SubstitutionMatrix<C> subMatrix){
  if (!query.getCompoundSet().equals(target.getCompoundSet())) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (type) {
default :
case GLOBAL:
    return new NeedlemanWunsch<S,C>(query,target,gapPenalty,subMatrix);
case LOCAL:
  return new SmithWaterman<S,C>(query,target,gapPenalty,subMatrix);
case GLOBAL_LINEAR_SPACE:
case LOCAL_LINEAR_SPACE:
throw new UnsupportedOperationException(Alignments.class.getSimpleName() + ""String_Node_Str"" + type+ ""String_Node_Str"");
}
}",0.9500734214390602
16511,"private void testSingleChain(Chain cPdb,Chain cCif){
  assertNotNull(cPdb);
  assertNotNull(cCif);
  String chainId=cPdb.getChainID();
  assertEquals(""String_Node_Str"",cPdb.getChainID(),cCif.getChainID());
  assertNotNull(""String_Node_Str"",cCif.getInternalChainID());
  assertTrue(""String_Node_Str"",cCif.getInternalChainID().length() <= 4);
  assertEquals(""String_Node_Str"",1,cPdb.getChainID().length());
  assertEquals(""String_Node_Str"",1,cCif.getChainID().length());
  if (isPolymer(cPdb)) {
    assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getCompound());
    assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cCif.getCompound());
    int molIdPdb=cPdb.getCompound().getMolId();
    int molIdCif=cCif.getCompound().getMolId();
    if (molIdPdb != molIdCif) {
      logger.warn(""String_Node_Str"",pdbId,molIdPdb,molIdCif);
      pdbIdsWithMismatchingMolIds.add(pdbId);
    }
  }
  assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getStructure());
  assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cCif.getStructure());
  assertEquals(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getAtomLength(),cCif.getAtomLength());
  assertEquals(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getSeqResLength(),cCif.getSeqResLength());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups().size(),cCif.getSeqResGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResLength(),cPdb.getSeqResGroups().size());
  assertEquals(""String_Node_Str"",cCif.getSeqResLength(),cCif.getSeqResGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getAtomLength(),cCif.getAtomLength());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups().size(),cCif.getAtomGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getAtomLength(),cPdb.getAtomGroups().size());
  assertEquals(""String_Node_Str"",cCif.getAtomLength(),cCif.getAtomGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups(GroupType.AMINOACID).size(),cCif.getAtomGroups(GroupType.AMINOACID).size());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups(GroupType.HETATM).size(),cCif.getAtomGroups(GroupType.HETATM).size());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups(GroupType.NUCLEOTIDE).size(),cCif.getAtomGroups(GroupType.NUCLEOTIDE).size());
  if (cPdb.getStructure().getPDBCode().equals(""String_Node_Str"") && cPdb.getChainID().equals(""String_Node_Str""))   return;
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups(GroupType.AMINOACID).size(),cCif.getSeqResGroups(GroupType.AMINOACID).size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups(GroupType.HETATM).size(),cCif.getSeqResGroups(GroupType.HETATM).size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups(GroupType.NUCLEOTIDE).size(),cCif.getSeqResGroups(GroupType.NUCLEOTIDE).size());
  assertTrue(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getAtomLength() >= 1);
  if (isPolymer(cPdb)) {
    assertTrue(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getSeqResLength() >= 1);
  }
  int allAtomGroupsSizePdb=cPdb.getAtomGroups(GroupType.AMINOACID).size() + cPdb.getAtomGroups(GroupType.HETATM).size() + cPdb.getAtomGroups(GroupType.NUCLEOTIDE).size();
  int allAtomGroupsSizeCif=cCif.getAtomGroups(GroupType.AMINOACID).size() + cCif.getAtomGroups(GroupType.HETATM).size() + cCif.getAtomGroups(GroupType.NUCLEOTIDE).size();
  assertEquals(""String_Node_Str"",allAtomGroupsSizePdb,allAtomGroupsSizeCif);
  assertEquals(""String_Node_Str"",cPdb.getAtomLength(),allAtomGroupsSizePdb);
  int allSeqResGroupsSizePdb=cPdb.getSeqResGroups(GroupType.AMINOACID).size() + cPdb.getSeqResGroups(GroupType.HETATM).size() + cPdb.getSeqResGroups(GroupType.NUCLEOTIDE).size();
  int allSeqResGroupsSizeCif=cCif.getSeqResGroups(GroupType.AMINOACID).size() + cCif.getSeqResGroups(GroupType.HETATM).size() + cCif.getSeqResGroups(GroupType.NUCLEOTIDE).size();
  assertEquals(""String_Node_Str"",allSeqResGroupsSizePdb,allSeqResGroupsSizeCif);
  assertEquals(""String_Node_Str"",cPdb.getSeqResLength(),allSeqResGroupsSizePdb);
}","private void testSingleChain(Chain cPdb,Chain cCif){
  assertNotNull(cPdb);
  assertNotNull(cCif);
  String chainId=cPdb.getChainID();
  assertEquals(""String_Node_Str"",cPdb.getChainID(),cCif.getChainID());
  assertNotNull(""String_Node_Str"",cCif.getInternalChainID());
  assertTrue(""String_Node_Str"",cCif.getInternalChainID().length() <= 4);
  assertEquals(""String_Node_Str"",1,cPdb.getChainID().length());
  assertEquals(""String_Node_Str"",1,cCif.getChainID().length());
  if (isPolymer(cPdb)) {
    assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getCompound());
    assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cCif.getCompound());
    int molIdPdb=cPdb.getCompound().getMolId();
    int molIdCif=cCif.getCompound().getMolId();
    if (molIdPdb != molIdCif) {
      logger.warn(""String_Node_Str"",pdbId,molIdPdb,molIdCif);
      pdbIdsWithMismatchingMolIds.add(pdbId);
    }
  }
  assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getStructure());
  assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cCif.getStructure());
  assertEquals(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getAtomLength(),cCif.getAtomLength());
  if (cPdb.getAtomSequence().matches(""String_Node_Str""))   return;
  assertEquals(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getSeqResLength(),cCif.getSeqResLength());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups().size(),cCif.getSeqResGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResLength(),cPdb.getSeqResGroups().size());
  assertEquals(""String_Node_Str"",cCif.getSeqResLength(),cCif.getSeqResGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getAtomLength(),cCif.getAtomLength());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups().size(),cCif.getAtomGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getAtomLength(),cPdb.getAtomGroups().size());
  assertEquals(""String_Node_Str"",cCif.getAtomLength(),cCif.getAtomGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups(GroupType.AMINOACID).size(),cCif.getAtomGroups(GroupType.AMINOACID).size());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups(GroupType.HETATM).size(),cCif.getAtomGroups(GroupType.HETATM).size());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups(GroupType.NUCLEOTIDE).size(),cCif.getAtomGroups(GroupType.NUCLEOTIDE).size());
  if (cPdb.getStructure().getPDBCode().equals(""String_Node_Str"") && cPdb.getChainID().equals(""String_Node_Str""))   return;
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups(GroupType.AMINOACID).size(),cCif.getSeqResGroups(GroupType.AMINOACID).size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups(GroupType.HETATM).size(),cCif.getSeqResGroups(GroupType.HETATM).size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups(GroupType.NUCLEOTIDE).size(),cCif.getSeqResGroups(GroupType.NUCLEOTIDE).size());
  assertTrue(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getAtomLength() >= 1);
  if (isPolymer(cPdb)) {
    assertTrue(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getSeqResLength() >= 1);
  }
  int allAtomGroupsSizePdb=cPdb.getAtomGroups(GroupType.AMINOACID).size() + cPdb.getAtomGroups(GroupType.HETATM).size() + cPdb.getAtomGroups(GroupType.NUCLEOTIDE).size();
  int allAtomGroupsSizeCif=cCif.getAtomGroups(GroupType.AMINOACID).size() + cCif.getAtomGroups(GroupType.HETATM).size() + cCif.getAtomGroups(GroupType.NUCLEOTIDE).size();
  assertEquals(""String_Node_Str"",allAtomGroupsSizePdb,allAtomGroupsSizeCif);
  assertEquals(""String_Node_Str"",cPdb.getAtomLength(),allAtomGroupsSizePdb);
  int allSeqResGroupsSizePdb=cPdb.getSeqResGroups(GroupType.AMINOACID).size() + cPdb.getSeqResGroups(GroupType.HETATM).size() + cPdb.getSeqResGroups(GroupType.NUCLEOTIDE).size();
  int allSeqResGroupsSizeCif=cCif.getSeqResGroups(GroupType.AMINOACID).size() + cCif.getSeqResGroups(GroupType.HETATM).size() + cCif.getSeqResGroups(GroupType.NUCLEOTIDE).size();
  assertEquals(""String_Node_Str"",allSeqResGroupsSizePdb,allSeqResGroupsSizeCif);
  assertEquals(""String_Node_Str"",cPdb.getSeqResLength(),allSeqResGroupsSizePdb);
}",0.9917761139069596
16512,"public void test11GS(){
  String pdbID=""String_Node_Str"";
  Structure s;
  try {
    AtomCache cache=new AtomCache();
    cache.getFileParsingParams().setAlignSeqRes(true);
    StructureIO.setAtomCache(cache);
    s=StructureIO.getStructure(pdbID);
    assertNotNull(s);
    assertTrue(s.getChains().size() > 0);
    Chain c=s.getChain(0);
    assertTrue(c.getSeqResGroups().size() > 2);
    Group first=c.getSeqResGroup(0);
    Group second=c.getSeqResGroup(1);
    Group third=c.getSeqResGroup(2);
    assertTrue(first instanceof AminoAcid);
    assertTrue(second instanceof AminoAcid);
    assertTrue(third instanceof AminoAcid);
    AminoAcid aafirst=(AminoAcid)first;
    AminoAcid aasecond=(AminoAcid)second;
    AminoAcid aathird=(AminoAcid)third;
    assertTrue(aafirst.getRecordType().equals(AminoAcid.SEQRESRECORD));
    assertTrue(aasecond.getRecordType().equals(AminoAcid.SEQRESRECORD));
    assertTrue(aathird.getRecordType().equals(AminoAcid.ATOMRECORD));
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}","@Test public void test11GS() throws IOException, StructureException {
  String pdbID=""String_Node_Str"";
  Structure s;
  AtomCache cache=new AtomCache();
  cache.getFileParsingParams().setAlignSeqRes(true);
  StructureIO.setAtomCache(cache);
  s=StructureIO.getStructure(pdbID);
  assertNotNull(s);
  assertTrue(s.getChains().size() > 0);
  Chain c=s.getChain(0);
  assertTrue(c.getSeqResGroups().size() > 2);
  Group first=c.getSeqResGroup(0);
  Group second=c.getSeqResGroup(1);
  Group third=c.getSeqResGroup(2);
  assertTrue(first instanceof AminoAcid);
  assertTrue(second instanceof AminoAcid);
  assertTrue(third instanceof AminoAcid);
  AminoAcid aafirst=(AminoAcid)first;
  AminoAcid aasecond=(AminoAcid)second;
  AminoAcid aathird=(AminoAcid)third;
  assertEquals(AminoAcid.SEQRESRECORD,aafirst.getRecordType());
  assertEquals(AminoAcid.SEQRESRECORD,aasecond.getRecordType());
  assertEquals(AminoAcid.ATOMRECORD,aathird.getRecordType());
}",0.8145563310069791
16513,"/** 
 * Aligns two chains of groups, where the first parent is representing the list of amino acids as obtained from the SEQRES records, and the second parent represents the groups obtained from the ATOM records (and containing the actual ATOM information). This does the actual alignment and if a group can be mapped to a position in the SEQRES then the corresponding position is replaced with the group that contains the atoms.
 * @param seqRes
 * @param atomRes
 * @return true if no match has been found
 */
private boolean alignProteinChains(List<Group> seqRes,List<Group> atomRes){
  Map<Integer,Integer> seqresIndexPosition=new HashMap<Integer,Integer>();
  Map<Integer,Integer> atomIndexPosition=new HashMap<Integer,Integer>();
  String seq1=getFullAtomSequence(seqRes,seqresIndexPosition,false);
  String seq2=getFullAtomSequence(atomRes,atomIndexPosition,false);
  logger.debug(""String_Node_Str"" + seq1.length() + ""String_Node_Str""+ seq1);
  logger.debug(""String_Node_Str"" + seq2.length() + ""String_Node_Str""+ seq2);
  ProteinSequence s1;
  ProteinSequence s2;
  try {
    s1=new ProteinSequence(seq1);
    s2=new ProteinSequence(seq2);
  }
 catch (  CompoundNotFoundException e) {
    logger.warn(""String_Node_Str"",e.getMessage());
    return true;
  }
  SubstitutionMatrix<AminoAcidCompound> matrix=SubstitutionMatrixHelper.getBlosum65();
  GapPenalty penalty=new SimpleGapPenalty(8,1);
  PairwiseSequenceAligner<ProteinSequence,AminoAcidCompound> smithWaterman=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.LOCAL,penalty,matrix);
  SequencePair<ProteinSequence,AminoAcidCompound> pair=smithWaterman.getPair();
  if (pair == null) {
    logger.warn(""String_Node_Str"");
    logger.warn(""String_Node_Str"");
    logger.warn(seq1);
    logger.warn(seq2);
    return true;
  }
  logger.debug(""String_Node_Str"" + pair.toString(100));
  boolean noMatchFound=mapChains(seqRes,atomRes,pair,seqresIndexPosition,atomIndexPosition);
  return noMatchFound;
}","/** 
 * Aligns two chains of groups, where the first parent is representing the list of amino acids as obtained from the SEQRES records, and the second parent represents the groups obtained from the ATOM records (and containing the actual ATOM information). This does the actual alignment and if a group can be mapped to a position in the SEQRES then the corresponding position is replaced with the group that contains the atoms.
 * @param seqRes
 * @param atomRes
 * @return true if no match has been found
 */
private boolean alignProteinChains(List<Group> seqRes,List<Group> atomRes){
  Map<Integer,Integer> seqresIndexPosition=new HashMap<Integer,Integer>();
  Map<Integer,Integer> atomIndexPosition=new HashMap<Integer,Integer>();
  String seq1=getFullAtomSequence(seqRes,seqresIndexPosition,false);
  String seq2=getFullAtomSequence(atomRes,atomIndexPosition,false);
  logger.debug(""String_Node_Str"" + seq1.length() + ""String_Node_Str""+ seq1);
  logger.debug(""String_Node_Str"" + seq2.length() + ""String_Node_Str""+ seq2);
  ProteinSequence s1;
  ProteinSequence s2;
  try {
    s1=new ProteinSequence(seq1);
    s2=new ProteinSequence(seq2);
  }
 catch (  CompoundNotFoundException e) {
    logger.warn(""String_Node_Str"",e.getMessage());
    return true;
  }
  SubstitutionMatrix<AminoAcidCompound> matrix=SubstitutionMatrixHelper.getBlosum65();
  GapPenalty penalty=new SimpleGapPenalty(8,1);
  PairwiseSequenceAligner<ProteinSequence,AminoAcidCompound> smithWaterman=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.LOCAL,penalty,matrix);
  SequencePair<ProteinSequence,AminoAcidCompound> pair=smithWaterman.getPair();
  if (pair == null || pair.getLength() == 0) {
    logger.warn(""String_Node_Str"");
    logger.warn(""String_Node_Str"");
    logger.warn(seq1);
    logger.warn(seq2);
    return true;
  }
  logger.debug(""String_Node_Str"" + pair.toString(100));
  boolean noMatchFound=mapChains(seqRes,atomRes,pair,seqresIndexPosition,atomIndexPosition);
  return noMatchFound;
}",0.9937106918238994
16514,"private Chain getEntityChain(String entity_id){
  return getChainFromList(entityChains,entity_id);
}","private Chain getEntityChain(String entity_id){
  for (  Chain chain : entityChains) {
    if (chain.getChainID().equals(entity_id)) {
      return chain;
    }
  }
  Chain chain=new ChainImpl();
  chain.setChainID(entity_id);
  entityChains.add(chain);
  return chain;
}",0.3504043126684636
16515,"/** 
 * The EntityPolySeq object provide the amino acid sequence objects for the Entities. Later on the entities are mapped to the BioJava Chain and Compound objects.
 * @param epolseq the EntityPolySeq record for one amino acid
 */
@Override public void newEntityPolySeq(EntityPolySeq epolseq){
  logger.debug(""String_Node_Str"" + epolseq);
  int eId=-1;
  try {
    eId=Integer.parseInt(epolseq.getEntity_id());
  }
 catch (  NumberFormatException e) {
    logger.warn(""String_Node_Str"" + e.getMessage());
  }
  Entity e=getEntity(eId);
  if (e == null) {
    logger.info(""String_Node_Str"" + epolseq.getEntity_id() + ""String_Node_Str"");
    return;
  }
  Chain entityChain=getEntityChain(epolseq.getEntity_id());
  if (epolseq.getMon_id().length() == 3 && StructureTools.get1LetterCodeAmino(epolseq.getMon_id()) != null) {
    AminoAcid g=new AminoAcidImpl();
    g.setRecordType(AminoAcid.SEQRESRECORD);
    g.setPDBName(epolseq.getMon_id());
    Character code1=StructureTools.get1LetterCodeAmino(epolseq.getMon_id());
    g.setAminoType(code1);
    g.setResidueNumber(ResidueNumber.fromString(epolseq.getNum()));
    entityChain.addGroup(g);
  }
 else   if (StructureTools.isNucleotide(epolseq.getMon_id())) {
    NucleotideImpl n=new NucleotideImpl();
    n.setResidueNumber(ResidueNumber.fromString(epolseq.getNum()));
    n.setPDBName(epolseq.getMon_id());
    entityChain.addGroup(n);
  }
 else {
    logger.debug(""String_Node_Str"",epolseq.getNum(),epolseq.getMon_id());
    HetatomImpl h=new HetatomImpl();
    h.setPDBName(epolseq.getMon_id());
    h.setResidueNumber(ResidueNumber.fromString(epolseq.getNum()));
    entityChain.addGroup(h);
  }
}","/** 
 * The EntityPolySeq object provide the amino acid sequence objects for the Entities. Later on the entities are mapped to the BioJava Chain and Compound objects.
 * @param epolseq the EntityPolySeq record for one amino acid
 */
@Override public void newEntityPolySeq(EntityPolySeq epolseq){
  logger.debug(""String_Node_Str"" + epolseq);
  int eId=-1;
  try {
    eId=Integer.parseInt(epolseq.getEntity_id());
  }
 catch (  NumberFormatException e) {
    logger.warn(""String_Node_Str"" + e.getMessage());
  }
  Entity e=getEntity(eId);
  if (e == null) {
    logger.info(""String_Node_Str"" + epolseq.getEntity_id() + ""String_Node_Str"");
    return;
  }
  Chain entityChain=getEntityChain(epolseq.getEntity_id());
  Group g=ChemCompGroupFactory.getGroupFromChemCompDictionary(epolseq.getMon_id());
  if (g != null && !g.getChemComp().isEmpty()) {
    if (g instanceof AminoAcidImpl) {
      AminoAcidImpl aa=(AminoAcidImpl)g;
      aa.setRecordType(AminoAcid.SEQRESRECORD);
    }
  }
 else {
    if (epolseq.getMon_id().length() == 3 && StructureTools.get1LetterCodeAmino(epolseq.getMon_id()) != null) {
      AminoAcidImpl a=new AminoAcidImpl();
      a.setRecordType(AminoAcid.SEQRESRECORD);
      Character code1=StructureTools.get1LetterCodeAmino(epolseq.getMon_id());
      a.setAminoType(code1);
      g=a;
    }
 else     if (StructureTools.isNucleotide(epolseq.getMon_id())) {
      NucleotideImpl n=new NucleotideImpl();
      g=n;
    }
 else {
      logger.debug(""String_Node_Str"",epolseq.getNum(),epolseq.getMon_id());
      HetatomImpl h=new HetatomImpl();
      g=h;
    }
  }
  g.setResidueNumber(ResidueNumber.fromString(epolseq.getNum()));
  g.setPDBName(epolseq.getMon_id());
  entityChain.addGroup(g);
}",0.5102101213376738
16516,"private void testSingleChain(Chain cPdb,Chain cCif){
  assertNotNull(cPdb);
  assertNotNull(cCif);
  String chainId=cPdb.getChainID();
  assertEquals(""String_Node_Str"",cPdb.getChainID(),cCif.getChainID());
  assertNotNull(""String_Node_Str"",cCif.getInternalChainID());
  assertTrue(""String_Node_Str"",cCif.getInternalChainID().length() <= 4);
  assertEquals(""String_Node_Str"",1,cPdb.getChainID().length());
  assertEquals(""String_Node_Str"",1,cCif.getChainID().length());
  if (isPolymer(cPdb)) {
    assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getCompound());
    assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cCif.getCompound());
    int molIdPdb=cPdb.getCompound().getMolId();
    int molIdCif=cCif.getCompound().getMolId();
    if (molIdPdb != molIdCif) {
      logger.warn(""String_Node_Str"",pdbId,molIdPdb,molIdCif);
      pdbIdsWithMismatchingMolIds.add(pdbId);
    }
  }
  assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getStructure());
  assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cCif.getStructure());
  assertEquals(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getAtomLength(),cCif.getAtomLength());
  assertEquals(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getSeqResLength(),cCif.getSeqResLength());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups().size(),cCif.getSeqResGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResLength(),cPdb.getSeqResGroups().size());
  assertEquals(""String_Node_Str"",cCif.getSeqResLength(),cCif.getSeqResGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getAtomLength(),cCif.getAtomLength());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups().size(),cCif.getAtomGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getAtomLength(),cPdb.getAtomGroups().size());
  assertEquals(""String_Node_Str"",cCif.getAtomLength(),cCif.getAtomGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups(GroupType.AMINOACID).size(),cCif.getAtomGroups(GroupType.AMINOACID).size());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups(GroupType.HETATM).size(),cCif.getAtomGroups(GroupType.HETATM).size());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups(GroupType.NUCLEOTIDE).size(),cCif.getAtomGroups(GroupType.NUCLEOTIDE).size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups(GroupType.AMINOACID).size(),cCif.getSeqResGroups(GroupType.AMINOACID).size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups(GroupType.HETATM).size(),cCif.getSeqResGroups(GroupType.HETATM).size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups(GroupType.NUCLEOTIDE).size(),cCif.getSeqResGroups(GroupType.NUCLEOTIDE).size());
  assertTrue(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getAtomLength() >= 1);
  if (isPolymer(cPdb)) {
    assertTrue(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getSeqResLength() >= 1);
  }
  int allAtomGroupsSizePdb=cPdb.getAtomGroups(GroupType.AMINOACID).size() + cPdb.getAtomGroups(GroupType.HETATM).size() + cPdb.getAtomGroups(GroupType.NUCLEOTIDE).size();
  int allAtomGroupsSizeCif=cCif.getAtomGroups(GroupType.AMINOACID).size() + cCif.getAtomGroups(GroupType.HETATM).size() + cCif.getAtomGroups(GroupType.NUCLEOTIDE).size();
  assertEquals(""String_Node_Str"",allAtomGroupsSizePdb,allAtomGroupsSizeCif);
  assertEquals(""String_Node_Str"",cPdb.getAtomLength(),allAtomGroupsSizePdb);
  int allSeqResGroupsSizePdb=cPdb.getSeqResGroups(GroupType.AMINOACID).size() + cPdb.getSeqResGroups(GroupType.HETATM).size() + cPdb.getSeqResGroups(GroupType.NUCLEOTIDE).size();
  int allSeqResGroupsSizeCif=cCif.getSeqResGroups(GroupType.AMINOACID).size() + cCif.getSeqResGroups(GroupType.HETATM).size() + cCif.getSeqResGroups(GroupType.NUCLEOTIDE).size();
  assertEquals(""String_Node_Str"",allSeqResGroupsSizePdb,allSeqResGroupsSizeCif);
  assertEquals(""String_Node_Str"",cPdb.getSeqResLength(),allSeqResGroupsSizePdb);
}","private void testSingleChain(Chain cPdb,Chain cCif){
  assertNotNull(cPdb);
  assertNotNull(cCif);
  String chainId=cPdb.getChainID();
  assertEquals(""String_Node_Str"",cPdb.getChainID(),cCif.getChainID());
  assertNotNull(""String_Node_Str"",cCif.getInternalChainID());
  assertTrue(""String_Node_Str"",cCif.getInternalChainID().length() <= 4);
  assertEquals(""String_Node_Str"",1,cPdb.getChainID().length());
  assertEquals(""String_Node_Str"",1,cCif.getChainID().length());
  if (isPolymer(cPdb)) {
    assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getCompound());
    assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cCif.getCompound());
    int molIdPdb=cPdb.getCompound().getMolId();
    int molIdCif=cCif.getCompound().getMolId();
    if (molIdPdb != molIdCif) {
      logger.warn(""String_Node_Str"",pdbId,molIdPdb,molIdCif);
      pdbIdsWithMismatchingMolIds.add(pdbId);
    }
  }
  assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getStructure());
  assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cCif.getStructure());
  assertEquals(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getAtomLength(),cCif.getAtomLength());
  assertEquals(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getSeqResLength(),cCif.getSeqResLength());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups().size(),cCif.getSeqResGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResLength(),cPdb.getSeqResGroups().size());
  assertEquals(""String_Node_Str"",cCif.getSeqResLength(),cCif.getSeqResGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getAtomLength(),cCif.getAtomLength());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups().size(),cCif.getAtomGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getAtomLength(),cPdb.getAtomGroups().size());
  assertEquals(""String_Node_Str"",cCif.getAtomLength(),cCif.getAtomGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups(GroupType.AMINOACID).size(),cCif.getAtomGroups(GroupType.AMINOACID).size());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups(GroupType.HETATM).size(),cCif.getAtomGroups(GroupType.HETATM).size());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups(GroupType.NUCLEOTIDE).size(),cCif.getAtomGroups(GroupType.NUCLEOTIDE).size());
  if (cPdb.getStructure().getPDBCode().equals(""String_Node_Str"") && cPdb.getChainID().equals(""String_Node_Str""))   return;
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups(GroupType.AMINOACID).size(),cCif.getSeqResGroups(GroupType.AMINOACID).size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups(GroupType.HETATM).size(),cCif.getSeqResGroups(GroupType.HETATM).size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups(GroupType.NUCLEOTIDE).size(),cCif.getSeqResGroups(GroupType.NUCLEOTIDE).size());
  assertTrue(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getAtomLength() >= 1);
  if (isPolymer(cPdb)) {
    assertTrue(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getSeqResLength() >= 1);
  }
  int allAtomGroupsSizePdb=cPdb.getAtomGroups(GroupType.AMINOACID).size() + cPdb.getAtomGroups(GroupType.HETATM).size() + cPdb.getAtomGroups(GroupType.NUCLEOTIDE).size();
  int allAtomGroupsSizeCif=cCif.getAtomGroups(GroupType.AMINOACID).size() + cCif.getAtomGroups(GroupType.HETATM).size() + cCif.getAtomGroups(GroupType.NUCLEOTIDE).size();
  assertEquals(""String_Node_Str"",allAtomGroupsSizePdb,allAtomGroupsSizeCif);
  assertEquals(""String_Node_Str"",cPdb.getAtomLength(),allAtomGroupsSizePdb);
  int allSeqResGroupsSizePdb=cPdb.getSeqResGroups(GroupType.AMINOACID).size() + cPdb.getSeqResGroups(GroupType.HETATM).size() + cPdb.getSeqResGroups(GroupType.NUCLEOTIDE).size();
  int allSeqResGroupsSizeCif=cCif.getSeqResGroups(GroupType.AMINOACID).size() + cCif.getSeqResGroups(GroupType.HETATM).size() + cCif.getSeqResGroups(GroupType.NUCLEOTIDE).size();
  assertEquals(""String_Node_Str"",allSeqResGroupsSizePdb,allSeqResGroupsSizeCif);
  assertEquals(""String_Node_Str"",cPdb.getSeqResLength(),allSeqResGroupsSizePdb);
}",0.984541912781199
16517,"private TreeMap<String,Compound> findCompoundsFromAlignment(){
  Set<Integer> polyChainIndices=new TreeSet<Integer>();
  List<Chain> pureNonPolymerChains=new ArrayList<Chain>();
  for (int i=0; i < s.getChains().size(); i++) {
    if (StructureTools.isChainPureNonPolymer(s.getChain(i))) {
      pureNonPolymerChains.add(s.getChain(i));
    }
 else {
      polyChainIndices.add(i);
    }
  }
  TreeMap<String,Compound> chainIds2compounds=new TreeMap<String,Compound>();
  int molId=1;
  outer:   for (  int i : polyChainIndices) {
    for (    int j : polyChainIndices) {
      if (j <= i)       continue;
      Chain c1=s.getChain(i);
      Chain c2=s.getChain(j);
      Map<Integer,Integer> positionIndex1=new HashMap<Integer,Integer>();
      Map<Integer,Integer> positionIndex2=new HashMap<Integer,Integer>();
      String str1=SeqRes2AtomAligner.getFullAtomSequence(c1.getAtomGroups(),positionIndex1);
      String str2=SeqRes2AtomAligner.getFullAtomSequence(c2.getAtomGroups(),positionIndex2);
      int seq1Length=0;
      int seq2Length=0;
      SequencePair<?,?> pair=null;
      if (isProteinSequence(str1) && isProteinSequence(str2)) {
        ProteinSequence s1=getProteinSequence(str1);
        ProteinSequence s2=getProteinSequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignProtein(s1,s2);
      }
 else       if (isDNASequence(str1) && isDNASequence(str2)) {
        DNASequence s1=getDNASequence(str1);
        DNASequence s2=getDNASequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignDNA(s1,s2);
      }
 else       if (isRNASequence(str1) && isRNASequence(str2)) {
        RNASequence s1=getRNASequence(str1);
        RNASequence s2=getRNASequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignRNA(s1,s2);
      }
 else {
        logger.debug(""String_Node_Str"");
        continue;
      }
      int numGaps=getNumGaps(pair);
      int numGaps1=getNumGapsQuery(pair);
      int numGaps2=getNumGapsTarget(pair);
      int nonGaps=pair.getLength() - numGaps;
      double identity=(double)pair.getNumIdenticals() / (double)nonGaps;
      double gapCov1=(double)numGaps1 / (double)seq1Length;
      double gapCov2=(double)numGaps2 / (double)seq2Length;
      logger.debug(""String_Node_Str"",c1.getChainID(),c2.getChainID(),String.format(""String_Node_Str"",identity),String.format(""String_Node_Str"",gapCov1),String.format(""String_Node_Str"",gapCov2));
      logger.debug(""String_Node_Str"" + pair.toString(100));
      if (identity > IDENTITY_THRESHOLD && gapCov1 < GAP_COVERAGE_THRESHOLD && gapCov2 < GAP_COVERAGE_THRESHOLD) {
        if (!chainIds2compounds.containsKey(c1.getChainID()) && !chainIds2compounds.containsKey(c2.getChainID())) {
          logger.debug(""String_Node_Str"",c1.getChainID(),c2.getChainID());
          Compound ent=new Compound();
          ent.addChain(c1);
          ent.addChain(c2);
          ent.setMolId(molId++);
          chainIds2compounds.put(c1.getChainID(),ent);
          chainIds2compounds.put(c2.getChainID(),ent);
        }
 else {
          Compound ent=chainIds2compounds.get(c1.getChainID());
          if (ent == null) {
            logger.debug(""String_Node_Str"",c1.getChainID(),c2.getChainID());
            ent=chainIds2compounds.get(c2.getChainID());
            ent.addChain(c1);
            chainIds2compounds.put(c1.getChainID(),ent);
          }
 else {
            logger.debug(""String_Node_Str"",c2.getChainID(),c1.getChainID());
            ent.addChain(c2);
            chainIds2compounds.put(c2.getChainID(),ent);
          }
        }
        if (!areResNumbersAligned(c1,c2)) {
          logger.warn(""String_Node_Str"",c1.getChainID(),c2.getChainID());
        }
      }
      if (identity > 1) {
        logger.warn(""String_Node_Str"",c1.getChainID(),c2.getChainID(),pair.getNumIdenticals(),nonGaps,identity);
        logger.warn(""String_Node_Str"" + pair.toString(100));
      }
      if (chainIds2compounds.size() == polyChainIndices.size())       break outer;
    }
  }
  for (  int i : polyChainIndices) {
    Chain c=s.getChain(i);
    if (!chainIds2compounds.containsKey(c.getChainID())) {
      logger.debug(""String_Node_Str"",c.getChainID());
      Compound ent=new Compound();
      ent.addChain(c);
      ent.setMolId(molId++);
      chainIds2compounds.put(c.getChainID(),ent);
    }
  }
  return chainIds2compounds;
}","private TreeMap<String,Compound> findCompoundsFromAlignment(){
  Set<Integer> polyChainIndices=new TreeSet<Integer>();
  List<Chain> pureNonPolymerChains=new ArrayList<Chain>();
  for (int i=0; i < s.getChains().size(); i++) {
    if (StructureTools.isChainPureNonPolymer(s.getChain(i))) {
      pureNonPolymerChains.add(s.getChain(i));
    }
 else {
      polyChainIndices.add(i);
    }
  }
  TreeMap<String,Compound> chainIds2compounds=new TreeMap<String,Compound>();
  int molId=1;
  outer:   for (  int i : polyChainIndices) {
    for (    int j : polyChainIndices) {
      if (j <= i)       continue;
      Chain c1=s.getChain(i);
      Chain c2=s.getChain(j);
      Map<Integer,Integer> positionIndex1=new HashMap<Integer,Integer>();
      Map<Integer,Integer> positionIndex2=new HashMap<Integer,Integer>();
      String str1=SeqRes2AtomAligner.getFullAtomSequence(c1.getAtomGroups(),positionIndex1,false);
      String str2=SeqRes2AtomAligner.getFullAtomSequence(c2.getAtomGroups(),positionIndex2,false);
      int seq1Length=0;
      int seq2Length=0;
      SequencePair<?,?> pair=null;
      if (isProteinSequence(str1) && isProteinSequence(str2)) {
        ProteinSequence s1=getProteinSequence(str1);
        ProteinSequence s2=getProteinSequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignProtein(s1,s2);
      }
 else       if (isDNASequence(str1) && isDNASequence(str2)) {
        DNASequence s1=getDNASequence(str1);
        DNASequence s2=getDNASequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignDNA(s1,s2);
      }
 else       if (isRNASequence(str1) && isRNASequence(str2)) {
        RNASequence s1=getRNASequence(str1);
        RNASequence s2=getRNASequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignRNA(s1,s2);
      }
 else {
        logger.debug(""String_Node_Str"");
        continue;
      }
      int numGaps=getNumGaps(pair);
      int numGaps1=getNumGapsQuery(pair);
      int numGaps2=getNumGapsTarget(pair);
      int nonGaps=pair.getLength() - numGaps;
      double identity=(double)pair.getNumIdenticals() / (double)nonGaps;
      double gapCov1=(double)numGaps1 / (double)seq1Length;
      double gapCov2=(double)numGaps2 / (double)seq2Length;
      logger.debug(""String_Node_Str"",c1.getChainID(),c2.getChainID(),String.format(""String_Node_Str"",identity),String.format(""String_Node_Str"",gapCov1),String.format(""String_Node_Str"",gapCov2));
      logger.debug(""String_Node_Str"" + pair.toString(100));
      if (identity > IDENTITY_THRESHOLD && gapCov1 < GAP_COVERAGE_THRESHOLD && gapCov2 < GAP_COVERAGE_THRESHOLD) {
        if (!chainIds2compounds.containsKey(c1.getChainID()) && !chainIds2compounds.containsKey(c2.getChainID())) {
          logger.debug(""String_Node_Str"",c1.getChainID(),c2.getChainID());
          Compound ent=new Compound();
          ent.addChain(c1);
          ent.addChain(c2);
          ent.setMolId(molId++);
          chainIds2compounds.put(c1.getChainID(),ent);
          chainIds2compounds.put(c2.getChainID(),ent);
        }
 else {
          Compound ent=chainIds2compounds.get(c1.getChainID());
          if (ent == null) {
            logger.debug(""String_Node_Str"",c1.getChainID(),c2.getChainID());
            ent=chainIds2compounds.get(c2.getChainID());
            ent.addChain(c1);
            chainIds2compounds.put(c1.getChainID(),ent);
          }
 else {
            logger.debug(""String_Node_Str"",c2.getChainID(),c1.getChainID());
            ent.addChain(c2);
            chainIds2compounds.put(c2.getChainID(),ent);
          }
        }
        if (!areResNumbersAligned(c1,c2)) {
          logger.warn(""String_Node_Str"",c1.getChainID(),c2.getChainID());
        }
      }
      if (identity > 1) {
        logger.warn(""String_Node_Str"",c1.getChainID(),c2.getChainID(),pair.getNumIdenticals(),nonGaps,identity);
        logger.warn(""String_Node_Str"" + pair.toString(100));
      }
      if (chainIds2compounds.size() == polyChainIndices.size())       break outer;
    }
  }
  for (  int i : polyChainIndices) {
    Chain c=s.getChain(i);
    if (!chainIds2compounds.containsKey(c.getChainID())) {
      logger.debug(""String_Node_Str"",c.getChainID());
      Compound ent=new Compound();
      ent.addChain(c);
      ent.setMolId(molId++);
      chainIds2compounds.put(c.getChainID(),ent);
    }
  }
  return chainIds2compounds;
}",0.998652896273013
16518,"private boolean mapChains(List<Group> seqResGroups,List<Group> atomRes,SequencePair<ProteinSequence,AminoAcidCompound> pair,Map<Integer,Integer> seqresIndexPosition,Map<Integer,Integer> atomIndexPosition){
  int aligLength=pair.getLength();
  boolean noMatchFound=true;
  Compound gapSymbol=AminoAcidCompoundSet.getAminoAcidCompoundSet().getCompoundForString(""String_Node_Str"");
  mainLoop:   for (int i=1; i <= aligLength; i++) {
    Compound s=pair.getCompoundAt(1,i);
    Compound a=pair.getCompoundAt(2,i);
    int posSeq=pair.getIndexInQueryAt(i) - 1;
    int posAtom=pair.getIndexInTargetAt(i) - 1;
    if (s.equals(gapSymbol) || a.equals(gapSymbol)) {
      continue;
    }
    if (s.equals(a)) {
      Group s1=seqResGroups.get(seqresIndexPosition.get(posSeq));
      Group a1=atomRes.get(atomIndexPosition.get(posAtom));
      if (s1 == null || a1 == null) {
        logger.warn(""String_Node_Str"" + i + ""String_Node_Str""+ s+ ""String_Node_Str""+ posSeq+ ""String_Node_Str""+ s1+ ""String_Node_Str""+ posAtom+ ""String_Node_Str""+ a1);
        continue mainLoop;
      }
      String pdbNameS=s1.getPDBName();
      String pdbNameA=a1.getPDBName();
      if (pdbNameS == null || pdbNameA == null) {
        logger.warn(""String_Node_Str"",posSeq,s1,a1,posAtom);
        logger.warn(""String_Node_Str"");
        return true;
      }
      if (!pdbNameA.equals(pdbNameS)) {
        if (!pdbNameA.trim().equals(pdbNameS.trim())) {
          logger.info(s1 + ""String_Node_Str"" + posSeq+ ""String_Node_Str""+ a1+ ""String_Node_Str""+ posAtom+ ""String_Node_Str""+ s+ ""String_Node_Str""+ a);
          if (s1.getType().equals(HetatomImpl.type) && a1.getType().equals(HetatomImpl.type)) {
            logger.info(""String_Node_Str"");
          }
 else {
            logger.warn(""String_Node_Str"",s1,a1);
          }
        }
      }
      seqResGroups.set(seqresIndexPosition.get(posSeq),a1);
      noMatchFound=false;
    }
  }
  if (noMatchFound) {
    logger.debug(""String_Node_Str"");
  }
  return noMatchFound;
}","private boolean mapChains(List<Group> seqResGroups,List<Group> atomRes,SequencePair<ProteinSequence,AminoAcidCompound> pair,Map<Integer,Integer> seqresIndexPosition,Map<Integer,Integer> atomIndexPosition){
  int aligLength=pair.getLength();
  boolean noMatchFound=true;
  Compound gapSymbol=AminoAcidCompoundSet.getAminoAcidCompoundSet().getCompoundForString(""String_Node_Str"");
  mainLoop:   for (int i=1; i <= aligLength; i++) {
    Compound s=pair.getCompoundAt(1,i);
    Compound a=pair.getCompoundAt(2,i);
    int posSeq=pair.getIndexInQueryAt(i) - 1;
    int posAtom=pair.getIndexInTargetAt(i) - 1;
    if (s.equals(gapSymbol) || a.equals(gapSymbol)) {
      continue;
    }
    if (s.equals(a)) {
      Group s1=seqResGroups.get(seqresIndexPosition.get(posSeq));
      Group a1=atomRes.get(atomIndexPosition.get(posAtom));
      if (s1 == null || a1 == null) {
        logger.warn(""String_Node_Str"" + i + ""String_Node_Str""+ s+ ""String_Node_Str""+ posSeq+ ""String_Node_Str""+ s1+ ""String_Node_Str""+ posAtom+ ""String_Node_Str""+ a1);
        continue mainLoop;
      }
      String pdbNameS=s1.getPDBName();
      String pdbNameA=a1.getPDBName();
      if (pdbNameS == null || pdbNameA == null) {
        logger.warn(""String_Node_Str"",posSeq,s1,a1,posAtom);
        logger.warn(""String_Node_Str"");
        return true;
      }
      if (!pdbNameA.trim().equals(pdbNameS.trim())) {
        String msg=""String_Node_Str"" + s1 + ""String_Node_Str""+ posSeq+ ""String_Node_Str""+ a1+ ""String_Node_Str""+ posAtom+ ""String_Node_Str""+ s+ ""String_Node_Str""+ a;
        if (s1.getType().equals(HetatomImpl.type) && a1.getType().equals(HetatomImpl.type)) {
          logger.info(msg + ""String_Node_Str"");
        }
 else {
          logger.warn(msg + ""String_Node_Str"");
        }
      }
      seqResGroups.set(seqresIndexPosition.get(posSeq),a1);
      noMatchFound=false;
    }
  }
  if (noMatchFound) {
    logger.debug(""String_Node_Str"");
  }
  return noMatchFound;
}",0.8774323982815264
16519,"/** 
 * Aligns two chains of groups, where the first parent is representing the list of amino acids as obtained from the SEQRES records, and the second parent represents the groups obtained from the ATOM records (and containing the actual ATOM information). This does the actual alignment and if a group can be mapped to a position in the SEQRES then the corresponding position is replaced with the group that contains the atoms.
 * @param seqRes
 * @param atomRes
 * @return true if no match has been found
 */
private boolean alignProteinChains(List<Group> seqRes,List<Group> atomRes){
  Map<Integer,Integer> seqresIndexPosition=new HashMap<Integer,Integer>();
  Map<Integer,Integer> atomIndexPosition=new HashMap<Integer,Integer>();
  String seq1=getFullAtomSequence(seqRes,seqresIndexPosition);
  String seq2=getFullAtomSequence(atomRes,atomIndexPosition);
  logger.debug(""String_Node_Str"" + seq1.length() + ""String_Node_Str""+ seq1);
  logger.debug(""String_Node_Str"" + seq2.length() + ""String_Node_Str""+ seq2);
  ProteinSequence s1;
  ProteinSequence s2;
  try {
    s1=new ProteinSequence(seq1);
    s2=new ProteinSequence(seq2);
  }
 catch (  CompoundNotFoundException e) {
    logger.warn(""String_Node_Str"",e.getMessage());
    return true;
  }
  SubstitutionMatrix<AminoAcidCompound> matrix=SubstitutionMatrixHelper.getBlosum65();
  GapPenalty penalty=new SimpleGapPenalty(8,1);
  PairwiseSequenceAligner<ProteinSequence,AminoAcidCompound> smithWaterman=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.LOCAL,penalty,matrix);
  SequencePair<ProteinSequence,AminoAcidCompound> pair=smithWaterman.getPair();
  if (pair == null) {
    logger.warn(""String_Node_Str"");
    logger.warn(""String_Node_Str"");
    logger.warn(seq1);
    logger.warn(seq2);
    return true;
  }
  logger.debug(""String_Node_Str"" + pair.toString(100));
  boolean noMatchFound=mapChains(seqRes,atomRes,pair,seqresIndexPosition,atomIndexPosition);
  return noMatchFound;
}","/** 
 * Aligns two chains of groups, where the first parent is representing the list of amino acids as obtained from the SEQRES records, and the second parent represents the groups obtained from the ATOM records (and containing the actual ATOM information). This does the actual alignment and if a group can be mapped to a position in the SEQRES then the corresponding position is replaced with the group that contains the atoms.
 * @param seqRes
 * @param atomRes
 * @return true if no match has been found
 */
private boolean alignProteinChains(List<Group> seqRes,List<Group> atomRes){
  Map<Integer,Integer> seqresIndexPosition=new HashMap<Integer,Integer>();
  Map<Integer,Integer> atomIndexPosition=new HashMap<Integer,Integer>();
  String seq1=getFullAtomSequence(seqRes,seqresIndexPosition,false);
  String seq2=getFullAtomSequence(atomRes,atomIndexPosition,false);
  logger.debug(""String_Node_Str"" + seq1.length() + ""String_Node_Str""+ seq1);
  logger.debug(""String_Node_Str"" + seq2.length() + ""String_Node_Str""+ seq2);
  ProteinSequence s1;
  ProteinSequence s2;
  try {
    s1=new ProteinSequence(seq1);
    s2=new ProteinSequence(seq2);
  }
 catch (  CompoundNotFoundException e) {
    logger.warn(""String_Node_Str"",e.getMessage());
    return true;
  }
  SubstitutionMatrix<AminoAcidCompound> matrix=SubstitutionMatrixHelper.getBlosum65();
  GapPenalty penalty=new SimpleGapPenalty(8,1);
  PairwiseSequenceAligner<ProteinSequence,AminoAcidCompound> smithWaterman=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.LOCAL,penalty,matrix);
  SequencePair<ProteinSequence,AminoAcidCompound> pair=smithWaterman.getPair();
  if (pair == null) {
    logger.warn(""String_Node_Str"");
    logger.warn(""String_Node_Str"");
    logger.warn(seq1);
    logger.warn(seq2);
    return true;
  }
  logger.debug(""String_Node_Str"" + pair.toString(100));
  boolean noMatchFound=mapChains(seqRes,atomRes,pair,seqresIndexPosition,atomIndexPosition);
  return noMatchFound;
}",0.9969527679024884
16520,"/** 
 * Returns the full sequence of the Atom records of a parent with X instead of HETATMSs. The advantage of this is that it allows us to also align HETATM groups back to the SEQRES.
 * @param groups the list of groups in a parent
 * @param positionIndex a Map to keep track of which group is at which sequence position
 * @return string representations
 */
public static String getFullAtomSequence(List<Group> groups,Map<Integer,Integer> positionIndex){
  StringBuffer sequence=new StringBuffer();
  int seqIndex=0;
  for (int i=0; i < groups.size(); i++) {
    Group g=groups.get(i);
    if (g instanceof AminoAcid) {
      AminoAcid a=(AminoAcid)g;
      char oneLetter=a.getAminoType();
      if (oneLetter == '?')       oneLetter='X';
      positionIndex.put(seqIndex,i);
      sequence.append(oneLetter);
      seqIndex++;
    }
 else {
      if (g.isWater())       continue;
      if (g.size() == 1) {
        Atom a=g.getAtom(0);
        if (a == null)         continue;
        if (a.getElement().isMetal())         continue;
      }
      ChemComp cc=g.getChemComp();
      if (cc == null) {
        logger.debug(""String_Node_Str"",g.toString());
        continue;
      }
      if (ResidueType.lPeptideLinking.equals(cc.getResidueType()) || PolymerType.PROTEIN_ONLY.contains(cc.getPolymerType()) || PolymerType.POLYNUCLEOTIDE_ONLY.contains(cc.getPolymerType())) {
        String c=cc.getOne_letter_code();
        if (c.equals(""String_Node_Str""))         c=""String_Node_Str"";
        if (c.length() > 1) {
          logger.info(""String_Node_Str"",g.toString(),c);
        }
        for (int cIdx=0; cIdx < c.length(); cIdx++) {
          positionIndex.put(seqIndex,i);
          sequence.append(c.charAt(cIdx));
          seqIndex++;
        }
      }
 else {
        logger.debug(""String_Node_Str"",g.toString());
        continue;
      }
    }
  }
  return sequence.toString();
}","/** 
 * Returns the full sequence of the Atom records of a parent with X instead of HETATMSs. The advantage of this is that it allows us to also align HETATM groups back to the SEQRES.
 * @param groups the list of groups in a parent
 * @param positionIndex a Map to keep track of which group is at which sequence position
 * @param isNucleotideChain whether the atom groups are predominantly nucleotides (the groups represent a nucleotide chain), if truenon-standard nucleotides will be represented with ambiguous letter 'N' instead of 'X', if false all non-standard residues will be 'X'
 * @return string representations
 */
public static String getFullAtomSequence(List<Group> groups,Map<Integer,Integer> positionIndex,boolean isNucleotideChain){
  StringBuffer sequence=new StringBuffer();
  int seqIndex=0;
  for (int i=0; i < groups.size(); i++) {
    Group g=groups.get(i);
    if (g instanceof AminoAcid) {
      AminoAcid a=(AminoAcid)g;
      char oneLetter=a.getAminoType();
      if (oneLetter == '?')       oneLetter='X';
      positionIndex.put(seqIndex,i);
      sequence.append(oneLetter);
      seqIndex++;
    }
 else {
      if (g.isWater())       continue;
      if (g.size() == 1) {
        Atom a=g.getAtom(0);
        if (a == null)         continue;
        if (a.getElement().isMetal())         continue;
      }
      ChemComp cc=g.getChemComp();
      if (cc == null) {
        logger.debug(""String_Node_Str"",g.toString());
        continue;
      }
      if (ResidueType.lPeptideLinking.equals(cc.getResidueType()) || PolymerType.PROTEIN_ONLY.contains(cc.getPolymerType()) || PolymerType.POLYNUCLEOTIDE_ONLY.contains(cc.getPolymerType())) {
        String c=cc.getOne_letter_code();
        if (c.equals(""String_Node_Str"")) {
          if (isNucleotideChain && PolymerType.POLYNUCLEOTIDE_ONLY.contains(cc.getPolymerType())) {
            c=""String_Node_Str"";
          }
 else {
            c=""String_Node_Str"";
          }
        }
        if (c.length() > 1) {
          logger.info(""String_Node_Str"",g.toString(),c);
        }
        for (int cIdx=0; cIdx < c.length(); cIdx++) {
          positionIndex.put(seqIndex,i);
          sequence.append(c.charAt(cIdx));
          seqIndex++;
        }
      }
 else {
        logger.debug(""String_Node_Str"",g.toString());
        continue;
      }
    }
  }
  return sequence.toString();
}",0.8888888888888888
16521,"private boolean alignNucleotideGroups(List<Group> seqRes,List<Group> atomRes){
  Map<Integer,Integer> seqresIndexPosition=new HashMap<Integer,Integer>();
  Map<Integer,Integer> atomIndexPosition=new HashMap<Integer,Integer>();
  String seq1=getFullAtomSequence(seqRes,seqresIndexPosition);
  String seq2=getFullAtomSequence(atomRes,atomIndexPosition);
  if (seq1.isEmpty() || seq2.isEmpty()) {
    logger.warn(""String_Node_Str"");
    return true;
  }
  logger.debug(""String_Node_Str"" + seq1.length() + ""String_Node_Str""+ seq1);
  logger.debug(""String_Node_Str"" + seq2.length() + ""String_Node_Str""+ seq2);
  Sequence<NucleotideCompound> s1;
  Sequence<NucleotideCompound> s2;
  try {
    s1=new DNASequence(seq1,AmbiguityDNACompoundSet.getDNACompoundSet());
  }
 catch (  CompoundNotFoundException e) {
    try {
      s1=new RNASequence(seq1,AmbiguityRNACompoundSet.getRNACompoundSet());
    }
 catch (    CompoundNotFoundException ex) {
      logger.warn(""String_Node_Str"" + seq1);
      return true;
    }
  }
  try {
    s2=new DNASequence(seq2,AmbiguityDNACompoundSet.getDNACompoundSet());
  }
 catch (  CompoundNotFoundException e) {
    try {
      s2=new RNASequence(seq2,AmbiguityRNACompoundSet.getRNACompoundSet());
    }
 catch (    CompoundNotFoundException ex) {
      logger.warn(""String_Node_Str"" + seq2);
      return true;
    }
  }
  if (!s1.getCompoundSet().equals(s2.getCompoundSet())) {
    if (!s1.getCompoundSet().equals(AmbiguityRNACompoundSet.getRNACompoundSet())) {
      try {
        s1=new RNASequence(seq1,AmbiguityRNACompoundSet.getRNACompoundSet());
      }
 catch (      CompoundNotFoundException ex) {
        logger.warn(""String_Node_Str"" + seq1);
        return true;
      }
    }
    if (!s2.getCompoundSet().equals(AmbiguityRNACompoundSet.getRNACompoundSet())) {
      try {
        s2=new RNASequence(seq2,AmbiguityRNACompoundSet.getRNACompoundSet());
      }
 catch (      CompoundNotFoundException ex) {
        logger.warn(""String_Node_Str"" + seq2);
        return true;
      }
    }
  }
  SubstitutionMatrix<NucleotideCompound> matrix=SubstitutionMatrixHelper.getNuc4_4();
  GapPenalty penalty=new SimpleGapPenalty(8,1);
  PairwiseSequenceAligner<Sequence<NucleotideCompound>,NucleotideCompound> smithWaterman=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.LOCAL,penalty,matrix);
  SequencePair<Sequence<NucleotideCompound>,NucleotideCompound> pair=smithWaterman.getPair();
  if (pair == null) {
    logger.warn(""String_Node_Str"");
    logger.warn(""String_Node_Str"");
    logger.warn(seq1);
    logger.warn(seq2);
    return true;
  }
  logger.debug(""String_Node_Str"" + pair.toString(100));
  boolean noMatchFound=mapDNAChains(seqRes,atomRes,pair,seqresIndexPosition,atomIndexPosition);
  return noMatchFound;
}","private boolean alignNucleotideGroups(List<Group> seqRes,List<Group> atomRes){
  Map<Integer,Integer> seqresIndexPosition=new HashMap<Integer,Integer>();
  Map<Integer,Integer> atomIndexPosition=new HashMap<Integer,Integer>();
  String seq1=getFullAtomSequence(seqRes,seqresIndexPosition,true);
  String seq2=getFullAtomSequence(atomRes,atomIndexPosition,true);
  if (seq1.isEmpty() || seq2.isEmpty()) {
    logger.warn(""String_Node_Str"");
    return true;
  }
  logger.debug(""String_Node_Str"" + seq1.length() + ""String_Node_Str""+ seq1);
  logger.debug(""String_Node_Str"" + seq2.length() + ""String_Node_Str""+ seq2);
  Sequence<NucleotideCompound> s1=getNucleotideSequence(seq1);
  Sequence<NucleotideCompound> s2=getNucleotideSequence(seq2);
  if (s1 == null || s2 == null)   return true;
  if (!s1.getCompoundSet().equals(s2.getCompoundSet())) {
    if (!s1.getCompoundSet().equals(AmbiguityRNACompoundSet.getRNACompoundSet())) {
      try {
        s1=new RNASequence(seq1,AmbiguityRNACompoundSet.getRNACompoundSet());
      }
 catch (      CompoundNotFoundException ex) {
        logger.warn(""String_Node_Str"" + seq1);
        return true;
      }
    }
    if (!s2.getCompoundSet().equals(AmbiguityRNACompoundSet.getRNACompoundSet())) {
      try {
        s2=new RNASequence(seq2,AmbiguityRNACompoundSet.getRNACompoundSet());
      }
 catch (      CompoundNotFoundException ex) {
        logger.warn(""String_Node_Str"" + seq2);
        return true;
      }
    }
  }
  SubstitutionMatrix<NucleotideCompound> matrix=SubstitutionMatrixHelper.getNuc4_4();
  GapPenalty penalty=new SimpleGapPenalty(8,1);
  PairwiseSequenceAligner<Sequence<NucleotideCompound>,NucleotideCompound> smithWaterman=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.LOCAL,penalty,matrix);
  SequencePair<Sequence<NucleotideCompound>,NucleotideCompound> pair=smithWaterman.getPair();
  if (pair == null) {
    logger.warn(""String_Node_Str"");
    logger.warn(""String_Node_Str"");
    logger.warn(seq1);
    logger.warn(seq2);
    return true;
  }
  logger.debug(""String_Node_Str"" + pair.toString(100));
  boolean noMatchFound=mapDNAChains(seqRes,atomRes,pair,seqresIndexPosition,atomIndexPosition);
  return noMatchFound;
}",0.8488862131246238
16522,"/** 
 * Generates a ProteinSequence corresponding to the sequence of struct, and maintains a mapping from the sequence back to the original groups. Chains are appended to one another. 'X' is used for heteroatoms.
 * @param struct Input structure
 * @param groupIndexPosition An empty map, which will be populated with(residue index in returned ProteinSequence) -> (Group within struct)
 * @return A ProteinSequence with the full sequence of struct. Chains areconcatenated in the same order as the input structures
 * @see {@link SeqRes2AtomAligner#getFullAtomSequence(List,Map)}, which does the heavy lifting.
 */
public static ProteinSequence getProteinSequenceForStructure(Structure struct,Map<Integer,Group> groupIndexPosition){
  if (groupIndexPosition != null) {
    groupIndexPosition.clear();
  }
  StringBuilder seqStr=new StringBuilder();
  for (  Chain chain : struct.getChains()) {
    List<Group> groups=chain.getAtomGroups();
    Map<Integer,Integer> chainIndexPosition=new HashMap<Integer,Integer>();
    int prevLen=seqStr.length();
    String chainSeq=SeqRes2AtomAligner.getFullAtomSequence(groups,chainIndexPosition);
    seqStr.append(chainSeq);
    for (    Integer seqIndex : chainIndexPosition.keySet()) {
      Integer groupIndex=chainIndexPosition.get(seqIndex);
      groupIndexPosition.put(prevLen + seqIndex,groups.get(groupIndex));
    }
  }
  ProteinSequence s=null;
  try {
    s=new ProteinSequence(seqStr.toString());
  }
 catch (  CompoundNotFoundException e) {
    logger.error(""String_Node_Str"",e.getMessage());
  }
  return s;
}","/** 
 * Generates a ProteinSequence corresponding to the sequence of struct, and maintains a mapping from the sequence back to the original groups. Chains are appended to one another. 'X' is used for heteroatoms.
 * @param struct Input structure
 * @param groupIndexPosition An empty map, which will be populated with(residue index in returned ProteinSequence) -> (Group within struct)
 * @return A ProteinSequence with the full sequence of struct. Chains areconcatenated in the same order as the input structures
 * @see {@link SeqRes2AtomAligner#getFullAtomSequence(List,Map)}, which does the heavy lifting.
 */
public static ProteinSequence getProteinSequenceForStructure(Structure struct,Map<Integer,Group> groupIndexPosition){
  if (groupIndexPosition != null) {
    groupIndexPosition.clear();
  }
  StringBuilder seqStr=new StringBuilder();
  for (  Chain chain : struct.getChains()) {
    List<Group> groups=chain.getAtomGroups();
    Map<Integer,Integer> chainIndexPosition=new HashMap<Integer,Integer>();
    int prevLen=seqStr.length();
    String chainSeq=SeqRes2AtomAligner.getFullAtomSequence(groups,chainIndexPosition,false);
    seqStr.append(chainSeq);
    for (    Integer seqIndex : chainIndexPosition.keySet()) {
      Integer groupIndex=chainIndexPosition.get(seqIndex);
      groupIndexPosition.put(prevLen + seqIndex,groups.get(groupIndex));
    }
  }
  ProteinSequence s=null;
  try {
    s=new ProteinSequence(seqStr.toString());
  }
 catch (  CompoundNotFoundException e) {
    logger.error(""String_Node_Str"",e.getMessage());
  }
  return s;
}",0.9980842911877394
16523,"/** 
 * @param recordName : three-letter name
 * @return true if successful download
 */
private static boolean downloadChemCompRecord(String recordName){
  String localName=getLocalFileName(recordName);
  String u=SERVER_LOCATION + recordName + ""String_Node_Str"";
  logger.debug(""String_Node_Str"" + u);
  URL url=null;
  try {
    url=new URL(u);
    HttpURLConnection uconn=HTTPConnectionTools.openHttpURLConnection(url);
    try (PrintWriter pw=new PrintWriter(new GZIPOutputStream(new FileOutputStream(localName)));BufferedReader fileBuffer=new BufferedReader(new InputStreamReader(uconn.getInputStream()))){
      String line;
      while ((line=fileBuffer.readLine()) != null) {
        pw.println(line);
      }
      pw.flush();
      return true;
    }
   }
 catch (  FileNotFoundException e) {
    logger.warn(recordName + ""String_Node_Str"" + SERVER_LOCATION+ ""String_Node_Str"");
  }
catch (  IOException e) {
    logger.error(""String_Node_Str"" + url.toString() + ""String_Node_Str""+ localName,e);
  }
  return false;
}","/** 
 * @param recordName : three-letter name
 * @return true if successful download
 */
private static boolean downloadChemCompRecord(String recordName){
  String localName=getLocalFileName(recordName);
  File newFile;
  try {
    newFile=File.createTempFile(recordName,""String_Node_Str"");
  }
 catch (  IOException e) {
    return false;
  }
  String u=SERVER_LOCATION + recordName + ""String_Node_Str"";
  logger.debug(""String_Node_Str"" + u);
  URL url=null;
  try {
    url=new URL(u);
    HttpURLConnection uconn=HTTPConnectionTools.openHttpURLConnection(url);
    try (PrintWriter pw=new PrintWriter(new GZIPOutputStream(new FileOutputStream(newFile)));BufferedReader fileBuffer=new BufferedReader(new InputStreamReader(uconn.getInputStream()))){
      String line;
      while ((line=fileBuffer.readLine()) != null) {
        pw.println(line);
      }
      pw.flush();
      newFile.renameTo(new File(localName));
      return true;
    }
   }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + url.toString() + ""String_Node_Str""+ localName+ ""String_Node_Str""+ e.getMessage());
    newFile.delete();
  }
  return false;
}",0.8228782287822878
16524,"public void setDefault(){
  parseSecStruc=false;
  alignSeqRes=true;
  parseCAOnly=false;
  setLoadChemCompInfo(false);
  headerOnly=false;
  updateRemediatedFiles=false;
  fullAtomNames=null;
  maxAtoms=MAX_ATOMS;
  atomCaThreshold=ATOM_CA_THRESHOLD;
  parseBioAssembly=false;
  createAtomBonds=false;
  createConects=false;
  createAtomCharges=true;
}","public void setDefault(){
  parseSecStruc=false;
  alignSeqRes=true;
  parseCAOnly=false;
  setLoadChemCompInfo(false);
  headerOnly=false;
  updateRemediatedFiles=false;
  fullAtomNames=null;
  maxAtoms=MAX_ATOMS;
  atomCaThreshold=ATOM_CA_THRESHOLD;
  parseBioAssembly=false;
  createAtomBonds=false;
  createConects=false;
  createAtomCharges=true;
  useInternalChainId=false;
}",0.9618528610354224
16525,"@Override public void documentEnd(){
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
 else   if (!params.isHeaderOnly()) {
    logger.warn(""String_Node_Str"");
  }
  structure.addModel(current_model);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    asymId2entityId.put(asym.getId(),asym.getEntity_id());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setChainID(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    addCompounds(asym);
  }
  if (structAsyms.isEmpty()) {
    logger.warn(""String_Node_Str"");
  }
  if (params.isAlignSeqRes() && !params.isHeaderOnly()) {
    logger.debug(""String_Node_Str"");
    alignSeqRes();
  }
 else {
    logger.debug(""String_Node_Str"");
    SeqRes2AtomAligner.storeUnAlignedSeqRes(structure,seqResChains,params.isHeaderOnly());
  }
  if (!params.isHeaderOnly()) {
    if (params.shouldCreateAtomBonds()) {
      addBonds();
    }
    if (params.isCreateLigandConects()) {
      addLigandConnections();
    }
    if (params.shouldCreateAtomCharges()) {
      addCharges();
    }
  }
  if (asymStrandId.isEmpty()) {
    logger.warn(""String_Node_Str"");
    asymStrandId=asymId2StrandIdFromAtomSites;
  }
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> model=structure.getModel(i);
    List<Chain> pdbChains=new ArrayList<Chain>();
    for (    Chain chain : model) {
      for (      String asym : asymStrandId.keySet()) {
        if (chain.getChainID().equals(asym)) {
          String newChainId=asymStrandId.get(asym);
          logger.debug(""String_Node_Str"",asym,chain.getAtomGroups().size(),newChainId);
          chain.setChainID(newChainId);
          chain.setInternalChainID(asym);
          for (          Group g : chain.getAtomGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          for (          Group g : chain.getSeqResGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          Chain known=isKnownChain(chain.getChainID(),pdbChains);
          if (known == null) {
            pdbChains.add(chain);
          }
 else {
            for (            Group g : chain.getAtomGroups()) {
              known.addGroup(g);
            }
          }
          break;
        }
      }
    }
    structure.setModel(i,pdbChains);
  }
  linkCompounds();
  if (!params.isHeaderOnly()) {
    createSSBonds();
    addSites();
  }
  if (params.isParseBioAssembly()) {
    Map<Integer,BioAssemblyInfo> bioAssemblies=new HashMap<Integer,BioAssemblyInfo>();
    for (    PdbxStructAssembly psa : strucAssemblies) {
      List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
      for (      PdbxStructAssemblyGen psag : strucAssemblyGens) {
        if (psag.getAssembly_id().equals(psa.getId())) {
          psags.add(psag);
        }
      }
      BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
      List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
      int mmSize=0;
      int bioAssemblyId=-1;
      try {
        bioAssemblyId=Integer.parseInt(psa.getId());
      }
 catch (      NumberFormatException e) {
        logger.info(""String_Node_Str"",psa.getId());
      }
      try {
        mmSize=Integer.parseInt(psa.getOligomeric_count());
      }
 catch (      NumberFormatException e) {
        if (bioAssemblyId != -1)         logger.warn(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
 else         logger.info(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
      }
      if (bioAssemblyId != -1) {
        BioAssemblyInfo bioAssembly=new BioAssemblyInfo();
        bioAssembly.setId(bioAssemblyId);
        bioAssembly.setMacromolecularSize(mmSize);
        bioAssembly.setTransforms(transformations);
        bioAssemblies.put(bioAssemblyId,bioAssembly);
      }
    }
    structure.getPDBHeader().setBioAssemblies(bioAssemblies);
  }
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators(ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
  Map<String,List<SeqMisMatch>> misMatchMap=new HashMap<String,List<SeqMisMatch>>();
  for (  StructRefSeqDif sdif : sequenceDifs) {
    SeqMisMatch misMatch=new SeqMisMatchImpl();
    misMatch.setDetails(sdif.getDetails());
    String insCode=sdif.getPdbx_pdb_ins_code();
    if (insCode != null && insCode.equals(""String_Node_Str""))     insCode=null;
    misMatch.setInsCode(insCode);
    misMatch.setOrigGroup(sdif.getDb_mon_id());
    misMatch.setPdbGroup(sdif.getMon_id());
    misMatch.setPdbResNum(sdif.getPdbx_auth_seq_num());
    misMatch.setUniProtId(sdif.getPdbx_seq_db_accession_code());
    misMatch.setSeqNum(sdif.getSeq_num());
    List<SeqMisMatch> mms=misMatchMap.get(sdif.getPdbx_pdb_strand_id());
    if (mms == null) {
      mms=new ArrayList<SeqMisMatch>();
      misMatchMap.put(sdif.getPdbx_pdb_strand_id(),mms);
    }
    mms.add(misMatch);
  }
  for (  String chainId : misMatchMap.keySet()) {
    try {
      Chain c=structure.getChainByPDB(chainId);
      c.setSeqMisMatches(misMatchMap.get(chainId));
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + chainId);
    }
  }
}","@Override public void documentEnd(){
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
 else   if (!params.isHeaderOnly()) {
    logger.warn(""String_Node_Str"");
  }
  structure.addModel(current_model);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    asymId2entityId.put(asym.getId(),asym.getEntity_id());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setChainID(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    addCompounds(asym);
  }
  if (structAsyms.isEmpty()) {
    logger.warn(""String_Node_Str"");
  }
  if (params.isAlignSeqRes() && !params.isHeaderOnly()) {
    logger.debug(""String_Node_Str"");
    alignSeqRes();
  }
 else {
    logger.debug(""String_Node_Str"");
    SeqRes2AtomAligner.storeUnAlignedSeqRes(structure,seqResChains,params.isHeaderOnly());
  }
  if (!params.isHeaderOnly()) {
    if (params.shouldCreateAtomBonds()) {
      addBonds();
    }
    if (params.isCreateLigandConects()) {
      addLigandConnections();
    }
    if (params.shouldCreateAtomCharges()) {
      addCharges();
    }
  }
  if (asymStrandId.isEmpty()) {
    logger.warn(""String_Node_Str"");
    asymStrandId=asymId2StrandIdFromAtomSites;
  }
  if (params.isUseInternalChainId() == false) {
    for (int i=0; i < structure.nrModels(); i++) {
      List<Chain> model=structure.getModel(i);
      List<Chain> pdbChains=new ArrayList<Chain>();
      for (      Chain chain : model) {
        for (        String asym : asymStrandId.keySet()) {
          if (chain.getChainID().equals(asym)) {
            String newChainId=asymStrandId.get(asym);
            logger.debug(""String_Node_Str"",asym,chain.getAtomGroups().size(),newChainId);
            chain.setChainID(newChainId);
            chain.setInternalChainID(asym);
            for (            Group g : chain.getAtomGroups()) {
              ResidueNumber resNum=g.getResidueNumber();
              if (resNum != null)               resNum.setChainId(newChainId);
            }
            for (            Group g : chain.getSeqResGroups()) {
              ResidueNumber resNum=g.getResidueNumber();
              if (resNum != null)               resNum.setChainId(newChainId);
            }
            Chain known=isKnownChain(chain.getChainID(),pdbChains);
            if (known == null) {
              pdbChains.add(chain);
            }
 else {
              for (              Group g : chain.getAtomGroups()) {
                known.addGroup(g);
              }
            }
            break;
          }
        }
      }
      structure.setModel(i,pdbChains);
    }
  }
 else {
    for (int i=0; i < structure.nrModels(); i++) {
      List<Chain> model=structure.getModel(i);
      for (      Chain chain : model) {
        for (        String asym : asymStrandId.keySet()) {
          if (chain.getChainID().equals(asym)) {
            String authChainId=asymStrandId.get(asym);
            chain.setInternalChainID(authChainId);
            break;
          }
        }
      }
    }
  }
  linkCompounds();
  if (!params.isHeaderOnly()) {
    createSSBonds();
    addSites();
  }
  if (params.isParseBioAssembly()) {
    Map<Integer,BioAssemblyInfo> bioAssemblies=new HashMap<Integer,BioAssemblyInfo>();
    for (    PdbxStructAssembly psa : strucAssemblies) {
      List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
      for (      PdbxStructAssemblyGen psag : strucAssemblyGens) {
        if (psag.getAssembly_id().equals(psa.getId())) {
          psags.add(psag);
        }
      }
      BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
      List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
      int mmSize=0;
      int bioAssemblyId=-1;
      try {
        bioAssemblyId=Integer.parseInt(psa.getId());
      }
 catch (      NumberFormatException e) {
        logger.info(""String_Node_Str"",psa.getId());
      }
      try {
        mmSize=Integer.parseInt(psa.getOligomeric_count());
      }
 catch (      NumberFormatException e) {
        if (bioAssemblyId != -1)         logger.warn(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
 else         logger.info(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
      }
      if (bioAssemblyId != -1) {
        BioAssemblyInfo bioAssembly=new BioAssemblyInfo();
        bioAssembly.setId(bioAssemblyId);
        bioAssembly.setMacromolecularSize(mmSize);
        bioAssembly.setTransforms(transformations);
        bioAssemblies.put(bioAssemblyId,bioAssembly);
      }
    }
    structure.getPDBHeader().setBioAssemblies(bioAssemblies);
  }
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators(ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
  Map<String,List<SeqMisMatch>> misMatchMap=new HashMap<String,List<SeqMisMatch>>();
  for (  StructRefSeqDif sdif : sequenceDifs) {
    SeqMisMatch misMatch=new SeqMisMatchImpl();
    misMatch.setDetails(sdif.getDetails());
    String insCode=sdif.getPdbx_pdb_ins_code();
    if (insCode != null && insCode.equals(""String_Node_Str""))     insCode=null;
    misMatch.setInsCode(insCode);
    misMatch.setOrigGroup(sdif.getDb_mon_id());
    misMatch.setPdbGroup(sdif.getMon_id());
    misMatch.setPdbResNum(sdif.getPdbx_auth_seq_num());
    misMatch.setUniProtId(sdif.getPdbx_seq_db_accession_code());
    misMatch.setSeqNum(sdif.getSeq_num());
    List<SeqMisMatch> mms=misMatchMap.get(sdif.getPdbx_pdb_strand_id());
    if (mms == null) {
      mms=new ArrayList<SeqMisMatch>();
      misMatchMap.put(sdif.getPdbx_pdb_strand_id(),mms);
    }
    mms.add(misMatch);
  }
  for (  String chainId : misMatchMap.keySet()) {
    try {
      Chain c=structure.getChainByPDB(chainId);
      c.setSeqMisMatches(misMatchMap.get(chainId));
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + chainId);
    }
  }
}",0.9517607332368548
16526,"/** 
 * @param recordName : three-letter name
 * @return true if successful download
 */
private static boolean downloadChemCompRecord(String recordName){
  String localName=getLocalFileName(recordName);
  String u=SERVER_LOCATION + recordName + ""String_Node_Str"";
  logger.debug(""String_Node_Str"" + u);
  URL url=null;
  try {
    url=new URL(u);
    HttpURLConnection uconn=HTTPConnectionTools.openHttpURLConnection(url);
    try (PrintWriter pw=new PrintWriter(new GZIPOutputStream(new FileOutputStream(localName)));BufferedReader fileBuffer=new BufferedReader(new InputStreamReader(uconn.getInputStream()))){
      String line;
      while ((line=fileBuffer.readLine()) != null) {
        pw.println(line);
      }
      pw.flush();
      return true;
    }
   }
 catch (  FileNotFoundException e) {
    logger.warn(recordName + ""String_Node_Str"" + SERVER_LOCATION+ ""String_Node_Str"");
  }
catch (  IOException e) {
    logger.error(""String_Node_Str"" + url.toString() + ""String_Node_Str""+ localName,e);
  }
  return false;
}","/** 
 * @param recordName : three-letter name
 * @return true if successful download
 */
private static boolean downloadChemCompRecord(String recordName){
  String localName=getLocalFileName(recordName);
  File newFile=new File(localName);
  String u=SERVER_LOCATION + recordName + ""String_Node_Str"";
  logger.debug(""String_Node_Str"" + u);
  URL url=null;
  try {
    url=new URL(u);
    HttpURLConnection uconn=HTTPConnectionTools.openHttpURLConnection(url);
    try (PrintWriter pw=new PrintWriter(new GZIPOutputStream(new FileOutputStream(newFile)));BufferedReader fileBuffer=new BufferedReader(new InputStreamReader(uconn.getInputStream()))){
      String line;
      while ((line=fileBuffer.readLine()) != null) {
        pw.println(line);
      }
      pw.flush();
      return true;
    }
   }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + url.toString() + ""String_Node_Str""+ localName+ ""String_Node_Str""+ e.getMessage());
    newFile.delete();
  }
  return false;
}",0.883605745418524
16527,"/** 
 * Return the String with the PDB server name, including the leading protocol  String (http:// or ftp://).  The server name will be by default the value   {@value #DEFAULT_PDB_FILE_SERVER} or the one read from system property  {@value #PDB_FILE_SERVER_PROPERTY}
 * @return the server name including the leading protocol string
 */
public static String getServerName(){
  String name=System.getProperty(PDB_FILE_SERVER_PROPERTY);
  if (name == null || name.trim().isEmpty()) {
    name=DEFAULT_PDB_FILE_SERVER;
    logger.debug(""String_Node_Str"",name);
  }
 else {
    if (!name.startsWith(""String_Node_Str"") || !name.startsWith(""String_Node_Str"")) {
      logger.warn(""String_Node_Str"",name,PDB_FILE_SERVER_PROPERTY);
      name=""String_Node_Str"" + name;
    }
    logger.info(""String_Node_Str"",name,PDB_FILE_SERVER_PROPERTY);
  }
  return name;
}","/** 
 * Return the String with the PDB server name, including the leading protocol  String (http:// or ftp://).  The server name will be by default the value   {@value #DEFAULT_PDB_FILE_SERVER} or the one read from system property  {@value #PDB_FILE_SERVER_PROPERTY}
 * @return the server name including the leading protocol string
 */
public static String getServerName(){
  String name=System.getProperty(PDB_FILE_SERVER_PROPERTY);
  if (name == null || name.trim().isEmpty()) {
    name=DEFAULT_PDB_FILE_SERVER;
    logger.debug(""String_Node_Str"",name);
  }
 else {
    if (!name.startsWith(""String_Node_Str"") && !name.startsWith(""String_Node_Str"")) {
      logger.warn(""String_Node_Str"",name,PDB_FILE_SERVER_PROPERTY);
      name=""String_Node_Str"" + name;
    }
    logger.info(""String_Node_Str"",name,PDB_FILE_SERVER_PROPERTY);
  }
  return name;
}",0.9976525821596244
16528,"/** 
 * Tries to determine the source and pdbId without fully realizing the identifier, which could require I/O depending on the source
 * @throws IllegalArgumentException if the source is recognizable but invalid
 */
private void init(){
  Matcher matcher=scopPattern.matcher(name);
  if (matcher.matches()) {
    mySource=Source.SCOP;
    pdbId=matcher.group(1);
    chainId=matcher.group(2);
    return;
  }
  if (name.startsWith(AtomCache.PDP_DOMAIN_IDENTIFIER)) {
    mySource=Source.PDP;
    matcher=PDPDomain.PDP_NAME_PATTERN.matcher(name);
    if (!matcher.matches()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    pdbId=matcher.group(1);
    chainId=matcher.group(2);
    return;
  }
  matcher=cathPattern.matcher(name);
  if (matcher.matches()) {
    mySource=Source.CATH;
    pdbId=matcher.group(1);
    chainId=matcher.group(2);
    return;
  }
  try {
    new URL(name);
    mySource=Source.URL;
    pdbId=null;
    chainId=null;
    return;
  }
 catch (  MalformedURLException e) {
  }
  File file=new File(FileDownloadUtils.expandUserHome(name));
  if (file.exists()) {
    mySource=Source.FILE;
    pdbId=null;
    chainId=null;
    return;
  }
  mySource=Source.PDB;
  SubstructureIdentifier si=new SubstructureIdentifier(getIdentifier());
  realized=si;
  pdbId=si.getPdbId();
  Set<String> chains=getChainIds(si);
  if (chains.size() == 1) {
    this.chainId=chains.iterator().next();
  }
 else   if (chains.size() > 1) {
    this.chainId=""String_Node_Str"";
  }
 else {
    this.chainId=null;
  }
}","/** 
 * Tries to determine the source and pdbId without fully realizing the identifier, which could require I/O depending on the source
 * @throws IllegalArgumentException if the source is recognizable but invalid
 */
private void init(){
  Matcher matcher=scopPattern.matcher(name);
  if (matcher.matches()) {
    mySource=Source.SCOP;
    pdbId=matcher.group(1);
    chainId=matcher.group(2);
    return;
  }
  if (name.startsWith(AtomCache.PDP_DOMAIN_IDENTIFIER)) {
    mySource=Source.PDP;
    matcher=PDPDomain.PDP_NAME_PATTERN.matcher(name);
    if (!matcher.matches()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    pdbId=matcher.group(1);
    chainId=matcher.group(2);
    return;
  }
  matcher=cathPattern.matcher(name);
  if (matcher.matches()) {
    mySource=Source.CATH;
    pdbId=matcher.group(1);
    chainId=matcher.group(2);
    return;
  }
  try {
    new URL(name);
    mySource=Source.URL;
    pdbId=null;
    chainId=null;
    return;
  }
 catch (  MalformedURLException e) {
  }
  File file=new File(FileDownloadUtils.expandUserHome(name));
  if (file.exists() || (file.getParentFile() != null && file.getParentFile().exists())) {
    mySource=Source.FILE;
    pdbId=null;
    chainId=null;
    return;
  }
  mySource=Source.PDB;
  SubstructureIdentifier si=new SubstructureIdentifier(getIdentifier());
  realized=si;
  pdbId=si.getPdbId();
  Set<String> chains=getChainIds(si);
  if (chains.size() == 1) {
    this.chainId=chains.iterator().next();
  }
 else   if (chains.size() > 1) {
    this.chainId=""String_Node_Str"";
  }
 else {
    this.chainId=null;
  }
}",0.9787503964478276
16529,"/** 
 * @return
 * @throws StructureException Wraps exceptions that may be thrown byindividual implementations. For example, a SCOP identifier may require that the domain definitions be available for download.
 */
private StructureIdentifier realize() throws StructureException {
  if (realized == null) {
switch (mySource) {
case CATH:
      realized=CathFactory.getCathDatabase().getDescriptionByCathId(getIdentifier());
    break;
case SCOP:
  realized=guessScopDomain(getIdentifier(),ScopFactory.getSCOP());
if (realized == null) {
  if (chainId.equals(""String_Node_Str"")) {
    realized=new SubstructureIdentifier(pdbId);
  }
 else {
    realized=new SubstructureIdentifier(pdbId,ResidueRange.parseMultiple(chainId));
  }
  logger.error(""String_Node_Str"",name,realized);
}
break;
case FILE:
try {
realized=new URLIdentifier(new File(name).toURI().toURL());
}
 catch (MalformedURLException e) {
throw new StructureException(""String_Node_Str"" + name,e);
}
break;
case URL:
try {
realized=new URLIdentifier(name);
}
 catch (MalformedURLException e) {
throw new StructureException(""String_Node_Str"" + name,e);
}
break;
case PDP:
try {
PDPProvider provider=new RemotePDPProvider(false);
realized=provider.getPDPDomain(name);
}
 catch (IOException e) {
throw new StructureException(""String_Node_Str"" + name,e);
}
break;
case PDB:
realized=new SubstructureIdentifier(getIdentifier());
break;
default :
realized=new PassthroughIdentifier(name);
break;
}
}
return realized;
}","/** 
 * @return
 * @throws StructureException Wraps exceptions that may be thrown byindividual implementations. For example, a SCOP identifier may require that the domain definitions be available for download.
 */
private StructureIdentifier realize() throws StructureException {
  if (realized == null) {
switch (mySource) {
case CATH:
      realized=CathFactory.getCathDatabase().getDescriptionByCathId(getIdentifier());
    break;
case SCOP:
  realized=guessScopDomain(getIdentifier(),ScopFactory.getSCOP());
if (realized == null) {
  if (chainId.equals(""String_Node_Str"")) {
    realized=new SubstructureIdentifier(pdbId);
  }
 else {
    realized=new SubstructureIdentifier(pdbId,ResidueRange.parseMultiple(chainId));
  }
  logger.error(""String_Node_Str"",name,realized);
}
break;
case FILE:
try {
realized=new URLIdentifier(new File(FileDownloadUtils.expandUserHome(name)).toURI().toURL());
}
 catch (MalformedURLException e) {
throw new StructureException(""String_Node_Str"" + name,e);
}
break;
case URL:
try {
realized=new URLIdentifier(name);
}
 catch (MalformedURLException e) {
throw new StructureException(""String_Node_Str"" + name,e);
}
break;
case PDP:
try {
PDPProvider provider=new RemotePDPProvider(false);
realized=provider.getPDPDomain(name);
}
 catch (IOException e) {
throw new StructureException(""String_Node_Str"" + name,e);
}
break;
case PDB:
realized=new SubstructureIdentifier(getIdentifier());
break;
default :
realized=new PassthroughIdentifier(name);
break;
}
}
return realized;
}",0.9858870967741936
16530,"/** 
 * Convert a BioJava   {@link MultipleSequenceAlignment} to a forester{@link Msa}. The easiest way to convert them is writting the msa as a FASTA file and then parsing it with the forester   {@link FastaParser}.
 * @param msa BioJava MultipleSequenceAlignment
 * @return forester Msa object
 * @throws IOException 
 * @throws Exception if the conversion was not possible
 */
public static <C extends Sequence<D>,D extends Compound>Msa convert(MultipleSequenceAlignment<C,D> msa) throws IOException {
  OutputStream os=new ByteArrayOutputStream();
  FastaWriter<C,D> fastaW=new FastaWriter<C,D>(os,msa.getAlignedSequences(),new FastaHeaderFormatInterface<C,D>(){
    @Override public String getHeader(    C sequence){
      return sequence.getAccession().toString();
    }
  }
);
  fastaW.process();
  String fastaMSA=os.toString();
  return FastaParser.parseMsa(fastaMSA);
}","/** 
 * Convert a BioJava   {@link MultipleSequenceAlignment} to a forester{@link Msa}. The easiest way to convert them is writting the msa as a FASTA file and then parsing it with the forester   {@link FastaParser}.
 * @param msa BioJava MultipleSequenceAlignment
 * @return forester Msa object
 * @throws IOException if the conversion was not possible
 */
public static <C extends Sequence<D>,D extends Compound>Msa convert(MultipleSequenceAlignment<C,D> msa) throws IOException {
  OutputStream os=new ByteArrayOutputStream();
  FastaWriter<C,D> fastaW=new FastaWriter<C,D>(os,msa.getAlignedSequences(),new FastaHeaderFormatInterface<C,D>(){
    @Override public String getHeader(    C sequence){
      return sequence.getAccession().toString();
    }
  }
);
  fastaW.process();
  String fastaMSA=os.toString();
  return FastaParser.parseMsa(fastaMSA);
}",0.9873271889400922
16531,"/** 
 * Provide a JMenuBar that can be added to a JFrame containing  a JmolPanel. The alignment has to be either an AFPChain or a MultipleAlignment: set the other parameter to null.<p> Menus included: <ul><li>File: open, save, export, import, exit. <li>Align: new pairwise alignment, new multiple alignment. <li>View: aligment panel, aligned pairs, text format,  FatCat format, distance matrices, dot plot. <li>Help </ul>
 * @return a JMenuBar
 */
public static JMenuBar initJmolMenu(JFrame frame,AbstractAlignmentJmol parent,AFPChain afpChain,MultipleAlignment msa){
  JMenuBar menu=new JMenuBar();
  JMenu file=new JMenu(""String_Node_Str"");
  file.setMnemonic(KeyEvent.VK_F);
  file.getAccessibleContext().setAccessibleDescription(""String_Node_Str"");
  if (parent != null) {
    JMenuItem loadF=getLoadMenuItem();
    loadF.addActionListener(new MyAlignmentLoadListener());
    file.add(loadF);
  }
  JMenuItem saveF=getSaveAlignmentMenuItem(afpChain,msa);
  file.add(saveF);
  JMenuItem openPDB=getShowPDBMenuItem();
  file.add(openPDB);
  JMenuItem openI=getOpenPDBMenuItem();
  file.add(openI);
  if (parent != null) {
    JMenuItem exportI=getExportPDBMenuItem(parent);
    file.add(exportI);
  }
  JMenuItem openDBI=getDBResultMenuItem();
  file.add(openDBI);
  file.addSeparator();
  if (parent != null) {
    JMenuItem print=getPrintMenuItem();
    print.addActionListener(parent.getJmolPanel());
    file.add(print);
  }
  file.addSeparator();
  JMenuItem closeI=getCloseMenuItem(frame);
  file.add(closeI);
  JMenuItem exitI=getExitMenuItem();
  file.add(exitI);
  menu.add(file);
  JMenu align=new JMenu(""String_Node_Str"");
  align.setMnemonic(KeyEvent.VK_A);
  JMenuItem pairI=getPairwiseAlignmentMenuItem();
  align.add(pairI);
  JMenuItem multI=getMultipleAlignmentMenuItem();
  align.add(multI);
  menu.add(align);
  JMenu view=new JMenu(""String_Node_Str"");
  view.getAccessibleContext().setAccessibleDescription(""String_Node_Str"");
  view.setMnemonic(KeyEvent.VK_V);
  if (parent != null) {
    JMenuItem apI=MenuCreator.getIcon(parent,ALIGNMENT_PANEL);
    apI.setMnemonic(KeyEvent.VK_M);
    apI.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_M,keyMask));
    view.add(apI);
    JMenuItem textI=MenuCreator.getIcon(parent,TEXT_ONLY);
    textI.setMnemonic(KeyEvent.VK_T);
    view.add(textI);
    JMenuItem pairsI=MenuCreator.getIcon(parent,PAIRS_ONLY);
    pairsI.setMnemonic(KeyEvent.VK_P);
    view.add(pairsI);
    JMenuItem textF=MenuCreator.getIcon(parent,FATCAT_TEXT);
    textF.setMnemonic(KeyEvent.VK_F);
    view.add(textF);
    JMenuItem distMax=new JMenuItem(DIST_MATRICES);
    distMax.setMnemonic(KeyEvent.VK_D);
    distMax.addActionListener(new MyDistMaxListener(parent));
    view.add(distMax);
    if (afpChain != null) {
      JMenuItem dotplot=new JMenuItem(DOT_PLOT);
      dotplot.setMnemonic(KeyEvent.VK_O);
      dotplot.addActionListener(new DotPlotListener(afpChain));
      view.add(dotplot);
    }
    if (afpChain == null) {
      JMenuItem tree=new JMenuItem(PHYLOGENETIC_TREE);
      tree.setMnemonic(KeyEvent.VK_T);
      view.add(tree);
    }
  }
  menu.add(view);
  JMenu about=new JMenu(""String_Node_Str"");
  about.setMnemonic(KeyEvent.VK_H);
  JMenuItem helpM=getHelpMenuItem();
  about.add(helpM);
  JMenuItem aboutM=getAboutMenuItem();
  about.add(aboutM);
  menu.add(Box.createGlue());
  menu.add(about);
  return menu;
}","/** 
 * Provide a JMenuBar that can be added to a JFrame containing  a JmolPanel. The alignment has to be either an AFPChain or a MultipleAlignment: set the other parameter to null.<p> Menus included: <ul><li>File: open, save, export, import, exit. <li>Align: new pairwise alignment, new multiple alignment. <li>View: aligment panel, aligned pairs, text format,  FatCat format, distance matrices, dot plot. <li>Help </ul>
 * @return a JMenuBar
 */
public static JMenuBar initJmolMenu(JFrame frame,AbstractAlignmentJmol parent,AFPChain afpChain,MultipleAlignment msa){
  JMenuBar menu=new JMenuBar();
  JMenu file=new JMenu(""String_Node_Str"");
  file.setMnemonic(KeyEvent.VK_F);
  file.getAccessibleContext().setAccessibleDescription(""String_Node_Str"");
  if (parent != null) {
    JMenuItem loadF=getLoadMenuItem();
    loadF.addActionListener(new MyAlignmentLoadListener());
    file.add(loadF);
  }
  JMenuItem saveF=getSaveAlignmentMenuItem(afpChain,msa);
  file.add(saveF);
  JMenuItem openPDB=getShowPDBMenuItem();
  file.add(openPDB);
  JMenuItem openI=getOpenPDBMenuItem();
  file.add(openI);
  if (parent != null) {
    JMenuItem exportI=getExportPDBMenuItem(parent);
    file.add(exportI);
  }
  JMenuItem openDBI=getDBResultMenuItem();
  file.add(openDBI);
  file.addSeparator();
  if (parent != null) {
    JMenuItem print=getPrintMenuItem();
    print.addActionListener(parent.getJmolPanel());
    file.add(print);
  }
  file.addSeparator();
  JMenuItem closeI=getCloseMenuItem(frame);
  file.add(closeI);
  JMenuItem exitI=getExitMenuItem();
  file.add(exitI);
  menu.add(file);
  JMenu align=new JMenu(""String_Node_Str"");
  align.setMnemonic(KeyEvent.VK_A);
  JMenuItem pairI=getPairwiseAlignmentMenuItem();
  align.add(pairI);
  JMenuItem multI=getMultipleAlignmentMenuItem();
  align.add(multI);
  menu.add(align);
  JMenu view=new JMenu(""String_Node_Str"");
  view.getAccessibleContext().setAccessibleDescription(""String_Node_Str"");
  view.setMnemonic(KeyEvent.VK_V);
  if (parent != null) {
    JMenuItem apI=MenuCreator.getIcon(parent,ALIGNMENT_PANEL);
    apI.setMnemonic(KeyEvent.VK_M);
    apI.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_M,keyMask));
    view.add(apI);
    JMenuItem textI=MenuCreator.getIcon(parent,TEXT_ONLY);
    textI.setMnemonic(KeyEvent.VK_T);
    view.add(textI);
    JMenuItem pairsI=MenuCreator.getIcon(parent,PAIRS_ONLY);
    pairsI.setMnemonic(KeyEvent.VK_P);
    view.add(pairsI);
    JMenuItem textF=MenuCreator.getIcon(parent,FATCAT_TEXT);
    textF.setMnemonic(KeyEvent.VK_F);
    view.add(textF);
    JMenuItem distMax=new JMenuItem(DIST_MATRICES);
    distMax.setMnemonic(KeyEvent.VK_D);
    distMax.addActionListener(new MyDistMaxListener(parent));
    view.add(distMax);
    if (afpChain != null) {
      JMenuItem dotplot=new JMenuItem(DOT_PLOT);
      dotplot.setMnemonic(KeyEvent.VK_O);
      dotplot.addActionListener(new DotPlotListener(afpChain));
      view.add(dotplot);
    }
    if (afpChain == null) {
      JMenuItem tree=getIcon(parent,PHYLOGENETIC_TREE);
      tree.setMnemonic(KeyEvent.VK_T);
      view.add(tree);
    }
  }
  menu.add(view);
  JMenu about=new JMenu(""String_Node_Str"");
  about.setMnemonic(KeyEvent.VK_H);
  JMenuItem helpM=getHelpMenuItem();
  about.add(helpM);
  JMenuItem aboutM=getAboutMenuItem();
  about.add(aboutM);
  menu.add(Box.createGlue());
  menu.add(about);
  return menu;
}",0.9957132298595712
16532,"@Override public void actionPerformed(ActionEvent ae){
  String cmd=ae.getActionCommand();
  if (multAln == null) {
    logger.error(""String_Node_Str"");
    return;
  }
  try {
    if (cmd.equals(MenuCreator.TEXT_ONLY)) {
      logger.warn(""String_Node_Str"");
    }
 else     if (cmd.equals(MenuCreator.PAIRS_ONLY)) {
      String result=MultipleAlignmentWriter.toAlignedResidues(multAln);
      MultipleAlignmentJmolDisplay.showAlignmentImage(multAln,result);
    }
 else     if (cmd.equals(MenuCreator.ALIGNMENT_PANEL)) {
      MultipleAlignmentJmolDisplay.showMultipleAligmentPanel(multAln,this);
    }
 else     if (cmd.equals(MenuCreator.FATCAT_TEXT)) {
      String result=MultipleAlignmentWriter.toFatCat(multAln) + ""String_Node_Str"";
      result+=MultipleAlignmentWriter.toTransformMatrices(multAln);
      MultipleAlignmentJmolDisplay.showAlignmentImage(multAln,result);
    }
 else     if (cmd.equals(MenuCreator.PHYLOGENETIC_TREE)) {
      Phylogeny kimura=MultipleAlignmentTools.getKimuraTree(multAln);
      Phylogeny blosum=MultipleAlignmentTools.getFDSBLOSUM40Tree(multAln);
      Phylogeny structural=MultipleAlignmentTools.getStructuralTree(multAln);
      Archaeopteryx.createApplication(new Phylogeny[]{kimura,blosum,structural});
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
}","@Override public void actionPerformed(ActionEvent ae){
  String cmd=ae.getActionCommand();
  if (multAln == null) {
    logger.error(""String_Node_Str"");
    return;
  }
  try {
    if (cmd.equals(MenuCreator.TEXT_ONLY)) {
      logger.warn(""String_Node_Str"");
    }
 else     if (cmd.equals(MenuCreator.PAIRS_ONLY)) {
      String result=MultipleAlignmentWriter.toAlignedResidues(multAln);
      MultipleAlignmentJmolDisplay.showAlignmentImage(multAln,result);
    }
 else     if (cmd.equals(MenuCreator.ALIGNMENT_PANEL)) {
      MultipleAlignmentJmolDisplay.showMultipleAligmentPanel(multAln,this);
    }
 else     if (cmd.equals(MenuCreator.FATCAT_TEXT)) {
      String result=MultipleAlignmentWriter.toFatCat(multAln) + ""String_Node_Str"";
      result+=MultipleAlignmentWriter.toTransformMatrices(multAln);
      MultipleAlignmentJmolDisplay.showAlignmentImage(multAln,result);
    }
 else     if (cmd.equals(MenuCreator.PHYLOGENETIC_TREE)) {
      Phylogeny kimura=MultipleAlignmentTools.getKimuraTree(multAln);
      Phylogeny blosum=MultipleAlignmentTools.getBLOSUM40Tree(multAln);
      Phylogeny structural=MultipleAlignmentTools.getStructuralTree(multAln);
      Archaeopteryx.createApplication(new Phylogeny[]{kimura,blosum,structural});
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
}",0.9988709070380128
16533,"/** 
 * Calculate a phylogenetic tree of the MultipleAlignment using RMSD distances and the Neighbor Joining algorithm from forester.
 * @param msta MultipleAlignment of protein structures
 * @return Phylogeny phylogenetic tree
 * @throws CompoundNotFoundException
 */
public static Phylogeny getStructuralTree(MultipleAlignment msta){
  double[][] rmsdMat=MultipleAlignmentTools.getRMSDMatrix(msta).getArray();
  BasicSymmetricalDistanceMatrix rmsdDist=(BasicSymmetricalDistanceMatrix)DistanceMatrixCalculator.structuralDistance(rmsdMat,1,5,0.4);
  for (int i=0; i < msta.size(); i++)   rmsdDist.setIdentifier(i,msta.getStructureIdentifier(i).toString());
  Phylogeny tree=TreeConstructor.distanceTree(rmsdDist,TreeConstructorType.NJ);
  tree.setName(""String_Node_Str"");
  return tree;
}","/** 
 * Calculate a phylogenetic tree of the MultipleAlignment using RMSD distances and the Neighbor Joining algorithm from forester.
 * @param msta MultipleAlignment of protein structures
 * @return Phylogeny phylogenetic tree
 * @throws CompoundNotFoundException
 */
public static Phylogeny getStructuralTree(MultipleAlignment msta){
  double[][] rmsdMat=MultipleAlignmentTools.getRMSDMatrix(msta).getArray();
  BasicSymmetricalDistanceMatrix rmsdDist=(BasicSymmetricalDistanceMatrix)DistanceMatrixCalculator.structuralDistance(rmsdMat,1,5,0.4);
  Map<String,Integer> alreadySeen=new HashMap<String,Integer>();
  for (int i=0; i < msta.size(); i++) {
    String id=msta.getStructureIdentifier(i).toString();
    if (alreadySeen.containsKey(id)) {
      alreadySeen.put(id,alreadySeen.get(id) + 1);
      id+=""String_Node_Str"" + alreadySeen.get(id);
    }
 else     alreadySeen.put(id,1);
    rmsdDist.setIdentifier(i,id);
  }
  Phylogeny tree=TreeConstructor.distanceTree(rmsdDist,TreeConstructorType.NJ);
  tree.setName(""String_Node_Str"");
  return tree;
}",0.8067135896047645
16534,"/** 
 * Convert a MultipleAlignment into a MultipleSequenceAlignment of AminoAcid residues. This method is only valid for protein structure alignments.
 * @param msta Multiple Structure Alignment
 * @return MultipleSequenceAlignment of protein sequences
 * @throws CompoundNotFoundException
 */
public static MultipleSequenceAlignment<ProteinSequence,AminoAcidCompound> toProteinMSA(MultipleAlignment msta) throws CompoundNotFoundException {
  Group g=msta.getAtomArrays().get(0)[0].getGroup();
  if (!(g instanceof AminoAcid)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  MultipleSequenceAlignment<ProteinSequence,AminoAcidCompound> msa=new MultipleSequenceAlignment<ProteinSequence,AminoAcidCompound>();
  List<String> seqs=getSequenceAlignment(msta);
  for (int i=0; i < msta.size(); i++) {
    AccessionID id=new AccessionID(msta.getStructureIdentifier(i).toString());
    ProteinSequence pseq=new ProteinSequence(seqs.get(i));
    pseq.setAccession(id);
    msa.addAlignedSequence(pseq);
  }
  return msa;
}","/** 
 * Convert a MultipleAlignment into a MultipleSequenceAlignment of AminoAcid residues. This method is only valid for protein structure alignments.
 * @param msta Multiple Structure Alignment
 * @return MultipleSequenceAlignment of protein sequences
 * @throws CompoundNotFoundException
 */
public static MultipleSequenceAlignment<ProteinSequence,AminoAcidCompound> toProteinMSA(MultipleAlignment msta) throws CompoundNotFoundException {
  Group g=msta.getAtomArrays().get(0)[0].getGroup();
  if (!(g instanceof AminoAcid)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  MultipleSequenceAlignment<ProteinSequence,AminoAcidCompound> msa=new MultipleSequenceAlignment<ProteinSequence,AminoAcidCompound>();
  Map<String,Integer> uniqueID=new HashMap<String,Integer>();
  List<String> seqs=getSequenceAlignment(msta);
  for (int i=0; i < msta.size(); i++) {
    String id=msta.getStructureIdentifier(i).toString();
    if (uniqueID.containsKey(id)) {
      uniqueID.put(id,uniqueID.get(id) + 1);
      id+=""String_Node_Str"" + uniqueID.get(id);
    }
 else     uniqueID.put(id,1);
    AccessionID acc=new AccessionID(id);
    ProteinSequence pseq=new ProteinSequence(seqs.get(i));
    pseq.setAccession(acc);
    msa.addAlignedSequence(pseq);
  }
  return msa;
}",0.8373673036093419
16535,"/** 
 * Analyze the symmetries of the input Atom array using the provided parameters.
 * @param atoms representative Atom array of the Structure
 * @param param CeSymmParameters bean
 * @return CeSymmResult
 * @throws StructureException
 */
public static CeSymmResult analyze(Atom[] atoms,CESymmParameters params) throws StructureException {
  if (atoms.length < 1)   throw new IllegalArgumentException(""String_Node_Str"");
  if (params.getSSEThreshold() > 0) {
    Structure s=atoms[0].getGroup().getChain().getStructure();
    if (SecStrucTools.getSecStrucInfo(s).isEmpty()) {
      logger.info(""String_Node_Str"");
      SecStrucCalc ssp=new SecStrucCalc();
      ssp.calculate(s,true);
    }
  }
  CeSymmIterative iter=new CeSymmIterative(params);
  CeSymmResult result=iter.execute(atoms);
  if (result.isSignificant()) {
    if (params.getOptimization() && result.getSymmLevels() > 1) {
      try {
        SymmetryAxes axes=result.getAxes();
        result.setAxes(null);
        SymmOptimizer optimizer=new SymmOptimizer(result);
        MultipleAlignment optimized=optimizer.optimize();
        result.setMultipleAlignment(optimized);
        result.setAxes(axes);
      }
 catch (      RefinerFailedException e) {
        logger.info(""String_Node_Str"" + e.getMessage());
        return result;
      }
    }
  }
  return result;
}","/** 
 * Analyze the symmetries of the input Atom array using the provided parameters.
 * @param atoms representative Atom array of the Structure
 * @param param CeSymmParameters bean
 * @return CeSymmResult
 * @throws StructureException
 */
public static CeSymmResult analyze(Atom[] atoms,CESymmParameters params) throws StructureException {
  if (atoms.length < 1)   throw new IllegalArgumentException(""String_Node_Str"");
  if (params.getSSEThreshold() > 0) {
    Structure s=atoms[0].getGroup().getChain().getStructure();
    if (SecStrucTools.getSecStrucInfo(s).isEmpty()) {
      logger.info(""String_Node_Str"");
      SecStrucCalc ssp=new SecStrucCalc();
      ssp.calculate(s,true);
    }
  }
  CeSymmIterative iter=new CeSymmIterative(params);
  CeSymmResult result=iter.execute(atoms);
  if (result.isSignificant()) {
    if (params.getOptimization() && result.getSymmLevels() > 1) {
      SymmetryAxes axes=result.getAxes();
      result.setAxes(null);
      try {
        SymmOptimizer optimizer=new SymmOptimizer(result);
        MultipleAlignment optimized=optimizer.optimize();
        result.setMultipleAlignment(optimized);
        result.setAxes(axes);
      }
 catch (      RefinerFailedException e) {
        logger.info(""String_Node_Str"" + e.getMessage());
        result.setAxes(axes);
        return result;
      }
    }
  }
  return result;
}",0.9785344189489268
16536,"/** 
 * Tests if a PDB file can be parsed
 * @throws Exception 
 */
@Test public void testReadPDBFile() throws Exception {
  assertEquals(""String_Node_Str"",""String_Node_Str"",structure.getPDBCode());
  Chain c=structure.getChain(0);
  assertEquals(""String_Node_Str"",58,c.getAtomGroups(GroupType.AMINOACID).size());
  assertTrue(c.getAtomGroups(GroupType.HETATM).size() == 0);
  Chain c2=structure.getChain(1);
  assertTrue(c2.getAtomGroups(GroupType.HETATM).size() == 65);
  assertTrue(c2.getAtomGroups(GroupType.NUCLEOTIDE).size() == 0);
  List<Compound> compounds=structure.getCompounds();
  assertTrue(compounds.size() == 1);
  Compound mol=compounds.get(0);
  assertTrue(mol.getMolName().startsWith(""String_Node_Str""));
}","/** 
 * Tests if a PDB file can be parsed
 * @throws Exception 
 */
@Test public void testReadPDBFile() throws Exception {
  assertEquals(""String_Node_Str"",""String_Node_Str"",structure.getPDBCode());
  Chain c=structure.getChain(0);
  assertEquals(""String_Node_Str"",58,c.getAtomGroups(GroupType.AMINOACID).size());
  assertTrue(c.getAtomGroups(GroupType.HETATM).size() == 0);
  Chain c2=structure.getChain(1);
  assertTrue(c2.getAtomGroups(GroupType.HETATM).size() == 65);
  assertTrue(c2.getAtomGroups(GroupType.NUCLEOTIDE).size() == 0);
  List<Compound> compounds=structure.getCompounds();
  assertEquals(2,compounds.size());
  Compound mol=compounds.get(0);
  assertTrue(mol.getMolName().startsWith(""String_Node_Str""));
}",0.986869384934347
16537,"@Before public void setUp() throws IOException {
  InputStream inStream=StructureTest.class.getResourceAsStream(""String_Node_Str"");
  assertNotNull(inStream);
  PDBFileParser pdbpars=new PDBFileParser();
  FileParsingParameters params=new FileParsingParameters();
  params.setAlignSeqRes(true);
  pdbpars.setFileParsingParameters(params);
  structure=pdbpars.parsePDBFile(inStream);
  assertNotNull(structure);
  assertEquals(""String_Node_Str"",2,structure.size());
}","@BeforeClass public static void setUp() throws IOException {
  InputStream inStream=StructureTest.class.getResourceAsStream(""String_Node_Str"");
  assertNotNull(inStream);
  PDBFileParser pdbpars=new PDBFileParser();
  FileParsingParameters params=new FileParsingParameters();
  params.setAlignSeqRes(true);
  pdbpars.setFileParsingParameters(params);
  structure=pdbpars.parsePDBFile(inStream);
  assertNotNull(structure);
  assertEquals(""String_Node_Str"",2,structure.size());
}",0.9872881355932204
16538,"@Test public void testPDBHeader(){
  PDBHeader header=structure.getPDBHeader();
  String classification=header.getClassification();
  assertTrue(classification.equals(""String_Node_Str""));
  String idCode=header.getIdCode();
  assertEquals(""String_Node_Str"" + idCode + ""String_Node_Str"",""String_Node_Str"",idCode);
  float resolution=header.getResolution();
  assertEquals(""String_Node_Str"" + resolution + ""String_Node_Str"",1.0,resolution,0.0001);
  String techShould=""String_Node_Str"";
  Set<ExperimentalTechnique> techniques=header.getExperimentalTechniques();
  String technique=techniques.iterator().next().getName();
  assertEquals(""String_Node_Str"" + technique,techShould,technique);
  List<Compound> compounds=structure.getCompounds();
  assertEquals(""String_Node_Str"",1,compounds.size());
  Compound comp=compounds.get(0);
  assertEquals(""String_Node_Str"",true,comp.getMolName().startsWith(""String_Node_Str""));
  List<String> chainIds=comp.getChainIds();
  List<Chain> chains=comp.getChains();
  assertEquals(""String_Node_Str"",chainIds.size(),chains.size());
  assertEquals(""String_Node_Str"",chainIds.get(0),chains.get(0).getChainID());
}","@Test public void testPDBHeader(){
  PDBHeader header=structure.getPDBHeader();
  String classification=header.getClassification();
  assertTrue(classification.equals(""String_Node_Str""));
  String idCode=header.getIdCode();
  assertEquals(""String_Node_Str"" + idCode + ""String_Node_Str"",""String_Node_Str"",idCode);
  float resolution=header.getResolution();
  assertEquals(""String_Node_Str"" + resolution + ""String_Node_Str"",1.0,resolution,0.0001);
  String techShould=""String_Node_Str"";
  Set<ExperimentalTechnique> techniques=header.getExperimentalTechniques();
  String technique=techniques.iterator().next().getName();
  assertEquals(""String_Node_Str"" + technique,techShould,technique);
  List<Compound> compounds=structure.getCompounds();
  assertEquals(""String_Node_Str"",2,compounds.size());
  Compound comp=compounds.get(0);
  assertEquals(""String_Node_Str"",true,comp.getMolName().startsWith(""String_Node_Str""));
  List<String> chainIds=comp.getChainIds();
  List<Chain> chains=comp.getChains();
  assertEquals(""String_Node_Str"",chainIds.size(),chains.size());
  assertEquals(""String_Node_Str"",chainIds.get(0),chains.get(0).getChainID());
}",0.9991258741258742
16539,"/** 
 * Utility method that employs some heuristics to find the Compounds for this Structure in case the information is missing in PDB/mmCIF file
 * @return
 */
public List<Compound> findCompounds(){
  TreeMap<String,Compound> chainIds2entities=findCompoundsFromAlignment();
  return findUniqueCompounds(chainIds2entities);
}","/** 
 * Utility method that employs some heuristics to find the Compounds for this Structure in case the information is missing in PDB/mmCIF file
 * @return
 */
public List<Compound> findCompounds(){
  TreeMap<String,Compound> chainIds2entities=findCompoundsFromAlignment();
  List<Compound> compounds=findUniqueCompounds(chainIds2entities);
  createPurelyNonPolyCompounds(compounds);
  return compounds;
}",0.8700410396716827
16540,"private TreeMap<String,Compound> findCompoundsFromAlignment(){
  Set<Integer> polyChainIndices=new TreeSet<Integer>();
  for (int i=0; i < s.getChains().size(); i++) {
    if (StructureTools.isChainPureNonPolymer(s.getChain(i))) {
      logger.warn(""String_Node_Str"",s.getChain(i).getChainID());
      continue;
    }
    polyChainIndices.add(i);
  }
  TreeMap<String,Compound> chainIds2compounds=new TreeMap<String,Compound>();
  int molId=1;
  outer:   for (  int i : polyChainIndices) {
    for (    int j : polyChainIndices) {
      if (j <= i)       continue;
      Chain c1=s.getChain(i);
      Chain c2=s.getChain(j);
      Map<Integer,Integer> positionIndex1=new HashMap<Integer,Integer>();
      Map<Integer,Integer> positionIndex2=new HashMap<Integer,Integer>();
      String str1=SeqRes2AtomAligner.getFullAtomSequence(c1.getAtomGroups(),positionIndex1);
      String str2=SeqRes2AtomAligner.getFullAtomSequence(c2.getAtomGroups(),positionIndex2);
      int seq1Length=0;
      int seq2Length=0;
      SequencePair<?,?> pair=null;
      if (isProteinSequence(str1) && isProteinSequence(str2)) {
        ProteinSequence s1=getProteinSequence(str1);
        ProteinSequence s2=getProteinSequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignProtein(s1,s2);
      }
 else       if (isDNASequence(str1) && isDNASequence(str2)) {
        DNASequence s1=getDNASequence(str1);
        DNASequence s2=getDNASequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignDNA(s1,s2);
      }
 else       if (isRNASequence(str1) && isRNASequence(str2)) {
        RNASequence s1=getRNASequence(str1);
        RNASequence s2=getRNASequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignRNA(s1,s2);
      }
 else {
        logger.debug(""String_Node_Str"");
        continue;
      }
      int numGaps=getNumGaps(pair);
      int numGaps1=getNumGapsQuery(pair);
      int numGaps2=getNumGapsTarget(pair);
      int nonGaps=pair.getLength() - numGaps;
      double identity=(double)pair.getNumIdenticals() / (double)nonGaps;
      double gapCov1=(double)numGaps1 / (double)seq1Length;
      double gapCov2=(double)numGaps2 / (double)seq2Length;
      logger.debug(""String_Node_Str"",c1.getChainID(),c2.getChainID(),String.format(""String_Node_Str"",identity),String.format(""String_Node_Str"",gapCov1),String.format(""String_Node_Str"",gapCov2));
      logger.debug(""String_Node_Str"" + pair.toString(100));
      if (identity > IDENTITY_THRESHOLD && gapCov1 < GAP_COVERAGE_THRESHOLD && gapCov2 < GAP_COVERAGE_THRESHOLD) {
        if (!chainIds2compounds.containsKey(c1.getChainID()) && !chainIds2compounds.containsKey(c2.getChainID())) {
          logger.debug(""String_Node_Str"",c1.getChainID(),c2.getChainID());
          Compound ent=new Compound();
          ent.addChain(c1);
          ent.addChain(c2);
          ent.setMolId(molId++);
          chainIds2compounds.put(c1.getChainID(),ent);
          chainIds2compounds.put(c2.getChainID(),ent);
        }
 else {
          Compound ent=chainIds2compounds.get(c1.getChainID());
          if (ent == null) {
            logger.debug(""String_Node_Str"",c1.getChainID(),c2.getChainID());
            ent=chainIds2compounds.get(c2.getChainID());
            ent.addChain(c1);
            chainIds2compounds.put(c1.getChainID(),ent);
          }
 else {
            logger.debug(""String_Node_Str"",c2.getChainID(),c1.getChainID());
            ent.addChain(c2);
            chainIds2compounds.put(c2.getChainID(),ent);
          }
        }
        if (!areResNumbersAligned(c1,c2)) {
          logger.warn(""String_Node_Str"",c1.getChainID(),c2.getChainID());
        }
      }
      if (identity > 1) {
        logger.warn(""String_Node_Str"",c1.getChainID(),c2.getChainID(),pair.getNumIdenticals(),nonGaps,identity);
        logger.warn(""String_Node_Str"" + pair.toString(100));
      }
      if (chainIds2compounds.size() == polyChainIndices.size())       break outer;
    }
  }
  for (  int i : polyChainIndices) {
    Chain c=s.getChain(i);
    if (!chainIds2compounds.containsKey(c.getChainID())) {
      logger.debug(""String_Node_Str"",c.getChainID());
      Compound ent=new Compound();
      ent.addChain(c);
      ent.setMolId(molId++);
      chainIds2compounds.put(c.getChainID(),ent);
    }
  }
  return chainIds2compounds;
}","private TreeMap<String,Compound> findCompoundsFromAlignment(){
  Set<Integer> polyChainIndices=new TreeSet<Integer>();
  List<Chain> pureNonPolymerChains=new ArrayList<Chain>();
  for (int i=0; i < s.getChains().size(); i++) {
    if (StructureTools.isChainPureNonPolymer(s.getChain(i))) {
      pureNonPolymerChains.add(s.getChain(i));
    }
 else {
      polyChainIndices.add(i);
    }
  }
  TreeMap<String,Compound> chainIds2compounds=new TreeMap<String,Compound>();
  int molId=1;
  outer:   for (  int i : polyChainIndices) {
    for (    int j : polyChainIndices) {
      if (j <= i)       continue;
      Chain c1=s.getChain(i);
      Chain c2=s.getChain(j);
      Map<Integer,Integer> positionIndex1=new HashMap<Integer,Integer>();
      Map<Integer,Integer> positionIndex2=new HashMap<Integer,Integer>();
      String str1=SeqRes2AtomAligner.getFullAtomSequence(c1.getAtomGroups(),positionIndex1);
      String str2=SeqRes2AtomAligner.getFullAtomSequence(c2.getAtomGroups(),positionIndex2);
      int seq1Length=0;
      int seq2Length=0;
      SequencePair<?,?> pair=null;
      if (isProteinSequence(str1) && isProteinSequence(str2)) {
        ProteinSequence s1=getProteinSequence(str1);
        ProteinSequence s2=getProteinSequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignProtein(s1,s2);
      }
 else       if (isDNASequence(str1) && isDNASequence(str2)) {
        DNASequence s1=getDNASequence(str1);
        DNASequence s2=getDNASequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignDNA(s1,s2);
      }
 else       if (isRNASequence(str1) && isRNASequence(str2)) {
        RNASequence s1=getRNASequence(str1);
        RNASequence s2=getRNASequence(str2);
        seq1Length=s1.getLength();
        seq2Length=s2.getLength();
        pair=alignRNA(s1,s2);
      }
 else {
        logger.debug(""String_Node_Str"");
        continue;
      }
      int numGaps=getNumGaps(pair);
      int numGaps1=getNumGapsQuery(pair);
      int numGaps2=getNumGapsTarget(pair);
      int nonGaps=pair.getLength() - numGaps;
      double identity=(double)pair.getNumIdenticals() / (double)nonGaps;
      double gapCov1=(double)numGaps1 / (double)seq1Length;
      double gapCov2=(double)numGaps2 / (double)seq2Length;
      logger.debug(""String_Node_Str"",c1.getChainID(),c2.getChainID(),String.format(""String_Node_Str"",identity),String.format(""String_Node_Str"",gapCov1),String.format(""String_Node_Str"",gapCov2));
      logger.debug(""String_Node_Str"" + pair.toString(100));
      if (identity > IDENTITY_THRESHOLD && gapCov1 < GAP_COVERAGE_THRESHOLD && gapCov2 < GAP_COVERAGE_THRESHOLD) {
        if (!chainIds2compounds.containsKey(c1.getChainID()) && !chainIds2compounds.containsKey(c2.getChainID())) {
          logger.debug(""String_Node_Str"",c1.getChainID(),c2.getChainID());
          Compound ent=new Compound();
          ent.addChain(c1);
          ent.addChain(c2);
          ent.setMolId(molId++);
          chainIds2compounds.put(c1.getChainID(),ent);
          chainIds2compounds.put(c2.getChainID(),ent);
        }
 else {
          Compound ent=chainIds2compounds.get(c1.getChainID());
          if (ent == null) {
            logger.debug(""String_Node_Str"",c1.getChainID(),c2.getChainID());
            ent=chainIds2compounds.get(c2.getChainID());
            ent.addChain(c1);
            chainIds2compounds.put(c1.getChainID(),ent);
          }
 else {
            logger.debug(""String_Node_Str"",c2.getChainID(),c1.getChainID());
            ent.addChain(c2);
            chainIds2compounds.put(c2.getChainID(),ent);
          }
        }
        if (!areResNumbersAligned(c1,c2)) {
          logger.warn(""String_Node_Str"",c1.getChainID(),c2.getChainID());
        }
      }
      if (identity > 1) {
        logger.warn(""String_Node_Str"",c1.getChainID(),c2.getChainID(),pair.getNumIdenticals(),nonGaps,identity);
        logger.warn(""String_Node_Str"" + pair.toString(100));
      }
      if (chainIds2compounds.size() == polyChainIndices.size())       break outer;
    }
  }
  for (  int i : polyChainIndices) {
    Chain c=s.getChain(i);
    if (!chainIds2compounds.containsKey(c.getChainID())) {
      logger.debug(""String_Node_Str"",c.getChainID());
      Compound ent=new Compound();
      ent.addChain(c);
      ent.setMolId(molId++);
      chainIds2compounds.put(c.getChainID(),ent);
    }
  }
  return chainIds2compounds;
}",0.9793337097684924
16541,"private static int findMaxCompoundId(List<Compound> compounds){
  List<Integer> allIds=new ArrayList<Integer>(compounds.size());
  for (  Compound compound : compounds) {
    allIds.add(compound.getMolId());
  }
  return Collections.max(allIds);
}","private static int findMaxCompoundId(List<Compound> compounds){
  return Collections.max(compounds,new Comparator<Compound>(){
    @Override public int compare(    Compound o1,    Compound o2){
      return new Integer(o1.getMolId()).compareTo(o2.getMolId());
    }
  }
).getMolId();
}",0.3120300751879699
16542,"@Override public void documentEnd(){
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
 else   if (!params.isHeaderOnly()) {
    logger.warn(""String_Node_Str"");
  }
  structure.addModel(current_model);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    asymId2entityId.put(asym.getId(),asym.getEntity_id());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setChainID(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    addCompounds(asym);
  }
  if (structAsyms.isEmpty()) {
    logger.warn(""String_Node_Str"");
  }
  if (params.isAlignSeqRes() && !params.isHeaderOnly()) {
    logger.debug(""String_Node_Str"");
    alignSeqRes();
  }
 else {
    logger.debug(""String_Node_Str"");
    SeqRes2AtomAligner.storeUnAlignedSeqRes(structure,seqResChains,params.isHeaderOnly());
  }
  if (!params.isHeaderOnly()) {
    if (params.shouldCreateAtomBonds()) {
      addBonds();
    }
    if (params.isCreateLigandConects()) {
      addLigandConnections();
    }
    if (params.shouldCreateAtomCharges()) {
      addCharges();
    }
  }
  boolean noAsymStrandIdMappingPresent=false;
  if (asymStrandId.isEmpty()) {
    logger.warn(""String_Node_Str"");
    asymStrandId=asymId2StrandIdFromAtomSites;
    noAsymStrandIdMappingPresent=true;
  }
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> model=structure.getModel(i);
    List<Chain> pdbChains=new ArrayList<Chain>();
    for (    Chain chain : model) {
      for (      String asym : asymStrandId.keySet()) {
        if (chain.getChainID().equals(asym)) {
          String newChainId=asymStrandId.get(asym);
          logger.debug(""String_Node_Str"",asym,chain.getAtomGroups().size(),newChainId);
          chain.setChainID(newChainId);
          chain.setInternalChainID(asym);
          for (          Group g : chain.getAtomGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          for (          Group g : chain.getSeqResGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          Chain known=isKnownChain(chain.getChainID(),pdbChains);
          if (known == null) {
            pdbChains.add(chain);
          }
 else {
            for (            Group g : chain.getAtomGroups()) {
              known.addGroup(g);
            }
          }
          break;
        }
      }
    }
    structure.setModel(i,pdbChains);
    Iterator<Chain> it=pdbChains.iterator();
    while (it.hasNext()) {
      Chain chain=it.next();
      String entityId=asymId2entityId.get(chain.getInternalChainID());
      if (entityId == null) {
        logger.warn(""String_Node_Str"",chain.getInternalChainID());
        continue;
      }
      int eId=Integer.parseInt(entityId);
      Compound compound=structure.getCompoundById(eId);
      if (compound == null) {
        logger.warn(""String_Node_Str"",eId,chain.getChainID());
        compound=new Compound();
        compound.setId((long)eId);
        compound.addChain(chain);
        chain.setCompound(compound);
        structure.addCompound(compound);
      }
 else {
        logger.debug(""String_Node_Str"",chain.getChainID(),chain.getInternalChainID(),eId);
        compound.addChain(chain);
        chain.setCompound(compound);
      }
    }
    if (noAsymStrandIdMappingPresent) {
      it=pdbChains.iterator();
      while (it.hasNext()) {
        Chain chain=it.next();
        if (StructureTools.isChainWaterOnly(chain)) {
          it.remove();
          logger.warn(""String_Node_Str"",chain.getChainID(),chain.getInternalChainID(),chain.getAtomGroups().size());
        }
      }
    }
  }
  if (!params.isHeaderOnly()) {
    createSSBonds();
    addSites();
  }
  List<Compound> compounds=structure.getCompounds();
  for (  Compound compound : compounds) {
    if (compound.getChains().isEmpty()) {
      logger.info(""String_Node_Str"",compound.getId() == null ? ""String_Node_Str"" : compound.getId(),compound.getMolName());
    }
  }
  if (params.isParseBioAssembly()) {
    Map<Integer,BioAssemblyInfo> bioAssemblies=new HashMap<Integer,BioAssemblyInfo>();
    for (    PdbxStructAssembly psa : strucAssemblies) {
      List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
      for (      PdbxStructAssemblyGen psag : strucAssemblyGens) {
        if (psag.getAssembly_id().equals(psa.getId())) {
          psags.add(psag);
        }
      }
      BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
      List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
      int mmSize=0;
      int bioAssemblyId=-1;
      try {
        bioAssemblyId=Integer.parseInt(psa.getId());
      }
 catch (      NumberFormatException e) {
        logger.info(""String_Node_Str"",psa.getId());
      }
      try {
        mmSize=Integer.parseInt(psa.getOligomeric_count());
      }
 catch (      NumberFormatException e) {
        if (bioAssemblyId != -1)         logger.warn(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
 else         logger.info(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
      }
      if (bioAssemblyId != -1) {
        BioAssemblyInfo bioAssembly=new BioAssemblyInfo();
        bioAssembly.setId(bioAssemblyId);
        bioAssembly.setMacromolecularSize(mmSize);
        bioAssembly.setTransforms(transformations);
        bioAssemblies.put(bioAssemblyId,bioAssembly);
      }
    }
    structure.getPDBHeader().setBioAssemblies(bioAssemblies);
  }
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators(ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
  Map<String,List<SeqMisMatch>> misMatchMap=new HashMap<String,List<SeqMisMatch>>();
  for (  StructRefSeqDif sdif : sequenceDifs) {
    SeqMisMatch misMatch=new SeqMisMatchImpl();
    misMatch.setDetails(sdif.getDetails());
    String insCode=sdif.getPdbx_pdb_ins_code();
    if (insCode != null && insCode.equals(""String_Node_Str""))     insCode=null;
    misMatch.setInsCode(insCode);
    misMatch.setOrigGroup(sdif.getDb_mon_id());
    misMatch.setPdbGroup(sdif.getMon_id());
    misMatch.setPdbResNum(sdif.getPdbx_auth_seq_num());
    misMatch.setUniProtId(sdif.getPdbx_seq_db_accession_code());
    misMatch.setSeqNum(sdif.getSeq_num());
    List<SeqMisMatch> mms=misMatchMap.get(sdif.getPdbx_pdb_strand_id());
    if (mms == null) {
      mms=new ArrayList<SeqMisMatch>();
      misMatchMap.put(sdif.getPdbx_pdb_strand_id(),mms);
    }
    mms.add(misMatch);
  }
  for (  String chainId : misMatchMap.keySet()) {
    try {
      Chain c=structure.getChainByPDB(chainId);
      c.setSeqMisMatches(misMatchMap.get(chainId));
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + chainId);
    }
  }
}","@Override public void documentEnd(){
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
 else   if (!params.isHeaderOnly()) {
    logger.warn(""String_Node_Str"");
  }
  structure.addModel(current_model);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    asymId2entityId.put(asym.getId(),asym.getEntity_id());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setChainID(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    addCompounds(asym);
  }
  if (structAsyms.isEmpty()) {
    logger.warn(""String_Node_Str"");
  }
  if (params.isAlignSeqRes() && !params.isHeaderOnly()) {
    logger.debug(""String_Node_Str"");
    alignSeqRes();
  }
 else {
    logger.debug(""String_Node_Str"");
    SeqRes2AtomAligner.storeUnAlignedSeqRes(structure,seqResChains,params.isHeaderOnly());
  }
  if (!params.isHeaderOnly()) {
    if (params.shouldCreateAtomBonds()) {
      addBonds();
    }
    if (params.isCreateLigandConects()) {
      addLigandConnections();
    }
    if (params.shouldCreateAtomCharges()) {
      addCharges();
    }
  }
  if (asymStrandId.isEmpty()) {
    logger.warn(""String_Node_Str"");
    asymStrandId=asymId2StrandIdFromAtomSites;
  }
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> model=structure.getModel(i);
    List<Chain> pdbChains=new ArrayList<Chain>();
    for (    Chain chain : model) {
      for (      String asym : asymStrandId.keySet()) {
        if (chain.getChainID().equals(asym)) {
          String newChainId=asymStrandId.get(asym);
          logger.debug(""String_Node_Str"",asym,chain.getAtomGroups().size(),newChainId);
          chain.setChainID(newChainId);
          chain.setInternalChainID(asym);
          for (          Group g : chain.getAtomGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          for (          Group g : chain.getSeqResGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          Chain known=isKnownChain(chain.getChainID(),pdbChains);
          if (known == null) {
            pdbChains.add(chain);
          }
 else {
            for (            Group g : chain.getAtomGroups()) {
              known.addGroup(g);
            }
          }
          break;
        }
      }
    }
    structure.setModel(i,pdbChains);
  }
  linkCompounds();
  if (!params.isHeaderOnly()) {
    createSSBonds();
    addSites();
  }
  if (params.isParseBioAssembly()) {
    Map<Integer,BioAssemblyInfo> bioAssemblies=new HashMap<Integer,BioAssemblyInfo>();
    for (    PdbxStructAssembly psa : strucAssemblies) {
      List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
      for (      PdbxStructAssemblyGen psag : strucAssemblyGens) {
        if (psag.getAssembly_id().equals(psa.getId())) {
          psags.add(psag);
        }
      }
      BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
      List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
      int mmSize=0;
      int bioAssemblyId=-1;
      try {
        bioAssemblyId=Integer.parseInt(psa.getId());
      }
 catch (      NumberFormatException e) {
        logger.info(""String_Node_Str"",psa.getId());
      }
      try {
        mmSize=Integer.parseInt(psa.getOligomeric_count());
      }
 catch (      NumberFormatException e) {
        if (bioAssemblyId != -1)         logger.warn(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
 else         logger.info(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
      }
      if (bioAssemblyId != -1) {
        BioAssemblyInfo bioAssembly=new BioAssemblyInfo();
        bioAssembly.setId(bioAssemblyId);
        bioAssembly.setMacromolecularSize(mmSize);
        bioAssembly.setTransforms(transformations);
        bioAssemblies.put(bioAssemblyId,bioAssembly);
      }
    }
    structure.getPDBHeader().setBioAssemblies(bioAssemblies);
  }
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators(ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
  Map<String,List<SeqMisMatch>> misMatchMap=new HashMap<String,List<SeqMisMatch>>();
  for (  StructRefSeqDif sdif : sequenceDifs) {
    SeqMisMatch misMatch=new SeqMisMatchImpl();
    misMatch.setDetails(sdif.getDetails());
    String insCode=sdif.getPdbx_pdb_ins_code();
    if (insCode != null && insCode.equals(""String_Node_Str""))     insCode=null;
    misMatch.setInsCode(insCode);
    misMatch.setOrigGroup(sdif.getDb_mon_id());
    misMatch.setPdbGroup(sdif.getMon_id());
    misMatch.setPdbResNum(sdif.getPdbx_auth_seq_num());
    misMatch.setUniProtId(sdif.getPdbx_seq_db_accession_code());
    misMatch.setSeqNum(sdif.getSeq_num());
    List<SeqMisMatch> mms=misMatchMap.get(sdif.getPdbx_pdb_strand_id());
    if (mms == null) {
      mms=new ArrayList<SeqMisMatch>();
      misMatchMap.put(sdif.getPdbx_pdb_strand_id(),mms);
    }
    mms.add(misMatch);
  }
  for (  String chainId : misMatchMap.keySet()) {
    try {
      Chain c=structure.getChainByPDB(chainId);
      c.setSeqMisMatches(misMatchMap.get(chainId));
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + chainId);
    }
  }
}",0.8572066706372841
16543,"private void testStructureMethods(Structure sPdb,Structure sCif){
  assertEquals(""String_Node_Str"",sPdb.isNmr(),sCif.isNmr());
  assertEquals(""String_Node_Str"",sPdb.isCrystallographic(),sCif.isCrystallographic());
  assertEquals(""String_Node_Str"",sPdb.nrModels(),sCif.nrModels());
  assertEquals(""String_Node_Str"",sPdb.getPDBCode(),sCif.getPDBCode());
  assertFalse(sPdb.isBiologicalAssembly());
  assertFalse(sCif.isBiologicalAssembly());
  boolean canCompareCompoundsSize=true;
  for (  Compound compound : sCif.getCompounds()) {
    if (compound.getMolName() == null || compound.getMolName().contains(""String_Node_Str"")) {
      canCompareCompoundsSize=false;
      break;
    }
  }
  if (canCompareCompoundsSize)   assertEquals(""String_Node_Str"",sPdb.getCompounds().size(),sCif.getCompounds().size());
}","private void testStructureMethods(Structure sPdb,Structure sCif){
  assertEquals(""String_Node_Str"",sPdb.isNmr(),sCif.isNmr());
  assertEquals(""String_Node_Str"",sPdb.isCrystallographic(),sCif.isCrystallographic());
  assertEquals(""String_Node_Str"",sPdb.nrModels(),sCif.nrModels());
  assertEquals(""String_Node_Str"",sPdb.getPDBCode(),sCif.getPDBCode());
  assertFalse(sPdb.isBiologicalAssembly());
  assertFalse(sCif.isBiologicalAssembly());
  boolean canCompareCompoundsSize=true;
  for (  Compound compound : sCif.getCompounds()) {
    if (compound.getMolName() == null || compound.getMolName().contains(""String_Node_Str"")) {
      canCompareCompoundsSize=false;
      break;
    }
  }
  if (canCompareCompoundsSize)   assertEquals(""String_Node_Str"",sPdb.getCompounds().size(),sCif.getCompounds().size());
  if (!sPdb.getPDBCode().equals(""String_Node_Str"") && !sPdb.getPDBCode().equals(""String_Node_Str""))   assertEquals(""String_Node_Str"",sPdb.getSSBonds().size(),sCif.getSSBonds().size());
}",0.8971650917176209
16544,"/** 
 * get residue number for first CYS. number and insertion code are joint together.
 * @return the residue number of the first CYS.
 */
public String getResnum1();","/** 
 * Get residue number for first CYS. number and insertion code are joined together.
 * @return the residue number of the first CYS.
 */
public String getResnum1();",0.9850746268656716
16545,"/** 
 * get residue number for second CYS. number and insertion code are joint together.
 * @return the residue number of the second CYS.
 */
public String getResnum2();","/** 
 * Get residue number for second CYS. number and insertion code are joined together.
 * @return the residue number of the second CYS.
 */
public String getResnum2();",0.9852507374631267
16546,"/** 
 * set serial number of this SSBOND in PDB file
 * @return the serial number
 */
public int getSerNum();","/** 
 * Set serial number of this SSBOND in PDB file
 * @return the serial number
 */
public int getSerNum();",0.9908256880733946
16547,"/** 
 * append the PDB representation of this SSBOND to the provided StringBUffer
 * @param buf a StringBuffer to print the PDB representation to
 */
@Override public void toPDB(StringBuffer buf);","/** 
 * Append the PDB representation of this SSBOND to the provided StringBUffer
 * @param buf a StringBuffer to print the PDB representation to
 */
@Override public void toPDB(StringBuffer buf);",0.9948979591836736
16548,"/** 
 * get serial number of this SSBOND in PDB file
 * @param serNum
 */
public void setSerNum(int serNum);","/** 
 * Get serial number of this SSBOND in PDB file
 * @param serNum
 */
public void setSerNum(int serNum);",0.9907407407407408
16549,"/** 
 * get residue number for first CYS. number and insertion code are joint together.
 * @return the residue number of the first CYS.
 */
@Override public String getResnum1(){
  return resnum1;
}","@Override public String getResnum1(){
  return resnum1;
}",0.4488188976377952
16550,"/** 
 * get residue number for second CYS. number and insertion code are joint together.
 * @return the residue number of the second CYS.
 */
@Override public String getResnum2(){
  return resnum2;
}","@Override public String getResnum2(){
  return resnum2;
}",0.4453125
16551,"/** 
 * set serial number of this SSBOND in PDB file
 * @return the serial number
 */
@Override public int getSerNum(){
  return serNum;
}","@Override public int getSerNum(){
  return serNum;
}",0.5473684210526316
16552,"/** 
 * append the PDB representation of this SSBOND to the provided StringBUffer
 * @param buf a StringBuffer to print the PDB representation to
 */
@Override public void toPDB(StringBuffer buf){
  buf.append(""String_Node_Str"");
  buf.append(String.format(""String_Node_Str"",serNum));
  buf.append(String.format(""String_Node_Str"",chainID1,resnum1,insCode1));
  buf.append(String.format(""String_Node_Str"",chainID2,resnum2,insCode2));
}","/** 
 * Append the PDB representation of this SSBOND to the provided StringBuffer
 * @param buf a StringBuffer to print the PDB representation to
 */
@Override public void toPDB(StringBuffer buf){
  buf.append(""String_Node_Str"");
  buf.append(String.format(""String_Node_Str"",serNum));
  buf.append(String.format(""String_Node_Str"",chainID1,resnum1,insCode1));
  buf.append(String.format(""String_Node_Str"",chainID2,resnum2,insCode2));
}",0.9953917050691244
16553,"private void pdb_SSBOND_Handler(String line){
  if (params.isHeaderOnly())   return;
  if (line.length() < 36) {
    logger.info(""String_Node_Str"");
    return;
  }
  String chain1=line.substring(15,16);
  String seqNum1=line.substring(17,21).trim();
  String icode1=line.substring(21,22);
  String chain2=line.substring(29,30);
  String seqNum2=line.substring(31,35).trim();
  String icode2=line.substring(35,36);
  if (icode1.equals(""String_Node_Str""))   icode1=""String_Node_Str"";
  if (icode2.equals(""String_Node_Str""))   icode2=""String_Node_Str"";
  SSBond ssbond=new SSBondImpl();
  ssbond.setChainID1(chain1);
  ssbond.setResnum1(seqNum1);
  ssbond.setChainID2(chain2);
  ssbond.setResnum2(seqNum2);
  ssbond.setInsCode1(icode1);
  ssbond.setInsCode2(icode2);
  structure.addSSBond(ssbond);
}","/** 
 * Process the disulfide bond info provided by an SSBOND record COLUMNS        DATA TYPE       FIELD         DEFINITION ------------------------------------------------------------------- 1 -  6        Record name     ""SSBOND"" 8 - 10        Integer         serNum       Serial number. 12 - 14        LString(3)      ""CYS""        Residue name. 16             Character       chainID1     Chain identifier. 18 - 21        Integer         seqNum1      Residue sequence number. 22             AChar           icode1       Insertion code. 26 - 28        LString(3)      ""CYS""        Residue name. 30             Character       chainID2     Chain identifier. 32 - 35        Integer         seqNum2      Residue sequence number. 36             AChar           icode2       Insertion code. 60 - 65        SymOP           sym1         Symmetry oper for 1st resid 67 - 72        SymOP           sym2         Symmetry oper for 2nd resid
 */
private void pdb_SSBOND_Handler(String line){
  if (params.isHeaderOnly())   return;
  if (line.length() < 36) {
    logger.info(""String_Node_Str"");
    return;
  }
  String chain1=line.substring(15,16);
  String seqNum1=line.substring(17,21).trim();
  String icode1=line.substring(21,22);
  String chain2=line.substring(29,30);
  String seqNum2=line.substring(31,35).trim();
  String icode2=line.substring(35,36);
  if (line.length() >= 72) {
    String symop1=line.substring(59,65).trim();
    String symop2=line.substring(66,72).trim();
    if (!symop1.equals(""String_Node_Str"") && !symop2.equals(""String_Node_Str"") && (!symop1.equals(""String_Node_Str"") || !symop2.equals(""String_Node_Str""))) {
      logger.info(""String_Node_Str"",seqNum1 + icode1,seqNum2 + icode2);
      return;
    }
  }
  if (icode1.equals(""String_Node_Str""))   icode1=""String_Node_Str"";
  if (icode2.equals(""String_Node_Str""))   icode2=""String_Node_Str"";
  SSBond ssbond=new SSBondImpl();
  ssbond.setChainID1(chain1);
  ssbond.setResnum1(seqNum1);
  ssbond.setChainID2(chain2);
  ssbond.setResnum2(seqNum2);
  ssbond.setInsCode1(icode1);
  ssbond.setInsCode2(icode2);
  structure.addSSBond(ssbond);
}",0.547954623581987
16554,"/** 
 * Lookup a residue - not found exceptions are handled with logger warnings.
 * @param chainId
 * @param seqId
 * @return Successful = Group, Failure = null
 */
Group lookupResidue(String chainId,String seqId){
  try {
    Chain chain=structure.getChainByPDB(chainId);
    if (null != chain) {
      try {
        return chain.getGroupByPDB(new ResidueNumber(chainId,Integer.parseInt(seqId),' '));
      }
 catch (      NumberFormatException e) {
        logger.warn(""String_Node_Str"" + chainId + seqId);
      }
    }
  }
 catch (  StructureException e) {
    logger.warn(""String_Node_Str"" + chainId + seqId+ ""String_Node_Str""+ e.getMessage(),e.getMessage());
  }
  return null;
}","/** 
 * Lookup a residue - not found exceptions are handled with logger warnings.
 * @param chainId
 * @param seqId
 * @return Successful = Group, Failure = null
 */
private Group lookupResidue(String chainId,String seqId){
  try {
    Chain chain=structure.getChainByPDB(chainId);
    if (null != chain) {
      try {
        ResidueNumber resNum=null;
        if (Character.isAlphabetic(seqId.charAt(seqId.length() - 1))) {
          resNum=new ResidueNumber(chainId,Integer.parseInt(seqId.substring(0,seqId.length() - 1)),seqId.charAt(seqId.length() - 1));
        }
 else {
          resNum=new ResidueNumber(chainId,Integer.parseInt(seqId),' ');
        }
        return chain.getGroupByPDB(resNum);
      }
 catch (      NumberFormatException e) {
        logger.warn(""String_Node_Str"",chainId + ""String_Node_Str"" + seqId);
      }
    }
  }
 catch (  StructureException e) {
    logger.warn(""String_Node_Str"" + chainId + ""String_Node_Str""+ seqId+ ""String_Node_Str"");
  }
  return null;
}",0.7011904761904761
16555,"private void createSSBonds(){
  List<SSBond> bonds=structure.getSSBonds();
  if (bonds == null)   bonds=new ArrayList<SSBond>();
  final String symop=""String_Node_Str"";
  int internalId=0;
  for (  StructConn conn : structConn) {
    String ptnr1_chainId=conn.getPtnr1_auth_asym_id();
    String ptnr1_seqId=conn.getPtnr1_auth_seq_id();
    String ptnr2_chainId=conn.getPtnr2_auth_asym_id();
    String ptnr2_seqId=conn.getPtnr2_auth_seq_id();
    Group s1=lookupResidue(ptnr1_chainId,ptnr1_seqId);
    Group s2=lookupResidue(ptnr2_chainId,ptnr2_seqId);
    if (null != s1 && null != s2) {
      if (""String_Node_Str"".equals(s1.getPDBName()) && symop.equals(conn.getPtnr1_symmetry()) && ""String_Node_Str"".equals(s2.getPDBName())&& symop.equals(conn.getPtnr2_symmetry())) {
        SSBondImpl bond=new SSBondImpl();
        bond.setSerNum(internalId++);
        bond.setChainID1(ptnr1_chainId);
        bond.setResnum1(ptnr1_seqId);
        if (""String_Node_Str"".equals(conn.getPdbx_ptnr1_PDB_ins_code())) {
          conn.setPdbx_ptnr1_PDB_ins_code(null);
        }
        bond.setInsCode1(conn.getPdbx_ptnr1_PDB_ins_code());
        bond.setChainID2(ptnr2_chainId);
        bond.setResnum2(ptnr2_seqId);
        if (""String_Node_Str"".equals(conn.getPdbx_ptnr2_PDB_ins_code())) {
          conn.setPdbx_ptnr2_PDB_ins_code(null);
        }
        bond.setInsCode2(conn.getPdbx_ptnr2_PDB_ins_code());
        bonds.add(bond);
      }
    }
  }
  structure.setSSBonds(bonds);
}","private void createSSBonds(){
  List<SSBond> bonds=structure.getSSBonds();
  if (bonds == null)   bonds=new ArrayList<SSBond>();
  final String symop=""String_Node_Str"";
  int internalId=0;
  for (  StructConn conn : structConn) {
    if (!conn.getConn_type_id().equals(""String_Node_Str""))     continue;
    String ptnr1_chainId=conn.getPtnr1_auth_asym_id();
    String insCode1=""String_Node_Str"";
    if (!conn.getPdbx_ptnr1_PDB_ins_code().equals(""String_Node_Str""))     insCode1=conn.getPdbx_ptnr1_PDB_ins_code();
    String insCode2=""String_Node_Str"";
    if (!conn.getPdbx_ptnr2_PDB_ins_code().equals(""String_Node_Str""))     insCode2=conn.getPdbx_ptnr2_PDB_ins_code();
    String ptnr1_seqId=conn.getPtnr1_auth_seq_id() + insCode1;
    String ptnr2_chainId=conn.getPtnr2_auth_asym_id();
    String ptnr2_seqId=conn.getPtnr2_auth_seq_id() + insCode2;
    Group s1=lookupResidue(ptnr1_chainId,ptnr1_seqId);
    Group s2=lookupResidue(ptnr2_chainId,ptnr2_seqId);
    if (null != s1 && null != s2) {
      if (""String_Node_Str"".equals(s1.getPDBName()) && ""String_Node_Str"".equals(s2.getPDBName())) {
        if (!conn.getPtnr1_symmetry().equals(symop) || !conn.getPtnr2_symmetry().equals(symop)) {
          logger.info(""String_Node_Str"",s1.getResidueNumber(),s2.getResidueNumber());
          continue;
        }
        SSBondImpl bond=new SSBondImpl();
        bond.setSerNum(internalId++);
        bond.setChainID1(ptnr1_chainId);
        bond.setResnum1(ptnr1_seqId);
        if (""String_Node_Str"".equals(conn.getPdbx_ptnr1_PDB_ins_code())) {
          conn.setPdbx_ptnr1_PDB_ins_code(null);
        }
        bond.setInsCode1(conn.getPdbx_ptnr1_PDB_ins_code());
        bond.setChainID2(ptnr2_chainId);
        bond.setResnum2(ptnr2_seqId);
        if (""String_Node_Str"".equals(conn.getPdbx_ptnr2_PDB_ins_code())) {
          conn.setPdbx_ptnr2_PDB_ins_code(null);
        }
        bond.setInsCode2(conn.getPdbx_ptnr2_PDB_ins_code());
        if (bonds.contains(bond)) {
          if (s1.getAltLocs().isEmpty() && s1.getAltLocs().isEmpty()) {
            logger.warn(""String_Node_Str"",s1.getResidueNumber(),s2.getResidueNumber());
          }
 else {
            logger.info(""String_Node_Str"",s1.getResidueNumber(),s2.getResidueNumber());
          }
        }
 else {
          bonds.add(bond);
        }
      }
    }
  }
  structure.setSSBonds(bonds);
}",0.7285044293903075
16556,"@Override public int getStartIndex(int str){
  int index=0;
  Integer start=null;
  while (start == null && index < alignRes.get(str).size()) {
    start=alignRes.get(str).get(index);
    index++;
  }
  return index;
}","@Override public int getStartIndex(int str){
  int index=-1;
  Integer start=null;
  while (start == null && index < alignRes.get(str).size()) {
    index++;
    start=alignRes.get(str).get(index);
  }
  return index;
}",0.8100686498855835
16557,"/** 
 * Method that converts a symmetry alignment into an alignment of the subunits only, as new independent structures. <p> This method changes the structure identifiers, the Atom arrays and re-scles the aligned residues in the Blocks corresponding to those changes. <p> Application: display superimposed subunits in Jmol.
 * @param result CeSymmResult of symmetry
 * @return MultipleAlignment of the subunits
 * @throws StructureException
 */
public static MultipleAlignment toSubunitAlignment(CeSymmResult result) throws StructureException {
  if (!result.isRefined())   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  MultipleAlignment msa=result.getMultipleAlignment();
  MultipleAlignmentEnsemble newEnsemble=msa.getEnsemble().clone();
  newEnsemble.setStructureIdentifiers(result.getProtodomains());
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  Structure divided=SymmetryTools.getQuaternaryStructure(result);
  MultipleAlignment subunits=newEnsemble.getMultipleAlignment(0);
  Block block=subunits.getBlock(0);
  for (int i=0; i < result.getMultipleAlignment().size(); i++) {
    Structure newStr=new StructureImpl();
    Chain newCh=divided.getChain(i);
    newStr.addChain(newCh);
    Atom[] subunit=StructureTools.getRepresentativeAtomArray(newCh);
    atomArrays.add(subunit);
  }
  newEnsemble.setAtomArrays(atomArrays);
  for (int su=0; su < block.size(); su++) {
    int count=0;
    Integer start=null;
    while (start == null && count < block.length()) {
      start=block.getAlignRes().get(su).get(0 + count);
      count++;
    }
    for (int res=0; res < block.length(); res++) {
      Integer residue=block.getAlignRes().get(su).get(res);
      if (residue != null)       residue-=start;
      block.getAlignRes().get(su).set(res,residue);
    }
  }
  return subunits;
}","/** 
 * Method that converts a symmetry alignment into an alignment of the subunits only, as new independent structures. <p> This method changes the structure identifiers, the Atom arrays and re-scles the aligned residues in the Blocks corresponding to those changes. <p> Application: display superimposed subunits in Jmol.
 * @param result CeSymmResult of symmetry
 * @return MultipleAlignment of the subunits
 * @throws StructureException
 */
public static MultipleAlignment toSubunitAlignment(CeSymmResult result) throws StructureException {
  if (!result.isRefined())   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  MultipleAlignment msa=result.getMultipleAlignment();
  MultipleAlignmentEnsemble newEnsemble=msa.getEnsemble().clone();
  newEnsemble.setStructureIdentifiers(result.getProtodomains());
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  Structure divided=SymmetryTools.getQuaternaryStructure(result);
  MultipleAlignment subunits=newEnsemble.getMultipleAlignment(0);
  Block block=subunits.getBlock(0);
  for (int i=0; i < result.getMultipleAlignment().size(); i++) {
    Structure newStr=new StructureImpl();
    Chain newCh=divided.getChain(i);
    newStr.addChain(newCh);
    Atom[] subunit=StructureTools.getRepresentativeAtomArray(newCh);
    atomArrays.add(subunit);
  }
  newEnsemble.setAtomArrays(atomArrays);
  for (int su=0; su < block.size(); su++) {
    Integer start=block.getStartResidue(su);
    for (int res=0; res < block.length(); res++) {
      Integer residue=block.getAlignRes().get(su).get(res);
      if (residue != null)       residue-=start;
      block.getAlignRes().get(su).set(res,residue);
    }
  }
  return subunits;
}",0.9266081042788326
16558,"/** 
 * Displays a single structure in a cartoon representation with each symmetric subunit colored differently.
 * @param symmResult the symmetry result obtained from CeSymm
 * @throws StructureException
 */
public static AbstractAlignmentJmol display(CeSymmResult symmResult) throws StructureException {
  if (symmResult.isRefined()) {
    MultipleAlignment msa=symmResult.getMultipleAlignment();
    List<Atom[]> atoms=msa.getAtomArrays();
    MultipleAlignmentJmol jmol=new MultipleAlignmentJmol(msa,atoms);
    jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());
    addSymmetryMenu(jmol,symmResult);
    jmol.evalString(printPointGroupAxes(symmResult));
    jmol.evalString(printSymmetryAxes(symmResult,false));
    return jmol;
  }
 else {
    Logger.info(""String_Node_Str"");
    return StructureAlignmentDisplay.display(symmResult.getSelfAlignment(),symmResult.getAtoms(),symmResult.getAtoms());
  }
}","/** 
 * Displays a single structure in a cartoon representation with each symmetric subunit colored differently.
 * @param symmResult the symmetry result obtained from CeSymm
 * @throws StructureException
 */
public static AbstractAlignmentJmol display(CeSymmResult symmResult) throws StructureException {
  if (symmResult.isRefined()) {
    MultipleAlignment msa=symmResult.getMultipleAlignment();
    List<Atom[]> atoms=msa.getAtomArrays();
    MultipleAlignmentJmol jmol=new MultipleAlignmentJmol(msa,atoms);
    jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());
    addSymmetryMenu(jmol,symmResult);
    jmol.evalString(printPointGroupAxes(symmResult));
    jmol.evalString(printSymmetryAxes(symmResult,false));
    return jmol;
  }
 else {
    Logger.info(""String_Node_Str"");
    Atom[] cloned=StructureTools.cloneAtomArray(symmResult.getAtoms());
    return StructureAlignmentDisplay.display(symmResult.getSelfAlignment(),symmResult.getAtoms(),cloned);
  }
}",0.9477572559366756
16559,"@Override public void actionPerformed(ActionEvent ae){
  String cmd=ae.getActionCommand();
  if (cmd.equals(""String_Node_Str"")) {
    if (symm == null) {
      logger.error(""String_Node_Str"");
      return;
    }
    try {
      MultipleAlignmentJmol j=SymmetryDisplay.displaySubunits(symm.getMultipleAlignment());
      String s=SymmetryDisplay.printSymmetryAxes(symm,true);
      j.evalString(s);
    }
 catch (    StructureException e) {
      e.printStackTrace();
    }
  }
 else   if (cmd.equals(""String_Node_Str"")) {
    if (symm == null) {
      logger.error(""String_Node_Str"");
      return;
    }
    try {
      MultipleAlignmentJmol j=SymmetryDisplay.displayFull(symm.getMultipleAlignment());
      String s=SymmetryDisplay.printSymmetryAxes(symm,false);
      j.evalString(s);
    }
 catch (    StructureException e) {
      e.printStackTrace();
    }
  }
 else   if (cmd.equals(""String_Node_Str"")) {
    if (symm == null) {
      logger.error(""String_Node_Str"");
      return;
    }
    try {
      StructureAlignmentDisplay.display(symm.getSelfAlignment(),symm.getAtoms(),symm.getAtoms());
    }
 catch (    StructureException e) {
      e.printStackTrace();
    }
  }
 else   if (cmd.equals(""String_Node_Str"")) {
    if (symm == null) {
      logger.error(""String_Node_Str"");
      return;
    }
    String script=SymmetryDisplay.printPointGroupAxes(symm);
    jmol.evalString(script);
    return;
  }
 else   if (cmd.equals(""String_Node_Str"")) {
    if (symm != null) {
      String s=SymmetryDisplay.printSymmetryAxes(symm,false);
      jmol.evalString(s);
      return;
    }
 else     logger.error(""String_Node_Str"");
  }
 else   if (cmd.equals(""String_Node_Str"")) {
    SymmetryGui.getInstance();
  }
}","@Override public void actionPerformed(ActionEvent ae){
  String cmd=ae.getActionCommand();
  if (cmd.equals(""String_Node_Str"")) {
    if (symm == null) {
      logger.error(""String_Node_Str"");
      return;
    }
    try {
      MultipleAlignmentJmol j=SymmetryDisplay.displaySubunits(symm.getMultipleAlignment());
      String s=SymmetryDisplay.printSymmetryAxes(symm,true);
      j.evalString(s);
    }
 catch (    StructureException e) {
      e.printStackTrace();
    }
  }
 else   if (cmd.equals(""String_Node_Str"")) {
    if (symm == null) {
      logger.error(""String_Node_Str"");
      return;
    }
    try {
      MultipleAlignmentJmol j=SymmetryDisplay.displayFull(symm.getMultipleAlignment());
      String s=SymmetryDisplay.printSymmetryAxes(symm,false);
      j.evalString(s);
    }
 catch (    StructureException e) {
      e.printStackTrace();
    }
  }
 else   if (cmd.equals(""String_Node_Str"")) {
    if (symm == null) {
      logger.error(""String_Node_Str"");
      return;
    }
    try {
      Atom[] cloned=StructureTools.cloneAtomArray(symm.getAtoms());
      StructureAlignmentDisplay.display(symm.getSelfAlignment(),symm.getAtoms(),cloned);
    }
 catch (    StructureException e) {
      e.printStackTrace();
    }
  }
 else   if (cmd.equals(""String_Node_Str"")) {
    if (symm == null) {
      logger.error(""String_Node_Str"");
      return;
    }
    String script=SymmetryDisplay.printPointGroupAxes(symm);
    jmol.evalString(script);
    return;
  }
 else   if (cmd.equals(""String_Node_Str"")) {
    if (symm != null) {
      String s=SymmetryDisplay.printSymmetryAxes(symm,false);
      jmol.evalString(s);
      return;
    }
 else     logger.error(""String_Node_Str"");
  }
 else   if (cmd.equals(""String_Node_Str"")) {
    SymmetryGui.getInstance();
  }
}",0.9745932058235798
16560,"@SuppressWarnings(""String_Node_Str"") protected static CeSymmResult align(Atom[] atoms,CESymmParameters params) throws StructureException {
  CeSymmResult result=new CeSymmResult();
  result.setParams(params);
  result.setAtoms(atoms);
  Atom[] ca2=StructureTools.duplicateCA2(atoms);
  int rows=atoms.length;
  int cols=ca2.length;
  if (rows == 0 || cols == 0) {
    throw new StructureException(""String_Node_Str"");
  }
  Matrix origM=null;
  AFPChain myAFP=new AFPChain(algorithmName);
  CECalculator calculator=new CECalculator(params);
  Matrix lastMatrix=null;
  List<AFPChain> selfAlignments=new ArrayList<AFPChain>();
  int i=0;
  do {
    if (origM != null)     myAFP.setDistanceMatrix((Matrix)origM.clone());
    origM=align(myAFP,atoms,ca2,params,origM,calculator,i);
    double tmScore2=AFPChainScorer.getTMScore(myAFP,atoms,ca2);
    myAFP.setTMScore(tmScore2);
    AFPChain newAFP=(AFPChain)myAFP.clone();
    newAFP=CeCPMain.postProcessAlignment(newAFP,atoms,ca2,calculator);
    double tmScore3=AFPChainScorer.getTMScore(newAFP,atoms,ca2);
    newAFP.setTMScore(tmScore3);
    if (tmScore3 < params.getScoreThreshold()) {
      if (i == 0)       selfAlignments.add(newAFP);
      lastMatrix=newAFP.getDistanceMatrix().copy();
      break;
    }
    selfAlignments.add(newAFP);
    i++;
  }
 while (i < params.getMaxSymmOrder() && multiPass);
  if (lastMatrix == null && selfAlignments.size() > 1 && multiPass) {
    AFPChain last=selfAlignments.get(selfAlignments.size() - 1);
    lastMatrix=SymmetryTools.blankOutPreviousAlignment(last,ca2,last.getCa1Length(),last.getCa2Length(),calculator,origM,params.getWinSize());
    lastMatrix=lastMatrix.getMatrix(0,last.getCa1Length() - 1,0,last.getCa2Length() - 1);
  }
  result.setSelfAlignment(selfAlignments.get(0));
  SymmetryType type=params.getSymmType();
  if (type == SymmetryType.AUTO) {
    if (result.getSelfAlignment().getBlockNum() == 1) {
      result.setType(SymmetryType.OPEN);
      logger.info(""String_Node_Str"");
    }
 else {
      result.setType(SymmetryType.CLOSE);
      logger.info(""String_Node_Str"");
    }
  }
  SymmetryRefiner refiner=null;
  OrderDetector orderDetector=null;
  int order=1;
  try {
switch (type) {
case CLOSE:
switch (params.getOrderDetectorMethod()) {
case SEQUENCE_FUNCTION:
        orderDetector=new SequenceFunctionOrderDetector(params.getMaxSymmOrder(),0.4f);
      order=orderDetector.calculateOrder(result.getSelfAlignment(),atoms);
    break;
case USER_INPUT:
  order=params.getUserOrder();
break;
}
switch (params.getRefineMethod()) {
case NOT_REFINED:
result.setSymmOrder(order);
return result;
case GRAPH:
refiner=new GraphRefiner();
break;
case SINGLE:
refiner=new SingleRefiner();
break;
}
break;
default :
if (params.getRefineMethod() == RefineMethod.NOT_REFINED) {
return result;
}
 else {
refiner=new OpenRefiner();
order=params.getUserOrder();
}
break;
}
MultipleAlignment msa=refiner.refine(result.getSelfAlignment(),atoms,order);
result.setMultipleAlignment(msa);
result.setSymmOrder(msa.size());
result.setRefined(true);
}
 catch (RefinerFailedException e) {
logger.info(""String_Node_Str"" + e.getMessage());
return result;
}
SymmetryAxes axes=new SymmetryAxes();
order=result.getSymmOrder();
Matrix4d axis=result.getMultipleAlignment().getBlockSet(0).getTransformations().get(1);
List<List<Integer>> superposition=new ArrayList<List<Integer>>();
List<Integer> chain1=new ArrayList<Integer>();
List<Integer> chain2=new ArrayList<Integer>();
superposition.add(chain1);
superposition.add(chain2);
List<Integer> subunitTrans=new ArrayList<Integer>();
switch (type) {
case CLOSE:
for (int bk=0; bk < order; bk++) {
chain1.add(bk);
chain2.add((bk + 1) % order);
subunitTrans.add(bk);
}
axes.addAxis(axis,superposition,subunitTrans,order);
break;
default :
subunitTrans.add(0);
for (int bk=0; bk < order - 1; bk++) {
chain1.add(bk);
chain2.add(bk + 1);
subunitTrans.add(bk + 1);
}
axes.addAxis(axis,superposition,subunitTrans,order);
break;
}
result.setAxes(axes);
return result;
}","@SuppressWarnings(""String_Node_Str"") protected static CeSymmResult align(Atom[] atoms,CESymmParameters params) throws StructureException {
  CeSymmResult result=new CeSymmResult();
  result.setParams(params);
  result.setAtoms(atoms);
  Atom[] ca2=StructureTools.duplicateCA2(atoms);
  int rows=atoms.length;
  int cols=ca2.length;
  if (rows == 0 || cols == 0) {
    throw new StructureException(""String_Node_Str"");
  }
  Matrix origM=null;
  AFPChain myAFP=new AFPChain(algorithmName);
  CECalculator calculator=new CECalculator(params);
  Matrix lastMatrix=null;
  List<AFPChain> selfAlignments=new ArrayList<AFPChain>();
  int i=0;
  do {
    if (origM != null)     myAFP.setDistanceMatrix((Matrix)origM.clone());
    origM=align(myAFP,atoms,ca2,params,origM,calculator,i);
    double tmScore2=AFPChainScorer.getTMScore(myAFP,atoms,ca2);
    myAFP.setTMScore(tmScore2);
    AFPChain newAFP=(AFPChain)myAFP.clone();
    newAFP=CeCPMain.postProcessAlignment(newAFP,atoms,ca2,calculator);
    double tmScore3=AFPChainScorer.getTMScore(newAFP,atoms,ca2);
    newAFP.setTMScore(tmScore3);
    if (tmScore3 < params.getScoreThreshold()) {
      if (i == 0)       selfAlignments.add(newAFP);
      lastMatrix=newAFP.getDistanceMatrix().copy();
      break;
    }
    selfAlignments.add(newAFP);
    i++;
  }
 while (i < params.getMaxSymmOrder() && multiPass);
  if (lastMatrix == null && selfAlignments.size() > 1 && multiPass) {
    AFPChain last=selfAlignments.get(selfAlignments.size() - 1);
    lastMatrix=SymmetryTools.blankOutPreviousAlignment(last,ca2,last.getCa1Length(),last.getCa2Length(),calculator,origM,params.getWinSize());
    lastMatrix=lastMatrix.getMatrix(0,last.getCa1Length() - 1,0,last.getCa2Length() - 1);
  }
  result.setSelfAlignment(selfAlignments.get(0));
  if (params.getSymmType() == SymmetryType.AUTO) {
    if (result.getSelfAlignment().getBlockNum() == 1) {
      result.setType(SymmetryType.OPEN);
      logger.info(""String_Node_Str"");
    }
 else {
      result.setType(SymmetryType.CLOSE);
      logger.info(""String_Node_Str"");
    }
  }
  SymmetryRefiner refiner=null;
  OrderDetector orderDetector=null;
  int order=1;
  try {
switch (result.getType()) {
case CLOSE:
switch (params.getOrderDetectorMethod()) {
case SEQUENCE_FUNCTION:
        orderDetector=new SequenceFunctionOrderDetector(params.getMaxSymmOrder(),0.4f);
      order=orderDetector.calculateOrder(result.getSelfAlignment(),atoms);
    break;
case USER_INPUT:
  order=params.getUserOrder();
break;
}
switch (params.getRefineMethod()) {
case NOT_REFINED:
result.setSymmOrder(order);
return result;
case GRAPH:
order=0;
refiner=new GraphRefiner();
break;
case SINGLE:
refiner=new SingleRefiner();
break;
}
break;
default :
if (params.getRefineMethod() == RefineMethod.NOT_REFINED) {
return result;
}
 else {
refiner=new OpenRefiner();
order=params.getUserOrder();
}
break;
}
MultipleAlignment msa=refiner.refine(result.getSelfAlignment(),atoms,order);
result.setMultipleAlignment(msa);
result.setSymmOrder(msa.size());
result.setRefined(true);
}
 catch (RefinerFailedException e) {
logger.info(""String_Node_Str"" + e.getMessage());
return result;
}
SymmetryAxes axes=new SymmetryAxes();
order=result.getSymmOrder();
Matrix4d axis=result.getMultipleAlignment().getBlockSet(0).getTransformations().get(1);
List<List<Integer>> superposition=new ArrayList<List<Integer>>();
List<Integer> chain1=new ArrayList<Integer>();
List<Integer> chain2=new ArrayList<Integer>();
superposition.add(chain1);
superposition.add(chain2);
List<Integer> subunitTrans=new ArrayList<Integer>();
switch (result.getType()) {
case CLOSE:
for (int bk=0; bk < order; bk++) {
chain1.add(bk);
chain2.add((bk + 1) % order);
subunitTrans.add(bk);
}
axes.addAxis(axis,superposition,subunitTrans,order);
break;
default :
subunitTrans.add(0);
for (int bk=0; bk < order - 1; bk++) {
chain1.add(bk);
chain2.add(bk + 1);
subunitTrans.add(bk + 1);
}
axes.addAxis(axis,superposition,subunitTrans,order);
break;
}
result.setAxes(axes);
return result;
}",0.9856303886042734
16561,"/** 
 * After all the analysis iteratives have finished, the final MultipleAlignment object is constructed using the alignment graph.
 * @throws StructureException
 */
private void buildAlignment() throws StructureException {
  MultipleAlignment msa=new MultipleAlignmentImpl();
  msa.getEnsemble().setAtomArrays(new ArrayList<Atom[]>());
  msa.getEnsemble().setAlgorithmName(CeSymm.algorithmName);
  msa.getEnsemble().setVersion(CeSymm.version);
  msa.getEnsemble().setStructureIdentifiers(new ArrayList<StructureIdentifier>());
  BlockSet bs=new BlockSetImpl(msa);
  Block b=new BlockImpl(bs);
  b.setAlignRes(new ArrayList<List<Integer>>());
  List<List<Integer>> groups=new ArrayList<List<Integer>>();
  List<Integer> alreadySeen=new ArrayList<Integer>();
  for (int i=0; i < alignGraph.size(); i++) {
    if (!alreadySeen.contains(i)) {
      List<Integer> group=new ArrayList<Integer>();
      List<Integer> residues=new ArrayList<Integer>();
      residues.add(i);
      while (residues.size() > 0) {
        List<Integer> newResidues=new ArrayList<Integer>();
        for (        Integer residue : residues) {
          group.add(residue);
          alreadySeen.add(residue);
          List<Integer> children=alignGraph.get(residue);
          newResidues.addAll(children);
        }
        residues=newResidues;
      }
      Collections.sort(group);
      groups.add(group);
    }
  }
  int order=1;
  for (  MultipleAlignment m : levels)   order*=m.size();
  for (int su=0; su < order; su++) {
    msa.getEnsemble().getStructureIdentifiers().add(new PassthroughIdentifier(""String_Node_Str"" + (su + 1)));
    msa.getEnsemble().getAtomArrays().add(allAtoms);
    b.getAlignRes().add(new ArrayList<Integer>());
    for (    List<Integer> group : groups) {
      if (group.size() != order)       continue;
      b.getAlignRes().get(su).add(group.get(su));
    }
  }
  result.setMultipleAlignment(msa);
  result.setRefined(true);
  result.setSymmOrder(order);
}","/** 
 * After all the analysis iteratives have finished, the final MultipleAlignment object is constructed using the alignment graph.
 * @throws StructureException
 */
private void buildAlignment() throws StructureException {
  MultipleAlignment msa=new MultipleAlignmentImpl();
  msa.getEnsemble().setAtomArrays(new ArrayList<Atom[]>());
  msa.getEnsemble().setAlgorithmName(CeSymm.algorithmName);
  msa.getEnsemble().setVersion(CeSymm.version);
  msa.getEnsemble().setStructureIdentifiers(new ArrayList<StructureIdentifier>());
  BlockSet bs=new BlockSetImpl(msa);
  Block b=new BlockImpl(bs);
  b.setAlignRes(new ArrayList<List<Integer>>());
  List<List<Integer>> groups=new ArrayList<List<Integer>>();
  List<Integer> alreadySeen=new ArrayList<Integer>();
  for (int i=0; i < alignGraph.size(); i++) {
    if (!alreadySeen.contains(i)) {
      List<Integer> group=new ArrayList<Integer>();
      List<Integer> residues=new ArrayList<Integer>();
      residues.add(i);
      while (residues.size() > 0) {
        List<Integer> newResidues=new ArrayList<Integer>();
        for (        Integer residue : residues) {
          group.add(residue);
          alreadySeen.add(residue);
          List<Integer> children=alignGraph.get(residue);
          newResidues.addAll(children);
        }
        residues=newResidues;
      }
      Collections.sort(group);
      groups.add(group);
    }
  }
  int order=1;
  for (  MultipleAlignment m : levels)   order*=m.size();
  for (int su=0; su < order; su++) {
    msa.getEnsemble().getStructureIdentifiers().add(new PassthroughIdentifier(""String_Node_Str"" + (su + 1)));
    msa.getEnsemble().getAtomArrays().add(allAtoms);
    b.getAlignRes().add(new ArrayList<Integer>());
    for (    List<Integer> group : groups) {
      if (group.size() != order)       continue;
      b.getAlignRes().get(su).add(group.get(su));
    }
  }
  CoreSuperimposer imposer=new CoreSuperimposer();
  imposer.superimpose(msa);
  MultipleAlignmentScorer.calculateScores(msa);
  result.setMultipleAlignment(msa);
  result.setRefined(true);
  result.setSymmOrder(order);
}",0.9687576875768756
16562,"/** 
 * This method runs iteratively the analysis of one level of symmetry with CeSymm on the input Atom array until no more symmetries exist.
 * @param atoms representative Atom array of the Structure
 * @return true if any symmetry was found, false if asymmetric
 * @throws StructureException
 */
private boolean iterate(Atom[] atoms) throws StructureException {
  logger.debug(""String_Node_Str"");
  if (atoms.length <= params.getWinSize() || atoms.length <= params.getMinCoreLength()) {
    logger.debug(""String_Node_Str"" + ""String_Node_Str"",atoms.length);
    return !levels.isEmpty();
  }
  if (params.getSymmLevels() > 0) {
    if (levels.size() == params.getSymmLevels())     return true;
  }
  CeSymmResult r=CeSymm.analyzeLevel(atoms,params);
  if (result == null)   result=r;
  if (params.getRefineMethod() == RefineMethod.NOT_REFINED)   return false;
 else   if (!result.isSignificant())   return !levels.isEmpty();
  Integer start=null;
  int it=0;
  while (start == null) {
    start=result.getMultipleAlignment().getBlocks().get(0).getAlignRes().get(0).get(it);
    it++;
  }
  Integer end=null;
  it=result.getMultipleAlignment().getBlocks().get(0).getAlignRes().get(0).size() - 1;
  while (end == null) {
    end=result.getMultipleAlignment().getBlocks().get(0).getAlignRes().get(0).get(it);
    it--;
  }
  Atom[] atomsR=Arrays.copyOfRange(atoms,start,end + 1);
  if (countHelixStrandSSE(atomsR) < params.getSSEThreshold())   return !levels.isEmpty();
  Block b=result.getMultipleAlignment().getBlock(0);
  for (int pos=0; pos < b.length(); pos++) {
    for (int su=0; su < b.size() - 1; su++) {
      Integer pos1=b.getAlignRes().get(su).get(pos);
      Integer pos2=b.getAlignRes().get(su + 1).get(pos);
      if (pos1 != null && pos2 != null) {
        alignGraph.get(pos1).add(pos2);
      }
    }
  }
  levels.add(result.getMultipleAlignment());
  return iterate(atomsR);
}","/** 
 * This method runs iteratively the analysis of one level of symmetry with CeSymm on the input Atom array until no more symmetries exist.
 * @param atoms representative Atom array of the Structure
 * @return true if any symmetry was found, false if asymmetric
 * @throws StructureException
 */
private boolean iterate(Atom[] atoms) throws StructureException {
  logger.debug(""String_Node_Str"");
  if (atoms.length <= params.getWinSize() || atoms.length <= params.getMinCoreLength()) {
    logger.debug(""String_Node_Str"" + ""String_Node_Str"",atoms.length);
    return !levels.isEmpty();
  }
  if (params.getSymmLevels() > 0) {
    if (levels.size() == params.getSymmLevels())     return true;
  }
  CeSymmResult r=CeSymm.analyzeLevel(atoms,params);
  if (result == null)   result=r;
  if (params.getRefineMethod() == RefineMethod.NOT_REFINED)   return false;
 else   if (!r.isSignificant())   return !levels.isEmpty();
  Integer start=null;
  int it=0;
  while (start == null) {
    start=r.getMultipleAlignment().getBlocks().get(0).getAlignRes().get(0).get(it);
    it++;
  }
  Integer end=null;
  it=r.getMultipleAlignment().getBlocks().get(0).getAlignRes().get(0).size() - 1;
  while (end == null) {
    end=r.getMultipleAlignment().getBlocks().get(0).getAlignRes().get(0).get(it);
    it--;
  }
  Atom[] atomsR=Arrays.copyOfRange(atoms,start,end + 1);
  if (countHelixStrandSSE(atomsR) < params.getSSEThreshold())   return !levels.isEmpty();
  Block b=r.getMultipleAlignment().getBlock(0);
  for (int pos=0; pos < b.length(); pos++) {
    for (int su=0; su < b.size() - 1; su++) {
      Integer pos1=b.getAlignRes().get(su).get(pos);
      Integer pos2=b.getAlignRes().get(su + 1).get(pos);
      if (pos1 != null && pos2 != null) {
        alignGraph.get(pos1).add(pos2);
      }
    }
  }
  levels.add(r.getMultipleAlignment());
  return iterate(atomsR);
}",0.9920212765957448
16563,"/** 
 * Return true if the symmetry result is significant, false otherwise.
 */
public boolean isSignificant(){
  if (symmOrder < 1)   return false;
  if (params.getRefineMethod() == RefineMethod.NOT_REFINED) {
    if (selfAlignment.getTMScore() < params.getScoreThreshold())     return false;
 else     return true;
  }
  if (refined) {
    if (multipleAlignment.getScore(MultipleAlignmentScorer.AVGTM_SCORE) > params.getScoreThreshold() && multipleAlignment.getCoreLength() < params.getMinCoreLength())     return true;
 else     return false;
  }
 else   return false;
}","/** 
 * Return true if the symmetry result is significant, false otherwise.
 */
public boolean isSignificant(){
  if (symmOrder < 1)   return false;
  if (params.getRefineMethod() == RefineMethod.NOT_REFINED) {
    if (selfAlignment.getTMScore() < params.getScoreThreshold())     return false;
 else     return true;
  }
  if (refined) {
    if (multipleAlignment.getScore(MultipleAlignmentScorer.AVGTM_SCORE) > params.getScoreThreshold() && multipleAlignment.getCoreLength() > params.getMinCoreLength())     return true;
 else     return false;
  }
 else   return false;
}",0.9982547993019196
16564,"@Override public MultipleAlignment refine(AFPChain selfAlignment,Atom[] atoms,int order) throws StructureException, RefinerFailedException {
  UndirectedGraph<Integer,DefaultEdge> graph=SymmetryTools.buildSymmetryGraph(selfAlignment);
  ConnectivityInspector<Integer,DefaultEdge> inspector=new ConnectivityInspector<Integer,DefaultEdge>(graph);
  List<Set<Integer>> components=inspector.connectedSets();
  if (order == 0) {
    Map<Integer,Integer> counts=new HashMap<Integer,Integer>();
    for (    Set<Integer> c : components) {
      if (counts.containsKey(c.size()))       counts.put(c.size(),counts.get(c.size()) + 1);
 else       counts.put(c.size(),1);
    }
    int maxCounts=0;
    for (    Integer ord : counts.keySet()) {
      if (counts.get(ord) > maxCounts) {
        order=ord;
        maxCounts=counts.get(ord);
      }
    }
  }
  List<ResidueGroup> groups=new ArrayList<ResidueGroup>();
  for (  Set<Integer> comp : components) {
    if (comp.size() != order) {
      ResidueGroup group=new ResidueGroup(comp);
      groups.add(group);
    }
  }
  int size=groups.size();
  if (size == 0)   throw new RefinerFailedException(""String_Node_Str"" + ""String_Node_Str"");
  GMatrix matrix=new GMatrix(size,size);
  for (int i=0; i < size; i++) {
    for (int j=i; j < size; j++) {
      if (i == j)       matrix.setElement(i,j,0);
      ResidueGroup g1=groups.get(i);
      ResidueGroup g2=groups.get(j);
      if (g1.isCompatible(g2)) {
        matrix.setElement(i,j,1);
        matrix.setElement(j,i,1);
      }
 else {
        matrix.setElement(i,j,0);
        matrix.setElement(j,i,0);
      }
    }
  }
  List<Integer> rowScores=new ArrayList<Integer>(size);
  for (int i=0; i < size; i++) {
    GVector row=new GVector(size);
    matrix.getRow(i,row);
    int rowScore=(int)row.normSquared();
    rowScores.set(i,rowScore);
  }
  List<List<Integer>> alignRes=new ArrayList<List<Integer>>(order);
  for (int i=0; i < order; i++)   alignRes.add(new ArrayList<Integer>());
  while (true) {
    Integer max=Collections.max(rowScores);
    int index=rowScores.indexOf(max);
    groups.get(index).combineWith(alignRes);
    boolean allZero=true;
    for (int i=0; i < size; i++) {
      if (matrix.getElement(index,i) < 1.0)       rowScores.set(i,0);
 else       if (rowScores.get(i) != 0)       allZero=false;
    }
    if (allZero)     break;
  }
  int length=alignRes.get(0).size();
  if (length == 0)   throw new RefinerFailedException(""String_Node_Str"");
  int[][][] optAln=new int[order][2][length];
  for (int bk=0; bk < order; bk++) {
    optAln[bk]=new int[2][];
    optAln[bk][0]=new int[length];
    optAln[bk][1]=new int[length];
    for (int pos=0; pos < length; pos++) {
      optAln[bk][0][pos]=alignRes.get(bk).get(pos);
      optAln[bk][1][pos]=alignRes.get((bk + 1) % order).get(pos);
    }
  }
  AFPChain afp=AlignmentTools.replaceOptAln(optAln,selfAlignment,atoms,atoms);
  return SymmetryTools.fromAFP(afp,atoms);
}","@Override public MultipleAlignment refine(AFPChain selfAlignment,Atom[] atoms,int order) throws StructureException, RefinerFailedException {
  UndirectedGraph<Integer,DefaultEdge> graph=SymmetryTools.buildSymmetryGraph(selfAlignment);
  ConnectivityInspector<Integer,DefaultEdge> inspector=new ConnectivityInspector<Integer,DefaultEdge>(graph);
  List<Set<Integer>> components=inspector.connectedSets();
  if (order == 0) {
    Map<Integer,Integer> counts=new HashMap<Integer,Integer>();
    for (    Set<Integer> c : components) {
      if (counts.containsKey(c.size()))       counts.put(c.size(),counts.get(c.size()) + 1);
 else       counts.put(c.size(),1);
    }
    int maxCounts=0;
    for (    Integer ord : counts.keySet()) {
      if (counts.get(ord) > maxCounts) {
        order=ord;
        maxCounts=counts.get(ord);
      }
    }
  }
  List<ResidueGroup> groups=new ArrayList<ResidueGroup>();
  for (  Set<Integer> comp : components) {
    if (comp.size() == order) {
      ResidueGroup group=new ResidueGroup(comp);
      groups.add(group);
    }
  }
  int size=groups.size();
  if (size == 0)   throw new RefinerFailedException(""String_Node_Str"" + ""String_Node_Str"");
  GMatrix matrix=new GMatrix(size,size);
  for (int i=0; i < size; i++) {
    for (int j=i; j < size; j++) {
      if (i == j) {
        matrix.setElement(i,j,0);
        continue;
      }
      ResidueGroup g1=groups.get(i);
      ResidueGroup g2=groups.get(j);
      if (g1.isCompatible(g2)) {
        matrix.setElement(i,j,1);
        matrix.setElement(j,i,1);
      }
 else {
        matrix.setElement(i,j,0);
        matrix.setElement(j,i,0);
      }
    }
  }
  List<Integer> rowScores=new ArrayList<Integer>(size);
  for (int i=0; i < size; i++) {
    GVector row=new GVector(size);
    matrix.getRow(i,row);
    int rowScore=(int)row.normSquared();
    rowScores.add(rowScore);
  }
  List<List<Integer>> alignRes=new ArrayList<List<Integer>>(order);
  for (int i=0; i < order; i++)   alignRes.add(new ArrayList<Integer>());
  while (true) {
    Integer max=Collections.max(rowScores);
    int index=rowScores.indexOf(max);
    groups.get(index).combineWith(alignRes);
    boolean allZero=true;
    for (int i=0; i < size; i++) {
      if (matrix.getElement(index,i) < 1.0)       rowScores.set(i,0);
 else       if (rowScores.get(i) != 0)       allZero=false;
    }
    if (allZero)     break;
  }
  int length=alignRes.get(0).size();
  if (length == 0)   throw new RefinerFailedException(""String_Node_Str"");
  int[][][] optAln=new int[order][2][length];
  for (int bk=0; bk < order; bk++) {
    optAln[bk]=new int[2][];
    optAln[bk][0]=new int[length];
    optAln[bk][1]=new int[length];
    for (int pos=0; pos < length; pos++) {
      optAln[bk][0][pos]=alignRes.get(bk).get(pos);
      optAln[bk][1][pos]=alignRes.get((bk + 1) % order).get(pos);
    }
  }
  AFPChain afp=AlignmentTools.replaceOptAln(optAln,selfAlignment,atoms,atoms);
  return SymmetryTools.fromAFP(afp,atoms);
}",0.9929078014184396
16565,"private Group getCorrectAltLocGroup(Character altLoc,String recordName,Character aminoCode1,String groupCode3,long seq_id){
  List<Atom> atoms=current_group.getAtoms();
  if (atoms.size() > 0) {
    Atom a1=atoms.get(0);
    if (a1.getAltLoc().equals(altLoc)) {
      return current_group;
    }
  }
  List<Group> altLocs=current_group.getAltLocs();
  for (  Group altLocG : altLocs) {
    atoms=altLocG.getAtoms();
    if (atoms.size() > 0) {
      for (      Atom a1 : atoms) {
        if (a1.getAltLoc().equals(altLoc)) {
          return altLocG;
        }
      }
    }
  }
  if (groupCode3.equals(current_group.getPDBName())) {
    if (current_group.getAtoms().size() == 0) {
      return current_group;
    }
    Group altLocG=(Group)current_group.clone();
    altLocG.setAtoms(new ArrayList<Atom>());
    current_group.addAltLoc(altLocG);
    return altLocG;
  }
  Group altLocG=getNewGroup(recordName,aminoCode1,seq_id,groupCode3);
  altLocG.setPDBName(groupCode3);
  altLocG.setResidueNumber(current_group.getResidueNumber());
  current_group.addAltLoc(altLocG);
  return altLocG;
}","private Group getCorrectAltLocGroup(Character altLoc,String recordName,Character aminoCode1,String groupCode3,long seq_id){
  List<Atom> atoms=current_group.getAtoms();
  if (atoms.size() > 0) {
    Atom a1=atoms.get(0);
    if (a1.getAltLoc().equals(altLoc)) {
      return current_group;
    }
  }
  List<Group> altLocs=current_group.getAltLocs();
  for (  Group altLocG : altLocs) {
    atoms=altLocG.getAtoms();
    if (atoms.size() > 0) {
      for (      Atom a1 : atoms) {
        if (a1.getAltLoc().equals(altLoc)) {
          return altLocG;
        }
      }
    }
  }
  if (groupCode3.equals(current_group.getPDBName())) {
    if (current_group.getAtoms().size() == 0) {
      return current_group;
    }
    Group altLocG=(Group)current_group.clone();
    altLocG.setAtoms(new ArrayList<Atom>());
    altLocG.getAltLocs().clear();
    current_group.addAltLoc(altLocG);
    return altLocG;
  }
  Group altLocG=getNewGroup(recordName,aminoCode1,seq_id,groupCode3);
  altLocG.setPDBName(groupCode3);
  altLocG.setResidueNumber(current_group.getResidueNumber());
  current_group.addAltLoc(altLocG);
  return altLocG;
}",0.9846708746618577
16566,"/** 
 * Requests for a structure to analyze.
 */
public SymmetryCalc(SymmetryGui p,Structure s,StructureIdentifier n){
  parent=p;
  structure=s;
  name=n;
}","/** 
 * Requests for a structure to analyze.
 */
public SymmetryCalc(SymmetryGui p,Structure s){
  parent=p;
  structure=s;
}",0.8865248226950354
16567,"@Override public void run(){
  CESymmParameters params=parent.getParameters();
  try {
    Atom[] atoms=StructureTools.getRepresentativeAtomArray(structure);
    CeSymmResult result=CeSymm.analyze(atoms,params);
    List<StructureIdentifier> names=new ArrayList<StructureIdentifier>();
    for (int su=0; su < result.getSymmOrder(); su++) {
      names.add(name);
    }
    result.getMultipleAlignment().getEnsemble().setStructureIdentifiers(names);
    MultipleAlignmentJmol jmol=SymmetryDisplay.display(result);
    String title=jmol.getTitle();
    if (params != null)     title+=""String_Node_Str"" + params.getOrderDetectorMethod() + ""String_Node_Str""+ params.getRefineMethod();
    jmol.setTitle(title);
  }
 catch (  StructureException e) {
    logger.warn(e.getMessage());
  }
  parent.notifyCalcFinished();
}","@Override public void run(){
  CESymmParameters params=parent.getParameters();
  try {
    Atom[] atoms=StructureTools.getRepresentativeAtomArray(structure);
    CeSymmResult result=CeSymm.analyze(atoms,params);
    AbstractAlignmentJmol jmol=SymmetryDisplay.display(result);
    String title=jmol.getTitle();
    if (params != null)     title+=""String_Node_Str"" + params.getOrderDetectorMethod() + ""String_Node_Str""+ params.getRefineMethod();
    jmol.setTitle(title);
  }
 catch (  StructureException e) {
    logger.warn(e.getMessage());
  }
  parent.notifyCalcFinished();
}",0.8204022988505747
16568,"/** 
 * Displays a single structure in a cartoon representation with each symmetric subunit colored differently.
 * @param symmResult the symmetry result obtained from CeSymm
 * @throws StructureException
 */
public static MultipleAlignmentJmol display(CeSymmResult symmResult) throws StructureException {
  MultipleAlignmentJmol jmol=null;
  MultipleAlignment msa=symmResult.getMultipleAlignment();
  if (symmResult.isRefined()) {
    List<Atom[]> atoms=msa.getAtomArrays();
    jmol=new MultipleAlignmentJmol(msa,atoms);
    jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());
    addSymmetryMenu(jmol,symmResult);
    jmol.evalString(printPointGroupAxes(symmResult));
    jmol.evalString(printSymmetryAxes(symmResult,false));
  }
 else {
    Logger.info(""String_Node_Str"");
    StructureAlignmentDisplay.display(symmResult.getSelfAlignment(),symmResult.getAtoms(),symmResult.getAtoms());
  }
  return jmol;
}","/** 
 * Displays a single structure in a cartoon representation with each symmetric subunit colored differently.
 * @param symmResult the symmetry result obtained from CeSymm
 * @throws StructureException
 */
public static AbstractAlignmentJmol display(CeSymmResult symmResult) throws StructureException {
  if (symmResult.isRefined()) {
    MultipleAlignment msa=symmResult.getMultipleAlignment();
    List<Atom[]> atoms=msa.getAtomArrays();
    MultipleAlignmentJmol jmol=new MultipleAlignmentJmol(msa,atoms);
    jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());
    addSymmetryMenu(jmol,symmResult);
    jmol.evalString(printPointGroupAxes(symmResult));
    jmol.evalString(printSymmetryAxes(symmResult,false));
    return jmol;
  }
 else {
    Logger.info(""String_Node_Str"");
    return StructureAlignmentDisplay.display(symmResult.getSelfAlignment(),symmResult.getAtoms(),symmResult.getAtoms());
  }
}",0.8630434782608696
16569,"private void calcAlignment(){
  int pos=tabPane.getSelectedIndex();
  StructurePairSelector tab=null;
  if (pos == 0) {
    tab=tab1;
  }
 else   if (pos == 1) {
    tab=tab3;
  }
 else   if (pos == 2) {
    tab=tab2;
  }
  try {
    Structure s=tab.getStructure1();
    if (s == null) {
      System.err.println(""String_Node_Str"");
      return;
    }
    StructureIdentifier name=new PassthroughIdentifier(""String_Node_Str"");
    if (pos == 0) {
      name=tab1.getName1();
    }
 else {
      name=s.getStructureIdentifier();
    }
    System.out.println(""String_Node_Str"" + name);
    alicalc=new SymmetryCalc(this,s,name);
    thread=new Thread(alicalc);
    thread.start();
    abortB.setEnabled(true);
    progress.setIndeterminate(true);
    ProgressThreadDrawer drawer=new ProgressThreadDrawer(progress);
    drawer.start();
  }
 catch (  StructureException e) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"" + e.getMessage());
  }
catch (  IOException e) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"" + e.getMessage());
  }
}","private void calcAlignment(){
  int pos=tabPane.getSelectedIndex();
  StructurePairSelector tab=null;
  if (pos == 0) {
    tab=tab1;
  }
 else   if (pos == 1) {
    tab=tab3;
  }
 else   if (pos == 2) {
    tab=tab2;
  }
  try {
    Structure s=tab.getStructure1();
    if (s == null) {
      System.err.println(""String_Node_Str"");
      return;
    }
    StructureIdentifier name=new PassthroughIdentifier(""String_Node_Str"");
    if (pos == 0) {
      name=tab1.getName1();
    }
 else {
      name=s.getStructureIdentifier();
    }
    System.out.println(""String_Node_Str"" + name);
    alicalc=new SymmetryCalc(this,s);
    thread=new Thread(alicalc);
    thread.start();
    abortB.setEnabled(true);
    progress.setIndeterminate(true);
    ProgressThreadDrawer drawer=new ProgressThreadDrawer(progress);
    drawer.start();
  }
 catch (  StructureException e) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"" + e.getMessage());
  }
catch (  IOException e) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"" + e.getMessage());
  }
}",0.9976336961665878
16570,"/** 
 * Analyze a single level of symmetry.
 * @param atoms Atom array of the current level
 * @return CeSymmResult
 * @throws StructureException
 */
public static CeSymmResult analyzeLevel(Atom[] atoms,CESymmParameters params) throws StructureException {
  if (atoms.length < 1)   throw new IllegalArgumentException(""String_Node_Str"");
  CeSymmResult result=align(atoms,params);
  if (result.isRefined()) {
    MultipleAlignment msa=result.getMultipleAlignment();
    CoreSuperimposer imposer=new CoreSuperimposer();
    imposer.superimpose(msa);
    MultipleAlignmentScorer.calculateScores(msa);
    result.setMultipleAlignment(msa);
    if (result.getParams().getOptimization()) {
      try {
        SymmOptimizer optimizer=new SymmOptimizer(result);
        msa=optimizer.optimize();
        result.setMultipleAlignment(msa);
      }
 catch (      RefinerFailedException e) {
        logger.debug(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  return result;
}","/** 
 * Analyze a single level of symmetry.
 * @param atoms Atom array of the current level
 * @return CeSymmResult
 * @throws StructureException
 */
public static CeSymmResult analyzeLevel(Atom[] atoms,CESymmParameters params) throws StructureException {
  if (atoms.length < 1)   throw new IllegalArgumentException(""String_Node_Str"");
  CeSymmResult result=align(atoms,params);
  if (result.isRefined()) {
    MultipleAlignment msa=result.getMultipleAlignment();
    if (result.getParams().getOptimization()) {
      try {
        SymmOptimizer optimizer=new SymmOptimizer(result);
        msa=optimizer.optimize();
        result.setMultipleAlignment(msa);
      }
 catch (      RefinerFailedException e) {
        logger.debug(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  return result;
}",0.9038785834738616
16571,"/** 
 * Converts a refined symmetry AFPChain alignment into the standard representation of symmetry in a MultipleAlignment, that contains the entire Atom array of the strcuture and the symmetric subunits are orgaized in different rows in a single Block.
 * @param symm AFPChain created with a symmetry algorithm and refined
 * @param atoms Atom array of the entire structure
 * @return MultipleAlignment format of the symmetry
 */
public static MultipleAlignment fromAFP(AFPChain symm,Atom[] atoms){
  if (!symm.getAlgorithmName().contains(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  MultipleAlignmentEnsemble e=new MultipleAlignmentEnsembleImpl(symm,atoms,atoms,false);
  e.setAtomArrays(new ArrayList<Atom[]>());
  StructureIdentifier name=null;
  if (e.getStructureIdentifiers() != null) {
    if (!e.getStructureIdentifiers().isEmpty())     name=e.getStructureIdentifiers().get(0);
  }
 else   name=atoms[0].getGroup().getChain().getStructure().getStructureIdentifier();
  e.setStructureIdentifiers(new ArrayList<StructureIdentifier>());
  MultipleAlignment result=new MultipleAlignmentImpl();
  BlockSet bs=new BlockSetImpl(result);
  Block b=new BlockImpl(bs);
  b.setAlignRes(new ArrayList<List<Integer>>());
  int order=symm.getBlockNum();
  for (int su=0; su < order; su++) {
    List<Integer> residues=e.getMultipleAlignment(0).getBlock(su).getAlignRes().get(0);
    b.getAlignRes().add(residues);
    e.getStructureIdentifiers().add(name);
    e.getAtomArrays().add(atoms);
  }
  e.getMultipleAlignments().set(0,result);
  result.setEnsemble(e);
  double tmScore=symm.getTMScore();
  result.putScore(MultipleAlignmentScorer.AVGTM_SCORE,tmScore);
  return result;
}","/** 
 * Converts a refined symmetry AFPChain alignment into the standard representation of symmetry in a MultipleAlignment, that contains the entire Atom array of the strcuture and the symmetric subunits are orgaized in different rows in a single Block.
 * @param symm AFPChain created with a symmetry algorithm and refined
 * @param atoms Atom array of the entire structure
 * @return MultipleAlignment format of the symmetry
 * @throws StructureException
 */
public static MultipleAlignment fromAFP(AFPChain symm,Atom[] atoms) throws StructureException {
  if (!symm.getAlgorithmName().contains(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  MultipleAlignmentEnsemble e=new MultipleAlignmentEnsembleImpl(symm,atoms,atoms,false);
  e.setAtomArrays(new ArrayList<Atom[]>());
  StructureIdentifier name=null;
  if (e.getStructureIdentifiers() != null) {
    if (!e.getStructureIdentifiers().isEmpty())     name=e.getStructureIdentifiers().get(0);
  }
 else   name=atoms[0].getGroup().getChain().getStructure().getStructureIdentifier();
  e.setStructureIdentifiers(new ArrayList<StructureIdentifier>());
  MultipleAlignment result=new MultipleAlignmentImpl();
  BlockSet bs=new BlockSetImpl(result);
  Block b=new BlockImpl(bs);
  b.setAlignRes(new ArrayList<List<Integer>>());
  int order=symm.getBlockNum();
  for (int su=0; su < order; su++) {
    List<Integer> residues=e.getMultipleAlignment(0).getBlock(su).getAlignRes().get(0);
    b.getAlignRes().add(residues);
    e.getStructureIdentifiers().add(name);
    e.getAtomArrays().add(atoms);
  }
  e.getMultipleAlignments().set(0,result);
  result.setEnsemble(e);
  CoreSuperimposer imposer=new CoreSuperimposer();
  imposer.superimpose(result);
  MultipleAlignmentScorer.calculateScores(result);
  return result;
}",0.921724333522405
16572,"/** 
 * By default the getStructure method loads asym units. This access method allows to recreate the quaternary structure for a protein if it is available.
 * @param pdbId
 * @param biolAssemblyNr - the ith biological assembly that is available for a PDB ID (we start counting at 1, 0 represents the asym unit).
 * @return a Structure object or null if that assembly is not available
 * @throws StructureException 
 * @throws IOException 
 */
public static Structure getBiologicalAssembly(String pdbId,int biolAssemblyNr) throws IOException, StructureException {
  pdbId=pdbId.toLowerCase();
  BioUnitDataProvider provider=BioUnitDataProviderFactory.getBioUnitDataProvider();
  checkInitAtomCache();
  provider.setAtomCache(cache);
  Structure asymUnit=provider.getAsymUnit(pdbId);
  if (biolAssemblyNr == 0) {
    logger.info(""String_Node_Str"");
    return asymUnit;
  }
  List<BiologicalAssemblyTransformation> transformations=asymUnit.getPDBHeader().getBioAssemblies().get(biolAssemblyNr).getTransforms();
  provider.setAsymUnit(null);
  provider.setAtomCache(null);
  if (transformations == null || transformations.size() == 0) {
    throw new StructureException(""String_Node_Str"" + biolAssemblyNr + ""String_Node_Str""+ pdbId);
  }
  BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
  return builder.rebuildQuaternaryStructure(asymUnit,transformations);
}","/** 
 * By default the getStructure method loads asym units. This access method allows to recreate the quaternary structure for a protein if it is available.
 * @param pdbId
 * @param biolAssemblyNr - the ith biological assembly that is available for a PDB ID (we start counting at 1, 0 represents the asym unit).
 * @return a Structure object or null if that assembly is not available
 * @throws StructureException if there is no bioassembly available for given biolAssemblyNr or some other problems encountered while loading it
 * @throws IOException 
 */
public static Structure getBiologicalAssembly(String pdbId,int biolAssemblyNr) throws IOException, StructureException {
  pdbId=pdbId.toLowerCase();
  BioUnitDataProvider provider=BioUnitDataProviderFactory.getBioUnitDataProvider();
  checkInitAtomCache();
  provider.setAtomCache(cache);
  Structure asymUnit=provider.getAsymUnit(pdbId);
  if (biolAssemblyNr == 0) {
    logger.info(""String_Node_Str"" + pdbId + ""String_Node_Str"");
    return asymUnit;
  }
  if (!asymUnit.getPDBHeader().getBioAssemblies().containsKey(biolAssemblyNr)) {
    throw new StructureException(""String_Node_Str"" + biolAssemblyNr + ""String_Node_Str""+ pdbId);
  }
  List<BiologicalAssemblyTransformation> transformations=asymUnit.getPDBHeader().getBioAssemblies().get(biolAssemblyNr).getTransforms();
  provider.setAsymUnit(null);
  provider.setAtomCache(null);
  if (transformations == null || transformations.size() == 0) {
    throw new StructureException(""String_Node_Str"" + biolAssemblyNr + ""String_Node_Str""+ pdbId);
  }
  BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
  return builder.rebuildQuaternaryStructure(asymUnit,transformations);
}",0.8600194868463787
16573,"@Override public void setPdbId(String pdbId){
  if (cache == null)   cache=new AtomCache();
  if (this.pdbId != null && (this.pdbId.equals(pdbId))) {
    return;
  }
  this.pdbId=pdbId;
  reset();
  MMCIFFileReader reader=new MMCIFFileReader(cache.getPath());
  FileParsingParameters params=cache.getFileParsingParams();
  params.setAlignSeqRes(true);
  params.setParseBioAssembly(true);
  reader.setFileParsingParameters(params);
  reader.setFetchBehavior(cache.getFetchBehavior());
  reader.setObsoleteBehavior(cache.getObsoleteBehavior());
  try {
    asymUnit=reader.getStructureById(pdbId);
    if (asymUnit.nrModels() > 1) {
      asymUnit=StructureTools.removeModels(asymUnit);
    }
    SimpleMMcifConsumer consumer=reader.getMMcifConsumer();
    pdbxStructOperList=consumer.getStructOpers();
    pdbxStructAssemblies=consumer.getStructAssemblies();
    pdbxStructAssemblyGens=consumer.getStructAssemblyGens();
    consumer.documentStart();
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + pdbId,e);
  }
}","@Override public void setPdbId(String pdbId){
  if (cache == null)   cache=new AtomCache();
  if (this.pdbId != null && (this.pdbId.equals(pdbId))) {
    return;
  }
  this.pdbId=pdbId;
  reset();
  MMCIFFileReader reader=new MMCIFFileReader(cache.getPath());
  FileParsingParameters params=cache.getFileParsingParams();
  params.setAlignSeqRes(true);
  params.setParseBioAssembly(true);
  reader.setFileParsingParameters(params);
  reader.setFetchBehavior(cache.getFetchBehavior());
  reader.setObsoleteBehavior(cache.getObsoleteBehavior());
  try {
    asymUnit=reader.getStructureById(pdbId);
    if (asymUnit.nrModels() > 1) {
      asymUnit=StructureTools.removeModels(asymUnit);
    }
    SimpleMMcifConsumer consumer=reader.getMMcifConsumer();
    pdbxStructOperList=consumer.getStructOpers();
    pdbxStructAssemblies=consumer.getStructAssemblies();
    pdbxStructAssemblyGens=consumer.getStructAssemblyGens();
    consumer.documentStart();
    Iterator<PdbxStructAssembly> it=pdbxStructAssemblies.iterator();
    while (it.hasNext()) {
      PdbxStructAssembly psa=it.next();
      try {
        Integer.parseInt(psa.getId());
      }
 catch (      NumberFormatException e) {
        logger.info(""String_Node_Str"",psa.getId(),pdbId);
        it.remove();
      }
    }
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + pdbId,e);
  }
}",0.8625156707062265
16574,"@Test public void test5LDH() throws IOException, StructureException {
  testID(""String_Node_Str"",1);
}","@Test public void test5LDH() throws IOException, StructureException {
  testID(""String_Node_Str"",1);
  testID(""String_Node_Str"",2);
  MmCifBiolAssemblyProvider mmcifProvider=new MmCifBiolAssemblyProvider();
  BioUnitDataProviderFactory.setBioUnitDataProvider(mmcifProvider.getClass().getCanonicalName());
  boolean gotException=false;
  try {
    StructureIO.getBiologicalAssembly(""String_Node_Str"",3);
  }
 catch (  StructureException e) {
    gotException=true;
  }
  assertTrue(""String_Node_Str"",gotException);
}",0.3306320907617504
16575,"/** 
 * Calculates the set of symmetry operation Matrices (transformations) of the new alignment, based on the symmetry relations in the SymmetryAxes object. <p> If the SymmetryAxes object is null, the superposition of the subunits is done without contraint.
 */
private void updateTransformation() throws StructureException {
  if (axes != null) {
    for (int t=0; t < axes.getElementaryAxes().size(); t++) {
      Matrix4d axis=axes.getElementaryAxes().get(t);
      List<Integer> chain1=axes.getSubunitRelation(t).get(0);
      List<Integer> chain2=axes.getSubunitRelation(t).get(1);
      List<Atom> list1=new ArrayList<Atom>();
      List<Atom> list2=new ArrayList<Atom>();
      for (int pair=0; pair < chain1.size(); pair++) {
        int p1=chain1.get(pair);
        int p2=chain2.get(pair);
        for (int k=0; k < length; k++) {
          Integer pos1=block.get(p1).get(k);
          Integer pos2=block.get(p2).get(k);
          if (pos1 != null && pos2 != null) {
            list1.add(atoms[pos1]);
            list2.add(atoms[pos2]);
          }
        }
      }
      Atom[] arr1=list1.toArray(new Atom[list1.size()]);
      Atom[] arr2=list2.toArray(new Atom[list2.size()]);
      SVDSuperimposer svd=new SVDSuperimposer(arr1,arr2);
      axis=svd.getTransformation();
      axes.updateAxis(t,axis);
    }
  }
 else {
    MultipleSuperimposer imposer=new CoreSuperimposer();
    imposer.superimpose(msa);
  }
}","/** 
 * Calculates the set of symmetry operation Matrices (transformations) of the new alignment, based on the symmetry relations in the SymmetryAxes object. <p> If the SymmetryAxes object is null, the superposition of the subunits is done without contraint.
 */
private void updateTransformation() throws StructureException, RefinerFailedException {
  if (msa.getCoreLength() == 0)   throw new RefinerFailedException(""String_Node_Str"");
  if (axes != null) {
    for (int t=0; t < axes.getElementaryAxes().size(); t++) {
      Matrix4d axis=axes.getElementaryAxes().get(t);
      List<Integer> chain1=axes.getSubunitRelation(t).get(0);
      List<Integer> chain2=axes.getSubunitRelation(t).get(1);
      List<Atom> list1=new ArrayList<Atom>();
      List<Atom> list2=new ArrayList<Atom>();
      for (int pair=0; pair < chain1.size(); pair++) {
        int p1=chain1.get(pair);
        int p2=chain2.get(pair);
        for (int k=0; k < length; k++) {
          Integer pos1=block.get(p1).get(k);
          Integer pos2=block.get(p2).get(k);
          if (pos1 != null && pos2 != null) {
            list1.add(atoms[pos1]);
            list2.add(atoms[pos2]);
          }
        }
      }
      Atom[] arr1=list1.toArray(new Atom[list1.size()]);
      Atom[] arr2=list2.toArray(new Atom[list2.size()]);
      SVDSuperimposer svd=new SVDSuperimposer(arr1,arr2);
      axis=svd.getTransformation();
      axes.updateAxis(t,axis);
    }
  }
 else {
    MultipleSuperimposer imposer=new CoreSuperimposer();
    imposer.superimpose(msa);
  }
}",0.9626136746379252
16576,"/** 
 * This method translates the internal data structures to a MultipleAlignment of the subunits in order to use the methods to score MultipleAlignments.
 * @throws StructureException
 * @throws RefinerFailedException
 */
private void updateMultipleAlignment() throws StructureException, RefinerFailedException {
  msa.clear();
  Block b=msa.getBlock(0);
  b.setAlignRes(block);
  subunitCore=b.getCoreLength();
  if (subunitCore < 1) {
    throw new RefinerFailedException(""String_Node_Str"");
  }
  updateTransformation();
  if (axes == null)   return;
  List<Matrix4d> transformations=new ArrayList<Matrix4d>();
  for (int su=0; su < order; su++) {
    transformations.add(axes.getSubunitTransform(su));
  }
  msa.getBlockSet(0).setTransformations(transformations);
}","/** 
 * This method translates the internal data structures to a MultipleAlignment of the subunits in order to use the methods to score MultipleAlignments.
 * @throws StructureException
 * @throws RefinerFailedException
 */
private void updateMultipleAlignment() throws StructureException, RefinerFailedException {
  msa.clear();
  Block b=msa.getBlock(0);
  b.setAlignRes(block);
  subunitCore=b.getCoreLength();
  if (subunitCore < 1)   throw new RefinerFailedException(""String_Node_Str"");
  updateTransformation();
  if (axes == null)   return;
  List<Matrix4d> transformations=new ArrayList<Matrix4d>();
  for (int su=0; su < order; su++) {
    transformations.add(axes.getSubunitTransform(su));
  }
  msa.getBlockSet(0).setTransformations(transformations);
}",0.9947848761408083
16577,"/** 
 * Deletes an alignment column at a randomly selected position.
 * @throws StructureException
 * @throws RefinerFailedException
 */
private boolean shrinkBlock() throws StructureException, RefinerFailedException {
  if (subunitCore <= Lmin)   return false;
  updateTransformation();
  updateMultipleAlignment();
  Matrix residueDistances=MultipleAlignmentTools.getAverageResidueDistances(msa);
  double maxDist=Double.MIN_VALUE;
  double[] colDistances=new double[length];
  int res=0;
  for (int col=0; col < length; col++) {
    int normalize=0;
    for (int s=0; s < order; s++) {
      if (residueDistances.get(s,col) != -1) {
        colDistances[col]+=residueDistances.get(s,col);
        normalize++;
      }
    }
    colDistances[col]/=normalize;
    if (colDistances[col] > maxDist) {
      if (rnd.nextDouble() > 0.5) {
        maxDist=colDistances[col];
        res=col;
      }
    }
  }
  for (int su=0; su < order; su++) {
    Integer residue=block.get(su).get(res);
    block.get(su).remove(res);
    if (residue != null)     freePool.add(residue);
    Collections.sort(freePool);
  }
  length--;
  checkGaps();
  return true;
}","/** 
 * Deletes an alignment column at a randomly selected position.
 * @throws StructureException
 * @throws RefinerFailedException
 */
private boolean shrinkBlock() throws StructureException, RefinerFailedException {
  if (subunitCore <= Lmin)   return false;
  updateMultipleAlignment();
  Matrix residueDistances=MultipleAlignmentTools.getAverageResidueDistances(msa);
  double maxDist=Double.MIN_VALUE;
  double[] colDistances=new double[length];
  int res=0;
  for (int col=0; col < length; col++) {
    int normalize=0;
    for (int s=0; s < order; s++) {
      if (residueDistances.get(s,col) != -1) {
        colDistances[col]+=residueDistances.get(s,col);
        normalize++;
      }
    }
    colDistances[col]/=normalize;
    if (colDistances[col] > maxDist) {
      if (rnd.nextDouble() > 0.5) {
        maxDist=colDistances[col];
        res=col;
      }
    }
  }
  for (int su=0; su < order; su++) {
    Integer residue=block.get(su).get(res);
    block.get(su).remove(res);
    if (residue != null)     freePool.add(residue);
    Collections.sort(freePool);
  }
  length--;
  checkGaps();
  return true;
}",0.988556338028169
16578,"/** 
 * After all the analysis iteratives have finished, the final MultipleAlignment object is constructed using the alignment graph.
 * @throws StructureException
 */
private void buildAlignment() throws StructureException {
  msa=new MultipleAlignmentImpl();
  msa.getEnsemble().setAtomArrays(new ArrayList<Atom[]>());
  msa.getEnsemble().setAlgorithmName(CeSymm.algorithmName);
  msa.getEnsemble().setVersion(CeSymm.version);
  msa.getEnsemble().setStructureNames(new ArrayList<String>());
  BlockSet bs=new BlockSetImpl(msa);
  Block b=new BlockImpl(bs);
  b.setAlignRes(new ArrayList<List<Integer>>());
  List<List<Integer>> groups=new ArrayList<List<Integer>>();
  List<Integer> alreadySeen=new ArrayList<Integer>();
  int size=0;
  for (int i=0; i < alignGraph.size(); i++) {
    if (!alreadySeen.contains(i)) {
      List<Integer> group=new ArrayList<Integer>();
      List<Integer> residues=new ArrayList<Integer>();
      residues.add(i);
      while (residues.size() > 0) {
        List<Integer> newResidues=new ArrayList<Integer>();
        for (        Integer residue : residues) {
          group.add(residue);
          alreadySeen.add(residue);
          List<Integer> children=alignGraph.get(residue);
          newResidues.addAll(children);
        }
        residues=newResidues;
      }
      Collections.sort(group);
      groups.add(group);
      if (group.size() > size)       size=group.size();
    }
  }
  for (int su=0; su < size; su++) {
    msa.getEnsemble().getStructureNames().add(""String_Node_Str"" + (su + 1));
    msa.getEnsemble().getAtomArrays().add(allAtoms);
    b.getAlignRes().add(new ArrayList<Integer>());
    for (    List<Integer> group : groups) {
      if (group.size() != size)       continue;
      b.getAlignRes().get(su).add(group.get(su));
    }
  }
}","/** 
 * After all the analysis iteratives have finished, the final MultipleAlignment object is constructed using the alignment graph.
 * @throws StructureException
 */
private void buildAlignment() throws StructureException {
  msa=new MultipleAlignmentImpl();
  msa.getEnsemble().setAtomArrays(new ArrayList<Atom[]>());
  msa.getEnsemble().setAlgorithmName(CeSymm.algorithmName);
  msa.getEnsemble().setVersion(CeSymm.version);
  msa.getEnsemble().setStructureNames(new ArrayList<String>());
  BlockSet bs=new BlockSetImpl(msa);
  Block b=new BlockImpl(bs);
  b.setAlignRes(new ArrayList<List<Integer>>());
  List<List<Integer>> groups=new ArrayList<List<Integer>>();
  List<Integer> alreadySeen=new ArrayList<Integer>();
  for (int i=0; i < alignGraph.size(); i++) {
    if (!alreadySeen.contains(i)) {
      List<Integer> group=new ArrayList<Integer>();
      List<Integer> residues=new ArrayList<Integer>();
      residues.add(i);
      while (residues.size() > 0) {
        List<Integer> newResidues=new ArrayList<Integer>();
        for (        Integer residue : residues) {
          group.add(residue);
          alreadySeen.add(residue);
          List<Integer> children=alignGraph.get(residue);
          newResidues.addAll(children);
        }
        residues=newResidues;
      }
      Collections.sort(group);
      groups.add(group);
    }
  }
  int order=01;
  for (  MultipleAlignment m : levels)   order*=m.size();
  for (int su=0; su < order; su++) {
    msa.getEnsemble().getStructureNames().add(""String_Node_Str"" + (su + 1));
    msa.getEnsemble().getAtomArrays().add(allAtoms);
    b.getAlignRes().add(new ArrayList<Integer>());
    for (    List<Integer> group : groups) {
      if (group.size() != order)       continue;
      b.getAlignRes().get(su).add(group.get(su));
    }
  }
}",0.5138580931263859
16579,"/** 
 * This method uses iteratively CeSymm to calculate all symmetries in the input array of atoms and organize them in a multiple alignment of the subunits.
 * @param atoms atoms
 * @return MultipleAlignment of the subunits
 * @throws StructureException
 */
public MultipleAlignment execute(Atom[] atoms) throws StructureException {
  allAtoms=atoms;
  for (Integer res=0; res < allAtoms.length; res++) {
    alignGraph.add(new ArrayList<Integer>());
  }
  boolean symm=iterate(atoms);
  if (symm)   buildAlignment();
 else {
    levels.add(msa);
  }
  recoverAxes();
  return msa;
}","/** 
 * This method uses iteratively CeSymm to calculate all symmetries in the input array of atoms and organize them in a multiple alignment of the subunits.
 * @param atoms atoms
 * @return MultipleAlignment of the subunits
 * @throws StructureException
 */
public MultipleAlignment execute(Atom[] atoms) throws StructureException {
  allAtoms=atoms;
  for (Integer res=0; res < allAtoms.length; res++) {
    alignGraph.add(new ArrayList<Integer>());
  }
  boolean symm=iterate(atoms);
  if (symm)   buildAlignment();
 else   levels.add(msa);
  recoverAxes();
  return msa;
}",0.9432013769363168
16580,"/** 
 * Calculates the set of symmetry operation Matrices (transformations) of the new alignment, based on the symmetry relations in the SymmetryAxes object. <p> If the SymmetryAxes object is null, the superposition of the subunits is done without contraint.
 */
private void updateTransformation() throws StructureException, RefinerFailedException {
  if (msa.getCoreLength() == 0)   throw new RefinerFailedException(""String_Node_Str"");
  if (axes != null) {
    for (int t=0; t < axes.getElementaryAxes().size(); t++) {
      Matrix4d axis=axes.getElementaryAxes().get(t);
      List<Integer> chain1=axes.getSubunitRelation(t).get(0);
      List<Integer> chain2=axes.getSubunitRelation(t).get(1);
      List<Atom> list1=new ArrayList<Atom>();
      List<Atom> list2=new ArrayList<Atom>();
      for (int pair=0; pair < chain1.size(); pair++) {
        int p1=chain1.get(pair);
        int p2=chain2.get(pair);
        for (int k=0; k < length; k++) {
          Integer pos1=block.get(p1).get(k);
          Integer pos2=block.get(p2).get(k);
          if (pos1 != null && pos2 != null) {
            list1.add(atoms[pos1]);
            list2.add(atoms[pos2]);
          }
        }
      }
      Atom[] arr1=list1.toArray(new Atom[list1.size()]);
      Atom[] arr2=list2.toArray(new Atom[list2.size()]);
      SVDSuperimposer svd=new SVDSuperimposer(arr1,arr2);
      axis=svd.getTransformation();
      axes.updateAxis(t,axis);
    }
  }
 else {
    MultipleSuperimposer imposer=new CoreSuperimposer();
    imposer.superimpose(msa);
  }
}","/** 
 * Calculates the set of symmetry operation Matrices (transformations) of the new alignment, based on the symmetry relations in the SymmetryAxes object. <p> If the SymmetryAxes object is null, the superposition of the subunits is done without contraint.
 */
private void updateTransformation() throws StructureException, RefinerFailedException {
  if (axes != null) {
    for (int t=0; t < axes.getElementaryAxes().size(); t++) {
      Matrix4d axis=axes.getElementaryAxes().get(t);
      List<Integer> chain1=axes.getSubunitRelation(t).get(0);
      List<Integer> chain2=axes.getSubunitRelation(t).get(1);
      List<Atom> list1=new ArrayList<Atom>();
      List<Atom> list2=new ArrayList<Atom>();
      for (int pair=0; pair < chain1.size(); pair++) {
        int p1=chain1.get(pair);
        int p2=chain2.get(pair);
        for (int k=0; k < length; k++) {
          Integer pos1=block.get(p1).get(k);
          Integer pos2=block.get(p2).get(k);
          if (pos1 != null && pos2 != null) {
            list1.add(atoms[pos1]);
            list2.add(atoms[pos2]);
          }
        }
      }
      Atom[] arr1=list1.toArray(new Atom[list1.size()]);
      Atom[] arr2=list2.toArray(new Atom[list2.size()]);
      if (arr1.length > 0 && arr2.length > 0) {
        SVDSuperimposer svd=new SVDSuperimposer(arr1,arr2);
        axis=svd.getTransformation();
        axes.updateAxis(t,axis);
      }
    }
  }
 else {
    MultipleSuperimposer imposer=new CoreSuperimposer();
    imposer.superimpose(msa);
  }
}",0.951227495908347
16581,"/** 
 * {@inheritDoc}
 */
@Override public void addGroup(Group group){
  group.setChain(this);
  groups.add(group);
  String pdbResnum=null;
  ResidueNumber resNum=group.getResidueNumber();
  if (resNum != null)   pdbResnum=resNum.toString();
  if (pdbResnum != null) {
    Integer pos=groups.size() - 1;
    if (pdbResnumMap.containsKey(pdbResnum)) {
      if (group instanceof AminoAcid)       pdbResnumMap.put(pdbResnum,pos);
    }
 else     pdbResnumMap.put(pdbResnum,pos);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void addGroup(Group group){
  group.setChain(this);
  for (  Group g : group.getAltLocs()) {
    g.setChain(this);
  }
  groups.add(group);
  String pdbResnum=null;
  ResidueNumber resNum=group.getResidueNumber();
  if (resNum != null)   pdbResnum=resNum.toString();
  if (pdbResnum != null) {
    Integer pos=groups.size() - 1;
    if (pdbResnumMap.containsKey(pdbResnum)) {
      if (group instanceof AminoAcid)       pdbResnumMap.put(pdbResnum,pos);
    }
 else     pdbResnumMap.put(pdbResnum,pos);
  }
}",0.9351403678606002
16582,"private Group getCorrectAltLocGroup(Character altLoc,String recordName,Character aminoCode1,String groupCode3){
  List<Atom> atoms=current_group.getAtoms();
  if (atoms.size() > 0) {
    Atom a1=atoms.get(0);
    if (a1.getAltLoc().equals(altLoc)) {
      return current_group;
    }
  }
  List<Group> altLocs=current_group.getAltLocs();
  for (  Group altLocG : altLocs) {
    atoms=altLocG.getAtoms();
    if (atoms.size() > 0) {
      for (      Atom a1 : atoms) {
        if (a1.getAltLoc().equals(altLoc)) {
          return altLocG;
        }
      }
    }
  }
  if (groupCode3.equals(current_group.getPDBName())) {
    if (current_group.getAtoms().size() == 0) {
      return current_group;
    }
    Group altLocG=(Group)current_group.clone();
    altLocG.setAtoms(new ArrayList<Atom>());
    current_group.addAltLoc(altLocG);
    return altLocG;
  }
  Group altLocG=getNewGroup(recordName,aminoCode1,groupCode3);
  altLocG.setPDBName(groupCode3);
  altLocG.setResidueNumber(current_group.getResidueNumber());
  current_group.addAltLoc(altLocG);
  return altLocG;
}","private Group getCorrectAltLocGroup(Character altLoc,String recordName,Character aminoCode1,String groupCode3){
  List<Atom> atoms=current_group.getAtoms();
  if (atoms.size() > 0) {
    Atom a1=atoms.get(0);
    if (a1.getAltLoc().equals(altLoc)) {
      return current_group;
    }
  }
  List<Group> altLocs=current_group.getAltLocs();
  for (  Group altLocG : altLocs) {
    atoms=altLocG.getAtoms();
    if (atoms.size() > 0) {
      for (      Atom a1 : atoms) {
        if (a1.getAltLoc().equals(altLoc)) {
          return altLocG;
        }
      }
    }
  }
  if (groupCode3.equals(current_group.getPDBName())) {
    if (current_group.getAtoms().size() == 0) {
      return current_group;
    }
    Group altLocG=(Group)current_group.clone();
    altLocG.setAtoms(new ArrayList<Atom>());
    altLocG.getAltLocs().clear();
    current_group.addAltLoc(altLocG);
    return altLocG;
  }
  Group altLocG=getNewGroup(recordName,aminoCode1,groupCode3);
  altLocG.setPDBName(groupCode3);
  altLocG.setResidueNumber(current_group.getResidueNumber());
  current_group.addAltLoc(altLocG);
  return altLocG;
}",0.9844036697247708
16583,"/** 
 * returns and identical copy of this Group object .
 * @return  and identical copy of this Group object
 */
@Override public Object clone(){
  AminoAcidImpl n=new AminoAcidImpl();
  n.setPDBFlag(has3D());
  n.setResidueNumber(getResidueNumber());
  n.setPDBName(getPDBName());
  n.setAminoType(getAminoType());
  n.setRecordType(recordType);
  for (  Atom atom1 : atoms) {
    Atom atom=(Atom)atom1.clone();
    n.addAtom(atom);
    atom.setGroup(n);
  }
  return n;
}","/** 
 * returns and identical copy of this Group object .
 * @return  and identical copy of this Group object
 */
@Override public Object clone(){
  AminoAcidImpl n=new AminoAcidImpl();
  n.setPDBFlag(has3D());
  n.setResidueNumber(getResidueNumber());
  n.setPDBName(getPDBName());
  n.setAminoType(getAminoType());
  n.setRecordType(recordType);
  for (  Atom atom1 : atoms) {
    Atom atom=(Atom)atom1.clone();
    n.addAtom(atom);
    atom.setGroup(n);
  }
  if (getAltLocs() != null && !getAltLocs().isEmpty()) {
    for (    Group altLocGroup : this.getAltLocs()) {
      Group nAltLocGroup=(Group)altLocGroup.clone();
      n.addAltLoc(nAltLocGroup);
    }
  }
  return n;
}",0.8034632034632034
16584,"/** 
 * returns and identical copy of this Group object .
 * @return  and identical copy of this Group object
 */
@Override public Object clone(){
  HetatomImpl n=new HetatomImpl();
  n.setPDBFlag(has3D());
  n.setResidueNumber(residueNumber);
  n.setPDBName(getPDBName());
  for (  Atom atom1 : atoms) {
    Atom atom=(Atom)atom1.clone();
    n.addAtom(atom);
    atom.setGroup(n);
  }
  return n;
}","/** 
 * returns and identical copy of this Group object .
 * @return  and identical copy of this Group object
 */
@Override public Object clone(){
  HetatomImpl n=new HetatomImpl();
  n.setPDBFlag(has3D());
  n.setResidueNumber(residueNumber);
  n.setPDBName(getPDBName());
  for (  Atom atom1 : atoms) {
    Atom atom=(Atom)atom1.clone();
    n.addAtom(atom);
    atom.setGroup(n);
  }
  if (altLocs != null) {
    for (    Group altLocGroup : this.altLocs) {
      Group nAltLocGroup=(Group)altLocGroup.clone();
      n.addAltLoc(nAltLocGroup);
    }
  }
  return n;
}",0.8041237113402062
16585,"@Override public Object clone(){
  NucleotideImpl n=new NucleotideImpl();
  n.setPDBFlag(has3D());
  n.setResidueNumber(getResidueNumber());
  n.setPDBName(getPDBName());
  for (  Atom atom1 : atoms) {
    Atom atom=(Atom)atom1.clone();
    n.addAtom(atom);
    atom.setGroup(n);
  }
  return n;
}","@Override public Object clone(){
  NucleotideImpl n=new NucleotideImpl();
  n.setPDBFlag(has3D());
  n.setResidueNumber(getResidueNumber());
  n.setPDBName(getPDBName());
  for (  Atom atom1 : atoms) {
    Atom atom=(Atom)atom1.clone();
    n.addAtom(atom);
    atom.setGroup(n);
  }
  if (getAltLocs() != null && !getAltLocs().isEmpty()) {
    for (    Group altLocGroup : this.getAltLocs()) {
      Group nAltLocGroup=(Group)altLocGroup.clone();
      n.addAltLoc(nAltLocGroup);
    }
  }
  return n;
}",0.7166042446941323
16586,"private void compareCloned(Structure s,Structure c) throws StructureException {
  assertEquals(s.getChains().size(),c.getChains().size());
  for (  Chain chain : s.getChains()) {
    Chain test=c.getChainByPDB(chain.getChainID());
    assertEquals(""String_Node_Str"" + chain.getChainID(),chain.getSeqResLength(),test.getSeqResLength());
    assertEquals(""String_Node_Str"" + chain.getChainID(),chain.getAtomLength(),test.getAtomLength());
  }
  Atom[] allAtoms=StructureTools.getAllAtomArray(s);
  Atom[] allAtomsCloned=StructureTools.getAllAtomArray(c);
  assertEquals(allAtoms.length,allAtomsCloned.length);
}","private void compareCloned(Structure s,Structure c) throws StructureException {
  assertEquals(s.getChains().size(),c.getChains().size());
  for (  Chain chain : s.getChains()) {
    Chain test=c.getChainByPDB(chain.getChainID());
    assertEquals(""String_Node_Str"" + chain.getChainID(),chain.getSeqResLength(),test.getSeqResLength());
    assertEquals(""String_Node_Str"" + chain.getChainID(),chain.getAtomLength(),test.getAtomLength());
    Iterator<Group> it=test.getAtomGroups().iterator();
    for (    Group g : chain.getAtomGroups()) {
      Group testGroup=it.next();
      assertEquals(g.getAltLocs().size(),testGroup.getAltLocs().size());
    }
  }
  Atom[] allAtoms=StructureTools.getAllAtomArray(s);
  Atom[] allAtomsCloned=StructureTools.getAllAtomArray(c);
  assertEquals(allAtoms.length,allAtomsCloned.length);
}",0.8493723849372385
16587,"/** 
 * Get the String form of this identifier.
 * @return The String form of this identifier
 */
String getIdentifier();","/** 
 * Get the String form of this identifier. It is recommended that the   {@link #toString()} method also return theidentifier, for consistency during serialization.
 * @return The String form of this identifier
 */
String getIdentifier();",0.6666666666666666
16588,"@Override public String toString(){
  StringBuilder s=new StringBuilder();
  s.append(name);
  s.append(""String_Node_Str"");
  try {
    String id=getPdbId();
    s.append(""String_Node_Str"");
    s.append(id);
    s.append(""String_Node_Str"");
  }
 catch (  StructureException e) {
  }
  s.append(""String_Node_Str"");
  s.append(mySource);
  s.append(""String_Node_Str"");
  return s.toString();
}","@Override public String toString(){
  return name;
}",0.2207207207207207
16589,"@Override public String toString(){
  String resume=""String_Node_Str"" + parent.getStructureIdentifiers() + ""String_Node_Str""+ parent.getAlgorithmName()+ ""String_Node_Str""+ parent.getVersion()+ ""String_Node_Str""+ getBlockSets().size()+ ""String_Node_Str""+ getBlocks().size()+ ""String_Node_Str""+ length()+ ""String_Node_Str""+ getCoreLength();
  for (  String score : getScores()) {
    resume+=""String_Node_Str"" + score + ""String_Node_Str"";
    resume+=String.format(""String_Node_Str"",getScore(score));
  }
  return resume;
}","@Override public String toString(){
  List<String> ids=new ArrayList<String>(parent.getStructureIdentifiers().size());
  for (  StructureIdentifier i : parent.getStructureIdentifiers()) {
    ids.add(i.getIdentifier());
  }
  String resume=""String_Node_Str"" + ids + ""String_Node_Str""+ parent.getAlgorithmName()+ ""String_Node_Str""+ parent.getVersion()+ ""String_Node_Str""+ getBlockSets().size()+ ""String_Node_Str""+ getBlocks().size()+ ""String_Node_Str""+ length()+ ""String_Node_Str""+ getCoreLength();
  for (  String score : getScores()) {
    resume+=""String_Node_Str"" + score + ""String_Node_Str"";
    resume+=String.format(""String_Node_Str"",getScore(score));
  }
  return resume;
}",0.8143213988343048
16590,"/** 
 * Converts the   {@link MultipleAlignment} into a multiple sequence alignmentString in FASTA format.
 * @param alignment MultipleAlignment
 * @return String multiple sequence alignment in FASTA format
 * @see MultipleAlignmentTools#getSequenceAlignment(MultipleAlignment)
 */
public static String toFASTA(MultipleAlignment alignment){
  List<String> alnSequences=MultipleAlignmentTools.getSequenceAlignment(alignment);
  String fasta=""String_Node_Str"";
  for (int st=0; st < alignment.size(); st++) {
    fasta+=""String_Node_Str"" + alignment.getEnsemble().getStructureIdentifiers().get(st) + ""String_Node_Str""+ alnSequences.get(st)+ ""String_Node_Str"";
  }
  return fasta;
}","/** 
 * Converts the   {@link MultipleAlignment} into a multiple sequence alignmentString in FASTA format.
 * @param alignment MultipleAlignment
 * @return String multiple sequence alignment in FASTA format
 * @see MultipleAlignmentTools#getSequenceAlignment(MultipleAlignment)
 */
public static String toFASTA(MultipleAlignment alignment){
  List<String> alnSequences=MultipleAlignmentTools.getSequenceAlignment(alignment);
  String fasta=""String_Node_Str"";
  for (int st=0; st < alignment.size(); st++) {
    fasta+=""String_Node_Str"" + alignment.getEnsemble().getStructureIdentifiers().get(st).getIdentifier() + ""String_Node_Str""+ alnSequences.get(st)+ ""String_Node_Str"";
  }
  return fasta;
}",0.9883551673944688
16591,"@Test public void testAFPconversion() throws Exception {
  AFPChain afp=new AFPChain(""String_Node_Str"");
  afp.setName1(""String_Node_Str"");
  afp.setName2(""String_Node_Str"");
  afp.setVersion(""String_Node_Str"");
  afp.setCalculationTime(System.currentTimeMillis());
  int[][][] optAln=new int[3][][];
  for (int b=0; b < optAln.length; b++) {
    int[][] block=new int[2][];
    for (int c=0; c < block.length; c++) {
      int[] residues={b + 5,b + 6,b + 7,b + 8,b + 9};
      block[c]=residues;
    }
    optAln[b]=block;
  }
  afp.setOptAln(optAln);
  afp.setBlockNum(optAln.length);
  double[][] mat={{0.13,1.5,0.84},{1.3,0.44,2.3},{1.0,1.2,2.03}};
  Matrix rot=new Matrix(mat);
  Atom shift=new AtomImpl();
  shift.setX(0.44);
  shift.setY(0.21);
  shift.setZ(0.89);
  Matrix[] blockRot={rot,rot,rot};
  afp.setBlockRotationMatrix(blockRot);
  Atom[] blockShift={shift,shift,shift};
  afp.setBlockShiftVector(blockShift);
  MultipleAlignmentEnsemble ensemble=new MultipleAlignmentEnsembleImpl(afp,null,null,true);
  MultipleAlignment msa=ensemble.getMultipleAlignment(0);
  assertEquals(afp.getName1(),ensemble.getStructureIdentifiers().get(0));
  assertEquals(afp.getName2(),ensemble.getStructureIdentifiers().get(1));
  assertEquals(afp.getAlgorithmName(),ensemble.getAlgorithmName());
  assertEquals(afp.getVersion(),ensemble.getVersion());
  assertTrue(ensemble.getCalculationTime().equals(afp.getCalculationTime()));
  assertEquals(afp.getBlockNum(),msa.getBlockSets().size());
  for (int b=0; b < afp.getBlockNum(); b++) {
    assertEquals(Calc.getTransformation(afp.getBlockRotationMatrix()[b],afp.getBlockShiftVector()[b]),msa.getBlockSet(b).getTransformations().get(1));
  }
  assertEquals(msa.getScore(MultipleAlignmentScorer.CE_SCORE),(Double)afp.getAlignScore());
  assertEquals(msa.getScore(MultipleAlignmentScorer.AVGTM_SCORE),(Double)afp.getTMScore());
  assertEquals(msa.getScore(MultipleAlignmentScorer.RMSD),(Double)afp.getTotalRmsdOpt());
  for (int b=0; b < 3; b++) {
    for (int c=0; c < 2; c++) {
      for (int res=0; res < 5; res++) {
        Integer afpRes=afp.getOptAln()[b][c][res];
        assertEquals(afpRes,msa.getBlock(b).getAlignRes().get(c).get(res));
      }
    }
  }
}","@Test public void testAFPconversion() throws Exception {
  AFPChain afp=new AFPChain(""String_Node_Str"");
  afp.setName1(""String_Node_Str"");
  afp.setName2(""String_Node_Str"");
  afp.setVersion(""String_Node_Str"");
  afp.setCalculationTime(System.currentTimeMillis());
  int[][][] optAln=new int[3][][];
  for (int b=0; b < optAln.length; b++) {
    int[][] block=new int[2][];
    for (int c=0; c < block.length; c++) {
      int[] residues={b + 5,b + 6,b + 7,b + 8,b + 9};
      block[c]=residues;
    }
    optAln[b]=block;
  }
  afp.setOptAln(optAln);
  afp.setBlockNum(optAln.length);
  double[][] mat={{0.13,1.5,0.84},{1.3,0.44,2.3},{1.0,1.2,2.03}};
  Matrix rot=new Matrix(mat);
  Atom shift=new AtomImpl();
  shift.setX(0.44);
  shift.setY(0.21);
  shift.setZ(0.89);
  Matrix[] blockRot={rot,rot,rot};
  afp.setBlockRotationMatrix(blockRot);
  Atom[] blockShift={shift,shift,shift};
  afp.setBlockShiftVector(blockShift);
  MultipleAlignmentEnsemble ensemble=new MultipleAlignmentEnsembleImpl(afp,null,null,true);
  MultipleAlignment msa=ensemble.getMultipleAlignment(0);
  assertEquals(afp.getName1(),ensemble.getStructureIdentifiers().get(0).getIdentifier());
  assertEquals(afp.getName2(),ensemble.getStructureIdentifiers().get(1).getIdentifier());
  assertEquals(afp.getAlgorithmName(),ensemble.getAlgorithmName());
  assertEquals(afp.getVersion(),ensemble.getVersion());
  assertTrue(ensemble.getCalculationTime().equals(afp.getCalculationTime()));
  assertEquals(afp.getBlockNum(),msa.getBlockSets().size());
  for (int b=0; b < afp.getBlockNum(); b++) {
    assertEquals(Calc.getTransformation(afp.getBlockRotationMatrix()[b],afp.getBlockShiftVector()[b]),msa.getBlockSet(b).getTransformations().get(1));
  }
  assertEquals(msa.getScore(MultipleAlignmentScorer.CE_SCORE),(Double)afp.getAlignScore());
  assertEquals(msa.getScore(MultipleAlignmentScorer.AVGTM_SCORE),(Double)afp.getTMScore());
  assertEquals(msa.getScore(MultipleAlignmentScorer.RMSD),(Double)afp.getTotalRmsdOpt());
  for (int b=0; b < 3; b++) {
    for (int c=0; c < 2; c++) {
      for (int res=0; res < 5; res++) {
        Integer afpRes=afp.getOptAln()[b][c][res];
        assertEquals(afpRes,msa.getBlock(b).getAlignRes().get(c).get(res));
      }
    }
  }
}",0.9928154467894028
16592,"/** 
 * Transforms atoms according to the superposition stored in the alignment. <p> For each structure in the alignment, returns an atom for each representative atom in the aligned columns, omitting unaligned residues (i.e. an array of length <tt>alignment.length()</tt> ). <p> All blocks are concatenated together, so Atoms may not appear in the same order as in their parent structure. If the alignment blocks contain null residues (gaps), then the returned array will also contain null Atoms in the same positions.
 * @param alignment MultipleAlignment
 * @return List of Atom arrays of only the aligned atoms of every structure(null Atom if a gap position)
 */
public static List<Atom[]> transformAtoms(MultipleAlignment alignment){
  if (alignment.getEnsemble() == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  List<Atom[]> atomArrays=alignment.getAtomArrays();
  List<Atom[]> transformed=new ArrayList<Atom[]>(atomArrays.size());
  for (int i=0; i < atomArrays.size(); i++) {
    Matrix4d transform=null;
    Atom[] curr=atomArrays.get(i);
    Atom[] transformedAtoms=new Atom[alignment.length()];
    int transformedAtomsLength=0;
    for (    BlockSet bs : alignment.getBlockSets()) {
      Atom[] blocksetAtoms=new Atom[bs.length()];
      for (      Block blk : bs.getBlocks()) {
        if (blk.size() != atomArrays.size()) {
          throw new IllegalStateException(String.format(""String_Node_Str"" + ""String_Node_Str"",atomArrays.size(),blk.size()));
        }
        for (int j=0; j < blk.length(); j++) {
          Integer alignedPos=blk.getAlignRes().get(i).get(j);
          if (alignedPos != null) {
            blocksetAtoms[j]=(Atom)curr[alignedPos].clone();
          }
        }
      }
      Matrix4d blockTrans=null;
      if (bs.getTransformations() != null)       blockTrans=bs.getTransformations().get(i);
      if (blockTrans == null) {
        blockTrans=transform;
      }
      for (      Atom a : blocksetAtoms) {
        if (a != null)         Calc.transform(a,blockTrans);
        transformedAtoms[transformedAtomsLength]=a;
        transformedAtomsLength++;
      }
    }
    assert(transformedAtomsLength == alignment.length());
    transformed.add(transformedAtoms);
  }
  return transformed;
}","/** 
 * Transforms atoms according to the superposition stored in the alignment. <p> For each structure in the alignment, returns an atom for each representative atom in the aligned columns, omitting unaligned residues (i.e. an array of length <tt>alignment.length()</tt> ). <p> All blocks are concatenated together, so Atoms may not appear in the same order as in their parent structure. If the alignment blocks contain null residues (gaps), then the returned array will also contain null Atoms in the same positions.
 * @param alignment MultipleAlignment
 * @return List of Atom arrays of only the aligned atoms of every structure(null Atom if a gap position)
 */
public static List<Atom[]> transformAtoms(MultipleAlignment alignment){
  if (alignment.getEnsemble() == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  List<Atom[]> atomArrays=alignment.getAtomArrays();
  List<Atom[]> transformed=new ArrayList<Atom[]>(atomArrays.size());
  for (int i=0; i < atomArrays.size(); i++) {
    Matrix4d transform=null;
    Atom[] curr=atomArrays.get(i);
    Atom[] transformedAtoms=new Atom[alignment.length()];
    int transformedAtomsLength=0;
    for (    BlockSet bs : alignment.getBlockSets()) {
      Atom[] blocksetAtoms=new Atom[bs.length()];
      int blockPos=0;
      for (      Block blk : bs.getBlocks()) {
        if (blk.size() != atomArrays.size()) {
          throw new IllegalStateException(String.format(""String_Node_Str"" + ""String_Node_Str"",atomArrays.size(),blk.size()));
        }
        for (int j=0; j < blk.length(); j++) {
          Integer alignedPos=blk.getAlignRes().get(i).get(j);
          if (alignedPos != null) {
            blocksetAtoms[blockPos]=(Atom)curr[alignedPos].clone();
          }
          blockPos++;
        }
      }
      Matrix4d blockTrans=null;
      if (bs.getTransformations() != null)       blockTrans=bs.getTransformations().get(i);
      if (blockTrans == null) {
        blockTrans=transform;
      }
      for (      Atom a : blocksetAtoms) {
        if (a != null)         Calc.transform(a,blockTrans);
        transformedAtoms[transformedAtomsLength]=a;
        transformedAtomsLength++;
      }
    }
    assert(transformedAtomsLength == alignment.length());
    transformed.add(transformedAtoms);
  }
  return transformed;
}",0.988379741284806
16593,"private void calcAlignment(){
  int pos=tabPane.getSelectedIndex();
  StructurePairSelector tab=null;
  if (pos == 0) {
    tab=tab1;
  }
 else   if (pos == 1) {
    tab=tab3;
  }
 else   if (pos == 2) {
    tab=tab2;
  }
  try {
    Structure s=tab.getStructure1();
    if (s == null) {
      System.err.println(""String_Node_Str"");
      return;
    }
    String name=""String_Node_Str"";
    if (pos == 0) {
      name=tab1.getName1();
    }
 else {
      name=s.getName();
    }
    System.out.println(""String_Node_Str"" + name);
    alicalc=new SymmetryCalc(this,s,name);
    thread=new Thread(alicalc);
    thread.start();
    abortB.setEnabled(true);
    progress.setIndeterminate(true);
    ProgressThreadDrawer drawer=new ProgressThreadDrawer(progress);
    drawer.start();
  }
 catch (  StructureException e) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"" + e.getMessage());
  }
  updateAlgorithm();
}","private void calcAlignment(){
  int pos=tabPane.getSelectedIndex();
  StructurePairSelector tab=null;
  if (pos == 0) {
    tab=tab1;
  }
 else   if (pos == 1) {
    tab=tab3;
  }
 else   if (pos == 2) {
    tab=tab2;
  }
  try {
    Structure s=tab.getStructure1();
    if (s == null) {
      System.err.println(""String_Node_Str"");
      return;
    }
    String name=""String_Node_Str"";
    if (pos == 0) {
      name=tab1.getName1();
    }
 else {
      name=s.getName();
    }
    System.out.println(""String_Node_Str"" + name);
    alicalc=new SymmetryCalc(this,s,name);
    thread=new Thread(alicalc);
    thread.start();
    abortB.setEnabled(true);
    progress.setIndeterminate(true);
    ProgressThreadDrawer drawer=new ProgressThreadDrawer(progress);
    drawer.start();
  }
 catch (  StructureException e) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"" + e.getMessage());
  }
}",0.988442487616951
16594,"private Box setupAlgorithm(){
  String[] algorithms={""String_Node_Str""};
  updateAlgorithm();
  JLabel algoLabel=new JLabel(""String_Node_Str"");
  JComboBox algorithmList=new JComboBox(algorithms);
  algorithmList.setSelectedIndex(0);
  Action actionAlgorithm=new AbstractAction(""String_Node_Str""){
    public static final long serialVersionUID=0l;
    @Override public void actionPerformed(    ActionEvent evt){
      updateAlgorithm();
    }
  }
;
  algorithmList.addActionListener(actionAlgorithm);
  Action paramAction=new AbstractAction(""String_Node_Str""){
    public static final long serialVersionUID=0l;
    @Override public void actionPerformed(    ActionEvent evt){
      configureParameters();
    }
  }
;
  JButton parameterButton=new JButton(paramAction);
  Box hBoxAlgo=Box.createHorizontalBox();
  hBoxAlgo.add(Box.createGlue());
  hBoxAlgo.add(algoLabel);
  hBoxAlgo.add(algorithmList);
  hBoxAlgo.add(Box.createGlue());
  hBoxAlgo.add(parameterButton);
  hBoxAlgo.add(Box.createGlue());
  return hBoxAlgo;
}","private Box setupAlgorithm(){
  String[] algorithms={""String_Node_Str""};
  JLabel algoLabel=new JLabel(""String_Node_Str"");
  JComboBox algorithmList=new JComboBox(algorithms);
  algorithmList.setSelectedIndex(0);
  Action paramAction=new AbstractAction(""String_Node_Str""){
    public static final long serialVersionUID=0l;
    @Override public void actionPerformed(    ActionEvent evt){
      configureParameters();
    }
  }
;
  JButton parameterButton=new JButton(paramAction);
  Box hBoxAlgo=Box.createHorizontalBox();
  hBoxAlgo.add(Box.createGlue());
  hBoxAlgo.add(algoLabel);
  hBoxAlgo.add(algorithmList);
  hBoxAlgo.add(Box.createGlue());
  hBoxAlgo.add(parameterButton);
  hBoxAlgo.add(Box.createGlue());
  return hBoxAlgo;
}",0.4368600682593856
16595,"public MultipleAlignment analyze(Atom[] atoms,CESymmParameters param) throws StructureException {
  if (atoms.length < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.params=param;
  AFPChain selfAFP=null;
  if (params.isMultipleAxes() && params.getRefineMethod() != RefineMethod.NOT_REFINED) {
    logger.info(""String_Node_Str"");
    CeSymmIterative iterative=new CeSymmIterative(params.clone());
    msa=iterative.execute(atoms);
    axes=iterative.getSymmetryAxes();
    if (SymmetryTools.isRefined(msa)) {
      refined=true;
    }
 else {
      selfAFP=align(atoms);
      msa=null;
    }
  }
 else {
    selfAFP=align(atoms);
  }
  if (refined) {
    if (msa == null)     msa=SymmetryTools.fromAFP(selfAFP,atoms);
    CoreSuperimposer imposer=new CoreSuperimposer();
    imposer.superimpose(msa);
    MultipleAlignmentScorer.calculateScores(msa);
    msa.putScore(""String_Node_Str"",1.0);
    if (this.params.getOptimization()) {
      try {
        SymmOptimizer optimizer=new SymmOptimizer(msa,axes,params,params.getSeed());
        msa=optimizer.optimize();
        msa.putScore(""String_Node_Str"",1.0);
      }
 catch (      RefinerFailedException e) {
        logger.info(""String_Node_Str"" + e.getMessage());
      }
    }
  }
 else {
    MultipleAlignmentEnsemble e=new MultipleAlignmentEnsembleImpl(selfAFP,atoms,atoms,false);
    msa=e.getMultipleAlignment(0);
    logger.info(""String_Node_Str"");
    msa.putScore(""String_Node_Str"",0.0);
  }
  return msa;
}","public MultipleAlignment analyze(Atom[] atoms,CESymmParameters param) throws StructureException {
  reset();
  if (atoms.length < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.params=param;
  AFPChain selfAFP=null;
  if (params.isMultipleAxes() && params.getRefineMethod() != RefineMethod.NOT_REFINED) {
    logger.info(""String_Node_Str"");
    CeSymmIterative iterative=new CeSymmIterative(params.clone());
    msa=iterative.execute(atoms);
    axes=iterative.getSymmetryAxes();
    if (SymmetryTools.isRefined(msa)) {
      refined=true;
    }
 else {
      selfAFP=align(atoms);
      msa=null;
    }
  }
 else {
    selfAFP=align(atoms);
  }
  if (refined) {
    if (msa == null)     msa=SymmetryTools.fromAFP(selfAFP,atoms);
    CoreSuperimposer imposer=new CoreSuperimposer();
    imposer.superimpose(msa);
    MultipleAlignmentScorer.calculateScores(msa);
    msa.putScore(""String_Node_Str"",1.0);
    if (this.params.getOptimization()) {
      try {
        SymmOptimizer optimizer=new SymmOptimizer(msa,axes,params,params.getSeed());
        msa=optimizer.optimize();
        msa.putScore(""String_Node_Str"",1.0);
      }
 catch (      RefinerFailedException e) {
        logger.info(""String_Node_Str"" + e.getMessage());
      }
    }
  }
 else {
    MultipleAlignmentEnsemble e=new MultipleAlignmentEnsembleImpl(selfAFP,atoms,atoms,false);
    msa=e.getMultipleAlignment(0);
    logger.info(""String_Node_Str"");
    msa.putScore(""String_Node_Str"",0.0);
  }
  return msa;
}",0.9963369963369964
16596,"public CeSymm(){
  super();
  params=new CESymmParameters();
  refined=false;
}","public CeSymm(){
  reset();
}",0.4814814814814814
16597,"public boolean isSignificant() throws StructureException {
  double symmetryThreshold=this.params.getSymmetryThreshold();
  return isSignificant(this.msa,symmetryThreshold);
}","public boolean isSignificant() throws StructureException {
  double symmetryThreshold=params.getSymmetryThreshold();
  return SymmetryTools.isSignificant(msa,symmetryThreshold);
}",0.9322033898305084
16598,"protected AFPChain align(Atom[] ca10,Atom[] ca2O,Object param) throws StructureException {
  if (!(param instanceof CESymmParameters))   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  this.params=(CESymmParameters)param;
  ca1=ca10;
  ca2=StructureTools.duplicateCA2(ca2O);
  rows=ca1.length;
  cols=ca2.length;
  if (rows == 0 || cols == 0) {
    throw new StructureException(""String_Node_Str"");
  }
  Matrix origM=null;
  AFPChain myAFP=new AFPChain();
  afpAlignments=new ArrayList<AFPChain>();
  calculator=new CECalculator(params);
  boolean multiple=(params.getRefineMethod() == RefineMethod.MULTIPLE);
  Matrix lastMatrix=null;
  int i=0;
  do {
    if (origM != null) {
      myAFP.setDistanceMatrix((Matrix)origM.clone());
    }
    origM=align(myAFP,ca1,ca2,params,origM,calculator,i);
    double tmScore2=AFPChainScorer.getTMScore(myAFP,ca1,ca2);
    myAFP.setTMScore(tmScore2);
    AFPChain newAFP=(AFPChain)myAFP.clone();
    newAFP=CeCPMain.postProcessAlignment(newAFP,ca1,ca2,calculator);
    double tmScore3=AFPChainScorer.getTMScore(newAFP,ca1,ca2);
    newAFP.setTMScore(tmScore3);
    logger.debug(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ newAFP.getTMScore());
    if (tmScore3 < params.getSymmetryThreshold()) {
      logger.debug(""String_Node_Str"" + newAFP.getTMScore());
      if (i == 0)       afpAlignments.add(newAFP);
      lastMatrix=newAFP.getDistanceMatrix().copy();
      break;
    }
    afpAlignments.add(newAFP);
    i++;
  }
 while (i < params.getMaxSymmOrder() && multiple);
  if (lastMatrix == null && afpAlignments.size() > 1) {
    AFPChain last=afpAlignments.get(afpAlignments.size() - 1);
    lastMatrix=SymmetryTools.blankOutPreviousAlignment(last,ca2,last.getCa1Length(),last.getCa2Length(),calculator,origM,params.getWinSize());
    lastMatrix=lastMatrix.getMatrix(0,last.getCa1Length() - 1,0,last.getCa2Length() - 1);
  }
  afpChain=afpAlignments.get(0);
  String name=ca1[0].getGroup().getChain().getStructure().getIdentifier();
  afpChain.setName1(name);
  afpChain.setName2(name);
  if (params.getRefineMethod() == RefineMethod.NOT_REFINED) {
    return afpChain;
  }
  type=params.getSymmetryType();
  if (type == SymmetryType.AUTO) {
    if (afpChain.getBlockNum() == 1) {
      type=SymmetryType.OPEN;
      logger.info(""String_Node_Str"");
    }
 else {
      type=SymmetryType.CLOSE;
      logger.info(""String_Node_Str"");
    }
  }
  Refiner refiner=null;
  try {
switch (type) {
case CLOSE:
      OrderDetector orderDetector=null;
switch (params.getOrderDetectorMethod()) {
case SEQUENCE_FUNCTION:
      orderDetector=new SequenceFunctionOrderDetector(params.getMaxSymmOrder(),0.4f);
    order=orderDetector.calculateOrder(afpChain,ca1);
  break;
case USER_INPUT:
order=params.getUserOrder();
break;
}
refiner=new SingleRefiner();
break;
default :
refiner=new OpenRefiner();
order=params.getUserOrder();
break;
}
afpChain=refiner.refine(afpAlignments,ca1,order);
refined=true;
}
 catch (RefinerFailedException e) {
logger.info(""String_Node_Str"" + e.getMessage());
return afpChain;
}
int order=afpChain.getBlockNum();
axes=new SymmetryAxes();
Matrix rot=afpChain.getBlockRotationMatrix()[0];
Atom shift=afpChain.getBlockShiftVector()[0];
Matrix4d axis=Calc.getTransformation(rot,shift);
List<List<Integer>> superposition=new ArrayList<List<Integer>>();
List<Integer> chain1=new ArrayList<Integer>();
List<Integer> chain2=new ArrayList<Integer>();
superposition.add(chain1);
superposition.add(chain2);
List<Integer> subunitTrans=new ArrayList<Integer>();
switch (type) {
case CLOSE:
for (int bk=0; bk < order; bk++) {
chain1.add(bk);
chain2.add((bk + 1) % order);
subunitTrans.add(bk);
}
axes.addAxis(axis,superposition,subunitTrans,order);
break;
default :
subunitTrans.add(0);
for (int bk=0; bk < order - 1; bk++) {
chain1.add(bk);
chain2.add(bk + 1);
subunitTrans.add(bk + 1);
}
axes.addAxis(axis,superposition,subunitTrans,order);
break;
}
return afpChain;
}","protected AFPChain align(Atom[] ca1) throws StructureException {
  Atom[] ca2=StructureTools.duplicateCA2(ca1);
  int rows=ca1.length;
  int cols=ca2.length;
  if (rows == 0 || cols == 0) {
    throw new StructureException(""String_Node_Str"");
  }
  Matrix origM=null;
  AFPChain myAFP=new AFPChain();
  CECalculator calculator=new CECalculator(params);
  boolean multiple=(params.getRefineMethod() == RefineMethod.MULTIPLE);
  Matrix lastMatrix=null;
  int i=0;
  do {
    if (origM != null) {
      myAFP.setDistanceMatrix((Matrix)origM.clone());
    }
    origM=align(myAFP,ca1,ca2,params,origM,calculator,i);
    double tmScore2=AFPChainScorer.getTMScore(myAFP,ca1,ca2);
    myAFP.setTMScore(tmScore2);
    AFPChain newAFP=(AFPChain)myAFP.clone();
    newAFP=CeCPMain.postProcessAlignment(newAFP,ca1,ca2,calculator);
    double tmScore3=AFPChainScorer.getTMScore(newAFP,ca1,ca2);
    newAFP.setTMScore(tmScore3);
    logger.debug(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ newAFP.getTMScore());
    if (tmScore3 < params.getSymmetryThreshold()) {
      logger.debug(""String_Node_Str"" + newAFP.getTMScore());
      if (i == 0)       selfAlignments.add(newAFP);
      lastMatrix=newAFP.getDistanceMatrix().copy();
      break;
    }
    selfAlignments.add(newAFP);
    i++;
  }
 while (i < params.getMaxSymmOrder() && multiple);
  if (lastMatrix == null && selfAlignments.size() > 1) {
    AFPChain last=selfAlignments.get(selfAlignments.size() - 1);
    lastMatrix=SymmetryTools.blankOutPreviousAlignment(last,ca2,last.getCa1Length(),last.getCa2Length(),calculator,origM,params.getWinSize());
    lastMatrix=lastMatrix.getMatrix(0,last.getCa1Length() - 1,0,last.getCa2Length() - 1);
  }
  AFPChain optimalAFP=selfAlignments.get(0);
  if (ca1.length != 0 && ca1[0].getGroup().getChain() != null && ca1[0].getGroup().getChain().getStructure() != null) {
    String name=ca1[0].getGroup().getChain().getStructure().getName();
    optimalAFP.setName1(name);
    optimalAFP.setName2(name);
  }
  if (params.getRefineMethod() == RefineMethod.NOT_REFINED) {
    return optimalAFP;
  }
  SymmetryType type=params.getSymmetryType();
  if (type == SymmetryType.AUTO) {
    if (optimalAFP.getBlockNum() == 1) {
      type=SymmetryType.OPEN;
      logger.info(""String_Node_Str"");
    }
 else {
      type=SymmetryType.CLOSE;
      logger.info(""String_Node_Str"");
    }
  }
  Refiner refiner=null;
  int order=1;
  try {
switch (type) {
case CLOSE:
      OrderDetector orderDetector=null;
switch (params.getOrderDetectorMethod()) {
case SEQUENCE_FUNCTION:
      orderDetector=new SequenceFunctionOrderDetector(params.getMaxSymmOrder(),0.4f);
    order=orderDetector.calculateOrder(optimalAFP,ca1);
  break;
case USER_INPUT:
order=params.getUserOrder();
break;
}
refiner=new SingleRefiner();
break;
default :
refiner=new OpenRefiner();
order=params.getUserOrder();
break;
}
optimalAFP=refiner.refine(selfAlignments,ca1,order);
refined=true;
}
 catch (RefinerFailedException e) {
logger.info(""String_Node_Str"" + e.getMessage());
return optimalAFP;
}
order=optimalAFP.getBlockNum();
Matrix rot=optimalAFP.getBlockRotationMatrix()[0];
Atom shift=optimalAFP.getBlockShiftVector()[0];
Matrix4d axis=Calc.getTransformation(rot,shift);
List<List<Integer>> superposition=new ArrayList<List<Integer>>();
List<Integer> chain1=new ArrayList<Integer>();
List<Integer> chain2=new ArrayList<Integer>();
superposition.add(chain1);
superposition.add(chain2);
List<Integer> subunitTrans=new ArrayList<Integer>();
switch (type) {
case CLOSE:
for (int bk=0; bk < order; bk++) {
chain1.add(bk);
chain2.add((bk + 1) % order);
subunitTrans.add(bk);
}
axes.addAxis(axis,superposition,subunitTrans,order);
break;
default :
subunitTrans.add(0);
for (int bk=0; bk < order - 1; bk++) {
chain1.add(bk);
chain2.add(bk + 1);
subunitTrans.add(bk + 1);
}
axes.addAxis(axis,superposition,subunitTrans,order);
break;
}
return optimalAFP;
}",0.8232895910307045
16599,"public MultipleAlignment analyze(Atom[] atoms,CESymmParameters param) throws StructureException {
  if (atoms.length < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.params=param;
  if (params.isMultipleAxes() && params.getRefineMethod() != RefineMethod.NOT_REFINED) {
    logger.info(""String_Node_Str"");
    CeSymmIterative iterative=new CeSymmIterative(params.clone());
    msa=iterative.execute(atoms);
    axes=iterative.getSymmetryAxes();
    if (SymmetryTools.isRefined(msa)) {
      refined=true;
    }
 else {
      afpChain=align(atoms,atoms,params);
      msa=null;
    }
  }
 else {
    afpChain=align(atoms,atoms,params);
  }
  if (refined) {
    if (msa == null)     msa=SymmetryTools.fromAFP(afpChain,ca1);
    CoreSuperimposer imposer=new CoreSuperimposer();
    imposer.superimpose(msa);
    MultipleAlignmentScorer.calculateScores(msa);
    msa.putScore(""String_Node_Str"",1.0);
    if (this.params.getOptimization()) {
      try {
        SymmOptimizer optimizer=new SymmOptimizer(msa,axes,params,params.getSeed());
        msa=optimizer.optimize();
        msa.putScore(""String_Node_Str"",1.0);
      }
 catch (      RefinerFailedException e) {
        logger.info(""String_Node_Str"" + e.getMessage());
      }
    }
  }
 else {
    MultipleAlignmentEnsemble e=new MultipleAlignmentEnsembleImpl(afpChain,ca1,ca1,false);
    msa=e.getMultipleAlignment(0);
    logger.info(""String_Node_Str"");
    msa.putScore(""String_Node_Str"",0.0);
  }
  return msa;
}","public MultipleAlignment analyze(Atom[] atoms,CESymmParameters param) throws StructureException {
  if (atoms.length < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.params=param;
  AFPChain selfAFP=null;
  if (params.isMultipleAxes() && params.getRefineMethod() != RefineMethod.NOT_REFINED) {
    logger.info(""String_Node_Str"");
    CeSymmIterative iterative=new CeSymmIterative(params.clone());
    msa=iterative.execute(atoms);
    axes=iterative.getSymmetryAxes();
    if (SymmetryTools.isRefined(msa)) {
      refined=true;
    }
 else {
      selfAFP=align(atoms);
      msa=null;
    }
  }
 else {
    selfAFP=align(atoms);
  }
  if (refined) {
    if (msa == null)     msa=SymmetryTools.fromAFP(selfAFP,atoms);
    CoreSuperimposer imposer=new CoreSuperimposer();
    imposer.superimpose(msa);
    MultipleAlignmentScorer.calculateScores(msa);
    msa.putScore(""String_Node_Str"",1.0);
    if (this.params.getOptimization()) {
      try {
        SymmOptimizer optimizer=new SymmOptimizer(msa,axes,params,params.getSeed());
        msa=optimizer.optimize();
        msa.putScore(""String_Node_Str"",1.0);
      }
 catch (      RefinerFailedException e) {
        logger.info(""String_Node_Str"" + e.getMessage());
      }
    }
  }
 else {
    MultipleAlignmentEnsemble e=new MultipleAlignmentEnsembleImpl(selfAFP,atoms,atoms,false);
    msa=e.getMultipleAlignment(0);
    logger.info(""String_Node_Str"");
    msa.putScore(""String_Node_Str"",0.0);
  }
  return msa;
}",0.9414911400869276
16600,"public void process() throws Exception {
  if (matrix == null) {
    double[][] distances=calculateDistanceMatrix(multipleSequenceAlignment,treeConstructionAlgorithm);
    matrix=new BasicSymmetricalDistanceMatrix(multipleSequenceAlignment.getSize());
    for (int i=0; i < matrix.getSize(); i++) {
      matrix.setIdentifier(i,multipleSequenceAlignment.getAlignedSequence(i).getAccession().getID());
    }
    for (int col=0; col < matrix.getSize(); col++) {
      for (int row=0; row < matrix.getSize(); row++) {
        matrix.setValue(col,row,distances[col][row]);
      }
    }
    copyDistanceMatrix=CheckTreeAccuracy.copyMatrix(matrix);
  }
  final List<Phylogeny> ps=new ArrayList<Phylogeny>();
  final NeighborJoining nj=NeighborJoining.createInstance(verbose);
  ps.add(nj.execute(matrix));
  p=ps.get(0);
}","public void process() throws Exception {
  if (matrix == null) {
    double[][] distances=calculateDistanceMatrix(multipleSequenceAlignment,treeConstructionAlgorithm);
    matrix=new BasicSymmetricalDistanceMatrix(multipleSequenceAlignment.getSize());
    for (int i=0; i < matrix.getSize(); i++) {
      matrix.setIdentifier(i,multipleSequenceAlignment.getAlignedSequence(i + 1).getAccession().getID());
    }
    for (int col=0; col < matrix.getSize(); col++) {
      for (int row=0; row < matrix.getSize(); row++) {
        matrix.setValue(col,row,distances[col][row]);
      }
    }
    copyDistanceMatrix=CheckTreeAccuracy.copyMatrix(matrix);
  }
  final List<Phylogeny> ps=new ArrayList<Phylogeny>();
  final NeighborJoining nj=NeighborJoining.createInstance(verbose);
  ps.add(nj.execute(matrix));
  p=ps.get(0);
}",0.9975579975579976
16601,"private double[][] calculateDistanceMatrix(MultipleSequenceAlignment<C,D> multipleSequenceAlignment,TreeConstructionAlgorithm tca){
  updateProgress(""String_Node_Str"",0);
  int numberOfSequences=multipleSequenceAlignment.getSize();
  String[] sequenceString=new String[numberOfSequences];
  for (int i=0; i < multipleSequenceAlignment.getSize(); i++) {
    sequenceString[i]=multipleSequenceAlignment.getAlignedSequence(i).getSequenceAsString();
  }
  double[][] distance=new double[numberOfSequences][numberOfSequences];
  int totalloopcount=(numberOfSequences / 2) * (numberOfSequences + 1);
  if (tca == TreeConstructionAlgorithm.PID) {
    int loopcount=0;
    for (int i=0; i < (numberOfSequences - 1); i++) {
      updateProgress(""String_Node_Str"",(loopcount * 100) / totalloopcount);
      for (int j=i; j < numberOfSequences; j++) {
        loopcount++;
        if (j == i) {
          distance[i][i]=0;
        }
 else {
          distance[i][j]=100 - Comparison.PID(sequenceString[i],sequenceString[j]);
          distance[j][i]=distance[i][j];
        }
      }
    }
  }
 else {
    ScoreMatrix pwmatrix=ResidueProperties.getScoreMatrix(treeConstructionAlgorithm.name());
    if (pwmatrix == null) {
      pwmatrix=ResidueProperties.getScoreMatrix(TreeConstructionAlgorithm.BLOSUM62.name());
    }
    int maxscore=0;
    int end=sequenceString[0].length();
    int loopcount=0;
    for (int i=0; i < (numberOfSequences - 1); i++) {
      updateProgress(""String_Node_Str"",(loopcount * 100) / totalloopcount);
      for (int j=i; j < numberOfSequences; j++) {
        int score=0;
        loopcount++;
        for (int k=0; k < end; k++) {
          try {
            score+=pwmatrix.getPairwiseScore(sequenceString[i].charAt(k),sequenceString[j].charAt(k));
          }
 catch (          Exception ex) {
            logger.error(""String_Node_Str"",ex);
          }
        }
        distance[i][j]=(float)score;
        if (score > maxscore) {
          maxscore=score;
        }
      }
    }
    for (int i=0; i < (numberOfSequences - 1); i++) {
      for (int j=i; j < numberOfSequences; j++) {
        distance[i][j]=(float)maxscore - distance[i][j];
        distance[j][i]=distance[i][j];
      }
    }
  }
  updateProgress(""String_Node_Str"",100);
  return distance;
}","private double[][] calculateDistanceMatrix(MultipleSequenceAlignment<C,D> multipleSequenceAlignment,TreeConstructionAlgorithm tca){
  updateProgress(""String_Node_Str"",0);
  int numberOfSequences=multipleSequenceAlignment.getSize();
  String[] sequenceString=new String[numberOfSequences];
  for (int i=0; i < multipleSequenceAlignment.getSize(); i++) {
    sequenceString[i]=multipleSequenceAlignment.getAlignedSequence(i + 1).getSequenceAsString();
  }
  double[][] distance=new double[numberOfSequences][numberOfSequences];
  int totalloopcount=(numberOfSequences / 2) * (numberOfSequences + 1);
  if (tca == TreeConstructionAlgorithm.PID) {
    int loopcount=0;
    for (int i=0; i < (numberOfSequences - 1); i++) {
      updateProgress(""String_Node_Str"",(loopcount * 100) / totalloopcount);
      for (int j=i; j < numberOfSequences; j++) {
        loopcount++;
        if (j == i) {
          distance[i][i]=0;
        }
 else {
          distance[i][j]=100 - Comparison.PID(sequenceString[i],sequenceString[j]);
          distance[j][i]=distance[i][j];
        }
      }
    }
  }
 else {
    ScoreMatrix pwmatrix=ResidueProperties.getScoreMatrix(treeConstructionAlgorithm.name());
    if (pwmatrix == null) {
      pwmatrix=ResidueProperties.getScoreMatrix(TreeConstructionAlgorithm.BLOSUM62.name());
    }
    int maxscore=0;
    int end=sequenceString[0].length();
    int loopcount=0;
    for (int i=0; i < (numberOfSequences - 1); i++) {
      updateProgress(""String_Node_Str"",(loopcount * 100) / totalloopcount);
      for (int j=i; j < numberOfSequences; j++) {
        int score=0;
        loopcount++;
        for (int k=0; k < end; k++) {
          try {
            score+=pwmatrix.getPairwiseScore(sequenceString[i].charAt(k),sequenceString[j].charAt(k));
          }
 catch (          Exception ex) {
            logger.error(""String_Node_Str"",ex);
          }
        }
        distance[i][j]=(float)score;
        if (score > maxscore) {
          maxscore=score;
        }
      }
    }
    for (int i=0; i < (numberOfSequences - 1); i++) {
      for (int j=i; j < numberOfSequences; j++) {
        distance[i][j]=(float)maxscore - distance[i][j];
        distance[j][i]=distance[i][j];
      }
    }
  }
  updateProgress(""String_Node_Str"",100);
  return distance;
}",0.9991251093613298
16602,"public static void main(String[] args) throws Exception {
  InputStream inStream=TreeConstructor.class.getResourceAsStream(""String_Node_Str"");
  FastaReader<ProteinSequence,AminoAcidCompound> fastaReader=new FastaReader<ProteinSequence,AminoAcidCompound>(inStream,new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>(),new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));
  LinkedHashMap<String,ProteinSequence> proteinSequences=fastaReader.process();
  inStream.close();
  MultipleSequenceAlignment<ProteinSequence,AminoAcidCompound> msa=new MultipleSequenceAlignment<ProteinSequence,AminoAcidCompound>();
  for (  ProteinSequence proteinSequence : proteinSequences.values()) {
    msa.addAlignedSequence(proteinSequence);
  }
  long readT=System.currentTimeMillis();
  DistanceMatrix DM=DistanceMatrixCalculator.kimuraDistance(msa);
  Phylogeny phylo=TreeConstructor.distanceTree((BasicSymmetricalDistanceMatrix)DM,TreeConstructorType.NJ);
  long treeT=System.currentTimeMillis();
  String newick=ForesterWrapper.getNewickString(phylo,true,true);
  System.out.println(newick);
  System.out.println(""String_Node_Str"" + (treeT - readT) + ""String_Node_Str"");
  double cv=DistanceTreeEvaluator.evaluate(phylo,DM);
  System.out.println(""String_Node_Str"" + (int)(cv * 100) + ""String_Node_Str"");
}","public static void main(String[] args) throws Exception {
  InputStream inStream=TreeConstructor.class.getResourceAsStream(""String_Node_Str"");
  FastaReader<ProteinSequence,AminoAcidCompound> fastaReader=new FastaReader<ProteinSequence,AminoAcidCompound>(inStream,new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>(),new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));
  LinkedHashMap<String,ProteinSequence> proteinSequences=fastaReader.process();
  inStream.close();
  MultipleSequenceAlignment<ProteinSequence,AminoAcidCompound> msa=new MultipleSequenceAlignment<ProteinSequence,AminoAcidCompound>();
  for (  ProteinSequence proteinSequence : proteinSequences.values()) {
    msa.addAlignedSequence(proteinSequence);
  }
  long readT=System.currentTimeMillis();
  SubstitutionMatrix<AminoAcidCompound> M=SubstitutionMatrixHelper.getBlosum62();
  DistanceMatrix DM=DistanceMatrixCalculator.fractionalDissimilarityScore(msa,M);
  Phylogeny phylo=TreeConstructor.distanceTree((BasicSymmetricalDistanceMatrix)DM,TreeConstructorType.NJ);
  long treeT=System.currentTimeMillis();
  String newick=ForesterWrapper.getNewickString(phylo,true,true);
  System.out.println(newick);
  System.out.println(""String_Node_Str"" + (treeT - readT) + ""String_Node_Str"");
  double cv=DistanceTreeEvaluator.evaluate(phylo,DM);
  System.out.println(""String_Node_Str"" + (int)(cv * 100) + ""String_Node_Str"");
}",0.9534883720930232
16603,"/** 
 * The dissimilarity score is the additive inverse of the similarity score (sum of scores) between two aligned sequences using a substitution model (Substitution Matrix). The maximum dissimilarity score is taken to be the maximum similarity score between self-alignments (each sequence against itself). Calculation of the score is as follows: <pre> Ds = maxScore - sum(M<sub>ai,bi</sub>) </pre> It is recommended to use the method  {@link #fractionalDissimilarityScore(MultipleSequenceAlignment,SubstitutionMatrix)}, since the maximum similarity score is not relative to the data set, but relative to the Substitution Matrix, and the score is normalized by the alignment length (fractional). <p> Gaps do not have a contribution to the similarity score calculation (gap penalty = 0).
 * @param msa MultipleSequenceAlignment
 * @param M SubstitutionMatrix for similarity scoring
 * @return DistanceMatrix
 */
public static <C extends Sequence<D>,D extends Compound>DistanceMatrix dissimilarityScore(MultipleSequenceAlignment<C,D> msa,SubstitutionMatrix<D> M){
  logger.info(""String_Node_Str"",""String_Node_Str"",0);
  int n=msa.getSize();
  List<C> seqs=msa.getAlignedSequences();
  DistanceMatrix DM=new BasicSymmetricalDistanceMatrix(n);
  int totalloopcount=(n / 2) * (n + 1);
  double maxscore=0;
  int end=msa.getLength();
  int loopcount=0;
  for (int i=0; i < (n - 1); i++) {
    logger.info(""String_Node_Str"",""String_Node_Str"",(loopcount * 100) / totalloopcount);
    for (int j=i; j < n; j++) {
      double score=0;
      loopcount++;
      for (int k=0; k < end; k++) {
        D from=seqs.get(i).getCompoundAt(k);
        D to=seqs.get(i).getCompoundAt(k);
        if (Comparison.isGap(from.getShortName().charAt(0)) || Comparison.isGap(to.getShortName().charAt(0)))         continue;
        score+=M.getValue(from,to);
      }
      DM.setValue(i,j,score);
      if (score > maxscore) {
        maxscore=score;
      }
    }
  }
  for (int i=0; i < n; i++) {
    DM.setIdentifier(i,msa.getAlignedSequence(i + 1).getAccession().getID());
    for (int j=i; j < n; j++) {
      if (i == j)       DM.setValue(i,j,0.0);
 else {
        double dS=maxscore - DM.getValue(i,j);
        DM.setValue(i,j,dS);
        DM.setValue(j,i,dS);
      }
    }
  }
  logger.info(""String_Node_Str"",""String_Node_Str"",100);
  return DM;
}","/** 
 * The dissimilarity score is the additive inverse of the similarity score (sum of scores) between two aligned sequences using a substitution model (Substitution Matrix). The maximum dissimilarity score is taken to be the maximum similarity score between self-alignments (each sequence against itself). Calculation of the score is as follows: <pre> Ds = maxScore - sum(M<sub>ai,bi</sub>) </pre> It is recommended to use the method  {@link #fractionalDissimilarityScore(MultipleSequenceAlignment,SubstitutionMatrix)}, since the maximum similarity score is not relative to the data set, but relative to the Substitution Matrix, and the score is normalized by the alignment length (fractional). <p> Gaps do not have a contribution to the similarity score calculation (gap penalty = 0).
 * @param msa MultipleSequenceAlignment
 * @param M SubstitutionMatrix for similarity scoring
 * @return DistanceMatrix
 */
public static <C extends Sequence<D>,D extends Compound>DistanceMatrix dissimilarityScore(MultipleSequenceAlignment<C,D> msa,SubstitutionMatrix<D> M){
  logger.info(""String_Node_Str"",""String_Node_Str"",0);
  int n=msa.getSize();
  String[] sequenceString=new String[n];
  for (int i=0; i < n; i++) {
    sequenceString[i]=msa.getAlignedSequence(i + 1).getSequenceAsString();
  }
  List<C> seqs=msa.getAlignedSequences();
  DistanceMatrix DM=new BasicSymmetricalDistanceMatrix(n);
  int totalloopcount=(n / 2) * (n + 1);
  double maxscore=0;
  int end=msa.getLength();
  int loopcount=0;
  for (int i=0; i < (n - 1); i++) {
    logger.info(""String_Node_Str"",""String_Node_Str"",(loopcount * 100) / totalloopcount);
    for (int j=i; j < n; j++) {
      double score=0;
      loopcount++;
      for (int k=0; k < end; k++) {
        if (Comparison.isGap(sequenceString[i].charAt(k)) || Comparison.isGap(sequenceString[j].charAt(k)))         continue;
        score+=M.getValue(seqs.get(i).getCompoundAt(k),seqs.get(j).getCompoundAt(k));
      }
      DM.setValue(i,j,score);
      if (score > maxscore) {
        maxscore=score;
      }
    }
  }
  for (int i=0; i < n; i++) {
    DM.setIdentifier(i,msa.getAlignedSequence(i + 1).getAccession().getID());
    for (int j=i; j < n; j++) {
      if (i == j)       DM.setValue(i,j,0.0);
 else {
        double dS=maxscore - DM.getValue(i,j);
        DM.setValue(i,j,dS);
        DM.setValue(j,i,dS);
      }
    }
  }
  logger.info(""String_Node_Str"",""String_Node_Str"",100);
  return DM;
}",0.911986588432523
16604,"/** 
 * The fractional dissimilarity score (Ds) is the average character dissimilarity between two aligned sequences. It is calculated as: <pre> Ds = sum(max(M) - M<sub>ai,bi</sub>) / L </pre> Where the sum through i runs for all the alignment positions, ai and bi are the AA at position i in the first and second aligned sequences, respectively, and L is the total length of the alignment (normalization). <p> The fractional dissimilarity score (Ds) is defined in the interval [0, 1], where 0 means that the sequences are identical and 1 that the sequences are completely different (similarity score of 0). Note that a value higher than one can be obtained, if the similarity score of the alignment is negative (rare case). <p> Gaps do not have a contribution to the similarity score calculation (gap penalty = 0)
 * @param msa MultipleSequenceAlignment
 * @param M SubstitutionMatrix for similarity scoring
 * @return DistanceMatrix
 */
public static <C extends Sequence<D>,D extends Compound>DistanceMatrix fractionalDissimilarityScore(MultipleSequenceAlignment<C,D> msa,SubstitutionMatrix<D> M){
  int n=msa.getSize();
  DistanceMatrix DM=new BasicSymmetricalDistanceMatrix(n);
  double[] scores=Alignments.getAllPairsScores(msa.getAlignedSequences(),PairwiseSequenceScorerType.GLOBAL_SIMILARITIES,new SimpleGapPenalty(0,0),M);
  int maxScore=M.getMaxValue() * msa.getLength();
  int indx=0;
  for (int i=0; i < n; i++) {
    DM.setIdentifier(i,msa.getAlignedSequence(i + 1).getAccession().getID());
    for (int j=i; j < n; j++) {
      if (i == j)       DM.setValue(i,j,0.0);
 else {
        double dS=(maxScore - scores[indx]) / msa.getLength();
        DM.setValue(i,j,dS);
        DM.setValue(j,i,dS);
        indx++;
      }
    }
  }
  return DM;
}","/** 
 * The fractional dissimilarity score (Ds) is the average character dissimilarity between two aligned sequences. It is calculated as: <pre> Ds = sum(max(M) - M<sub>ai,bi</sub>) / L </pre> Where the sum through i runs for all the alignment positions, ai and bi are the AA at position i in the first and second aligned sequences, respectively, and L is the total length of the alignment (normalization). <p> The fractional dissimilarity score (Ds) is defined in the interval [0, 1], where 0 means that the sequences are identical and 1 that the sequences are completely different (similarity score of 0). Note that a value higher than one can be obtained, if the similarity score of the alignment is negative (big evolutionary distance). <p> Gaps do not have a contribution to the similarity score calculation (gap penalty = 0)
 * @param msa MultipleSequenceAlignment
 * @param M SubstitutionMatrix for similarity scoring
 * @return DistanceMatrix
 */
public static <C extends Sequence<D>,D extends Compound>DistanceMatrix fractionalDissimilarityScore(MultipleSequenceAlignment<C,D> msa,SubstitutionMatrix<D> M){
  int n=msa.getSize();
  DistanceMatrix DM=new BasicSymmetricalDistanceMatrix(n);
  double[] scores=Alignments.getAllPairsScores(msa.getAlignedSequences(),PairwiseSequenceScorerType.GLOBAL_SIMILARITIES,new SimpleGapPenalty(0,0),M);
  ConcurrencyTools.shutdown();
  int maxScore=M.getMaxValue() * msa.getLength();
  int indx=0;
  for (int i=0; i < n; i++) {
    DM.setIdentifier(i,msa.getAlignedSequence(i + 1).getAccession().getID());
    for (int j=i; j < n; j++) {
      if (i == j)       DM.setValue(i,j,0.0);
 else {
        double dS=(maxScore - scores[indx]) / msa.getLength();
        DM.setValue(i,j,dS);
        DM.setValue(j,i,dS);
        indx++;
      }
    }
  }
  return DM;
}",0.982328190743338
16605,"/** 
 * The dissimilarity score is the additive inverse of the similarity score (sum of scores) between two aligned sequences using a substitution model (Substitution Matrix). The maximum dissimilarity score is taken to be the maximum similarity score between self-alignments (each sequence against itself). Calculation of the score is as follows: <pre> Ds = maxScore - sum(M<sub>ai,bi</sub>) </pre> It is recommended to use the method  {@link #fractionalDissimilarityScore(MultipleSequenceAlignment,SubstitutionMatrix)}, since the maximum similarity score is not relative to the data set, but relative to the Substitution Matrix, and the score is normalized by the alignment length (fractional). <p> Gaps do not have a contribution to the similarity score calculation (gap penalty = 0).
 * @param msa MultipleSequenceAlignment
 * @param M SubstitutionMatrix for similarity scoring
 * @return DistanceMatrix
 */
public static <C extends Sequence<D>,D extends Compound>DistanceMatrix dissimilarityScore(MultipleSequenceAlignment<C,D> msa,SubstitutionMatrix<D> M){
  logger.info(""String_Node_Str"",""String_Node_Str"",0);
  int n=msa.getSize();
  String[] sequenceString=new String[n];
  for (int i=0; i < n; i++) {
    sequenceString[i]=msa.getAlignedSequence(i + 1).getSequenceAsString();
  }
  List<C> seqs=msa.getAlignedSequences();
  DistanceMatrix DM=new BasicSymmetricalDistanceMatrix(n);
  int totalloopcount=(n / 2) * (n + 1);
  double maxscore=0;
  int end=msa.getLength();
  int loopcount=0;
  for (int i=0; i < (n - 1); i++) {
    logger.info(""String_Node_Str"",""String_Node_Str"",(loopcount * 100) / totalloopcount);
    for (int j=i; j < n; j++) {
      double score=0;
      loopcount++;
      for (int k=0; k < end; k++) {
        if (Comparison.isGap(sequenceString[i].charAt(k)) || Comparison.isGap(sequenceString[j].charAt(k)))         continue;
        score+=M.getValue(seqs.get(i).getCompoundAt(k),seqs.get(j).getCompoundAt(k));
      }
      DM.setValue(i,j,score);
      if (score > maxscore) {
        maxscore=score;
      }
    }
  }
  for (int i=0; i < n; i++) {
    DM.setIdentifier(i,msa.getAlignedSequence(i + 1).getAccession().getID());
    for (int j=i; j < n; j++) {
      if (i == j)       DM.setValue(i,j,0.0);
 else {
        double dS=maxscore - DM.getValue(i,j);
        DM.setValue(i,j,dS);
        DM.setValue(j,i,dS);
      }
    }
  }
  logger.info(""String_Node_Str"",""String_Node_Str"",100);
  return DM;
}","/** 
 * The dissimilarity score is the additive inverse of the similarity score (sum of scores) between two aligned sequences using a substitution model (Substitution Matrix). The maximum dissimilarity score is taken to be the maximum similarity score between self-alignments (each sequence against itself). Calculation of the score is as follows: <pre> Ds = maxScore - sum<sub>i</sub>(M<sub>ai,bi</sub>) </pre> It is recommended to use the method  {@link #fractionalDissimilarityScore(MultipleSequenceAlignment,SubstitutionMatrix)}, since the maximum similarity score is not relative to the data set, but relative to the Substitution Matrix, and the score is normalized by the alignment length (fractional). <p> Gaps do not have a contribution to the similarity score calculation (gap penalty = 0).
 * @param msa MultipleSequenceAlignment
 * @param M SubstitutionMatrix for similarity scoring
 * @return DistanceMatrix
 */
public static <C extends Sequence<D>,D extends Compound>DistanceMatrix dissimilarityScore(MultipleSequenceAlignment<C,D> msa,SubstitutionMatrix<D> M){
  logger.info(""String_Node_Str"",""String_Node_Str"",0);
  int n=msa.getSize();
  String[] sequenceString=new String[n];
  for (int i=0; i < n; i++) {
    sequenceString[i]=msa.getAlignedSequence(i + 1).getSequenceAsString();
  }
  List<C> seqs=msa.getAlignedSequences();
  DistanceMatrix DM=new BasicSymmetricalDistanceMatrix(n);
  int totalloopcount=(n / 2) * (n + 1);
  double maxscore=0;
  int end=msa.getLength();
  int loopcount=0;
  for (int i=0; i < (n - 1); i++) {
    logger.info(""String_Node_Str"",""String_Node_Str"",(loopcount * 100) / totalloopcount);
    for (int j=i; j < n; j++) {
      double score=0;
      loopcount++;
      for (int k=0; k < end; k++) {
        if (Comparison.isGap(sequenceString[i].charAt(k)) || Comparison.isGap(sequenceString[j].charAt(k)))         continue;
        score+=M.getValue(seqs.get(i).getCompoundAt(k + 1),seqs.get(j).getCompoundAt(k + 1));
      }
      if (i != j)       DM.setValue(i,j,score);
      if (score > maxscore) {
        maxscore=score;
      }
    }
  }
  for (int i=0; i < n; i++) {
    DM.setIdentifier(i,msa.getAlignedSequence(i + 1).getAccession().getID());
    for (int j=i; j < n; j++) {
      if (i == j)       DM.setValue(i,j,0.0);
 else {
        double dS=maxscore - DM.getValue(i,j);
        DM.setValue(i,j,dS);
        DM.setValue(j,i,dS);
      }
    }
  }
  logger.info(""String_Node_Str"",""String_Node_Str"",100);
  return DM;
}",0.9922764227642276
16606,"/** 
 * Evaluate the goodness of fit of a given tree to the original distance matrix. The returned value is the coefficient of variation, i.e. the square root of the LS error normalized by the mean. <p> This measure can also give an estimate of the quality of the distance matrix, because a bad fit may mean that the distance is non-additive.
 * @param tree Phylogenetic Distance Tree to evaluate
 * @param matrix Distance Matrix with the original distances
 * @return the square root of the average tree LS error normalized by theaverage tree distance (coefficient of variation, CV).
 */
public static double evaluate(Phylogeny tree,DistanceMatrix matrix){
  int numSequences=matrix.getSize();
  List<PhylogenyNode> externalNodes=tree.getExternalNodes();
  HashMap<String,PhylogenyNode> externalNodesHashMap=new HashMap<String,PhylogenyNode>();
  Set<PhylogenyNode> path=new HashSet<PhylogenyNode>();
  for (  PhylogenyNode node : externalNodes) {
    externalNodesHashMap.put(node.getName(),node);
  }
  int count=0;
  double averageMatrixDistance=0.0;
  double averageTreeDistance=0.0;
  double averageTreeErrorDistance=0.0;
  for (int row=0; row < numSequences - 1; row++) {
    String nodeName1=matrix.getIdentifier(row);
    PhylogenyNode node1=externalNodesHashMap.get(nodeName1);
    markPathToRoot(node1,path);
    for (int col=row + 1; col < numSequences; col++) {
      count++;
      String nodeName2=matrix.getIdentifier(col);
      PhylogenyNode node2=externalNodesHashMap.get(nodeName2);
      double distance=matrix.getValue(col,row);
      averageMatrixDistance=averageMatrixDistance + distance;
      PhylogenyNode commonParent=findCommonParent(node2,path);
      if (commonParent != null) {
        double treeDistance=getNodeDistance(commonParent,node1) + getNodeDistance(commonParent,node2);
        averageTreeDistance+=treeDistance;
        averageTreeErrorDistance+=(distance - treeDistance) * (distance - treeDistance);
        logger.info(""String_Node_Str"",nodeName1,nodeName2,distance,treeDistance,Math.abs(distance - treeDistance));
      }
 else {
        logger.warn(""String_Node_Str"",node1,node2);
      }
    }
    path.clear();
  }
  averageMatrixDistance/=count;
  averageTreeDistance/=count;
  averageTreeErrorDistance/=count;
  logger.info(""String_Node_Str"",averageMatrixDistance);
  logger.info(""String_Node_Str"",averageTreeDistance);
  logger.info(""String_Node_Str"",averageTreeErrorDistance);
  return Math.sqrt((averageTreeErrorDistance)) / (averageMatrixDistance);
}","/** 
 * Evaluate the goodness of fit of a given tree to the original distance matrix. The returned value is the coefficient of variation, i.e. the square root of the LS error normalized by the mean. <p> This measure can also give an estimate of the quality of the distance matrix, because a bad fit may mean that the distance is non-additive.
 * @param tree Phylogenetic Distance Tree to evaluate
 * @param matrix Distance Matrix with the original distances
 * @return the square root of the average tree LS error normalized by theaverage tree distance (coefficient of variation, CV).
 */
public static double evaluate(Phylogeny tree,DistanceMatrix matrix){
  int numSequences=matrix.getSize();
  List<PhylogenyNode> externalNodes=tree.getExternalNodes();
  HashMap<String,PhylogenyNode> externalNodesHashMap=new HashMap<String,PhylogenyNode>();
  Set<PhylogenyNode> path=new HashSet<PhylogenyNode>();
  for (  PhylogenyNode node : externalNodes) {
    externalNodesHashMap.put(node.getName(),node);
  }
  int count=0;
  double averageMatrixDistance=0.0;
  double averageTreeDistance=0.0;
  double averageTreeErrorDistance=0.0;
  for (int row=0; row < numSequences - 1; row++) {
    String nodeName1=matrix.getIdentifier(row);
    PhylogenyNode node1=externalNodesHashMap.get(nodeName1);
    markPathToRoot(node1,path);
    for (int col=row + 1; col < numSequences; col++) {
      count++;
      String nodeName2=matrix.getIdentifier(col);
      PhylogenyNode node2=externalNodesHashMap.get(nodeName2);
      double distance=matrix.getValue(col,row);
      averageMatrixDistance=averageMatrixDistance + distance;
      PhylogenyNode commonParent=findCommonParent(node2,path);
      if (commonParent != null) {
        double treeDistance=getNodeDistance(commonParent,node1) + getNodeDistance(commonParent,node2);
        averageTreeDistance+=treeDistance;
        averageTreeErrorDistance+=(distance - treeDistance) * (distance - treeDistance);
        logger.info(""String_Node_Str"",nodeName1,nodeName2,distance,treeDistance,Math.abs(distance - treeDistance));
      }
 else {
        logger.warn(""String_Node_Str"",node1,node2);
      }
    }
    path.clear();
  }
  averageMatrixDistance/=count;
  averageTreeDistance/=count;
  averageTreeErrorDistance/=count;
  logger.info(""String_Node_Str"",averageMatrixDistance);
  logger.info(""String_Node_Str"",averageTreeDistance);
  logger.info(""String_Node_Str"",averageTreeErrorDistance);
  return Math.sqrt(averageTreeErrorDistance) / averageMatrixDistance;
}",0.9992012779552716
16607,"@Override public List<Result> createObjects(double maxEScore) throws IOException, ParseException {
  List<Result> results=new ArrayList();
  log.info(""String_Node_Str"");
  LineNumberReader lnr=new LineNumberReader(new FileReader(targetFile));
  lnr.skip(Long.MAX_VALUE);
  fileLinesCount=lnr.getLineNumber();
  log.info(fileLinesCount + ""String_Node_Str"");
  lnr.close();
  FileInputStream fileInputStream=new FileInputStream(targetFile);
  Scanner scanner=new Scanner(fileInputStream);
  String line=fetchData(scanner);
  int lineNumber=1;
  while (scanner.hasNext()) {
    try {
      BlastResultBuilder resultBuilder=new BlastResultBuilder();
      resultBuilder.setQueryID(queryId).setDbFile(databaseFile).setProgram(programName).setQueryDef(queryName).setReference(blastReference);
      List<Hit> hits=new ArrayList();
      String currentQueryId=queryId;
      while (currentQueryId.equals(queryId) && scanner.hasNext()) {
        BlastHitBuilder hitBuilder=new BlastHitBuilder();
        List<Hsp> hsps=new ArrayList();
        String currentSubjectId=subjectId;
        while (currentSubjectId.equals(subjectId) && scanner.hasNext()) {
          if (new Double(evalue) > maxEScore) {
            line=fetchData(scanner);
            lineNumber++;
            continue;
          }
          BlastHspBuilder hspBuilder=new BlastHspBuilder();
          hspBuilder.setHspAlignLen(new Integer(alnLength)).setHspGaps(new Integer(gapOpenCount)).setHspQueryFrom(new Integer(queryStart)).setHspQueryTo(new Integer(queryEnd)).setHspHitFrom(new Integer(subjectStart)).setHspHitTo(new Integer(subjectEnd)).setHspEvalue(new Double(evalue)).setHspBitScore(new Double(bitScore)).setPercentageIdentity(new Double(percIdentity) / 100).setMismatchCount(new Integer(mismatchCount));
          hsps.add(hspBuilder.createBlastHsp());
          line=fetchData(scanner);
          lineNumber++;
        }
        hits.add(hitBuilder.setHsps(hsps).createBlastHit());
      }
      results.add(resultBuilder.setHits(hits).createBlastResult());
    }
 catch (    NumberFormatException e) {
      throw new ParseException(""String_Node_Str"" + lineNumber + ""String_Node_Str""+ line,0);
    }
  }
  return results;
}","@Override public List<Result> createObjects(double maxEScore) throws IOException, ParseException {
  List<Result> results=new ArrayList();
  log.info(""String_Node_Str"");
  LineNumberReader lnr=new LineNumberReader(new FileReader(targetFile));
  lnr.skip(Long.MAX_VALUE);
  fileLinesCount=lnr.getLineNumber();
  log.info(fileLinesCount + ""String_Node_Str"");
  lnr.close();
  FileInputStream fileInputStream=new FileInputStream(targetFile);
  Scanner scanner=new Scanner(fileInputStream);
  String line=fetchData(scanner);
  int lineNumber=0;
  while (lineNumber < fileLinesCount) {
    try {
      BlastResultBuilder resultBuilder=new BlastResultBuilder();
      resultBuilder.setQueryID(queryId).setDbFile(databaseFile).setProgram(programName).setQueryDef(queryName).setReference(blastReference);
      List<Hit> hits=new ArrayList();
      String currentQueryId=queryId;
      while (currentQueryId.equals(queryId) && lineNumber < fileLinesCount) {
        BlastHitBuilder hitBuilder=new BlastHitBuilder();
        List<Hsp> hsps=new ArrayList();
        String currentSubjectId=subjectId;
        while (currentSubjectId.equals(subjectId) && lineNumber < fileLinesCount) {
          if (new Double(evalue) > maxEScore) {
            line=fetchData(scanner);
            lineNumber++;
            continue;
          }
          BlastHspBuilder hspBuilder=new BlastHspBuilder();
          hspBuilder.setHspAlignLen(new Integer(alnLength)).setHspGaps(new Integer(gapOpenCount)).setHspQueryFrom(new Integer(queryStart)).setHspQueryTo(new Integer(queryEnd)).setHspHitFrom(new Integer(subjectStart)).setHspHitTo(new Integer(subjectEnd)).setHspEvalue(new Double(evalue)).setHspBitScore(new Double(bitScore)).setPercentageIdentity(new Double(percIdentity) / 100).setMismatchCount(new Integer(mismatchCount));
          hsps.add(hspBuilder.createBlastHsp());
          if (scanner.hasNext())           line=fetchData(scanner);
          lineNumber++;
        }
        hits.add(hitBuilder.setHsps(hsps).createBlastHit());
      }
      results.add(resultBuilder.setHits(hits).createBlastResult());
    }
 catch (    NumberFormatException e) {
      throw new ParseException(""String_Node_Str"" + lineNumber + ""String_Node_Str""+ line,0);
    }
  }
  return results;
}",0.958904109589041
16608,"/** 
 * Detect helical turn patterns.
 */
private void calculateTurns(){
  for (int i=0; i < groups.length; i++) {
    for (int turn=3; turn <= 5; turn++) {
      if (i + turn >= groups.length)       continue;
      if (isBonded(i + turn,i)) {
        logger.debug(""String_Node_Str"" + (i + turn) + i);
        for (int j=i; j < i + turn + 1; j++) {
          logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ j+ ""String_Node_Str""+ turn);
          SecStrucGroup group=groups[j];
          SecStrucState state=(SecStrucState)group.getProperty(Group.SEC_STRUC);
          boolean[] turns=state.getTurn();
          turns[turn - 3]=true;
        }
      }
    }
  }
}","/** 
 * Detect helical turn patterns.
 */
private void calculateTurns(){
  for (int i=0; i < groups.length; i++) {
    for (int turn=3; turn <= 5; turn++) {
      if (i + turn >= groups.length)       continue;
      if (isBonded(i + turn,i)) {
        logger.debug(""String_Node_Str"" + (i + turn) + i);
        for (int j=i; j < i + turn + 1; j++) {
          logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ j+ ""String_Node_Str""+ turn);
          SecStrucState state=getSecStrucState(j);
          boolean[] turns=state.getTurn();
          turns[turn - 3]=true;
        }
      }
    }
  }
}",0.8983451536643026
16609,"private void checkSetTurns(){
  for (int i=0; i < groups.length - 3; i++) {
    Group g=groups[i];
    SecStrucState state=(SecStrucState)g.getProperty(Group.SEC_STRUC);
    SecStrucType type=state.getType();
    if (type.isHelixType())     continue;
    boolean[] turns=state.getTurn();
    for (int t=0; t < 3; t++) {
      if (turns[t]) {
        for (int l=i + 1; l < i + t + 3; l++) {
          logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ type);
          if (l >= groups.length)           break;
          SecStrucType typel=getSecStrucType(l);
          if (typel.equals(SecStrucType.coil))           setSecStrucType(l,SecStrucType.turn);
        }
      }
    }
  }
}","private void checkSetTurns(){
  for (int i=0; i < groups.length - 3; i++) {
    SecStrucState state=getSecStrucState(i);
    SecStrucType type=state.getType();
    if (type.isHelixType())     continue;
    boolean[] turns=state.getTurn();
    for (int t=0; t < 3; t++) {
      if (turns[t]) {
        for (int l=i + 1; l < i + t + 3; l++) {
          logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ type);
          if (l >= groups.length)           break;
          SecStrucType typel=getSecStrucType(l);
          if (typel.equals(SecStrucType.coil))           setSecStrucType(l,SecStrucType.turn);
        }
      }
    }
  }
}",0.9056603773584906
16610,"/** 
 * Test if two groups are forming an H-Bond. DSSP defines H-Bonds if the energy < -500 cal/mol
 * @param one group one
 * @param two group two
 * @return flag if the two are forming an Hbond
 */
private boolean isBonded(int i,int j){
  Group one=groups[i];
  SecStrucState stateOne=(SecStrucState)one.getProperty(Group.SEC_STRUC);
  double acc1e=stateOne.getAccept1().getEnergy();
  double acc2e=stateOne.getAccept2().getEnergy();
  int partnerAcc1=stateOne.getAccept1().getPartner();
  int partnerAcc2=stateOne.getAccept2().getPartner();
  if (((partnerAcc1 == j) && (acc1e < HBONDHIGHENERGY)) || ((partnerAcc2 == j) && (acc2e < HBONDHIGHENERGY))) {
    logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ j);
    return true;
  }
  return false;
}","/** 
 * Test if two groups are forming an H-Bond. DSSP defines H-Bonds if the energy < -500 cal/mol
 * @param one group one
 * @param two group two
 * @return flag if the two are forming an Hbond
 */
private boolean isBonded(int i,int j){
  SecStrucState stateOne=getSecStrucState(i);
  double acc1e=stateOne.getAccept1().getEnergy();
  double acc2e=stateOne.getAccept2().getEnergy();
  int partnerAcc1=stateOne.getAccept1().getPartner();
  int partnerAcc2=stateOne.getAccept2().getPartner();
  if (((partnerAcc1 == j) && (acc1e < HBONDHIGHENERGY)) || ((partnerAcc2 == j) && (acc2e < HBONDHIGHENERGY))) {
    logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ j);
    return true;
  }
  return false;
}",0.9406143344709896
16611,"private void setSecStrucType(int pos,SecStrucType type){
  Group g=groups[pos];
  SecStrucState s=(SecStrucState)g.getProperty(Group.SEC_STRUC);
  s.setType(type);
}","private void setSecStrucType(int pos,SecStrucType type){
  SecStrucState s=getSecStrucState(pos);
  s.setType(type);
}",0.7915194346289752
16612,"private void checkSetHelix(int prange,SecStrucType type){
  int range=prange - 3;
  logger.debug(""String_Node_Str"" + type + ""String_Node_Str""+ prange+ ""String_Node_Str""+ range);
  for (int i=1; i < groups.length - range - 1; i++) {
    Group g=groups[i];
    SecStrucState state=(SecStrucState)g.getProperty(Group.SEC_STRUC);
    Group prevG=groups[i - 1];
    SecStrucState prevState=(SecStrucState)prevG.getProperty(Group.SEC_STRUC);
    Group nextG=groups[i + 1];
    SecStrucState nextState=(SecStrucState)nextG.getProperty(Group.SEC_STRUC);
    boolean[] turns=state.getTurn();
    boolean[] pturns=prevState.getTurn();
    boolean[] nturns=nextState.getTurn();
    if (turns[range] && pturns[range] && nturns[range]) {
      boolean empty=true;
      for (int curr=i; curr <= i + range; curr++) {
        logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ prange+ ""String_Node_Str""+ range);
        SecStrucType cstate=getSecStrucType(curr);
        if (cstate.isHelixType()) {
          empty=false;
          break;
        }
      }
      if (empty) {
        for (int curr=i; curr <= i + range; curr++) {
          setSecStrucType(curr,type);
        }
      }
    }
  }
}","private void checkSetHelix(int prange,SecStrucType type){
  int range=prange - 3;
  logger.debug(""String_Node_Str"" + type + ""String_Node_Str""+ prange+ ""String_Node_Str""+ range);
  for (int i=1; i < groups.length - range - 1; i++) {
    SecStrucState state=getSecStrucState(i);
    SecStrucState prevState=getSecStrucState(i - 1);
    SecStrucState nextState=getSecStrucState(i + 1);
    boolean[] turns=state.getTurn();
    boolean[] pturns=prevState.getTurn();
    boolean[] nturns=nextState.getTurn();
    if (turns[range] && pturns[range] && nturns[range]) {
      boolean empty=true;
      for (int curr=i; curr <= i + range; curr++) {
        logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ prange+ ""String_Node_Str""+ range);
        SecStrucType cstate=getSecStrucType(curr);
        if (cstate.isHelixType()) {
          empty=false;
          break;
        }
      }
      if (empty) {
        for (int curr=i; curr <= i + range; curr++) {
          setSecStrucType(curr,type);
        }
      }
    }
  }
}",0.8141112618724559
16613,"@Override public String toString(){
  StringBuffer buf=new StringBuffer();
  String nl=System.getProperty(""String_Node_Str"");
  buf.append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  for (int i=0; i < groups.length; i++) {
    buf.append(nl);
    SecStrucState ss=(SecStrucState)groups[i].getProperty(Group.SEC_STRUC);
    buf.append(ss.printDSSPline(i));
  }
  return buf.toString();
}","@Override public String toString(){
  StringBuffer buf=new StringBuffer();
  String nl=System.getProperty(""String_Node_Str"");
  buf.append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  for (int i=0; i < groups.length; i++) {
    buf.append(nl);
    SecStrucState ss=getSecStrucState(i);
    buf.append(ss.printDSSPline(i));
  }
  return buf.toString();
}",0.8423645320197044
16614,"private boolean shouldExtendLadder(Ladder ladder,int start,int end,BridgeType btype){
  return ((btype.equals(ladder.btype)) && (start == ladder.to + 1) && (((end == ladder.lto + 1) && (btype.equals(BridgeType.parallel))) || ((end == ladder.lfrom - 1) && (btype.equals(BridgeType.parallel)))));
}","/** 
 * Conditions to extend a ladder with a given beta Bridge: <li>The bridge and ladder are of the same type. <li>The smallest bridge residue is sequential to the first strand ladder. <li>The second bridge residue is either sequential (parallel) or previous (antiparallel) to the second strand of the ladder </li>
 * @param ladder the ladder candidate to extend
 * @param i index of the first bridge residue
 * @param j index of the second bridge residue
 * @param btype type of beta bridge
 * @return true if the bridge (i,j) extends the ladder
 */
private boolean shouldExtendLadder(Ladder ladder,int i,int j,BridgeType btype){
  boolean sameType=btype.equals(ladder.btype);
  if (!sameType)   return false;
  boolean sequential=(i == ladder.to + 1);
  if (!sequential)   return false;
switch (btype) {
case parallel:
    if (j == ladder.lto + 1)     return true;
  break;
case antiparallel:
if (j == ladder.lfrom - 1) return true;
break;
}
return false;
}",0.2659235668789809
16615,"public static List<SecStrucElement> getSSE(Structure s){
  List<SecStrucElement> listSSE=new ArrayList<SecStrucElement>();
  GroupIterator iter=new GroupIterator(s);
  while (iter.hasNext()) {
    Group g=iter.next();
    if (g instanceof AminoAcid) {
      AminoAcid aa=(AminoAcid)g;
    }
  }
  return listSSE;
}","public static List<SecStrucElement> getSSE(Structure s){
  List<SecStrucElement> listSSE=new ArrayList<SecStrucElement>();
  GroupIterator iter=new GroupIterator(s);
  while (iter.hasNext()) {
    Group g=iter.next();
    if (g.hasAminoAtoms()) {
    }
  }
  return listSSE;
}",0.9016949152542372
16616,"@Test public void testDSSPParser() throws IOException, StructureException {
  List<String> names=Arrays.asList(""String_Node_Str"");
  for (  String name : names) {
    AtomCache cache=new AtomCache();
    Structure s=cache.getStructure(name);
    List<SecStrucState> file=DSSPParser.parseFile(""String_Node_Str"" + name + ""String_Node_Str"",s,false);
    List<SecStrucState> pdb=DSSPParser.fetch(name,s,false);
    SecStrucPred sec=new SecStrucPred();
    List<SecStrucState> pred=sec.predict(s,false);
    List<SecStrucState> parseBack=DSSPParser.parseString(sec.toString(),s,false);
    assertTrue(""String_Node_Str"",file.size() == pdb.size() && pred.size() == parseBack.size() && pred.size() == file.size());
    for (int i=0; i < file.size(); i++) {
      assertEquals(""String_Node_Str"" + i + ""String_Node_Str"",file.get(i),pdb.get(i));
      assertEquals(""String_Node_Str"" + i + ""String_Node_Str"",pred.get(i),parseBack.get(i));
      assertEquals(""String_Node_Str"" + i + ""String_Node_Str"",file.get(i),pred.get(i));
    }
  }
}","@Test public void testDSSPParser() throws IOException, StructureException {
  List<String> names=Arrays.asList(""String_Node_Str"");
  for (  String name : names) {
    AtomCache cache=new AtomCache();
    Structure s=cache.getStructure(name);
    List<SecStrucState> file=DSSPParser.parseFile(""String_Node_Str"" + name + ""String_Node_Str"",s,false);
    List<SecStrucState> pdb=DSSPParser.fetch(name,s,false);
    SecStrucPred sec=new SecStrucPred();
    List<SecStrucState> pred=sec.predict(s,false);
    List<SecStrucState> parseBack=DSSPParser.parseString(sec.toString(),s,false);
    assertTrue(""String_Node_Str"",file.size() == pdb.size() && pred.size() == parseBack.size() && pred.size() == file.size());
    for (int i=0; i < file.size(); i++) {
      assertEquals(""String_Node_Str"" + (i + 1) + ""String_Node_Str"",file.get(i),pdb.get(i));
      assertEquals(""String_Node_Str"" + (i + 1) + ""String_Node_Str"",pred.get(i),parseBack.get(i));
      assertEquals(""String_Node_Str"" + (i + 1) + ""String_Node_Str"",file.get(i),pred.get(i));
    }
  }
}",0.988394584139265
16617,"@Test public void testSecStrucPred() throws StructureException, IOException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  for (  String name : names) {
    AtomCache cache=new AtomCache();
    Structure s=cache.getStructure(name);
    SecStrucPred sec=new SecStrucPred();
    List<SecStrucState> biojava=sec.predict(s,false);
    List<SecStrucState> dssp=DSSPParser.fetch(name,s,false);
    assertTrue(""String_Node_Str"",biojava.size() == dssp.size());
    for (int i=0; i < dssp.size(); i++) {
      assertEquals(""String_Node_Str"" + i + ""String_Node_Str"",biojava.get(i),dssp.get(i));
    }
  }
}","@Test public void testSecStrucPred() throws StructureException, IOException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  for (  String name : names) {
    AtomCache cache=new AtomCache();
    Structure s=cache.getStructure(name);
    SecStrucPred sec=new SecStrucPred();
    List<SecStrucState> biojava=sec.predict(s,false);
    System.out.println(sec);
    List<SecStrucState> dssp=DSSPParser.fetch(name,s,false);
    assertTrue(""String_Node_Str"",biojava.size() == dssp.size());
    for (int i=0; i < dssp.size(); i++) {
      assertEquals(""String_Node_Str"" + (i + 1) + ""String_Node_Str"",biojava.get(i),dssp.get(i));
    }
  }
}",0.9742457689477556
16618,"/** 
 * Detect helical turn patterns.
 */
private void calculateTurns(){
  for (int i=0; i < groups.length; i++) {
    for (int turn=3; turn <= 5; turn++) {
      if (i + turn >= groups.length)       continue;
      if (isBonded(i + turn,i)) {
        logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ (i + turn)+ ""String_Node_Str""+ turn);
        getSecStrucState(i).setTurn('>',turn);
        getSecStrucState(i + turn).setTurn('<',turn);
        for (int j=i + 1; j < i + turn; j++) {
          Integer t=turn;
          char helix=t.toString().charAt(0);
          getSecStrucState(j).setTurn(helix,turn);
        }
      }
    }
  }
}","/** 
 * Detect helical turn patterns.
 */
private void calculateTurns(){
  for (int i=0; i < groups.length; i++) {
    for (int turn=3; turn <= 5; turn++) {
      if (i + turn >= groups.length)       continue;
      if (isBonded(i,i + turn)) {
        logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ (i + turn)+ ""String_Node_Str""+ turn);
        getSecStrucState(i).setTurn('>',turn);
        getSecStrucState(i + turn).setTurn('<',turn);
        for (int j=i + 1; j < i + turn; j++) {
          Integer t=turn;
          char helix=t.toString().charAt(0);
          getSecStrucState(j).setTurn(helix,turn);
        }
      }
    }
  }
}",0.9891472868217054
16619,"private void detectBends(){
  for (int i=2; i < groups.length - 2; i++) {
    SecStrucGroup im2=groups[i - 2];
    SecStrucGroup g=groups[i];
    SecStrucGroup ip2=groups[i + 2];
    Atom caim2=im2.getCA();
    Atom cag=g.getCA();
    Atom caip2=ip2.getCA();
    Atom caminus2=Calc.subtract(caim2,cag);
    Atom caplus2=Calc.subtract(cag,caip2);
    double angle=Calc.angle(caminus2,caplus2);
    SecStrucState state=getSecStrucState(i);
    state.setKappa((float)angle);
    if (angle > 70.0 && angle < 359.9) {
      if (state.getType().equals(SecStrucType.coil)) {
        state.setType(SecStrucType.bend);
      }
      state.setBend(true);
    }
  }
}","private void detectBends(){
  for (int i=2; i < groups.length - 2; i++) {
    boolean bonded=true;
    for (int k=0; k < 4; k++) {
      int index=i + k - 2;
      Atom C=groups[index].getC();
      Atom N=groups[index + 1].getN();
      if (Calc.getDistance(C,N) > MAX_PEPTIDE_BOND_LENGTH) {
        bonded=false;
        break;
      }
    }
    if (!bonded)     continue;
    SecStrucGroup im2=groups[i - 2];
    SecStrucGroup g=groups[i];
    SecStrucGroup ip2=groups[i + 2];
    Atom caim2=im2.getCA();
    Atom cag=g.getCA();
    Atom caip2=ip2.getCA();
    Atom caminus2=Calc.subtract(caim2,cag);
    Atom caplus2=Calc.subtract(cag,caip2);
    double angle=Calc.angle(caminus2,caplus2);
    SecStrucState state=getSecStrucState(i);
    state.setKappa((float)angle);
    if (angle > 70.0 && angle < 359.99) {
      setSecStrucType(i,SecStrucType.bend);
      state.setBend(true);
    }
  }
}",0.7173213135866066
16620,"private void checkSetTurns(){
  SecStrucType type=SecStrucType.turn;
  for (int idx=0; idx < 3; idx++) {
    for (int i=0; i < groups.length; i++) {
      SecStrucState state=getSecStrucState(i);
      char[] turn=state.getTurn();
      if (turn[idx] == '>') {
        if (!DSSP_HELICES)         setSecStrucType(i,type);
        setSecStrucType(i + 1,type);
        i+=2;
        SecStrucState nextState=getSecStrucState(i);
        char nturn=nextState.getTurn()[idx];
        boolean closing=false;
        boolean stop=false;
        while (!stop) {
          setSecStrucType(i - 1,type);
          i++;
          nextState=getSecStrucState(i);
          nturn=nextState.getTurn()[idx];
          if (!closing && nturn == '<')           closing=true;
          if (closing && nturn == '>')           stop=true;
          if (nturn == ' ')           stop=true;
        }
        if (!DSSP_HELICES)         setSecStrucType(i - 1,type);
      }
    }
  }
}","private void checkSetTurns(){
  SecStrucType type=SecStrucType.turn;
  for (int idx=0; idx < 3; idx++) {
    for (int i=0; i < groups.length; i++) {
      SecStrucState state=getSecStrucState(i);
      char[] turn=state.getTurn();
      if (turn[idx] == '>' || turn[idx] == 'X') {
        if (!DSSP_HELICES)         setSecStrucType(i,type);
        setSecStrucType(i + 1,type);
        i+=2;
        SecStrucState nextState=getSecStrucState(i);
        char nturn=nextState.getTurn()[idx];
        boolean closing=false;
        boolean stop=false;
        while (!stop) {
          setSecStrucType(i - 1,type);
          i++;
          nextState=getSecStrucState(i);
          nturn=nextState.getTurn()[idx];
          if (!closing && nturn == '<')           closing=true;
          if (closing && (nturn != '<' && nturn != 'X'))           stop=true;
          if (nturn == ' ')           stop=true;
        }
        i--;
        if (!DSSP_HELICES)         setSecStrucType(i,type);
        i-=2;
      }
    }
  }
}",0.947795235681703
16621,"private boolean hasBulge(Ladder l1,Ladder l2){
  boolean bulge=((l1.btype.equals(l2.btype)) && (l2.from - l1.to < 6) && (l1.to < l2.from)&& (l2.connectedTo == 0));
  if (!bulge)   return bulge;
switch (l1.btype) {
case parallel:
    bulge=((l2.lfrom - l1.lto > 0) && (((l2.lfrom - l1.lto < 6) && (l2.from - l1.to < 3)) || (l2.lfrom - l1.lto < 3)));
  break;
case antiparallel:
bulge=((l1.lfrom - l2.lto > 0) && (((l1.lfrom - l2.lto < 6) && (l2.from - l1.to < 3)) || (l1.lfrom - l2.lto < 3)));
break;
}
return bulge;
}","/** 
 * For beta structures, we define explicitly: a bulge-linked  ladder consists of two (perfect) ladder or bridges of the  same type connected by at most one extra residue on one  strand and at most four extra residues on the other strand, all residues in bulge-linked ladders are marked ""E,"" including the extra residues.
 */
private boolean hasBulge(Ladder l1,Ladder l2){
  boolean bulge=((l1.btype.equals(l2.btype)) && (l2.from - l1.to < 6) && (l1.to < l2.from)&& (l2.connectedTo == 0));
  if (!bulge)   return bulge;
switch (l1.btype) {
case parallel:
    bulge=((l2.lfrom - l1.lto > 0) && (((l2.lfrom - l1.lto < 6) && (l2.from - l1.to < 3)) || (l2.lfrom - l1.lto < 3)));
  break;
case antiparallel:
bulge=((l1.lfrom - l2.lto > 0) && (((l1.lfrom - l2.lto < 6) && (l2.from - l1.to < 3)) || (l1.lfrom - l2.lto < 3)));
break;
}
return bulge;
}",0.7580645161290323
16622,"/** 
 * Test if two groups are forming an H-Bond. The bond tested is from the NH of group i to the CO of group j. DSSP defines H-Bonds if the energy < -500 cal/mol.
 * @param one group one
 * @param two group two
 * @return flag if the two are forming an Hbond
 */
private boolean isBonded(int i,int j){
  SecStrucState stateOne=getSecStrucState(i);
  double acc1e=stateOne.getAccept1().getEnergy();
  double acc2e=stateOne.getAccept2().getEnergy();
  int partnerAcc1=stateOne.getAccept1().getPartner();
  int partnerAcc2=stateOne.getAccept2().getPartner();
  if (((partnerAcc1 == j) && (acc1e < HBONDHIGHENERGY)) || ((partnerAcc2 == j) && (acc2e < HBONDHIGHENERGY))) {
    logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ j);
    return true;
  }
  return false;
}","/** 
 * Test if two groups are forming an H-Bond. The bond tested is from the CO of group i to the NH of group j. Acceptor (i) and donor (j). The donor of i has to be j, and the acceptor of j  has to be i. DSSP defines H-Bonds if the energy < -500 cal/mol.
 * @param one group one
 * @param two group two
 * @return flag if the two are forming an Hbond
 */
private boolean isBonded(int i,int j){
  SecStrucState one=getSecStrucState(i);
  SecStrucState two=getSecStrucState(j);
  double don1e=one.getDonor1().getEnergy();
  double don2e=one.getDonor2().getEnergy();
  double acc1e=two.getAccept1().getEnergy();
  double acc2e=two.getAccept2().getEnergy();
  int don1p=one.getDonor1().getPartner();
  int don2p=one.getDonor2().getPartner();
  int acc1p=two.getAccept1().getPartner();
  int acc2p=two.getAccept2().getPartner();
  boolean hbond=(don1p == j && don1e < HBONDHIGHENERGY) || (don2p == j && don2e < HBONDHIGHENERGY) || (acc1p == i && acc1e < HBONDHIGHENERGY)|| (acc2p == i && acc2e < HBONDHIGHENERGY);
  if (hbond) {
    logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ j);
    return true;
  }
  return false;
}",0.6063157894736843
16623,"/** 
 * A minimal helix is defined by two consecutive n-turns. For example, a 4-helix, of minimal length 4 from residues  i to (i+3), requires turns (of type 4) at residues (i-1) and i. <p> Note that the orignal DSSP implementation does not assign helix type to residue (i-1) and residue (i+n+1), although  they contain a helix turn. As they state in the original paper, ""the helices are one residue shorter than they would be according to rule 6.3 of IUPAC-IUB"".
 * @param n
 * @param type
 */
private void checkSetHelix(int n,SecStrucType type){
  int idx=n - 3;
  logger.debug(""String_Node_Str"" + type + ""String_Node_Str""+ n+ ""String_Node_Str""+ idx);
  for (int i=1; i < groups.length; i++) {
    SecStrucState state=getSecStrucState(i);
    SecStrucState previousState=getSecStrucState(i - 1);
    char turn=state.getTurn()[idx];
    char pturn=previousState.getTurn()[idx];
    if (turn == '>' && pturn == '>') {
      if (!DSSP_HELICES)       setSecStrucType(i - 1,type);
      i++;
      SecStrucState nextState=getSecStrucState(i);
      char nturn=nextState.getTurn()[idx];
      boolean closing=false;
      boolean stop=false;
      while (!stop) {
        setSecStrucType(i - 1,type);
        i++;
        nextState=getSecStrucState(i);
        nturn=nextState.getTurn()[idx];
        if (!closing && nturn == '<')         closing=true;
        if (closing && nturn == '>')         stop=true;
        if (nturn == ' ')         stop=true;
      }
      if (!DSSP_HELICES)       setSecStrucType(i - 1,type);
    }
  }
}","/** 
 * A minimal helix is defined by two consecutive n-turns. For example, a 4-helix, of minimal length 4 from residues  i to (i+3), requires turns (of type 4) at residues (i-1) and i. <p> Note that the orignal DSSP implementation does not assign helix type to residue (i-1) and residue (i+n+1), although  they contain a helix turn. As they state in the original paper, ""the helices are one residue shorter than they would be according to rule 6.3 of IUPAC-IUB"".
 * @param n
 * @param type
 */
private void checkSetHelix(int n,SecStrucType type){
  int idx=n - 3;
  logger.debug(""String_Node_Str"" + type + ""String_Node_Str""+ n+ ""String_Node_Str""+ idx);
  for (int i=1; i < groups.length - 1; i++) {
    SecStrucState state=getSecStrucState(i);
    SecStrucState previousState=getSecStrucState(i - 1);
    if (state.type.isHelixType())     continue;
    if (getSecStrucState(i + 1).type.isHelixType())     continue;
    char turn=state.getTurn()[idx];
    char pturn=previousState.getTurn()[idx];
    if ((turn == '>' || turn == 'X') && (pturn == '>' || pturn == 'X')) {
      if (!DSSP_HELICES)       setSecStrucType(i - 1,type);
      i++;
      SecStrucState nextState=getSecStrucState(i);
      char nturn=nextState.getTurn()[idx];
      int counter=2;
      boolean closing=false;
      while (counter > 0) {
        setSecStrucType(i - 1,type);
        i++;
        if (nturn == 'X' && closing)         counter--;
        if (nturn == '<')         counter--;
        if (nturn == '>')         counter++;
        if (nturn == '<')         closing=true;
        nextState=getSecStrucState(i);
        nturn=nextState.getTurn()[idx];
      }
      i--;
      if (!DSSP_HELICES)       setSecStrucType(i,type);
      i--;
    }
  }
}",0.8342016549187864
16624,"private void findBridges(int i){
  for (int j=i + 3; j < groups.length - 1; j++) {
    BridgeType btype=null;
    if ((isBonded(i - 1,j) && isBonded(j,i + 1)) || (isBonded(j - 1,i) && isBonded(i,j + 1))) {
      btype=BridgeType.parallel;
    }
 else     if ((isBonded(i,j) && isBonded(j,i)) || (isBonded(i - 1,j + 1) && (isBonded(j - 1,i + 1)))) {
      btype=BridgeType.antiparallel;
    }
    if (btype != null) {
      registerBridge(i,j,btype);
    }
  }
}","/** 
 * Two nonoverlapping stretches of three residues each, i-1,i,i+1 and j-1,j,j+1, form either a parallel or antiparallel bridge, depending on which of two basic patterns is matched. We assign a bridge between residues i and j if there are two H bonds characteristic of beta- structure; in particular: <p> Parallel Bridge(i,j) =: [Hbond(i-1,j) and Hbond(j,i+1)]  or [Hbond(j-1,i) and Hbond(i,j+1)] <p> Antiparallel Bridge(i,j) =: [Hbond(i,j) and Hbond(j,i)]  or [Hbond(i-1,j+1) and Hbond(j-1,i+1)]
 */
private void findBridges(int i){
  for (int j=i + 3; j < groups.length - 1; j++) {
    BridgeType btype=null;
    if ((isBonded(i - 1,j) && isBonded(j,i + 1)) || (isBonded(j - 1,i) && isBonded(i,j + 1))) {
      btype=BridgeType.parallel;
    }
 else     if ((isBonded(i,j) && isBonded(j,i)) || (isBonded(i - 1,j + 1) && (isBonded(j - 1,i + 1)))) {
      btype=BridgeType.antiparallel;
    }
    if (btype != null) {
      registerBridge(i,j,btype);
    }
  }
}",0.6461107217939733
16625,"private void registerBridge(int i,int j,BridgeType btype){
  if (i > j) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"");
    int tmp=i;
    i=j;
    j=tmp;
  }
  BetaBridge bridge=new BetaBridge();
  bridge.partner1=i;
  bridge.partner2=j;
  bridge.type=btype;
  getSecStrucState(i).setBridge(bridge);
  getSecStrucState(j).setBridge(bridge);
  bridges.add(bridge);
}","private void registerBridge(int i,int j,BridgeType btype){
  BetaBridge bridge=new BetaBridge(i,j,btype);
  getSecStrucState(i).setBridge(bridge);
  getSecStrucState(j).setBridge(bridge);
  bridges.add(bridge);
}",0.3769100169779287
16626,"/** 
 * Calculate the HBonds between different groups. see Creighton page 147 f
 */
private void calculateHBonds() throws StructureException {
  if (groups.length < 5)   return;
  for (int i=1; i < groups.length; i++) {
    SecStrucGroup one=groups[i];
    if (!one.hasAtom(""String_Node_Str"")) {
      logger.warn(""String_Node_Str"" + one.getResidueNumber() + ""String_Node_Str"");
      continue;
    }
    for (int j=i + 1; j < groups.length; j++) {
      SecStrucGroup two=groups[j];
      double dist=Calc.getDistance(one.getCA(),two.getCA());
      if (dist >= CA_MIN_DIST)       continue;
      checkAddHBond(i,j);
      if (j != (i + 1))       checkAddHBond(j,i);
    }
  }
}","/** 
 * Calculate the HBonds between different groups. see Creighton page 147 f
 */
private void calculateHBonds() throws StructureException {
  if (groups.length < 5)   return;
  for (int i=0; i < groups.length; i++) {
    SecStrucGroup one=groups[i];
    for (int j=i + 1; j < groups.length; j++) {
      SecStrucGroup two=groups[j];
      double dist=Calc.getDistance(one.getCA(),two.getCA());
      if (dist >= CA_MIN_DIST)       continue;
      checkAddHBond(i,j);
      if (j != (i + 1))       checkAddHBond(j,i);
    }
  }
}",0.8760330578512396
16627,"/** 
 * Test if two groups are forming an H-Bond. DSSP defines H-Bonds if the energy < -500 cal/mol
 * @param one group one
 * @param two group two
 * @return flag if the two are forming an Hbond
 */
private boolean isBonded(int i,int j){
  Group one=groups[i];
  SecStrucState stateOne=(SecStrucState)one.getProperty(Group.SEC_STRUC);
  double acc1e=stateOne.getAccept1().getEnergy();
  double acc2e=stateOne.getAccept2().getEnergy();
  int partnerAcc1=stateOne.getAccept1().getPartner();
  int partnerAcc2=stateOne.getAccept2().getPartner();
  if (((partnerAcc1 == j) && (acc1e < HBONDHIGHENERGY)) || ((partnerAcc2 == j) && (acc2e < HBONDHIGHENERGY))) {
    return true;
  }
  return false;
}","/** 
 * Test if two groups are forming an H-Bond. DSSP defines H-Bonds if the energy < -500 cal/mol
 * @param one group one
 * @param two group two
 * @return flag if the two are forming an Hbond
 */
private boolean isBonded(int i,int j){
  Group one=groups[i];
  SecStrucState stateOne=(SecStrucState)one.getProperty(Group.SEC_STRUC);
  double acc1e=stateOne.getAccept1().getEnergy();
  double acc2e=stateOne.getAccept2().getEnergy();
  int partnerAcc1=stateOne.getAccept1().getPartner();
  int partnerAcc2=stateOne.getAccept2().getPartner();
  if (((partnerAcc1 == j) && (acc1e < HBONDHIGHENERGY)) || ((partnerAcc2 == j) && (acc2e < HBONDHIGHENERGY))) {
    logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ j);
    return true;
  }
  return false;
}",0.955922865013774
16628,"private void checkAddHBond(int i,int j){
  SecStrucGroup one=groups[i];
  if (one.getPDBName().equals(""String_Node_Str"")) {
    logger.debug(""String_Node_Str"" + one.getResidueNumber());
    return;
  }
  SecStrucGroup two=groups[j];
  if (!two.hasAtom(""String_Node_Str"")) {
    logger.warn(""String_Node_Str"" + two.getResidueNumber() + ""String_Node_Str"");
    return;
  }
  double energy=0;
  try {
    energy=calculateHBondEnergy(one,two);
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"",e);
    return;
  }
  logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ j+ ""String_Node_Str""+ energy);
  trackHBondEnergy(i,j,energy);
}","private void checkAddHBond(int i,int j){
  SecStrucGroup one=groups[i];
  if (one.getPDBName().equals(""String_Node_Str"")) {
    logger.debug(""String_Node_Str"" + one.getResidueNumber());
    return;
  }
  if (!one.hasAtom(""String_Node_Str"")) {
    logger.warn(""String_Node_Str"" + one.getResidueNumber() + ""String_Node_Str"");
    return;
  }
  SecStrucGroup two=groups[j];
  double energy=0;
  try {
    energy=calculateHBondEnergy(one,two);
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"",e);
    return;
  }
  logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ j+ ""String_Node_Str""+ energy);
  trackHBondEnergy(i,j,energy);
}",0.786046511627907
16629,"/** 
 * Find valid symmetry orders for a given stoichiometry. For instance, an A6B4 protein would give [1,2] because (A6B4)1 and (A3B2)2 are valid decompositions.
 * @param stoichiometry List giving the number of copies in each chain cluster
 * @return The common factors of the stoichiometry
 */
public static List<Integer> getValidFolds(List<Integer> stoichiometry){
  List<Integer> denominators=new ArrayList<Integer>();
  int nChains=stoichiometry.size();
  Set<Integer> nominators=new TreeSet<Integer>(stoichiometry);
  for (int d=1; d <= nChains; d++) {
    int count=0;
    for (Iterator<Integer> iter=nominators.iterator(); iter.hasNext(); ) {
      if (iter.next() % d == 0) {
        count++;
      }
    }
    if (count == nominators.size()) {
      denominators.add(d);
    }
  }
  return denominators;
}","/** 
 * Find valid symmetry orders for a given stoichiometry. For instance, an A6B4 protein would give [1,2] because (A6B4)1 and (A3B2)2 are valid decompositions.
 * @param stoichiometry List giving the number of copies in each chain cluster
 * @return The common factors of the stoichiometry
 */
public static List<Integer> getValidFolds(List<Integer> stoichiometry){
  List<Integer> denominators=new ArrayList<Integer>();
  int nChains=Collections.max(stoichiometry);
  Set<Integer> nominators=new TreeSet<Integer>(stoichiometry);
  for (int d=1; d <= nChains; d++) {
    boolean isDivisable=true;
    for (    Integer n : nominators) {
      if (n % d != 0) {
        isDivisable=false;
        break;
      }
    }
    if (isDivisable) {
      denominators.add(d);
    }
  }
  return denominators;
}",0.7103150092649784
16630,"private void storeUnAlignedSeqRes(Structure structure,List<Chain> seqResChains){
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> atomList=structure.getModel(i);
    for (    Chain seqRes : seqResChains) {
      Chain atomRes;
      atomRes=SeqRes2AtomAligner.getMatchingAtomRes(seqRes,atomList);
      atomRes.setSeqResGroups(seqRes.getAtomGroups());
    }
  }
}","private void storeUnAlignedSeqRes(Structure structure,List<Chain> seqResChains){
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> atomList=structure.getModel(i);
    for (    Chain seqRes : seqResChains) {
      Chain atomRes;
      atomRes=SeqRes2AtomAligner.getMatchingAtomRes(seqRes,atomList);
      if (atomRes != null)       atomRes.setSeqResGroups(seqRes.getAtomGroups());
 else       logger.warn(""String_Node_Str"" + seqRes.getChainID());
    }
  }
}",0.8907168037602821
16631,"public MultipleAlignment analyze(Atom[] atoms,CESymmParameters param) throws StructureException {
  if (atoms.length < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.params=param;
  if (params.isMultipleAxes() && params.getRefineMethod() != RefineMethod.NOT_REFINED) {
    logger.warn(""String_Node_Str"");
    CeSymmIterative iterative=new CeSymmIterative(params);
    MultipleAlignment result=iterative.execute(atoms);
    axes=iterative.getSymmetryAxes();
    return result;
  }
  AFPChain afp=align(atoms,atoms,params);
  if (refined) {
    msa=SymmetryTools.fromAFP(afp,ca1);
    msa.putScore(""String_Node_Str"",1.0);
    if (this.params.getOptimization()) {
      ExecutorService executor=Executors.newCachedThreadPool();
      List<Future<MultipleAlignment>> future=new ArrayList<Future<MultipleAlignment>>();
      int seed=this.params.getSeed();
      for (int rep=0; rep < 4; rep++) {
        Callable<MultipleAlignment> worker=new SymmOptimizer(msa,axes,params,seed++);
        Future<MultipleAlignment> submit=executor.submit(worker);
        future.add(submit);
      }
      double maxScore=Double.NEGATIVE_INFINITY;
      double score=maxScore;
      MultipleAlignment result=msa;
      for (int rep=0; rep < future.size(); rep++) {
        try {
          result=future.get(rep).get();
          score=result.getScore(MultipleAlignmentScorer.MC_SCORE);
        }
 catch (        InterruptedException e) {
          logger.warn(""String_Node_Str"",e);
        }
catch (        ExecutionException e) {
          logger.warn(""String_Node_Str"",e);
        }
        if (score > maxScore) {
          msa=result;
          maxScore=score;
        }
      }
      msa.putScore(""String_Node_Str"",1.0);
      executor.shutdown();
    }
  }
 else {
    MultipleAlignmentEnsemble e=new MultipleAlignmentEnsembleImpl(afp,ca1,ca1,false);
    msa=e.getMultipleAlignment(0);
    logger.warn(""String_Node_Str"" + ""String_Node_Str"");
    msa.putScore(""String_Node_Str"",0.0);
  }
  return msa;
}","public MultipleAlignment analyze(Atom[] atoms,CESymmParameters param) throws StructureException {
  if (atoms.length < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.params=param;
  if (params.isMultipleAxes() && params.getRefineMethod() != RefineMethod.NOT_REFINED) {
    logger.warn(""String_Node_Str"");
    CeSymmIterative iterative=new CeSymmIterative(params);
    msa=iterative.execute(atoms);
    axes=iterative.getSymmetryAxes();
    if (SymmetryTools.isRefined(msa)) {
      refined=true;
    }
 else {
      afpChain=align(atoms,atoms,params);
    }
  }
 else {
    afpChain=align(atoms,atoms,params);
  }
  if (refined) {
    if (msa == null)     msa=SymmetryTools.fromAFP(afpChain,ca1);
    msa.putScore(""String_Node_Str"",1.0);
    if (this.params.getOptimization()) {
      ExecutorService executor=Executors.newCachedThreadPool();
      List<Future<MultipleAlignment>> future=new ArrayList<Future<MultipleAlignment>>();
      int seed=this.params.getSeed();
      for (int rep=0; rep < 4; rep++) {
        Callable<MultipleAlignment> worker=new SymmOptimizer(msa,axes,params,seed++);
        Future<MultipleAlignment> submit=executor.submit(worker);
        future.add(submit);
      }
      double maxScore=Double.NEGATIVE_INFINITY;
      double score=maxScore;
      MultipleAlignment result=msa;
      for (int rep=0; rep < future.size(); rep++) {
        try {
          result=future.get(rep).get();
          score=result.getScore(MultipleAlignmentScorer.MC_SCORE);
        }
 catch (        InterruptedException e) {
          logger.warn(""String_Node_Str"",e);
        }
catch (        ExecutionException e) {
          logger.warn(""String_Node_Str"",e);
        }
        if (score > maxScore) {
          msa=result;
          maxScore=score;
        }
      }
      msa.putScore(""String_Node_Str"",1.0);
      executor.shutdown();
    }
  }
 else {
    MultipleAlignmentEnsemble e=new MultipleAlignmentEnsembleImpl(afpChain,ca1,ca1,false);
    msa=e.getMultipleAlignment(0);
    logger.warn(""String_Node_Str"" + ""String_Node_Str"");
    msa.putScore(""String_Node_Str"",0.0);
  }
  return msa;
}",0.9116726835138388
16632,"/** 
 * This method uses iteratively CeSymm to calculate all  symmetries in the input array of atoms and organize  them in a multiple alignment of the subunits.
 * @param atoms atoms 
 * @return MultipleAlignment of the subunits
 * @throws StructureException  
 */
public MultipleAlignment execute(Atom[] atoms) throws StructureException {
  allAtoms=atoms;
  for (Integer res=0; res < allAtoms.length; res++) {
    alignment.add(new ArrayList<Integer>());
  }
  iterate(atoms,0);
  buildAlignment();
  recoverAxes();
  try {
    SymmOptimizer optimizer=new SymmOptimizer(msa,axes,params,params.getSeed());
    msa=optimizer.optimize();
    msa.putScore(""String_Node_Str"",1.0);
  }
 catch (  RefinerFailedException e) {
    e.printStackTrace();
  }
  return msa;
}","/** 
 * This method uses iteratively CeSymm to calculate all  symmetries in the input array of atoms and organize  them in a multiple alignment of the subunits.
 * @param atoms atoms 
 * @return MultipleAlignment of the subunits
 * @throws StructureException  
 */
public MultipleAlignment execute(Atom[] atoms) throws StructureException {
  allAtoms=atoms;
  for (Integer res=0; res < allAtoms.length; res++) {
    alignment.add(new ArrayList<Integer>());
  }
  iterate(atoms,0);
  buildAlignment();
  recoverAxes();
  return msa;
}",0.8033924441017734
16633,"/** 
 * Returns true if the symmetry alignment has been refined,  false otherwise.  <p> For a refined alignment only one Block with no repeated  residues is necessary. Sufficient condition is not tested  (only known from the algorithm).
 * @param symm the symmetry alignment
 * @return true if the alignment is refined
 */
public static boolean isRefined(MultipleAlignment symm){
  if (symm.getScore(""String_Node_Str"") != null) {
    if (symm.getScore(""String_Node_Str"") > 0)     return true;
 else     return false;
  }
 else {
    if (symm.getBlocks().size() > 1) {
      symm.putScore(""String_Node_Str"",0.0);
      return false;
    }
 else {
      List<Integer> alreadySeen=new ArrayList<Integer>();
      List<List<Integer>> align=symm.getBlock(0).getAlignRes();
      for (int str=0; str < symm.size(); str++) {
        for (int res=0; res < align.get(str).size(); res++) {
          Integer residue=align.get(str).get(res);
          if (residue == null)           continue;
          if (alreadySeen.contains(residue)) {
            symm.putScore(""String_Node_Str"",0.0);
            return false;
          }
 else {
            alreadySeen.add(residue);
          }
        }
      }
      return true;
    }
  }
}","/** 
 * Returns true if the symmetry alignment has been refined,  false otherwise.  <p> For a refined alignment only one Block with no repeated  residues is necessary. Sufficient condition is not tested  (only known from the algorithm).
 * @param symm the symmetry alignment
 * @return true if the alignment is refined
 */
public static boolean isRefined(MultipleAlignment symm){
  if (symm.getScore(""String_Node_Str"") != null) {
    if (symm.getScore(""String_Node_Str"") > 0)     return true;
 else     return false;
  }
 else {
    if (symm.getBlocks().size() > 1) {
      symm.putScore(""String_Node_Str"",0.0);
      return false;
    }
 else     if (symm.size() < 2)     return false;
 else {
      List<Integer> alreadySeen=new ArrayList<Integer>();
      List<List<Integer>> align=symm.getBlock(0).getAlignRes();
      for (int str=0; str < symm.size(); str++) {
        for (int res=0; res < align.get(str).size(); res++) {
          Integer residue=align.get(str).get(res);
          if (residue == null)           continue;
          if (alreadySeen.contains(residue)) {
            symm.putScore(""String_Node_Str"",0.0);
            return false;
          }
 else {
            alreadySeen.add(residue);
          }
        }
      }
      return true;
    }
  }
}",0.9803607214428858
16634,"/** 
 * Constructor from an AFPChain instance. Creates an equivalent pairwise  alignment, but in the MultipleAlignment format.
 * @param afp pairwise alignment
 * @param ca1 Atoms of the first strcuture
 * @param ca2 Atoms of the second structure
 * @param flexible true if the alignment is flexible (use BlockSets)
 * @return MultipleAlignmentEnsemble an ensemble
 */
public MultipleAlignmentEnsembleImpl(AFPChain afp,Atom[] ca1,Atom[] ca2,boolean flexible){
  this();
  atomArrays=Arrays.asList(ca1,ca2);
  structureNames=Arrays.asList(afp.getName1(),afp.getName2());
  algorithmName=afp.getAlgorithmName();
  version=afp.getVersion();
  calculationTime=afp.getCalculationTime();
  MultipleAlignment msa=new MultipleAlignmentImpl(this);
  setMultipleAlignments(Arrays.asList((MultipleAlignment)msa));
  Matrix4d ident=new Matrix4d();
  ident.setIdentity();
  Matrix[] rot=afp.getBlockRotationMatrix();
  Atom[] shift=afp.getBlockShiftVector();
  if (flexible) {
    for (int bs=0; bs < afp.getBlockNum(); bs++) {
      BlockSet blockSet=new BlockSetImpl(msa);
      Matrix4d blockTr=Calc.getTransformation(rot[bs],shift[bs]);
      blockSet.setTransformations(Arrays.asList(ident,blockTr));
      Block block=new BlockImpl(blockSet);
      block.setAlignRes(new ArrayList<List<Integer>>());
      block.getAlignRes().add(new ArrayList<Integer>());
      block.getAlignRes().add(new ArrayList<Integer>());
      Matrix rotB=afp.getBlockRotationMatrix()[bs];
      Atom shiftB=afp.getBlockShiftVector()[bs];
      Matrix4d transformB=Calc.getTransformation(rotB,shiftB);
      blockSet.setTransformations(Arrays.asList(ident,transformB));
      for (int i=0; i < afp.getOptAln()[bs][0].length; i++) {
        block.getAlignRes().get(0).add(afp.getOptAln()[bs][0][i]);
        block.getAlignRes().get(1).add(afp.getOptAln()[bs][1][i]);
      }
    }
  }
 else {
    BlockSet blockSet=new BlockSetImpl(msa);
    Matrix4d blockTr=Calc.getTransformation(rot[0],shift[0]);
    blockSet.setTransformations(Arrays.asList(ident,blockTr));
    for (int bs=0; bs < afp.getBlockNum(); bs++) {
      Block block=new BlockImpl(blockSet);
      block.setAlignRes(new ArrayList<List<Integer>>());
      block.getAlignRes().add(new ArrayList<Integer>());
      block.getAlignRes().add(new ArrayList<Integer>());
      for (int i=0; i < afp.getOptAln()[bs][0].length; i++) {
        block.getAlignRes().get(0).add(afp.getOptAln()[bs][0][i]);
        block.getAlignRes().get(1).add(afp.getOptAln()[bs][1][i]);
      }
    }
  }
  msa.putScore(MultipleAlignmentScorer.PROBABILITY,afp.getProbability());
  msa.putScore(MultipleAlignmentScorer.AVGTM_SCORE,afp.getTMScore());
  msa.putScore(MultipleAlignmentScorer.CE_SCORE,afp.getAlignScore());
  msa.putScore(MultipleAlignmentScorer.RMSD,afp.getTotalRmsdOpt());
}","/** 
 * Constructor from an AFPChain instance. Creates an equivalent pairwise  alignment, but in the MultipleAlignment format.
 * @param afp pairwise alignment
 * @param ca1 Atoms of the first strcuture
 * @param ca2 Atoms of the second structure
 * @param flexible true if the alignment is flexible (use BlockSets)
 * @return MultipleAlignmentEnsemble an ensemble
 */
public MultipleAlignmentEnsembleImpl(AFPChain afp,Atom[] ca1,Atom[] ca2,boolean flexible){
  this();
  atomArrays=Arrays.asList(ca1,ca2);
  structureNames=Arrays.asList(afp.getName1(),afp.getName2());
  algorithmName=afp.getAlgorithmName();
  version=afp.getVersion();
  calculationTime=afp.getCalculationTime();
  MultipleAlignment msa=new MultipleAlignmentImpl(this);
  setMultipleAlignments(Arrays.asList((MultipleAlignment)msa));
  Matrix4d ident=new Matrix4d();
  ident.setIdentity();
  Matrix[] rot=afp.getBlockRotationMatrix();
  Atom[] shift=afp.getBlockShiftVector();
  if (flexible) {
    for (int bs=0; bs < afp.getBlockNum(); bs++) {
      BlockSet blockSet=new BlockSetImpl(msa);
      Matrix4d blockTr=null;
      try {
        blockTr=Calc.getTransformation(rot[bs],shift[bs]);
      }
 catch (      IndexOutOfBoundsException e) {
        blockTr=ident;
      }
      blockSet.setTransformations(Arrays.asList(ident,blockTr));
      Block block=new BlockImpl(blockSet);
      block.setAlignRes(new ArrayList<List<Integer>>());
      block.getAlignRes().add(new ArrayList<Integer>());
      block.getAlignRes().add(new ArrayList<Integer>());
      Matrix rotB=afp.getBlockRotationMatrix()[bs];
      Atom shiftB=afp.getBlockShiftVector()[bs];
      Matrix4d transformB=Calc.getTransformation(rotB,shiftB);
      blockSet.setTransformations(Arrays.asList(ident,transformB));
      for (int i=0; i < afp.getOptAln()[bs][0].length; i++) {
        block.getAlignRes().get(0).add(afp.getOptAln()[bs][0][i]);
        block.getAlignRes().get(1).add(afp.getOptAln()[bs][1][i]);
      }
    }
  }
 else {
    BlockSet blockSet=new BlockSetImpl(msa);
    Matrix4d blockTr=null;
    try {
      blockTr=Calc.getTransformation(rot[0],shift[0]);
    }
 catch (    IndexOutOfBoundsException e) {
      blockTr=ident;
    }
    blockSet.setTransformations(Arrays.asList(ident,blockTr));
    for (int bs=0; bs < afp.getBlockNum(); bs++) {
      Block block=new BlockImpl(blockSet);
      block.setAlignRes(new ArrayList<List<Integer>>());
      block.getAlignRes().add(new ArrayList<Integer>());
      block.getAlignRes().add(new ArrayList<Integer>());
      for (int i=0; i < afp.getOptAln()[bs][0].length; i++) {
        block.getAlignRes().get(0).add(afp.getOptAln()[bs][0][i]);
        block.getAlignRes().get(1).add(afp.getOptAln()[bs][1][i]);
      }
    }
  }
  msa.putScore(MultipleAlignmentScorer.PROBABILITY,afp.getProbability());
  msa.putScore(MultipleAlignmentScorer.AVGTM_SCORE,afp.getTMScore());
  msa.putScore(MultipleAlignmentScorer.CE_SCORE,afp.getAlignScore());
  msa.putScore(MultipleAlignmentScorer.RMSD,afp.getTotalRmsdOpt());
}",0.9614457831325302
16635,"/** 
 * If available, get the list of subalignments.<p> Should be length one unless   {@link CESymmParameters#getMaxSymmOrder()}was set.
 * @return List of AFP alignments
 */
public List<AFPChain> getAfpAlignments(){
  return afpAlignments;
}","/** 
 * If available, get the list of subalignments.<p> Should be length one unless using the MULTIPLE refiner.
 * @return List of AFP alignments
 */
public List<AFPChain> getAfpAlignments(){
  return afpAlignments;
}",0.8366013071895425
16636,"/** 
 * This method runs iteratively CeSymm on the symmetric units until no more symmetries exist.
 * @param atoms Coordinates of the structure atoms
 * @throws StructureException
 */
private void iterate(Atom[] atoms) throws StructureException {
  if (atoms.length <= params.getWinSize() || atoms.length <= params.getMinSubunitLength()) {
    logger.debug(""String_Node_Str"",atoms.length);
    return;
  }
  CeSymm aligner=new CeSymm();
  MultipleAlignment align=aligner.analyze(atoms,params);
  if (name == null)   name=align.getEnsemble().getStructureNames().get(0);
  if (!SymmetryTools.isRefined(align))   return;
 else   if (align.getScore(MultipleAlignmentScorer.AVGTM_SCORE) < params.getSymmetryThreshold() || align.getCoreLength() < params.getMinSubunitLength()) {
    return;
  }
  levels.add(align);
  Block b=align.getBlock(0);
  for (int pos=0; pos < b.length(); pos++) {
    for (int su=0; su < b.size() - 1; su++) {
      Integer pos1=b.getAlignRes().get(su).get(pos);
      Integer pos2=b.getAlignRes().get(su + 1).get(pos);
      if (pos1 != null && pos2 != null) {
        alignment.get(pos1).add(pos2);
      }
    }
  }
  Integer start=null;
  int it=0;
  while (start == null) {
    start=align.getBlocks().get(0).getAlignRes().get(0).get(it);
    it++;
  }
  Integer end=null;
  it=align.getBlocks().get(0).getAlignRes().get(0).size() - 1;
  while (end == null) {
    end=align.getBlocks().get(0).getAlignRes().get(0).get(it);
    it--;
  }
  Atom[] atomsR=Arrays.copyOfRange(atoms,start,end + 1);
  iterate(atomsR);
}","/** 
 * This method runs iteratively CeSymm on the symmetric units until no more symmetries exist.
 * @param atoms Coordinates of the structure atoms
 * @throws StructureException
 */
private void iterate(Atom[] atoms) throws StructureException {
  logger.debug(""String_Node_Str"");
  if (atoms.length <= params.getWinSize() || atoms.length <= params.getMinSubunitLength()) {
    logger.debug(""String_Node_Str"" + ""String_Node_Str"",atoms.length);
    return;
  }
  CeSymm aligner=new CeSymm();
  MultipleAlignment align=aligner.analyze(atoms,params);
  if (name == null)   name=align.getEnsemble().getStructureNames().get(0);
  if (!SymmetryTools.isRefined(align))   return;
 else   if (align.getScore(MultipleAlignmentScorer.AVGTM_SCORE) < params.getSymmetryThreshold() || align.getCoreLength() < params.getMinSubunitLength()) {
    return;
  }
  levels.add(align);
  Block b=align.getBlock(0);
  for (int pos=0; pos < b.length(); pos++) {
    for (int su=0; su < b.size() - 1; su++) {
      Integer pos1=b.getAlignRes().get(su).get(pos);
      Integer pos2=b.getAlignRes().get(su + 1).get(pos);
      if (pos1 != null && pos2 != null) {
        alignment.get(pos1).add(pos2);
      }
    }
  }
  Integer start=null;
  int it=0;
  while (start == null) {
    start=align.getBlocks().get(0).getAlignRes().get(0).get(it);
    it++;
  }
  Integer end=null;
  it=align.getBlocks().get(0).getAlignRes().get(0).size() - 1;
  while (end == null) {
    end=align.getBlocks().get(0).getAlignRes().get(0).get(it);
    it--;
  }
  Atom[] atomsR=Arrays.copyOfRange(atoms,start,end + 1);
  iterate(atomsR);
}",0.982444940951165
16637,"@Override public AFPChain refine(List<AFPChain> afpAlignments,Atom[] atoms) throws RefinerFailedException, StructureException {
  List<List<Integer>> graph=SymmetryTools.buildSymmetryGraph(afpAlignments,atoms,true);
  AFPChain afpChain=afpAlignments.get(afpAlignments.size() - 1);
  List<Integer> alreadySeen=new ArrayList<Integer>();
  List<List<Integer>> groups=new ArrayList<List<Integer>>();
  for (int i=0; i < graph.size(); i++) {
    if (!alreadySeen.contains(i)) {
      List<Integer> group=new ArrayList<Integer>();
      int residue=i;
      while (residue != -1 && !alreadySeen.contains(residue)) {
        group.add(residue);
        List<Integer> neigh=graph.get(residue);
        if (neigh.size() > 1) {
          if (neigh.get(1) > residue) {
            residue=neigh.get(1);
          }
 else           residue=-1;
        }
 else         if (neigh.size() > 0) {
          if (neigh.get(0) > residue) {
            residue=neigh.get(0);
          }
 else           residue=-1;
        }
 else         residue=-1;
      }
      Collections.sort(group);
      if (group.size() > 1) {
        groups.add(group);
        alreadySeen.addAll(group);
      }
    }
  }
  List<Integer> sizes=new ArrayList<Integer>(atoms.length);
  for (int p=0; p < atoms.length; p++)   sizes.add(0);
  for (int i=0; i < groups.size(); i++) {
    int gorder=groups.get(i).size();
    sizes.set(gorder,sizes.get(gorder) + 1);
  }
  int maxNr=0;
  for (int s=2; s < sizes.size(); s++) {
    if (sizes.get(s) * s > maxNr) {
      order=s;
      maxNr=sizes.get(s) * s;
    }
  }
  List<List<Integer>> subunits=new ArrayList<List<Integer>>();
  for (  List<Integer> g : groups)   if (g.size() == order)   subunits.add(g);
  List<Integer> deleteIndices=new ArrayList<Integer>();
  for (int i=1; i < subunits.size(); i++) {
    for (int j=0; j < subunits.get(i).size() - 1; j++) {
      if (subunits.get(i).get(j) > subunits.get(0).get(j + 1)) {
        deleteIndices.add(i);
        break;
      }
    }
  }
  for (int i=deleteIndices.size() - 1; i >= 0; i--) {
    int index=deleteIndices.get(i);
    subunits.remove(index);
  }
  for (  List<Integer> g : groups) {
    if (g.size() > order) {
      List<Integer> group=new ArrayList<Integer>();
      for (int pos=0; pos < g.size() && group.size() < order; pos++) {
        boolean consistent=true;
        for (        List<Integer> sub : subunits) {
          if (sub.get(group.size()) > g.get(pos))           consistent=false;
          if (group.size() < order - 1) {
            if (sub.get(group.size() + 1) < g.get(pos))             consistent=false;
          }
        }
        if (consistent && group.size() < order)         group.add(g.get(pos));
      }
      if (group.size() == order)       subunits.add(group);
    }
  }
  int[][][] optAln=new int[order][2][subunits.size()];
  for (int bk=0; bk < order; bk++) {
    optAln[bk]=new int[2][];
    optAln[bk][0]=new int[subunits.size()];
    optAln[bk][1]=new int[subunits.size()];
    for (int su=0; su < subunits.size(); su++) {
      optAln[bk][0][su]=subunits.get(su).get(bk);
      optAln[bk][1][su]=subunits.get(su).get((bk + 1) % order);
    }
  }
  afpChain=AlignmentTools.replaceOptAln(optAln,afpChain,atoms,atoms);
  return afpChain;
}","@Override public AFPChain refine(List<AFPChain> afpAlignments,Atom[] atoms) throws RefinerFailedException, StructureException {
  List<List<Integer>> graph=SymmetryTools.buildSymmetryGraph(afpAlignments,atoms,true);
  AFPChain afpChain=afpAlignments.get(afpAlignments.size() - 1);
  List<Integer> alreadySeen=new ArrayList<Integer>();
  List<List<Integer>> groups=new ArrayList<List<Integer>>();
  for (int i=0; i < graph.size(); i++) {
    if (!alreadySeen.contains(i)) {
      List<Integer> group=new ArrayList<Integer>();
      int residue=i;
      while (residue != -1 && !alreadySeen.contains(residue)) {
        group.add(residue);
        List<Integer> neigh=graph.get(residue);
        if (neigh.size() > 1) {
          if (neigh.get(1) > residue) {
            residue=neigh.get(1);
          }
 else           residue=-1;
        }
 else         if (neigh.size() > 0) {
          if (neigh.get(0) > residue) {
            residue=neigh.get(0);
          }
 else           residue=-1;
        }
 else         residue=-1;
      }
      Collections.sort(group);
      if (group.size() > 1) {
        groups.add(group);
        alreadySeen.addAll(group);
      }
    }
  }
  List<Integer> sizes=new ArrayList<Integer>(atoms.length);
  for (int p=0; p < atoms.length; p++)   sizes.add(0);
  for (int i=0; i < groups.size(); i++) {
    int gorder=groups.get(i).size();
    sizes.set(gorder,sizes.get(gorder) + 1);
  }
  int maxNr=0;
  for (int s=2; s < sizes.size(); s++) {
    if (sizes.get(s) * s > maxNr) {
      order=s;
      maxNr=sizes.get(s) * s;
    }
  }
  List<List<Integer>> subunits=new ArrayList<List<Integer>>();
  for (  List<Integer> g : groups)   if (g.size() == order)   subunits.add(g);
  List<Integer> deleteIndices=new ArrayList<Integer>();
  for (int i=1; i < subunits.size(); i++) {
    for (int j=0; j < subunits.get(i).size() - 1; j++) {
      if (subunits.get(i).get(j) > subunits.get(0).get(j + 1)) {
        deleteIndices.add(i);
        break;
      }
    }
  }
  for (int i=deleteIndices.size() - 1; i >= 0; i--) {
    int index=deleteIndices.get(i);
    subunits.remove(index);
  }
  for (  List<Integer> g : groups) {
    if (g.size() > order) {
      List<Integer> group=new ArrayList<Integer>();
      for (int pos=0; pos < g.size() && group.size() < order; pos++) {
        boolean consistent=true;
        for (        List<Integer> sub : subunits) {
          if (sub.get(group.size()) > g.get(pos))           consistent=false;
          if (group.size() < order - 1) {
            if (sub.get(group.size() + 1) < g.get(pos))             consistent=false;
          }
        }
        if (consistent && group.size() < order)         group.add(g.get(pos));
      }
      if (group.size() == order)       subunits.add(group);
    }
  }
  if (subunits.size() == 0) {
    throw new RefinerFailedException(""String_Node_Str"");
  }
  int[][][] optAln=new int[order][2][subunits.size()];
  for (int bk=0; bk < order; bk++) {
    optAln[bk]=new int[2][];
    optAln[bk][0]=new int[subunits.size()];
    optAln[bk][1]=new int[subunits.size()];
    for (int su=0; su < subunits.size(); su++) {
      optAln[bk][0][su]=subunits.get(su).get(bk);
      optAln[bk][1][su]=subunits.get(su).get((bk + 1) % order);
    }
  }
  afpChain=AlignmentTools.replaceOptAln(optAln,afpChain,atoms,atoms);
  return afpChain;
}",0.9861891030505388
16638,"/** 
 * Method that converts the symmetric units of a structure into different chains, so that internal symmetry can be translated into quaternary. <p> Application: obtain the internal symmetry axis with the quaternary  symmetry code in biojava or calculate independent subunit properties.
 * @param symmetry MultipleAlignment of the subunits only
 * @return Structure with different chains for every symmetric unit
 */
public static Structure getQuaternaryStructure(MultipleAlignment symmetry){
  if (!symmetry.getEnsemble().getAlgorithmName().contains(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Atom[] atoms=symmetry.getAtomArrays().get(0);
  Structure cloned=atoms[0].getGroup().getChain().getParent().clone();
  atoms=StructureTools.getRepresentativeAtomArray(cloned);
  Structure symm=new StructureImpl();
  symm.setChains(new ArrayList<Chain>());
  char chainID='A';
  for (int i=0; i < symmetry.size(); i++) {
    Chain newCh=new ChainImpl();
    newCh.setChainID(chainID + ""String_Node_Str"");
    chainID++;
    symm.addChain(newCh);
    Block align=symmetry.getBlock(0);
    int count=0;
    Integer start=null;
    while (start == null && count < align.length()) {
      start=align.getAlignRes().get(i).get(0 + count);
      count++;
    }
    count=1;
    Integer end=null;
    while (end == null && count <= align.length()) {
      end=align.getAlignRes().get(i).get(align.length() - count);
      count++;
    }
    end++;
    Atom[] subunit=Arrays.copyOfRange(atoms,start,end);
    for (int k=0; k < subunit.length; k++)     newCh.addGroup((Group)subunit[k].getGroup().clone());
  }
  return symm;
}","/** 
 * Method that converts the symmetric units of a structure into different chains, so that internal symmetry can be translated into quaternary. <p> Application: obtain the internal symmetry axis with the quaternary  symmetry code in biojava or calculate independent subunit properties.
 * @param symmetry MultipleAlignment of the subunits only
 * @return Structure with different chains for every symmetric unit
 */
public static Structure getQuaternaryStructure(MultipleAlignment symmetry){
  if (!symmetry.getEnsemble().getAlgorithmName().contains(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Atom[] atoms=symmetry.getAtomArrays().get(0);
  Structure cloned=atoms[0].getGroup().getChain().getStructure().clone();
  atoms=StructureTools.getRepresentativeAtomArray(cloned);
  Structure symm=new StructureImpl();
  symm.setChains(new ArrayList<Chain>());
  char chainID='A';
  for (int i=0; i < symmetry.size(); i++) {
    Chain newCh=new ChainImpl();
    newCh.setChainID(chainID + ""String_Node_Str"");
    chainID++;
    symm.addChain(newCh);
    Block align=symmetry.getBlock(0);
    int count=0;
    Integer start=null;
    while (start == null && count < align.length()) {
      start=align.getAlignRes().get(i).get(0 + count);
      count++;
    }
    count=1;
    Integer end=null;
    while (end == null && count <= align.length()) {
      end=align.getAlignRes().get(i).get(align.length() - count);
      count++;
    }
    end++;
    Atom[] subunit=Arrays.copyOfRange(atoms,start,end);
    for (int k=0; k < subunit.length; k++)     newCh.addGroup((Group)subunit[k].getGroup().clone());
  }
  return symm;
}",0.9954805664356734
16639,"public MultipleAlignment analyze(Atom[] atoms,CESymmParameters param) throws StructureException {
  if (atoms.length < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.params=param;
  if (params.isMultipleAxes() && params.getRefineMethod() != RefineMethod.NOT_REFINED) {
    logger.warn(""String_Node_Str"");
    CeSymmIterative iterative=new CeSymmIterative(params.clone());
    msa=iterative.execute(atoms);
    axes=iterative.getSymmetryAxes();
    if (SymmetryTools.isRefined(msa)) {
      refined=true;
    }
 else {
      afpChain=align(atoms,atoms,params);
    }
  }
 else {
    afpChain=align(atoms,atoms,params);
  }
  if (refined) {
    if (msa == null)     msa=SymmetryTools.fromAFP(afpChain,ca1);
    msa.putScore(""String_Node_Str"",1.0);
    if (this.params.getOptimization()) {
      try {
        SymmOptimizer optimizer=new SymmOptimizer(msa,axes,params,params.getSeed());
        msa=optimizer.optimize();
      }
 catch (      RefinerFailedException e) {
        logger.warn(""String_Node_Str"",e);
      }
    }
  }
 else {
    MultipleAlignmentEnsemble e=new MultipleAlignmentEnsembleImpl(afpChain,ca1,ca1,false);
    msa=e.getMultipleAlignment(0);
    logger.warn(""String_Node_Str"");
    msa.putScore(""String_Node_Str"",0.0);
  }
  return msa;
}","public MultipleAlignment analyze(Atom[] atoms,CESymmParameters param) throws StructureException {
  if (atoms.length < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.params=param;
  if (params.isMultipleAxes() && params.getRefineMethod() != RefineMethod.NOT_REFINED) {
    logger.warn(""String_Node_Str"");
    CeSymmIterative iterative=new CeSymmIterative(params.clone());
    msa=iterative.execute(atoms);
    axes=iterative.getSymmetryAxes();
    if (SymmetryTools.isRefined(msa)) {
      refined=true;
    }
 else {
      afpChain=align(atoms,atoms,params);
      msa=null;
    }
  }
 else {
    afpChain=align(atoms,atoms,params);
  }
  if (refined) {
    if (msa == null)     msa=SymmetryTools.fromAFP(afpChain,ca1);
    msa.putScore(""String_Node_Str"",1.0);
    if (this.params.getOptimization()) {
      try {
        SymmOptimizer optimizer=new SymmOptimizer(msa,axes,params,params.getSeed());
        msa=optimizer.optimize();
      }
 catch (      RefinerFailedException e) {
        logger.warn(""String_Node_Str"",e);
      }
    }
  }
 else {
    MultipleAlignmentEnsemble e=new MultipleAlignmentEnsembleImpl(afpChain,ca1,ca1,false);
    msa=e.getMultipleAlignment(0);
    logger.warn(""String_Node_Str"");
    msa.putScore(""String_Node_Str"",0.0);
  }
  return msa;
}",0.9938176197836168
16640,"/** 
 * For the iterative algorithm to work properly the refinement and  optimization options should be turned on, because the alignment has to be consistent at every recursive step.
 * @param params CeSymm parameters
 */
public CeSymmIterative(CESymmParameters params){
  this.params=params;
  params.setMultipleAxes(false);
  msa=new MultipleAlignmentImpl();
  msa.getEnsemble().setAtomArrays(new ArrayList<Atom[]>());
  msa.getEnsemble().setAlgorithmName(CeSymm.algorithmName);
  msa.getEnsemble().setVersion(CeSymm.version);
  msa.getEnsemble().setStructureNames(new ArrayList<String>());
  BlockSet bs=new BlockSetImpl(msa);
  Block b=new BlockImpl(bs);
  b.setAlignRes(new ArrayList<List<Integer>>());
  alignment=new ArrayList<List<Integer>>();
  levels=new ArrayList<MultipleAlignment>();
  axes=new SymmetryAxes();
  name=null;
}","/** 
 * For the iterative algorithm to work properly the refinement and  optimization options should be turned on, because the alignment has to be consistent at every recursive step.
 * @param params CeSymm parameters, make sure they are cloned
 */
public CeSymmIterative(CESymmParameters params){
  this.params=params;
  params.setMultipleAxes(false);
  msa=new MultipleAlignmentImpl();
  msa.getEnsemble().setAtomArrays(new ArrayList<Atom[]>());
  msa.getEnsemble().setAlgorithmName(CeSymm.algorithmName);
  msa.getEnsemble().setVersion(CeSymm.version);
  msa.getEnsemble().setStructureNames(new ArrayList<String>());
  BlockSet bs=new BlockSetImpl(msa);
  Block b=new BlockImpl(bs);
  b.setAlignRes(new ArrayList<List<Integer>>());
  alignment=new ArrayList<List<Integer>>();
  levels=new ArrayList<MultipleAlignment>();
  axes=new SymmetryAxes();
  name=null;
}",0.9841456253669996
16641,"/** 
 * Method that converts the symmetric units of a structure into different chains, so that internal symmetry can be translated into quaternary. <p> Application: obtain the internal symmetry axis with the quaternary  symmetry code in biojava or calculate independent subunit properties.
 * @param symmetry MultipleAlignment of the subunits only
 * @return Structure with different chains for every symmetric unit
 */
public static Structure getQuaternaryStructure(MultipleAlignment symmetry){
  if (!symmetry.getEnsemble().getAlgorithmName().contains(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Atom[] atoms=symmetry.getAtomArrays().get(0);
  Structure cloned=atoms[0].getGroup().getChain().getParent().clone();
  atoms=StructureTools.getRepresentativeAtomArray(cloned);
  Structure symm=new StructureImpl();
  symm.setChains(new ArrayList<Chain>());
  char chainID='A';
  for (int i=0; i < symmetry.size(); i++) {
    Chain newCh=new ChainImpl();
    newCh.setChainID(chainID + ""String_Node_Str"");
    chainID++;
    symm.addChain(newCh);
    Block align=symmetry.getBlock(0);
    int count=0;
    Integer start=null;
    while (start == null && count < align.length()) {
      start=align.getAlignRes().get(i).get(0 + count);
      count++;
    }
    count=1;
    Integer end=null;
    while (end == null && count < align.length()) {
      end=align.getAlignRes().get(i).get(align.length() - count);
      count++;
    }
    end++;
    Atom[] subunit=Arrays.copyOfRange(atoms,start,end);
    for (int k=0; k < subunit.length; k++)     newCh.addGroup((Group)subunit[k].getGroup().clone());
  }
  return symm;
}","/** 
 * Method that converts the symmetric units of a structure into different chains, so that internal symmetry can be translated into quaternary. <p> Application: obtain the internal symmetry axis with the quaternary  symmetry code in biojava or calculate independent subunit properties.
 * @param symmetry MultipleAlignment of the subunits only
 * @return Structure with different chains for every symmetric unit
 */
public static Structure getQuaternaryStructure(MultipleAlignment symmetry){
  if (!symmetry.getEnsemble().getAlgorithmName().contains(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Atom[] atoms=symmetry.getAtomArrays().get(0);
  Structure cloned=atoms[0].getGroup().getChain().getParent().clone();
  atoms=StructureTools.getRepresentativeAtomArray(cloned);
  Structure symm=new StructureImpl();
  symm.setChains(new ArrayList<Chain>());
  char chainID='A';
  for (int i=0; i < symmetry.size(); i++) {
    Chain newCh=new ChainImpl();
    newCh.setChainID(chainID + ""String_Node_Str"");
    chainID++;
    symm.addChain(newCh);
    Block align=symmetry.getBlock(0);
    int count=0;
    Integer start=null;
    while (start == null && count < align.length()) {
      start=align.getAlignRes().get(i).get(0 + count);
      count++;
    }
    count=1;
    Integer end=null;
    while (end == null && count <= align.length()) {
      end=align.getAlignRes().get(i).get(align.length() - count);
      count++;
    }
    end++;
    Atom[] subunit=Arrays.copyOfRange(atoms,start,end);
    for (int k=0; k < subunit.length; k++)     newCh.addGroup((Group)subunit[k].getGroup().clone());
  }
  return symm;
}",0.9996983408748116
16642,"public MultipleAlignment analyze(Atom[] atoms,CESymmParameters param) throws StructureException {
  if (atoms.length < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.params=param;
  if (params.isMultipleAxes() && params.getRefineMethod() != RefineMethod.NOT_REFINED) {
    logger.warn(""String_Node_Str"");
    CeSymmIterative iterative=new CeSymmIterative(params.clone());
    msa=iterative.execute(atoms);
    axes=iterative.getSymmetryAxes();
    if (SymmetryTools.isRefined(msa)) {
      refined=true;
    }
 else {
      afpChain=align(atoms,atoms,params);
      msa=null;
    }
  }
 else {
    afpChain=align(atoms,atoms,params);
  }
  if (refined) {
    if (msa == null)     msa=SymmetryTools.fromAFP(afpChain,ca1);
    MultipleAlignmentScorer.calculateScores(msa);
    msa.putScore(""String_Node_Str"",1.0);
    if (this.params.getOptimization()) {
      try {
        SymmOptimizer optimizer=new SymmOptimizer(msa,axes,params,params.getSeed());
        msa=optimizer.optimize();
        msa.putScore(""String_Node_Str"",1.0);
      }
 catch (      RefinerFailedException e) {
        logger.warn(""String_Node_Str"",e);
      }
    }
  }
 else {
    MultipleAlignmentEnsemble e=new MultipleAlignmentEnsembleImpl(afpChain,ca1,ca1,false);
    msa=e.getMultipleAlignment(0);
    logger.warn(""String_Node_Str"");
    msa.putScore(""String_Node_Str"",0.0);
  }
  return msa;
}","public MultipleAlignment analyze(Atom[] atoms,CESymmParameters param) throws StructureException {
  if (atoms.length < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.params=param;
  if (params.isMultipleAxes() && params.getRefineMethod() != RefineMethod.NOT_REFINED) {
    logger.warn(""String_Node_Str"");
    CeSymmIterative iterative=new CeSymmIterative(params.clone());
    msa=iterative.execute(atoms);
    axes=iterative.getSymmetryAxes();
    if (SymmetryTools.isRefined(msa)) {
      refined=true;
    }
 else {
      afpChain=align(atoms,atoms,params);
      msa=null;
    }
  }
 else {
    afpChain=align(atoms,atoms,params);
  }
  if (refined) {
    if (msa == null)     msa=SymmetryTools.fromAFP(afpChain,ca1);
    CoreSuperimposer imposer=new CoreSuperimposer();
    imposer.superimpose(msa);
    MultipleAlignmentScorer.calculateScores(msa);
    msa.putScore(""String_Node_Str"",1.0);
    if (this.params.getOptimization()) {
      try {
        SymmOptimizer optimizer=new SymmOptimizer(msa,axes,params,params.getSeed());
        msa=optimizer.optimize();
        msa.putScore(""String_Node_Str"",1.0);
      }
 catch (      RefinerFailedException e) {
        logger.warn(""String_Node_Str"",e);
      }
    }
  }
 else {
    MultipleAlignmentEnsemble e=new MultipleAlignmentEnsembleImpl(afpChain,ca1,ca1,false);
    msa=e.getMultipleAlignment(0);
    logger.warn(""String_Node_Str"");
    msa.putScore(""String_Node_Str"",0.0);
  }
  return msa;
}",0.9711505039972194
16643,"public static void main(String[] args) throws IOException, StructureException {
  String name=""String_Node_Str"";
  List<Atom[]> atoms=new ArrayList<Atom[]>();
  AtomCache cache=new AtomCache();
  Atom[] ca=cache.getAtoms(name);
  atoms.add(ca);
  CeSymm ceSymm=new CeSymm();
  CESymmParameters params=(CESymmParameters)ceSymm.getParameters();
  params.setRefineMethod(RefineMethod.SINGLE);
  params.setSymmetryType(SymmetryType.AUTO);
  params.setOptimization(true);
  params.setMultipleAxes(true);
  MultipleAlignment symmetry=ceSymm.align(atoms);
  System.out.println(MultipleAlignmentWriter.toFatCat(symmetry));
}","public static void main(String[] args) throws IOException, StructureException {
  String name=""String_Node_Str"";
  List<Atom[]> atoms=new ArrayList<Atom[]>();
  AtomCache cache=new AtomCache();
  Structure s=cache.getStructure(name);
  Atom[] array=StructureTools.getRepresentativeAtomArray(s);
  atoms.add(array);
  CeSymm ceSymm=new CeSymm();
  CESymmParameters params=(CESymmParameters)ceSymm.getParameters();
  params.setRefineMethod(RefineMethod.SINGLE);
  params.setSymmetryType(SymmetryType.AUTO);
  params.setOptimization(true);
  params.setMultipleAxes(true);
  MultipleAlignment symmetry=ceSymm.align(atoms);
  System.out.println(MultipleAlignmentWriter.toFatCat(symmetry));
}",0.9093701996927804
16644,"public static void main(String[] args) throws IOException, StructureException, InterruptedException, ExecutionException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AtomCache cache=new AtomCache();
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  for (  String name : names) {
    atomArrays.add(cache.getAtoms(name));
  }
  MultipleMcMain algorithm=new MultipleMcMain(new CeCPMain());
  MultipleMcParameters params=(MultipleMcParameters)algorithm.getParameters();
  params.setMinBlockLen(10);
  MultipleAlignment result=algorithm.align(atomArrays);
  result.getEnsemble().setStructureNames(names);
  result.getEnsemble().setAlgorithmName(algorithm.getAlgorithmName());
  result.getEnsemble().setVersion(algorithm.getVersion());
  MultipleAlignmentDisplay.display(result);
}","public static void main(String[] args) throws IOException, StructureException, InterruptedException, ExecutionException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AtomCache cache=new AtomCache();
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  for (  String name : names) {
    atomArrays.add(cache.getAtoms(name));
  }
  StructureAlignment pairwise=new FatCatFlexible();
  MultipleMcMain algorithm=new MultipleMcMain(pairwise);
  MultipleMcParameters params=(MultipleMcParameters)algorithm.getParameters();
  params.setMinBlockLen(10);
  params.setGapExtension(20.0);
  MultipleAlignment result=algorithm.align(atomArrays);
  result.getEnsemble().setStructureNames(names);
  result.getEnsemble().setAlgorithmName(algorithm.getAlgorithmName());
  result.getEnsemble().setVersion(algorithm.getVersion());
  MultipleAlignmentDisplay.display(result);
}",0.9005649717514125
16645,"public static void main(String[] args) throws IOException, StructureException, InterruptedException, ExecutionException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AtomCache cache=new AtomCache();
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  for (  String name : names) {
    atomArrays.add(cache.getAtoms(name));
  }
  MultipleMcMain algorithm=new MultipleMcMain(new CeCPMain());
  MultipleMcParameters params=(MultipleMcParameters)algorithm.getParameters();
  params.setMinBlockLen(15);
  params.setMinAlignedStructures(10);
  MultipleAlignment result=algorithm.align(atomArrays);
  result.getEnsemble().setStructureNames(names);
  result.getEnsemble().setAlgorithmName(algorithm.getAlgorithmName());
  result.getEnsemble().setVersion(algorithm.getVersion());
  System.out.println(MultipleAlignmentWriter.toFatCat(result));
  System.out.println(MultipleAlignmentWriter.toTransformMatrices(result));
  System.out.println(MultipleAlignmentWriter.toXML(result.getEnsemble()));
}","public static void main(String[] args) throws IOException, StructureException, InterruptedException, ExecutionException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AtomCache cache=new AtomCache();
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  for (  String name : names) {
    atomArrays.add(cache.getAtoms(name));
  }
  MultipleMcMain algorithm=new MultipleMcMain(new CeMain());
  MultipleMcParameters params=(MultipleMcParameters)algorithm.getParameters();
  params.setMinBlockLen(15);
  params.setMinAlignedStructures(10);
  MultipleAlignment result=algorithm.align(atomArrays);
  result.getEnsemble().setStructureNames(names);
  result.getEnsemble().setAlgorithmName(algorithm.getAlgorithmName());
  result.getEnsemble().setVersion(algorithm.getVersion());
  System.out.println(MultipleAlignmentWriter.toFatCat(result));
  System.out.println(MultipleAlignmentWriter.toTransformMatrices(result));
  System.out.println(MultipleAlignmentWriter.toXML(result.getEnsemble()));
}",0.9660238751147842
16646,"/** 
 * This method takes a list of pairwise alignments to the reference  structure and calculates a MultipleAlignment resulting from combining  their residue equivalencies. <p> It uses the blocks in AFPChain as   {@link Block}s in the  MultipleAlignment, so considers non-topological alignments, if the alignment is rigid. If the alignment is flexible,  it considers the blocks as   {@link BlockSets}.
 * @param afpList the list of pairwise alignments to the reference
 * @param atomArrays List of Atoms of the structures
 * @param ref index of the reference structure
 * @param flexible uses BlockSets if true, uses Blocks otherwise
 * @return MultipleAlignment seed alignment
 * @throws StructureException 
 */
private static MultipleAlignment combineReferenceAlignments(List<AFPChain> afpList,List<Atom[]> atomArrays,int ref,boolean flexible) throws StructureException {
  int size=atomArrays.size();
  int length=0;
  if (ref == 0)   length=afpList.get(1).getCa1Length();
 else   length=afpList.get(0).getCa2Length();
  SortedSet<Integer> flexibleBoundaries=new TreeSet<Integer>();
  List<List<Integer>> equivalencies=new ArrayList<List<Integer>>();
  for (int str=0; str < size; str++) {
    equivalencies.add(new ArrayList<Integer>());
    for (int res=0; res < length; res++) {
      if (str == ref)       equivalencies.get(str).add(res);
 else       equivalencies.get(str).add(null);
    }
  }
  for (int str=0; str < size; str++) {
    if (str == ref)     continue;
    for (int bk=0; bk < afpList.get(str).getBlockNum(); bk++) {
      for (int i=0; i < afpList.get(str).getOptLen()[bk]; i++) {
        int res1=0;
        int res2=0;
        if (str > ref) {
          res1=afpList.get(str).getOptAln()[bk][0][i];
          res2=afpList.get(str).getOptAln()[bk][1][i];
        }
 else         if (str < ref) {
          res1=afpList.get(str).getOptAln()[bk][1][i];
          res2=afpList.get(str).getOptAln()[bk][0][i];
        }
        equivalencies.get(str).set(res1,res2);
        if (flexible && i == 0)         flexibleBoundaries.add(res1);
      }
    }
  }
  MultipleAlignment seed=new MultipleAlignmentImpl();
  seed.getEnsemble().setAtomArrays(atomArrays);
  BlockSet blockSet=new BlockSetImpl(seed);
  new BlockImpl(blockSet);
  int[] lastResidues=new int[size];
  Arrays.fill(lastResidues,-1);
  for (int pos=0; pos < length; pos++) {
    if (flexibleBoundaries.contains(pos) && blockSet.getBlocks().get(blockSet.getBlocks().size() - 1).getAlignRes() != null) {
      blockSet=new BlockSetImpl(seed);
      new BlockImpl(blockSet);
    }
    boolean cp=false;
    for (int str=0; str < size; str++) {
      if (equivalencies.get(str).get(pos) == null) {
        continue;
      }
 else       if (equivalencies.get(str).get(pos) < lastResidues[str]) {
        cp=true;
        break;
      }
 else       lastResidues[str]=equivalencies.get(str).get(pos);
    }
    if (cp) {
      new BlockImpl(blockSet);
      Arrays.fill(lastResidues,-1);
    }
    for (int str=0; str < size; str++) {
      Block lastB=blockSet.getBlocks().get(blockSet.getBlocks().size() - 1);
      if (lastB.getAlignRes() == null) {
        List<List<Integer>> alnRes=new ArrayList<List<Integer>>(size);
        for (int k=0; k < size; k++) {
          alnRes.add(new ArrayList<Integer>());
        }
        lastB.setAlignRes(alnRes);
      }
      lastB.getAlignRes().get(str).add(equivalencies.get(str).get(pos));
    }
  }
  MultipleSuperimposer imposer=new ReferenceSuperimposer(ref);
  imposer.superimpose(seed);
  return seed;
}","/** 
 * This method takes a list of pairwise alignments to the reference  structure and calculates a MultipleAlignment resulting from combining  their residue equivalencies. <p> It uses the blocks in AFPChain as   {@link Block}s in the  MultipleAlignment, so considers non-topological alignments, if the alignment is rigid. If the alignment is flexible,  it considers the blocks as   {@link BlockSets}.
 * @param afpList the list of pairwise alignments to the reference
 * @param atomArrays List of Atoms of the structures
 * @param ref index of the reference structure
 * @param flexible uses BlockSets if true, uses Blocks otherwise
 * @return MultipleAlignment seed alignment
 * @throws StructureException 
 */
private static MultipleAlignment combineReferenceAlignments(List<AFPChain> afpList,List<Atom[]> atomArrays,int ref,boolean flexible) throws StructureException {
  int size=atomArrays.size();
  int length=0;
  if (ref == 0)   length=afpList.get(1).getCa1Length();
 else   length=afpList.get(0).getCa2Length();
  SortedSet<Integer> flexibleBoundaries=new TreeSet<Integer>();
  List<List<Integer>> equivalencies=new ArrayList<List<Integer>>();
  for (int str=0; str < size; str++) {
    equivalencies.add(new ArrayList<Integer>());
    for (int res=0; res < length; res++) {
      if (str == ref)       equivalencies.get(str).add(res);
 else       equivalencies.get(str).add(null);
    }
  }
  for (int str=0; str < size; str++) {
    if (str == ref)     continue;
    for (int bk=0; bk < afpList.get(str).getBlockNum(); bk++) {
      for (int i=0; i < afpList.get(str).getOptLen()[bk]; i++) {
        int res1=0;
        int res2=0;
        if (str > ref) {
          res1=afpList.get(str).getOptAln()[bk][0][i];
          res2=afpList.get(str).getOptAln()[bk][1][i];
        }
 else         if (str < ref) {
          res1=afpList.get(str).getOptAln()[bk][1][i];
          res2=afpList.get(str).getOptAln()[bk][0][i];
        }
        equivalencies.get(str).set(res1,res2);
        if (flexible && i == 0)         flexibleBoundaries.add(res1);
      }
    }
  }
  MultipleAlignment seed=new MultipleAlignmentImpl();
  seed.getEnsemble().setAtomArrays(atomArrays);
  BlockSet blockSet=new BlockSetImpl(seed);
  new BlockImpl(blockSet);
  int[] lastResidues=new int[size];
  Arrays.fill(lastResidues,-1);
  for (int pos=0; pos < length; pos++) {
    if (flexibleBoundaries.contains(pos) && blockSet.getBlocks().get(blockSet.getBlocks().size() - 1).getAlignRes() != null) {
      blockSet=new BlockSetImpl(seed);
      new BlockImpl(blockSet);
    }
    boolean cp=false;
    for (int str=0; str < size; str++) {
      if (equivalencies.get(str).get(pos) == null) {
        continue;
      }
 else       if (equivalencies.get(str).get(pos) < lastResidues[str]) {
        cp=true;
        break;
      }
 else       lastResidues[str]=equivalencies.get(str).get(pos);
    }
    if (cp) {
      new BlockImpl(blockSet);
      Arrays.fill(lastResidues,-1);
    }
    for (int str=0; str < size; str++) {
      Block lastB=blockSet.getBlocks().get(blockSet.getBlocks().size() - 1);
      if (lastB.getAlignRes() == null) {
        List<List<Integer>> alnRes=new ArrayList<List<Integer>>(size);
        for (int k=0; k < size; k++) {
          alnRes.add(new ArrayList<Integer>());
        }
        lastB.setAlignRes(alnRes);
      }
      lastB.getAlignRes().get(str).add(equivalencies.get(str).get(pos));
    }
  }
  return seed;
}",0.9847919655667144
16647,"@Override public void reset(){
  randomSeed=0;
  minBlockLen=10;
  minAlignedStructures=0;
  gapOpen=10.0;
  gapExtension=5.0;
  convergenceSteps=0;
  nrThreads=4;
}","@Override public void reset(){
  randomSeed=0;
  minBlockLen=10;
  minAlignedStructures=0;
  gapOpen=20.0;
  gapExtension=15.0;
  convergenceSteps=0;
  nrThreads=4;
}",0.9909365558912386
16648,"private void initResSerialsMap(Chain c){
  if (c.getSeqResGroups() == null || c.getSeqResGroups().isEmpty()) {
    logger.warn(""String_Node_Str"" + ""String_Node_Str"",c.getChainID());
    chains2pdbResNums2ResSerials.put(c.getChainID(),null);
    return;
  }
  Map<ResidueNumber,Integer> resNums2ResSerials=new HashMap<ResidueNumber,Integer>();
  chains2pdbResNums2ResSerials.put(c.getChainID(),resNums2ResSerials);
  for (int i=0; i < c.getSeqResGroups().size(); i++) {
    resNums2ResSerials.put(c.getSeqResGroup(i).getResidueNumber(),i + 1);
  }
}","private void initResSerialsMap(Chain c){
  if (c.getSeqResGroups() == null || c.getSeqResGroups().isEmpty()) {
    logger.warn(""String_Node_Str"" + ""String_Node_Str"",c.getChainID());
    chains2pdbResNums2ResSerials.put(c.getChainID(),null);
    return;
  }
  Map<ResidueNumber,Integer> resNums2ResSerials=new HashMap<ResidueNumber,Integer>();
  chains2pdbResNums2ResSerials.put(c.getChainID(),resNums2ResSerials);
  for (int i=0; i < c.getSeqResGroups().size(); i++) {
    ResidueNumber resNum=c.getSeqResGroup(i).getResidueNumber();
    if (resNum == null) {
      resNum=findResNumInOtherChains(i,c);
    }
    resNums2ResSerials.put(resNum,i + 1);
  }
}",0.8471760797342193
16649,"/** 
 * Given a Group g of Chain c (member of this Compound) return the corresponding position in the  alignment of all member sequences (1-based numbering), i.e. the index (1-based) in the SEQRES sequence. This allows for comparisons of residues belonging to different chains of the same Compound (entity). <p> If   {@link FileParsingParameters#setAlignSeqRes(boolean)} is not used or SEQRES not present, a mapping will not be available and this method will return  {@link ResidueNumber#getSeqNum()} for all residues, whichin some cases will be correctly aligned indices (when no insertion codes are  used and when all chains within the entity are numbered in the same way), but in general they will be neither unique (because of insertion codes) nor aligned. </p>
 * @param g
 * @param c
 * @return the aligned residue index (1 to n), if no SEQRES groups are available at all then {@link ResidueNumber#getSeqNum()} is returned as a fall-back, if the group is not found in the SEQRES groups then -1 is returned  for the given group and chain
 * @throws IllegalArgumentException if the given Chain is not a member of this Compound
 * @see {@link Chain#getSeqResGroup(int)} 
 */
public int getAlignedResIndex(Group g,Chain c){
  boolean contained=false;
  for (  Chain member : getChains()) {
    if (c.getChainID().equals(member.getChainID())) {
      contained=true;
      break;
    }
  }
  if (!contained)   throw new IllegalArgumentException(""String_Node_Str"" + c.getChainID() + ""String_Node_Str""+ getChainIds().toString());
  if (!chains2pdbResNums2ResSerials.containsKey(c.getChainID())) {
    initResSerialsMap(c);
  }
  Map<ResidueNumber,Integer> map=chains2pdbResNums2ResSerials.get(c.getChainID());
  int serial;
  if (map != null) {
    Integer alignedSerial=map.get(g.getResidueNumber());
    if (alignedSerial == null) {
      serial=-1;
    }
 else {
      serial=alignedSerial;
    }
  }
 else {
    serial=g.getResidueNumber().getSeqNum();
  }
  return serial;
}","/** 
 * Given a Group g of Chain c (member of this Compound) return the corresponding position in the  alignment of all member sequences (1-based numbering), i.e. the index (1-based) in the SEQRES sequence. This allows for comparisons of residues belonging to different chains of the same Compound (entity). <p> If   {@link FileParsingParameters#setAlignSeqRes(boolean)} is not used or SEQRES not present, a mapping will not be available and this method will return  {@link ResidueNumber#getSeqNum()} for all residues, whichin some cases will be correctly aligned indices (when no insertion codes are  used and when all chains within the entity are numbered in the same way), but in general they will be neither unique (because of insertion codes) nor aligned. </p>
 * @param g
 * @param c
 * @return the aligned residue index (1 to n), if no SEQRES groups are available at all then {@link ResidueNumber#getSeqNum()} is returned as a fall-back, if the group is not found in the SEQRES groups then -1 is returned  for the given group and chain
 * @throws IllegalArgumentException if the given Chain is not a member of this Compound
 * @see {@link Chain#getSeqResGroup(int)} 
 */
public int getAlignedResIndex(Group g,Chain c){
  boolean contained=false;
  for (  Chain member : getChains()) {
    if (c.getChainID().equals(member.getChainID())) {
      contained=true;
      break;
    }
  }
  if (!contained)   throw new IllegalArgumentException(""String_Node_Str"" + c.getChainID() + ""String_Node_Str""+ getChainIds().toString());
  if (!chains2pdbResNums2ResSerials.containsKey(c.getChainID())) {
    initResSerialsMap(c);
  }
  Map<ResidueNumber,Integer> map=chains2pdbResNums2ResSerials.get(c.getChainID());
  int serial;
  if (map != null) {
    ResidueNumber resNum=g.getResidueNumber();
    if (resNum == null && c.getSeqResGroups() != null && !c.getSeqResGroups().isEmpty()) {
      int index=-1;
      for (int i=0; i < c.getSeqResGroups().size(); i++) {
        if (g == c.getSeqResGroup(i)) {
          index=i;
          break;
        }
      }
      resNum=findResNumInOtherChains(index,c);
    }
    if (resNum == null) {
      serial=-1;
    }
 else {
      Integer alignedSerial=map.get(resNum);
      if (alignedSerial == null) {
        serial=-1;
      }
 else {
        serial=alignedSerial;
      }
    }
  }
 else {
    serial=g.getResidueNumber().getSeqNum();
  }
  return serial;
}",0.8724035608308606
16650,"public void resetDisplay(){
  if (multAln != null) {
    String script=getJmolString(multAln,transformedAtoms,colorPalette,colorByBlocks.isSelected());
    evalString(script);
    jmolPanel.evalString(""String_Node_Str"");
  }
}","public void resetDisplay(){
  if (multAln != null && transformedAtoms != null) {
    String script=getJmolString(multAln,transformedAtoms,colorPalette,colorByBlocks.isSelected());
    evalString(script);
    jmolPanel.evalString(""String_Node_Str"");
  }
}",0.9416666666666668
16651,"/** 
 * The constructor displays the Mutltiple Alignment  in a new JmolPanel Frame.
 * @param msa: contains the aligned residues.
 * @param rotatedAtoms: contains the transformed Atom coordinates. 
 */
public MultipleAlignmentJmol(MultipleAlignment msa,List<Atom[]> rotatedAtoms){
  AligUIManager.setLookAndFeel();
  nrOpenWindows++;
  jmolPanel=new JmolPanel();
  frame=new JFrame();
  JMenuBar menu=MenuCreator.initJmolMenu(frame,this,null,msa);
  frame.setJMenuBar(menu);
  this.multAln=msa;
  this.transformedAtoms=rotatedAtoms;
  this.selectedStructures=new ArrayList<JCheckBox>();
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      nrOpenWindows--;
      destroy();
      if (nrOpenWindows > 0)       frame.dispose();
 else {
        MultipleAlignmentGUI gui=MultipleAlignmentGUI.getInstanceNoVisibilityChange();
        if (gui.isVisible()) {
          frame.dispose();
          gui.requestFocus();
        }
 else         System.exit(0);
      }
    }
  }
);
  Container contentPane=frame.getContentPane();
  Box vBox=Box.createVerticalBox();
  jmolPanel.addMouseMotionListener(this);
  jmolPanel.addMouseListener(this);
  jmolPanel.setPreferredSize(new Dimension(DEFAULT_WIDTH,DEFAULT_HEIGHT));
  vBox.add(jmolPanel);
  JTextField field=new JTextField();
  field.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  field.setText(COMMAND_LINE_HELP);
  RasmolCommandListener listener=new RasmolCommandListener(jmolPanel,field);
  field.addActionListener(listener);
  field.addMouseListener(listener);
  field.addKeyListener(listener);
  vBox.add(field);
  Box hBox0=Box.createHorizontalBox();
  hBox0.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  JButton show=new JButton(""String_Node_Str"");
  show.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      jmolPanel.evalString(""String_Node_Str"");
      String cmd=getJmolString(multAln,transformedAtoms,colorPalette,colorByBlocks.isSelected());
      cmd+=""String_Node_Str"";
      for (int st=0; st < multAln.size(); st++) {
        if (selectedStructures.get(st).isSelected()) {
          cmd+=""String_Node_Str"" + (st + 1) + ""String_Node_Str"";
        }
      }
      cmd+=""String_Node_Str"";
      jmolPanel.executeCmd(cmd + ""String_Node_Str"");
    }
  }
);
  hBox0.add(show);
  hBox0.add(Box.createGlue());
  for (int str=0; str < multAln.size(); str++) {
    JCheckBox structureSelection=new JCheckBox(multAln.getEnsemble().getStructureNames().get(str));
    hBox0.add(structureSelection);
    hBox0.add(Box.createGlue());
    structureSelection.setSelected(true);
    selectedStructures.add(structureSelection);
  }
  vBox.add(hBox0);
  Box hBox1=Box.createHorizontalBox();
  hBox1.add(Box.createGlue());
  String[] styles=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox style=new JComboBox(styles);
  hBox1.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(style);
  vBox.add(hBox1);
  contentPane.add(vBox);
  style.addActionListener(jmolPanel);
  String[] colorModes=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox jcolors=new JComboBox(colorModes);
  jcolors.addActionListener(jmolPanel);
  hBox1.add(Box.createGlue());
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(jcolors);
  String[] cPalette={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox palette=new JComboBox(cPalette);
  palette.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      JComboBox source=(JComboBox)e.getSource();
      String value=source.getSelectedItem().toString();
      evalString(""String_Node_Str"" + ""String_Node_Str"");
      if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Set1;
      }
 else       if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Set2;
      }
 else       if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Spectral;
      }
 else       if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Pastel1;
      }
      String script=getJmolString(multAln,transformedAtoms,colorPalette,colorByBlocks.isSelected());
      evalString(script + ""String_Node_Str"");
    }
  }
);
  hBox1.add(Box.createGlue());
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(palette);
  Box hBox2=Box.createHorizontalBox();
  hBox2.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  JButton resetDisplay=new JButton(""String_Node_Str"");
  resetDisplay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      System.out.println(""String_Node_Str"");
      jmolPanel.executeCmd(""String_Node_Str"");
    }
  }
);
  hBox2.add(resetDisplay);
  hBox2.add(Box.createGlue());
  JCheckBox toggleSelection=new JCheckBox(""String_Node_Str"");
  toggleSelection.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      boolean showSelection=(e.getStateChange() == ItemEvent.SELECTED);
      if (showSelection) {
        jmolPanel.executeCmd(""String_Node_Str"");
      }
 else       jmolPanel.executeCmd(""String_Node_Str"");
    }
  }
);
  hBox2.add(toggleSelection);
  hBox2.add(Box.createGlue());
  colorByBlocks=new JCheckBox(""String_Node_Str"");
  colorByBlocks.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      evalString(""String_Node_Str"" + getJmolString(multAln,transformedAtoms,colorPalette,colorByBlocks.isSelected()) + ""String_Node_Str"");
    }
  }
);
  hBox2.add(colorByBlocks);
  hBox2.add(Box.createGlue());
  vBox.add(hBox2);
  Box hBox=Box.createHorizontalBox();
  status=new JTextField();
  status.setBackground(Color.white);
  status.setEditable(false);
  status.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  status.setPreferredSize(new Dimension(DEFAULT_WIDTH / 2,30));
  status.setMinimumSize(new Dimension(DEFAULT_WIDTH / 2,30));
  hBox.add(status);
  text=new JTextField();
  text.setBackground(Color.white);
  text.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  text.setPreferredSize(new Dimension(DEFAULT_WIDTH / 2,30));
  text.setMinimumSize(new Dimension(DEFAULT_WIDTH / 2,30));
  text.setText(""String_Node_Str"");
  text.setEditable(false);
  hBox.add(text);
  vBox.add(hBox);
  contentPane.add(vBox);
  MyJmolStatusListener li=(MyJmolStatusListener)jmolPanel.getStatusListener();
  li.setTextField(status);
  frame.pack();
  frame.setVisible(true);
  initCoords();
  resetDisplay();
}","/** 
 * The constructor displays the Mutltiple Alignment  in a new JmolPanel Frame.
 * @param msa: contains the aligned residues.
 * @param rotatedAtoms: contains the transformed Atom coordinates. 
 */
public MultipleAlignmentJmol(MultipleAlignment msa,List<Atom[]> rotatedAtoms){
  AligUIManager.setLookAndFeel();
  nrOpenWindows++;
  jmolPanel=new JmolPanel();
  frame=new JFrame();
  JMenuBar menu=MenuCreator.initJmolMenu(frame,this,null,msa);
  frame.setJMenuBar(menu);
  this.multAln=msa;
  this.transformedAtoms=rotatedAtoms;
  this.selectedStructures=new ArrayList<JCheckBox>();
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      nrOpenWindows--;
      destroy();
      if (nrOpenWindows > 0)       frame.dispose();
 else {
        MultipleAlignmentGUI gui=MultipleAlignmentGUI.getInstanceNoVisibilityChange();
        if (gui.isVisible()) {
          frame.dispose();
          gui.requestFocus();
        }
 else         System.exit(0);
      }
    }
  }
);
  Container contentPane=frame.getContentPane();
  Box vBox=Box.createVerticalBox();
  jmolPanel.addMouseMotionListener(this);
  jmolPanel.addMouseListener(this);
  jmolPanel.setPreferredSize(new Dimension(DEFAULT_WIDTH,DEFAULT_HEIGHT));
  vBox.add(jmolPanel);
  JTextField field=new JTextField();
  field.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  field.setText(COMMAND_LINE_HELP);
  RasmolCommandListener listener=new RasmolCommandListener(jmolPanel,field);
  field.addActionListener(listener);
  field.addMouseListener(listener);
  field.addKeyListener(listener);
  vBox.add(field);
  if (multAln != null) {
    Box hBox0=Box.createHorizontalBox();
    hBox0.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
    JButton show=new JButton(""String_Node_Str"");
    show.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        jmolPanel.evalString(""String_Node_Str"");
        String cmd=getJmolString(multAln,transformedAtoms,colorPalette,colorByBlocks.isSelected());
        cmd+=""String_Node_Str"";
        for (int st=0; st < multAln.size(); st++) {
          if (selectedStructures.get(st).isSelected()) {
            cmd+=""String_Node_Str"" + (st + 1) + ""String_Node_Str"";
          }
        }
        cmd+=""String_Node_Str"";
        jmolPanel.executeCmd(cmd + ""String_Node_Str"");
      }
    }
);
    hBox0.add(show);
    hBox0.add(Box.createGlue());
    for (int str=0; str < multAln.size(); str++) {
      JCheckBox structureSelection=new JCheckBox(multAln.getEnsemble().getStructureNames().get(str));
      hBox0.add(structureSelection);
      hBox0.add(Box.createGlue());
      structureSelection.setSelected(true);
      selectedStructures.add(structureSelection);
    }
    vBox.add(hBox0);
  }
  Box hBox1=Box.createHorizontalBox();
  hBox1.add(Box.createGlue());
  String[] styles=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox style=new JComboBox(styles);
  hBox1.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(style);
  vBox.add(hBox1);
  contentPane.add(vBox);
  style.addActionListener(jmolPanel);
  String[] colorModes=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox jcolors=new JComboBox(colorModes);
  jcolors.addActionListener(jmolPanel);
  hBox1.add(Box.createGlue());
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(jcolors);
  String[] cPalette={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox palette=new JComboBox(cPalette);
  palette.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      JComboBox source=(JComboBox)e.getSource();
      String value=source.getSelectedItem().toString();
      evalString(""String_Node_Str"" + ""String_Node_Str"");
      if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Set1;
      }
 else       if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Set2;
      }
 else       if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Spectral;
      }
 else       if (value == ""String_Node_Str"") {
        colorPalette=ColorBrewer.Pastel1;
      }
      String script=getJmolString(multAln,transformedAtoms,colorPalette,colorByBlocks.isSelected());
      evalString(script + ""String_Node_Str"");
    }
  }
);
  hBox1.add(Box.createGlue());
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(palette);
  Box hBox2=Box.createHorizontalBox();
  hBox2.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  JButton resetDisplay=new JButton(""String_Node_Str"");
  resetDisplay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      System.out.println(""String_Node_Str"");
      jmolPanel.executeCmd(""String_Node_Str"");
    }
  }
);
  hBox2.add(resetDisplay);
  hBox2.add(Box.createGlue());
  JCheckBox toggleSelection=new JCheckBox(""String_Node_Str"");
  toggleSelection.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      boolean showSelection=(e.getStateChange() == ItemEvent.SELECTED);
      if (showSelection) {
        jmolPanel.executeCmd(""String_Node_Str"");
      }
 else       jmolPanel.executeCmd(""String_Node_Str"");
    }
  }
);
  hBox2.add(toggleSelection);
  hBox2.add(Box.createGlue());
  colorByBlocks=new JCheckBox(""String_Node_Str"");
  colorByBlocks.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      evalString(""String_Node_Str"" + getJmolString(multAln,transformedAtoms,colorPalette,colorByBlocks.isSelected()) + ""String_Node_Str"");
    }
  }
);
  hBox2.add(colorByBlocks);
  hBox2.add(Box.createGlue());
  vBox.add(hBox2);
  Box hBox=Box.createHorizontalBox();
  status=new JTextField();
  status.setBackground(Color.white);
  status.setEditable(false);
  status.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  status.setPreferredSize(new Dimension(DEFAULT_WIDTH / 2,30));
  status.setMinimumSize(new Dimension(DEFAULT_WIDTH / 2,30));
  hBox.add(status);
  text=new JTextField();
  text.setBackground(Color.white);
  text.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  text.setPreferredSize(new Dimension(DEFAULT_WIDTH / 2,30));
  text.setMinimumSize(new Dimension(DEFAULT_WIDTH / 2,30));
  text.setText(""String_Node_Str"");
  text.setEditable(false);
  hBox.add(text);
  vBox.add(hBox);
  contentPane.add(vBox);
  MyJmolStatusListener li=(MyJmolStatusListener)jmolPanel.getStatusListener();
  li.setTextField(status);
  frame.pack();
  frame.setVisible(true);
  initCoords();
  resetDisplay();
}",0.9810904274887794
16652,"/** 
 * Convert JAMA rotation and translation to a Vecmath transformation matrix
 * @param rot 3x3 Rotation matrix
 * @param trans 3x1 Translation matrix
 * @return 4x4 transformation matrix
 */
public static Matrix4d getTransformation(Matrix rot,Atom trans){
  return new Matrix4d(new Matrix3d(rot.getColumnPackedCopy()),new Vector3d(trans.getCoords()),1.0);
}","/** 
 * Convert JAMA rotation and translation to a Vecmath transformation matrix
 * @param rot 3x3 Rotation matrix
 * @param trans 3x1 Translation matrix
 * @return 4x4 transformation matrix
 */
public static Matrix4d getTransformation(Matrix rot,Atom trans){
  return new Matrix4d(new Matrix3d(rot.getRowPackedCopy()),new Vector3d(trans.getCoords()),1.0);
}",0.9874826147426982
16653,"@Test public void testAFPconversion() throws Exception {
  AFPChain afp=new AFPChain();
  afp.setName1(""String_Node_Str"");
  afp.setName2(""String_Node_Str"");
  afp.setAlgorithmName(""String_Node_Str"");
  afp.setVersion(""String_Node_Str"");
  afp.setCalculationTime(System.currentTimeMillis());
  int[][][] optAln=new int[3][][];
  for (int b=0; b < optAln.length; b++) {
    int[][] block=new int[2][];
    for (int c=0; c < block.length; c++) {
      int[] residues={b + 5,b + 6,b + 7,b + 8,b + 9};
      block[c]=residues;
    }
    optAln[b]=block;
  }
  afp.setOptAln(optAln);
  afp.setBlockNum(optAln.length);
  Matrix rot=Matrix.identity(3,3);
  Atom shift=new AtomImpl();
  shift.setX(0);
  shift.setY(0);
  shift.setZ(0);
  Matrix[] blockRot={rot,rot,rot};
  afp.setBlockRotationMatrix(blockRot);
  Atom[] blockShift={shift,shift,shift};
  afp.setBlockShiftVector(blockShift);
  MultipleAlignmentEnsemble ensemble=new MultipleAlignmentEnsembleImpl(afp,null,null,true);
  MultipleAlignment msa=ensemble.getMultipleAlignments().get(0);
  assertEquals(afp.getName1(),ensemble.getStructureNames().get(0));
  assertEquals(afp.getName2(),ensemble.getStructureNames().get(1));
  assertEquals(afp.getAlgorithmName(),ensemble.getAlgorithmName());
  assertEquals(afp.getVersion(),ensemble.getVersion());
  assertTrue(ensemble.getCalculationTime().equals(afp.getCalculationTime()));
  assertEquals(afp.getBlockNum(),msa.getBlockSets().size());
  assertEquals(Calc.getTransformation(afp.getBlockRotationMatrix()[0],afp.getBlockShiftVector()[0]),msa.getTransformations().get(1));
  assertEquals(msa.getScore(MultipleAlignmentScorer.CE_SCORE),(Double)afp.getAlignScore());
  assertEquals(msa.getScore(MultipleAlignmentScorer.AVGTM_SCORE),(Double)afp.getTMScore());
  assertEquals(msa.getScore(MultipleAlignmentScorer.RMSD),(Double)afp.getTotalRmsdOpt());
  for (int b=0; b < 3; b++) {
    for (int c=0; c < 2; c++) {
      for (int res=0; res < 5; res++) {
        Integer afpRes=afp.getOptAln()[b][c][res];
        assertEquals(afpRes,msa.getBlocks().get(b).getAlignRes().get(c).get(res));
      }
    }
  }
}","@Test public void testAFPconversion() throws Exception {
  AFPChain afp=new AFPChain();
  afp.setName1(""String_Node_Str"");
  afp.setName2(""String_Node_Str"");
  afp.setAlgorithmName(""String_Node_Str"");
  afp.setVersion(""String_Node_Str"");
  afp.setCalculationTime(System.currentTimeMillis());
  int[][][] optAln=new int[3][][];
  for (int b=0; b < optAln.length; b++) {
    int[][] block=new int[2][];
    for (int c=0; c < block.length; c++) {
      int[] residues={b + 5,b + 6,b + 7,b + 8,b + 9};
      block[c]=residues;
    }
    optAln[b]=block;
  }
  afp.setOptAln(optAln);
  afp.setBlockNum(optAln.length);
  double[][] mat={{0.13,1.5,0.84},{1.3,0.44,2.3},{1.0,1.2,2.03}};
  Matrix rot=new Matrix(mat);
  Atom shift=new AtomImpl();
  shift.setX(0.44);
  shift.setY(0.21);
  shift.setZ(0.89);
  Matrix[] blockRot={rot,rot,rot};
  afp.setBlockRotationMatrix(blockRot);
  Atom[] blockShift={shift,shift,shift};
  afp.setBlockShiftVector(blockShift);
  MultipleAlignmentEnsemble ensemble=new MultipleAlignmentEnsembleImpl(afp,null,null,true);
  MultipleAlignment msa=ensemble.getMultipleAlignments().get(0);
  assertEquals(afp.getName1(),ensemble.getStructureNames().get(0));
  assertEquals(afp.getName2(),ensemble.getStructureNames().get(1));
  assertEquals(afp.getAlgorithmName(),ensemble.getAlgorithmName());
  assertEquals(afp.getVersion(),ensemble.getVersion());
  assertTrue(ensemble.getCalculationTime().equals(afp.getCalculationTime()));
  assertEquals(afp.getBlockNum(),msa.getBlockSets().size());
  assertEquals(Calc.getTransformation(afp.getBlockRotationMatrix()[0],afp.getBlockShiftVector()[0]),msa.getTransformations().get(1));
  assertEquals(msa.getScore(MultipleAlignmentScorer.CE_SCORE),(Double)afp.getAlignScore());
  assertEquals(msa.getScore(MultipleAlignmentScorer.AVGTM_SCORE),(Double)afp.getTMScore());
  assertEquals(msa.getScore(MultipleAlignmentScorer.RMSD),(Double)afp.getTotalRmsdOpt());
  for (int b=0; b < 3; b++) {
    for (int c=0; c < 2; c++) {
      for (int res=0; res < 5; res++) {
        Integer afpRes=afp.getOptAln()[b][c][res];
        assertEquals(afpRes,msa.getBlocks().get(b).getAlignRes().get(c).get(res));
      }
    }
  }
}",0.9775386055217596
16654,"public static void main(String[] args) throws IOException, StructureException, InterruptedException, ExecutionException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AtomCache cache=new AtomCache();
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  for (  String name : names) {
    atomArrays.add(cache.getAtoms(name));
  }
  CeMcMain algorithm=new CeMcMain();
  MultipleAlignment result=algorithm.align(atomArrays);
  result.getEnsemble().setStructureNames(names);
  result.getEnsemble().setAlgorithmName(algorithm.getAlgorithmName());
  result.getEnsemble().setVersion(algorithm.getVersion());
  MultipleAlignmentDisplay.display(result);
}","public static void main(String[] args) throws IOException, StructureException, InterruptedException, ExecutionException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AtomCache cache=new AtomCache();
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  for (  String name : names) {
    atomArrays.add(cache.getAtoms(name));
  }
  CeMcMain algorithm=new CeMcMain();
  MultipleAlignment result=algorithm.align(atomArrays);
  result.getEnsemble().setStructureNames(names);
  result.getEnsemble().setAlgorithmName(algorithm.getAlgorithmName());
  result.getEnsemble().setVersion(algorithm.getVersion());
  MultipleAlignmentDisplay.display(result);
}",0.9506849315068492
16655,"/** 
 * Get a collection of all scores which have been set
 * @return Set of all score names
 */
@Override public Set<String> getScores(){
  return Collections.unmodifiableSet(scores.keySet());
}","/** 
 * Get a collection of all scores which have been set
 * @return Set of all score names
 */
@Override public Set<String> getScores(){
  if (scores == null)   return Collections.emptySet();
  return Collections.unmodifiableSet(scores.keySet());
}",0.8764044943820225
16656,"/** 
 * Returns the double List containing the aligned residues for each structure. alignRes.get(structure).get(residue) = alignRes.get(size).get(length). <p> Initializes the variable if it is null.
 * @return List a double List of aligned residues for each structure.
 * @see #setAlignRes()
 */
public List<List<Integer>> getAlignRes();","/** 
 * Returns the double List containing the aligned residues for each structure. alignRes.get(structure).get(residue) = alignRes.get(size).get(length).
 * @return List a double List of aligned residues for each structure.
 * @see #setAlignRes()
 */
public List<List<Integer>> getAlignRes();",0.9301587301587302
16657,"@Override public List<List<Integer>> getAlignRes(){
  if (alignRes == null)   alignRes=new ArrayList<List<Integer>>();
  return alignRes;
}","@Override public List<List<Integer>> getAlignRes(){
  return alignRes;
}",0.6824644549763034
16658,"/** 
 * Add a new multiple alignment to the end of the ensemble and set its ensemble to this.
 * @param alignment
 */
public void addMultipleAlignment(MultipleAlignment alignment);","/** 
 * Add a new MultipleAlignment to the end of the ensemble and set its parent ensemble to this.
 * @param alignment
 */
public void addMultipleAlignment(MultipleAlignment alignment);",0.9672131147540984
16659,"/** 
 * Clear scores and distance matrix. Recursively clears member alignments.
 */
@Override public void clear(){
  super.clear();
  distanceMatrix=null;
  for (  MultipleAlignment a : getMultipleAlignments()) {
    a.clear();
  }
}","@Override public void clear(){
  super.clear();
  distanceMatrix=null;
  for (  MultipleAlignment a : getMultipleAlignments()) {
    a.clear();
  }
}",0.7801047120418848
16660,"@Override public List<Matrix> getDistanceMatrix(){
  if (distanceMatrix == null)   updateDistanceMatrix();
  return distanceMatrix;
}","@Override public List<Matrix> getDistanceMatrix(){
  return distanceMatrix;
}",0.7333333333333333
16661,"/** 
 * Add a new multiple alignment to the end of the ensemble and set its ensemble to this.
 * @param alignment
 */
@Override public void addMultipleAlignment(MultipleAlignment alignment){
  multipleAlignments.add(alignment);
  alignment.setEnsemble(this);
}","@Override public void addMultipleAlignment(MultipleAlignment alignment){
  if (multipleAlignments == null)   multipleAlignments=new ArrayList<MultipleAlignment>();
  multipleAlignments.add(alignment);
  alignment.setEnsemble(this);
}",0.5760649087221096
16662,"/** 
 * Superimpose all structures in a MultipleAlignment to the reference structure. The superposition is done for all individual BlockSets. If there is only one BlockSet, the superposition is alse set in the  MultipleAlignment as the global superposition. <p> This method only calculates and sets the transformation 4D Matrices. If any score is needed it should be calculated and set separately afterwards with   {@link MultipleAlignmentScorer}.
 * @param alignment MultipleAlignment object to superimpose.
 */
@Override public void superimpose(MultipleAlignment alignment) throws StructureException {
  if (alignment.getEnsemble() == null)   throw new NullPointerException(""String_Node_Str"");
  List<Atom[]> atomArrays=alignment.getEnsemble().getAtomArrays();
  if (alignment.getBlockSets().size() < 1)   throw new IndexOutOfBoundsException(""String_Node_Str"");
  if (atomArrays.size() <= reference) {
    throw new IndexOutOfBoundsException(String.format(""String_Node_Str"",reference,atomArrays.size()));
  }
  alignment.clear();
  for (  BlockSet bs : alignment.getBlockSets()) {
    List<Matrix4d> transforms=new ArrayList<Matrix4d>(atomArrays.size());
    for (int i=0; i < atomArrays.size(); i++) {
      if (i == reference) {
        Matrix4d ident=new Matrix4d();
        ident.setIdentity();
        transforms.add(ident);
        continue;
      }
      Atom[] ref=atomArrays.get(reference);
      Atom[] curr=atomArrays.get(i);
      List<Atom> atomSet1=new ArrayList<Atom>();
      List<Atom> atomSet2=new ArrayList<Atom>();
      for (      Block blk : bs.getBlocks()) {
        if (blk.size() != atomArrays.size()) {
          throw new IllegalStateException(String.format(""String_Node_Str"",atomArrays.size(),blk.size()));
        }
        for (int j=0; j < blk.length(); j++) {
          Integer pos1=blk.getAlignRes().get(0).get(j);
          Integer pos2=blk.getAlignRes().get(i).get(j);
          if (pos1 == null || pos2 == null)           continue;
          atomSet1.add(ref[pos1]);
          atomSet2.add(curr[pos2]);
        }
      }
      Atom[] array1=atomSet1.toArray(new Atom[atomSet1.size()]);
      Atom[] array2=atomSet2.toArray(new Atom[atomSet2.size()]);
      array2=StructureTools.cloneAtomArray(array2);
      SVDSuperimposer svd=new SVDSuperimposer(array1,array2);
      Calc.transform(array2,svd.getTransformation());
      transforms.add(svd.getTransformation());
    }
    bs.setTransformations(transforms);
  }
  if (alignment.getBlockSets().size() == 1)   alignment.setTransformations(alignment.getBlockSets().get(0).getTransformations());
}","/** 
 * Superimpose all structures in a MultipleAlignment to the reference structure. The superposition is done for all individual BlockSets. If there is only one BlockSet, the superposition is alse set in the  MultipleAlignment as the global superposition. <p> This method only calculates and sets the transformation 4D Matrices. If any score is needed it should be calculated and set separately afterwards with   {@link MultipleAlignmentScorer}.
 * @param alignment MultipleAlignment object to superimpose.
 */
@Override public void superimpose(MultipleAlignment alignment) throws StructureException {
  if (alignment.getEnsemble() == null)   throw new NullPointerException(""String_Node_Str"");
  List<Atom[]> atomArrays=alignment.getEnsemble().getAtomArrays();
  if (alignment.getBlockSets().size() < 1)   throw new IndexOutOfBoundsException(""String_Node_Str"");
  if (atomArrays.size() <= reference) {
    throw new IndexOutOfBoundsException(String.format(""String_Node_Str"",reference,atomArrays.size()));
  }
  alignment.clear();
  for (  BlockSet bs : alignment.getBlockSets()) {
    List<Matrix4d> transforms=new ArrayList<Matrix4d>(atomArrays.size());
    for (int i=0; i < atomArrays.size(); i++) {
      if (i == reference) {
        Matrix4d ident=new Matrix4d();
        ident.setIdentity();
        transforms.add(ident);
        continue;
      }
      Atom[] ref=atomArrays.get(reference);
      Atom[] curr=atomArrays.get(i);
      List<Atom> atomSet1=new ArrayList<Atom>();
      List<Atom> atomSet2=new ArrayList<Atom>();
      for (      Block blk : bs.getBlocks()) {
        if (blk.size() != atomArrays.size()) {
          throw new IllegalStateException(String.format(""String_Node_Str"",atomArrays.size(),blk.size()));
        }
        for (int j=0; j < blk.length(); j++) {
          Integer pos1=blk.getAlignRes().get(reference).get(j);
          Integer pos2=blk.getAlignRes().get(i).get(j);
          if (pos1 == null || pos2 == null)           continue;
          atomSet1.add(ref[pos1]);
          atomSet2.add(curr[pos2]);
        }
      }
      Atom[] array1=atomSet1.toArray(new Atom[atomSet1.size()]);
      Atom[] array2=atomSet2.toArray(new Atom[atomSet2.size()]);
      array2=StructureTools.cloneAtomArray(array2);
      SVDSuperimposer svd=new SVDSuperimposer(array1,array2);
      Calc.transform(array2,svd.getTransformation());
      transforms.add(svd.getTransformation());
    }
    bs.setTransformations(transforms);
  }
  if (alignment.getBlockSets().size() == 1)   alignment.setTransformations(alignment.getBlockSets().get(0).getTransformations());
}",0.9980680061823802
16663,"public static void main(String[] args) throws IOException, StructureException, InterruptedException, ExecutionException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AtomCache cache=new AtomCache();
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  for (  String name : names) {
    atomArrays.add(cache.getAtoms(name));
  }
  MultipleMcMain algorithm=new MultipleMcMain();
  MultipleMcParameters params=(MultipleMcParameters)algorithm.getParameters();
  params.setPairwiseAlgorithm(CeCPMain.algorithmName);
  MultipleAlignment result=algorithm.align(atomArrays);
  result.getEnsemble().setStructureNames(names);
  result.getEnsemble().setAlgorithmName(algorithm.getAlgorithmName());
  result.getEnsemble().setVersion(algorithm.getVersion());
  MultipleAlignmentDisplay.display(result);
}","public static void main(String[] args) throws IOException, StructureException, InterruptedException, ExecutionException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AtomCache cache=new AtomCache();
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  for (  String name : names) {
    atomArrays.add(cache.getAtoms(name));
  }
  MultipleMcMain algorithm=new MultipleMcMain();
  MultipleMcParameters params=(MultipleMcParameters)algorithm.getParameters();
  params.setPairwiseAlgorithm(CeCPMain.algorithmName);
  MultipleAlignment result=algorithm.align(atomArrays);
  result.getEnsemble().setStructureNames(names);
  result.getEnsemble().setAlgorithmName(algorithm.getAlgorithmName());
  result.getEnsemble().setVersion(algorithm.getVersion());
  MultipleAlignmentDisplay.display(result);
}",0.9694915254237289
16664,"/** 
 * Optimization method based in a Monte-Carlo approach. Starting from the refined alignment uses 4 types of moves: <p> 1- Shift Row: if there are enough freePool residues available.<p> 2- Expand Block: add another alignment column if there are residues available.<p> 3- Shrink Block: move a block column to the freePool.<p> 4- Insert gap: insert a gap in a random position of the alignment.
 */
private void optimizeMC(int maxIter) throws StructureException {
  lengthHistory=new ArrayList<Integer>();
  rmsdHistory=new ArrayList<Double>();
  scoreHistory=new ArrayList<Double>();
  int conv=0;
  int stepsToConverge=Math.max(maxIter / 50,1000);
  int i=1;
  while (i < maxIter && conv < stepsToConverge) {
    MultipleAlignment lastMSA=msa.clone();
    List<SortedSet<Integer>> lastFreePool=new ArrayList<SortedSet<Integer>>();
    for (int k=0; k < size; k++) {
      SortedSet<Integer> p=new TreeSet<Integer>();
      for (      Integer l : freePool.get(k))       p.add(l);
      lastFreePool.add(p);
    }
    double lastScore=mcScore;
    boolean moved=false;
    while (!moved) {
      double move=rnd.nextDouble();
      if (move < 0.5) {
        moved=shiftRow();
        if (debug)         System.out.println(""String_Node_Str"");
      }
 else       if (move < 0.8) {
        moved=expandBlock();
        if (debug)         System.out.println(""String_Node_Str"");
      }
 else       if (move < 0.9) {
        moved=shrinkBlock();
        if (debug)         System.out.println(""String_Node_Str"");
      }
 else {
        moved=insertGap();
        if (debug)         System.out.println(""String_Node_Str"");
      }
    }
    msa.clear();
    imposer.superimpose(msa);
    mcScore=MultipleAlignmentScorer.getMultipleMCScore(msa,Gopen,Gextend);
    double AS=mcScore - lastScore;
    double prob=1.0;
    if (AS < 0) {
      prob=probabilityFunction(AS,i,maxIter);
      double p=rnd.nextDouble();
      if (p > prob) {
        msa=lastMSA;
        freePool=lastFreePool;
        mcScore=lastScore;
        conv++;
      }
 else       conv=0;
    }
 else     conv=0;
    if (debug)     System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ prob+ ""String_Node_Str""+ AS+ ""String_Node_Str""+ conv);
    if (i % 100 == 1) {
      lengthHistory.add(msa.length());
      rmsdHistory.add(MultipleAlignmentScorer.getRMSD(msa));
      scoreHistory.add(mcScore);
    }
    i++;
  }
  imposer.superimpose(msa);
  MultipleAlignmentScorer.calculateScores(msa);
  msa.putScore(MultipleAlignmentScorer.MC_SCORE,mcScore);
}","/** 
 * Optimization method based in a Monte-Carlo approach. Starting from the refined alignment uses 4 types of moves: <p> 1- Shift Row: if there are enough freePool residues available.<p> 2- Expand Block: add another alignment column if there are residues available.<p> 3- Shrink Block: move a block column to the freePool.<p> 4- Insert gap: insert a gap in a random position of the alignment.
 */
private void optimizeMC(int maxIter) throws StructureException {
  lengthHistory=new ArrayList<Integer>();
  rmsdHistory=new ArrayList<Double>();
  scoreHistory=new ArrayList<Double>();
  int conv=0;
  int stepsToConverge=Math.max(maxIter / 50,1000);
  int i=1;
  while (i < maxIter && conv < stepsToConverge) {
    MultipleAlignment lastMSA=msa.clone();
    List<SortedSet<Integer>> lastFreePool=new ArrayList<SortedSet<Integer>>();
    for (int k=0; k < size; k++) {
      SortedSet<Integer> p=new TreeSet<Integer>();
      for (      Integer l : freePool.get(k))       p.add(l);
      lastFreePool.add(p);
    }
    double lastScore=mcScore;
    boolean moved=false;
    while (!moved) {
      double move=rnd.nextDouble();
      if (move < 0.4) {
        moved=shiftRow();
        if (debug)         System.out.println(""String_Node_Str"");
      }
 else       if (move < 0.7) {
        moved=expandBlock();
        if (debug)         System.out.println(""String_Node_Str"");
      }
 else       if (move < 0.85) {
        moved=shrinkBlock();
        if (debug)         System.out.println(""String_Node_Str"");
      }
 else {
        moved=insertGap();
        if (debug)         System.out.println(""String_Node_Str"");
      }
    }
    msa.clear();
    imposer.superimpose(msa);
    mcScore=MultipleAlignmentScorer.getMultipleMCScore(msa,Gopen,Gextend);
    double AS=mcScore - lastScore;
    double prob=1.0;
    if (AS < 0) {
      prob=probabilityFunction(AS,i,maxIter);
      double p=rnd.nextDouble();
      if (p > prob) {
        msa=lastMSA;
        freePool=lastFreePool;
        mcScore=lastScore;
        conv++;
      }
 else       conv=0;
    }
 else     conv=0;
    if (debug)     System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ prob+ ""String_Node_Str""+ AS+ ""String_Node_Str""+ conv);
    if (i % 100 == 1) {
      lengthHistory.add(msa.length());
      rmsdHistory.add(MultipleAlignmentScorer.getRMSD(msa));
      scoreHistory.add(mcScore);
    }
    i++;
  }
  imposer.superimpose(msa);
  MultipleAlignmentScorer.calculateScores(msa);
  msa.putScore(MultipleAlignmentScorer.MC_SCORE,mcScore);
}",0.9986130374479888
16665,"/** 
 * Insert a gap in one of the structures in a random position in the alignment. The random distribution is not uniform, positions with higher distance are more likely to be gapped. A gap is a null in the Block position.
 */
private boolean insertGap(){
  Matrix residueDistances=MultipleAlignmentTools.getAverageResidueDistances(msa);
  double maxDist=Double.MIN_VALUE;
  int structure=0;
  int block=0;
  int position=0;
  int column=0;
  for (int b=0; b < blockNr; b++) {
    for (int col=0; col < msa.getBlocks().get(b).length(); col++) {
      for (int str=0; str < size; str++) {
        if (residueDistances.get(str,column) != -1) {
          if (residueDistances.get(str,column) > maxDist) {
            if (rnd.nextDouble() > 0.5) {
              structure=str;
              block=b;
              position=col;
            }
          }
        }
      }
      column++;
    }
  }
  if (msa.getBlocks().get(block).length() <= Lmin)   return false;
  Integer residueL=msa.getBlocks().get(block).getAlignRes().get(structure).get(position);
  if (residueL != null)   freePool.get(structure).add(residueL);
 else   return false;
  msa.getBlocks().get(block).getAlignRes().get(structure).set(position,null);
  checkGaps();
  return true;
}","/** 
 * Insert a gap in one of the structures in a random position in the alignment. The random distribution is not uniform, positions with higher distance are more likely to be gapped. A gap is a null in the Block position.
 */
private boolean insertGap(){
  Matrix residueDistances=MultipleAlignmentTools.getAverageResidueDistances(msa);
  double maxDist=Double.MIN_VALUE;
  int structure=0;
  int block=0;
  int position=0;
  int column=0;
  for (int b=0; b < blockNr; b++) {
    for (int col=0; col < msa.getBlocks().get(b).length(); col++) {
      for (int str=0; str < size; str++) {
        if (residueDistances.get(str,column) != -1) {
          if (residueDistances.get(str,column) > maxDist) {
            if (rnd.nextDouble() > 0.5) {
              structure=str;
              block=b;
              position=col;
              maxDist=residueDistances.get(str,column);
            }
          }
        }
      }
      column++;
    }
  }
  if (msa.getBlocks().get(block).length() <= Lmin)   return false;
  Integer residueL=msa.getBlocks().get(block).getAlignRes().get(structure).get(position);
  if (residueL != null)   freePool.get(structure).add(residueL);
 else   return false;
  msa.getBlocks().get(block).getAlignRes().get(structure).set(position,null);
  checkGaps();
  return true;
}",0.9780736100234926
16666,"/** 
 * Return the Compound for this chain.
 * @return the Compound object 
 * @see #setCompound(Compound)
 */
public Compound getCompound();","/** 
 * Returns the Compound for this chain.
 * @return the Compound object 
 * @see #setCompound(Compound)
 */
public Compound getCompound();",0.9964664310954064
16667,"/** 
 * Return the sequence of amino acids as it has been provided in the ATOM records.
 * @return amino acid sequence as string
 * @see #getSeqResSequence()
 */
public String getAtomSequence();","/** 
 * Returns the sequence of amino acids as it has been provided in the ATOM records. Non-standard residues will be present in the string only if the property   {@value PDBFileReader#LOAD_CHEM_COMP_PROPERTY} has been set.
 * @return amino acid sequence as string
 * @see #getSeqResSequence()
 */
public String getAtomSequence();",0.7390476190476191
16668,"/** 
 * Get the Swissprot id of this chain.
 * @return a String representing the swissprot id value
 * @see #setSwissprotId(String sp_id)
 */
public String getSwissprotId();","/** 
 * Gets the Swissprot id of this chain.
 * @return a String representing the swissprot id value
 * @see #setSwissprotId(String sp_id)
 */
public String getSwissprotId();",0.9971181556195964
16669,"/** 
 * Set the Compound
 * @param compound the Compound 
 * @see #getCompound()
 */
public void setCompound(Compound compound);","/** 
 * Sets the Compound
 * @param compound the Compound 
 * @see #getCompound()
 */
public void setCompound(Compound compound);",0.9961089494163424
16670,"/** 
 * Return the number of groups in the SEQRES records of the chain, i.e. the number of aminoacids/nucleotides in the construct 
 * @return the length
 * @see #getSeqResGroup(int)
 * @see #getSeqResGroups()
 * @see #getAtomLength()
 */
public int getSeqResLength();","/** 
 * Returns the number of groups in the SEQRES records of the chain, i.e. the number of aminoacids/nucleotides in the construct 
 * @return the length
 * @see #getSeqResGroup(int)
 * @see #getSeqResGroups()
 * @see #getAtomLength()
 */
public int getSeqResLength();",0.9981378026070764
16671,"/** 
 * Return the number of Groups with observed density in the chain, i.e.  those with coordinates in ATOM and HETATMs (including waters) records
 * @return the length
 * @see #getAtomGroup(int)
 * @see #getAtomGroups()
 * @see #getSeqResLength()) 
 */
public int getAtomLength();","/** 
 * Returns the number of Groups with observed density in the chain, i.e.  those with coordinates in ATOM and HETATMs (including waters) records
 * @return the length
 * @see #getAtomGroup(int)
 * @see #getAtomGroups()
 * @see #getSeqResLength()) 
 */
public int getAtomLength();",0.9982300884955752
16672,"/** 
 * {@inheritDoc}
 */
@Override public String getSeqResSequence(){
  String prop=System.getProperty(PDBFileReader.LOAD_CHEM_COMP_PROPERTY);
  if (prop != null && prop.equalsIgnoreCase(""String_Node_Str"")) {
    StringBuilder str=new StringBuilder();
    for (    Group g : seqResGroups) {
      ChemComp cc=g.getChemComp();
      if (cc == null) {
        logger.warn(""String_Node_Str"",g);
        str.append(""String_Node_Str"");
      }
 else       if (PolymerType.PROTEIN_ONLY.contains(cc.getPolymerType()) || PolymerType.POLYNUCLEOTIDE_ONLY.contains(cc.getPolymerType())) {
        String oneLetter=ChemCompGroupFactory.getOneLetterCode(cc);
        if (oneLetter == null || oneLetter.isEmpty() || oneLetter.equals(""String_Node_Str""))         oneLetter=""String_Node_Str"";
        str.append(oneLetter);
      }
 else {
        str.append(""String_Node_Str"");
      }
    }
    return str.toString();
  }
  StringBuilder str=new StringBuilder();
  for (  Group group : seqResGroups) {
    if (group instanceof AminoAcid) {
      AminoAcid aa=(AminoAcid)group;
      str.append(aa.getAminoType());
    }
 else {
      str.append(""String_Node_Str"");
    }
  }
  return str.toString();
}","/** 
 * {@inheritDoc}
 */
@Override public String getSeqResSequence(){
  String prop=System.getProperty(PDBFileReader.LOAD_CHEM_COMP_PROPERTY);
  if (prop != null && prop.equalsIgnoreCase(""String_Node_Str"")) {
    logger.info(""String_Node_Str"",PDBFileReader.LOAD_CHEM_COMP_PROPERTY);
    StringBuilder str=new StringBuilder();
    for (    Group g : seqResGroups) {
      ChemComp cc=g.getChemComp();
      if (cc == null) {
        logger.warn(""String_Node_Str"",g);
        str.append(""String_Node_Str"");
      }
 else       if (PolymerType.PROTEIN_ONLY.contains(cc.getPolymerType()) || PolymerType.POLYNUCLEOTIDE_ONLY.contains(cc.getPolymerType())) {
        String oneLetter=ChemCompGroupFactory.getOneLetterCode(cc);
        if (oneLetter == null || oneLetter.isEmpty() || oneLetter.equals(""String_Node_Str""))         oneLetter=Character.toString(StructureTools.UNKNOWN_GROUP_LABEL);
        str.append(oneLetter);
      }
 else {
        str.append(StructureTools.UNKNOWN_GROUP_LABEL);
      }
    }
    return str.toString();
  }
  logger.info(""String_Node_Str"",PDBFileReader.LOAD_CHEM_COMP_PROPERTY);
  StringBuilder str=new StringBuilder();
  for (  Group group : seqResGroups) {
    if (group instanceof AminoAcid) {
      AminoAcid aa=(AminoAcid)group;
      str.append(aa.getAminoType());
    }
 else {
      str.append(StructureTools.UNKNOWN_GROUP_LABEL);
    }
  }
  return str.toString();
}",0.8012350443844075
16673,"/** 
 * {@inheritDoc}
 */
@Override public String getAtomSequence(){
  String prop=System.getProperty(PDBFileReader.LOAD_CHEM_COMP_PROPERTY);
  if (prop != null && prop.equalsIgnoreCase(""String_Node_Str"")) {
    List<Group> groups=getAtomGroups();
    StringBuilder sequence=new StringBuilder();
    for (    Group g : groups) {
      ChemComp cc=g.getChemComp();
      if (PolymerType.PROTEIN_ONLY.contains(cc.getPolymerType()) || PolymerType.POLYNUCLEOTIDE_ONLY.contains(cc.getPolymerType())) {
        String oneLetter=ChemCompGroupFactory.getOneLetterCode(cc);
        if (oneLetter == null)         oneLetter=""String_Node_Str"";
        sequence.append(oneLetter);
      }
    }
    return sequence.toString();
  }
  List<Group> aminos=getAtomGroups(GroupType.AMINOACID);
  StringBuilder sequence=new StringBuilder();
  for (  Group amino : aminos) {
    AminoAcid a=(AminoAcid)amino;
    sequence.append(a.getAminoType());
  }
  return sequence.toString();
}","/** 
 * {@inheritDoc}
 */
@Override public String getAtomSequence(){
  String prop=System.getProperty(PDBFileReader.LOAD_CHEM_COMP_PROPERTY);
  if (prop != null && prop.equalsIgnoreCase(""String_Node_Str"")) {
    logger.info(""String_Node_Str"",PDBFileReader.LOAD_CHEM_COMP_PROPERTY);
    List<Group> groups=getAtomGroups();
    StringBuilder sequence=new StringBuilder();
    for (    Group g : groups) {
      ChemComp cc=g.getChemComp();
      if (PolymerType.PROTEIN_ONLY.contains(cc.getPolymerType()) || PolymerType.POLYNUCLEOTIDE_ONLY.contains(cc.getPolymerType())) {
        String oneLetter=ChemCompGroupFactory.getOneLetterCode(cc);
        if (oneLetter == null)         oneLetter=Character.toString(StructureTools.UNKNOWN_GROUP_LABEL);
        sequence.append(oneLetter);
      }
    }
    return sequence.toString();
  }
  logger.info(""String_Node_Str"",PDBFileReader.LOAD_CHEM_COMP_PROPERTY);
  List<Group> aminos=getAtomGroups(GroupType.AMINOACID);
  StringBuilder sequence=new StringBuilder();
  for (  Group amino : aminos) {
    if (amino instanceof AminoAcid) {
      AminoAcid a=(AminoAcid)amino;
      sequence.append(a.getAminoType());
    }
 else {
      logger.warn(""String_Node_Str"",amino.toString());
    }
  }
  return sequence.toString();
}",0.7870619946091644
16674,"/** 
 * Convert the SEQRES groups of a Chain to a Biojava Sequence object.
 * @return the SEQRES groups of the Chain as a Sequence object.
 */
@Override public Sequence<?> getBJSequence(){
  String seq=getSeqResSequence();
  Sequence<AminoAcidCompound> s=null;
  try {
    s=new ProteinSequence(seq);
  }
 catch (  CompoundNotFoundException e) {
    logger.error(""String_Node_Str"",e.getMessage());
  }
  return s;
}","/** 
 * {@inheritDoc} 
 */
@Override public Sequence<?> getBJSequence(){
  String seq=getSeqResSequence();
  Sequence<AminoAcidCompound> s=null;
  try {
    s=new ProteinSequence(seq);
  }
 catch (  CompoundNotFoundException e) {
    logger.error(""String_Node_Str"",e.getMessage());
  }
  return s;
}",0.803921568627451
16675,"private static void downloadChemCompRecord(String recordName){
  String localName=getLocalFileName(recordName);
  String u=SERVER_LOCATION + recordName + ""String_Node_Str"";
  try {
    URL url=new URL(u);
    HttpURLConnection uconn=HTTPConnectionTools.openHttpURLConnection(url);
    InputStream conn=uconn.getInputStream();
    FileOutputStream outPut=new FileOutputStream(localName);
    GZIPOutputStream gzOutPut=new GZIPOutputStream(outPut);
    PrintWriter pw=new PrintWriter(gzOutPut);
    BufferedReader fileBuffer=new BufferedReader(new InputStreamReader(conn));
    String line;
    while ((line=fileBuffer.readLine()) != null) {
      pw.println(line);
    }
    pw.flush();
    pw.close();
    outPut.close();
    conn.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","private static void downloadChemCompRecord(String recordName){
  String localName=getLocalFileName(recordName);
  String u=SERVER_LOCATION + recordName + ""String_Node_Str"";
  URL url=null;
  try {
    url=new URL(u);
    HttpURLConnection uconn=HTTPConnectionTools.openHttpURLConnection(url);
    InputStream conn=uconn.getInputStream();
    FileOutputStream outPut=new FileOutputStream(localName);
    GZIPOutputStream gzOutPut=new GZIPOutputStream(outPut);
    PrintWriter pw=new PrintWriter(gzOutPut);
    BufferedReader fileBuffer=new BufferedReader(new InputStreamReader(conn));
    String line;
    while ((line=fileBuffer.readLine()) != null) {
      pw.println(line);
    }
    pw.flush();
    pw.close();
    outPut.close();
    conn.close();
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + url.toString() + ""String_Node_Str""+ localName,e);
  }
}",0.9295942720763724
16676,"/** 
 * Loads the definitions for this   {@link ChemComp} from a local file and instantiates a new object.
 * @param recordName the ID of the {@link ChemComp}
 * @return a new {@link ChemComp} definition.
 */
@Override public ChemComp getChemComp(String recordName){
  recordName=recordName.toUpperCase().trim();
  if (recordName.equals(""String_Node_Str"")) {
    return null;
  }
  try {
    if (!fileExists(recordName)) {
      checkDoFirstInstall();
    }
    if (!fileExists(recordName)) {
      downloadChemCompRecord(recordName);
    }
    String filename=getLocalFileName(recordName);
    InputStreamProvider isp=new InputStreamProvider();
    InputStream inStream=isp.getInputStream(filename);
    MMcifParser parser=new SimpleMMcifParser();
    ChemCompConsumer consumer=new ChemCompConsumer();
    parser.addMMcifConsumer(consumer);
    parser.parse(new BufferedReader(new InputStreamReader(inStream)));
    ChemicalComponentDictionary dict=consumer.getDictionary();
    ChemComp chemComp=dict.getChemComp(recordName);
    return chemComp;
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return null;
}","/** 
 * Loads the definitions for this   {@link ChemComp} from a local file and instantiates a new object.
 * @param recordName the ID of the {@link ChemComp}
 * @return a new {@link ChemComp} definition.
 */
@Override public ChemComp getChemComp(String recordName){
  recordName=recordName.toUpperCase().trim();
  if (recordName.equals(""String_Node_Str"")) {
    return null;
  }
  if (!fileExists(recordName)) {
    checkDoFirstInstall();
  }
  if (!fileExists(recordName)) {
    downloadChemCompRecord(recordName);
  }
  String filename=getLocalFileName(recordName);
  try {
    InputStreamProvider isp=new InputStreamProvider();
    InputStream inStream=isp.getInputStream(filename);
    MMcifParser parser=new SimpleMMcifParser();
    ChemCompConsumer consumer=new ChemCompConsumer();
    parser.addMMcifConsumer(consumer);
    parser.parse(new BufferedReader(new InputStreamReader(inStream)));
    ChemicalComponentDictionary dict=consumer.getDictionary();
    ChemComp chemComp=dict.getChemComp(recordName);
    return chemComp;
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + filename,e);
  }
  return null;
}",0.9606368863334808
16677,"public static void main(String[] args) throws IOException, StructureException, InterruptedException, ExecutionException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AtomCache cache=new AtomCache();
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  for (  String name : names) {
    atomArrays.add(cache.getAtoms(name));
  }
  CeMcMain algorithm=new CeMcMain();
  MultipleAlignment result=algorithm.align(atomArrays);
  result.getEnsemble().setStructureNames(names);
  result.getEnsemble().setAlgorithmName(algorithm.getAlgorithmName());
  result.getEnsemble().setVersion(algorithm.getVersion());
  MultipleAlignmentDisplay.display(result);
}","public static void main(String[] args) throws IOException, StructureException, InterruptedException, ExecutionException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AtomCache cache=new AtomCache();
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  for (  String name : names) {
    atomArrays.add(cache.getAtoms(name));
  }
  CeMcMain algorithm=new CeMcMain();
  MultipleAlignment result=algorithm.align(atomArrays);
  result.getEnsemble().setStructureNames(names);
  result.getEnsemble().setAlgorithmName(algorithm.getAlgorithmName());
  result.getEnsemble().setVersion(algorithm.getVersion());
  MultipleAlignmentDisplay.display(result);
}",0.9770408163265306
16678,"/** 
 * Optimization method based in a Monte-Carlo approach. Starting from the refined alignment uses 4 types of moves: <p> 1- Shift Row: if there are enough freePool residues available.<p> 2- Expand Block: add another alignment column if there are residues available.<p> 3- Shrink Block: move a block column to the freePool.<p> 4- Insert gap: insert a gap in a random position of the alignment.
 */
private void optimizeMC(int maxIter) throws StructureException {
  lengthHistory=new ArrayList<Integer>();
  rmsdHistory=new ArrayList<Double>();
  scoreHistory=new ArrayList<Double>();
  int conv=0;
  int stepsToConverge=maxIter / 20;
  int i=1;
  while (i < maxIter && conv < stepsToConverge) {
    BlockSet lastBlock=block.clone();
    List<SortedSet<Integer>> lastFreePool=new ArrayList<SortedSet<Integer>>();
    for (int k=0; k < size; k++) {
      SortedSet<Integer> p=new TreeSet<Integer>();
      for (      Integer l : freePool.get(k))       p.add(l);
      lastFreePool.add(p);
    }
    double lastScore=mcScore;
    boolean moved=false;
    while (!moved) {
      int move=rnd.nextInt(4);
switch (move) {
case 0:
        moved=shiftRow();
      if (debug)       System.out.println(""String_Node_Str"");
    break;
case 1:
  moved=expandBlock();
if (debug) System.out.println(""String_Node_Str"");
break;
case 2:
moved=shrinkBlock();
if (debug) System.out.println(""String_Node_Str"");
break;
case 3:
moved=insertGap();
if (debug) System.out.println(""String_Node_Str"");
break;
}
}
block.clear();
msa.setBlockSets(Arrays.asList(block));
imposer.superimpose(msa);
mcScore=MultipleAlignmentScorer.getCEMCScore(msa);
double AS=mcScore - lastScore;
double prob=1.0;
if (AS < 0) {
prob=probabilityFunction(AS,i,maxIter);
double p=rnd.nextDouble();
if (p > prob) {
block=lastBlock;
freePool=lastFreePool;
mcScore=lastScore;
conv++;
}
 else conv=0;
}
 else conv=0;
if (debug) System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ prob+ ""String_Node_Str""+ AS+ ""String_Node_Str""+ conv);
if (i % 100 == 1) {
msa.setBlockSets(Arrays.asList(block));
imposer.superimpose(msa);
lengthHistory.add(block.length());
rmsdHistory.add(MultipleAlignmentScorer.getRMSD(msa));
scoreHistory.add(mcScore);
}
i++;
}
msa.setBlockSets(Arrays.asList(block));
imposer.superimpose(msa);
MultipleAlignmentScorer.calculateScores(msa);
msa.putScore(MultipleAlignmentScorer.CEMC_SCORE,mcScore);
}","/** 
 * Optimization method based in a Monte-Carlo approach. Starting from the refined alignment uses 4 types of moves: <p> 1- Shift Row: if there are enough freePool residues available.<p> 2- Expand Block: add another alignment column if there are residues available.<p> 3- Shrink Block: move a block column to the freePool.<p> 4- Insert gap: insert a gap in a random position of the alignment.
 */
private void optimizeMC(int maxIter) throws StructureException {
  lengthHistory=new ArrayList<Integer>();
  rmsdHistory=new ArrayList<Double>();
  scoreHistory=new ArrayList<Double>();
  int conv=0;
  int stepsToConverge=Math.max(maxIter / 50,1000);
  int i=1;
  while (i < maxIter && conv < stepsToConverge) {
    BlockSet lastBlock=block.clone();
    List<SortedSet<Integer>> lastFreePool=new ArrayList<SortedSet<Integer>>();
    for (int k=0; k < size; k++) {
      SortedSet<Integer> p=new TreeSet<Integer>();
      for (      Integer l : freePool.get(k))       p.add(l);
      lastFreePool.add(p);
    }
    double lastScore=mcScore;
    boolean moved=false;
    while (!moved) {
      int move=rnd.nextInt(4);
switch (move) {
case 0:
        moved=shiftRow();
      if (debug)       System.out.println(""String_Node_Str"");
    break;
case 1:
  moved=expandBlock();
if (debug) System.out.println(""String_Node_Str"");
break;
case 2:
moved=shrinkBlock();
if (debug) System.out.println(""String_Node_Str"");
break;
case 3:
moved=insertGap();
if (debug) System.out.println(""String_Node_Str"");
break;
}
}
block.clear();
msa.setBlockSets(Arrays.asList(block));
imposer.superimpose(msa);
mcScore=MultipleAlignmentScorer.getCEMCScore(msa);
double AS=mcScore - lastScore;
double prob=1.0;
if (AS < 0) {
prob=probabilityFunction(AS,i,maxIter);
double p=rnd.nextDouble();
if (p > prob) {
block=lastBlock;
freePool=lastFreePool;
mcScore=lastScore;
conv++;
}
 else conv=0;
}
 else conv=0;
if (debug) System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ prob+ ""String_Node_Str""+ AS+ ""String_Node_Str""+ conv);
if (i % 100 == 1) {
msa.setBlockSets(Arrays.asList(block));
imposer.superimpose(msa);
lengthHistory.add(block.length());
rmsdHistory.add(MultipleAlignmentScorer.getRMSD(msa));
scoreHistory.add(mcScore);
}
i++;
}
msa.setBlockSets(Arrays.asList(block));
imposer.superimpose(msa);
MultipleAlignmentScorer.calculateScores(msa);
msa.putScore(MultipleAlignmentScorer.CEMC_SCORE,mcScore);
}",0.9964308209111904
16679,"/** 
 * Insert a gap in one of the structures in a random position in the alignment. A gap is a null in the Block position.
 */
private boolean insertGap(){
  int str=rnd.nextInt(size);
  int bk=rnd.nextInt(blockNr);
  int res=rnd.nextInt(block.getBlocks().get(bk).length());
  Integer residueL=block.getBlocks().get(bk).getAlignRes().get(str).get(res);
  if (residueL != null)   freePool.get(str).add(residueL);
 else   return false;
  block.getBlocks().get(bk).getAlignRes().get(str).set(res,null);
  checkGaps();
  return true;
}","/** 
 * Insert a gap in one of the structures in a random position in the alignment. A gap is a null in the Block position.
 */
private boolean insertGap(){
  int str=rnd.nextInt(size);
  int bk=rnd.nextInt(blockNr);
  if (block.getBlocks().get(bk).length() <= Lmin)   return false;
  int res=rnd.nextInt(block.getBlocks().get(bk).length());
  Integer residueL=block.getBlocks().get(bk).getAlignRes().get(str).get(res);
  if (residueL != null)   freePool.get(str).add(residueL);
 else   return false;
  block.getBlocks().get(bk).getAlignRes().get(str).set(res,null);
  checkGaps();
  return true;
}",0.9415929203539825
16680,"/** 
 * After the alignment changes (optAln, optLen, blockNum, at a minimum), many other properties which depend on the superposition will be invalid. This method re-runs a rigid superposition over the whole alignment and repopulates the required properties, including RMSD (TotalRMSD) and TM-Score.
 * @param afpChain
 * @param ca1
 * @param ca2 Second set of ca atoms. Will be modified based on the superposition
 * @throws StructureException
 * @see {@link CECalculator#calc_rmsd(Atom[],Atom[],int,boolean)}contains much of the same code, but stores results in a CECalculator instance rather than an AFPChain
 */
public static void updateSuperposition(AFPChain afpChain,Atom[] ca1,Atom[] ca2) throws StructureException {
  afpChain.setCa1Length(ca1.length);
  afpChain.setCa2Length(ca2.length);
  int[] focusRes1=afpChain.getFocusRes1();
  int[] focusRes2=afpChain.getFocusRes2();
  if (focusRes1 == null) {
    focusRes1=new int[afpChain.getCa1Length()];
    afpChain.setFocusRes1(focusRes1);
  }
  if (focusRes2 == null) {
    focusRes2=new int[afpChain.getCa2Length()];
    afpChain.setFocusRes2(focusRes2);
  }
  if (afpChain.getNrEQR() == 0)   return;
  Atom[] ca1aligned=new Atom[afpChain.getOptLength()];
  Atom[] ca2aligned=new Atom[afpChain.getOptLength()];
  int pos=0;
  int[] blockLens=afpChain.getOptLen();
  int[][][] optAln=afpChain.getOptAln();
  assert(afpChain.getBlockNum() <= optAln.length);
  for (int block=0; block < afpChain.getBlockNum(); block++) {
    for (int i=0; i < blockLens[block]; i++) {
      int pos1=optAln[block][0][i];
      int pos2=optAln[block][1][i];
      Atom a1=ca1[pos1];
      Atom a2=(Atom)ca2[pos2].clone();
      ca1aligned[pos]=a1;
      ca2aligned[pos]=a2;
      pos++;
    }
  }
  if (pos != afpChain.getOptLength()) {
    logger.warn(""String_Node_Str"" + pos + ""String_Node_Str""+ afpChain.getOptLength());
    ca1aligned=(Atom[])resizeArray(ca1aligned,pos);
    ca2aligned=(Atom[])resizeArray(ca2aligned,pos);
  }
  SVDSuperimposer svd=new SVDSuperimposer(ca1aligned,ca2aligned);
  Matrix matrix=svd.getRotation();
  Atom shift=svd.getTranslation();
  Matrix[] blockMxs=new Matrix[afpChain.getBlockNum()];
  Arrays.fill(blockMxs,matrix);
  afpChain.setBlockRotationMatrix(blockMxs);
  Atom[] blockShifts=new Atom[afpChain.getBlockNum()];
  Arrays.fill(blockShifts,shift);
  afpChain.setBlockShiftVector(blockShifts);
  for (  Atom a : ca2aligned) {
    Calc.rotate(a,matrix);
    Calc.shift(a,shift);
  }
  double rmsd=SVDSuperimposer.getRMS(ca1aligned,ca2aligned);
  double tmScore=SVDSuperimposer.getTMScore(ca1aligned,ca2aligned,ca1.length,ca2.length);
  afpChain.setTotalRmsdOpt(rmsd);
  afpChain.setTMScore(tmScore);
  double[] blockRMSD=new double[afpChain.getBlockNum()];
  double[] blockScore=new double[afpChain.getBlockNum()];
  for (int k=0; k < afpChain.getBlockNum(); k++) {
    Atom[] ca1block=new Atom[afpChain.getOptLen()[k]];
    Atom[] ca2block=new Atom[afpChain.getOptLen()[k]];
    int position=0;
    for (int i=0; i < blockLens[k]; i++) {
      int pos1=optAln[k][0][i];
      int pos2=optAln[k][1][i];
      Atom a1=ca1[pos1];
      Atom a2=(Atom)ca2[pos2].clone();
      ca1block[position]=a1;
      ca2block[position]=a2;
      position++;
    }
    if (position != afpChain.getOptLen()[k]) {
      logger.warn(""String_Node_Str"" + pos + ""String_Node_Str""+ afpChain.getOptLen()[k]);
      ca1block=(Atom[])resizeArray(ca1block,position);
      ca2block=(Atom[])resizeArray(ca2block,position);
    }
    SVDSuperimposer svdb=new SVDSuperimposer(ca1block,ca2block);
    Matrix matrixb=svdb.getRotation();
    Atom shiftb=svdb.getTranslation();
    afpChain.getBlockRotationMatrix()[k]=matrixb;
    afpChain.getBlockShiftVector()[k]=shiftb;
    afpChain.setBlockShiftVector(blockShifts);
    for (    Atom a : ca2block) {
      Calc.rotate(a,matrixb);
      Calc.shift(a,shiftb);
    }
    double rmsdb=SVDSuperimposer.getRMS(ca1block,ca2block);
    double tmScoreb=SVDSuperimposer.getTMScore(ca1block,ca2block,ca1.length,ca2.length);
    blockRMSD[k]=rmsdb;
    blockScore[k]=tmScoreb;
  }
  afpChain.setOptRmsd(blockRMSD);
  afpChain.setBlockRmsd(blockRMSD);
  afpChain.setBlockScore(blockScore);
}","/** 
 * After the alignment changes (optAln, optLen, blockNum, at a minimum), many other properties which depend on the superposition will be invalid. This method re-runs a rigid superposition over the whole alignment and repopulates the required properties, including RMSD (TotalRMSD) and TM-Score.
 * @param afpChain
 * @param ca1
 * @param ca2 Second set of ca atoms. Will be modified based on the superposition
 * @throws StructureException
 * @see {@link CECalculator#calc_rmsd(Atom[],Atom[],int,boolean)}contains much of the same code, but stores results in a CECalculator instance rather than an AFPChain
 */
public static void updateSuperposition(AFPChain afpChain,Atom[] ca1,Atom[] ca2) throws StructureException {
  afpChain.setCa1Length(ca1.length);
  afpChain.setCa2Length(ca2.length);
  int[] focusRes1=afpChain.getFocusRes1();
  int[] focusRes2=afpChain.getFocusRes2();
  if (focusRes1 == null) {
    focusRes1=new int[afpChain.getCa1Length()];
    afpChain.setFocusRes1(focusRes1);
  }
  if (focusRes2 == null) {
    focusRes2=new int[afpChain.getCa2Length()];
    afpChain.setFocusRes2(focusRes2);
  }
  if (afpChain.getNrEQR() == 0)   return;
  Atom[] ca1aligned=new Atom[afpChain.getOptLength()];
  Atom[] ca2aligned=new Atom[afpChain.getOptLength()];
  int pos=0;
  int[] blockLens=afpChain.getOptLen();
  int[][][] optAln=afpChain.getOptAln();
  assert(afpChain.getBlockNum() <= optAln.length);
  for (int block=0; block < afpChain.getBlockNum(); block++) {
    for (int i=0; i < blockLens[block]; i++) {
      int pos1=optAln[block][0][i];
      int pos2=optAln[block][1][i];
      Atom a1=ca1[pos1];
      Atom a2=(Atom)ca2[pos2].clone();
      ca1aligned[pos]=a1;
      ca2aligned[pos]=a2;
      pos++;
    }
  }
  if (pos != afpChain.getOptLength()) {
    logger.warn(""String_Node_Str"" + pos + ""String_Node_Str""+ afpChain.getOptLength());
    ca1aligned=(Atom[])resizeArray(ca1aligned,pos);
    ca2aligned=(Atom[])resizeArray(ca2aligned,pos);
  }
  SVDSuperimposer svd=new SVDSuperimposer(ca1aligned,ca2aligned);
  Matrix matrix=svd.getRotation();
  Atom shift=svd.getTranslation();
  Matrix[] blockMxs=new Matrix[afpChain.getBlockNum()];
  Arrays.fill(blockMxs,matrix);
  afpChain.setBlockRotationMatrix(blockMxs);
  Atom[] blockShifts=new Atom[afpChain.getBlockNum()];
  Arrays.fill(blockShifts,shift);
  afpChain.setBlockShiftVector(blockShifts);
  for (  Atom a : ca2aligned) {
    Calc.rotate(a,matrix);
    Calc.shift(a,shift);
  }
  double rmsd=SVDSuperimposer.getRMS(ca1aligned,ca2aligned);
  double tmScore=SVDSuperimposer.getTMScore(ca1aligned,ca2aligned,ca1.length,ca2.length);
  afpChain.setTotalRmsdOpt(rmsd);
  afpChain.setTMScore(tmScore);
  double[] blockRMSD=new double[afpChain.getBlockNum()];
  double[] blockScore=new double[afpChain.getBlockNum()];
  for (int k=0; k < afpChain.getBlockNum(); k++) {
    Atom[] ca1block=new Atom[afpChain.getOptLen()[k]];
    Atom[] ca2block=new Atom[afpChain.getOptLen()[k]];
    int position=0;
    for (int i=0; i < blockLens[k]; i++) {
      int pos1=optAln[k][0][i];
      int pos2=optAln[k][1][i];
      Atom a1=ca1[pos1];
      Atom a2=(Atom)ca2[pos2].clone();
      ca1block[position]=a1;
      ca2block[position]=a2;
      position++;
    }
    if (position != afpChain.getOptLen()[k]) {
      logger.warn(""String_Node_Str"" + pos + ""String_Node_Str""+ afpChain.getOptLen()[k]);
      ca1block=(Atom[])resizeArray(ca1block,position);
      ca2block=(Atom[])resizeArray(ca2block,position);
    }
    SVDSuperimposer svdb=new SVDSuperimposer(ca1block,ca2block);
    Matrix matrixb=svdb.getRotation();
    Atom shiftb=svdb.getTranslation();
    for (    Atom a : ca2block) {
      Calc.rotate(a,matrixb);
      Calc.shift(a,shiftb);
    }
    double rmsdb=SVDSuperimposer.getRMS(ca1block,ca2block);
    double tmScoreb=SVDSuperimposer.getTMScore(ca1block,ca2block,ca1.length,ca2.length);
    blockRMSD[k]=rmsdb;
    blockScore[k]=tmScoreb;
  }
  afpChain.setOptRmsd(blockRMSD);
  afpChain.setBlockRmsd(blockRMSD);
  afpChain.setBlockScore(blockScore);
}",0.9825885790819432
16681,"@Test public void testFASTA(){
}","@Test public void testFASTA() throws StructureException, IOException {
  MultipleAlignment alignment=generateTestMultipleAlignment();
  String result=MultipleAlignmentWriter.toFASTA(alignment);
  System.out.println(result);
  StringBuffer expected=new StringBuffer();
  expected.append(""String_Node_Str"");
  expected.append(""String_Node_Str"");
  expected.append(""String_Node_Str"");
  expected.append(""String_Node_Str"");
  expected.append(""String_Node_Str"");
  expected.append(""String_Node_Str"");
  assertEquals(result,expected.toString());
}",0.1116928446771378
16682,"/** 
 * prints the connections in PDB style Thanks to Tamas Horvath for this one
 */
private String printPDBConnections(){
  StringBuffer str=new StringBuffer();
  List<Map<String,Integer>> cons=structure.getConnections();
  for (int cnr=0; cnr < cons.size(); cnr++) {
    Map<String,Integer> con=cons.get(cnr);
    Integer as=con.get(""String_Node_Str"");
    String atomserial=""String_Node_Str"";
    String bond1=""String_Node_Str"";
    String bond2=""String_Node_Str"";
    String bond3=""String_Node_Str"";
    String bond4=""String_Node_Str"";
    String hyd1=""String_Node_Str"";
    String hyd2=""String_Node_Str"";
    String salt1=""String_Node_Str"";
    String hyd3=""String_Node_Str"";
    String hyd4=""String_Node_Str"";
    String salt2=""String_Node_Str"";
    if (con.containsKey(""String_Node_Str""))     bond1=con.get(""String_Node_Str"").toString();
    if (con.containsKey(""String_Node_Str""))     bond2=con.get(""String_Node_Str"").toString();
    if (con.containsKey(""String_Node_Str""))     bond3=con.get(""String_Node_Str"").toString();
    if (con.containsKey(""String_Node_Str""))     bond4=con.get(""String_Node_Str"").toString();
    if (con.containsKey(""String_Node_Str""))     hyd1=con.get(""String_Node_Str"").toString();
    if (con.containsKey(""String_Node_Str""))     hyd2=con.get(""String_Node_Str"").toString();
    if (con.containsKey(""String_Node_Str""))     salt1=con.get(""String_Node_Str"").toString();
    if (con.containsKey(""String_Node_Str""))     hyd3=con.get(""String_Node_Str"").toString();
    if (con.containsKey(""String_Node_Str""))     hyd4=con.get(""String_Node_Str"").toString();
    if (con.containsKey(""String_Node_Str""))     salt2=con.get(""String_Node_Str"").toString();
    atomserial=alignRight(""String_Node_Str"" + as,5);
    bond1=alignRight(bond1,5);
    bond2=alignRight(bond2,5);
    bond3=alignRight(bond3,5);
    bond4=alignRight(bond4,5);
    hyd1=alignRight(hyd1,5);
    hyd2=alignRight(hyd2,5);
    salt1=alignRight(salt1,5);
    hyd3=alignRight(hyd3,5);
    hyd4=alignRight(hyd4,5);
    salt2=alignRight(salt2,5);
    String connectLine=""String_Node_Str"" + atomserial + bond1+ bond2+ bond3+ bond4+ hyd1+ hyd2+ salt1+ hyd3+ hyd4+ salt2;
    str.append(connectLine).append(newline);
  }
  return str.toString();
}","/** 
 * prints the connections in PDB style Thanks to Tamas Horvath for this one
 */
private String printPDBConnections(){
  StringBuffer str=new StringBuffer();
  List<Map<String,Integer>> cons=structure.getConnections();
  for (int cnr=0; cnr < cons.size(); cnr++) {
    Map<String,Integer> con=cons.get(cnr);
    Integer as=con.get(""String_Node_Str"");
    String atomserial=""String_Node_Str"";
    String bond1=""String_Node_Str"";
    String bond2=""String_Node_Str"";
    String bond3=""String_Node_Str"";
    String bond4=""String_Node_Str"";
    String hyd1=""String_Node_Str"";
    String hyd2=""String_Node_Str"";
    String salt1=""String_Node_Str"";
    String hyd3=""String_Node_Str"";
    String hyd4=""String_Node_Str"";
    String salt2=""String_Node_Str"";
    if (con.containsKey(""String_Node_Str""))     bond1=con.get(""String_Node_Str"").toString();
    if (con.containsKey(""String_Node_Str""))     bond2=con.get(""String_Node_Str"").toString();
    if (con.containsKey(""String_Node_Str""))     bond3=con.get(""String_Node_Str"").toString();
    if (con.containsKey(""String_Node_Str""))     bond4=con.get(""String_Node_Str"").toString();
    if (con.containsKey(""String_Node_Str""))     hyd1=con.get(""String_Node_Str"").toString();
    if (con.containsKey(""String_Node_Str""))     hyd2=con.get(""String_Node_Str"").toString();
    if (con.containsKey(""String_Node_Str""))     salt1=con.get(""String_Node_Str"").toString();
    if (con.containsKey(""String_Node_Str""))     hyd3=con.get(""String_Node_Str"").toString();
    if (con.containsKey(""String_Node_Str""))     hyd4=con.get(""String_Node_Str"").toString();
    if (con.containsKey(""String_Node_Str""))     salt2=con.get(""String_Node_Str"").toString();
    atomserial=String.format(""String_Node_Str"",as);
    bond1=String.format(""String_Node_Str"",bond1);
    bond2=String.format(""String_Node_Str"",bond2);
    bond3=String.format(""String_Node_Str"",bond3);
    bond4=String.format(""String_Node_Str"",bond4);
    hyd1=String.format(""String_Node_Str"",hyd1);
    hyd2=String.format(""String_Node_Str"",hyd2);
    salt1=String.format(""String_Node_Str"",salt1);
    hyd3=String.format(""String_Node_Str"",hyd3);
    hyd4=String.format(""String_Node_Str"",hyd4);
    salt2=String.format(""String_Node_Str"",salt2);
    String connectLine=""String_Node_Str"" + atomserial + bond1+ bond2+ bond3+ bond4+ hyd1+ hyd2+ salt1+ hyd3+ hyd4+ salt2;
    str.append(connectLine).append(newline);
  }
  return str.toString();
}",0.8178102817810282
16683,"/** 
 * returns if the Connections should be added default is true;
 * @return if the printConnections flag is set
 */
public boolean doPrintConnections(){
  return printConnections;
}","/** 
 * Returns if the Connections should be added default is true;
 * @return if the printConnections flag is set
 */
public boolean doPrintConnections(){
  return printConnections;
}",0.9945652173913044
16684,"/** 
 * Handler for ATOM Record Format <pre> ATOM      1  N   ASP A  15     110.964  24.941  59.191  1.00 83.44           N COLUMNS        DATA TYPE       FIELD         DEFINITION --------------------------------------------------------------------------------- 1 -  6        Record name     ""ATOM  "" 7 - 11        Integer         serial        Atom serial number. 13 - 16        Atom            name          Atom name. 17             Character       altLoc        Alternate location indicator. 18 - 20        Residue name    resName       Residue name. 22             Character       chainID       Chain identifier. 23 - 26        Integer         resSeq        Residue sequence number. 27             AChar           iCode         Code for insertion of residues. 31 - 38        Real(8.3)       x             Orthogonal coordinates for X in Angstroms. 39 - 46        Real(8.3)       y             Orthogonal coordinates for Y in Angstroms. 47 - 54        Real(8.3)       z             Orthogonal coordinates for Z in Angstroms. 55 - 60        Real(6.2)       occupancy     Occupancy. 61 - 66        Real(6.2)       tempFactor    Temperature factor. 73 - 76        LString(4)      segID         Segment identifier, left-justified. 77 - 78        LString(2)      element       Element symbol, right-justified. 79 - 80        LString(2)      charge        Charge on the atom. </pre>
 */
private void pdb_ATOM_Handler(String line){
  boolean startOfNewChain=false;
  String chain_id=line.substring(21,22);
  if (current_chain == null) {
    current_chain=new ChainImpl();
    current_chain.setChainID(chain_id);
    startOfNewChain=true;
    current_model.add(current_chain);
  }
  if (!chain_id.equals(current_chain.getChainID())) {
    startOfNewChain=true;
    current_chain.addGroup(current_group);
    Chain testchain;
    testchain=isKnownChain(current_chain.getChainID(),current_model);
    if (testchain != null && testchain.getChainID().equals(chain_id)) {
    }
 else {
      testchain=isKnownChain(chain_id,current_model);
    }
    if (testchain == null) {
      current_chain=new ChainImpl();
      current_chain.setChainID(chain_id);
    }
 else {
      current_chain=testchain;
    }
    if (!current_model.contains(current_chain))     current_model.add(current_chain);
  }
  String recordName=line.substring(0,6).trim();
  String groupCode3=line.substring(17,20);
  String resNum=line.substring(22,26).trim();
  Character iCode=line.substring(26,27).charAt(0);
  if (iCode == ' ')   iCode=null;
  ResidueNumber residueNumber=new ResidueNumber(chain_id,Integer.valueOf(resNum),iCode);
  Character aminoCode1=null;
  if (recordName.equals(""String_Node_Str"")) {
    aminoCode1=StructureTools.get1LetterCode(groupCode3);
  }
 else {
    aminoCode1=StructureTools.get1LetterCode(groupCode3);
    if (aminoCode1 != null)     if (aminoCode1.equals(StructureTools.UNKNOWN_GROUP_LABEL))     aminoCode1=null;
  }
  if (current_group == null) {
    current_group=getNewGroup(recordName,aminoCode1,groupCode3);
    current_group.setPDBName(groupCode3);
    current_group.setResidueNumber(residueNumber);
    addTohetGroupsDecider(current_group);
  }
  if (startOfNewChain) {
    current_group=getNewGroup(recordName,aminoCode1,groupCode3);
    current_group.setPDBName(groupCode3);
    current_group.setResidueNumber(residueNumber);
    addTohetGroupsDecider(current_group);
  }
  Character altLoc=new Character(line.substring(16,17).charAt(0));
  Group altGroup=null;
  if (!residueNumber.equals(current_group.getResidueNumber())) {
    current_chain.addGroup(current_group);
    current_group.trimToSize();
    current_group=getNewGroup(recordName,aminoCode1,groupCode3);
    current_group.setPDBName(groupCode3);
    current_group.setResidueNumber(residueNumber);
    addTohetGroupsDecider(current_group);
  }
 else {
    if (!altLoc.equals(' ')) {
      logger.debug(""String_Node_Str"" + current_group + ""String_Node_Str""+ altGroup);
      altGroup=getCorrectAltLocGroup(altLoc,recordName,aminoCode1,groupCode3);
      if (altGroup.getChain() == null) {
        altGroup.setChain(current_chain);
      }
    }
  }
  if (params.isHeaderOnly())   return;
  atomCount++;
  if (atomCount == my_ATOM_CA_THRESHOLD) {
    logger.warn(""String_Node_Str"" + my_ATOM_CA_THRESHOLD + ""String_Node_Str"");
    seqResChains.clear();
    switchCAOnly();
  }
  if (atomCount == load_max_atoms) {
    logger.warn(""String_Node_Str"" + load_max_atoms + ""String_Node_Str"");
    logger.warn(""String_Node_Str"" + line);
    return;
  }
  if (atomCount > load_max_atoms) {
    return;
  }
  String fullname=line.substring(12,16);
  if (parseCAonly) {
    if (!fullname.equals(""String_Node_Str"")) {
      atomCount--;
      return;
    }
  }
  if (params.getAcceptedAtomNames() != null) {
    boolean found=false;
    for (    String ok : params.getAcceptedAtomNames()) {
      if (ok.equals(fullname.trim())) {
        found=true;
        break;
      }
    }
    if (!found) {
      atomCount--;
      return;
    }
  }
  int pdbnumber=Integer.parseInt(line.substring(6,11).trim());
  AtomImpl atom=new AtomImpl();
  atom.setPDBserial(pdbnumber);
  atom.setAltLoc(altLoc);
  atom.setName(fullname.trim());
  double x=Double.parseDouble(line.substring(30,38).trim());
  double y=Double.parseDouble(line.substring(38,46).trim());
  double z=Double.parseDouble(line.substring(46,54).trim());
  double[] coords=new double[3];
  coords[0]=x;
  coords[1]=y;
  coords[2]=z;
  atom.setCoords(coords);
  double occu=1.0;
  if (line.length() > 59) {
    try {
      occu=Double.parseDouble(line.substring(54,60).trim());
    }
 catch (    NumberFormatException e) {
    }
  }
  double tempf=0.0;
  if (line.length() > 65) {
    try {
      tempf=Double.parseDouble(line.substring(60,66).trim());
    }
 catch (    NumberFormatException e) {
    }
  }
  atom.setOccupancy(occu);
  atom.setTempFactor(tempf);
  Element element=Element.R;
  if (line.length() > 77) {
    try {
      element=Element.valueOfIgnoreCase(line.substring(76,78).trim());
    }
 catch (    IllegalArgumentException e) {
    }
  }
 else {
    String elementSymbol=null;
    if (fullname.trim().length() == 4) {
      elementSymbol=fullname.substring(0,1);
    }
 else     if (fullname.trim().length() > 1) {
      elementSymbol=fullname.substring(0,2).trim();
    }
 else {
      elementSymbol=""String_Node_Str"";
    }
    try {
      element=Element.valueOfIgnoreCase(elementSymbol);
    }
 catch (    IllegalArgumentException e) {
    }
  }
  atom.setElement(element);
  if (altGroup != null) {
    altGroup.addAtom(atom);
    altGroup=null;
  }
 else {
    current_group.addAtom(atom);
  }
  if (!current_group.hasAtom(atom.getName())) {
    current_group.addAtom(atom);
  }
}","/** 
 * Handler for ATOM Record Format <pre> ATOM      1  N   ASP A  15     110.964  24.941  59.191  1.00 83.44           N COLUMNS        DATA TYPE       FIELD         DEFINITION --------------------------------------------------------------------------------- 1 -  6        Record name     ""ATOM  "" 7 - 11        Integer         serial        Atom serial number. 13 - 16        Atom            name          Atom name. 17             Character       altLoc        Alternate location indicator. 18 - 20        Residue name    resName       Residue name. 22             Character       chainID       Chain identifier. 23 - 26        Integer         resSeq        Residue sequence number. 27             AChar           iCode         Code for insertion of residues. 31 - 38        Real(8.3)       x             Orthogonal coordinates for X in Angstroms. 39 - 46        Real(8.3)       y             Orthogonal coordinates for Y in Angstroms. 47 - 54        Real(8.3)       z             Orthogonal coordinates for Z in Angstroms. 55 - 60        Real(6.2)       occupancy     Occupancy. 61 - 66        Real(6.2)       tempFactor    Temperature factor. 73 - 76        LString(4)      segID         Segment identifier, left-justified. 77 - 78        LString(2)      element       Element symbol, right-justified. 79 - 80        LString(2)      charge        Charge on the atom. </pre>
 */
private void pdb_ATOM_Handler(String line){
  boolean startOfNewChain=false;
  String chain_id=line.substring(21,22);
  if (current_chain == null) {
    current_chain=new ChainImpl();
    current_chain.setChainID(chain_id);
    startOfNewChain=true;
    current_model.add(current_chain);
  }
  if (!chain_id.equals(current_chain.getChainID())) {
    startOfNewChain=true;
    current_chain.addGroup(current_group);
    Chain testchain;
    testchain=isKnownChain(current_chain.getChainID(),current_model);
    if (testchain != null && testchain.getChainID().equals(chain_id)) {
    }
 else {
      testchain=isKnownChain(chain_id,current_model);
    }
    if (testchain == null) {
      current_chain=new ChainImpl();
      current_chain.setChainID(chain_id);
    }
 else {
      current_chain=testchain;
    }
    if (!current_model.contains(current_chain))     current_model.add(current_chain);
  }
  String recordName=line.substring(0,6).trim();
  String groupCode3=line.substring(17,20).trim();
  String resNum=line.substring(22,26).trim();
  Character iCode=line.substring(26,27).charAt(0);
  if (iCode == ' ')   iCode=null;
  ResidueNumber residueNumber=new ResidueNumber(chain_id,Integer.valueOf(resNum),iCode);
  Character aminoCode1=null;
  if (recordName.equals(""String_Node_Str"")) {
    aminoCode1=StructureTools.get1LetterCode(groupCode3);
  }
 else {
    aminoCode1=StructureTools.get1LetterCode(groupCode3);
    if (aminoCode1 != null)     if (aminoCode1.equals(StructureTools.UNKNOWN_GROUP_LABEL))     aminoCode1=null;
  }
  if (current_group == null) {
    current_group=getNewGroup(recordName,aminoCode1,groupCode3);
    current_group.setPDBName(groupCode3);
    current_group.setResidueNumber(residueNumber);
    addTohetGroupsDecider(current_group);
  }
  if (startOfNewChain) {
    current_group=getNewGroup(recordName,aminoCode1,groupCode3);
    current_group.setPDBName(groupCode3);
    current_group.setResidueNumber(residueNumber);
    addTohetGroupsDecider(current_group);
  }
  Character altLoc=new Character(line.substring(16,17).charAt(0));
  Group altGroup=null;
  if (!residueNumber.equals(current_group.getResidueNumber())) {
    current_chain.addGroup(current_group);
    current_group.trimToSize();
    current_group=getNewGroup(recordName,aminoCode1,groupCode3);
    current_group.setPDBName(groupCode3);
    current_group.setResidueNumber(residueNumber);
    addTohetGroupsDecider(current_group);
  }
 else {
    if (!altLoc.equals(' ')) {
      logger.debug(""String_Node_Str"" + current_group + ""String_Node_Str""+ altGroup);
      altGroup=getCorrectAltLocGroup(altLoc,recordName,aminoCode1,groupCode3);
      if (altGroup.getChain() == null) {
        altGroup.setChain(current_chain);
      }
    }
  }
  if (params.isHeaderOnly())   return;
  atomCount++;
  if (atomCount == my_ATOM_CA_THRESHOLD) {
    logger.warn(""String_Node_Str"" + my_ATOM_CA_THRESHOLD + ""String_Node_Str"");
    seqResChains.clear();
    switchCAOnly();
  }
  if (atomCount == load_max_atoms) {
    logger.warn(""String_Node_Str"" + load_max_atoms + ""String_Node_Str"");
    logger.warn(""String_Node_Str"" + line);
    return;
  }
  if (atomCount > load_max_atoms) {
    return;
  }
  String fullname=line.substring(12,16);
  if (parseCAonly) {
    if (!fullname.equals(""String_Node_Str"")) {
      atomCount--;
      return;
    }
  }
  if (params.getAcceptedAtomNames() != null) {
    boolean found=false;
    for (    String ok : params.getAcceptedAtomNames()) {
      if (ok.equals(fullname.trim())) {
        found=true;
        break;
      }
    }
    if (!found) {
      atomCount--;
      return;
    }
  }
  int pdbnumber=Integer.parseInt(line.substring(6,11).trim());
  AtomImpl atom=new AtomImpl();
  atom.setPDBserial(pdbnumber);
  atom.setAltLoc(altLoc);
  atom.setName(fullname.trim());
  double x=Double.parseDouble(line.substring(30,38).trim());
  double y=Double.parseDouble(line.substring(38,46).trim());
  double z=Double.parseDouble(line.substring(46,54).trim());
  double[] coords=new double[3];
  coords[0]=x;
  coords[1]=y;
  coords[2]=z;
  atom.setCoords(coords);
  double occu=1.0;
  if (line.length() > 59) {
    try {
      occu=Double.parseDouble(line.substring(54,60).trim());
    }
 catch (    NumberFormatException e) {
    }
  }
  double tempf=0.0;
  if (line.length() > 65) {
    try {
      tempf=Double.parseDouble(line.substring(60,66).trim());
    }
 catch (    NumberFormatException e) {
    }
  }
  atom.setOccupancy(occu);
  atom.setTempFactor(tempf);
  Element element=Element.R;
  if (line.length() > 77) {
    try {
      element=Element.valueOfIgnoreCase(line.substring(76,78).trim());
    }
 catch (    IllegalArgumentException e) {
    }
  }
 else {
    String elementSymbol=null;
    if (fullname.trim().length() == 4) {
      elementSymbol=fullname.substring(0,1);
    }
 else     if (fullname.trim().length() > 1) {
      elementSymbol=fullname.substring(0,2).trim();
    }
 else {
      elementSymbol=""String_Node_Str"";
    }
    try {
      element=Element.valueOfIgnoreCase(elementSymbol);
    }
 catch (    IllegalArgumentException e) {
    }
  }
  atom.setElement(element);
  if (altGroup != null) {
    altGroup.addAtom(atom);
    altGroup=null;
  }
 else {
    current_group.addAtom(atom);
  }
  if (!current_group.hasAtom(atom.getName())) {
    current_group.addAtom(atom);
  }
}",0.9994792828981626
16685,"@Override public void newAtomSite(AtomSite atom){
  boolean startOfNewChain=false;
  String chain_id=atom.getLabel_asym_id();
  String recordName=atom.getGroup_PDB();
  String residueNumberS=atom.getAuth_seq_id();
  Integer residueNrInt=Integer.parseInt(residueNumberS);
  String groupCode3=atom.getLabel_comp_id();
  if (groupCode3.length() == 1) {
    groupCode3=""String_Node_Str"" + groupCode3;
  }
  if (groupCode3.length() == 2) {
    groupCode3=""String_Node_Str"" + groupCode3;
  }
  Character aminoCode1=null;
  if (recordName.equals(""String_Node_Str""))   aminoCode1=StructureTools.get1LetterCodeAmino(groupCode3);
 else {
    aminoCode1=StructureTools.get1LetterCodeAmino(groupCode3);
    if (aminoCode1 != null && aminoCode1.equals(StructureTools.UNKNOWN_GROUP_LABEL))     aminoCode1=null;
  }
  String insCodeS=atom.getPdbx_PDB_ins_code();
  Character insCode=null;
  if (!insCodeS.equals(""String_Node_Str"")) {
    insCode=insCodeS.charAt(0);
  }
  long seq_id=-1;
  try {
    seq_id=Long.parseLong(atom.getLabel_seq_id());
  }
 catch (  NumberFormatException e) {
  }
  String nmrModel=atom.getPdbx_PDB_model_num();
  if (current_nmr_model == null) {
    current_nmr_model=nmrModel;
  }
  if (!current_nmr_model.equals(nmrModel)) {
    current_nmr_model=nmrModel;
    if (current_chain != null) {
      current_chain.addGroup(current_group);
      current_group.trimToSize();
    }
    structure.addModel(current_model);
    current_model=new ArrayList<Chain>();
    current_chain=null;
    current_group=null;
  }
  if (current_chain == null) {
    current_chain=new ChainImpl();
    current_chain.setChainID(chain_id);
    current_model.add(current_chain);
    startOfNewChain=true;
  }
  if (!chain_id.equals(current_chain.getChainID())) {
    startOfNewChain=true;
    current_chain.addGroup(current_group);
    Chain testchain;
    testchain=isKnownChain(current_chain.getChainID(),current_model);
    if (testchain != null && testchain.getChainID().equals(chain_id)) {
    }
 else {
      testchain=isKnownChain(chain_id,current_model);
    }
    if (testchain == null) {
      current_chain=new ChainImpl();
      current_chain.setChainID(chain_id);
    }
 else {
      current_chain=testchain;
    }
    if (!current_model.contains(current_chain))     current_model.add(current_chain);
  }
  ResidueNumber residueNumber=new ResidueNumber(chain_id,residueNrInt,insCode);
  if (current_group == null) {
    current_group=getNewGroup(recordName,aminoCode1,seq_id,groupCode3);
    current_group.setResidueNumber(residueNumber);
    current_group.setPDBName(groupCode3);
  }
  if (startOfNewChain) {
    current_group=getNewGroup(recordName,aminoCode1,seq_id,groupCode3);
    current_group.setResidueNumber(residueNumber);
    current_group.setPDBName(groupCode3);
  }
  Group altGroup=null;
  String altLocS=atom.getLabel_alt_id();
  Character altLoc=' ';
  if (altLocS.length() > 0) {
    altLoc=altLocS.charAt(0);
    if (altLoc.equals('.'))     altLoc=' ';
  }
  if (!residueNumber.equals(current_group.getResidueNumber())) {
    current_chain.addGroup(current_group);
    current_group.trimToSize();
    current_group=getNewGroup(recordName,aminoCode1,seq_id,groupCode3);
    current_group.setPDBName(groupCode3);
    current_group.setResidueNumber(residueNumber);
  }
 else {
    if (!altLoc.equals(' ') && (!altLoc.equals('.'))) {
      logger.debug(""String_Node_Str"" + altLoc + ""String_Node_Str""+ current_group+ ""String_Node_Str""+ altGroup);
      altGroup=getCorrectAltLocGroup(altLoc,recordName,aminoCode1,groupCode3,seq_id);
      if (altGroup.getChain() == null) {
        altGroup.setChain(current_chain);
      }
    }
  }
  if (params.isHeaderOnly())   return;
  if (params.isParseCAOnly()) {
    if (!(atom.getLabel_atom_id().equals(StructureTools.CA_ATOM_NAME) && atom.getType_symbol().equals(""String_Node_Str""))) {
      return;
    }
  }
  asymId2StrandIdFromAtomSites.put(atom.getLabel_asym_id(),atom.getAuth_asym_id());
  Atom a=convertAtom(atom);
  if (altGroup != null) {
    altGroup.addAtom(a);
    altGroup=null;
  }
 else {
    current_group.addAtom(a);
  }
  if (!current_group.hasAtom(a.getName())) {
    current_group.addAtom(a);
  }
}","@Override public void newAtomSite(AtomSite atom){
  boolean startOfNewChain=false;
  String chain_id=atom.getLabel_asym_id();
  String recordName=atom.getGroup_PDB();
  String residueNumberS=atom.getAuth_seq_id();
  Integer residueNrInt=Integer.parseInt(residueNumberS);
  String groupCode3=atom.getLabel_comp_id();
  Character aminoCode1=null;
  if (recordName.equals(""String_Node_Str""))   aminoCode1=StructureTools.get1LetterCodeAmino(groupCode3);
 else {
    aminoCode1=StructureTools.get1LetterCodeAmino(groupCode3);
    if (aminoCode1 != null && aminoCode1.equals(StructureTools.UNKNOWN_GROUP_LABEL))     aminoCode1=null;
  }
  String insCodeS=atom.getPdbx_PDB_ins_code();
  Character insCode=null;
  if (!insCodeS.equals(""String_Node_Str"")) {
    insCode=insCodeS.charAt(0);
  }
  long seq_id=-1;
  try {
    seq_id=Long.parseLong(atom.getLabel_seq_id());
  }
 catch (  NumberFormatException e) {
  }
  String nmrModel=atom.getPdbx_PDB_model_num();
  if (current_nmr_model == null) {
    current_nmr_model=nmrModel;
  }
  if (!current_nmr_model.equals(nmrModel)) {
    current_nmr_model=nmrModel;
    if (current_chain != null) {
      current_chain.addGroup(current_group);
      current_group.trimToSize();
    }
    structure.addModel(current_model);
    current_model=new ArrayList<Chain>();
    current_chain=null;
    current_group=null;
  }
  if (current_chain == null) {
    current_chain=new ChainImpl();
    current_chain.setChainID(chain_id);
    current_model.add(current_chain);
    startOfNewChain=true;
  }
  if (!chain_id.equals(current_chain.getChainID())) {
    startOfNewChain=true;
    current_chain.addGroup(current_group);
    Chain testchain;
    testchain=isKnownChain(current_chain.getChainID(),current_model);
    if (testchain != null && testchain.getChainID().equals(chain_id)) {
    }
 else {
      testchain=isKnownChain(chain_id,current_model);
    }
    if (testchain == null) {
      current_chain=new ChainImpl();
      current_chain.setChainID(chain_id);
    }
 else {
      current_chain=testchain;
    }
    if (!current_model.contains(current_chain))     current_model.add(current_chain);
  }
  ResidueNumber residueNumber=new ResidueNumber(chain_id,residueNrInt,insCode);
  if (current_group == null) {
    current_group=getNewGroup(recordName,aminoCode1,seq_id,groupCode3);
    current_group.setResidueNumber(residueNumber);
    current_group.setPDBName(groupCode3);
  }
  if (startOfNewChain) {
    current_group=getNewGroup(recordName,aminoCode1,seq_id,groupCode3);
    current_group.setResidueNumber(residueNumber);
    current_group.setPDBName(groupCode3);
  }
  Group altGroup=null;
  String altLocS=atom.getLabel_alt_id();
  Character altLoc=' ';
  if (altLocS.length() > 0) {
    altLoc=altLocS.charAt(0);
    if (altLoc.equals('.'))     altLoc=' ';
  }
  if (!residueNumber.equals(current_group.getResidueNumber())) {
    current_chain.addGroup(current_group);
    current_group.trimToSize();
    current_group=getNewGroup(recordName,aminoCode1,seq_id,groupCode3);
    current_group.setPDBName(groupCode3);
    current_group.setResidueNumber(residueNumber);
  }
 else {
    if (!altLoc.equals(' ') && (!altLoc.equals('.'))) {
      logger.debug(""String_Node_Str"" + altLoc + ""String_Node_Str""+ current_group+ ""String_Node_Str""+ altGroup);
      altGroup=getCorrectAltLocGroup(altLoc,recordName,aminoCode1,groupCode3,seq_id);
      if (altGroup.getChain() == null) {
        altGroup.setChain(current_chain);
      }
    }
  }
  if (params.isHeaderOnly())   return;
  if (params.isParseCAOnly()) {
    if (!(atom.getLabel_atom_id().equals(StructureTools.CA_ATOM_NAME) && atom.getType_symbol().equals(""String_Node_Str""))) {
      return;
    }
  }
  asymId2StrandIdFromAtomSites.put(atom.getLabel_asym_id(),atom.getAuth_asym_id());
  Atom a=convertAtom(atom);
  if (altGroup != null) {
    altGroup.addAtom(a);
    altGroup=null;
  }
 else {
    current_group.addAtom(a);
  }
  if (!current_group.hasAtom(a.getName())) {
    current_group.addAtom(a);
  }
}",0.979227761485826
16686,"/** 
 * Return a list of pdb Strings corresponding to the aligned positions of the molecule. <p>  Adapted the method to a more general version for the multiple alignments,  using the MultipleAlignment DS.
 * @param aligPos
 * @param multAln
 * @param ca
 */
public static final List<String> getPDBresnum(int structNum,MultipleAlignment multAln,Atom[] ca){
  List<String> lst=new ArrayList<String>();
  for (  BlockSet bs : multAln.getBlockSets()) {
    for (    Block block : bs.getBlocks()) {
      for (int i=0; i < block.length(); i++) {
        Integer pos=block.getAlignRes().get(structNum).get(i);
        if (pos == null)         continue;
 else         if (pos < ca.length) {
          String pdbInfo=JmolTools.getPdbInfo(ca[pos]);
          lst.add(pdbInfo);
        }
      }
    }
  }
  return lst;
}","/** 
 * Return a list of pdb Strings corresponding to the aligned positions of the molecule.  Only supports a pairwise alignment with the AFPChain DS.
 * @param aligPos
 * @param afpChain
 * @param ca
 */
public static final List<String> getPDBresnum(int aligPos,AFPChain afpChain,Atom[] ca){
  List<String> lst=new ArrayList<String>();
  if (aligPos > 1) {
    System.err.println(""String_Node_Str"");
    return lst;
  }
  int blockNum=afpChain.getBlockNum();
  int[] optLen=afpChain.getOptLen();
  int[][][] optAln=afpChain.getOptAln();
  if (optLen == null)   return lst;
  for (int bk=0; bk < blockNum; bk++) {
    for (int i=0; i < optLen[bk]; i++) {
      int pos=optAln[bk][aligPos][i];
      if (pos < ca.length) {
        String pdbInfo=JmolTools.getPdbInfo(ca[pos]);
        lst.add(pdbInfo);
      }
    }
  }
  return lst;
}",0.5078979343863913
16687,"/** 
 * Given an aligned position in the sequence alignment, it returns the Atom that corresponds. It does not support gaps in the multiple alignment right now!
 * @param multAln the alignment information
 * @param str the structure
 * @param pos the position in the sequence alignment
 * @return Atom the aligned atom
 * @throws StructureAlignmentException if the atoms cannot be obtained
 */
@Deprecated public static Atom getAtomForAligPos(MultipleAlignment multAln,int str,int pos) throws StructureAlignmentException {
  List<Integer> residues=new ArrayList<Integer>();
  for (  BlockSet bs : multAln.getBlockSets()) {
    for (    Block b : bs.getBlocks())     residues.addAll(b.getAlignRes().get(str));
  }
  if (residues.size() == 0)   return null;
  String sequence=MultipleAlignmentTools.getSequenceAlignment(multAln).get(str);
  int aligpos=0;
  for (int i=0; i < pos; i++) {
    if (sequence.charAt(i) != '-')     aligpos++;
  }
  int capos=residues.get(aligpos);
  if (capos < 0 || capos > multAln.getEnsemble().getAtomArrays().get(str).length)   return null;
  return multAln.getEnsemble().getAtomArrays().get(str)[capos];
}","/** 
 * return the atom at alignment position aligPos. at the present only works with block 0
 * @param chainNr the number of the aligned pair. 0... first chain, 1... second chain.
 * @param afpChain an afpChain object
 * @param aligPos position on the alignment
 * @param getPrevious gives the previous position if false, gives the next posible atom
 * @return a CA atom that is at a particular position of the alignment 
 */
public static final Atom getAtomForAligPos(AFPChain afpChain,int chainNr,int aligPos,Atom[] ca,boolean getPrevious) throws StructureException {
  int[] optLen=afpChain.getOptLen();
  if (optLen == null)   return null;
  if (chainNr < 0 || chainNr > 1) {
    throw new StructureException(""String_Node_Str"" + chainNr);
  }
  int capos=getUngappedFatCatPos(afpChain,chainNr,aligPos);
  if (capos < 0) {
    capos=getNextFatCatPos(afpChain,chainNr,aligPos,getPrevious);
  }
 else {
  }
  if (capos < 0) {
    System.err.println(""String_Node_Str"" + aligPos + ""String_Node_Str""+ chainNr+ ""String_Node_Str"");
    return null;
  }
  if (capos > ca.length) {
    System.err.println(""String_Node_Str"" + chainNr + ""String_Node_Str""+ capos+ ""String_Node_Str"");
    return null;
  }
  return ca[capos];
}",0.0959660297239915
16688,"@Override public void actionPerformed(ActionEvent e){
  String cmd=e.getActionCommand();
  if (cmd.equals(MenuCreator.TEXT_ONLY)) {
    if (multAln == null) {
      System.err.println(""String_Node_Str"");
      return;
    }
    System.out.println(""String_Node_Str"");
  }
 else   if (cmd.equals(MenuCreator.PAIRS_ONLY)) {
    if (multAln == null) {
      System.err.println(""String_Node_Str"");
      return;
    }
    System.out.println(""String_Node_Str"");
  }
 else   if (cmd.equals(MenuCreator.ALIGNMENT_PANEL)) {
    if (multAln == null) {
      System.err.println(""String_Node_Str"");
      return;
    }
    try {
      DisplayAFP.showAlignmentImage(multAln,this,colors);
    }
 catch (    StructureAlignmentException e1) {
      e1.printStackTrace();
    }
catch (    StructureException e1) {
      e1.printStackTrace();
    }
  }
 else   if (cmd.equals(MenuCreator.FATCAT_TEXT)) {
    if (multAln == null) {
      System.err.println(""String_Node_Str"");
      return;
    }
    System.out.println(""String_Node_Str"");
  }
}","@Override public void actionPerformed(ActionEvent e){
  String cmd=e.getActionCommand();
  if (cmd.equals(MenuCreator.TEXT_ONLY)) {
    if (multAln == null) {
      System.err.println(""String_Node_Str"");
      return;
    }
    System.out.println(""String_Node_Str"");
  }
 else   if (cmd.equals(MenuCreator.PAIRS_ONLY)) {
    if (multAln == null) {
      System.err.println(""String_Node_Str"");
      return;
    }
    System.out.println(""String_Node_Str"");
  }
 else   if (cmd.equals(MenuCreator.ALIGNMENT_PANEL)) {
    if (multAln == null) {
      System.err.println(""String_Node_Str"");
      return;
    }
    try {
      MultipleAlignmentDisplay.showMultipleAligmentPanel(multAln,this,colors);
    }
 catch (    StructureAlignmentException e1) {
      e1.printStackTrace();
    }
catch (    StructureException e1) {
      e1.printStackTrace();
    }
  }
 else   if (cmd.equals(MenuCreator.FATCAT_TEXT)) {
    if (multAln == null) {
      System.err.println(""String_Node_Str"");
      return;
    }
    System.out.println(""String_Node_Str"");
  }
}",0.9696092619392184
16689,"/** 
 * Generate a Jmol command String that colors the aligned residues of every structure.
 * @param multAln
 * @param atomArrays
 * @throws StructureAlignmentException 
 */
private static String getJmolString(MultipleAlignment multAln,List<Atom[]> atomArrays,Color[] colors) throws StructureAlignmentException {
  if (multAln.getBlockSets().size() > 1)   return getMultiBlockJmolString(multAln,atomArrays,colors);
 else   if (multAln.getBlockSets().get(0).getBlocks().size() > 1)   return getMultiBlockJmolString(multAln,atomArrays,colors);
  StringBuffer j=new StringBuffer();
  j.append(DEFAULT_SCRIPT);
  StringBuffer sel=new StringBuffer();
  sel.append(""String_Node_Str"");
  List<List<String>> allPDB=new ArrayList<List<String>>();
  for (int i=0; i < multAln.size(); i++) {
    List<String> pdb=DisplayAFP.getPDBresnum(i,multAln,atomArrays.get(i));
    allPDB.add(pdb);
    sel.append(""String_Node_Str"");
    int pos=0;
    for (    String res : pdb) {
      if (pos > 0)       sel.append(""String_Node_Str"");
      pos++;
      sel.append(res);
      sel.append(""String_Node_Str"" + (i + 1));
    }
    if (pos == 0)     sel.append(""String_Node_Str"");
    sel.append(""String_Node_Str"" + colors[i].getRed() + ""String_Node_Str""+ colors[i].getGreen()+ ""String_Node_Str""+ colors[i].getBlue()+ ""String_Node_Str"");
  }
  j.append(sel);
  j.append(""String_Node_Str"");
  j.append(LIGAND_DISPLAY_SCRIPT);
  StringBuffer buf=new StringBuffer(""String_Node_Str"");
  for (int i=0; i < multAln.size(); i++) {
    int count=0;
    for (    String res : allPDB.get(i)) {
      if (count > 0)       buf.append(""String_Node_Str"");
      buf.append(res);
      buf.append(""String_Node_Str"" + (i + 1));
      count++;
    }
    if (i != multAln.size() - 1)     buf.append(""String_Node_Str"");
  }
  j.append(buf);
  return j.toString();
}","/** 
 * Generate a Jmol command String that colors the aligned residues of every structure.
 * @param multAln
 * @param atomArrays
 * @throws StructureAlignmentException 
 */
private static String getJmolString(MultipleAlignment multAln,List<Atom[]> atomArrays,Color[] colors) throws StructureAlignmentException {
  if (multAln.getBlockSets().size() > 1)   return getMultiBlockJmolString(multAln,atomArrays,colors);
 else   if (multAln.getBlockSets().get(0).getBlocks().size() > 1)   return getMultiBlockJmolString(multAln,atomArrays,colors);
  StringBuffer j=new StringBuffer();
  j.append(DEFAULT_SCRIPT);
  StringBuffer sel=new StringBuffer();
  sel.append(""String_Node_Str"");
  List<List<String>> allPDB=new ArrayList<List<String>>();
  for (int i=0; i < multAln.size(); i++) {
    List<String> pdb=MultipleAlignmentDisplay.getPDBresnum(i,multAln,atomArrays.get(i));
    allPDB.add(pdb);
    sel.append(""String_Node_Str"");
    int pos=0;
    for (    String res : pdb) {
      if (pos > 0)       sel.append(""String_Node_Str"");
      pos++;
      sel.append(res);
      sel.append(""String_Node_Str"" + (i + 1));
    }
    if (pos == 0)     sel.append(""String_Node_Str"");
    sel.append(""String_Node_Str"" + colors[i].getRed() + ""String_Node_Str""+ colors[i].getGreen()+ ""String_Node_Str""+ colors[i].getBlue()+ ""String_Node_Str"");
  }
  j.append(sel);
  j.append(""String_Node_Str"");
  j.append(LIGAND_DISPLAY_SCRIPT);
  StringBuffer buf=new StringBuffer(""String_Node_Str"");
  for (int i=0; i < multAln.size(); i++) {
    int count=0;
    for (    String res : allPDB.get(i)) {
      if (count > 0)       buf.append(""String_Node_Str"");
      buf.append(res);
      buf.append(""String_Node_Str"" + (i + 1));
      count++;
    }
    if (i != multAln.size() - 1)     buf.append(""String_Node_Str"");
  }
  j.append(buf);
  return j.toString();
}",0.9945385035499726
16690,"/** 
 * Superimpose all structures in a BlockSet to the reference structure
 * @param alignment The MultipleAlignment object to superimpose.
 * @throws StructureAlignmentException 
 */
@Override public void superimpose(MultipleAlignment alignment) throws StructureException, StructureAlignmentException {
  if (alignment.getEnsemble() == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  List<Atom[]> atomArrays=alignment.getEnsemble().getAtomArrays();
  List<Block> blocks=alignment.getBlocks();
  if (blocks.size() < 1)   throw new StructureAlignmentException(""String_Node_Str"");
  if (reference < 0 || atomArrays.size() <= reference) {
    throw new IndexOutOfBoundsException(String.format(""String_Node_Str"",reference,atomArrays.size()));
  }
  List<Matrix4d> transforms=new ArrayList<Matrix4d>(atomArrays.size());
  double totalDistanceSq=0;
  double totalLength=0;
  double totalTM=0;
  for (int i=0; i < atomArrays.size(); i++) {
    if (i == reference) {
      Matrix4d ident=new Matrix4d();
      ident.setIdentity();
      transforms.add(ident);
      continue;
    }
    Atom[] ref=atomArrays.get(reference);
    Atom[] curr=atomArrays.get(i);
    List<Atom> atomSet1=new ArrayList<Atom>();
    List<Atom> atomSet2=new ArrayList<Atom>();
    for (    Block blk : blocks) {
      if (blk.size() != atomArrays.size()) {
        throw new StructureAlignmentException(String.format(""String_Node_Str"",atomArrays.size(),blk.size()));
      }
      for (int j=0; j < blk.length(); j++) {
        Integer pos1=blk.getAlignRes().get(0).get(j);
        Integer pos2=blk.getAlignRes().get(i).get(j);
        if (pos1 == null || pos2 == null)         continue;
        atomSet1.add(ref[pos1]);
        atomSet2.add(curr[pos2]);
      }
    }
    Atom[] array1=atomSet1.toArray(new Atom[atomSet1.size()]);
    Atom[] array2=atomSet2.toArray(new Atom[atomSet2.size()]);
    array2=StructureTools.cloneAtomArray(array2);
    SVDSuperimposer svd=new SVDSuperimposer(array1,array2);
    transforms.add(svd.getTransformation());
    double rmsd=SVDSuperimposer.getRMS(array1,array2);
    totalDistanceSq+=rmsd * rmsd * array1.length;
    totalLength+=array1.length;
    totalTM+=SVDSuperimposer.getTMScore(array1,array2,ref.length,curr.length);
  }
  alignment.setTransformations(transforms);
  for (  BlockSet bs : alignment.getBlockSets()) {
    bs.setTransformations(null);
  }
  alignment.putScore(""String_Node_Str"",totalDistanceSq / totalLength);
  alignment.putScore(""String_Node_Str"",totalTM / atomArrays.size());
}","/** 
 * Superimpose all structures in a MultipleAlignment to the reference structure. <p> This method only calculates and sets the transformation 4D matrices. If any score is needed it should be calculated and set separately afterwards with   {@link MultipleAlignmentScorer}.
 * @param alignment The MultipleAlignment object to superimpose.
 * @throws StructureAlignmentException 
 */
@Override public void superimpose(MultipleAlignment alignment) throws StructureException, StructureAlignmentException {
  if (alignment.getEnsemble() == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  List<Atom[]> atomArrays=alignment.getEnsemble().getAtomArrays();
  List<Block> blocks=alignment.getBlocks();
  if (blocks.size() < 1)   throw new StructureAlignmentException(""String_Node_Str"");
  if (reference < 0 || atomArrays.size() <= reference) {
    throw new IndexOutOfBoundsException(String.format(""String_Node_Str"",reference,atomArrays.size()));
  }
  List<Matrix4d> transforms=new ArrayList<Matrix4d>(atomArrays.size());
  for (int i=0; i < atomArrays.size(); i++) {
    if (i == reference) {
      Matrix4d ident=new Matrix4d();
      ident.setIdentity();
      transforms.add(ident);
      continue;
    }
    Atom[] ref=atomArrays.get(reference);
    Atom[] curr=atomArrays.get(i);
    List<Atom> atomSet1=new ArrayList<Atom>();
    List<Atom> atomSet2=new ArrayList<Atom>();
    for (    Block blk : blocks) {
      if (blk.size() != atomArrays.size()) {
        throw new StructureAlignmentException(String.format(""String_Node_Str"",atomArrays.size(),blk.size()));
      }
      for (int j=0; j < blk.length(); j++) {
        Integer pos1=blk.getAlignRes().get(0).get(j);
        Integer pos2=blk.getAlignRes().get(i).get(j);
        if (pos1 == null || pos2 == null)         continue;
        atomSet1.add(ref[pos1]);
        atomSet2.add(curr[pos2]);
      }
    }
    Atom[] array1=atomSet1.toArray(new Atom[atomSet1.size()]);
    Atom[] array2=atomSet2.toArray(new Atom[atomSet2.size()]);
    array2=StructureTools.cloneAtomArray(array2);
    SVDSuperimposer svd=new SVDSuperimposer(array1,array2);
    Calc.transform(array2,svd.getTransformation());
    transforms.add(svd.getTransformation());
  }
  alignment.setTransformations(transforms);
  for (  BlockSet bs : alignment.getBlockSets()) {
    bs.setTransformations(null);
  }
}",0.8343558282208589
16691,"/** 
 * show some info about this gui
 */
public static void showAboutDialog(){
  AboutDialog dialog=new AboutDialog();
  dialog.showDialog();
}","/** 
 * Show some info about this GUI
 */
public static void showAboutDialog(){
  AboutDialog dialog=new AboutDialog();
  dialog.showDialog();
}",0.9722222222222222
16692,"/** 
 * Create the menu for the ""Text Only"" representation of MultipleAlignments
 * @param frame
 * @param actionListener
 * @param multAln 
 * @return a JMenuBar
 */
public static JMenuBar getAlignmentTextMenu(JFrame frame,ActionListener actionListener,MultipleAlignment multAln){
  JMenuBar menu=new JMenuBar();
  JMenu file=new JMenu(""String_Node_Str"");
  file.getAccessibleContext().setAccessibleDescription(""String_Node_Str"");
  menu.add(file);
  ImageIcon saveicon=createImageIcon(""String_Node_Str"");
  JMenuItem saveF=null;
  if (saveicon != null)   saveF=new JMenuItem(""String_Node_Str"",saveicon);
 else   saveF=new JMenuItem(""String_Node_Str"");
  saveF.setMnemonic(KeyEvent.VK_S);
  MySaveFileListener listener=new MySaveFileListener(null);
  listener.setFatCatOutput(true);
  saveF.addActionListener(listener);
  file.add(saveF);
  file.addSeparator();
  JMenuItem print=getPrintMenuItem();
  print.addActionListener(actionListener);
  file.add(print);
  file.addSeparator();
  JMenuItem closeI=MenuCreator.getCloseMenuItem(frame);
  file.add(closeI);
  JMenuItem exitI=MenuCreator.getExitMenuItem();
  file.add(exitI);
  JMenu edit=new JMenu(""String_Node_Str"");
  edit.setMnemonic(KeyEvent.VK_E);
  menu.add(edit);
  JMenuItem eqrI=MenuCreator.getIcon(actionListener,SELECT_EQR);
  edit.add(eqrI);
  JMenuItem eqrcI=MenuCreator.getIcon(actionListener,EQR_COLOR);
  edit.add(eqrcI);
  JMenuItem simI=MenuCreator.getIcon(actionListener,SIMILARITY_COLOR);
  edit.add(simI);
  JMenuItem fatcatI=MenuCreator.getIcon(actionListener,FATCAT_BLOCK);
  edit.add(fatcatI);
  JMenu view=new JMenu(""String_Node_Str"");
  view.getAccessibleContext().setAccessibleDescription(""String_Node_Str"");
  view.setMnemonic(KeyEvent.VK_V);
  menu.add(view);
  JMenuItem fastaI=MenuCreator.getIcon(actionListener,FASTA_FORMAT);
  view.add(fastaI);
  JMenuItem pairsI=MenuCreator.getIcon(actionListener,PAIRS_ONLY);
  view.add(pairsI);
  JMenuItem textF=MenuCreator.getIcon(actionListener,FATCAT_TEXT);
  view.add(textF);
  JMenu about=new JMenu(""String_Node_Str"");
  about.setMnemonic(KeyEvent.VK_A);
  JMenuItem helpM=MenuCreator.getHelpMenuItem();
  about.add(helpM);
  JMenuItem aboutM=MenuCreator.getAboutMenuItem();
  about.add(aboutM);
  menu.add(Box.createGlue());
  menu.add(about);
  return menu;
}","/** 
 * Create the menu for the Text representations of Structural Alignments.
 * @param frame
 * @param actionListener
 * @param afpChain
 * @return a JMenuBar
 */
public static JMenuBar getAlignmentTextMenu(JFrame frame,ActionListener actionListener,AFPChain afpChain){
  JMenuBar menu=new JMenuBar();
  JMenu file=new JMenu(""String_Node_Str"");
  file.getAccessibleContext().setAccessibleDescription(""String_Node_Str"");
  menu.add(file);
  ImageIcon saveicon=createImageIcon(""String_Node_Str"");
  JMenuItem saveF=null;
  if (saveicon != null)   saveF=new JMenuItem(""String_Node_Str"",saveicon);
 else   saveF=new JMenuItem(""String_Node_Str"");
  saveF.setMnemonic(KeyEvent.VK_S);
  MySaveFileListener listener=new MySaveFileListener(afpChain);
  listener.setFatCatOutput(true);
  saveF.addActionListener(listener);
  file.add(saveF);
  file.addSeparator();
  JMenuItem print=getPrintMenuItem();
  print.addActionListener(actionListener);
  file.add(print);
  file.addSeparator();
  JMenuItem closeI=MenuCreator.getCloseMenuItem(frame);
  file.add(closeI);
  JMenuItem exitI=MenuCreator.getExitMenuItem();
  file.add(exitI);
  JMenu view=new JMenu(""String_Node_Str"");
  view.getAccessibleContext().setAccessibleDescription(""String_Node_Str"");
  view.setMnemonic(KeyEvent.VK_V);
  menu.add(view);
  JMenuItem textI=MenuCreator.getIcon(actionListener,TEXT_ONLY);
  view.add(textI);
  JMenuItem fastaI=MenuCreator.getIcon(actionListener,FASTA_FORMAT);
  view.add(fastaI);
  JMenuItem pairsI=MenuCreator.getIcon(actionListener,PAIRS_ONLY);
  view.add(pairsI);
  JMenuItem textF=MenuCreator.getIcon(actionListener,FATCAT_TEXT);
  view.add(textF);
  JMenu about=new JMenu(""String_Node_Str"");
  about.setMnemonic(KeyEvent.VK_A);
  JMenuItem helpM=MenuCreator.getHelpMenuItem();
  about.add(helpM);
  JMenuItem aboutM=MenuCreator.getAboutMenuItem();
  about.add(aboutM);
  menu.add(Box.createGlue());
  menu.add(about);
  return menu;
}",0.7428300545152879
16693,"/** 
 * Creates a new Frame with the MultipleAlignment Sequence Panel. The panel can communicate with the Jmol 3D visualization by selecting the aligned residues of all structures.
 * @param multAln
 * @param jmol
 * @param colors
 * @throws StructureException
 */
public static void showMultipleAligmentPanel(MultipleAlignment multAln,AbstractAlignmentJmol jmol,Color[] colors) throws StructureException {
  MultipleAligPanel me=new MultipleAligPanel(multAln,colors,jmol);
  JFrame frame=new JFrame();
  frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
  frame.setTitle(""String_Node_Str"");
  me.setPreferredSize(new Dimension(me.getCoordManager().getPreferredWidth(),me.getCoordManager().getPreferredHeight()));
  JMenuBar menu=MenuCreator.getAlignmentTextMenu(frame,me,multAln);
  frame.setJMenuBar(menu);
  JScrollPane scroll=new JScrollPane(me);
  scroll.setAutoscrolls(true);
  MultipleStatusDisplay status=new MultipleStatusDisplay(me);
  me.addAlignmentPositionListener(status);
  Box vBox=Box.createVerticalBox();
  vBox.add(scroll);
  vBox.add(status);
  frame.getContentPane().add(vBox);
  frame.pack();
  frame.setVisible(true);
  frame.addWindowListener(me);
  frame.addWindowListener(status);
}","/** 
 * Creates a new Frame with the MultipleAlignment Sequence Panel. The panel can communicate with the Jmol 3D visualization by selecting the aligned residues of all structures.
 * @param multAln
 * @param jmol
 * @param colors
 * @throws StructureException
 */
public static void showMultipleAligmentPanel(MultipleAlignment multAln,AbstractAlignmentJmol jmol,ColorBrewer colorPattelete) throws StructureException {
  MultipleAligPanel me=new MultipleAligPanel(multAln,jmol);
  JFrame frame=new JFrame();
  frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
  frame.setTitle(jmol.getTitle());
  me.setPreferredSize(new Dimension(me.getCoordManager().getPreferredWidth(),me.getCoordManager().getPreferredHeight()));
  JMenuBar menu=MenuCreator.getAlignmentPanelMenu(frame,me,null);
  frame.setJMenuBar(menu);
  JScrollPane scroll=new JScrollPane(me);
  scroll.setAutoscrolls(true);
  MultipleStatusDisplay status=new MultipleStatusDisplay(me);
  me.addAlignmentPositionListener(status);
  Box vBox=Box.createVerticalBox();
  vBox.add(scroll);
  vBox.add(status);
  frame.getContentPane().add(vBox);
  frame.pack();
  frame.setVisible(true);
  frame.addWindowListener(me);
  frame.addWindowListener(status);
}",0.9633895516248456
16694,"/** 
 * Creates a new Frame with the String output representation of the   {@link MultipleAlignment}.
 * @param multAln
 * @param result String output
 */
public static void showAlignmentImage(MultipleAlignment multAln,String result){
  JFrame frame=new JFrame();
  String title=multAln.getEnsemble().getAlgorithmName() + ""String_Node_Str"" + multAln.getEnsemble().getVersion();
  frame.setTitle(title);
  frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
  AlignmentTextPanel txtPanel=new AlignmentTextPanel();
  txtPanel.setText(result);
  JMenuBar menu=MenuCreator.getAlignmentTextMenu(frame,txtPanel,multAln);
  frame.setJMenuBar(menu);
  JScrollPane js=new JScrollPane();
  js.getViewport().add(txtPanel);
  js.getViewport().setBorder(null);
  frame.getContentPane().add(js);
  frame.pack();
  frame.setVisible(true);
}","/** 
 * Creates a new Frame with the String output representation of the   {@link MultipleAlignment}.
 * @param multAln
 * @param result String output
 */
public static void showAlignmentImage(MultipleAlignment multAln,String result){
  JFrame frame=new JFrame();
  String title=multAln.getEnsemble().getAlgorithmName() + ""String_Node_Str"" + multAln.getEnsemble().getVersion();
  frame.setTitle(title);
  frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
  AlignmentTextPanel txtPanel=new AlignmentTextPanel();
  txtPanel.setText(result);
  JMenuBar menu=MenuCreator.getAlignmentTextMenu(frame,txtPanel,null);
  frame.setJMenuBar(menu);
  JScrollPane js=new JScrollPane();
  js.getViewport().add(txtPanel);
  js.getViewport().setBorder(null);
  frame.getContentPane().add(js);
  frame.pack();
  frame.setVisible(true);
}",0.9933614966807484
16695,"@Override public void actionPerformed(ActionEvent arg0){
  System.out.println(""String_Node_Str"");
  if (parent == null) {
    System.err.println(""String_Node_Str"");
    return;
  }
  if (parent.getDisTable1() != null)   showMatrix(parent.getDisTable1(),""String_Node_Str"");
  if (parent.getDisTable2() != null)   showMatrix(parent.getDisTable2(),""String_Node_Str"");
}","@Override public void actionPerformed(ActionEvent a){
  System.out.println(""String_Node_Str"");
  if (parent.getDistanceMatrices() == null) {
    System.err.println(""String_Node_Str"");
    return;
  }
  for (int i=0; i < parent.getDistanceMatrices().size(); i++) {
    if (parent.getDistanceMatrices().get(i) != null)     showMatrix(parent.getDistanceMatrices().get(i),""String_Node_Str"" + (i + 1));
  }
}",0.6059817945383615
16696,"public MyDistMaxListener(AFPChain parent){
  this.parent=parent;
}","public MyDistMaxListener(AbstractAlignmentJmol parent){
  this.parent=parent;
}",0.8551724137931035
16697,"/** 
 * Constructor using a MultipleAlignment for any other kind of alignment. Default colors are used, so they might not correlate with the jmol coloring.
 * @param multAln
 * @param jmol
 */
public MultipleAligPanel(MultipleAlignment multAln,AbstractAlignmentJmol jmol){
  this(multAln,null,jmol);
}","/** 
 * Constructor using a MultipleAlignment.
 * @param multAln
 * @param colors
 */
public MultipleAligPanel(MultipleAlignment multAln,AbstractAlignmentJmol jmol){
  this();
  this.multAln=multAln;
  this.mapSeqToStruct=new ArrayList<Integer>();
  this.alnSeq=MultipleAlignmentTools.getSequenceAlignment(this.multAln,this.mapSeqToStruct);
  this.size=multAln.size();
  this.length=this.alnSeq.get(0).length();
  coordManager=new MultipleAlignmentCoordManager(size,length);
  this.jmol=jmol;
}",0.1509433962264151
16698,"@Override public void paintComponent(Graphics g){
  super.paintComponent(g);
  Graphics2D g2D=(Graphics2D)g;
  g2D.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
  g2D.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  int startpos=0;
  int endpos=length;
  String summary=multAln.toString();
  g2D.drawString(summary,20,coordManager.getSummaryPos());
  Color significantCol=Color.black;
  g2D.setPaint(significantCol);
  Rectangle sig=new Rectangle(10,10,10,10);
  g2D.fill(sig);
  for (int i=startpos; i < endpos; i++) {
    boolean isGapped=false;
    g2D.setFont(seqFont);
    if (mapSeqToStruct.get(i) != -1)     g2D.setFont(eqFont);
 else     isGapped=true;
    List<Point> points=new ArrayList<Point>();
    for (int str=0; str < size; str++)     points.add(coordManager.getPanelPos(str,i));
    Point p1=points.get(0);
    Point p2=points.get(points.size() - 1);
    for (int str=0; str < size; str++) {
      char c=alnSeq.get(str).charAt(i);
      Color bg=colors[str % colors.length];
      if (!isGapped) {
        if (colorBySimilarity) {
          boolean equal=true;
          boolean similar=true;
          for (int st=0; st < size - 1; st++) {
            char c1=alnSeq.get(st).charAt(i);
            char c2=alnSeq.get(st + 1).charAt(i);
            if (equal && c1 == c2)             continue;
 else             equal=false;
            if (AFPAlignmentDisplay.aaScore(c1,c2) > 0)             continue;
 else             similar=false;
            break;
          }
          if (equal)           bg=COLOR_EQUAL;
 else           if (similar)           bg=COLOR_SIMILAR;
 else           bg=Color.LIGHT_GRAY;
        }
 else         if (colorByAlignmentBlock) {
          int blockNr=MultipleAlignmentTools.getBlockForAligPos(multAln,mapSeqToStruct,i);
          double fraction=(blockNr * 1.0) / (multAln.getBlocks().size() + 1.0);
          bg=ColorUtils.darker(bg,fraction);
        }
        if (isSelected(i))         bg=Color.YELLOW;
        g2D.setPaint(bg);
        Rectangle rec=new Rectangle(points.get(str).x - 1,points.get(str).y - 11,(p2.x - p1.x) + 12,(p2.y - p1.y) / size);
        g2D.fill(rec);
      }
      g2D.setColor(Color.black);
      g2D.drawString(c + ""String_Node_Str"",points.get(str).x,points.get(str).y);
    }
  }
  int nrLines=length / MultipleAlignmentCoordManager.DEFAULT_LINE_LENGTH;
  for (int i=0; i < nrLines + 1; i++) {
    for (int str=0; str < size; str++) {
      Point p1=coordManager.getLegendPosition(i,str);
      int aligPos=i * MultipleAlignmentCoordManager.DEFAULT_LINE_LENGTH;
      Atom a1=MultipleAlignmentTools.getAtomForAligPos(multAln,mapSeqToStruct,str,aligPos);
      String label1=JmolTools.getPdbInfo(a1,false);
      g2D.drawString(label1,p1.x,p1.y);
      Point p3=coordManager.getEndLegendPosition(i,str);
      aligPos=i * MultipleAlignmentCoordManager.DEFAULT_LINE_LENGTH + MultipleAlignmentCoordManager.DEFAULT_LINE_LENGTH - 1;
      if (aligPos > length)       aligPos=length - 1;
      Atom a3=MultipleAlignmentTools.getAtomForAligPos(multAln,mapSeqToStruct,str,aligPos);
      String label3=JmolTools.getPdbInfo(a3,false);
      g2D.drawString(label3,p3.x,p3.y);
    }
  }
}","@Override public void paintComponent(Graphics g){
  super.paintComponent(g);
  Graphics2D g2D=(Graphics2D)g;
  g2D.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
  g2D.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  int startpos=0;
  int endpos=length;
  String summary=multAln.toString();
  g2D.drawString(summary,20,coordManager.getSummaryPos());
  Color significantCol=Color.black;
  g2D.setPaint(significantCol);
  Rectangle sig=new Rectangle(10,10,10,10);
  g2D.fill(sig);
  for (int i=startpos; i < endpos; i++) {
    boolean isGapped=false;
    g2D.setFont(seqFont);
    if (mapSeqToStruct.get(i) != -1)     g2D.setFont(eqFont);
 else     isGapped=true;
    List<Point> points=new ArrayList<Point>();
    for (int str=0; str < size; str++)     points.add(coordManager.getPanelPos(str,i));
    Point p1=points.get(0);
    Point p2=points.get(points.size() - 1);
    for (int str=0; str < size; str++) {
      char c=alnSeq.get(str).charAt(i);
      Color bg=jmol.getColorPattelete().getColorPalette(size)[str];
      if (!isGapped) {
        if (colorBySimilarity) {
          boolean equal=true;
          boolean similar=true;
          for (int st=0; st < size - 1; st++) {
            char c1=alnSeq.get(st).charAt(i);
            char c2=alnSeq.get(st + 1).charAt(i);
            if (equal && c1 == c2)             continue;
 else             equal=false;
            if (AFPAlignmentDisplay.aaScore(c1,c2) > 0)             continue;
 else             similar=false;
            break;
          }
          if (equal)           bg=COLOR_EQUAL;
 else           if (similar)           bg=COLOR_SIMILAR;
 else           bg=Color.LIGHT_GRAY;
        }
 else         if (colorByAlignmentBlock) {
          int blockNr=MultipleAlignmentTools.getBlockForAligPos(multAln,mapSeqToStruct,i);
          bg=jmol.getColorPattelete().getColorPalette(multAln.getBlocks().size())[blockNr];
        }
        if (isSelected(i))         bg=Color.YELLOW;
        if (Character.isUpperCase(c) && c != '-') {
          g2D.setPaint(bg);
          Rectangle rec=new Rectangle(points.get(str).x - 1,points.get(str).y - 11,(p2.x - p1.x) + 12,(p2.y - p1.y) / size);
          g2D.fill(rec);
        }
      }
      g2D.setColor(Color.black);
      g2D.drawString(c + ""String_Node_Str"",points.get(str).x,points.get(str).y);
    }
  }
  int nrLines=length / MultipleAlignmentCoordManager.DEFAULT_LINE_LENGTH;
  for (int i=0; i < nrLines + 1; i++) {
    for (int str=0; str < size; str++) {
      Point p1=coordManager.getLegendPosition(i,str);
      int aligPos=i * MultipleAlignmentCoordManager.DEFAULT_LINE_LENGTH;
      Atom a1=MultipleAlignmentTools.getAtomForAligPos(multAln,mapSeqToStruct,str,aligPos);
      String label1=JmolTools.getPdbInfo(a1,false);
      g2D.drawString(label1,p1.x,p1.y);
      Point p3=coordManager.getEndLegendPosition(i,str);
      aligPos=i * MultipleAlignmentCoordManager.DEFAULT_LINE_LENGTH + MultipleAlignmentCoordManager.DEFAULT_LINE_LENGTH - 1;
      if (aligPos > length)       aligPos=length - 1;
      Atom a3=MultipleAlignmentTools.getAtomForAligPos(multAln,mapSeqToStruct,str,aligPos);
      String label3=JmolTools.getPdbInfo(a3,false);
      g2D.drawString(label3,p3.x,p3.y);
    }
  }
}",0.9522064437318676
16699,"public static void main(String[] args) throws IOException, StructureException, StructureAlignmentException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AtomCache cache=new AtomCache();
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  for (  String name : names)   atomArrays.add(cache.getAtoms(name));
  MultipleAlignment fakeMultAln=fakeMultipleAlignment(""String_Node_Str"",atomArrays);
  FatCat fatcat=new FatCat();
  AFPChain afpChain=fatcat.alignRigid(atomArrays.get(0),atomArrays.get(1));
  MultipleAlignmentEnsemble ensemble=new MultipleAlignmentEnsembleImpl(afpChain,atomArrays.get(0),atomArrays.get(1));
  MultipleAlignment pairwise=ensemble.getMultipleAlignments().get(0);
  StructureAlignmentDisplay.display(fakeMultAln);
}","public static void main(String[] args) throws IOException, StructureException, StructureAlignmentException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AtomCache cache=new AtomCache();
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  for (  String name : names)   atomArrays.add(cache.getAtoms(name));
  MultipleAlignment fakeMultAln=fakeMultipleAlignment(""String_Node_Str"",atomArrays);
  fakeMultAln.getEnsemble().setStructureNames(names);
  FatCat fatcat=new FatCat();
  AFPChain afpChain=fatcat.alignRigid(atomArrays.get(0),atomArrays.get(1));
  MultipleAlignmentEnsemble ensemble=new MultipleAlignmentEnsembleImpl(afpChain,atomArrays.get(0),atomArrays.get(1));
  MultipleAlignment pairwise=ensemble.getMultipleAlignments().get(0);
  StructureAlignmentDisplay.display(fakeMultAln);
}",0.967509025270758
16700,"@Override public int size() throws StructureAlignmentException {
  if (structureNames == null)   throw new StructureAlignmentException(""String_Node_Str"");
 else   return structureNames.size();
}","@Override public int size() throws StructureAlignmentException {
  if (structureNames != null)   return structureNames.size();
 else   if (atomArrays != null)   return atomArrays.size();
 else   throw new StructureAlignmentException(""String_Node_Str"");
}",0.6964285714285714
16701,"/** 
 * Method that constructs a fake MultipleAlignment with two BlockSets, with two and one Blocks respectively. Used to test the correctness of the DataStructure. In the future it will be in the Test packages.
 * @param family name of the protein family
 * @param atomArrays
 * @return MultipleAlignment
 * @throws StructureException
 * @throws StructureAlignmentException
 */
private static MultipleAlignment fakeMultipleAlignment(String family,List<Atom[]> atomArrays) throws StructureException, StructureAlignmentException {
  MultipleAlignmentEnsemble ensemble=new MultipleAlignmentEnsembleImpl();
  ensemble.setAtomArrays(atomArrays);
  ensemble.setAlgorithmName(""String_Node_Str"");
  MultipleAlignment fakeMultAln=new MultipleAlignmentImpl(ensemble);
  if (family == ""String_Node_Str"") {
    BlockSet blockSet1=new BlockSetImpl(fakeMultAln);
    BlockSet blockSet2=new BlockSetImpl(fakeMultAln);
    Block block1=new BlockImpl(blockSet1);
    Block block2=new BlockImpl(blockSet1);
    Block block3=new BlockImpl(blockSet2);
    List<Integer> aligned11=Arrays.asList(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21);
    List<Integer> aligned12=Arrays.asList(29,30,31,32,33,34,35,36,37,38);
    List<Integer> aligned13=Arrays.asList(123,124,125,126,127,128,129,130,131,132,133,134);
    List<Integer> aligned21=Arrays.asList(10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,null,27,28,29,30,31);
    List<Integer> aligned22=Arrays.asList(39,40,41,42,43,44,45,46,47,48);
    List<Integer> aligned23=Arrays.asList(133,134,135,136,137,138,139,140,141,142,143,144);
    List<Integer> aligned31=Arrays.asList(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21);
    List<Integer> aligned32=Arrays.asList(29,30,31,32,33,34,35,36,37,38);
    List<Integer> aligned33=Arrays.asList(117,118,119,120,121,122,123,124,125,126,127,128);
    List<Integer> aligned41=Arrays.asList(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,null,17,18,19,20,21);
    List<Integer> aligned42=Arrays.asList(30,31,32,33,34,35,36,37,38,39);
    List<Integer> aligned43=Arrays.asList(121,122,123,124,125,126,127,128,129,130,131,132);
    block1.getAlignRes().add(aligned11);
    block1.getAlignRes().add(aligned21);
    block1.getAlignRes().add(aligned31);
    block1.getAlignRes().add(aligned41);
    block2.getAlignRes().add(aligned12);
    block2.getAlignRes().add(aligned22);
    block2.getAlignRes().add(aligned32);
    block2.getAlignRes().add(aligned42);
    block3.getAlignRes().add(aligned13);
    block3.getAlignRes().add(aligned23);
    block3.getAlignRes().add(aligned33);
    block3.getAlignRes().add(aligned43);
    fakeMultAln.updateCache(PoseMethod.REFERENCE);
  }
  return fakeMultAln;
}","/** 
 * Method that constructs a fake MultipleAlignment with two BlockSets, with two and one Blocks respectively. Used to test the correctness of the DataStructure. In the future it will be in the Test packages.
 * @param family name of the protein family
 * @param atomArrays
 * @return MultipleAlignment
 * @throws StructureException
 * @throws StructureAlignmentException
 */
private static MultipleAlignment fakeMultipleAlignment(String family,List<Atom[]> atomArrays) throws StructureException, StructureAlignmentException {
  MultipleAlignmentEnsemble ensemble=new MultipleAlignmentEnsembleImpl();
  ensemble.setAtomArrays(atomArrays);
  ensemble.setAlgorithmName(""String_Node_Str"");
  MultipleAlignment fakeMultAln=new MultipleAlignmentImpl(ensemble);
  if (family == ""String_Node_Str"") {
    BlockSet blockSet1=new BlockSetImpl(fakeMultAln);
    BlockSet blockSet2=new BlockSetImpl(fakeMultAln);
    Block block1=new BlockImpl(blockSet1);
    Block block2=new BlockImpl(blockSet1);
    Block block3=new BlockImpl(blockSet2);
    List<Integer> aligned11=Arrays.asList(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21);
    List<Integer> aligned12=Arrays.asList(29,30,31,32,33,34,35,36,37,38);
    List<Integer> aligned13=Arrays.asList(123,124,125,126,127,128,129,130,131,132,133,134);
    List<Integer> aligned21=Arrays.asList(10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,null,27,28,29,30,31);
    List<Integer> aligned22=Arrays.asList(39,40,41,42,43,44,45,46,47,48);
    List<Integer> aligned23=Arrays.asList(133,134,135,136,137,138,139,140,141,142,143,144);
    List<Integer> aligned31=Arrays.asList(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21);
    List<Integer> aligned32=Arrays.asList(29,30,31,32,33,34,35,36,37,38);
    List<Integer> aligned33=Arrays.asList(117,118,119,120,121,122,123,124,125,126,127,128);
    List<Integer> aligned41=Arrays.asList(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,null,17,18,19,20,21);
    List<Integer> aligned42=Arrays.asList(30,31,32,33,34,35,36,37,38,39);
    List<Integer> aligned43=Arrays.asList(121,122,123,124,125,126,127,128,129,130,131,132);
    block1.getAlignRes().add(aligned11);
    block1.getAlignRes().add(aligned21);
    block1.getAlignRes().add(aligned31);
    block1.getAlignRes().add(aligned41);
    block2.getAlignRes().add(aligned12);
    block2.getAlignRes().add(aligned22);
    block2.getAlignRes().add(aligned32);
    block2.getAlignRes().add(aligned42);
    block3.getAlignRes().add(aligned13);
    block3.getAlignRes().add(aligned23);
    block3.getAlignRes().add(aligned33);
    block3.getAlignRes().add(aligned43);
    MultipleSuperimposer imposer=new ReferenceSuperimposer();
    imposer.superimpose(fakeMultAln);
  }
  return fakeMultAln;
}",0.9687673258177786
16702,"public static void main(String[] args) throws IOException, StructureException, StructureAlignmentException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AtomCache cache=new AtomCache();
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  for (  String name : names)   atomArrays.add(cache.getAtoms(name));
  MultipleAlignment fakeMultAln=fakeMultipleAlignment(""String_Node_Str"",atomArrays);
  FatCat fatcat=new FatCat();
  AFPChain afpChain=fatcat.alignRigid(atomArrays.get(0),atomArrays.get(1));
  MultipleAlignment pairwise=new MultipleAlignmentImpl(afpChain,atomArrays.get(0),atomArrays.get(1));
  StructureAlignmentDisplay.display(fakeMultAln);
}","public static void main(String[] args) throws IOException, StructureException, StructureAlignmentException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AtomCache cache=new AtomCache();
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  for (  String name : names)   atomArrays.add(cache.getAtoms(name));
  MultipleAlignment fakeMultAln=fakeMultipleAlignment(""String_Node_Str"",atomArrays);
  FatCat fatcat=new FatCat();
  AFPChain afpChain=fatcat.alignRigid(atomArrays.get(0),atomArrays.get(1));
  MultipleAlignmentEnsemble ensemble=new MultipleAlignmentEnsembleImpl(afpChain,atomArrays.get(0),atomArrays.get(1));
  MultipleAlignment pairwise=ensemble.getMultipleAlignments().get(0);
  StructureAlignmentDisplay.display(fakeMultAln);
}",0.9277266754270695
16703,"/** 
 * Note: ca2, hetatoms2 and nucleotides2 should not be rotated. This will be done here...
 */
public static final StructureAlignmentJmol display(AFPChain afpChain,Group[] twistedGroups,Atom[] ca1,Atom[] ca2,List<Group> hetatms1,List<Group> hetatms2) throws StructureException {
  List<Atom> twistedAs=new ArrayList<Atom>();
  for (  Group g : twistedGroups) {
    if (g == null)     continue;
    if (g.size() < 1)     continue;
    Atom a=g.getAtom(0);
    twistedAs.add(a);
  }
  Atom[] twistedAtoms=(Atom[])twistedAs.toArray(new Atom[twistedAs.size()]);
  twistedAtoms=StructureTools.cloneAtomArray(twistedAtoms);
  Atom[] arr1=getAtomArray(ca1,hetatms1);
  Atom[] arr2=getAtomArray(twistedAtoms,hetatms2);
  String title=afpChain.getAlgorithmName() + ""String_Node_Str"" + afpChain.getVersion()+ ""String_Node_Str""+ afpChain.getName1()+ ""String_Node_Str""+ afpChain.getName2();
  StructureAlignmentJmol jmol=new StructureAlignmentJmol(afpChain,arr1,arr2);
  System.out.format(""String_Node_Str"",arr2[0].getX(),arr2[0].getY(),arr2[0].getZ());
  jmol.setTitle(title);
  return jmol;
}","/** 
 * Note: ca2, hetatoms2 and nucleotides2 should not be rotated. This will be done here...
 */
public static final StructureAlignmentJmol display(AFPChain afpChain,Group[] twistedGroups,Atom[] ca1,Atom[] ca2,List<Group> hetatms1,List<Group> hetatms2) throws StructureException {
  List<Atom> twistedAs=new ArrayList<Atom>();
  for (  Group g : twistedGroups) {
    if (g == null)     continue;
    if (g.size() < 1)     continue;
    Atom a=g.getAtom(0);
    twistedAs.add(a);
  }
  Atom[] twistedAtoms=twistedAs.toArray(new Atom[twistedAs.size()]);
  twistedAtoms=StructureTools.cloneAtomArray(twistedAtoms);
  Atom[] arr1=getAtomArray(ca1,hetatms1);
  Atom[] arr2=getAtomArray(twistedAtoms,hetatms2);
  String title=afpChain.getAlgorithmName() + ""String_Node_Str"" + afpChain.getVersion()+ ""String_Node_Str""+ afpChain.getName1()+ ""String_Node_Str""+ afpChain.getName2();
  StructureAlignmentJmol jmol=new StructureAlignmentJmol(afpChain,arr1,arr2);
  System.out.format(""String_Node_Str"",arr2[0].getX(),arr2[0].getY(),arr2[0].getZ());
  jmol.setTitle(title);
  return jmol;
}",0.9963031423290204
16704,"/** 
 * Return a list of pdb Strings corresponding to the aligned positions of the molecule.  Adapted the method to a more general version for the multiple alignments, using the MultipleAlignment DS.
 * @param aligPos
 * @param multAln
 * @param ca
 * @throws StructureAlignmentException 
 */
public static final List<String> getPDBresnum(int structNum,MultipleAlignment multAln,Atom[] ca) throws StructureAlignmentException {
  List<String> lst=new ArrayList<String>();
  for (int bs=0; bs < multAln.getBlockSetNum(); bs++) {
    for (int b=0; b < multAln.getBlockSets().get(bs).getBlockNum(); b++) {
      for (int i=0; i < multAln.getBlockSets().get(bs).getBlocks().get(b).length(); i++) {
        Block block=multAln.getBlockSets().get(bs).getBlocks().get(b);
        Integer pos=block.getAlignRes().get(structNum).get(i);
        if (pos == null)         continue;
 else         if (pos < ca.length) {
          String pdbInfo=JmolTools.getPdbInfo(ca[pos]);
          lst.add(pdbInfo);
        }
      }
    }
  }
  return lst;
}","/** 
 * Return a list of pdb Strings corresponding to the aligned positions of the molecule.  Adapted the method to a more general version for the multiple alignments, using the MultipleAlignment DS.
 * @param aligPos
 * @param multAln
 * @param ca
 * @throws StructureAlignmentException 
 */
public static final List<String> getPDBresnum(int structNum,MultipleAlignment multAln,Atom[] ca) throws StructureAlignmentException {
  List<String> lst=new ArrayList<String>();
  for (  BlockSet bs : multAln.getBlockSets()) {
    for (    Block block : bs.getBlocks()) {
      for (int i=0; i < block.length(); i++) {
        Integer pos=block.getAlignRes().get(structNum).get(i);
        if (pos == null)         continue;
 else         if (pos < ca.length) {
          String pdbInfo=JmolTools.getPdbInfo(ca[pos]);
          lst.add(pdbInfo);
        }
      }
    }
  }
  return lst;
}",0.802713987473904
16705,"/** 
 * Given an aligned position in the sequence alignment, it returns the Atom that corresponds. It does not support gaps in the multiple alignment right now!
 * @param multAln the alignment information
 * @param str the structure
 * @param pos the position in the sequence alignment
 * @return Atom the aligned atom
 * @throws StructureAlignmentException 
 */
public static Atom getAtomForAligPos(MultipleAlignment multAln,int str,int pos) throws StructureAlignmentException {
  List<Integer> residues=new ArrayList<Integer>();
  for (  BlockSet bs : multAln.getBlockSets()) {
    for (    Block b : bs.getBlocks())     residues.addAll(b.getAlignRes().get(str));
  }
  if (residues.size() == 0)   return null;
  String sequence=multAln.getAlnSequences().get(str);
  int aligpos=0;
  for (int i=0; i < pos; i++) {
    if (sequence.charAt(i) != '-')     aligpos++;
  }
  int capos=residues.get(aligpos);
  if (capos < 0 || capos > multAln.getParent().getAtomArrays().get(str).length)   return null;
  return multAln.getParent().getAtomArrays().get(str)[capos];
}","/** 
 * Given an aligned position in the sequence alignment, it returns the Atom that corresponds. It does not support gaps in the multiple alignment right now!
 * @param multAln the alignment information
 * @param str the structure
 * @param pos the position in the sequence alignment
 * @return Atom the aligned atom
 * @throws StructureAlignmentException 
 */
public static Atom getAtomForAligPos(MultipleAlignment multAln,int str,int pos) throws StructureAlignmentException {
  List<Integer> residues=new ArrayList<Integer>();
  for (  BlockSet bs : multAln.getBlockSets()) {
    for (    Block b : bs.getBlocks())     residues.addAll(b.getAlignRes().get(str));
  }
  if (residues.size() == 0)   return null;
  String sequence=multAln.getAlnSequences().get(str);
  int aligpos=0;
  for (int i=0; i < pos; i++) {
    if (sequence.charAt(i) != '-')     aligpos++;
  }
  int capos=residues.get(aligpos);
  if (capos < 0 || capos > multAln.getEnsemble().getAtomArrays().get(str).length)   return null;
  return multAln.getEnsemble().getAtomArrays().get(str)[capos];
}",0.9868544600938968
16706,"/** 
 * Returns the first atom for each group
 * @param ca
 * @param hetatms
 * @return
 * @throws StructureException
 */
public static final Atom[] getAtomArray(Atom[] ca,List<Group> hetatms) throws StructureException {
  List<Atom> atoms=new ArrayList<Atom>();
  Collections.addAll(atoms,ca);
  logger.debug(""String_Node_Str"",hetatms.size());
  for (  Group g : hetatms) {
    if (g.size() < 1)     continue;
    Atom a=g.getAtom(0);
    a.setGroup(g);
    atoms.add(a);
  }
  Atom[] arr=(Atom[])atoms.toArray(new Atom[atoms.size()]);
  return arr;
}","/** 
 * Returns the first atom for each group
 * @param ca
 * @param hetatms
 * @return
 * @throws StructureException
 */
public static final Atom[] getAtomArray(Atom[] ca,List<Group> hetatms) throws StructureException {
  List<Atom> atoms=new ArrayList<Atom>();
  Collections.addAll(atoms,ca);
  logger.debug(""String_Node_Str"",hetatms.size());
  for (  Group g : hetatms) {
    if (g.size() < 1)     continue;
    Atom a=g.getAtom(0);
    a.setGroup(g);
    atoms.add(a);
  }
  Atom[] arr=atoms.toArray(new Atom[atoms.size()]);
  return arr;
}",0.937956204379562
16707,"/** 
 * Create a ""fake"" Structure objects that contains the two sets of atoms aligned on top of each other.
 * @param afpChain the container of the alignment
 * @param ca1 atoms for protein 1
 * @param ca2 atoms for protein 2
 * @return a protein structure with 2 models.
 * @throws StructureException
 */
public static Structure createArtificalStructure(AFPChain afpChain,Atom[] ca1,Atom[] ca2) throws StructureException {
  if (afpChain.getNrEQR() < 1) {
    return DisplayAFP.getAlignedStructure(ca1,ca2);
  }
  Group[] twistedGroups=StructureAlignmentDisplay.prepareGroupsForDisplay(afpChain,ca1,ca2);
  List<Atom> twistedAs=new ArrayList<Atom>();
  for (  Group g : twistedGroups) {
    if (g == null)     continue;
    if (g.size() < 1)     continue;
    Atom a=g.getAtom(0);
    twistedAs.add(a);
  }
  Atom[] twistedAtoms=(Atom[])twistedAs.toArray(new Atom[twistedAs.size()]);
  List<Group> hetatms=StructureTools.getUnalignedGroups(ca1);
  List<Group> hetatms2=StructureTools.getUnalignedGroups(ca2);
  Atom[] arr1=DisplayAFP.getAtomArray(ca1,hetatms);
  Atom[] arr2=DisplayAFP.getAtomArray(twistedAtoms,hetatms2);
  Structure artificial=DisplayAFP.getAlignedStructure(arr1,arr2);
  return artificial;
}","/** 
 * Create a ""fake"" Structure objects that contains the two sets of atoms aligned on top of each other.
 * @param afpChain the container of the alignment
 * @param ca1 atoms for protein 1
 * @param ca2 atoms for protein 2
 * @return a protein structure with 2 models.
 * @throws StructureException
 */
public static Structure createArtificalStructure(AFPChain afpChain,Atom[] ca1,Atom[] ca2) throws StructureException {
  if (afpChain.getNrEQR() < 1) {
    return DisplayAFP.getAlignedStructure(ca1,ca2);
  }
  Group[] twistedGroups=StructureAlignmentDisplay.prepareGroupsForDisplay(afpChain,ca1,ca2);
  List<Atom> twistedAs=new ArrayList<Atom>();
  for (  Group g : twistedGroups) {
    if (g == null)     continue;
    if (g.size() < 1)     continue;
    Atom a=g.getAtom(0);
    twistedAs.add(a);
  }
  Atom[] twistedAtoms=twistedAs.toArray(new Atom[twistedAs.size()]);
  List<Group> hetatms=StructureTools.getUnalignedGroups(ca1);
  List<Group> hetatms2=StructureTools.getUnalignedGroups(ca2);
  Atom[] arr1=DisplayAFP.getAtomArray(ca1,hetatms);
  Atom[] arr2=DisplayAFP.getAtomArray(twistedAtoms,hetatms2);
  Structure artificial=DisplayAFP.getAlignedStructure(arr1,arr2);
  return artificial;
}",0.9966887417218544
16708,"/** 
 * Display a MultipleAlignment. New structures are downloaded if they were not cached in the alignment and they are entirely rotated here with the Pose information.
 * @param multAln
 * @return MultipleAlignmentJmol instance
 * @throws StructureException
 * @throws StructureAlignmentException 
 * @throws IOException 
 */
public static MultipleAlignmentJmol display(MultipleAlignment multAln) throws StructureException, StructureAlignmentException, IOException {
  int size=multAln.size();
  if (multAln.getAtomArrays() == null)   multAln.getEnsemble().updateAtomArrays();
  for (int i=0; i < size; i++) {
    if (multAln.getAtomArrays().get(i).length < 1)     throw new StructureException(""String_Node_Str"" + multAln.getAtomArrays().get(i).length);
  }
  try {
    List<Atom[]> rotatedAtoms=new ArrayList<Atom[]>();
    for (int i=0; i < size; i++) {
      Structure displayS=multAln.getAtomArrays().get(i)[0].getGroup().getChain().getParent().clone();
      Atom[] rotCA=StructureTools.getRepresentativeAtomArray(displayS);
      Calc.rotate(rotCA[0].getGroup().getChain().getParent(),multAln.getPose().getRotation().get(i));
      Calc.shift(rotCA[0].getGroup().getChain().getParent(),multAln.getPose().getTranslation().get(i));
      rotatedAtoms.add(rotCA);
    }
    MultipleAlignmentJmol jmol=new MultipleAlignmentJmol(multAln,rotatedAtoms);
    jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());
    return jmol;
  }
 catch (  StructureAlignmentException e) {
    e.printStackTrace();
    System.err.println(""String_Node_Str"");
    MultipleAlignmentJmol jmol=new MultipleAlignmentJmol(multAln,multAln.getAtomArrays());
    jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());
    return jmol;
  }
}","/** 
 * Display a MultipleAlignment. New structures are downloaded if they were not cached in the alignment and they are entirely rotated here with the Pose information.
 * @param multAln
 * @return MultipleAlignmentJmol instance
 * @throws StructureException
 * @throws StructureAlignmentException 
 * @throws IOException 
 */
public static MultipleAlignmentJmol display(MultipleAlignment multAln) throws StructureException, StructureAlignmentException, IOException {
  int size=multAln.size();
  List<Atom[]> atomArrays=multAln.getEnsemble().getAtomArrays();
  for (int i=0; i < size; i++) {
    if (atomArrays.get(i).length < 1)     throw new StructureException(""String_Node_Str"" + atomArrays.get(i).length);
  }
  List<Atom[]> rotatedAtoms=new ArrayList<Atom[]>();
  List<Matrix4d> transformations=multAln.getTransformations();
  if (transformations == null) {
    logger.error(""String_Node_Str"");
    multAln=multAln.clone();
    MultipleSuperimposer imposer=new ReferenceSuperimposer();
    imposer.superimpose(multAln);
    transformations=multAln.getTransformations();
    assert(transformations != null);
  }
  for (int i=0; i < size; i++) {
    Structure displayS=atomArrays.get(i)[0].getGroup().getChain().getParent().clone();
    Atom[] rotCA=StructureTools.getRepresentativeAtomArray(displayS);
    Calc.transform(rotCA[0].getGroup().getChain().getParent(),multAln.getTransformations().get(i));
    rotatedAtoms.add(rotCA);
  }
  MultipleAlignmentJmol jmol=new MultipleAlignmentJmol(multAln,rotatedAtoms);
  jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());
  return jmol;
}",0.5205643950765536
16709,"public List<Atom[]> getAtomArrays() throws StructureAlignmentException {
  return multAln.getParent().getAtomArrays();
}","public List<Atom[]> getAtomArrays() throws StructureAlignmentException {
  return multAln.getEnsemble().getAtomArrays();
}",0.950413223140496
16710,"private List<String> processSingleLine(String line){
  List<String> data=new ArrayList<String>();
  if (line.trim().length() == 0) {
    return data;
  }
  if (line.trim().length() == 1) {
    if (line.startsWith(STRING_LIMIT))     return data;
  }
  boolean inString=false;
  boolean inS1=false;
  boolean inS2=false;
  String word=""String_Node_Str"";
  for (int i=0; i < line.length(); i++) {
    Character c=line.charAt(i);
    Character nextC=null;
    if (i < line.length() - 1)     nextC=line.charAt(i + 1);
    if (c == ' ') {
      if (!inString) {
        if (!word.equals(""String_Node_Str""))         data.add(word.trim());
        word=""String_Node_Str"";
      }
 else {
        word+=c;
      }
    }
 else     if (c == S1) {
      if (inString) {
        boolean wordEnd=false;
        if (!inS2) {
          if (nextC != null) {
            if (Character.isWhitespace(nextC)) {
              i++;
              wordEnd=true;
            }
          }
        }
        if (wordEnd) {
          if (!word.equals(""String_Node_Str""))           data.add(word.trim());
          word=""String_Node_Str"";
          inString=false;
          inS1=false;
        }
 else {
          word+=c;
        }
      }
 else {
        inString=true;
        inS1=true;
      }
    }
 else     if (c == S2) {
      if (inString) {
        boolean wordEnd=false;
        if (!inS1) {
          if (nextC != null) {
            if (Character.isWhitespace(nextC)) {
              i++;
              wordEnd=true;
            }
          }
        }
        if (wordEnd) {
          if (!word.equals(""String_Node_Str""))           data.add(word.trim());
          word=""String_Node_Str"";
          inString=false;
          inS2=false;
        }
 else {
          word+=c;
        }
      }
 else {
        inString=true;
        inS2=true;
      }
    }
 else {
      word+=c;
    }
  }
  if (!word.trim().equals(""String_Node_Str""))   data.add(word);
  return data;
}","private List<String> processSingleLine(String line){
  List<String> data=new ArrayList<String>();
  if (line.trim().length() == 0) {
    return data;
  }
  if (line.trim().length() == 1) {
    if (line.startsWith(STRING_LIMIT))     return data;
  }
  boolean inString=false;
  boolean inS1=false;
  boolean inS2=false;
  String word=""String_Node_Str"";
  for (int i=0; i < line.length(); i++) {
    Character c=line.charAt(i);
    Character nextC=null;
    if (i < line.length() - 1)     nextC=line.charAt(i + 1);
    Character lastC=null;
    if (i > 0)     lastC=line.charAt(i - 1);
    if (c == ' ') {
      if (!inString) {
        if (!word.equals(""String_Node_Str""))         data.add(word.trim());
        word=""String_Node_Str"";
      }
 else {
        word+=c;
      }
    }
 else     if (c == S1) {
      if (inString) {
        boolean wordEnd=false;
        if (!inS2) {
          if (nextC != null) {
            if (Character.isWhitespace(nextC)) {
              i++;
              wordEnd=true;
            }
          }
        }
        if (wordEnd) {
          if (!word.equals(""String_Node_Str""))           data.add(word.trim());
          word=""String_Node_Str"";
          inString=false;
          inS1=false;
        }
 else {
          word+=c;
        }
      }
 else       if (lastC == null || lastC == ' ') {
        inString=true;
        inS1=true;
      }
 else {
        word+=c;
      }
    }
 else     if (c == S2) {
      if (inString) {
        boolean wordEnd=false;
        if (!inS1) {
          if (nextC != null) {
            if (Character.isWhitespace(nextC)) {
              i++;
              wordEnd=true;
            }
          }
        }
        if (wordEnd) {
          if (!word.equals(""String_Node_Str""))           data.add(word.trim());
          word=""String_Node_Str"";
          inString=false;
          inS2=false;
        }
 else {
          word+=c;
        }
      }
 else       if (lastC == null || lastC == ' ') {
        inString=true;
        inS2=true;
      }
 else {
        word+=c;
      }
    }
 else {
      word+=c;
    }
  }
  if (!word.trim().equals(""String_Node_Str""))   data.add(word);
  return data;
}",0.9266521423384168
16711,"/** 
 * This is to test the issue discussed here: http://www.globalphasing.com/startools/ Essentially single quote characters (') are valid not only for quoting, but also as parts of data values as long as some rules of the STAR format are followed. For instance Phenix produces mmCIF files with non-quoted strings containing single quote characters 
 * @throws IOException
 */
public void testQuotingCornerCase() throws IOException {
  InputStream inStream=this.getClass().getResourceAsStream(""String_Node_Str"");
  MMcifParser parser=new SimpleMMcifParser();
  SimpleMMcifConsumer consumer=new SimpleMMcifConsumer();
  FileParsingParameters fileParsingParams=new FileParsingParameters();
  fileParsingParams.setAlignSeqRes(true);
  consumer.setFileParsingParameters(fileParsingParams);
  parser.addMMcifConsumer(consumer);
  parser.parse(new BufferedReader(new InputStreamReader(inStream)));
  Structure s=consumer.getStructure();
  assertNotNull(s);
}","/** 
 * This is to test the issue discussed here: http://www.globalphasing.com/startools/ Essentially single quote characters (') are valid not only for quoting, but also as parts of data values as long as some rules of the STAR format are followed. For instance Phenix produces mmCIF files with non-quoted strings containing single quote characters 
 * @throws IOException
 */
@Test public void testQuotingCornerCase() throws IOException {
  InputStream inStream=this.getClass().getResourceAsStream(""String_Node_Str"");
  MMcifParser parser=new SimpleMMcifParser();
  SimpleMMcifConsumer consumer=new SimpleMMcifConsumer();
  FileParsingParameters fileParsingParams=new FileParsingParameters();
  fileParsingParams.setAlignSeqRes(true);
  consumer.setFileParsingParameters(fileParsingParams);
  parser.addMMcifConsumer(consumer);
  parser.parse(new BufferedReader(new InputStreamReader(inStream)));
  Structure s=consumer.getStructure();
  assertNotNull(s);
}",0.9968619246861924
16712,"/** 
 * A test for reading a phenix-produced (ver 1.9_1692) mmCIF file. This is the file submitted to the PDB for deposition of entry 4lup
 * @throws IOException
 */
@Ignore @Test public void testPhenixFile() throws IOException {
  InputStream inStream=new GZIPInputStream(this.getClass().getResourceAsStream(""String_Node_Str""));
  MMcifParser parser=new SimpleMMcifParser();
  SimpleMMcifConsumer consumer=new SimpleMMcifConsumer();
  FileParsingParameters fileParsingParams=new FileParsingParameters();
  fileParsingParams.setAlignSeqRes(true);
  consumer.setFileParsingParameters(fileParsingParams);
  parser.addMMcifConsumer(consumer);
  parser.parse(new BufferedReader(new InputStreamReader(inStream)));
  Structure s=consumer.getStructure();
  assertNotNull(s);
  assertTrue(s.isCrystallographic());
}","/** 
 * A test for reading a phenix-produced (ver 1.9_1692) mmCIF file. This is the file submitted to the PDB for deposition of entry 4lup See github issue #234
 * @throws IOException
 */
public void testPhenixFile() throws IOException {
  InputStream inStream=new GZIPInputStream(this.getClass().getResourceAsStream(""String_Node_Str""));
  MMcifParser parser=new SimpleMMcifParser();
  SimpleMMcifConsumer consumer=new SimpleMMcifConsumer();
  FileParsingParameters fileParsingParams=new FileParsingParameters();
  fileParsingParams.setAlignSeqRes(true);
  consumer.setFileParsingParameters(fileParsingParams);
  parser.addMMcifConsumer(consumer);
  parser.parse(new BufferedReader(new InputStreamReader(inStream)));
  Structure s=consumer.getStructure();
  assertNotNull(s);
  assertTrue(s.isCrystallographic());
}",0.9778051787916152
16713,"private static void printJmolScript4Block(Atom[] atoms,List<List<Integer>> alignRes,Color[] colors,StringWriter jmol,int str,int colorPos,int blockNum){
  Color start=ColorUtils.lighter(colors[str % colors.length],1);
  double fraction=(colorPos * 1.0) / blockNum;
  Color color=ColorUtils.darker(start,fraction);
  List<String> pdb=new ArrayList<String>();
  for (int i=0; i < alignRes.get(str).size(); i++) {
    if (alignRes.get(str).get(i) != null) {
      int pos=alignRes.get(str).get(i);
      pdb.add(JmolTools.getPdbInfo(atoms[pos]));
    }
  }
  StringBuffer buf=new StringBuffer(""String_Node_Str"");
  int count=0;
  for (  String res : pdb) {
    if (count > 0)     buf.append(""String_Node_Str"");
    buf.append(res);
    buf.append(""String_Node_Str"" + (str + 1));
    count++;
  }
  buf.append(""String_Node_Str"" + color.getRed() + ""String_Node_Str""+ color.getGreen()+ ""String_Node_Str""+ color.getBlue()+ ""String_Node_Str"");
  jmol.append(buf);
}","private static void printJmolScript4Block(Atom[] atoms,List<List<Integer>> alignRes,Color[] colors,StringWriter jmol,int str,int colorPos,int blockNum){
  Color start=colors[str % colors.length];
  double fraction=(colorPos * 1.0) / (blockNum + 1.0);
  Color color=ColorUtils.darker(start,fraction);
  List<String> pdb=new ArrayList<String>();
  for (int i=0; i < alignRes.get(str).size(); i++) {
    if (alignRes.get(str).get(i) != null) {
      int pos=alignRes.get(str).get(i);
      pdb.add(JmolTools.getPdbInfo(atoms[pos]));
    }
  }
  StringBuffer buf=new StringBuffer(""String_Node_Str"");
  int count=0;
  for (  String res : pdb) {
    if (count > 0)     buf.append(""String_Node_Str"");
    buf.append(res);
    buf.append(""String_Node_Str"" + (str + 1));
    count++;
  }
  buf.append(""String_Node_Str"" + color.getRed() + ""String_Node_Str""+ color.getGreen()+ ""String_Node_Str""+ color.getBlue()+ ""String_Node_Str"");
  jmol.append(buf);
}",0.9505263157894736
16714,"public void resetDisplay() throws StructureAlignmentException {
  if (multAln != null) {
    String script=getJmolString(multAln,atomArrays,colors);
    System.out.println(script);
    evalString(script);
    jmolPanel.evalString(""String_Node_Str"");
    jmolPanel.evalString(""String_Node_Str"");
  }
}","public void resetDisplay() throws StructureAlignmentException {
  if (multAln != null) {
    String script=getJmolString(multAln,atomArrays,colors);
    evalString(script);
    jmolPanel.evalString(""String_Node_Str"");
    jmolPanel.evalString(""String_Node_Str"");
  }
}",0.6725352112676056
16715,"/** 
 * After the alignment changes (optAln, optLen, blockNum, at a minimum), many other properties which depend on the superposition will be invalid. This method re-runs a rigid superposition over the whole alignment and repopulates the required properties, including RMSD (TotalRMSD) and TM-Score.
 * @param afpChain
 * @param ca1
 * @param ca2 Second set of ca atoms. Will be modified based on the superposition
 * @throws StructureException
 * @see {@link CECalculator#calc_rmsd(Atom[],Atom[],int,boolean)}contains much of the same code, but stores results in a CECalculator instance rather than an AFPChain
 */
public static void updateSuperposition(AFPChain afpChain,Atom[] ca1,Atom[] ca2) throws StructureException {
  afpChain.setCa1Length(ca1.length);
  afpChain.setCa2Length(ca2.length);
  int[] focusRes1=afpChain.getFocusRes1();
  int[] focusRes2=afpChain.getFocusRes2();
  if (focusRes1 == null) {
    focusRes1=new int[afpChain.getCa1Length()];
    afpChain.setFocusRes1(focusRes1);
  }
  if (focusRes2 == null) {
    focusRes2=new int[afpChain.getCa2Length()];
    afpChain.setFocusRes2(focusRes2);
  }
  if (afpChain.getNrEQR() == 0)   return;
  Atom[] ca1aligned=new Atom[afpChain.getOptLength()];
  Atom[] ca2aligned=new Atom[afpChain.getOptLength()];
  int pos=0;
  int[] blockLens=afpChain.getOptLen();
  int[][][] optAln=afpChain.getOptAln();
  assert(afpChain.getBlockNum() <= optAln.length);
  for (int block=0; block < afpChain.getBlockNum(); block++) {
    for (int i=0; i < blockLens[block]; i++) {
      int pos1=optAln[block][0][i];
      int pos2=optAln[block][1][i];
      Atom a1=ca1[pos1];
      Atom a2=(Atom)ca2[pos2].clone();
      ca1aligned[pos]=a1;
      ca2aligned[pos]=a2;
      pos++;
    }
  }
  if (pos != afpChain.getOptLength()) {
    logger.warn(""String_Node_Str"" + pos + ""String_Node_Str""+ afpChain.getOptLength());
    ca1aligned=(Atom[])resizeArray(ca1aligned,pos);
    ca2aligned=(Atom[])resizeArray(ca2aligned,pos);
  }
  SVDSuperimposer svd=new SVDSuperimposer(ca1aligned,ca2aligned);
  Matrix matrix=svd.getRotation();
  Atom shift=svd.getTranslation();
  Matrix[] blockMxs=new Matrix[afpChain.getBlockNum()];
  Arrays.fill(blockMxs,matrix);
  afpChain.setBlockRotationMatrix(blockMxs);
  Atom[] blockShifts=new Atom[afpChain.getBlockNum()];
  Arrays.fill(blockShifts,shift);
  afpChain.setBlockShiftVector(blockShifts);
  for (  Atom a : ca2aligned) {
    Calc.rotate(a,matrix);
    Calc.shift(a,shift);
  }
  double rmsd=SVDSuperimposer.getRMS(ca1aligned,ca2aligned);
  double tmScore=SVDSuperimposer.getTMScore(ca1aligned,ca2aligned,ca1.length,ca2.length);
  afpChain.setTotalRmsdOpt(rmsd);
  afpChain.setTMScore(tmScore);
  double[] blockRMSD=new double[afpChain.getBlockNum()];
  double[] blockScore=new double[afpChain.getBlockNum()];
  for (int k=0; k < afpChain.getBlockNum(); k++) {
    AFPChain afpChainb=(AFPChain)afpChain.clone();
    Atom[] ca1block=new Atom[afpChainb.getOptLen()[k]];
    Atom[] ca2block=new Atom[afpChainb.getOptLen()[k]];
    int position=0;
    for (int i=0; i < blockLens[k]; i++) {
      int pos1=optAln[k][0][i];
      int pos2=optAln[k][1][i];
      Atom a1=ca1[pos1];
      Atom a2=(Atom)ca2[pos2].clone();
      ca1block[position]=a1;
      ca2block[position]=a2;
      position++;
    }
    if (position != afpChainb.getOptLen()[k]) {
      logger.warn(""String_Node_Str"" + pos + ""String_Node_Str""+ afpChainb.getOptLen()[k]);
      ca1block=(Atom[])resizeArray(ca1block,position);
      ca2block=(Atom[])resizeArray(ca2block,position);
    }
    SVDSuperimposer svdb=new SVDSuperimposer(ca1block,ca2block);
    Matrix matrixb=svdb.getRotation();
    Atom shiftb=svdb.getTranslation();
    Matrix[] blockMxsb=new Matrix[afpChain.getBlockNum()];
    Arrays.fill(blockMxsb,matrix);
    afpChainb.setBlockRotationMatrix(blockMxsb);
    Atom[] blockShiftsb=new Atom[afpChainb.getBlockNum()];
    Arrays.fill(blockShiftsb,shiftb);
    afpChainb.setBlockShiftVector(blockShiftsb);
    for (    Atom a : ca2block) {
      Calc.rotate(a,matrixb);
      Calc.shift(a,shiftb);
    }
    double rmsdb=SVDSuperimposer.getRMS(ca1block,ca2block);
    double tmScoreb=SVDSuperimposer.getTMScore(ca1block,ca2block,ca1.length,ca2.length);
    blockRMSD[k]=rmsdb;
    blockScore[k]=tmScoreb;
  }
  afpChain.setOptRmsd(blockRMSD);
  afpChain.setBlockRmsd(blockRMSD);
  afpChain.setBlockScore(blockScore);
}","/** 
 * After the alignment changes (optAln, optLen, blockNum, at a minimum), many other properties which depend on the superposition will be invalid. This method re-runs a rigid superposition over the whole alignment and repopulates the required properties, including RMSD (TotalRMSD) and TM-Score.
 * @param afpChain
 * @param ca1
 * @param ca2 Second set of ca atoms. Will be modified based on the superposition
 * @throws StructureException
 * @see {@link CECalculator#calc_rmsd(Atom[],Atom[],int,boolean)}contains much of the same code, but stores results in a CECalculator instance rather than an AFPChain
 */
public static void updateSuperposition(AFPChain afpChain,Atom[] ca1,Atom[] ca2) throws StructureException {
  afpChain.setCa1Length(ca1.length);
  afpChain.setCa2Length(ca2.length);
  int[] focusRes1=afpChain.getFocusRes1();
  int[] focusRes2=afpChain.getFocusRes2();
  if (focusRes1 == null) {
    focusRes1=new int[afpChain.getCa1Length()];
    afpChain.setFocusRes1(focusRes1);
  }
  if (focusRes2 == null) {
    focusRes2=new int[afpChain.getCa2Length()];
    afpChain.setFocusRes2(focusRes2);
  }
  if (afpChain.getNrEQR() == 0)   return;
  Atom[] ca1aligned=new Atom[afpChain.getOptLength()];
  Atom[] ca2aligned=new Atom[afpChain.getOptLength()];
  int pos=0;
  int[] blockLens=afpChain.getOptLen();
  int[][][] optAln=afpChain.getOptAln();
  assert(afpChain.getBlockNum() <= optAln.length);
  for (int block=0; block < afpChain.getBlockNum(); block++) {
    for (int i=0; i < blockLens[block]; i++) {
      int pos1=optAln[block][0][i];
      int pos2=optAln[block][1][i];
      Atom a1=ca1[pos1];
      Atom a2=(Atom)ca2[pos2].clone();
      ca1aligned[pos]=a1;
      ca2aligned[pos]=a2;
      pos++;
    }
  }
  if (pos != afpChain.getOptLength()) {
    logger.warn(""String_Node_Str"" + pos + ""String_Node_Str""+ afpChain.getOptLength());
    ca1aligned=(Atom[])resizeArray(ca1aligned,pos);
    ca2aligned=(Atom[])resizeArray(ca2aligned,pos);
  }
  SVDSuperimposer svd=new SVDSuperimposer(ca1aligned,ca2aligned);
  Matrix matrix=svd.getRotation();
  Atom shift=svd.getTranslation();
  Matrix[] blockMxs=new Matrix[afpChain.getBlockNum()];
  Arrays.fill(blockMxs,matrix);
  afpChain.setBlockRotationMatrix(blockMxs);
  Atom[] blockShifts=new Atom[afpChain.getBlockNum()];
  Arrays.fill(blockShifts,shift);
  afpChain.setBlockShiftVector(blockShifts);
  for (  Atom a : ca2aligned) {
    Calc.rotate(a,matrix);
    Calc.shift(a,shift);
  }
  double rmsd=SVDSuperimposer.getRMS(ca1aligned,ca2aligned);
  double tmScore=SVDSuperimposer.getTMScore(ca1aligned,ca2aligned,ca1.length,ca2.length);
  afpChain.setTotalRmsdOpt(rmsd);
  afpChain.setTMScore(tmScore);
  double[] blockRMSD=new double[afpChain.getBlockNum()];
  double[] blockScore=new double[afpChain.getBlockNum()];
  for (int k=0; k < afpChain.getBlockNum(); k++) {
    Atom[] ca1block=new Atom[afpChain.getOptLen()[k]];
    Atom[] ca2block=new Atom[afpChain.getOptLen()[k]];
    int position=0;
    for (int i=0; i < blockLens[k]; i++) {
      int pos1=optAln[k][0][i];
      int pos2=optAln[k][1][i];
      Atom a1=ca1[pos1];
      Atom a2=(Atom)ca2[pos2].clone();
      ca1block[position]=a1;
      ca2block[position]=a2;
      position++;
    }
    if (position != afpChain.getOptLen()[k]) {
      logger.warn(""String_Node_Str"" + pos + ""String_Node_Str""+ afpChain.getOptLen()[k]);
      ca1block=(Atom[])resizeArray(ca1block,position);
      ca2block=(Atom[])resizeArray(ca2block,position);
    }
    SVDSuperimposer svdb=new SVDSuperimposer(ca1block,ca2block);
    Matrix matrixb=svdb.getRotation();
    Atom shiftb=svdb.getTranslation();
    Arrays.fill(blockMxs,matrixb);
    afpChain.setBlockRotationMatrix(blockMxs);
    Arrays.fill(blockShifts,shiftb);
    afpChain.setBlockShiftVector(blockShifts);
    for (    Atom a : ca2block) {
      Calc.rotate(a,matrixb);
      Calc.shift(a,shiftb);
    }
    double rmsdb=SVDSuperimposer.getRMS(ca1block,ca2block);
    double tmScoreb=SVDSuperimposer.getTMScore(ca1block,ca2block,ca1.length,ca2.length);
    blockRMSD[k]=rmsdb;
    blockScore[k]=tmScoreb;
  }
  afpChain.setOptRmsd(blockRMSD);
  afpChain.setBlockRmsd(blockRMSD);
  afpChain.setBlockScore(blockScore);
}",0.9552447552447552
16716,"/** 
 * Copy constructor.
 * @param bs BlockSetImpl object to be copied.
 * @return BlockSetImpl an identical copy of the input BlockSetImpl object.
 */
public BlockSetImpl(BlockSetImpl bs){
  this.parent=bs.parent;
  this.pose=(Pose)bs.pose.clone();
  this.length=bs.length;
  this.coreLength=bs.coreLength;
  List<Block> blocks=new ArrayList<Block>();
  for (  Block b : bs.blocks) {
    blocks.add((Block)b.clone());
  }
  this.blocks=blocks;
}","/** 
 * Copy constructor.
 * @param bs BlockSetImpl object to be copied.
 * @return BlockSetImpl an identical copy of the input BlockSetImpl object.
 */
public BlockSetImpl(BlockSetImpl bs){
  this.parent=bs.parent;
  this.length=bs.length;
  this.coreLength=bs.coreLength;
  this.pose=null;
  pose=null;
  List<Block> blocks=new ArrayList<Block>();
  for (  Block b : bs.blocks) {
    Block newBK=(Block)b.clone();
    newBK.setBlockSet(this);
  }
  this.blocks=blocks;
}",0.8378672470076169
16717,"/** 
 * Copy constructor.
 * @param e MultipleAlignmentEnsembleImpl to copy.
 * @return MultipleAlignmentEnsembleImpl identical copy of the input MultipleAlignmentEnsembleImpl.
 */
public MultipleAlignmentEnsembleImpl(MultipleAlignmentEnsembleImpl e){
  algorithmName=e.algorithmName;
  version=e.version;
  ioTime=e.ioTime;
  id=e.id;
  calculationTime=e.calculationTime;
  atomArrays=null;
  if (e.atomArrays != null) {
    atomArrays=new ArrayList<Atom[]>();
    for (    Atom[] array : e.atomArrays) {
      Atom[] newArray=new Atom[array.length];
      for (int i=0; i < array.length; i++) {
        newArray[i]=(Atom)array[i].clone();
      }
      atomArrays.add(newArray);
    }
  }
  distanceMatrix=null;
  if (e.distanceMatrix != null) {
    distanceMatrix=new ArrayList<Matrix>();
    for (    Matrix mat : e.distanceMatrix) {
      distanceMatrix.add((Matrix)mat.clone());
    }
  }
  multipleAlignments=null;
  if (e.multipleAlignments != null) {
    multipleAlignments=new ArrayList<MultipleAlignment>();
    for (    MultipleAlignment msa : e.multipleAlignments) {
      multipleAlignments.add((MultipleAlignment)msa.clone());
    }
  }
  structureNames=new ArrayList<String>(e.structureNames);
}","/** 
 * Copy constructor.
 * @param e MultipleAlignmentEnsembleImpl to copy.
 * @return MultipleAlignmentEnsembleImpl identical copy of the input MultipleAlignmentEnsembleImpl.
 */
public MultipleAlignmentEnsembleImpl(MultipleAlignmentEnsembleImpl e){
  algorithmName=e.algorithmName;
  version=e.version;
  ioTime=e.ioTime;
  id=e.id;
  calculationTime=e.calculationTime;
  atomArrays=null;
  if (e.atomArrays != null) {
    atomArrays=new ArrayList<Atom[]>();
    for (    Atom[] array : e.atomArrays) {
      Atom[] newArray=new Atom[array.length];
      for (int i=0; i < array.length; i++) {
        newArray[i]=(Atom)array[i].clone();
      }
      atomArrays.add(newArray);
    }
  }
  distanceMatrix=null;
  if (e.distanceMatrix != null) {
    distanceMatrix=new ArrayList<Matrix>();
    for (    Matrix mat : e.distanceMatrix) {
      distanceMatrix.add((Matrix)mat.clone());
    }
  }
  multipleAlignments=null;
  if (e.multipleAlignments != null) {
    multipleAlignments=new ArrayList<MultipleAlignment>();
    for (    MultipleAlignment msa : e.multipleAlignments) {
      MultipleAlignment newMSA=(MultipleAlignment)msa.clone();
      newMSA.setParent(this);
    }
  }
  structureNames=new ArrayList<String>(e.structureNames);
}",0.9441500203832044
16718,"/** 
 * Copy constructor.
 * @param ma MultipleAlignmentImpl to copy.
 * @return MultipleAlignmentImpl identical copy of the input MultipleAlignmentImpl.
 */
public MultipleAlignmentImpl(MultipleAlignmentImpl ma){
  parent=ma.parent;
  alnSequences=new ArrayList<String>(ma.getAlnSequences());
  blockSets=null;
  if (ma.blockSets != null) {
    this.blockSets=new ArrayList<BlockSet>();
    for (    BlockSet bs : ma.blockSets) {
      blockSets.add((BlockSet)bs.clone());
    }
  }
  algScore=ma.getAlgScore();
  probability=ma.getProbability();
}","/** 
 * Copy constructor.
 * @param ma MultipleAlignmentImpl to copy.
 * @return MultipleAlignmentImpl identical copy of the input MultipleAlignmentImpl.
 */
public MultipleAlignmentImpl(MultipleAlignmentImpl ma){
  parent=ma.parent;
  alnSequences=new ArrayList<String>(ma.getAlnSequences());
  pose=null;
  blockSets=null;
  if (ma.blockSets != null) {
    this.blockSets=new ArrayList<BlockSet>();
    for (    BlockSet bs : ma.blockSets) {
      BlockSet newBS=(BlockSet)bs.clone();
      newBS.setMultipleAlignment(this);
    }
  }
  algScore=ma.getAlgScore();
  probability=ma.getProbability();
}",0.9087749782797568
16719,"/** 
 * After the alignment changes (optAln, optLen, blockNum, at a minimum), many other properties which depend on the superposition will be invalid. This method re-runs a rigid superposition over the whole alignment and repopulates the required properties, including RMSD (TotalRMSD) and TM-Score.
 * @param afpChain
 * @param ca1
 * @param ca2 Second set of ca atoms. Will be modified based on the superposition
 * @throws StructureException
 * @see {@link CECalculator#calc_rmsd(Atom[],Atom[],int,boolean)}contains much of the same code, but stores results in a CECalculator instance rather than an AFPChain
 */
public static void updateSuperposition(AFPChain afpChain,Atom[] ca1,Atom[] ca2) throws StructureException {
  afpChain.setCa1Length(ca1.length);
  afpChain.setCa2Length(ca2.length);
  int[] focusRes1=afpChain.getFocusRes1();
  int[] focusRes2=afpChain.getFocusRes2();
  if (focusRes1 == null) {
    focusRes1=new int[afpChain.getCa1Length()];
    afpChain.setFocusRes1(focusRes1);
  }
  if (focusRes2 == null) {
    focusRes2=new int[afpChain.getCa2Length()];
    afpChain.setFocusRes2(focusRes2);
  }
  if (afpChain.getNrEQR() == 0)   return;
  Atom[] ca1aligned=new Atom[afpChain.getOptLength()];
  Atom[] ca2aligned=new Atom[afpChain.getOptLength()];
  int pos=0;
  int[] blockLens=afpChain.getOptLen();
  int[][][] optAln=afpChain.getOptAln();
  assert(afpChain.getBlockNum() <= optAln.length);
  for (int block=0; block < afpChain.getBlockNum(); block++) {
    for (int i=0; i < blockLens[block]; i++) {
      int pos1=optAln[block][0][i];
      int pos2=optAln[block][1][i];
      Atom a1=ca1[pos1];
      Atom a2=(Atom)ca2[pos2].clone();
      ca1aligned[pos]=a1;
      ca2aligned[pos]=a2;
      pos++;
    }
  }
  if (pos != afpChain.getOptLength()) {
    logger.warn(""String_Node_Str"" + pos + ""String_Node_Str""+ afpChain.getOptLength());
    ca1aligned=(Atom[])resizeArray(ca1aligned,pos);
    ca2aligned=(Atom[])resizeArray(ca2aligned,pos);
  }
  SVDSuperimposer svd=new SVDSuperimposer(ca1aligned,ca2aligned);
  Matrix matrix=svd.getRotation();
  Atom shift=svd.getTranslation();
  Matrix[] blockMxs=new Matrix[afpChain.getBlockNum()];
  Arrays.fill(blockMxs,matrix);
  afpChain.setBlockRotationMatrix(blockMxs);
  Atom[] blockShifts=new Atom[afpChain.getBlockNum()];
  Arrays.fill(blockShifts,shift);
  afpChain.setBlockShiftVector(blockShifts);
  for (  Atom a : ca2aligned) {
    Calc.rotate(a,matrix);
    Calc.shift(a,shift);
  }
  double rmsd=SVDSuperimposer.getRMS(ca1aligned,ca2aligned);
  double tmScore=SVDSuperimposer.getTMScore(ca1aligned,ca2aligned,ca1.length,ca2.length);
  afpChain.setTotalRmsdOpt(rmsd);
  afpChain.setTMScore(tmScore);
  double[] blockRMSD=new double[afpChain.getBlockNum()];
  double[] blockScore=new double[afpChain.getBlockNum()];
  for (int k=0; k < afpChain.getBlockNum(); k++) {
    Atom[] ca1block=new Atom[afpChain.getOptLen()[k]];
    Atom[] ca2block=new Atom[afpChain.getOptLen()[k]];
    int position=0;
    for (int i=0; i < blockLens[k]; i++) {
      int pos1=optAln[k][0][i];
      int pos2=optAln[k][1][i];
      Atom a1=ca1[pos1];
      Atom a2=(Atom)ca2[pos2].clone();
      ca1block[position]=a1;
      ca2block[position]=a2;
      position++;
    }
    if (position != afpChain.getOptLen()[k]) {
      logger.warn(""String_Node_Str"" + pos + ""String_Node_Str""+ afpChain.getOptLen()[k]);
      ca1block=(Atom[])resizeArray(ca1block,position);
      ca2block=(Atom[])resizeArray(ca2block,position);
    }
    SVDSuperimposer svdb=new SVDSuperimposer(ca1block,ca2block);
    Matrix matrixb=svdb.getRotation();
    Atom shiftb=svdb.getTranslation();
    Arrays.fill(blockMxs,matrixb);
    afpChain.setBlockRotationMatrix(blockMxs);
    Arrays.fill(blockShifts,shiftb);
    afpChain.setBlockShiftVector(blockShifts);
    for (    Atom a : ca2block) {
      Calc.rotate(a,matrixb);
      Calc.shift(a,shiftb);
    }
    double rmsdb=SVDSuperimposer.getRMS(ca1block,ca2block);
    double tmScoreb=SVDSuperimposer.getTMScore(ca1block,ca2block,ca1.length,ca2.length);
    blockRMSD[k]=rmsdb;
    blockScore[k]=tmScoreb;
  }
  afpChain.setOptRmsd(blockRMSD);
  afpChain.setBlockRmsd(blockRMSD);
  afpChain.setBlockScore(blockScore);
}","/** 
 * After the alignment changes (optAln, optLen, blockNum, at a minimum), many other properties which depend on the superposition will be invalid. This method re-runs a rigid superposition over the whole alignment and repopulates the required properties, including RMSD (TotalRMSD) and TM-Score.
 * @param afpChain
 * @param ca1
 * @param ca2 Second set of ca atoms. Will be modified based on the superposition
 * @throws StructureException
 * @see {@link CECalculator#calc_rmsd(Atom[],Atom[],int,boolean)}contains much of the same code, but stores results in a CECalculator instance rather than an AFPChain
 */
public static void updateSuperposition(AFPChain afpChain,Atom[] ca1,Atom[] ca2) throws StructureException {
  afpChain.setCa1Length(ca1.length);
  afpChain.setCa2Length(ca2.length);
  int[] focusRes1=afpChain.getFocusRes1();
  int[] focusRes2=afpChain.getFocusRes2();
  if (focusRes1 == null) {
    focusRes1=new int[afpChain.getCa1Length()];
    afpChain.setFocusRes1(focusRes1);
  }
  if (focusRes2 == null) {
    focusRes2=new int[afpChain.getCa2Length()];
    afpChain.setFocusRes2(focusRes2);
  }
  if (afpChain.getNrEQR() == 0)   return;
  Atom[] ca1aligned=new Atom[afpChain.getOptLength()];
  Atom[] ca2aligned=new Atom[afpChain.getOptLength()];
  int pos=0;
  int[] blockLens=afpChain.getOptLen();
  int[][][] optAln=afpChain.getOptAln();
  assert(afpChain.getBlockNum() <= optAln.length);
  for (int block=0; block < afpChain.getBlockNum(); block++) {
    for (int i=0; i < blockLens[block]; i++) {
      int pos1=optAln[block][0][i];
      int pos2=optAln[block][1][i];
      Atom a1=ca1[pos1];
      Atom a2=(Atom)ca2[pos2].clone();
      ca1aligned[pos]=a1;
      ca2aligned[pos]=a2;
      pos++;
    }
  }
  if (pos != afpChain.getOptLength()) {
    logger.warn(""String_Node_Str"" + pos + ""String_Node_Str""+ afpChain.getOptLength());
    ca1aligned=(Atom[])resizeArray(ca1aligned,pos);
    ca2aligned=(Atom[])resizeArray(ca2aligned,pos);
  }
  SVDSuperimposer svd=new SVDSuperimposer(ca1aligned,ca2aligned);
  Matrix matrix=svd.getRotation();
  Atom shift=svd.getTranslation();
  Matrix[] blockMxs=new Matrix[afpChain.getBlockNum()];
  Arrays.fill(blockMxs,matrix);
  afpChain.setBlockRotationMatrix(blockMxs);
  Atom[] blockShifts=new Atom[afpChain.getBlockNum()];
  Arrays.fill(blockShifts,shift);
  afpChain.setBlockShiftVector(blockShifts);
  for (  Atom a : ca2aligned) {
    Calc.rotate(a,matrix);
    Calc.shift(a,shift);
  }
  double rmsd=SVDSuperimposer.getRMS(ca1aligned,ca2aligned);
  double tmScore=SVDSuperimposer.getTMScore(ca1aligned,ca2aligned,ca1.length,ca2.length);
  afpChain.setTotalRmsdOpt(rmsd);
  afpChain.setTMScore(tmScore);
  double[] blockRMSD=new double[afpChain.getBlockNum()];
  double[] blockScore=new double[afpChain.getBlockNum()];
  for (int k=0; k < afpChain.getBlockNum(); k++) {
    Atom[] ca1block=new Atom[afpChain.getOptLen()[k]];
    Atom[] ca2block=new Atom[afpChain.getOptLen()[k]];
    int position=0;
    for (int i=0; i < blockLens[k]; i++) {
      int pos1=optAln[k][0][i];
      int pos2=optAln[k][1][i];
      Atom a1=ca1[pos1];
      Atom a2=(Atom)ca2[pos2].clone();
      ca1block[position]=a1;
      ca2block[position]=a2;
      position++;
    }
    if (position != afpChain.getOptLen()[k]) {
      logger.warn(""String_Node_Str"" + pos + ""String_Node_Str""+ afpChain.getOptLen()[k]);
      ca1block=(Atom[])resizeArray(ca1block,position);
      ca2block=(Atom[])resizeArray(ca2block,position);
    }
    SVDSuperimposer svdb=new SVDSuperimposer(ca1block,ca2block);
    Matrix matrixb=svdb.getRotation();
    Atom shiftb=svdb.getTranslation();
    afpChain.getBlockRotationMatrix()[k]=matrixb;
    afpChain.getBlockShiftVector()[k]=shiftb;
    afpChain.setBlockShiftVector(blockShifts);
    for (    Atom a : ca2block) {
      Calc.rotate(a,matrixb);
      Calc.shift(a,shiftb);
    }
    double rmsdb=SVDSuperimposer.getRMS(ca1block,ca2block);
    double tmScoreb=SVDSuperimposer.getTMScore(ca1block,ca2block,ca1.length,ca2.length);
    blockRMSD[k]=rmsdb;
    blockScore[k]=tmScoreb;
  }
  afpChain.setOptRmsd(blockRMSD);
  afpChain.setBlockRmsd(blockRMSD);
  afpChain.setBlockScore(blockScore);
}",0.979591836734694
16720,"/** 
 * Initialize variables
 * @param rotation
 * @param translation
 */
private void init(Matrix rotation,Atom translation){
  if (rotation.getColumnDimension() != 3 || rotation.getRowDimension() != 3) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  double c=(rotation.trace() - 1) / 2.0;
  this.theta=Math.acos(c);
  if (theta < MIN_ANGLE) {
    calculateTranslationalAxis(rotation,translation);
  }
 else {
    calculateRotationalAxis(rotation,translation,c);
  }
}","/** 
 * Initialize variables
 * @param rotation
 * @param translation
 */
private void init(Matrix rotation,Atom translation){
  if (rotation.getColumnDimension() != 3 || rotation.getRowDimension() != 3) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  double c=(rotation.trace() - 1) / 2.0;
  if (-1 - 1e-8 < c && c < -1)   c=-1;
  if (1 + 1e-8 > c && c > 1)   c=1;
  if (-1 > c || c > 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.theta=Math.acos(c);
  if (theta < MIN_ANGLE) {
    calculateTranslationalAxis(rotation,translation);
  }
 else {
    calculateRotationalAxis(rotation,translation,c);
  }
}",0.8568920105355575
16721,"@Override public void actionPerformed(ActionEvent arg0){
  System.out.println(""String_Node_Str"");
  if (parent == null) {
    System.err.println(""String_Node_Str"");
    return;
  }
  showMatrix(parent.getDisTable1(),""String_Node_Str"");
  showMatrix(parent.getDisTable2(),""String_Node_Str"");
}","@Override public void actionPerformed(ActionEvent arg0){
  System.out.println(""String_Node_Str"");
  if (parent == null) {
    System.err.println(""String_Node_Str"");
    return;
  }
  if (parent.getDisTable1() != null)   showMatrix(parent.getDisTable1(),""String_Node_Str"");
  if (parent.getDisTable2() != null)   showMatrix(parent.getDisTable2(),""String_Node_Str"");
}",0.8875379939209727
16722,"/** 
 * Helper method. Calculates and sets the global and individual RMSD and TMscore of the alignment. Needs the updated background distances matrices, since it assumes all distances to be already calculated.
 * @throws StructureAlignmentException
 * @throws StructureException
 */
private void updateRMSDandScore() throws StructureAlignmentException, StructureException {
  int size=size();
  listRMSD=new ArrayList<Double>();
  listTMscore=new ArrayList<Double>();
  for (int s1=0; s1 < size; s1++) {
    int lenRMSD=0;
    int lenScore=0;
    double sumRMSD=0.0;
    double sumScore=0.0;
    for (int s2=0; s2 < size; s2++) {
      int Lmin=Math.min(getAtomArrays().get(s1).length,getAtomArrays().get(s2).length);
      double d0=1.24 * Math.cbrt(Lmin - 15.) - 1.8;
      double d0sq=d0 * d0;
      lenScore+=Lmin;
      for (int k=0; k < getBlocks().size(); k++) {
        for (int j=0; j < getBlocks().get(k).length(); j++) {
          Integer pos1=getBlocks().get(k).getAlignRes().get(s1).get(j);
          Integer pos2=getBlocks().get(k).getAlignRes().get(s2).get(j);
          if (pos1 == null || pos2 == null)           continue;
          double d=backDistMatrix.get(s1).get(s2).get(pos1,pos2);
          sumRMSD+=(d * d);
          sumScore+=1. / (1 + d * d / d0sq);
          lenRMSD++;
        }
      }
    }
    listRMSD.add(Math.sqrt(sumRMSD / lenRMSD));
    listTMscore.add(sumScore / lenScore);
  }
  for (int i=0; i < size; i++) {
    rmsd=listRMSD.get(i);
    tmScore=listTMscore.get(i);
  }
  rmsd/=size;
  tmScore/=size;
}","/** 
 * Helper method. Calculates and sets the global and individual RMSD and TMscore of the alignment. Needs the updated background distances matrices, since it assumes all distances to be already calculated.
 * @throws StructureAlignmentException
 * @throws StructureException
 */
private void updateRMSDandScore() throws StructureAlignmentException, StructureException {
  int size=size();
  rmsd=0;
  tmScore=0;
  listRMSD=new ArrayList<Double>();
  listTMscore=new ArrayList<Double>();
  for (int s1=0; s1 < size; s1++) {
    int lenRMSD=0;
    int lenScore=0;
    double sumRMSD=0.0;
    double sumScore=0.0;
    for (int s2=0; s2 < size; s2++) {
      int Lmin=Math.min(getAtomArrays().get(s1).length,getAtomArrays().get(s2).length);
      double d0=1.24 * Math.cbrt(Lmin - 15.) - 1.8;
      double d0sq=d0 * d0;
      lenScore+=Lmin;
      for (int k=0; k < getBlocks().size(); k++) {
        for (int j=0; j < getBlocks().get(k).length(); j++) {
          Integer pos1=getBlocks().get(k).getAlignRes().get(s1).get(j);
          Integer pos2=getBlocks().get(k).getAlignRes().get(s2).get(j);
          if (pos1 == null || pos2 == null)           continue;
          double d=backDistMatrix.get(s1).get(s2).get(pos1,pos2);
          sumRMSD+=(d * d);
          sumScore+=1. / (1 + d * d / d0sq);
          lenRMSD++;
        }
      }
    }
    listRMSD.add(Math.sqrt(sumRMSD / lenRMSD));
    listTMscore.add(sumScore / lenScore);
  }
  for (int i=0; i < size; i++) {
    rmsd+=listRMSD.get(i);
    tmScore+=listTMscore.get(i);
  }
  rmsd/=size;
  tmScore/=size;
}",0.9919743178170144
16723,"/** 
 * Method that constructs a fake MultipleAlignment with two BlockSets, with two and one Blocks respectively. Used to test the correctness of the DataStructure. In the future it will be in the Test packages.
 * @param family name of the protein family
 * @param atomArrays
 * @return MultipleAlignment
 * @throws StructureException
 * @throws StructureAlignmentException
 */
private static MultipleAlignment fakeMultipleAlignment(String family,List<Atom[]> atomArrays) throws StructureException, StructureAlignmentException {
  MultipleAlignmentEnsemble ensemble=new MultipleAlignmentEnsembleImpl();
  ensemble.setAtomArrays(atomArrays,true);
  ensemble.setAlgorithmName(""String_Node_Str"");
  MultipleAlignment fakeMultAln=new MultipleAlignmentImpl(ensemble);
  if (family == ""String_Node_Str"") {
    BlockSet blockSet1=new BlockSetImpl(fakeMultAln);
    BlockSet blockSet2=new BlockSetImpl(fakeMultAln);
    Block block1=new BlockImpl(blockSet1);
    Block block2=new BlockImpl(blockSet1);
    Block block3=new BlockImpl(blockSet2);
    List<Integer> aligned11=Arrays.asList(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21);
    List<Integer> aligned12=Arrays.asList(29,30,31,32,33,34,35,36,37,38);
    List<Integer> aligned13=Arrays.asList(123,124,125,126,127,128,129,130,131,132,133,134);
    List<Integer> aligned21=Arrays.asList(10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,null,27,28,29,30,31);
    List<Integer> aligned22=Arrays.asList(39,40,41,42,43,44,45,46,47,48);
    List<Integer> aligned23=Arrays.asList(133,134,135,136,137,138,139,140,141,142,143,144);
    List<Integer> aligned31=Arrays.asList(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21);
    List<Integer> aligned32=Arrays.asList(29,30,31,32,33,34,35,36,37,38);
    List<Integer> aligned33=Arrays.asList(117,118,119,120,121,122,123,124,125,126,127,128);
    List<Integer> aligned41=Arrays.asList(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,null,17,18,19,20,21);
    List<Integer> aligned42=Arrays.asList(30,31,32,33,34,35,36,37,38,39);
    List<Integer> aligned43=Arrays.asList(121,122,123,124,125,126,127,128,129,130,131,132);
    block1.getAlignRes().add(aligned11);
    block1.getAlignRes().add(aligned21);
    block1.getAlignRes().add(aligned31);
    block1.getAlignRes().add(aligned41);
    block2.getAlignRes().add(aligned12);
    block2.getAlignRes().add(aligned22);
    block2.getAlignRes().add(aligned32);
    block2.getAlignRes().add(aligned42);
    block3.getAlignRes().add(aligned13);
    block3.getAlignRes().add(aligned23);
    block3.getAlignRes().add(aligned33);
    block3.getAlignRes().add(aligned43);
    fakeMultAln.updateCache(PoseMethod.REFERENCE);
  }
  return fakeMultAln;
}","/** 
 * Method that constructs a fake MultipleAlignment with two BlockSets, with two and one Blocks respectively. Used to test the correctness of the DataStructure. In the future it will be in the Test packages.
 * @param family name of the protein family
 * @param atomArrays
 * @return MultipleAlignment
 * @throws StructureException
 * @throws StructureAlignmentException
 */
private static MultipleAlignment fakeMultipleAlignment(String family,List<Atom[]> atomArrays) throws StructureException, StructureAlignmentException {
  MultipleAlignmentEnsemble ensemble=new MultipleAlignmentEnsembleImpl();
  ensemble.setAtomArrays(atomArrays);
  ensemble.setAlgorithmName(""String_Node_Str"");
  MultipleAlignment fakeMultAln=new MultipleAlignmentImpl(ensemble);
  if (family == ""String_Node_Str"") {
    BlockSet blockSet1=new BlockSetImpl(fakeMultAln);
    BlockSet blockSet2=new BlockSetImpl(fakeMultAln);
    Block block1=new BlockImpl(blockSet1);
    Block block2=new BlockImpl(blockSet1);
    Block block3=new BlockImpl(blockSet2);
    List<Integer> aligned11=Arrays.asList(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21);
    List<Integer> aligned12=Arrays.asList(29,30,31,32,33,34,35,36,37,38);
    List<Integer> aligned13=Arrays.asList(123,124,125,126,127,128,129,130,131,132,133,134);
    List<Integer> aligned21=Arrays.asList(10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,null,27,28,29,30,31);
    List<Integer> aligned22=Arrays.asList(39,40,41,42,43,44,45,46,47,48);
    List<Integer> aligned23=Arrays.asList(133,134,135,136,137,138,139,140,141,142,143,144);
    List<Integer> aligned31=Arrays.asList(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21);
    List<Integer> aligned32=Arrays.asList(29,30,31,32,33,34,35,36,37,38);
    List<Integer> aligned33=Arrays.asList(117,118,119,120,121,122,123,124,125,126,127,128);
    List<Integer> aligned41=Arrays.asList(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,null,17,18,19,20,21);
    List<Integer> aligned42=Arrays.asList(30,31,32,33,34,35,36,37,38,39);
    List<Integer> aligned43=Arrays.asList(121,122,123,124,125,126,127,128,129,130,131,132);
    block1.getAlignRes().add(aligned11);
    block1.getAlignRes().add(aligned21);
    block1.getAlignRes().add(aligned31);
    block1.getAlignRes().add(aligned41);
    block2.getAlignRes().add(aligned12);
    block2.getAlignRes().add(aligned22);
    block2.getAlignRes().add(aligned32);
    block2.getAlignRes().add(aligned42);
    block3.getAlignRes().add(aligned13);
    block3.getAlignRes().add(aligned23);
    block3.getAlignRes().add(aligned33);
    block3.getAlignRes().add(aligned43);
    fakeMultAln.updateCache(PoseMethod.REFERENCE);
  }
  return fakeMultAln;
}",0.9990683808459102
16724,"/** 
 * Display a MultipleAlignment. Atoms are rotated here with the Pose method.
 * @param multAln
 * @return MultipleAlignmentJmol instance
 * @throws StructureException
 * @throws StructureAlignmentException 
 */
public static MultipleAlignmentJmol display(MultipleAlignment multAln) throws StructureException, StructureAlignmentException {
  for (int i=0; i < multAln.size(); i++) {
    if (multAln.getAtomArrays().get(i).length < 1)     throw new StructureException(""String_Node_Str"" + multAln.getAtomArrays().get(i).length);
  }
  try {
    List<Atom[]> rotatedAtoms=multAln.getPose().getRotatedAtoms();
    MultipleAlignmentJmol jmol=new MultipleAlignmentJmol(multAln,rotatedAtoms);
    jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());
    return jmol;
  }
 catch (  StructureAlignmentException e) {
    e.printStackTrace();
    System.err.println(""String_Node_Str"");
    MultipleAlignmentJmol jmol=new MultipleAlignmentJmol(multAln,multAln.getAtomArrays());
    jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());
    return jmol;
  }
}","/** 
 * Display a MultipleAlignment. New structures are downloaded if they were not cached in the alignment and they are entirely rotated here with the Pose information.
 * @param multAln
 * @return MultipleAlignmentJmol instance
 * @throws StructureException
 * @throws StructureAlignmentException 
 * @throws IOException 
 */
public static MultipleAlignmentJmol display(MultipleAlignment multAln) throws StructureException, StructureAlignmentException, IOException {
  int size=multAln.size();
  if (multAln.getAtomArrays() == null)   multAln.getParent().updateAtomArrays();
  for (int i=0; i < size; i++) {
    if (multAln.getAtomArrays().get(i).length < 1)     throw new StructureException(""String_Node_Str"" + multAln.getAtomArrays().get(i).length);
  }
  try {
    List<Atom[]> rotatedAtoms=new ArrayList<Atom[]>();
    for (int i=0; i < size; i++) {
      Structure displayS=multAln.getAtomArrays().get(i)[0].getGroup().getChain().getParent().clone();
      Atom[] rotCA=StructureTools.getAtomCAArray(displayS);
      Calc.rotate(rotCA[0].getGroup().getChain().getParent(),multAln.getPose().getRotation().get(i));
      Calc.shift(rotCA[0].getGroup().getChain().getParent(),multAln.getPose().getTranslation().get(i));
      rotatedAtoms.add(rotCA);
    }
    MultipleAlignmentJmol jmol=new MultipleAlignmentJmol(multAln,rotatedAtoms);
    jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());
    return jmol;
  }
 catch (  StructureAlignmentException e) {
    e.printStackTrace();
    System.err.println(""String_Node_Str"");
    MultipleAlignmentJmol jmol=new MultipleAlignmentJmol(multAln,multAln.getAtomArrays());
    jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());
    return jmol;
  }
}",0.6599640933572711
16725,"/** 
 * Default constructor. Instantiates an empty CeMcMain object.
 */
public CeMcMain(){
  ensemble=null;
  params=new CeMcParameters();
}","/** 
 * Default constructor. Instantiates an empty CeMcMain object with the default parameters.
 */
public CeMcMain(){
  ensemble=null;
  params=new CeMcParameters();
}",0.9090909090909092
16726,"/** 
 * This method takes a list of pairwise alignments to the reference structure and calculates the  MultipleAlignment resulting from them. It ignores blocks in AFPChain (flexible parts) and builds  the Blocks as the definition of MultipleAlignment dictates   {@link Block}. Gaps are not included.
 * @param afpList the list of pairwise alignments to the reference
 * @param atomArrays List of Atoms of the structures
 * @param ref index of the reference structure
 * @return MultipleAlignment seed alignment
 * @throws StructureAlignmentException 
 * @throws StructureException 
 */
private static MultipleAlignment seedFromReference(List<AFPChain> afpList,List<Atom[]> atomArrays,int ref) throws StructureAlignmentException, StructureException {
  int size=atomArrays.size();
  int length=0;
  if (ref == 0)   length=afpList.get(1).getCa1Length();
 else   length=afpList.get(0).getCa2Length();
  List<List<Integer>> equivalencies=new ArrayList<List<Integer>>();
  for (int i=0; i < length; i++) {
    equivalencies.add(new ArrayList<Integer>());
    for (int j=0; j < size; j++) {
      if (j == ref)       equivalencies.get(i).add(i);
 else       equivalencies.get(i).add(null);
    }
  }
  for (int j=0; j < size; j++) {
    if (j == ref)     continue;
    for (int bk=0; bk < afpList.get(j).getBlockNum(); bk++) {
      for (int i=0; i < afpList.get(j).getOptLen()[bk]; i++) {
        int res1=0;
        int res2=0;
        if (j > ref) {
          res1=afpList.get(j).getOptAln()[bk][0][i];
          res2=afpList.get(j).getOptAln()[bk][1][i];
        }
 else         if (j < ref) {
          res1=afpList.get(j).getOptAln()[bk][1][i];
          res2=afpList.get(j).getOptAln()[bk][0][i];
        }
        equivalencies.get(res1).set(j,res2);
      }
    }
  }
  MultipleAlignment seed=new MultipleAlignmentImpl(atomArrays);
  BlockSet blockSet=new BlockSetImpl(seed);
  new BlockImpl(blockSet);
  for (int i=0; i < length; i++) {
    boolean gap=false;
    boolean cp=false;
    for (int j=0; j < size; j++) {
      if (equivalencies.get(i).get(j) == null) {
        gap=true;
        break;
      }
      if (blockSet.getBlocks().get(blockSet.getBlockNum() - 1).length() > 0) {
        if (equivalencies.get(i).get(j) < blockSet.getBlocks().get(blockSet.getBlockNum() - 1).getAlignRes().get(j).get(blockSet.getBlocks().get(blockSet.getBlockNum() - 1).length() - 1)) {
          cp=true;
        }
      }
    }
    if (gap)     continue;
    if (cp)     new BlockImpl(blockSet);
    for (int j=0; j < size; j++) {
      if (blockSet.getBlocks().get(blockSet.getBlockNum() - 1).getAlignRes().size() == 0)       for (int k=0; k < size; k++)       blockSet.getBlocks().get(blockSet.getBlockNum() - 1).getAlignRes().add(new ArrayList<Integer>());
      blockSet.getBlocks().get(blockSet.getBlockNum() - 1).getAlignRes().get(j).add(equivalencies.get(i).get(j));
    }
  }
  seed.updateCache(PoseMethod.REFERENCE);
  return seed;
}","/** 
 * This method takes a list of pairwise alignments to the reference structure and calculates the  MultipleAlignment resulting from them. It ignores blocks in AFPChain (flexible parts) and builds  the Blocks as the definition of MultipleAlignment dictates   {@link Block}. Gaps are not included.
 * @param afpList the list of pairwise alignments to the reference
 * @param atomArrays List of Atoms of the structures
 * @param ref index of the reference structure
 * @return MultipleAlignment seed alignment
 * @throws StructureAlignmentException 
 * @throws StructureException 
 */
private MultipleAlignment seedFromReference(List<AFPChain> afpList,List<Atom[]> atomArrays,int ref) throws StructureAlignmentException, StructureException {
  int size=atomArrays.size();
  int length=0;
  if (ref == 0)   length=afpList.get(1).getCa1Length();
 else   length=afpList.get(0).getCa2Length();
  List<List<Integer>> equivalencies=new ArrayList<List<Integer>>();
  for (int i=0; i < length; i++) {
    equivalencies.add(new ArrayList<Integer>());
    for (int j=0; j < size; j++) {
      if (j == ref)       equivalencies.get(i).add(i);
 else       equivalencies.get(i).add(null);
    }
  }
  for (int j=0; j < size; j++) {
    if (j == ref)     continue;
    for (int bk=0; bk < afpList.get(j).getBlockNum(); bk++) {
      for (int i=0; i < afpList.get(j).getOptLen()[bk]; i++) {
        int res1=0;
        int res2=0;
        if (j > ref) {
          res1=afpList.get(j).getOptAln()[bk][0][i];
          res2=afpList.get(j).getOptAln()[bk][1][i];
        }
 else         if (j < ref) {
          res1=afpList.get(j).getOptAln()[bk][1][i];
          res2=afpList.get(j).getOptAln()[bk][0][i];
        }
        equivalencies.get(res1).set(j,res2);
      }
    }
  }
  MultipleAlignment seed=new MultipleAlignmentImpl(ensemble);
  BlockSet blockSet=new BlockSetImpl(seed);
  new BlockImpl(blockSet);
  for (int i=0; i < length; i++) {
    boolean gap=false;
    boolean cp=false;
    for (int j=0; j < size; j++) {
      if (equivalencies.get(i).get(j) == null) {
        gap=true;
        break;
      }
      if (blockSet.getBlocks().get(blockSet.getBlockNum() - 1).length() > 0) {
        if (equivalencies.get(i).get(j) < blockSet.getBlocks().get(blockSet.getBlockNum() - 1).getAlignRes().get(j).get(blockSet.getBlocks().get(blockSet.getBlockNum() - 1).length() - 1)) {
          cp=true;
        }
      }
    }
    if (gap)     continue;
    if (cp)     new BlockImpl(blockSet);
    for (int j=0; j < size; j++) {
      if (blockSet.getBlocks().get(blockSet.getBlockNum() - 1).getAlignRes().size() == 0)       for (int k=0; k < size; k++)       blockSet.getBlocks().get(blockSet.getBlockNum() - 1).getAlignRes().add(new ArrayList<Integer>());
      blockSet.getBlocks().get(blockSet.getBlockNum() - 1).getAlignRes().get(j).add(equivalencies.get(i).get(j));
    }
  }
  seed.updateCache(PoseMethod.REFERENCE);
  return seed;
}",0.9957374254049446
16727,"/** 
 * Creates the seed of the multiple structure alignment, before optimization, from all-to-all pairwise alignments of the structures. The alignments are generated in parallel using the Java API for concurrency management.  The closest structure to all others is chosen as the reference and all the alignments to it are taken to generate  an ungapped seed MultipleAlignment. This method is static because can be used outside this alignment class.
 * @param atomArrays List of Atoms to align of the structures
 * @return MultipleAlignment seed alignment
 * @throws ExecutionException 
 * @throws InterruptedException 
 * @throws StructureException 
 * @throws StructureAlignmentException 
 */
public static MultipleAlignment generateSeed(List<Atom[]> atomArrays) throws InterruptedException, ExecutionException, StructureAlignmentException, StructureException {
  int size=atomArrays.size();
  List<List<AFPChain>> afpAlignments=new ArrayList<List<AFPChain>>();
  for (int i=0; i < size; i++) {
    afpAlignments.add(new ArrayList<AFPChain>());
    for (int j=0; j < size; j++)     afpAlignments.get(i).add(null);
  }
  ExecutorService executor=Executors.newCachedThreadPool();
  List<Future<AFPChain>> afpFuture=new ArrayList<Future<AFPChain>>();
  for (int i=0; i < size; i++) {
    for (int j=i + 1; j < size; j++) {
      Callable<AFPChain> worker=new ParallelAlignment(atomArrays.get(i),atomArrays.get(j),new CeMain());
      Future<AFPChain> submit=executor.submit(worker);
      afpFuture.add(submit);
    }
  }
  int index=0;
  for (int i=0; i < size; i++) {
    for (int j=i; j < size; j++) {
      if (i != j) {
        afpAlignments.get(i).add(j,afpFuture.get(index).get());
        afpAlignments.get(j).add(i,afpFuture.get(index).get());
        index++;
      }
    }
  }
  executor.shutdown();
  List<Double> RMSDs=new ArrayList<Double>();
  for (int i=0; i < size; i++) {
    double rmsd=0.0;
    for (int j=0; j < size; j++) {
      if (i != j)       rmsd+=afpAlignments.get(i).get(j).getTotalRmsdOpt();
    }
    RMSDs.add(rmsd);
  }
  int ref=0;
  for (int i=1; i < size; i++) {
    if (RMSDs.get(i) < RMSDs.get(ref))     ref=i;
  }
  return seedFromReference(afpAlignments.get(ref),atomArrays,ref);
}","/** 
 * Creates the seed of the multiple structure alignment, before optimization, from all-to-all pairwise alignments of the structures. The alignments are generated in parallel using the Java API for concurrency management.  The closest structure to all others is chosen as the reference and all the alignments to it are taken to generate  an ungapped seed MultipleAlignment. This method is static because can be used outside this alignment class.
 * @param atomArrays List of Atoms to align of the structures
 * @return MultipleAlignment seed alignment
 * @throws ExecutionException 
 * @throws InterruptedException 
 * @throws StructureException 
 * @throws StructureAlignmentException 
 */
public MultipleAlignment generateSeed(List<Atom[]> atomArrays) throws InterruptedException, ExecutionException, StructureAlignmentException, StructureException {
  int size=atomArrays.size();
  List<List<AFPChain>> afpAlignments=new ArrayList<List<AFPChain>>();
  for (int i=0; i < size; i++) {
    afpAlignments.add(new ArrayList<AFPChain>());
    for (int j=0; j < size; j++)     afpAlignments.get(i).add(null);
  }
  ExecutorService executor=Executors.newCachedThreadPool();
  List<Future<AFPChain>> afpFuture=new ArrayList<Future<AFPChain>>();
  for (int i=0; i < size; i++) {
    for (int j=i + 1; j < size; j++) {
      Callable<AFPChain> worker=new ParallelAlignment(atomArrays.get(i),atomArrays.get(j),new CeMain());
      Future<AFPChain> submit=executor.submit(worker);
      afpFuture.add(submit);
    }
  }
  int index=0;
  for (int i=0; i < size; i++) {
    for (int j=i; j < size; j++) {
      if (i != j) {
        afpAlignments.get(i).add(j,afpFuture.get(index).get());
        afpAlignments.get(j).add(i,afpFuture.get(index).get());
        index++;
      }
    }
  }
  executor.shutdown();
  List<Double> RMSDs=new ArrayList<Double>();
  for (int i=0; i < size; i++) {
    double rmsd=0.0;
    for (int j=0; j < size; j++) {
      if (i != j)       rmsd+=afpAlignments.get(i).get(j).getTotalRmsdOpt();
    }
    RMSDs.add(rmsd);
  }
  int ref=0;
  for (int i=1; i < size; i++) {
    if (RMSDs.get(i) < RMSDs.get(ref))     ref=i;
  }
  return seedFromReference(afpAlignments.get(ref),atomArrays,ref);
}",0.9984216459977452
16728,"@Override public void setBlockSet(BlockSet parent){
  this.parent=parent;
  if (parent != null)   parent.getBlocks().add(this);
}","@Override public void setBlockSet(BlockSet parent){
  if (parent != null)   parent.getBlocks().remove(this);
  this.parent=parent;
  if (parent != null)   parent.getBlocks().add(this);
}",0.819047619047619
16729,"@Override public void setMultipleAlignment(MultipleAlignment parent){
  this.parent=parent;
  if (parent != null)   parent.getBlockSets().add(this);
}","@Override public void setMultipleAlignment(MultipleAlignment parent){
  if (parent != null)   parent.getBlockSets().remove(this);
  this.parent=parent;
  if (parent != null)   parent.getBlockSets().add(this);
}",0.6944444444444444
16730,"/** 
 * Returns the List of Atom arrays. Every structure has an Atom array associated.
 * @return List of Atom[].
 * @see #setAtomArrays(List)
 */
public List<Atom[]> getAtomArrays();","/** 
 * Returns the List of Atom arrays. Every structure has an Atom array associated. The Atom arrays are only stored as a cache, and must be deleted when the alignment is serialized or stored.
 * @return List of Atom[].
 * @see #setAtomArrays(List)
 */
public List<Atom[]> getAtomArrays();",0.7721518987341772
16731,"/** 
 * Sets the List of Atom arrays. Every structure has an Atom array associated.
 * @param atomArrays the List of Atom[].
 * @param setNames if true the List of structure names is updated with the corresponding PDB codes of the Atoms.
 * @see #getAtomArrays()
 * @see #setStructureNames(List)
 */
public void setAtomArrays(List<Atom[]> atomArrays,boolean setNames);","/** 
 * Sets the List of Atom arrays. Every structure has an Atom array associated. The Atom arrays are only stored as a cache, and must be deleted when the alignment is serialized or stored.
 * @param atomArrays the List of Atom[].
 * @see #getAtomArrays()
 * @see #setStructureNames(List)
 */
public void setAtomArrays(List<Atom[]> atomArrays);",0.6666666666666666
16732,"/** 
 * Set the List containing the names of the structures aligned (i.e.: PDB code, SCOP domain, etc.).
 * @param structureNames names of the structures
 * @see #getStructureNames()
 * @see #setAtomArrays(List)
 */
public void setStructureNames(List<String> structureNames);","/** 
 * Set the List containing the names of the structures aligned (i.e.: PDB code, SCOP domain, etc.). The names are structure identifiers of the structures.
 * @param structureNames names of the structures, structure identifiers
 * @see #getStructureNames()
 * @see #setAtomArrays(List)
 */
public void setStructureNames(List<String> structureNames);",0.8757961783439491
16733,"/** 
 * Returns a List containing the names of the structures aligned (i.e.: PDB code, SCOP domain, etc.). They are in the same order as in the Atom List and alignment List (same index number for same structure).
 * @return List of String names of the structures
 * @see #setStructureNames(List)
 * @see #getAtomArrays()
 */
public List<String> getStructureNames();","/** 
 * Returns a List containing the names of the structures aligned (i.e.: PDB code, SCOP domain, etc.). The names are structure identifiers of the structures. They are in the same order as in the alignment Blocks (same index number for same structure).
 * @return List of String names of the structures
 * @see #setStructureNames(List)
 * @see #getAtomArrays()
 */
public List<String> getStructureNames();",0.8978007761966365
16734,"@Override public List<Atom[]> getAtomArrays(){
  if (atomArrays == null)   atomArrays=new ArrayList<Atom[]>();
  return atomArrays;
}","@Override public List<Atom[]> getAtomArrays(){
  if (atomArrays == null)   ;
  return atomArrays;
}",0.853448275862069
16735,"@Override public void setAtomArrays(List<Atom[]> atomArrays,boolean setNames){
  this.atomArrays=atomArrays;
  if (setNames) {
    List<String> names=new ArrayList<String>();
    for (int i=0; i < atomArrays.size(); i++)     names.add(atomArrays.get(i)[0].getGroup().getChain().getParent().getPDBCode());
    setStructureNames(names);
  }
}","@Override public void setAtomArrays(List<Atom[]> atomArrays){
  this.atomArrays=atomArrays;
  List<String> names=new ArrayList<String>();
  for (int i=0; i < atomArrays.size(); i++)   names.add(atomArrays.get(i)[0].getGroup().getChain().getParent().getIdentifier());
  setStructureNames(names);
}",0.8836477987421384
16736,"@Override public List<String> getStructureNames(){
  if (structureNames == null)   structureNames=new ArrayList<String>();
  return structureNames;
}","@Override public List<String> getStructureNames(){
  return structureNames;
}",0.6814159292035398
16737,"@Override public int size() throws StructureAlignmentException {
  if (atomArrays == null)   throw new StructureAlignmentException(""String_Node_Str"");
 else   return atomArrays.size();
}","@Override public int size() throws StructureAlignmentException {
  if (structureNames == null)   throw new StructureAlignmentException(""String_Node_Str"");
 else   return structureNames.size();
}",0.9052631578947368
16738,"public static void main(String[] args) throws IOException, StructureException, StructureAlignmentException, InterruptedException, ExecutionException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AtomCache cache=new AtomCache();
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  for (  String name : names)   atomArrays.add(cache.getAtoms(name));
  CeMcMain algorithm=new CeMcMain();
  MultipleAlignment result=algorithm.align(atomArrays);
  result.getParent().setAlgorithmName(algorithm.getAlgorithmName());
  result.getParent().setVersion(algorithm.getVersion());
  StructureAlignmentDisplay.display(result);
}","public static void main(String[] args) throws IOException, StructureException, StructureAlignmentException, InterruptedException, ExecutionException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AtomCache cache=new AtomCache();
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  for (  String name : names)   atomArrays.add(cache.getAtoms(name));
  CeMcMain algorithm=new CeMcMain();
  MultipleAlignment result=algorithm.align(atomArrays);
  result.getParent().setStructureNames(names);
  result.getParent().setAlgorithmName(algorithm.getAlgorithmName());
  result.getParent().setVersion(algorithm.getVersion());
  StructureAlignmentDisplay.display(result);
}",0.9250175192711984
16739,"/** 
 * The user selected one of the Combo boxes...
 * @param event an ActionEvent
 */
@Override public void actionPerformed(ActionEvent event){
  Object mysource=event.getSource();
  if (!(mysource instanceof JComboBox)) {
    super.actionPerformed(event);
    return;
  }
  JComboBox source=(JComboBox)event.getSource();
  String value=source.getSelectedItem().toString();
  String selectLigand=""String_Node_Str"";
  if (value.equals(""String_Node_Str"")) {
    String script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    this.executeCmd(script);
  }
 else   if (value.equals(""String_Node_Str"")) {
    String script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    this.executeCmd(script);
  }
 else   if (value.equals(""String_Node_Str"")) {
    String script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    this.executeCmd(script);
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    String script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    this.executeCmd(script);
  }
 else   if (value.equals(""String_Node_Str"")) {
    jmolColorByChain();
    String script=""String_Node_Str"" + selectLigand + ""String_Node_Str"";
    this.executeCmd(script);
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"" + selectLigand + ""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"" + selectLigand + ""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"" + selectLigand + ""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"" + selectLigand + ""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"" + selectLigand + ""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    colorByPDP();
  }
 else   if (value.equals(""String_Node_Str"")) {
    colorBySCOP();
  }
}","/** 
 * The user selected one of the Combo boxes...
 * @param event an ActionEvent
 */
@Override public void actionPerformed(ActionEvent event){
  Object mysource=event.getSource();
  if (!(mysource instanceof JComboBox)) {
    super.actionPerformed(event);
    return;
  }
  JComboBox source=(JComboBox)event.getSource();
  String value=source.getSelectedItem().toString();
  evalString(""String_Node_Str"");
  String selectLigand=""String_Node_Str"";
  if (value.equals(""String_Node_Str"")) {
    String script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    this.executeCmd(script);
  }
 else   if (value.equals(""String_Node_Str"")) {
    String script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    this.executeCmd(script);
  }
 else   if (value.equals(""String_Node_Str"")) {
    String script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    this.executeCmd(script);
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    String script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    this.executeCmd(script);
  }
 else   if (value.equals(""String_Node_Str"")) {
    jmolColorByChain();
    String script=""String_Node_Str"" + selectLigand + ""String_Node_Str"";
    this.executeCmd(script);
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"" + selectLigand + ""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"" + selectLigand + ""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"" + selectLigand + ""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"" + selectLigand + ""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"" + selectLigand + ""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    colorByPDP();
  }
 else   if (value.equals(""String_Node_Str"")) {
    colorBySCOP();
  }
  evalString(""String_Node_Str"");
}",0.9868158210147824
16740,"/** 
 * Copy constructor.
 * @param bs BlockSetImpl object to be copied.
 * @return BlockSetImpl an identical copy of the input BlockSetImpl object.
 */
public BlockSetImpl(BlockSetImpl bs){
  this.parent=bs.parent;
  this.length=bs.length;
  this.coreLength=bs.coreLength;
  this.pose=null;
  pose=null;
  List<Block> blocks=new ArrayList<Block>();
  for (  Block b : bs.blocks) {
    Block newBK=(Block)b.clone();
    newBK.setBlockSet(this);
  }
  this.blocks=blocks;
}","/** 
 * Copy constructor.
 * @param bs BlockSetImpl object to be copied.
 * @return BlockSetImpl an identical copy of the input BlockSetImpl object.
 */
public BlockSetImpl(BlockSetImpl bs){
  this.parent=bs.parent;
  this.length=bs.length;
  this.coreLength=bs.coreLength;
  this.pose=null;
  pose=null;
  blocks=null;
  if (bs.blocks != null) {
    this.blocks=new ArrayList<Block>();
    for (    Block b : bs.blocks) {
      Block newB=(Block)b.clone();
      newB.setBlockSet(this);
    }
  }
}",0.8218331616889805
16741,"/** 
 * Copy constructor.
 * @param ma MultipleAlignmentImpl to copy.
 * @return MultipleAlignmentImpl identical copy of the input MultipleAlignmentImpl.
 */
public MultipleAlignmentImpl(MultipleAlignmentImpl ma){
  parent=ma.parent;
  alnSequences=new ArrayList<String>(ma.getAlnSequences());
  pose=null;
  blockSets=null;
  if (ma.blockSets != null) {
    this.blockSets=new ArrayList<BlockSet>();
    for (    BlockSet bs : ma.blockSets) {
      BlockSet newBS=(BlockSet)bs.clone();
      newBS.setMultipleAlignment(this);
    }
  }
  algScore=ma.getAlgScore();
  probability=ma.getProbability();
}","/** 
 * Copy constructor.
 * @param ma MultipleAlignmentImpl to copy.
 * @return MultipleAlignmentImpl identical copy of the input MultipleAlignmentImpl.
 */
public MultipleAlignmentImpl(MultipleAlignmentImpl ma){
  parent=ma.parent;
  alnSequences=null;
  if (ma.alnSequences != null)   alnSequences=new ArrayList<String>(ma.alnSequences);
  pose=null;
  blockSets=null;
  if (ma.blockSets != null) {
    this.blockSets=new ArrayList<BlockSet>();
    for (    BlockSet bs : ma.blockSets) {
      BlockSet newBS=(BlockSet)bs.clone();
      newBS.setMultipleAlignment(this);
    }
  }
  algScore=ma.getAlgScore();
  probability=ma.getProbability();
}",0.9528377298161472
16742,"public static void main(String[] args) throws IOException, StructureException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AtomCache cache=new AtomCache();
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  for (  String name : names)   atomArrays.add(cache.getAtoms(name));
  MultipleAlignment fakeMultAln=fakeMultipleAlignment(""String_Node_Str"",atomArrays);
  fakeMultAln.setAlgorithmName(""String_Node_Str"");
  fakeMultAln.setAtomArrays(atomArrays);
  fakeMultAln.setStructureNames(names);
  List<Atom[]> rotatedAtoms=new ArrayList<Atom[]>();
  for (int i=0; i < fakeMultAln.getSize(); i++) {
    Matrix rotationMatrix=fakeMultAln.getBlockSets().get(0).getPose().getRotationMatrix().get(i);
    Atom shiftVector=fakeMultAln.getBlockSets().get(0).getPose().getTranslation().get(i);
    Atom[] rotCA=StructureTools.cloneAtomArray(atomArrays.get(i));
    for (    Atom a : rotCA) {
      Calc.rotate(a,rotationMatrix);
      Calc.shift(a,shiftVector);
    }
    rotatedAtoms.add(rotCA);
  }
  MultipleAlignmentJmol jmol=new MultipleAlignmentJmol(fakeMultAln,rotatedAtoms);
}","public static void main(String[] args) throws IOException, StructureException {
  List<String> names=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AtomCache cache=new AtomCache();
  List<Atom[]> atomArrays=new ArrayList<Atom[]>();
  for (  String name : names)   atomArrays.add(cache.getAtoms(name));
  MultipleAlignment fakeMultAln=fakeMultipleAlignment(""String_Node_Str"",atomArrays);
  fakeMultAln.setAlgorithmName(""String_Node_Str"");
  fakeMultAln.setAtomArrays(atomArrays);
  fakeMultAln.setStructureNames(names);
  List<Atom[]> rotatedAtoms=new ArrayList<Atom[]>();
  for (int i=0; i < fakeMultAln.getSize(); i++) {
    Matrix rotationMatrix=fakeMultAln.getBlockSets().get(0).getPose().getRotationMatrix().get(i);
    Atom shiftVector=fakeMultAln.getBlockSets().get(0).getPose().getTranslation().get(i);
    Atom[] rotCA=StructureTools.cloneAtomArray(atomArrays.get(i));
    for (    Atom a : rotCA) {
      Calc.rotate(a,rotationMatrix);
      Calc.shift(a,shiftVector);
    }
    rotatedAtoms.add(rotCA);
  }
  MultipleAlignmentJmol jmol=new MultipleAlignmentJmol(fakeMultAln,rotatedAtoms);
  jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());
}",0.9727659574468084
16743,"protected void initCoords(){
  try {
    if (multAln == null) {
      if (structure != null)       setStructure(structure);
 else {
        return;
      }
    }
    Structure artificial=DisplayAFP.getAlignedStructure(atomArrays);
    PDBHeader header=new PDBHeader();
    String title=multAln.getAlgorithmName() + ""String_Node_Str"" + multAln.getVersion()+ ""String_Node_Str"";
    for (    String name : multAln.getStructureNames())     title+=name + ""String_Node_Str"";
    header.setTitle(title);
    artificial.setPDBHeader(header);
    setStructure(artificial);
  }
 catch (  StructureException e) {
    e.printStackTrace();
  }
}","protected void initCoords(){
  try {
    if (multAln == null) {
      if (structure != null)       setStructure(structure);
 else {
        return;
      }
    }
    Structure artificial=DisplayAFP.getAlignedStructure(atomArrays);
    PDBHeader header=new PDBHeader();
    String title=multAln.getAlgorithmName() + ""String_Node_Str"" + multAln.getVersion()+ ""String_Node_Str"";
    for (    String name : multAln.getStructureNames())     title+=name + ""String_Node_Str"";
    System.out.println(title);
    header.setTitle(title);
    artificial.setPDBHeader(header);
    setStructure(artificial);
  }
 catch (  StructureException e) {
    e.printStackTrace();
  }
}",0.976061776061776
16744,"public void resetDisplay(){
  if (afpChain != null && ca1 != null && ca2 != null) {
    String script=getJmolString(afpChain,ca1,ca2);
    System.out.println(script);
    jmolPanel.evalString(""String_Node_Str"");
  }
}","public void resetDisplay(){
  if (afpChain != null && ca1 != null && ca2 != null) {
    String script=getJmolString(afpChain,ca1,ca2);
    evalString(script);
    jmolPanel.evalString(""String_Node_Str"");
  }
}",0.9342723004694836
16745,"/** 
 * After the alignment changes (optAln, optLen, blockNum, at a minimum), many other properties which depend on the superposition will be invalid. This method re-runs a rigid superposition over the whole alignment and repopulates the required properties, including RMSD (TotalRMSD) and TM-Score.
 * @param afpChain
 * @param ca1
 * @param ca2 Second set of ca atoms. Will be modified based on the superposition
 * @throws StructureException
 * @see {@link CECalculator#calc_rmsd(Atom[],Atom[],int,boolean)}contains much of the same code, but stores results in a CECalculator instance rather than an AFPChain
 */
public static void updateSuperposition(AFPChain afpChain,Atom[] ca1,Atom[] ca2) throws StructureException {
  int[] focusRes1=afpChain.getFocusRes1();
  int[] focusRes2=afpChain.getFocusRes2();
  if (focusRes1 == null) {
    focusRes1=new int[afpChain.getCa1Length()];
    afpChain.setFocusRes1(focusRes1);
  }
  if (focusRes2 == null) {
    focusRes2=new int[afpChain.getCa2Length()];
    afpChain.setFocusRes2(focusRes2);
  }
  if (afpChain.getNrEQR() == 0)   return;
  Atom[] ca1aligned=new Atom[afpChain.getOptLength()];
  Atom[] ca2aligned=new Atom[afpChain.getOptLength()];
  int pos=0;
  int[] blockLens=afpChain.getOptLen();
  int[][][] optAln=afpChain.getOptAln();
  assert(afpChain.getBlockNum() <= optAln.length);
  for (int block=0; block < afpChain.getBlockNum(); block++) {
    for (int i=0; i < blockLens[block]; i++) {
      int pos1=optAln[block][0][i];
      int pos2=optAln[block][1][i];
      Atom a1=ca1[pos1];
      Atom a2=(Atom)ca2[pos2].clone();
      ca1aligned[pos]=a1;
      ca2aligned[pos]=a2;
      pos++;
    }
  }
  if (pos != afpChain.getOptLength()) {
    logger.warn(""String_Node_Str"" + pos + ""String_Node_Str""+ afpChain.getOptLength());
    ca1aligned=(Atom[])resizeArray(ca1aligned,pos);
    ca2aligned=(Atom[])resizeArray(ca2aligned,pos);
  }
  SVDSuperimposer svd=new SVDSuperimposer(ca1aligned,ca2aligned);
  Matrix matrix=svd.getRotation();
  Atom shift=svd.getTranslation();
  Matrix[] blockMxs=new Matrix[afpChain.getBlockNum()];
  Arrays.fill(blockMxs,matrix);
  afpChain.setBlockRotationMatrix(blockMxs);
  Atom[] blockShifts=new Atom[afpChain.getBlockNum()];
  Arrays.fill(blockShifts,shift);
  afpChain.setBlockShiftVector(blockShifts);
  for (  Atom a : ca2aligned) {
    Calc.rotate(a,matrix);
    Calc.shift(a,shift);
  }
  double rmsd=SVDSuperimposer.getRMS(ca1aligned,ca2aligned);
  double tmScore=SVDSuperimposer.getTMScore(ca1aligned,ca2aligned,ca1.length,ca2.length);
  afpChain.setTotalRmsdOpt(rmsd);
  afpChain.setTMScore(tmScore);
  double[] blockRMSD=new double[afpChain.getBlockNum()];
  double[] blockScore=new double[afpChain.getBlockNum()];
  for (int k=0; k < afpChain.getBlockNum(); k++) {
    AFPChain afpChainb=(AFPChain)afpChain.clone();
    Atom[] ca1block=new Atom[afpChainb.getOptLen()[k]];
    Atom[] ca2block=new Atom[afpChainb.getOptLen()[k]];
    int position=0;
    for (int i=0; i < blockLens[k]; i++) {
      int pos1=optAln[k][0][i];
      int pos2=optAln[k][1][i];
      Atom a1=ca1[pos1];
      Atom a2=(Atom)ca2[pos2].clone();
      ca1block[position]=a1;
      ca2block[position]=a2;
      position++;
    }
    if (position != afpChainb.getOptLen()[k]) {
      logger.warn(""String_Node_Str"" + pos + ""String_Node_Str""+ afpChainb.getOptLen()[k]);
      ca1block=(Atom[])resizeArray(ca1block,position);
      ca2block=(Atom[])resizeArray(ca2block,position);
    }
    SVDSuperimposer svdb=new SVDSuperimposer(ca1block,ca2block);
    Matrix matrixb=svdb.getRotation();
    Atom shiftb=svdb.getTranslation();
    Matrix[] blockMxsb=new Matrix[afpChain.getBlockNum()];
    Arrays.fill(blockMxsb,matrix);
    afpChainb.setBlockRotationMatrix(blockMxsb);
    Atom[] blockShiftsb=new Atom[afpChainb.getBlockNum()];
    Arrays.fill(blockShiftsb,shiftb);
    afpChainb.setBlockShiftVector(blockShiftsb);
    for (    Atom a : ca2block) {
      Calc.rotate(a,matrixb);
      Calc.shift(a,shiftb);
    }
    double rmsdb=SVDSuperimposer.getRMS(ca1block,ca2block);
    double tmScoreb=SVDSuperimposer.getTMScore(ca1block,ca2block,ca1.length,ca2.length);
    blockRMSD[k]=rmsdb;
    blockScore[k]=tmScoreb;
  }
  afpChain.setOptRmsd(blockRMSD);
  afpChain.setBlockRmsd(blockRMSD);
  afpChain.setBlockScore(blockScore);
}","/** 
 * After the alignment changes (optAln, optLen, blockNum, at a minimum), many other properties which depend on the superposition will be invalid. This method re-runs a rigid superposition over the whole alignment and repopulates the required properties, including RMSD (TotalRMSD) and TM-Score.
 * @param afpChain
 * @param ca1
 * @param ca2 Second set of ca atoms. Will be modified based on the superposition
 * @throws StructureException
 * @see {@link CECalculator#calc_rmsd(Atom[],Atom[],int,boolean)}contains much of the same code, but stores results in a CECalculator instance rather than an AFPChain
 */
public static void updateSuperposition(AFPChain afpChain,Atom[] ca1,Atom[] ca2) throws StructureException {
  afpChain.setCa1Length(ca1.length);
  afpChain.setCa2Length(ca2.length);
  int[] focusRes1=afpChain.getFocusRes1();
  int[] focusRes2=afpChain.getFocusRes2();
  if (focusRes1 == null) {
    focusRes1=new int[afpChain.getCa1Length()];
    afpChain.setFocusRes1(focusRes1);
  }
  if (focusRes2 == null) {
    focusRes2=new int[afpChain.getCa2Length()];
    afpChain.setFocusRes2(focusRes2);
  }
  if (afpChain.getNrEQR() == 0)   return;
  Atom[] ca1aligned=new Atom[afpChain.getOptLength()];
  Atom[] ca2aligned=new Atom[afpChain.getOptLength()];
  int pos=0;
  int[] blockLens=afpChain.getOptLen();
  int[][][] optAln=afpChain.getOptAln();
  assert(afpChain.getBlockNum() <= optAln.length);
  for (int block=0; block < afpChain.getBlockNum(); block++) {
    for (int i=0; i < blockLens[block]; i++) {
      int pos1=optAln[block][0][i];
      int pos2=optAln[block][1][i];
      Atom a1=ca1[pos1];
      Atom a2=(Atom)ca2[pos2].clone();
      ca1aligned[pos]=a1;
      ca2aligned[pos]=a2;
      pos++;
    }
  }
  if (pos != afpChain.getOptLength()) {
    logger.warn(""String_Node_Str"" + pos + ""String_Node_Str""+ afpChain.getOptLength());
    ca1aligned=(Atom[])resizeArray(ca1aligned,pos);
    ca2aligned=(Atom[])resizeArray(ca2aligned,pos);
  }
  SVDSuperimposer svd=new SVDSuperimposer(ca1aligned,ca2aligned);
  Matrix matrix=svd.getRotation();
  Atom shift=svd.getTranslation();
  Matrix[] blockMxs=new Matrix[afpChain.getBlockNum()];
  Arrays.fill(blockMxs,matrix);
  afpChain.setBlockRotationMatrix(blockMxs);
  Atom[] blockShifts=new Atom[afpChain.getBlockNum()];
  Arrays.fill(blockShifts,shift);
  afpChain.setBlockShiftVector(blockShifts);
  for (  Atom a : ca2aligned) {
    Calc.rotate(a,matrix);
    Calc.shift(a,shift);
  }
  double rmsd=SVDSuperimposer.getRMS(ca1aligned,ca2aligned);
  double tmScore=SVDSuperimposer.getTMScore(ca1aligned,ca2aligned,ca1.length,ca2.length);
  afpChain.setTotalRmsdOpt(rmsd);
  afpChain.setTMScore(tmScore);
  double[] blockRMSD=new double[afpChain.getBlockNum()];
  double[] blockScore=new double[afpChain.getBlockNum()];
  for (int k=0; k < afpChain.getBlockNum(); k++) {
    AFPChain afpChainb=(AFPChain)afpChain.clone();
    Atom[] ca1block=new Atom[afpChainb.getOptLen()[k]];
    Atom[] ca2block=new Atom[afpChainb.getOptLen()[k]];
    int position=0;
    for (int i=0; i < blockLens[k]; i++) {
      int pos1=optAln[k][0][i];
      int pos2=optAln[k][1][i];
      Atom a1=ca1[pos1];
      Atom a2=(Atom)ca2[pos2].clone();
      ca1block[position]=a1;
      ca2block[position]=a2;
      position++;
    }
    if (position != afpChainb.getOptLen()[k]) {
      logger.warn(""String_Node_Str"" + pos + ""String_Node_Str""+ afpChainb.getOptLen()[k]);
      ca1block=(Atom[])resizeArray(ca1block,position);
      ca2block=(Atom[])resizeArray(ca2block,position);
    }
    SVDSuperimposer svdb=new SVDSuperimposer(ca1block,ca2block);
    Matrix matrixb=svdb.getRotation();
    Atom shiftb=svdb.getTranslation();
    Matrix[] blockMxsb=new Matrix[afpChain.getBlockNum()];
    Arrays.fill(blockMxsb,matrix);
    afpChainb.setBlockRotationMatrix(blockMxsb);
    Atom[] blockShiftsb=new Atom[afpChainb.getBlockNum()];
    Arrays.fill(blockShiftsb,shiftb);
    afpChainb.setBlockShiftVector(blockShiftsb);
    for (    Atom a : ca2block) {
      Calc.rotate(a,matrixb);
      Calc.shift(a,shiftb);
    }
    double rmsdb=SVDSuperimposer.getRMS(ca1block,ca2block);
    double tmScoreb=SVDSuperimposer.getTMScore(ca1block,ca2block,ca1.length,ca2.length);
    blockRMSD[k]=rmsdb;
    blockScore[k]=tmScoreb;
  }
  afpChain.setOptRmsd(blockRMSD);
  afpChain.setBlockRmsd(blockRMSD);
  afpChain.setBlockScore(blockScore);
}",0.9914785812989406
16746,"public BiojavaJmol(){
  frame=new JFrame();
  JMenuBar menu=MenuCreator.initMenu();
  frame.setJMenuBar(menu);
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      frame.dispose();
    }
  }
);
  Container contentPane=frame.getContentPane();
  Box vBox=Box.createVerticalBox();
  jmolPanel=new JmolPanel();
  jmolPanel.setPreferredSize(new Dimension(500,500));
  vBox.add(jmolPanel);
  JTextField field=new JTextField();
  field.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  field.setText(""String_Node_Str"");
  org.biojava.nbio.structure.align.gui.jmol.RasmolCommandListener listener=new org.biojava.nbio.structure.align.gui.jmol.RasmolCommandListener(jmolPanel,field);
  field.addActionListener(listener);
  field.addMouseListener(listener);
  field.addKeyListener(listener);
  vBox.add(field);
  Box hBox1=Box.createHorizontalBox();
  String[] styles=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox style=new JComboBox(styles);
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(style);
  vBox.add(hBox1);
  style.addActionListener(jmolPanel);
  String[] colorModes=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox colors=new JComboBox(colorModes);
  colors.addActionListener(jmolPanel);
  hBox1.add(Box.createGlue());
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(colors);
  Box hBox2=Box.createHorizontalBox();
  JButton resetDisplay=new JButton(""String_Node_Str"");
  resetDisplay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      System.out.println(""String_Node_Str"");
      jmolPanel.executeCmd(""String_Node_Str"");
    }
  }
);
  hBox2.add(resetDisplay);
  hBox2.add(Box.createGlue());
  JCheckBox toggleSelection=new JCheckBox(""String_Node_Str"");
  toggleSelection.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      boolean showSelection=(e.getStateChange() == ItemEvent.SELECTED);
      if (showSelection) {
        jmolPanel.executeCmd(""String_Node_Str"");
      }
 else {
        jmolPanel.executeCmd(""String_Node_Str"");
      }
    }
  }
);
  hBox2.add(toggleSelection);
  hBox2.add(Box.createGlue());
  vBox.add(hBox2);
  contentPane.add(vBox);
  frame.pack();
  frame.setVisible(true);
}","public BiojavaJmol(){
  frame=new JFrame();
  JMenuBar menu=MenuCreator.initMenu();
  frame.setJMenuBar(menu);
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      frame.dispose();
    }
  }
);
  Container contentPane=frame.getContentPane();
  Box vBox=Box.createVerticalBox();
  jmolPanel=new JmolPanel();
  jmolPanel.setPreferredSize(new Dimension(500,500));
  vBox.add(jmolPanel);
  JTextField field=new JTextField();
  field.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  field.setText(""String_Node_Str"");
  org.biojava.nbio.structure.align.gui.jmol.RasmolCommandListener listener=new org.biojava.nbio.structure.align.gui.jmol.RasmolCommandListener(jmolPanel,field);
  field.addActionListener(listener);
  field.addMouseListener(listener);
  field.addKeyListener(listener);
  vBox.add(field);
  Box hBox1=Box.createHorizontalBox();
  hBox1.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  String[] styles=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox style=new JComboBox(styles);
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(style);
  vBox.add(hBox1);
  style.addActionListener(jmolPanel);
  String[] colorModes=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JComboBox colors=new JComboBox(colorModes);
  colors.addActionListener(jmolPanel);
  hBox1.add(Box.createGlue());
  hBox1.add(new JLabel(""String_Node_Str""));
  hBox1.add(colors);
  Box hBox2=Box.createHorizontalBox();
  hBox2.setMaximumSize(new Dimension(Short.MAX_VALUE,30));
  JButton resetDisplay=new JButton(""String_Node_Str"");
  resetDisplay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      System.out.println(""String_Node_Str"");
      jmolPanel.executeCmd(""String_Node_Str"");
    }
  }
);
  hBox2.add(resetDisplay);
  hBox2.add(Box.createGlue());
  JCheckBox toggleSelection=new JCheckBox(""String_Node_Str"");
  toggleSelection.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      boolean showSelection=(e.getStateChange() == ItemEvent.SELECTED);
      if (showSelection) {
        jmolPanel.executeCmd(""String_Node_Str"");
      }
 else {
        jmolPanel.executeCmd(""String_Node_Str"");
      }
    }
  }
);
  hBox2.add(toggleSelection);
  hBox2.add(Box.createGlue());
  vBox.add(hBox2);
  contentPane.add(vBox);
  frame.pack();
  frame.setVisible(true);
}",0.9766151407055094
16747,"public static final String convertAtomsToSeq(Atom[] atoms){
  StringBuilder buf=new StringBuilder();
  Group prevGroup=null;
  for (  Atom a : atoms) {
    Group g=a.getGroup();
    if (prevGroup != null) {
      if (prevGroup.equals(g)) {
        continue;
      }
    }
    String code3=g.getPDBName();
    try {
      buf.append(convert_3code_1code(code3));
    }
 catch (    UnknownPdbAminoAcidException e) {
      buf.append('X');
    }
    prevGroup=g;
  }
  return buf.toString();
}","public static final String convertAtomsToSeq(Atom[] atoms){
  StringBuilder buf=new StringBuilder();
  Group prevGroup=null;
  for (  Atom a : atoms) {
    Group g=a.getGroup();
    if (prevGroup != null) {
      if (prevGroup.equals(g)) {
        continue;
      }
    }
    String code3=g.getPDBName();
    Character code1=get1LetterCodeAmino(code3);
    if (code1 == null)     code1=UNKNOWN_GROUP_LABEL;
    buf.append(code1);
    prevGroup=g;
  }
  return buf.toString();
}",0.6977225672877847
16748,"/** 
 * Convert three character amino acid codes into single character e.g. convert CYS to C
 * @return a character
 * @param code3 a three character amino acid representation String
 * @throws UnknownPdbAminoAcidException
 * @see {@link #get1LetterCode(String)}
 */
public static final Character convert_3code_1code(String code3) throws UnknownPdbAminoAcidException {
  Character code1=null;
  code1=aminoAcids.get(code3);
  if (code1 == null) {
    throw new UnknownPdbAminoAcidException(code3 + ""String_Node_Str"");
  }
 else {
    return code1;
  }
}","/** 
 * @param code3
 * @return
 * @deprecated Use {@link #get1LetterCodeAmino(String)} instead
 */
@Deprecated public static final Character convert_3code_1code(String code3){
  return get1LetterCodeAmino(code3);
}",0.2786458333333333
16749,"/** 
 * Count how many number of Atoms are contained within a Structure object.
 * @param s the structure object
 * @return the number of Atoms in this Structure
 */
public static final int getNrAtoms(Structure s){
  int nrAtoms=0;
  Iterator<Group> iter=new GroupIterator(s);
  while (iter.hasNext()) {
    Group g=iter.next();
    nrAtoms+=g.size();
  }
  return nrAtoms;
}","/** 
 * Count how many Atoms are contained within a Structure object.
 * @param s the structure object
 * @return the number of Atoms in this Structure
 */
public static final int getNrAtoms(Structure s){
  int nrAtoms=0;
  Iterator<Group> iter=new GroupIterator(s);
  while (iter.hasNext()) {
    Group g=iter.next();
    nrAtoms+=g.size();
  }
  return nrAtoms;
}",0.9864864864864864
16750,"/** 
 * Returns the set of intra-chain contacts for the given chain for C-alpha atoms (including non-standard  aminoacids appearing as HETATM groups), i.e. the contact map. Uses a geometric hashing algorithm that speeds up the calculation without need of full distance matrix.   The parsing mode   {@link FileParsingParameters#setAlignSeqRes(boolean)} needs to be set to true for this to work.
 * @param chain
 * @param cutoff
 * @return
 * @deprecated Use the more generic {@link #getRepresentativeAtomsInContact(Chain,double)} instead
 */
@Deprecated public static AtomContactSet getAtomsCAInContact(Chain chain,double cutoff){
  Grid grid=new Grid(cutoff);
  Atom[] atoms=getAtomCAArray(chain);
  grid.addAtoms(atoms);
  return grid.getContacts();
}","/** 
 * Returns the set of intra-chain contacts for the given chain for C-alpha atoms (including non-standard  aminoacids appearing as HETATM groups), i.e. the contact map. Uses a geometric hashing algorithm that speeds up the calculation without need of full distance matrix.   The parsing mode   {@link FileParsingParameters#setAlignSeqRes(boolean)} needs to be set to true for this to work.
 * @param chain
 * @param cutoff
 * @return
 * @see {@link #getRepresentativeAtomsInContact(Chain,double)}
 */
public static AtomContactSet getAtomsCAInContact(Chain chain,double cutoff){
  Grid grid=new Grid(cutoff);
  Atom[] atoms=getAtomCAArray(chain);
  grid.addAtoms(atoms);
  return grid.getContacts();
}",0.962912087912088
16751,"/** 
 * Return an Atom array of the C-alpha atoms. Any atom that is a carbon and has CA name will be returned.
 * @param s the structure object
 * @return an Atom[] array
 * @deprecated Use the more generic {@link #getRepresentativeAtomArray(Structure)} instead
 */
@Deprecated public static Atom[] getAtomCAArray(Structure s){
  List<Atom> atoms=new ArrayList<Atom>();
  for (  Chain c : s.getChains()) {
    for (    Group g : c.getAtomGroups()) {
      if (g.hasAtom(CA_ATOM_NAME) && g.getAtom(CA_ATOM_NAME).getElement() == Element.C) {
        atoms.add(g.getAtom(CA_ATOM_NAME));
      }
    }
  }
  return atoms.toArray(new Atom[atoms.size()]);
}","/** 
 * Return an Atom array of the C-alpha atoms. Any atom that is a carbon and has CA name will be returned.
 * @param s the structure object
 * @return an Atom[] array
 * @see #getRepresentativeAtomArray(Structure)
 */
public static Atom[] getAtomCAArray(Structure s){
  List<Atom> atoms=new ArrayList<Atom>();
  for (  Chain c : s.getChains()) {
    for (    Group g : c.getAtomGroups()) {
      if (g.hasAtom(CA_ATOM_NAME) && g.getAtom(CA_ATOM_NAME).getElement() == Element.C) {
        atoms.add(g.getAtom(CA_ATOM_NAME));
      }
    }
  }
  return atoms.toArray(new Atom[atoms.size()]);
}",0.9406099518459068
16752,"/** 
 * Convert a three letter aminoacid code into a single character code. If the code does not correspond to a amino acid or nucleotide, returns  {@link #UNKNOWN_GROUP_LABEL}. Returned null for nucleotides prior to version 4.0.1.
 * @param groupCode3 three letter representation
 * @return The 1-letter abbreviation
 */
public static final Character get1LetterCode(String groupCode3){
  Character aminoCode1;
  try {
    aminoCode1=convert_3code_1code(groupCode3);
  }
 catch (  UnknownPdbAminoAcidException e) {
    groupCode3=groupCode3.trim();
    if (isNucleotide(groupCode3)) {
      aminoCode1=nucleotides30.get(groupCode3);
      if (aminoCode1 == null) {
        aminoCode1=nucleotides23.get(groupCode3);
      }
      if (aminoCode1 == null) {
        aminoCode1=UNKNOWN_GROUP_LABEL;
      }
    }
 else {
      aminoCode1=UNKNOWN_GROUP_LABEL;
    }
  }
  return aminoCode1;
}","/** 
 * Convert a three letter amino acid or nucleotide code into a single character code. If the code does not correspond to an amino acid or nucleotide, returns  {@link #UNKNOWN_GROUP_LABEL}. Returned null for nucleotides prior to version 4.0.1.
 * @param groupCode3 three letter representation
 * @return The 1-letter abbreviation
 */
public static final Character get1LetterCode(String groupCode3){
  Character code1;
  code1=get1LetterCodeAmino(groupCode3);
  if (code1 == null) {
    groupCode3=groupCode3.trim();
    if (isNucleotide(groupCode3)) {
      code1=nucleotides30.get(groupCode3);
      if (code1 == null) {
        code1=nucleotides23.get(groupCode3);
      }
      if (code1 == null) {
        code1=UNKNOWN_GROUP_LABEL;
      }
    }
 else {
      code1=UNKNOWN_GROUP_LABEL;
    }
  }
  return code1;
}",0.8678362573099415
16753,"public static final boolean isNucleotide(String groupCode3){
  String code=groupCode3.trim();
  return nucleotides30.containsKey(code) || nucleotides23.containsKey(code);
}","/** 
 * Test if the three-letter code of an ATOM entry corresponds to a nucleotide or to an aminoacid.
 * @param a 3-character code for a group.
 */
public static final boolean isNucleotide(String groupCode3){
  String code=groupCode3.trim();
  return nucleotides30.containsKey(code) || nucleotides23.containsKey(code);
}",0.6977687626774848
16754,"private void initResSerialsMap(Chain c){
  if (c.getSeqResGroups().isEmpty()) {
    logger.warn(""String_Node_Str"",c.getChainID());
  }
  Map<ResidueNumber,Integer> resNums2ResSerials=new HashMap<ResidueNumber,Integer>();
  chains2pdbResNums2ResSerials.put(c.getChainID(),resNums2ResSerials);
  for (int i=0; i < c.getSeqResGroups().size(); i++) {
    resNums2ResSerials.put(c.getSeqResGroup(i).getResidueNumber(),i + 1);
  }
}","private void initResSerialsMap(Chain c){
  if (c.getSeqResGroups() == null || c.getSeqResGroups().isEmpty()) {
    logger.warn(""String_Node_Str"" + ""String_Node_Str"",c.getChainID());
  }
  Map<ResidueNumber,Integer> resNums2ResSerials=new HashMap<ResidueNumber,Integer>();
  chains2pdbResNums2ResSerials.put(c.getChainID(),resNums2ResSerials);
  if (c.getSeqResGroups() == null)   return;
  for (int i=0; i < c.getSeqResGroups().size(); i++) {
    resNums2ResSerials.put(c.getSeqResGroup(i).getResidueNumber(),i + 1);
  }
}",0.8987341772151899
16755,"/** 
 * Given a Group g of Chain c (member of this Compound) return the corresponding position in the  alignment of all member sequences (1-based numbering), i.e. this is equivalent  to getting the index (1-based) in the SEQRES sequence.  If   {@link FileParsingParameters#setAlignSeqRes(boolean)} is not used, a mapping will not be availableand this method will return -1 for all residues of all chains.
 * @param g
 * @param c
 * @return the aligned residue index (1 to n) or -1 if no mapping exists for the given group
 * @throws IllegalArgumentException if the given Chain is not a member of this Compound
 * @see {@link Chain#getSeqResGroup(int)} 
 */
public int getAlignedResIndex(Group g,Chain c){
  if (!chains.contains(c))   throw new IllegalArgumentException(""String_Node_Str"" + c.getChainID() + ""String_Node_Str""+ getChainIds().toString());
  if (chains2pdbResNums2ResSerials.isEmpty() || !chains2pdbResNums2ResSerials.containsKey(c.getChainID())) {
    initResSerialsMap(c);
  }
  Integer alignedSerial=chains2pdbResNums2ResSerials.get(c.getChainID()).get(g.getResidueNumber());
  if (alignedSerial == null) {
    return -1;
  }
  return alignedSerial;
}","/** 
 * Given a Group g of Chain c (member of this Compound) return the corresponding position in the  alignment of all member sequences (1-based numbering), i.e. the index (1-based) in the SEQRES sequence. This allows for comparisons of residues belonging to different chains of the same Compound (entity). <p> If   {@link FileParsingParameters#setAlignSeqRes(boolean)} is not used or SEQRES not present, a mapping will not be available and this method will return  {@link ResidueNumber#getSeqNum()} for all residues, whichin some cases will be correctly aligned indices (when no insertion codes are  used and when all chains within the entity are numbered in the same way), but in general they will be neither unique (because of insertion codes) nor aligned. </p>
 * @param g
 * @param c
 * @return the aligned residue index (1 to n) or {@link ResidueNumber#getSeqNum()} if no mapping exists for the given group and chain
 * @throws IllegalArgumentException if the given Chain is not a member of this Compound
 * @see {@link Chain#getSeqResGroup(int)} 
 */
public int getAlignedResIndex(Group g,Chain c){
  boolean contained=false;
  for (  Chain member : getChains()) {
    if (c.getChainID().equals(member.getChainID())) {
      contained=true;
      break;
    }
  }
  if (!contained)   throw new IllegalArgumentException(""String_Node_Str"" + c.getChainID() + ""String_Node_Str""+ getChainIds().toString());
  if (chains2pdbResNums2ResSerials.isEmpty() || !chains2pdbResNums2ResSerials.containsKey(c.getChainID())) {
    initResSerialsMap(c);
  }
  Integer alignedSerial=chains2pdbResNums2ResSerials.get(c.getChainID()).get(g.getResidueNumber());
  if (alignedSerial == null) {
    return g.getResidueNumber().getSeqNum();
  }
  return alignedSerial;
}",0.6808219178082192
16756,"/** 
 * Returns the set of inter-chain contacts between the two given chains for all non-H atoms. Uses a geometric hashing algorithm that speeds up the calculation without need of full distance matrix. 
 * @param chain1
 * @param chain2
 * @param cutoff
 * @param hetAtoms if true HET atoms are included, if false they are not
 * @return
 */
public static AtomContactSet getAtomsInContact(Chain chain1,Chain chain2,double cutoff,boolean hetAtoms){
  return getAtomsInContact(chain1,chain2,null,cutoff,hetAtoms);
}","/** 
 * Returns the set of inter-chain contacts between the two given chains for all non-H atoms. Uses a geometric hashing algorithm that speeds up the calculation without need of full distance matrix. The parsing mode   {@link FileParsingParameters#setAlignSeqRes(boolean)} needs to be set to true for this to work.  
 * @param chain1
 * @param chain2
 * @param cutoff
 * @param hetAtoms if true HET atoms are included, if false they are not
 * @return
 */
public static AtomContactSet getAtomsInContact(Chain chain1,Chain chain2,double cutoff,boolean hetAtoms){
  return getAtomsInContact(chain1,chain2,null,cutoff,hetAtoms);
}",0.8984238178633975
16757,"/** 
 * Returns the set of intra-chain contacts for the given chain for C-alpha atoms (including non-standard  aminoacids appearing as HETATM groups), i.e. the contact map. Uses a geometric hashing algorithm that speeds up the calculation without need of full distance matrix.  
 * @param chain
 * @param cutoff
 * @return
 */
public static AtomContactSet getAtomsCAInContact(Chain chain,double cutoff){
  Grid grid=new Grid(cutoff);
  Atom[] atoms=getAtomCAArray(chain);
  grid.addAtoms(atoms);
  return grid.getContacts();
}","/** 
 * Returns the set of intra-chain contacts for the given chain for C-alpha atoms (including non-standard  aminoacids appearing as HETATM groups), i.e. the contact map. Uses a geometric hashing algorithm that speeds up the calculation without need of full distance matrix.   The parsing mode   {@link FileParsingParameters#setAlignSeqRes(boolean)} needs to be set to true for this to work.
 * @param chain
 * @param cutoff
 * @return
 */
public static AtomContactSet getAtomsCAInContact(Chain chain,double cutoff){
  Grid grid=new Grid(cutoff);
  Atom[] atoms=getAtomCAArray(chain);
  grid.addAtoms(atoms);
  return grid.getContacts();
}",0.9014567266495288
16758,"public void add(GroupContact groupContact){
  contacts.put(getResNumberPairFromContact(groupContact),groupContact);
}","public void add(GroupContact groupContact){
  contacts.put(getResIdPairFromContact(groupContact),groupContact);
}",0.9652173913043478
16759,"/** 
 * Constructs a <code>GroupContactSet</code> by collapsing the given <code>AtomContactSet</code> into residue-residue (group-group) contacts. 
 * @param atomContacts
 */
public GroupContactSet(AtomContactSet atomContacts){
  contacts=new HashMap<Pair<ResidueNumber>,GroupContact>();
  atoms2groups(atomContacts);
}","/** 
 * Constructs a <code>GroupContactSet</code> by collapsing the given <code>AtomContactSet</code> into residue-residue (group-group) contacts. 
 * @param atomContacts
 */
public GroupContactSet(AtomContactSet atomContacts){
  contacts=new HashMap<Pair<ResidueIdentifier>,GroupContact>();
  atoms2groups(atomContacts);
}",0.9813084112149532
16760,"private void atoms2groups(AtomContactSet atomContacts){
  for (  AtomContact atomContact : atomContacts) {
    Pair<Atom> atomPair=atomContact.getPair();
    Group iResidue=atomPair.getFirst().getGroup();
    Group jResidue=atomPair.getSecond().getGroup();
    if (iResidue.equals(jResidue))     continue;
    Pair<Group> residuePair=new Pair<Group>(iResidue,jResidue);
    Pair<ResidueNumber> pair=new Pair<ResidueNumber>(iResidue.getResidueNumber(),jResidue.getResidueNumber());
    if (!contacts.containsKey(pair)) {
      GroupContact groupContact=new GroupContact();
      groupContact.setPair(residuePair);
      groupContact.addAtomContact(atomContact);
      contacts.put(pair,groupContact);
    }
 else {
      GroupContact groupContact=contacts.get(pair);
      groupContact.addAtomContact(atomContact);
    }
  }
}","private void atoms2groups(AtomContactSet atomContacts){
  for (  AtomContact atomContact : atomContacts) {
    Pair<Atom> atomPair=atomContact.getPair();
    Group iResidue=atomPair.getFirst().getGroup();
    Group jResidue=atomPair.getSecond().getGroup();
    if (iResidue.equals(jResidue))     continue;
    Pair<Group> residuePair=new Pair<Group>(iResidue,jResidue);
    Pair<ResidueIdentifier> pair=new Pair<ResidueIdentifier>(new ResidueIdentifier(iResidue),new ResidueIdentifier(jResidue));
    if (!contacts.containsKey(pair)) {
      GroupContact groupContact=new GroupContact();
      groupContact.setPair(residuePair);
      groupContact.addAtomContact(atomContact);
      contacts.put(pair,groupContact);
    }
 else {
      GroupContact groupContact=contacts.get(pair);
      groupContact.addAtomContact(atomContact);
    }
  }
}",0.9279711884753902
16761,"/** 
 * Tell whether the given pair is a contact in this GroupContactSet, in a chain-identifier independent way: contacts happening between different copies of  the same Compound(Entity) will be considered equal as long as they have the same residue numbers.
 * @param resId1
 * @param resId2
 * @return
 */
public boolean hasContact(ResidueIdentifier resId1,ResidueIdentifier resId2){
  if (residueIdContacts == null) {
    initResidueIdContacts();
  }
  return residueIdContacts.contains(new Pair<ResidueIdentifier>(resId1,resId2));
}","/** 
 * Tell whether the given pair is a contact in this GroupContactSet, in a chain-identifier independent way: contacts happening between different copies of  the same Compound(Entity) will be considered equal as long as they have the same residue numbers.
 * @param resId1
 * @param resId2
 * @return
 */
public boolean hasContact(ResidueIdentifier resId1,ResidueIdentifier resId2){
  return contacts.containsKey(new Pair<ResidueIdentifier>(resId1,resId2));
}",0.9038076152304608
16762,"public ResidueIdentifier(int seqNum,Character insCode){
  this.seqNum=seqNum;
  this.insCode=insCode;
}","public ResidueIdentifier(Group g){
  Chain c=g.getChain();
  if (c == null) {
    logger.warn(""String_Node_Str"",g.toString());
    this.seqResIndex=-1;
  }
 else {
    Compound comp=c.getCompound();
    if (comp == null) {
      logger.warn(""String_Node_Str"",g.toString());
      this.seqResIndex=-1;
    }
 else {
      this.seqResIndex=comp.getAlignedResIndex(g,c);
    }
  }
}",0.1784232365145228
16763,"@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + seqNum;
  result=prime * result + (insCode == null ? 0 : insCode);
  return result;
}","@Override public int hashCode(){
  return seqResIndex;
}",0.3949579831932773
16764,"@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  ResidueIdentifier other=(ResidueIdentifier)obj;
  if (this.seqNum != other.seqNum)   return false;
  if (this.insCode == null && other.insCode != null)   return false;
  if (this.insCode != null && other.insCode == null)   return false;
  if (this.insCode == null && other.insCode == null)   return true;
  if (this.insCode != other.insCode)   return false;
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  ResidueIdentifier other=(ResidueIdentifier)obj;
  return this.seqResIndex == other.seqResIndex;
}",0.5947955390334573
16765,"@Override public String toString(){
  return ""String_Node_Str"" + seqNum + (insCode == null ? ""String_Node_Str"" : insCode);
}","@Override public String toString(){
  return ""String_Node_Str"" + seqResIndex;
}",0.729064039408867
16766,"/** 
 * Calculates the contact overlap score between this StructureInterface and the given one.  The two sides of the given StructureInterface need to match this StructureInterface in the sense that they must come from the same Compound (Entity), i.e. their residue numbers need to align with 100% identity, except for unobserved  density residues.
 * @param other
 * @param invert if false the comparison will be done first-to-first and second-to-second, if true the match will be first-to-second and second-to-first
 * @return the contact overlap score, range [0.0,1.0]
 */
public double getContactOverlapScore(StructureInterface other,boolean invert){
  Structure thisStruct=getParentStructure();
  Structure otherStruct=other.getParentStructure();
  if (thisStruct != otherStruct) {
    logger.warn(""String_Node_Str"");
    return 0;
  }
  Pair<Chain> thisChains=getParentChains();
  Pair<Chain> otherChains=other.getParentChains();
  if (thisChains.getFirst().getCompound() == null || thisChains.getSecond().getCompound() == null || otherChains.getFirst().getCompound() == null || otherChains.getSecond().getCompound() == null) {
    logger.warn(""String_Node_Str"",this.getId(),other.getId());
    return 0;
  }
  Pair<Compound> thisCompounds=new Pair<Compound>(thisChains.getFirst().getCompound(),thisChains.getSecond().getCompound());
  Pair<Compound> otherCompounds=new Pair<Compound>(otherChains.getFirst().getCompound(),otherChains.getSecond().getCompound());
  if (((thisCompounds.getFirst() == otherCompounds.getFirst()) && (thisCompounds.getSecond() == otherCompounds.getSecond())) || ((thisCompounds.getFirst() == otherCompounds.getSecond()) && (thisCompounds.getSecond() == otherCompounds.getFirst()))) {
    int common=0;
    GroupContactSet thisContacts=getGroupContacts();
    GroupContactSet otherContacts=other.getGroupContacts();
    for (    GroupContact thisContact : thisContacts) {
      ResidueIdentifier first=null;
      ResidueIdentifier second=null;
      if (!invert) {
        first=new ResidueIdentifier(thisContact.getPair().getFirst().getResidueNumber().getSeqNum(),thisContact.getPair().getFirst().getResidueNumber().getInsCode());
        second=new ResidueIdentifier(thisContact.getPair().getSecond().getResidueNumber().getSeqNum(),thisContact.getPair().getSecond().getResidueNumber().getInsCode());
      }
 else {
        first=new ResidueIdentifier(thisContact.getPair().getSecond().getResidueNumber().getSeqNum(),thisContact.getPair().getSecond().getResidueNumber().getInsCode());
        second=new ResidueIdentifier(thisContact.getPair().getFirst().getResidueNumber().getSeqNum(),thisContact.getPair().getFirst().getResidueNumber().getInsCode());
      }
      if (otherContacts.hasContact(first,second)) {
        common++;
      }
    }
    return (2.0 * common) / (thisContacts.size() + otherContacts.size());
  }
 else {
    logger.debug(""String_Node_Str"",thisChains.getFirst().getChainID(),thisChains.getSecond().getChainID(),otherChains.getFirst().getChainID(),otherChains.getSecond().getChainID());
    return 0.0;
  }
}","/** 
 * Calculates the contact overlap score between this StructureInterface and the given one.  The two sides of the given StructureInterface need to match this StructureInterface in the sense that they must come from the same Compound (Entity), i.e. their residue numbers need to align with 100% identity, except for unobserved  density residues. The SEQRES indices obtained through   {@link Compound#getAlignedResIndex(Group,Chain)} areused to match residues, thus if no SEQRES is present or if  {@link FileParsingParameters#setAlignSeqRes(boolean)}is not used, this calculation is not guaranteed to work properly.
 * @param other
 * @param invert if false the comparison will be done first-to-first and second-to-second, if true the match will be first-to-second and second-to-first
 * @return the contact overlap score, range [0.0,1.0]
 */
public double getContactOverlapScore(StructureInterface other,boolean invert){
  Structure thisStruct=getParentStructure();
  Structure otherStruct=other.getParentStructure();
  if (thisStruct != otherStruct) {
    logger.warn(""String_Node_Str"");
    return 0;
  }
  Pair<Chain> thisChains=getParentChains();
  Pair<Chain> otherChains=other.getParentChains();
  if (thisChains.getFirst().getCompound() == null || thisChains.getSecond().getCompound() == null || otherChains.getFirst().getCompound() == null || otherChains.getSecond().getCompound() == null) {
    logger.warn(""String_Node_Str"",this.getId(),other.getId());
    return 0;
  }
  Pair<Compound> thisCompounds=new Pair<Compound>(thisChains.getFirst().getCompound(),thisChains.getSecond().getCompound());
  Pair<Compound> otherCompounds=new Pair<Compound>(otherChains.getFirst().getCompound(),otherChains.getSecond().getCompound());
  if (((thisCompounds.getFirst() == otherCompounds.getFirst()) && (thisCompounds.getSecond() == otherCompounds.getSecond())) || ((thisCompounds.getFirst() == otherCompounds.getSecond()) && (thisCompounds.getSecond() == otherCompounds.getFirst()))) {
    int common=0;
    GroupContactSet thisContacts=getGroupContacts();
    GroupContactSet otherContacts=other.getGroupContacts();
    for (    GroupContact thisContact : thisContacts) {
      ResidueIdentifier first=null;
      ResidueIdentifier second=null;
      if (!invert) {
        first=new ResidueIdentifier(thisContact.getPair().getFirst());
        second=new ResidueIdentifier(thisContact.getPair().getSecond());
      }
 else {
        first=new ResidueIdentifier(thisContact.getPair().getSecond());
        second=new ResidueIdentifier(thisContact.getPair().getFirst());
      }
      if (otherContacts.hasContact(first,second)) {
        common++;
      }
    }
    return (2.0 * common) / (thisContacts.size() + otherContacts.size());
  }
 else {
    logger.debug(""String_Node_Str"",thisChains.getFirst().getChainID(),thisChains.getSecond().getChainID(),otherChains.getFirst().getChainID(),otherChains.getSecond().getChainID());
    return 0.0;
  }
}",0.8267729613021093
16767,"/** 
 * Calculate the interface clusters for this StructureInterfaceList  using a contact overlap score to measure the similarity of interfaces. Subsequent calls will use the cached value without recomputing the clusters.
 * @param contactOverlapScoreClusterCutoff the contact overlap score above which a pair will be clustered
 * @return
 */
public List<StructureInterfaceCluster> getClusters(double contactOverlapScoreClusterCutoff){
  if (clusters != null) {
    return clusters;
  }
  clusters=new ArrayList<StructureInterfaceCluster>();
  if (list.size() == 0)   return clusters;
  double[][] matrix=new double[list.size()][list.size()];
  for (int i=0; i < list.size(); i++) {
    for (int j=i + 1; j < list.size(); j++) {
      StructureInterface iInterf=list.get(i);
      StructureInterface jInterf=list.get(j);
      double scoreDirect=iInterf.getContactOverlapScore(jInterf,false);
      double scoreInvert=iInterf.getContactOverlapScore(jInterf,true);
      double maxScore=Math.max(scoreDirect,scoreInvert);
      matrix[i][j]=maxScore;
    }
  }
  SingleLinkageClusterer slc=new SingleLinkageClusterer(matrix,true);
  Map<Integer,Set<Integer>> clusteredIndices=slc.getClusters(contactOverlapScoreClusterCutoff);
  for (  int clusterIdx : clusteredIndices.keySet()) {
    List<StructureInterface> members=new ArrayList<StructureInterface>();
    for (    int idx : clusteredIndices.get(clusterIdx)) {
      members.add(list.get(idx));
    }
    StructureInterfaceCluster cluster=new StructureInterfaceCluster();
    cluster.setMembers(members);
    double averageScore=0.0;
    int countPairs=0;
    for (int i=0; i < members.size(); i++) {
      for (int j=i + 1; j < members.size(); j++) {
        averageScore+=matrix[members.get(i).getId() - 1][members.get(j).getId() - 1];
        countPairs++;
      }
    }
    averageScore=averageScore / (double)countPairs;
    cluster.setAverageScore(averageScore);
    clusters.add(cluster);
  }
  for (  StructureInterfaceCluster cluster : clusters) {
    for (    StructureInterface interf : cluster.getMembers()) {
      interf.setCluster(cluster);
    }
  }
  Collections.sort(clusters,new Comparator<StructureInterfaceCluster>(){
    @Override public int compare(    StructureInterfaceCluster o1,    StructureInterfaceCluster o2){
      return Double.compare(o2.getTotalArea(),o1.getTotalArea());
    }
  }
);
  int id=1;
  for (  StructureInterfaceCluster cluster : clusters) {
    cluster.setId(id);
    id++;
  }
  return clusters;
}","/** 
 * Calculate the interface clusters for this StructureInterfaceList  using a contact overlap score to measure the similarity of interfaces. Subsequent calls will use the cached value without recomputing the clusters.
 * @param contactOverlapScoreClusterCutoff the contact overlap score above which a pair will be clustered
 * @return
 */
public List<StructureInterfaceCluster> getClusters(double contactOverlapScoreClusterCutoff){
  if (clusters != null) {
    return clusters;
  }
  clusters=new ArrayList<StructureInterfaceCluster>();
  if (list.size() == 0)   return clusters;
  double[][] matrix=new double[list.size()][list.size()];
  for (int i=0; i < list.size(); i++) {
    for (int j=i + 1; j < list.size(); j++) {
      StructureInterface iInterf=list.get(i);
      StructureInterface jInterf=list.get(j);
      double scoreDirect=iInterf.getContactOverlapScore(jInterf,false);
      double scoreInvert=iInterf.getContactOverlapScore(jInterf,true);
      double maxScore=Math.max(scoreDirect,scoreInvert);
      matrix[i][j]=maxScore;
    }
  }
  SingleLinkageClusterer slc=new SingleLinkageClusterer(matrix,true);
  Map<Integer,Set<Integer>> clusteredIndices=slc.getClusters(contactOverlapScoreClusterCutoff);
  for (  int clusterIdx : clusteredIndices.keySet()) {
    List<StructureInterface> members=new ArrayList<StructureInterface>();
    for (    int idx : clusteredIndices.get(clusterIdx)) {
      members.add(list.get(idx));
    }
    StructureInterfaceCluster cluster=new StructureInterfaceCluster();
    cluster.setMembers(members);
    double averageScore=0.0;
    int countPairs=0;
    for (int i=0; i < members.size(); i++) {
      for (int j=i + 1; j < members.size(); j++) {
        averageScore+=matrix[members.get(i).getId() - 1][members.get(j).getId() - 1];
        countPairs++;
      }
    }
    if (countPairs > 0) {
      averageScore=averageScore / (double)countPairs;
    }
 else {
      averageScore=1.0;
    }
    cluster.setAverageScore(averageScore);
    clusters.add(cluster);
  }
  for (  StructureInterfaceCluster cluster : clusters) {
    for (    StructureInterface interf : cluster.getMembers()) {
      interf.setCluster(cluster);
    }
  }
  Collections.sort(clusters,new Comparator<StructureInterfaceCluster>(){
    @Override public int compare(    StructureInterfaceCluster o1,    StructureInterfaceCluster o2){
      return Double.compare(o2.getTotalArea(),o1.getTotalArea());
    }
  }
);
  int id=1;
  for (  StructureInterfaceCluster cluster : clusters) {
    cluster.setId(id);
    id++;
  }
  return clusters;
}",0.9857932123125492
16768,"/** 
 * Populates domainMap
 * @throws IOException 
 */
private void indexDomains() throws IOException {
  domainsFileLock.writeLock().lock();
  try {
    if (allDomains == null) {
      ensureDomainsFileInstalled();
    }
    domainMap=new HashMap<String,List<EcodDomain>>((int)(150000 / .85),.85f);
    for (    EcodDomain d : allDomains) {
      String pdbId=d.getPdbId();
      if (pdbId == null) {
        String ecodId=d.getDomainId();
        if (ecodId != null && !ecodId.isEmpty()) {
          Matcher match=ECOD_RE.matcher(ecodId);
          pdbId=match.group(1);
        }
      }
      List<EcodDomain> currDomains;
      if (domainMap.containsKey(pdbId)) {
        currDomains=domainMap.get(pdbId);
      }
 else {
        currDomains=new LinkedList<EcodDomain>();
        domainMap.put(pdbId,currDomains);
      }
      currDomains.add(d);
    }
  }
  finally {
    domainsFileLock.writeLock().unlock();
  }
}","/** 
 * Populates domainMap
 * @throws IOException 
 */
private void indexDomains() throws IOException {
  domainsFileLock.writeLock().lock();
  logger.trace(""String_Node_Str"");
  try {
    if (allDomains == null) {
      ensureDomainsFileInstalled();
    }
    domainMap=new HashMap<String,List<EcodDomain>>((int)(150000 / .85),.85f);
    for (    EcodDomain d : allDomains) {
      String pdbId=d.getPdbId();
      if (pdbId == null) {
        String ecodId=d.getDomainId();
        if (ecodId != null && !ecodId.isEmpty()) {
          Matcher match=ECOD_RE.matcher(ecodId);
          pdbId=match.group(1);
        }
      }
      List<EcodDomain> currDomains;
      if (domainMap.containsKey(pdbId)) {
        currDomains=domainMap.get(pdbId);
      }
 else {
        currDomains=new LinkedList<EcodDomain>();
        domainMap.put(pdbId,currDomains);
      }
      currDomains.add(d);
    }
  }
  finally {
    logger.trace(""String_Node_Str"");
    domainsFileLock.writeLock().unlock();
  }
}",0.9624608967674662
16769,"public void setVersion(String version){
  domainsFileLock.readLock().lock();
  try {
    if (version.equals(this.version)) {
      return;
    }
  }
  finally {
    domainsFileLock.readLock().unlock();
  }
  domainsFileLock.writeLock().lock();
  try {
    this.version=version;
    this.clear();
  }
  finally {
    domainsFileLock.writeLock().unlock();
  }
}","public void setVersion(String version){
  domainsFileLock.readLock().lock();
  logger.trace(""String_Node_Str"");
  try {
    if (version.equals(this.version)) {
      return;
    }
  }
  finally {
    logger.trace(""String_Node_Str"");
    domainsFileLock.readLock().unlock();
  }
  domainsFileLock.writeLock().lock();
  logger.trace(""String_Node_Str"");
  try {
    this.version=version;
    this.clear();
  }
  finally {
    logger.trace(""String_Node_Str"");
    domainsFileLock.writeLock().unlock();
  }
}",0.8329466357308585
16770,"/** 
 * Blocks until ECOD domains file has been downloaded and parsed. This may be useful in multithreaded environments
 * @throws IOException
 */
public void ensureDomainsFileInstalled() throws IOException {
  domainsFileLock.readLock().lock();
  try {
    if (allDomains != null) {
      return;
    }
  }
  finally {
    domainsFileLock.readLock().unlock();
  }
  domainsFileLock.writeLock().lock();
  try {
    if (!domainsAvailable()) {
      downloadDomains();
    }
    parseDomains();
  }
  finally {
    domainsFileLock.writeLock().unlock();
  }
}","/** 
 * Blocks until ECOD domains file has been downloaded and parsed. This may be useful in multithreaded environments
 * @throws IOException
 */
public void ensureDomainsFileInstalled() throws IOException {
  domainsFileLock.readLock().lock();
  logger.trace(""String_Node_Str"");
  try {
    if (allDomains != null) {
      return;
    }
  }
  finally {
    logger.trace(""String_Node_Str"");
    domainsFileLock.readLock().unlock();
  }
  domainsFileLock.writeLock().lock();
  logger.trace(""String_Node_Str"");
  try {
    if (!domainsAvailable()) {
      downloadDomains();
    }
    parseDomains();
  }
  finally {
    logger.trace(""String_Node_Str"");
    domainsFileLock.writeLock().unlock();
  }
}",0.8853503184713376
16771,"/** 
 * Clears all domains, requiring the file to be reparsed for subsequent accesses
 */
public void clear(){
  domainsFileLock.writeLock().lock();
  ;
  allDomains=null;
  domainMap=null;
  domainsFileLock.writeLock().unlock();
}","/** 
 * Clears all domains, requiring the file to be reparsed for subsequent accesses
 */
public void clear(){
  domainsFileLock.writeLock().lock();
  logger.trace(""String_Node_Str"");
  allDomains=null;
  domainMap=null;
  logger.trace(""String_Node_Str"");
  domainsFileLock.writeLock().unlock();
}",0.875
16772,"/** 
 * Get a list of all ECOD domains for a particular PDB ID
 * @param pdbId
 * @return the list of domains, or null if no matching domains were found
 * @throws IOException
 */
public List<EcodDomain> getDomainsForPDB(String pdbId) throws IOException {
  domainsFileLock.readLock().lock();
  try {
    while (domainMap == null) {
      domainsFileLock.readLock().unlock();
      indexDomains();
      domainsFileLock.readLock().lock();
    }
    if (pdbId != null)     pdbId=pdbId.toLowerCase();
    List<EcodDomain> doms=domainMap.get(pdbId);
    if (doms == null) {
      return null;
    }
    List<EcodDomain> clonedDoms=new ArrayList<EcodDomain>(doms.size());
    for (    EcodDomain d : doms) {
      clonedDoms.add(new EcodDomain(d));
    }
    return clonedDoms;
  }
  finally {
    domainsFileLock.readLock().unlock();
  }
}","/** 
 * Get a list of all ECOD domains for a particular PDB ID
 * @param pdbId
 * @return the list of domains, or null if no matching domains were found
 * @throws IOException
 */
public List<EcodDomain> getDomainsForPDB(String pdbId) throws IOException {
  domainsFileLock.readLock().lock();
  try {
    logger.trace(""String_Node_Str"");
    while (domainMap == null) {
      logger.trace(""String_Node_Str"");
      domainsFileLock.readLock().unlock();
      indexDomains();
      domainsFileLock.readLock().lock();
      logger.trace(""String_Node_Str"");
    }
    if (pdbId != null)     pdbId=pdbId.toLowerCase();
    List<EcodDomain> doms=domainMap.get(pdbId);
    if (doms == null) {
      return null;
    }
    List<EcodDomain> clonedDoms=new ArrayList<EcodDomain>(doms.size());
    for (    EcodDomain d : doms) {
      clonedDoms.add(new EcodDomain(d));
    }
    return clonedDoms;
  }
  finally {
    logger.trace(""String_Node_Str"");
    domainsFileLock.readLock().unlock();
  }
}",0.9166666666666666
16773,"/** 
 * Downloads the domains file, overwriting any existing file
 * @throws IOException
 */
private void downloadDomains() throws IOException {
  domainsFileLock.writeLock().lock();
  try {
    URL domainsURL=new URL(url + DOMAINS_PATH + getDomainFilename());
    File localFile=getDomainFile();
    logger.info(""String_Node_Str"",domainsURL,localFile);
    FileDownloadUtils.downloadFile(domainsURL,localFile);
  }
 catch (  MalformedURLException e) {
    logger.error(""String_Node_Str"" + url + DOMAINS_PATH+ getDomainFilename(),e);
  }
 finally {
    domainsFileLock.writeLock().unlock();
  }
}","/** 
 * Downloads the domains file, overwriting any existing file
 * @throws IOException
 */
private void downloadDomains() throws IOException {
  domainsFileLock.writeLock().lock();
  logger.trace(""String_Node_Str"");
  try {
    URL domainsURL=new URL(url + DOMAINS_PATH + getDomainFilename());
    File localFile=getDomainFile();
    logger.info(""String_Node_Str"",domainsURL,localFile);
    FileDownloadUtils.downloadFile(domainsURL,localFile);
  }
 catch (  MalformedURLException e) {
    logger.error(""String_Node_Str"" + url + DOMAINS_PATH+ getDomainFilename(),e);
  }
 finally {
    logger.trace(""String_Node_Str"");
    domainsFileLock.writeLock().unlock();
  }
}",0.9430379746835444
16774,"/** 
 * Parses the domains from the local file
 * @throws IOException
 */
private void parseDomains() throws IOException {
  domainsFileLock.writeLock().lock();
  try {
    EcodParser parser=new EcodParser(getDomainFile());
    allDomains=parser.getDomains();
  }
  finally {
    domainsFileLock.writeLock().unlock();
  }
}","/** 
 * Parses the domains from the local file
 * @throws IOException
 */
private void parseDomains() throws IOException {
  domainsFileLock.writeLock().lock();
  logger.trace(""String_Node_Str"");
  try {
    EcodParser parser=new EcodParser(getDomainFile());
    allDomains=parser.getDomains();
  }
  finally {
    logger.trace(""String_Node_Str"");
    domainsFileLock.writeLock().unlock();
  }
}",0.8997214484679665
16775,"public List<EcodDomain> getAllDomains() throws IOException {
  domainsFileLock.readLock().lock();
  try {
    while (allDomains == null) {
      domainsFileLock.readLock().unlock();
      ensureDomainsFileInstalled();
      domainsFileLock.readLock().lock();
    }
    return allDomains;
  }
  finally {
    domainsFileLock.readLock().lock();
  }
}","public List<EcodDomain> getAllDomains() throws IOException {
  domainsFileLock.readLock().lock();
  logger.trace(""String_Node_Str"");
  try {
    while (allDomains == null) {
      logger.trace(""String_Node_Str"");
      domainsFileLock.readLock().unlock();
      ensureDomainsFileInstalled();
      domainsFileLock.readLock().lock();
      logger.trace(""String_Node_Str"");
    }
    return allDomains;
  }
  finally {
    logger.trace(""String_Node_Str"");
    domainsFileLock.readLock().unlock();
  }
}",0.8207547169811321
16776,"/** 
 * Set an alternate download location for files
 * @param cacheLocation
 */
public void setCacheLocation(String cacheLocation){
  if (cacheLocation.equals(this.cacheLocation)) {
    return;
  }
  domainsFileLock.writeLock().lock();
  this.cacheLocation=cacheLocation;
  domainsFileLock.writeLock().unlock();
}","/** 
 * Set an alternate download location for files
 * @param cacheLocation
 */
public void setCacheLocation(String cacheLocation){
  if (cacheLocation.equals(this.cacheLocation)) {
    return;
  }
  domainsFileLock.writeLock().lock();
  logger.trace(""String_Node_Str"");
  this.cacheLocation=cacheLocation;
  logger.trace(""String_Node_Str"");
  domainsFileLock.writeLock().unlock();
}",0.8997134670487106
16777,"public EcodDomain getDomainsById(String ecodId) throws IOException {
  if (ecodId == null || ecodId.isEmpty()) {
    return null;
  }
  Matcher match=ECOD_RE.matcher(ecodId);
  String pdbId=null;
  if (match.matches())   pdbId=match.group(1);
  List<EcodDomain> doms=getDomainsForPDB(pdbId);
  for (  EcodDomain d : doms) {
    if (ecodId.equals(d.getDomainId())) {
      return d;
    }
  }
  return null;
}","public EcodDomain getDomainsById(String ecodId) throws IOException {
  if (ecodId == null || ecodId.isEmpty()) {
    return null;
  }
  Matcher match=ECOD_RE.matcher(ecodId);
  String pdbId=null;
  if (match.matches())   pdbId=match.group(1);
  List<EcodDomain> doms=getDomainsForPDB(pdbId);
  if (doms == null) {
    logger.debug(""String_Node_Str"",pdbId,ecodId);
    return null;
  }
  logger.debug(""String_Node_Str"",doms.size(),pdbId);
  for (  EcodDomain d : doms) {
    if (ecodId.equals(d.getDomainId())) {
      return d;
    }
  }
  return null;
}",0.8482328482328483
16778,"/** 
 * Checks that the domains file has been downloaded
 * @return
 */
private boolean domainsAvailable(){
  domainsFileLock.readLock().lock();
  try {
    File f=getDomainFile();
    return f.exists() && f.length() > 0;
  }
  finally {
    domainsFileLock.readLock().unlock();
  }
}","/** 
 * Checks that the domains file has been downloaded
 * @return
 */
private boolean domainsAvailable(){
  domainsFileLock.readLock().lock();
  logger.trace(""String_Node_Str"");
  try {
    File f=getDomainFile();
    return f.exists() && f.length() > 0;
  }
  finally {
    logger.trace(""String_Node_Str"");
    domainsFileLock.readLock().unlock();
  }
}",0.8875
16779,"@Test public void testDownloads() throws IOException {
  File domainsFile=new File(ecod.getCacheLocation(),""String_Node_Str"" + VERSION + ""String_Node_Str"");
  if (domainsFile.exists()) {
    domainsFile.delete();
  }
  ecod.ensureDomainsFileInstalled();
  assertTrue(""String_Node_Str"" + domainsFile.toString(),domainsFile.exists());
}","@Test public void testDownloads() throws IOException {
  EcodInstallation ecod2=new EcodInstallation(tmpFolder.getRoot().getAbsolutePath());
  ecod2.setVersion(VERSION);
  File domainsFile=new File(ecod2.getCacheLocation(),""String_Node_Str"" + VERSION + ""String_Node_Str"");
  if (domainsFile.exists()) {
    domainsFile.delete();
  }
  ecod2.ensureDomainsFileInstalled();
  assertTrue(""String_Node_Str"" + domainsFile.toString(),domainsFile.exists());
}",0.6675159235668789
16780,"@Override public AFPChain align(Atom[] ca1,Atom[] ca2,Object parameters) throws StructureException {
  if (parameters == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(parameters instanceof SmithWaterman3DParameters))   throw new IllegalArgumentException(""String_Node_Str"" + parameters.getClass().getName());
  params=(SmithWaterman3DParameters)parameters;
  AFPChain afpChain=new AFPChain();
  try {
    String seq1=StructureTools.convertAtomsToSeq(ca1);
    String seq2=StructureTools.convertAtomsToSeq(ca2);
    ProteinSequence s1=new ProteinSequence(seq1);
    ProteinSequence s2=new ProteinSequence(seq2);
    SubstitutionMatrix<AminoAcidCompound> matrix=SubstitutionMatrixHelper.getBlosum65();
    GapPenalty penalty=new SimpleGapPenalty();
    penalty.setOpenPenalty(params.getGapOpen());
    penalty.setExtensionPenalty(params.getGapExtend());
    PairwiseSequenceAligner<ProteinSequence,AminoAcidCompound> smithWaterman=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.LOCAL,penalty,matrix);
    SequencePair<ProteinSequence,AminoAcidCompound> pair=smithWaterman.getPair();
    logger.debug(""String_Node_Str"" + pair.toString(100));
    afpChain=convert(ca1,ca2,pair,smithWaterman);
  }
 catch (  CompoundNotFoundException e) {
    throw new StructureException(e.getMessage(),e);
  }
  return afpChain;
}","@Override public AFPChain align(Atom[] ca1,Atom[] ca2,Object parameters) throws StructureException {
  if (parameters == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(parameters instanceof SmithWaterman3DParameters))   throw new IllegalArgumentException(""String_Node_Str"" + parameters.getClass().getName());
  params=(SmithWaterman3DParameters)parameters;
  AFPChain afpChain=new AFPChain();
  String seq1=StructureTools.convertAtomsToSeq(ca1);
  String seq2=StructureTools.convertAtomsToSeq(ca2);
  ProteinSequence s1=null;
  ProteinSequence s2=null;
  try {
    s1=new ProteinSequence(seq1);
    s2=new ProteinSequence(seq2);
  }
 catch (  CompoundNotFoundException e) {
    throw new StructureException(e.getMessage(),e);
  }
  SubstitutionMatrix<AminoAcidCompound> matrix=SubstitutionMatrixHelper.getBlosum65();
  GapPenalty penalty=new SimpleGapPenalty();
  penalty.setOpenPenalty(params.getGapOpen());
  penalty.setExtensionPenalty(params.getGapExtend());
  PairwiseSequenceAligner<ProteinSequence,AminoAcidCompound> smithWaterman=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.LOCAL,penalty,matrix);
  SequencePair<ProteinSequence,AminoAcidCompound> pair=smithWaterman.getPair();
  if (pair.getTarget().toString().isEmpty() || pair.getQuery().toString().isEmpty()) {
    throw new StructureException(""String_Node_Str"" + s1 + ""String_Node_Str""+ s2);
  }
  logger.debug(""String_Node_Str"" + pair.toString(100));
  afpChain=convert(ca1,ca2,pair,smithWaterman);
  return afpChain;
}",0.8288973384030418
16781,"public boolean identityMatch(Atom[] cAlphaAtoms,String chainId,int modelNumber,int structureId,String sequence){
  UniqueSequenceList u=uniqueSequenceList.get(0);
  String refSequence=u.getSeqResSequence();
  boolean seqMatch=refSequence.equals(sequence);
  if (seqMatch) {
    List<Integer> alig1=new ArrayList<Integer>();
    List<Integer> alig2=new ArrayList<Integer>();
    Atom[] referenceAtoms=u.getCalphaAtoms();
    int inCommon=alignIdenticalSequence(referenceAtoms,cAlphaAtoms,alig1,alig2);
    if (inCommon > 0) {
      UniqueSequenceList seqList=new UniqueSequenceList(cAlphaAtoms,chainId,modelNumber,structureId,sequence);
      seqList.setAlignment1(alig1);
      seqList.setAlignment2(alig2);
      addUniqueSequenceList(seqList);
      return true;
    }
  }
  return false;
}","public boolean identityMatch(Atom[] cAlphaAtoms,String chainId,int modelNumber,int structureId,String sequence){
  UniqueSequenceList u=uniqueSequenceList.get(0);
  String refSequence=u.getSeqResSequence();
  boolean seqMatch=refSequence.equals(sequence);
  if (seqMatch) {
    List<Integer> alig1=new ArrayList<Integer>();
    List<Integer> alig2=new ArrayList<Integer>();
    Atom[] referenceAtoms=u.getCalphaAtoms();
    int inCommon=0;
    try {
      inCommon=alignIdenticalSequence(referenceAtoms,cAlphaAtoms,alig1,alig2);
    }
 catch (    StructureException e) {
      logger.warn(""String_Node_Str"",u.getChainId(),refSequence,chainId,sequence);
    }
    if (inCommon > 0) {
      UniqueSequenceList seqList=new UniqueSequenceList(cAlphaAtoms,chainId,modelNumber,structureId,sequence);
      seqList.setAlignment1(alig1);
      seqList.setAlignment2(alig2);
      addUniqueSequenceList(seqList);
      return true;
    }
  }
  return false;
}",0.9081515499425948
16782,"private AFPChain alignPairBySequence(Atom[] ca1Seq,Atom[] ca2Seq){
  SmithWaterman3Daligner aligner=new SmithWaterman3Daligner();
  AFPChain afp=null;
  try {
    afp=aligner.align(ca1Seq,ca2Seq);
  }
 catch (  StructureException e) {
    logger.error(""String_Node_Str"" + ca1Seq.length + ""String_Node_Str""+ ca2Seq.length,e);
  }
  return afp;
}","private AFPChain alignPairBySequence(Atom[] ca1Seq,Atom[] ca2Seq) throws StructureException {
  SmithWaterman3Daligner aligner=new SmithWaterman3Daligner();
  return aligner.align(ca1Seq,ca2Seq);
}",0.609981515711645
16783,"private int alignIdenticalSequence(Atom[] ca1Seq,Atom[] ca2Seq,List<Integer> align1,List<Integer> align2){
  AFPChain afp=alignPairBySequence(ca1Seq,ca2Seq);
  int[][][] align=afp.getOptAln();
  if (align == null) {
    return 0;
  }
  int len=afp.getOptLength();
  List<Integer> delta=new ArrayList<Integer>();
  Set<Integer> unique=new HashSet<Integer>();
  for (int i=0; i < len; i++) {
    Atom a1=ca1Seq[align[0][0][i]];
    String residueName1=a1.getGroup().getPDBName();
    Atom a2=ca2Seq[align[0][1][i]];
    String residueName2=a2.getGroup().getPDBName();
    if (residueName1.equals(residueName2)) {
      int n1=a1.getGroup().getResidueNumber().getSeqNum();
      int n2=a2.getGroup().getResidueNumber().getSeqNum();
      delta.add(n2 - n1);
      unique.add(n2 - n1);
    }
  }
  int offset=0;
  int frequency=0;
  for (  Integer i : unique) {
    int freq=Collections.frequency(delta,i);
    if (freq > frequency) {
      offset=i;
      frequency=freq;
    }
  }
  for (int i=0; i < len; i++) {
    Atom a1=ca1Seq[align[0][0][i]];
    int n1=a1.getGroup().getResidueNumber().getSeqNum();
    Atom a2=ca2Seq[align[0][1][i]];
    int n2=a2.getGroup().getResidueNumber().getSeqNum();
    if (n2 - offset == n1) {
      align1.add(align[0][0][i]);
      align2.add(align[0][1][i]);
    }
  }
  return align1.size();
}","private int alignIdenticalSequence(Atom[] ca1Seq,Atom[] ca2Seq,List<Integer> align1,List<Integer> align2) throws StructureException {
  AFPChain afp=alignPairBySequence(ca1Seq,ca2Seq);
  int[][][] align=afp.getOptAln();
  if (align == null) {
    return 0;
  }
  int len=afp.getOptLength();
  List<Integer> delta=new ArrayList<Integer>();
  Set<Integer> unique=new HashSet<Integer>();
  for (int i=0; i < len; i++) {
    Atom a1=ca1Seq[align[0][0][i]];
    String residueName1=a1.getGroup().getPDBName();
    Atom a2=ca2Seq[align[0][1][i]];
    String residueName2=a2.getGroup().getPDBName();
    if (residueName1.equals(residueName2)) {
      int n1=a1.getGroup().getResidueNumber().getSeqNum();
      int n2=a2.getGroup().getResidueNumber().getSeqNum();
      delta.add(n2 - n1);
      unique.add(n2 - n1);
    }
  }
  int offset=0;
  int frequency=0;
  for (  Integer i : unique) {
    int freq=Collections.frequency(delta,i);
    if (freq > frequency) {
      offset=i;
      frequency=freq;
    }
  }
  for (int i=0; i < len; i++) {
    Atom a1=ca1Seq[align[0][0][i]];
    int n1=a1.getGroup().getResidueNumber().getSeqNum();
    Atom a2=ca2Seq[align[0][1][i]];
    int n2=a2.getGroup().getResidueNumber().getSeqNum();
    if (n2 - offset == n1) {
      align1.add(align[0][0][i]);
      align2.add(align[0][1][i]);
    }
  }
  return align1.size();
}",0.9899441340782122
16784,"public Structure rebuildQuaternaryStructure(Structure asymUnit,List<BiologicalAssemblyTransformation> transformations){
  orderTransformationsByChainId(asymUnit,transformations);
  Structure s=asymUnit.clone();
  s.setChains(new ArrayList<Chain>());
  for (  BiologicalAssemblyTransformation transformation : transformations) {
    for (    Chain c : asymUnit.getChains()) {
      String intChainID=c.getInternalChainID();
      if (intChainID == null) {
        logger.info(""String_Node_Str"" + c.getChainID());
        intChainID=c.getChainID();
      }
      if (transformation.getChainId().equals(intChainID)) {
        Chain chain=(Chain)c.clone();
        for (        Group g : chain.getAtomGroups()) {
          for (          Atom a : g.getAtoms()) {
            transformation.transformPoint(a.getCoords());
          }
        }
        String transformId=transformation.getId();
        addChainAndModel(s,chain,transformId);
      }
    }
  }
  s.setBiologicalAssembly(true);
  return s;
}","public Structure rebuildQuaternaryStructure(Structure asymUnit,List<BiologicalAssemblyTransformation> transformations){
  orderTransformationsByChainId(asymUnit,transformations);
  Structure s=asymUnit.clone();
  s.resetModels();
  for (  BiologicalAssemblyTransformation transformation : transformations) {
    for (    Chain c : asymUnit.getChains()) {
      String intChainID=c.getInternalChainID();
      if (intChainID == null) {
        logger.info(""String_Node_Str"" + c.getChainID());
        intChainID=c.getChainID();
      }
      if (transformation.getChainId().equals(intChainID)) {
        Chain chain=(Chain)c.clone();
        for (        Group g : chain.getAtomGroups()) {
          for (          Atom a : g.getAtoms()) {
            transformation.transformPoint(a.getCoords());
          }
        }
        String transformId=transformation.getId();
        addChainAndModel(s,chain,transformId);
      }
    }
  }
  s.setBiologicalAssembly(true);
  return s;
}",0.9778002018163472
16785,"private boolean alignNucleotideGroups(List<Group> seqRes,List<Group> atomRes){
  Map<Integer,Integer> seqresIndexPosition=new HashMap<Integer,Integer>();
  Map<Integer,Integer> atomIndexPosition=new HashMap<Integer,Integer>();
  String seq1=getFullAtomSequence(seqRes,seqresIndexPosition);
  String seq2=getFullAtomSequence(atomRes,atomIndexPosition);
  logger.debug(""String_Node_Str"" + seq1.length() + ""String_Node_Str""+ seq1);
  logger.debug(""String_Node_Str"" + seq2.length() + ""String_Node_Str""+ seq2);
  Sequence<NucleotideCompound> s1;
  Sequence<NucleotideCompound> s2;
  try {
    s1=new DNASequence(seq1,AmbiguityDNACompoundSet.getDNACompoundSet());
  }
 catch (  CompoundNotFoundException e) {
    try {
      s1=new RNASequence(seq1,AmbiguityRNACompoundSet.getRNACompoundSet());
    }
 catch (    CompoundNotFoundException ex) {
      logger.warn(""String_Node_Str"" + seq1);
      return true;
    }
  }
  try {
    s2=new DNASequence(seq2,AmbiguityDNACompoundSet.getDNACompoundSet());
  }
 catch (  CompoundNotFoundException e) {
    try {
      s2=new RNASequence(seq2,AmbiguityRNACompoundSet.getRNACompoundSet());
    }
 catch (    CompoundNotFoundException ex) {
      logger.warn(""String_Node_Str"" + seq2);
      return true;
    }
  }
  if (!s1.getCompoundSet().equals(s2.getCompoundSet())) {
    if (!s1.getCompoundSet().equals(AmbiguityRNACompoundSet.getRNACompoundSet())) {
      try {
        s1=new RNASequence(seq1,AmbiguityRNACompoundSet.getRNACompoundSet());
      }
 catch (      CompoundNotFoundException ex) {
        logger.warn(""String_Node_Str"" + seq1);
        return true;
      }
    }
    if (!s2.getCompoundSet().equals(AmbiguityRNACompoundSet.getRNACompoundSet())) {
      try {
        s2=new RNASequence(seq2,AmbiguityRNACompoundSet.getRNACompoundSet());
      }
 catch (      CompoundNotFoundException ex) {
        logger.warn(""String_Node_Str"" + seq2);
        return true;
      }
    }
  }
  SubstitutionMatrix<NucleotideCompound> matrix=SubstitutionMatrixHelper.getNuc4_4();
  GapPenalty penalty=new SimpleGapPenalty(8,1);
  PairwiseSequenceAligner<Sequence<NucleotideCompound>,NucleotideCompound> smithWaterman=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.LOCAL,penalty,matrix);
  SequencePair<Sequence<NucleotideCompound>,NucleotideCompound> pair=smithWaterman.getPair();
  if (pair == null) {
    logger.warn(""String_Node_Str"");
    logger.warn(""String_Node_Str"");
    logger.warn(seq1);
    logger.warn(seq2);
    return true;
  }
  logger.debug(""String_Node_Str"" + pair.toString(100));
  boolean noMatchFound=mapDNAChains(seqRes,atomRes,pair,seqresIndexPosition,atomIndexPosition);
  return noMatchFound;
}","private boolean alignNucleotideGroups(List<Group> seqRes,List<Group> atomRes){
  Map<Integer,Integer> seqresIndexPosition=new HashMap<Integer,Integer>();
  Map<Integer,Integer> atomIndexPosition=new HashMap<Integer,Integer>();
  String seq1=getFullAtomSequence(seqRes,seqresIndexPosition);
  String seq2=getFullAtomSequence(atomRes,atomIndexPosition);
  if (seq1.isEmpty() || seq2.isEmpty()) {
    logger.warn(""String_Node_Str"");
    return true;
  }
  logger.debug(""String_Node_Str"" + seq1.length() + ""String_Node_Str""+ seq1);
  logger.debug(""String_Node_Str"" + seq2.length() + ""String_Node_Str""+ seq2);
  Sequence<NucleotideCompound> s1;
  Sequence<NucleotideCompound> s2;
  try {
    s1=new DNASequence(seq1,AmbiguityDNACompoundSet.getDNACompoundSet());
  }
 catch (  CompoundNotFoundException e) {
    try {
      s1=new RNASequence(seq1,AmbiguityRNACompoundSet.getRNACompoundSet());
    }
 catch (    CompoundNotFoundException ex) {
      logger.warn(""String_Node_Str"" + seq1);
      return true;
    }
  }
  try {
    s2=new DNASequence(seq2,AmbiguityDNACompoundSet.getDNACompoundSet());
  }
 catch (  CompoundNotFoundException e) {
    try {
      s2=new RNASequence(seq2,AmbiguityRNACompoundSet.getRNACompoundSet());
    }
 catch (    CompoundNotFoundException ex) {
      logger.warn(""String_Node_Str"" + seq2);
      return true;
    }
  }
  if (!s1.getCompoundSet().equals(s2.getCompoundSet())) {
    if (!s1.getCompoundSet().equals(AmbiguityRNACompoundSet.getRNACompoundSet())) {
      try {
        s1=new RNASequence(seq1,AmbiguityRNACompoundSet.getRNACompoundSet());
      }
 catch (      CompoundNotFoundException ex) {
        logger.warn(""String_Node_Str"" + seq1);
        return true;
      }
    }
    if (!s2.getCompoundSet().equals(AmbiguityRNACompoundSet.getRNACompoundSet())) {
      try {
        s2=new RNASequence(seq2,AmbiguityRNACompoundSet.getRNACompoundSet());
      }
 catch (      CompoundNotFoundException ex) {
        logger.warn(""String_Node_Str"" + seq2);
        return true;
      }
    }
  }
  SubstitutionMatrix<NucleotideCompound> matrix=SubstitutionMatrixHelper.getNuc4_4();
  GapPenalty penalty=new SimpleGapPenalty(8,1);
  PairwiseSequenceAligner<Sequence<NucleotideCompound>,NucleotideCompound> smithWaterman=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.LOCAL,penalty,matrix);
  SequencePair<Sequence<NucleotideCompound>,NucleotideCompound> pair=smithWaterman.getPair();
  if (pair == null) {
    logger.warn(""String_Node_Str"");
    logger.warn(""String_Node_Str"");
    logger.warn(seq1);
    logger.warn(seq2);
    return true;
  }
  logger.debug(""String_Node_Str"" + pair.toString(100));
  boolean noMatchFound=mapDNAChains(seqRes,atomRes,pair,seqresIndexPosition,atomIndexPosition);
  return noMatchFound;
}",0.9818181818181818
16786,"@Override public void documentEnd(){
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  structure.addModel(current_model);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    asymId2entityId.put(asym.getId(),asym.getEntity_id());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setChainID(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    int eId=0;
    try {
      eId=Integer.parseInt(asym.getEntity_id());
    }
 catch (    NumberFormatException e) {
      logger.warn(""String_Node_Str"",asym.getEntity_id());
    }
    Entity e=getEntity(eId);
    for (    EntitySrcGen esg : entitySrcGens) {
      if (!esg.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESG(esg,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcNat esn : entitySrcNats) {
      if (!esn.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESN(esn,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcSyn ess : entitySrcSyns) {
      if (!ess.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESS(ess,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    Compound c=structure.getCompoundById(eId);
    if (c == null) {
      c=new Compound();
      c.setMolId(eId);
      if (e != null && e.getType().equals(""String_Node_Str"")) {
        c.setMolName(e.getPdbx_description());
        structure.addCompound(c);
        logger.debug(""String_Node_Str"",eId,c.getMolName());
      }
    }
  }
  if (params.isAlignSeqRes()) {
    List<Chain> atomList=structure.getModel(0);
    for (    Chain seqResChain : seqResChains) {
      Chain atomChain=SeqRes2AtomAligner.getMatchingAtomRes(seqResChain,atomList);
      if (atomChain == null) {
        logger.warn(""String_Node_Str"",seqResChain.getChainID());
        continue;
      }
      List<Group> seqResGroups=seqResChain.getAtomGroups();
      for (int seqResPos=0; seqResPos < seqResGroups.size(); seqResPos++) {
        Group seqresG=seqResGroups.get(seqResPos);
        boolean found=false;
        for (        Group atomG : atomChain.getAtomGroups()) {
          int internalNr=getInternalNr(atomG);
          if (seqresG.getResidueNumber().getSeqNum() == internalNr) {
            seqResGroups.set(seqResPos,atomG);
            found=true;
            break;
          }
        }
        if (!found)         seqresG.setResidueNumber(null);
      }
      atomChain.setSeqResGroups(seqResGroups);
    }
  }
  if (params.shouldCreateAtomBonds())   addBonds();
  Set<String> asymIds=asymStrandId.keySet();
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> model=structure.getModel(i);
    List<Chain> pdbChains=new ArrayList<Chain>();
    for (    Chain chain : model) {
      for (      String asym : asymIds) {
        if (chain.getChainID().equals(asym)) {
          String newChainId=asymStrandId.get(asym);
          logger.debug(""String_Node_Str"",asym,chain.getAtomGroups().size(),newChainId);
          chain.setChainID(newChainId);
          chain.setInternalChainID(asym);
          for (          Group g : chain.getAtomGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          for (          Group g : chain.getSeqResGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          Chain known=isKnownChain(chain.getChainID(),pdbChains);
          if (known == null) {
            pdbChains.add(chain);
          }
 else {
            for (            Group g : chain.getAtomGroups()) {
              known.addGroup(g);
            }
          }
          break;
        }
      }
    }
    structure.setModel(i,pdbChains);
    Iterator<Chain> it=pdbChains.iterator();
    while (it.hasNext()) {
      Chain chain=it.next();
      String entityId=asymId2entityId.get(chain.getInternalChainID());
      int eId=Integer.parseInt(entityId);
      Compound compound=structure.getCompoundById(eId);
      if (compound == null) {
        logger.warn(""String_Node_Str"" + ""String_Node_Str"",eId,chain.getChainID(),chain.getInternalChainID(),chain.getAtomGroups().size());
        it.remove();
      }
 else {
        logger.debug(""String_Node_Str"",chain.getChainID(),chain.getInternalChainID(),eId);
        compound.addChain(chain);
        chain.setCompound(compound);
      }
    }
  }
  List<Compound> compounds=structure.getCompounds();
  for (  Compound compound : compounds) {
    if (compound.getChains().isEmpty()) {
      logger.info(""String_Node_Str"",compound.getId() == null ? ""String_Node_Str"" : compound.getId(),compound.getMolName());
    }
  }
  if (params.isParseBioAssembly()) {
    Map<Integer,BioAssemblyInfo> bioAssemblies=new HashMap<Integer,BioAssemblyInfo>();
    for (    PdbxStructAssembly psa : strucAssemblies) {
      List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
      for (      PdbxStructAssemblyGen psag : strucAssemblyGens) {
        if (psag.getAssembly_id().equals(psa.getId())) {
          psags.add(psag);
        }
      }
      BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
      List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
      int mmSize=0;
      int bioAssemblyId=-1;
      try {
        bioAssemblyId=Integer.parseInt(psa.getId());
      }
 catch (      NumberFormatException e) {
        logger.info(""String_Node_Str"",psa.getId());
      }
      try {
        mmSize=Integer.parseInt(psa.getOligomeric_count());
      }
 catch (      NumberFormatException e) {
        if (bioAssemblyId != -1)         logger.warn(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
 else         logger.info(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
      }
      if (bioAssemblyId != -1) {
        BioAssemblyInfo bioAssembly=new BioAssemblyInfo();
        bioAssembly.setId(bioAssemblyId);
        bioAssembly.setMacromolecularSize(mmSize);
        bioAssembly.setTransforms(transformations);
        bioAssemblies.put(bioAssemblyId,bioAssembly);
      }
    }
    structure.getPDBHeader().setBioAssemblies(bioAssemblies);
  }
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators(ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
}","@Override public void documentEnd(){
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  structure.addModel(current_model);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    asymId2entityId.put(asym.getId(),asym.getEntity_id());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setChainID(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    int eId=0;
    try {
      eId=Integer.parseInt(asym.getEntity_id());
    }
 catch (    NumberFormatException e) {
      logger.warn(""String_Node_Str"",asym.getEntity_id());
    }
    Entity e=getEntity(eId);
    for (    EntitySrcGen esg : entitySrcGens) {
      if (!esg.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESG(esg,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcNat esn : entitySrcNats) {
      if (!esn.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESN(esn,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcSyn ess : entitySrcSyns) {
      if (!ess.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESS(ess,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    Compound c=structure.getCompoundById(eId);
    if (c == null) {
      c=new Compound();
      c.setMolId(eId);
      if (e != null && e.getType().equals(""String_Node_Str"")) {
        c.setMolName(e.getPdbx_description());
        structure.addCompound(c);
        logger.debug(""String_Node_Str"",eId,c.getMolName());
      }
    }
  }
  if (params.isAlignSeqRes()) {
    alignSeqRes();
  }
  if (params.shouldCreateAtomBonds()) {
    addBonds();
  }
  Set<String> asymIds=asymStrandId.keySet();
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> model=structure.getModel(i);
    List<Chain> pdbChains=new ArrayList<Chain>();
    for (    Chain chain : model) {
      for (      String asym : asymIds) {
        if (chain.getChainID().equals(asym)) {
          String newChainId=asymStrandId.get(asym);
          logger.debug(""String_Node_Str"",asym,chain.getAtomGroups().size(),newChainId);
          chain.setChainID(newChainId);
          chain.setInternalChainID(asym);
          for (          Group g : chain.getAtomGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          for (          Group g : chain.getSeqResGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          Chain known=isKnownChain(chain.getChainID(),pdbChains);
          if (known == null) {
            pdbChains.add(chain);
          }
 else {
            for (            Group g : chain.getAtomGroups()) {
              known.addGroup(g);
            }
          }
          break;
        }
      }
    }
    structure.setModel(i,pdbChains);
    Iterator<Chain> it=pdbChains.iterator();
    while (it.hasNext()) {
      Chain chain=it.next();
      String entityId=asymId2entityId.get(chain.getInternalChainID());
      int eId=Integer.parseInt(entityId);
      Compound compound=structure.getCompoundById(eId);
      if (compound == null) {
        logger.warn(""String_Node_Str"" + ""String_Node_Str"",eId,chain.getChainID(),chain.getInternalChainID(),chain.getAtomGroups().size());
        it.remove();
      }
 else {
        logger.debug(""String_Node_Str"",chain.getChainID(),chain.getInternalChainID(),eId);
        compound.addChain(chain);
        chain.setCompound(compound);
      }
    }
  }
  List<Compound> compounds=structure.getCompounds();
  for (  Compound compound : compounds) {
    if (compound.getChains().isEmpty()) {
      logger.info(""String_Node_Str"",compound.getId() == null ? ""String_Node_Str"" : compound.getId(),compound.getMolName());
    }
  }
  if (params.isParseBioAssembly()) {
    Map<Integer,BioAssemblyInfo> bioAssemblies=new HashMap<Integer,BioAssemblyInfo>();
    for (    PdbxStructAssembly psa : strucAssemblies) {
      List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
      for (      PdbxStructAssemblyGen psag : strucAssemblyGens) {
        if (psag.getAssembly_id().equals(psa.getId())) {
          psags.add(psag);
        }
      }
      BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
      List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
      int mmSize=0;
      int bioAssemblyId=-1;
      try {
        bioAssemblyId=Integer.parseInt(psa.getId());
      }
 catch (      NumberFormatException e) {
        logger.info(""String_Node_Str"",psa.getId());
      }
      try {
        mmSize=Integer.parseInt(psa.getOligomeric_count());
      }
 catch (      NumberFormatException e) {
        if (bioAssemblyId != -1)         logger.warn(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
 else         logger.info(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
      }
      if (bioAssemblyId != -1) {
        BioAssemblyInfo bioAssembly=new BioAssemblyInfo();
        bioAssembly.setId(bioAssemblyId);
        bioAssembly.setMacromolecularSize(mmSize);
        bioAssembly.setTransforms(transformations);
        bioAssemblies.put(bioAssemblyId,bioAssembly);
      }
    }
    structure.getPDBHeader().setBioAssemblies(bioAssemblies);
  }
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators(ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
}",0.9314190317195326
16787,"private boolean isAminoAcid(Group group){
  ChemComp cc=group.getChemComp();
  if (cc.getResidueType() == null) {
    System.err.println(""String_Node_Str"" + group.getPDBName());
    return false;
  }
  return (cc.getResidueType().equals(ResidueType.lPeptideLinking) || cc.getResidueType().equals(ResidueType.glycine));
}","private boolean isAminoAcid(Group group){
  ChemComp cc=group.getChemComp();
  if (cc.getResidueType() == null) {
    logger.warn(""String_Node_Str"" + group.getPDBName());
    return false;
  }
  return (cc.getResidueType().equals(ResidueType.lPeptideLinking) || cc.getResidueType().equals(ResidueType.glycine));
}",0.957345971563981
16788,"/** 
 * Get the list of chains that are part of this Compound
 * @return a List of Chain objects
 */
public List<Chain> getChains(){
  return this.chains;
}","/** 
 * Get the list of chains that are part of this Compound. Note that for multi-model  structures chains from all models are returned.
 * @return a List of Chain objects
 */
public List<Chain> getChains(){
  return this.chains;
}",0.8041237113402062
16789,"/** 
 * Return the list of member chain IDs that are described by this Compound 
 * @return the list of ChainIDs that are described by this Compound
 * @see #setChains(List)
 * @see #getChains()
 */
public List<String> getChainIds(){
  List<String> chainIds=new ArrayList<String>();
  for (  Chain chain : chains) {
    chainIds.add(chain.getChainID());
  }
  return chainIds;
}","/** 
 * Return the list of member chain IDs that are described by this Compound,  only unique chain IDs are contained in the list.  Note that in the case of multimodel structures this will return just the unique chain identifiers whilst   {@link #getChains()} will return a corresponding chain per model. 
 * @return the list of unique ChainIDs that are described by this Compound
 * @see #setChains(List)
 * @see #getChains()
 */
public List<String> getChainIds(){
  Set<String> uniqChainIds=new TreeSet<String>();
  for (int i=0; i < getChains().size(); i++) {
    uniqChainIds.add(getChains().get(i).getChainID());
  }
  return new ArrayList<String>(uniqChainIds);
}",0.5348615090735435
16790,"/** 
 * returns an identical copy of this structure .
 * @return an identical Structure object
 */
@Override public Structure clone(){
  Structure n=new StructureImpl();
  n.setPDBCode(getPDBCode());
  n.setName(getName());
  n.setPDBHeader(pdbHeader);
  n.setDBRefs(this.getDBRefs());
  n.setConnections(getConnections());
  n.setSites(getSites());
  for (int i=0; i < nrModels(); i++) {
    List<Chain> cloned_model=new ArrayList<Chain>();
    for (int j=0; j < size(i); j++) {
      Chain cloned_chain=(Chain)getChain(i,j).clone();
      cloned_chain.setParent(n);
      cloned_model.add(cloned_chain);
    }
    n.addModel(cloned_model);
  }
  List<Compound> newCompoundList=new ArrayList<Compound>();
  for (  Compound compound : this.compounds) {
    Compound newCompound=new Compound(compound);
    for (    String chainId : compound.getChainIds()) {
      try {
        for (int modelNr=0; modelNr < n.nrModels(); modelNr++) {
          Chain newChain=n.getChainByPDB(chainId,modelNr);
          newChain.setCompound(newCompound);
          newCompound.addChain(newChain);
        }
      }
 catch (      StructureException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
    newCompoundList.add(newCompound);
  }
  n.setCompounds(newCompoundList);
  for (  SSBond ssbond : ssbonds) {
    n.addSSBond(ssbond.clone());
  }
  return n;
}","/** 
 * returns an identical copy of this structure .
 * @return an identical Structure object
 */
@Override public Structure clone(){
  Structure n=new StructureImpl();
  n.setPDBCode(getPDBCode());
  n.setName(getName());
  n.setPDBHeader(pdbHeader);
  n.setDBRefs(this.getDBRefs());
  n.setConnections(getConnections());
  n.setSites(getSites());
  for (int i=0; i < nrModels(); i++) {
    List<Chain> cloned_model=new ArrayList<Chain>();
    for (int j=0; j < size(i); j++) {
      Chain cloned_chain=(Chain)getChain(i,j).clone();
      cloned_chain.setParent(n);
      cloned_model.add(cloned_chain);
    }
    n.addModel(cloned_model);
  }
  List<Compound> newCompoundList=new ArrayList<Compound>();
  for (  Compound compound : this.compounds) {
    Compound newCompound=new Compound(compound);
    for (    String chainId : compound.getChainIds()) {
      for (int modelNr=0; modelNr < n.nrModels(); modelNr++) {
        try {
          Chain newChain=n.getChainByPDB(chainId,modelNr);
          newChain.setCompound(newCompound);
          newCompound.addChain(newChain);
        }
 catch (        StructureException e) {
          logger.warn(""String_Node_Str"" + chainId + ""String_Node_Str""+ modelNr+ ""String_Node_Str""+ compound.getMolId()+ ""String_Node_Str"");
        }
      }
    }
    newCompoundList.add(newCompound);
  }
  n.setCompounds(newCompoundList);
  for (  SSBond ssbond : ssbonds) {
    n.addSSBond(ssbond.clone());
  }
  return n;
}",0.9314387211367672
16791,"/** 
 * Test of process method, of class GenbankReader.
 */
@Test public void testProcess() throws Throwable {
  GenbankProxySequenceReader<AminoAcidCompound> genbankProteinReader=new GenbankProxySequenceReader<AminoAcidCompound>(System.getProperty(""String_Node_Str""),""String_Node_Str"",AminoAcidCompoundSet.getAminoAcidCompoundSet());
  ProteinSequence proteinSequence=new ProteinSequence(genbankProteinReader);
  genbankProteinReader.getHeaderParser().parseHeader(genbankProteinReader.getHeader(),proteinSequence);
  logger.info(""String_Node_Str"",proteinSequence.getAccession(),proteinSequence.getLength(),proteinSequence.getSequenceAsString().substring(0,10));
  GenbankProxySequenceReader<NucleotideCompound> genbankDNAReader=new GenbankProxySequenceReader<NucleotideCompound>(System.getProperty(""String_Node_Str""),""String_Node_Str"",DNACompoundSet.getDNACompoundSet());
  DNASequence dnaSequence=new DNASequence(genbankDNAReader);
  genbankDNAReader.getHeaderParser().parseHeader(genbankDNAReader.getHeader(),dnaSequence);
  logger.info(""String_Node_Str"",dnaSequence.getAccession(),dnaSequence.getLength(),dnaSequence.getSequenceAsString().substring(0,10));
  File dnaFile=new File(""String_Node_Str"");
  File protFile=new File(""String_Node_Str"");
  LinkedHashMap<String,DNASequence> dnaSequences=GenbankReaderHelper.readGenbankDNASequence(dnaFile);
  for (  DNASequence sequence : dnaSequences.values()) {
    logger.info(""String_Node_Str"",sequence.getSequenceAsString());
  }
  LinkedHashMap<String,ProteinSequence> protSequences=GenbankReaderHelper.readGenbankProteinSequence(protFile);
  for (  ProteinSequence sequence : protSequences.values()) {
    logger.info(""String_Node_Str"",sequence.getSequenceAsString());
  }
  FileInputStream is=new FileInputStream(dnaFile);
  GenbankReader<DNASequence,NucleotideCompound> dnaReader=new GenbankReader<DNASequence,NucleotideCompound>(is,new GenericGenbankHeaderParser<DNASequence,NucleotideCompound>(),new DNASequenceCreator(DNACompoundSet.getDNACompoundSet()));
  dnaSequences=dnaReader.process();
  is.close();
  logger.info(""String_Node_Str"",dnaSequences);
  is=new FileInputStream(protFile);
  GenbankReader<ProteinSequence,AminoAcidCompound> protReader=new GenbankReader<ProteinSequence,AminoAcidCompound>(is,new GenericGenbankHeaderParser<ProteinSequence,AminoAcidCompound>(),new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));
  protSequences=protReader.process();
  is.close();
  logger.info(""String_Node_Str"",protSequences);
}","/** 
 * Test of process method, of class GenbankReader.
 */
@Test public void testProcess() throws Throwable {
  GenbankProxySequenceReader<AminoAcidCompound> genbankProteinReader=new GenbankProxySequenceReader<AminoAcidCompound>(System.getProperty(""String_Node_Str""),""String_Node_Str"",AminoAcidCompoundSet.getAminoAcidCompoundSet());
  ProteinSequence proteinSequence=new ProteinSequence(genbankProteinReader);
  genbankProteinReader.getHeaderParser().parseHeader(genbankProteinReader.getHeader(),proteinSequence);
  logger.info(""String_Node_Str"",proteinSequence.getAccession(),proteinSequence.getLength(),proteinSequence.getSequenceAsString().substring(0,10));
  GenbankProxySequenceReader<NucleotideCompound> genbankDNAReader=new GenbankProxySequenceReader<NucleotideCompound>(System.getProperty(""String_Node_Str""),""String_Node_Str"",DNACompoundSet.getDNACompoundSet());
  DNASequence dnaSequence=new DNASequence(genbankDNAReader);
  genbankDNAReader.getHeaderParser().parseHeader(genbankDNAReader.getHeader(),dnaSequence);
  logger.info(""String_Node_Str"",dnaSequence.getAccession(),dnaSequence.getLength(),dnaSequence.getSequenceAsString().substring(0,10));
  ClasspathResource dnaResource=new ClasspathResource(""String_Node_Str"",true);
  ClasspathResource protResource=new ClasspathResource(""String_Node_Str"");
  LinkedHashMap<String,DNASequence> dnaSequences=GenbankReaderHelper.readGenbankDNASequence(dnaResource.getInputStream());
  for (  DNASequence sequence : dnaSequences.values()) {
    logger.info(""String_Node_Str"",sequence.getSequenceAsString());
  }
  LinkedHashMap<String,ProteinSequence> protSequences=GenbankReaderHelper.readGenbankProteinSequence(protResource.getInputStream());
  for (  ProteinSequence sequence : protSequences.values()) {
    logger.info(""String_Node_Str"",sequence.getSequenceAsString());
  }
  GenbankReader<DNASequence,NucleotideCompound> dnaReader=new GenbankReader<DNASequence,NucleotideCompound>(dnaResource.getInputStream(),new GenericGenbankHeaderParser<DNASequence,NucleotideCompound>(),new DNASequenceCreator(DNACompoundSet.getDNACompoundSet()));
  dnaSequences=dnaReader.process();
  logger.info(""String_Node_Str"",dnaSequences);
  GenbankReader<ProteinSequence,AminoAcidCompound> protReader=new GenbankReader<ProteinSequence,AminoAcidCompound>(protResource.getInputStream(),new GenericGenbankHeaderParser<ProteinSequence,AminoAcidCompound>(),new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));
  protSequences=protReader.process();
  logger.info(""String_Node_Str"",protSequences);
}",0.8521224086870681
16792,"/** 
 * Get the predominant   {@link GroupType} for a given Chain, following these rules:<li>if the ratio of number of residues of a certain  {@link GroupType} to total non-water residues is above the threshold  {@value #RATIO_RESIDUES_TO_TOTAL}, then that   {@link GroupType} is returned </li><li>if there is no  {@link GroupType} that is above the threshold then the {@link GroupType} with most members is chosen, logging it</li> See also  {@link ChemComp#getPolymerType()} and {@link ChemComp#getResidueType()} which follow the PDB chemical component dictionary and provide a much more accurate description of  groups and their linking.
 * @param c
 * @return
 */
public static GroupType getPredominantGroupType(Chain c){
  int sizeAminos=c.getAtomGroups(GroupType.AMINOACID).size();
  int sizeNucleotides=c.getAtomGroups(GroupType.NUCLEOTIDE).size();
  List<Group> hetAtoms=c.getAtomGroups(GroupType.HETATM);
  int sizeHetatoms=hetAtoms.size();
  int sizeWaters=0;
  for (  Group g : hetAtoms) {
    if (g.isWater())     sizeWaters++;
  }
  int fullSize=sizeAminos + sizeNucleotides + sizeHetatoms - sizeWaters;
  if ((double)sizeAminos / (double)fullSize > RATIO_RESIDUES_TO_TOTAL)   return GroupType.AMINOACID;
  if ((double)sizeNucleotides / (double)fullSize > RATIO_RESIDUES_TO_TOTAL)   return GroupType.NUCLEOTIDE;
  if ((double)(sizeHetatoms - sizeWaters) / (double)fullSize > RATIO_RESIDUES_TO_TOTAL)   return GroupType.HETATM;
  GroupType max;
  if (sizeNucleotides > sizeAminos) {
    if (sizeNucleotides > sizeHetatoms) {
      max=GroupType.NUCLEOTIDE;
    }
 else {
      max=GroupType.HETATM;
    }
  }
 else {
    if (sizeAminos > sizeHetatoms) {
      max=GroupType.AMINOACID;
    }
 else {
      max=GroupType.HETATM;
    }
  }
  logger.debug(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",c.getChainID(),RATIO_RESIDUES_TO_TOTAL,max,sizeAminos,sizeNucleotides,sizeHetatoms,sizeWaters,(double)sizeAminos / (double)fullSize,(double)sizeNucleotides / (double)fullSize);
  return max;
}","/** 
 * Get the predominant   {@link GroupType} for a given Chain, following these rules:<li>if the ratio of number of residues of a certain  {@link GroupType} to total non-water residues is above the threshold  {@value #RATIO_RESIDUES_TO_TOTAL}, then that   {@link GroupType} is returned </li><li>if there is no  {@link GroupType} that is above the threshold then the {@link GroupType} with most members is chosen, logging it</li> <p> See also  {@link ChemComp#getPolymerType()} and {@link ChemComp#getResidueType()} which follow the PDB chemical component dictionary and provide a much more accurate description of  groups and their linking. </p>
 * @param c
 * @return
 */
public static GroupType getPredominantGroupType(Chain c){
  int sizeAminos=c.getAtomGroups(GroupType.AMINOACID).size();
  int sizeNucleotides=c.getAtomGroups(GroupType.NUCLEOTIDE).size();
  List<Group> hetAtoms=c.getAtomGroups(GroupType.HETATM);
  int sizeHetatoms=hetAtoms.size();
  int sizeWaters=0;
  for (  Group g : hetAtoms) {
    if (g.isWater())     sizeWaters++;
  }
  int sizeHetatomsWithoutWater=sizeHetatoms - sizeWaters;
  int fullSize=sizeAminos + sizeNucleotides + sizeHetatomsWithoutWater;
  if ((double)sizeAminos / (double)fullSize > RATIO_RESIDUES_TO_TOTAL)   return GroupType.AMINOACID;
  if ((double)sizeNucleotides / (double)fullSize > RATIO_RESIDUES_TO_TOTAL)   return GroupType.NUCLEOTIDE;
  if ((double)(sizeHetatomsWithoutWater) / (double)fullSize > RATIO_RESIDUES_TO_TOTAL)   return GroupType.HETATM;
  GroupType max;
  if (sizeNucleotides > sizeAminos) {
    if (sizeNucleotides > sizeHetatomsWithoutWater) {
      max=GroupType.NUCLEOTIDE;
    }
 else {
      max=GroupType.HETATM;
    }
  }
 else {
    if (sizeAminos > sizeHetatomsWithoutWater) {
      max=GroupType.AMINOACID;
    }
 else {
      max=GroupType.HETATM;
    }
  }
  logger.debug(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",c.getChainID(),RATIO_RESIDUES_TO_TOTAL,max,sizeAminos,sizeNucleotides,sizeHetatomsWithoutWater,sizeWaters,(double)sizeAminos / (double)fullSize,(double)sizeNucleotides / (double)fullSize);
  return max;
}",0.9600193845408288
16793,"/** 
 * returns an identical copy of this structure .
 * @return an identical Structure object
 */
@Override public Structure clone(){
  Structure n=new StructureImpl();
  n.setPDBCode(getPDBCode());
  n.setName(getName());
  n.setPDBHeader(pdbHeader);
  n.setDBRefs(this.getDBRefs());
  n.setConnections(getConnections());
  n.setSites(getSites());
  for (int i=0; i < nrModels(); i++) {
    List<Chain> cloned_model=new ArrayList<Chain>();
    for (int j=0; j < size(i); j++) {
      Chain cloned_chain=(Chain)getChain(i,j).clone();
      cloned_chain.setParent(n);
      cloned_model.add(cloned_chain);
    }
    n.addModel(cloned_model);
  }
  List<Compound> newCompoundList=new ArrayList<Compound>();
  for (  Compound compound : this.compounds) {
    Compound newCompound=new Compound(compound);
    for (    String chainId : compound.getChainIds()) {
      try {
        Chain newChain=n.getChainByPDB(chainId);
        newChain.setCompound(newCompound);
        newCompound.addChain(newChain);
      }
 catch (      StructureException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
    newCompoundList.add(newCompound);
  }
  n.setCompounds(newCompoundList);
  for (  SSBond ssbond : ssbonds) {
    n.addSSBond(ssbond.clone());
  }
  return n;
}","/** 
 * returns an identical copy of this structure .
 * @return an identical Structure object
 */
@Override public Structure clone(){
  Structure n=new StructureImpl();
  n.setPDBCode(getPDBCode());
  n.setName(getName());
  n.setPDBHeader(pdbHeader);
  n.setDBRefs(this.getDBRefs());
  n.setConnections(getConnections());
  n.setSites(getSites());
  for (int i=0; i < nrModels(); i++) {
    List<Chain> cloned_model=new ArrayList<Chain>();
    for (int j=0; j < size(i); j++) {
      Chain cloned_chain=(Chain)getChain(i,j).clone();
      cloned_chain.setParent(n);
      cloned_model.add(cloned_chain);
    }
    n.addModel(cloned_model);
  }
  List<Compound> newCompoundList=new ArrayList<Compound>();
  for (  Compound compound : this.compounds) {
    Compound newCompound=new Compound(compound);
    for (    String chainId : compound.getChainIds()) {
      try {
        for (int modelNr=0; modelNr < n.nrModels(); modelNr++) {
          Chain newChain=n.getChainByPDB(chainId,modelNr);
          newChain.setCompound(newCompound);
          newCompound.addChain(newChain);
        }
      }
 catch (      StructureException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
    newCompoundList.add(newCompound);
  }
  n.setCompounds(newCompoundList);
  for (  SSBond ssbond : ssbonds) {
    n.addSSBond(ssbond.clone());
  }
  return n;
}",0.9638095238095238
16794,"private void testChainRefs(Chain c){
  assertNotNull(c.getCompound());
  for (  Group g : c.getAtomGroups()) {
    assertSame(""String_Node_Str"" + g.toString(),c,g.getChain());
    for (    Atom a : g.getAtoms()) {
      assertSame(g,a.getGroup());
      assertSame(c,a.getGroup().getChain());
    }
    if (c.getSeqResGroups().size() > 0) {
      assertTrue(""String_Node_Str"" + g.toString(),containsReference(g,c.getSeqResGroups()));
    }
  }
  for (  Group g : c.getSeqResGroups()) {
    assertSame(""String_Node_Str"" + g.toString(),c,g.getChain());
    for (    Atom a : g.getAtoms()) {
      assertSame(g,a.getGroup());
      assertSame(c,a.getGroup().getChain());
    }
  }
}","private void testChainRefs(Chain c){
  assertNotNull(c.getCompound());
  for (  Group g : c.getAtomGroups()) {
    assertSame(""String_Node_Str"" + g.toString(),c,g.getChain());
    for (    Atom a : g.getAtoms()) {
      assertSame(g,a.getGroup());
      assertSame(c,a.getGroup().getChain());
    }
    if (c.getSeqResGroups().size() > 0) {
      if (g.getType() == GroupType.HETATM)       continue;
      assertTrue(""String_Node_Str"" + g.toString(),containsReference(g,c.getSeqResGroups()));
    }
  }
  for (  Group g : c.getSeqResGroups()) {
    assertSame(""String_Node_Str"" + g.toString(),c,g.getChain());
    for (    Atom a : g.getAtoms()) {
      assertSame(g,a.getGroup());
      assertSame(c,a.getGroup().getChain());
    }
  }
}",0.958362738179252
16795,"@Test public void testCrossReferencesMmCif() throws IOException, StructureException {
  AtomCache cache=new AtomCache();
  cache.setUseMmCif(true);
  FileParsingParameters params=new FileParsingParameters();
  params.setAlignSeqRes(false);
  cache.setFileParsingParams(params);
  StructureIO.setAtomCache(cache);
  Structure structure=StructureIO.getStructure(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  doFullTest(structure);
}","@Test public void testCrossReferencesMmCif() throws IOException, StructureException {
  AtomCache cache=new AtomCache();
  cache.setUseMmCif(true);
  FileParsingParameters params=new FileParsingParameters();
  params.setAlignSeqRes(false);
  cache.setFileParsingParams(params);
  StructureIO.setAtomCache(cache);
  Structure structure=StructureIO.getStructure(PDBCODE1);
  System.out.println(""String_Node_Str"");
  doFullTest(structure);
  structure=StructureIO.getStructure(PDBCODE2);
  doFullTest(structure);
}",0.860125260960334
16796,"@Test public void testCrossReferencesPdbAlignSeqRes() throws IOException, StructureException {
  AtomCache cache=new AtomCache();
  cache.setUseMmCif(false);
  FileParsingParameters params=new FileParsingParameters();
  params.setAlignSeqRes(true);
  cache.setFileParsingParams(params);
  StructureIO.setAtomCache(cache);
  System.out.println(""String_Node_Str"");
  Structure structure=StructureIO.getStructure(""String_Node_Str"");
  doFullTest(structure);
}","@Test public void testCrossReferencesPdbAlignSeqRes() throws IOException, StructureException {
  AtomCache cache=new AtomCache();
  cache.setUseMmCif(false);
  FileParsingParameters params=new FileParsingParameters();
  params.setAlignSeqRes(true);
  cache.setFileParsingParams(params);
  StructureIO.setAtomCache(cache);
  System.out.println(""String_Node_Str"");
  Structure structure=StructureIO.getStructure(PDBCODE1);
  doFullTest(structure);
  structure=StructureIO.getStructure(PDBCODE2);
  doFullTest(structure);
}",0.9016393442622952
16797,"@Test public void testCrossReferencesMmCifAlignSeqRes() throws IOException, StructureException {
  AtomCache cache=new AtomCache();
  cache.setUseMmCif(true);
  FileParsingParameters params=new FileParsingParameters();
  params.setAlignSeqRes(true);
  cache.setFileParsingParams(params);
  StructureIO.setAtomCache(cache);
  Structure structure=StructureIO.getStructure(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  doFullTest(structure);
}","@Test public void testCrossReferencesMmCifAlignSeqRes() throws IOException, StructureException {
  AtomCache cache=new AtomCache();
  cache.setUseMmCif(true);
  FileParsingParameters params=new FileParsingParameters();
  params.setAlignSeqRes(true);
  cache.setFileParsingParams(params);
  StructureIO.setAtomCache(cache);
  Structure structure=StructureIO.getStructure(PDBCODE1);
  System.out.println(""String_Node_Str"");
  doFullTest(structure);
  structure=StructureIO.getStructure(PDBCODE2);
  doFullTest(structure);
}",0.8629856850715747
16798,"@Test public void testCrossReferencesPdb() throws IOException, StructureException {
  AtomCache cache=new AtomCache();
  cache.setUseMmCif(false);
  FileParsingParameters params=new FileParsingParameters();
  params.setAlignSeqRes(false);
  cache.setFileParsingParams(params);
  StructureIO.setAtomCache(cache);
  Structure structure=StructureIO.getStructure(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  doFullTest(structure);
}","@Test public void testCrossReferencesPdb() throws IOException, StructureException {
  AtomCache cache=new AtomCache();
  cache.setUseMmCif(false);
  FileParsingParameters params=new FileParsingParameters();
  params.setAlignSeqRes(false);
  cache.setFileParsingParams(params);
  StructureIO.setAtomCache(cache);
  Structure structure=StructureIO.getStructure(PDBCODE1);
  System.out.println(""String_Node_Str"");
  doFullTest(structure);
  structure=StructureIO.getStructure(PDBCODE2);
  doFullTest(structure);
}",0.8598326359832636
16799,"private void testStructureRefs(Structure s) throws StructureException {
  for (  Chain c : s.getChains()) {
    logger.debug(""String_Node_Str"",System.identityHashCode(s));
    logger.debug(""String_Node_Str"",System.identityHashCode(c.getParent()));
    assertSame(s,c.getParent());
    testChainRefs(c);
  }
  for (  Compound compound : s.getCompounds()) {
    for (    Chain c : compound.getChains()) {
      assertSame(compound,c.getCompound());
      Chain cFromStruc=s.getChainByPDB(c.getChainID());
      assertSame(cFromStruc,c);
    }
  }
}","private void testStructureRefs(Structure s) throws StructureException {
  for (  Chain c : s.getChains()) {
    logger.debug(""String_Node_Str"",System.identityHashCode(s));
    logger.debug(""String_Node_Str"",System.identityHashCode(c.getParent()));
    assertSame(s,c.getParent());
    testChainRefs(c);
  }
  for (  Compound compound : s.getCompounds()) {
    for (    Chain c : compound.getChains()) {
      assertSame(compound,c.getCompound());
      int count=0;
      for (int modelNr=0; modelNr < s.nrModels(); modelNr++) {
        Chain cFromStruc=s.getChainByPDB(c.getChainID(),modelNr);
        if (cFromStruc == c)         count++;
      }
      assertEquals(""String_Node_Str"",1,count);
    }
  }
}",0.839584996009577
16800,"/** 
 * Searches for previously downloaded files
 * @param pdbId
 * @return A file pointing to the existing file, or null if not found
 */
public File getLocalFile(String pdbId){
  LinkedList<File> searchdirs=new LinkedList<File>();
  String middle=pdbId.substring(1,3).toLowerCase();
  File splitdir=new File(splitDirPath,middle);
  searchdirs.add(splitdir);
  if (getObsoleteBehavior() == ObsoleteBehavior.FETCH_OBSOLETE) {
    File obsdir=new File(obsoleteDirPath,middle);
    searchdirs.add(obsdir);
  }
  String[] prefixes=new String[]{""String_Node_Str"",""String_Node_Str""};
  for (  File searchdir : searchdirs) {
    for (    String prefix : prefixes) {
      for (      String ex : getExtensions()) {
        File f=new File(searchdir,prefix + pdbId + ex);
        if (f.exists()) {
          return f;
        }
      }
    }
  }
  return null;
}","/** 
 * Searches for previously downloaded files
 * @param pdbId
 * @return A file pointing to the existing file, or null if not found
 */
public File getLocalFile(String pdbId){
  LinkedList<File> searchdirs=new LinkedList<File>();
  String middle=pdbId.substring(1,3).toLowerCase();
  File splitdir=new File(splitDirPath,middle);
  searchdirs.add(splitdir);
  if (getObsoleteBehavior() == ObsoleteBehavior.FETCH_OBSOLETE) {
    File obsdir=new File(obsoleteDirPath,middle);
    searchdirs.add(obsdir);
  }
  String[] prefixes=new String[]{""String_Node_Str"",""String_Node_Str""};
  for (  File searchdir : searchdirs) {
    for (    String prefix : prefixes) {
      for (      String ex : getExtensions()) {
        File f=new File(searchdir,prefix + pdbId.toLowerCase() + ex);
        if (f.exists()) {
          return f;
        }
      }
    }
  }
  return null;
}",0.991869918699187
16801,"/** 
 * Calculate interfaces between original asymmetric unit and neighboring whole unit cells, including the original full unit cell i.e. i=0,j=0,k=0
 * @param set
 * @param cutoff
 */
private void calcInterfacesCrystal(StructureInterfaceList set,double cutoff,boolean isCrystallographic){
  long start=-1;
  long end=-1;
  int trialCount=0;
  int skippedRedundant=0;
  int skippedAUsNoOverlap=0;
  int skippedChainsNoOverlap=0;
  int skippedSelfEquivalent=0;
  Matrix4d[] ops=null;
  if (isCrystallographic) {
    ops=structure.getCrystallographicInfo().getTransformationsOrthonormal();
  }
 else {
    ops=new Matrix4d[1];
    ops[0]=new Matrix4d(IDENTITY);
  }
  UnitCellBoundingBox bbGrid=new UnitCellBoundingBox(numOperatorsSg,numChainsAu);
  ;
  bbGrid.setBbs(structure,ops,INCLUDE_HETATOMS);
  if (!isCrystallographic)   numCells=0;
  boolean verbose=logger.isDebugEnabled();
  if (verbose) {
    trialCount=0;
    start=System.currentTimeMillis();
    int neighbors=(2 * numCells + 1) * (2 * numCells + 1) * (2 * numCells + 1) - 1;
    int auTrials=(numChainsAu * (numChainsAu - 1)) / 2;
    int trials=numChainsAu * numOperatorsSg * numChainsAu* neighbors;
    logger.debug(""String_Node_Str"" + auTrials);
    logger.debug(""String_Node_Str"" + neighbors + ""String_Node_Str""+ numCells+ ""String_Node_Str""+ ""String_Node_Str""+ numChainsAu+ ""String_Node_Str""+ numOperatorsSg+ ""String_Node_Str""+ neighbors+ ""String_Node_Str""+ trials);
    logger.debug(""String_Node_Str"" + (auTrials + trials));
  }
  for (int a=-numCells; a <= numCells; a++) {
    for (int b=-numCells; b <= numCells; b++) {
      for (int c=-numCells; c <= numCells; c++) {
        Point3i trans=new Point3i(a,b,c);
        Vector3d transOrth=new Vector3d(a,b,c);
        if (a != 0 || b != 0 || c != 0)         this.crystallographicInfo.getCrystalCell().transfToOrthonormal(transOrth);
        UnitCellBoundingBox bbGridTrans=bbGrid.getTranslatedBbs(transOrth);
        for (int n=0; n < numOperatorsSg; n++) {
          if (!bbGrid.getAuBoundingBox(0).overlaps(bbGridTrans.getAuBoundingBox(n),cutoff)) {
            skippedAUsNoOverlap++;
            continue;
          }
          CrystalTransform tt=new CrystalTransform(this.crystallographicInfo.getSpaceGroup(),n);
          tt.translate(trans);
          if (isRedundant(tt)) {
            skippedRedundant++;
            continue;
          }
          addVisited(tt);
          boolean selfEquivalent=false;
          if (tt.isEquivalent(tt)) {
            logger.debug(""String_Node_Str"" + tt + ""String_Node_Str"");
            selfEquivalent=true;
          }
          StringBuilder builder=null;
          if (verbose)           builder=new StringBuilder(tt + ""String_Node_Str"");
          int contactsFound=0;
          for (int j=0; j < numChainsAu; j++) {
            for (int i=0; i < numChainsAu; i++) {
              if (selfEquivalent && (j > i)) {
                skippedSelfEquivalent++;
                continue;
              }
              if (n == 0 && a == 0 && b == 0 && c == 0 && i == j)               continue;
              if (!bbGrid.getChainBoundingBox(0,i).overlaps(bbGridTrans.getChainBoundingBox(n,j),cutoff)) {
                skippedChainsNoOverlap++;
                if (verbose) {
                  builder.append(""String_Node_Str"");
                }
                continue;
              }
              trialCount++;
              Chain chainj=null;
              Chain chaini=structure.getChain(i);
              if (n == 0 && a == 0 && b == 0 && c == 0) {
                chainj=structure.getChain(j);
              }
 else {
                chainj=(Chain)structure.getChain(j).clone();
                Matrix4d m=new Matrix4d(ops[n]);
                translate(m,transOrth);
                Calc.transform(chainj,m);
              }
              StructureInterface interf=calcContacts(chaini,chainj,cutoff,tt,builder);
              if (interf != null) {
                contactsFound++;
                set.add(interf);
              }
            }
          }
          if (verbose) {
            if (a == 0 && b == 0 && c == 0 && n == 0)             builder.append(""String_Node_Str"" + contactsFound + ""String_Node_Str""+ (numChainsAu * (numChainsAu - 1)) / 2 + ""String_Node_Str"");
 else             if (selfEquivalent)             builder.append(""String_Node_Str"" + contactsFound + ""String_Node_Str""+ (numChainsAu * (numChainsAu + 1)) / 2 + ""String_Node_Str"");
 else             builder.append(""String_Node_Str"" + contactsFound + ""String_Node_Str""+ numChainsAu * numChainsAu + ""String_Node_Str"");
            logger.debug(builder.toString());
          }
        }
      }
    }
  }
  end=System.currentTimeMillis();
  logger.debug(""String_Node_Str"" + trialCount + ""String_Node_Str""+ (end - start) / 1000 + ""String_Node_Str"");
  logger.debug(""String_Node_Str"" + skippedAUsNoOverlap);
  logger.debug(""String_Node_Str"" + skippedChainsNoOverlap);
  logger.debug(""String_Node_Str"" + skippedRedundant);
  logger.debug(""String_Node_Str"" + skippedSelfEquivalent);
  logger.debug(""String_Node_Str"" + set.size() + ""String_Node_Str"");
}","/** 
 * Calculate interfaces between original asymmetric unit and neighboring whole unit cells, including the original full unit cell i.e. i=0,j=0,k=0
 * @param set
 * @param cutoff
 */
private void calcInterfacesCrystal(StructureInterfaceList set,double cutoff){
  long start=-1;
  long end=-1;
  int trialCount=0;
  int skippedRedundant=0;
  int skippedAUsNoOverlap=0;
  int skippedChainsNoOverlap=0;
  int skippedSelfEquivalent=0;
  Matrix4d[] ops=null;
  if (isCrystallographic) {
    ops=structure.getCrystallographicInfo().getTransformationsOrthonormal();
  }
 else {
    ops=new Matrix4d[1];
    ops[0]=new Matrix4d(IDENTITY);
  }
  UnitCellBoundingBox bbGrid=new UnitCellBoundingBox(numOperatorsSg,numChainsAu);
  ;
  bbGrid.setBbs(structure,ops,INCLUDE_HETATOMS);
  if (!isCrystallographic)   numCells=0;
  boolean verbose=logger.isDebugEnabled();
  if (verbose) {
    trialCount=0;
    start=System.currentTimeMillis();
    int neighbors=(2 * numCells + 1) * (2 * numCells + 1) * (2 * numCells + 1) - 1;
    int auTrials=(numChainsAu * (numChainsAu - 1)) / 2;
    int trials=numChainsAu * numOperatorsSg * numChainsAu* neighbors;
    logger.debug(""String_Node_Str"" + auTrials);
    logger.debug(""String_Node_Str"" + neighbors + ""String_Node_Str""+ numCells+ ""String_Node_Str""+ ""String_Node_Str""+ numChainsAu+ ""String_Node_Str""+ numOperatorsSg+ ""String_Node_Str""+ neighbors+ ""String_Node_Str""+ trials);
    logger.debug(""String_Node_Str"" + (auTrials + trials));
  }
  for (int a=-numCells; a <= numCells; a++) {
    for (int b=-numCells; b <= numCells; b++) {
      for (int c=-numCells; c <= numCells; c++) {
        Point3i trans=new Point3i(a,b,c);
        Vector3d transOrth=new Vector3d(a,b,c);
        if (a != 0 || b != 0 || c != 0)         this.crystallographicInfo.getCrystalCell().transfToOrthonormal(transOrth);
        UnitCellBoundingBox bbGridTrans=bbGrid.getTranslatedBbs(transOrth);
        for (int n=0; n < numOperatorsSg; n++) {
          if (!bbGrid.getAuBoundingBox(0).overlaps(bbGridTrans.getAuBoundingBox(n),cutoff)) {
            skippedAUsNoOverlap++;
            continue;
          }
          CrystalTransform tt=new CrystalTransform(this.crystallographicInfo.getSpaceGroup(),n);
          tt.translate(trans);
          if (isRedundant(tt)) {
            skippedRedundant++;
            continue;
          }
          addVisited(tt);
          boolean selfEquivalent=false;
          if (tt.isEquivalent(tt)) {
            logger.debug(""String_Node_Str"" + tt + ""String_Node_Str"");
            selfEquivalent=true;
          }
          StringBuilder builder=null;
          if (verbose)           builder=new StringBuilder(tt + ""String_Node_Str"");
          int contactsFound=0;
          for (int j=0; j < numChainsAu; j++) {
            for (int i=0; i < numChainsAu; i++) {
              if (selfEquivalent && (j > i)) {
                skippedSelfEquivalent++;
                continue;
              }
              if (n == 0 && a == 0 && b == 0 && c == 0 && i == j)               continue;
              if (!bbGrid.getChainBoundingBox(0,i).overlaps(bbGridTrans.getChainBoundingBox(n,j),cutoff)) {
                skippedChainsNoOverlap++;
                if (verbose) {
                  builder.append(""String_Node_Str"");
                }
                continue;
              }
              trialCount++;
              Chain chainj=null;
              Chain chaini=structure.getChain(i);
              if (n == 0 && a == 0 && b == 0 && c == 0) {
                chainj=structure.getChain(j);
              }
 else {
                chainj=(Chain)structure.getChain(j).clone();
                Matrix4d m=new Matrix4d(ops[n]);
                translate(m,transOrth);
                Calc.transform(chainj,m);
              }
              StructureInterface interf=calcContacts(chaini,chainj,cutoff,tt,builder);
              if (interf != null) {
                contactsFound++;
                set.add(interf);
              }
            }
          }
          if (verbose) {
            if (a == 0 && b == 0 && c == 0 && n == 0)             builder.append(""String_Node_Str"" + contactsFound + ""String_Node_Str""+ (numChainsAu * (numChainsAu - 1)) / 2 + ""String_Node_Str"");
 else             if (selfEquivalent)             builder.append(""String_Node_Str"" + contactsFound + ""String_Node_Str""+ (numChainsAu * (numChainsAu + 1)) / 2 + ""String_Node_Str"");
 else             builder.append(""String_Node_Str"" + contactsFound + ""String_Node_Str""+ numChainsAu * numChainsAu + ""String_Node_Str"");
            logger.debug(builder.toString());
          }
        }
      }
    }
  }
  end=System.currentTimeMillis();
  logger.debug(""String_Node_Str"" + trialCount + ""String_Node_Str""+ (end - start) / 1000 + ""String_Node_Str"");
  logger.debug(""String_Node_Str"" + skippedAUsNoOverlap);
  logger.debug(""String_Node_Str"" + skippedChainsNoOverlap);
  logger.debug(""String_Node_Str"" + skippedRedundant);
  logger.debug(""String_Node_Str"" + skippedSelfEquivalent);
  logger.debug(""String_Node_Str"" + set.size() + ""String_Node_Str"");
}",0.9973453937665911
16802,"/** 
 * Returns the list of unique interfaces that the given Structure has upon generation of all crystal symmetry mates. An interface is defined as any pair of chains that contact, i.e. for which there is at least a pair of atoms (one from each chain) within the given cutoff distance.
 * @param cutoff the distance cutoff for 2 chains to be considered in contact
 * @return
 */
public StructureInterfaceList getUniqueInterfaces(double cutoff){
  StructureInterfaceList set=new StructureInterfaceList();
  if (structure.getChains().size() == 0) {
    logger.warn(""String_Node_Str"");
    return set;
  }
  initialiseVisited();
  calcInterfacesCrystal(set,cutoff,isCrystallographic);
  return set;
}","/** 
 * Returns the list of unique interfaces that the given Structure has upon generation of all crystal symmetry mates. An interface is defined as any pair of chains that contact, i.e. for which there is at least a pair of atoms (one from each chain) within the given cutoff distance.
 * @param cutoff the distance cutoff for 2 chains to be considered in contact
 * @return
 */
public StructureInterfaceList getUniqueInterfaces(double cutoff){
  StructureInterfaceList set=new StructureInterfaceList();
  if (structure.getChains().size() == 0) {
    logger.warn(""String_Node_Str"");
    return set;
  }
  initialiseVisited();
  calcInterfacesCrystal(set,cutoff);
  return set;
}",0.9862018881626724
16803,"public CrystalBuilder(Structure structure){
  this.structure=structure;
  this.crystallographicInfo=structure.getCrystallographicInfo();
  this.numChainsAu=structure.getChains().size();
  this.numOperatorsSg=1;
  this.isCrystallographic=false;
  if (structure.isCrystallographic() && this.crystallographicInfo.getSpaceGroup() == null) {
    logger.warn(""String_Node_Str"");
  }
  if (structure.isCrystallographic() && this.crystallographicInfo.getSpaceGroup() != null) {
    this.numOperatorsSg=this.crystallographicInfo.getSpaceGroup().getMultiplicity();
    this.isCrystallographic=true;
  }
  this.numCells=DEF_NUM_CELLS;
}","public CrystalBuilder(Structure structure){
  this.structure=structure;
  this.crystallographicInfo=structure.getCrystallographicInfo();
  this.numChainsAu=structure.getChains().size();
  this.numOperatorsSg=1;
  if (structure.isCrystallographic()) {
    this.isCrystallographic=true;
    if (this.crystallographicInfo.getSpaceGroup() == null) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
    }
 else {
      this.numOperatorsSg=this.crystallographicInfo.getSpaceGroup().getMultiplicity();
    }
    if (this.crystallographicInfo.getCrystalCell() == null) {
      logger.warn(""String_Node_Str"");
      this.isCrystallographic=false;
    }
  }
 else {
    this.isCrystallographic=false;
  }
  this.numCells=DEF_NUM_CELLS;
}",0.6352429296591733
16804,"/** 
 * Parse a PDB file and return a datastructure implementing PDBStructure interface.
 * @param buf  a BufferedReader object
 * @return the Structure object
 * @throws IOException ...
 */
public Structure parsePDBFile(BufferedReader buf) throws IOException {
  load_max_atoms=params.getMaxAtoms();
  my_ATOM_CA_THRESHOLD=params.getAtomCaThreshold();
  structure=new StructureImpl();
  current_model=new ArrayList<Chain>();
  seqResChains=new ArrayList<Chain>();
  siteMap=new LinkedHashMap<String,Site>();
  current_chain=null;
  current_group=null;
  pdbHeader=new PDBHeader();
  connects=new ArrayList<Map<String,Integer>>();
  continuationField=""String_Node_Str"";
  continuationString=""String_Node_Str"";
  current_compound=new Compound();
  sourceLines.clear();
  compndLines.clear();
  isLastCompndLine=false;
  isLastSourceLine=false;
  molTypeCounter=1;
  compounds.clear();
  helixList.clear();
  strandList.clear();
  turnList.clear();
  lengthCheck=-1;
  atomCount=0;
  atomOverflow=false;
  linkRecords=new ArrayList<LinkRecord>();
  parseCAonly=params.isParseCAOnly();
  String line=null;
  while ((line=buf.readLine()) != null) {
    if (line.equals(""String_Node_Str"") || (line.equals(NEWLINE))) {
      continue;
    }
    if ((line.startsWith(""String_Node_Str"")) || (line.startsWith(""String_Node_Str""))) {
      continue;
    }
    if (line.length() < 6) {
      logger.info(""String_Node_Str"" + line + ""String_Node_Str"");
      continue;
    }
    String recordName=line.substring(0,6).trim();
    if (recordName.equals(""String_Node_Str""))     pdb_ATOM_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_SEQRES_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_ATOM_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_MODEL_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_HEADER_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_AUTHOR_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_TITLE_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     sourceLines.add(line);
 else     if (recordName.equals(""String_Node_Str""))     compndLines.add(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_JRNL_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_EXPDTA_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_CRYST1_Handler(line);
 else     if (recordName.startsWith(""String_Node_Str""))     pdb_MTRIXn_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_REMARK_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_CONECT_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_REVDAT_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_DBREF_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_SITE_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_SSBOND_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_LINK_Handler(line);
 else     if (params.isParseSecStruc()) {
      if (recordName.equals(""String_Node_Str""))       pdb_HELIX_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_SHEET_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_TURN_Handler(line);
    }
 else {
    }
  }
  makeCompounds(compndLines,sourceLines);
  triggerEndFileChecks();
  if (params.shouldCreateAtomBonds()) {
    formBonds();
  }
  if (params.isParseSecStruc())   setSecStruc();
  return structure;
}","/** 
 * Parse a PDB file and return a datastructure implementing PDBStructure interface.
 * @param buf  a BufferedReader object
 * @return the Structure object
 * @throws IOException ...
 */
public Structure parsePDBFile(BufferedReader buf) throws IOException {
  load_max_atoms=params.getMaxAtoms();
  my_ATOM_CA_THRESHOLD=params.getAtomCaThreshold();
  structure=new StructureImpl();
  current_model=new ArrayList<Chain>();
  seqResChains=new ArrayList<Chain>();
  siteMap=new LinkedHashMap<String,Site>();
  current_chain=null;
  current_group=null;
  pdbHeader=new PDBHeader();
  connects=new ArrayList<Map<String,Integer>>();
  continuationField=""String_Node_Str"";
  continuationString=""String_Node_Str"";
  current_compound=new Compound();
  sourceLines.clear();
  compndLines.clear();
  isLastCompndLine=false;
  isLastSourceLine=false;
  molTypeCounter=1;
  compounds.clear();
  helixList.clear();
  strandList.clear();
  turnList.clear();
  lengthCheck=-1;
  atomCount=0;
  atomOverflow=false;
  linkRecords=new ArrayList<LinkRecord>();
  siteToResidueMap.clear();
  parseCAonly=params.isParseCAOnly();
  String line=null;
  while ((line=buf.readLine()) != null) {
    if (line.equals(""String_Node_Str"") || (line.equals(NEWLINE))) {
      continue;
    }
    if ((line.startsWith(""String_Node_Str"")) || (line.startsWith(""String_Node_Str""))) {
      continue;
    }
    if (line.length() < 6) {
      logger.info(""String_Node_Str"" + line + ""String_Node_Str"");
      continue;
    }
    String recordName=line.substring(0,6).trim();
    if (recordName.equals(""String_Node_Str""))     pdb_ATOM_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_SEQRES_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_ATOM_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_MODEL_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_HEADER_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_AUTHOR_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_TITLE_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     sourceLines.add(line);
 else     if (recordName.equals(""String_Node_Str""))     compndLines.add(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_JRNL_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_EXPDTA_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_CRYST1_Handler(line);
 else     if (recordName.startsWith(""String_Node_Str""))     pdb_MTRIXn_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_REMARK_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_CONECT_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_REVDAT_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_DBREF_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_SITE_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_SSBOND_Handler(line);
 else     if (recordName.equals(""String_Node_Str""))     pdb_LINK_Handler(line);
 else     if (params.isParseSecStruc()) {
      if (recordName.equals(""String_Node_Str""))       pdb_HELIX_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_SHEET_Handler(line);
 else       if (recordName.equals(""String_Node_Str""))       pdb_TURN_Handler(line);
    }
 else {
    }
  }
  makeCompounds(compndLines,sourceLines);
  triggerEndFileChecks();
  if (params.shouldCreateAtomBonds()) {
    formBonds();
  }
  if (params.isParseSecStruc())   setSecStruc();
  return structure;
}",0.9961717254580256
16805,"/** 
 * Returns the list of unique interfaces that the given Structure has upon generation of all crystal symmetry mates. An interface is defined as any pair of chains that contact, i.e. for which there is at least a pair of atoms (one from each chain) within the given cutoff distance.
 * @param cutoff the distance cutoff for 2 chains to be considered in contact
 * @return
 */
public StructureInterfaceList getUniqueInterfaces(double cutoff){
  StructureInterfaceList set=new StructureInterfaceList();
  initialiseVisited();
  calcInterfacesCrystal(set,cutoff,isCrystallographic);
  return set;
}","/** 
 * Returns the list of unique interfaces that the given Structure has upon generation of all crystal symmetry mates. An interface is defined as any pair of chains that contact, i.e. for which there is at least a pair of atoms (one from each chain) within the given cutoff distance.
 * @param cutoff the distance cutoff for 2 chains to be considered in contact
 * @return
 */
public StructureInterfaceList getUniqueInterfaces(double cutoff){
  StructureInterfaceList set=new StructureInterfaceList();
  if (structure.getChains().size() == 0) {
    logger.warn(""String_Node_Str"");
    return set;
  }
  initialiseVisited();
  calcInterfacesCrystal(set,cutoff,isCrystallographic);
  return set;
}",0.9236700077101002
16806,"/** 
 * Returns the list of unique interfaces that the given Structure has upon generation of all crystal symmetry mates. An interface is defined as any pair of chains that contact, i.e. for which there is at least a pair of atoms (one from each chain) within the given cutoff distance.
 * @param cutoff the distance cutoff for 2 chains to be considered in contact
 * @return
 */
public StructureInterfaceList getUniqueInterfaces(double cutoff){
  StructureInterfaceList set=new StructureInterfaceList();
  initialiseVisited();
  calcInterfacesCrystal(set,cutoff,structure.isCrystallographic());
  return set;
}","/** 
 * Returns the list of unique interfaces that the given Structure has upon generation of all crystal symmetry mates. An interface is defined as any pair of chains that contact, i.e. for which there is at least a pair of atoms (one from each chain) within the given cutoff distance.
 * @param cutoff the distance cutoff for 2 chains to be considered in contact
 * @return
 */
public StructureInterfaceList getUniqueInterfaces(double cutoff){
  StructureInterfaceList set=new StructureInterfaceList();
  initialiseVisited();
  calcInterfacesCrystal(set,cutoff,isCrystallographic);
  return set;
}",0.9900826446280993
16807,"public CrystalBuilder(Structure structure){
  this.structure=structure;
  this.crystallographicInfo=structure.getCrystallographicInfo();
  this.numChainsAu=structure.getChains().size();
  this.numOperatorsSg=1;
  if (structure.isCrystallographic()) {
    this.numOperatorsSg=this.crystallographicInfo.getSpaceGroup().getMultiplicity();
  }
  this.numCells=DEF_NUM_CELLS;
}","public CrystalBuilder(Structure structure){
  this.structure=structure;
  this.crystallographicInfo=structure.getCrystallographicInfo();
  this.numChainsAu=structure.getChains().size();
  this.numOperatorsSg=1;
  this.isCrystallographic=false;
  if (this.crystallographicInfo.getSpaceGroup() == null) {
    logger.warn(""String_Node_Str"");
  }
  if (structure.isCrystallographic() && this.crystallographicInfo.getSpaceGroup() != null) {
    this.numOperatorsSg=this.crystallographicInfo.getSpaceGroup().getMultiplicity();
    this.isCrystallographic=true;
  }
  this.numCells=DEF_NUM_CELLS;
}",0.7019730010384216
16808,"/** 
 * Calculates the contact overlap score between this StructureInterface and the given one.  The two sides of the given StructureInterface need to match this StructureInterface in the sense that they must come from the same Compound (Entity), i.e. their residue numbers need to align with 100% identity, except for unobserved  density residues.
 * @param other
 * @param invert if false the comparison will be done first-to-first and second-to-second, if true the match will be first-to-second and second-to-first
 * @return the contact overlap score, range [0.0,1.0]
 */
public double getContactOverlapScore(StructureInterface other,boolean invert){
  Structure thisStruct=getParentStructure();
  Structure otherStruct=other.getParentStructure();
  if (thisStruct != otherStruct) {
    logger.warn(""String_Node_Str"");
    return 0;
  }
  Pair<Chain> thisChains=getParentChains();
  Pair<Chain> otherChains=other.getParentChains();
  Pair<Compound> thisCompounds=new Pair<Compound>(thisChains.getFirst().getCompound(),thisChains.getSecond().getCompound());
  Pair<Compound> otherCompounds=new Pair<Compound>(otherChains.getFirst().getCompound(),otherChains.getSecond().getCompound());
  if (((thisCompounds.getFirst() == otherCompounds.getFirst()) && (thisCompounds.getSecond() == otherCompounds.getSecond())) || ((thisCompounds.getFirst() == otherCompounds.getSecond()) && (thisCompounds.getSecond() == otherCompounds.getFirst()))) {
    int common=0;
    GroupContactSet thisContacts=getGroupContacts();
    GroupContactSet otherContacts=other.getGroupContacts();
    for (    GroupContact thisContact : thisContacts) {
      ResidueIdentifier first=null;
      ResidueIdentifier second=null;
      if (!invert) {
        first=new ResidueIdentifier(thisContact.getPair().getFirst().getResidueNumber().getSeqNum(),thisContact.getPair().getFirst().getResidueNumber().getInsCode());
        second=new ResidueIdentifier(thisContact.getPair().getSecond().getResidueNumber().getSeqNum(),thisContact.getPair().getSecond().getResidueNumber().getInsCode());
      }
 else {
        first=new ResidueIdentifier(thisContact.getPair().getSecond().getResidueNumber().getSeqNum(),thisContact.getPair().getSecond().getResidueNumber().getInsCode());
        second=new ResidueIdentifier(thisContact.getPair().getFirst().getResidueNumber().getSeqNum(),thisContact.getPair().getFirst().getResidueNumber().getInsCode());
      }
      if (otherContacts.hasContact(first,second)) {
        common++;
      }
    }
    return (2.0 * common) / (thisContacts.size() + otherContacts.size());
  }
 else {
    logger.debug(""String_Node_Str"",thisChains.getFirst().getChainID(),thisChains.getSecond().getChainID(),otherChains.getFirst().getChainID(),otherChains.getSecond().getChainID());
    return 0.0;
  }
}","/** 
 * Calculates the contact overlap score between this StructureInterface and the given one.  The two sides of the given StructureInterface need to match this StructureInterface in the sense that they must come from the same Compound (Entity), i.e. their residue numbers need to align with 100% identity, except for unobserved  density residues.
 * @param other
 * @param invert if false the comparison will be done first-to-first and second-to-second, if true the match will be first-to-second and second-to-first
 * @return the contact overlap score, range [0.0,1.0]
 */
public double getContactOverlapScore(StructureInterface other,boolean invert){
  Structure thisStruct=getParentStructure();
  Structure otherStruct=other.getParentStructure();
  if (thisStruct != otherStruct) {
    logger.warn(""String_Node_Str"");
    return 0;
  }
  Pair<Chain> thisChains=getParentChains();
  Pair<Chain> otherChains=other.getParentChains();
  if (thisChains.getFirst().getCompound() == null || thisChains.getSecond().getCompound() == null || otherChains.getFirst().getCompound() == null || otherChains.getSecond().getCompound() == null) {
    logger.warn(""String_Node_Str"",this.getId(),other.getId());
    return 0;
  }
  Pair<Compound> thisCompounds=new Pair<Compound>(thisChains.getFirst().getCompound(),thisChains.getSecond().getCompound());
  Pair<Compound> otherCompounds=new Pair<Compound>(otherChains.getFirst().getCompound(),otherChains.getSecond().getCompound());
  if (((thisCompounds.getFirst() == otherCompounds.getFirst()) && (thisCompounds.getSecond() == otherCompounds.getSecond())) || ((thisCompounds.getFirst() == otherCompounds.getSecond()) && (thisCompounds.getSecond() == otherCompounds.getFirst()))) {
    int common=0;
    GroupContactSet thisContacts=getGroupContacts();
    GroupContactSet otherContacts=other.getGroupContacts();
    for (    GroupContact thisContact : thisContacts) {
      ResidueIdentifier first=null;
      ResidueIdentifier second=null;
      if (!invert) {
        first=new ResidueIdentifier(thisContact.getPair().getFirst().getResidueNumber().getSeqNum(),thisContact.getPair().getFirst().getResidueNumber().getInsCode());
        second=new ResidueIdentifier(thisContact.getPair().getSecond().getResidueNumber().getSeqNum(),thisContact.getPair().getSecond().getResidueNumber().getInsCode());
      }
 else {
        first=new ResidueIdentifier(thisContact.getPair().getSecond().getResidueNumber().getSeqNum(),thisContact.getPair().getSecond().getResidueNumber().getInsCode());
        second=new ResidueIdentifier(thisContact.getPair().getFirst().getResidueNumber().getSeqNum(),thisContact.getPair().getFirst().getResidueNumber().getInsCode());
      }
      if (otherContacts.hasContact(first,second)) {
        common++;
      }
    }
    return (2.0 * common) / (thisContacts.size() + otherContacts.size());
  }
 else {
    logger.debug(""String_Node_Str"",thisChains.getFirst().getChainID(),thisChains.getSecond().getChainID(),otherChains.getFirst().getChainID(),otherChains.getSecond().getChainID());
    return 0.0;
  }
}",0.9523809523809524
16809,"private void pdb_MODEL_Handler(String line){
  if (current_chain != null) {
    if (current_group != null) {
      current_chain.addGroup(current_group);
      current_group.trimToSize();
    }
    Chain ch=isKnownChain(current_chain.getChainID(),current_model);
    if (ch == null) {
      current_model.add(current_chain);
    }
    structure.addModel(current_model);
    current_model=new ArrayList<Chain>();
    current_chain=null;
    current_group=null;
  }
}","private void pdb_MODEL_Handler(String line){
  if (current_chain != null) {
    if (current_group != null) {
      current_chain.addGroup(current_group);
      current_group.trimToSize();
    }
    Chain ch=isKnownChain(current_chain.getChainID(),current_model);
    if (ch == null) {
      current_model.add(current_chain);
    }
    Iterator<Chain> it=current_model.iterator();
    while (it.hasNext()) {
      Chain c=it.next();
      if (StructureTools.isChainWaterOnly(c)) {
        logger.warn(""String_Node_Str"",c.getChainID(),c.getAtomGroups().size());
        it.remove();
      }
    }
    structure.addModel(current_model);
    current_model=new ArrayList<Chain>();
    current_chain=null;
    current_group=null;
  }
}",0.7788944723618091
16810,"private void triggerEndFileChecks(){
  Date modDate=pdbHeader.getModDate();
  if (modDate.equals(new Date(0))) {
    Date depositionDate=pdbHeader.getDepDate();
    if (!depositionDate.equals(modDate)) {
      pdbHeader.setDepDate(depositionDate);
    }
  }
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
  if (!journalLines.isEmpty()) {
    buildjournalArticle();
    pdbHeader.setJournalArticle(journalArticle);
  }
  structure.addModel(current_model);
  structure.setPDBHeader(pdbHeader);
  structure.setCrystallographicInfo(crystallographicInfo);
  structure.setConnections(connects);
  structure.setDBRefs(dbrefs);
  if (params.isAlignSeqRes()) {
    logger.debug(""String_Node_Str"");
    SeqRes2AtomAligner aligner=new SeqRes2AtomAligner();
    aligner.align(structure,seqResChains);
  }
 else   if (params.getStoreEmptySeqRes()) {
    logger.debug(""String_Node_Str"");
    storeUnAlignedSeqRes(structure,seqResChains);
  }
  linkChains2Compound(structure);
  structure.setCompounds(compounds);
  linkSitesToGroups();
  if (bioAssemblyParser != null) {
    pdbHeader.setBioAssemblies(bioAssemblyParser.getTransformationMap());
  }
  if (ncsOperators != null && ncsOperators.size() > 0) {
    crystallographicInfo.setNcsOperators(ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
  if (rfreeNoCutoffLine > 0 && rfreeStandardLine < 0) {
    pdbHeader.setRfree(rfreeNoCutoffLine);
  }
 else   if (rfreeNoCutoffLine > 0 && rfreeStandardLine > 0) {
    pdbHeader.setRfree(rfreeStandardLine);
  }
 else   if (rfreeNoCutoffLine < 0 && rfreeStandardLine > 0) {
    pdbHeader.setRfree(rfreeStandardLine);
  }
  structure.getCompounds();
}","private void triggerEndFileChecks(){
  Date modDate=pdbHeader.getModDate();
  if (modDate.equals(new Date(0))) {
    Date depositionDate=pdbHeader.getDepDate();
    if (!depositionDate.equals(modDate)) {
      pdbHeader.setDepDate(depositionDate);
    }
  }
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
  if (!journalLines.isEmpty()) {
    buildjournalArticle();
    pdbHeader.setJournalArticle(journalArticle);
  }
  Iterator<Chain> it=current_model.iterator();
  while (it.hasNext()) {
    Chain c=it.next();
    if (StructureTools.isChainWaterOnly(c)) {
      logger.warn(""String_Node_Str"",c.getChainID(),c.getAtomGroups().size());
      it.remove();
    }
  }
  structure.addModel(current_model);
  structure.setPDBHeader(pdbHeader);
  structure.setCrystallographicInfo(crystallographicInfo);
  structure.setConnections(connects);
  structure.setDBRefs(dbrefs);
  if (params.isAlignSeqRes()) {
    logger.debug(""String_Node_Str"");
    SeqRes2AtomAligner aligner=new SeqRes2AtomAligner();
    aligner.align(structure,seqResChains);
  }
 else   if (params.getStoreEmptySeqRes()) {
    logger.debug(""String_Node_Str"");
    storeUnAlignedSeqRes(structure,seqResChains);
  }
  linkChains2Compound(structure);
  structure.setCompounds(compounds);
  linkSitesToGroups();
  if (bioAssemblyParser != null) {
    pdbHeader.setBioAssemblies(bioAssemblyParser.getTransformationMap());
  }
  if (ncsOperators != null && ncsOperators.size() > 0) {
    crystallographicInfo.setNcsOperators(ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
  if (rfreeNoCutoffLine > 0 && rfreeStandardLine < 0) {
    pdbHeader.setRfree(rfreeNoCutoffLine);
  }
 else   if (rfreeNoCutoffLine > 0 && rfreeStandardLine > 0) {
    pdbHeader.setRfree(rfreeStandardLine);
  }
 else   if (rfreeNoCutoffLine < 0 && rfreeStandardLine > 0) {
    pdbHeader.setRfree(rfreeStandardLine);
  }
  structure.getCompounds();
}",0.9354166666666668
16811,"@Override public void documentEnd(){
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  structure.addModel(current_model);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    asymId2entityId.put(asym.getId(),asym.getEntity_id());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setChainID(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    int eId=0;
    try {
      eId=Integer.parseInt(asym.getEntity_id());
    }
 catch (    NumberFormatException e) {
      logger.warn(""String_Node_Str"",asym.getEntity_id());
    }
    Entity e=getEntity(eId);
    for (    EntitySrcGen esg : entitySrcGens) {
      if (!esg.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESG(esg,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcNat esn : entitySrcNats) {
      if (!esn.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESN(esn,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcSyn ess : entitySrcSyns) {
      if (!ess.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESS(ess,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    Compound c=structure.getCompoundById(eId);
    if (c == null) {
      c=new Compound();
      c.setMolId(eId);
      if (e != null && e.getType().equals(""String_Node_Str"")) {
        c.setMolName(e.getPdbx_description());
        structure.addCompound(c);
        logger.debug(""String_Node_Str"",eId,c.getMolName());
      }
    }
  }
  if (params.isAlignSeqRes()) {
    List<Chain> atomList=structure.getModel(0);
    for (    Chain seqResChain : seqResChains) {
      Chain atomChain=SeqRes2AtomAligner.getMatchingAtomRes(seqResChain,atomList);
      List<Group> seqResGroups=seqResChain.getAtomGroups();
      for (int seqResPos=0; seqResPos < seqResGroups.size(); seqResPos++) {
        Group seqresG=seqResGroups.get(seqResPos);
        boolean found=false;
        for (        Group atomG : atomChain.getAtomGroups()) {
          int internalNr=getInternalNr(atomG);
          if (seqresG.getResidueNumber().getSeqNum() == internalNr) {
            seqResGroups.set(seqResPos,atomG);
            found=true;
            break;
          }
        }
        if (!found)         seqresG.setResidueNumber(null);
      }
      atomChain.setSeqResGroups(seqResGroups);
    }
  }
  if (params.shouldCreateAtomBonds())   addBonds();
  Set<String> asymIds=asymStrandId.keySet();
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> model=structure.getModel(i);
    List<Chain> pdbChains=new ArrayList<Chain>();
    for (    Chain chain : model) {
      for (      String asym : asymIds) {
        if (chain.getChainID().equals(asym)) {
          String newChainId=asymStrandId.get(asym);
          logger.debug(""String_Node_Str"",asym,chain.getAtomGroups().size(),newChainId);
          chain.setChainID(newChainId);
          chain.setInternalChainID(asym);
          for (          Group g : chain.getAtomGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          for (          Group g : chain.getSeqResGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          Chain known=isKnownChain(chain.getChainID(),pdbChains);
          if (known == null) {
            pdbChains.add(chain);
          }
 else {
            for (            Group g : chain.getAtomGroups()) {
              known.addGroup(g);
            }
          }
          break;
        }
      }
    }
    structure.setModel(i,pdbChains);
    for (    Chain chain : pdbChains) {
      String entityId=asymId2entityId.get(chain.getInternalChainID());
      int eId=Integer.parseInt(entityId);
      Compound compound=structure.getCompoundById(eId);
      if (compound == null) {
        logger.warn(""String_Node_Str"",eId,chain.getChainID(),chain.getInternalChainID());
      }
 else {
        logger.debug(""String_Node_Str"",chain.getChainID(),chain.getInternalChainID(),eId);
        compound.addChain(chain);
        chain.setCompound(compound);
      }
    }
  }
  List<Compound> compounds=structure.getCompounds();
  for (  Compound compound : compounds) {
    if (compound.getChains().isEmpty()) {
      logger.info(""String_Node_Str"",compound.getId() == null ? ""String_Node_Str"" : compound.getId(),compound.getMolName());
    }
  }
  if (params.isParseBioAssembly()) {
    Map<Integer,BioAssemblyInfo> bioAssemblies=new HashMap<Integer,BioAssemblyInfo>();
    for (    PdbxStructAssembly psa : strucAssemblies) {
      List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
      for (      PdbxStructAssemblyGen psag : strucAssemblyGens) {
        if (psag.getAssembly_id().equals(psa.getId())) {
          psags.add(psag);
        }
      }
      BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
      List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
      boolean validBioAssembly=true;
      int mmSize=0;
      int bioAssemblyId=0;
      try {
        mmSize=Integer.parseInt(psa.getOligomeric_count());
      }
 catch (      NumberFormatException e) {
        logger.info(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
        validBioAssembly=false;
      }
      try {
        bioAssemblyId=Integer.parseInt(psa.getId());
      }
 catch (      NumberFormatException e) {
        logger.info(""String_Node_Str"",psa.getId());
        validBioAssembly=false;
      }
      if (validBioAssembly) {
        BioAssemblyInfo bioAssembly=new BioAssemblyInfo();
        bioAssembly.setId(bioAssemblyId);
        bioAssembly.setMacromolecularSize(mmSize);
        bioAssembly.setTransforms(transformations);
        bioAssemblies.put(bioAssemblyId,bioAssembly);
      }
    }
    structure.getPDBHeader().setBioAssemblies(bioAssemblies);
  }
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators(ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
}","@Override public void documentEnd(){
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  structure.addModel(current_model);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    asymId2entityId.put(asym.getId(),asym.getEntity_id());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setChainID(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    int eId=0;
    try {
      eId=Integer.parseInt(asym.getEntity_id());
    }
 catch (    NumberFormatException e) {
      logger.warn(""String_Node_Str"",asym.getEntity_id());
    }
    Entity e=getEntity(eId);
    for (    EntitySrcGen esg : entitySrcGens) {
      if (!esg.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESG(esg,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcNat esn : entitySrcNats) {
      if (!esn.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESN(esn,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcSyn ess : entitySrcSyns) {
      if (!ess.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESS(ess,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    Compound c=structure.getCompoundById(eId);
    if (c == null) {
      c=new Compound();
      c.setMolId(eId);
      if (e != null && e.getType().equals(""String_Node_Str"")) {
        c.setMolName(e.getPdbx_description());
        structure.addCompound(c);
        logger.debug(""String_Node_Str"",eId,c.getMolName());
      }
    }
  }
  if (params.isAlignSeqRes()) {
    List<Chain> atomList=structure.getModel(0);
    for (    Chain seqResChain : seqResChains) {
      Chain atomChain=SeqRes2AtomAligner.getMatchingAtomRes(seqResChain,atomList);
      List<Group> seqResGroups=seqResChain.getAtomGroups();
      for (int seqResPos=0; seqResPos < seqResGroups.size(); seqResPos++) {
        Group seqresG=seqResGroups.get(seqResPos);
        boolean found=false;
        for (        Group atomG : atomChain.getAtomGroups()) {
          int internalNr=getInternalNr(atomG);
          if (seqresG.getResidueNumber().getSeqNum() == internalNr) {
            seqResGroups.set(seqResPos,atomG);
            found=true;
            break;
          }
        }
        if (!found)         seqresG.setResidueNumber(null);
      }
      atomChain.setSeqResGroups(seqResGroups);
    }
  }
  if (params.shouldCreateAtomBonds())   addBonds();
  Set<String> asymIds=asymStrandId.keySet();
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> model=structure.getModel(i);
    List<Chain> pdbChains=new ArrayList<Chain>();
    for (    Chain chain : model) {
      for (      String asym : asymIds) {
        if (chain.getChainID().equals(asym)) {
          String newChainId=asymStrandId.get(asym);
          logger.debug(""String_Node_Str"",asym,chain.getAtomGroups().size(),newChainId);
          chain.setChainID(newChainId);
          chain.setInternalChainID(asym);
          for (          Group g : chain.getAtomGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          for (          Group g : chain.getSeqResGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          Chain known=isKnownChain(chain.getChainID(),pdbChains);
          if (known == null) {
            pdbChains.add(chain);
          }
 else {
            for (            Group g : chain.getAtomGroups()) {
              known.addGroup(g);
            }
          }
          break;
        }
      }
    }
    Iterator<Chain> it=pdbChains.iterator();
    while (it.hasNext()) {
      Chain c=it.next();
      if (StructureTools.isChainWaterOnly(c)) {
        logger.warn(""String_Node_Str"",c.getChainID(),c.getInternalChainID(),c.getAtomGroups().size());
        it.remove();
      }
    }
    structure.setModel(i,pdbChains);
    for (    Chain chain : pdbChains) {
      String entityId=asymId2entityId.get(chain.getInternalChainID());
      int eId=Integer.parseInt(entityId);
      Compound compound=structure.getCompoundById(eId);
      if (compound == null) {
        logger.warn(""String_Node_Str"",eId,chain.getChainID(),chain.getInternalChainID());
      }
 else {
        logger.debug(""String_Node_Str"",chain.getChainID(),chain.getInternalChainID(),eId);
        compound.addChain(chain);
        chain.setCompound(compound);
      }
    }
  }
  List<Compound> compounds=structure.getCompounds();
  for (  Compound compound : compounds) {
    if (compound.getChains().isEmpty()) {
      logger.info(""String_Node_Str"",compound.getId() == null ? ""String_Node_Str"" : compound.getId(),compound.getMolName());
    }
  }
  if (params.isParseBioAssembly()) {
    Map<Integer,BioAssemblyInfo> bioAssemblies=new HashMap<Integer,BioAssemblyInfo>();
    for (    PdbxStructAssembly psa : strucAssemblies) {
      List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
      for (      PdbxStructAssemblyGen psag : strucAssemblyGens) {
        if (psag.getAssembly_id().equals(psa.getId())) {
          psags.add(psag);
        }
      }
      BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
      List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
      boolean validBioAssembly=true;
      int mmSize=0;
      int bioAssemblyId=0;
      try {
        mmSize=Integer.parseInt(psa.getOligomeric_count());
      }
 catch (      NumberFormatException e) {
        logger.info(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
        validBioAssembly=false;
      }
      try {
        bioAssemblyId=Integer.parseInt(psa.getId());
      }
 catch (      NumberFormatException e) {
        logger.info(""String_Node_Str"",psa.getId());
        validBioAssembly=false;
      }
      if (validBioAssembly) {
        BioAssemblyInfo bioAssembly=new BioAssemblyInfo();
        bioAssembly.setId(bioAssemblyId);
        bioAssembly.setMacromolecularSize(mmSize);
        bioAssembly.setTransforms(transformations);
        bioAssemblies.put(bioAssemblyId,bioAssembly);
      }
    }
    structure.getPDBHeader().setBioAssemblies(bioAssemblies);
  }
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators(ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
}",0.9818787219056156
16812,"public static Chain getMatchingAtomRes(Chain seqRes,List<Chain> atomList){
  Iterator<Chain> iter=atomList.iterator();
  while (iter.hasNext()) {
    Chain atomChain=iter.next();
    if (atomChain.getChainID().equals(seqRes.getChainID())) {
      return atomChain;
    }
  }
  logger.debug(""String_Node_Str"" + seqRes.getChainID() + ""String_Node_Str""+ atomList.size());
  return null;
}","public static Chain getMatchingAtomRes(Chain seqRes,List<Chain> atomList){
  Iterator<Chain> iter=atomList.iterator();
  while (iter.hasNext()) {
    Chain atomChain=iter.next();
    if (atomChain.getChainID().equals(seqRes.getChainID())) {
      return atomChain;
    }
  }
  logger.info(""String_Node_Str"" + seqRes.getChainID() + ""String_Node_Str""+ atomList.size());
  return null;
}",0.988296488946684
16813,"@Override public void documentEnd(){
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  structure.addModel(current_model);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    asymId2entityId.put(asym.getId(),asym.getEntity_id());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setChainID(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    int eId=0;
    try {
      eId=Integer.parseInt(asym.getEntity_id());
    }
 catch (    NumberFormatException e) {
      logger.warn(""String_Node_Str"",asym.getEntity_id());
    }
    Entity e=getEntity(eId);
    for (    EntitySrcGen esg : entitySrcGens) {
      if (!esg.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESG(esg,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcNat esn : entitySrcNats) {
      if (!esn.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESN(esn,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcSyn ess : entitySrcSyns) {
      if (!ess.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESS(ess,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    Compound c=structure.getCompoundById(eId);
    if (c == null) {
      c=new Compound();
      c.setMolId(eId);
      if (e != null && e.getType().equals(""String_Node_Str"")) {
        c.setMolName(e.getPdbx_description());
        structure.addCompound(c);
        logger.debug(""String_Node_Str"",eId,c.getMolName());
      }
    }
  }
  if (params.isAlignSeqRes()) {
    List<Chain> atomList=structure.getModel(0);
    for (    Chain seqResChain : seqResChains) {
      Chain atomChain=SeqRes2AtomAligner.getMatchingAtomRes(seqResChain,atomList);
      List<Group> seqResGroups=seqResChain.getAtomGroups();
      for (int seqResPos=0; seqResPos < seqResGroups.size(); seqResPos++) {
        Group seqresG=seqResGroups.get(seqResPos);
        boolean found=false;
        for (        Group atomG : atomChain.getAtomGroups()) {
          int internalNr=getInternalNr(atomG);
          if (seqresG.getResidueNumber().getSeqNum() == internalNr) {
            seqResGroups.set(seqResPos,atomG);
            found=true;
            break;
          }
        }
        if (!found)         seqresG.setResidueNumber(null);
      }
      atomChain.setSeqResGroups(seqResGroups);
    }
  }
  if (params.shouldCreateAtomBonds())   addBonds();
  Set<String> asymIds=asymStrandId.keySet();
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> model=structure.getModel(i);
    List<Chain> pdbChains=new ArrayList<Chain>();
    for (    Chain chain : model) {
      for (      String asym : asymIds) {
        if (chain.getChainID().equals(asym)) {
          String newChainId=asymStrandId.get(asym);
          logger.debug(""String_Node_Str"",asym,chain.getAtomGroups().size(),newChainId);
          chain.setChainID(newChainId);
          chain.setInternalChainID(asym);
          for (          Group g : chain.getAtomGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          for (          Group g : chain.getSeqResGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          Chain known=isKnownChain(chain.getChainID(),pdbChains);
          if (known == null) {
            pdbChains.add(chain);
          }
 else {
            for (            Group g : chain.getAtomGroups()) {
              known.addGroup(g);
            }
          }
          break;
        }
      }
    }
    Iterator<Chain> it=pdbChains.iterator();
    while (it.hasNext()) {
      Chain c=it.next();
      if (StructureTools.isChainWaterOnly(c)) {
        logger.warn(""String_Node_Str"",c.getChainID(),c.getInternalChainID(),c.getAtomGroups().size());
        it.remove();
      }
    }
    structure.setModel(i,pdbChains);
    for (    Chain chain : pdbChains) {
      String entityId=asymId2entityId.get(chain.getInternalChainID());
      int eId=Integer.parseInt(entityId);
      Compound compound=structure.getCompoundById(eId);
      if (compound == null) {
        logger.warn(""String_Node_Str"",eId,chain.getChainID(),chain.getInternalChainID());
      }
 else {
        logger.debug(""String_Node_Str"",chain.getChainID(),chain.getInternalChainID(),eId);
        compound.addChain(chain);
        chain.setCompound(compound);
      }
    }
  }
  List<Compound> compounds=structure.getCompounds();
  for (  Compound compound : compounds) {
    if (compound.getChains().isEmpty()) {
      logger.info(""String_Node_Str"",compound.getId() == null ? ""String_Node_Str"" : compound.getId(),compound.getMolName());
    }
  }
  if (params.isParseBioAssembly()) {
    Map<Integer,BioAssemblyInfo> bioAssemblies=new HashMap<Integer,BioAssemblyInfo>();
    for (    PdbxStructAssembly psa : strucAssemblies) {
      List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
      for (      PdbxStructAssemblyGen psag : strucAssemblyGens) {
        if (psag.getAssembly_id().equals(psa.getId())) {
          psags.add(psag);
        }
      }
      BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
      List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
      int mmSize=0;
      int bioAssemblyId=-1;
      try {
        bioAssemblyId=Integer.parseInt(psa.getId());
      }
 catch (      NumberFormatException e) {
        logger.info(""String_Node_Str"",psa.getId());
      }
      try {
        mmSize=Integer.parseInt(psa.getOligomeric_count());
      }
 catch (      NumberFormatException e) {
        if (bioAssemblyId != -1)         logger.warn(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
 else         logger.info(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
      }
      if (bioAssemblyId != -1) {
        BioAssemblyInfo bioAssembly=new BioAssemblyInfo();
        bioAssembly.setId(bioAssemblyId);
        bioAssembly.setMacromolecularSize(mmSize);
        bioAssembly.setTransforms(transformations);
        bioAssemblies.put(bioAssemblyId,bioAssembly);
      }
    }
    structure.getPDBHeader().setBioAssemblies(bioAssemblies);
  }
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators(ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
}","@Override public void documentEnd(){
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  structure.addModel(current_model);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    asymId2entityId.put(asym.getId(),asym.getEntity_id());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setChainID(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    int eId=0;
    try {
      eId=Integer.parseInt(asym.getEntity_id());
    }
 catch (    NumberFormatException e) {
      logger.warn(""String_Node_Str"",asym.getEntity_id());
    }
    Entity e=getEntity(eId);
    for (    EntitySrcGen esg : entitySrcGens) {
      if (!esg.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESG(esg,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcNat esn : entitySrcNats) {
      if (!esn.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESN(esn,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcSyn ess : entitySrcSyns) {
      if (!ess.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESS(ess,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    Compound c=structure.getCompoundById(eId);
    if (c == null) {
      c=new Compound();
      c.setMolId(eId);
      if (e != null && e.getType().equals(""String_Node_Str"")) {
        c.setMolName(e.getPdbx_description());
        structure.addCompound(c);
        logger.debug(""String_Node_Str"",eId,c.getMolName());
      }
    }
  }
  if (params.isAlignSeqRes()) {
    List<Chain> atomList=structure.getModel(0);
    for (    Chain seqResChain : seqResChains) {
      Chain atomChain=SeqRes2AtomAligner.getMatchingAtomRes(seqResChain,atomList);
      if (atomChain == null) {
        logger.warn(""String_Node_Str"",seqResChain.getChainID());
        continue;
      }
      List<Group> seqResGroups=seqResChain.getAtomGroups();
      for (int seqResPos=0; seqResPos < seqResGroups.size(); seqResPos++) {
        Group seqresG=seqResGroups.get(seqResPos);
        boolean found=false;
        for (        Group atomG : atomChain.getAtomGroups()) {
          int internalNr=getInternalNr(atomG);
          if (seqresG.getResidueNumber().getSeqNum() == internalNr) {
            seqResGroups.set(seqResPos,atomG);
            found=true;
            break;
          }
        }
        if (!found)         seqresG.setResidueNumber(null);
      }
      atomChain.setSeqResGroups(seqResGroups);
    }
  }
  if (params.shouldCreateAtomBonds())   addBonds();
  Set<String> asymIds=asymStrandId.keySet();
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> model=structure.getModel(i);
    List<Chain> pdbChains=new ArrayList<Chain>();
    for (    Chain chain : model) {
      for (      String asym : asymIds) {
        if (chain.getChainID().equals(asym)) {
          String newChainId=asymStrandId.get(asym);
          logger.debug(""String_Node_Str"",asym,chain.getAtomGroups().size(),newChainId);
          chain.setChainID(newChainId);
          chain.setInternalChainID(asym);
          for (          Group g : chain.getAtomGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          for (          Group g : chain.getSeqResGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          Chain known=isKnownChain(chain.getChainID(),pdbChains);
          if (known == null) {
            pdbChains.add(chain);
          }
 else {
            for (            Group g : chain.getAtomGroups()) {
              known.addGroup(g);
            }
          }
          break;
        }
      }
    }
    Iterator<Chain> it=pdbChains.iterator();
    while (it.hasNext()) {
      Chain c=it.next();
      if (StructureTools.isChainWaterOnly(c)) {
        logger.warn(""String_Node_Str"",c.getChainID(),c.getInternalChainID(),c.getAtomGroups().size());
        it.remove();
      }
    }
    structure.setModel(i,pdbChains);
    for (    Chain chain : pdbChains) {
      String entityId=asymId2entityId.get(chain.getInternalChainID());
      int eId=Integer.parseInt(entityId);
      Compound compound=structure.getCompoundById(eId);
      if (compound == null) {
        logger.warn(""String_Node_Str"",eId,chain.getChainID(),chain.getInternalChainID());
      }
 else {
        logger.debug(""String_Node_Str"",chain.getChainID(),chain.getInternalChainID(),eId);
        compound.addChain(chain);
        chain.setCompound(compound);
      }
    }
  }
  List<Compound> compounds=structure.getCompounds();
  for (  Compound compound : compounds) {
    if (compound.getChains().isEmpty()) {
      logger.info(""String_Node_Str"",compound.getId() == null ? ""String_Node_Str"" : compound.getId(),compound.getMolName());
    }
  }
  if (params.isParseBioAssembly()) {
    Map<Integer,BioAssemblyInfo> bioAssemblies=new HashMap<Integer,BioAssemblyInfo>();
    for (    PdbxStructAssembly psa : strucAssemblies) {
      List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
      for (      PdbxStructAssemblyGen psag : strucAssemblyGens) {
        if (psag.getAssembly_id().equals(psa.getId())) {
          psags.add(psag);
        }
      }
      BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
      List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
      int mmSize=0;
      int bioAssemblyId=-1;
      try {
        bioAssemblyId=Integer.parseInt(psa.getId());
      }
 catch (      NumberFormatException e) {
        logger.info(""String_Node_Str"",psa.getId());
      }
      try {
        mmSize=Integer.parseInt(psa.getOligomeric_count());
      }
 catch (      NumberFormatException e) {
        if (bioAssemblyId != -1)         logger.warn(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
 else         logger.info(""String_Node_Str"",psa.getOligomeric_count(),psa.getId());
      }
      if (bioAssemblyId != -1) {
        BioAssemblyInfo bioAssembly=new BioAssemblyInfo();
        bioAssembly.setId(bioAssemblyId);
        bioAssembly.setMacromolecularSize(mmSize);
        bioAssembly.setTransforms(transformations);
        bioAssemblies.put(bioAssemblyId,bioAssembly);
      }
    }
    structure.getPDBHeader().setBioAssemblies(bioAssemblies);
  }
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators(ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
}",0.9924044328228117
16814,"private void testSingleChain(Chain cPdb,Chain cCif){
  assertNotNull(cPdb);
  assertNotNull(cCif);
  String chainId=cPdb.getChainID();
  assertEquals(""String_Node_Str"",cPdb.getChainID(),cCif.getChainID());
  assertNotNull(""String_Node_Str"",cCif.getInternalChainID());
  assertTrue(""String_Node_Str"",cCif.getInternalChainID().length() <= 4);
  assertEquals(""String_Node_Str"",1,cPdb.getChainID().length());
  assertEquals(""String_Node_Str"",1,cCif.getChainID().length());
  if (isPolymer(cPdb)) {
    assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getCompound());
    assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cCif.getCompound());
    int molIdPdb=cPdb.getCompound().getMolId();
    int molIdCif=cCif.getCompound().getMolId();
    if (molIdPdb != molIdCif) {
      logger.warn(""String_Node_Str"",pdbId,molIdPdb,molIdCif);
      pdbIdsWithMismatchingMolIds.add(pdbId);
    }
  }
  assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getParent());
  assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cCif.getParent());
  assertEquals(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getAtomLength(),cCif.getAtomLength());
  assertEquals(""String_Node_Str"",cPdb.getSeqResLength(),cCif.getSeqResLength());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups().size(),cCif.getSeqResGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResLength(),cPdb.getSeqResGroups().size());
  assertEquals(""String_Node_Str"",cCif.getSeqResLength(),cCif.getSeqResGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getAtomLength(),cCif.getAtomLength());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups().size(),cCif.getAtomGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getAtomLength(),cPdb.getAtomGroups().size());
  assertEquals(""String_Node_Str"",cCif.getAtomLength(),cCif.getAtomGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups(GroupType.AMINOACID).size(),cCif.getAtomGroups(GroupType.AMINOACID).size());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups(GroupType.HETATM).size(),cCif.getAtomGroups(GroupType.HETATM).size());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups(GroupType.NUCLEOTIDE).size(),cCif.getAtomGroups(GroupType.NUCLEOTIDE).size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups(GroupType.AMINOACID).size(),cCif.getSeqResGroups(GroupType.AMINOACID).size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups(GroupType.HETATM).size(),cCif.getSeqResGroups(GroupType.HETATM).size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups(GroupType.NUCLEOTIDE).size(),cCif.getSeqResGroups(GroupType.NUCLEOTIDE).size());
  assertTrue(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getAtomLength() >= 1);
  if (isPolymer(cPdb)) {
    assertTrue(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getSeqResLength() >= 1);
  }
  int allAtomGroupsSizePdb=cPdb.getAtomGroups(GroupType.AMINOACID).size() + cPdb.getAtomGroups(GroupType.HETATM).size() + cPdb.getAtomGroups(GroupType.NUCLEOTIDE).size();
  int allAtomGroupsSizeCif=cCif.getAtomGroups(GroupType.AMINOACID).size() + cCif.getAtomGroups(GroupType.HETATM).size() + cCif.getAtomGroups(GroupType.NUCLEOTIDE).size();
  assertEquals(""String_Node_Str"",allAtomGroupsSizePdb,allAtomGroupsSizeCif);
  assertEquals(""String_Node_Str"",cPdb.getAtomLength(),allAtomGroupsSizePdb);
  int allSeqResGroupsSizePdb=cPdb.getSeqResGroups(GroupType.AMINOACID).size() + cPdb.getSeqResGroups(GroupType.HETATM).size() + cPdb.getSeqResGroups(GroupType.NUCLEOTIDE).size();
  int allSeqResGroupsSizeCif=cCif.getSeqResGroups(GroupType.AMINOACID).size() + cCif.getSeqResGroups(GroupType.HETATM).size() + cCif.getSeqResGroups(GroupType.NUCLEOTIDE).size();
  assertEquals(""String_Node_Str"",allSeqResGroupsSizePdb,allSeqResGroupsSizeCif);
  assertEquals(""String_Node_Str"",cPdb.getSeqResLength(),allSeqResGroupsSizePdb);
}","private void testSingleChain(Chain cPdb,Chain cCif){
  assertNotNull(cPdb);
  assertNotNull(cCif);
  String chainId=cPdb.getChainID();
  assertEquals(""String_Node_Str"",cPdb.getChainID(),cCif.getChainID());
  assertNotNull(""String_Node_Str"",cCif.getInternalChainID());
  assertTrue(""String_Node_Str"",cCif.getInternalChainID().length() <= 4);
  assertEquals(""String_Node_Str"",1,cPdb.getChainID().length());
  assertEquals(""String_Node_Str"",1,cCif.getChainID().length());
  if (isPolymer(cPdb)) {
    assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getCompound());
    assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cCif.getCompound());
    int molIdPdb=cPdb.getCompound().getMolId();
    int molIdCif=cCif.getCompound().getMolId();
    if (molIdPdb != molIdCif) {
      logger.warn(""String_Node_Str"",pdbId,molIdPdb,molIdCif);
      pdbIdsWithMismatchingMolIds.add(pdbId);
    }
  }
  assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getParent());
  assertNotNull(""String_Node_Str"" + chainId + ""String_Node_Str"",cCif.getParent());
  assertEquals(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getAtomLength(),cCif.getAtomLength());
  assertEquals(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getSeqResLength(),cCif.getSeqResLength());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups().size(),cCif.getSeqResGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResLength(),cPdb.getSeqResGroups().size());
  assertEquals(""String_Node_Str"",cCif.getSeqResLength(),cCif.getSeqResGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getAtomLength(),cCif.getAtomLength());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups().size(),cCif.getAtomGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getAtomLength(),cPdb.getAtomGroups().size());
  assertEquals(""String_Node_Str"",cCif.getAtomLength(),cCif.getAtomGroups().size());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups(GroupType.AMINOACID).size(),cCif.getAtomGroups(GroupType.AMINOACID).size());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups(GroupType.HETATM).size(),cCif.getAtomGroups(GroupType.HETATM).size());
  assertEquals(""String_Node_Str"",cPdb.getAtomGroups(GroupType.NUCLEOTIDE).size(),cCif.getAtomGroups(GroupType.NUCLEOTIDE).size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups(GroupType.AMINOACID).size(),cCif.getSeqResGroups(GroupType.AMINOACID).size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups(GroupType.HETATM).size(),cCif.getSeqResGroups(GroupType.HETATM).size());
  assertEquals(""String_Node_Str"",cPdb.getSeqResGroups(GroupType.NUCLEOTIDE).size(),cCif.getSeqResGroups(GroupType.NUCLEOTIDE).size());
  assertTrue(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getAtomLength() >= 1);
  if (isPolymer(cPdb)) {
    assertTrue(""String_Node_Str"" + chainId + ""String_Node_Str"",cPdb.getSeqResLength() >= 1);
  }
  int allAtomGroupsSizePdb=cPdb.getAtomGroups(GroupType.AMINOACID).size() + cPdb.getAtomGroups(GroupType.HETATM).size() + cPdb.getAtomGroups(GroupType.NUCLEOTIDE).size();
  int allAtomGroupsSizeCif=cCif.getAtomGroups(GroupType.AMINOACID).size() + cCif.getAtomGroups(GroupType.HETATM).size() + cCif.getAtomGroups(GroupType.NUCLEOTIDE).size();
  assertEquals(""String_Node_Str"",allAtomGroupsSizePdb,allAtomGroupsSizeCif);
  assertEquals(""String_Node_Str"",cPdb.getAtomLength(),allAtomGroupsSizePdb);
  int allSeqResGroupsSizePdb=cPdb.getSeqResGroups(GroupType.AMINOACID).size() + cPdb.getSeqResGroups(GroupType.HETATM).size() + cPdb.getSeqResGroups(GroupType.NUCLEOTIDE).size();
  int allSeqResGroupsSizeCif=cCif.getSeqResGroups(GroupType.AMINOACID).size() + cCif.getSeqResGroups(GroupType.HETATM).size() + cCif.getSeqResGroups(GroupType.NUCLEOTIDE).size();
  assertEquals(""String_Node_Str"",allSeqResGroupsSizePdb,allSeqResGroupsSizeCif);
  assertEquals(""String_Node_Str"",cPdb.getSeqResLength(),allSeqResGroupsSizePdb);
}",0.9961498973305954
16815,"@Override public void newRefine(Refine r){
  PDBHeader pdbHeader=structure.getPDBHeader();
  if (pdbHeader.getResolution() != PDBHeader.DEFAULT_RESOLUTION) {
    logger.warn(""String_Node_Str"",r.getLs_d_res_high(),String.format(""String_Node_Str"",pdbHeader.getResolution()));
  }
  try {
    pdbHeader.setResolution(Float.parseFloat(r.getLs_d_res_high()));
  }
 catch (  NumberFormatException e) {
    logger.info(""String_Node_Str"" + r.getLs_d_res_high() + ""String_Node_Str""+ e.getMessage());
  }
  if (pdbHeader.getRfree() != PDBHeader.DEFAULT_RFREE) {
    logger.warn(""String_Node_Str"",r.getLs_R_factor_R_free(),String.format(""String_Node_Str"",pdbHeader.getRfree()));
  }
  try {
    pdbHeader.setRfree(Float.parseFloat(r.getLs_R_factor_R_free()));
  }
 catch (  NumberFormatException e) {
    logger.debug(""String_Node_Str"",r.getLs_R_factor_R_free());
  }
}","@Override public void newRefine(Refine r){
  PDBHeader pdbHeader=structure.getPDBHeader();
  if (pdbHeader.getResolution() != PDBHeader.DEFAULT_RESOLUTION) {
    logger.warn(""String_Node_Str"",r.getLs_d_res_high(),String.format(""String_Node_Str"",pdbHeader.getResolution()));
  }
  try {
    pdbHeader.setResolution(Float.parseFloat(r.getLs_d_res_high()));
  }
 catch (  NumberFormatException e) {
    logger.info(""String_Node_Str"" + r.getLs_d_res_high() + ""String_Node_Str""+ e.getMessage());
  }
  if (pdbHeader.getRfree() != PDBHeader.DEFAULT_RFREE) {
    logger.warn(""String_Node_Str"",r.getLs_R_factor_R_free(),String.format(""String_Node_Str"",pdbHeader.getRfree()));
  }
  if (r.getLs_R_factor_R_free() == null) {
    logger.info(""String_Node_Str"");
  }
 else {
    try {
      pdbHeader.setRfree(Float.parseFloat(r.getLs_R_factor_R_free()));
    }
 catch (    NumberFormatException e) {
      logger.debug(""String_Node_Str"",r.getLs_R_factor_R_free());
    }
  }
}",0.9413055403181568
16816,"/** 
 * Get the representative Chain for this Compound. We choose the Chain with the first chain identifier after lexicographical sorting, e.g. chain A if Compound is composed of chains A,B,C,D,E
 * @return
 */
public Chain getRepresentative(){
  String minChainId=""String_Node_Str"";
  Chain firstLexicographicalIdChain=null;
  for (  Chain chain : chains) {
    if (chain.getChainID().compareTo(minChainId) < 0) {
      minChainId=chain.getChainID();
      firstLexicographicalIdChain=chain;
    }
  }
  return firstLexicographicalIdChain;
}","/** 
 * Get the representative Chain for this Compound. We choose the Chain with the first chain identifier after lexicographical sorting (case insensitive),  e.g. chain A if Compound is composed of chains A,B,C,D,E
 * @return
 */
public Chain getRepresentative(){
  List<String> chainIds=new ArrayList<String>();
  for (  Chain chain : chains) {
    chainIds.add(chain.getChainID());
  }
  Collections.sort(chainIds,String.CASE_INSENSITIVE_ORDER);
  for (  Chain chain : chains) {
    if (chain.getChainID().equals(chainIds.get(0))) {
      return chain;
    }
  }
  logger.error(""String_Node_Str"",this.toString());
  return null;
}",0.4697872340425532
16817,"public static int[] setSteps(Last[][][] traceback,int[] xyMax,List<Step> sx,List<Step> sy){
  return setSteps(traceback,true,xyMax,Last.SUBSTITUTION,sx,sy);
}","/** 
 * Find local alignment path through traceback matrix
 * @param traceback
 * @param xyMax
 * @param sx
 * @param sy
 * @return
 */
public static int[] setSteps(Last[][][] traceback,int[] xyMax,List<Step> sx,List<Step> sy){
  return setSteps(traceback,true,xyMax,Last.SUBSTITUTION,sx,sy);
}",0.6991150442477876
16818,"public static Last[][] setScoreVector(int x,int xb,int yb,int ye,int gep,int[] subs,boolean storing,int[][][] scores,int[] xyMax,int score){
  Last[][] pointers;
  ensureScoringMatrixColumn(x,storing,scores);
  if (x == xb) {
    pointers=new Last[ye + 1][1];
  }
 else {
    pointers=new Last[ye + 1][];
    pointers[0]=new Last[1];
    for (int y=1; y < scores[x].length; y++) {
      pointers[y][0]=setScorePoint(x,y,gep,subs[y],scores);
      if (scores[x][y][0] <= 0) {
        scores[x][y][0]=0;
        pointers[y][0]=null;
      }
 else       if (scores[x][y][0] > score) {
        xyMax[0]=x;
        xyMax[1]=y;
        score=scores[x][y][0];
      }
    }
  }
  return pointers;
}","/** 
 * Score local alignment for a given position in the query sequence for a linear gap penalty
 * @param x
 * @param xb
 * @param yb
 * @param ye
 * @param gep
 * @param subs
 * @param storing
 * @param scores
 * @param xyMax
 * @param score
 * @return
 */
public static Last[][] setScoreVector(int x,int xb,int yb,int ye,int gep,int[] subs,boolean storing,int[][][] scores,int[] xyMax,int score){
  Last[][] pointers;
  ensureScoringMatrixColumn(x,storing,scores);
  if (x == xb) {
    pointers=new Last[ye + 1][1];
  }
 else {
    pointers=new Last[ye + 1][];
    pointers[0]=new Last[1];
    for (int y=1; y < scores[x].length; y++) {
      pointers[y][0]=setScorePoint(x,y,gep,subs[y],scores);
      if (scores[x][y][0] <= 0) {
        scores[x][y][0]=0;
        pointers[y][0]=null;
      }
 else       if (scores[x][y][0] > score) {
        xyMax[0]=x;
        xyMax[1]=y;
        score=scores[x][y][0];
      }
    }
  }
  return pointers;
}",0.8416565164433617
16819,"/** 
 * Converts a list of anchors into a subproblem list.
 * @param anchors anchored read pairs
 * @param querySequenceLength length of query sequence
 * @param targetSequenceLength length of target sequence
 * @return list alignment subproblems
 */
public static List<Subproblem> getSubproblems(List<Anchor> anchors,int querySequenceLength,int targetSequenceLength){
  Collections.sort(anchors,new Anchor.QueryIndexComparator());
  List<Subproblem> list=new ArrayList<Subproblem>();
  Anchor last=new Anchor(-1,-1);
  boolean isAnchored=false;
  for (int i=0; i < anchors.size(); i++) {
    if (anchors.get(i).targetIndex <= last.targetIndex || anchors.get(i).queryIndex <= last.queryIndex) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    list.add(new Subproblem(last.queryIndex + 1,last.targetIndex + 1,anchors.get(i).queryIndex,anchors.get(i).targetIndex,isAnchored));
    last=anchors.get(i);
    isAnchored=true;
  }
  list.add(new Subproblem(last.queryIndex + 1,last.targetIndex + 1,querySequenceLength,targetSequenceLength,isAnchored));
  return list;
}","/** 
 * Convert a list of anchors into a subproblem list.
 * @param anchors anchored read pairs
 * @param querySequenceLength length of query sequence
 * @param targetSequenceLength length of target sequence
 * @return list alignment subproblems
 */
public static List<Subproblem> getSubproblems(List<Anchor> anchors,int querySequenceLength,int targetSequenceLength){
  Collections.sort(anchors,new Anchor.QueryIndexComparator());
  List<Subproblem> list=new ArrayList<Subproblem>();
  Anchor last=new Anchor(-1,-1);
  boolean isAnchored=false;
  for (int i=0; i < anchors.size(); i++) {
    if (anchors.get(i).targetIndex <= last.targetIndex || anchors.get(i).queryIndex <= last.queryIndex) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    list.add(new Subproblem(last.queryIndex + 1,last.targetIndex + 1,anchors.get(i).queryIndex,anchors.get(i).targetIndex,isAnchored));
    last=anchors.get(i);
    isAnchored=true;
  }
  list.add(new Subproblem(last.queryIndex + 1,last.targetIndex + 1,querySequenceLength,targetSequenceLength,isAnchored));
  return list;
}",0.9995393827729157
16820,"public FarmJobRunnable(FarmJobParameters params){
  terminated=false;
  this.params=params;
  verbose=false;
  cache=new AtomCache(params.getPdbFilePath(),params.getCacheFilePath());
  if (params.getServer() != null && (!params.getServer().equals(""String_Node_Str""))) {
    RemotePDPProvider pdpprovider=new RemotePDPProvider();
    String serverURL=params.getServer();
    if (!serverURL.endsWith(""String_Node_Str""))     serverURL+=""String_Node_Str"";
    if (serverURL.endsWith(alignURL)) {
      serverURL=serverURL.substring(0,serverURL.length() - alignURL.length());
    }
    pdpprovider.setServer(serverURL + ""String_Node_Str"");
    cache.setPdpprovider(pdpprovider);
    RemoteScopInstallation scop=new RemoteScopInstallation();
    scop.setServer(serverURL + ""String_Node_Str"");
    ScopFactory.setScopDatabase(scop);
  }
  FileParsingParameters fparams=cache.getFileParsingParams();
  fparams.setUpdateRemediatedFiles(params.isUpdateRemediatedFiles());
  maxNrAlignments=params.getNrAlignments();
  progressListeners=null;
  if (params.getUsername() == null) {
    userName=randomUsername;
  }
 else {
    userName=params.getUsername();
  }
  counter=new CountProgressListener();
  addAlignmentProgressListener(counter);
  waitForAlignments=true;
  if (params.isVerbose()) {
    verbose=true;
  }
}","public FarmJobRunnable(FarmJobParameters params){
  terminated=false;
  this.params=params;
  verbose=false;
  cache=new AtomCache(params.getPdbFilePath(),params.getCacheFilePath());
  if (params.getServer() != null && (!params.getServer().equals(""String_Node_Str""))) {
    RemotePDPProvider pdpprovider=new RemotePDPProvider();
    String serverURL=params.getServer();
    if (!serverURL.endsWith(""String_Node_Str""))     serverURL+=""String_Node_Str"";
    if (serverURL.endsWith(alignURL)) {
      serverURL=serverURL.substring(0,serverURL.length() - alignURL.length());
    }
    pdpprovider.setServer(serverURL + ""String_Node_Str"");
    cache.setPdpprovider(pdpprovider);
    RemoteScopInstallation scop=new RemoteScopInstallation();
    scop.setServer(serverURL + ""String_Node_Str"");
    ScopFactory.setScopDatabase(scop);
  }
  cache.setFetchBehavior(FetchBehavior.FETCH_REMEDIATED);
  maxNrAlignments=params.getNrAlignments();
  progressListeners=null;
  if (params.getUsername() == null) {
    userName=randomUsername;
  }
 else {
    userName=params.getUsername();
  }
  counter=new CountProgressListener();
  addAlignmentProgressListener(counter);
  waitForAlignments=true;
  if (params.isVerbose()) {
    verbose=true;
  }
}",0.931496062992126
16821,"/** 
 * @deprecated Use {@link #getFetchBehavior()}
 */
@Deprecated @Override public void setAutoFetch(boolean autoFetch){
  if (autoFetch) {
    setFetchBehavior(FetchBehavior.DEFAULT);
  }
 else {
    setFetchBehavior(FetchBehavior.LOCAL_ONLY);
  }
}","/** 
 * @deprecated Use {@link #setFetchBehavior()}
 */
@Deprecated public void setAutoFetch(boolean autoFetch){
  if (autoFetch) {
    setFetchBehavior(FetchBehavior.DEFAULT);
  }
 else {
    setFetchBehavior(FetchBehavior.LOCAL_ONLY);
  }
}",0.9757085020242916
16822,"/** 
 * Returns the path value.
 * @return a String representing the path value
 * @see #setPath
 */
@SuppressWarnings(""String_Node_Str"") @Override public String getPath(){
  return path.toString();
}","/** 
 * Returns the path value.
 * @return a String representing the path value
 * @see #setPath
 */
public String getPath(){
  return path.toString();
}",0.8668555240793201
16823,"/** 
 * @deprecated Use {@link #getFetchBehavior()}
 */
@Deprecated @Override public boolean isAutoFetch(){
  return fetchBehavior != FetchBehavior.LOCAL_ONLY;
}","/** 
 * @deprecated Use {@link #getFetchBehavior()}
 */
@Deprecated public boolean isAutoFetch(){
  return fetchBehavior != FetchBehavior.LOCAL_ONLY;
}",0.967948717948718
16824,"/** 
 * Sets the path for the directory where PDB files are read/written 
 */
@SuppressWarnings(""String_Node_Str"") @Override public void setPath(String p){
  path=new File(FileDownloadUtils.expandUserHome(p));
  initPaths();
}","/** 
 * Sets the path for the directory where PDB files are read/written 
 */
public void setPath(String p){
  path=new File(FileDownloadUtils.expandUserHome(p));
  initPaths();
}",0.8839506172839506
16825,"/** 
 * Attempts to delete all versions of a structure from the local directory.
 * @param pdbId
 * @return True if one or more files were deleted
 */
public boolean deleteStructure(String pdbId){
  boolean deleted=false;
  File existing=getLocalFile(pdbId);
  while (existing != null) {
    assert(existing.exists());
    if (getFetchBehavior() == FetchBehavior.LOCAL_ONLY) {
      throw new RuntimeException(""String_Node_Str"");
    }
    boolean success=existing.delete();
    if (success) {
      logger.info(""String_Node_Str"" + existing.getAbsolutePath());
    }
    deleted|=success;
    File parent=existing.getParentFile();
    if (parent != null) {
      success=parent.delete();
      if (success) {
        logger.info(""String_Node_Str"" + parent.getAbsolutePath());
      }
    }
    existing=getLocalFile(pdbId);
  }
  return deleted;
}","/** 
 * Attempts to delete all versions of a structure from the local directory.
 * @param pdbId
 * @return True if one or more files were deleted
 */
public boolean deleteStructure(String pdbId){
  boolean deleted=false;
  ObsoleteBehavior obsolete=getObsoleteBehavior();
  setObsoleteBehavior(ObsoleteBehavior.FETCH_OBSOLETE);
  try {
    File existing=getLocalFile(pdbId);
    while (existing != null) {
      assert(existing.exists());
      if (getFetchBehavior() == FetchBehavior.LOCAL_ONLY) {
        throw new RuntimeException(""String_Node_Str"");
      }
      boolean success=existing.delete();
      if (success) {
        logger.info(""String_Node_Str"" + existing.getAbsolutePath());
      }
      deleted=deleted || success;
      File parent=existing.getParentFile();
      if (parent != null) {
        success=parent.delete();
        if (success) {
          logger.info(""String_Node_Str"" + parent.getAbsolutePath());
        }
      }
      existing=getLocalFile(pdbId);
    }
    return deleted;
  }
  finally {
    setObsoleteBehavior(obsolete);
  }
}",0.8496868475991649
16826,"/** 
 * Should be called whenever any of the path variables change. Thus, if   {@link getSplitDirPath()} or {@link getObsoleteDirPath()}depend on anything, they should call this function when that thing changes (possibly including at the end of the constructor).
 */
protected void initPaths(){
  String[] split=getSplitDirPath();
  String[] obsolete=getObsoleteDirPath();
  StringBuilder splitURL=new StringBuilder(""String_Node_Str"");
  for (int i=0; i < split.length; i++) {
    splitURL.append(""String_Node_Str"");
    splitURL.append(split[i]);
  }
  StringBuilder obsoleteURL=new StringBuilder(""String_Node_Str"");
  for (int i=0; i < obsolete.length; i++) {
    obsoleteURL.append(""String_Node_Str"");
    obsoleteURL.append(obsolete[i]);
  }
  splitDirURL=splitURL.toString();
  obsoleteDirURL=obsoleteURL.toString();
  splitDirPath=path;
  for (int i=0; i < split.length; i++) {
    splitDirPath=new File(splitDirPath,split[i]);
  }
  obsoleteDirPath=path;
  for (int i=0; i < obsolete.length; i++) {
    obsoleteDirPath=new File(obsoleteDirPath,split[i]);
  }
}","/** 
 * Should be called whenever any of the path variables change. Thus, if   {@link getSplitDirPath()} or {@link getObsoleteDirPath()}depend on anything, they should call this function when that thing changes (possibly including at the end of the constructor).
 */
protected void initPaths(){
  String[] split=getSplitDirPath();
  String[] obsolete=getObsoleteDirPath();
  StringBuilder splitURL=new StringBuilder(""String_Node_Str"");
  for (int i=0; i < split.length; i++) {
    splitURL.append(""String_Node_Str"");
    splitURL.append(split[i]);
  }
  StringBuilder obsoleteURL=new StringBuilder(""String_Node_Str"");
  for (int i=0; i < obsolete.length; i++) {
    obsoleteURL.append(""String_Node_Str"");
    obsoleteURL.append(obsolete[i]);
  }
  splitDirURL=splitURL.toString();
  obsoleteDirURL=obsoleteURL.toString();
  splitDirPath=path;
  for (int i=0; i < split.length; i++) {
    splitDirPath=new File(splitDirPath,split[i]);
  }
  obsoleteDirPath=path;
  for (int i=0; i < obsolete.length; i++) {
    obsoleteDirPath=new File(obsoleteDirPath,obsolete[i]);
  }
}",0.9939167056621432
16827,"@Before public void setUp(){
  cache=new AtomCache();
  String[] uncacheIDs=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  List<LocalPDBDirectory> readers=new ArrayList<LocalPDBDirectory>();
  readers.add(new MMCIFFileReader(cache.getPath()));
  readers.add(new PDBFileReader(cache.getCachePath()));
  for (  LocalPDBDirectory reader : readers) {
    reader.setFetchBehavior(cache.getFetchBehavior());
    reader.setObsoleteBehavior(cache.getObsoleteBehavior());
    for (    String pdbId : uncacheIDs) {
      reader.deleteStructure(pdbId);
    }
  }
}","@Before public void setUp(){
  cache=new AtomCache();
  String[] uncacheIDs=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  List<LocalPDBDirectory> readers=new ArrayList<LocalPDBDirectory>();
  readers.add(new MMCIFFileReader(cache.getPath()));
  readers.add(new PDBFileReader(cache.getPath()));
  for (  LocalPDBDirectory reader : readers) {
    reader.setFetchBehavior(cache.getFetchBehavior());
    reader.setObsoleteBehavior(cache.getObsoleteBehavior());
    for (    String pdbId : uncacheIDs) {
      reader.deleteStructure(pdbId);
    }
  }
}",0.9956483899042646
16828,"/** 
 * Download a structure, but don't parse it yet or store it in memory. Used to pre-fetch large numbers of structures.
 * @param pdbId
 * @throws IOException 
 */
public void prefetchStructure(String pdbId) throws IOException {
  if (pdbId.length() < 4)   throw new IOException(""String_Node_Str"" + pdbId);
  File file=getLocalFile(pdbId);
  if (file == null) {
    file=downloadStructure(pdbId);
  }
  if (!file.exists()) {
    throw new IOException(""String_Node_Str"" + pdbId + ""String_Node_Str"");
  }
}","/** 
 * Download a structure, but don't parse it yet or store it in memory. Used to pre-fetch large numbers of structures.
 * @param pdbId
 * @throws IOException 
 */
public void prefetchStructure(String pdbId) throws IOException {
  if (pdbId.length() < 4)   throw new IOException(""String_Node_Str"" + pdbId);
  File file=downloadStructure(pdbId);
  if (!file.exists()) {
    throw new IOException(""String_Node_Str"" + pdbId + ""String_Node_Str"");
  }
}",0.908141962421712
16829,"/** 
 * Load or download the specified structure and return it as an InputStream for direct parsing.
 * @param pdbId
 * @return
 * @throws IOException
 */
protected InputStream getInputStream(String pdbId) throws IOException {
  if (pdbId.length() < 4)   throw new IOException(""String_Node_Str"" + pdbId);
  File file=getLocalFile(pdbId);
  if (file == null) {
    file=downloadStructure(pdbId);
  }
  if (!file.exists()) {
    throw new IOException(""String_Node_Str"" + pdbId + ""String_Node_Str"");
  }
  InputStreamProvider isp=new InputStreamProvider();
  InputStream inputStream=isp.getInputStream(file);
  return inputStream;
}","/** 
 * Load or download the specified structure and return it as an InputStream for direct parsing.
 * @param pdbId
 * @return
 * @throws IOException
 */
protected InputStream getInputStream(String pdbId) throws IOException {
  if (pdbId.length() < 4)   throw new IOException(""String_Node_Str"" + pdbId);
  File file=downloadStructure(pdbId);
  if (!file.exists()) {
    throw new IOException(""String_Node_Str"" + pdbId + ""String_Node_Str"");
  }
  InputStreamProvider isp=new InputStreamProvider();
  InputStream inputStream=isp.getInputStream(file);
  return inputStream;
}",0.9267886855241264
16830,"public static void main(String[] args) throws Exception {
  String uniprotID1=""String_Node_Str"";
  String uniprotID2=""String_Node_Str"";
  ProteinSequence s1=getSequenceForId(uniprotID1);
  ProteinSequence s2=getSequenceForId(uniprotID2);
  SubstitutionMatrix<AminoAcidCompound> matrix=SubstitutionMatrixHelper.getBlosum65();
  GapPenalty penalty=new SimpleGapPenalty();
  short gop=8;
  short extend=1;
  penalty.setOpenPenalty(gop);
  penalty.setExtensionPenalty(extend);
  PairwiseSequenceAligner<ProteinSequence,AminoAcidCompound> smithWaterman=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.LOCAL,penalty,matrix);
  SequencePair<ProteinSequence,AminoAcidCompound> pair=smithWaterman.getPair();
  System.out.println(pair.toString(60));
}","public static void main(String[] args) throws Exception {
  String uniprotID1=""String_Node_Str"";
  String uniprotID2=""String_Node_Str"";
  ProteinSequence s1=getSequenceForId(uniprotID1);
  ProteinSequence s2=getSequenceForId(uniprotID2);
  SubstitutionMatrix<AminoAcidCompound> matrix=SubstitutionMatrixHelper.getBlosum65();
  GapPenalty penalty=new SimpleGapPenalty();
  int gop=8;
  int extend=1;
  penalty.setOpenPenalty(gop);
  penalty.setExtensionPenalty(extend);
  PairwiseSequenceAligner<ProteinSequence,AminoAcidCompound> smithWaterman=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.LOCAL,penalty,matrix);
  SequencePair<ProteinSequence,AminoAcidCompound> pair=smithWaterman.getPair();
  System.out.println(pair.toString(60));
}",0.9920529801324504
16831,"public static void main(String[] args) throws Exception {
  String query=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String target=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  GapPenalty penalty=new SimpleGapPenalty((short)-14,(short)-4);
  PairwiseSequenceAligner<DNASequence,NucleotideCompound> aligner=Alignments.getPairwiseAligner(new DNASequence(query,AmbiguityDNACompoundSet.getDNACompoundSet()),new DNASequence(target,AmbiguityDNACompoundSet.getDNACompoundSet()),PairwiseSequenceAlignerType.GLOBAL,penalty,SubstitutionMatrixHelper.getNuc4_4());
  SequencePair<DNASequence,NucleotideCompound> alignment=aligner.getPair();
  System.out.println(""String_Node_Str"" + alignment);
  int identical=alignment.getNumIdenticals();
  System.out.println(""String_Node_Str"" + identical);
  System.out.println(""String_Node_Str"" + identical / (float)query.length());
  System.out.println(""String_Node_Str"" + identical / (float)target.length());
}","public static void main(String[] args) throws Exception {
  String query=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String target=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  GapPenalty penalty=new SimpleGapPenalty(-14,-4);
  PairwiseSequenceAligner<DNASequence,NucleotideCompound> aligner=Alignments.getPairwiseAligner(new DNASequence(query,AmbiguityDNACompoundSet.getDNACompoundSet()),new DNASequence(target,AmbiguityDNACompoundSet.getDNACompoundSet()),PairwiseSequenceAlignerType.GLOBAL,penalty,SubstitutionMatrixHelper.getNuc4_4());
  SequencePair<DNASequence,NucleotideCompound> alignment=aligner.getPair();
  System.out.println(""String_Node_Str"" + alignment);
  int identical=alignment.getNumIdenticals();
  System.out.println(""String_Node_Str"" + identical);
  System.out.println(""String_Node_Str"" + identical / (float)query.length());
  System.out.println(""String_Node_Str"" + identical / (float)target.length());
}",0.9957472660996356
16832,"/** 
 * Sets the default gap extension penalty.
 * @param gep the default gap extension penalty
 */
public static void setDefaultExtensionPenalty(short gep){
  dgep=gep;
}","/** 
 * Sets the default gap extension penalty.
 * @param gep the default gap extension penalty
 */
public static void setDefaultExtensionPenalty(int gep){
  dgep=gep;
}",0.9823529411764704
16833,"/** 
 * @param gop Should be nonnegative
 */
@Override public void setOpenPenalty(short gop){
  this.gop=(short)-Math.abs(gop);
  setType();
}","/** 
 * @param gop Should be nonnegative
 */
@Override public void setOpenPenalty(int gop){
  this.gop=-Math.abs(gop);
  setType();
}",0.9527272727272728
16834,"/** 
 * <strong>Returns the negative of the opening penalty passed to the constructor.</strong>
 */
@Override public short getOpenPenalty(){
  return gop;
}","/** 
 * <strong>Returns the negative of the opening penalty passed to the constructor.</strong>
 */
@Override public int getOpenPenalty(){
  return gop;
}",0.9806451612903224
16835,"/** 
 * <strong>Returns the negative of the extension penalty passed to the constructor.</strong>
 */
@Override public short getExtensionPenalty(){
  return gep;
}","/** 
 * <strong>Returns the negative of the extension penalty passed to the constructor.</strong>
 */
@Override public int getExtensionPenalty(){
  return gep;
}",0.9814814814814816
16836,"/** 
 * Sets the default gap open penalty.
 * @param gop the default gap open penalty
 */
public static void setDefaultOpenPenalty(short gop){
  dgop=gop;
}","/** 
 * Sets the default gap open penalty.
 * @param gop the default gap open penalty
 */
public static void setDefaultOpenPenalty(int gop){
  dgop=gop;
}",0.9806451612903224
16837,"/** 
 * Creates a new set of gap penalties.
 * @param gop the gap open penalty; should be nonnegative
 * @param gep the gap extension penalty; should be nonnegative
 */
public SimpleGapPenalty(short gop,short gep){
  this.gop=(short)-Math.abs(gop);
  this.gep=(short)-Math.abs(gep);
  setType();
}","/** 
 * Creates a new set of gap penalties.
 * @param gop the gap open penalty; should be nonnegative
 * @param gep the gap extension penalty; should be nonnegative
 */
public SimpleGapPenalty(int gop,int gep){
  this.gop=-Math.abs(gop);
  this.gep=-Math.abs(gep);
  setType();
}",0.9548611111111112
16838,"/** 
 * @param gep Should be nonnegative
 */
@Override public void setExtensionPenalty(short gep){
  this.gep=(short)-Math.abs(gep);
  setType();
}","/** 
 * @param gep Should be nonnegative
 */
@Override public void setExtensionPenalty(int gep){
  this.gep=-Math.abs(gep);
  setType();
}",0.9543859649122808
16839,"public DefaultAAIndexProvider(){
  InputStream inStream=getInputStreamToAAindexFile();
  AAIndexFileParser parser=new AAIndexFileParser();
  try {
    parser.parse(inStream);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  matrices=parser.getMatrices();
}","public DefaultAAIndexProvider(){
  InputStream inStream=getInputStreamToAAindexFile();
  AAIndexFileParser parser=new AAIndexFileParser();
  try {
    parser.parse(inStream);
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"",e);
  }
  matrices=parser.getMatrices();
}",0.99645390070922
16840,"/** 
 * Sets penalty given when a deletion or insertion gap first opens
 * @param gop gap open penalty
 */
void setOpenPenalty(short gop);","/** 
 * Sets penalty given when a deletion or insertion gap first opens
 * @param gop gap open penalty
 */
void setOpenPenalty(int gop);",0.978102189781022
16841,"/** 
 * Returns penalty given when a deletion or insertion gap first opens
 * @return gap open penalty
 */
short getOpenPenalty();","/** 
 * Returns penalty given when a deletion or insertion gap first opens
 * @return gap open penalty
 */
int getOpenPenalty();",0.9767441860465116
16842,"/** 
 * Returns penalty given when an already open gap elongates by a single element
 * @return gap extension penalty
 */
short getExtensionPenalty();","/** 
 * Returns penalty given when an already open gap elongates by a single element
 * @return gap extension penalty
 */
int getExtensionPenalty();",0.9798657718120806
16843,"/** 
 * Sets penalty given when an already open gap elongates by a single element
 * @param gep gap extension penalty
 */
void setExtensionPenalty(short gep);","/** 
 * Sets penalty given when an already open gap elongates by a single element
 * @param gep gap extension penalty
 */
void setExtensionPenalty(int gep);",0.9808917197452228
16844,"@Test public void testSimpleGapPenalty(){
  short gop=-12, gep=-3;
  GapPenalty defaults=new SimpleGapPenalty();
  SimpleGapPenalty.setDefaultOpenPenalty(gop);
  SimpleGapPenalty.setDefaultExtensionPenalty(gep);
  GapPenalty gaps=new SimpleGapPenalty();
  assertEquals(gaps.getOpenPenalty(),gop);
  assertEquals(gaps.getExtensionPenalty(),gep);
  assertEquals(gaps.getType(),GapPenalty.Type.AFFINE);
  SimpleGapPenalty.setDefaultOpenPenalty(defaults.getOpenPenalty());
  SimpleGapPenalty.setDefaultExtensionPenalty(defaults.getExtensionPenalty());
}","@Test public void testSimpleGapPenalty(){
  int gop=-12, gep=-3;
  GapPenalty defaults=new SimpleGapPenalty();
  SimpleGapPenalty.setDefaultOpenPenalty(gop);
  SimpleGapPenalty.setDefaultExtensionPenalty(gep);
  GapPenalty gaps=new SimpleGapPenalty();
  assertEquals(gaps.getOpenPenalty(),gop);
  assertEquals(gaps.getExtensionPenalty(),gep);
  assertEquals(gaps.getType(),GapPenalty.Type.AFFINE);
  SimpleGapPenalty.setDefaultOpenPenalty(defaults.getOpenPenalty());
  SimpleGapPenalty.setDefaultExtensionPenalty(defaults.getExtensionPenalty());
}",0.9945255474452556
16845,"/** 
 * Calculate the interface clusters for this StructureInterfaceList  using a contact overlap score to measure the similarity of interfaces. Subsequent calls will use the cached value without recomputing the clusters.
 * @return
 */
public List<StructureInterfaceCluster> getClusters(){
  if (clusters != null) {
    return clusters;
  }
  clusters=new ArrayList<StructureInterfaceCluster>();
  double[][] matrix=new double[list.size()][list.size()];
  for (int i=0; i < list.size(); i++) {
    for (int j=i + 1; j < list.size(); j++) {
      StructureInterface iInterf=list.get(i);
      StructureInterface jInterf=list.get(j);
      double scoreDirect=iInterf.getContactOverlapScore(jInterf,false);
      double scoreInvert=iInterf.getContactOverlapScore(jInterf,true);
      double maxScore=Math.max(scoreDirect,scoreInvert);
      matrix[i][j]=maxScore;
    }
  }
  SingleLinkageClusterer slc=new SingleLinkageClusterer(matrix,true);
  Map<Integer,Set<Integer>> clusteredIndices=slc.getClusters(CONTACT_OVERLAP_SCORE_CLUSTER_CUTOFF);
  for (  int clusterIdx : clusteredIndices.keySet()) {
    List<StructureInterface> members=new ArrayList<StructureInterface>();
    for (    int idx : clusteredIndices.get(clusterIdx)) {
      members.add(list.get(idx));
    }
    StructureInterfaceCluster cluster=new StructureInterfaceCluster();
    cluster.setMembers(members);
    clusters.add(cluster);
  }
  for (  StructureInterfaceCluster cluster : clusters) {
    for (    StructureInterface interf : cluster.getMembers()) {
      interf.setCluster(cluster);
    }
  }
  Collections.sort(clusters,new Comparator<StructureInterfaceCluster>(){
    @Override public int compare(    StructureInterfaceCluster o1,    StructureInterfaceCluster o2){
      return Double.compare(o2.getTotalArea(),o1.getTotalArea());
    }
  }
);
  int id=1;
  for (  StructureInterfaceCluster cluster : clusters) {
    cluster.setId(id);
    id++;
  }
  return clusters;
}","/** 
 * Calculate the interface clusters for this StructureInterfaceList  using a contact overlap score to measure the similarity of interfaces. Subsequent calls will use the cached value without recomputing the clusters.
 * @return
 */
public List<StructureInterfaceCluster> getClusters(){
  if (clusters != null) {
    return clusters;
  }
  clusters=new ArrayList<StructureInterfaceCluster>();
  if (list.size() == 0)   return clusters;
  double[][] matrix=new double[list.size()][list.size()];
  for (int i=0; i < list.size(); i++) {
    for (int j=i + 1; j < list.size(); j++) {
      StructureInterface iInterf=list.get(i);
      StructureInterface jInterf=list.get(j);
      double scoreDirect=iInterf.getContactOverlapScore(jInterf,false);
      double scoreInvert=iInterf.getContactOverlapScore(jInterf,true);
      double maxScore=Math.max(scoreDirect,scoreInvert);
      matrix[i][j]=maxScore;
    }
  }
  SingleLinkageClusterer slc=new SingleLinkageClusterer(matrix,true);
  Map<Integer,Set<Integer>> clusteredIndices=slc.getClusters(CONTACT_OVERLAP_SCORE_CLUSTER_CUTOFF);
  for (  int clusterIdx : clusteredIndices.keySet()) {
    List<StructureInterface> members=new ArrayList<StructureInterface>();
    for (    int idx : clusteredIndices.get(clusterIdx)) {
      members.add(list.get(idx));
    }
    StructureInterfaceCluster cluster=new StructureInterfaceCluster();
    cluster.setMembers(members);
    clusters.add(cluster);
  }
  for (  StructureInterfaceCluster cluster : clusters) {
    for (    StructureInterface interf : cluster.getMembers()) {
      interf.setCluster(cluster);
    }
  }
  Collections.sort(clusters,new Comparator<StructureInterfaceCluster>(){
    @Override public int compare(    StructureInterfaceCluster o1,    StructureInterfaceCluster o2){
      return Double.compare(o2.getTotalArea(),o1.getTotalArea());
    }
  }
);
  int id=1;
  for (  StructureInterfaceCluster cluster : clusters) {
    cluster.setId(id);
    id++;
  }
  return clusters;
}",0.9890945980218108
16846,"/** 
 * Returns the full sequence of the Atom records of a parent with X instead of HETATMSs. The advantage of this is that it allows us to also align HETATM groups back to the SEQRES.
 * @param groups the list of groups in a parent
 * @param positionIndex a Map to keep track of which group is at which sequence position
 * @return string representations
 */
public static String getFullAtomSequence(List<Group> groups,Map<Integer,Integer> positionIndex){
  StringBuffer sequence=new StringBuffer();
  int seqIndex=0;
  for (int i=0; i < groups.size(); i++) {
    Group g=groups.get(i);
    if (g instanceof AminoAcid) {
      AminoAcid a=(AminoAcid)g;
      char oneLetter=a.getAminoType();
      if (oneLetter == '?')       oneLetter='X';
      positionIndex.put(seqIndex,i);
      sequence.append(oneLetter);
      seqIndex++;
    }
 else {
      if (g.isWater())       continue;
      if (g.size() == 1) {
        Atom a=g.getAtom(0);
        if (a == null)         continue;
        if (a.getElement().isMetal())         continue;
      }
      ChemComp cc=g.getChemComp();
      if (cc == null) {
        continue;
      }
      if (ResidueType.lPeptideLinking.equals(cc.getResidueType()) || PolymerType.PROTEIN_ONLY.contains(cc.getPolymerType()) || PolymerType.POLYNUCLEOTIDE_ONLY.contains(cc.getPolymerType())) {
        String c=cc.getOne_letter_code();
        if (c.equals(""String_Node_Str""))         c=""String_Node_Str"";
        positionIndex.put(seqIndex,i);
        sequence.append(c);
        seqIndex++;
      }
 else {
        continue;
      }
    }
  }
  return sequence.toString();
}","/** 
 * Returns the full sequence of the Atom records of a parent with X instead of HETATMSs. The advantage of this is that it allows us to also align HETATM groups back to the SEQRES.
 * @param groups the list of groups in a parent
 * @param positionIndex a Map to keep track of which group is at which sequence position
 * @return string representations
 */
public static String getFullAtomSequence(List<Group> groups,Map<Integer,Integer> positionIndex){
  StringBuffer sequence=new StringBuffer();
  int seqIndex=0;
  for (int i=0; i < groups.size(); i++) {
    Group g=groups.get(i);
    if (g instanceof AminoAcid) {
      AminoAcid a=(AminoAcid)g;
      char oneLetter=a.getAminoType();
      if (oneLetter == '?')       oneLetter='X';
      positionIndex.put(seqIndex,i);
      sequence.append(oneLetter);
      seqIndex++;
    }
 else {
      if (g.isWater())       continue;
      if (g.size() == 1) {
        Atom a=g.getAtom(0);
        if (a == null)         continue;
        if (a.getElement().isMetal())         continue;
      }
      ChemComp cc=g.getChemComp();
      if (cc == null) {
        logger.debug(""String_Node_Str"",g.toString());
        continue;
      }
      if (ResidueType.lPeptideLinking.equals(cc.getResidueType()) || PolymerType.PROTEIN_ONLY.contains(cc.getPolymerType()) || PolymerType.POLYNUCLEOTIDE_ONLY.contains(cc.getPolymerType())) {
        String c=cc.getOne_letter_code();
        if (c.equals(""String_Node_Str""))         c=""String_Node_Str"";
        if (c.length() > 1) {
          logger.info(""String_Node_Str"",g.toString(),c);
        }
        for (int cIdx=0; cIdx < c.length(); cIdx++) {
          positionIndex.put(seqIndex,i);
          sequence.append(c.charAt(cIdx));
          seqIndex++;
        }
      }
 else {
        logger.debug(""String_Node_Str"",g.toString());
        continue;
      }
    }
  }
  return sequence.toString();
}",0.8770022883295194
16847,"/** 
 * Returns Nuc 4.4 matrix by Lowe
 * @return Nuc 4.4 matrix
 */
public static SubstitutionMatrix<NucleotideCompound> getNuc4_4(){
  return getNucleotideMatrix(""String_Node_Str"");
}","/** 
 * Returns Nuc 4.4 matrix by Lowe Both of the nucleotide sequences to align can contain ambiguous nucleotides
 * @return Nuc 4.4 matrix
 */
public static SubstitutionMatrix<NucleotideCompound> getNuc4_4(){
  return getNucleotideMatrix(""String_Node_Str"");
}",0.8295964125560538
16848,"/** 
 * Returns Nuc 4.2 matrix by Lowe
 * @return Nuc 4.2 matrix
 */
public static SubstitutionMatrix<NucleotideCompound> getNuc4_2(){
  return getNucleotideMatrix(""String_Node_Str"");
}","/** 
 * Returns Nuc 4.2 matrix by Lowe Only the first nucleotide sequence to align can contain ambiguous nucleotides
 * @return Nuc 4.2 matrix
 */
public static SubstitutionMatrix<NucleotideCompound> getNuc4_2(){
  return getNucleotideMatrix(""String_Node_Str"");
}",0.8258928571428571
16849,"protected void align(){
}","/** 
 * Performs alignment
 */
protected void align(){
}",0.6172839506172839
16850,"protected int[] getSubstitutionScoreVector(int queryColumn,Subproblem subproblem){
  int[] subs=new int[subproblem.getTargetEndIndex() + 1];
  if (queryColumn > 0) {
    for (int y=Math.max(1,subproblem.getTargetStartIndex()); y <= subproblem.getTargetEndIndex(); y++) {
      subs[y]=getSubstitutionScore(queryColumn,y);
    }
  }
  return subs;
}","/** 
 * Returns score for the alignment of the query column to all target columns
 * @param queryColumn
 * @param subproblem
 * @return
 */
protected int[] getSubstitutionScoreVector(int queryColumn,Subproblem subproblem){
  int[] subs=new int[subproblem.getTargetEndIndex() + 1];
  if (queryColumn > 0) {
    for (int y=Math.max(1,subproblem.getTargetStartIndex()); y <= subproblem.getTargetEndIndex(); y++) {
      subs[y]=getSubstitutionScore(queryColumn,y);
    }
  }
  return subs;
}",0.8325358851674641
16851,"protected void reset(){
  xyMax=new int[]{0,0};
  xyStart=new int[]{0,0};
  scores=null;
  types=(gapPenalty == null || gapPenalty.getType() == GapPenalty.Type.LINEAR) ? new String[]{null} : new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  time=-1;
  profile=null;
}","/** 
 * Resets output fields; should be overridden to set max and min
 */
protected void reset(){
  xyMax=new int[]{0,0};
  xyStart=new int[]{0,0};
  scores=null;
  types=(gapPenalty == null || gapPenalty.getType() == GapPenalty.Type.LINEAR) ? new String[]{null} : new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  time=-1;
  profile=null;
}",0.8861538461538462
16852,"private List<Location> parseLocationString(String string,int versus) throws ParserException {
  Matcher m;
  List<Location> boundedLocationsCollection=new ArrayList();
  List<String> tokens=splitString(string);
  for (  String t : tokens) {
    m=genbankSplitPattern.matcher(t);
    if (!m.find()) {
      throw new ParserException(""String_Node_Str"" + t + ""String_Node_Str""+ string);
    }
    String splitQualifier=m.group(1);
    String splitString=m.group(2);
    if (!splitQualifier.isEmpty()) {
      int localVersus=splitQualifier.equalsIgnoreCase(""String_Node_Str"") ? -1 : 1;
      List<Location> subLocations=parseLocationString(splitString,versus * localVersus);
switch (complexFeaturesAppendMode) {
case FLATTEN:
        boundedLocationsCollection.addAll(subLocations);
      break;
case HIERARCHICAL:
    if (subLocations.size() == 1) {
      boundedLocationsCollection.addAll(subLocations);
    }
 else {
      Point min=Location.Tools.getMin(subLocations).getStart();
      Point max=Location.Tools.getMax(subLocations).getEnd();
      AbstractLocation motherLocation=new SimpleLocation(min,max);
      if (splitQualifier.equalsIgnoreCase(""String_Node_Str"")) {
        motherLocation=new InsdcLocations.GroupLocation(subLocations);
      }
      if (splitQualifier.equalsIgnoreCase(""String_Node_Str"")) {
        motherLocation=new InsdcLocations.OrderLocation(subLocations);
      }
      if (splitQualifier.equalsIgnoreCase(""String_Node_Str"")) {
        motherLocation=new InsdcLocations.BondLocation(subLocations);
      }
      motherLocation.setStrand(getGroupLocationStrand(subLocations));
      boundedLocationsCollection.add(motherLocation);
    }
  break;
}
}
 else {
m=singleLocationPattern.matcher(splitString);
if (!m.find()) {
throw new ParserException(""String_Node_Str"" + splitString + ""String_Node_Str""+ string);
}
String accession=m.group(1);
Strand s=versus == 1 ? Strand.POSITIVE : Strand.NEGATIVE;
int start=new Integer(m.group(3));
int end=m.group(6) == null ? start : new Integer(m.group(6));
if (featureGlobalStart > start) {
featureGlobalStart=start;
}
if (featureGlobalEnd < end) {
featureGlobalEnd=end;
}
AbstractLocation l=new SimpleLocation(start,end,s);
if (m.group(4) != null && m.group(4).equals(""String_Node_Str"")) l.setBetweenCompounds(true);
if (m.group(2).equals(""String_Node_Str"")) {
l.setPartialOn5prime(true);
}
if (m.group(5) != null && (m.group(5).equals(""String_Node_Str"") || m.group(7).equals(""String_Node_Str""))) {
l.setPartialOn3prime(true);
}
if (!(accession == null || ""String_Node_Str"".equals(accession))) l.setAccession(new AccessionID(accession));
boundedLocationsCollection.add(l);
}
}
return boundedLocationsCollection;
}","private List<Location> parseLocationString(String string,int versus) throws ParserException {
  Matcher m;
  List<Location> boundedLocationsCollection=new ArrayList<Location>();
  List<String> tokens=splitString(string);
  for (  String t : tokens) {
    m=genbankSplitPattern.matcher(t);
    if (!m.find()) {
      throw new ParserException(""String_Node_Str"" + t + ""String_Node_Str""+ string);
    }
    String splitQualifier=m.group(1);
    String splitString=m.group(2);
    if (!splitQualifier.isEmpty()) {
      int localVersus=splitQualifier.equalsIgnoreCase(""String_Node_Str"") ? -1 : 1;
      List<Location> subLocations=parseLocationString(splitString,versus * localVersus);
switch (complexFeaturesAppendMode) {
case FLATTEN:
        boundedLocationsCollection.addAll(subLocations);
      break;
case HIERARCHICAL:
    if (subLocations.size() == 1) {
      boundedLocationsCollection.addAll(subLocations);
    }
 else {
      Point min=Location.Tools.getMin(subLocations).getStart();
      Point max=Location.Tools.getMax(subLocations).getEnd();
      AbstractLocation motherLocation=new SimpleLocation(min,max);
      if (splitQualifier.equalsIgnoreCase(""String_Node_Str"")) {
        motherLocation=new InsdcLocations.GroupLocation(subLocations);
      }
      if (splitQualifier.equalsIgnoreCase(""String_Node_Str"")) {
        motherLocation=new InsdcLocations.OrderLocation(subLocations);
      }
      if (splitQualifier.equalsIgnoreCase(""String_Node_Str"")) {
        motherLocation=new InsdcLocations.BondLocation(subLocations);
      }
      motherLocation.setStrand(getGroupLocationStrand(subLocations));
      boundedLocationsCollection.add(motherLocation);
    }
  break;
}
}
 else {
m=singleLocationPattern.matcher(splitString);
if (!m.find()) {
throw new ParserException(""String_Node_Str"" + splitString + ""String_Node_Str""+ string);
}
String accession=m.group(1);
Strand s=versus == 1 ? Strand.POSITIVE : Strand.NEGATIVE;
int start=new Integer(m.group(3));
int end=m.group(6) == null ? start : new Integer(m.group(6));
if (featureGlobalStart > start) {
featureGlobalStart=start;
}
if (featureGlobalEnd < end) {
featureGlobalEnd=end;
}
AbstractLocation l=new SimpleLocation(start,end,s);
if (m.group(4) != null && m.group(4).equals(""String_Node_Str"")) l.setBetweenCompounds(true);
if (m.group(2).equals(""String_Node_Str"")) {
l.setPartialOn5prime(true);
}
if (m.group(5) != null && (m.group(5).equals(""String_Node_Str"") || m.group(7).equals(""String_Node_Str""))) {
l.setPartialOn3prime(true);
}
if (!(accession == null || ""String_Node_Str"".equals(accession))) l.setAccession(new AccessionID(accession));
boundedLocationsCollection.add(l);
}
}
return boundedLocationsCollection;
}",0.9981398809523808
16853,"private boolean alignNucleotideGroups(List<Group> seqRes,List<Group> atomRes){
  Map<Integer,Integer> seqresIndexPosition=new HashMap<Integer,Integer>();
  Map<Integer,Integer> atomIndexPosition=new HashMap<Integer,Integer>();
  String seq1=getFullAtomSequence(seqRes,seqresIndexPosition);
  String seq2=getFullAtomSequence(atomRes,atomIndexPosition);
  logger.debug(""String_Node_Str"" + seq1.length() + ""String_Node_Str""+ seq1);
  logger.debug(""String_Node_Str"" + seq2.length() + ""String_Node_Str""+ seq2);
  @SuppressWarnings(""String_Node_Str"") Sequence s1;
  @SuppressWarnings(""String_Node_Str"") Sequence s2;
  try {
    s1=new DNASequence(seq1,AmbiguityDNACompoundSet.getDNACompoundSet());
  }
 catch (  CompoundNotFoundException e) {
    try {
      s1=new RNASequence(seq1,AmbiguityRNACompoundSet.getRNACompoundSet());
    }
 catch (    CompoundNotFoundException ex) {
      logger.warn(""String_Node_Str"" + seq1);
      return true;
    }
  }
  try {
    s2=new DNASequence(seq2,AmbiguityDNACompoundSet.getDNACompoundSet());
  }
 catch (  CompoundNotFoundException e) {
    try {
      s2=new RNASequence(seq2,AmbiguityRNACompoundSet.getRNACompoundSet());
    }
 catch (    CompoundNotFoundException ex) {
      logger.warn(""String_Node_Str"" + seq2);
      return true;
    }
  }
  if (!s1.getCompoundSet().equals(s2.getCompoundSet())) {
    if (!s1.getCompoundSet().equals(AmbiguityRNACompoundSet.getRNACompoundSet())) {
      try {
        s1=new RNASequence(seq1,AmbiguityRNACompoundSet.getRNACompoundSet());
      }
 catch (      CompoundNotFoundException ex) {
        logger.warn(""String_Node_Str"" + seq1);
        return true;
      }
    }
    if (!s2.getCompoundSet().equals(AmbiguityRNACompoundSet.getRNACompoundSet())) {
      try {
        s2=new RNASequence(seq2,AmbiguityRNACompoundSet.getRNACompoundSet());
      }
 catch (      CompoundNotFoundException ex) {
        logger.warn(""String_Node_Str"" + seq2);
        return true;
      }
    }
  }
  SubstitutionMatrix<NucleotideCompound> matrix=SubstitutionMatrixHelper.getNuc4_2();
  GapPenalty penalty=new SimpleGapPenalty();
  short gop=8;
  short extend=1;
  penalty.setOpenPenalty(gop);
  penalty.setExtensionPenalty(extend);
  @SuppressWarnings({""String_Node_Str""}) PairwiseSequenceAligner<?,NucleotideCompound> smithWaterman=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.LOCAL,penalty,matrix);
  @SuppressWarnings(""String_Node_Str"") SequencePair pair=smithWaterman.getPair();
  if (pair == null) {
    logger.warn(""String_Node_Str"");
    logger.warn(""String_Node_Str"");
    logger.warn(seq1);
    logger.warn(seq2);
    return true;
  }
  logger.debug(""String_Node_Str"" + pair.toString(100));
  @SuppressWarnings(""String_Node_Str"") boolean noMatchFound=mapDNAChains(seqRes,atomRes,pair,seqresIndexPosition,atomIndexPosition);
  return noMatchFound;
}","private boolean alignNucleotideGroups(List<Group> seqRes,List<Group> atomRes){
  Map<Integer,Integer> seqresIndexPosition=new HashMap<Integer,Integer>();
  Map<Integer,Integer> atomIndexPosition=new HashMap<Integer,Integer>();
  String seq1=getFullAtomSequence(seqRes,seqresIndexPosition);
  String seq2=getFullAtomSequence(atomRes,atomIndexPosition);
  logger.debug(""String_Node_Str"" + seq1.length() + ""String_Node_Str""+ seq1);
  logger.debug(""String_Node_Str"" + seq2.length() + ""String_Node_Str""+ seq2);
  Sequence<NucleotideCompound> s1;
  Sequence<NucleotideCompound> s2;
  try {
    s1=new DNASequence(seq1,AmbiguityDNACompoundSet.getDNACompoundSet());
  }
 catch (  CompoundNotFoundException e) {
    try {
      s1=new RNASequence(seq1,AmbiguityRNACompoundSet.getRNACompoundSet());
    }
 catch (    CompoundNotFoundException ex) {
      logger.warn(""String_Node_Str"" + seq1);
      return true;
    }
  }
  try {
    s2=new DNASequence(seq2,AmbiguityDNACompoundSet.getDNACompoundSet());
  }
 catch (  CompoundNotFoundException e) {
    try {
      s2=new RNASequence(seq2,AmbiguityRNACompoundSet.getRNACompoundSet());
    }
 catch (    CompoundNotFoundException ex) {
      logger.warn(""String_Node_Str"" + seq2);
      return true;
    }
  }
  if (!s1.getCompoundSet().equals(s2.getCompoundSet())) {
    if (!s1.getCompoundSet().equals(AmbiguityRNACompoundSet.getRNACompoundSet())) {
      try {
        s1=new RNASequence(seq1,AmbiguityRNACompoundSet.getRNACompoundSet());
      }
 catch (      CompoundNotFoundException ex) {
        logger.warn(""String_Node_Str"" + seq1);
        return true;
      }
    }
    if (!s2.getCompoundSet().equals(AmbiguityRNACompoundSet.getRNACompoundSet())) {
      try {
        s2=new RNASequence(seq2,AmbiguityRNACompoundSet.getRNACompoundSet());
      }
 catch (      CompoundNotFoundException ex) {
        logger.warn(""String_Node_Str"" + seq2);
        return true;
      }
    }
  }
  SubstitutionMatrix<NucleotideCompound> matrix=SubstitutionMatrixHelper.getNuc4_4();
  GapPenalty penalty=new SimpleGapPenalty(8,1);
  PairwiseSequenceAligner<Sequence<NucleotideCompound>,NucleotideCompound> smithWaterman=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.LOCAL,penalty,matrix);
  SequencePair<Sequence<NucleotideCompound>,NucleotideCompound> pair=smithWaterman.getPair();
  if (pair == null) {
    logger.warn(""String_Node_Str"");
    logger.warn(""String_Node_Str"");
    logger.warn(seq1);
    logger.warn(seq2);
    return true;
  }
  logger.debug(""String_Node_Str"" + pair.toString(100));
  boolean noMatchFound=mapDNAChains(seqRes,atomRes,pair,seqresIndexPosition,atomIndexPosition);
  return noMatchFound;
}",0.918252673554468
16854,"/** 
 * Aligns two chains of groups, where the first parent is representing the list of amino acids as obtained from the SEQRES records, and the second parent represents the groups obtained from the ATOM records (and containing the actual ATOM information). This does the actual alignment and if a group can be mapped to a position in the SEQRES then the corresponding position is replaced with the group that contains the atoms.
 * @param seqRes
 * @param atomRes
 * @return true if no match has been found
 */
private boolean alignProteinChains(List<Group> seqRes,List<Group> atomRes){
  Map<Integer,Integer> seqresIndexPosition=new HashMap<Integer,Integer>();
  Map<Integer,Integer> atomIndexPosition=new HashMap<Integer,Integer>();
  String seq1=getFullAtomSequence(seqRes,seqresIndexPosition);
  String seq2=getFullAtomSequence(atomRes,atomIndexPosition);
  logger.debug(""String_Node_Str"" + seq1.length() + ""String_Node_Str""+ seq1);
  logger.debug(""String_Node_Str"" + seq2.length() + ""String_Node_Str""+ seq2);
  ProteinSequence s1;
  ProteinSequence s2;
  try {
    s1=new ProteinSequence(seq1);
    s2=new ProteinSequence(seq2);
  }
 catch (  CompoundNotFoundException e) {
    logger.warn(""String_Node_Str"",e.getMessage());
    return true;
  }
  SubstitutionMatrix<AminoAcidCompound> matrix=SubstitutionMatrixHelper.getBlosum65();
  GapPenalty penalty=new SimpleGapPenalty();
  short gop=8;
  short extend=1;
  penalty.setOpenPenalty(gop);
  penalty.setExtensionPenalty(extend);
  PairwiseSequenceAligner<ProteinSequence,AminoAcidCompound> smithWaterman=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.LOCAL,penalty,matrix);
  SequencePair<ProteinSequence,AminoAcidCompound> pair=smithWaterman.getPair();
  if (pair == null) {
    logger.warn(""String_Node_Str"");
    logger.warn(""String_Node_Str"");
    logger.warn(seq1);
    logger.warn(seq2);
    return true;
  }
  logger.debug(""String_Node_Str"" + pair.toString(100));
  boolean noMatchFound=mapChains(seqRes,atomRes,pair,seqresIndexPosition,atomIndexPosition);
  return noMatchFound;
}","/** 
 * Aligns two chains of groups, where the first parent is representing the list of amino acids as obtained from the SEQRES records, and the second parent represents the groups obtained from the ATOM records (and containing the actual ATOM information). This does the actual alignment and if a group can be mapped to a position in the SEQRES then the corresponding position is replaced with the group that contains the atoms.
 * @param seqRes
 * @param atomRes
 * @return true if no match has been found
 */
private boolean alignProteinChains(List<Group> seqRes,List<Group> atomRes){
  Map<Integer,Integer> seqresIndexPosition=new HashMap<Integer,Integer>();
  Map<Integer,Integer> atomIndexPosition=new HashMap<Integer,Integer>();
  String seq1=getFullAtomSequence(seqRes,seqresIndexPosition);
  String seq2=getFullAtomSequence(atomRes,atomIndexPosition);
  logger.debug(""String_Node_Str"" + seq1.length() + ""String_Node_Str""+ seq1);
  logger.debug(""String_Node_Str"" + seq2.length() + ""String_Node_Str""+ seq2);
  ProteinSequence s1;
  ProteinSequence s2;
  try {
    s1=new ProteinSequence(seq1);
    s2=new ProteinSequence(seq2);
  }
 catch (  CompoundNotFoundException e) {
    logger.warn(""String_Node_Str"",e.getMessage());
    return true;
  }
  SubstitutionMatrix<AminoAcidCompound> matrix=SubstitutionMatrixHelper.getBlosum65();
  GapPenalty penalty=new SimpleGapPenalty(8,1);
  PairwiseSequenceAligner<ProteinSequence,AminoAcidCompound> smithWaterman=Alignments.getPairwiseAligner(s1,s2,PairwiseSequenceAlignerType.LOCAL,penalty,matrix);
  SequencePair<ProteinSequence,AminoAcidCompound> pair=smithWaterman.getPair();
  if (pair == null) {
    logger.warn(""String_Node_Str"");
    logger.warn(""String_Node_Str"");
    logger.warn(seq1);
    logger.warn(seq2);
    return true;
  }
  logger.debug(""String_Node_Str"" + pair.toString(100));
  boolean noMatchFound=mapChains(seqRes,atomRes,pair,seqresIndexPosition,atomIndexPosition);
  return noMatchFound;
}",0.9746646795827124
16855,"private boolean mapDNAChains(List<Group> seqResGroups,List<Group> atomRes,SequencePair<DNASequence,NucleotideCompound> pair,Map<Integer,Integer> seqresIndexPosition,Map<Integer,Integer> atomIndexPosition){
  int aligLength=pair.getLength();
  boolean noMatchFound=true;
  Compound gapSymbol=DNACompoundSet.getDNACompoundSet().getCompoundForString(""String_Node_Str"");
  mainLoop:   for (int i=1; i <= aligLength; i++) {
    Compound s=pair.getCompoundAt(1,i);
    Compound a=pair.getCompoundAt(2,i);
    int posSeq=pair.getIndexInQueryAt(i) - 1;
    int posAtom=pair.getIndexInTargetAt(i) - 1;
    if (s.equals(gapSymbol) || a.equals(gapSymbol)) {
      continue;
    }
    if (s.equals(a)) {
      Group s1=seqResGroups.get(seqresIndexPosition.get(posSeq));
      Group a1=atomRes.get(atomIndexPosition.get(posAtom));
      if (s1 == null || a1 == null) {
        logger.warn(""String_Node_Str"" + i + ""String_Node_Str""+ s+ ""String_Node_Str""+ posSeq+ ""String_Node_Str""+ s1+ ""String_Node_Str""+ posAtom+ ""String_Node_Str""+ a1);
        continue mainLoop;
      }
      String pdbNameS=s1.getPDBName();
      String pdbNameA=a1.getPDBName();
      if (pdbNameS == null || pdbNameA == null) {
        logger.warn(""String_Node_Str"" + posSeq + ""String_Node_Str""+ s1+ ""String_Node_Str""+ a1+ ""String_Node_Str""+ posAtom);
        logger.warn(""String_Node_Str"");
      }
      if (!pdbNameA.equals(pdbNameS)) {
        if (!pdbNameA.trim().equals(pdbNameS.trim())) {
          logger.info(s1 + ""String_Node_Str"" + posSeq+ ""String_Node_Str""+ a1+ ""String_Node_Str""+ posAtom+ ""String_Node_Str""+ s+ ""String_Node_Str""+ a);
          if (s1.getType().equals(HetatomImpl.type) && a1.getType().equals(HetatomImpl.type)) {
            logger.info(""String_Node_Str"");
          }
 else {
            logger.warn(""String_Node_Str"" + s1 + ""String_Node_Str""+ a1);
          }
        }
      }
      seqResGroups.set(seqresIndexPosition.get(posSeq),a1);
      noMatchFound=false;
    }
  }
  if (noMatchFound) {
    logger.debug(""String_Node_Str"");
  }
  return noMatchFound;
}","private boolean mapDNAChains(List<Group> seqResGroups,List<Group> atomRes,SequencePair<Sequence<NucleotideCompound>,NucleotideCompound> pair,Map<Integer,Integer> seqresIndexPosition,Map<Integer,Integer> atomIndexPosition){
  int aligLength=pair.getLength();
  boolean noMatchFound=true;
  Compound gapSymbol=DNACompoundSet.getDNACompoundSet().getCompoundForString(""String_Node_Str"");
  mainLoop:   for (int i=1; i <= aligLength; i++) {
    Compound s=pair.getCompoundAt(1,i);
    Compound a=pair.getCompoundAt(2,i);
    int posSeq=pair.getIndexInQueryAt(i) - 1;
    int posAtom=pair.getIndexInTargetAt(i) - 1;
    if (s.equals(gapSymbol) || a.equals(gapSymbol)) {
      continue;
    }
    if (s.equals(a)) {
      Group s1=seqResGroups.get(seqresIndexPosition.get(posSeq));
      Group a1=atomRes.get(atomIndexPosition.get(posAtom));
      if (s1 == null || a1 == null) {
        logger.warn(""String_Node_Str"" + i + ""String_Node_Str""+ s+ ""String_Node_Str""+ posSeq+ ""String_Node_Str""+ s1+ ""String_Node_Str""+ posAtom+ ""String_Node_Str""+ a1);
        continue mainLoop;
      }
      String pdbNameS=s1.getPDBName();
      String pdbNameA=a1.getPDBName();
      if (pdbNameS == null || pdbNameA == null) {
        logger.warn(""String_Node_Str"" + posSeq + ""String_Node_Str""+ s1+ ""String_Node_Str""+ a1+ ""String_Node_Str""+ posAtom);
        logger.warn(""String_Node_Str"");
      }
      if (!pdbNameA.equals(pdbNameS)) {
        if (!pdbNameA.trim().equals(pdbNameS.trim())) {
          logger.info(s1 + ""String_Node_Str"" + posSeq+ ""String_Node_Str""+ a1+ ""String_Node_Str""+ posAtom+ ""String_Node_Str""+ s+ ""String_Node_Str""+ a);
          if (s1.getType().equals(HetatomImpl.type) && a1.getType().equals(HetatomImpl.type)) {
            logger.info(""String_Node_Str"");
          }
 else {
            logger.warn(""String_Node_Str"" + s1 + ""String_Node_Str""+ a1);
          }
        }
      }
      seqResGroups.set(seqresIndexPosition.get(posSeq),a1);
      noMatchFound=false;
    }
  }
  if (noMatchFound) {
    logger.debug(""String_Node_Str"");
  }
  return noMatchFound;
}",0.9944188303809754
16856,"/** 
 * attempts to reduce the memory imprint of this group by trimming  all internal Collection objects to the required size.
 */
@SuppressWarnings(""String_Node_Str"") public void trimToSize(){
  if (atoms instanceof ArrayList) {
    ArrayList myatoms=(ArrayList)atoms;
    myatoms.trimToSize();
  }
  if (altLocs instanceof ArrayList) {
    ArrayList myAltLocs=(ArrayList)altLocs;
    myAltLocs.trimToSize();
  }
  atomNameLookup=new HashMap<String,Atom>(atomNameLookup);
  if (hasAltLoc()) {
    for (    Group alt : getAltLocs()) {
      alt.trimToSize();
    }
  }
}","/** 
 * attempts to reduce the memory imprint of this group by trimming  all internal Collection objects to the required size.
 */
public void trimToSize(){
  if (atoms instanceof ArrayList<?>) {
    ArrayList<Atom> myatoms=(ArrayList<Atom>)atoms;
    myatoms.trimToSize();
  }
  if (altLocs instanceof ArrayList<?>) {
    ArrayList<Group> myAltLocs=(ArrayList<Group>)altLocs;
    myAltLocs.trimToSize();
  }
  atomNameLookup=new HashMap<String,Atom>(atomNameLookup);
  if (hasAltLoc()) {
    for (    Group alt : getAltLocs()) {
      alt.trimToSize();
    }
  }
}",0.6202643171806167
16857,"/** 
 * Handler for ATOM Record Format <pre> ATOM      1  N   ASP A  15     110.964  24.941  59.191  1.00 83.44           N COLUMNS        DATA TYPE       FIELD         DEFINITION --------------------------------------------------------------------------------- 1 -  6        Record name     ""ATOM  "" 7 - 11        Integer         serial        Atom serial number. 13 - 16        Atom            name          Atom name. 17             Character       altLoc        Alternate location indicator. 18 - 20        Residue name    resName       Residue name. 22             Character       chainID       Chain identifier. 23 - 26        Integer         resSeq        Residue sequence number. 27             AChar           iCode         Code for insertion of residues. 31 - 38        Real(8.3)       x             Orthogonal coordinates for X in Angstroms. 39 - 46        Real(8.3)       y             Orthogonal coordinates for Y in Angstroms. 47 - 54        Real(8.3)       z             Orthogonal coordinates for Z in Angstroms. 55 - 60        Real(6.2)       occupancy     Occupancy. 61 - 66        Real(6.2)       tempFactor    Temperature factor. 73 - 76        LString(4)      segID         Segment identifier, left-justified. 77 - 78        LString(2)      element       Element symbol, right-justified. 79 - 80        LString(2)      charge        Charge on the atom. </pre>
 */
private void pdb_ATOM_Handler(String line){
  boolean startOfNewChain=false;
  String chain_id=line.substring(21,22);
  if (current_chain == null) {
    current_chain=new ChainImpl();
    current_chain.setChainID(chain_id);
    startOfNewChain=true;
    current_model.add(current_chain);
  }
  if (!chain_id.equals(current_chain.getChainID())) {
    startOfNewChain=true;
    current_chain.addGroup(current_group);
    Chain testchain;
    testchain=isKnownChain(current_chain.getChainID(),current_model);
    if (testchain != null && testchain.getChainID().equals(chain_id)) {
    }
 else {
      testchain=isKnownChain(chain_id,current_model);
    }
    if (testchain == null) {
      current_chain=new ChainImpl();
      current_chain.setChainID(chain_id);
    }
 else {
      current_chain=testchain;
    }
    if (!current_model.contains(current_chain))     current_model.add(current_chain);
  }
  String recordName=line.substring(0,6).trim();
  String groupCode3=line.substring(17,20);
  String resNum=line.substring(22,26).trim();
  Character iCode=line.substring(26,27).charAt(0);
  if (iCode == ' ')   iCode=null;
  ResidueNumber residueNumber=new ResidueNumber(chain_id,Integer.valueOf(resNum),iCode);
  Character aminoCode1=null;
  if (recordName.equals(""String_Node_Str"")) {
    aminoCode1=StructureTools.get1LetterCode(groupCode3);
  }
 else {
    aminoCode1=StructureTools.get1LetterCode(groupCode3);
    if (aminoCode1 != null)     if (aminoCode1.equals(StructureTools.UNKNOWN_GROUP_LABEL))     aminoCode1=null;
  }
  if (current_group == null) {
    current_group=getNewGroup(recordName,aminoCode1,groupCode3);
    current_group.setPDBName(groupCode3);
    current_group.setResidueNumber(residueNumber);
    addTohetGroupsDecider(current_group);
  }
  if (startOfNewChain) {
    current_group=getNewGroup(recordName,aminoCode1,groupCode3);
    current_group.setPDBName(groupCode3);
    current_group.setResidueNumber(residueNumber);
    addTohetGroupsDecider(current_group);
  }
  Character altLoc=new Character(line.substring(16,17).charAt(0));
  Group altGroup=null;
  if (!residueNumber.equals(current_group.getResidueNumber())) {
    current_chain.addGroup(current_group);
    current_group.trimToSize();
    current_group=getNewGroup(recordName,aminoCode1,groupCode3);
    current_group.setPDBName(groupCode3);
    current_group.setResidueNumber(residueNumber);
    addTohetGroupsDecider(current_group);
  }
 else {
    if (!altLoc.equals(' ')) {
      altGroup=getCorrectAltLocGroup(altLoc,recordName,aminoCode1,groupCode3);
      if (altGroup.getChain() == null) {
        altGroup.setChain(current_chain);
      }
    }
  }
  if (params.isHeaderOnly())   return;
  atomCount++;
  if (atomCount == my_ATOM_CA_THRESHOLD) {
    System.err.println(""String_Node_Str"" + my_ATOM_CA_THRESHOLD + ""String_Node_Str"");
    seqResChains.clear();
    switchCAOnly();
  }
  if (atomCount == load_max_atoms) {
    System.err.println(""String_Node_Str"" + load_max_atoms + ""String_Node_Str"");
    System.err.println(""String_Node_Str"" + line);
    return;
  }
  if (atomCount > load_max_atoms) {
    return;
  }
  String fullname=line.substring(12,16);
  if (parseCAonly) {
    if (!fullname.equals(""String_Node_Str"")) {
      atomCount--;
      return;
    }
  }
  if (params.getAcceptedAtomNames() != null) {
    boolean found=false;
    for (    String ok : params.getAcceptedAtomNames()) {
      if (ok.equals(fullname.trim())) {
        found=true;
        break;
      }
    }
    if (!found) {
      atomCount--;
      return;
    }
  }
  int pdbnumber=Integer.parseInt(line.substring(6,11).trim());
  AtomImpl atom=new AtomImpl();
  atom.setPDBserial(pdbnumber);
  atom.setAltLoc(altLoc);
  atom.setName(fullname.trim());
  double x=Double.parseDouble(line.substring(30,38).trim());
  double y=Double.parseDouble(line.substring(38,46).trim());
  double z=Double.parseDouble(line.substring(46,54).trim());
  double[] coords=new double[3];
  coords[0]=x;
  coords[1]=y;
  coords[2]=z;
  atom.setCoords(coords);
  double occu=1.0;
  if (line.length() > 59) {
    try {
      occu=Double.parseDouble(line.substring(54,60).trim());
    }
 catch (    NumberFormatException e) {
    }
  }
  double tempf=0.0;
  if (line.length() > 65) {
    try {
      tempf=Double.parseDouble(line.substring(60,66).trim());
    }
 catch (    NumberFormatException e) {
    }
  }
  atom.setOccupancy(occu);
  atom.setTempFactor(tempf);
  Element element=Element.R;
  if (line.length() > 77) {
    try {
      element=Element.valueOfIgnoreCase(line.substring(76,78).trim());
    }
 catch (    IllegalArgumentException e) {
    }
  }
 else {
    String elementSymbol=null;
    if (fullname.trim().length() == 4) {
      elementSymbol=fullname.substring(0,1);
    }
 else     if (fullname.trim().length() > 1) {
      elementSymbol=fullname.substring(0,2).trim();
    }
 else {
      elementSymbol=""String_Node_Str"";
    }
    try {
      element=Element.valueOfIgnoreCase(elementSymbol);
    }
 catch (    IllegalArgumentException e) {
    }
  }
  atom.setElement(element);
  if (altGroup != null) {
    altGroup.addAtom(atom);
    altGroup=null;
  }
 else {
    current_group.addAtom(atom);
  }
  if (!current_group.hasAtom(atom.getName())) {
    current_group.addAtom(atom);
  }
}","/** 
 * Handler for ATOM Record Format <pre> ATOM      1  N   ASP A  15     110.964  24.941  59.191  1.00 83.44           N COLUMNS        DATA TYPE       FIELD         DEFINITION --------------------------------------------------------------------------------- 1 -  6        Record name     ""ATOM  "" 7 - 11        Integer         serial        Atom serial number. 13 - 16        Atom            name          Atom name. 17             Character       altLoc        Alternate location indicator. 18 - 20        Residue name    resName       Residue name. 22             Character       chainID       Chain identifier. 23 - 26        Integer         resSeq        Residue sequence number. 27             AChar           iCode         Code for insertion of residues. 31 - 38        Real(8.3)       x             Orthogonal coordinates for X in Angstroms. 39 - 46        Real(8.3)       y             Orthogonal coordinates for Y in Angstroms. 47 - 54        Real(8.3)       z             Orthogonal coordinates for Z in Angstroms. 55 - 60        Real(6.2)       occupancy     Occupancy. 61 - 66        Real(6.2)       tempFactor    Temperature factor. 73 - 76        LString(4)      segID         Segment identifier, left-justified. 77 - 78        LString(2)      element       Element symbol, right-justified. 79 - 80        LString(2)      charge        Charge on the atom. </pre>
 */
private void pdb_ATOM_Handler(String line){
  boolean startOfNewChain=false;
  String chain_id=line.substring(21,22);
  if (current_chain == null) {
    current_chain=new ChainImpl();
    current_chain.setChainID(chain_id);
    startOfNewChain=true;
    current_model.add(current_chain);
  }
  if (!chain_id.equals(current_chain.getChainID())) {
    startOfNewChain=true;
    current_chain.addGroup(current_group);
    Chain testchain;
    testchain=isKnownChain(current_chain.getChainID(),current_model);
    if (testchain != null && testchain.getChainID().equals(chain_id)) {
    }
 else {
      testchain=isKnownChain(chain_id,current_model);
    }
    if (testchain == null) {
      current_chain=new ChainImpl();
      current_chain.setChainID(chain_id);
    }
 else {
      current_chain=testchain;
    }
    if (!current_model.contains(current_chain))     current_model.add(current_chain);
  }
  String recordName=line.substring(0,6).trim();
  String groupCode3=line.substring(17,20);
  String resNum=line.substring(22,26).trim();
  Character iCode=line.substring(26,27).charAt(0);
  if (iCode == ' ')   iCode=null;
  ResidueNumber residueNumber=new ResidueNumber(chain_id,Integer.valueOf(resNum),iCode);
  Character aminoCode1=null;
  if (recordName.equals(""String_Node_Str"")) {
    aminoCode1=StructureTools.get1LetterCode(groupCode3);
  }
 else {
    aminoCode1=StructureTools.get1LetterCode(groupCode3);
    if (aminoCode1 != null)     if (aminoCode1.equals(StructureTools.UNKNOWN_GROUP_LABEL))     aminoCode1=null;
  }
  if (current_group == null) {
    current_group=getNewGroup(recordName,aminoCode1,groupCode3);
    current_group.setPDBName(groupCode3);
    current_group.setResidueNumber(residueNumber);
    addTohetGroupsDecider(current_group);
  }
  if (startOfNewChain) {
    current_group=getNewGroup(recordName,aminoCode1,groupCode3);
    current_group.setPDBName(groupCode3);
    current_group.setResidueNumber(residueNumber);
    addTohetGroupsDecider(current_group);
  }
  Character altLoc=new Character(line.substring(16,17).charAt(0));
  Group altGroup=null;
  if (!residueNumber.equals(current_group.getResidueNumber())) {
    current_chain.addGroup(current_group);
    current_group.trimToSize();
    current_group=getNewGroup(recordName,aminoCode1,groupCode3);
    current_group.setPDBName(groupCode3);
    current_group.setResidueNumber(residueNumber);
    addTohetGroupsDecider(current_group);
  }
 else {
    if (!altLoc.equals(' ')) {
      logger.debug(""String_Node_Str"" + current_group + ""String_Node_Str""+ altGroup);
      altGroup=getCorrectAltLocGroup(altLoc,recordName,aminoCode1,groupCode3);
      if (altGroup.getChain() == null) {
        altGroup.setChain(current_chain);
      }
    }
  }
  if (params.isHeaderOnly())   return;
  atomCount++;
  if (atomCount == my_ATOM_CA_THRESHOLD) {
    System.err.println(""String_Node_Str"" + my_ATOM_CA_THRESHOLD + ""String_Node_Str"");
    seqResChains.clear();
    switchCAOnly();
  }
  if (atomCount == load_max_atoms) {
    System.err.println(""String_Node_Str"" + load_max_atoms + ""String_Node_Str"");
    System.err.println(""String_Node_Str"" + line);
    return;
  }
  if (atomCount > load_max_atoms) {
    return;
  }
  String fullname=line.substring(12,16);
  if (parseCAonly) {
    if (!fullname.equals(""String_Node_Str"")) {
      atomCount--;
      return;
    }
  }
  if (params.getAcceptedAtomNames() != null) {
    boolean found=false;
    for (    String ok : params.getAcceptedAtomNames()) {
      if (ok.equals(fullname.trim())) {
        found=true;
        break;
      }
    }
    if (!found) {
      atomCount--;
      return;
    }
  }
  int pdbnumber=Integer.parseInt(line.substring(6,11).trim());
  AtomImpl atom=new AtomImpl();
  atom.setPDBserial(pdbnumber);
  atom.setAltLoc(altLoc);
  atom.setName(fullname.trim());
  double x=Double.parseDouble(line.substring(30,38).trim());
  double y=Double.parseDouble(line.substring(38,46).trim());
  double z=Double.parseDouble(line.substring(46,54).trim());
  double[] coords=new double[3];
  coords[0]=x;
  coords[1]=y;
  coords[2]=z;
  atom.setCoords(coords);
  double occu=1.0;
  if (line.length() > 59) {
    try {
      occu=Double.parseDouble(line.substring(54,60).trim());
    }
 catch (    NumberFormatException e) {
    }
  }
  double tempf=0.0;
  if (line.length() > 65) {
    try {
      tempf=Double.parseDouble(line.substring(60,66).trim());
    }
 catch (    NumberFormatException e) {
    }
  }
  atom.setOccupancy(occu);
  atom.setTempFactor(tempf);
  Element element=Element.R;
  if (line.length() > 77) {
    try {
      element=Element.valueOfIgnoreCase(line.substring(76,78).trim());
    }
 catch (    IllegalArgumentException e) {
    }
  }
 else {
    String elementSymbol=null;
    if (fullname.trim().length() == 4) {
      elementSymbol=fullname.substring(0,1);
    }
 else     if (fullname.trim().length() > 1) {
      elementSymbol=fullname.substring(0,2).trim();
    }
 else {
      elementSymbol=""String_Node_Str"";
    }
    try {
      element=Element.valueOfIgnoreCase(elementSymbol);
    }
 catch (    IllegalArgumentException e) {
    }
  }
  atom.setElement(element);
  if (altGroup != null) {
    altGroup.addAtom(atom);
    altGroup=null;
  }
 else {
    current_group.addAtom(atom);
  }
  if (!current_group.hasAtom(atom.getName())) {
    current_group.addAtom(atom);
  }
}",0.993653401030389
16858,"public void newAtomSite(AtomSite atom){
  boolean startOfNewChain=false;
  String chain_id=atom.getLabel_asym_id();
  String recordName=atom.getGroup_PDB();
  String residueNumberS=atom.getAuth_seq_id();
  Integer residueNrInt=Integer.parseInt(residueNumberS);
  String groupCode3=atom.getLabel_comp_id();
  if (groupCode3.length() == 1) {
    groupCode3=""String_Node_Str"" + groupCode3;
  }
  if (groupCode3.length() == 2) {
    groupCode3=""String_Node_Str"" + groupCode3;
  }
  Character aminoCode1=null;
  if (recordName.equals(""String_Node_Str""))   aminoCode1=StructureTools.get1LetterCode(groupCode3);
 else {
    aminoCode1=StructureTools.get1LetterCode(groupCode3);
    if (aminoCode1 != null && aminoCode1.equals(StructureTools.UNKNOWN_GROUP_LABEL))     aminoCode1=null;
  }
  String insCodeS=atom.getPdbx_PDB_ins_code();
  Character insCode=null;
  if (!insCodeS.equals(""String_Node_Str"")) {
    insCode=insCodeS.charAt(0);
  }
  long seq_id=-1;
  try {
    seq_id=Long.parseLong(atom.getLabel_seq_id());
  }
 catch (  NumberFormatException e) {
  }
  String nmrModel=atom.getPdbx_PDB_model_num();
  if (current_nmr_model == null) {
    current_nmr_model=nmrModel;
  }
  if (!current_nmr_model.equals(nmrModel)) {
    current_nmr_model=nmrModel;
    if (current_chain != null) {
      current_chain.addGroup(current_group);
      current_group.trimToSize();
    }
    structure.addModel(current_model);
    current_model=new ArrayList<Chain>();
    current_chain=null;
    current_group=null;
  }
  if (current_chain == null) {
    current_chain=new ChainImpl();
    current_chain.setChainID(chain_id);
    current_model.add(current_chain);
    startOfNewChain=true;
  }
  if (!chain_id.equals(current_chain.getChainID())) {
    startOfNewChain=true;
    current_chain.addGroup(current_group);
    Chain testchain;
    testchain=isKnownChain(current_chain.getChainID(),current_model);
    if (testchain != null && testchain.getChainID().equals(chain_id)) {
    }
 else {
      testchain=isKnownChain(chain_id,current_model);
    }
    if (testchain == null) {
      current_chain=new ChainImpl();
      current_chain.setChainID(chain_id);
    }
 else {
      current_chain=testchain;
    }
    if (!current_model.contains(current_chain))     current_model.add(current_chain);
  }
  ResidueNumber residueNumber=new ResidueNumber(chain_id,residueNrInt,insCode);
  if (current_group == null) {
    current_group=getNewGroup(recordName,aminoCode1,seq_id,groupCode3);
    current_group.setResidueNumber(residueNumber);
    current_group.setPDBName(groupCode3);
  }
  if (startOfNewChain) {
    current_group=getNewGroup(recordName,aminoCode1,seq_id,groupCode3);
    current_group.setResidueNumber(residueNumber);
    current_group.setPDBName(groupCode3);
  }
  Group altGroup=null;
  String altLocS=atom.getLabel_alt_id();
  Character altLoc=' ';
  if (altLocS.length() > 0) {
    altLoc=altLocS.charAt(0);
    if (altLoc.equals('.'))     altLoc=' ';
  }
  if (!residueNumber.equals(current_group.getResidueNumber())) {
    current_chain.addGroup(current_group);
    current_group.trimToSize();
    current_group=getNewGroup(recordName,aminoCode1,seq_id,groupCode3);
    current_group.setPDBName(groupCode3);
    current_group.setResidueNumber(residueNumber);
  }
 else {
    if (!altLoc.equals(' ') && (!altLoc.equals('.'))) {
      altGroup=getCorrectAltLocGroup(altLoc,recordName,aminoCode1,groupCode3,seq_id);
    }
  }
  if (params.isHeaderOnly())   return;
  if (params.isParseCAOnly()) {
    if (!(atom.getLabel_atom_id().equals(""String_Node_Str"") && atom.getType_symbol().equals(""String_Node_Str""))) {
      return;
    }
  }
  Atom a=convertAtom(atom);
  if (altGroup != null) {
    altGroup.addAtom(a);
    altGroup=null;
  }
 else {
    current_group.addAtom(a);
  }
  if (!current_group.hasAtom(a.getName())) {
    current_group.addAtom(a);
  }
}","public void newAtomSite(AtomSite atom){
  boolean startOfNewChain=false;
  String chain_id=atom.getLabel_asym_id();
  String recordName=atom.getGroup_PDB();
  String residueNumberS=atom.getAuth_seq_id();
  Integer residueNrInt=Integer.parseInt(residueNumberS);
  String groupCode3=atom.getLabel_comp_id();
  if (groupCode3.length() == 1) {
    groupCode3=""String_Node_Str"" + groupCode3;
  }
  if (groupCode3.length() == 2) {
    groupCode3=""String_Node_Str"" + groupCode3;
  }
  Character aminoCode1=null;
  if (recordName.equals(""String_Node_Str""))   aminoCode1=StructureTools.get1LetterCode(groupCode3);
 else {
    aminoCode1=StructureTools.get1LetterCode(groupCode3);
    if (aminoCode1 != null && aminoCode1.equals(StructureTools.UNKNOWN_GROUP_LABEL))     aminoCode1=null;
  }
  String insCodeS=atom.getPdbx_PDB_ins_code();
  Character insCode=null;
  if (!insCodeS.equals(""String_Node_Str"")) {
    insCode=insCodeS.charAt(0);
  }
  long seq_id=-1;
  try {
    seq_id=Long.parseLong(atom.getLabel_seq_id());
  }
 catch (  NumberFormatException e) {
  }
  String nmrModel=atom.getPdbx_PDB_model_num();
  if (current_nmr_model == null) {
    current_nmr_model=nmrModel;
  }
  if (!current_nmr_model.equals(nmrModel)) {
    current_nmr_model=nmrModel;
    if (current_chain != null) {
      current_chain.addGroup(current_group);
      current_group.trimToSize();
    }
    structure.addModel(current_model);
    current_model=new ArrayList<Chain>();
    current_chain=null;
    current_group=null;
  }
  if (current_chain == null) {
    current_chain=new ChainImpl();
    current_chain.setChainID(chain_id);
    current_model.add(current_chain);
    startOfNewChain=true;
  }
  if (!chain_id.equals(current_chain.getChainID())) {
    startOfNewChain=true;
    current_chain.addGroup(current_group);
    Chain testchain;
    testchain=isKnownChain(current_chain.getChainID(),current_model);
    if (testchain != null && testchain.getChainID().equals(chain_id)) {
    }
 else {
      testchain=isKnownChain(chain_id,current_model);
    }
    if (testchain == null) {
      current_chain=new ChainImpl();
      current_chain.setChainID(chain_id);
    }
 else {
      current_chain=testchain;
    }
    if (!current_model.contains(current_chain))     current_model.add(current_chain);
  }
  ResidueNumber residueNumber=new ResidueNumber(chain_id,residueNrInt,insCode);
  if (current_group == null) {
    current_group=getNewGroup(recordName,aminoCode1,seq_id,groupCode3);
    current_group.setResidueNumber(residueNumber);
    current_group.setPDBName(groupCode3);
  }
  if (startOfNewChain) {
    current_group=getNewGroup(recordName,aminoCode1,seq_id,groupCode3);
    current_group.setResidueNumber(residueNumber);
    current_group.setPDBName(groupCode3);
  }
  Group altGroup=null;
  String altLocS=atom.getLabel_alt_id();
  Character altLoc=' ';
  if (altLocS.length() > 0) {
    altLoc=altLocS.charAt(0);
    if (altLoc.equals('.'))     altLoc=' ';
  }
  if (!residueNumber.equals(current_group.getResidueNumber())) {
    current_chain.addGroup(current_group);
    current_group.trimToSize();
    current_group=getNewGroup(recordName,aminoCode1,seq_id,groupCode3);
    current_group.setPDBName(groupCode3);
    current_group.setResidueNumber(residueNumber);
  }
 else {
    if (!altLoc.equals(' ') && (!altLoc.equals('.'))) {
      logger.debug(""String_Node_Str"" + altLoc + ""String_Node_Str""+ current_group+ ""String_Node_Str""+ altGroup);
      altGroup=getCorrectAltLocGroup(altLoc,recordName,aminoCode1,groupCode3,seq_id);
      if (altGroup.getChain() == null) {
        altGroup.setChain(current_chain);
      }
    }
  }
  if (params.isHeaderOnly())   return;
  if (params.isParseCAOnly()) {
    if (!(atom.getLabel_atom_id().equals(""String_Node_Str"") && atom.getType_symbol().equals(""String_Node_Str""))) {
      return;
    }
  }
  Atom a=convertAtom(atom);
  if (altGroup != null) {
    altGroup.addAtom(a);
    altGroup=null;
  }
 else {
    current_group.addAtom(a);
  }
  if (!current_group.hasAtom(a.getName())) {
    current_group.addAtom(a);
  }
}",0.9743783920232236
16859,"@Test public void test3PIUmmcif() throws IOException, StructureException {
  AtomCache cache=new AtomCache();
  StructureIO.setAtomCache(cache);
  cache.setUseMmCif(true);
  Structure structure=StructureIO.getStructure(""String_Node_Str"");
  assertNotNull(structure);
  Atom[] ca=StructureTools.getAtomCAArray(structure);
  List<Atom> caList=new ArrayList<Atom>();
  for (  Chain c : structure.getChains()) {
    for (    Group g : c.getAtomGroups()) {
      for (      Group altLocGroup : g.getAltLocs()) {
        ensureAllAtomsSameAltCode(altLocGroup);
      }
      List<Atom> atoms=g.getAtoms();
      boolean caInMain=false;
      for (      Atom a : atoms) {
        if (a.getName().equals(StructureTools.CA_ATOM_NAME)) {
          caList.add(a);
          caInMain=true;
          break;
        }
      }
      if (!caInMain && g.hasAtom(StructureTools.CA_ATOM_NAME)) {
        fail(""String_Node_Str"");
      }
    }
  }
  assertEquals(ca.length,caList.size());
}","@Test public void test3PIUmmcif() throws IOException, StructureException {
  AtomCache cache=new AtomCache();
  FileParsingParameters params=new FileParsingParameters();
  params.setAlignSeqRes(true);
  cache.setFileParsingParams(params);
  StructureIO.setAtomCache(cache);
  cache.setUseMmCif(true);
  Structure structure=StructureIO.getStructure(""String_Node_Str"");
  assertNotNull(structure);
  Atom[] ca=StructureTools.getAtomCAArray(structure);
  List<Atom> caList=new ArrayList<Atom>();
  for (  Chain c : structure.getChains()) {
    for (    Group g : c.getAtomGroups()) {
      for (      Group altLocGroup : g.getAltLocs()) {
        ensureAllAtomsSameAltCode(altLocGroup);
        for (        Atom a : altLocGroup.getAtoms()) {
          assertNotNull(a.getGroup());
          assertNotNull(a.getGroup().getChain());
        }
      }
      List<Atom> atoms=g.getAtoms();
      boolean caInMain=false;
      for (      Atom a : atoms) {
        assertNotNull(a.getGroup());
        assertNotNull(a.getGroup().getChain());
        if (a.getName().equals(StructureTools.CA_ATOM_NAME)) {
          caList.add(a);
          caInMain=true;
          break;
        }
      }
      if (!caInMain && g.hasAtom(StructureTools.CA_ATOM_NAME)) {
        fail(""String_Node_Str"");
      }
    }
  }
  assertEquals(ca.length,caList.size());
}",0.8403288619645175
16860,"@Test public void test3PIUpdb() throws IOException, StructureException {
  AtomCache cache=new AtomCache();
  StructureIO.setAtomCache(cache);
  cache.setUseMmCif(false);
  Structure structure=StructureIO.getStructure(""String_Node_Str"");
  assertNotNull(structure);
  Atom[] ca=StructureTools.getAtomCAArray(structure);
  List<Atom> caList=new ArrayList<Atom>();
  for (  Chain c : structure.getChains()) {
    for (    Group g : c.getAtomGroups()) {
      for (      Group altLocGroup : g.getAltLocs()) {
        ensureAllAtomsSameAltCode(altLocGroup);
      }
      List<Atom> atoms=g.getAtoms();
      boolean caInMain=false;
      for (      Atom a : atoms) {
        if (a.getName().equals(StructureTools.CA_ATOM_NAME)) {
          caList.add(a);
          caInMain=true;
          break;
        }
      }
      if (!caInMain && g.hasAtom(StructureTools.CA_ATOM_NAME)) {
        fail(""String_Node_Str"");
      }
    }
  }
  assertTrue(ca.length == caList.size());
}","@Test public void test3PIUpdb() throws IOException, StructureException {
  AtomCache cache=new AtomCache();
  FileParsingParameters params=new FileParsingParameters();
  params.setAlignSeqRes(true);
  cache.setFileParsingParams(params);
  StructureIO.setAtomCache(cache);
  cache.setUseMmCif(false);
  Structure structure=StructureIO.getStructure(""String_Node_Str"");
  assertNotNull(structure);
  Atom[] ca=StructureTools.getAtomCAArray(structure);
  List<Atom> caList=new ArrayList<Atom>();
  for (  Chain c : structure.getChains()) {
    for (    Group g : c.getAtomGroups()) {
      for (      Group altLocGroup : g.getAltLocs()) {
        ensureAllAtomsSameAltCode(altLocGroup);
        for (        Atom a : altLocGroup.getAtoms()) {
          assertNotNull(a.getGroup());
          assertNotNull(a.getGroup().getChain());
        }
      }
      List<Atom> atoms=g.getAtoms();
      boolean caInMain=false;
      for (      Atom a : atoms) {
        assertNotNull(a.getGroup());
        assertNotNull(a.getGroup().getChain());
        if (a.getName().equals(StructureTools.CA_ATOM_NAME)) {
          caList.add(a);
          caInMain=true;
          break;
        }
      }
      if (!caInMain && g.hasAtom(StructureTools.CA_ATOM_NAME)) {
        fail(""String_Node_Str"");
      }
    }
  }
  assertTrue(ca.length == caList.size());
}",0.8403288619645175
16861,"private void doFullTest(Structure structure) throws StructureException {
  System.out.println(""String_Node_Str"");
  testStructureRefs(structure);
  logger.debug(""String_Node_Str"",System.identityHashCode(structure));
  Structure structureCopy=structure.clone();
  logger.debug(""String_Node_Str"",System.identityHashCode(structureCopy));
  assertNotSame(structure,structureCopy);
  System.out.println(""String_Node_Str"");
  testStructureRefs(structureCopy);
  logger.debug(""String_Node_Str"",System.identityHashCode(structure));
  System.out.println(""String_Node_Str"");
  testStructureRefs(structure);
  System.out.println(""String_Node_Str"");
  for (  Chain c : structure.getChains()) {
    Chain clonedChain=(Chain)c.clone();
    testChainRefs(clonedChain);
  }
  System.out.println(""String_Node_Str"");
  for (  Chain c : structure.getChains()) {
    Atom[] atomArray=StructureTools.getAllAtomArray(c);
    testAtomArrayRefs(atomArray,c);
  }
  CrystalBuilder cb=new CrystalBuilder(structure);
  StructureInterfaceList interfaces=cb.getUniqueInterfaces();
  for (  StructureInterface interf : interfaces) {
    testInterfaceRefs(structure,interf);
  }
}","private void doFullTest(Structure structure) throws StructureException {
  System.out.println(""String_Node_Str"");
  testStructureRefs(structure);
  logger.debug(""String_Node_Str"",System.identityHashCode(structure));
  Structure structureCopy=structure.clone();
  logger.debug(""String_Node_Str"",System.identityHashCode(structureCopy));
  assertNotSame(structure,structureCopy);
  System.out.println(""String_Node_Str"");
  testStructureRefs(structureCopy);
  logger.debug(""String_Node_Str"",System.identityHashCode(structure));
  System.out.println(""String_Node_Str"");
  testStructureRefs(structure);
  System.out.println(""String_Node_Str"");
  for (  Chain c : structure.getChains()) {
    Chain clonedChain=(Chain)c.clone();
    testChainRefs(clonedChain);
  }
  System.out.println(""String_Node_Str"");
  for (  Chain c : structure.getChains()) {
    Atom[] atomArray=StructureTools.getAllAtomArray(c);
    testAtomArrayRefs(atomArray,c);
  }
  CrystalBuilder cb=new CrystalBuilder(structure);
  StructureInterfaceList interfaces=cb.getUniqueInterfaces();
  for (  StructureInterface interf : interfaces) {
    testInterfaceRefs(structure,interf);
  }
  System.out.println(""String_Node_Str"");
  testStructureRefs(structure);
}",0.9692113032475748
16862,"/** 
 * Returns and array of all atoms of the chain (first model), including  Hydrogens (if present) and all HETATOMs
 * @param c input chain
 * @return all atom array
 */
public static final Atom[] getAllAtomArray(Chain c){
  List<Atom> atoms=new ArrayList<Atom>();
  for (  Group g : c.getAtomGroups()) {
    for (    Atom a : g.getAtoms()) {
      atoms.add(a);
    }
  }
  return (Atom[])atoms.toArray(new Atom[atoms.size()]);
}","/** 
 * Returns and array of all atoms of the chain (first model), including  Hydrogens (if present) and all HETATOMs. Waters are not included.
 * @param c input chain
 * @return all atom array
 */
public static final Atom[] getAllAtomArray(Chain c){
  List<Atom> atoms=new ArrayList<Atom>();
  for (  Group g : c.getAtomGroups()) {
    if (g.isWater())     continue;
    for (    Atom a : g.getAtoms()) {
      atoms.add(a);
    }
  }
  return (Atom[])atoms.toArray(new Atom[atoms.size()]);
}",0.934054054054054
16863,"/** 
 * Returns and array of all non-Hydrogen atoms in the given Chain,  optionally including HET atoms or not
 * @param c
 * @param hetAtoms if true HET atoms are included in array, if false they are not
 * @return
 */
public static final Atom[] getAllNonHAtomArray(Chain c,boolean hetAtoms){
  List<Atom> atoms=new ArrayList<Atom>();
  for (  Group g : c.getAtomGroups()) {
    for (    Atom a : g.getAtoms()) {
      if (a.getElement() == Element.H)       continue;
      if (!hetAtoms && g.getType().equals(GroupType.HETATM))       continue;
      atoms.add(a);
    }
  }
  return (Atom[])atoms.toArray(new Atom[atoms.size()]);
}","/** 
 * Returns and array of all non-Hydrogen atoms in the given Chain,  optionally including HET atoms or not Waters are not included. 
 * @param c
 * @param hetAtoms if true HET atoms are included in array, if false they are not
 * @return
 */
public static final Atom[] getAllNonHAtomArray(Chain c,boolean hetAtoms){
  List<Atom> atoms=new ArrayList<Atom>();
  for (  Group g : c.getAtomGroups()) {
    if (g.isWater())     continue;
    for (    Atom a : g.getAtoms()) {
      if (a.getElement() == Element.H)       continue;
      if (!hetAtoms && g.getType().equals(GroupType.HETATM))       continue;
      atoms.add(a);
    }
  }
  return (Atom[])atoms.toArray(new Atom[atoms.size()]);
}",0.9540316503391107
16864,"@Override public void documentEnd(){
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  structure.addModel(current_model);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    asymId2entityId.put(asym.getId(),asym.getEntity_id());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setChainID(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    int eId=0;
    try {
      eId=Integer.parseInt(asym.getEntity_id());
    }
 catch (    NumberFormatException e) {
      logger.warn(""String_Node_Str"",asym.getEntity_id());
    }
    Entity e=getEntity(eId);
    for (    EntitySrcGen esg : entitySrcGens) {
      if (!esg.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESG(esg,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcNat esn : entitySrcNats) {
      if (!esn.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESN(esn,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcSyn ess : entitySrcSyns) {
      if (!ess.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESS(ess,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    Compound c=structure.getCompoundById(eId);
    if (c == null) {
      c=new Compound();
      c.setMolId(eId);
      if (e != null && e.getType().equals(""String_Node_Str"")) {
        if (e != null)         c.setMolName(e.getPdbx_description());
        structure.addCompound(c);
        logger.debug(""String_Node_Str"",eId,c.getMolName());
      }
    }
  }
  if (params.isAlignSeqRes()) {
    List<Chain> atomList=structure.getModel(0);
    for (    Chain seqResChain : seqResChains) {
      Chain atomChain=SeqRes2AtomAligner.getMatchingAtomRes(seqResChain,atomList);
      List<Group> seqResGroups=seqResChain.getAtomGroups();
      for (int seqResPos=0; seqResPos < seqResGroups.size(); seqResPos++) {
        Group seqresG=seqResGroups.get(seqResPos);
        boolean found=false;
        for (        Group atomG : atomChain.getAtomGroups()) {
          int internalNr=getInternalNr(atomG);
          if (seqresG.getResidueNumber().getSeqNum() == internalNr) {
            seqResGroups.set(seqResPos,atomG);
            found=true;
            break;
          }
        }
        if (!found)         seqresG.setResidueNumber(null);
      }
      atomChain.setSeqResGroups(seqResGroups);
    }
  }
  addBonds();
  Set<String> asymIds=asymStrandId.keySet();
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> model=structure.getModel(i);
    List<Chain> pdbChains=new ArrayList<Chain>();
    for (    Chain chain : model) {
      for (      String asym : asymIds) {
        if (chain.getChainID().equals(asym)) {
          String newChainId=asymStrandId.get(asym);
          logger.debug(""String_Node_Str"",asym,chain.getAtomGroups().size(),newChainId);
          chain.setChainID(newChainId);
          chain.setInternalChainID(asym);
          for (          Group g : chain.getAtomGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          for (          Group g : chain.getSeqResGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          Chain known=isKnownChain(chain.getChainID(),pdbChains);
          if (known == null) {
            pdbChains.add(chain);
          }
 else {
            for (            Group g : chain.getAtomGroups()) {
              known.addGroup(g);
            }
          }
          break;
        }
      }
    }
    structure.setModel(i,pdbChains);
    for (    Chain chain : pdbChains) {
      String entityId=asymId2entityId.get(chain.getInternalChainID());
      int eId=Integer.parseInt(entityId);
      Compound compound=structure.getCompoundById(eId);
      if (compound == null) {
        logger.warn(""String_Node_Str"",eId,chain.getChainID(),chain.getInternalChainID());
      }
 else {
        logger.debug(""String_Node_Str"",chain.getChainID(),chain.getInternalChainID(),eId);
        compound.addChain(chain);
        chain.setCompound(compound);
      }
    }
  }
  PDBHeader header=structure.getPDBHeader();
  header.setNrBioAssemblies(strucAssemblies.size());
  Map<String,List<BiologicalAssemblyTransformation>> transformationMap=new HashMap<String,List<BiologicalAssemblyTransformation>>();
  for (  PdbxStructAssembly psa : strucAssemblies) {
    List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
    for (    PdbxStructAssemblyGen psag : strucAssemblyGens) {
      if (psag.getAssembly_id().equals(psa.getId())) {
        psags.add(psag);
      }
    }
    BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
    List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
    transformationMap.put(psa.getId(),transformations);
  }
  structure.getPDBHeader().setBioUnitTranformationMap(transformationMap);
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators((Matrix4d[])ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
  structure.getCompounds();
}","@Override public void documentEnd(){
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  structure.addModel(current_model);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    asymId2entityId.put(asym.getId(),asym.getEntity_id());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setChainID(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    int eId=0;
    try {
      eId=Integer.parseInt(asym.getEntity_id());
    }
 catch (    NumberFormatException e) {
      logger.warn(""String_Node_Str"",asym.getEntity_id());
    }
    Entity e=getEntity(eId);
    for (    EntitySrcGen esg : entitySrcGens) {
      if (!esg.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESG(esg,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcNat esn : entitySrcNats) {
      if (!esn.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESN(esn,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcSyn ess : entitySrcSyns) {
      if (!ess.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESS(ess,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    Compound c=structure.getCompoundById(eId);
    if (c == null) {
      c=new Compound();
      c.setMolId(eId);
      if (e != null && e.getType().equals(""String_Node_Str"")) {
        if (e != null)         c.setMolName(e.getPdbx_description());
        structure.addCompound(c);
        logger.debug(""String_Node_Str"",eId,c.getMolName());
      }
    }
  }
  if (params.isAlignSeqRes()) {
    List<Chain> atomList=structure.getModel(0);
    for (    Chain seqResChain : seqResChains) {
      Chain atomChain=SeqRes2AtomAligner.getMatchingAtomRes(seqResChain,atomList);
      List<Group> seqResGroups=seqResChain.getAtomGroups();
      for (int seqResPos=0; seqResPos < seqResGroups.size(); seqResPos++) {
        Group seqresG=seqResGroups.get(seqResPos);
        boolean found=false;
        for (        Group atomG : atomChain.getAtomGroups()) {
          int internalNr=getInternalNr(atomG);
          if (seqresG.getResidueNumber().getSeqNum() == internalNr) {
            seqResGroups.set(seqResPos,atomG);
            found=true;
            break;
          }
        }
        if (!found)         seqresG.setResidueNumber(null);
      }
      atomChain.setSeqResGroups(seqResGroups);
    }
  }
  addBonds();
  Set<String> asymIds=asymStrandId.keySet();
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> model=structure.getModel(i);
    List<Chain> pdbChains=new ArrayList<Chain>();
    for (    Chain chain : model) {
      for (      String asym : asymIds) {
        if (chain.getChainID().equals(asym)) {
          String newChainId=asymStrandId.get(asym);
          logger.debug(""String_Node_Str"",asym,chain.getAtomGroups().size(),newChainId);
          chain.setChainID(newChainId);
          chain.setInternalChainID(asym);
          for (          Group g : chain.getAtomGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          for (          Group g : chain.getSeqResGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          Chain known=isKnownChain(chain.getChainID(),pdbChains);
          if (known == null) {
            pdbChains.add(chain);
          }
 else {
            for (            Group g : chain.getAtomGroups()) {
              known.addGroup(g);
            }
          }
          break;
        }
      }
    }
    structure.setModel(i,pdbChains);
    for (    Chain chain : pdbChains) {
      String entityId=asymId2entityId.get(chain.getInternalChainID());
      int eId=Integer.parseInt(entityId);
      Compound compound=structure.getCompoundById(eId);
      if (compound == null) {
        logger.warn(""String_Node_Str"",eId,chain.getChainID(),chain.getInternalChainID());
      }
 else {
        logger.debug(""String_Node_Str"",chain.getChainID(),chain.getInternalChainID(),eId);
        compound.addChain(chain);
        chain.setCompound(compound);
      }
    }
  }
  if (params.isParseBioAssembly()) {
    PDBHeader header=structure.getPDBHeader();
    header.setNrBioAssemblies(strucAssemblies.size());
    Map<String,List<BiologicalAssemblyTransformation>> transformationMap=new HashMap<String,List<BiologicalAssemblyTransformation>>();
    for (    PdbxStructAssembly psa : strucAssemblies) {
      List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
      for (      PdbxStructAssemblyGen psag : strucAssemblyGens) {
        if (psag.getAssembly_id().equals(psa.getId())) {
          psags.add(psag);
        }
      }
      BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
      List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
      transformationMap.put(psa.getId(),transformations);
    }
    structure.getPDBHeader().setBioUnitTranformationMap(transformationMap);
  }
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators((Matrix4d[])ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
  structure.getCompounds();
}",0.9919622446722218
16865,"private void testHeader(Structure sPdb,Structure sCif){
  PDBHeader hPdb=sPdb.getPDBHeader();
  PDBHeader hCif=sCif.getPDBHeader();
  boolean isNmr=sPdb.isNmr();
  boolean isCrystallographic=sPdb.isCrystallographic();
  assertNotNull(hPdb);
  assertNotNull(hCif);
  assertEquals(""String_Node_Str"",hPdb.getIdCode(),hCif.getIdCode());
  assertNotNull(""String_Node_Str"",hPdb.getAuthors());
  assertNotNull(""String_Node_Str"",hCif.getAuthors());
  assertTrue(""String_Node_Str"",hPdb.getAuthors().length() >= 2);
  assertNotNull(""String_Node_Str"",hPdb.getClassification());
  assertNotNull(""String_Node_Str"",hCif.getClassification());
  assertNotNull(""String_Node_Str"",hCif.getDescription());
  assertEquals(""String_Node_Str"",hPdb.getDepDate(),hCif.getDepDate());
  assertEquals(""String_Node_Str"",hPdb.getModDate(),hCif.getModDate());
  assertNotNull(hPdb.getExperimentalTechniques());
  assertNotNull(hCif.getExperimentalTechniques());
  assertTrue(hPdb.getExperimentalTechniques().size() > 0);
  assertEquals(""String_Node_Str"",hPdb.getExperimentalTechniques(),hCif.getExperimentalTechniques());
  if (!hPdb.getExperimentalTechniques().contains(ExperimentalTechnique.ELECTRON_CRYSTALLOGRAPHY) && !hPdb.getExperimentalTechniques().contains(ExperimentalTechnique.ELECTRON_MICROSCOPY)) {
    assertEquals(""String_Node_Str"",hPdb.getResolution(),hCif.getResolution(),DELTA_RESOLUTION);
  }
  assertNotNull(""String_Node_Str"",hPdb.getTitle());
  assertNotNull(""String_Node_Str"",hCif.getTitle());
  assertEquals(""String_Node_Str"",hPdb.getTitle().toLowerCase().replaceAll(""String_Node_Str"",""String_Node_Str""),hCif.getTitle().toLowerCase().replaceAll(""String_Node_Str"",""String_Node_Str""));
  if (isNmr) {
    assertEquals(""String_Node_Str"",PDBHeader.DEFAULT_RESOLUTION,hPdb.getResolution(),DELTA_RESOLUTION);
  }
  if (!isCrystallographic) {
    assertEquals(""String_Node_Str"",PDBHeader.DEFAULT_RFREE,DELTA_RFREE,hPdb.getRfree());
    assertEquals(""String_Node_Str"",PDBHeader.DEFAULT_RFREE,DELTA_RFREE,hCif.getRfree());
  }
  if (isCrystallographic) {
    assertEquals(""String_Node_Str"",hPdb.getRfree(),hCif.getRfree(),DELTA_RFREE);
    assertNotNull(""String_Node_Str"",hPdb.getCrystallographicInfo());
    assertNotNull(""String_Node_Str"",hCif.getCrystallographicInfo());
    PDBCrystallographicInfo ciPdb=hPdb.getCrystallographicInfo();
    PDBCrystallographicInfo ciCif=hCif.getCrystallographicInfo();
    assertNotNull(ciPdb.getSpaceGroup());
    assertNotNull(ciCif.getSpaceGroup());
    assertNotNull(""String_Node_Str"",ciPdb.getCrystalCell());
    assertNotNull(""String_Node_Str"",ciCif.getCrystalCell());
    CrystalCell ccPdb=ciPdb.getCrystalCell();
    CrystalCell ccCif=ciCif.getCrystalCell();
    assertEquals(""String_Node_Str"",ccPdb.getA(),ccCif.getA(),DELTA);
    assertEquals(""String_Node_Str"",ccPdb.getB(),ccCif.getB(),DELTA);
    assertEquals(""String_Node_Str"",ccPdb.getC(),ccCif.getC(),DELTA);
    assertEquals(""String_Node_Str"",ccPdb.getAlpha(),ccCif.getAlpha(),DELTA);
    assertEquals(""String_Node_Str"",ccPdb.getBeta(),ccCif.getBeta(),DELTA);
    assertEquals(""String_Node_Str"",ccPdb.getGamma(),ccCif.getGamma(),DELTA);
    if (ciPdb.getNcsOperators() == null) {
      assertTrue(ciCif.getNcsOperators() == null);
    }
 else {
      Matrix4d[] ncsOpersPdb=ciPdb.getNcsOperators();
      Matrix4d[] ncsOpersCif=ciCif.getNcsOperators();
      assertEquals(""String_Node_Str"",ncsOpersPdb.length,ncsOpersCif.length);
      for (int i=0; i < ncsOpersPdb.length; i++) {
        assertTrue(""String_Node_Str"" + i + ""String_Node_Str"",ncsOpersPdb[i].epsilonEquals(ncsOpersCif[i],0.0001));
      }
    }
  }
}","private void testHeader(Structure sPdb,Structure sCif){
  PDBHeader hPdb=sPdb.getPDBHeader();
  PDBHeader hCif=sCif.getPDBHeader();
  boolean isNmr=sPdb.isNmr();
  boolean isCrystallographic=sPdb.isCrystallographic();
  assertNotNull(hPdb);
  assertNotNull(hCif);
  assertEquals(""String_Node_Str"",hPdb.getIdCode(),hCif.getIdCode());
  assertNotNull(""String_Node_Str"",hPdb.getAuthors());
  assertNotNull(""String_Node_Str"",hCif.getAuthors());
  assertTrue(""String_Node_Str"",hPdb.getAuthors().length() >= 2);
  assertNotNull(""String_Node_Str"",hPdb.getClassification());
  assertNotNull(""String_Node_Str"",hCif.getClassification());
  assertNotNull(""String_Node_Str"",hCif.getDescription());
  assertEquals(""String_Node_Str"",hPdb.getDepDate(),hCif.getDepDate());
  assertEquals(""String_Node_Str"",hPdb.getModDate(),hCif.getModDate());
  assertNotNull(hPdb.getExperimentalTechniques());
  assertNotNull(hCif.getExperimentalTechniques());
  assertTrue(hPdb.getExperimentalTechniques().size() > 0);
  assertEquals(""String_Node_Str"",hPdb.getExperimentalTechniques(),hCif.getExperimentalTechniques());
  if (!hPdb.getExperimentalTechniques().contains(ExperimentalTechnique.ELECTRON_CRYSTALLOGRAPHY) && !hPdb.getExperimentalTechniques().contains(ExperimentalTechnique.ELECTRON_MICROSCOPY)) {
    assertEquals(""String_Node_Str"",hPdb.getResolution(),hCif.getResolution(),DELTA_RESOLUTION);
  }
  assertNotNull(""String_Node_Str"",hPdb.getTitle());
  assertNotNull(""String_Node_Str"",hCif.getTitle());
  assertEquals(""String_Node_Str"",hPdb.getTitle().toLowerCase().replaceAll(""String_Node_Str"",""String_Node_Str""),hCif.getTitle().toLowerCase().replaceAll(""String_Node_Str"",""String_Node_Str""));
  if (isNmr) {
    assertEquals(""String_Node_Str"",PDBHeader.DEFAULT_RESOLUTION,hPdb.getResolution(),DELTA_RESOLUTION);
  }
  if (!isCrystallographic) {
    assertEquals(""String_Node_Str"",PDBHeader.DEFAULT_RFREE,DELTA_RFREE,hPdb.getRfree());
    assertEquals(""String_Node_Str"",PDBHeader.DEFAULT_RFREE,DELTA_RFREE,hCif.getRfree());
  }
  if (isCrystallographic) {
    assertEquals(""String_Node_Str"",hPdb.getRfree(),hCif.getRfree(),DELTA_RFREE);
    assertNotNull(""String_Node_Str"",hPdb.getCrystallographicInfo());
    assertNotNull(""String_Node_Str"",hCif.getCrystallographicInfo());
    PDBCrystallographicInfo ciPdb=hPdb.getCrystallographicInfo();
    PDBCrystallographicInfo ciCif=hCif.getCrystallographicInfo();
    assertNotNull(ciPdb.getSpaceGroup());
    assertNotNull(ciCif.getSpaceGroup());
    assertNotNull(""String_Node_Str"",ciPdb.getCrystalCell());
    assertNotNull(""String_Node_Str"",ciCif.getCrystalCell());
    CrystalCell ccPdb=ciPdb.getCrystalCell();
    CrystalCell ccCif=ciCif.getCrystalCell();
    assertEquals(""String_Node_Str"",ccPdb.getA(),ccCif.getA(),DELTA);
    assertEquals(""String_Node_Str"",ccPdb.getB(),ccCif.getB(),DELTA);
    assertEquals(""String_Node_Str"",ccPdb.getC(),ccCif.getC(),DELTA);
    assertEquals(""String_Node_Str"",ccPdb.getAlpha(),ccCif.getAlpha(),DELTA);
    assertEquals(""String_Node_Str"",ccPdb.getBeta(),ccCif.getBeta(),DELTA);
    assertEquals(""String_Node_Str"",ccPdb.getGamma(),ccCif.getGamma(),DELTA);
    if (ciPdb.getNcsOperators() == null) {
      assertTrue(ciCif.getNcsOperators() == null);
    }
 else {
      Matrix4d[] ncsOpersPdb=ciPdb.getNcsOperators();
      Matrix4d[] ncsOpersCif=ciCif.getNcsOperators();
      assertEquals(""String_Node_Str"",ncsOpersPdb.length,ncsOpersCif.length);
      for (int i=0; i < ncsOpersPdb.length; i++) {
        assertTrue(""String_Node_Str"" + i + ""String_Node_Str"",ncsOpersPdb[i].epsilonEquals(ncsOpersCif[i],0.0001));
      }
    }
  }
  if (isCrystallographic && hPdb.getCrystallographicInfo().getNcsOperators() == null && (!sPdb.getPDBCode().equalsIgnoreCase(""String_Node_Str"")) && (!sPdb.getPDBCode().equalsIgnoreCase(""String_Node_Str"")) && (!sPdb.getPDBCode().equalsIgnoreCase(""String_Node_Str""))) {
    assertEquals(""String_Node_Str"",hPdb.getNrBioAssemblies(),hCif.getNrBioAssemblies());
    Map<String,List<BiologicalAssemblyTransformation>> batPdb=hPdb.getBioUnitTranformationMap();
    Map<String,List<BiologicalAssemblyTransformation>> batCif=hCif.getBioUnitTranformationMap();
    assertEquals(""String_Node_Str"",hPdb.getNrBioAssemblies(),batPdb.size());
    assertEquals(""String_Node_Str"",batPdb.size(),batCif.size());
  }
}",0.9117162761241292
16866,"private Structure getCifStructure(String pdbId) throws IOException, StructureException {
  cache.setUseMmCif(true);
  params.setAlignSeqRes(true);
  return cache.getStructure(pdbId);
}","private Structure getCifStructure(String pdbId) throws IOException, StructureException {
  cache.setUseMmCif(true);
  params.setAlignSeqRes(true);
  params.setParseBioAssembly(true);
  return cache.getStructure(pdbId);
}",0.9108910891089108
16867,"private Structure getPdbStructure(String pdbId) throws IOException, StructureException {
  cache.setUseMmCif(false);
  params.setAlignSeqRes(true);
  return cache.getStructure(pdbId);
}","private Structure getPdbStructure(String pdbId) throws IOException, StructureException {
  cache.setUseMmCif(false);
  params.setAlignSeqRes(true);
  params.setParseBioAssembly(true);
  return cache.getStructure(pdbId);
}",0.9113300492610836
16868,"private void testChainRefs(Chain c){
  assertNotNull(c.getCompound());
  for (  Group g : c.getAtomGroups()) {
    assertSame(""String_Node_Str"" + g.toString(),c,g.getChain());
    for (    Atom a : g.getAtoms()) {
      assertSame(g,a.getGroup());
      assertSame(c,a.getGroup().getChain());
    }
    if (c.getSeqResGroups().size() > 0) {
      assertTrue(""String_Node_Str"" + g.toString(),c.getSeqResGroups().contains(g));
    }
  }
  for (  Group g : c.getSeqResGroups()) {
    assertSame(""String_Node_Str"" + g.toString(),c,g.getChain());
    for (    Atom a : g.getAtoms()) {
      assertSame(g,a.getGroup());
      assertSame(c,a.getGroup().getChain());
    }
  }
}","private void testChainRefs(Chain c){
  assertNotNull(c.getCompound());
  for (  Group g : c.getAtomGroups()) {
    assertSame(""String_Node_Str"" + g.toString(),c,g.getChain());
    for (    Atom a : g.getAtoms()) {
      assertSame(g,a.getGroup());
      assertSame(c,a.getGroup().getChain());
    }
    if (c.getSeqResGroups().size() > 0) {
      assertTrue(""String_Node_Str"" + g.toString(),containsReference(g,c.getSeqResGroups()));
    }
  }
  for (  Group g : c.getSeqResGroups()) {
    assertSame(""String_Node_Str"" + g.toString(),c,g.getChain());
    for (    Atom a : g.getAtoms()) {
      assertSame(g,a.getGroup());
      assertSame(c,a.getGroup().getChain());
    }
  }
}",0.9770200148257968
16869,"private void triggerEndFileChecks(){
  Date modDate=pdbHeader.getModDate();
  if (modDate.equals(new Date(0))) {
    Date depositionDate=pdbHeader.getDepDate();
    if (!depositionDate.equals(modDate)) {
      pdbHeader.setDepDate(depositionDate);
    }
  }
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
  if (!journalLines.isEmpty()) {
    buildjournalArticle();
    pdbHeader.setJournalArticle(journalArticle);
  }
  structure.addModel(current_model);
  structure.setPDBHeader(pdbHeader);
  structure.setCrystallographicInfo(crystallographicInfo);
  structure.setConnections(connects);
  structure.setDBRefs(dbrefs);
  if (params.isAlignSeqRes()) {
    logger.debug(""String_Node_Str"");
    SeqRes2AtomAligner aligner=new SeqRes2AtomAligner();
    aligner.align(structure,seqResChains);
  }
 else   if (params.getStoreEmptySeqRes()) {
    logger.debug(""String_Node_Str"");
    storeUnAlignedSeqRes(structure,seqResChains);
  }
  linkChains2Compound(structure);
  structure.setCompounds(compounds);
  linkSitesToGroups();
  if (bioAssemblyParser != null) {
    pdbHeader.setBioUnitTranformationMap(bioAssemblyParser.getTransformationMap());
    pdbHeader.setNrBioAssemblies(bioAssemblyParser.getNrBioAssemblies());
  }
  if (ncsOperators != null && ncsOperators.size() > 0) {
    crystallographicInfo.setNcsOperators((Matrix4d[])ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
  if (rfreeNoCutoffLine > 0 && rfreeStandardLine < 0) {
    pdbHeader.setRfree(rfreeNoCutoffLine);
  }
 else   if (rfreeNoCutoffLine > 0 && rfreeStandardLine > 0) {
    pdbHeader.setRfree(rfreeStandardLine);
  }
 else   if (rfreeNoCutoffLine < 0 && rfreeStandardLine > 0) {
    pdbHeader.setRfree(rfreeStandardLine);
  }
}","private void triggerEndFileChecks(){
  Date modDate=pdbHeader.getModDate();
  if (modDate.equals(new Date(0))) {
    Date depositionDate=pdbHeader.getDepDate();
    if (!depositionDate.equals(modDate)) {
      pdbHeader.setDepDate(depositionDate);
    }
  }
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
  if (!journalLines.isEmpty()) {
    buildjournalArticle();
    pdbHeader.setJournalArticle(journalArticle);
  }
  structure.addModel(current_model);
  structure.setPDBHeader(pdbHeader);
  structure.setCrystallographicInfo(crystallographicInfo);
  structure.setConnections(connects);
  structure.setDBRefs(dbrefs);
  if (params.isAlignSeqRes()) {
    logger.debug(""String_Node_Str"");
    SeqRes2AtomAligner aligner=new SeqRes2AtomAligner();
    aligner.align(structure,seqResChains);
  }
 else   if (params.getStoreEmptySeqRes()) {
    logger.debug(""String_Node_Str"");
    storeUnAlignedSeqRes(structure,seqResChains);
  }
  linkChains2Compound(structure);
  structure.setCompounds(compounds);
  linkSitesToGroups();
  if (bioAssemblyParser != null) {
    pdbHeader.setBioUnitTranformationMap(bioAssemblyParser.getTransformationMap());
    pdbHeader.setNrBioAssemblies(bioAssemblyParser.getNrBioAssemblies());
  }
  if (ncsOperators != null && ncsOperators.size() > 0) {
    crystallographicInfo.setNcsOperators((Matrix4d[])ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
  if (rfreeNoCutoffLine > 0 && rfreeStandardLine < 0) {
    pdbHeader.setRfree(rfreeNoCutoffLine);
  }
 else   if (rfreeNoCutoffLine > 0 && rfreeStandardLine > 0) {
    pdbHeader.setRfree(rfreeStandardLine);
  }
 else   if (rfreeNoCutoffLine < 0 && rfreeStandardLine > 0) {
    pdbHeader.setRfree(rfreeStandardLine);
  }
  structure.getCompounds();
}",0.992545260915868
16870,"public void documentEnd(){
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  structure.addModel(current_model);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    asymId2entityId.put(asym.getId(),asym.getEntity_id());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setChainID(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    int eId=0;
    try {
      eId=Integer.parseInt(asym.getEntity_id());
    }
 catch (    NumberFormatException e) {
      logger.warn(""String_Node_Str"",asym.getEntity_id());
    }
    Entity e=getEntity(eId);
    for (    EntitySrcGen esg : entitySrcGens) {
      if (!esg.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESG(esg,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcNat esn : entitySrcNats) {
      if (!esn.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESN(esn,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcSyn ess : entitySrcSyns) {
      if (!ess.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESS(ess,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    Compound c=structure.getCompoundById(eId);
    if (c == null) {
      c=new Compound();
      c.setMolId(eId);
      if (e != null && e.getType().equals(""String_Node_Str"")) {
        if (e != null)         c.setMolName(e.getPdbx_description());
        structure.addCompound(c);
        logger.debug(""String_Node_Str"",eId,c.getMolName());
      }
    }
  }
  if (params.isAlignSeqRes()) {
    SeqRes2AtomAligner aligner=new SeqRes2AtomAligner();
    List<Chain> atomList=structure.getModel(0);
    for (    Chain seqResChain : seqResChains) {
      Chain atomChain=aligner.getMatchingAtomRes(seqResChain,atomList);
      List<Group> seqResGroups=seqResChain.getAtomGroups();
      for (int seqResPos=0; seqResPos < seqResGroups.size(); seqResPos++) {
        Group seqresG=seqResGroups.get(seqResPos);
        boolean found=false;
        for (        Group atomG : atomChain.getAtomGroups()) {
          int internalNr=getInternalNr(atomG);
          if (seqresG.getResidueNumber().getSeqNum() == internalNr) {
            seqResGroups.set(seqResPos,atomG);
            found=true;
            break;
          }
        }
        if (!found)         seqresG.setResidueNumber(null);
      }
      atomChain.setSeqResGroups(seqResGroups);
    }
  }
  addBonds();
  Set<String> asymIds=asymStrandId.keySet();
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> model=structure.getModel(i);
    List<Chain> pdbChains=new ArrayList<Chain>();
    for (    Chain chain : model) {
      for (      String asym : asymIds) {
        if (chain.getChainID().equals(asym)) {
          String newChainId=asymStrandId.get(asym);
          logger.debug(""String_Node_Str"",asym,chain.getAtomGroups().size(),newChainId);
          chain.setChainID(newChainId);
          chain.setInternalChainID(asym);
          for (          Group g : chain.getAtomGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          for (          Group g : chain.getSeqResGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          Chain known=isKnownChain(chain.getChainID(),pdbChains);
          if (known == null) {
            pdbChains.add(chain);
          }
 else {
            for (            Group g : chain.getAtomGroups()) {
              known.addGroup(g);
            }
          }
          break;
        }
      }
    }
    structure.setModel(i,pdbChains);
    for (    Chain chain : pdbChains) {
      String entityId=asymId2entityId.get(chain.getInternalChainID());
      int eId=Integer.parseInt(entityId);
      Compound compound=structure.getCompoundById(eId);
      if (compound == null) {
        logger.warn(""String_Node_Str"",eId,chain.getChainID(),chain.getInternalChainID());
      }
 else {
        logger.debug(""String_Node_Str"",chain.getChainID(),chain.getInternalChainID(),eId);
        compound.addChain(chain);
        chain.setCompound(compound);
      }
    }
  }
  PDBHeader header=structure.getPDBHeader();
  header.setNrBioAssemblies(strucAssemblies.size());
  Map<String,List<BiologicalAssemblyTransformation>> transformationMap=new HashMap<String,List<BiologicalAssemblyTransformation>>();
  for (  PdbxStructAssembly psa : strucAssemblies) {
    List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
    for (    PdbxStructAssemblyGen psag : strucAssemblyGens) {
      if (psag.getAssembly_id().equals(psa.getId())) {
        psags.add(psag);
      }
    }
    BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
    List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
    transformationMap.put(psa.getId(),transformations);
  }
  structure.getPDBHeader().setBioUnitTranformationMap(transformationMap);
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators((Matrix4d[])ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
}","public void documentEnd(){
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  structure.addModel(current_model);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    asymId2entityId.put(asym.getId(),asym.getEntity_id());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setChainID(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    int eId=0;
    try {
      eId=Integer.parseInt(asym.getEntity_id());
    }
 catch (    NumberFormatException e) {
      logger.warn(""String_Node_Str"",asym.getEntity_id());
    }
    Entity e=getEntity(eId);
    for (    EntitySrcGen esg : entitySrcGens) {
      if (!esg.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESG(esg,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcNat esn : entitySrcNats) {
      if (!esn.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESN(esn,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcSyn ess : entitySrcSyns) {
      if (!ess.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESS(ess,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    Compound c=structure.getCompoundById(eId);
    if (c == null) {
      c=new Compound();
      c.setMolId(eId);
      if (e != null && e.getType().equals(""String_Node_Str"")) {
        if (e != null)         c.setMolName(e.getPdbx_description());
        structure.addCompound(c);
        logger.debug(""String_Node_Str"",eId,c.getMolName());
      }
    }
  }
  if (params.isAlignSeqRes()) {
    SeqRes2AtomAligner aligner=new SeqRes2AtomAligner();
    List<Chain> atomList=structure.getModel(0);
    for (    Chain seqResChain : seqResChains) {
      Chain atomChain=aligner.getMatchingAtomRes(seqResChain,atomList);
      List<Group> seqResGroups=seqResChain.getAtomGroups();
      for (int seqResPos=0; seqResPos < seqResGroups.size(); seqResPos++) {
        Group seqresG=seqResGroups.get(seqResPos);
        boolean found=false;
        for (        Group atomG : atomChain.getAtomGroups()) {
          int internalNr=getInternalNr(atomG);
          if (seqresG.getResidueNumber().getSeqNum() == internalNr) {
            seqResGroups.set(seqResPos,atomG);
            found=true;
            break;
          }
        }
        if (!found)         seqresG.setResidueNumber(null);
      }
      atomChain.setSeqResGroups(seqResGroups);
    }
  }
  addBonds();
  Set<String> asymIds=asymStrandId.keySet();
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> model=structure.getModel(i);
    List<Chain> pdbChains=new ArrayList<Chain>();
    for (    Chain chain : model) {
      for (      String asym : asymIds) {
        if (chain.getChainID().equals(asym)) {
          String newChainId=asymStrandId.get(asym);
          logger.debug(""String_Node_Str"",asym,chain.getAtomGroups().size(),newChainId);
          chain.setChainID(newChainId);
          chain.setInternalChainID(asym);
          for (          Group g : chain.getAtomGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          for (          Group g : chain.getSeqResGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          Chain known=isKnownChain(chain.getChainID(),pdbChains);
          if (known == null) {
            pdbChains.add(chain);
          }
 else {
            for (            Group g : chain.getAtomGroups()) {
              known.addGroup(g);
            }
          }
          break;
        }
      }
    }
    structure.setModel(i,pdbChains);
    for (    Chain chain : pdbChains) {
      String entityId=asymId2entityId.get(chain.getInternalChainID());
      int eId=Integer.parseInt(entityId);
      Compound compound=structure.getCompoundById(eId);
      if (compound == null) {
        logger.warn(""String_Node_Str"",eId,chain.getChainID(),chain.getInternalChainID());
      }
 else {
        logger.debug(""String_Node_Str"",chain.getChainID(),chain.getInternalChainID(),eId);
        compound.addChain(chain);
        chain.setCompound(compound);
      }
    }
  }
  PDBHeader header=structure.getPDBHeader();
  header.setNrBioAssemblies(strucAssemblies.size());
  Map<String,List<BiologicalAssemblyTransformation>> transformationMap=new HashMap<String,List<BiologicalAssemblyTransformation>>();
  for (  PdbxStructAssembly psa : strucAssemblies) {
    List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
    for (    PdbxStructAssemblyGen psag : strucAssemblyGens) {
      if (psag.getAssembly_id().equals(psa.getId())) {
        psags.add(psag);
      }
    }
    BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
    List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
    transformationMap.put(psa.getId(),transformations);
  }
  structure.getPDBHeader().setBioUnitTranformationMap(transformationMap);
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators((Matrix4d[])ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
  structure.getCompounds();
}",0.997930524759793
16871,"/** 
 * After the parsing of a PDB file the   {@link Chain} and  {@link Compound}objects need to be linked to each other.
 * @param s the structure
 */
public void linkChains2Compound(Structure s){
  List<Compound> compounds=s.getCompounds();
  for (  Compound comp : compounds) {
    List<Chain> chains=new ArrayList<Chain>();
    List<String> chainIds=comp.getChainIds();
    if (chainIds == null)     continue;
    for (    String chainId : chainIds) {
      if (chainId.equals(""String_Node_Str""))       chainId=""String_Node_Str"";
      try {
        Chain c=s.findChain(chainId);
        chains.add(c);
      }
 catch (      StructureException e) {
        e.printStackTrace();
      }
    }
    comp.setChains(chains);
  }
  if (compounds.size() == 1) {
    Compound comp=compounds.get(0);
    if (comp.getChainIds() == null) {
      List<Chain> chains=s.getChains(0);
      if (chains.size() == 1) {
        Chain ch=chains.get(0);
        List<String> chainIds=new ArrayList<String>();
        chainIds.add(ch.getChainID());
        comp.setChainIds(chainIds);
        comp.addChain(ch);
      }
    }
  }
  for (  Compound comp : compounds) {
    if (comp.getChainIds() == null) {
      continue;
    }
    for (    String chainId : comp.getChainIds()) {
      if (chainId.equals(""String_Node_Str""))       continue;
      try {
        Chain c=s.getChainByPDB(chainId);
        c.setCompound(comp);
      }
 catch (      StructureException e) {
        e.printStackTrace();
      }
    }
  }
}","/** 
 * After the parsing of a PDB file the   {@link Chain} and  {@link Compound}objects need to be linked to each other.
 * @param s the structure
 */
public void linkChains2Compound(Structure s){
  List<Compound> compounds=s.getCompounds();
  for (  Compound comp : compounds) {
    List<Chain> chains=new ArrayList<Chain>();
    List<String> chainIds=comp.getChainIds();
    if (chainIds == null)     continue;
    for (    String chainId : chainIds) {
      if (chainId.equals(""String_Node_Str""))       chainId=""String_Node_Str"";
      try {
        Chain c=s.findChain(chainId);
        chains.add(c);
      }
 catch (      StructureException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
    comp.setChains(chains);
  }
  if (compounds.size() == 1) {
    Compound comp=compounds.get(0);
    if (comp.getChainIds() == null) {
      List<Chain> chains=s.getChains(0);
      if (chains.size() == 1) {
        Chain ch=chains.get(0);
        List<String> chainIds=new ArrayList<String>();
        chainIds.add(ch.getChainID());
        comp.setChainIds(chainIds);
        comp.addChain(ch);
      }
    }
  }
  for (  Compound comp : compounds) {
    if (comp.getChainIds() == null) {
      continue;
    }
    for (    String chainId : comp.getChainIds()) {
      if (chainId.equals(""String_Node_Str""))       continue;
      try {
        Chain c=s.getChainByPDB(chainId);
        c.setCompound(comp);
      }
 catch (      StructureException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
  }
}",0.966996699669967
16872,"private Chain getChainFromList(List<Chain> chains,String name){
  for (  Chain chain : chains) {
    if (chain.getChainID().equals(name)) {
      return chain;
    }
  }
  Chain chain=new ChainImpl();
  chain.setChainID(name);
  chains.add(chain);
  return chain;
}","private static Chain getChainFromList(List<Chain> chains,String name){
  for (  Chain chain : chains) {
    if (chain.getChainID().equals(name)) {
      return chain;
    }
  }
  Chain chain=new ChainImpl();
  chain.setChainID(name);
  chains.add(chain);
  return chain;
}",0.9869646182495344
16873,"/** 
 * Start the parsing
 */
public void documentStart(){
  structure=new StructureImpl();
  current_chain=null;
  current_group=null;
  current_nmr_model=null;
  current_model=new ArrayList<Chain>();
  entities=new ArrayList<Entity>();
  strucRefs=new ArrayList<StructRef>();
  seqResChains=new ArrayList<Chain>();
  entityChains=new ArrayList<Chain>();
  structAsyms=new ArrayList<StructAsym>();
  asymStrandId=new HashMap<String,String>();
  structOpers=new ArrayList<PdbxStructOperList>();
  strucAssemblies=new ArrayList<PdbxStructAssembly>();
  strucAssemblyGens=new ArrayList<PdbxStructAssemblyGen>();
  entitySrcGens=new ArrayList<EntitySrcGen>();
  entitySrcNats=new ArrayList<EntitySrcNat>();
  entitySrcSyns=new ArrayList<EntitySrcSyn>();
  structConn=new ArrayList<StructConn>();
  structNcsOper=new ArrayList<StructNcsOper>();
}","/** 
 * Start the parsing
 */
public void documentStart(){
  structure=new StructureImpl();
  current_chain=null;
  current_group=null;
  current_nmr_model=null;
  current_model=new ArrayList<Chain>();
  entities=new ArrayList<Entity>();
  strucRefs=new ArrayList<StructRef>();
  seqResChains=new ArrayList<Chain>();
  entityChains=new ArrayList<Chain>();
  structAsyms=new ArrayList<StructAsym>();
  asymStrandId=new HashMap<String,String>();
  asymId2entityId=new HashMap<String,String>();
  structOpers=new ArrayList<PdbxStructOperList>();
  strucAssemblies=new ArrayList<PdbxStructAssembly>();
  strucAssemblyGens=new ArrayList<PdbxStructAssemblyGen>();
  entitySrcGens=new ArrayList<EntitySrcGen>();
  entitySrcNats=new ArrayList<EntitySrcNat>();
  entitySrcSyns=new ArrayList<EntitySrcSyn>();
  structConn=new ArrayList<StructConn>();
  structNcsOper=new ArrayList<StructNcsOper>();
}",0.9722863741339492
16874,"/** 
 * The EntityPolySeq object provide the amino acid sequence objects for the Entities. Later on the entities are mapped to the BioJava Chain and Compound objects.
 * @param epolseq the EntityPolySeq record for one amino acid
 */
public void newEntityPolySeq(EntityPolySeq epolseq){
  logger.debug(""String_Node_Str"" + epolseq);
  int eId=-1;
  try {
    eId=Integer.parseInt(epolseq.getEntity_id());
  }
 catch (  NumberFormatException e) {
    logger.warn(""String_Node_Str"" + e.getMessage());
  }
  Entity e=getEntity(eId);
  if (e == null) {
    logger.info(""String_Node_Str"" + epolseq.getEntity_id() + ""String_Node_Str"");
    return;
  }
  Chain entityChain=getEntityChain(epolseq.getEntity_id());
  AminoAcid g=new AminoAcidImpl();
  g.setRecordType(AminoAcid.SEQRESRECORD);
  try {
    if (epolseq.getMon_id().length() == 3) {
      g.setPDBName(epolseq.getMon_id());
      Character code1=StructureTools.convert_3code_1code(epolseq.getMon_id());
      g.setAminoType(code1);
      g.setResidueNumber(ResidueNumber.fromString(epolseq.getNum()));
      entityChain.addGroup(g);
    }
 else     if (StructureTools.isNucleotide(epolseq.getMon_id())) {
      NucleotideImpl n=new NucleotideImpl();
      n.setResidueNumber(ResidueNumber.fromString(epolseq.getNum()));
      n.setPDBName(epolseq.getMon_id());
      entityChain.addGroup(n);
    }
 else {
      HetatomImpl h=new HetatomImpl();
      h.setPDBName(epolseq.getMon_id());
      h.setResidueNumber(ResidueNumber.fromString(epolseq.getNum()));
      entityChain.addGroup(h);
    }
  }
 catch (  UnknownPdbAminoAcidException ex) {
    HetatomImpl h=new HetatomImpl();
    h.setPDBName(epolseq.getMon_id());
    h.setResidueNumber(ResidueNumber.fromString(epolseq.getNum()));
    entityChain.addGroup(h);
  }
}","/** 
 * The EntityPolySeq object provide the amino acid sequence objects for the Entities. Later on the entities are mapped to the BioJava Chain and Compound objects.
 * @param epolseq the EntityPolySeq record for one amino acid
 */
public void newEntityPolySeq(EntityPolySeq epolseq){
  logger.debug(""String_Node_Str"" + epolseq);
  int eId=-1;
  try {
    eId=Integer.parseInt(epolseq.getEntity_id());
  }
 catch (  NumberFormatException e) {
    logger.warn(""String_Node_Str"" + e.getMessage());
  }
  Entity e=getEntity(eId);
  if (e == null) {
    logger.info(""String_Node_Str"" + epolseq.getEntity_id() + ""String_Node_Str"");
    return;
  }
  Chain entityChain=getEntityChain(epolseq.getEntity_id());
  AminoAcid g=new AminoAcidImpl();
  g.setRecordType(AminoAcid.SEQRESRECORD);
  try {
    if (epolseq.getMon_id().length() == 3) {
      g.setPDBName(epolseq.getMon_id());
      Character code1=StructureTools.convert_3code_1code(epolseq.getMon_id());
      g.setAminoType(code1);
      g.setResidueNumber(ResidueNumber.fromString(epolseq.getNum()));
      entityChain.addGroup(g);
    }
 else     if (StructureTools.isNucleotide(epolseq.getMon_id())) {
      NucleotideImpl n=new NucleotideImpl();
      n.setResidueNumber(ResidueNumber.fromString(epolseq.getNum()));
      n.setPDBName(epolseq.getMon_id());
      entityChain.addGroup(n);
    }
 else {
      HetatomImpl h=new HetatomImpl();
      h.setPDBName(epolseq.getMon_id());
      h.setResidueNumber(ResidueNumber.fromString(epolseq.getNum()));
      entityChain.addGroup(h);
    }
  }
 catch (  UnknownPdbAminoAcidException ex) {
    logger.debug(""String_Node_Str"",epolseq.getNum(),epolseq.getMon_id());
    HetatomImpl h=new HetatomImpl();
    h.setPDBName(epolseq.getMon_id());
    h.setResidueNumber(ResidueNumber.fromString(epolseq.getNum()));
    entityChain.addGroup(h);
  }
}",0.9795467108899945
16875,"public void newEntity(Entity entity){
  logger.debug(entity.toString());
  entities.add(entity);
}","public void newEntity(Entity entity){
  logger.debug(""String_Node_Str"",entity.toString());
  entities.add(entity);
}",0.9158878504672896
16876,"public void documentEnd(){
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
 else {
    logger.debug(""String_Node_Str"");
  }
  structure.addModel(current_model);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"" + asym.getEntity_id() + ""String_Node_Str""+ asym.getId());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setChainID(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    for (    EntitySrcGen esg : entitySrcGens) {
      String eId=esg.getEntity_id();
      if (!eId.equals(asym.getEntity_id()))       continue;
      int eIdInt=0;
      try {
        eIdInt=Integer.parseInt(eId);
      }
 catch (      NumberFormatException e) {
        logger.warn(""String_Node_Str"",eId);
      }
      Compound c=structure.getCompoundById(eIdInt);
      if (c == null) {
        c=createNewCompoundFromESG(esg,eIdInt);
        List<Compound> compounds=structure.getCompounds();
        compounds.add(c);
        structure.setCompounds(compounds);
      }
      c.addChain(s);
    }
    for (    EntitySrcNat esn : entitySrcNats) {
      String eId=esn.getEntity_id();
      if (!eId.equals(asym.getEntity_id()))       continue;
      int eIdInt=0;
      try {
        eIdInt=Integer.parseInt(eId);
      }
 catch (      NumberFormatException e) {
        logger.warn(""String_Node_Str"",eId);
      }
      Compound c=structure.getCompoundById(eIdInt);
      if (c == null) {
        c=createNewCompoundFromESN(esn,eIdInt);
        List<Compound> compounds=structure.getCompounds();
        compounds.add(c);
        structure.setCompounds(compounds);
      }
      c.addChain(s);
    }
    for (    EntitySrcSyn ess : entitySrcSyns) {
      String eId=ess.getEntity_id();
      if (!eId.equals(asym.getEntity_id()))       continue;
      int eIdInt=0;
      try {
        eIdInt=Integer.parseInt(eId);
      }
 catch (      NumberFormatException e) {
        logger.warn(""String_Node_Str"",eId);
      }
      Compound c=structure.getCompoundById(eIdInt);
      if (c == null) {
        c=createNewCompoundFromESS(ess,eIdInt);
        List<Compound> compounds=structure.getCompounds();
        compounds.add(c);
        structure.setCompounds(compounds);
      }
      c.addChain(s);
    }
  }
  if (params.isAlignSeqRes()) {
    SeqRes2AtomAligner aligner=new SeqRes2AtomAligner();
    List<Chain> atomList=structure.getModel(0);
    for (    Chain seqResChain : seqResChains) {
      Chain atomChain=aligner.getMatchingAtomRes(seqResChain,atomList);
      List<Group> seqResGroups=seqResChain.getAtomGroups();
      for (int seqResPos=0; seqResPos < seqResGroups.size(); seqResPos++) {
        Group seqresG=seqResGroups.get(seqResPos);
        boolean found=false;
        for (        Group atomG : atomChain.getAtomGroups()) {
          int internalNr=getInternalNr(atomG);
          if (seqresG.getResidueNumber().getSeqNum() == internalNr) {
            seqResGroups.set(seqResPos,atomG);
            found=true;
            break;
          }
        }
        if (!found)         seqresG.setResidueNumber(null);
      }
      atomChain.setSeqResGroups(seqResGroups);
    }
  }
  addBonds();
  Set<String> asymIds=asymStrandId.keySet();
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> model=structure.getModel(i);
    List<Chain> pdbChains=new ArrayList<Chain>();
    for (    Chain chain : model) {
      for (      String asym : asymIds) {
        if (chain.getChainID().equals(asym)) {
          String newChainId=asymStrandId.get(asym);
          logger.debug(""String_Node_Str"" + asym + ""String_Node_Str""+ newChainId);
          chain.setChainID(newChainId);
          chain.setInternalChainID(asym);
          for (          Group g : chain.getAtomGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          for (          Group g : chain.getSeqResGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          Chain known=isKnownChain(chain.getChainID(),pdbChains);
          if (known == null) {
            pdbChains.add(chain);
          }
 else {
            for (            Group g : chain.getAtomGroups()) {
              known.addGroup(g);
            }
          }
          break;
        }
      }
    }
    structure.setModel(i,pdbChains);
  }
  PDBHeader header=structure.getPDBHeader();
  header.setNrBioAssemblies(strucAssemblies.size());
  Map<String,List<BiologicalAssemblyTransformation>> transformationMap=new HashMap<String,List<BiologicalAssemblyTransformation>>();
  for (  PdbxStructAssembly psa : strucAssemblies) {
    List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
    for (    PdbxStructAssemblyGen psag : strucAssemblyGens) {
      if (psag.getAssembly_id().equals(psa.getId())) {
        psags.add(psag);
      }
    }
    BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
    List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
    transformationMap.put(psa.getId(),transformations);
  }
  structure.getPDBHeader().setBioUnitTranformationMap(transformationMap);
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators((Matrix4d[])ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
}","public void documentEnd(){
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  structure.addModel(current_model);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    asymId2entityId.put(asym.getId(),asym.getEntity_id());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setChainID(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    for (    EntitySrcGen esg : entitySrcGens) {
      String eId=esg.getEntity_id();
      if (!eId.equals(asym.getEntity_id()))       continue;
      int eIdInt=0;
      try {
        eIdInt=Integer.parseInt(eId);
      }
 catch (      NumberFormatException e) {
        logger.warn(""String_Node_Str"",eId);
      }
      Compound c=structure.getCompoundById(eIdInt);
      if (c == null) {
        c=createNewCompoundFromESG(esg,eIdInt);
        List<Compound> compounds=structure.getCompounds();
        compounds.add(c);
        logger.debug(""String_Node_Str"",eIdInt,c.getMolName());
      }
    }
    for (    EntitySrcNat esn : entitySrcNats) {
      String eId=esn.getEntity_id();
      if (!eId.equals(asym.getEntity_id()))       continue;
      int eIdInt=0;
      try {
        eIdInt=Integer.parseInt(eId);
      }
 catch (      NumberFormatException e) {
        logger.warn(""String_Node_Str"",eId);
      }
      Compound c=structure.getCompoundById(eIdInt);
      if (c == null) {
        c=createNewCompoundFromESN(esn,eIdInt);
        List<Compound> compounds=structure.getCompounds();
        compounds.add(c);
        logger.debug(""String_Node_Str"",eIdInt,c.getMolName());
      }
    }
    for (    EntitySrcSyn ess : entitySrcSyns) {
      String eId=ess.getEntity_id();
      if (!eId.equals(asym.getEntity_id()))       continue;
      int eIdInt=0;
      try {
        eIdInt=Integer.parseInt(eId);
      }
 catch (      NumberFormatException e) {
        logger.warn(""String_Node_Str"",eId);
      }
      Compound c=structure.getCompoundById(eIdInt);
      if (c == null) {
        c=createNewCompoundFromESS(ess,eIdInt);
        List<Compound> compounds=structure.getCompounds();
        compounds.add(c);
        logger.debug(""String_Node_Str"",eIdInt,c.getMolName());
      }
    }
    int eId=0;
    try {
      eId=Integer.parseInt(asym.getEntity_id());
    }
 catch (    NumberFormatException e) {
      logger.warn(""String_Node_Str"",asym.getEntity_id());
    }
    Compound c=structure.getCompoundById(eId);
    if (c == null) {
      c=new Compound();
      c.setMolId(eId);
      Entity e=getEntity(eId);
      if (e != null && e.getType().equals(""String_Node_Str"")) {
        if (e != null)         c.setMolName(e.getPdbx_description());
        List<Compound> compounds=structure.getCompounds();
        compounds.add(c);
        logger.debug(""String_Node_Str"",eId,c.getMolName());
      }
    }
  }
  if (params.isAlignSeqRes()) {
    SeqRes2AtomAligner aligner=new SeqRes2AtomAligner();
    List<Chain> atomList=structure.getModel(0);
    for (    Chain seqResChain : seqResChains) {
      Chain atomChain=aligner.getMatchingAtomRes(seqResChain,atomList);
      List<Group> seqResGroups=seqResChain.getAtomGroups();
      for (int seqResPos=0; seqResPos < seqResGroups.size(); seqResPos++) {
        Group seqresG=seqResGroups.get(seqResPos);
        boolean found=false;
        for (        Group atomG : atomChain.getAtomGroups()) {
          int internalNr=getInternalNr(atomG);
          if (seqresG.getResidueNumber().getSeqNum() == internalNr) {
            seqResGroups.set(seqResPos,atomG);
            found=true;
            break;
          }
        }
        if (!found)         seqresG.setResidueNumber(null);
      }
      atomChain.setSeqResGroups(seqResGroups);
    }
  }
  addBonds();
  Set<String> asymIds=asymStrandId.keySet();
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> model=structure.getModel(i);
    List<Chain> pdbChains=new ArrayList<Chain>();
    for (    Chain chain : model) {
      for (      String asym : asymIds) {
        if (chain.getChainID().equals(asym)) {
          String newChainId=asymStrandId.get(asym);
          logger.debug(""String_Node_Str"",asym,chain.getAtomGroups().size(),newChainId);
          chain.setChainID(newChainId);
          chain.setInternalChainID(asym);
          for (          Group g : chain.getAtomGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          for (          Group g : chain.getSeqResGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          Chain known=isKnownChain(chain.getChainID(),pdbChains);
          if (known == null) {
            pdbChains.add(chain);
          }
 else {
            for (            Group g : chain.getAtomGroups()) {
              known.addGroup(g);
            }
          }
          break;
        }
      }
    }
    structure.setModel(i,pdbChains);
    for (    Chain chain : pdbChains) {
      String entityId=asymId2entityId.get(chain.getInternalChainID());
      int eId=Integer.parseInt(entityId);
      Compound compound=structure.getCompoundById(eId);
      logger.debug(""String_Node_Str"",chain.getChainID(),chain.getInternalChainID(),eId);
      compound.addChain(chain);
      chain.setCompound(compound);
    }
  }
  PDBHeader header=structure.getPDBHeader();
  header.setNrBioAssemblies(strucAssemblies.size());
  Map<String,List<BiologicalAssemblyTransformation>> transformationMap=new HashMap<String,List<BiologicalAssemblyTransformation>>();
  for (  PdbxStructAssembly psa : strucAssemblies) {
    List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
    for (    PdbxStructAssemblyGen psag : strucAssemblyGens) {
      if (psag.getAssembly_id().equals(psa.getId())) {
        psags.add(psag);
      }
    }
    BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
    List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
    transformationMap.put(psa.getId(),transformations);
  }
  structure.getPDBHeader().setBioUnitTranformationMap(transformationMap);
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators((Matrix4d[])ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
}",0.2730417403336151
16877,"public void parse(BufferedReader buf) throws IOException {
  triggerDocumentStart();
  struct=new Struct();
  String line=null;
  boolean inLoop=false;
  List<String> loopFields=new ArrayList<String>();
  List<String> lineData=new ArrayList<String>();
  Set<String> loopWarnings=new HashSet<String>();
  String category=null;
  line=buf.readLine();
  if (!line.startsWith(""String_Node_Str"")) {
    logger.error(""String_Node_Str"" + line);
    triggerDocumentEnd();
    return;
  }
  while ((line=buf.readLine()) != null) {
    if (inLoop) {
      if (line.startsWith(LOOP_END)) {
        inLoop=false;
        lineData.clear();
        category=null;
        loopFields.clear();
        loopWarnings.clear();
        continue;
      }
      if (line.startsWith(FIELD_LINE)) {
        String txt=line.trim();
        if (txt.indexOf('.') > -1) {
          String[] spl=txt.split(""String_Node_Str"");
          category=spl[0];
          String attribute=spl[1];
          loopFields.add(attribute);
          if (spl.length > 2) {
            logger.warn(""String_Node_Str"");
          }
        }
 else {
          category=txt;
        }
      }
 else {
        lineData=processLine(line,buf,loopFields.size());
        if (lineData.size() != loopFields.size()) {
          logger.warn(""String_Node_Str"");
        }
        endLineChecks(category,loopFields,lineData,loopWarnings);
        lineData.clear();
      }
    }
 else {
      if (line.startsWith(LOOP_START)) {
        loopFields.clear();
        loopWarnings.clear();
        inLoop=true;
        category=null;
        lineData.clear();
        continue;
      }
 else       if (line.startsWith(LOOP_END)) {
        inLoop=false;
        if (category != null)         endLineChecks(category,loopFields,lineData,loopWarnings);
        category=null;
        loopFields.clear();
        loopWarnings.clear();
        lineData.clear();
      }
 else {
        List<String> data=processLine(line,buf,2);
        if (data.size() < 1) {
          lineData.clear();
          continue;
        }
        String key=data.get(0);
        int pos=key.indexOf(""String_Node_Str"");
        if (pos < 0) {
          if (!line.startsWith(""String_Node_Str"")) {
            logger.warn(""String_Node_Str"" + line);
            triggerDocumentEnd();
            return;
          }
          category=null;
          lineData.clear();
          continue;
        }
        category=key.substring(0,pos);
        String value=data.get(1);
        loopFields.add(key.substring(pos + 1,key.length()));
        lineData.add(value);
      }
    }
  }
  if (struct != null) {
    triggerStructData(struct);
  }
  triggerDocumentEnd();
}","public void parse(BufferedReader buf) throws IOException {
  triggerDocumentStart();
  struct=new Struct();
  String line=null;
  boolean inLoop=false;
  List<String> loopFields=new ArrayList<String>();
  List<String> lineData=new ArrayList<String>();
  Set<String> loopWarnings=new HashSet<String>();
  String category=null;
  line=buf.readLine();
  if (!line.startsWith(""String_Node_Str"")) {
    logger.error(""String_Node_Str"" + line);
    triggerDocumentEnd();
    return;
  }
  while ((line=buf.readLine()) != null) {
    logger.debug(inLoop + ""String_Node_Str"" + line);
    if (inLoop) {
      if (line.startsWith(LOOP_END)) {
        inLoop=false;
        lineData.clear();
        category=null;
        loopFields.clear();
        loopWarnings.clear();
        continue;
      }
      if (line.startsWith(FIELD_LINE)) {
        String txt=line.trim();
        if (txt.indexOf('.') > -1) {
          String[] spl=txt.split(""String_Node_Str"");
          category=spl[0];
          String attribute=spl[1];
          loopFields.add(attribute);
          if (spl.length > 2) {
            logger.warn(""String_Node_Str"");
          }
        }
 else {
          category=txt;
        }
      }
 else {
        lineData=processLine(line,buf,loopFields.size());
        if (lineData.size() != loopFields.size()) {
          logger.warn(""String_Node_Str"");
        }
        endLineChecks(category,loopFields,lineData,loopWarnings);
        lineData.clear();
      }
    }
 else {
      if (line.startsWith(LOOP_START)) {
        loopFields.clear();
        loopWarnings.clear();
        inLoop=true;
        category=null;
        lineData.clear();
        continue;
      }
 else       if (line.startsWith(LOOP_END)) {
        inLoop=false;
        if (category != null)         endLineChecks(category,loopFields,lineData,loopWarnings);
        category=null;
        loopFields.clear();
        loopWarnings.clear();
        lineData.clear();
      }
 else {
        List<String> data=processLine(line,buf,2);
        if (data.size() < 1) {
          lineData.clear();
          continue;
        }
        String key=data.get(0);
        int pos=key.indexOf(""String_Node_Str"");
        if (pos < 0) {
          if (!line.startsWith(""String_Node_Str"")) {
            logger.warn(""String_Node_Str"" + line);
            triggerDocumentEnd();
            return;
          }
          category=null;
          lineData.clear();
          continue;
        }
        category=key.substring(0,pos);
        String value=data.get(1);
        loopFields.add(key.substring(pos + 1,key.length()));
        lineData.add(value);
      }
    }
  }
  if (struct != null) {
    triggerStructData(struct);
  }
  triggerDocumentEnd();
}",0.990172445763026
16878,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public String toString(){
  StringBuffer buf=new StringBuffer();
  buf.append(this.getClass().getName()).append(""String_Node_Str"");
  try {
    Class c=this.getClass();
    Method[] methods=c.getMethods();
    for (int i=0; i < methods.length; i++) {
      Method m=methods[i];
      String name=m.getName();
      if (name.substring(0,3).equals(""String_Node_Str"")) {
        Object o=m.invoke(this,new Object[]{});
        if (o instanceof String) {
          buf.append(name.substring(3,name.length()) + ""String_Node_Str"" + o+ ""String_Node_Str"");
        }
 else         if (o instanceof List) {
          buf.append(name.substring(3,name.length())).append(""String_Node_Str"");
          List<Object> lst=(List<Object>)o;
          for (          Object obj : lst) {
            if (obj instanceof Chain) {
              continue;
            }
            buf.append(obj).append(""String_Node_Str"");
          }
        }
 else {
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return buf.toString();
}","@SuppressWarnings({""String_Node_Str""}) public String toString(){
  StringBuffer buf=new StringBuffer();
  buf.append(this.getClass().getName()).append(""String_Node_Str"");
  try {
    Class<? extends AbstractBean> c=this.getClass();
    Method[] methods=c.getMethods();
    for (int i=0; i < methods.length; i++) {
      Method m=methods[i];
      String name=m.getName();
      if (name.substring(0,3).equals(""String_Node_Str"")) {
        Object o=m.invoke(this,new Object[]{});
        if (o instanceof String) {
          buf.append(name.substring(3,name.length()) + ""String_Node_Str"" + o+ ""String_Node_Str"");
        }
 else         if (o instanceof List) {
          buf.append(name.substring(3,name.length())).append(""String_Node_Str"");
          List<Object> lst=(List<Object>)o;
          for (          Object obj : lst) {
            if (obj instanceof Chain) {
              continue;
            }
            buf.append(obj).append(""String_Node_Str"");
          }
        }
 else {
        }
      }
    }
  }
 catch (  InvocationTargetException e) {
    logger.error(""String_Node_Str"",e);
  }
catch (  IllegalAccessException e) {
    logger.error(""String_Node_Str"",e);
  }
  return buf.toString();
}",0.770363951473137
16879,"/** 
 * @param args
 */
public static void main(String[] args) throws Exception {
  String pdbCode=""String_Node_Str"";
  AtomCache cache=new AtomCache();
  cache.setUseMmCif(true);
  StructureIO.setAtomCache(cache);
  Structure structure=StructureIO.getStructure(pdbCode);
  System.out.println(structure.getPDBCode());
  SpaceGroup sg=structure.getCrystallographicInfo().getSpaceGroup();
  if (sg != null) {
    System.out.println(sg.getShortSymbol() + ""String_Node_Str"" + sg.getId()+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + sg.getNumOperators());
  }
  System.out.println(""String_Node_Str"" + NTHREADS + ""String_Node_Str"");
  long start=System.currentTimeMillis();
  CrystalBuilder cb=new CrystalBuilder(structure);
  StructureInterfaceList interfaces=cb.getUniqueInterfaces(CUTOFF);
  interfaces.calcAsas(N_SPHERE_POINTS,NTHREADS,CONSIDER_COFACTORS);
  interfaces.removeInterfacesBelowArea(MIN_AREA_TO_KEEP);
  List<StructureInterfaceCluster> clusters=interfaces.getClusters();
  long end=System.currentTimeMillis();
  long total=(end - start) / 1000;
  System.out.println(""String_Node_Str"" + total + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + interfaces.size());
  for (int i=0; i < interfaces.size(); i++) {
    StructureInterface interf=interfaces.get(i + 1);
    String infiniteStr=""String_Node_Str"";
    if (interf.isInfinite())     infiniteStr=""String_Node_Str"";
    System.out.println(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ interf.getCrystalIds().getFirst()+ ""String_Node_Str""+ interf.getCrystalIds().getSecond()+ infiniteStr);
    List<AtomContact> clashing=interf.getContacts().getContactsWithinDistance(CLASH_DISTANCE);
    if (clashing.size() > 10)     System.out.println(clashing.size() + ""String_Node_Str"");
    CrystalTransform transf1=interf.getTransforms().getFirst();
    CrystalTransform transf2=interf.getTransforms().getSecond();
    System.out.println(""String_Node_Str"" + SpaceGroup.getAlgebraicFromMatrix(transf1.getMatTransform()) + ""String_Node_Str""+ SpaceGroup.getAlgebraicFromMatrix(transf2.getMatTransform()));
    int foldType=sg.getAxisFoldType(transf2.getTransformId());
    AxisAngle4d axisAngle=sg.getRotAxisAngle(transf2.getTransformId());
    String screwStr=""String_Node_Str"";
    if (transf2.getTransformType().isScrew()) {
      Vector3d screwTransl=transf2.getTranslScrewComponent();
      screwStr=""String_Node_Str"" + transf2.getTransformType().getShortName() + ""String_Node_Str""+ String.format(""String_Node_Str"",screwTransl.x,screwTransl.y,screwTransl.z);
    }
    System.out.println(""String_Node_Str"" + foldType + ""String_Node_Str""+ String.format(""String_Node_Str"",axisAngle.x,axisAngle.y,axisAngle.z)+ screwStr);
    System.out.println(""String_Node_Str"" + interf.getContacts().size());
    Pair<List<Group>> cores=interf.getCoreResidues(BSATOASA_CUTOFF,MIN_ASA_FOR_SURFACE);
    System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",BSATOASA_CUTOFF) + ""String_Node_Str""+ cores.getFirst().size()+ ""String_Node_Str""+ cores.getSecond().size());
    System.out.printf(""String_Node_Str"",interf.getTotalArea());
  }
  System.out.println(""String_Node_Str"");
  for (  StructureInterfaceCluster cluster : clusters) {
    for (    StructureInterface member : cluster.getMembers()) {
      System.out.print(member.getId() + ""String_Node_Str"");
    }
    System.out.println();
  }
}","/** 
 * @param args
 */
public static void main(String[] args) throws Exception {
  String pdbCode=""String_Node_Str"";
  AtomCache cache=new AtomCache();
  cache.setUseMmCif(true);
  StructureIO.setAtomCache(cache);
  Structure structure=StructureIO.getStructure(pdbCode);
  System.out.println(structure.getPDBCode());
  SpaceGroup sg=structure.getCrystallographicInfo().getSpaceGroup();
  if (sg != null) {
    System.out.println(sg.getShortSymbol() + ""String_Node_Str"" + sg.getId()+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + sg.getNumOperators());
  }
  System.out.println(""String_Node_Str"" + NTHREADS + ""String_Node_Str"");
  long start=System.currentTimeMillis();
  CrystalBuilder cb=new CrystalBuilder(structure);
  StructureInterfaceList interfaces=cb.getUniqueInterfaces(CUTOFF);
  interfaces.calcAsas(N_SPHERE_POINTS,NTHREADS,CONSIDER_COFACTORS);
  interfaces.removeInterfacesBelowArea(MIN_AREA_TO_KEEP);
  List<StructureInterfaceCluster> clusters=interfaces.getClusters();
  long end=System.currentTimeMillis();
  long total=(end - start) / 1000;
  System.out.println(""String_Node_Str"" + total + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + interfaces.size());
  for (int i=0; i < interfaces.size(); i++) {
    StructureInterface interf=interfaces.get(i + 1);
    String infiniteStr=""String_Node_Str"";
    if (interf.isInfinite())     infiniteStr=""String_Node_Str"";
    System.out.println(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ interf.getCrystalIds().getFirst()+ ""String_Node_Str""+ interf.getCrystalIds().getSecond()+ infiniteStr);
    List<AtomContact> clashing=interf.getContacts().getContactsWithinDistance(CLASH_DISTANCE);
    if (clashing.size() > 10)     System.out.println(clashing.size() + ""String_Node_Str"");
    CrystalTransform transf1=interf.getTransforms().getFirst();
    CrystalTransform transf2=interf.getTransforms().getSecond();
    System.out.println(""String_Node_Str"" + SpaceGroup.getAlgebraicFromMatrix(transf1.getMatTransform()) + ""String_Node_Str""+ SpaceGroup.getAlgebraicFromMatrix(transf2.getMatTransform()));
    String screwStr=""String_Node_Str"";
    if (transf2.getTransformType().isScrew()) {
      Vector3d screwTransl=transf2.getTranslScrewComponent();
      screwStr=""String_Node_Str"" + transf2.getTransformType().getShortName() + ""String_Node_Str""+ String.format(""String_Node_Str"",screwTransl.x,screwTransl.y,screwTransl.z);
    }
    if (structure.isCrystallographic()) {
      int foldType=sg.getAxisFoldType(transf2.getTransformId());
      AxisAngle4d axisAngle=sg.getRotAxisAngle(transf2.getTransformId());
      System.out.println(""String_Node_Str"" + foldType + ""String_Node_Str""+ String.format(""String_Node_Str"",axisAngle.x,axisAngle.y,axisAngle.z)+ screwStr);
    }
    System.out.println(""String_Node_Str"" + interf.getContacts().size());
    Pair<List<Group>> cores=interf.getCoreResidues(BSATOASA_CUTOFF,MIN_ASA_FOR_SURFACE);
    System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",BSATOASA_CUTOFF) + ""String_Node_Str""+ cores.getFirst().size()+ ""String_Node_Str""+ cores.getSecond().size());
    System.out.printf(""String_Node_Str"",interf.getTotalArea());
  }
  System.out.println(""String_Node_Str"");
  for (  StructureInterfaceCluster cluster : clusters) {
    for (    StructureInterface member : cluster.getMembers()) {
      System.out.print(member.getId() + ""String_Node_Str"");
    }
    System.out.println();
  }
}",0.8720657276995305
16880,"/** 
 * returns and identical copy of this Group object .
 * @return  and identical copy of this Group object
 */
public Object clone(){
  AminoAcidImpl n=new AminoAcidImpl();
  n.setPDBFlag(has3D());
  n.setResidueNumber(getResidueNumber());
  n.setPDBName(getPDBName());
  n.setAminoType(getAminoType());
  n.setRecordType(recordType);
  for (int i=0; i < atoms.size(); i++) {
    Atom atom=(Atom)atoms.get(i);
    n.addAtom((Atom)atom.clone());
  }
  return n;
}","/** 
 * returns and identical copy of this Group object .
 * @return  and identical copy of this Group object
 */
public Object clone(){
  AminoAcidImpl n=new AminoAcidImpl();
  n.setPDBFlag(has3D());
  n.setResidueNumber(getResidueNumber());
  n.setPDBName(getPDBName());
  n.setAminoType(getAminoType());
  n.setRecordType(recordType);
  for (int i=0; i < atoms.size(); i++) {
    Atom atom=(Atom)atoms.get(i).clone();
    n.addAtom(atom);
    atom.setGroup(n);
  }
  return n;
}",0.9112050739957716
16881,"/** 
 * Returns an identical copy of this Chain .
 * @return an identical copy of this Chain
 */
public Object clone(){
  ChainImpl n=new ChainImpl();
  n.setChainID(getChainID());
  n.setSwissprotId(getSwissprotId());
  n.setCompound(this.getCompound());
  n.setInternalChainID(internalChainID);
  for (int i=0; i < groups.size(); i++) {
    Group g=groups.get(i);
    n.addGroup((Group)g.clone());
  }
  if (seqResGroups.size() > 0) {
    List<Group> tmpSeqRes=new ArrayList<Group>();
    for (int i=0; i < seqResGroups.size(); i++) {
      Group g=(Group)seqResGroups.get(i).clone();
      tmpSeqRes.add(g);
    }
    Chain tmp=new ChainImpl();
    tmp.setAtomGroups(tmpSeqRes);
    SeqRes2AtomAligner seqresaligner=new SeqRes2AtomAligner();
    seqresaligner.mapSeqresRecords(n,tmp);
  }
  return n;
}","/** 
 * Returns an identical copy of this Chain .
 * @return an identical copy of this Chain
 */
public Object clone(){
  ChainImpl n=new ChainImpl();
  n.setChainID(getChainID());
  n.setSwissprotId(getSwissprotId());
  n.setCompound(this.mol);
  n.setInternalChainID(internalChainID);
  for (int i=0; i < groups.size(); i++) {
    Group g=(Group)groups.get(i).clone();
    n.addGroup(g);
    g.setChain(n);
  }
  if (seqResGroups.size() > 0) {
    List<Group> tmpSeqRes=new ArrayList<Group>();
    for (int i=0; i < seqResGroups.size(); i++) {
      Group g=(Group)seqResGroups.get(i).clone();
      g.setChain(n);
      tmpSeqRes.add(g);
    }
    Chain tmp=new ChainImpl();
    tmp.setAtomGroups(tmpSeqRes);
    SeqRes2AtomAligner seqresaligner=new SeqRes2AtomAligner();
    seqresaligner.mapSeqresRecords(n,tmp);
  }
  return n;
}",0.9097560975609756
16882,"public Compound(){
  chains=new ArrayList<Chain>();
  molId=-1;
}","/** 
 * Constructs a new Compound copying all data from the given one but not setting the Chains
 * @param c
 */
public Compound(Compound c){
  this.chains=new ArrayList<Chain>();
  this.molId=c.molId;
  this.refChainId=c.refChainId;
  this.molName=c.molName;
  this.title=c.title;
  if (c.synonyms != null) {
    this.synonyms=new ArrayList<String>();
    synonyms.addAll(c.synonyms);
  }
  if (c.ecNums != null) {
    this.ecNums=new ArrayList<String>();
    ecNums.addAll(c.ecNums);
  }
  this.engineered=c.engineered;
  this.mutation=c.mutation;
  this.biologicalUnit=c.biologicalUnit;
  this.details=c.details;
  this.numRes=c.numRes;
  this.resNames=c.resNames;
  this.headerVars=c.headerVars;
  this.synthetic=c.synthetic;
  this.fragment=c.fragment;
  this.organismScientific=c.organismScientific;
  this.organismTaxId=c.organismTaxId;
  this.organismCommon=c.organismCommon;
  this.strain=c.strain;
  this.variant=c.variant;
  this.cellLine=c.cellLine;
  this.atcc=c.atcc;
  this.organ=c.organ;
  this.tissue=c.tissue;
  this.cell=c.cell;
  this.organelle=c.organelle;
  this.secretion=c.secretion;
  this.gene=c.gene;
  this.cellularLocation=c.cellularLocation;
  this.expressionSystem=c.expressionSystem;
  this.expressionSystemTaxId=c.expressionSystemTaxId;
  this.expressionSystemStrain=c.expressionSystemStrain;
  this.expressionSystemVariant=c.expressionSystemVariant;
  this.expressionSystemCellLine=c.expressionSystemCellLine;
  this.expressionSystemAtccNumber=c.expressionSystemAtccNumber;
  this.expressionSystemOrgan=c.expressionSystemOrgan;
  this.expressionSystemTissue=c.expressionSystemTissue;
  this.expressionSystemCell=c.expressionSystemCell;
  this.expressionSystemOrganelle=c.expressionSystemOrganelle;
  this.expressionSystemCellularLocation=c.expressionSystemCellularLocation;
  this.expressionSystemVectorType=c.expressionSystemVectorType;
  this.expressionSystemVector=c.expressionSystemVector;
  this.expressionSystemPlasmid=c.expressionSystemPlasmid;
  this.expressionSystemGene=c.expressionSystemGene;
  this.expressionSystemOtherDetails=c.expressionSystemOtherDetails;
}",0.0515653775322283
16883,"/** 
 * returns and identical copy of this Group object .
 * @return  and identical copy of this Group object
 */
public Object clone(){
  HetatomImpl n=new HetatomImpl();
  n.setPDBFlag(has3D());
  n.setResidueNumber(residueNumber);
  n.setPDBName(getPDBName());
  for (int i=0; i < atoms.size(); i++) {
    Atom atom=atoms.get(i);
    n.addAtom((Atom)atom.clone());
  }
  return n;
}","/** 
 * returns and identical copy of this Group object .
 * @return  and identical copy of this Group object
 */
public Object clone(){
  HetatomImpl n=new HetatomImpl();
  n.setPDBFlag(has3D());
  n.setResidueNumber(residueNumber);
  n.setPDBName(getPDBName());
  for (int i=0; i < atoms.size(); i++) {
    Atom atom=(Atom)atoms.get(i).clone();
    n.addAtom(atom);
    atom.setGroup(n);
  }
  return n;
}",0.9267676767676768
16884,"public Object clone(){
  NucleotideImpl n=new NucleotideImpl();
  n.setPDBFlag(has3D());
  n.setResidueNumber(getResidueNumber());
  n.setPDBName(getPDBName());
  for (int i=0; i < atoms.size(); i++) {
    Atom atom=(Atom)atoms.get(i);
    n.addAtom((Atom)atom.clone());
  }
  return n;
}","public Object clone(){
  NucleotideImpl n=new NucleotideImpl();
  n.setPDBFlag(has3D());
  n.setResidueNumber(getResidueNumber());
  n.setPDBName(getPDBName());
  for (int i=0; i < atoms.size(); i++) {
    Atom atom=(Atom)atoms.get(i).clone();
    n.addAtom(atom);
    atom.setGroup(n);
  }
  return n;
}",0.9121621621621622
16885,"/** 
 * returns an identical copy of this structure .
 * @return an identical Structure object
 */
public Structure clone(){
  Structure n=new StructureImpl();
  n.setPDBCode(getPDBCode());
  n.setName(getName());
  n.setPDBHeader(pdbHeader);
  n.setDBRefs(this.getDBRefs());
  n.setConnections(getConnections());
  n.setSites(getSites());
  n.setCrystallographicInfo(getCrystallographicInfo());
  for (int i=0; i < nrModels(); i++) {
    List<Chain> cloned_model=new ArrayList<Chain>();
    for (int j=0; j < size(i); j++) {
      Chain current_chain=(Chain)getChain(i,j);
      Chain cloned_chain=(Chain)current_chain.clone();
      cloned_model.add(cloned_chain);
    }
    n.addModel(cloned_model);
  }
  for (  SSBond ssbond : ssbonds) {
    n.addSSBond(ssbond.clone());
  }
  return n;
}","public Structure clone(){
  Structure n=new StructureImpl();
  n.setPDBCode(getPDBCode());
  n.setName(getName());
  n.setPDBHeader(pdbHeader);
  n.setDBRefs(this.getDBRefs());
  n.setConnections(getConnections());
  n.setSites(getSites());
  for (int i=0; i < nrModels(); i++) {
    List<Chain> cloned_model=new ArrayList<Chain>();
    for (int j=0; j < size(i); j++) {
      Chain cloned_chain=(Chain)getChain(i,j).clone();
      cloned_chain.setParent(n);
      cloned_model.add(cloned_chain);
    }
    n.addModel(cloned_model);
  }
  List<Compound> newCompoundList=new ArrayList<Compound>();
  for (  Compound compound : this.compounds) {
    Compound newCompound=new Compound(compound);
    for (    String chainId : compound.getChainIds()) {
      try {
        Chain newChain=n.getChainByPDB(chainId);
        newChain.setCompound(newCompound);
        newCompound.addChain(newChain);
      }
 catch (      StructureException e) {
        logger.error(""String_Node_Str"");
      }
    }
    newCompoundList.add(newCompound);
  }
  n.setCompounds(newCompoundList);
  for (  SSBond ssbond : ssbonds) {
    n.addSSBond(ssbond.clone());
  }
  return n;
}",0.5384615384615384
16886,"public void basicLoad(){
  try {
    PDBFileReader reader=new PDBFileReader();
    reader.setPath(""String_Node_Str"");
    reader.setPdbDirectorySplit(true);
    reader.setAutoFetch(true);
    FileParsingParameters params=new FileParsingParameters();
    params.setAlignSeqRes(true);
    params.setParseSecStruc(false);
    reader.setFileParsingParameters(params);
    Structure structure=reader.getStructureById(""String_Node_Str"");
    System.out.println(structure);
    Chain c=structure.getChainByPDB(""String_Node_Str"");
    System.out.print(c);
    System.out.println(c.getHeader());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void basicLoad(){
  try {
    PDBFileReader reader=new PDBFileReader();
    reader.setPath(""String_Node_Str"");
    reader.setPdbDirectorySplit(true);
    reader.setAutoFetch(true);
    FileParsingParameters params=new FileParsingParameters();
    params.setAlignSeqRes(true);
    params.setParseSecStruc(false);
    reader.setFileParsingParameters(params);
    Structure structure=reader.getStructureById(""String_Node_Str"");
    System.out.println(structure);
    Chain c=structure.getChainByPDB(""String_Node_Str"");
    System.out.print(c);
    System.out.println(c.getCompound());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9891808346213292
16887,"/** 
 * Returns an identical copy of this Chain .
 * @return an identical copy of this Chain
 */
public Object clone(){
  ChainImpl n=new ChainImpl();
  n.setChainID(getChainID());
  n.setSwissprotId(getSwissprotId());
  n.setHeader(this.getHeader());
  n.setInternalChainID(internalChainID);
  for (int i=0; i < groups.size(); i++) {
    Group g=(Group)groups.get(i);
    n.addGroup((Group)g.clone());
  }
  if (seqResGroups.size() > 0) {
    List<Group> tmpSeqRes=new ArrayList<Group>();
    for (int i=0; i < seqResGroups.size(); i++) {
      Group g=(Group)seqResGroups.get(i);
      tmpSeqRes.add(g);
    }
    Chain tmp=new ChainImpl();
    tmp.setAtomGroups(tmpSeqRes);
    SeqRes2AtomAligner seqresaligner=new SeqRes2AtomAligner();
    try {
      seqresaligner.mapSeqresRecords(n,tmp);
    }
 catch (    StructureException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  return n;
}","/** 
 * Returns an identical copy of this Chain .
 * @return an identical copy of this Chain
 */
public Object clone(){
  ChainImpl n=new ChainImpl();
  n.setChainID(getChainID());
  n.setSwissprotId(getSwissprotId());
  n.setCompound(this.getCompound());
  n.setInternalChainID(internalChainID);
  for (int i=0; i < groups.size(); i++) {
    Group g=(Group)groups.get(i);
    n.addGroup((Group)g.clone());
  }
  if (seqResGroups.size() > 0) {
    List<Group> tmpSeqRes=new ArrayList<Group>();
    for (int i=0; i < seqResGroups.size(); i++) {
      Group g=(Group)seqResGroups.get(i);
      tmpSeqRes.add(g);
    }
    Chain tmp=new ChainImpl();
    tmp.setAtomGroups(tmpSeqRes);
    SeqRes2AtomAligner seqresaligner=new SeqRes2AtomAligner();
    try {
      seqresaligner.mapSeqresRecords(n,tmp);
    }
 catch (    StructureException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  return n;
}",0.97452934662237
16888,"/** 
 * get the chains that are part of this Compound
 * @return a List of Chain objects
 */
public List<Chain> getChains(){
  return this.chainList;
}","/** 
 * Get the list of chains that are part of this Compound
 * @return a List of Chain objects
 */
public List<Chain> getChains(){
  return this.chains;
}",0.9576547231270358
16889,"public void addChain(Chain chain){
  this.chainList.add(chain);
}","/** 
 * Add new Chain to this Compound
 * @param chain
 */
public void addChain(Chain chain){
  this.chains.add(chain);
}",0.6666666666666666
16890,"/** 
 * Returns the ref chain id value.
 * @return the RefChainID
 * @see #setRefChainId(String)
 */
public String getRefChainId(){
  return refChainId;
}","/** 
 * Return the ref chain id value.
 * @return the RefChainID
 * @see #setRefChainId(String)
 */
public String getRefChainId(){
  return refChainId;
}",0.996742671009772
16891,"@SuppressWarnings(""String_Node_Str"") public String toString(){
  StringBuffer buf=new StringBuffer();
  buf.append(""String_Node_Str"" + molId + ""String_Node_Str""+ molName+ ""String_Node_Str"");
  try {
    @SuppressWarnings(""String_Node_Str"") Class c=Class.forName(""String_Node_Str"");
    Method[] methods=c.getMethods();
    for (int i=0; i < methods.length; i++) {
      Method m=methods[i];
      String name=m.getName();
      if (name.substring(0,3).equals(""String_Node_Str"")) {
        if (name.equals(""String_Node_Str""))         continue;
        if (name.equals(""String_Node_Str""))         continue;
        Object o=m.invoke(this,new Object[]{});
        if (o instanceof String) {
          if (o != null)           buf.append(name.substring(3,name.length()) + ""String_Node_Str"" + o+ ""String_Node_Str"");
        }
        if (o instanceof List) {
          if (o != null)           buf.append(name.substring(3,name.length())).append(""String_Node_Str"");
          List<Object> lst=(List<Object>)o;
          for (          Object obj : lst) {
            if (obj instanceof Chain) {
              continue;
            }
            buf.append(obj).append(""String_Node_Str"");
          }
        }
      }
    }
  }
 catch (  ClassNotFoundException e) {
    logger.error(""String_Node_Str"",e);
  }
catch (  InvocationTargetException e) {
    logger.error(""String_Node_Str"",e);
  }
catch (  IllegalAccessException e) {
    logger.error(""String_Node_Str"",e);
  }
  return buf.toString();
}","public String toString(){
  StringBuilder buf=new StringBuilder();
  buf.append(""String_Node_Str"" + molId + ""String_Node_Str"");
  buf.append(molName == null ? ""String_Node_Str"" : ""String_Node_Str"" + molName + ""String_Node_Str"");
  buf.append(""String_Node_Str"");
  if (chainIds != null) {
    for (int i=0; i < chainIds.size(); i++) {
      buf.append(chainIds.get(i));
      if (i != chainIds.size() - 1)       buf.append(""String_Node_Str"");
    }
  }
 else {
    buf.append(""String_Node_Str"");
  }
  return buf.toString();
}",0.2131879028259792
16892,"public void showCompound(){
  System.out.println(""String_Node_Str"");
  if (this.molId != -1) {
    System.out.println(""String_Node_Str"" + this.molId);
  }
  if (this.chainId != null) {
    System.out.println(""String_Node_Str"" + this.chainId);
  }
  if (this.molName != null) {
    System.out.println(""String_Node_Str"" + this.molName);
  }
  if (this.title != null) {
    System.out.println(""String_Node_Str"" + this.title);
  }
  if (this.synonyms != null) {
    for (    String x : this.synonyms) {
      System.out.println(""String_Node_Str"" + x);
    }
  }
  if (this.ecNums != null) {
    for (    String x : this.ecNums) {
      System.out.println(""String_Node_Str"" + x);
    }
  }
  if (this.fragment != null) {
    System.out.println(""String_Node_Str"" + this.fragment);
  }
  if (this.engineered != null) {
    System.out.println(""String_Node_Str"" + this.engineered);
  }
  if (this.mutation != null) {
    System.out.println(""String_Node_Str"" + this.mutation);
  }
  if (this.biologicalUnit != null) {
    System.out.println(""String_Node_Str"" + this.biologicalUnit);
  }
  if (this.details != null) {
    System.out.println(""String_Node_Str"" + this.details);
  }
  if (this.numRes != null) {
    System.out.println(""String_Node_Str"" + this.numRes);
  }
}","public void showCompound(){
  System.out.println(""String_Node_Str"");
  if (this.molId != -1) {
    System.out.println(""String_Node_Str"" + this.molId);
  }
  if (this.chainIds != null) {
    System.out.println(""String_Node_Str"" + this.chainIds);
  }
  if (this.molName != null) {
    System.out.println(""String_Node_Str"" + this.molName);
  }
  if (this.title != null) {
    System.out.println(""String_Node_Str"" + this.title);
  }
  if (this.synonyms != null) {
    for (    String x : this.synonyms) {
      System.out.println(""String_Node_Str"" + x);
    }
  }
  if (this.ecNums != null) {
    for (    String x : this.ecNums) {
      System.out.println(""String_Node_Str"" + x);
    }
  }
  if (this.fragment != null) {
    System.out.println(""String_Node_Str"" + this.fragment);
  }
  if (this.engineered != null) {
    System.out.println(""String_Node_Str"" + this.engineered);
  }
  if (this.mutation != null) {
    System.out.println(""String_Node_Str"" + this.mutation);
  }
  if (this.biologicalUnit != null) {
    System.out.println(""String_Node_Str"" + this.biologicalUnit);
  }
  if (this.details != null) {
    System.out.println(""String_Node_Str"" + this.details);
  }
  if (this.numRes != null) {
    System.out.println(""String_Node_Str"" + this.numRes);
  }
}",0.999206978588422
16893,"/** 
 * Returns the ref chain id value.
 * @param refChainId the RefChainID
 * @see #getRefChainId()
 */
public void setRefChainId(String refChainId){
  this.refChainId=refChainId;
}","/** 
 * Return the ref chain id value.
 * @param refChainId the RefChainID
 * @see #getRefChainId()
 */
public void setRefChainId(String refChainId){
  this.refChainId=refChainId;
}",0.9972451790633609
16894,"/** 
 * Returns the mol id value.
 * @return the MolId value
 * @see #setMolId(int)
 */
public int getMolId(){
  return molId;
}","/** 
 * Return the mol id value.
 * @return the MolId value
 * @see #setMolId(int)
 */
public int getMolId(){
  return molId;
}",0.996078431372549
16895,"public Compound(){
  chainList=new ArrayList<Chain>();
  molId=-1;
}","public Compound(){
  chains=new ArrayList<Chain>();
  molId=-1;
}",0.9774436090225564
16896,"public void setChains(List<Chain> chains){
  this.chainList=chains;
}","public void setChains(List<Chain> chains){
  this.chains=chains;
}",0.9777777777777776
16897,"/** 
 * string representation.
 */
public String toString(){
  String newline=System.getProperty(""String_Node_Str"");
  StringBuffer str=new StringBuffer();
  str.append(""String_Node_Str"");
  str.append(name);
  str.append(""String_Node_Str"");
  str.append(pdb_id);
  str.append(""String_Node_Str"");
  if (nrModels() > 1) {
    str.append(""String_Node_Str"");
    str.append(nrModels());
    str.append(newline);
  }
  str.append(pdbHeader.toString());
  str.append(newline);
  for (int i=0; i < nrModels(); i++) {
    if (nrModels() > 1) {
      str.append(""String_Node_Str"");
      str.append(i);
      str.append(""String_Node_Str"");
      str.append(newline);
    }
    str.append(""String_Node_Str"");
    str.append(newline);
    for (int j=0; j < size(i); j++) {
      Chain cha=(Chain)getChain(i,j);
      List<Group> agr=cha.getAtomGroups(""String_Node_Str"");
      List<Group> hgr=cha.getAtomGroups(""String_Node_Str"");
      List<Group> ngr=cha.getAtomGroups(""String_Node_Str"");
      str.append(""String_Node_Str"" + j + ""String_Node_Str""+ cha.getChainID()+ ""String_Node_Str"");
      if (cha.getHeader() != null) {
        Compound comp=cha.getHeader();
        String molName=comp.getMolName();
        if (molName != null) {
          str.append(molName);
        }
      }
      str.append(newline);
      str.append(""String_Node_Str"").append(cha.getSeqResLength());
      str.append(""String_Node_Str"").append(cha.getAtomLength());
      str.append(""String_Node_Str"").append(agr.size());
      str.append(""String_Node_Str"").append(hgr.size());
      str.append(""String_Node_Str"" + ngr.size() + newline);
    }
  }
  str.append(""String_Node_Str"" + dbrefs.size() + newline);
  for (  DBRef dbref : dbrefs) {
    str.append(dbref.toPDB()).append(newline);
  }
  str.append(""String_Node_Str"").append(newline);
  Iterator<Compound> iter=compounds.iterator();
  while (iter.hasNext()) {
    Compound mol=iter.next();
    str.append(mol).append(newline);
  }
  return str.toString();
}","/** 
 * string representation.
 */
public String toString(){
  String newline=System.getProperty(""String_Node_Str"");
  StringBuffer str=new StringBuffer();
  str.append(""String_Node_Str"");
  str.append(name);
  str.append(""String_Node_Str"");
  str.append(pdb_id);
  str.append(""String_Node_Str"");
  if (nrModels() > 1) {
    str.append(""String_Node_Str"");
    str.append(nrModels());
    str.append(newline);
  }
  str.append(pdbHeader.toString());
  str.append(newline);
  for (int i=0; i < nrModels(); i++) {
    if (nrModels() > 1) {
      str.append(""String_Node_Str"");
      str.append(i);
      str.append(""String_Node_Str"");
      str.append(newline);
    }
    str.append(""String_Node_Str"");
    str.append(newline);
    for (int j=0; j < size(i); j++) {
      Chain cha=(Chain)getChain(i,j);
      List<Group> agr=cha.getAtomGroups(""String_Node_Str"");
      List<Group> hgr=cha.getAtomGroups(""String_Node_Str"");
      List<Group> ngr=cha.getAtomGroups(""String_Node_Str"");
      str.append(""String_Node_Str"" + j + ""String_Node_Str""+ cha.getChainID()+ ""String_Node_Str"");
      if (cha.getCompound() != null) {
        Compound comp=cha.getCompound();
        String molName=comp.getMolName();
        if (molName != null) {
          str.append(molName);
        }
      }
      str.append(newline);
      str.append(""String_Node_Str"").append(cha.getSeqResLength());
      str.append(""String_Node_Str"").append(cha.getAtomLength());
      str.append(""String_Node_Str"").append(agr.size());
      str.append(""String_Node_Str"").append(hgr.size());
      str.append(""String_Node_Str"" + ngr.size() + newline);
    }
  }
  str.append(""String_Node_Str"" + dbrefs.size() + newline);
  for (  DBRef dbref : dbrefs) {
    str.append(dbref.toPDB()).append(newline);
  }
  str.append(""String_Node_Str"").append(newline);
  Iterator<Compound> iter=compounds.iterator();
  while (iter.hasNext()) {
    Compound mol=iter.next();
    str.append(mol).append(newline);
  }
  return str.toString();
}",0.9929435483870968
16898,"/** 
 * Convert a Chain to a new Chain containing C-alpha atoms only.
 * @param chain to convert
 * @return a new chain containing Amino acids with C-alpha only. 
 */
public static Chain getCAOnly(Chain chain){
  Chain newChain=new ChainImpl();
  newChain.setChainID(chain.getChainID());
  newChain.setHeader(chain.getHeader());
  newChain.setSwissprotId(chain.getSwissprotId());
  List<Group> groups=chain.getAtomGroups();
  grouploop:   for (  Group g : groups) {
    List<Atom> atoms=g.getAtoms();
    if (!(g instanceof AminoAcid))     continue;
    for (    Atom a : atoms) {
      if (a.getName().equals(StructureTools.CA_ATOM_NAME) && a.getElement() == Element.C) {
        AminoAcid n=new AminoAcidImpl();
        n.setPDBName(g.getPDBName());
        n.setResidueNumber(g.getResidueNumber());
        n.addAtom(a);
        newChain.addGroup(n);
        continue grouploop;
      }
    }
  }
  return newChain;
}","/** 
 * Convert a Chain to a new Chain containing C-alpha atoms only.
 * @param chain to convert
 * @return a new chain containing Amino acids with C-alpha only. 
 */
public static Chain getCAOnly(Chain chain){
  Chain newChain=new ChainImpl();
  newChain.setChainID(chain.getChainID());
  newChain.setCompound(chain.getCompound());
  newChain.setSwissprotId(chain.getSwissprotId());
  List<Group> groups=chain.getAtomGroups();
  grouploop:   for (  Group g : groups) {
    List<Atom> atoms=g.getAtoms();
    if (!(g instanceof AminoAcid))     continue;
    for (    Atom a : atoms) {
      if (a.getName().equals(StructureTools.CA_ATOM_NAME) && a.getElement() == Element.C) {
        AminoAcid n=new AminoAcidImpl();
        n.setPDBName(g.getPDBName());
        n.setResidueNumber(g.getResidueNumber());
        n.addAtom(a);
        newChain.addGroup(n);
        continue grouploop;
      }
    }
  }
  return newChain;
}",0.9739696312364424
16899,"/** 
 * @param args
 */
public static void main(String[] args) throws Exception {
  String pdbCode=""String_Node_Str"";
  AtomCache cache=new AtomCache();
  cache.setUseMmCif(true);
  StructureIO.setAtomCache(cache);
  Structure structure=StructureIO.getStructure(pdbCode);
  System.out.println(structure.getPDBCode());
  SpaceGroup sg=structure.getCrystallographicInfo().getSpaceGroup();
  if (sg != null) {
    System.out.println(sg.getShortSymbol() + ""String_Node_Str"" + sg.getId()+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + sg.getNumOperators());
  }
  System.out.println(""String_Node_Str"" + NTHREADS + ""String_Node_Str"");
  long start=System.currentTimeMillis();
  CrystalBuilder cb=new CrystalBuilder(structure);
  StructureInterfaceList interfaces=cb.getUniqueInterfaces(CUTOFF);
  interfaces.calcAsas(N_SPHERE_POINTS,NTHREADS,CONSIDER_COFACTORS);
  interfaces.removeInterfacesBelowArea(MIN_AREA_TO_KEEP);
  List<StructureInterfaceCluster> clusters=interfaces.getClusters();
  long end=System.currentTimeMillis();
  long total=(end - start) / 1000;
  System.out.println(""String_Node_Str"" + total + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + interfaces.size());
  for (int i=0; i < interfaces.size(); i++) {
    StructureInterface interf=interfaces.get(i + 1);
    String infiniteStr=""String_Node_Str"";
    if (interf.isInfinite())     infiniteStr=""String_Node_Str"";
    System.out.println(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ interf.getCrystalIds().getFirst()+ ""String_Node_Str""+ interf.getCrystalIds().getSecond()+ infiniteStr);
    List<AtomContact> clashing=interf.getContacts().getContactsWithinDistance(CLASH_DISTANCE);
    if (clashing.size() > 10)     System.out.println(clashing.size() + ""String_Node_Str"");
    CrystalTransform transf1=interf.getTransforms().getFirst();
    CrystalTransform transf2=interf.getTransforms().getSecond();
    System.out.println(""String_Node_Str"" + SpaceGroup.getAlgebraicFromMatrix(transf1.getMatTransform()) + ""String_Node_Str""+ SpaceGroup.getAlgebraicFromMatrix(transf2.getMatTransform()));
    String screwStr=""String_Node_Str"";
    if (transf2.getTransformType().isScrew()) {
      Vector3d screwTransl=transf2.getTranslScrewComponent();
      screwStr=""String_Node_Str"" + transf2.getTransformType().getShortName() + ""String_Node_Str""+ String.format(""String_Node_Str"",screwTransl.x,screwTransl.y,screwTransl.z);
    }
    if (structure.isCrystallographic()) {
      int foldType=sg.getAxisFoldType(transf2.getTransformId());
      AxisAngle4d axisAngle=sg.getRotAxisAngle(transf2.getTransformId());
      System.out.println(""String_Node_Str"" + foldType + ""String_Node_Str""+ String.format(""String_Node_Str"",axisAngle.x,axisAngle.y,axisAngle.z)+ screwStr);
    }
    System.out.println(""String_Node_Str"" + interf.getContacts().size());
    Pair<List<Group>> cores=interf.getCoreResidues(BSATOASA_CUTOFF,MIN_ASA_FOR_SURFACE);
    System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",BSATOASA_CUTOFF) + ""String_Node_Str""+ cores.getFirst().size()+ ""String_Node_Str""+ cores.getSecond().size());
    System.out.printf(""String_Node_Str"",interf.getTotalArea());
    if (interf.isIsologous()) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
  System.out.println(""String_Node_Str"");
  for (  StructureInterfaceCluster cluster : clusters) {
    System.out.print(cluster.getId() + ""String_Node_Str"");
    for (    StructureInterface member : cluster.getMembers()) {
      System.out.print(member.getId() + ""String_Node_Str"");
    }
    System.out.println();
  }
}","/** 
 * @param args
 */
public static void main(String[] args) throws Exception {
  String pdbCode=""String_Node_Str"";
  AtomCache cache=new AtomCache();
  cache.setUseMmCif(true);
  FileParsingParameters params=new FileParsingParameters();
  params.setAlignSeqRes(true);
  cache.setFileParsingParams(params);
  StructureIO.setAtomCache(cache);
  Structure structure=StructureIO.getStructure(pdbCode);
  System.out.println(structure.getPDBCode());
  SpaceGroup sg=structure.getCrystallographicInfo().getSpaceGroup();
  if (sg != null) {
    System.out.println(sg.getShortSymbol() + ""String_Node_Str"" + sg.getId()+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + sg.getNumOperators());
  }
  System.out.println(""String_Node_Str"" + NTHREADS + ""String_Node_Str"");
  long start=System.currentTimeMillis();
  CrystalBuilder cb=new CrystalBuilder(structure);
  StructureInterfaceList interfaces=cb.getUniqueInterfaces(CUTOFF);
  interfaces.calcAsas(N_SPHERE_POINTS,NTHREADS,CONSIDER_COFACTORS);
  interfaces.removeInterfacesBelowArea(MIN_AREA_TO_KEEP);
  List<StructureInterfaceCluster> clusters=interfaces.getClusters();
  long end=System.currentTimeMillis();
  long total=(end - start) / 1000;
  System.out.println(""String_Node_Str"" + total + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + interfaces.size());
  for (int i=0; i < interfaces.size(); i++) {
    StructureInterface interf=interfaces.get(i + 1);
    String infiniteStr=""String_Node_Str"";
    if (interf.isInfinite())     infiniteStr=""String_Node_Str"";
    System.out.println(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ interf.getCrystalIds().getFirst()+ ""String_Node_Str""+ interf.getCrystalIds().getSecond()+ infiniteStr);
    List<AtomContact> clashing=interf.getContacts().getContactsWithinDistance(CLASH_DISTANCE);
    if (clashing.size() > 10)     System.out.println(clashing.size() + ""String_Node_Str"");
    CrystalTransform transf1=interf.getTransforms().getFirst();
    CrystalTransform transf2=interf.getTransforms().getSecond();
    System.out.println(""String_Node_Str"" + SpaceGroup.getAlgebraicFromMatrix(transf1.getMatTransform()) + ""String_Node_Str""+ SpaceGroup.getAlgebraicFromMatrix(transf2.getMatTransform()));
    String screwStr=""String_Node_Str"";
    if (transf2.getTransformType().isScrew()) {
      Vector3d screwTransl=transf2.getTranslScrewComponent();
      screwStr=""String_Node_Str"" + transf2.getTransformType().getShortName() + ""String_Node_Str""+ String.format(""String_Node_Str"",screwTransl.x,screwTransl.y,screwTransl.z);
    }
    if (structure.isCrystallographic()) {
      int foldType=sg.getAxisFoldType(transf2.getTransformId());
      AxisAngle4d axisAngle=sg.getRotAxisAngle(transf2.getTransformId());
      System.out.println(""String_Node_Str"" + foldType + ""String_Node_Str""+ String.format(""String_Node_Str"",axisAngle.x,axisAngle.y,axisAngle.z)+ screwStr);
    }
    System.out.println(""String_Node_Str"" + interf.getContacts().size());
    Pair<List<Group>> cores=interf.getCoreResidues(BSATOASA_CUTOFF,MIN_ASA_FOR_SURFACE);
    System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",BSATOASA_CUTOFF) + ""String_Node_Str""+ cores.getFirst().size()+ ""String_Node_Str""+ cores.getSecond().size());
    System.out.printf(""String_Node_Str"",interf.getTotalArea());
    if (interf.isIsologous()) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
  System.out.println(""String_Node_Str"");
  for (  StructureInterfaceCluster cluster : clusters) {
    System.out.print(cluster.getId() + ""String_Node_Str"");
    for (    StructureInterface member : cluster.getMembers()) {
      System.out.print(member.getId() + ""String_Node_Str"");
    }
    System.out.println();
  }
}",0.9825699229833806
16900,"/** 
 * Returns an identical copy of this Chain .
 * @return an identical copy of this Chain
 */
public Object clone(){
  ChainImpl n=new ChainImpl();
  n.setChainID(getChainID());
  n.setSwissprotId(getSwissprotId());
  n.setCompound(this.getCompound());
  n.setInternalChainID(internalChainID);
  for (int i=0; i < groups.size(); i++) {
    Group g=(Group)groups.get(i);
    n.addGroup((Group)g.clone());
  }
  if (seqResGroups.size() > 0) {
    List<Group> tmpSeqRes=new ArrayList<Group>();
    for (int i=0; i < seqResGroups.size(); i++) {
      Group g=(Group)seqResGroups.get(i);
      tmpSeqRes.add(g);
    }
    Chain tmp=new ChainImpl();
    tmp.setAtomGroups(tmpSeqRes);
    SeqRes2AtomAligner seqresaligner=new SeqRes2AtomAligner();
    seqresaligner.mapSeqresRecords(n,tmp);
  }
  return n;
}","/** 
 * Returns an identical copy of this Chain .
 * @return an identical copy of this Chain
 */
public Object clone(){
  ChainImpl n=new ChainImpl();
  n.setChainID(getChainID());
  n.setSwissprotId(getSwissprotId());
  n.setCompound(this.getCompound());
  n.setInternalChainID(internalChainID);
  for (int i=0; i < groups.size(); i++) {
    Group g=groups.get(i);
    n.addGroup((Group)g.clone());
  }
  if (seqResGroups.size() > 0) {
    List<Group> tmpSeqRes=new ArrayList<Group>();
    for (int i=0; i < seqResGroups.size(); i++) {
      Group g=(Group)seqResGroups.get(i).clone();
      tmpSeqRes.add(g);
    }
    Chain tmp=new ChainImpl();
    tmp.setAtomGroups(tmpSeqRes);
    SeqRes2AtomAligner seqresaligner=new SeqRes2AtomAligner();
    seqresaligner.mapSeqresRecords(n,tmp);
  }
  return n;
}",0.9906774394033562
16901,"/** 
 * String representation.
 * @return String representation of the Chain
 */
public String toString(){
  String newline=System.getProperty(""String_Node_Str"");
  StringBuffer str=new StringBuffer();
  str.append(""String_Node_Str"" + getChainID() + ""String_Node_Str""+ newline);
  if (mol != null) {
    if (mol.getMolName() != null) {
      str.append(mol.getMolName()).append(newline);
    }
  }
  str.append(""String_Node_Str"" + getSeqResGroups().size() + ""String_Node_Str""+ getAtomLength()+ ""String_Node_Str""+ newline);
  for (int i=0; i < seqResGroups.size(); i++) {
    Group gr=(Group)seqResGroups.get(i);
    str.append(gr.toString()).append(newline);
  }
  return str.toString();
}","/** 
 * String representation.
 * @return String representation of the Chain
 */
public String toString(){
  String newline=System.getProperty(""String_Node_Str"");
  StringBuilder str=new StringBuilder();
  str.append(""String_Node_Str"" + getChainID() + ""String_Node_Str""+ newline);
  if (mol != null) {
    if (mol.getMolName() != null) {
      str.append(mol.getMolName()).append(newline);
    }
  }
  str.append(""String_Node_Str"" + getSeqResGroups().size() + ""String_Node_Str""+ getAtomLength()+ ""String_Node_Str""+ newline);
  return str.toString();
}",0.8435483870967742
16902,"private void storeUnAlignedSeqRes(Structure structure,List<Chain> seqResChains){
  SeqRes2AtomAligner aligner=new SeqRes2AtomAligner();
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> atomList=structure.getModel(i);
    for (    Chain seqRes : seqResChains) {
      Chain atomRes;
      atomRes=aligner.getMatchingAtomRes(seqRes,atomList);
      atomRes.setSeqResGroups(seqRes.getAtomGroups());
    }
  }
}","private void storeUnAlignedSeqRes(Structure structure,List<Chain> seqResChains){
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> atomList=structure.getModel(i);
    for (    Chain seqRes : seqResChains) {
      Chain atomRes;
      atomRes=SeqRes2AtomAligner.getMatchingAtomRes(seqRes,atomList);
      atomRes.setSeqResGroups(seqRes.getAtomGroups());
    }
  }
}",0.9152119700748128
16903,"/** 
 * map the seqres groups to the atomRes chain. updates the atomRes chain object with the mapped data seqRes chain should not be needed after this and atomRes should be continued to be used.
 * @param atomRes
 * @param seqRes
 */
public void mapSeqresRecords(Chain atomRes,Chain seqRes){
  List<Group> seqResGroups=seqRes.getAtomGroups();
  List<Group> atmResGroups=atomRes.getAtomGroups();
  logger.debug(""String_Node_Str"",atomRes.getChainID(),atmResGroups.size(),seqRes.getChainID(),seqResGroups.size());
  List<Group> matchedGroups=trySimpleMatch(seqResGroups,atmResGroups);
  if (matchedGroups != null) {
    atomRes.setSeqResGroups(matchedGroups);
    return;
  }
  logger.debug(""String_Node_Str"");
  int numAminosSeqres=seqRes.getAtomGroups(GroupType.AMINOACID).size();
  int numNucleotidesSeqres=seqRes.getAtomGroups(GroupType.NUCLEOTIDE).size();
  if (numAminosSeqres < 1) {
    if (numNucleotidesSeqres > 1) {
      logger.debug(""String_Node_Str"",seqRes.getChainID(),numNucleotidesSeqres);
      alignNucleotideChains(seqRes,atomRes);
      return;
    }
 else {
      logger.debug(""String_Node_Str"",seqRes.getChainID(),numAminosSeqres,numNucleotidesSeqres);
      return;
    }
  }
  if (atomRes.getAtomGroups(GroupType.AMINOACID).size() < 1) {
    logger.debug(""String_Node_Str"",atomRes.getChainID());
    return;
  }
  logger.debug(""String_Node_Str"",atomRes.getChainID());
  boolean noMatchFound=alignProteinChains(seqResGroups,atomRes.getAtomGroups());
  if (!noMatchFound) {
    atomRes.setSeqResGroups(seqResGroups);
  }
}","/** 
 * Map the seqRes groups to the atomRes chain. Updates the atomRes chain object with the mapped data The seqRes chain should not be needed after this and atomRes should be further used.
 * @param atomRes the chain containing ATOM groups (in atomGroups slot). This chain is modified to contain in its seqresGroups slot the mapped atom groups
 * @param seqRes the chain containing SEQRES groups (in atomGroups slot). This chain is not modified
 */
public void mapSeqresRecords(Chain atomRes,Chain seqRes){
  List<Group> seqResGroups=seqRes.getAtomGroups();
  List<Group> atmResGroups=atomRes.getAtomGroups();
  logger.debug(""String_Node_Str"",atomRes.getChainID(),atmResGroups.size(),seqRes.getChainID(),seqResGroups.size());
  List<Group> matchedGroups=trySimpleMatch(seqResGroups,atmResGroups);
  if (matchedGroups != null) {
    atomRes.setSeqResGroups(matchedGroups);
    return;
  }
  logger.debug(""String_Node_Str"");
  int numAminosSeqres=seqRes.getAtomGroups(GroupType.AMINOACID).size();
  int numNucleotidesSeqres=seqRes.getAtomGroups(GroupType.NUCLEOTIDE).size();
  if (numAminosSeqres < 1) {
    if (numNucleotidesSeqres > 1) {
      logger.debug(""String_Node_Str"",seqRes.getChainID(),numNucleotidesSeqres);
      alignNucleotideChains(seqRes,atomRes);
      return;
    }
 else {
      logger.debug(""String_Node_Str"",seqRes.getChainID(),numAminosSeqres,numNucleotidesSeqres);
      return;
    }
  }
  if (atomRes.getAtomGroups(GroupType.AMINOACID).size() < 1) {
    logger.debug(""String_Node_Str"",atomRes.getChainID());
    return;
  }
  logger.debug(""String_Node_Str"",atomRes.getChainID());
  boolean noMatchFound=alignProteinChains(seqResGroups,atomRes.getAtomGroups());
  if (!noMatchFound) {
    atomRes.setSeqResGroups(seqResGroups);
  }
}",0.8978478326765686
16904,"public Chain getMatchingAtomRes(Chain seqRes,List<Chain> atomList){
  Iterator<Chain> iter=atomList.iterator();
  while (iter.hasNext()) {
    Chain atomChain=iter.next();
    if (atomChain.getChainID().equals(seqRes.getChainID())) {
      return atomChain;
    }
  }
  logger.debug(""String_Node_Str"" + seqRes.getChainID() + ""String_Node_Str""+ atomList.size());
  return null;
}","public static Chain getMatchingAtomRes(Chain seqRes,List<Chain> atomList){
  Iterator<Chain> iter=atomList.iterator();
  while (iter.hasNext()) {
    Chain atomChain=iter.next();
    if (atomChain.getChainID().equals(seqRes.getChainID())) {
      return atomChain;
    }
  }
  logger.debug(""String_Node_Str"" + seqRes.getChainID() + ""String_Node_Str""+ atomList.size());
  return null;
}",0.9908256880733946
16905,"/** 
 * a simple matching approach that tries to do a 1:1 mapping between SEQRES and ATOM records returns true if this simple matching approach worked fine
 * @param seqRes
 * @param atomList
 * @return
 */
private List<Group> trySimpleMatch(List<Group> seqResGroups,List<Group> atmResGroups){
  @SuppressWarnings(""String_Node_Str"") List<Group> newSeqResGroups=(ArrayList<Group>)((ArrayList<Group>)seqResGroups).clone();
  boolean startAt1=true;
  for (int atomResPos=0; atomResPos < atmResGroups.size(); atomResPos++) {
    Group atomResGroup=atmResGroups.get(atomResPos);
    String threeLetterCode=atomResGroup.getPDBName();
    if (excludeTypes.contains(threeLetterCode)) {
      continue;
    }
    ResidueNumber atomResNum=atomResGroup.getResidueNumber();
    int seqResPos=atomResNum.getSeqNum();
    if (seqResPos < 0) {
      logger.debug(""String_Node_Str"",seqResPos);
      return null;
    }
    if (seqResPos == 0) {
      Group seqResGroup=seqResGroups.get(0);
      if (seqResGroup.getPDBName().equals(atomResGroup.getPDBName())) {
        startAt1=false;
      }
 else {
        logger.debug(""String_Node_Str"",seqResGroup.getPDBName(),atomResGroup.getPDBName());
        return null;
      }
    }
    if (startAt1)     seqResPos--;
    if (startAt1 && seqResPos >= seqResGroups.size()) {
      if (atomResGroup instanceof AminoAcid) {
        logger.debug(""String_Node_Str"" + seqResPos + ""String_Node_Str""+ seqResGroups.size()+ ""String_Node_Str""+ atomResGroup);
        return null;
      }
 else       if (atomResGroup instanceof NucleotideImpl) {
        logger.debug(""String_Node_Str"" + seqResPos + ""String_Node_Str""+ seqResGroups.size()+ ""String_Node_Str""+ atomResGroup);
        return null;
      }
 else {
        continue;
      }
    }
    if (seqResPos >= seqResGroups.size()) {
      logger.debug(""String_Node_Str"" + seqResPos);
      if (atomResGroup instanceof AminoAcid)       return null;
 else       continue;
    }
    Group seqResGroup=seqResGroups.get(seqResPos);
    if (!seqResGroup.getPDBName().trim().equals(atomResGroup.getPDBName().trim())) {
      logger.debug(""String_Node_Str"" + seqResPos + ""String_Node_Str""+ atomResGroup+ ""String_Node_Str""+ seqResGroup);
      return null;
    }
    logger.trace(""String_Node_Str"",seqResPos,atomResGroup);
    newSeqResGroups.set(seqResPos,atomResGroup);
  }
  return newSeqResGroups;
}","/** 
 * A simple matching approach that tries to do a 1:1 mapping between SEQRES and ATOM records
 * @param seqRes
 * @param atomList
 * @return the matching or null if the matching didn't work
 */
private List<Group> trySimpleMatch(List<Group> seqResGroups,List<Group> atmResGroups){
  @SuppressWarnings(""String_Node_Str"") List<Group> newSeqResGroups=(ArrayList<Group>)((ArrayList<Group>)seqResGroups).clone();
  boolean startAt1=true;
  for (int atomResPos=0; atomResPos < atmResGroups.size(); atomResPos++) {
    Group atomResGroup=atmResGroups.get(atomResPos);
    String threeLetterCode=atomResGroup.getPDBName();
    if (excludeTypes.contains(threeLetterCode)) {
      continue;
    }
    ResidueNumber atomResNum=atomResGroup.getResidueNumber();
    int seqResPos=atomResNum.getSeqNum();
    if (seqResPos < 0) {
      logger.debug(""String_Node_Str"",seqResPos);
      return null;
    }
    if (seqResPos == 0) {
      Group seqResGroup=seqResGroups.get(0);
      if (seqResGroup.getPDBName().equals(atomResGroup.getPDBName())) {
        startAt1=false;
      }
 else {
        logger.debug(""String_Node_Str"",seqResGroup.getPDBName(),atomResGroup.getPDBName());
        return null;
      }
    }
    if (startAt1)     seqResPos--;
    if (startAt1 && seqResPos >= seqResGroups.size()) {
      if (atomResGroup instanceof AminoAcid) {
        logger.debug(""String_Node_Str"" + seqResPos + ""String_Node_Str""+ seqResGroups.size()+ ""String_Node_Str""+ atomResGroup);
        return null;
      }
 else       if (atomResGroup instanceof NucleotideImpl) {
        logger.debug(""String_Node_Str"" + seqResPos + ""String_Node_Str""+ seqResGroups.size()+ ""String_Node_Str""+ atomResGroup);
        return null;
      }
 else {
        continue;
      }
    }
    if (seqResPos >= seqResGroups.size()) {
      logger.debug(""String_Node_Str"" + seqResPos);
      if (atomResGroup instanceof AminoAcid)       return null;
 else       continue;
    }
    Group seqResGroup=seqResGroups.get(seqResPos);
    if (!seqResGroup.getPDBName().trim().equals(atomResGroup.getPDBName().trim())) {
      logger.debug(""String_Node_Str"" + seqResPos + ""String_Node_Str""+ atomResGroup+ ""String_Node_Str""+ seqResGroup);
      return null;
    }
    Group replacedGroup=newSeqResGroups.set(seqResPos,atomResGroup);
    logger.debug(""String_Node_Str"",seqResPos,replacedGroup.getResidueNumber(),replacedGroup.getPDBName(),atomResGroup.getResidueNumber(),atomResGroup.getPDBName());
  }
  return newSeqResGroups;
}",0.893976897689769
16906,"public void documentEnd(){
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  structure.addModel(current_model);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    asymId2entityId.put(asym.getId(),asym.getEntity_id());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setChainID(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    int eId=0;
    try {
      eId=Integer.parseInt(asym.getEntity_id());
    }
 catch (    NumberFormatException e) {
      logger.warn(""String_Node_Str"",asym.getEntity_id());
    }
    Entity e=getEntity(eId);
    for (    EntitySrcGen esg : entitySrcGens) {
      if (!esg.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESG(esg,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcNat esn : entitySrcNats) {
      if (!esn.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESN(esn,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcSyn ess : entitySrcSyns) {
      if (!ess.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESS(ess,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    Compound c=structure.getCompoundById(eId);
    if (c == null) {
      c=new Compound();
      c.setMolId(eId);
      if (e != null && e.getType().equals(""String_Node_Str"")) {
        if (e != null)         c.setMolName(e.getPdbx_description());
        structure.addCompound(c);
        logger.debug(""String_Node_Str"",eId,c.getMolName());
      }
    }
  }
  if (params.isAlignSeqRes()) {
    SeqRes2AtomAligner aligner=new SeqRes2AtomAligner();
    List<Chain> atomList=structure.getModel(0);
    for (    Chain seqResChain : seqResChains) {
      Chain atomChain=aligner.getMatchingAtomRes(seqResChain,atomList);
      List<Group> seqResGroups=seqResChain.getAtomGroups();
      for (int seqResPos=0; seqResPos < seqResGroups.size(); seqResPos++) {
        Group seqresG=seqResGroups.get(seqResPos);
        boolean found=false;
        for (        Group atomG : atomChain.getAtomGroups()) {
          int internalNr=getInternalNr(atomG);
          if (seqresG.getResidueNumber().getSeqNum() == internalNr) {
            seqResGroups.set(seqResPos,atomG);
            found=true;
            break;
          }
        }
        if (!found)         seqresG.setResidueNumber(null);
      }
      atomChain.setSeqResGroups(seqResGroups);
    }
  }
  addBonds();
  Set<String> asymIds=asymStrandId.keySet();
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> model=structure.getModel(i);
    List<Chain> pdbChains=new ArrayList<Chain>();
    for (    Chain chain : model) {
      for (      String asym : asymIds) {
        if (chain.getChainID().equals(asym)) {
          String newChainId=asymStrandId.get(asym);
          logger.debug(""String_Node_Str"",asym,chain.getAtomGroups().size(),newChainId);
          chain.setChainID(newChainId);
          chain.setInternalChainID(asym);
          for (          Group g : chain.getAtomGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          for (          Group g : chain.getSeqResGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          Chain known=isKnownChain(chain.getChainID(),pdbChains);
          if (known == null) {
            pdbChains.add(chain);
          }
 else {
            for (            Group g : chain.getAtomGroups()) {
              known.addGroup(g);
            }
          }
          break;
        }
      }
    }
    structure.setModel(i,pdbChains);
    for (    Chain chain : pdbChains) {
      String entityId=asymId2entityId.get(chain.getInternalChainID());
      int eId=Integer.parseInt(entityId);
      Compound compound=structure.getCompoundById(eId);
      if (compound == null) {
        logger.warn(""String_Node_Str"",eId,chain.getChainID(),chain.getInternalChainID());
      }
 else {
        logger.debug(""String_Node_Str"",chain.getChainID(),chain.getInternalChainID(),eId);
        compound.addChain(chain);
        chain.setCompound(compound);
      }
    }
  }
  PDBHeader header=structure.getPDBHeader();
  header.setNrBioAssemblies(strucAssemblies.size());
  Map<String,List<BiologicalAssemblyTransformation>> transformationMap=new HashMap<String,List<BiologicalAssemblyTransformation>>();
  for (  PdbxStructAssembly psa : strucAssemblies) {
    List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
    for (    PdbxStructAssemblyGen psag : strucAssemblyGens) {
      if (psag.getAssembly_id().equals(psa.getId())) {
        psags.add(psag);
      }
    }
    BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
    List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
    transformationMap.put(psa.getId(),transformations);
  }
  structure.getPDBHeader().setBioUnitTranformationMap(transformationMap);
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators((Matrix4d[])ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
  structure.getCompounds();
}","public void documentEnd(){
  if (current_chain != null) {
    current_chain.addGroup(current_group);
    if (isKnownChain(current_chain.getChainID(),current_model) == null) {
      current_model.add(current_chain);
    }
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  structure.addModel(current_model);
  for (  StructAsym asym : structAsyms) {
    logger.debug(""String_Node_Str"",asym.getEntity_id(),asym.getId());
    asymId2entityId.put(asym.getId(),asym.getEntity_id());
    Chain s=getEntityChain(asym.getEntity_id());
    Chain seqres=(Chain)s.clone();
    seqres=removeSeqResHeterogeneity(seqres);
    seqres.setChainID(asym.getId());
    seqResChains.add(seqres);
    logger.debug(""String_Node_Str"" + asym.getId() + ""String_Node_Str""+ seqres+ ""String_Node_Str"");
    int eId=0;
    try {
      eId=Integer.parseInt(asym.getEntity_id());
    }
 catch (    NumberFormatException e) {
      logger.warn(""String_Node_Str"",asym.getEntity_id());
    }
    Entity e=getEntity(eId);
    for (    EntitySrcGen esg : entitySrcGens) {
      if (!esg.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESG(esg,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcNat esn : entitySrcNats) {
      if (!esn.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESN(esn,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    for (    EntitySrcSyn ess : entitySrcSyns) {
      if (!ess.getEntity_id().equals(asym.getEntity_id()))       continue;
      Compound c=structure.getCompoundById(eId);
      if (c == null) {
        if (e != null && e.getType().equals(""String_Node_Str"")) {
          c=createNewCompoundFromESS(ess,eId);
          c.setMolName(e.getPdbx_description());
          structure.addCompound(c);
          logger.debug(""String_Node_Str"",eId,c.getMolName());
        }
      }
    }
    Compound c=structure.getCompoundById(eId);
    if (c == null) {
      c=new Compound();
      c.setMolId(eId);
      if (e != null && e.getType().equals(""String_Node_Str"")) {
        if (e != null)         c.setMolName(e.getPdbx_description());
        structure.addCompound(c);
        logger.debug(""String_Node_Str"",eId,c.getMolName());
      }
    }
  }
  if (params.isAlignSeqRes()) {
    List<Chain> atomList=structure.getModel(0);
    for (    Chain seqResChain : seqResChains) {
      Chain atomChain=SeqRes2AtomAligner.getMatchingAtomRes(seqResChain,atomList);
      List<Group> seqResGroups=seqResChain.getAtomGroups();
      for (int seqResPos=0; seqResPos < seqResGroups.size(); seqResPos++) {
        Group seqresG=seqResGroups.get(seqResPos);
        boolean found=false;
        for (        Group atomG : atomChain.getAtomGroups()) {
          int internalNr=getInternalNr(atomG);
          if (seqresG.getResidueNumber().getSeqNum() == internalNr) {
            seqResGroups.set(seqResPos,atomG);
            found=true;
            break;
          }
        }
        if (!found)         seqresG.setResidueNumber(null);
      }
      atomChain.setSeqResGroups(seqResGroups);
    }
  }
  addBonds();
  Set<String> asymIds=asymStrandId.keySet();
  for (int i=0; i < structure.nrModels(); i++) {
    List<Chain> model=structure.getModel(i);
    List<Chain> pdbChains=new ArrayList<Chain>();
    for (    Chain chain : model) {
      for (      String asym : asymIds) {
        if (chain.getChainID().equals(asym)) {
          String newChainId=asymStrandId.get(asym);
          logger.debug(""String_Node_Str"",asym,chain.getAtomGroups().size(),newChainId);
          chain.setChainID(newChainId);
          chain.setInternalChainID(asym);
          for (          Group g : chain.getAtomGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          for (          Group g : chain.getSeqResGroups()) {
            ResidueNumber resNum=g.getResidueNumber();
            if (resNum != null)             resNum.setChainId(newChainId);
          }
          Chain known=isKnownChain(chain.getChainID(),pdbChains);
          if (known == null) {
            pdbChains.add(chain);
          }
 else {
            for (            Group g : chain.getAtomGroups()) {
              known.addGroup(g);
            }
          }
          break;
        }
      }
    }
    structure.setModel(i,pdbChains);
    for (    Chain chain : pdbChains) {
      String entityId=asymId2entityId.get(chain.getInternalChainID());
      int eId=Integer.parseInt(entityId);
      Compound compound=structure.getCompoundById(eId);
      if (compound == null) {
        logger.warn(""String_Node_Str"",eId,chain.getChainID(),chain.getInternalChainID());
      }
 else {
        logger.debug(""String_Node_Str"",chain.getChainID(),chain.getInternalChainID(),eId);
        compound.addChain(chain);
        chain.setCompound(compound);
      }
    }
  }
  PDBHeader header=structure.getPDBHeader();
  header.setNrBioAssemblies(strucAssemblies.size());
  Map<String,List<BiologicalAssemblyTransformation>> transformationMap=new HashMap<String,List<BiologicalAssemblyTransformation>>();
  for (  PdbxStructAssembly psa : strucAssemblies) {
    List<PdbxStructAssemblyGen> psags=new ArrayList<PdbxStructAssemblyGen>(1);
    for (    PdbxStructAssemblyGen psag : strucAssemblyGens) {
      if (psag.getAssembly_id().equals(psa.getId())) {
        psags.add(psag);
      }
    }
    BiologicalAssemblyBuilder builder=new BiologicalAssemblyBuilder();
    List<BiologicalAssemblyTransformation> transformations=builder.getBioUnitTransformationList(psa,psags,structOpers);
    transformationMap.put(psa.getId(),transformations);
  }
  structure.getPDBHeader().setBioUnitTranformationMap(transformationMap);
  ArrayList<Matrix4d> ncsOperators=new ArrayList<Matrix4d>();
  for (  StructNcsOper sNcsOper : structNcsOper) {
    if (sNcsOper.getCode().equals(""String_Node_Str"")) {
      ncsOperators.add(sNcsOper.getOperator());
    }
  }
  if (ncsOperators.size() > 0) {
    structure.getCrystallographicInfo().setNcsOperators((Matrix4d[])ncsOperators.toArray(new Matrix4d[ncsOperators.size()]));
  }
  structure.getCompounds();
}",0.979425695677916
16907,"public TreeMap<String,Entity> findEntities(){
  TreeMap<String,Entity> chainIds2entities=new TreeMap<String,Entity>();
  List<String> chainIds=new ArrayList<String>();
  for (  Chain c : s.getChains()) {
    chainIds.add(c.getChainID());
  }
  Collections.sort(chainIds);
  try {
    outer:     for (int i=0; i < chainIds.size(); i++) {
      for (int j=i + 1; j < chainIds.size(); j++) {
        Chain c1=null;
        Chain c2=null;
        try {
          c1=s.getChainByPDB(chainIds.get(i));
          c2=s.getChainByPDB(chainIds.get(j));
        }
 catch (        StructureException e) {
          logger.error(""String_Node_Str"",e);
        }
        ProteinSequence s1=new ProteinSequence(c1.getAtomSequence());
        ProteinSequence s2=new ProteinSequence(c2.getAtomSequence());
        SequencePair<ProteinSequence,AminoAcidCompound> pair=align(s1,s2);
        int nonGaps=pair.getLength() - getNumGaps(pair);
        double identity=(double)pair.getNumIdenticals() / (double)nonGaps;
        logger.debug(""String_Node_Str"",c1.getChainID(),c2.getChainID(),identity);
        if (identity > 0.99999) {
          if (!chainIds2entities.containsKey(c1.getChainID()) && !chainIds2entities.containsKey(c2.getChainID())) {
            logger.debug(""String_Node_Str"",c1.getChainID(),c2.getChainID());
            if (areResNumbersAligned(c1,c2)) {
              Entity ent=new Entity();
              ent.addMember(c1);
              ent.setRepresentative(c1);
              ent.addMember(c2);
              chainIds2entities.put(c1.getChainID(),ent);
              chainIds2entities.put(c2.getChainID(),ent);
            }
 else {
              logger.warn(""String_Node_Str"");
            }
          }
 else {
            Entity ent=chainIds2entities.get(c1.getChainID());
            if (ent == null) {
              logger.debug(""String_Node_Str"",c1.getChainID(),c2.getChainID());
              ent=chainIds2entities.get(c2.getChainID());
              if (areResNumbersAligned(c1,c2)) {
                ent.addMember(c1);
                chainIds2entities.put(c1.getChainID(),ent);
              }
 else {
                logger.warn(""String_Node_Str"");
              }
            }
 else {
              logger.debug(""String_Node_Str"",c2.getChainID(),c1.getChainID());
              if (areResNumbersAligned(c1,c2)) {
                ent.addMember(c2);
                chainIds2entities.put(c2.getChainID(),ent);
              }
 else {
                logger.warn(""String_Node_Str"");
              }
            }
          }
        }
 else         if (identity > 0.95) {
          logger.info(""String_Node_Str"",c1.getChainID(),c2.getChainID(),nonGaps - pair.getNumIdenticals(),nonGaps,identity);
          logger.info(""String_Node_Str"" + pair.toString(100));
        }
 else         if (identity > 1) {
          logger.warn(""String_Node_Str"",c1.getChainID(),c2.getChainID(),pair.getNumIdenticals(),nonGaps,identity);
          logger.warn(""String_Node_Str"" + pair.toString(100));
        }
        if (chainIds2entities.size() == s.getChains().size())         break outer;
      }
    }
    for (    Chain c : s.getChains()) {
      if (!chainIds2entities.containsKey(c.getChainID())) {
        logger.debug(""String_Node_Str"" + c.getChainID());
        chainIds2entities.put(c.getChainID(),getTrivialEntity(c));
      }
    }
  }
 catch (  CompoundNotFoundException e) {
    logger.warn(""String_Node_Str"" + e.getMessage());
    return getTrivialEntities();
  }
  return chainIds2entities;
}","public TreeMap<String,Entity> findEntities(){
  TreeMap<String,Entity> chainIds2entities=new TreeMap<String,Entity>();
  List<String> chainIds=new ArrayList<String>();
  for (  Chain c : s.getChains()) {
    if (c.getAtomGroups(GroupType.AMINOACID).size() > 1 && c.getAtomGroups(GroupType.NUCLEOTIDE).size() < 1) {
      chainIds.add(c.getChainID());
    }
  }
  Collections.sort(chainIds);
  try {
    outer:     for (int i=0; i < chainIds.size(); i++) {
      for (int j=i + 1; j < chainIds.size(); j++) {
        Chain c1=null;
        Chain c2=null;
        try {
          c1=s.getChainByPDB(chainIds.get(i));
          c2=s.getChainByPDB(chainIds.get(j));
        }
 catch (        StructureException e) {
          logger.error(""String_Node_Str"",e);
        }
        ProteinSequence s1=new ProteinSequence(c1.getAtomSequence());
        ProteinSequence s2=new ProteinSequence(c2.getAtomSequence());
        SequencePair<ProteinSequence,AminoAcidCompound> pair=align(s1,s2);
        int nonGaps=pair.getLength() - getNumGaps(pair);
        double identity=(double)pair.getNumIdenticals() / (double)nonGaps;
        logger.debug(""String_Node_Str"",c1.getChainID(),c2.getChainID(),identity);
        if (identity > 0.99999) {
          if (!chainIds2entities.containsKey(c1.getChainID()) && !chainIds2entities.containsKey(c2.getChainID())) {
            logger.debug(""String_Node_Str"",c1.getChainID(),c2.getChainID());
            if (areResNumbersAligned(c1,c2)) {
              Entity ent=new Entity();
              ent.addMember(c1);
              ent.setRepresentative(c1);
              ent.addMember(c2);
              chainIds2entities.put(c1.getChainID(),ent);
              chainIds2entities.put(c2.getChainID(),ent);
            }
 else {
              logger.warn(""String_Node_Str"");
            }
          }
 else {
            Entity ent=chainIds2entities.get(c1.getChainID());
            if (ent == null) {
              logger.debug(""String_Node_Str"",c1.getChainID(),c2.getChainID());
              ent=chainIds2entities.get(c2.getChainID());
              if (areResNumbersAligned(c1,c2)) {
                ent.addMember(c1);
                chainIds2entities.put(c1.getChainID(),ent);
              }
 else {
                logger.warn(""String_Node_Str"");
              }
            }
 else {
              logger.debug(""String_Node_Str"",c2.getChainID(),c1.getChainID());
              if (areResNumbersAligned(c1,c2)) {
                ent.addMember(c2);
                chainIds2entities.put(c2.getChainID(),ent);
              }
 else {
                logger.warn(""String_Node_Str"");
              }
            }
          }
        }
 else         if (identity > 0.95) {
          logger.info(""String_Node_Str"",c1.getChainID(),c2.getChainID(),nonGaps - pair.getNumIdenticals(),nonGaps,identity);
          logger.info(""String_Node_Str"" + pair.toString(100));
        }
 else         if (identity > 1) {
          logger.warn(""String_Node_Str"",c1.getChainID(),c2.getChainID(),pair.getNumIdenticals(),nonGaps,identity);
          logger.warn(""String_Node_Str"" + pair.toString(100));
        }
        if (chainIds2entities.size() == chainIds.size())         break outer;
      }
    }
    for (    Chain c : s.getChains()) {
      if (!chainIds2entities.containsKey(c.getChainID())) {
        logger.debug(""String_Node_Str"" + c.getChainID());
        chainIds2entities.put(c.getChainID(),getTrivialEntity(c));
      }
    }
  }
 catch (  CompoundNotFoundException e) {
    logger.warn(""String_Node_Str"" + e.getMessage());
    return getTrivialEntities();
  }
  return chainIds2entities;
}",0.9730412805391744
16908,"/** 
 * @author Daniel Cameron
 */
@Test public void testCaseEquivalence(){
  DNACompoundSet dnacs=DNACompoundSet.getDNACompoundSet();
  SubstitutionMatrix<NucleotideCompound> dnaTest=new SimpleSubstitutionMatrix<NucleotideCompound>(dnacs,""String_Node_Str"",""String_Node_Str"");
  @SuppressWarnings(""String_Node_Str"") short[][] matrix=dnaTest.getMatrix();
  assertEquals(dnaTest.getValue(dnacs.getCompoundForString(""String_Node_Str""),dnacs.getCompoundForString(""String_Node_Str"")),5);
  assertEquals(dnaTest.getValue(dnacs.getCompoundForString(""String_Node_Str""),dnacs.getCompoundForString(""String_Node_Str"")),0);
  assertEquals(dnaTest.getValue(dnacs.getCompoundForString(""String_Node_Str""),dnacs.getCompoundForString(""String_Node_Str"")),5);
  assertEquals(dnaTest.getValue(dnacs.getCompoundForString(""String_Node_Str""),dnacs.getCompoundForString(""String_Node_Str"")),0);
}","@Test public void testCaseEquivalence(){
  DNACompoundSet dnacs=DNACompoundSet.getDNACompoundSet();
  SubstitutionMatrix<NucleotideCompound> dnaTest=new SimpleSubstitutionMatrix<NucleotideCompound>(dnacs,""String_Node_Str"",""String_Node_Str"");
  @SuppressWarnings(""String_Node_Str"") short[][] matrix=dnaTest.getMatrix();
  assertEquals(dnaTest.getValue(dnacs.getCompoundForString(""String_Node_Str""),dnacs.getCompoundForString(""String_Node_Str"")),5);
  assertEquals(dnaTest.getValue(dnacs.getCompoundForString(""String_Node_Str""),dnacs.getCompoundForString(""String_Node_Str"")),0);
  assertEquals(dnaTest.getValue(dnacs.getCompoundForString(""String_Node_Str""),dnacs.getCompoundForString(""String_Node_Str"")),5);
  assertEquals(dnaTest.getValue(dnacs.getCompoundForString(""String_Node_Str""),dnacs.getCompoundForString(""String_Node_Str"")),0);
}",0.9794961921499707
16909,"public boolean compoundsEquivalent(C compoundOne,C compoundTwo){
  assertCompound(compoundOne);
  assertCompound(compoundTwo);
  return equivalentsMap.get(compoundOne).contains(compoundTwo);
}","public boolean compoundsEquivalent(C compoundOne,C compoundTwo){
  assertCompound(compoundOne);
  assertCompound(compoundTwo);
  return compoundOne.equals(compoundTwo) || equivalentsMap.get(compoundOne).contains(compoundTwo);
}",0.9164677804295944
16910,"private void assertCompound(C compound){
  boolean okay=hasCompound(compound);
  if (!okay) {
    logger.warn(""String_Node_Str"",getClass().getSimpleName(),compound);
  }
}","private void assertCompound(C compound){
  if (!hasCompound(compound)) {
    logger.warn(""String_Node_Str"",getClass().getSimpleName(),compound);
  }
}",0.909657320872274
16911,"@Override @SuppressWarnings(""String_Node_Str"") public boolean equals(Object o){
  if (Equals.classEqual(this,o)) {
    AbstractCompoundSet<C> that=(AbstractCompoundSet<C>)o;
    return Equals.equal(charSeqToCompound,that.charSeqToCompound) && Equals.equal(equivalentsMap,that.equivalentsMap);
  }
  return false;
}","@Override @SuppressWarnings(""String_Node_Str"") public boolean equals(Object o){
  if (!(o instanceof AbstractCompoundSet))   return false;
  if (Equals.classEqual(this,o)) {
    AbstractCompoundSet<C> that=(AbstractCompoundSet<C>)o;
    return Equals.equal(charSeqToCompound,that.charSeqToCompound) && Equals.equal(equivalentsMap,that.equivalentsMap);
  }
  return false;
}",0.9141193595342066
16912,"public boolean hasCompound(C compound){
  C retrievedCompound=getCompoundForString(compound.toString());
  return (retrievedCompound == null) ? false : true;
}","public boolean hasCompound(C compound){
  C retrievedCompound=getCompoundForString(compound.toString());
  return retrievedCompound != null;
}",0.9368770764119602
16913,"@Override public boolean isCompoundStringLengthEqual(){
  if (compoundStringLengthEqual == null) {
    int lastSize=-1;
    compoundStringLengthEqual=Boolean.TRUE;
    for (    CharSequence c : charSeqToCompound.keySet()) {
      int size=c.length();
      if (lastSize != -1) {
        lastSize=size;
        continue;
      }
      if (lastSize != size) {
        compoundStringLengthEqual=Boolean.FALSE;
        break;
      }
    }
  }
  return compoundStringLengthEqual;
}","@Override public boolean isCompoundStringLengthEqual(){
  if (compoundStringLengthEqual == null) {
    int lastSize=-1;
    compoundStringLengthEqual=Boolean.TRUE;
    for (    CharSequence c : charSeqToCompound.keySet()) {
      if (lastSize != c.length()) {
        compoundStringLengthEqual=Boolean.FALSE;
        break;
      }
    }
  }
  return compoundStringLengthEqual;
}",0.8598130841121495
16914,"@Test public void test(){
  String[] uniprotIDs=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (  String id : uniprotIDs) {
    try {
      testUniprot(id);
      Thread.sleep(1000);
    }
 catch (    Exception e) {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
}","@Test public void test() throws IOException, InterruptedException {
  String[] uniprotIDs=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (  String id : uniprotIDs) {
    try {
      testUniprot(id);
      Thread.sleep(1000);
    }
 catch (    CompoundNotFoundException e) {
      fail(e.getMessage());
    }
  }
}",0.8880105401844532
16915,"private void testUniprot(String uniprotID) throws Exception {
  ProteinSequence seq=getUniprot(uniprotID);
  AminoAcidCompoundSet compoundSet=AminoAcidCompoundSet.getAminoAcidCompoundSet();
  assertTrue(compoundSet.isValidSequence(seq));
  @SuppressWarnings(""String_Node_Str"") float[] values=Jronn.getDisorderScores(seq);
}","private void testUniprot(String uniprotID) throws CompoundNotFoundException, IOException {
  ProteinSequence seq=getUniprot(uniprotID);
  AminoAcidCompoundSet compoundSet=AminoAcidCompoundSet.getAminoAcidCompoundSet();
  assertTrue(compoundSet.isValidSequence(seq));
  Jronn.getDisorderScores(seq);
}",0.869983948635634
16916,"/** 
 * Fetch a protein sequence from the UniProt web site
 * @param uniProtID
 * @return a Protein Sequence
 * @throws Exception
 */
private static ProteinSequence getUniprot(String uniProtID) throws Exception {
  AminoAcidCompoundSet set=AminoAcidCompoundSet.getAminoAcidCompoundSet();
  UniprotProxySequenceReader<AminoAcidCompound> uniprotSequence=new UniprotProxySequenceReader<AminoAcidCompound>(uniProtID,set);
  ProteinSequence seq=new ProteinSequence(uniprotSequence);
  return seq;
}","/** 
 * Fetch a protein sequence from the UniProt web site
 * @param uniProtID
 * @return a Protein Sequence
 * @throws IOException 
 * @throws CompoundNotFoundException
 */
private static ProteinSequence getUniprot(String uniProtID) throws CompoundNotFoundException, IOException {
  AminoAcidCompoundSet set=AminoAcidCompoundSet.getAminoAcidCompoundSet();
  UniprotProxySequenceReader<AminoAcidCompound> uniprotSequence=new UniprotProxySequenceReader<AminoAcidCompound>(uniProtID,set);
  ProteinSequence seq=new ProteinSequence(uniprotSequence);
  return seq;
}",0.9345971563981044
16917,"public Structure rebuildQuaternaryStructure(Structure asymUnit,List<BiologicalAssemblyTransformation> transformations){
  orderTransformationsByChainId(asymUnit,transformations);
  Structure s=asymUnit.clone();
  s.setChains(new ArrayList<Chain>());
  for (  BiologicalAssemblyTransformation transformation : transformations) {
    for (    Chain c : asymUnit.getChains()) {
      String intChainID=c.getInternalChainID();
      if (intChainID == null) {
        intChainID=c.getChainID();
      }
      if (transformation.getChainId().equals(intChainID)) {
        Chain chain=(Chain)c.clone();
        for (        Group g : chain.getAtomGroups()) {
          for (          Atom a : g.getAtoms()) {
            transformation.transformPoint(a.getCoords());
          }
        }
        int modelNumber=Integer.parseInt(transformation.getId());
        addChainAndModel(s,chain,modelNumber);
      }
    }
  }
  s.setBiologicalAssembly(true);
  return s;
}","public Structure rebuildQuaternaryStructure(Structure asymUnit,List<BiologicalAssemblyTransformation> transformations){
  orderTransformationsByChainId(asymUnit,transformations);
  Structure s=asymUnit.clone();
  s.setChains(new ArrayList<Chain>());
  for (  BiologicalAssemblyTransformation transformation : transformations) {
    for (    Chain c : asymUnit.getChains()) {
      String intChainID=c.getInternalChainID();
      if (intChainID == null) {
        intChainID=c.getChainID();
      }
      if (transformation.getChainId().equals(intChainID)) {
        Chain chain=(Chain)c.clone();
        for (        Group g : chain.getAtomGroups()) {
          for (          Atom a : g.getAtoms()) {
            transformation.transformPoint(a.getCoords());
          }
        }
        String transformId=transformation.getId();
        addChainAndModel(s,chain,transformId);
      }
    }
  }
  s.setBiologicalAssembly(true);
  return s;
}",0.8334209143457698
16918,"private void addChainAndModel(Structure s,Chain newChain,int modelCount){
  if (modelCount == 0) {
    s.addChain(newChain);
  }
 else   if (modelCount > s.nrModels()) {
    List<Chain> newModel=new ArrayList<Chain>();
    newModel.add(newChain);
    s.addModel(newModel);
  }
 else {
    s.addChain(newChain,modelCount - 1);
  }
}","private void addChainAndModel(Structure s,Chain newChain,String modelId){
  int modelCount=modelIndex.indexOf(modelId);
  if (modelCount == -1) {
    modelIndex.add(modelId);
    modelCount=modelIndex.indexOf(modelId);
  }
  if (modelCount == 0) {
    s.addChain(newChain);
  }
 else   if (modelCount > s.nrModels()) {
    List<Chain> newModel=new ArrayList<Chain>();
    newModel.add(newChain);
    s.addModel(newModel);
  }
 else {
    s.addChain(newChain,modelCount - 1);
  }
}",0.781750924784217
16919,"/** 
 * Get the status of the a collection of PDBs in question in a single query.
 * @see #getStatus(String)
 * @param pdbIds
 * @return The status array, or null if an error occurred.
 */
public static Status[] getStatus(String[] pdbIds){
  Status[] statuses=new Status[pdbIds.length];
  List<Map<String,String>> attrList=getStatusIdRecords(pdbIds);
  if (attrList == null || attrList.size() != pdbIds.length) {
    logger.error(""String_Node_Str"" + pdbIds + ""String_Node_Str"");
    return null;
  }
  for (int pdbNum=0; pdbNum < pdbIds.length; pdbNum++) {
    boolean foundAttr=false;
    for (    Map<String,String> attrs : attrList) {
      String id=attrs.get(""String_Node_Str"");
      if (id == null || !id.equalsIgnoreCase(pdbIds[pdbNum])) {
        continue;
      }
      String statusStr=attrs.get(""String_Node_Str"");
      if (statusStr == null) {
        logger.error(""String_Node_Str"" + pdbIds[pdbNum]);
        statuses[pdbNum]=null;
      }
      Status status=Status.fromString(statusStr);
      if (status == null) {
        logger.error(""String_Node_Str"" + statusStr + ""String_Node_Str"");
        statuses[pdbNum]=null;
      }
      statuses[pdbNum]=status;
      foundAttr=true;
    }
    if (!foundAttr) {
      logger.error(""String_Node_Str"" + pdbIds[pdbNum]);
      statuses[pdbNum]=null;
    }
  }
  return statuses;
}","/** 
 * Get the status of the a collection of PDBs in question in a single query.
 * @see #getStatus(String)
 * @param pdbIds
 * @return The status array, or null if an error occurred.
 */
public static Status[] getStatus(String[] pdbIds){
  Status[] statuses=new Status[pdbIds.length];
  List<Map<String,String>> attrList=getStatusIdRecords(pdbIds);
  if (attrList == null || attrList.size() != pdbIds.length) {
    logger.error(""String_Node_Str"",Arrays.toString(pdbIds));
    return null;
  }
  for (int pdbNum=0; pdbNum < pdbIds.length; pdbNum++) {
    boolean foundAttr=false;
    for (    Map<String,String> attrs : attrList) {
      String id=attrs.get(""String_Node_Str"");
      if (id == null || !id.equalsIgnoreCase(pdbIds[pdbNum])) {
        continue;
      }
      String statusStr=attrs.get(""String_Node_Str"");
      Status status=null;
      if (statusStr == null) {
        logger.error(""String_Node_Str"" + pdbIds[pdbNum]);
        statuses[pdbNum]=null;
      }
 else {
        status=Status.fromString(statusStr);
      }
      if (status == null) {
        logger.error(""String_Node_Str"",statusStr);
        statuses[pdbNum]=null;
      }
      statuses[pdbNum]=status;
      foundAttr=true;
    }
    if (!foundAttr) {
      logger.error(""String_Node_Str"" + pdbIds[pdbNum]);
      statuses[pdbNum]=null;
    }
  }
  return statuses;
}",0.9472511144130756
16920,"/** 
 * Returns a list of current PDB IDs
 * @return a list of PDB IDs, or null if a problem occurred
 */
public static SortedSet<String> getCurrentPDBIds(){
  SortedSet<String> allPDBs=new TreeSet<String>();
  String serverName=System.getProperty(PDB_SERVER_PROPERTY);
  if (serverName == null)   serverName=DEFAULT_PDB_SERVER;
 else   logger.info(String.format(""String_Node_Str"",PDB_SERVER_PROPERTY,serverName));
  String urlStr=String.format(""String_Node_Str"",serverName);
  try {
    URL u=new URL(urlStr);
    InputStream stream=HTTPConnectionTools.getInputStream(u,60000);
    if (stream != null) {
      BufferedReader reader=new BufferedReader(new InputStreamReader(stream));
      String line=null;
      while ((line=reader.readLine()) != null) {
        int index=line.lastIndexOf(""String_Node_Str"");
        if (index > 0) {
          allPDBs.add(line.substring(index + 13,index + 17));
        }
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    return null;
  }
  return allPDBs;
}","/** 
 * Returns a list of current PDB IDs
 * @return a list of PDB IDs, or null if a problem occurred
 */
public static SortedSet<String> getCurrentPDBIds(){
  SortedSet<String> allPDBs=new TreeSet<String>();
  String serverName=System.getProperty(PDB_SERVER_PROPERTY);
  if (serverName == null)   serverName=DEFAULT_PDB_SERVER;
 else   logger.info(String.format(""String_Node_Str"",PDB_SERVER_PROPERTY,serverName));
  String urlStr=String.format(""String_Node_Str"",serverName);
  try {
    URL u=new URL(urlStr);
    InputStream stream=HTTPConnectionTools.getInputStream(u,60000);
    if (stream != null) {
      BufferedReader reader=new BufferedReader(new InputStreamReader(stream));
      String line=null;
      while ((line=reader.readLine()) != null) {
        int index=line.lastIndexOf(""String_Node_Str"");
        if (index > 0) {
          allPDBs.add(line.substring(index + 13,index + 17));
        }
      }
    }
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"",e);
    return null;
  }
  return allPDBs;
}",0.9766081871345028
16921,"public void testFetchCurrent() throws IOException, StructureException {
  cache.setAutoFetch(true);
  cache.setFetchCurrent(true);
  cache.setFetchFileEvenIfObsolete(false);
  Structure s;
  try {
    s=cache.getStructure(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"");
  }
catch (  StructureException e) {
    System.err.println(""String_Node_Str"");
  }
  s=cache.getStructure(""String_Node_Str"");
  assertEquals(""String_Node_Str"",""String_Node_Str"",s.getPDBCode());
}","public void testFetchCurrent() throws IOException, StructureException {
  cache.setUseMmCif(false);
  cache.setAutoFetch(true);
  cache.setFetchCurrent(true);
  cache.setFetchFileEvenIfObsolete(false);
  Structure s;
  try {
    s=cache.getStructure(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"");
  }
catch (  StructureException e) {
    System.err.println(""String_Node_Str"");
  }
  s=cache.getStructure(""String_Node_Str"");
  assertEquals(""String_Node_Str"",""String_Node_Str"",s.getPDBCode());
}",0.9747747747747748
16922,"public void setUp(){
  String cacheDir=cache.getPath();
  String[] uncacheIDs=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ArrayList<String> extensions=new ArrayList<String>();
  extensions.add(""String_Node_Str"");
  extensions.add(""String_Node_Str"");
  extensions.add(""String_Node_Str"");
  extensions.add(""String_Node_Str"");
  extensions.add(""String_Node_Str"");
  extensions.add(""String_Node_Str"");
  for (  String pdbId : uncacheIDs) {
    String middle=pdbId.substring(1,3).toLowerCase();
    String fpath=cacheDir + lineSplit + middle+ lineSplit+ pdbId;
    String ppath=cacheDir + lineSplit + middle+ lineSplit+ ""String_Node_Str""+ pdbId;
    String[] paths=new String[]{fpath,ppath};
    for (int p=0; p < paths.length; p++) {
      String testpath=paths[p];
      for (int i=0; i < extensions.size(); i++) {
        String ex=(String)extensions.get(i);
        File f=new File(testpath + ex);
        if (f.exists()) {
          System.out.println(""String_Node_Str"" + testpath + ex);
          assertTrue(""String_Node_Str"" + testpath + ex+ ""String_Node_Str"",f.delete());
        }
      }
    }
  }
}","public void setUp(){
  cache=new AtomCache();
  String cacheDir=cache.getPath();
  String[] uncacheIDs=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ArrayList<String> extensions=new ArrayList<String>();
  extensions.add(""String_Node_Str"");
  extensions.add(""String_Node_Str"");
  extensions.add(""String_Node_Str"");
  extensions.add(""String_Node_Str"");
  extensions.add(""String_Node_Str"");
  extensions.add(""String_Node_Str"");
  for (  String pdbId : uncacheIDs) {
    String middle=pdbId.substring(1,3).toLowerCase();
    String fpath=cacheDir + lineSplit + middle+ lineSplit+ pdbId;
    String ppath=cacheDir + lineSplit + middle+ lineSplit+ ""String_Node_Str""+ pdbId;
    String[] paths=new String[]{fpath,ppath};
    for (int p=0; p < paths.length; p++) {
      String testpath=paths[p];
      for (int i=0; i < extensions.size(); i++) {
        String ex=(String)extensions.get(i);
        File f=new File(testpath + ex);
        if (f.exists()) {
          System.out.println(""String_Node_Str"" + testpath + ex);
          assertTrue(""String_Node_Str"" + testpath + ex+ ""String_Node_Str"",f.delete());
        }
      }
    }
  }
}",0.9890686488850022
16923,"public void testFetchObsolete() throws IOException, StructureException {
  cache.setAutoFetch(true);
  cache.setFetchCurrent(false);
  cache.setFetchFileEvenIfObsolete(true);
  Structure s;
  s=cache.getStructure(""String_Node_Str"");
  assertEquals(""String_Node_Str"",""String_Node_Str"",s.getPDBCode());
  s=cache.getStructure(""String_Node_Str"");
  assertEquals(""String_Node_Str"",""String_Node_Str"",s.getPDBCode());
  System.err.println(""String_Node_Str"");
}","public void testFetchObsolete() throws IOException, StructureException {
  cache.setUseMmCif(false);
  cache.setAutoFetch(true);
  cache.setFetchCurrent(false);
  cache.setFetchFileEvenIfObsolete(true);
  Structure s;
  s=cache.getStructure(""String_Node_Str"");
  assertEquals(""String_Node_Str"",""String_Node_Str"",s.getPDBCode());
  s=cache.getStructure(""String_Node_Str"");
  assertEquals(""String_Node_Str"",""String_Node_Str"",s.getPDBCode());
  System.err.println(""String_Node_Str"");
}",0.97008547008547
16924,"public void testLoadStructureFromURL() throws IOException, StructureException {
  try {
    AtomCache cache=new AtomCache();
    String path=cache.getPath();
    path+=""String_Node_Str"" + FILE_SEPARATOR;
    File f=new File(path);
    if (!f.exists()) {
      System.out.println(""String_Node_Str"" + f);
      f.mkdir();
    }
    AtomCache c=new AtomCache(path,true);
    c.getStructure(""String_Node_Str"");
    File newFile=new File(path + FILE_SEPARATOR + ""String_Node_Str""+ FILE_SEPARATOR+ ""String_Node_Str"");
    URL u=newFile.toURI().toURL();
    System.out.println(u);
    Structure s=c.getStructure(u.toString() + ""String_Node_Str"");
    System.out.println(s);
  }
 catch (  Exception e) {
    fail(e.getMessage());
  }
}","public void testLoadStructureFromURL() throws IOException, StructureException {
  try {
    AtomCache cache=new AtomCache();
    String path=cache.getPath();
    path+=""String_Node_Str"" + FILE_SEPARATOR;
    File f=new File(path);
    if (!f.exists()) {
      System.out.println(""String_Node_Str"" + f);
      f.mkdir();
    }
    AtomCache c=new AtomCache(path,true);
    c.setUseMmCif(false);
    c.getStructure(""String_Node_Str"");
    File newFile=new File(path + FILE_SEPARATOR + ""String_Node_Str""+ FILE_SEPARATOR+ ""String_Node_Str"");
    URL u=newFile.toURI().toURL();
    System.out.println(u);
    Structure s=c.getStructure(u.toString() + ""String_Node_Str"");
    System.out.println(s);
  }
 catch (  Exception e) {
    fail(e.getMessage());
  }
}",0.9824324324324324
16925,"/** 
 * Swaps the order of structures in an AFPChain
 * @param a
 * @return
 */
public AFPChain invertAlignment(AFPChain a){
  String name1=a.getName1();
  String name2=a.getName2();
  a.setName1(name2);
  a.setName2(name1);
  int len1=a.getCa1Length();
  a.setCa1Length(a.getCa2Length());
  a.setCa2Length(len1);
  int beg1=a.getAlnbeg1();
  a.setAlnbeg1(a.getAlnbeg2());
  a.setAlnbeg2(beg1);
  char[] alnseq1=a.getAlnseq1();
  a.setAlnseq1(a.getAlnseq2());
  a.setAlnseq2(alnseq1);
  Matrix distab1=a.getDisTable1();
  a.setDisTable1(a.getDisTable2());
  a.setDisTable2(distab1);
  int[] focusRes1=a.getFocusRes1();
  a.setFocusRes1(a.getFocusRes2());
  a.setFocusRes2(focusRes1);
  String[][][] pdbAln=a.getPdbAln();
  if (pdbAln != null) {
    for (int block=0; block < a.getBlockNum(); block++) {
      String[] paln1=pdbAln[block][0];
      pdbAln[block][0]=pdbAln[block][1];
      pdbAln[block][1]=paln1;
    }
  }
  int[][][] optAln=a.getOptAln();
  if (optAln != null) {
    for (int block=0; block < a.getBlockNum(); block++) {
      int[] aln1=optAln[block][0];
      optAln[block][0]=optAln[block][1];
      optAln[block][1]=aln1;
    }
  }
  a.setOptAln(optAln);
  Matrix distmat=a.getDistanceMatrix();
  if (distmat != null)   a.setDistanceMatrix(distmat.transpose());
  Matrix[] blockRotMat=a.getBlockRotationMatrix();
  Atom[] shiftVec=a.getBlockShiftVector();
  if (blockRotMat != null) {
    for (int block=0; block < a.getBlockNum(); block++) {
      if (blockRotMat[block] != null) {
        blockRotMat[block]=blockRotMat[block].inverse();
        Calc.rotate(shiftVec[block],blockRotMat[block]);
        try {
          shiftVec[block]=Calc.invert(shiftVec[block]);
        }
 catch (        StructureException e) {
        }
      }
    }
  }
  return a;
}","/** 
 * Swaps the order of structures in an AFPChain
 * @param a
 * @return
 */
public AFPChain invertAlignment(AFPChain a){
  String name1=a.getName1();
  String name2=a.getName2();
  a.setName1(name2);
  a.setName2(name1);
  int len1=a.getCa1Length();
  a.setCa1Length(a.getCa2Length());
  a.setCa2Length(len1);
  int beg1=a.getAlnbeg1();
  a.setAlnbeg1(a.getAlnbeg2());
  a.setAlnbeg2(beg1);
  char[] alnseq1=a.getAlnseq1();
  a.setAlnseq1(a.getAlnseq2());
  a.setAlnseq2(alnseq1);
  Matrix distab1=a.getDisTable1();
  a.setDisTable1(a.getDisTable2());
  a.setDisTable2(distab1);
  int[] focusRes1=a.getFocusRes1();
  a.setFocusRes1(a.getFocusRes2());
  a.setFocusRes2(focusRes1);
  String[][][] pdbAln=a.getPdbAln();
  if (pdbAln != null) {
    for (int block=0; block < a.getBlockNum(); block++) {
      String[] paln1=pdbAln[block][0];
      pdbAln[block][0]=pdbAln[block][1];
      pdbAln[block][1]=paln1;
    }
  }
  int[][][] optAln=a.getOptAln();
  if (optAln != null) {
    for (int block=0; block < a.getBlockNum(); block++) {
      int[] aln1=optAln[block][0];
      optAln[block][0]=optAln[block][1];
      optAln[block][1]=aln1;
    }
  }
  a.setOptAln(optAln);
  Matrix distmat=a.getDistanceMatrix();
  if (distmat != null)   a.setDistanceMatrix(distmat.transpose());
  Matrix[] blockRotMat=a.getBlockRotationMatrix();
  Atom[] shiftVec=a.getBlockShiftVector();
  if (blockRotMat != null) {
    for (int block=0; block < a.getBlockNum(); block++) {
      if (blockRotMat[block] != null) {
        blockRotMat[block]=blockRotMat[block].inverse();
        Calc.rotate(shiftVec[block],blockRotMat[block]);
        shiftVec[block]=Calc.invert(shiftVec[block]);
      }
    }
  }
  return a;
}",0.9724454649827784
16926,"/** 
 * Swaps the order of structures in an AFPChain
 * @param a
 * @return
 */
public AFPChain invertAlignment(AFPChain a){
  String name1=a.getName1();
  String name2=a.getName2();
  a.setName1(name2);
  a.setName2(name1);
  int len1=a.getCa1Length();
  a.setCa1Length(a.getCa2Length());
  a.setCa2Length(len1);
  int beg1=a.getAlnbeg1();
  a.setAlnbeg1(a.getAlnbeg2());
  a.setAlnbeg2(beg1);
  char[] alnseq1=a.getAlnseq1();
  a.setAlnseq1(a.getAlnseq2());
  a.setAlnseq2(alnseq1);
  Matrix distab1=a.getDisTable1();
  a.setDisTable1(a.getDisTable2());
  a.setDisTable2(distab1);
  int[] focusRes1=a.getFocusRes1();
  a.setFocusRes1(a.getFocusRes2());
  a.setFocusRes2(focusRes1);
  String[][][] pdbAln=a.getPdbAln();
  if (pdbAln != null) {
    for (int block=0; block < a.getBlockNum(); block++) {
      String[] paln1=pdbAln[block][0];
      pdbAln[block][0]=pdbAln[block][1];
      pdbAln[block][1]=paln1;
    }
  }
  int[][][] optAln=a.getOptAln();
  int[] optLen=a.getOptLen();
  if (optAln != null) {
    for (int block=0; block < a.getBlockNum(); block++) {
      int[] aln1=optAln[block][0];
      optAln[block][0]=optAln[block][1];
      optAln[block][1]=aln1;
    }
  }
  a.setOptAln(optAln);
  Matrix distmat=a.getDistanceMatrix();
  if (distmat != null)   a.setDistanceMatrix(distmat.transpose());
  Matrix[] blockRotMat=a.getBlockRotationMatrix();
  Atom[] shiftVec=a.getBlockShiftVector();
  if (blockRotMat != null) {
    for (int block=0; block < a.getBlockNum(); block++) {
      if (blockRotMat[block] != null) {
        blockRotMat[block]=blockRotMat[block].inverse();
        try {
          shiftVec[block]=Calc.invert(shiftVec[block]);
        }
 catch (        StructureException e) {
        }
      }
    }
  }
  return a;
}","/** 
 * Swaps the order of structures in an AFPChain
 * @param a
 * @return
 */
public AFPChain invertAlignment(AFPChain a){
  String name1=a.getName1();
  String name2=a.getName2();
  a.setName1(name2);
  a.setName2(name1);
  int len1=a.getCa1Length();
  a.setCa1Length(a.getCa2Length());
  a.setCa2Length(len1);
  int beg1=a.getAlnbeg1();
  a.setAlnbeg1(a.getAlnbeg2());
  a.setAlnbeg2(beg1);
  char[] alnseq1=a.getAlnseq1();
  a.setAlnseq1(a.getAlnseq2());
  a.setAlnseq2(alnseq1);
  Matrix distab1=a.getDisTable1();
  a.setDisTable1(a.getDisTable2());
  a.setDisTable2(distab1);
  int[] focusRes1=a.getFocusRes1();
  a.setFocusRes1(a.getFocusRes2());
  a.setFocusRes2(focusRes1);
  String[][][] pdbAln=a.getPdbAln();
  if (pdbAln != null) {
    for (int block=0; block < a.getBlockNum(); block++) {
      String[] paln1=pdbAln[block][0];
      pdbAln[block][0]=pdbAln[block][1];
      pdbAln[block][1]=paln1;
    }
  }
  int[][][] optAln=a.getOptAln();
  int[] optLen=a.getOptLen();
  if (optAln != null) {
    for (int block=0; block < a.getBlockNum(); block++) {
      int[] aln1=optAln[block][0];
      optAln[block][0]=optAln[block][1];
      optAln[block][1]=aln1;
    }
  }
  a.setOptAln(optAln);
  Matrix distmat=a.getDistanceMatrix();
  if (distmat != null)   a.setDistanceMatrix(distmat.transpose());
  Matrix[] blockRotMat=a.getBlockRotationMatrix();
  Atom[] shiftVec=a.getBlockShiftVector();
  if (blockRotMat != null) {
    for (int block=0; block < a.getBlockNum(); block++) {
      if (blockRotMat[block] != null) {
        blockRotMat[block]=blockRotMat[block].inverse();
        Calc.rotate(shiftVec[block],blockRotMat[block]);
        try {
          shiftVec[block]=Calc.invert(shiftVec[block]);
        }
 catch (        StructureException e) {
        }
      }
    }
  }
  return a;
}",0.9840022452989056
16927,"/** 
 * Get the space group for the given international short name, using the PDB format, e.g. 'P 21 21 21' or 'C 1 c 1'
 * @param shortName
 * @return the SpaceGroup or null if the shortName is not valid
 */
public static SpaceGroup getSpaceGroup(String shortName){
  if (shortName == null)   return null;
  if (shortName.equals(""String_Node_Str""))   shortName=""String_Node_Str"";
  shortName=shortName.substring(0,1) + shortName.substring(1).toLowerCase();
  return name2sgs.get(shortName);
}","/** 
 * Get the space group for the given international short name, using the PDB format, e.g. 'P 21 21 21' or 'C 1 c 1'
 * @param shortName
 * @return the SpaceGroup or null if the shortName is not valid
 */
public static SpaceGroup getSpaceGroup(String shortName){
  if (shortName == null || shortName.length() <= 2)   return null;
  if (shortName.equals(""String_Node_Str""))   shortName=""String_Node_Str"";
  shortName=shortName.substring(0,1) + shortName.substring(1).toLowerCase();
  return name2sgs.get(shortName);
}",0.9733464955577492
16928,"/** 
 * Swaps the order of structures in an AFPChain
 * @param a
 * @return
 */
public AFPChain invertAlignment(AFPChain a){
  String name1=a.getName1();
  String name2=a.getName2();
  a.setName1(name2);
  a.setName2(name1);
  int len1=a.getCa1Length();
  a.setCa1Length(a.getCa2Length());
  a.setCa2Length(len1);
  int beg1=a.getAlnbeg1();
  a.setAlnbeg1(a.getAlnbeg2());
  a.setAlnbeg2(beg1);
  char[] alnseq1=a.getAlnseq1();
  a.setAlnseq1(a.getAlnseq2());
  a.setAlnseq2(alnseq1);
  Matrix distab1=a.getDisTable1();
  a.setDisTable1(a.getDisTable2());
  a.setDisTable2(distab1);
  int[] focusRes1=a.getFocusRes1();
  a.setFocusRes1(a.getFocusRes2());
  a.setFocusRes2(focusRes1);
  String[][][] pdbAln=a.getPdbAln();
  if (pdbAln != null) {
    for (int block=0; block < a.getBlockNum(); block++) {
      String[] paln1=pdbAln[block][0];
      pdbAln[block][0]=pdbAln[block][1];
      pdbAln[block][1]=paln1;
    }
  }
  int[][][] optAln=a.getOptAln();
  int[] optLen=a.getOptLen();
  if (optAln != null) {
    for (int block=0; block < a.getBlockNum(); block++) {
      int[] aln1=optAln[block][0];
      optAln[block][0]=optAln[block][1];
      optAln[block][1]=aln1;
    }
  }
  a.setOptAln(optAln);
  Matrix distmat=a.getDistanceMatrix();
  if (distmat != null)   a.setDistanceMatrix(distmat.transpose());
  Matrix[] blockRotMat=a.getBlockRotationMatrix();
  Atom[] shiftVec=a.getBlockShiftVector();
  if (blockRotMat != null) {
    for (int block=0; block < a.getBlockNum(); block++) {
      if (blockRotMat[block] != null) {
        blockRotMat[block]=blockRotMat[block].inverse();
        shiftVec[block]=Calc.invert(shiftVec[block]);
      }
    }
  }
  return a;
}","/** 
 * Swaps the order of structures in an AFPChain
 * @param a
 * @return
 */
public AFPChain invertAlignment(AFPChain a){
  String name1=a.getName1();
  String name2=a.getName2();
  a.setName1(name2);
  a.setName2(name1);
  int len1=a.getCa1Length();
  a.setCa1Length(a.getCa2Length());
  a.setCa2Length(len1);
  int beg1=a.getAlnbeg1();
  a.setAlnbeg1(a.getAlnbeg2());
  a.setAlnbeg2(beg1);
  char[] alnseq1=a.getAlnseq1();
  a.setAlnseq1(a.getAlnseq2());
  a.setAlnseq2(alnseq1);
  Matrix distab1=a.getDisTable1();
  a.setDisTable1(a.getDisTable2());
  a.setDisTable2(distab1);
  int[] focusRes1=a.getFocusRes1();
  a.setFocusRes1(a.getFocusRes2());
  a.setFocusRes2(focusRes1);
  String[][][] pdbAln=a.getPdbAln();
  if (pdbAln != null) {
    for (int block=0; block < a.getBlockNum(); block++) {
      String[] paln1=pdbAln[block][0];
      pdbAln[block][0]=pdbAln[block][1];
      pdbAln[block][1]=paln1;
    }
  }
  int[][][] optAln=a.getOptAln();
  int[] optLen=a.getOptLen();
  if (optAln != null) {
    for (int block=0; block < a.getBlockNum(); block++) {
      int[] aln1=optAln[block][0];
      optAln[block][0]=optAln[block][1];
      optAln[block][1]=aln1;
    }
  }
  a.setOptAln(optAln);
  Matrix distmat=a.getDistanceMatrix();
  if (distmat != null)   a.setDistanceMatrix(distmat.transpose());
  Matrix[] blockRotMat=a.getBlockRotationMatrix();
  Atom[] shiftVec=a.getBlockShiftVector();
  if (blockRotMat != null) {
    for (int block=0; block < a.getBlockNum(); block++) {
      if (blockRotMat[block] != null) {
        blockRotMat[block]=blockRotMat[block].inverse();
        try {
          shiftVec[block]=Calc.invert(shiftVec[block]);
        }
 catch (        StructureException e) {
        }
      }
    }
  }
  return a;
}",0.97201166180758
16929,"/** 
 * Handler for HEADER Record Format COLUMNS        DATA TYPE       FIELD           DEFINITION ---------------------------------------------------------------------------------- 1 -  6        Record name     ""HEADER"" 11 - 50        String(40)      classification  Classifies the molecule(s) 51 - 59        Date            depDate         Deposition date.  This is the date the coordinates were received by the PDB 63 - 66        IDcode          idCode          This identifier is unique within PDB
 */
private void pdb_HEADER_Handler(String line){
  String classification=null;
  String deposition_date=null;
  String pdbCode=null;
  int len=line.trim().length();
  if (len > 10) {
    classification=line.substring(10,max(len,50)).trim();
    pdbHeader.setClassification(classification);
  }
  if (len > 50) {
    deposition_date=line.substring(50,max(len,59)).trim();
    try {
      Date dep=dateFormat.parse(deposition_date);
      pdbHeader.setDepDate(dep);
    }
 catch (    ParseException e) {
      logger.fine(""String_Node_Str"" + deposition_date + ""String_Node_Str"");
    }
  }
  if (len > 62) {
    pdbCode=line.substring(62,max(len,66)).trim();
    pdbId=pdbCode;
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + pdbId);
    }
    structure.setPDBCode(pdbCode);
    pdbHeader.setIdCode(pdbCode);
  }
  if (len > 66) {
    if (pdbId.equals(line.substring(72,76))) {
      isLegacyFormat=true;
      System.out.println(pdbId + ""String_Node_Str"");
    }
  }
}","/** 
 * Handler for HEADER Record Format COLUMNS        DATA TYPE       FIELD           DEFINITION ---------------------------------------------------------------------------------- 1 -  6        Record name     ""HEADER"" 11 - 50        String(40)      classification  Classifies the molecule(s) 51 - 59        Date            depDate         Deposition date.  This is the date the coordinates were received by the PDB 63 - 66        IDcode          idCode          This identifier is unique within PDB
 */
private void pdb_HEADER_Handler(String line){
  String classification=null;
  String deposition_date=null;
  String pdbCode=null;
  int len=line.trim().length();
  if (len > 10) {
    classification=line.substring(10,min(len,50)).trim();
    pdbHeader.setClassification(classification);
  }
  if (len > 50) {
    deposition_date=line.substring(50,min(len,59)).trim();
    try {
      Date dep=dateFormat.parse(deposition_date);
      pdbHeader.setDepDate(dep);
    }
 catch (    ParseException e) {
      logger.fine(""String_Node_Str"" + deposition_date + ""String_Node_Str"");
    }
  }
  if (len > 62) {
    pdbCode=line.substring(62,min(len,66)).trim();
    pdbId=pdbCode;
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + pdbId);
    }
    structure.setPDBCode(pdbCode);
    pdbHeader.setIdCode(pdbCode);
  }
  if (len > 66) {
    if (pdbId.equals(line.substring(72,76))) {
      isLegacyFormat=true;
      System.out.println(pdbId + ""String_Node_Str"");
    }
  }
}",0.995956873315364
16930,"/** 
 * Handler for TITLE Record Format COLUMNS        DATA TYPE       FIELD          DEFINITION ---------------------------------------------------------------------------------- 1 -  6        Record name     ""TITLE "" 9 - 10        Continuation    continuation   Allows concatenation of multiple records. 11 - 70        String          title          Title of the experiment.
 */
private void pdb_TITLE_Handler(String line){
  String title;
  if (line.length() > 79)   title=line.substring(10,80).trim();
 else   title=line.substring(10,line.length()).trim();
  String t=pdbHeader.getTitle();
  if ((t != null) && (!t.equals(""String_Node_Str"")))   t+=""String_Node_Str"";
 else   t=""String_Node_Str"";
  t+=title;
  pdbHeader.setTitle(t);
}","/** 
 * Handler for TITLE Record Format COLUMNS        DATA TYPE       FIELD          DEFINITION ---------------------------------------------------------------------------------- 1 -  6        Record name     ""TITLE "" 9 - 10        Continuation    continuation   Allows concatenation of multiple records. 11 - 70        String          title          Title of the experiment.
 */
private void pdb_TITLE_Handler(String line){
  String title;
  if (line.length() > 79)   title=line.substring(10,80).trim();
 else   title=line.substring(10,line.length()).trim();
  String t=pdbHeader.getTitle();
  if ((t != null) && (!t.equals(""String_Node_Str""))) {
    if (t.endsWith(""String_Node_Str""))     t+=""String_Node_Str"";
 else     t+=""String_Node_Str"";
  }
 else   t=""String_Node_Str"";
  t+=title;
  pdbHeader.setTitle(t);
}",0.9221864951768488
16931,"/** 
 * Handler for CRYST1 Record Format The CRYST1 record presents the unit cell parameters, space group, and Z value. If the entry describes a structure determined by a technique other than X-ray crystallography, CRYST1 contains a = b = c = 1.0, alpha = beta = gamma = 90 degrees, space group = P 1, and Z =1. COLUMNS DATA TYPE    FIELD          DEFINITION ------------------------------------------------------------- 1 - 6  Record name  ""CRYST1"" 7 - 15 Real(9.3)    a              a (Angstroms). 16 - 24 Real(9.3)    b              b (Angstroms). 25 - 33 Real(9.3)    c              c (Angstroms). 34 - 40 Real(7.2)    alpha          alpha (degrees). 41 - 47 Real(7.2)    beta           beta (degrees). 48 - 54 Real(7.2)    gamma          gamma (degrees). 56 - 66 LString      sGroup         Space group. 67 - 70 Integer      z              Z value.
 */
private void pdb_CRYST1_Handler(String line){
  if (line.length() < 69) {
    return;
  }
  float a;
  float b;
  float c;
  float alpha;
  float beta;
  float gamma;
  String spaceGroup=""String_Node_Str"";
  int z;
  try {
    a=Float.parseFloat(line.substring(6,15).trim());
    b=Float.parseFloat(line.substring(15,24).trim());
    c=Float.parseFloat(line.substring(24,33).trim());
    alpha=Float.parseFloat(line.substring(33,40).trim());
    beta=Float.parseFloat(line.substring(40,47).trim());
    gamma=Float.parseFloat(line.substring(47,54).trim());
    z=Integer.parseInt(line.substring(66,70).trim());
  }
 catch (  NumberFormatException e) {
    logger.fine(e.getMessage());
    logger.fine(""String_Node_Str"" + line);
    return;
  }
  spaceGroup=line.substring(55,66).trim();
  if (a == 1.0f && b == 1.0f && c == 1.0f && alpha == 90.0f && beta == 90.0f && gamma == 90.0f && spaceGroup.equals(""String_Node_Str"") && z == 1) {
    return;
  }
  CrystalCell xtalCell=new CrystalCell();
  crystallographicInfo.setCrystalCell(xtalCell);
  xtalCell.setA(a);
  xtalCell.setB(b);
  xtalCell.setC(c);
  xtalCell.setAlpha(alpha);
  xtalCell.setBeta(beta);
  xtalCell.setGamma(gamma);
  SpaceGroup sg=SymoplibParser.getSpaceGroup(spaceGroup);
  if (sg == null)   logger.warning(""String_Node_Str"" + spaceGroup + ""String_Node_Str"");
  crystallographicInfo.setSpaceGroup(sg);
  crystallographicInfo.setZ(z);
}","/** 
 * Handler for CRYST1 Record Format The CRYST1 record presents the unit cell parameters, space group, and Z value. If the entry describes a structure determined by a technique other than X-ray crystallography, CRYST1 contains a = b = c = 1.0, alpha = beta = gamma = 90 degrees, space group = P 1, and Z =1. COLUMNS DATA TYPE    FIELD          DEFINITION ------------------------------------------------------------- 1 - 6  Record name  ""CRYST1"" 7 - 15 Real(9.3)    a              a (Angstroms). 16 - 24 Real(9.3)    b              b (Angstroms). 25 - 33 Real(9.3)    c              c (Angstroms). 34 - 40 Real(7.2)    alpha          alpha (degrees). 41 - 47 Real(7.2)    beta           beta (degrees). 48 - 54 Real(7.2)    gamma          gamma (degrees). 56 - 66 LString      sGroup         Space group. 67 - 70 Integer      z              Z value.
 */
private void pdb_CRYST1_Handler(String line){
  if (line.length() < 69) {
    return;
  }
  float a;
  float b;
  float c;
  float alpha;
  float beta;
  float gamma;
  String spaceGroup=""String_Node_Str"";
  int z;
  try {
    a=Float.parseFloat(line.substring(6,15).trim());
    b=Float.parseFloat(line.substring(15,24).trim());
    c=Float.parseFloat(line.substring(24,33).trim());
    alpha=Float.parseFloat(line.substring(33,40).trim());
    beta=Float.parseFloat(line.substring(40,47).trim());
    gamma=Float.parseFloat(line.substring(47,54).trim());
    z=Integer.parseInt(line.substring(66,70).trim());
  }
 catch (  NumberFormatException e) {
    logger.fine(e.getMessage());
    logger.fine(""String_Node_Str"" + line);
    return;
  }
  spaceGroup=line.substring(55,66).trim();
  if (a == 1.0f && b == 1.0f && c == 1.0f && alpha == 90.0f && beta == 90.0f && gamma == 90.0f && spaceGroup.equals(""String_Node_Str"") && z == 1) {
    return;
  }
  CrystalCell xtalCell=new CrystalCell();
  crystallographicInfo.setCrystalCell(xtalCell);
  xtalCell.setA(a);
  xtalCell.setB(b);
  xtalCell.setC(c);
  xtalCell.setAlpha(alpha);
  xtalCell.setBeta(beta);
  xtalCell.setGamma(gamma);
  SpaceGroup sg=SymoplibParser.getSpaceGroup(spaceGroup);
  if (sg == null)   logger.fine(""String_Node_Str"" + spaceGroup + ""String_Node_Str"");
  crystallographicInfo.setSpaceGroup(sg);
  crystallographicInfo.setZ(z);
}",0.9975679858500996
16932,"public void newCell(Cell cell){
  try {
    float a=Float.parseFloat(cell.getLength_a());
    float b=Float.parseFloat(cell.getLength_b());
    float c=Float.parseFloat(cell.getLength_c());
    float alpha=Float.parseFloat(cell.getAngle_alpha());
    float beta=Float.parseFloat(cell.getAngle_beta());
    float gamma=Float.parseFloat(cell.getAngle_gamma());
    if (a == 1.0f && b == 1.0f && c == 1.0f && alpha == 90.0f && beta == 90.0f && gamma == 90.0f) {
      return;
    }
    CrystalCell xtalCell=new CrystalCell();
    structure.getPDBHeader().getCrystallographicInfo().setCrystalCell(xtalCell);
    xtalCell.setA(a);
    xtalCell.setB(b);
    xtalCell.setC(c);
    xtalCell.setAlpha(alpha);
    xtalCell.setBeta(beta);
    xtalCell.setGamma(gamma);
  }
 catch (  NumberFormatException e) {
    structure.getPDBHeader().getCrystallographicInfo().setCrystalCell(null);
    logger.warning(""String_Node_Str"");
  }
  try {
    structure.getPDBHeader().getCrystallographicInfo().setZ(Integer.parseInt(cell.getZ_PDB()));
  }
 catch (  NumberFormatException e) {
    logger.warning(""String_Node_Str"");
  }
}","public void newCell(Cell cell){
  try {
    float a=Float.parseFloat(cell.getLength_a());
    float b=Float.parseFloat(cell.getLength_b());
    float c=Float.parseFloat(cell.getLength_c());
    float alpha=Float.parseFloat(cell.getAngle_alpha());
    float beta=Float.parseFloat(cell.getAngle_beta());
    float gamma=Float.parseFloat(cell.getAngle_gamma());
    if (a == 1.0f && b == 1.0f && c == 1.0f && alpha == 90.0f && beta == 90.0f && gamma == 90.0f) {
      return;
    }
    CrystalCell xtalCell=new CrystalCell();
    structure.getPDBHeader().getCrystallographicInfo().setCrystalCell(xtalCell);
    xtalCell.setA(a);
    xtalCell.setB(b);
    xtalCell.setC(c);
    xtalCell.setAlpha(alpha);
    xtalCell.setBeta(beta);
    xtalCell.setGamma(gamma);
  }
 catch (  NumberFormatException e) {
    structure.getPDBHeader().getCrystallographicInfo().setCrystalCell(null);
    logger.fine(""String_Node_Str"" + e.getMessage() + ""String_Node_Str"");
  }
  try {
    structure.getPDBHeader().getCrystallographicInfo().setZ(Integer.parseInt(cell.getZ_PDB()));
  }
 catch (  NumberFormatException e) {
    logger.fine(""String_Node_Str"");
  }
}",0.9728526924788607
16933,"public void newRefine(Refine r){
  PDBHeader pdbHeader=structure.getPDBHeader();
  try {
    pdbHeader.setResolution(Float.parseFloat(r.getLs_d_res_high()));
  }
 catch (  NumberFormatException e) {
    logger.warning(""String_Node_Str"" + r.getLs_d_res_high() + ""String_Node_Str""+ e.getMessage());
  }
}","public void newRefine(Refine r){
  PDBHeader pdbHeader=structure.getPDBHeader();
  if (pdbHeader.getResolution() != PDBHeader.DEFAULT_RESOLUTION) {
    logger.fine(""String_Node_Str"" + r.getLs_d_res_high() + ""String_Node_Str""+ String.format(""String_Node_Str"",pdbHeader.getResolution())+ ""String_Node_Str"");
    return;
  }
  try {
    pdbHeader.setResolution(Float.parseFloat(r.getLs_d_res_high()));
  }
 catch (  NumberFormatException e) {
    logger.fine(""String_Node_Str"" + r.getLs_d_res_high() + ""String_Node_Str""+ e.getMessage());
  }
}",0.7007125890736342
16934,"public void newSymmetry(Symmetry symmetry){
  String spaceGroup=symmetry.getSpace_group_name_H_M();
  SpaceGroup sg=SymoplibParser.getSpaceGroup(spaceGroup);
  if (sg == null)   logger.warning(""String_Node_Str"" + spaceGroup + ""String_Node_Str"");
  structure.getPDBHeader().getCrystallographicInfo().setSpaceGroup(sg);
}","public void newSymmetry(Symmetry symmetry){
  String spaceGroup=symmetry.getSpace_group_name_H_M();
  SpaceGroup sg=SymoplibParser.getSpaceGroup(spaceGroup);
  if (sg == null)   logger.fine(""String_Node_Str"" + spaceGroup + ""String_Node_Str"");
  structure.getPDBHeader().getCrystallographicInfo().setSpaceGroup(sg);
}",0.9826771653543308
16935,"public void setTransfAlgebraic(List<String> transfAlgebraic){
  if (transformations == null)   transformations=new ArrayList<Matrix4d>(transfAlgebraic.size());
  if (this.transfAlgebraic == null)   this.transfAlgebraic=new ArrayList<String>(transfAlgebraic.size());
  for (  String transf : transfAlgebraic) {
    addTransformation(transf);
  }
}","public void setTransfAlgebraic(List<String> transfAlgebraic){
  if (transformations == null || transformations.size() == 0)   transformations=new ArrayList<Matrix4d>(transfAlgebraic.size());
  if (this.transfAlgebraic == null || this.transfAlgebraic.size() == 0)   this.transfAlgebraic=new ArrayList<String>(transfAlgebraic.size());
  for (  String transf : transfAlgebraic) {
    addTransformation(transf);
  }
}",0.911725955204216
16936,"protected void initializeCellTranslations(){
  cellTranslations=new Vector3d[multiplicity / primitiveMultiplicity];
  cellTranslations[0]=new Vector3d(0,0,0);
  if (transformations == null) {
    System.err.println(""String_Node_Str"" + this.toXML());
  }
  if (multiplicity == primitiveMultiplicity) {
    return;
  }
  int fold=multiplicity / primitiveMultiplicity;
  for (int n=1; n < fold; n++) {
    if (transformations.size() < (n * primitiveMultiplicity))     System.out.println(this.toXML());
    Matrix4d t=transformations.get(n * primitiveMultiplicity);
    cellTranslations[n]=new Vector3d(t.m03,t.m13,t.m23);
  }
}","protected void initializeCellTranslations(){
  if (cellTranslations != null && cellTranslations.length > 0) {
    return;
  }
  cellTranslations=new Vector3d[multiplicity / primitiveMultiplicity];
  cellTranslations[0]=new Vector3d(0,0,0);
  if (transformations == null) {
    System.err.println(""String_Node_Str"" + this.toXML());
  }
  if (multiplicity == primitiveMultiplicity) {
    return;
  }
  int fold=multiplicity / primitiveMultiplicity;
  for (int n=1; n < fold; n++) {
    if (transformations.size() < (n * primitiveMultiplicity)) {
      System.err.println(""String_Node_Str"" + (n * primitiveMultiplicity));
      System.err.println(this.toXML());
    }
    Matrix4d t=transformations.get(n * primitiveMultiplicity);
    cellTranslations[n]=new Vector3d(t.m03,t.m13,t.m23);
  }
}",0.8783592644978784
16937,"public List<String> getTransfAlgebraic(){
  return transfAlgebraic;
}","@XmlJavaTypeAdapter(TransfAlgebraicAdapter.class) public List<String> getTransfAlgebraic(){
  return transfAlgebraic;
}",0.7340425531914894
16938,"private Group getCorrectAltLocGroup(Character altLoc,String recordName,Character aminoCode1,String groupCode3,long seq_id){
  List<Atom> atoms=current_group.getAtoms();
  if (atoms.size() > 0) {
    Atom a1=atoms.get(0);
    if (a1.getAltLoc().equals(altLoc)) {
      return current_group;
    }
  }
  List<Group> altLocs=current_group.getAltLocs();
  for (  Group altLocG : altLocs) {
    atoms=altLocG.getAtoms();
    if (atoms.size() > 0) {
      for (      Atom a1 : atoms) {
        if (a1.getAltLoc().equals(altLoc)) {
          return altLocG;
        }
      }
    }
  }
  if (groupCode3.equals(current_group.getPDBName())) {
    if (current_group.getAtoms().size() == 0)     return current_group;
    Group altLocG=(Group)current_group.clone();
    current_group.addAltLoc(altLocG);
    return altLocG;
  }
  Group altLocG=getNewGroup(recordName,aminoCode1,seq_id,groupCode3);
  try {
    altLocG.setPDBName(groupCode3);
  }
 catch (  PDBParseException e) {
    e.printStackTrace();
  }
  altLocG.setResidueNumber(current_group.getResidueNumber());
  current_group.addAltLoc(altLocG);
  return altLocG;
}","private Group getCorrectAltLocGroup(Character altLoc,String recordName,Character aminoCode1,String groupCode3,long seq_id){
  List<Atom> atoms=current_group.getAtoms();
  if (atoms.size() > 0) {
    Atom a1=atoms.get(0);
    if (a1.getAltLoc().equals(altLoc)) {
      return current_group;
    }
  }
  List<Group> altLocs=current_group.getAltLocs();
  for (  Group altLocG : altLocs) {
    atoms=altLocG.getAtoms();
    if (atoms.size() > 0) {
      for (      Atom a1 : atoms) {
        if (a1.getAltLoc().equals(altLoc)) {
          return altLocG;
        }
      }
    }
  }
  if (groupCode3.equals(current_group.getPDBName())) {
    if (current_group.getAtoms().size() == 0) {
      return current_group;
    }
    Group altLocG=(Group)current_group.clone();
    altLocG.setAtoms(new ArrayList<Atom>());
    current_group.addAltLoc(altLocG);
    return altLocG;
  }
  Group altLocG=getNewGroup(recordName,aminoCode1,seq_id,groupCode3);
  try {
    altLocG.setPDBName(groupCode3);
  }
 catch (  PDBParseException e) {
    e.printStackTrace();
  }
  altLocG.setResidueNumber(current_group.getResidueNumber());
  current_group.addAltLoc(altLocG);
  return altLocG;
}",0.975887768522578
16939,"/** 
 * Loads the SIFTS mapping. Attempts to load the mapping file file in the PDB cache directory. If the file does not exist or could not be parsed, downloads and stores a GZ-compressed file.
 * @param useOnlyLocal If true, will throw an IOException if the file needs to be downloaded
 * @return
 * @throws IOException If the local file could not be read and could not be downloaded (including if onlyLocal is true)
 */
public static SiftsChainToUniprotMapping load(boolean useOnlyLocal) throws IOException {
  String cacheDir=System.getProperty(AbstractUserArgumentProcessor.CACHE_DIR);
  if (cacheDir != null) {
    DEFAULT_FILE=new File(cacheDir.endsWith(File.pathSeparator) ? cacheDir + DEFAULT_FILENAME : cacheDir + File.pathSeparator + DEFAULT_FILENAME);
  }
 else {
    DEFAULT_FILE=File.createTempFile(DEFAULT_FILENAME,""String_Node_Str"");
  }
  if (!DEFAULT_FILE.exists()) {
    if (useOnlyLocal)     throw new IOException(DEFAULT_FILE + ""String_Node_Str"");
    download();
  }
  try {
    return build();
  }
 catch (  IOException e) {
    e.printStackTrace();
    if (useOnlyLocal)     throw new IOException(DEFAULT_FILE + ""String_Node_Str"");
    download();
    return build();
  }
}","/** 
 * Loads the SIFTS mapping. Attempts to load the mapping file file in the PDB cache directory. If the file does not exist or could not be parsed, downloads and stores a GZ-compressed file.
 * @param useOnlyLocal If true, will throw an IOException if the file needs to be downloaded
 * @return
 * @throws IOException If the local file could not be read and could not be downloaded (including if onlyLocal is true)
 */
public static SiftsChainToUniprotMapping load(boolean useOnlyLocal) throws IOException {
  String cacheDir=System.getProperty(AbstractUserArgumentProcessor.CACHE_DIR);
  if (cacheDir != null) {
    DEFAULT_FILE=new File(cacheDir.endsWith(File.pathSeparator) ? cacheDir + DEFAULT_FILENAME : cacheDir + File.pathSeparator + DEFAULT_FILENAME);
  }
 else {
    DEFAULT_FILE=File.createTempFile(DEFAULT_FILENAME,""String_Node_Str"");
  }
  if (!DEFAULT_FILE.exists() || DEFAULT_FILE.length() == 0) {
    if (useOnlyLocal)     throw new IOException(DEFAULT_FILE + ""String_Node_Str"");
    download();
  }
  try {
    return build();
  }
 catch (  IOException e) {
    e.printStackTrace();
    if (useOnlyLocal)     throw new IOException(DEFAULT_FILE + ""String_Node_Str"");
    download();
    return build();
  }
}",0.9876135425268372
16940,"/** 
 * map the seqres groups to the atomRes chain. updates the atomRes chain object with the mapped data seqRes chain shuold not be needed after this and atomRes should be continued to be used.
 * @param atomRes
 * @param seqRes
 * @throws StructureException 
 */
public void mapSeqresRecords(Chain atomRes,Chain seqRes) throws StructureException {
  List<Group> seqResGroups=seqRes.getAtomGroups();
  List<Group> atmResGroups=atomRes.getAtomGroups();
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + atomRes.getChainID() + ""String_Node_Str""+ atmResGroups.size()+ ""String_Node_Str""+ seqRes.getChainID()+ ""String_Node_Str""+ seqResGroups.size()+ ""String_Node_Str"");
  }
  boolean simpleMatchSuccessful=trySimpleMatch(seqResGroups,atmResGroups);
  if (simpleMatchSuccessful) {
    atomRes.setSeqResGroups(seqResGroups);
    return;
  }
  if (seqRes.getAtomGroups(GroupType.AMINOACID).size() < 1) {
    if (seqRes.getAtomGroups(GroupType.NUCLEOTIDE).size() > 1) {
      if (DEBUG) {
        System.out.println(""String_Node_Str"" + seqRes.getChainID() + ""String_Node_Str"");
      }
      align2NucleotideChains(seqRes,atomRes);
      return;
    }
 else {
      if (DEBUG) {
        System.out.println(""String_Node_Str"" + seqRes.getChainID() + ""String_Node_Str"");
      }
      return;
    }
  }
  if (atomRes.getAtomGroups(GroupType.AMINOACID).size() < 1) {
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + atomRes.getChainID() + ""String_Node_Str"");
    }
    return;
  }
  if (DEBUG)   System.out.println(""String_Node_Str"" + atomRes.getChainID());
  boolean noMatchFound=align(seqResGroups,atomRes.getAtomGroups());
  if (!noMatchFound) {
    atomRes.setSeqResGroups(seqResGroups);
  }
}","/** 
 * map the seqres groups to the atomRes chain. updates the atomRes chain object with the mapped data seqRes chain shuold not be needed after this and atomRes should be continued to be used.
 * @param atomRes
 * @param seqRes
 * @throws StructureException 
 */
public void mapSeqresRecords(Chain atomRes,Chain seqRes) throws StructureException {
  List<Group> seqResGroups=seqRes.getAtomGroups();
  List<Group> atmResGroups=atomRes.getAtomGroups();
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + atomRes.getChainID() + ""String_Node_Str""+ atmResGroups.size()+ ""String_Node_Str""+ seqRes.getChainID()+ ""String_Node_Str""+ seqResGroups.size()+ ""String_Node_Str"");
  }
  List<Group> matchedGroups=trySimpleMatch(seqResGroups,atmResGroups);
  if (matchedGroups != null) {
    atomRes.setSeqResGroups(matchedGroups);
    return;
  }
  if (seqRes.getAtomGroups(GroupType.AMINOACID).size() < 1) {
    if (seqRes.getAtomGroups(GroupType.NUCLEOTIDE).size() > 1) {
      if (DEBUG) {
        System.out.println(""String_Node_Str"" + seqRes.getChainID() + ""String_Node_Str"");
      }
      align2NucleotideChains(seqRes,atomRes);
      return;
    }
 else {
      if (DEBUG) {
        System.out.println(""String_Node_Str"" + seqRes.getChainID() + ""String_Node_Str"");
      }
      return;
    }
  }
  if (atomRes.getAtomGroups(GroupType.AMINOACID).size() < 1) {
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + atomRes.getChainID() + ""String_Node_Str"");
    }
    return;
  }
  if (DEBUG)   System.out.println(""String_Node_Str"" + atomRes.getChainID());
  boolean noMatchFound=align(seqResGroups,atomRes.getAtomGroups());
  if (!noMatchFound) {
    atomRes.setSeqResGroups(seqResGroups);
  }
}",0.9240246406570842
16941,"/** 
 * a simple matching approach that tries to do a 1:1 mapping between SEQRES and ATOM records returns true if this simple matching approach worked fine
 * @param seqRes
 * @param atomList
 * @return
 */
public boolean trySimpleMatch(List<Group> seqResGroups,List<Group> atmResGroups){
  @SuppressWarnings(""String_Node_Str"") List<Group> newSeqResGroups=(ArrayList<Group>)((ArrayList<Group>)seqResGroups).clone();
  boolean startAt1=true;
  for (int atomResPos=0; atomResPos < atmResGroups.size(); atomResPos++) {
    Group atomResGroup=atmResGroups.get(atomResPos);
    String threeLetterCode=atomResGroup.getPDBName();
    if (excludeTypes.contains(threeLetterCode)) {
      continue;
    }
    ResidueNumber atomResNum=atomResGroup.getResidueNumber();
    int seqResPos=atomResNum.getSeqNum();
    if (seqResPos < 0) {
      if (DEBUG)       System.err.println(""String_Node_Str"");
      return false;
    }
    if (seqResPos == 0) {
      Group seqResGroup=seqResGroups.get(0);
      if (seqResGroup.getPDBName().equals(atomResGroup.getPDBName())) {
        startAt1=false;
      }
 else {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + seqResGroup.getPDBName() + ""String_Node_Str""+ atomResGroup.getPDBName()+ ""String_Node_Str"");
        }
        return false;
      }
    }
    if (startAt1)     seqResPos--;
    if (startAt1 && seqResPos >= seqResGroups.size()) {
      if (atomResGroup instanceof AminoAcid) {
        if (DEBUG)         System.err.println(""String_Node_Str"" + seqResPos + ""String_Node_Str""+ seqResGroups.size()+ ""String_Node_Str""+ atomResGroup);
        return false;
      }
 else       if (atomResGroup instanceof NucleotideImpl) {
        if (DEBUG)         System.err.println(""String_Node_Str"" + seqResPos + ""String_Node_Str""+ seqResGroups.size()+ ""String_Node_Str""+ atomResGroup);
        return false;
      }
 else {
        continue;
      }
    }
    if (seqResPos >= seqResGroups.size()) {
      if (DEBUG)       System.err.println(""String_Node_Str"" + seqResPos);
      if (atomResGroup instanceof AminoAcid)       return false;
 else       continue;
    }
    Group seqResGroup=seqResGroups.get(seqResPos);
    if (!seqResGroup.getPDBName().trim().equals(atomResGroup.getPDBName().trim())) {
      if (DEBUG)       System.err.println(""String_Node_Str"" + seqResPos + ""String_Node_Str""+ atomResGroup+ ""String_Node_Str""+ seqResGroup);
      return false;
    }
    if (DEBUG)     System.err.println(""String_Node_Str"" + seqResPos + ""String_Node_Str""+ atomResGroup);
    newSeqResGroups.set(seqResPos,atomResGroup);
  }
  seqResGroups=newSeqResGroups;
  return true;
}","/** 
 * a simple matching approach that tries to do a 1:1 mapping between SEQRES and ATOM records returns true if this simple matching approach worked fine
 * @param seqRes
 * @param atomList
 * @return
 */
public List<Group> trySimpleMatch(List<Group> seqResGroups,List<Group> atmResGroups){
  @SuppressWarnings(""String_Node_Str"") List<Group> newSeqResGroups=(ArrayList<Group>)((ArrayList<Group>)seqResGroups).clone();
  boolean startAt1=true;
  for (int atomResPos=0; atomResPos < atmResGroups.size(); atomResPos++) {
    Group atomResGroup=atmResGroups.get(atomResPos);
    String threeLetterCode=atomResGroup.getPDBName();
    if (excludeTypes.contains(threeLetterCode)) {
      continue;
    }
    ResidueNumber atomResNum=atomResGroup.getResidueNumber();
    int seqResPos=atomResNum.getSeqNum();
    if (seqResPos < 0) {
      if (DEBUG)       System.err.println(""String_Node_Str"");
      return null;
    }
    if (seqResPos == 0) {
      Group seqResGroup=seqResGroups.get(0);
      if (seqResGroup.getPDBName().equals(atomResGroup.getPDBName())) {
        startAt1=false;
      }
 else {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + seqResGroup.getPDBName() + ""String_Node_Str""+ atomResGroup.getPDBName()+ ""String_Node_Str"");
        }
        return null;
      }
    }
    if (startAt1)     seqResPos--;
    if (startAt1 && seqResPos >= seqResGroups.size()) {
      if (atomResGroup instanceof AminoAcid) {
        if (DEBUG)         System.err.println(""String_Node_Str"" + seqResPos + ""String_Node_Str""+ seqResGroups.size()+ ""String_Node_Str""+ atomResGroup);
        return null;
      }
 else       if (atomResGroup instanceof NucleotideImpl) {
        if (DEBUG)         System.err.println(""String_Node_Str"" + seqResPos + ""String_Node_Str""+ seqResGroups.size()+ ""String_Node_Str""+ atomResGroup);
        return null;
      }
 else {
        continue;
      }
    }
    if (seqResPos >= seqResGroups.size()) {
      if (DEBUG)       System.err.println(""String_Node_Str"" + seqResPos);
      if (atomResGroup instanceof AminoAcid)       return null;
 else       continue;
    }
    Group seqResGroup=seqResGroups.get(seqResPos);
    if (!seqResGroup.getPDBName().trim().equals(atomResGroup.getPDBName().trim())) {
      if (DEBUG)       System.err.println(""String_Node_Str"" + seqResPos + ""String_Node_Str""+ atomResGroup+ ""String_Node_Str""+ seqResGroup);
      return null;
    }
    if (DEBUG)     System.err.println(""String_Node_Str"" + seqResPos + ""String_Node_Str""+ atomResGroup);
    newSeqResGroups.set(seqResPos,atomResGroup);
  }
  if (DEBUG) {
  }
  return newSeqResGroups;
}",0.9759541984732824
16942,"/** 
 * The user selected one of the Combo boxes...
 * @param event an ActionEvent
 */
public void actionPerformed(ActionEvent event){
  Object mysource=event.getSource();
  if (!(mysource instanceof JComboBox)) {
    super.actionPerformed(event);
    return;
  }
  JComboBox<?> source=(JComboBox<?>)event.getSource();
  String value=source.getSelectedItem().toString();
  String selectLigand=""String_Node_Str"";
  if (value.equals(""String_Node_Str"")) {
    String script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    this.executeCmd(script);
  }
 else   if (value.equals(""String_Node_Str"")) {
    String script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    this.executeCmd(script);
  }
 else   if (value.equals(""String_Node_Str"")) {
    String script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    this.executeCmd(script);
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    String script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    this.executeCmd(script);
  }
 else   if (value.equals(""String_Node_Str"")) {
    jmolColorByChain();
    String script=""String_Node_Str"" + selectLigand + ""String_Node_Str"";
    this.executeCmd(script);
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"" + selectLigand + ""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"" + selectLigand + ""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"" + selectLigand + ""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"" + selectLigand + ""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"" + selectLigand + ""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    colorByPDP();
  }
 else   if (value.equals(""String_Node_Str"")) {
    colorBySCOP();
  }
}","/** 
 * The user selected one of the Combo boxes...
 * @param event an ActionEvent
 */
public void actionPerformed(ActionEvent event){
  Object mysource=event.getSource();
  if (!(mysource instanceof JComboBox)) {
    super.actionPerformed(event);
    return;
  }
  JComboBox source=(JComboBox)event.getSource();
  String value=source.getSelectedItem().toString();
  String selectLigand=""String_Node_Str"";
  if (value.equals(""String_Node_Str"")) {
    String script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    this.executeCmd(script);
  }
 else   if (value.equals(""String_Node_Str"")) {
    String script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    this.executeCmd(script);
  }
 else   if (value.equals(""String_Node_Str"")) {
    String script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    this.executeCmd(script);
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    String script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    this.executeCmd(script);
  }
 else   if (value.equals(""String_Node_Str"")) {
    jmolColorByChain();
    String script=""String_Node_Str"" + selectLigand + ""String_Node_Str"";
    this.executeCmd(script);
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"" + selectLigand + ""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"" + selectLigand + ""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"" + selectLigand + ""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"" + selectLigand + ""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    this.executeCmd(""String_Node_Str"" + selectLigand + ""String_Node_Str"");
  }
 else   if (value.equals(""String_Node_Str"")) {
    colorByPDP();
  }
 else   if (value.equals(""String_Node_Str"")) {
    colorBySCOP();
  }
}",0.9987819732034104
16943,"private static void formatPosition(int pos1,Atom[] ca,int len,StringWriter header1,StringWriter header2){
  int linePos=len % LINELENGTH;
  if (header1.getBuffer().length() < linePos) {
    for (int i=header1.getBuffer().length(); i < linePos; i++) {
      header1.append(""String_Node_Str"");
    }
  }
  Atom a=ca[pos1];
  Group g=a.getGroup();
  ResidueNumber residueNumber=g.getResidueNumber();
  pos1=residueNumber.getSeqNum();
  boolean hasInsertionCode=false;
  if (residueNumber.getInsCode() != null) {
    hasInsertionCode=true;
  }
  if ((pos1 % 10 == 0) && (!hasInsertionCode)) {
    CharSequence display=getPDBPos(a);
    boolean ignoreH1=false;
    if (header1.getBuffer().length() - 1 > linePos) {
      ignoreH1=true;
      System.out.println(""String_Node_Str"" + len + ""String_Node_Str""+ header1.getBuffer().length()+ ""String_Node_Str""+ linePos+ ""String_Node_Str""+ header1.toString()+ ""String_Node_Str"");
    }
    if (!ignoreH1) {
      header1.append(String.format(""String_Node_Str"",display));
      header2.append(""String_Node_Str"");
    }
 else {
      header2.append(""String_Node_Str"");
    }
  }
 else   if (hasInsertionCode) {
    Character insCode=g.getResidueNumber().getInsCode();
    if (insCode != null)     header2.append(insCode);
 else {
      header2.append(""String_Node_Str"");
    }
  }
 else   if (((pos1) % 5) == 0 && len > 5) {
    header2.append(""String_Node_Str"");
  }
 else {
    if (len > 0)     header2.append(""String_Node_Str"");
  }
}","private static void formatPosition(int pos1,Atom[] ca,int len,StringWriter header1,StringWriter header2){
  int linePos=len % LINELENGTH;
  if (header1.getBuffer().length() < linePos) {
    for (int i=header1.getBuffer().length(); i < linePos; i++) {
      header1.append(""String_Node_Str"");
    }
  }
  Atom a=ca[pos1];
  Group g=a.getGroup();
  ResidueNumber residueNumber=g.getResidueNumber();
  pos1=residueNumber.getSeqNum();
  boolean hasInsertionCode=false;
  if (residueNumber.getInsCode() != null) {
    hasInsertionCode=true;
  }
  if ((pos1 % 10 == 0) && (!hasInsertionCode)) {
    CharSequence display=getPDBPos(a);
    boolean ignoreH1=false;
    if (header1.getBuffer().length() - 1 > linePos) {
      ignoreH1=true;
      System.err.println(""String_Node_Str"" + len + ""String_Node_Str""+ header1.getBuffer().length()+ ""String_Node_Str""+ linePos+ ""String_Node_Str""+ header1.toString()+ ""String_Node_Str"");
    }
    if (!ignoreH1) {
      header1.append(String.format(""String_Node_Str"",display));
      header2.append(""String_Node_Str"");
    }
 else {
      header2.append(""String_Node_Str"");
    }
  }
 else   if (hasInsertionCode) {
    Character insCode=g.getResidueNumber().getInsCode();
    if (insCode != null)     header2.append(insCode);
 else {
      header2.append(""String_Node_Str"");
    }
  }
 else   if (((pos1) % 5) == 0 && len > 5) {
    header2.append(""String_Node_Str"");
  }
 else {
    if (len > 0)     header2.append(""String_Node_Str"");
  }
}",0.9979633401221996
16944,"/** 
 * Creates a Map specifying the alignment as a mapping between residue indices of protein 1 and residue indices of protein 2. <p>For example,<pre> 1234 5678</pre> becomes<pre> 1->5 2->6 3->7 4->8</pre>
 * @param afpChain An alignment
 * @return A mapping from aligned residues of protein 1 to their partners in protein 2.
 * @throws StructureException If afpChain is not one-to-one
 */
public static Map<Integer,Integer> alignmentAsMap(AFPChain afpChain) throws StructureException {
  Map<Integer,Integer> map=new HashMap<Integer,Integer>();
  int[][][] optAln=afpChain.getOptAln();
  int[] optLen=afpChain.getOptLen();
  for (int block=0; block < afpChain.getBlockNum(); block++) {
    for (int pos=0; pos < optLen[block]; pos++) {
      int res1=optAln[block][0][pos];
      int res2=optAln[block][1][pos];
      if (map.containsKey(res1)) {
        throw new StructureException(String.format(""String_Node_Str"",res1,map.get(res1),res2));
      }
      map.put(res1,res2);
    }
  }
  return map;
}","/** 
 * Creates a Map specifying the alignment as a mapping between residue indices of protein 1 and residue indices of protein 2. <p>For example,<pre> 1234 5678</pre> becomes<pre> 1->5 2->6 3->7 4->8</pre>
 * @param afpChain An alignment
 * @return A mapping from aligned residues of protein 1 to their partners in protein 2.
 * @throws StructureException If afpChain is not one-to-one
 */
public static Map<Integer,Integer> alignmentAsMap(AFPChain afpChain) throws StructureException {
  Map<Integer,Integer> map=new HashMap<Integer,Integer>();
  if (afpChain.getAlnLength() < 1) {
    return map;
  }
  int[][][] optAln=afpChain.getOptAln();
  int[] optLen=afpChain.getOptLen();
  for (int block=0; block < afpChain.getBlockNum(); block++) {
    for (int pos=0; pos < optLen[block]; pos++) {
      int res1=optAln[block][0][pos];
      int res2=optAln[block][1][pos];
      if (map.containsKey(res1)) {
        throw new StructureException(String.format(""String_Node_Str"",res1,map.get(res1),res2));
      }
      map.put(res1,res2);
    }
  }
  return map;
}",0.9723970944309928
16945,"/** 
 * Loads the SIFTS mapping. Attempts to load the mapping file file in the PDB cache directory. If the file does not exist or could not be parsed, downloads and stores a GZ-compressed file.
 * @param useOnlyLocal If true, will throw an IOException if the file needs to be downloaded
 * @return
 * @throws IOException If the local file could not be read and could not be downloaded (including if onlyLocal is true)
 */
public static SiftsChainToUniprotMapping load(boolean useOnlyLocal) throws IOException {
  String cacheDir=System.getProperty(AbstractUserArgumentProcessor.CACHE_DIR);
  if (cacheDir != null) {
    DEFAULT_FILE=new File(cacheDir.endsWith(File.pathSeparator) ? cacheDir + DEFAULT_FILENAME : cacheDir + File.pathSeparator + DEFAULT_FILENAME);
  }
 else {
    DEFAULT_FILE=File.createTempFile(DEFAULT_FILENAME,""String_Node_Str"");
  }
  if (!DEFAULT_FILE.exists()) {
    if (useOnlyLocal)     throw new IOException(DEFAULT_FILE + ""String_Node_Str"");
    download();
  }
  try {
    return build();
  }
 catch (  IOException e) {
    e.printStackTrace();
    if (useOnlyLocal)     throw new IOException(DEFAULT_FILE + ""String_Node_Str"");
    download();
    return build();
  }
}","/** 
 * Loads the SIFTS mapping. Attempts to load the mapping file file in the PDB cache directory. If the file does not exist or could not be parsed, downloads and stores a GZ-compressed file.
 * @param useOnlyLocal If true, will throw an IOException if the file needs to be downloaded
 * @return
 * @throws IOException If the local file could not be read and could not be downloaded (including if onlyLocal is true)
 */
public static SiftsChainToUniprotMapping load(boolean useOnlyLocal) throws IOException {
  String cacheDir=System.getProperty(AbstractUserArgumentProcessor.CACHE_DIR);
  if (cacheDir != null) {
    DEFAULT_FILE=new File(cacheDir.endsWith(File.pathSeparator) ? cacheDir + DEFAULT_FILENAME : cacheDir + File.pathSeparator + DEFAULT_FILENAME);
  }
 else {
    DEFAULT_FILE=File.createTempFile(DEFAULT_FILENAME,""String_Node_Str"");
  }
  if (!DEFAULT_FILE.exists() || DEFAULT_FILE.length() == 0) {
    if (useOnlyLocal)     throw new IOException(DEFAULT_FILE + ""String_Node_Str"");
    download();
  }
  try {
    return build();
  }
 catch (  IOException e) {
    e.printStackTrace();
    if (useOnlyLocal)     throw new IOException(DEFAULT_FILE + ""String_Node_Str"");
    download();
    return build();
  }
}",0.9876135425268372
16946,"private static void formatPosition(int pos1,Atom[] ca,int len,StringWriter header1,StringWriter header2){
  int linePos=len % LINELENGTH;
  if (header1.getBuffer().length() < linePos) {
    for (int i=header1.getBuffer().length(); i < linePos; i++) {
      header1.append(""String_Node_Str"");
    }
  }
  Atom a=ca[pos1];
  Group g=a.getGroup();
  ResidueNumber residueNumber=g.getResidueNumber();
  pos1=residueNumber.getSeqNum();
  boolean hasInsertionCode=false;
  if (residueNumber.getInsCode() != null) {
    hasInsertionCode=true;
  }
  if ((pos1 % 10 == 0) && (!hasInsertionCode)) {
    CharSequence display=getPDBPos(a);
    boolean ignoreH1=false;
    if (header1.getBuffer().length() - 1 > linePos) {
      ignoreH1=true;
      System.out.println(""String_Node_Str"" + len + ""String_Node_Str""+ header1.getBuffer().length()+ ""String_Node_Str""+ linePos+ ""String_Node_Str""+ header1.toString()+ ""String_Node_Str"");
    }
    if (!ignoreH1) {
      header1.append(String.format(""String_Node_Str"",display));
      header2.append(""String_Node_Str"");
    }
 else {
      header2.append(""String_Node_Str"");
    }
  }
 else   if (hasInsertionCode) {
    Character insCode=g.getResidueNumber().getInsCode();
    if (insCode != null)     header2.append(insCode);
 else {
      header2.append(""String_Node_Str"");
    }
  }
 else   if (((pos1) % 5) == 0 && len > 5) {
    header2.append(""String_Node_Str"");
  }
 else {
    if (len > 0)     header2.append(""String_Node_Str"");
  }
}","private static void formatPosition(int pos1,Atom[] ca,int len,StringWriter header1,StringWriter header2){
  int linePos=len % LINELENGTH;
  if (header1.getBuffer().length() < linePos) {
    for (int i=header1.getBuffer().length(); i < linePos; i++) {
      header1.append(""String_Node_Str"");
    }
  }
  Atom a=ca[pos1];
  Group g=a.getGroup();
  ResidueNumber residueNumber=g.getResidueNumber();
  pos1=residueNumber.getSeqNum();
  boolean hasInsertionCode=false;
  if (residueNumber.getInsCode() != null) {
    hasInsertionCode=true;
  }
  if ((pos1 % 10 == 0) && (!hasInsertionCode)) {
    CharSequence display=getPDBPos(a);
    boolean ignoreH1=false;
    if (header1.getBuffer().length() - 1 > linePos) {
      ignoreH1=true;
    }
    if (!ignoreH1) {
      header1.append(String.format(""String_Node_Str"",display));
      header2.append(""String_Node_Str"");
    }
 else {
      header2.append(""String_Node_Str"");
    }
  }
 else   if (hasInsertionCode) {
    Character insCode=g.getResidueNumber().getInsCode();
    if (insCode != null)     header2.append(insCode);
 else {
      header2.append(""String_Node_Str"");
    }
  }
 else   if (((pos1) % 5) == 0 && len > 5) {
    header2.append(""String_Node_Str"");
  }
 else {
    if (len > 0)     header2.append(""String_Node_Str"");
  }
}",0.9322218194998187
16947,"/** 
 * @see #toConciseAlignmentString(Map,Map)
 */
public static Map<Integer,Integer> fromConciseAlignmentString(String string){
  char[] chars=string.toCharArray();
  Map<Integer,Integer> map=new HashMap<Integer,Integer>();
  for (int i=1; i < chars.length - 1; i++) {
    if (chars[i] == '>') {
      map.put(Integer.parseInt(String.valueOf(chars[i - 1])),Integer.parseInt(String.valueOf(chars[i + 1])));
    }
  }
  return map;
}","/** 
 * @see #toConciseAlignmentString(Map,Map)
 */
public static Map<Integer,Integer> fromConciseAlignmentString(String string){
  Map<Integer,Integer> map=new HashMap<Integer,Integer>();
  boolean matches=true;
  while (matches) {
    Pattern pattern=Pattern.compile(""String_Node_Str"");
    Matcher matcher=pattern.matcher(string);
    matches=matcher.find();
    if (matches) {
      Integer from=Integer.parseInt(matcher.group(1));
      Integer to=Integer.parseInt(matcher.group(2));
      map.put(from,to);
      string=string.substring(matcher.end(1) + 1);
    }
  }
  return map;
}",0.4403131115459882
16948,"/** 
 * Loads a   {@link StructureIdentifier} from the specified string.The type returned for any particular string can be considered relatively stable but should not be relied on.
 */
public static StructureIdentifier loadIdentifier(String id){
  try {
    return new UriIdentifier(id);
  }
 catch (  URISyntaxException e) {
    return new SubstructureIdentifier(id);
  }
}","/** 
 * Loads a   {@link StructureIdentifier} from the specified string.The type returned for any particular string can be considered relatively stable but should not be relied on.
 */
public static StructureIdentifier loadIdentifier(String id,AtomCache cache){
  if (id.matches(CATH_PATTERN)) {
    return CathFactory.getCathDatabase().getDescriptionByCathId(id);
  }
 else   if (id.matches(SCOP_PATTERN)) {
    return ScopFactory.getSCOP().getDomainByScopID(id);
  }
  try {
    return new SubstructureIdentifier(id,cache);
  }
 catch (  Exception e) {
    throw new IllegalArgumentException(""String_Node_Str"" + id,e);
  }
}",0.652
16949,"@Override public String getIdentifier(){
  return ResidueRange.toString(ranges);
}","@Override public String getIdentifier(){
  if (ranges.isEmpty())   return pdbId;
  return pdbId + ""String_Node_Str"" + ResidueRange.toString(ranges);
}",0.7068965517241379
16950,"public SubstructureIdentifier(String id){
  if (id.contains(""String_Node_Str"")) {
    this.pdbId=id;
    this.ranges=new ArrayList<ResidueRange>();
  }
 else {
    String[] s=id.split(""String_Node_Str"");
    this.pdbId=s[0];
    this.ranges=ResidueRange.parseMultiple(s[1]);
  }
}","public SubstructureIdentifier(String id,AtomCache cache) throws IOException, StructureException {
  if (id.contains(""String_Node_Str"")) {
    this.pdbId=id.split(""String_Node_Str"")[0];
  }
 else {
    this.pdbId=id;
  }
  AtomPositionMap map=new AtomPositionMap(cache.getAtoms(pdbId));
  if (id.contains(""String_Node_Str"")) {
    String[] s=id.split(""String_Node_Str"");
    this.ranges=ResidueRange.parseMultiple(s[1],map);
  }
 else {
    this.ranges=map.getRanges();
  }
}",0.4854111405835544
16951,"@Override public String getIdentifier(){
  return pdbId + ResidueRange.toString(getResidueRanges());
}","@Override public String getIdentifier(){
  return pdbId + ""String_Node_Str"" + ResidueRange.toString(getResidueRanges());
}",0.9107142857142856
16952,"/** 
 * Factory method to run a list of scorers concurrently.  This method runs the scorers in parallel by submitting all of the scoring tasks to the shared thread pool of the   {@link ConcurrencyTools} utility.
 * @param < S > each {@link Sequence} of an alignment pair is of type S
 * @param < C > each element of an {@link AlignedSequence} is a {@link Compound} of type C
 * @param scorers list of scorers to run
 * @return list of score results from running scorers
 */
public static <S extends Sequence<C>,C extends Compound>int[] runPairwiseScorers(List<PairwiseSequenceScorer<S,C>> scorers){
  int n=1, all=scorers.size();
  List<Future<Integer>> futures=new ArrayList<Future<Integer>>();
  for (  PairwiseSequenceScorer<S,C> scorer : scorers) {
    futures.add(ConcurrencyTools.submit(new CallablePairwiseSequenceScorer<S,C>(scorer),String.format(""String_Node_Str"",n++,all)));
  }
  List<Integer> results=getListFromFutures(futures);
  int[] scores=new int[results.size()];
  for (int i=0; i < scores.length; i++) {
    scores[i]=results.get(i);
  }
  return scores;
}","/** 
 * Factory method to run a list of scorers concurrently.  This method runs the scorers in parallel by submitting all of the scoring tasks to the shared thread pool of the   {@link ConcurrencyTools} utility.
 * @param < S > each {@link Sequence} of an alignment pair is of type S
 * @param < C > each element of an {@link AlignedSequence} is a {@link Compound} of type C
 * @param scorers list of scorers to run
 * @return list of score results from running scorers
 */
public static <S extends Sequence<C>,C extends Compound>double[] runPairwiseScorers(List<PairwiseSequenceScorer<S,C>> scorers){
  int n=1, all=scorers.size();
  List<Future<Double>> futures=new ArrayList<Future<Double>>();
  for (  PairwiseSequenceScorer<S,C> scorer : scorers) {
    futures.add(ConcurrencyTools.submit(new CallablePairwiseSequenceScorer<S,C>(scorer),String.format(""String_Node_Str"",n++,all)));
  }
  List<Double> results=getListFromFutures(futures);
  double[] scores=new double[results.size()];
  for (int i=0; i < scores.length; i++) {
    scores[i]=results.get(i);
  }
  return scores;
}",0.969416126042632
16953,"/** 
 * Factory method which computes a similarity score for the given   {@link Sequence} pair.
 * @param < S > each {@link Sequence} of the pair is of type S
 * @param < C > each element of a {@link Sequence} is a {@link Compound} of type C
 * @param query the first {@link Sequence} to score
 * @param target the second {@link Sequence} to score
 * @param type chosen type from list of pairwise sequence scoring routines
 * @param gapPenalty the gap penalties used during alignment
 * @param subMatrix the set of substitution scores used during alignment
 * @return sequence pair score
 */
static <S extends Sequence<C>,C extends Compound>int getPairwiseScore(S query,S target,PairwiseSequenceScorerType type,GapPenalty gapPenalty,SubstitutionMatrix<C> subMatrix){
  return getPairwiseScorer(query,target,type,gapPenalty,subMatrix).getScore();
}","/** 
 * Factory method which computes a similarity score for the given   {@link Sequence} pair.
 * @param < S > each {@link Sequence} of the pair is of type S
 * @param < C > each element of a {@link Sequence} is a {@link Compound} of type C
 * @param query the first {@link Sequence} to score
 * @param target the second {@link Sequence} to score
 * @param type chosen type from list of pairwise sequence scoring routines
 * @param gapPenalty the gap penalties used during alignment
 * @param subMatrix the set of substitution scores used during alignment
 * @return sequence pair score
 */
static <S extends Sequence<C>,C extends Compound>double getPairwiseScore(S query,S target,PairwiseSequenceScorerType type,GapPenalty gapPenalty,SubstitutionMatrix<C> subMatrix){
  return getPairwiseScorer(query,target,type,gapPenalty,subMatrix).getScore();
}",0.99469652327637
16954,"/** 
 * Factory method which computes a sequence pair score for all   {@link Sequence} pairs in the given {@link List}. This method runs the scorings in parallel by submitting all of the scorings to the shared thread pool of the  {@link ConcurrencyTools} utility.
 * @param < S > each {@link Sequence} of a pair is of type S
 * @param < C > each element of a {@link Sequence} is a {@link Compound} of type C
 * @param sequences the {@link List} of {@link Sequence}s to align
 * @param type chosen type from list of pairwise sequence scoring routines
 * @param gapPenalty the gap penalties used during alignment
 * @param subMatrix the set of substitution scores used during alignment
 * @return list of sequence pair scores
 */
public static <S extends Sequence<C>,C extends Compound>int[] getAllPairsScores(List<S> sequences,PairwiseSequenceScorerType type,GapPenalty gapPenalty,SubstitutionMatrix<C> subMatrix){
  return runPairwiseScorers(getAllPairsScorers(sequences,type,gapPenalty,subMatrix));
}","/** 
 * Factory method which computes a sequence pair score for all   {@link Sequence} pairs in the given {@link List}. This method runs the scorings in parallel by submitting all of the scorings to the shared thread pool of the  {@link ConcurrencyTools} utility.
 * @param < S > each {@link Sequence} of a pair is of type S
 * @param < C > each element of a {@link Sequence} is a {@link Compound} of type C
 * @param sequences the {@link List} of {@link Sequence}s to align
 * @param type chosen type from list of pairwise sequence scoring routines
 * @param gapPenalty the gap penalties used during alignment
 * @param subMatrix the set of substitution scores used during alignment
 * @return list of sequence pair scores
 */
public static <S extends Sequence<C>,C extends Compound>double[] getAllPairsScores(List<S> sequences,PairwiseSequenceScorerType type,GapPenalty gapPenalty,SubstitutionMatrix<C> subMatrix){
  return runPairwiseScorers(getAllPairsScorers(sequences,type,gapPenalty,subMatrix));
}",0.9955112219451372
16955,"@Override public int getMaxScore(){
  if (aligner != null) {
    align();
  }
  return max;
}","@Override public double getMaxScore(){
  if (aligner != null) {
    align();
  }
  return max;
}",0.9523809523809524
16956,"@Override public int getMinScore(){
  return 0;
}","@Override public double getMinScore(){
  return 0;
}",0.9108910891089108
16957,"@Override public int getScore(){
  if (aligner != null) {
    align();
  }
  return score;
}","@Override public double getScore(){
  if (aligner != null) {
    align();
  }
  return score;
}",0.9518716577540108
16958,"@Override public int getMaxScore(){
  if (aligner != null) {
    align();
  }
  return max;
}","@Override public double getMaxScore(){
  if (aligner != null) {
    align();
  }
  return max;
}",0.9523809523809524
16959,"@Override public int getMinScore(){
  return 0;
}","@Override public double getMinScore(){
  return 0;
}",0.9108910891089108
16960,"@Override public int getScore(){
  if (aligner != null) {
    align();
  }
  return score;
}","@Override public double getScore(){
  if (aligner != null) {
    align();
  }
  return score;
}",0.9518716577540108
16961,"/** 
 * Returns the similarity matrix used to construct this guide tree.  The scores have not been normalized.
 * @return the similarity matrix used to construct this guide tree
 */
public int[][] getScoreMatrix(){
  int[][] matrix=new int[sequences.size()][sequences.size()];
  for (int i=0, n=0; i < matrix.length; i++) {
    matrix[i][i]=scorers.get(i).getMaxScore();
    for (int j=i + 1; j < matrix.length; j++) {
      matrix[i][j]=matrix[j][i]=scorers.get(n++).getScore();
    }
  }
  return matrix;
}","/** 
 * Returns the similarity matrix used to construct this guide tree.  The scores have not been normalized.
 * @return the similarity matrix used to construct this guide tree
 */
public double[][] getScoreMatrix(){
  double[][] matrix=new double[sequences.size()][sequences.size()];
  for (int i=0, n=0; i < matrix.length; i++) {
    matrix[i][i]=scorers.get(i).getMaxScore();
    for (int j=i + 1; j < matrix.length; j++) {
      matrix[i][j]=matrix[j][i]=scorers.get(n++).getScore();
    }
  }
  return matrix;
}",0.9736585365853658
16962,"/** 
 * Returns a sequence pair score for all   {@link Sequence} pairs in the given {@link List}.
 * @return list of sequence pair scores
 */
public int[] getAllPairsScores(){
  int[] scores=new int[scorers.size()];
  int n=0;
  for (  PairwiseSequenceScorer<S,C> scorer : scorers) {
    scores[n++]=scorer.getScore();
  }
  return scores;
}","/** 
 * Returns a sequence pair score for all   {@link Sequence} pairs in the given {@link List}.
 * @return list of sequence pair scores
 */
public double[] getAllPairsScores(){
  double[] scores=new double[scorers.size()];
  int n=0;
  for (  PairwiseSequenceScorer<S,C> scorer : scorers) {
    scores[n++]=scorer.getScore();
  }
  return scores;
}",0.9609261939218524
16963,"@Override public int getMaxScore(){
  return 0;
}","@Override public double getMaxScore(){
  return 0;
}",0.9108910891089108
16964,"@Override public int getMinScore(){
  return 0;
}","@Override public double getMinScore(){
  return 0;
}",0.9108910891089108
16965,"@Override public int getScore(){
  return 0;
}","@Override public double getScore(){
  return 0;
}",0.9052631578947368
16966,"@Override public int getMinScore(){
  if (profile == null) {
    align();
  }
  return min;
}","@Override public double getMinScore(){
  if (profile == null) {
    align();
  }
  return min;
}",0.9523809523809524
16967,"@Override public int getMaxScore(){
  if (profile == null) {
    align();
  }
  return max;
}","@Override public double getMaxScore(){
  if (profile == null) {
    align();
  }
  return max;
}",0.9523809523809524
16968,"@Override public int getScore(){
  if (profile == null) {
    align();
  }
  return score;
}","@Override public double getScore(){
  if (profile == null) {
    align();
  }
  return score;
}",0.9518716577540108
16969,"@Override public Integer call(){
  return pss.getScore();
}","@Override public Double call(){
  return pss.getScore();
}",0.905982905982906
16970,"/** 
 * Returns maximum possible score.
 * @return maximum possible score
 */
int getMaxScore();","/** 
 * Returns maximum possible score.
 * @return maximum possible score
 */
double getMaxScore();",0.953846153846154
16971,"/** 
 * Returns minimum possible score.
 * @return minimum possible score
 */
int getMinScore();","/** 
 * Returns minimum possible score.
 * @return minimum possible score
 */
double getMinScore();",0.953846153846154
16972,"/** 
 * Returns score resulting from algorithm.  This should normalize between 0 and 1 by calculating (  {@link #getScore()} - {@link #getMinScore()}) / (  {@link #getMaxScore()} - {@link #getMinScore()}).
 * @return score resulting from algorithm
 */
int getScore();","/** 
 * Returns score resulting from algorithm.  This should normalize between 0 and 1 by calculating (  {@link #getScore()} - {@link #getMinScore()}) / (  {@link #getMaxScore()} - {@link #getMinScore()}).
 * @return score resulting from algorithm
 */
double getScore();",0.9832402234636872
16973,"@Test public void testGetAllPairsScores(){
  assertArrayEquals(tree.getAllPairsScores(),new int[]{4,0,3,0,3,0});
}","@Test public void testGetAllPairsScores(){
  assertArrayEquals(tree.getAllPairsScores(),new double[]{4,0,3,0,3,0},0.00001);
}",0.9288702928870292
16974,"public static Cut[] getCuts(int k,Subproblem subproblem,int[] dim,boolean anchor0){
  Cut[] cuts;
  int m=subproblem.getQueryEndIndex() - subproblem.getQueryStartIndex() - (anchor0 ? 1 : 0);
  if (k < m) {
    cuts=new Cut[k];
    for (int i=0; i < k; i++) {
      cuts[i]=new Cut(subproblem.getQueryStartIndex() + ((i + 1) * (m + 1) * k / (k + 1)),dim);
    }
  }
 else {
    cuts=new Cut[m];
    for (int i=0, x=subproblem.getQueryStartIndex() + (anchor0 ? 1 : 0); i < m; i++, x++) {
      cuts[i]=new Cut(x,dim);
    }
  }
  return cuts;
}","public static Cut[] getCuts(int k,Subproblem subproblem,int[] dim,boolean anchor0){
  Cut[] cuts;
  int m=subproblem.getQueryEndIndex() - subproblem.getQueryStartIndex() - (anchor0 ? 1 : 0);
  if (k < m) {
    cuts=new Cut[k];
    int firstCutIndex=subproblem.getQueryStartIndex() + (anchor0 ? 1 : 0);
    int finalCutIndex=firstCutIndex + m - 1;
    for (int i=0; i < k; i++) {
      cuts[i]=new Cut(firstCutIndex + i * m / (k - 1),dim);
    }
  }
 else {
    cuts=new Cut[m];
    for (int i=0, x=subproblem.getQueryStartIndex() + (anchor0 ? 1 : 0); i < m; i++, x++) {
      cuts[i]=new Cut(x,dim);
    }
  }
  return cuts;
}",0.803082191780822
16975,"/** 
 * Fundamentally, an alignment is just a list of aligned residues in each protein. This method converts two lists of ResidueNumbers into an AFPChain. <p>Parameters are filled with defaults (often null) or sometimes calculated. <p>For a way to modify the alignment of an existing AFPChain, see  {@link AlignmentTools#replaceOptAln(AFPChain,Atom[],Atom[],Map)}
 * @param ca1 CA atoms of the first protein
 * @param ca2 CA atoms of the second protein
 * @param aligned1 A list of aligned residues from the first protein
 * @param aligned2 A list of aligned residues from the second protein.Must be the same length as aligned1.
 * @return An AFPChain representing the alignment. Many properties may benull or another default.
 * @throws StructureException if an error occured during superposition
 * @throws IllegalArgumentException if aligned1 and aligned2 have differentlengths
 * @see AlignmentTools#replaceOptAln(AFPChain,Atom[],Atom[],Map)
 */
public static AFPChain createAFPChain(Atom[] ca1,Atom[] ca2,ResidueNumber[] aligned1,ResidueNumber[] aligned2) throws StructureException {
  int alnLen=aligned1.length;
  if (alnLen != aligned2.length) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  AFPChain a=new AFPChain();
  try {
    a.setName1(ca1[0].getGroup().getChain().getParent().getName());
    a.setName2(ca2[0].getGroup().getChain().getParent().getName());
  }
 catch (  Exception e) {
  }
  a.setBlockNum(1);
  a.setCa1Length(ca1.length);
  a.setCa2Length(ca2.length);
  a.setOptLength(alnLen);
  a.setOptLen(new int[]{alnLen});
  Matrix[] ms=new Matrix[a.getBlockNum()];
  a.setBlockRotationMatrix(ms);
  Atom[] blockShiftVector=new Atom[a.getBlockNum()];
  a.setBlockShiftVector(blockShiftVector);
  String[][][] pdbAln=new String[1][2][alnLen];
  for (int i=0; i < alnLen; i++) {
    pdbAln[0][0][i]=aligned1[i].getChainId() + ""String_Node_Str"" + aligned1[i].toString();
    pdbAln[0][1][i]=aligned2[i].getChainId() + ""String_Node_Str"" + aligned2[i].toString();
  }
  a.setPdbAln(pdbAln);
  AFPChainXMLParser.rebuildAFPChain(a,ca1,ca2);
  return a;
}","/** 
 * Fundamentally, an alignment is just a list of aligned residues in each protein. This method converts two lists of ResidueNumbers into an AFPChain. <p>Parameters are filled with defaults (often null) or sometimes calculated. <p>For a way to modify the alignment of an existing AFPChain, see  {@link AlignmentTools#replaceOptAln(AFPChain,Atom[],Atom[],Map)}
 * @param ca1 CA atoms of the first protein
 * @param ca2 CA atoms of the second protein
 * @param aligned1 A list of aligned residues from the first protein
 * @param aligned2 A list of aligned residues from the second protein.Must be the same length as aligned1.
 * @return An AFPChain representing the alignment. Many properties may benull or another default.
 * @throws StructureException if an error occured during superposition
 * @throws IllegalArgumentException if aligned1 and aligned2 have differentlengths
 * @see AlignmentTools#replaceOptAln(AFPChain,Atom[],Atom[],Map)
 */
public static AFPChain createAFPChain(Atom[] ca1,Atom[] ca2,ResidueNumber[] aligned1,ResidueNumber[] aligned2) throws StructureException {
  int alnLen=aligned1.length;
  if (alnLen != aligned2.length) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  AFPChain a=new AFPChain();
  try {
    a.setName1(ca1[0].getGroup().getChain().getParent().getName());
    if (ca2[0].getGroup().getChain().getParent() != null) {
      a.setName2(ca2[0].getGroup().getChain().getParent().getName());
    }
  }
 catch (  Exception e) {
  }
  a.setBlockNum(1);
  a.setCa1Length(ca1.length);
  a.setCa2Length(ca2.length);
  a.setOptLength(alnLen);
  a.setOptLen(new int[]{alnLen});
  Matrix[] ms=new Matrix[a.getBlockNum()];
  a.setBlockRotationMatrix(ms);
  Atom[] blockShiftVector=new Atom[a.getBlockNum()];
  a.setBlockShiftVector(blockShiftVector);
  String[][][] pdbAln=new String[1][2][alnLen];
  for (int i=0; i < alnLen; i++) {
    pdbAln[0][0][i]=aligned1[i].getChainId() + ""String_Node_Str"" + aligned1[i].toString();
    pdbAln[0][1][i]=aligned2[i].getChainId() + ""String_Node_Str"" + aligned2[i].toString();
  }
  a.setPdbAln(pdbAln);
  AFPChainXMLParser.rebuildAFPChain(a,ca1,ca2);
  return a;
}",0.983969825553984
16976,"/** 
 * Set the default scop version and instance
 * @param scop
 */
public static void setScopDatabase(ScopDatabase scop){
  System.out.println(""String_Node_Str"" + scop.getClass().getName());
  defaultVersion=scop.getScopVersion();
  versionedScopDBs.put(defaultVersion,scop);
}","/** 
 * Set the default scop version and instance
 * @param scop
 */
public static void setScopDatabase(ScopDatabase scop){
  defaultVersion=scop.getScopVersion();
  versionedScopDBs.put(defaultVersion,scop);
}",0.8588957055214724
16977,"/** 
 * Gets an instance of the specified scop version. <p> The particular implementation returned is influenced by the <tt>forceLocalData</tt> parameter. When false, the instance returned will generally be a  {@link RemoteScopInstallation}, although this may be influenced by previous calls to this class. When true, the result is guaranteed to implement   {@link LocalScopDatabase} (generally a {@link BerkeleyScopInstallation}). <p> Note that  
 * @param version A version number, such as {@link #VERSION_1_75A}
 * @param forceLocalData Whether to use a local installation or a remote installation
 * @return an
 */
public static ScopDatabase getSCOP(String version,boolean forceLocalData){
  if (version == null) {
    version=defaultVersion;
  }
  ScopDatabase scop=versionedScopDBs.get(version);
  if (forceLocalData) {
    if (scop == null || !(scop instanceof LocalScopDatabase)) {
      BerkeleyScopInstallation berkeley=new BerkeleyScopInstallation();
      berkeley.setScopVersion(version);
      versionedScopDBs.put(version,berkeley);
      return berkeley;
    }
    return scop;
  }
 else {
    if (scop == null) {
      scop=new RemoteScopInstallation();
      scop.setScopVersion(version);
      versionedScopDBs.put(version,scop);
    }
    return scop;
  }
}","/** 
 * Gets an instance of the specified scop version. <p> The particular implementation returned is influenced by the <tt>forceLocalData</tt> parameter. When false, the instance returned will generally be a  {@link RemoteScopInstallation}, although this may be influenced by previous calls to this class. When true, the result is guaranteed to implement   {@link LocalScopDatabase} (generally a {@link BerkeleyScopInstallation}). <p> Note that  
 * @param version A version number, such as {@link #VERSION_1_75A}
 * @param forceLocalData Whether to use a local installation or a remote installation
 * @return an
 */
public static ScopDatabase getSCOP(String version,boolean forceLocalData){
  if (version == null) {
    version=DEFAULT_VERSION;
  }
  ScopDatabase scop=versionedScopDBs.get(version);
  if (forceLocalData) {
    if (scop == null || !(scop instanceof LocalScopDatabase)) {
      BerkeleyScopInstallation berkeley=new BerkeleyScopInstallation();
      berkeley.setScopVersion(version);
      versionedScopDBs.put(version,berkeley);
      return berkeley;
    }
    return scop;
  }
 else {
    if (scop == null) {
      scop=new RemoteScopInstallation();
      scop.setScopVersion(version);
      versionedScopDBs.put(version,scop);
    }
    return scop;
  }
}",0.9894324853228964
16978,"/** 
 * Set the default scop version and instance
 * @param scop
 */
public static void setScopDatabase(ScopDatabase scop){
  defaultVersion=scop.getScopVersion();
  versionedScopDBs.put(defaultVersion,scop);
}","/** 
 * Set the default scop version and instance
 * @param scop
 */
public static void setScopDatabase(ScopDatabase scop){
  DEFAULT_VERSION=scop.getScopVersion();
  versionedScopDBs.put(DEFAULT_VERSION,scop);
}",0.8720379146919431
16979,"protected void downloadClaFile() throws IOException {
  String filename=getFilename(""String_Node_Str"");
  URL url=new URL(scopDownloadURL + filename);
  downloadFileFromRemote(url,new File(filename));
}","@Override protected void downloadClaFile() throws IOException {
  String filename=getFilename(""String_Node_Str"");
  URL url=new URL(scopDownloadURL + filename);
  downloadFileFromRemote(url,new File(getClaFilename()));
}",0.919431279620853
16980,"protected void downloadComFile() throws IOException {
  String filename=getFilename(""String_Node_Str"");
  URL url=new URL(scopDownloadURL + filename);
  downloadFileFromRemote(url,new File(filename));
}","@Override protected void downloadComFile() throws IOException {
  String filename=getFilename(""String_Node_Str"");
  URL url=new URL(scopDownloadURL + filename);
  downloadFileFromRemote(url,new File(getComFilename()));
}",0.919431279620853
16981,"protected void downloadHieFile() throws IOException {
  String filename=getFilename(""String_Node_Str"");
  URL url=new URL(scopDownloadURL + filename);
  downloadFileFromRemote(url,new File(filename));
}","@Override protected void downloadHieFile() throws IOException {
  String filename=getFilename(""String_Node_Str"");
  URL url=new URL(scopDownloadURL + filename);
  downloadFileFromRemote(url,new File(getHieFilename()));
}",0.919431279620853
16982,"protected void downloadDesFile() throws IOException {
  String filename=getFilename(""String_Node_Str"");
  URL url=new URL(scopDownloadURL + filename);
  downloadFileFromRemote(url,new File(filename));
}","@Override protected void downloadDesFile() throws IOException {
  String filename=getFilename(""String_Node_Str"");
  URL url=new URL(scopDownloadURL + filename);
  downloadFileFromRemote(url,new File(getDesFilename()));
}",0.919431279620853
16983,"/** 
 * Gets an instance of the specified scop version. <p> The particular implementation returned is influenced by the <tt>forceLocalData</tt> parameter. When false, the instance returned will generally be a  {@link RemoteScopInstallation}, although this may be influenced by previous calls to this class. When true, the result is guaranteed to implement   {@link LocalScopDatabase} (generally a {@link BerkeleyScopInstallation}). <p> Note that  
 * @param version A version number, such as {@link #VERSION_1_75A}
 * @param forceLocalData Whether to use a local installation or a remote installation
 * @return an
 */
public static ScopDatabase getSCOP(String version,boolean forceLocalData){
  if (version == null) {
    version=defaultVersion;
  }
  ScopDatabase scop=versionedScopDBs.get(version);
  if (forceLocalData) {
    if (scop == null || !(scop instanceof LocalScopDatabase)) {
      BerkeleyScopInstallation berkeley=new BerkeleyScopInstallation();
      berkeley.setScopVersion(version);
      versionedScopDBs.put(version,berkeley);
      return berkeley;
    }
    return scop;
  }
 else {
    if (scop == null) {
      scop=new RemoteScopInstallation();
      versionedScopDBs.put(version,scop);
    }
    return scop;
  }
}","/** 
 * Gets an instance of the specified scop version. <p> The particular implementation returned is influenced by the <tt>forceLocalData</tt> parameter. When false, the instance returned will generally be a  {@link RemoteScopInstallation}, although this may be influenced by previous calls to this class. When true, the result is guaranteed to implement   {@link LocalScopDatabase} (generally a {@link BerkeleyScopInstallation}). <p> Note that  
 * @param version A version number, such as {@link #VERSION_1_75A}
 * @param forceLocalData Whether to use a local installation or a remote installation
 * @return an
 */
public static ScopDatabase getSCOP(String version,boolean forceLocalData){
  if (version == null) {
    version=defaultVersion;
  }
  ScopDatabase scop=versionedScopDBs.get(version);
  if (forceLocalData) {
    if (scop == null || !(scop instanceof LocalScopDatabase)) {
      BerkeleyScopInstallation berkeley=new BerkeleyScopInstallation();
      berkeley.setScopVersion(version);
      versionedScopDBs.put(version,berkeley);
      return berkeley;
    }
    return scop;
  }
 else {
    if (scop == null) {
      scop=new RemoteScopInstallation();
      scop.setScopVersion(version);
      versionedScopDBs.put(version,scop);
    }
    return scop;
  }
}",0.9857029388403494
16984,"protected void downloadClaFile() throws FileNotFoundException, IOException {
  String remoteFilename=claFileName + scopVersion + ""String_Node_Str"";
  URL url=new URL(scopDownloadURL + remoteFilename);
  String localFileName=getClaFilename();
  File localFile=new File(localFileName);
  downloadFileFromRemote(url,localFile);
}","protected void downloadClaFile() throws IOException {
  String filename=getFilename(""String_Node_Str"");
  URL url=new URL(scopDownloadURL + filename);
  downloadFileFromRemote(url,new File(filename));
}",0.5378787878787878
16985,"protected void downloadComFile() throws FileNotFoundException, IOException {
  String remoteFilename=comFileName + scopVersion + ""String_Node_Str"";
  URL url=new URL(scopDownloadURL + remoteFilename);
  String localFileName=getComFilename();
  File localFile=new File(localFileName);
  downloadFileFromRemote(url,localFile);
}","protected void downloadComFile() throws IOException {
  String filename=getFilename(""String_Node_Str"");
  URL url=new URL(scopDownloadURL + filename);
  downloadFileFromRemote(url,new File(filename));
}",0.5378787878787878
16986,"protected void downloadHieFile() throws FileNotFoundException, IOException {
  String remoteFilename=hieFileName + scopVersion + ""String_Node_Str"";
  URL url=new URL(scopDownloadURL + remoteFilename);
  String localFileName=getHieFilename();
  File localFile=new File(localFileName);
  downloadFileFromRemote(url,localFile);
}","protected void downloadHieFile() throws IOException {
  String filename=getFilename(""String_Node_Str"");
  URL url=new URL(scopDownloadURL + filename);
  downloadFileFromRemote(url,new File(filename));
}",0.5378787878787878
16987,"protected void downloadDesFile() throws FileNotFoundException, IOException {
  String remoteFilename=desFileName + scopVersion + ""String_Node_Str"";
  URL url=new URL(scopDownloadURL + remoteFilename);
  String localFileName=getDesFilename();
  File localFile=new File(localFileName);
  downloadFileFromRemote(url,localFile);
}","protected void downloadDesFile() throws IOException {
  String filename=getFilename(""String_Node_Str"");
  URL url=new URL(scopDownloadURL + filename);
  downloadFileFromRemote(url,new File(filename));
}",0.5378787878787878
16988,"/** 
 * <residue dbResNum=""1"" dbResName=""THR""> <crossRefDb dbSource=""PDB"" dbVersion=""20101103"" dbCoordSys=""PDBresnum"" dbAccessionId=""1a4w"" dbResNum=""1H"" dbResName=""THR"" dbChainId=""L""></crossRefDb> <crossRefDb dbSource=""UniProt"" dbVersion=""157-2"" dbCoordSys=""UniProt"" dbAccessionId=""P00734"" dbResNum=""328"" dbResName=""T""></crossRefDb> <crossRefDb dbSource=""SCOP"" dbVersion=""1.75"" dbCoordSys=""PDBresnum"" dbAccessionId=""26083"" dbResNum=""1H"" dbResName=""THR"" dbChainId=""L""></crossRefDb> <residueDetail dbSource=""MSD"" property=""Annotation""> Not_Observed</residueDetail> </residue>
 */
private SiftsResidue getResidue(Element residue){
  SiftsResidue res=new SiftsResidue();
  String dbResNumS=residue.getAttribute(""String_Node_Str"");
  res.setNaturalPos(Integer.parseInt(dbResNumS));
  String seqResName=residue.getAttribute(""String_Node_Str"");
  res.setSeqResName(seqResName);
  boolean observed=true;
  String detail=getTextValue(residue,""String_Node_Str"");
  if (detail != null)   if (detail != null && detail.trim().equalsIgnoreCase(""String_Node_Str"")) {
    observed=false;
  }
  res.setNotObserved(!observed);
  NodeList nl=residue.getElementsByTagName(""String_Node_Str"");
  if (nl != null && nl.getLength() > 0) {
    for (int i=0; i < nl.getLength(); i++) {
      Element crossRefEl=(Element)nl.item(i);
      String dbSource=crossRefEl.getAttribute(""String_Node_Str"");
      String dbCoordSys=crossRefEl.getAttribute(""String_Node_Str"");
      String dbAccessionId=crossRefEl.getAttribute(""String_Node_Str"");
      String dbResNum=crossRefEl.getAttribute(""String_Node_Str"");
      String dbResName=crossRefEl.getAttribute(""String_Node_Str"");
      String dbChainId=crossRefEl.getAttribute(""String_Node_Str"");
      if (dbSource.equals(""String_Node_Str"") && (dbCoordSys.equals(""String_Node_Str""))) {
        res.setPdbResNum(dbResNum);
        res.setPdbResName(dbResName);
        res.setChainId(dbChainId);
        res.setPdbId(dbAccessionId);
      }
 else       if (dbCoordSys.equals(""String_Node_Str"")) {
        res.setUniProtPos(Integer.parseInt(dbResNum));
        res.setUniProtResName(dbResName);
        res.setUniProtAccessionId(dbAccessionId);
      }
    }
  }
  return res;
}","/** 
 * <residue dbResNum=""1"" dbResName=""THR""> <crossRefDb dbSource=""PDB"" dbVersion=""20101103"" dbCoordSys=""PDBresnum"" dbAccessionId=""1a4w"" dbResNum=""1H"" dbResName=""THR"" dbChainId=""L""></crossRefDb> <crossRefDb dbSource=""UniProt"" dbVersion=""157-2"" dbCoordSys=""UniProt"" dbAccessionId=""P00734"" dbResNum=""328"" dbResName=""T""></crossRefDb> <crossRefDb dbSource=""SCOP"" dbVersion=""1.75"" dbCoordSys=""PDBresnum"" dbAccessionId=""26083"" dbResNum=""1H"" dbResName=""THR"" dbChainId=""L""></crossRefDb> <residueDetail dbSource=""MSD"" property=""Annotation""> Not_Observed</residueDetail> </residue>
 */
private SiftsResidue getResidue(Element residue){
  SiftsResidue res=new SiftsResidue();
  String dbResNumS=residue.getAttribute(""String_Node_Str"");
  res.setNaturalPos(Integer.parseInt(dbResNumS));
  String seqResName=residue.getAttribute(""String_Node_Str"");
  res.setSeqResName(seqResName);
  boolean observed=true;
  String detail=getTextValue(residue,""String_Node_Str"");
  if (detail != null)   if (detail != null && detail.trim().equalsIgnoreCase(""String_Node_Str"")) {
    observed=false;
  }
  res.setNotObserved(!observed);
  NodeList nl=residue.getElementsByTagName(""String_Node_Str"");
  if (nl != null && nl.getLength() > 0) {
    for (int i=0; i < nl.getLength(); i++) {
      Element crossRefEl=(Element)nl.item(i);
      String dbSource=crossRefEl.getAttribute(""String_Node_Str"");
      String dbCoordSys=crossRefEl.getAttribute(""String_Node_Str"");
      String dbAccessionId=crossRefEl.getAttribute(""String_Node_Str"");
      String dbResNum=crossRefEl.getAttribute(""String_Node_Str"");
      String dbResName=crossRefEl.getAttribute(""String_Node_Str"");
      String dbChainId=crossRefEl.getAttribute(""String_Node_Str"");
      if (dbSource.equals(""String_Node_Str"") && (dbCoordSys.equals(""String_Node_Str""))) {
        res.setPdbResNum(dbResNum);
        res.setPdbResName(dbResName);
        res.setChainId(dbChainId);
        res.setPdbId(dbAccessionId);
      }
 else       if (dbSource.equals(""String_Node_Str"")) {
        res.setUniProtPos(Integer.parseInt(dbResNum));
        res.setUniProtResName(dbResName);
        res.setUniProtAccessionId(dbAccessionId);
      }
    }
  }
  return res;
}",0.9968021927820924
16989,"private void pdb_SSBOND_Handler(String line){
  String chain1=line.substring(15,16);
  String seqNum1=line.substring(18,21).trim();
  String icode1=line.substring(21,22);
  String chain2=line.substring(29,30);
  String seqNum2=line.substring(31,35).trim();
  String icode2=line.substring(35,36);
  if (icode1.equals(""String_Node_Str""))   icode1=""String_Node_Str"";
  if (icode2.equals(""String_Node_Str""))   icode2=""String_Node_Str"";
  SSBond ssbond=new SSBond();
  ssbond.setChainID1(chain1);
  ssbond.setResnum1(seqNum1);
  ssbond.setChainID2(chain2);
  ssbond.setResnum2(seqNum2);
  ssbond.setInsCode1(icode1);
  ssbond.setInsCode2(icode2);
  structure.addSSBond(ssbond);
}","private void pdb_SSBOND_Handler(String line){
  String chain1=line.substring(15,16);
  String seqNum1=line.substring(17,21).trim();
  String icode1=line.substring(21,22);
  String chain2=line.substring(29,30);
  String seqNum2=line.substring(31,35).trim();
  String icode2=line.substring(35,36);
  if (icode1.equals(""String_Node_Str""))   icode1=""String_Node_Str"";
  if (icode2.equals(""String_Node_Str""))   icode2=""String_Node_Str"";
  SSBond ssbond=new SSBond();
  ssbond.setChainID1(chain1);
  ssbond.setResnum1(seqNum1);
  ssbond.setChainID2(chain2);
  ssbond.setResnum2(seqNum2);
  ssbond.setInsCode1(icode1);
  ssbond.setInsCode2(icode2);
  structure.addSSBond(ssbond);
}",0.9985163204747776
16990,"public static void main(String[] args) throws Exception {
  GenbankProxySequenceReader<AminoAcidCompound> genbankProteinReader=new GenbankProxySequenceReader<AminoAcidCompound>(""String_Node_Str"",""String_Node_Str"",AminoAcidCompoundSet.getAminoAcidCompoundSet());
  ProteinSequence proteinSequence=new ProteinSequence(genbankProteinReader);
  proteinSequence.setAccession(new AccessionID(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + proteinSequence.getAccession() + ""String_Node_Str""+ proteinSequence.getLength()+ ""String_Node_Str""+ proteinSequence.getSequenceAsString().substring(0,10)+ ""String_Node_Str"");
  GenbankProxySequenceReader<NucleotideCompound> genbankDNAReader=new GenbankProxySequenceReader<NucleotideCompound>(""String_Node_Str"",""String_Node_Str"",DNACompoundSet.getDNACompoundSet());
  DNASequence dnaSequence=new DNASequence(genbankDNAReader);
  dnaSequence.setAccession(new AccessionID(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + dnaSequence.getAccession() + ""String_Node_Str""+ dnaSequence.getLength()+ ""String_Node_Str""+ dnaSequence.getSequenceAsString().substring(0,10)+ ""String_Node_Str"");
  genbankDNAReader=new GenbankProxySequenceReader<NucleotideCompound>(""String_Node_Str"",""String_Node_Str"",DNACompoundSet.getDNACompoundSet());
  dnaSequence=new DNASequence(genbankDNAReader);
  dnaSequence.setAccession(new AccessionID(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + dnaSequence.getAccession() + ""String_Node_Str""+ dnaSequence.getLength()+ ""String_Node_Str""+ dnaSequence.getSequenceAsString().substring(0,10)+ ""String_Node_Str"");
  genbankDNAReader=new GenbankProxySequenceReader<NucleotideCompound>(""String_Node_Str"",""String_Node_Str"",DNACompoundSet.getDNACompoundSet());
  dnaSequence=new DNASequence(genbankDNAReader);
  dnaSequence.setAccession(new AccessionID(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + dnaSequence.getAccession() + ""String_Node_Str""+ dnaSequence.getLength()+ ""String_Node_Str""+ dnaSequence.getSequenceAsString().substring(0,10)+ ""String_Node_Str"");
  genbankDNAReader=new GenbankProxySequenceReader<NucleotideCompound>(""String_Node_Str"",""String_Node_Str"",DNACompoundSet.getDNACompoundSet());
  dnaSequence=new DNASequence(genbankDNAReader);
  dnaSequence.setAccession(new AccessionID(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + dnaSequence.getAccession() + ""String_Node_Str""+ dnaSequence.getLength()+ ""String_Node_Str""+ dnaSequence.getSequenceAsString().substring(0,10)+ ""String_Node_Str"");
  genbankDNAReader=new GenbankProxySequenceReader<NucleotideCompound>(""String_Node_Str"",""String_Node_Str"",DNACompoundSet.getDNACompoundSet());
  dnaSequence=new DNASequence(genbankDNAReader);
  dnaSequence.setAccession(new AccessionID(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + dnaSequence.getAccession() + ""String_Node_Str""+ dnaSequence.getLength()+ ""String_Node_Str""+ dnaSequence.getSequenceAsString().substring(0,10)+ ""String_Node_Str"");
  genbankDNAReader=new GenbankProxySequenceReader<NucleotideCompound>(""String_Node_Str"",""String_Node_Str"",DNACompoundSet.getDNACompoundSet());
  dnaSequence=new DNASequence(genbankDNAReader);
  dnaSequence.setAccession(new AccessionID(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + dnaSequence.getAccession() + ""String_Node_Str""+ dnaSequence.getLength()+ ""String_Node_Str""+ dnaSequence.getSequenceAsString().substring(0,10)+ ""String_Node_Str"");
  genbankDNAReader=new GenbankProxySequenceReader<NucleotideCompound>(""String_Node_Str"",""String_Node_Str"",DNACompoundSet.getDNACompoundSet());
  dnaSequence=new DNASequence(genbankDNAReader);
  dnaSequence.setAccession(new AccessionID(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + dnaSequence.getAccession() + ""String_Node_Str""+ dnaSequence.getLength()+ ""String_Node_Str""+ dnaSequence.getSequenceAsString().substring(0,10)+ ""String_Node_Str"");
}","public static void main(String[] args) throws Exception {
  GenbankProxySequenceReader<AminoAcidCompound> genbankProteinReader=new GenbankProxySequenceReader<AminoAcidCompound>(""String_Node_Str"",""String_Node_Str"",AminoAcidCompoundSet.getAminoAcidCompoundSet());
  ProteinSequence proteinSequence=new ProteinSequence(genbankProteinReader);
  genbankProteinReader.getHeaderParser().parseHeader(genbankProteinReader.getHeader(),proteinSequence);
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + proteinSequence.getAccession() + ""String_Node_Str""+ proteinSequence.getLength()+ ""String_Node_Str""+ proteinSequence.getSequenceAsString().substring(0,10)+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + genbankProteinReader.getKeyWords());
  System.out.println(""String_Node_Str"" + genbankProteinReader.getDatabaseReferences());
  GenbankProxySequenceReader<NucleotideCompound> genbankDNAReader=new GenbankProxySequenceReader<NucleotideCompound>(""String_Node_Str"",""String_Node_Str"",DNACompoundSet.getDNACompoundSet());
  DNASequence dnaSequence=new DNASequence(genbankDNAReader);
  genbankDNAReader.getHeaderParser().parseHeader(genbankDNAReader.getHeader(),dnaSequence);
  dnaSequence.setAccession(new AccessionID(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + dnaSequence.getAccession() + ""String_Node_Str""+ dnaSequence.getLength()+ ""String_Node_Str""+ dnaSequence.getSequenceAsString().substring(0,10)+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + genbankDNAReader.getKeyWords());
  System.out.println(""String_Node_Str"" + genbankDNAReader.getDatabaseReferences());
  genbankDNAReader=new GenbankProxySequenceReader<NucleotideCompound>(""String_Node_Str"",""String_Node_Str"",DNACompoundSet.getDNACompoundSet());
  dnaSequence=new DNASequence(genbankDNAReader);
  genbankDNAReader.getHeaderParser().parseHeader(genbankDNAReader.getHeader(),dnaSequence);
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + dnaSequence.getAccession() + ""String_Node_Str""+ dnaSequence.getLength()+ ""String_Node_Str""+ dnaSequence.getSequenceAsString().substring(0,10)+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + genbankDNAReader.getKeyWords());
  System.out.println(""String_Node_Str"" + genbankDNAReader.getDatabaseReferences());
  genbankDNAReader=new GenbankProxySequenceReader<NucleotideCompound>(""String_Node_Str"",""String_Node_Str"",DNACompoundSet.getDNACompoundSet());
  dnaSequence=new DNASequence(genbankDNAReader);
  genbankDNAReader.getHeaderParser().parseHeader(genbankDNAReader.getHeader(),dnaSequence);
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + dnaSequence.getAccession() + ""String_Node_Str""+ dnaSequence.getLength()+ ""String_Node_Str""+ dnaSequence.getSequenceAsString().substring(0,10)+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + genbankDNAReader.getKeyWords());
  System.out.println(""String_Node_Str"" + genbankDNAReader.getDatabaseReferences());
  genbankDNAReader=new GenbankProxySequenceReader<NucleotideCompound>(""String_Node_Str"",""String_Node_Str"",DNACompoundSet.getDNACompoundSet());
  dnaSequence=new DNASequence(genbankDNAReader);
  genbankDNAReader.getHeaderParser().parseHeader(genbankDNAReader.getHeader(),dnaSequence);
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + dnaSequence.getAccession() + ""String_Node_Str""+ dnaSequence.getLength()+ ""String_Node_Str""+ dnaSequence.getSequenceAsString().substring(0,10)+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + genbankDNAReader.getKeyWords());
  System.out.println(""String_Node_Str"" + genbankDNAReader.getDatabaseReferences());
  genbankDNAReader=new GenbankProxySequenceReader<NucleotideCompound>(""String_Node_Str"",""String_Node_Str"",DNACompoundSet.getDNACompoundSet());
  dnaSequence=new DNASequence(genbankDNAReader);
  genbankDNAReader.getHeaderParser().parseHeader(genbankDNAReader.getHeader(),dnaSequence);
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + dnaSequence.getAccession() + ""String_Node_Str""+ dnaSequence.getLength()+ ""String_Node_Str""+ dnaSequence.getSequenceAsString().substring(0,10)+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + genbankDNAReader.getKeyWords());
  System.out.println(""String_Node_Str"" + genbankDNAReader.getDatabaseReferences());
  genbankDNAReader=new GenbankProxySequenceReader<NucleotideCompound>(""String_Node_Str"",""String_Node_Str"",DNACompoundSet.getDNACompoundSet());
  dnaSequence=new DNASequence(genbankDNAReader);
  genbankDNAReader.getHeaderParser().parseHeader(genbankDNAReader.getHeader(),dnaSequence);
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + dnaSequence.getAccession() + ""String_Node_Str""+ dnaSequence.getLength()+ ""String_Node_Str""+ dnaSequence.getSequenceAsString().substring(0,10)+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + genbankDNAReader.getKeyWords());
  System.out.println(""String_Node_Str"" + genbankDNAReader.getDatabaseReferences());
  genbankDNAReader=new GenbankProxySequenceReader<NucleotideCompound>(""String_Node_Str"",""String_Node_Str"",DNACompoundSet.getDNACompoundSet());
  dnaSequence=new DNASequence(genbankDNAReader);
  genbankDNAReader.getHeaderParser().parseHeader(genbankDNAReader.getHeader(),dnaSequence);
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + dnaSequence.getAccession() + ""String_Node_Str""+ dnaSequence.getLength()+ ""String_Node_Str""+ dnaSequence.getSequenceAsString().substring(0,10)+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + genbankDNAReader.getKeyWords());
  System.out.println(""String_Node_Str"" + genbankDNAReader.getDatabaseReferences());
}",0.7522178667216836
16991,"/** 
 * Load the sequence
 * @return
 */
private boolean init(){
  try {
    BufferedReader br=new BufferedReader(new FileReader(file));
    String sequence=sequenceParser.getSequence(br,sequenceLength);
    setContents(sequence);
    br.close();
  }
 catch (  Exception e) {
    throw new FileAccessError(""String_Node_Str"" + file + ""String_Node_Str""+ sequenceStartIndex+ ""String_Node_Str""+ sequenceLength+ ""String_Node_Str""+ e.toString());
  }
  return true;
}","/** 
 * Load the sequence
 * @return
 */
private boolean init(){
  try {
    BufferedReader br=new BufferedReader(new FileReader(file));
    br.skip(sequenceStartIndex);
    String sequence=sequenceParser.getSequence(br,sequenceLength);
    setContents(sequence);
    br.close();
  }
 catch (  Exception e) {
    throw new FileAccessError(""String_Node_Str"" + file + ""String_Node_Str""+ sequenceStartIndex+ ""String_Node_Str""+ sequenceLength+ ""String_Node_Str""+ e.toString());
  }
  return true;
}",0.9654450261780104
16992,"public Group getAltLocGroup(Character altLoc){
  if (altLocs == null || altLocs.size() == 0)   return null;
  for (  Group group : altLocs) {
    if (group.getAtoms().isEmpty())     continue;
    try {
      if (group.getAtom(0).getAltLoc().equals(altLoc)) {
        return group;
      }
    }
 catch (    StructureException e) {
    }
  }
  return null;
}","public Group getAltLocGroup(Character altLoc){
  try {
    if (getAtom(0).getAltLoc().equals(altLoc)) {
      return this;
    }
    if (altLocs == null || altLocs.size() == 0)     return null;
    for (    Group group : altLocs) {
      if (group.getAtoms().isEmpty())       continue;
      if (group.getAtom(0).getAltLoc().equals(altLoc)) {
        return group;
      }
    }
  }
 catch (  StructureException e) {
  }
  return null;
}",0.853904282115869
16993,"public static void getAlignmentFromFasta(){
  String fastaStr=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  InputStream fasta;
  try {
    fasta=new ByteArrayInputStream(fastaStr.getBytes(""String_Node_Str""));
  }
 catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
    return;
  }
  FastaHeaderParserInterface<ProteinSequence,AminoAcidCompound> headerParser;
  headerParser=new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>();
  AtomCache cache=new AtomCache();
  AminoAcidCompoundSet aaSet=AminoAcidCompoundSet.getAminoAcidCompoundSet();
  SequenceCreatorInterface<AminoAcidCompound> creator;
  creator=new CasePreservingProteinSequenceCreator(aaSet);
  FastaStructureParser parser=new FastaStructureParser(fasta,headerParser,creator,cache);
  try {
    parser.process();
  }
 catch (  IOException e) {
    e.printStackTrace();
    return;
  }
catch (  StructureException e) {
    e.printStackTrace();
    return;
  }
  ResidueNumber[][] residues=parser.getResidues();
  ProteinSequence[] sequences=parser.getSequences();
  Structure[] structures=parser.getStructures();
  for (int structNum=0; structNum < sequences.length; structNum++) {
    CasePreservingProteinSequenceCreator.setLowercaseToNull(sequences[structNum],residues[structNum]);
  }
  residues=StructureSequenceMatcher.removeGaps(residues);
  Atom[] ca1=StructureTools.getAtomCAArray(structures[0]);
  Atom[] ca2=StructureTools.getAtomCAArray(structures[1]);
  AFPChain afp=AlignmentTools.createAFPChain(ca1,ca2,residues[0],residues[1]);
  try {
    StructureAlignmentDisplay.display(afp,ca1,ca2);
  }
 catch (  StructureException e) {
    e.printStackTrace();
    return;
  }
}","public static void getAlignmentFromFasta() throws StructureException {
  String fastaStr=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  InputStream fasta;
  try {
    fasta=new ByteArrayInputStream(fastaStr.getBytes(""String_Node_Str""));
  }
 catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
    return;
  }
  FastaHeaderParserInterface<ProteinSequence,AminoAcidCompound> headerParser;
  headerParser=new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>();
  AtomCache cache=new AtomCache();
  AminoAcidCompoundSet aaSet=AminoAcidCompoundSet.getAminoAcidCompoundSet();
  SequenceCreatorInterface<AminoAcidCompound> creator;
  creator=new CasePreservingProteinSequenceCreator(aaSet);
  FastaStructureParser parser=new FastaStructureParser(fasta,headerParser,creator,cache);
  try {
    parser.process();
  }
 catch (  IOException e) {
    e.printStackTrace();
    return;
  }
catch (  StructureException e) {
    e.printStackTrace();
    return;
  }
  ResidueNumber[][] residues=parser.getResidues();
  ProteinSequence[] sequences=parser.getSequences();
  Structure[] structures=parser.getStructures();
  for (int structNum=0; structNum < sequences.length; structNum++) {
    CasePreservingProteinSequenceCreator.setLowercaseToNull(sequences[structNum],residues[structNum]);
  }
  residues=StructureSequenceMatcher.removeGaps(residues);
  Atom[] ca1=StructureTools.getAtomCAArray(structures[0]);
  Atom[] ca2=StructureTools.getAtomCAArray(structures[1]);
  AFPChain afp=AlignmentTools.createAFPChain(ca1,ca2,residues[0],residues[1]);
  try {
    StructureAlignmentDisplay.display(afp,ca1,ca2);
  }
 catch (  StructureException e) {
    e.printStackTrace();
    return;
  }
}",0.9923273657289002
16994,"public static void main(String[] args){
  getAlignmentFromFasta();
}","public static void main(String[] args) throws StructureException {
  getAlignmentFromFasta();
}",0.8343558282208589
16995,"/** 
 * Takes a structure and sequence corresponding to an alignment between a structure or sequence and itself (or even a structure with a sequence), where the result has a circular permutation site  {@link cpSite} residues to the right.
 * @param cpSite The number of residues from the beginning of the sequence at which the circular permutation site occurs; can be positive or negative; values greater than the length of the sequence are acceptable
 */
public static AFPChain cpFastaToAfpChain(ProteinSequence sequence,ProteinSequence second,Structure structure,int cpSite) throws StructureException {
  if (structure == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (sequence == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int j=0;
  int ungappedCpShift=0;
  while (ungappedCpShift < Math.abs(cpSite)) {
    char c;
    if (cpSite > 0) {
      c=sequence.getSequenceAsString().charAt(j);
    }
 else {
      c=sequence.getSequenceAsString().charAt(sequence.getLength() - 1 - j);
    }
    if (c != '-') {
      ungappedCpShift++;
    }
    j++;
  }
  Atom[] ca1=StructureTools.getAtomCAArray(structure);
  Atom[] ca2=StructureTools.getAtomCAArray(structure);
  ProteinSequence antipermuted=new ProteinSequence(SequenceTools.permuteCyclic(second.getSequenceAsString(),ungappedCpShift));
  ResidueNumber[] residues=StructureSequenceMatcher.matchSequenceToStructure(sequence,structure);
  ResidueNumber[] antipermutedResidues=StructureSequenceMatcher.matchSequenceToStructure(antipermuted,structure);
  ResidueNumber[] nonpermutedResidues=new ResidueNumber[antipermutedResidues.length];
  SequenceTools.permuteCyclic(antipermutedResidues,nonpermutedResidues,-ungappedCpShift);
  if (sequence.getUserCollection() != null) {
    CasePreservingProteinSequenceCreator.setLowercaseToNull(sequence,residues);
  }
  if (second.getUserCollection() != null) {
    CasePreservingProteinSequenceCreator.setLowercaseToNull(second,nonpermutedResidues);
  }
  return buildAlignment(ca1,ca2,residues,nonpermutedResidues);
}","/** 
 * Takes a structure and sequence corresponding to an alignment between a structure or sequence and itself (or even a structure with a sequence), where the result has a circular permutation site  {@link cpSite} residues to the right.
 * @param cpSite The number of residues from the beginning of the sequence at which the circular permutation site occurs; can be positive or negative; values greater than the length of the sequence are acceptable
 */
public static AFPChain cpFastaToAfpChain(ProteinSequence sequence,ProteinSequence second,Structure structure,int cpSite) throws StructureException {
  if (structure == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (sequence == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int gappedCpShift=0;
  int ungappedCpShift=0;
  while (ungappedCpShift < Math.abs(cpSite)) {
    char c;
    try {
      if (cpSite > 0) {
        c=sequence.getSequenceAsString().charAt(gappedCpShift);
      }
 else {
        c=sequence.getSequenceAsString().charAt(sequence.getLength() - 1 - gappedCpShift);
      }
    }
 catch (    StringIndexOutOfBoundsException e) {
      throw new IllegalArgumentException(""String_Node_Str"" + cpSite + ""String_Node_Str"");
    }
    if (c != '-') {
      ungappedCpShift++;
    }
    gappedCpShift++;
  }
  Atom[] ca1=StructureTools.getAtomCAArray(structure);
  Atom[] ca2=StructureTools.getAtomCAArray(structure);
  ProteinSequence antipermuted=new ProteinSequence(SequenceTools.permuteCyclic(second.getSequenceAsString(),gappedCpShift));
  ResidueNumber[] residues=StructureSequenceMatcher.matchSequenceToStructure(sequence,structure);
  ResidueNumber[] antipermutedResidues=StructureSequenceMatcher.matchSequenceToStructure(antipermuted,structure);
  ResidueNumber[] nonpermutedResidues=new ResidueNumber[antipermutedResidues.length];
  SequenceTools.permuteCyclic(antipermutedResidues,nonpermutedResidues,-gappedCpShift);
  if (sequence.getUserCollection() != null) {
    CasePreservingProteinSequenceCreator.setLowercaseToNull(sequence,residues);
  }
  if (second.getUserCollection() != null) {
    CasePreservingProteinSequenceCreator.setLowercaseToNull(second,nonpermutedResidues);
  }
  return buildAlignment(ca1,ca2,residues,nonpermutedResidues);
}",0.9469087566076764
16996,"/** 
 * Builds an   {@link AFPChain} from already-matched arrays of atoms and residues.
 * @param ca1 An array of atoms in the first structure
 * @param ca2 An array of atoms in the second structure
 * @param residues1 An array of  {@link ResidueNumber ResidueNumbers} in the first structure that are aligned. Only null ResidueNumbers are considered to be unaligned
 * @param residues2 An array of  {@link ResidueNumber ResidueNumbers} in the second structure that are aligned. Only null ResidueNumbers are considered to be unaligned
 */
private static AFPChain buildAlignment(Atom[] ca1,Atom[] ca2,ResidueNumber[] residues1,ResidueNumber[] residues2) throws StructureException {
  List<ResidueNumber> alignedResiduesList1=new ArrayList<ResidueNumber>();
  List<ResidueNumber> alignedResiduesList2=new ArrayList<ResidueNumber>();
  for (int i=0; i < residues1.length; i++) {
    if (residues1[i] != null && residues2[i] != null) {
      alignedResiduesList1.add(residues1[i]);
      alignedResiduesList2.add(residues2[i]);
    }
  }
  ResidueNumber[] alignedResidues1=alignedResiduesList1.toArray(new ResidueNumber[alignedResiduesList1.size()]);
  ResidueNumber[] alignedResidues2=alignedResiduesList2.toArray(new ResidueNumber[alignedResiduesList2.size()]);
  AFPChain afpChain=AlignmentTools.createAFPChain(ca1,ca2,alignedResidues1,alignedResidues2);
  if (alignedResidues1.length > 0 && alignedResidues2.length > 0) {
    Atom[] alignedAtoms1=getAligned(ca1,alignedResiduesList1);
    Atom[] alignedAtoms2=getAligned(ca2,alignedResiduesList2);
    SVDSuperimposer svd=new SVDSuperimposer(alignedAtoms1,alignedAtoms2);
    Matrix matrix=svd.getRotation();
    Atom shift=svd.getTranslation();
    Atom[] aligned2Clone=StructureTools.cloneCAArray(alignedAtoms2);
    for (    Atom atom : aligned2Clone) {
      Calc.rotate(atom,matrix);
      Calc.shift(atom,shift);
    }
    double rmsd=SVDSuperimposer.getRMS(alignedAtoms1,aligned2Clone);
    double tmScore=SVDSuperimposer.getTMScore(alignedAtoms1,aligned2Clone,ca1.length,ca2.length);
    for (    AFP afp : afpChain.getAfpSet()) {
      afp.setFragLen(1);
      afp.setM(matrix);
      afp.setRmsd(rmsd);
      afp.setScore(tmScore);
    }
    afpChain.setBlockShiftVector(new Atom[]{shift});
    afpChain.setBlockRotationMatrix(new Matrix[]{matrix});
    afpChain.setBlockRmsd(new double[]{rmsd});
    afpChain.setBlockGap(new int[]{afpChain.getGapLen()});
    afpChain.setBlockSize(new int[]{alignedAtoms1.length});
    afpChain.setTotalRmsdOpt(rmsd);
    afpChain.setTMScore(tmScore);
  }
 else {
    afpChain.setTMScore(0);
  }
  return afpChain;
}","/** 
 * Builds an   {@link AFPChain} from already-matched arrays of atoms and residues.
 * @param ca1 An array of atoms in the first structure
 * @param ca2 An array of atoms in the second structure
 * @param residues1 An array of  {@link ResidueNumber ResidueNumbers} in the first structure that are aligned. Only null ResidueNumbers are considered to be unaligned
 * @param residues2 An array of  {@link ResidueNumber ResidueNumbers} in the second structure that are aligned. Only null ResidueNumbers are considered to be unaligned
 */
private static AFPChain buildAlignment(Atom[] ca1,Atom[] ca2,ResidueNumber[] residues1,ResidueNumber[] residues2) throws StructureException {
  List<ResidueNumber> alignedResiduesList1=new ArrayList<ResidueNumber>();
  List<ResidueNumber> alignedResiduesList2=new ArrayList<ResidueNumber>();
  for (int i=0; i < residues1.length; i++) {
    if (residues1[i] != null && residues2[i] != null) {
      alignedResiduesList1.add(residues1[i]);
      alignedResiduesList2.add(residues2[i]);
    }
  }
  ResidueNumber[] alignedResidues1=alignedResiduesList1.toArray(new ResidueNumber[alignedResiduesList1.size()]);
  ResidueNumber[] alignedResidues2=alignedResiduesList2.toArray(new ResidueNumber[alignedResiduesList2.size()]);
  AFPChain afpChain=AlignmentTools.createAFPChain(ca1,ca2,alignedResidues1,alignedResidues2);
  if (alignedResidues1.length > 0 && alignedResidues2.length > 0) {
    AFPTwister.twistOptimized(afpChain,ca1,ca2);
    List<Group> hetatms2=new ArrayList<Group>();
    List<Group> nucs2=new ArrayList<Group>();
    Group g2=ca2[0].getGroup();
    Chain c2=null;
    if (g2 != null) {
      c2=g2.getChain();
      if (c2 != null) {
        hetatms2=c2.getAtomGroups(""String_Node_Str"");
        nucs2=c2.getAtomGroups(""String_Node_Str"");
      }
    }
    if (afpChain.getBlockNum() > 0) {
      if (hetatms2.size() > 0 || nucs2.size() > 0) {
        if (afpChain.getBlockRotationMatrix().length > 0) {
          Matrix m1=afpChain.getBlockRotationMatrix()[0];
          Atom vector1=afpChain.getBlockShiftVector()[0];
          for (          Group g : hetatms2) {
            Calc.rotate(g,m1);
            Calc.shift(g,vector1);
          }
          for (          Group g : nucs2) {
            Calc.rotate(g,m1);
            Calc.shift(g,vector1);
          }
        }
      }
    }
    double tmScore=AFPChainScorer.getTMScore(afpChain,ca1,ca2);
    afpChain.setTMScore(tmScore);
  }
 else {
    afpChain.setTMScore(0);
  }
  return afpChain;
}",0.6120453656628861
16997,"/** 
 * Takes a structure and sequence corresponding to an alignment between a structure or sequence and itself (or even a structure with a sequence), where the result has a circular permutation site  {@link cpSite} residues to the right.
 * @param cpSite The number of residues from the beginning of the sequence at which the circular permutation site occurs; can be positive or negative; values greater than the length of the sequence are acceptable
 */
public static AFPChain cpFastaToAfpChain(ProteinSequence sequence,ProteinSequence second,Structure structure,int cpSite) throws StructureException {
  setUserCollection(sequence);
  if (structure == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (sequence == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Atom[] ca1=StructureTools.getAtomCAArray(structure);
  Atom[] ca2=StructureTools.cloneCAArray(ca1);
  ProteinSequence antipermuted=new ProteinSequence(SequenceTools.permuteCyclic(second.getSequenceAsString(),-cpSite));
  ResidueNumber[] residues=StructureSequenceMatcher.matchSequenceToStructure(sequence,structure);
  ResidueNumber[] antipermutedResidues=StructureSequenceMatcher.matchSequenceToStructure(antipermuted,structure);
  ResidueNumber[] nonpermutedResidues=new ResidueNumber[antipermutedResidues.length];
  SequenceTools.permuteCyclic(antipermutedResidues,nonpermutedResidues,+cpSite);
  for (  ResidueNumber r : residues)   System.err.print(r + ""String_Node_Str"");
  System.err.println();
  for (  char c : sequence.getSequenceAsString().toCharArray())   System.err.print(c + ""String_Node_Str"");
  System.err.println();
  for (  ResidueNumber r : nonpermutedResidues)   System.err.print(r + ""String_Node_Str"");
  System.err.println();
  for (  char c : second.getSequenceAsString().toCharArray())   System.err.print(c + ""String_Node_Str"");
  System.err.println();
  if (sequence.getUserCollection() != null) {
    CasePreservingProteinSequenceCreator.setLowercaseToNull(sequence,residues);
  }
  if (antipermuted.getUserCollection() != null) {
    CasePreservingProteinSequenceCreator.setLowercaseToNull(second,nonpermutedResidues);
  }
  return buildAlignment(ca1,ca2,residues,nonpermutedResidues);
}","/** 
 * Takes a structure and sequence corresponding to an alignment between a structure or sequence and itself (or even a structure with a sequence), where the result has a circular permutation site  {@link cpSite} residues to the right.
 * @param cpSite The number of residues from the beginning of the sequence at which the circular permutation site occurs; can be positive or negative; values greater than the length of the sequence are acceptable
 */
public static AFPChain cpFastaToAfpChain(ProteinSequence sequence,ProteinSequence second,Structure structure,int cpSite) throws StructureException {
  if (structure == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (sequence == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Atom[] ca1=StructureTools.getAtomCAArray(structure);
  Atom[] ca2=StructureTools.getAtomCAArray(structure);
  ProteinSequence antipermuted=new ProteinSequence(SequenceTools.permuteCyclic(second.getSequenceAsString(),-cpSite));
  ResidueNumber[] residues=StructureSequenceMatcher.matchSequenceToStructure(sequence,structure);
  ResidueNumber[] antipermutedResidues=StructureSequenceMatcher.matchSequenceToStructure(antipermuted,structure);
  ResidueNumber[] nonpermutedResidues=new ResidueNumber[antipermutedResidues.length];
  SequenceTools.permuteCyclic(antipermutedResidues,nonpermutedResidues,+cpSite);
  if (sequence.getUserCollection() != null) {
    CasePreservingProteinSequenceCreator.setLowercaseToNull(sequence,residues);
  }
  if (antipermuted.getUserCollection() != null) {
    CasePreservingProteinSequenceCreator.setLowercaseToNull(second,nonpermutedResidues);
  }
  for (  ResidueNumber r : residues)   System.err.print(r + ""String_Node_Str"");
  System.err.println();
  for (  char c : sequence.getSequenceAsString().toCharArray())   System.err.print(c + ""String_Node_Str"");
  System.err.println();
  for (  ResidueNumber r : nonpermutedResidues)   System.err.print(r + ""String_Node_Str"");
  System.err.println();
  for (  char c : second.getSequenceAsString().toCharArray())   System.err.print(c + ""String_Node_Str"");
  System.err.println();
  return buildAlignment(ca1,ca2,residues,nonpermutedResidues);
}",0.8646091462041
16998,"/** 
 * Takes a structure and sequence corresponding to an alignment between a structure or sequence and itself (or even a structure with a sequence), where the result has a circular permutation site  {@link cpSite} residues to the right.
 * @param cpSite The number of residues from the beginning of the sequence at which the circular permutation site occurs; can be positive or negative; values greater than the length of the sequence are acceptable
 */
public static AFPChain cpFastaToAfpChain(ProteinSequence sequence,ProteinSequence second,Structure structure,int cpSite) throws StructureException {
  if (structure == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (sequence == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Atom[] ca1=StructureTools.getAtomCAArray(structure);
  Atom[] ca2=StructureTools.getAtomCAArray(structure);
  ProteinSequence antipermuted=new ProteinSequence(SequenceTools.permuteCyclic(second.getSequenceAsString(),-cpSite));
  ResidueNumber[] residues=StructureSequenceMatcher.matchSequenceToStructure(sequence,structure);
  ResidueNumber[] antipermutedResidues=StructureSequenceMatcher.matchSequenceToStructure(antipermuted,structure);
  ResidueNumber[] nonpermutedResidues=new ResidueNumber[antipermutedResidues.length];
  SequenceTools.permuteCyclic(antipermutedResidues,nonpermutedResidues,+cpSite);
  if (sequence.getUserCollection() != null) {
    CasePreservingProteinSequenceCreator.setLowercaseToNull(sequence,residues);
  }
  if (antipermuted.getUserCollection() != null) {
    CasePreservingProteinSequenceCreator.setLowercaseToNull(second,nonpermutedResidues);
  }
  for (  ResidueNumber r : residues)   System.err.print(r + ""String_Node_Str"");
  System.err.println();
  for (  char c : sequence.getSequenceAsString().toCharArray())   System.err.print(c + ""String_Node_Str"");
  System.err.println();
  for (  ResidueNumber r : nonpermutedResidues)   System.err.print(r + ""String_Node_Str"");
  System.err.println();
  for (  char c : second.getSequenceAsString().toCharArray())   System.err.print(c + ""String_Node_Str"");
  System.err.println();
  return buildAlignment(ca1,ca2,residues,nonpermutedResidues);
}","/** 
 * Takes a structure and sequence corresponding to an alignment between a structure or sequence and itself (or even a structure with a sequence), where the result has a circular permutation site  {@link cpSite} residues to the right.
 * @param cpSite The number of residues from the beginning of the sequence at which the circular permutation site occurs; can be positive or negative; values greater than the length of the sequence are acceptable
 */
public static AFPChain cpFastaToAfpChain(ProteinSequence sequence,ProteinSequence second,Structure structure,int cpSite) throws StructureException {
  if (structure == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (sequence == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Atom[] ca1=StructureTools.getAtomCAArray(structure);
  Atom[] ca2=StructureTools.getAtomCAArray(structure);
  ProteinSequence antipermuted=new ProteinSequence(SequenceTools.permuteCyclic(second.getSequenceAsString(),-cpSite));
  ResidueNumber[] residues=StructureSequenceMatcher.matchSequenceToStructure(sequence,structure);
  ResidueNumber[] antipermutedResidues=StructureSequenceMatcher.matchSequenceToStructure(antipermuted,structure);
  ResidueNumber[] nonpermutedResidues=new ResidueNumber[antipermutedResidues.length];
  SequenceTools.permuteCyclic(antipermutedResidues,nonpermutedResidues,+cpSite);
  if (sequence.getUserCollection() != null) {
    CasePreservingProteinSequenceCreator.setLowercaseToNull(sequence,residues);
  }
  if (second.getUserCollection() != null) {
    CasePreservingProteinSequenceCreator.setLowercaseToNull(second,nonpermutedResidues);
  }
  for (  ResidueNumber r : residues)   System.err.print(r + ""String_Node_Str"");
  System.out.println();
  for (  char c : sequence.getSequenceAsString().toCharArray())   System.err.print(c + ""String_Node_Str"");
  System.out.println();
  for (  ResidueNumber r : nonpermutedResidues)   System.err.print(r + ""String_Node_Str"");
  System.out.println();
  for (  char c : second.getSequenceAsString().toCharArray())   System.err.print(c + ""String_Node_Str"");
  System.out.println();
  for (int i=0; i < residues.length; i++) {
    if (residues[i] == null && nonpermutedResidues[i] != null || residues[i] != null && nonpermutedResidues[i] == null) {
      System.out.println(""String_Node_Str"" + i);
    }
  }
  for (int i=0; i < residues.length; i++) {
    if (residues[i] == null) {
      System.out.print(""String_Node_Str"");
    }
 else {
      System.out.print(sequence.getSequenceAsString().charAt(i));
    }
  }
  System.out.println();
  for (int i=0; i < residues.length; i++) {
    if (nonpermutedResidues[i] == null) {
      System.out.print(""String_Node_Str"");
    }
 else {
      System.out.print(second.getSequenceAsString().charAt(i));
    }
  }
  int x=0;
  for (int i=0; i < nonpermutedResidues.length; i++)   if (nonpermutedResidues[i] == null)   x++;
  System.out.println();
  System.out.println(""String_Node_Str"" + x);
  return buildAlignment(ca1,ca2,residues,nonpermutedResidues);
}",0.8270619536297985
16999,"@Test public void testCp() throws IOException, StructureException {
  Structure structure=cache.getStructure(""String_Node_Str"");
  ProteinSequence sequence=new ProteinSequence(""String_Node_Str"");
  ProteinSequence second=new ProteinSequence(""String_Node_Str"");
  AFPChain afpChain=FastaAFPChainConverter.cpFastaToAfpChain(sequence,second,structure,-393);
  String xml=AFPChainXMLConverter.toXML(afpChain);
  System.out.println(xml);
}","@Test public void testCp() throws IOException, StructureException {
  Structure structure=cache.getStructure(""String_Node_Str"");
  String first=(""String_Node_Str"");
  String second=(""String_Node_Str"");
  int y=0;
  for (int i=0; i < second.length(); i++)   if (second.charAt(i) == '-' || Character.isLowerCase(second.charAt(i)))   y++;
  System.out.println(""String_Node_Str"" + y);
  AFPChain afpChain=FastaAFPChainConverter.cpFastaToAfpChain(first,second,structure,-393);
  String xml=AFPChainXMLConverter.toXML(afpChain);
  System.out.println(xml);
}",0.6456852791878173
17000,"/** 
 * Fundamentally, an alignment is just a list of aligned residues in each protein. This method converts two lists of ResidueNumbers into an AFPChain. <p>Parameters are filled with defaults (often null) or sometimes calculated. <p>For a way to modify the alignment of an existing AFPChain, see  {@link AlignmentTools#replaceOptAln(AFPChain,Atom[],Atom[],Map)}
 * @param ca1 CA atoms of the first protein
 * @param ca2 CA atoms of the second protein
 * @param aligned1 A list of aligned residues from the first protein
 * @param aligned2 A list of aligned residues from the second protein.Must be the same length as aligned1.
 * @return An AFPChain representing the alignment. Many properties may benull or another default.
 * @throws StructureException if an error occured during superposition
 * @throws IllegalArgumentException if aligned1 and aligned2 have differentlengths
 * @see AlignmentTools#replaceOptAln(AFPChain,Atom[],Atom[],Map)
 */
public static AFPChain createAFPChain(Atom[] ca1,Atom[] ca2,ResidueNumber[] aligned1,ResidueNumber[] aligned2) throws StructureException {
  int alnLen=aligned1.length;
  if (alnLen != aligned2.length) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  AFPChain a=new AFPChain();
  a.setName1(ca1[0].getGroup().getChain().getParent().getName());
  a.setName2(ca2[0].getGroup().getChain().getParent().getName());
  a.setBlockNum(1);
  a.setCa1Length(ca1.length);
  a.setCa2Length(ca2.length);
  a.setOptLength(alnLen);
  a.setOptLen(new int[]{alnLen});
  Matrix[] ms=new Matrix[a.getBlockNum()];
  a.setBlockRotationMatrix(ms);
  Atom[] blockShiftVector=new Atom[a.getBlockNum()];
  a.setBlockShiftVector(blockShiftVector);
  String[][][] pdbAln=new String[1][2][alnLen];
  for (int i=0; i < alnLen; i++) {
    pdbAln[0][0][i]=aligned1[i].getChainId() + ""String_Node_Str"" + aligned1[i].toString();
    pdbAln[0][1][i]=aligned2[i].getChainId() + ""String_Node_Str"" + aligned2[i].toString();
  }
  a.setPdbAln(pdbAln);
  AFPChainXMLParser.rebuildAFPChain(a,ca1,ca2);
  AlignmentTools.splitBlocksByTopology(a,ca1,ca2);
  return a;
}","/** 
 * Fundamentally, an alignment is just a list of aligned residues in each protein. This method converts two lists of ResidueNumbers into an AFPChain. <p>Parameters are filled with defaults (often null) or sometimes calculated. <p>For a way to modify the alignment of an existing AFPChain, see  {@link AlignmentTools#replaceOptAln(AFPChain,Atom[],Atom[],Map)}
 * @param ca1 CA atoms of the first protein
 * @param ca2 CA atoms of the second protein
 * @param aligned1 A list of aligned residues from the first protein
 * @param aligned2 A list of aligned residues from the second protein.Must be the same length as aligned1.
 * @return An AFPChain representing the alignment. Many properties may benull or another default.
 * @throws StructureException if an error occured during superposition
 * @throws IllegalArgumentException if aligned1 and aligned2 have differentlengths
 * @see AlignmentTools#replaceOptAln(AFPChain,Atom[],Atom[],Map)
 */
public static AFPChain createAFPChain(Atom[] ca1,Atom[] ca2,ResidueNumber[] aligned1,ResidueNumber[] aligned2) throws StructureException {
  int alnLen=aligned1.length;
  if (alnLen != aligned2.length) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  AFPChain a=new AFPChain();
  a.setName1(ca1[0].getGroup().getChain().getParent().getName());
  a.setName2(ca2[0].getGroup().getChain().getParent().getName());
  a.setBlockNum(1);
  a.setCa1Length(ca1.length);
  a.setCa2Length(ca2.length);
  a.setOptLength(alnLen);
  a.setOptLen(new int[]{alnLen});
  Matrix[] ms=new Matrix[a.getBlockNum()];
  a.setBlockRotationMatrix(ms);
  Atom[] blockShiftVector=new Atom[a.getBlockNum()];
  a.setBlockShiftVector(blockShiftVector);
  String[][][] pdbAln=new String[1][2][alnLen];
  for (int i=0; i < alnLen; i++) {
    pdbAln[0][0][i]=aligned1[i].getChainId() + ""String_Node_Str"" + aligned1[i].toString();
    pdbAln[0][1][i]=aligned2[i].getChainId() + ""String_Node_Str"" + aligned2[i].toString();
  }
  a.setPdbAln(pdbAln);
  AFPChainXMLParser.rebuildAFPChain(a,ca1,ca2);
  return a;
}",0.9876662636033856
