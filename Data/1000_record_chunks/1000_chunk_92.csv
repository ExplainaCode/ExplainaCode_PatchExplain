record_number,buggy_code,fixed_code,code_similarity
91001,"@Test public void testRemoveObjectL(){
  final int size=map.size();
  final TestEdge ref=graph.edgeRef();
  final TestEdge remove=map.remove(Ak,ref);
  assertNull(""String_Node_Str"",remove);
  assertEquals(""String_Node_Str"",size,map.size());
  final TestEdge remove2=map.remove(Bk,ref);
  assertEquals(""String_Node_Str"",eAB,remove2);
  assertEquals(""String_Node_Str"",size - 1,map.size());
}","@Test public void testRemoveObjectL(){
  final int size=map.size();
  final TestEdge ref=graph.edgeRef();
  final TestEdge remove=map.removeWithRef(Ak,ref);
  assertNull(""String_Node_Str"",remove);
  assertEquals(""String_Node_Str"",size,map.size());
  final TestEdge remove2=map.removeWithRef(Bk,ref);
  assertEquals(""String_Node_Str"",eAB,remove2);
  assertEquals(""String_Node_Str"",size - 1,map.size());
}",0.9823232323232324
91002,"@Override @Test public void testRemoveObjectL(){
  final int size=map.size();
  final TestVertex ref=graph.vertexRef();
  final TestVertex remove=map.remove(Ak,ref);
  assertNull(""String_Node_Str"",remove);
  assertEquals(""String_Node_Str"",size,map.size());
  final TestVertex remove2=map.remove(Bk,ref);
  assertEquals(""String_Node_Str"",Ck2,remove2);
  assertEquals(""String_Node_Str"",size - 1,map.size());
}","@Override @Test public void testRemoveObjectL(){
  final int size=map.size();
  final TestVertex ref=graph.vertexRef();
  final TestVertex remove=map.removeWithRef(Ak,ref);
  assertNull(""String_Node_Str"",remove);
  assertEquals(""String_Node_Str"",size,map.size());
  final TestVertex remove2=map.removeWithRef(Bk,ref);
  assertEquals(""String_Node_Str"",Ck2,remove2);
  assertEquals(""String_Node_Str"",size - 1,map.size());
}",0.9830917874396136
91003,"@Test public void testRemoveObjectL(){
  final int size=map.size();
  final TestVertex ref=graph.vertexRef();
  final TestVertex remove=map.remove(Ak,ref);
  assertNull(""String_Node_Str"",remove);
  assertEquals(""String_Node_Str"",size,map.size());
  final TestVertex remove2=map.remove(Bk,ref);
  assertEquals(""String_Node_Str"",Ck,remove2);
  assertEquals(""String_Node_Str"",size - 1,map.size());
}","@Test public void testRemoveObjectL(){
  final int size=map.size();
  final TestVertex ref=graph.vertexRef();
  final TestVertex remove=map.removeWithRef(Ak,ref);
  assertNull(""String_Node_Str"",remove);
  assertEquals(""String_Node_Str"",size,map.size());
  final TestVertex remove2=map.removeWithRef(Bk,ref);
  assertEquals(""String_Node_Str"",Ck,remove2);
  assertEquals(""String_Node_Str"",size - 1,map.size());
}",0.9826302729528535
91004,"private void install(){
  final HashSet<AbstractNamedDefaultKeyStrokeAction> actions=new HashSet<AbstractNamedDefaultKeyStrokeAction>();
  actions.add(new ChangeSpotRadiusAction(true,true));
  actions.add(new ChangeSpotRadiusAction(true,false));
  actions.add(new ChangeSpotRadiusAction(false,true));
  actions.add(new ChangeSpotRadiusAction(false,false));
  for (  final AbstractNamedDefaultKeyStrokeAction action : actions) {
    actionMap.put(action.name(),action);
    inputMap.put(action.getDefaultKeyStroke(),action.name());
  }
}","private void install(){
  final HashSet<AbstractNamedDefaultKeyStrokeAction> actions=new HashSet<AbstractNamedDefaultKeyStrokeAction>();
  actions.add(new ChangeSpotRadiusAction(true,true));
  actions.add(new ChangeSpotRadiusAction(true,false));
  actions.add(new ChangeSpotRadiusAction(false,true));
  actions.add(new ChangeSpotRadiusAction(false,false));
  actions.add(new DeleteSpotAction());
  for (  final AbstractNamedDefaultKeyStrokeAction action : actions) {
    actionMap.put(action.name(),action);
    inputMap.put(action.getDefaultKeyStroke(),action.name());
  }
}",0.9648964896489648
91005,"private boolean deleteSpot(final SpotCovariance spot){
  final int timepoint=spot.getTimepoint();
  trackscheme.getGraph().remove(getTrackSchemeVertex(spot));
  final boolean ok=model.deleteSpot(spot);
  wrapper.refresh(timepoint);
  return ok;
}","private boolean deleteSpot(final OverlayVertexWrapper<SpotCovariance,Link<SpotCovariance>> v){
  final int timepoint=v.getTimepoint();
  final PoolObjectSet<OverlayVertexWrapper<SpotCovariance,Link<SpotCovariance>>> set=(PoolObjectSet<OverlayVertexWrapper<SpotCovariance,Link<SpotCovariance>>>)wrapper.getSpots(timepoint);
  set.getIndexCollection().remove(v.getInternalPoolIndex());
  trackscheme.getGraph().remove(v.getTrackSchemeVertex());
  final boolean ok=model.deleteSpot(v.get());
  wrapper.updateSearchFor(timepoint);
  return ok;
}",0.1880559085133418
91006,"private void quicksort(final int low,final int high,final Comparator<O> comparator,final O tmpRef1,final O tmpRef2){
  final O pivot=get((low + high) / 2,tmpRef1);
  int i=low;
  int j=high;
  do {
    while (comparator.compare(get(i,tmpRef2),pivot) < 0)     i++;
    while (comparator.compare(pivot,get(j,tmpRef2)) < 0)     j--;
    if (i <= j) {
      swap(i,j);
      i++;
      j--;
    }
  }
 while (i <= j);
  if (low < j)   quicksort(low,j,comparator,tmpRef1,tmpRef2);
  if (i < high)   quicksort(i,high,comparator,tmpRef1,tmpRef2);
}","private void quicksort(final int low,final int high,final Comparator<? super O> comparator,final O tmpRef1,final O tmpRef2){
  final O pivot=get((low + high) / 2,tmpRef1);
  int i=low;
  int j=high;
  do {
    while (comparator.compare(get(i,tmpRef2),pivot) < 0)     i++;
    while (comparator.compare(pivot,get(j,tmpRef2)) < 0)     j--;
    if (i <= j) {
      swap(i,j);
      i++;
      j--;
    }
  }
 while (i <= j);
  if (low < j)   quicksort(low,j,comparator,tmpRef1,tmpRef2);
  if (i < high)   quicksort(i,high,comparator,tmpRef1,tmpRef2);
}",0.9926605504587156
91007,"@Override public void sort(final Comparator<O> comparator){
  if (indices.size() < 2)   return;
  quicksort(0,size() - 1,comparator,createRef(),createRef());
}","@Override public void sort(final Comparator<? super O> comparator){
  if (indices.size() < 2)   return;
  quicksort(0,size() - 1,comparator,createRef(),createRef());
}",0.9754601226993864
91008,"/** 
 * Sort the values in the list, in ascending order according to the specified   {@link Comparator}.
 * @param comparator the comparator to use for ordering.
 */
public void sort(Comparator<O> comparator);","/** 
 * Sort the values in the list, in ascending order according to the specified   {@link Comparator}.
 * @param comparator the comparator to use for ordering.
 */
@Override public void sort(Comparator<? super O> comparator);",0.9587155963302753
91009,"@Override public void sort(final Comparator<O> comparator){
  Collections.sort(collection,comparator);
}","@Override public void sort(final Comparator<? super O> comparator){
  Collections.sort(collection,comparator);
}",0.9629629629629628
91010,"@Override public void refresh(){
  frame.repaint();
}","@Override public void refresh(){
  if (sl != null) {
    final RefSet<TrackSchemeVertex> selectedVertices=selectionModel.getSelectedVertices();
    if (!selectedVertices.isEmpty())     sl.select(selectedVertices.iterator().next());
    sl.repaint();
  }
  frame.repaint();
}",0.2324159021406728
91011,"private void unlinkFromTarget(final E edge,final E tmpEdge,final V tmpVertex){
  vertexPool.getByInternalPoolIndex(edge.getTargetVertexInternalPoolIndex(),tmpVertex);
  final int targetInIndex=tmpVertex.getFirstInEdgeIndex();
  if (targetInIndex == edge.getInternalPoolIndex()) {
    tmpVertex.setFirstInEdgeIndex(edge.getNextTargetEdgeIndex());
  }
 else {
    getByInternalPoolIndex(targetInIndex,tmpEdge);
    int nextTargetEdgeIndex=tmpEdge.getNextTargetEdgeIndex();
    while (nextTargetEdgeIndex >= 0) {
      getByInternalPoolIndex(nextTargetEdgeIndex,tmpEdge);
      nextTargetEdgeIndex=tmpEdge.getNextTargetEdgeIndex();
    }
    tmpEdge.setNextTargetEdgeIndex(edge.getNextTargetEdgeIndex());
  }
}","private void unlinkFromTarget(final E edge,final E tmpEdge,final V tmpVertex){
  vertexPool.getByInternalPoolIndex(edge.getTargetVertexInternalPoolIndex(),tmpVertex);
  final int targetInIndex=tmpVertex.getFirstInEdgeIndex();
  if (targetInIndex == edge.getInternalPoolIndex()) {
    tmpVertex.setFirstInEdgeIndex(edge.getNextTargetEdgeIndex());
  }
 else {
    getByInternalPoolIndex(targetInIndex,tmpEdge);
    int nextTargetEdgeIndex=tmpEdge.getNextTargetEdgeIndex();
    while (nextTargetEdgeIndex != edge.getInternalPoolIndex()) {
      getByInternalPoolIndex(nextTargetEdgeIndex,tmpEdge);
      nextTargetEdgeIndex=tmpEdge.getNextTargetEdgeIndex();
    }
    tmpEdge.setNextTargetEdgeIndex(edge.getNextTargetEdgeIndex());
  }
}",0.9791666666666666
91012,"private void unlinkFromTarget(final E edge,final E tmpEdge,final V tmpVertex){
  vertexPool.getByInternalPoolIndex(edge.getTargetVertexInternalPoolIndex(),tmpVertex);
  final int targetInIndex=tmpVertex.getFirstInEdgeIndex();
  if (targetInIndex == edge.getInternalPoolIndex()) {
    tmpVertex.setFirstInEdgeIndex(edge.getNextTargetEdgeIndex());
  }
 else {
    getByInternalPoolIndex(targetInIndex,tmpEdge);
    int nextTargetEdgeIndex=tmpEdge.getNextTargetEdgeIndex();
    while (nextTargetEdgeIndex >= 0) {
      getByInternalPoolIndex(nextTargetEdgeIndex,tmpEdge);
      nextTargetEdgeIndex=tmpEdge.getNextTargetEdgeIndex();
    }
    tmpEdge.setNextTargetEdgeIndex(edge.getNextTargetEdgeIndex());
  }
}","private void unlinkFromTarget(final E edge,final E tmpEdge,final V tmpVertex){
  vertexPool.getByInternalPoolIndex(edge.getTargetVertexInternalPoolIndex(),tmpVertex);
  final int targetInIndex=tmpVertex.getFirstInEdgeIndex();
  if (targetInIndex == edge.getInternalPoolIndex()) {
    tmpVertex.setFirstInEdgeIndex(edge.getNextTargetEdgeIndex());
  }
 else {
    getByInternalPoolIndex(targetInIndex,tmpEdge);
    int nextTargetEdgeIndex=tmpEdge.getNextTargetEdgeIndex();
    while (nextTargetEdgeIndex != edge.getInternalPoolIndex()) {
      getByInternalPoolIndex(nextTargetEdgeIndex,tmpEdge);
      nextTargetEdgeIndex=tmpEdge.getNextTargetEdgeIndex();
    }
    tmpEdge.setNextTargetEdgeIndex(edge.getNextTargetEdgeIndex());
  }
}",0.9791666666666666
91013,"/** 
 * Make this   {@link PoolObject} refer to the same data as {@code obj}
 * @param obj A  {@link PoolObject}, usually of the same type as this one.
 */
@Override @SuppressWarnings(""String_Node_Str"") public O refTo(final O obj){
  updateAccess(obj.memPool,obj.index);
  return (O)this;
}","/** 
 * Make this   {@link PoolObject} refer to the same data as {@code obj}
 * @param obj A  {@link PoolObject}, usually of the same type as this one.
 */
@Override @SuppressWarnings(""String_Node_Str"") public O refTo(final O obj){
  updateAccess(((PoolObject<?,T>)obj).memPool,((PoolObject<?,T>)obj).index);
  return (O)this;
}",0.919093851132686
91014,"TrackSchemeEdge(final AbstractEdgePool<TrackSchemeEdge,TrackSchemeVertex,ByteMappedElement> pool){
  super(pool);
  setSelected(false);
}","TrackSchemeEdge(final AbstractEdgePool<TrackSchemeEdge,TrackSchemeVertex,ByteMappedElement> pool){
  super(pool);
}",0.9126984126984128
91015,"public BreadthFirstIterator(final V root,final Graph<V,E> graph){
  super(graph);
  this.queue=createVertexDeque();
  queue.offer(root);
  fetchNext();
}","public BreadthFirstIterator(final V root,final Graph<V,E> graph){
  super(graph);
  this.queue=createVertexDeque();
  queue.offer(root);
  fetchNext();
  visited.add(root);
}",0.9357798165137616
91016,"public DepthFirstIterator(final V root,final Graph<V,E> graph){
  super(graph);
  stack=createVertexStack();
  stack.push(root);
  fetchNext();
}","public DepthFirstIterator(final V root,final Graph<V,E> graph){
  super(graph);
  stack=createVertexStack();
  stack.push(root);
  fetchNext();
  visited.add(root);
}",0.932475884244373
91017,"@Override public List<O> subList(final int fromIndex,final int toIndex){
  return new PoolObjectList<O,T>(this,(TIntArrayList)indices.subList(fromIndex,fromIndex));
}","@Override public List<O> subList(final int fromIndex,final int toIndex){
  return new PoolObjectList<O,T>(this,(TIntArrayList)indices.subList(fromIndex,toIndex));
}",0.987878787878788
91018,"@Override public SpotList subList(final int fromIndex,final int toIndex){
  return new SpotList(this,getIndexCollection().subList(fromIndex,fromIndex));
}","@Override public SpotList subList(final int fromIndex,final int toIndex){
  return new SpotList(this,getIndexCollection().subList(fromIndex,toIndex));
}",0.9869281045751634
91019,"public ScreenEntities cropAndScale(final double minX,final double maxX,final double minY,final double maxY,final int screenWidth,final int screenHeight){
  swapPools();
  final TrackSchemeVertex v1=graph.vertexRef();
  final TrackSchemeVertex v2=graph.vertexRef();
  final ScreenVertex sv=screenVertexPool.createRef();
  final ScreenEdge se=screenEdgePool.createRef();
  final ArrayList<ScreenVertexRange> vertexRanges=new ArrayList<ScreenVertexRange>();
  final double yScale=(double)(screenHeight - 1) / (maxY - minY);
  final double xScale=(double)(screenWidth - 1) / (maxX - minX);
  final double allowedMinD=2.0 / xScale;
  final long t0=System.currentTimeMillis();
  final TIntIterator iter=timepoints.iterator();
  while (iter.hasNext()) {
    final int timepoint=iter.next();
    if (timepoint + 1 >= minY && timepoint - 1 <= maxY) {
      final int timepointStartScreenVertexIndex=screenVertices.size();
      final double y=(timepoint - minY) * yScale;
      final double prevY=(timepoint - 1 - minY) * yScale;
      final TrackSchemeVertexList vertexList=timepointToOrderedVertices.get(timepoint);
      int minIndex=vertexList.binarySearch(minX);
      minIndex--;
      if (minIndex < 0)       minIndex=0;
      int maxIndex=vertexList.binarySearch(maxX,minIndex,vertexList.size());
      if (maxIndex < vertexList.size() - 1)       maxIndex++;
      final double minLayoutX=vertexList.getMinLayoutXDistance();
      TIntArrayList denseRanges=vertexList.getDenseRanges(minIndex,maxIndex + 1,minLayoutX,allowedMinD,3,v1);
      if (denseRanges == null)       denseRanges=new TIntArrayList();
      denseRanges.add(maxIndex + 1);
      final TIntIterator riter=denseRanges.iterator();
      int nextRangeStart=riter.next();
      double prevX=Double.NEGATIVE_INFINITY;
      double minVertexScreenDist=yScale;
      for (int i=minIndex; i <= maxIndex; ++i) {
        if (i < nextRangeStart) {
          vertexList.get(i,v1);
          final int v1si=screenVertices.size();
          v1.setScreenVertexIndex(v1si);
          final int id=v1.getInternalPoolIndex();
          final double x=(v1.getLayoutX() - minX) * xScale;
          final boolean selected=false;
          screenVertexPool.create(sv).init(id,x,y,selected);
          screenVertices.add(sv);
          minVertexScreenDist=Math.min(minVertexScreenDist,x - prevX);
          prevX=x;
          for (          final TrackSchemeEdge edge : v1.incomingEdges()) {
            edge.getSource(v2);
            final int v2si=v2.getScreenVertexIndex();
            if (v2si > 0 && v2si < screenVertices.size() && screenVertices.get(v2si,sv).getId() == v2.getInternalPoolIndex()) {
              final int eid=edge.getInternalPoolIndex();
              final int sourceScreenVertexIndex=v2si;
              final int targetScreenVertexIndex=v1si;
              final boolean eselected=false;
              screenEdgePool.create(se).init(eid,sourceScreenVertexIndex,targetScreenVertexIndex,eselected);
              screenEdges.add(se);
            }
          }
        }
 else {
          final int rangeMinIndex=nextRangeStart;
          final int rangeMaxIndex=riter.next();
          nextRangeStart=riter.next();
          i=rangeMaxIndex;
          final double svMinX=(vertexList.get(rangeMinIndex,v1).getLayoutX() - minX) * xScale;
          final double svMaxX=(vertexList.get(rangeMaxIndex,v1).getLayoutX() - minX) * xScale;
          vertexRanges.add(new ScreenVertexRange(svMinX,svMaxX,prevY,y));
          minVertexScreenDist=0;
        }
      }
      for (int i=timepointStartScreenVertexIndex; i < screenVertices.size(); ++i) {
        screenVertices.get(i,sv).setVertexDist(minVertexScreenDist);
      }
    }
  }
  screenEdgePool.releaseRef(se);
  screenVertexPool.releaseRef(sv);
  graph.releaseRef(v1);
  graph.releaseRef(v2);
  return new ScreenEntities(screenVertices,screenEdges,vertexRanges);
}","public ScreenEntities cropAndScale(final double minX,final double maxX,final double minY,final double maxY,final int screenWidth,final int screenHeight){
  swapPools();
  final TrackSchemeVertex v1=graph.vertexRef();
  final TrackSchemeVertex v2=graph.vertexRef();
  final ScreenVertex sv=screenVertexPool.createRef();
  final ScreenEdge se=screenEdgePool.createRef();
  final ArrayList<ScreenVertexRange> vertexRanges=new ArrayList<ScreenVertexRange>();
  final double yScale=(double)(screenHeight - 1) / (maxY - minY);
  final double xScale=(double)(screenWidth - 1) / (maxX - minX);
  final double allowedMinD=2.0 / xScale;
  final long t0=System.currentTimeMillis();
  final TIntIterator iter=timepoints.iterator();
  while (iter.hasNext()) {
    final int timepoint=iter.next();
    if (timepoint + 1 >= minY && timepoint - 1 <= maxY) {
      final int timepointStartScreenVertexIndex=screenVertices.size();
      final double y=(timepoint - minY) * yScale;
      final double prevY=(timepoint - 1 - minY) * yScale;
      final TrackSchemeVertexList vertexList=timepointToOrderedVertices.get(timepoint);
      int minIndex=vertexList.binarySearch(minX);
      minIndex--;
      if (minIndex < 0)       minIndex=0;
      int maxIndex=vertexList.binarySearch(maxX,minIndex,vertexList.size());
      if (maxIndex < vertexList.size() - 1)       maxIndex++;
      final double minLayoutX=vertexList.getMinLayoutXDistance();
      TIntArrayList denseRanges=vertexList.getDenseRanges(minIndex,maxIndex + 1,minLayoutX,allowedMinD,3,v1);
      if (denseRanges == null)       denseRanges=new TIntArrayList();
      denseRanges.add(maxIndex + 1);
      final TIntIterator riter=denseRanges.iterator();
      int nextRangeStart=riter.next();
      double prevX=Double.NEGATIVE_INFINITY;
      double minVertexScreenDist=yScale;
      for (int i=minIndex; i <= maxIndex; ++i) {
        if (i < nextRangeStart) {
          vertexList.get(i,v1);
          final int v1si=screenVertices.size();
          v1.setScreenVertexIndex(v1si);
          final int id=v1.getInternalPoolIndex();
          final double x=(v1.getLayoutX() - minX) * xScale;
          final boolean selected=false;
          screenVertexPool.create(sv).init(id,x,y,selected);
          screenVertices.add(sv);
          minVertexScreenDist=Math.min(minVertexScreenDist,x - prevX);
          prevX=x;
          for (          final TrackSchemeEdge edge : v1.incomingEdges()) {
            edge.getSource(v2);
            final int v2si=v2.getScreenVertexIndex();
            if (v2si >= 0 && v2si < screenVertices.size() && screenVertices.get(v2si,sv).getId() == v2.getInternalPoolIndex()) {
              final int eid=edge.getInternalPoolIndex();
              final int sourceScreenVertexIndex=v2si;
              final int targetScreenVertexIndex=v1si;
              final boolean eselected=false;
              screenEdgePool.create(se).init(eid,sourceScreenVertexIndex,targetScreenVertexIndex,eselected);
              screenEdges.add(se);
            }
          }
        }
 else {
          final int rangeMinIndex=nextRangeStart;
          final int rangeMaxIndex=riter.next();
          nextRangeStart=riter.next();
          i=rangeMaxIndex;
          final double svMinX=(vertexList.get(rangeMinIndex,v1).getLayoutX() - minX) * xScale;
          final double svMaxX=(vertexList.get(rangeMaxIndex,v1).getLayoutX() - minX) * xScale;
          vertexRanges.add(new ScreenVertexRange(svMinX,svMaxX,prevY,y));
          minVertexScreenDist=0;
        }
      }
      for (int i=timepointStartScreenVertexIndex; i < screenVertices.size(); ++i) {
        screenVertices.get(i,sv).setVertexDist(minVertexScreenDist);
      }
    }
  }
  screenEdgePool.releaseRef(se);
  screenVertexPool.releaseRef(sv);
  graph.releaseRef(v1);
  graph.releaseRef(v2);
  return new ScreenEntities(screenVertices,screenEdges,vertexRanges);
}",0.9998713164328916
91020,"private int build(final Collection<O> objects){
  final KDTreeNode<O,T> n1=createRef();
  final KDTreeNode<O,T> n2=createRef();
  final KDTreeNode<O,T> n3=createRef();
  for (  final O obj : objects)   create(n1).init(obj);
  final int max=objects.size() - 1;
  final int r=makeNode(0,max,0,n1,n2,n3);
  releaseRef(n1);
  releaseRef(n2);
  releaseRef(n3);
  return r;
}","private void build(final Collection<O> objects){
  final KDTreeNode<O,T> n1=createRef();
  final KDTreeNode<O,T> n2=createRef();
  final KDTreeNode<O,T> n3=createRef();
  for (  final O obj : objects)   create(n1).init(obj);
  final int max=objects.size() - 1;
  final int r=makeNode(0,max,0,n1,n2,n3);
  releaseRef(n1);
  releaseRef(n2);
  releaseRef(n3);
  rootIndex=r;
}",0.9703504043126684
91021,"private KDTree(final int initialCapacity,final NodeFactory<O,T> nodeFactory,final int numDimensions,final Collection<O> objects,final Pool<O,?> objectPool){
  super(initialCapacity,nodeFactory);
  this.n=numDimensions;
  this.objectPool=objectPool;
  this.rootIndex=build(objects);
}","private KDTree(final int initialCapacity,final NodeFactory<O,T> nodeFactory,final int numDimensions,final Collection<O> objects,final Pool<O,?> objectPool){
  super(initialCapacity,nodeFactory);
  this.n=numDimensions;
  this.objectPool=objectPool;
}",0.9380863039399624
91022,"public static <O extends PoolObject<O,?> & RealLocalizable,T extends MappedElement>KDTree<O,T> kdtree(final Collection<O> objects,final Pool<O,?> objectPool,final MemPool.Factory<T> poolFactory){
  if (objects.isEmpty())   return null;
  return new NodeFactory<O,T>(objects,objectPool,poolFactory).kdtree;
}","public static <O extends PoolObject<O,?> & RealLocalizable,T extends MappedElement>KDTree<O,T> kdtree(final Collection<O> objects,final Pool<O,?> objectPool,final MemPool.Factory<T> poolFactory){
  if (objects.isEmpty())   return null;
  final KDTree<O,T> kdtree=new NodeFactory<O,T>(objects,objectPool,poolFactory).kdtree;
  kdtree.build(objects);
  return kdtree;
}",0.8902077151335311
91023,"public int create(){
  if (firstFreeIndex < 0)   return append();
 else {
    final int index=firstFreeIndex;
    updateAccess(dataAccess,firstFreeIndex);
    firstFreeIndex=dataAccess.getIndex(4);
    return index;
  }
}","public int create(){
  ++size;
  if (firstFreeIndex < 0)   return append();
 else {
    final int index=firstFreeIndex;
    updateAccess(dataAccess,firstFreeIndex);
    firstFreeIndex=dataAccess.getIndex(4);
    return index;
  }
}",0.9778761061946902
91024,"public void free(final int index){
  if (index >= 0 && index < allocatedSize) {
    updateAccess(dataAccess,index);
    final boolean isFree=dataAccess.getInt(0) == FREE_ELEMENT_MAGIC_NUMBER;
    if (!isFree) {
      dataAccess.putIndex(FREE_ELEMENT_MAGIC_NUMBER,0);
      dataAccess.putIndex(firstFreeIndex,4);
      firstFreeIndex=index;
    }
  }
}","public void free(final int index){
  if (index >= 0 && index < allocatedSize) {
    updateAccess(dataAccess,index);
    final boolean isFree=dataAccess.getInt(0) == FREE_ELEMENT_MAGIC_NUMBER;
    if (!isFree) {
      --size;
      dataAccess.putIndex(FREE_ELEMENT_MAGIC_NUMBER,0);
      dataAccess.putIndex(firstFreeIndex,4);
      firstFreeIndex=index;
    }
  }
}",0.9804469273743016
91025,"@Override public String transform(TextNode node,String original){
  StringBuilder build=new StringBuilder();
  char[] ca=original.toCharArray();
  for (int i=0; i < ca.length; i++) {
switch (ca[i]) {
case '&':
      build.append(""String_Node_Str"");
    if (offsets != null) {
      offsets.add(node.begin + i,4);
    }
  break;
case '<':
build.append(""String_Node_Str"");
if (offsets != null) {
offsets.add(node.begin + i,3);
}
break;
case '>':
build.append(""String_Node_Str"");
if (offsets != null) {
offsets.add(node.begin + i,3);
}
break;
case '""':
build.append(""String_Node_Str"");
if (offsets != null) {
offsets.add(node.begin + i,5);
}
break;
case '\n':
case '\r':
String parentTagNode=node.parent != null ? node.parent.getName().toLowerCase() : null;
if (parentTagNode != null && attributes != null && attributes.containsKey(parentTagNode) && !attributes.get(parentTagNode).transformNewLines) {
break;
}
if (i + 1 < ca.length && ((ca[i] == '\n' && ca[i + 1] == '\r') || (ca[i] == '\r' && ca[i + 1] == '\n'))) {
if (offsets != null) {
offsets.add(node.begin + i,3);
}
i++;
}
 else if (offsets != null) {
offsets.add(node.begin + i,4);
}
build.append(""String_Node_Str"");
break;
default :
build.append(ca[i]);
}
}
return build.toString();
}","@Override public String transform(TextNode node,String original){
  StringBuilder build=new StringBuilder();
  char[] ca=original.toCharArray();
  for (int i=0; i < ca.length; i++) {
switch (ca[i]) {
case '&':
      build.append(""String_Node_Str"");
    if (offsets != null) {
      offsets.add(node.begin + i,4);
    }
  break;
case '<':
build.append(""String_Node_Str"");
if (offsets != null) {
offsets.add(node.begin + i,3);
}
break;
case '>':
build.append(""String_Node_Str"");
if (offsets != null) {
offsets.add(node.begin + i,3);
}
break;
case '""':
build.append(""String_Node_Str"");
if (offsets != null) {
offsets.add(node.begin + i,5);
}
break;
case '\n':
case '\r':
String parentTagNode=node.parent != null ? node.parent.getName().toLowerCase() : null;
if (parentTagNode != null && attributes != null && attributes.containsKey(parentTagNode) && !attributes.get(parentTagNode).transformNewLines) {
build.append(ca[i]);
break;
}
if (i + 1 < ca.length && ((ca[i] == '\n' && ca[i + 1] == '\r') || (ca[i] == '\r' && ca[i + 1] == '\n'))) {
if (offsets != null) {
offsets.add(node.begin + i,3);
}
i++;
}
 else if (offsets != null) {
offsets.add(node.begin + i,4);
}
build.append(""String_Node_Str"");
break;
default :
build.append(ca[i]);
}
}
return build.toString();
}",0.9916100679184978
91026,"@Override public String transform(TextNode node,String original){
  StringBuilder build=new StringBuilder();
  char[] ca=original.toCharArray();
  for (int i=0; i < ca.length; i++) {
switch (ca[i]) {
case '&':
      build.append(""String_Node_Str"");
    offsets.add(node.begin + i,4);
  break;
case '<':
build.append(""String_Node_Str"");
offsets.add(node.begin + i,3);
break;
case '>':
build.append(""String_Node_Str"");
offsets.add(node.begin + i,3);
break;
case '""':
build.append(""String_Node_Str"");
offsets.add(node.begin + i,5);
break;
case '\n':
case '\r':
if (i + i < ca.length && ((ca[i] == '\n' && ca[i + 1] == '\r') || (ca[i] == '\r' && ca[i + 1] == '\n'))) {
offsets.add(node.begin + i,3);
i++;
}
 else {
offsets.add(node.begin + i,4);
}
build.append(""String_Node_Str"");
break;
default :
build.append(ca[i]);
}
}
return build.toString();
}","@Override public String transform(TextNode node,String original){
  StringBuilder build=new StringBuilder();
  char[] ca=original.toCharArray();
  for (int i=0; i < ca.length; i++) {
switch (ca[i]) {
case '&':
      build.append(""String_Node_Str"");
    offsets.add(node.begin + i,4);
  break;
case '<':
build.append(""String_Node_Str"");
offsets.add(node.begin + i,3);
break;
case '>':
build.append(""String_Node_Str"");
offsets.add(node.begin + i,3);
break;
case '""':
build.append(""String_Node_Str"");
offsets.add(node.begin + i,5);
break;
case '\n':
case '\r':
if (i + 1 < ca.length && ((ca[i] == '\n' && ca[i + 1] == '\r') || (ca[i] == '\r' && ca[i + 1] == '\n'))) {
offsets.add(node.begin + i,3);
i++;
}
 else {
offsets.add(node.begin + i,4);
}
build.append(""String_Node_Str"");
break;
default :
build.append(ca[i]);
}
}
return build.toString();
}",0.9988165680473372
91027,"/** 
 * Activates 
 */
@Override protected void activate(ComponentContext ctx) throws IOException, ConfigurationException {
  super.activate(ctx);
  config=new SphinxConfig();
  ciFactory=ci;
  String acoustic_bundleSymbolicName=null;
  config.CUSTOM_MODEL_AVAILABLE=true;
  Object value=ctx.getProperties().get(ACOUSTIC_MODEL_PROVIDER_BUNDLE_NAME);
  if (value != null && !value.toString().isEmpty()) {
    acoustic_bundleSymbolicName=value.toString();
    config.setBundleSymbolicName(value.toString());
  }
  value=ctx.getProperties().get(DICTIONARY_MODEL);
  if (value != null && !value.toString().isEmpty()) {
    modelFileListener=new NamedModelFileListener<DictionaryModel>();
    dataFileTracker.add(modelFileListener,value.toString(),null);
  }
 else {
    throw new ConfigurationException(DICTIONARY_MODEL,""String_Node_Str"" + getClass().getSimpleName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  value=ctx.getProperties().get(LANGUAGE_MODEL);
  if (value != null && !value.toString().isEmpty()) {
    modelFileListener=new NamedModelFileListener<LanguageModel>();
    dataFileTracker.add(modelFileListener,value.toString(),null);
  }
 else {
    throw new ConfigurationException(DICTIONARY_MODEL,""String_Node_Str"" + getClass().getSimpleName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  String acousticResource[]={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (  String resourceName : acousticResource) {
    dataFileTracker.add(modelFileListener,acoustic_bundleSymbolicName,resourceName,null);
  }
}","/** 
 * Activates 
 * @throws java.io.IOException
 * @throws org.osgi.service.cm.ConfigurationException
 */
@Override protected void activate(ComponentContext ctx) throws IOException, ConfigurationException {
  super.activate(ctx);
  config=new SphinxConfig();
  ciFactory=ci;
  String bundleSymbolicName=null;
  config.CUSTOM_MODEL_AVAILABLE=true;
  Object value=ctx.getProperties().get(BUNDLE_SYMBOLIC_NAME);
  if (value != null && !value.toString().isEmpty()) {
    bundleSymbolicName=value.toString();
    config.setBundleSymbolicName(value.toString());
  }
  value=ctx.getProperties().get(DICTIONARY_MODEL);
  if (value != null && !value.toString().isEmpty()) {
    modelFileListener=new NamedModelFileListener<DictionaryModel>();
    dataFileTracker.add(modelFileListener,value.toString(),null);
  }
 else {
    throw new ConfigurationException(DICTIONARY_MODEL,""String_Node_Str"" + getClass().getSimpleName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  value=ctx.getProperties().get(LANGUAGE_MODEL);
  if (value != null && !value.toString().isEmpty()) {
    modelFileListener=new NamedModelFileListener<LanguageModel>();
    dataFileTracker.add(modelFileListener,value.toString(),null);
  }
 else {
    throw new ConfigurationException(DICTIONARY_MODEL,""String_Node_Str"" + getClass().getSimpleName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  String acousticResource[]={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (  String resourceName : acousticResource) {
    dataFileTracker.add(modelFileListener,bundleSymbolicName,resourceName,null);
  }
}",0.9283183428727174
91028,"/** 
 * ServiceProperties are currently only used for automatic ordering of the  execution of EnhancementEngines (e.g. by the WeightedChain implementation). ORDERING_PRE_PROCESSING: All values >= 200 are considered for engines that do some kind of preprocessing of the content. This includes e.g. the  conversion of media formats such as extracting the plain text from HTML,  keyframes from videos, wave form from mp3 ...; extracting metadata directly  encoded within the parsed content such as ID3 tags from MP3 or RDFa,  microdata provided by HTML content. use a value <   {@link ServiceProperties#ORDERING_PRE_PROCESSING}and >=   {@link ServiceProperties#ORDERING_PRE_PROCESSING}.
 */
public Map<String,Object> getServiceProperties(){
  return Collections.unmodifiableMap(Collections.singletonMap(ENHANCEMENT_ENGINE_ORDERING,(Object)ORDERING_PRE_PROCESSING));
}","/** 
 * ServiceProperties are currently only used for automatic ordering of the  execution of EnhancementEngines (e.g. by the WeightedChain implementation). ORDERING_PRE_PROCESSING: All values >= 200 are considered for engines that do some kind of preprocessing of the content. This includes e.g. the  conversion of media formats such as extracting the plain text from HTML,  keyframes from videos, wave form from mp3 ...; extracting metadata directly  encoded within the parsed content such as ID3 tags from MP3 or RDFa,  microdata provided by HTML content. use a value <   {@link ServiceProperties#ORDERING_PRE_PROCESSING}and >=   {@link ServiceProperties#ORDERING_PRE_PROCESSING}.
 */
@Override public Map<String,Object> getServiceProperties(){
  return Collections.unmodifiableMap(Collections.singletonMap(ENHANCEMENT_ENGINE_ORDERING,(Object)ORDERING_PRE_PROCESSING));
}",0.9942462600690448
91029,"protected void deactivate(ComponentContext ctx){
  dataFileTracker.removeAll(modelFileListener);
  config=null;
  super.deactivate(ctx);
}","@Override protected void deactivate(ComponentContext ctx){
  dataFileTracker.removeAll(modelFileListener);
  config=null;
  super.deactivate(ctx);
}",0.965034965034965
91030,"protected boolean initConfig(ModelProvider MPi){
  System.out.println(""String_Node_Str"");
  this.MPi=MPi;
  lmodel=new LanguageModel();
  amodel=new AcousticModel();
  dmodel=new DictionaryModel();
  if (!CUSTOM_MODEL_AVAILABLE) {
    System.out.println(""String_Node_Str"");
    amodel=MPi.getDefaultModel(getDefaultLanguage(),amodel);
    System.out.println(""String_Node_Str"");
    dmodel=MPi.getDefaultModel(getDefaultLanguage(),dmodel);
    System.out.println(""String_Node_Str"");
    lmodel=MPi.getDefaultModel(getDefaultLanguage(),lmodel);
  }
 else {
    lmodel=this.MPi.getModel(languageModelFile,lmodel,null);
    amodel=this.MPi.getModel(acousticModelFile,amodel,bundleSymbolicName);
    dmodel=this.MPi.getModel(dictionaryModelFile,dmodel,null);
  }
  if (amodel == null || dmodel == null || lmodel == null)   return false;
  return true;
}","protected boolean initConfig(ModelProvider MPi){
  System.out.println(""String_Node_Str"");
  this.MPi=MPi;
  lmodel=new LanguageModel();
  amodel=new AcousticModel();
  dmodel=new DictionaryModel();
  if (!CUSTOM_MODEL_AVAILABLE) {
    System.out.println(""String_Node_Str"");
    amodel=MPi.getDefaultModel(getDefaultLanguage(),amodel);
    System.out.println(""String_Node_Str"");
    dmodel=MPi.getDefaultModel(getDefaultLanguage(),dmodel);
    System.out.println(""String_Node_Str"");
    lmodel=MPi.getDefaultModel(getDefaultLanguage(),lmodel);
  }
 else {
    lmodel=this.MPi.getModel(languageModelFile,lmodel,bundleSymbolicName);
    amodel=this.MPi.getModel(acousticModelFile,amodel,bundleSymbolicName);
    dmodel=this.MPi.getModel(dictionaryModelFile,dmodel,bundleSymbolicName);
  }
  return amodel != null && dmodel != null && lmodel != null;
}",0.8903301886792453
91031,"public SphinxConfig(){
}","public SphinxConfig(){
  this.dictionaryModelFile=new HashSet<String>();
  this.languageModelFile=new HashSet<String>();
  this.acousticModelFile=new HashSet<String>();
}",0.2474226804123711
91032,"/** 
 * Responds the content of the app.
 */
@Override public void handleGET(CoapExchange request){
  try {
    File file=new File(getInstalledPath());
    @SuppressWarnings(""String_Node_Str"") Scanner scanner=new Scanner(file).useDelimiter(""String_Node_Str"");
    String content=scanner.next();
    scanner.close();
    request.respond(ResponseCode.CONTENT,content);
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
    request.respond(ResponseCode.INTERNAL_SERVER_ERROR);
  }
}","/** 
 * Responds the content of the app.
 */
@Override public void handleGET(CoapExchange request){
  try {
    File file=new File(getInstalledPath());
    @SuppressWarnings(""String_Node_Str"") Scanner scanner=new Scanner(file).useDelimiter(""String_Node_Str"");
    String content=scanner.next();
    scanner.close();
    request.respond(ResponseCode.CONTENT,content);
  }
 catch (  FileNotFoundException|NoSuchElementException e) {
    e.printStackTrace();
    request.respond(ResponseCode.INTERNAL_SERVER_ERROR);
  }
}",0.9772951628825272
91033,"private void callJSCallback(CoapExchange exchange,CoapCallback callback){
  try {
    callback.call(new JavaScriptCoapExchange(exchange),exchange.advanced().getRequest());
  }
 catch (  NashornException e) {
    System.err.println(""String_Node_Str"" + e.getFileName() + ""String_Node_Str""+ e.getLineNumber()+ ""String_Node_Str""+ e.getMessage());
    throw e;
  }
}","private void callJSCallback(CoapExchange exchange,CoapCallback callback){
  try {
    callback.call(new JavaScriptCoapExchange(exchange),exchange.advanced().getRequest());
  }
 catch (  NashornException e) {
    exchange.respond(CoAP.ResponseCode.INTERNAL_SERVER_ERROR,e.getMessage());
    System.err.println(""String_Node_Str"" + e.getFileName() + ""String_Node_Str""+ e.getLineNumber()+ ""String_Node_Str""+ e.getMessage());
    throw e;
  }
}",0.9025
91034,"/** 
 * Executes the given JavaScript code.
 * @param code the JavaScript code
 */
public void execute(String code){
  dependencies.clear();
  moduleCache.clear();
  String name=getName();
  code=code;
  ScriptEngineManager scriptEngineManager=new ScriptEngineManager();
  classloader=new DynamicClassloader(Thread.currentThread().getContextClassLoader());
  engine=(NashornScriptEngine)new NashornScriptEngineFactory().getScriptEngine(classloader);
  try {
    context=new AppContext();
    context.setBindings(engine.createBindings(),ScriptContext.ENGINE_SCOPE);
    Bindings engineScope=context.getBindings(ScriptContext.ENGINE_SCOPE);
    jsaccess=new JavaScriptAccess();
    engineScope.put(""String_Node_Str"",jsaccess);
    engineScope.put(""String_Node_Str"",(IRequire)moduleName -> jsaccess.require(moduleName));
    engineScope.put(""String_Node_Str"",(IExtend)(a,b) -> jsaccess.extend(a,b));
    engineScope.put(""String_Node_Str"",(ISuperCall)(a,b,c) -> jsaccess.superCall(a,b,c));
    String bootstrap=Utils.readFile(getClass().getClassLoader().getResource(""String_Node_Str""));
    code=bootstrap.replaceAll(""String_Node_Str"",""String_Node_Str"").replace('\n',' ') + ""String_Node_Str"" + code+ ""String_Node_Str"";
    engine.eval(code,context);
  }
 catch (  ScriptException e) {
    e.printStackTrace();
    Throwable cause=e.getCause();
    if (cause != null && cause instanceof InterruptedException) {
      System.out.println(""String_Node_Str"" + getName() + ""String_Node_Str"");
    }
 else {
      System.err.println(""String_Node_Str"" + e.getFileName() + ""String_Node_Str""+ e.getLineNumber()+ ""String_Node_Str""+ e.getMessage());
    }
  }
}","/** 
 * Executes the given JavaScript code.
 * @param code the JavaScript code
 */
public void execute(String code){
  dependencies.clear();
  moduleCache.clear();
  String name=getName();
  code=code;
  ScriptEngineManager scriptEngineManager=new ScriptEngineManager();
  classloader=new DynamicClassloader(Thread.currentThread().getContextClassLoader());
  engine=(NashornScriptEngine)new NashornScriptEngineFactory().getScriptEngine(classloader);
  try {
    context=new AppContext();
    context.setBindings(engine.createBindings(),ScriptContext.ENGINE_SCOPE);
    Bindings engineScope=context.getBindings(ScriptContext.ENGINE_SCOPE);
    jsaccess=new JavaScriptAccess();
    engineScope.put(""String_Node_Str"",jsaccess);
    engineScope.put(""String_Node_Str"",(IRequire)moduleName -> jsaccess.require(moduleName));
    engineScope.put(""String_Node_Str"",(IExtend)(a,b) -> jsaccess.extend(a,b));
    engineScope.put(""String_Node_Str"",(ISuperCall)(a,b,c) -> jsaccess.superCall(a,b,c));
    String bootstrap=Utils.readFile(getClass().getClassLoader().getResource(""String_Node_Str""));
    code=bootstrap.replaceAll(""String_Node_Str"",""String_Node_Str"").replace('\n',' ') + ""String_Node_Str"" + code+ ""String_Node_Str"";
    engine.eval(code,context);
  }
 catch (  RuntimeException|ScriptException e) {
    Throwable cause=e.getCause();
    if (cause != null && cause instanceof InterruptedException) {
      System.out.println(""String_Node_Str"" + getName() + ""String_Node_Str"");
    }
 else {
      e.printStackTrace();
      if (e instanceof ScriptException) {
        System.err.println(""String_Node_Str"" + ((ScriptException)e).getFileName() + ""String_Node_Str""+ ((ScriptException)e).getLineNumber()+ ""String_Node_Str""+ e.getMessage());
      }
    }
  }
}",0.8655486907914093
91035,"/** 
 * Deletes the file with the code of this app.
 * @throws IOException if file does not exist or is not deletable.
 */
private void deleteLib() throws IOException {
  String apppath=getInstalledPath();
  File file=new File(apppath);
  if (!file.exists())   throw new IOException(""String_Node_Str"" + apppath + ""String_Node_Str""+ name+ ""String_Node_Str"");
  if (!file.canWrite())   throw new IOException(""String_Node_Str"" + apppath + ""String_Node_Str""+ name+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + apppath);
  boolean success=file.delete();
  if (!success)   throw new IOException(""String_Node_Str"" + apppath + ""String_Node_Str""+ name+ ""String_Node_Str"");
}","/** 
 * Deletes the file with the code of this lib.
 * @throws IOException if file does not exist or is not deletable.
 */
private void deleteLib() throws IOException {
  String apppath=getInstalledPath();
  File file=new File(apppath);
  if (!file.exists())   throw new IOException(""String_Node_Str"" + apppath + ""String_Node_Str""+ name+ ""String_Node_Str"");
  if (!file.canWrite())   throw new IOException(""String_Node_Str"" + apppath + ""String_Node_Str""+ name+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + apppath);
  boolean success=file.delete();
  if (!success)   throw new IOException(""String_Node_Str"" + apppath + ""String_Node_Str""+ name+ ""String_Node_Str"");
}",0.9955947136563876
91036,"/** 
 * Deletes this app and all instances of it from the server. The AppManager stops the execution of all instances of this app and removes all config files from their parent resources and from the disk.
 */
@Override public void handleDELETE(CoapExchange request){
  try {
    manager.deleteApps(name);
    deleteLib();
    delete();
    request.respond(CoAP.ResponseCode.DELETED);
  }
 catch (  IOException e) {
    e.printStackTrace();
    request.respond(CoAP.ResponseCode.INTERNAL_SERVER_ERROR,e.getMessage());
  }
}","/** 
 * Deletes this app and all instances of it from the server. The AppManager stops the execution of all instances of this app and removes all config files from their parent resources and from the disk.
 */
@Override public void handleDELETE(CoapExchange request){
  try {
    deleteLib();
    delete();
    request.respond(CoAP.ResponseCode.DELETED);
  }
 catch (  IOException e) {
    e.printStackTrace();
    request.respond(CoAP.ResponseCode.INTERNAL_SERVER_ERROR,e.getMessage());
  }
}",0.970472440944882
91037,"private void prepareServerConfiguration() throws IOException {
  appFolder=new File(""String_Node_Str"");
  cleanupConfiguration();
  appFolder.mkdir();
  appFolder.deleteOnExit();
  new File(""String_Node_Str"").mkdir();
  new File(""String_Node_Str"").mkdir();
  new File(""String_Node_Str"").mkdir();
{
    PrintWriter writer=new PrintWriter(""String_Node_Str"",""String_Node_Str"");
    writer.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    writer.close();
  }
}","private void prepareServerConfiguration() throws IOException {
  appFolder=new File(""String_Node_Str"");
  cleanupConfiguration();
  appFolder.mkdir();
  appFolder.deleteOnExit();
  new File(""String_Node_Str"" + File.separator + ""String_Node_Str"").mkdir();
  new File(""String_Node_Str"" + File.separator + ""String_Node_Str"").mkdir();
  new File(""String_Node_Str"" + File.separator + ""String_Node_Str"").mkdir();
{
    PrintWriter writer=new PrintWriter(""String_Node_Str"",""String_Node_Str"");
    writer.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    writer.close();
  }
}",0.9253530598520512
91038,"/** 
 * Adds a config, creates a correspondig resource and adds it as subresource.
 * @param appconfig the configuration
 */
public void addConfig(AppConfig appconfig){
  String identifier=appconfig.getName();
  appconfigs.add(appconfig);
  Resource res=appconfig.createConfigResource(identifier);
  add(res);
}","/** 
 * Adds a config, creates a correspondig resource and adds it as subresource.
 * @param appconfig the configuration
 */
public void addConfig(final AppConfig appconfig){
  String identifier=appconfig.getName();
  appconfigs.add(appconfig);
  final Resource res=appconfig.createConfigResource(identifier);
  appconfig.getObservable().addObserver(new Observer(){
    public void update(    Observable o,    Object arg){
      if (!(arg instanceof AppConfig.ConfigChangeSet))       return;
      AbstractConfig.ConfigChangeSet set=(AbstractConfig.ConfigChangeSet)arg;
      if (set.contains(AppConfig.AVAILABILITY)) {
        if (appconfig.getProperty(AppConfig.AVAILABILITY).equals(AppConfig.UNABAILABLE)) {
          appconfigs.remove(appconfig);
          AppConfigsResource.this.delete(res);
        }
      }
    }
  }
);
  add(res);
}",0.5273200346921075
91039,"@Override @Transactional(readOnly=true) public Optional<MethodDescriptor> getMethodById(@NotNull Long methodId){
  GetMethodsRequest request=GetMethodsRequest.defaults().toBuilder().maxResults(1).suppressUntrackedMethods(false).suppressSyntheticMethods(false).build();
  MethodDescriptorRowCallbackHandler rowCallbackHandler=new MethodDescriptorRowCallbackHandler(""String_Node_Str"");
  jdbcTemplate.query(rowCallbackHandler.getSelectStatement(),rowCallbackHandler,customerIdProvider.getCustomerId(),methodId);
  return rowCallbackHandler.getResult(request).stream().findFirst();
}","@Override @Transactional(readOnly=true) public Optional<MethodDescriptor> getMethodById(@NotNull Long methodId){
  GetMethodsRequest request=GetMethodsRequest.defaults().toBuilder().maxResults(1).suppressUntrackedMethods(false).suppressSyntheticMethods(false).minCollectedDays(0).build();
  MethodDescriptorRowCallbackHandler rowCallbackHandler=new MethodDescriptorRowCallbackHandler(""String_Node_Str"");
  jdbcTemplate.query(rowCallbackHandler.getSelectStatement(),rowCallbackHandler,customerIdProvider.getCustomerId(),methodId);
  return rowCallbackHandler.getResult(request).stream().findFirst();
}",0.9830508474576272
91040,"@Override public void onApplicationEvent(ApplicationReadyEvent event){
  sendNotification(String.format(""String_Node_Str"",settings.getApplicationName(),settings.getDisplayVersion(),settings.getDnsCname()),Channel.BUILDS);
}","@Override public void onApplicationEvent(ApplicationReadyEvent event){
  doSend(String.format(""String_Node_Str"",settings.getApplicationName(),settings.getDisplayVersion(),settings.getDnsCname()),Channel.BUILDS);
}",0.9495412844036696
91041,"@PreDestroy public void notifyShutdown(){
  sendNotification(String.format(""String_Node_Str"",settings.getApplicationName(),settings.getDisplayVersion(),settings.getDnsCname()),Channel.BUILDS);
}","@PreDestroy public void notifyShutdown(){
  doSend(String.format(""String_Node_Str"",settings.getApplicationName(),settings.getDisplayVersion(),settings.getDnsCname()),Channel.BUILDS);
}",0.9576719576719576
91042,"@Override @Async public void sendNotification(String text,Channel channel){
  String ch=channel.name().toLowerCase().replace(""String_Node_Str"",""String_Node_Str"");
  doSendPayload(Payload.builder().text(text).channel(ch).build());
}","@Override @Async public void sendNotification(String text,Channel channel){
  doSend(text,channel);
}",0.5481927710843374
91043,"@Override @Transactional public CustomerData registerAgentDataPublication(CustomerData customerData,Instant publishedAt){
  CustomerData result=customerData;
  if (customerData.getPricePlan().getMaxCollectionPeriodDays() > 0 && customerData.getTrialPeriodEndsAt() == null) {
    result=customerData.toBuilder().collectionStartedAt(publishedAt).trialPeriodEndsAt(publishedAt.plus(customerData.getPricePlan().getMaxCollectionPeriodDays(),DAYS)).build();
    int updated=jdbcTemplate.update(""String_Node_Str"" + ""String_Node_Str"",Timestamp.from(Instant.now()),Timestamp.from(result.getCollectionStartedAt()),Timestamp.from(result.getTrialPeriodEndsAt()),customerData.getCustomerId());
    if (updated <= 0) {
      logger.warn(""String_Node_Str"",result);
    }
 else {
      logger.info(""String_Node_Str"",result);
    }
  }
  return result;
}","@Override @Transactional public CustomerData registerAgentDataPublication(CustomerData customerData,Instant publishedAt){
  final CustomerData result;
  if (customerData.getPricePlan().getMaxCollectionPeriodDays() > 0 && customerData.getTrialPeriodEndsAt() == null) {
    result=startTrialPeriod(customerData,publishedAt);
  }
 else   if (customerData.getCollectionStartedAt() == null) {
    result=recordCollectionStarted(customerData,publishedAt);
  }
 else {
    result=customerData;
  }
  return result;
}",0.4725111441307578
91044,"@Test @Sql(scripts=""String_Node_Str"") public void should_getStatus_correctly(){
  Instant now=Instant.now();
  Timestamp moreThanThreeDaysAgo=Timestamp.from(now.minus(3,DAYS).minus(5,HOURS));
  Timestamp tenMinutesAgo=Timestamp.from(now.minusSeconds(600));
  Timestamp oneMinuteAgo=Timestamp.from(now.minusSeconds(60));
  Timestamp inOneMinute=Timestamp.from(now.plusSeconds(60));
  Timestamp inOneMinutePlusPublishingInterval=Timestamp.from(now.plusSeconds(PricePlan.DEMO.getPublishIntervalSeconds() - 60));
  jdbcTemplate.update(""String_Node_Str"",tenMinutesAgo,inOneMinute,TRUE,""String_Node_Str"");
  jdbcTemplate.update(""String_Node_Str"",tenMinutesAgo,inOneMinute,FALSE,""String_Node_Str"");
  jdbcTemplate.update(""String_Node_Str"",tenMinutesAgo,oneMinuteAgo,TRUE,""String_Node_Str"");
  jdbcTemplate.update(""String_Node_Str"",tenMinutesAgo,oneMinuteAgo,FALSE,""String_Node_Str"");
  jdbcTemplate.update(""String_Node_Str"",tenMinutesAgo,oneMinuteAgo);
  jdbcTemplate.update(""String_Node_Str"",moreThanThreeDaysAgo,""String_Node_Str"");
  GetStatusResponse1 status=webappService.getStatus();
  assertThat(status.getPricePlan(),is(""String_Node_Str""));
  assertThat(status.getCollectionResolutionSeconds(),is(PricePlan.DEMO.getPublishIntervalSeconds()));
  assertThat(status.getMaxNumberOfAgents(),is(PricePlan.DEMO.getMaxNumberOfAgents()));
  assertThat(status.getMaxCollectionPeriodDays(),is(-1));
  assertThat(status.getMaxNumberOfMethods(),is(PricePlan.DEMO.getMaxMethods()));
  assertThat(status.getNumAgents(),is(4));
  assertThat(status.getNumLiveAgents(),is(2));
  assertThat(status.getNumLiveEnabledAgents(),is(1));
  assertThat(status.getAgents().get(0),is(AgentDescriptor1.builder().agentAlive(true).agentLiveAndEnabled(true).agentVersion(""String_Node_Str"").appName(""String_Node_Str"").appVersion(""String_Node_Str"").environment(""String_Node_Str"").excludePackages(""String_Node_Str"").id(1L).methodVisibility(""String_Node_Str"").nextPollExpectedAtMillis(cutMillis(inOneMinute)).nextPublicationExpectedAtMillis(cutMillis(inOneMinutePlusPublishingInterval)).packages(""String_Node_Str"").pollReceivedAtMillis(cutMillis(tenMinutesAgo)).publishedAtMillis(cutMillis(oneMinuteAgo)).startedAtMillis(cutMillis(moreThanThreeDaysAgo)).tags(""String_Node_Str"").build()));
  assertThat(status.getNumMethods(),is(10));
  assertThat(status.getCollectedSinceMillis(),is(cutMillis(moreThanThreeDaysAgo)));
  assertThat(status.getCollectedDays(),is(3));
  assertThat(status.getUsers(),hasSize(2));
}","@Test @Sql(scripts=""String_Node_Str"") public void should_getStatus_correctly(){
  Timestamps timestamps=new Timestamps().invoke();
  GetStatusResponse1 status=webappService.getStatus();
  assertThat(status.getPricePlan(),is(""String_Node_Str""));
  assertThat(status.getCollectionResolutionSeconds(),is(PricePlan.DEMO.getPublishIntervalSeconds()));
  assertThat(status.getMaxNumberOfAgents(),is(PricePlan.DEMO.getMaxNumberOfAgents()));
  assertThat(status.getMaxCollectionPeriodDays(),is(-1));
  assertThat(status.getMaxNumberOfMethods(),is(PricePlan.DEMO.getMaxMethods()));
  assertThat(status.getNumAgents(),is(4));
  assertThat(status.getNumLiveAgents(),is(2));
  assertThat(status.getNumLiveEnabledAgents(),is(1));
  assertThat(status.getAgents().get(0),is(AgentDescriptor1.builder().agentAlive(true).agentLiveAndEnabled(true).agentVersion(""String_Node_Str"").appName(""String_Node_Str"").appVersion(""String_Node_Str"").environment(""String_Node_Str"").excludePackages(""String_Node_Str"").id(1L).methodVisibility(""String_Node_Str"").nextPollExpectedAtMillis(cutMillis(timestamps.plusOneMinute)).nextPublicationExpectedAtMillis(cutMillis(Timestamp.from(timestamps.minusTwoMinutes.toInstant().plusSeconds(PricePlan.DEMO.getPublishIntervalSeconds())))).packages(""String_Node_Str"").pollReceivedAtMillis(cutMillis(timestamps.minusTenMinutes)).publishedAtMillis(cutMillis(timestamps.minusTwoMinutes)).startedAtMillis(cutMillis(timestamps.minusThreeDaysPlus)).tags(""String_Node_Str"").build()));
  assertThat(status.getNumMethods(),is(10));
  assertThat(status.getCollectedSinceMillis(),is(cutMillis(timestamps.minusThreeDaysPlus)));
  assertThat(status.getCollectedDays(),is(3));
  assertThat(status.getUsers(),hasSize(2));
}",0.6327359617682198
91045,"private boolean updateAgentState(CustomerData customerData,String jvmUuid){
}","private boolean updateAgentState(CustomerData customerData,String jvmUuid){
  long customerId=customerData.getCustomerId();
  Instant now=Instant.now();
  int updated=jdbcTemplate.update(""String_Node_Str"" + ""String_Node_Str"",customerId,Timestamp.from(now.minusSeconds(60)));
  if (updated > 0) {
    log.info(""String_Node_Str"",updated,customerData);
  }
  Timestamp nextExpectedPollTimestamp=Timestamp.from(now.plusSeconds(customerData.getPricePlan().getPollIntervalSeconds()));
  updated=jdbcTemplate.update(""String_Node_Str"",Timestamp.from(now),nextExpectedPollTimestamp,customerId,jvmUuid);
  if (updated == 0) {
    log.info(""String_Node_Str"",customerId,jvmUuid);
    jdbcTemplate.update(""String_Node_Str"",customerId,jvmUuid,Timestamp.from(now),nextExpectedPollTimestamp,Boolean.TRUE);
  }
 else {
    log.debug(""String_Node_Str"",customerId,jvmUuid);
  }
  Integer numOtherEnabledLiveAgents=jdbcTemplate.queryForObject(""String_Node_Str"" + ""String_Node_Str"",Integer.class,customerId,Timestamp.from(now.minusSeconds(10)),jvmUuid);
  String planName=customerData.getPlanName();
  int maxNumberOfAgents=customerData.getPricePlan().getMaxNumberOfAgents();
  boolean enabled=numOtherEnabledLiveAgents < maxNumberOfAgents;
  if (!enabled) {
    log.warn(""String_Node_Str"",customerId,numOtherEnabledLiveAgents,planName,maxNumberOfAgents);
  }
 else {
    log.debug(""String_Node_Str"",customerId,numOtherEnabledLiveAgents + 1,planName,maxNumberOfAgents);
  }
  jdbcTemplate.update(""String_Node_Str"",enabled,jvmUuid);
  return enabled;
}",0.0958307405102675
91046,"@Override public HerokuProvisionResponse provision(HerokuProvisionRequest request){
  log.debug(""String_Node_Str"",request);
  String licenseKey=customerService.addCustomer(CustomerService.AddCustomerRequest.builder().source(""String_Node_Str"").externalId(request.getUuid()).name(request.getHeroku_id()).plan(request.getPlan()).build());
  Map<String,String> config=new HashMap<>();
  config.put(""String_Node_Str"",settings.getHerokuCodekvastUrl());
  config.put(""String_Node_Str"",licenseKey);
  HerokuProvisionResponse response=HerokuProvisionResponse.builder().id(request.getUuid()).config(config).build();
  log.debug(""String_Node_Str"",response);
  return response;
}","@Override public HerokuProvisionResponse provision(HerokuProvisionRequest request){
  log.debug(""String_Node_Str"",request);
  String licenseKey=customerService.addCustomer(CustomerService.AddCustomerRequest.builder().source(CustomerService.Source.HEROKU).externalId(request.getUuid()).name(request.getHeroku_id()).plan(request.getPlan()).build());
  Map<String,String> config=new HashMap<>();
  config.put(""String_Node_Str"",settings.getHerokuCodekvastUrl());
  config.put(""String_Node_Str"",licenseKey);
  HerokuProvisionResponse response=HerokuProvisionResponse.builder().id(request.getUuid()).config(config).build();
  log.debug(""String_Node_Str"",response);
  return response;
}",0.9658246656760772
91047,"private String doHerokuSingleSignOn(String externalId,long timestampSeconds,String token,String email) throws AuthenticationException {
  String expectedToken=makeHerokuSsoToken(externalId,timestampSeconds);
  log.debug(""String_Node_Str"",externalId,token,timestampSeconds,expectedToken);
  long nowSeconds=System.currentTimeMillis() / 1000L;
  if (timestampSeconds > nowSeconds + 60) {
    throw new NonceExpiredException(""String_Node_Str"");
  }
  if (timestampSeconds < nowSeconds - 5 * 60) {
    throw new NonceExpiredException(""String_Node_Str"");
  }
  if (!expectedToken.equals(token)) {
    throw new BadCredentialsException(""String_Node_Str"");
  }
  CustomerData customerData=customerService.getCustomerDataByExternalId(externalId);
  customerService.registerLogin(customerData,email,""String_Node_Str"");
  return webappTokenProvider.createWebappToken(customerData.getCustomerId(),WebappCredentials.builder().externalId(externalId).customerName(customerData.getCustomerName()).email(email).source(customerData.getSource()).build());
}","private String doHerokuSingleSignOn(String externalId,long timestampSeconds,String token,String email) throws AuthenticationException {
  String expectedToken=makeHerokuSsoToken(externalId,timestampSeconds);
  log.debug(""String_Node_Str"",externalId,token,timestampSeconds,expectedToken);
  long nowSeconds=System.currentTimeMillis() / 1000L;
  if (timestampSeconds > nowSeconds + 60) {
    throw new NonceExpiredException(""String_Node_Str"");
  }
  if (timestampSeconds < nowSeconds - 5 * 60) {
    throw new NonceExpiredException(""String_Node_Str"");
  }
  if (!expectedToken.equals(token)) {
    throw new BadCredentialsException(""String_Node_Str"");
  }
  CustomerData customerData=customerService.getCustomerDataByExternalId(externalId);
  customerService.registerLogin(customerData,email,CustomerService.Source.HEROKU);
  return webappTokenProvider.createWebappToken(customerData.getCustomerId(),WebappCredentials.builder().externalId(externalId).customerName(customerData.getCustomerName()).email(email).source(customerData.getSource()).build());
}",0.9779904306220096
91048,"/** 
 * Save an uploaded   {@link CodeBasePublication} into the import area where it will be processed by another thread.
 * @param licenseKey          The agent's licenseKey.
 * @param codeBaseFingerprint Is the {@link CodeBaseFingerprint#getSha256()} value for the code base.
 * @param inputStream         The data input stream.
 * @return The resulting file or null of the code base was already uploaded.
 * @throws LicenseViolationException If invalid license or license violations
 */
File saveCodeBasePublication(String licenseKey,String codeBaseFingerprint,InputStream inputStream) throws LicenseViolationException, IOException ;","/** 
 * Save an uploaded   {@link CodeBasePublication} into the import area where it will be processed by another thread.
 * @param licenseKey          The agent's licenseKey.
 * @param codeBaseFingerprint Is the {@link CodeBaseFingerprint}'s SHA-256 value for the code base.
 * @param inputStream         The data input stream.
 * @return The resulting file or null of the code base was already uploaded.
 * @throws LicenseViolationException If invalid license or license violations
 */
File saveCodeBasePublication(String licenseKey,String codeBaseFingerprint,InputStream inputStream) throws LicenseViolationException, IOException ;",0.9874015748031496
91049,"/** 
 * Save an uploaded   {@link InvocationDataPublication} into the import area where it will be processed by another thread.
 * @param licenseKey          The agent's licenseKey.
 * @param codeBaseFingerprint Is the associated code base's {@link CodeBaseFingerprint#getSha256()} value.
 * @param inputStream         The data input stream.
 * @return The resulting file
 * @throws LicenseViolationException If invalid license or license violations
 */
File saveInvocationDataPublication(String licenseKey,String codeBaseFingerprint,InputStream inputStream) throws LicenseViolationException, IOException ;","/** 
 * Save an uploaded   {@link InvocationDataPublication} into the import area where it will be processed by another thread.
 * @param licenseKey          The agent's licenseKey.
 * @param codeBaseFingerprint Is the associated code base's {@link CodeBaseFingerprint}'s SHA-256 value.
 * @param inputStream         The data input stream.
 * @return The resulting file or null if the invocation data was already uploaded.
 * @throws LicenseViolationException If invalid license or license violations
 */
File saveInvocationDataPublication(String licenseKey,String codeBaseFingerprint,InputStream inputStream) throws LicenseViolationException, IOException ;",0.9453681710213776
91050,"@Test public void should_query_signature_correctly() throws Exception {
  ImportDescriptorBuilder builder=builder().now(now).app(""String_Node_Str"").app(""String_Node_Str"").method(testDataGenerator.getMethod(0)).method(testDataGenerator.getMethod(1)).method(testDataGenerator.getMethod(2)).jvm(createJvm(1,adjust(now,-10,DAYS),adjust(now,-1,DAYS),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).jvm(createJvm(2,adjust(now,-20,DAYS),adjust(now,-11,DAYS),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).jvm(createJvm(3,adjust(now,-30,DAYS),adjust(now,-29,DAYS),""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  for (long appId=1; appId <= 2; appId++) {
    for (long methodId=1; methodId <= 3; methodId++) {
      for (long jvmId=1; jvmId <= 3; jvmId++) {
        long hash=appId * 100 + methodId * 10 + jvmId;
        builder.invocation(Invocation.builder().localApplicationId(appId).localMethodId(methodId).localJvmId(jvmId).status(SignatureStatus.EXACT_MATCH).invocationCount(hash).invokedAtMillis(hash).build());
      }
    }
  }
  testDataGenerator.simulateFileImport(builder.build());
  List<MethodDescriptor> methods=queryService.findMethodsBySignature(null);
  assertThat(methods,hasSize(3));
  methods=queryService.findMethodsBySignature(testDataGenerator.getMethod(1).getSignature());
  assertThat(methods,hasSize(1));
  methods=queryService.findMethodsBySignature(testDataGenerator.getMethod(1).getSignature().substring(3,10));
  assertThat(methods,hasSize(1));
  MethodDescriptor md=methods.get(0);
  ApplicationId app1=ApplicationId.of(""String_Node_Str"",""String_Node_Str"");
  ApplicationId app2=ApplicationId.of(""String_Node_Str"",""String_Node_Str"");
  assertThat(md.getOccursInApplications().keySet(),contains(app1,app2));
  assertThat(toDaysAgo(md.getCollectedSinceMillis()),is(30));
  methods=queryService.findMethodsBySignature(""String_Node_Str"");
  assertThat(methods,hasSize(0));
}","@Test public void should_query_signature_correctly() throws Exception {
  ImportDescriptorBuilder builder=builder().now(now).app(""String_Node_Str"").app(""String_Node_Str"").app(""String_Node_Str"").method(testDataGenerator.getMethod(1)).method(testDataGenerator.getMethod(2)).method(testDataGenerator.getMethod(3)).jvm(createJvm(1,adjust(now,-10,DAYS),adjust(now,-1,DAYS),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).jvm(createJvm(2,adjust(now,-30,DAYS),adjust(now,-29,DAYS),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).jvm(createJvm(3,adjust(now,-20,DAYS),adjust(now,-19,DAYS),""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  for (long appId=1; appId <= 3; appId++) {
    for (long methodId=1; methodId <= 3; methodId++) {
      for (long jvmId=1; jvmId <= 3; jvmId++) {
        long hash=appId * 100 + methodId * 10 + jvmId;
        builder.invocation(Invocation.builder().localApplicationId(appId).localMethodId(methodId).localJvmId(jvmId).status(SignatureStatus.EXACT_MATCH).invocationCount(hash).invokedAtMillis(hash).build());
      }
    }
  }
  testDataGenerator.simulateFileImport(builder.build());
  List<MethodDescriptor> methods=queryService.findMethodsBySignature(null);
  assertThat(methods,hasSize(3));
  methods=queryService.findMethodsBySignature(testDataGenerator.getMethod(1).getSignature());
  assertThat(methods,hasSize(1));
  methods=queryService.findMethodsBySignature(testDataGenerator.getMethod(1).getSignature().substring(3,10));
  assertThat(methods,hasSize(1));
  MethodDescriptor md=methods.get(0);
  assertThat(toDaysAgo(md.getCollectedSinceMillis()),is(30));
  assertThat(toDaysAgo(md.getCollectedToMillis()),is(1));
  methods=queryService.findMethodsBySignature(""String_Node_Str"");
  assertThat(methods,hasSize(0));
}",0.9123850730124392
91051,"@Inject public TestDataGenerator(ImportDAO importDao){
  this.importDao=importDao;
  Class[] testClasses={TestClass1.class,TestClass2.class};
  long localId=1;
  for (  Class testClass : testClasses) {
    for (    Method method : testClass.getDeclaredMethods()) {
      methods.add(new MethodDescriptor(localId,method));
      localId+=1;
    }
  }
}","@Inject public TestDataGenerator(ImportDAO importDao){
  this.importDao=importDao;
  Class[] testClasses={TestClass1.class,TestClass2.class};
  long localId=0;
  for (  Class testClass : testClasses) {
    for (    Method method : testClass.getDeclaredMethods()) {
      methods.add(new MethodDescriptor(localId,method));
      localId+=1;
    }
  }
}",0.9971509971509972
91052,"@Override public void processRow(ResultSet rs) throws SQLException {
  long id=rs.getLong(""String_Node_Str"");
  String signature=rs.getString(""String_Node_Str"");
  if (!queryState.isSameMethod(id)) {
    log.trace(""String_Node_Str"",id,signature);
    queryState.addTo(result);
    queryState=new QueryState(id);
  }
  queryState.countRow();
  long startedAt=rs.getTimestamp(""String_Node_Str"").getTime();
  long dumpedAt=rs.getTimestamp(""String_Node_Str"").getTime();
  long invokedAtMillis=rs.getLong(""String_Node_Str"");
  MethodDescriptor.MethodDescriptorBuilder builder=queryState.getBuilder();
  builder.occursInApplication(ApplicationId.of(rs.getString(""String_Node_Str""),rs.getString(""String_Node_Str"")),ApplicationDescriptor.builder().startedAtMillis(startedAt).dumpedAtMillis(dumpedAt).invokedAtMillis(invokedAtMillis).status(SignatureStatus.valueOf(rs.getString(""String_Node_Str""))).build()).collectedInEnvironment(rs.getString(""String_Node_Str""),EnvironmentDescriptor.builder().hostName(rs.getString(""String_Node_Str"")).tags(splitOnCommaOrSemicolon(rs.getString(""String_Node_Str""))).collectedSinceMillis(startedAt).collectedToMillis(dumpedAt).invokedAtMillis(invokedAtMillis).build()).declaringType(rs.getString(""String_Node_Str"")).modifiers(rs.getString(""String_Node_Str"")).packageName(rs.getString(""String_Node_Str"")).signature(signature).visibility(rs.getString(""String_Node_Str""));
}","@Override public void processRow(ResultSet rs) throws SQLException {
  long id=rs.getLong(""String_Node_Str"");
  String signature=rs.getString(""String_Node_Str"");
  if (!queryState.isSameMethod(id)) {
    log.trace(""String_Node_Str"",id,signature);
    queryState.addTo(result);
    queryState=new QueryState(id);
  }
  queryState.countRow();
  long startedAt=rs.getTimestamp(""String_Node_Str"").getTime();
  long dumpedAt=rs.getTimestamp(""String_Node_Str"").getTime();
  long invokedAtMillis=rs.getLong(""String_Node_Str"");
  MethodDescriptor.MethodDescriptorBuilder builder=queryState.getBuilder();
  String appName=rs.getString(""String_Node_Str"");
  String appVersion=rs.getString(""String_Node_Str"");
  queryState.saveApplication(ApplicationDescriptor.builder().name(appName).version(appVersion).startedAtMillis(startedAt).dumpedAtMillis(dumpedAt).invokedAtMillis(invokedAtMillis).status(SignatureStatus.valueOf(rs.getString(""String_Node_Str""))).build());
  queryState.saveEnvironment(EnvironmentDescriptor.builder().name(rs.getString(""String_Node_Str"")).hostName(rs.getString(""String_Node_Str"")).tags(splitOnCommaOrSemicolon(rs.getString(""String_Node_Str""))).collectedSinceMillis(startedAt).collectedToMillis(dumpedAt).invokedAtMillis(invokedAtMillis).build());
  builder.declaringType(rs.getString(""String_Node_Str"")).modifiers(rs.getString(""String_Node_Str"")).packageName(rs.getString(""String_Node_Str"")).signature(signature).visibility(rs.getString(""String_Node_Str""));
}",0.8493723849372385
91053,"private Collection<String> splitOnCommaOrSemicolon(String tags){
  String[] strings=tags.split(""String_Node_Str"");
  return Arrays.asList(strings);
}","private Set<String> splitOnCommaOrSemicolon(String tags){
  return new HashSet<>(Arrays.asList(tags.split(""String_Node_Str"")));
}",0.7050359712230215
91054,"void addTo(List<MethodDescriptor> result){
  if (builder != null) {
    log.debug(""String_Node_Str"",methodId,rows);
    result.add(builder.build());
  }
}","void addTo(List<MethodDescriptor> result){
  if (builder != null) {
    log.debug(""String_Node_Str"",methodId,rows);
    builder.occursInApplications(new TreeSet<>(applications.values()));
    builder.collectedInEnvironments(new TreeSet<>(environments.values()));
    result.add(builder.build());
  }
}",0.567032967032967
91055,"public static ApplicationId of(String name,String version){
  return new ApplicationId(name,version);
}","public static ApplicationId of(ApplicationDescriptor applicationDescriptor){
  return new ApplicationId(applicationDescriptor.getName(),applicationDescriptor.getVersion());
}",0.5776173285198556
91056,"/** 
 * Maximum value of occursInApplications.getDumpedAtMillis
 */
public long getCollectedToMillis(){
  return occursInApplications.values().stream().map(ApplicationDescriptor::getDumpedAtMillis).reduce(Math::max).orElse(0L);
}","/** 
 * Maximum value of occursInApplications.getDumpedAtMillis
 */
public long getCollectedToMillis(){
  return occursInApplications.stream().map(ApplicationDescriptor::getDumpedAtMillis).reduce(Math::max).orElse(0L);
}",0.979955456570156
91057,"/** 
 * Minimum value of occursInApplications.startedAtMillis
 */
public long getCollectedSinceMillis(){
  return occursInApplications.values().stream().map(ApplicationDescriptor::getStartedAtMillis).reduce(Math::min).orElse(0L);
}","/** 
 * Minimum value of occursInApplications.startedAtMillis
 */
public long getCollectedSinceMillis(){
  return occursInApplications.stream().map(ApplicationDescriptor::getStartedAtMillis).reduce(Math::min).orElse(0L);
}",0.9801324503311258
91058,"/** 
 * Maximum value of occursInApplications.invokedAtMillis;
 */
public long getLastInvokedAtMillis(){
  return occursInApplications.values().stream().map(ApplicationDescriptor::getInvokedAtMillis).reduce(Math::max).orElse(0L);
}","/** 
 * Maximum value of occursInApplications.invokedAtMillis;
 */
public long getLastInvokedAtMillis(){
  return occursInApplications.stream().map(ApplicationDescriptor::getInvokedAtMillis).reduce(Math::max).orElse(0L);
}",0.9801324503311258
91059,"@Override protected void doStoreNormalizedSignature(JvmState jvmState,String normalizedSignature,long invokedAtMillis,SignatureConfidence confidence){
  invocationsCollector.put(jvmState.getJvm().getJvmUuid(),jvmState.getJvm().getStartedAtMillis(),normalizedSignature,invokedAtMillis,confidence);
}","@Override protected void doStoreNormalizedSignature(JvmState jvmState,String normalizedSignature,long invokedAtMillis,SignatureStatus status){
  invocationsCollector.put(jvmState.getJvm().getJvmUuid(),jvmState.getJvm().getStartedAtMillis(),normalizedSignature,invokedAtMillis,status);
}",0.9143835616438356
91060,"@Transactional public void put(String jvmUuid,long jvmStartedAtMillis,String signature,long invokedAtMillis,SignatureConfidence confidence){
  if (jvmUuid == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (jvmStartedAtMillis <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (signature == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (invokedAtMillis < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (confidence == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (invokedAtMillis > 0 && invokedAtMillis < jvmStartedAtMillis) {
    log.debug(""String_Node_Str"",invokedAtMillis,jvmStartedAtMillis);
    return;
  }
  int count=jdbcTemplate.queryForObject(""String_Node_Str"" + ""String_Node_Str"",Integer.class,jvmUuid,signature,invokedAtMillis);
  if (count == 0) {
    long millisSinceJvmStart=invokedAtMillis == 0L ? 0L : invokedAtMillis - jvmStartedAtMillis;
    jdbcTemplate.update(""String_Node_Str"" + ""String_Node_Str"",jvmUuid,signature,invokedAtMillis,millisSinceJvmStart,confidence.ordinal());
  }
}","@Transactional public void put(String jvmUuid,long jvmStartedAtMillis,String signature,long invokedAtMillis,SignatureStatus status){
  if (jvmUuid == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (jvmStartedAtMillis <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (signature == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (invokedAtMillis < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (status == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (invokedAtMillis > 0 && invokedAtMillis < jvmStartedAtMillis) {
    log.debug(""String_Node_Str"",invokedAtMillis,jvmStartedAtMillis);
    return;
  }
  int count=jdbcTemplate.queryForObject(""String_Node_Str"" + ""String_Node_Str"",Integer.class,jvmUuid,signature,invokedAtMillis);
  if (count == 0) {
    long millisSinceJvmStart=invokedAtMillis == 0L ? 0L : invokedAtMillis - jvmStartedAtMillis;
    jdbcTemplate.update(""String_Node_Str"" + ""String_Node_Str"",jvmUuid,signature,invokedAtMillis,millisSinceJvmStart,status.ordinal());
  }
}",0.9708480565371024
91061,"/** 
 * Retrieve the number of collectors for a certain application name.
 */
int getNumCollectors(long organisationId,String appName);","/** 
 * Retrieve the number of collectors for a certain application name/version.
 */
int getNumCollectors(long organisationId,String appName,String appVersion);",0.9121621621621622
91062,"@Override public int getNumCollectors(long organisationId,String appName){
  return jdbcTemplate.queryForObject(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",Integer.class,organisationId,appName);
}","@Override public int getNumCollectors(long organisationId,String appName,String appVersion){
  return jdbcTemplate.queryForObject(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",Integer.class,organisationId,appName,appVersion);
}",0.9051383399209486
91063,"@Override @Transactional(rollbackFor=Exception.class) public void deleteCollector(String username,Collector collector) throws CodekvastException {
  long organisationId=userDAO.getOrganisationIdForUsername(username);
  Collection<AppId> appIds=agentDAO.getApplicationIds(organisationId,collector.getAppName(),collector.getAppVersion(),collector.getHostname());
  int rowsDeleted=agentDAO.deleteCollectors(organisationId,collector.getAppName(),collector.getAppVersion(),collector.getHostname());
  int numCollectors=agentDAO.getNumCollectors(organisationId,collector.getAppName());
  if (numCollectors == 0) {
    log.debug(""String_Node_Str"",collector.getAppName());
    rowsDeleted+=agentDAO.deleteApplication(organisationId,collector.getAppName());
  }
 else {
    statisticsService.recalculateApplicationStatistics(organisationId,Collections.singletonList(collector.getAppName()));
  }
  log.info(""String_Node_Str"",collector,rowsDeleted);
  eventBus.post(agentDAO.createWebSocketMessage(organisationId));
}","@Override @Transactional(rollbackFor=Exception.class) public void deleteCollector(String username,Collector collector) throws CodekvastException {
  long organisationId=userDAO.getOrganisationIdForUsername(username);
  Collection<AppId> appIds=agentDAO.getApplicationIds(organisationId,collector.getAppName(),collector.getAppVersion(),collector.getHostname());
  int rowsDeleted=agentDAO.deleteCollectors(organisationId,collector.getAppName(),collector.getAppVersion(),collector.getHostname());
  int numCollectorsByName=agentDAO.getNumCollectors(organisationId,collector.getAppName());
  int numCollectorsByNameAndVersion=agentDAO.getNumCollectors(organisationId,collector.getAppName(),collector.getAppVersion());
  if (numCollectorsByName == 0) {
    log.debug(""String_Node_Str"",collector.getAppName());
    rowsDeleted+=agentDAO.deleteApplication(organisationId,collector.getAppName());
  }
 else   if (numCollectorsByNameAndVersion > 0) {
    statisticsService.recalculateApplicationStatistics(organisationId,Collections.singletonList(collector.getAppName()));
  }
 else   if (numCollectorsByNameAndVersion == 0) {
    rowsDeleted+=agentDAO.deleteApplicationStatistics(organisationId,collector.getAppName(),collector.getAppVersion());
  }
  log.info(""String_Node_Str"",collector,rowsDeleted);
  eventBus.post(agentDAO.createWebSocketMessage(organisationId));
}",0.8502741459299874
91064,"@Override @Transactional(readOnly=true,rollbackFor=Exception.class) public GetMethodUsageResponse getMethodUsage(String username,GetMethodUsageRequest request) throws CodekvastException {
  long startedAt=System.currentTimeMillis();
  ReportParameters params=ReportParameters.builder().organisationId(userDAO.getOrganisationIdForUsername(username)).applicationIds(agentDAO.getApplicationIds(userDAO.getOrganisationIdForUsername(username),request.getApplications()).stream().map(AppId::getAppId).collect(Collectors.toList())).jvmIds(reportDAO.getJvmIdsByAppVersions(userDAO.getOrganisationIdForUsername(username),request.getVersions())).bootstrapSeconds(request.getBootstrapSeconds()).usageCycleSeconds(request.getUsageCycleSeconds()).build();
  List<MethodUsageEntry> methods=new ArrayList<>();
  Map<MethodUsageScope,Integer> numMethodsByScope=new HashMap<>();
  for (  MethodUsageScope scope : request.getMethodUsageScopes()) {
    Collection<MethodUsageEntry> methodsForScope=reportDAO.getMethodsForScope(scope,params);
    numMethodsByScope.put(scope,methodsForScope.size());
    methods.addAll(methodsForScope);
  }
  GetMethodUsageResponse response=GetMethodUsageResponse.builder().request(request).numMethods(reportDAO.countMethods(userDAO.getOrganisationIdForUsername(username))).methods(methods.subList(0,Math.min(methods.size(),request.getMaxPreviewRows()))).numMethodsByScope(numMethodsByScope).build();
  log.debug(""String_Node_Str"",username,request,System.currentTimeMillis() - startedAt);
  return response;
}","@Override @Transactional(readOnly=true,rollbackFor=Exception.class) public GetMethodUsageResponse getMethodUsage(String username,GetMethodUsageRequest request) throws CodekvastException {
  log.debug(""String_Node_Str"",request,username);
  long startedAt=System.currentTimeMillis();
  ReportParameters params=ReportParameters.builder().organisationId(userDAO.getOrganisationIdForUsername(username)).applicationIds(agentDAO.getApplicationIds(userDAO.getOrganisationIdForUsername(username),request.getApplications()).stream().map(AppId::getAppId).collect(Collectors.toList())).jvmIds(reportDAO.getJvmIdsByAppVersions(userDAO.getOrganisationIdForUsername(username),request.getVersions())).bootstrapSeconds(request.getBootstrapSeconds()).usageCycleSeconds(request.getUsageCycleSeconds()).build();
  List<MethodUsageEntry> methods=new ArrayList<>();
  Map<MethodUsageScope,Integer> numMethodsByScope=new HashMap<>();
  for (  MethodUsageScope scope : request.getMethodUsageScopes()) {
    Collection<MethodUsageEntry> methodsForScope=reportDAO.getMethodsForScope(scope,params);
    numMethodsByScope.put(scope,methodsForScope.size());
    methods.addAll(methodsForScope);
  }
  GetMethodUsageResponse response=GetMethodUsageResponse.builder().request(request).numMethods(reportDAO.countMethods(userDAO.getOrganisationIdForUsername(username))).methods(methods.subList(0,Math.min(methods.size(),request.getMaxPreviewRows()))).numMethodsByScope(numMethodsByScope).build();
  log.debug(""String_Node_Str"",username,request,System.currentTimeMillis() - startedAt);
  return response;
}",0.9841680129240712
91065,"/** 
 * Send the message to the currently logged in users that are affected by the message.
 */
@Subscribe public void onWebSocketMessage(WebSocketMessage message){
  message.getUsernames().stream().filter(webSocketUserPresenceHandler::isPresent).forEach(username -> {
    log.debug(""String_Node_Str"",message,username);
    messagingTemplate.convertAndSendToUser(username,""String_Node_Str"",message);
  }
);
}","/** 
 * Send the message to the currently logged in users that are affected by the message.
 */
@Subscribe public void onWebSocketMessage(WebSocketMessage message){
  message.getUsernames().stream().filter(username -> webSocketUserPresenceHandler.isPresent(username)).forEach(username -> {
    log.debug(""String_Node_Str"",message,username);
    messagingTemplate.convertAndSendToUser(username,""String_Node_Str"",message);
  }
);
}",0.8578255675029869
91066,"private Collection<CollectorDisplay> queryCollectors(long organisationId){
  return jdbcTemplate.query(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",new CollectorDisplayRowMapper(),organisationId);
}","private Collection<CollectorDisplay> queryCollectors(long organisationId){
  return jdbcTemplate.query(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",new CollectorDisplayRowMapper(),organisationId);
}",0.8921985815602836
91067,"@Override public CollectorDisplay mapRow(ResultSet rs,int rowNum) throws SQLException {
  return CollectorDisplay.builder().appName(rs.getString(1)).appVersion(rs.getString(2)).agentHostname(rs.getString(3)).agentVersion(String.format(""String_Node_Str"",rs.getString(4),rs.getString(5))).agentUploadIntervalSeconds(rs.getInt(6)).agentClockSkewMillis(rs.getLong(7)).collectorHostname(rs.getString(8)).collectorVersion(String.format(""String_Node_Str"",rs.getString(9),rs.getString(10))).collectorStartedAtMillis(rs.getLong(11)).dataReceivedAtMillis(rs.getLong(12)).collectorResolutionSeconds(rs.getInt(13)).methodVisibility(rs.getString(14)).build();
}","@Override public CollectorDisplay mapRow(ResultSet rs,int rowNum) throws SQLException {
  return CollectorDisplay.builder().appName(rs.getString(1)).appVersion(rs.getString(2)).agentHostname(rs.getString(3)).agentVersion(String.format(""String_Node_Str"",rs.getString(4),rs.getString(5))).agentUploadIntervalSeconds(rs.getInt(6)).agentClockSkewMillis(rs.getLong(7)).collectorHostname(rs.getString(8)).collectorVersion(String.format(""String_Node_Str"",rs.getString(9),rs.getString(10))).collectorResolutionSeconds(rs.getInt(11)).methodVisibility(rs.getString(12)).collectorStartedAtMillis(rs.getLong(13)).dataReceivedAtMillis(rs.getLong(14)).build();
}",0.8317901234567902
91068,"@Before public void before() throws Exception {
  eventBus.register(this);
}","@Before public void before() throws Exception {
  eventBus.register(this);
  events.clear();
}",0.8941176470588236
91069,"@Test public void testStoreInvocationData() throws Exception {
  agentService.storeJvmData(""String_Node_Str"",createJvmData(now));
  assertEventsWithinMillis(1,2000L);
  List<SignatureEntry> signatures=new ArrayList<>();
  signatures.add(new SignatureEntry(""String_Node_Str"",0L,0L,null));
  signatures.add(new SignatureEntry(""String_Node_Str"",100L,100L,SignatureConfidence.EXACT_MATCH));
  signatures.add(new SignatureEntry(""String_Node_Str"",200L,200L,SignatureConfidence.EXACT_MATCH));
  SignatureData data=SignatureData.builder().jvmUuid(JVM_UUID).signatures(signatures).build();
  events.clear();
  agentService.storeSignatureData(data);
  assertEventsWithinMillis(2,2000L);
  assertThat(events,hasSize(2));
  assertThat(events.get(0),is(instanceOf(InvocationDataReceivedEvent.class)));
  assertThat(events.get(1),is(instanceOf(ApplicationStatisticsMessage.class)));
}","@Test public void testStoreInvocationData() throws Exception {
  agentService.storeJvmData(""String_Node_Str"",createJvmData(now));
  assertEventsWithinMillis(2,2000L);
  List<SignatureEntry> signatures=new ArrayList<>();
  signatures.add(new SignatureEntry(""String_Node_Str"",0L,0L,null));
  signatures.add(new SignatureEntry(""String_Node_Str"",100L,100L,SignatureConfidence.EXACT_MATCH));
  signatures.add(new SignatureEntry(""String_Node_Str"",200L,200L,SignatureConfidence.EXACT_MATCH));
  SignatureData data=SignatureData.builder().jvmUuid(JVM_UUID).signatures(signatures).build();
  events.clear();
  agentService.storeSignatureData(data);
  assertEventsWithinMillis(2,2000L);
  assertThat(events,hasSize(2));
  assertThat(events.get(0),is(instanceOf(InvocationDataReceivedEvent.class)));
  assertThat(events.get(1),is(instanceOf(ApplicationStatisticsMessage.class)));
}",0.9988505747126436
91070,"@Override public SignatureData storeInvocationData(AppId appId,SignatureData signatureData){
  List<Object[]> args=new ArrayList<>();
  for (  SignatureEntry entry : signatureData.getSignatures()) {
    args.add(new Object[]{appId.getOrganisationId(),appId.getAppId(),appId.getJvmId(),entry.getSignature(),entry.getInvokedAtMillis(),entry.getMillisSinceJvmStart(),entry.getConfidence() == null ? null : entry.getConfidence().ordinal()});
  }
  int[] inserted=jdbcTemplate.batchUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",args);
  List<SignatureEntry> result=new ArrayList<>();
  int i=0;
  for (  SignatureEntry entry : signatureData.getSignatures()) {
    if (inserted[i] > 0) {
      result.add(entry);
    }
    i+=1;
  }
  return SignatureData.builder().jvmUuid(signatureData.getJvmUuid()).signatures(result).build();
}","@Override public SignatureData storeInvocationData(AppId appId,SignatureData signatureData){
  List<Object[]> args=new ArrayList<>();
  for (  SignatureEntry entry : signatureData.getSignatures()) {
    args.add(new Object[]{appId.getOrganisationId(),appId.getAppId(),appId.getJvmId(),entry.getSignature(),entry.getInvokedAtMillis(),entry.getMillisSinceJvmStart(),entry.getConfidence() == null ? null : entry.getConfidence().ordinal()});
  }
  int[] updated=jdbcTemplate.batchUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",args);
  List<SignatureEntry> result=new ArrayList<>();
  int i=0;
  for (  SignatureEntry entry : signatureData.getSignatures()) {
    if (updated[i] > 0) {
      result.add(entry);
    }
    i+=1;
  }
  return SignatureData.builder().jvmUuid(signatureData.getJvmUuid()).signatures(result).build();
}",0.98932384341637
91071,"@Transactional public void storeNormalizedInvocations(JvmState jvmState,List<Invocation> invocations){
  CodeBase codeBase=jvmState.getCodeBase();
  int recognized=0;
  int unrecognized=0;
  int ignored=0;
  int overridden=0;
  for (  Invocation invocation : invocations) {
    String rawSignature=invocation.getSignature();
    String normalizedSignature=codeBase.normalizeSignature(rawSignature);
    SignatureConfidence confidence=null;
    if (normalizedSignature == null) {
      ignored+=1;
    }
 else     if (codeBase.hasSignature(normalizedSignature)) {
      recognized+=1;
      confidence=SignatureConfidence.EXACT_MATCH;
    }
 else {
      String baseSignature=codeBase.getBaseSignature(normalizedSignature);
      if (baseSignature != null) {
        log.debug(""String_Node_Str"",normalizedSignature,baseSignature);
        overridden+=1;
        confidence=SignatureConfidence.FOUND_IN_PARENT_CLASS;
        normalizedSignature=baseSignature;
      }
 else       if (normalizedSignature.equals(rawSignature)) {
        unrecognized+=1;
        confidence=SignatureConfidence.NOT_FOUND_IN_CODE_BASE;
        log.debug(""String_Node_Str"",normalizedSignature);
      }
 else {
        unrecognized+=1;
        confidence=SignatureConfidence.NOT_FOUND_IN_CODE_BASE;
        log.debug(""String_Node_Str"",normalizedSignature,rawSignature);
      }
    }
    if (normalizedSignature != null) {
      invocationsCollector.put(jvmState.getJvm().getJvmUuid(),normalizedSignature,invocation.getInvokedAtMillis(),invocation.getInvokedAtMillis() - jvmState.getJvm().getStartedAtMillis(),confidence);
    }
  }
  FileUtils.deleteAllConsumedInvocationDataFiles(jvmState.getInvocationsFile());
  if (unrecognized > 0) {
    log.warn(""String_Node_Str"",recognized,overridden,unrecognized,ignored);
  }
 else {
    log.debug(""String_Node_Str"",recognized,overridden,ignored);
  }
}","@Transactional public void storeNormalizedInvocations(JvmState jvmState,List<Invocation> invocations){
  CodeBase codeBase=jvmState.getCodeBase();
  int recognized=0;
  int unrecognized=0;
  int ignored=0;
  int overridden=0;
  for (  Invocation invocation : invocations) {
    String rawSignature=invocation.getSignature();
    String normalizedSignature=codeBase.normalizeSignature(rawSignature);
    SignatureConfidence confidence=null;
    if (normalizedSignature == null) {
      ignored+=1;
    }
 else     if (codeBase.hasSignature(normalizedSignature)) {
      recognized+=1;
      confidence=SignatureConfidence.EXACT_MATCH;
    }
 else {
      String baseSignature=codeBase.getBaseSignature(normalizedSignature);
      if (baseSignature != null) {
        log.debug(""String_Node_Str"",normalizedSignature,baseSignature);
        overridden+=1;
        confidence=SignatureConfidence.FOUND_IN_PARENT_CLASS;
        normalizedSignature=baseSignature;
      }
 else       if (normalizedSignature.equals(rawSignature)) {
        unrecognized+=1;
        confidence=SignatureConfidence.NOT_FOUND_IN_CODE_BASE;
        log.debug(""String_Node_Str"",normalizedSignature);
      }
 else {
        unrecognized+=1;
        confidence=SignatureConfidence.NOT_FOUND_IN_CODE_BASE;
        log.debug(""String_Node_Str"",normalizedSignature,rawSignature);
      }
    }
    if (normalizedSignature != null) {
      invocationsCollector.put(jvmState.getJvm().getJvmUuid(),jvmState.getJvm().getStartedAtMillis(),normalizedSignature,invocation.getInvokedAtMillis(),confidence);
    }
  }
  FileUtils.deleteAllConsumedInvocationDataFiles(jvmState.getInvocationsFile());
  if (unrecognized > 0) {
    log.warn(""String_Node_Str"",recognized,overridden,unrecognized,ignored);
  }
 else {
    log.debug(""String_Node_Str"",recognized,overridden,ignored);
  }
}",0.9596122778675282
91072,"void put(String jvmUuid,String signature,long invokedAtMillis,long millisSinceJvmStart,SignatureConfidence confidence);","void put(String jvmUuid,long jvmStartedAtMillis,String signature,long invokedAtMillis,SignatureConfidence confidence);",0.7932489451476793
91073,"@Override @Transactional public void put(String jvmUuid,String signature,long invokedAtMillis,long millisSinceJvmStart,SignatureConfidence confidence){
  if (signature == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (invokedAtMillis < 0L) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int count=jdbcTemplate.queryForObject(""String_Node_Str"" + ""String_Node_Str"",Integer.class,jvmUuid,signature,invokedAtMillis);
  if (count == 0) {
    jdbcTemplate.update(""String_Node_Str"" + ""String_Node_Str"",jvmUuid,signature,invokedAtMillis,millisSinceJvmStart,confidence == null ? -1 : confidence.ordinal());
  }
}","@Override @Transactional public void put(String jvmUuid,long jvmStartedAtMillis,String signature,long invokedAtMillis,SignatureConfidence confidence){
  if (jvmUuid == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (jvmStartedAtMillis <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (signature == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (invokedAtMillis < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (invokedAtMillis > 0 && invokedAtMillis < jvmStartedAtMillis) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int count=jdbcTemplate.queryForObject(""String_Node_Str"" + ""String_Node_Str"",Integer.class,jvmUuid,signature,invokedAtMillis);
  if (count == 0) {
    long millisSinceJvmStart=invokedAtMillis == 0L ? 0L : invokedAtMillis - jvmStartedAtMillis;
    jdbcTemplate.update(""String_Node_Str"" + ""String_Node_Str"",jvmUuid,signature,invokedAtMillis,millisSinceJvmStart,confidence == null ? -1 : confidence.ordinal());
  }
}",0.7202797202797203
91074,"@Test public void testPutZeroSignature() throws Exception {
  invocationsCollector.put(jvmUuid1,""String_Node_Str"",0L,100L,null);
  List<SignatureEntry> notUploadedInvocations=invocationsCollector.getNotUploadedInvocations(jvmUuid1);
  assertThat(notUploadedInvocations,hasSize(1));
  assertThat(notUploadedInvocations.get(0).getConfidence(),is(nullValue()));
}","@Test public void testPutZeroSignature() throws Exception {
  invocationsCollector.put(jvmUuid1,now,""String_Node_Str"",0L,null);
  List<SignatureEntry> notUploadedInvocations=invocationsCollector.getNotUploadedInvocations(jvmUuid1);
  assertThat(notUploadedInvocations,hasSize(1));
  assertThat(notUploadedInvocations.get(0).getConfidence(),is(nullValue()));
}",0.9874826147426982
91075,"@Test(expected=IllegalArgumentException.class) public void testPutNegativeSignature() throws Exception {
  invocationsCollector.put(jvmUuid1,""String_Node_Str"",-1L,100L,null);
}","@Test(expected=IllegalArgumentException.class) public void testPutNegativeSignature() throws Exception {
  invocationsCollector.put(jvmUuid1,now,""String_Node_Str"",-1L,null);
}",0.9743589743589745
91076,"@Test public void testPutSignatureTwiceWithDifferentConfidence(){
  invocationsCollector.put(jvmUuid1,""String_Node_Str"",now,100L,EXACT_MATCH);
  invocationsCollector.put(jvmUuid1,""String_Node_Str"",now,100L,FOUND_IN_PARENT_CLASS);
  List<SignatureEntry> signatures=invocationsCollector.getNotUploadedInvocations(jvmUuid1);
  assertThat(signatures,hasSize(1));
  assertThat(signatures.get(0).getConfidence(),is(FOUND_IN_PARENT_CLASS));
}","@Test public void testPutSignatureTwiceWithDifferentConfidence(){
  invocationsCollector.put(jvmUuid1,now - 100L,""String_Node_Str"",now,EXACT_MATCH);
  invocationsCollector.put(jvmUuid1,now - 100L,""String_Node_Str"",now,FOUND_IN_PARENT_CLASS);
  List<SignatureEntry> signatures=invocationsCollector.getNotUploadedInvocations(jvmUuid1);
  assertThat(signatures,hasSize(1));
  assertThat(signatures.get(0).getConfidence(),is(FOUND_IN_PARENT_CLASS));
}",0.9002267573696145
91077,"@Test public void testPutSignatureTwice(){
  invocationsCollector.put(jvmUuid1,""String_Node_Str"",now,100L,EXACT_MATCH);
  invocationsCollector.put(jvmUuid1,""String_Node_Str"",now,100L,EXACT_MATCH);
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid1),hasSize(1));
}","@Test public void testPutSignatureTwice(){
  invocationsCollector.put(jvmUuid1,now - 100L,""String_Node_Str"",now,EXACT_MATCH);
  invocationsCollector.put(jvmUuid1,now - 100L,""String_Node_Str"",now,EXACT_MATCH);
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid1),hasSize(1));
}",0.9442508710801394
91078,"@Test(expected=IllegalArgumentException.class) public void testPutNullSignature() throws Exception {
  invocationsCollector.put(jvmUuid1,null,100L,100L,null);
}","@Test(expected=IllegalArgumentException.class) public void testPutNullSignature() throws Exception {
  invocationsCollector.put(jvmUuid1,now - 100L,null,0,null);
}",0.934984520123839
91079,"@Test public void testPutTwoSignaturesOnce(){
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid1),hasSize(0));
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid2),hasSize(0));
  invocationsCollector.put(jvmUuid1,""String_Node_Str"",now,100L,EXACT_MATCH);
  invocationsCollector.put(jvmUuid1,""String_Node_Str"",now,100L,EXACT_MATCH);
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid1),hasSize(2));
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid2),hasSize(0));
}","@Test public void testPutTwoSignaturesOnce(){
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid1),hasSize(0));
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid2),hasSize(0));
  invocationsCollector.put(jvmUuid1,now - 100L,""String_Node_Str"",now,EXACT_MATCH);
  invocationsCollector.put(jvmUuid1,now - 100L,""String_Node_Str"",now,EXACT_MATCH);
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid1),hasSize(2));
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid2),hasSize(0));
}",0.9703153988868276
91080,"@Test public void testClearNotUploadedSignatures(){
  invocationsCollector.put(jvmUuid1,""String_Node_Str"",now,100L,EXACT_MATCH);
  invocationsCollector.put(jvmUuid2,""String_Node_Str"",now,100L,EXACT_MATCH);
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid1),hasSize(1));
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid2),hasSize(1));
  invocationsCollector.clearNotUploadedSignatures(jvmUuid1);
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid1),hasSize(0));
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid2),hasSize(1));
}","@Test public void testClearNotUploadedSignatures(){
  invocationsCollector.put(jvmUuid1,now - 100L,""String_Node_Str"",now,EXACT_MATCH);
  invocationsCollector.put(jvmUuid2,now - 100L,""String_Node_Str"",now,EXACT_MATCH);
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid1),hasSize(1));
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid2),hasSize(1));
  invocationsCollector.clearNotUploadedSignatures(jvmUuid1);
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid1),hasSize(0));
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid2),hasSize(1));
}",0.9273927392739274
91081,"@Test public void testPutSignatureOnce(){
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid1),hasSize(0));
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid2),hasSize(0));
  invocationsCollector.put(jvmUuid1,""String_Node_Str"",now,100L,EXACT_MATCH);
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid1),hasSize(1));
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid2),hasSize(0));
}","@Test public void testPutSignatureOnce(){
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid1),hasSize(0));
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid2),hasSize(0));
  invocationsCollector.put(jvmUuid1,now - 100L,""String_Node_Str"",now,EXACT_MATCH);
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid1),hasSize(1));
  assertThat(invocationsCollector.getNotUploadedInvocations(jvmUuid2),hasSize(0));
}",0.9516483516483516
91082,"@Test public void testPutSignatureTriceWithDifferentTimestamps(){
  invocationsCollector.put(jvmUuid1,""String_Node_Str"",now - 1,100L,EXACT_MATCH);
  invocationsCollector.put(jvmUuid1,""String_Node_Str"",now,100L,EXACT_MATCH);
  invocationsCollector.put(jvmUuid1,""String_Node_Str"",now - 2,100L,EXACT_MATCH);
  List<SignatureEntry> signatures=invocationsCollector.getNotUploadedInvocations(jvmUuid1);
  assertThat(signatures,hasSize(1));
  assertThat(signatures.get(0).getInvokedAtMillis(),is(now));
}","@Test public void testPutSignatureTriceWithDifferentTimestamps(){
  invocationsCollector.put(jvmUuid1,now - 100L,""String_Node_Str"",now - 1,EXACT_MATCH);
  invocationsCollector.put(jvmUuid1,now - 100L,""String_Node_Str"",now,EXACT_MATCH);
  invocationsCollector.put(jvmUuid1,now - 100L,""String_Node_Str"",now - 2,EXACT_MATCH);
  List<SignatureEntry> signatures=invocationsCollector.getNotUploadedInvocations(jvmUuid1);
  assertThat(signatures,hasSize(1));
  assertThat(signatures.get(0).getInvokedAtMillis(),is(now));
}",0.9525691699604744
91083,"@Override public SignatureEntry mapRow(ResultSet rs,int rowNum) throws SQLException {
  Integer confidence=rs.getInt(4);
  return new SignatureEntry(rs.getString(1),rs.getLong(2),rs.getLong(2),confidence == -1 ? null : SignatureConfidence.fromOrdinal(confidence));
}","@Override public SignatureEntry mapRow(ResultSet rs,int rowNum) throws SQLException {
  Integer confidence=rs.getInt(4);
  return new SignatureEntry(rs.getString(1),rs.getLong(2),rs.getLong(3),confidence == -1 ? null : SignatureConfidence.fromOrdinal(confidence));
}",0.9962406015037594
91084,"@Override public List<SignatureEntry> getNotUploadedInvocations(String jvmUuid){
  return jdbcTemplate.query(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",new RowMapper<SignatureEntry>(){
    @Override public SignatureEntry mapRow(    ResultSet rs,    int rowNum) throws SQLException {
      Integer confidence=rs.getInt(4);
      return new SignatureEntry(rs.getString(1),rs.getLong(2),rs.getLong(2),confidence == -1 ? null : SignatureConfidence.fromOrdinal(confidence));
    }
  }
,jvmUuid);
}","@Override public List<SignatureEntry> getNotUploadedInvocations(String jvmUuid){
  return jdbcTemplate.query(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",new RowMapper<SignatureEntry>(){
    @Override public SignatureEntry mapRow(    ResultSet rs,    int rowNum) throws SQLException {
      Integer confidence=rs.getInt(4);
      return new SignatureEntry(rs.getString(1),rs.getLong(2),rs.getLong(3),confidence == -1 ? null : SignatureConfidence.fromOrdinal(confidence));
    }
  }
,jvmUuid);
}",0.9980276134122288
91085,"@AssertTrue public boolean assertValid(){
  if (invokedAtMillis == 0L && millisSinceJvmStart == 0L) {
    return true;
  }
  if (invokedAtMillis > 0L && millisSinceJvmStart > 0L) {
    return true;
  }
  return false;
}","@AssertTrue public boolean assertValid(){
  return ((invokedAtMillis == 0L) && (millisSinceJvmStart == 0L)) || ((invokedAtMillis > 0L) && (millisSinceJvmStart > 0L));
}",0.7855297157622739
91086,"private void doAnalyzeCollectorData(){
  log.debug(""String_Node_Str"");
  now=System.currentTimeMillis();
  findJvmStates();
  for (  JvmState jvmState : jvmStates.values()) {
    if (jvmState.getInvocationDataUploadedAt() == 0L) {
      FileUtils.resetAllConsumedInvocationDataFiles(jvmState.getInvocationsFile());
    }
    uploadJvmData(jvmState);
    analyzeAndUploadCodeBaseIfNeeded(jvmState,new CodeBase(jvmState.getJvm().getCollectorConfig()));
    processInvocationsDataIfNeeded(jvmState);
  }
}","private void doAnalyzeCollectorData(){
  log.debug(""String_Node_Str"");
  now=System.currentTimeMillis();
  findJvmStates();
  for (  JvmState jvmState : jvmStates.values()) {
    if (jvmState.isFirstRun()) {
      FileUtils.resetAllConsumedInvocationDataFiles(jvmState.getInvocationsFile());
      jvmState.setFirstRun(false);
    }
    uploadJvmData(jvmState);
    analyzeAndUploadCodeBaseIfNeeded(jvmState,new CodeBase(jvmState.getJvm().getCollectorConfig()));
    processInvocationsDataIfNeeded(jvmState);
  }
}",0.4429133858267716
91087,"private void analyzeAndUploadCodeBaseIfNeeded(JvmState jvmState,CodeBase newCodeBase){
  if (jvmState.getCodebaseUploadedAt() == 0 || !newCodeBase.equals(jvmState.getCodeBase())) {
    if (jvmState.getCodebaseUploadedAt() == 0) {
      log.debug(""String_Node_Str"");
    }
 else {
      resolveAppVersion(jvmState);
      log.info(""String_Node_Str"");
    }
    codeBaseScanner.scanSignatures(newCodeBase);
    try {
      agentApi.uploadSignatureData(getJvmData(jvmState),newCodeBase.getSignatures());
      jvmState.setCodeBase(newCodeBase);
      jvmState.setCodebaseUploadedAt(now);
    }
 catch (    AgentApiException e) {
      logException(""String_Node_Str"" + agentApi.getServerUri(),e);
    }
  }
}","private void analyzeAndUploadCodeBaseIfNeeded(JvmState jvmState,CodeBase newCodeBase){
  if (jvmState.getCodebaseUploadedAt() == 0 || !newCodeBase.equals(jvmState.getCodeBase())) {
    if (jvmState.getCodebaseUploadedAt() == 0) {
      log.debug(""String_Node_Str"");
    }
 else {
      resolveAppVersion(jvmState);
      log.info(""String_Node_Str"");
    }
    codeBaseScanner.scanSignatures(newCodeBase);
    jvmState.setCodeBase(newCodeBase);
    try {
      agentApi.uploadSignatureData(getJvmData(jvmState),newCodeBase.getSignatures());
      jvmState.setCodebaseUploadedAt(now);
    }
 catch (    AgentApiException e) {
      logException(""String_Node_Str"" + agentApi.getServerUri(),e);
    }
  }
}",0.9431009957325748
91088,"private void addOrUpdateJvmState(File file){
  try {
    Jvm jvm=Jvm.readFrom(file);
    JvmState jvmState=jvmStates.get(jvm.getJvmFingerprint());
    if (jvmState == null) {
      jvmState=new JvmState(jvm);
      jvmState.setAppVersion(getAppVersion(jvm));
      jvmStates.put(jvm.getJvmFingerprint(),jvmState);
    }
    jvmState.setInvocationsFile(new File(file.getParentFile(),CollectorConfig.INVOCATIONS_BASENAME));
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"" + file,e);
  }
}","private void addOrUpdateJvmState(File file){
  try {
    Jvm jvm=Jvm.readFrom(file);
    JvmState jvmState=jvmStates.get(jvm.getJvmFingerprint());
    if (jvmState == null) {
      jvmState=new JvmState();
      jvmState.setAppVersion(getAppVersion(jvm));
      jvmStates.put(jvm.getJvmFingerprint(),jvmState);
    }
    jvmState.setJvm(jvm);
    jvmState.setInvocationsFile(new File(file.getParentFile(),CollectorConfig.INVOCATIONS_BASENAME));
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"" + file,e);
  }
}",0.9717073170731708
91089,"private void addJvmState(Collection<JvmState> result,File file){
  try {
    JvmState jvmState=JvmState.builder().invocationsFile(new File(file.getParentFile(),CollectorConfig.INVOCATIONS_BASENAME)).jvm(Jvm.readFrom(file)).build();
    jvmState.setCodeBase(codeBases.get(jvmState.getJvm().getJvmFingerprint()));
    result.add(jvmState);
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"" + file,e);
  }
}","private void addJvmState(File file){
  try {
    Jvm jvm=Jvm.readFrom(file);
    JvmState jvmState=jvmStates.get(jvm.getJvmFingerprint());
    if (jvmState == null) {
      jvmState=new JvmState(jvm);
      jvmState.setAppVersion(getAppVersion(jvm));
      jvmStates.put(jvm.getJvmFingerprint(),jvmState);
    }
    jvmState.setInvocationsFile(new File(file.getParentFile(),CollectorConfig.INVOCATIONS_BASENAME));
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"" + file,e);
  }
}",0.421978021978022
91090,"private void uploadJvmData(Jvm jvm,String appVersion){
  try {
    agentApi.uploadJvmData(JvmData.builder().appName(jvm.getCollectorConfig().getAppName()).tags(jvm.getCollectorConfig().getTags()).appVersion(appVersion).hostName(jvm.getHostName()).startedAtMillis(jvm.getStartedAtMillis()).dumpedAtMillis(jvm.getDumpedAtMillis()).jvmFingerprint(jvm.getJvmFingerprint()).computerId(computerId.toString()).codekvastVersion(codekvastGradleVersion).codekvastVcsId(codekvastVcsId).build());
  }
 catch (  AgentApiException e) {
    logException(""String_Node_Str"" + agentApi.getServerUri(),e);
  }
}","private void uploadJvmData(JvmState jvmState){
  Jvm jvm=jvmState.getJvm();
  if (jvmState.getJvmDataUploadedAt() < jvm.getDumpedAtMillis()) {
    try {
      agentApi.uploadJvmData(JvmData.builder().appName(jvm.getCollectorConfig().getAppName()).tags(jvm.getCollectorConfig().getTags()).appVersion(jvmState.getAppVersion()).hostName(jvm.getHostName()).startedAtMillis(jvm.getStartedAtMillis()).dumpedAtMillis(jvm.getDumpedAtMillis()).jvmFingerprint(jvm.getJvmFingerprint()).computerId(computerId.toString()).codekvastVersion(codekvastGradleVersion).codekvastVcsId(codekvastVcsId).build());
      jvmState.setJvmDataUploadedAt(jvm.getDumpedAtMillis());
    }
 catch (    AgentApiException e) {
      logException(""String_Node_Str"" + agentApi.getServerUri(),e);
    }
  }
}",0.2111436950146627
91091,"private void findJvmState(Collection<JvmState> result,File dataPath){
  log.debug(""String_Node_Str"",dataPath);
  File[] files=dataPath.listFiles();
  if (files != null) {
    for (    File file : files) {
      if (file.isFile() && file.getName().equals(CollectorConfig.JVM_BASENAME)) {
        addJvmState(result,file);
      }
 else       if (file.isDirectory()) {
        findJvmState(result,file);
      }
    }
  }
}","private void findJvmState(File dataPath){
  log.debug(""String_Node_Str"",dataPath);
  File[] files=dataPath.listFiles();
  if (files != null) {
    for (    File file : files) {
      if (file.isFile() && file.getName().equals(CollectorConfig.JVM_BASENAME)) {
        addJvmState(file);
      }
 else       if (file.isDirectory()) {
        findJvmState(file);
      }
    }
  }
}",0.9475
91092,"@Scheduled(initialDelay=10L,fixedDelayString=""String_Node_Str"") public void analyseCollectorData(){
  log.debug(""String_Node_Str"");
  long now=System.currentTimeMillis();
  for (  JvmState jvmState : findJvmStates()) {
    Jvm jvm=jvmState.getJvm();
    String appVersion=getAppVersion(jvm);
    String fingerprint=jvm.getJvmFingerprint();
    Long oldProcessedAt=jvmProcessedAt.get(fingerprint);
    if (oldProcessedAt == null) {
      FileUtils.resetAllConsumedInvocationDataFiles(jvmState.getInvocationsFile());
      uploadJvmData(jvm,appVersion);
      analyzeAndUploadCodeBaseIfNeeded(jvmState,new CodeBase(jvm.getCollectorConfig()));
      processInvocationsDataIfNeeded(jvmState);
    }
 else     if (oldProcessedAt < jvm.getDumpedAtMillis()) {
      uploadJvmData(jvm,appVersion);
      processInvocationsDataIfNeeded(jvmState);
    }
    jvmProcessedAt.put(fingerprint,now);
  }
}","@Scheduled(initialDelay=10L,fixedDelayString=""String_Node_Str"") public void analyseCollectorData(){
  log.debug(""String_Node_Str"");
  now=System.currentTimeMillis();
  findJvmStates();
  for (  JvmState jvmState : jvmStates.values()) {
    if (jvmState.getInvocationDataUploadedAt() == 0L) {
      FileUtils.resetAllConsumedInvocationDataFiles(jvmState.getInvocationsFile());
    }
    uploadJvmData(jvmState);
    analyzeAndUploadCodeBaseIfNeeded(jvmState,new CodeBase(jvmState.getJvm().getCollectorConfig()));
    processInvocationsDataIfNeeded(jvmState);
  }
}",0.6276668960770819
91093,"private Collection<JvmState> findJvmStates(){
  Collection<JvmState> result=new ArrayList<>();
  findJvmState(result,config.getSharedConfig().getDataPath());
  return result;
}","private void findJvmStates(){
  findJvmState(config.getSharedConfig().getDataPath());
}",0.6463878326996197
91094,"private void analyzeAndUploadCodeBaseIfNeeded(JvmState jvmState,CodeBase newCodeBase){
  if (!newCodeBase.equals(jvmState.getCodeBase())) {
    codeBaseScanner.scanSignatures(newCodeBase);
    try {
      agentApi.uploadSignatureData(jvmState.getJvm().getJvmFingerprint(),newCodeBase.getSignatures());
      jvmState.setCodeBase(newCodeBase);
      codeBases.put(jvmState.getJvm().getJvmFingerprint(),newCodeBase);
    }
 catch (    AgentApiException e) {
      logException(""String_Node_Str"" + agentApi.getServerUri(),e);
    }
  }
}","private void analyzeAndUploadCodeBaseIfNeeded(JvmState jvmState,CodeBase newCodeBase){
  if (jvmState.getCodebaseUploadedAt() == 0 || !newCodeBase.equals(jvmState.getCodeBase())) {
    codeBaseScanner.scanSignatures(newCodeBase);
    try {
      agentApi.uploadSignatureData(jvmState.getJvm().getJvmFingerprint(),newCodeBase.getSignatures());
      jvmState.setCodeBase(newCodeBase);
      jvmState.setCodebaseUploadedAt(now);
    }
 catch (    AgentApiException e) {
      logException(""String_Node_Str"" + agentApi.getServerUri(),e);
    }
  }
}",0.8907407407407407
91095,"private String getAppVersion(Jvm jvm){
  String appVersion=appVersions.get(jvm.getJvmFingerprint());
  if (appVersion == null) {
    appVersion=resolveAppVersion(appVersionStrategies,jvm.getCollectorConfig().getCodeBaseFiles(),jvm.getCollectorConfig().getAppVersion());
    appVersions.put(jvm.getJvmFingerprint(),appVersion);
  }
  return appVersion;
}","private String getAppVersion(Jvm jvm){
  return resolveAppVersion(appVersionStrategies,jvm.getCollectorConfig().getCodeBaseFiles(),jvm.getCollectorConfig().getAppVersion());
}",0.6590909090909091
91096,"private void uploadUsedSignatures(JvmState jvmState){
  try {
    agentApi.uploadInvocationsData(jvmState.getJvm().getJvmFingerprint(),jvmState.getInvocationsCollector().getNotUploadedInvocations());
    jvmState.getInvocationsCollector().clearNotUploadedSignatures();
    FileUtils.deleteAllConsumedInvocationDataFiles(jvmState.getInvocationsFile());
  }
 catch (  AgentApiException e) {
    logException(""String_Node_Str"",e);
  }
}","private void uploadUsedSignatures(JvmState jvmState){
  try {
    agentApi.uploadInvocationsData(jvmState.getJvm().getJvmFingerprint(),jvmState.getInvocationsCollector().getNotUploadedInvocations());
    jvmState.getInvocationsCollector().clearNotUploadedSignatures();
    FileUtils.deleteAllConsumedInvocationDataFiles(jvmState.getInvocationsFile());
  }
 catch (  AgentApiException e) {
    logException(""String_Node_Str"" + agentApi.getServerUri(),e);
    FileUtils.resetAllConsumedInvocationDataFiles(jvmState.getInvocationsFile());
  }
}",0.8891170431211499
91097,"@Override @Transactional(readOnly=true) public Collection<InvocationEntry> getSignatures(long organisationId){
  String queries[]={""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""};
  long startedAt=System.currentTimeMillis();
  List<InvocationEntry> result=jdbcTemplate.query(queries[0],new InvocationsEntryRowMapper(),organisationId);
  log.warn(""String_Node_Str"",organisationId,(System.currentTimeMillis() - startedAt) / 1000L);
  return result;
}","@Override @Transactional(readOnly=true) public Collection<InvocationEntry> getSignatures(long organisationId){
  long startedAt=System.currentTimeMillis();
  Set<InvocationEntry> result=new HashSet<>(jdbcTemplate.query(""String_Node_Str"",new InvocationsEntryRowMapper(),organisationId));
  log.debug(""String_Node_Str"",organisationId,System.currentTimeMillis() - startedAt);
  return result;
}",0.2254758418740849
91098,"@Scheduled(initialDelay=10L,fixedDelayString=""String_Node_Str"") public void analyseSensorData(){
  log.debug(""String_Node_Str"");
  uploadJvmRunIfNeeded(config.getJvmRunFile());
  analyzeCodeBaseIfNeeded(new CodeBase(config));
  if (codeBase != null) {
    processUsageDataIfNeeded(config.getUsageFile());
  }
}","@Scheduled(initialDelay=10L,fixedDelayString=""String_Node_Str"") public void analyseSensorData(){
  log.debug(""String_Node_Str"");
  uploadJvmRunIfNeeded(config.getJvmRunFile());
  analyzeAndUploadCodeBaseIfNeeded(new CodeBase(config));
  if (codeBase != null) {
    processUsageDataIfNeeded(config.getUsageFile());
  }
}",0.985691573926868
91099,"CodeBase(AgentConfig config){
  this.config=config;
  this.codeBaseFile=new File(config.getCodeBaseUri());
}","CodeBase(AgentConfig config){
  this.config=config;
  this.codeBaseFile=new File(config.getCodeBaseUri());
  this.fingerprint=initUrls();
}",0.8744939271255061
91100,"URL[] getUrls(){
  updateFingerprint();
  if (needsExploding) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  return urls.toArray(new URL[urls.size()]);
}","URL[] getUrls(){
  if (needsExploding) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  return urls.toArray(new URL[urls.size()]);
}",0.9309309309309308
91101,"CodeBaseFingerprint build(){
  return new CodeBaseFingerprint(count,size,lastModified,Long.valueOf(hashCode).hashCode());
}","CodeBaseFingerprint build(){
  return new CodeBaseFingerprint(count,size,lastModified,Long.valueOf(hashCodeSum).hashCode());
}",0.9879518072289156
91102,"public void record(File file){
  count+=1;
  size+=file.length();
  lastModified=max(lastModified,file.lastModified());
  hashCode+=file.hashCode();
  log.trace(""String_Node_Str"",file,this);
}","public Builder record(File file){
  count+=1;
  size+=file.length();
  lastModified=max(lastModified,file.lastModified());
  hashCodeSum+=file.hashCode();
  log.trace(""String_Node_Str"",file,this);
  return this;
}",0.928395061728395
91103,"void put(String signature,long usedAtMillis,UsageConfidence confidence){
  if (signature != null) {
    UsageDataEntry newEntry=new UsageDataEntry(signature,usedAtMillis,confidence);
    UsageDataEntry oldEntry=entries.put(signature,newEntry);
    if (!newEntry.equals(oldEntry)) {
      notUploadedSignatures.add(newEntry);
    }
  }
}","void put(@NonNull String signature,long usedAtMillis,@NonNull UsageConfidence confidence){
  notUploadedSignatures.add(new UsageDataEntry(signature,usedAtMillis,confidence));
}",0.5546875
91104,"private String getAppName(File usageFile){
  return usageFile.getName();
}","private String getAppName(File usageFile){
  String name=usageFile.getName();
  return name.substring(0,name.length() - Configuration.USAGE_FILE_SUFFIX.length());
}",0.5798319327731093
91105,"private void processUsageDataIfNew(File usageFile){
  long modifiedAt=usageFile.lastModified();
  Long oldModifiedAt=dataFileModifiedAtMillis.get(usageFile);
  if (oldModifiedAt == null || oldModifiedAt != modifiedAt) {
    String appName=getAppName(usageFile);
    applyRecordedUsage(codeBase,getAppUsage(appName),SensorUtils.readUsageFrom(usageFile));
    dataFileModifiedAtMillis.put(usageFile,modifiedAt);
  }
}","private void processUsageDataIfNew(File usageFile){
  long modifiedAt=usageFile.lastModified();
  Long oldModifiedAt=dataFileModifiedAtMillis.get(usageFile.getPath());
  if (oldModifiedAt == null || oldModifiedAt != modifiedAt) {
    String appName=getAppName(usageFile);
    applyRecordedUsage(codeBase,getAppUsage(appName),SensorUtils.readUsageFrom(usageFile));
    dataFileModifiedAtMillis.put(usageFile.getPath(),modifiedAt);
  }
}",0.976470588235294
91106,"public CodeBase(Configuration config){
  this.config=config;
  this.codeBaseFile=new File(config.getCodeBaseUri());
  checkArgument(codeBaseFile.exists(),""String_Node_Str"" + codeBaseFile + ""String_Node_Str"");
}","public CodeBase(Configuration config){
  this.config=config;
  this.codeBaseFile=new File(config.getCodeBaseUri());
}",0.7155963302752294
91107,"protected void initialize(Object... arg){
  CoreSession session=null;
  DocumentModelList rootSections=null;
  DocumentModelList higherSections=null;
  DocumentModelList testme=null;
  HashMap latestPublicationsMap=new HashMap<DocumentModel,DocumentModelList>();
  session=ctx.getCoreSession();
  if (session != null) {
    String query=""String_Node_Str"";
    try {
      rootSections=session.query(query);
      if (!rootSections.isEmpty()) {
        Iterator<DocumentModel> rootSectionIterator=rootSections.iterator();
        query=""String_Node_Str"";
        query=query.concat(rootSectionIterator.next().getId());
        while (rootSectionIterator.hasNext()) {
          query=query.concat(""String_Node_Str"");
          query=query.concat(rootSectionIterator.next().getId());
        }
        query=query.concat(""String_Node_Str"");
        higherSections=session.query(query);
      }
      ctx.setProperty(""String_Node_Str"",higherSections);
      latestPublicationsMap=getLatestPublicationMap(session,higherSections);
      ctx.setProperty(""String_Node_Str"",latestPublicationsMap);
      log.warn(higherSections.size());
    }
 catch (    ClientException e) {
      log.error(e);
    }
  }
}","@Override protected void initialize(Object... arg){
  CoreSession session=null;
  DocumentModelList rootSections=null;
  DocumentModelList higherSections=null;
  DocumentModelList testme=null;
  HashMap latestPublicationsMap=new HashMap<DocumentModel,DocumentModelList>();
  session=ctx.getCoreSession();
  if (session != null) {
    String query=""String_Node_Str"";
    try {
      rootSections=session.query(query);
      if (!rootSections.isEmpty()) {
        Iterator<DocumentModel> rootSectionIterator=rootSections.iterator();
        query=""String_Node_Str"";
        query=query.concat(rootSectionIterator.next().getId());
        while (rootSectionIterator.hasNext()) {
          query=query.concat(""String_Node_Str"");
          query=query.concat(rootSectionIterator.next().getId());
        }
        query=query.concat(""String_Node_Str"");
        higherSections=session.query(query);
      }
      ctx.setProperty(""String_Node_Str"",higherSections);
      latestPublicationsMap=getLatestPublicationMap(session,higherSections);
      ctx.setProperty(""String_Node_Str"",latestPublicationsMap);
      log.warn(higherSections.size());
    }
 catch (    ClientException e) {
      log.error(e);
    }
  }
}",0.9958437240232751
91108,"protected void initialize(Object... arg){
  String id=(String)arg[0];
  CoreSession session=null;
  DocumentModel currentSection;
  DocumentModelList childSections=null;
  DocumentModelList childrenContent;
  session=ctx.getCoreSession();
  HashMap latestPublicationsMap=new HashMap<DocumentModel,DocumentModelList>();
  if (session != null) {
    try {
      currentSection=session.query(""String_Node_Str"" + id + ""String_Node_Str"").get(0);
      childSections=session.query(""String_Node_Str"" + currentSection.getId() + ""String_Node_Str"");
      childrenContent=session.query(""String_Node_Str"" + currentSection.getId() + ""String_Node_Str"");
      ctx.setProperty(""String_Node_Str"",childSections);
      ctx.setProperty(""String_Node_Str"",currentSection);
      ctx.setProperty(""String_Node_Str"",childrenContent);
      latestPublicationsMap=getLatestPublicationMap(session,childSections);
      ctx.setProperty(""String_Node_Str"",latestPublicationsMap);
      log.warn(childSections.size());
    }
 catch (    ClientException e) {
      log.error(e);
    }
  }
}","@Override protected void initialize(Object... arg){
  String id=(String)arg[0];
  CoreSession session=null;
  DocumentModel currentSection;
  DocumentModelList childSections=null;
  DocumentModelList childrenContent;
  session=ctx.getCoreSession();
  HashMap latestPublicationsMap=new HashMap<DocumentModel,DocumentModelList>();
  if (session != null) {
    try {
      currentSection=session.query(""String_Node_Str"" + id + ""String_Node_Str"").get(0);
      childSections=session.query(""String_Node_Str"" + currentSection.getId() + ""String_Node_Str"");
      childrenContent=session.query(""String_Node_Str"" + currentSection.getId() + ""String_Node_Str"");
      ctx.setProperty(""String_Node_Str"",childSections);
      ctx.setProperty(""String_Node_Str"",currentSection);
      ctx.setProperty(""String_Node_Str"",childrenContent);
      latestPublicationsMap=getLatestPublicationMap(session,childSections);
      ctx.setProperty(""String_Node_Str"",latestPublicationsMap);
      log.warn(childSections.size());
    }
 catch (    ClientException e) {
      log.error(e);
    }
  }
}",0.9953051643192488
91109,"@Path(""String_Node_Str"") public Resource getsectionContent(@PathParam(""String_Node_Str"") String id){
  return newObject(""String_Node_Str"",id);
}","@Override @Path(""String_Node_Str"") public Resource getsectionContent(@PathParam(""String_Node_Str"") String id){
  return newObject(""String_Node_Str"",id);
}",0.9664429530201344
91110,"@GET public Object doGet(){
  return getView(""String_Node_Str"");
}","@Override @GET public Object doGet(){
  return getView(""String_Node_Str"");
}",0.9295774647887324
91111,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  mHighScoreTextView=(TextView)findViewById(R.id.mainHighScore);
  mNewGameButton=(Button)findViewById(R.id.newGameButton);
  mResetScoreButton=(Button)findViewById(R.id.resetScoreButton);
  mLevelSpinner=(Spinner)findViewById(R.id.levelSpinner);
  mSharedPrefs=PreferenceManager.getDefaultSharedPreferences(getBaseContext());
  ArrayAdapter<CharSequence> adapter=ArrayAdapter.createFromResource(this,R.array.levels,android.R.layout.simple_spinner_item);
  adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
  mLevelSpinner.setAdapter(adapter);
  mLevelSpinner.setOnItemSelectedListener(this);
  mLevelSpinner.setSelection(2);
  mNewGameButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      Intent intent=new Intent(getBaseContext(),UI.class);
      startActivity(intent);
    }
  }
);
  mResetScoreButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      SharedPreferences.Editor editor=mSharedPrefs.edit();
      editor.clear();
      editor.commit();
      updateScoreTextView();
    }
  }
);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  mHighScoreTextView=(TextView)findViewById(R.id.mainHighScore);
  mNewGameButton=(Button)findViewById(R.id.newGameButton);
  mResetScoreButton=(Button)findViewById(R.id.resetScoreButton);
  mLevelSpinner=(Spinner)findViewById(R.id.levelSpinner);
  mSharedPrefs=PreferenceManager.getDefaultSharedPreferences(getBaseContext());
  ArrayAdapter<CharSequence> adapter=ArrayAdapter.createFromResource(this,R.array.levels,android.R.layout.simple_spinner_item);
  adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
  mLevelSpinner.setAdapter(adapter);
  mLevelSpinner.setOnItemSelectedListener(this);
  mLevelSpinner.setSelection(2);
  mNewGameButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      Intent intent=new Intent(getBaseContext(),UI.class);
      startActivity(intent);
    }
  }
);
  mResetScoreButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      SharedPreferences.Editor editor=mSharedPrefs.edit();
      editor.remove(""String_Node_Str"");
      editor.commit();
      updateScoreTextView();
    }
  }
);
}",0.9881889763779528
91112,"@Override public void onClick(View v){
  SharedPreferences.Editor editor=mSharedPrefs.edit();
  editor.clear();
  editor.commit();
  updateScoreTextView();
}","@Override public void onClick(View v){
  SharedPreferences.Editor editor=mSharedPrefs.edit();
  editor.remove(""String_Node_Str"");
  editor.commit();
  updateScoreTextView();
}",0.9216867469879518
91113,"private void updateUI(){
  mHandler.post(new Runnable(){
    @Override public void run(){
      if (!State.getGameOver()) {
        mScoreTextView.setText(getString(R.string.score) + String.format(""String_Node_Str"",State.getScore()));
        mScoreMultiplierTextView.setText(getString(R.string.multiplier) + State.getScoreMultiplier() + ""String_Node_Str"");
        if (State.getScore() > mHighScore) {
          mHighScore=State.getScore();
          mNewHighScore=true;
          mHighScoreTextView.setTextColor(Color.GREEN);
        }
        mHighScoreTextView.setText(getString(R.string.high_score) + String.format(""String_Node_Str"",mHighScore));
        mLivesTextView.setText(getString(R.string.lives) + State.getLifes());
      }
 else {
        if (mNewHighScore) {
          mSharedPrefsEditor.putLong(""String_Node_Str"",mHighScore);
          mSharedPrefsEditor.commit();
          mSoundPool.play(mSoundIds.get(""String_Node_Str""),100,100,1,0,1.0f);
        }
        showGameOverDialog(State.getScore(),mNewHighScore);
        mFinish=true;
      }
    }
  }
);
}","private void updateUI(){
  mHandler.post(new Runnable(){
    @Override public void run(){
      if (!State.getGameOver()) {
        mScoreTextView.setText(getString(R.string.score) + String.format(""String_Node_Str"",State.getScore()));
        mScoreMultiplierTextView.setText(getString(R.string.multiplier) + State.getScoreMultiplier() + ""String_Node_Str"");
        if (State.getScore() > mHighScore) {
          mHighScore=State.getScore();
          mNewHighScore=true;
          mHighScoreTextView.setTextColor(Color.GREEN);
        }
        mHighScoreTextView.setText(getString(R.string.high_score) + String.format(""String_Node_Str"",mHighScore));
        mLivesTextView.setText(getString(R.string.lives) + State.getLifes());
      }
 else {
        if (mNewHighScore) {
          mSharedPrefsEditor.putLong(""String_Node_Str"",mHighScore);
          mSharedPrefsEditor.commit();
          mSoundPool.play(mSoundIds.get(""String_Node_Str""),100,100,0,0,1.0f);
        }
        showGameOverDialog(State.getScore(),mNewHighScore);
        mFinish=true;
      }
    }
  }
);
}",0.9990689013035382
91114,"@Override public void run(){
  if (!State.getGameOver()) {
    mScoreTextView.setText(getString(R.string.score) + String.format(""String_Node_Str"",State.getScore()));
    mScoreMultiplierTextView.setText(getString(R.string.multiplier) + State.getScoreMultiplier() + ""String_Node_Str"");
    if (State.getScore() > mHighScore) {
      mHighScore=State.getScore();
      mNewHighScore=true;
      mHighScoreTextView.setTextColor(Color.GREEN);
    }
    mHighScoreTextView.setText(getString(R.string.high_score) + String.format(""String_Node_Str"",mHighScore));
    mLivesTextView.setText(getString(R.string.lives) + State.getLifes());
  }
 else {
    if (mNewHighScore) {
      mSharedPrefsEditor.putLong(""String_Node_Str"",mHighScore);
      mSharedPrefsEditor.commit();
      mSoundPool.play(mSoundIds.get(""String_Node_Str""),100,100,1,0,1.0f);
    }
    showGameOverDialog(State.getScore(),mNewHighScore);
    mFinish=true;
  }
}","@Override public void run(){
  if (!State.getGameOver()) {
    mScoreTextView.setText(getString(R.string.score) + String.format(""String_Node_Str"",State.getScore()));
    mScoreMultiplierTextView.setText(getString(R.string.multiplier) + State.getScoreMultiplier() + ""String_Node_Str"");
    if (State.getScore() > mHighScore) {
      mHighScore=State.getScore();
      mNewHighScore=true;
      mHighScoreTextView.setTextColor(Color.GREEN);
    }
    mHighScoreTextView.setText(getString(R.string.high_score) + String.format(""String_Node_Str"",mHighScore));
    mLivesTextView.setText(getString(R.string.lives) + State.getLifes());
  }
 else {
    if (mNewHighScore) {
      mSharedPrefsEditor.putLong(""String_Node_Str"",mHighScore);
      mSharedPrefsEditor.commit();
      mSoundPool.play(mSoundIds.get(""String_Node_Str""),100,100,0,0,1.0f);
    }
    showGameOverDialog(State.getScore(),mNewHighScore);
    mFinish=true;
  }
}",0.9989177489177488
91115,"private void createLevel(int blocksX,int blocksY,float initialX,float initialY,float spaceX,float spaceY){
  mBricks=new Brick[blocksX][blocksY];
  float newPosX=initialX;
  float newPosY=initialY;
  for (int i=0; i < mBricks.length; i++) {
    float sign=-1;
    for (int j=0; j < mBricks[i].length; j++) {
      sign*=-1;
      double prob=Math.random();
      if (prob <= (Brick.MOBILE_BRICK_PROBABILITY + Brick.EXPLOSIVE_BRICK_PROBABILITY + Brick.GRAY_BRICK_PROBABILITY)) {
        if (prob <= Brick.MOBILE_BRICK_PROBABILITY) {
          MobileBrick mBrick=new MobileBrick(Colors.GREEN_GRADIENT,newPosX,newPosY,0.1f,Type.MOBILE,3);
          mBrick.setXVelocity(sign * mBrick.getWidth() / 30);
          mBrick.setGlobalBrickMatrixIndex(i,j);
          mBricks[i][j]=mBrick;
          mMobileBricks.add(mBrick);
        }
 else         if ((prob - Brick.MOBILE_BRICK_PROBABILITY) <= Brick.EXPLOSIVE_BRICK_PROBABILITY) {
          mBricks[i][j]=new Brick(Colors.RED_GRADIENT,newPosX,newPosY,0.1f,Type.EXPLOSIVE);
        }
 else {
          mBricks[i][j]=new Brick(Colors.GRAY_GRADIENT,newPosX,newPosY,0.1f,Type.HARD);
        }
      }
 else {
        mBricks[i][j]=new Brick(Colors.RAINBOW,newPosX,newPosY,0.1f,Type.NORMAL);
      }
      newPosX+=spaceX;
    }
    newPosX=initialX;
    newPosY-=spaceY;
  }
}","private void createLevel(int blocksX,int blocksY,float initialX,float initialY,float spaceX,float spaceY){
  mBricks=new Brick[blocksX][blocksY];
  float newPosX=initialX;
  float newPosY=initialY;
  float width=(Brick.VERTICES[4] - Brick.VERTICES[0]) * Brick.scale;
  for (int i=0; i < mBricks.length; i++) {
    float sign=1;
    for (int j=0; j < mBricks[i].length; j++) {
      sign*=-1;
      double prob=Math.random();
      if (prob <= (Brick.MOBILE_BRICK_PROBABILITY + Brick.EXPLOSIVE_BRICK_PROBABILITY + Brick.GRAY_BRICK_PROBABILITY)) {
        if (prob <= Brick.MOBILE_BRICK_PROBABILITY) {
          MobileBrick mBrick=new MobileBrick(Colors.GREEN_GRADIENT,newPosX,newPosY,Brick.scale,Type.MOBILE,3);
          mBrick.setXVelocity(sign * mBrick.getWidth() / 30);
          mBrick.setGlobalBrickMatrixIndex(i,j);
          mBricks[i][j]=mBrick;
          mMobileBricks.add(mBrick);
        }
 else         if ((prob - Brick.MOBILE_BRICK_PROBABILITY) <= Brick.EXPLOSIVE_BRICK_PROBABILITY) {
          mBricks[i][j]=new Brick(Colors.RED_GRADIENT,newPosX,newPosY,Brick.scale,Type.EXPLOSIVE);
        }
 else {
          mBricks[i][j]=new Brick(Colors.GRAY_GRADIENT,newPosX,newPosY,Brick.scale,Type.HARD);
        }
      }
 else {
        mBricks[i][j]=new Brick(Colors.RAINBOW,newPosX,newPosY,Brick.scale,Type.NORMAL);
      }
      newPosX+=spaceX;
    }
    newPosX=initialX;
    newPosY-=spaceY;
  }
}",0.9523110785033015
91116,"public boolean detectCollisionWithBrick(Brick other){
  if (this.getTopY() >= other.getBottomY() && this.getBottomY() <= other.getTopY() && this.getRightX() >= other.getLeftX() && this.getLeftX() <= other.getRightX()) {
    if (this.getLeftX() < other.getLeftX())     Log.d(TAG,""String_Node_Str"" + mIndexI + ""String_Node_Str""+ mIndexJ+ ""String_Node_Str"");
 else     Log.d(TAG,""String_Node_Str"" + mIndexI + ""String_Node_Str""+ mIndexJ+ ""String_Node_Str"");
    collided=true;
    return true;
  }
 else   return false;
}","public boolean detectCollisionWithBrick(Brick other){
  if (mToWait > 0)   return false;
  if (this.getTopY() >= other.getBottomY() && this.getBottomY() <= other.getTopY() && this.getRightX() >= other.getLeftX() && this.getLeftX() <= other.getRightX()) {
    if (this.getLeftX() < other.getLeftX()) {
      if (mXVelocity < 0)       mXVelocity*=-1;
      Log.d(TAG,""String_Node_Str"" + mIndexI + ""String_Node_Str""+ mIndexJ+ ""String_Node_Str"");
    }
 else {
      if (mXVelocity > 0)       mXVelocity*=-1;
      Log.d(TAG,""String_Node_Str"" + mIndexI + ""String_Node_Str""+ mIndexJ+ ""String_Node_Str"");
    }
    collided=true;
    return true;
  }
 else   return false;
}",0.8658227848101265
91117,"public boolean detectCollisionWithWall(){
  if ((this.getRightX() >= Game.sScreenHigherX) || (this.getLeftX() <= Game.sScreenLowerX)) {
    if (this.getRightX() >= Game.sScreenHigherX)     Log.d(TAG,""String_Node_Str"" + mIndexI + ""String_Node_Str""+ mIndexJ+ ""String_Node_Str"");
 else     Log.d(TAG,""String_Node_Str"" + mIndexI + ""String_Node_Str""+ mIndexJ+ ""String_Node_Str"");
    collided=true;
    return true;
  }
 else   return false;
}","public boolean detectCollisionWithWall(){
  if (mToWait > 0)   return false;
  if ((this.getRightX() >= Game.sScreenHigherX) || (this.getLeftX() <= Game.sScreenLowerX)) {
    if (this.getRightX() >= Game.sScreenHigherX) {
      if (mXVelocity < 0)       mXVelocity*=-1;
      Log.d(TAG,""String_Node_Str"" + mIndexI + ""String_Node_Str""+ mIndexJ+ ""String_Node_Str"");
    }
 else {
      if (mXVelocity > 0)       mXVelocity*=-1;
      Log.d(TAG,""String_Node_Str"" + mIndexI + ""String_Node_Str""+ mIndexJ+ ""String_Node_Str"");
    }
    collided=true;
    return true;
  }
 else   return false;
}",0.8451801363193768
91118,"private Collision detectColision(){
  if ((mBall.getRightX() >= mScreenHigherX) || (mBall.getLeftX() <= mScreenLowerX)) {
    return Collision.WALL_RIGHT_LEFT_SIDE;
  }
 else   if ((mBall.getTopY() >= mScreenHigherY) || (mBall.getBottomY() <= mScreenLowerY) && Config.INVICIBILITY) {
    return Collision.WALL_TOP_BOTTOM_SIDE;
  }
 else   if (mBall.getBottomY() <= mScreenLowerY && !Config.INVICIBILITY) {
    return Collision.LIFE_LOST;
  }
  Log.v(TAG,mBall.toString());
  if (mBall.getTopY() >= mPaddle.getBottomY() && mBall.getBottomY() <= mPaddle.getTopY() && mBall.getRightX() >= mPaddle.getLeftX() && mBall.getLeftX() <= mPaddle.getRightX()) {
    updateScoreMultiplier(ScoreMultiplier.PADDLE_HIT);
    return Collision.PADDLE_BALL;
  }
  for (int i=0; i < mBricks.length; i++) {
    for (int j=0; j < mBricks[i].length; j++) {
      Brick brick=mBricks[i][j];
      if (brick != null) {
        if (mBall.getTopY() >= brick.getBottomY() && mBall.getBottomY() <= brick.getTopY() && mBall.getRightX() >= brick.getLeftX() && mBall.getLeftX() <= brick.getRightX()) {
          Log.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ j+ ""String_Node_Str"");
          mBricks[i][j]=null;
          sScore+=100 * sScoreMultiplier;
          Log.i(TAG,""String_Node_Str"" + sScoreMultiplier + ""String_Node_Str""+ sScore);
          updateScoreMultiplier(ScoreMultiplier.BRICK_HIT);
          return Collision.PADDLE_BRICK;
        }
      }
    }
  }
  return Collision.NOT_AVAILABLE;
}","private Collision detectColision(){
  if ((mBall.getRightX() >= sScreenHigherX) || (mBall.getLeftX() <= sScreenLowerX)) {
    return Collision.WALL_RIGHT_LEFT_SIDE;
  }
 else   if ((mBall.getTopY() >= sScreenHigherY) || (mBall.getBottomY() <= sScreenLowerY) && Config.INVICIBILITY) {
    return Collision.WALL_TOP_BOTTOM_SIDE;
  }
 else   if (mBall.getBottomY() <= sScreenLowerY && !Config.INVICIBILITY) {
    return Collision.LIFE_LOST;
  }
  Log.v(TAG,mBall.toString());
  if (mBall.getTopY() >= mPaddle.getBottomY() && mBall.getBottomY() <= mPaddle.getTopY() && mBall.getRightX() >= mPaddle.getLeftX() && mBall.getLeftX() <= mPaddle.getRightX()) {
    updateScoreMultiplier(ScoreMultiplier.PADDLE_HIT);
    return Collision.PADDLE_BALL;
  }
  for (int i=0; i < mBricks.length; i++) {
    for (int j=0; j < mBricks[i].length; j++) {
      Brick brick=mBricks[i][j];
      if (brick != null) {
        if (mBall.getTopY() >= brick.getBottomY() && mBall.getBottomY() <= brick.getTopY() && mBall.getRightX() >= brick.getLeftX() && mBall.getLeftX() <= brick.getRightX()) {
          Log.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ j+ ""String_Node_Str"");
          mBricks[i][j]=null;
          sScore+=100 * sScoreMultiplier;
          Log.i(TAG,""String_Node_Str"" + sScoreMultiplier + ""String_Node_Str""+ sScore);
          updateScoreMultiplier(ScoreMultiplier.BRICK_HIT);
          return Collision.PADDLE_BRICK;
        }
      }
    }
  }
  return Collision.NOT_AVAILABLE;
}",0.9966216216216216
91119,"public void resetElements(){
  sScore=0;
  sLifes=Config.LIFE_COUNT;
  updateScoreMultiplier(ScoreMultiplier.RESTART_LEVEL);
  mPaddle=new Paddle(Colors.RAINBOW,0.0f,-0.7f,0.1f);
  Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + mPaddle.getBottomY() + ""String_Node_Str""+ mPaddle.getTopY()+ ""String_Node_Str""+ mPaddle.getLeftX()+ ""String_Node_Str""+ mPaddle.getRightX());
  mBall=new Ball(Colors.RAINBOW,0.0f,0.0f,-0.02f,-0.05f,0.1f,0.01f);
  Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + mBall.getBottomY() + ""String_Node_Str""+ mBall.getTopY()+ ""String_Node_Str""+ mBall.getLeftX()+ ""String_Node_Str""+ mBall.getRightX());
  createLevel(Colors.RAINBOW,8,12,-0.55f,0.7f,0.1f,0.04f);
}","public void resetElements(){
  sScreenHigherX=1.0f;
  sScreenLowerX=-1.0f;
  sScreenHigherY=1.0f;
  sScreenLowerY=-1.0f;
  sScore=0;
  sLifes=Config.LIFE_COUNT;
  updateScoreMultiplier(ScoreMultiplier.RESTART_LEVEL);
  mPaddle=new Paddle(Colors.RAINBOW,0.0f,-0.7f,0.1f);
  Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + mPaddle.getBottomY() + ""String_Node_Str""+ mPaddle.getTopY()+ ""String_Node_Str""+ mPaddle.getLeftX()+ ""String_Node_Str""+ mPaddle.getRightX());
  mBall=new Ball(Colors.RAINBOW,0.0f,0.0f,-0.02f,-0.05f,0.1f,0.01f);
  Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + mBall.getBottomY() + ""String_Node_Str""+ mBall.getTopY()+ ""String_Node_Str""+ mBall.getLeftX()+ ""String_Node_Str""+ mBall.getRightX());
  createLevel(Colors.RAINBOW,8,12,-0.55f,0.7f,0.1f,0.04f);
}",0.9371584699453552
91120,"public void updateScreenMeasures(float screenWidth,float screenHeight){
  Log.i(TAG,""String_Node_Str"" + screenWidth + ""String_Node_Str""+ screenHeight);
  mScreenLowerX=SCREEN_INITIAL_X - screenWidth / 2;
  mScreenHigherX=SCREEN_INITIAL_X + screenWidth / 2;
  mScreenLowerY=SCREEN_INITIAL_Y - screenHeight / 2;
  mScreenHigherY=SCREEN_INITIAL_Y + screenHeight / 2;
  Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"" + mScreenLowerX + ""String_Node_Str""+ mScreenHigherX+ ""String_Node_Str""+ mScreenLowerY+ ""String_Node_Str""+ mScreenHigherY);
}","public void updateScreenMeasures(float screenWidth,float screenHeight){
  Log.i(TAG,""String_Node_Str"" + screenWidth + ""String_Node_Str""+ screenHeight);
  sScreenLowerX=SCREEN_INITIAL_X - screenWidth / 2;
  sScreenHigherX=SCREEN_INITIAL_X + screenWidth / 2;
  sScreenLowerY=SCREEN_INITIAL_Y - screenHeight / 2;
  sScreenHigherY=SCREEN_INITIAL_Y + screenHeight / 2;
  Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"" + sScreenLowerX + ""String_Node_Str""+ sScreenHigherX+ ""String_Node_Str""+ sScreenLowerY+ ""String_Node_Str""+ sScreenHigherY);
}",0.9851301115241636
91121,"public void setPosX(float x){
  mPosX=x;
}","public void setPosX(float x){
  if (x >= Game.sScreenLowerX && x <= Game.sScreenHigherX) {
    mPosX=x;
  }
 else   if (x < Game.sScreenLowerX) {
    mPosX=Game.sScreenLowerX;
  }
 else   if (x > Game.sScreenHigherX) {
    mPosX=Game.sScreenHigherX;
  }
}",0.2760942760942761
91122,"public void setPosY(float y){
  mPosY=y;
}","public void setPosY(float y){
  if (y >= Game.sScreenLowerY && y <= Game.sScreenHigherY) {
    mPosY=y;
  }
 else   if (y < Game.sScreenLowerY) {
    mPosY=Game.sScreenLowerY;
  }
 else   if (y > Game.sScreenHigherY) {
    mPosY=Game.sScreenHigherY;
  }
}",0.2760942760942761
91123,"private Collision detectColision(){
  float paddleLeftX=mPaddle.getLeftX();
  float paddleRightX=mPaddle.getRightX();
  float paddleTopY=mPaddle.getTopY();
  if ((mBall.getRightX() >= SCREEN_HIGHER_X) || (mBall.getLeftX() <= SCREEN_LOWER_X)) {
    return Collision.WALL_RIGHT_LEFT_SIDE;
  }
 else   if ((mBall.getTopY() >= SCREEN_HIGHER_Y) || (mBall.getBottomY() <= SCREEN_LOWER_Y)) {
    return Collision.WALL_TOP_BOTTOM_SIDE;
  }
  Log.v(TAG,mBall.toString());
  if ((mBall.getBottomY() <= paddleTopY) && (((mBall.getLeftX() < paddleLeftX) && (mBall.getRightX() >= paddleLeftX)) || ((mBall.getLeftX() <= paddleLeftX) && (mBall.getRightX() < paddleRightX)) || ((mBall.getLeftX() >= paddleLeftX) && (mBall.getRightX() <= paddleRightX)))) {
    if (mBall.getDirection() == BallDirection.RIGHT_DOWNWARD) {
      return Collision.PADDLE_BALL_FROM_LEFT;
    }
 else     if (mBall.getDirection() == BallDirection.LEFT_DOWNWARD) {
      return Collision.PADDLE_BALL_FROM_RIGHT;
    }
  }
  for (  Brick bricks[] : mBricks) {
    for (    Brick brick : bricks) {
    }
  }
  return Collision.NOT_AVAILABLE;
}","private Collision detectColision(){
  float paddleLeftX=mPaddle.getLeftX();
  float paddleRightX=mPaddle.getRightX();
  float paddleTopY=mPaddle.getTopY();
  if ((mBall.getRightX() >= SCREEN_HIGHER_X) || (mBall.getLeftX() <= SCREEN_LOWER_X)) {
    return Collision.WALL_RIGHT_LEFT_SIDE;
  }
 else   if ((mBall.getTopY() >= SCREEN_HIGHER_Y) || (mBall.getBottomY() <= SCREEN_LOWER_Y)) {
    return Collision.WALL_TOP_BOTTOM_SIDE;
  }
  Log.v(TAG,mBall.toString());
  if ((mBall.getBottomY() <= paddleTopY) && (((mBall.getLeftX() < paddleLeftX) && (mBall.getRightX() >= paddleLeftX)) || ((mBall.getLeftX() <= paddleLeftX) && (mBall.getRightX() > paddleRightX)) || ((mBall.getLeftX() >= paddleLeftX) && (mBall.getRightX() <= paddleRightX)))) {
    if (mBall.getDirection() == BallDirection.RIGHT_DOWNWARD) {
      return Collision.PADDLE_BALL_FROM_LEFT;
    }
 else     if (mBall.getDirection() == BallDirection.LEFT_DOWNWARD) {
      return Collision.PADDLE_BALL_FROM_RIGHT;
    }
  }
  for (  Brick bricks[] : mBricks) {
    for (    Brick brick : bricks) {
    }
  }
  return Collision.NOT_AVAILABLE;
}",0.9990917347865576
91124,"public void updateState(float deltaTime){
  mBall.setBallSpeed(deltaTime);
  Collision collisionType=detectColision();
switch (collisionType) {
case WALL_RIGHT_LEFT_SIDE:
    Log.d(TAG,""String_Node_Str"");
  mBall.turnToPerpendicularDirection(true);
break;
case WALL_TOP_BOTTOM_SIDE:
Log.d(TAG,""String_Node_Str"");
mBall.turnToPerpendicularDirection(false);
break;
default :
break;
}
mBall.move();
}","public void updateState(){
  Collision collisionType=detectColision();
switch (collisionType) {
case WALL_RIGHT_LEFT_SIDE:
    Log.d(TAG,""String_Node_Str"");
  mBall.turnToPerpendicularDirection(true);
break;
case WALL_TOP_BOTTOM_SIDE:
Log.d(TAG,""String_Node_Str"");
mBall.turnToPerpendicularDirection(false);
break;
default :
break;
}
mBall.move();
}",0.935656836461126
91125,"public void drawElements(GL10 gl){
  mPaddle.draw(gl);
  mBall.draw(gl);
  for (int i=0; i < mBlocks.length; i++) {
    for (int j=0; j < mBlocks[i].length; j++) {
      mBlocks[i][j].draw(gl);
    }
  }
}","public void drawElements(GL10 gl,float deltaTime){
  mPaddle.draw(gl);
  mBall.draw(gl);
  for (int i=0; i < mBlocks.length; i++) {
    for (int j=0; j < mBlocks[i].length; j++) {
      mBlocks[i][j].draw(gl);
    }
  }
  mBall.setBallSpeed(deltaTime);
}",0.8932461873638344
91126,"@Override public void onDrawFrame(GL10 gl){
  long currentTime=System.nanoTime();
  long deltaTime=(currentTime - mPrevFrameTime) / Constants.NANOS_PER_SECONDS;
  mPrevFrameTime=currentTime;
  Log.v(TAG,""String_Node_Str"" + Constants.MS_PER_SECONDS / deltaTime);
  gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
  mGame.updateState(deltaTime < Constants.MS_PER_FRAME ? deltaTime : Constants.MS_PER_FRAME);
  mGame.drawElements(gl);
}","@Override public void onDrawFrame(GL10 gl){
  long currentTime=System.nanoTime();
  long deltaTime=(currentTime - mPrevFrameTime) / Constants.NANOS_PER_SECONDS;
  mPrevFrameTime=currentTime;
  Log.v(TAG,""String_Node_Str"" + Constants.MS_PER_SECONDS / deltaTime);
  gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
  mGame.updateState();
  mGame.drawElements(gl,deltaTime < Constants.MS_PER_FRAME ? deltaTime : Constants.MS_PER_FRAME);
}",0.9374262101534828
91127,"@Override public void onSurfaceChanged(GL10 gl,int width,int height){
  gl.glViewport(0,0,width,height);
  mScreenWidth=width;
  mScreenHeight=height;
  float ratio=(float)width / height;
  mGame.updateScreenMeasures(2 * (ratio - WALL),2.0f - WALL);
  gl.glMatrixMode(GL10.GL_PROJECTION);
  gl.glLoadIdentity();
  gl.glOrthof(-ratio,ratio,-1.0f,1.0f,-1.0f,1.0f);
  Matrix.orthoM(mUnprojectProjMatrix,0,-ratio,ratio,-1.0f,1.0f,-1.0f,1.0f);
  Matrix.setIdentityM(mUnprojectViewMatrix,0);
}","@Override public void onSurfaceChanged(GL10 gl,int width,int height){
  gl.glViewport(0,0,width,height);
  mScreenWidth=width;
  mScreenHeight=height;
  float ratio=(float)width / height;
  mGame.updateScreenMeasures((2.0f * ratio) - WALL,2.0f - WALL);
  gl.glMatrixMode(GL10.GL_PROJECTION);
  gl.glLoadIdentity();
  gl.glOrthof(-ratio,ratio,-1.0f,1.0f,-1.0f,1.0f);
  Matrix.orthoM(mUnprojectProjMatrix,0,-ratio,ratio,-1.0f,1.0f,-1.0f,1.0f);
  Matrix.setIdentityM(mUnprojectViewMatrix,0);
}",0.9825997952917092
91128,"private void syncGUIElements(){
  intervalPercent=(int)(((float)tile.intervalReset / (float)((tile.interval + 1) * 20)) * 200);
  progressBar=(int)((float)intervalPercent * 0.7F);
  if (progressBar <= 7) {
    progressVertical=progressBar;
    progressHorizontal=0;
  }
 else {
    progressVertical=7;
    progressHorizontal=progressBar - 6;
  }
  if (intervalPercent >= 100 && intervalPercent <= 200) {
    burstOffset=(int)(((float)tile.intervalReset / (float)((tile.interval + 1) * 20)) * 20) - 11;
  }
 else {
    burstOffset=0;
  }
  guiParticle=(int)((float)(intervalPercent - 100));
  if (tile.interval <= 1) {
    guiParticle=guiParticle + 3;
  }
  fuelLoadVertical=0;
  fuelLoadhorizontal=0;
}","private void syncGUIElements(){
  intervalPercent=(int)(((float)tile.intervalReset / (float)((tile.interval + 1) * 20)) * 200);
  if (intervalPercent <= 100) {
    progressBar=(int)((float)intervalPercent * 0.7F);
    if (progressBar <= 7) {
      progressVertical=progressBar;
      progressHorizontal=0;
    }
 else {
      progressVertical=7;
      progressHorizontal=progressBar - 6;
    }
  }
 else {
    progressVertical=7;
    progressHorizontal=64;
  }
  if (intervalPercent >= 100 && intervalPercent <= 200) {
    burstOffset=(int)(((float)tile.intervalReset / (float)((tile.interval + 1) * 20)) * 20) - 11;
  }
 else {
    burstOffset=0;
  }
  if (intervalPercent <= 113) {
    guiParticle=(int)((float)(intervalPercent - 100));
  }
 else {
    guiParticle=13;
  }
  System.out.println(""String_Node_Str"" + guiParticle);
  if (tile.interval <= 1) {
    guiParticle=guiParticle + 3;
  }
  fuelLoadVertical=0;
  fuelLoadhorizontal=0;
}",0.8540145985401459
91129,"public void markRawNotifications(List<StoredRawNotification<Long,String>> list,ProcessingStatus processingStatus) throws IngestException {
  Connection connection=null;
  PreparedStatement statement=null;
  try {
    if (list != null && list.size() > 0) {
      connection=getConnection();
      StringBuilder sqlStatementBuilder=new StringBuilder(STATEMENT_UPDATE_RAW_NOTIF_STATUS);
      int listSize=list.size();
      for (int i=0; i < listSize - 1; i++) {
        sqlStatementBuilder.append(""String_Node_Str"");
      }
      sqlStatementBuilder.append(""String_Node_Str"");
      statement=connection.prepareStatement(sqlStatementBuilder.toString());
      statement.setString(1,processingStatus.toString());
      int counter=2;
      for (      StoredRawNotification<Long,String> storedRawNotification : list) {
        Long internalIDObj=storedRawNotification.getInternalID();
        statement.setLong(counter,internalIDObj);
        counter++;
      }
      long startTime=0;
      if (plog.isTraceEnabled())       startTime=System.currentTimeMillis();
      int result=statement.executeUpdate();
      if (plog.isTraceEnabled())       plog.trace(""String_Node_Str"" + (System.currentTimeMillis() - startTime));
      statement.close();
      if (log.isDebugEnabled())       log.debug(""String_Node_Str"" + processingStatus.toString() + ""String_Node_Str""+ result);
    }
  }
 catch (  SQLException sqle) {
    throw new IngestException(sqle);
  }
 finally {
    if (statement != null) {
      try {
        statement.close();
      }
 catch (      SQLException e) {
        log.warn(""String_Node_Str"",e);
      }
      statement=null;
    }
    connectionPool.releaseEntry(connection);
  }
}","public void markRawNotifications(List<StoredRawNotification<Long,String>> list,ProcessingStatus processingStatus) throws IngestException {
  Connection connection=null;
  PreparedStatement statement=null;
  try {
    if (list != null && list.size() > 0) {
      connection=getConnection();
      StringBuilder sqlStatementBuilder=new StringBuilder(STATEMENT_UPDATE_RAW_NOTIF_STATUS);
      int listSize=list.size();
      for (int i=0; i < listSize - 1; i++) {
        sqlStatementBuilder.append(""String_Node_Str"");
      }
      sqlStatementBuilder.append(""String_Node_Str"");
      statement=connection.prepareStatement(sqlStatementBuilder.toString());
      statement.setString(1,processingStatus.toString());
      int counter=2;
      for (      StoredRawNotification<Long,String> storedRawNotification : list) {
        Long internalIDObj=storedRawNotification.getInternalID();
        statement.setLong(counter,internalIDObj);
        counter++;
      }
      long startTime=0;
      if (plog.isTraceEnabled())       startTime=System.currentTimeMillis();
      int result=statement.executeUpdate();
      if (plog.isTraceEnabled())       plog.trace(""String_Node_Str"" + (System.currentTimeMillis() - startTime));
      statement.close();
      if (log.isDebugEnabled())       log.debug(""String_Node_Str"" + processingStatus.toString() + ""String_Node_Str""+ result);
    }
  }
 catch (  SQLException sqle) {
    throw new IngestException(sqle);
  }
 finally {
    if (statement != null) {
      try {
        statement.close();
      }
 catch (      SQLException e) {
        log.warn(""String_Node_Str"",e);
      }
    }
    connectionPool.releaseEntry(connection);
  }
}",0.9934679334916864
91130,"protected IngestionResult addNewFileEntity(EntityType entityInfo,Connection connection) throws IngestException, SQLException {
  FileType file=entityInfo.getFile();
  AgentType ownerAgent=AgentType.Factory.newInstance();
  UserAgentType user=UserAgentType.Factory.newInstance();
  user.setAgentID(file.getOwnerDN());
  ownerAgent.setUserAgent(user);
  ownerAgent.setType(AgentEnumType.OTHER);
  IngestionResult ownerResult=addNewAgent(ownerAgent,connection);
  IngestionResult ingestionResult=null;
  if (KomaduUtils.manageDBLock(DBLockConstants.LOCK_ACQUIRE,file.getFileURI(),connection)) {
    Long baseEntityId=addNewBaseEntity(EntityTypeEnum.FILE,entityInfo.getAttributes(),entityInfo.getRole(),entityInfo.getLocation(),connection);
    TupleData tuple=new TupleData();
    tuple.addAttribute(""String_Node_Str"",baseEntityId,TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",file.getFileURI(),TableAttributeData.DataType.STRING);
    tuple.addAttribute(""String_Node_Str"",ownerResult.getDbId(),TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",KomaduUtils.getTimestamp(file.getCreateDate()),TableAttributeData.DataType.TIMESTAMP);
    tuple.addAttribute(""String_Node_Str"",file.getSize(),TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",file.getMd5Sum(),TableAttributeData.DataType.STRING);
    tuple.addAttribute(""String_Node_Str"",file.getFileName(),TableAttributeData.DataType.STRING);
    Long fileId=insertTuple(""String_Node_Str"",tuple,""String_Node_Str"",connection);
    ingestionResult=new IngestionResult(file.getFileURI(),fileId);
    KomaduUtils.manageDBLock(DBLockConstants.LOCK_RELEASE,file.getFileURI(),connection);
  }
  return ingestionResult;
}","protected IngestionResult addNewFileEntity(EntityType entityInfo,Connection connection) throws IngestException, SQLException {
  FileType file=entityInfo.getFile();
  IngestionResult ownerResult=null;
  if (file.getOwnerDN() != null) {
    AgentType ownerAgent=AgentType.Factory.newInstance();
    UserAgentType user=UserAgentType.Factory.newInstance();
    user.setAgentID(file.getOwnerDN());
    ownerAgent.setUserAgent(user);
    ownerAgent.setType(AgentEnumType.OTHER);
    ownerResult=addNewAgent(ownerAgent,connection);
  }
  IngestionResult ingestionResult=null;
  if (KomaduUtils.manageDBLock(DBLockConstants.LOCK_ACQUIRE,file.getFileURI(),connection)) {
    Long baseEntityId=addNewBaseEntity(EntityTypeEnum.FILE,entityInfo.getAttributes(),entityInfo.getRole(),entityInfo.getLocation(),connection);
    TupleData tuple=new TupleData();
    tuple.addAttribute(""String_Node_Str"",baseEntityId,TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",file.getFileURI(),TableAttributeData.DataType.STRING);
    if (ownerResult != null)     tuple.addAttribute(""String_Node_Str"",ownerResult.getDbId(),TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",KomaduUtils.getTimestamp(file.getCreateDate()),TableAttributeData.DataType.TIMESTAMP);
    tuple.addAttribute(""String_Node_Str"",file.getSize(),TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",file.getMd5Sum(),TableAttributeData.DataType.STRING);
    tuple.addAttribute(""String_Node_Str"",file.getFileName(),TableAttributeData.DataType.STRING);
    Long fileId=insertTuple(""String_Node_Str"",tuple,""String_Node_Str"",connection);
    ingestionResult=new IngestionResult(file.getFileURI(),fileId);
    KomaduUtils.manageDBLock(DBLockConstants.LOCK_RELEASE,file.getFileURI(),connection);
  }
  return ingestionResult;
}",0.9563758389261744
91131,"protected void cacheRawNotificationsFromDB(ProcessingFilterType processingFilterType) throws SQLException, IngestException {
  Connection connection=null;
  List<StoredRawNotification<Long,String>> workList=null;
  PreparedStatement statement=null;
  ResultSet resultSet=null;
  PreparedStatement updateStatement=null;
  try {
    connection=getConnection();
    StringBuilder sqlStatementBuilder;
    String selectFilter;
    if (ProcessingFilterType.KNOWN_TYPES.equals(processingFilterType)) {
      sqlStatementBuilder=new StringBuilder(STATEMENT_SELECT_KNOWN_NOTIF);
      selectFilter=ProcessingFilterType.UNKNOWN_TYPES.name();
      workList=rawKnownNotificationCache;
    }
 else {
      sqlStatementBuilder=new StringBuilder(STATEMENT_SELECT_UNKNOWN_NOTIF);
      selectFilter=processingFilterType.name();
      workList=rawUnknownNotificationCache;
    }
    statement=connection.prepareStatement(sqlStatementBuilder.toString());
    statement.setString(1,ProcessingStatus.RAW.name());
    statement.setString(2,selectFilter);
    statement.setInt(3,rawNotificationCacheSize);
    long startTime=0;
    if (plog.isTraceEnabled())     startTime=System.currentTimeMillis();
    resultSet=statement.executeQuery();
    if (plog.isTraceEnabled())     plog.trace(""String_Node_Str"" + (System.currentTimeMillis() - startTime));
    StringBuilder updateStatementBuilder=new StringBuilder(STATEMENT_UPDATE_RAW_NOTIF_STATUS);
    List<Long> internalIDList=new ArrayList<Long>();
    while (resultSet.next()) {
      long internalID=resultSet.getLong(""String_Node_Str"");
      internalIDList.add(internalID);
      String notificationTypeString=resultSet.getString(""String_Node_Str"");
      String notification=resultSet.getString(""String_Node_Str"");
      BaseDBStoredRawNotification storedRawNotification=new BaseDBStoredRawNotification(internalID,NotificationTypeEnum.valueOf(notificationTypeString),notification);
      workList.add(storedRawNotification);
    }
    int listSize=internalIDList.size();
    if (listSize > 0) {
      for (int i=0; i < listSize - 1; i++) {
        updateStatementBuilder.append(""String_Node_Str"");
      }
      updateStatementBuilder.append(""String_Node_Str"");
      updateStatement=connection.prepareStatement(updateStatementBuilder.toString());
      updateStatement.setString(1,ProcessingStatus.PROCESSING.name());
      int index=2;
      for (      Long id : internalIDList) {
        updateStatement.setLong(index++,id);
      }
      if (plog.isTraceEnabled())       startTime=System.currentTimeMillis();
      int result=updateStatement.executeUpdate();
      if (plog.isTraceEnabled())       plog.trace(""String_Node_Str"" + (System.currentTimeMillis() - startTime));
      if (result != listSize) {
        throw new IngestException(""String_Node_Str"" + listSize + ""String_Node_Str""+ result);
      }
    }
  }
 catch (  SQLException sqle) {
    throw new IngestException(sqle);
  }
 finally {
    if (updateStatement != null) {
      updateStatement.close();
    }
    if (resultSet != null) {
      resultSet.close();
    }
    if (statement != null) {
      statement.close();
    }
    connectionPool.releaseEntry(connection);
  }
}","protected void cacheRawNotificationsFromDB(ProcessingFilterType processingFilterType) throws SQLException, IngestException {
  Connection connection=null;
  List<StoredRawNotification<Long,String>> workList;
  PreparedStatement statement=null;
  ResultSet resultSet=null;
  PreparedStatement updateStatement=null;
  try {
    connection=getConnection();
    StringBuilder sqlStatementBuilder;
    String selectFilter;
    if (ProcessingFilterType.KNOWN_TYPES.equals(processingFilterType)) {
      sqlStatementBuilder=new StringBuilder(STATEMENT_SELECT_KNOWN_NOTIF);
      selectFilter=ProcessingFilterType.UNKNOWN_TYPES.name();
      workList=rawKnownNotificationCache;
    }
 else {
      sqlStatementBuilder=new StringBuilder(STATEMENT_SELECT_UNKNOWN_NOTIF);
      selectFilter=processingFilterType.name();
      workList=rawUnknownNotificationCache;
    }
    statement=connection.prepareStatement(sqlStatementBuilder.toString());
    statement.setString(1,ProcessingStatus.RAW.name());
    statement.setString(2,selectFilter);
    statement.setInt(3,rawNotificationCacheSize);
    long startTime=0;
    if (plog.isTraceEnabled())     startTime=System.currentTimeMillis();
    resultSet=statement.executeQuery();
    if (plog.isTraceEnabled())     plog.trace(""String_Node_Str"" + (System.currentTimeMillis() - startTime));
    StringBuilder updateStatementBuilder=new StringBuilder(STATEMENT_UPDATE_RAW_NOTIF_STATUS);
    List<Long> internalIDList=new ArrayList<Long>();
    while (resultSet.next()) {
      long internalID=resultSet.getLong(""String_Node_Str"");
      internalIDList.add(internalID);
      String notificationTypeString=resultSet.getString(""String_Node_Str"");
      String notification=resultSet.getString(""String_Node_Str"");
      BaseDBStoredRawNotification storedRawNotification=new BaseDBStoredRawNotification(internalID,NotificationTypeEnum.valueOf(notificationTypeString),notification);
      workList.add(storedRawNotification);
    }
    int listSize=internalIDList.size();
    if (listSize > 0) {
      for (int i=0; i < listSize - 1; i++) {
        updateStatementBuilder.append(""String_Node_Str"");
      }
      updateStatementBuilder.append(""String_Node_Str"");
      updateStatement=connection.prepareStatement(updateStatementBuilder.toString());
      updateStatement.setString(1,ProcessingStatus.PROCESSING.name());
      int index=2;
      for (      Long id : internalIDList) {
        updateStatement.setLong(index++,id);
      }
      if (plog.isTraceEnabled())       startTime=System.currentTimeMillis();
      int result=updateStatement.executeUpdate();
      if (plog.isTraceEnabled())       plog.trace(""String_Node_Str"" + (System.currentTimeMillis() - startTime));
      if (result != listSize) {
        throw new IngestException(""String_Node_Str"" + listSize + ""String_Node_Str""+ result);
      }
    }
  }
 catch (  SQLException sqle) {
    throw new IngestException(sqle);
  }
 finally {
    if (updateStatement != null) {
      updateStatement.close();
    }
    if (resultSet != null) {
      resultSet.close();
    }
    if (statement != null) {
      statement.close();
    }
    connectionPool.releaseEntry(connection);
  }
}",0.9992127224059204
91132,"protected void addNewGeneration(GenerationType generation,Long activityId,Long entityId,Connection connection) throws IngestException, SQLException {
  TupleData tuple=new TupleData();
  tuple.addAttribute(""String_Node_Str"",activityId,TableAttributeData.DataType.LONG);
  tuple.addAttribute(""String_Node_Str"",entityId,TableAttributeData.DataType.LONG);
  tuple.addAttribute(""String_Node_Str"",generation.getLocation(),TableAttributeData.DataType.STRING);
  tuple.addAttribute(""String_Node_Str"",KomaduUtils.getTimestamp(generation.getTimestamp()),TableAttributeData.DataType.TIMESTAMP);
  Long generationId=insertTuple(""String_Node_Str"",tuple,""String_Node_Str"",connection);
  if (generation.getAttributes() != null) {
    addAttributes(""String_Node_Str"",""String_Node_Str"",generationId,generation.getAttributes().getAttributeArray(),connection);
  }
}","protected void addNewGeneration(GenerationType generation,Long activityId,Long entityId,Connection connection) throws IngestException, SQLException {
  TupleData tuple=new TupleData();
  tuple.addAttribute(""String_Node_Str"",activityId,TableAttributeData.DataType.LONG);
  tuple.addAttribute(""String_Node_Str"",entityId,TableAttributeData.DataType.LONG);
  if (generation.isSetLocation())   tuple.addAttribute(""String_Node_Str"",generation.getLocation(),TableAttributeData.DataType.STRING);
  if (generation.isSetTimestamp())   tuple.addAttribute(""String_Node_Str"",KomaduUtils.getTimestamp(generation.getTimestamp()),TableAttributeData.DataType.TIMESTAMP);
  Long generationId=insertTuple(""String_Node_Str"",tuple,""String_Node_Str"",connection);
  if (generation.getAttributes() != null) {
    addAttributes(""String_Node_Str"",""String_Node_Str"",generationId,generation.getAttributes().getAttributeArray(),connection);
  }
}",0.9609065155807366
91133,"protected IngestionResult addNewFileEntity(EntityType entityInfo,Connection connection) throws IngestException, SQLException {
  FileType file=entityInfo.getFile();
  IngestionResult ownerResult=null;
  if (file.getOwnerDN() != null) {
    AgentType ownerAgent=AgentType.Factory.newInstance();
    UserAgentType user=UserAgentType.Factory.newInstance();
    user.setAgentID(file.getOwnerDN());
    ownerAgent.setUserAgent(user);
    ownerAgent.setType(AgentEnumType.OTHER);
    ownerResult=addNewAgent(ownerAgent,connection);
  }
  IngestionResult ingestionResult=null;
  if (KomaduUtils.manageDBLock(DBLockConstants.LOCK_ACQUIRE,file.getFileURI(),connection)) {
    Long baseEntityId=addNewBaseEntity(EntityTypeEnum.FILE,entityInfo.getAttributes(),entityInfo.getRole(),entityInfo.getLocation(),connection);
    TupleData tuple=new TupleData();
    tuple.addAttribute(""String_Node_Str"",baseEntityId,TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",file.getFileURI(),TableAttributeData.DataType.STRING);
    if (ownerResult != null)     tuple.addAttribute(""String_Node_Str"",ownerResult.getDbId(),TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",KomaduUtils.getTimestamp(file.getCreateDate()),TableAttributeData.DataType.TIMESTAMP);
    tuple.addAttribute(""String_Node_Str"",file.getSize(),TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",file.getMd5Sum(),TableAttributeData.DataType.STRING);
    tuple.addAttribute(""String_Node_Str"",file.getFileName(),TableAttributeData.DataType.STRING);
    Long fileId=insertTuple(""String_Node_Str"",tuple,""String_Node_Str"",connection);
    ingestionResult=new IngestionResult(file.getFileURI(),fileId);
    KomaduUtils.manageDBLock(DBLockConstants.LOCK_RELEASE,file.getFileURI(),connection);
  }
  return ingestionResult;
}","protected IngestionResult addNewFileEntity(EntityType entityInfo,Connection connection) throws IngestException, SQLException {
  FileType file=entityInfo.getFile();
  IngestionResult ownerResult=null;
  if (file.getOwnerDN() != null) {
    AgentType ownerAgent=AgentType.Factory.newInstance();
    UserAgentType user=UserAgentType.Factory.newInstance();
    user.setAgentID(file.getOwnerDN());
    ownerAgent.setUserAgent(user);
    ownerAgent.setType(AgentEnumType.OTHER);
    ownerResult=addNewAgent(ownerAgent,connection);
  }
  IngestionResult ingestionResult=null;
  if (KomaduUtils.manageDBLock(DBLockConstants.LOCK_ACQUIRE,file.getFileURI(),connection)) {
    Long baseEntityId=addNewBaseEntity(EntityTypeEnum.FILE,entityInfo.getAttributes(),entityInfo.getRole(),entityInfo.getLocation(),connection);
    TupleData tuple=new TupleData();
    tuple.addAttribute(""String_Node_Str"",baseEntityId,TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",file.getFileURI(),TableAttributeData.DataType.STRING);
    if (ownerResult != null)     tuple.addAttribute(""String_Node_Str"",ownerResult.getDbId(),TableAttributeData.DataType.LONG);
    if (file.isSetCreateDate())     tuple.addAttribute(""String_Node_Str"",KomaduUtils.getTimestamp(file.getCreateDate()),TableAttributeData.DataType.TIMESTAMP);
    tuple.addAttribute(""String_Node_Str"",file.getSize(),TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",file.getMd5Sum(),TableAttributeData.DataType.STRING);
    tuple.addAttribute(""String_Node_Str"",file.getFileName(),TableAttributeData.DataType.STRING);
    Long fileId=insertTuple(""String_Node_Str"",tuple,""String_Node_Str"",connection);
    ingestionResult=new IngestionResult(file.getFileURI(),fileId);
    KomaduUtils.manageDBLock(DBLockConstants.LOCK_RELEASE,file.getFileURI(),connection);
  }
  return ingestionResult;
}",0.9913700107874864
91134,"/** 
 * Creates a prov entity using the given entity Id. First queries the exe_entity table to get the type of the entity and then queries the relevant table to get further information.
 * @param entityId - entity Id in the database
 * @return Entity instance or null if there's no such entity
 */
protected Entity createEntity(String entityId,Connection connection) throws SQLException {
  assert(entityId != null);
  l.debug(""String_Node_Str"");
  PreparedStatement stmt=null;
  ResultSet resultSet=null;
  Entity entity=null;
  try {
    stmt=connection.prepareStatement(PROVSqlQuery.GET_ENTITY_TYPE);
    stmt.setString(1,entityId);
    resultSet=stmt.executeQuery();
    String entityType;
    if (resultSet.next()) {
      entityType=resultSet.getString(""String_Node_Str"");
    }
 else {
      return null;
    }
    if (stmt != null) {
      stmt.close();
      stmt=null;
    }
    if (resultSet != null) {
      resultSet.close();
      resultSet=null;
    }
    if (entityType.equals(BaseDBIngesterImplementer.EntityTypeEnum.FILE.name())) {
      stmt=connection.prepareStatement(PROVSqlQuery.GET_FILE_BY_ID);
      stmt.setString(1,entityId);
      resultSet=stmt.executeQuery();
      while (resultSet.next()) {
        String fileURI=resultSet.getString(""String_Node_Str"");
        String size=resultSet.getString(""String_Node_Str"");
        String creationDate=resultSet.getString(""String_Node_Str"");
        String fileName=resultSet.getString(""String_Node_Str"");
        String md5=resultSet.getString(""String_Node_Str"");
        entity=newEntity(QueryConstants.FILE_IDENTIFIER + entityId,fileURI,QueryConstants.ENTITY_FILE);
        Other sizeAtt=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),size,Name.QNAME_XSD_STRING);
        pFactory.addAttribute(entity,sizeAtt);
        Other dateAtt=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),creationDate,Name.QNAME_XSD_STRING);
        pFactory.addAttribute(entity,dateAtt);
        Other nameAtt=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),fileName,Name.QNAME_XSD_STRING);
        pFactory.addAttribute(entity,nameAtt);
        Other md5Att=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),md5,Name.QNAME_XSD_STRING);
        pFactory.addAttribute(entity,md5Att);
        addCustomAttributes(PROVSqlQuery.GET_EXE_ENTITY_ATTRIBUTES_BY_ID,entityId,entity,connection);
      }
      if (stmt != null) {
        stmt.close();
        stmt=null;
      }
      if (resultSet != null) {
        resultSet.close();
        resultSet=null;
      }
    }
 else     if (entityType.equals(BaseDBIngesterImplementer.EntityTypeEnum.BLOCK.name())) {
      stmt=connection.prepareStatement(PROVSqlQuery.GET_BLOCK_BY_ID);
      stmt.setString(1,entityId);
      resultSet=stmt.executeQuery();
      while (resultSet.next()) {
        String blockUri=resultSet.getString(""String_Node_Str"");
        String size=resultSet.getString(""String_Node_Str"");
        String blockContent=resultSet.getString(""String_Node_Str"");
        String md5=resultSet.getString(""String_Node_Str"");
        entity=newEntity(QueryConstants.BLOCK_IDENTIFIER + entityId,blockUri,QueryConstants.ENTITY_BLOCK);
        Other sizeAtt=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),size,Name.QNAME_XSD_STRING);
        pFactory.addAttribute(entity,sizeAtt);
        Other contentAtt=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),blockContent,Name.QNAME_XSD_STRING);
        pFactory.addAttribute(entity,contentAtt);
        Other md5Att=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),md5,Name.QNAME_XSD_STRING);
        pFactory.addAttribute(entity,md5Att);
        addCustomAttributes(PROVSqlQuery.GET_EXE_ENTITY_ATTRIBUTES_BY_ID,entityId,entity,connection);
      }
      if (stmt != null) {
        stmt.close();
        stmt=null;
      }
      if (resultSet != null) {
        resultSet.close();
        resultSet=null;
      }
    }
 else     if (entityType.equals(BaseDBIngesterImplementer.EntityTypeEnum.COLLECTION.name())) {
      stmt=connection.prepareStatement(PROVSqlQuery.GET_COLLECTION_BY_ID);
      stmt.setString(1,entityId);
      resultSet=stmt.executeQuery();
      while (resultSet.next()) {
        String collectionUri=resultSet.getString(""String_Node_Str"");
        entity=newEntity(QueryConstants.COLLECTION_IDENTIFIER + entityId,collectionUri,QueryConstants.ENTITY_COLLECTION);
        addCustomAttributes(PROVSqlQuery.GET_EXE_ENTITY_ATTRIBUTES_BY_ID,entityId,entity,connection);
      }
      if (stmt != null) {
        stmt.close();
        stmt=null;
      }
      if (resultSet != null) {
        resultSet.close();
        resultSet=null;
      }
    }
 else     if (entityType.equals(BaseDBIngesterImplementer.EntityTypeEnum.GENERIC.name())) {
      stmt=connection.prepareStatement(PROVSqlQuery.GET_GENERIC_ENTITY_BY_ID);
      stmt.setString(1,entityId);
      resultSet=stmt.executeQuery();
      while (resultSet.next()) {
        String genericEntityUri=resultSet.getString(""String_Node_Str"");
        entity=newEntity(QueryConstants.FILE_IDENTIFIER + entityId,genericEntityUri,QueryConstants.ENTITY_BLOCK);
        addCustomAttributes(PROVSqlQuery.GET_EXE_ENTITY_ATTRIBUTES_BY_ID,entityId,entity,connection);
      }
      if (stmt != null) {
        stmt.close();
        stmt=null;
      }
      if (resultSet != null) {
        resultSet.close();
        resultSet=null;
      }
    }
    l.debug(""String_Node_Str"");
  }
 catch (  SQLException e) {
    l.error(""String_Node_Str"");
    l.error(e.toString());
  }
 finally {
    if (stmt != null) {
      stmt.close();
    }
    if (resultSet != null) {
      resultSet.close();
    }
  }
  return entity;
}","/** 
 * Creates a prov entity using the given entity Id. First queries the exe_entity table to get the type of the entity and then queries the relevant table to get further information.
 * @param entityId - entity Id in the database
 * @return Entity instance or null if there's no such entity
 */
protected Entity createEntity(String entityId,Connection connection) throws SQLException {
  assert(entityId != null);
  l.debug(""String_Node_Str"");
  PreparedStatement stmt=null;
  ResultSet resultSet=null;
  Entity entity=null;
  try {
    stmt=connection.prepareStatement(PROVSqlQuery.GET_ENTITY_TYPE);
    stmt.setString(1,entityId);
    resultSet=stmt.executeQuery();
    String entityType;
    if (resultSet.next()) {
      entityType=resultSet.getString(""String_Node_Str"");
    }
 else {
      return null;
    }
    if (stmt != null) {
      stmt.close();
      stmt=null;
    }
    if (resultSet != null) {
      resultSet.close();
      resultSet=null;
    }
    if (entityType.equals(BaseDBIngesterImplementer.EntityTypeEnum.FILE.name())) {
      stmt=connection.prepareStatement(PROVSqlQuery.GET_FILE_BY_ID);
      stmt.setString(1,entityId);
      resultSet=stmt.executeQuery();
      while (resultSet.next()) {
        String fileURI=resultSet.getString(""String_Node_Str"");
        String size=resultSet.getString(""String_Node_Str"");
        String creationDate=resultSet.getString(""String_Node_Str"");
        String fileName=resultSet.getString(""String_Node_Str"");
        String md5=resultSet.getString(""String_Node_Str"");
        entity=newEntity(QueryConstants.FILE_IDENTIFIER + entityId,fileURI,QueryConstants.ENTITY_FILE);
        if (size != null) {
          Other sizeAtt=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),size,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,sizeAtt);
        }
        if (creationDate != null) {
          Other dateAtt=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),creationDate,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,dateAtt);
        }
        if (fileName != null) {
          Other nameAtt=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),fileName,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,nameAtt);
        }
        if (md5 != null) {
          Other md5Att=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),md5,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,md5Att);
        }
        addCustomAttributes(PROVSqlQuery.GET_EXE_ENTITY_ATTRIBUTES_BY_ID,entityId,entity,connection);
      }
      if (stmt != null) {
        stmt.close();
        stmt=null;
      }
      if (resultSet != null) {
        resultSet.close();
        resultSet=null;
      }
    }
 else     if (entityType.equals(BaseDBIngesterImplementer.EntityTypeEnum.BLOCK.name())) {
      stmt=connection.prepareStatement(PROVSqlQuery.GET_BLOCK_BY_ID);
      stmt.setString(1,entityId);
      resultSet=stmt.executeQuery();
      while (resultSet.next()) {
        String blockUri=resultSet.getString(""String_Node_Str"");
        String size=resultSet.getString(""String_Node_Str"");
        String blockContent=resultSet.getString(""String_Node_Str"");
        String md5=resultSet.getString(""String_Node_Str"");
        entity=newEntity(QueryConstants.BLOCK_IDENTIFIER + entityId,blockUri,QueryConstants.ENTITY_BLOCK);
        if (size != null) {
          Other sizeAtt=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),size,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,sizeAtt);
        }
        if (blockContent != null) {
          Other contentAtt=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),blockContent,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,contentAtt);
        }
        if (md5 != null) {
          Other md5Att=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),md5,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,md5Att);
        }
        addCustomAttributes(PROVSqlQuery.GET_EXE_ENTITY_ATTRIBUTES_BY_ID,entityId,entity,connection);
      }
      if (stmt != null) {
        stmt.close();
        stmt=null;
      }
      if (resultSet != null) {
        resultSet.close();
        resultSet=null;
      }
    }
 else     if (entityType.equals(BaseDBIngesterImplementer.EntityTypeEnum.COLLECTION.name())) {
      stmt=connection.prepareStatement(PROVSqlQuery.GET_COLLECTION_BY_ID);
      stmt.setString(1,entityId);
      resultSet=stmt.executeQuery();
      while (resultSet.next()) {
        String collectionUri=resultSet.getString(""String_Node_Str"");
        entity=newEntity(QueryConstants.COLLECTION_IDENTIFIER + entityId,collectionUri,QueryConstants.ENTITY_COLLECTION);
        addCustomAttributes(PROVSqlQuery.GET_EXE_ENTITY_ATTRIBUTES_BY_ID,entityId,entity,connection);
      }
      if (stmt != null) {
        stmt.close();
        stmt=null;
      }
      if (resultSet != null) {
        resultSet.close();
        resultSet=null;
      }
    }
 else     if (entityType.equals(BaseDBIngesterImplementer.EntityTypeEnum.GENERIC.name())) {
      stmt=connection.prepareStatement(PROVSqlQuery.GET_GENERIC_ENTITY_BY_ID);
      stmt.setString(1,entityId);
      resultSet=stmt.executeQuery();
      while (resultSet.next()) {
        String genericEntityUri=resultSet.getString(""String_Node_Str"");
        entity=newEntity(QueryConstants.FILE_IDENTIFIER + entityId,genericEntityUri,QueryConstants.ENTITY_BLOCK);
        addCustomAttributes(PROVSqlQuery.GET_EXE_ENTITY_ATTRIBUTES_BY_ID,entityId,entity,connection);
      }
      if (stmt != null) {
        stmt.close();
        stmt=null;
      }
      if (resultSet != null) {
        resultSet.close();
        resultSet=null;
      }
    }
    l.debug(""String_Node_Str"");
  }
 catch (  SQLException e) {
    l.error(""String_Node_Str"");
    l.error(e.toString());
  }
 finally {
    if (stmt != null) {
      stmt.close();
    }
    if (resultSet != null) {
      resultSet.close();
    }
  }
  return entity;
}",0.9732418524871356
91135,"/** 
 * Creates a prov entity using the given entity Id. First queries the exe_entity table to get the type of the entity and then queries the relevant table to get further information.
 * @param entityId - entity Id in the database
 * @return Entity instance or null if there's no such entity
 */
protected Entity createEntity(String entityId,Connection connection) throws SQLException {
  assert(entityId != null);
  l.debug(""String_Node_Str"");
  PreparedStatement stmt=null;
  ResultSet resultSet=null;
  Entity entity=null;
  try {
    stmt=connection.prepareStatement(PROVSqlQuery.GET_ENTITY_TYPE);
    stmt.setString(1,entityId);
    resultSet=stmt.executeQuery();
    String entityType;
    if (resultSet.next()) {
      entityType=resultSet.getString(""String_Node_Str"");
    }
 else {
      return null;
    }
    if (stmt != null) {
      stmt.close();
      stmt=null;
    }
    if (resultSet != null) {
      resultSet.close();
      resultSet=null;
    }
    if (entityType.equals(BaseDBIngesterImplementer.EntityTypeEnum.FILE.name())) {
      stmt=connection.prepareStatement(PROVSqlQuery.GET_FILE_BY_ID);
      stmt.setString(1,entityId);
      resultSet=stmt.executeQuery();
      while (resultSet.next()) {
        String fileURI=resultSet.getString(""String_Node_Str"");
        String size=resultSet.getString(""String_Node_Str"");
        String creationDate=resultSet.getString(""String_Node_Str"");
        String fileName=resultSet.getString(""String_Node_Str"");
        String md5=resultSet.getString(""String_Node_Str"");
        entity=newEntity(QueryConstants.FILE_IDENTIFIER + entityId,fileURI,QueryConstants.ENTITY_FILE);
        if (size != null) {
          Other sizeAtt=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),size,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,sizeAtt);
        }
        if (creationDate != null) {
          Other dateAtt=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),creationDate,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,dateAtt);
        }
        if (fileName != null) {
          Other nameAtt=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),fileName,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,nameAtt);
        }
        if (md5 != null) {
          Other md5Att=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),md5,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,md5Att);
        }
        addCustomAttributes(PROVSqlQuery.GET_EXE_ENTITY_ATTRIBUTES_BY_ID,entityId,entity,connection);
      }
      if (stmt != null) {
        stmt.close();
        stmt=null;
      }
      if (resultSet != null) {
        resultSet.close();
        resultSet=null;
      }
    }
 else     if (entityType.equals(BaseDBIngesterImplementer.EntityTypeEnum.BLOCK.name())) {
      stmt=connection.prepareStatement(PROVSqlQuery.GET_BLOCK_BY_ID);
      stmt.setString(1,entityId);
      resultSet=stmt.executeQuery();
      while (resultSet.next()) {
        String blockUri=resultSet.getString(""String_Node_Str"");
        String size=resultSet.getString(""String_Node_Str"");
        String blockContent=resultSet.getString(""String_Node_Str"");
        String md5=resultSet.getString(""String_Node_Str"");
        entity=newEntity(QueryConstants.BLOCK_IDENTIFIER + entityId,blockUri,QueryConstants.ENTITY_BLOCK);
        if (size != null) {
          Other sizeAtt=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),size,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,sizeAtt);
        }
        if (blockContent != null) {
          Other contentAtt=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),blockContent,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,contentAtt);
        }
        if (md5 != null) {
          Other md5Att=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),md5,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,md5Att);
        }
        addCustomAttributes(PROVSqlQuery.GET_EXE_ENTITY_ATTRIBUTES_BY_ID,entityId,entity,connection);
      }
      if (stmt != null) {
        stmt.close();
        stmt=null;
      }
      if (resultSet != null) {
        resultSet.close();
        resultSet=null;
      }
    }
 else     if (entityType.equals(BaseDBIngesterImplementer.EntityTypeEnum.COLLECTION.name())) {
      stmt=connection.prepareStatement(PROVSqlQuery.GET_COLLECTION_BY_ID);
      stmt.setString(1,entityId);
      resultSet=stmt.executeQuery();
      while (resultSet.next()) {
        String collectionUri=resultSet.getString(""String_Node_Str"");
        entity=newEntity(QueryConstants.COLLECTION_IDENTIFIER + entityId,collectionUri,QueryConstants.ENTITY_COLLECTION);
        addCustomAttributes(PROVSqlQuery.GET_EXE_ENTITY_ATTRIBUTES_BY_ID,entityId,entity,connection);
      }
      if (stmt != null) {
        stmt.close();
        stmt=null;
      }
      if (resultSet != null) {
        resultSet.close();
        resultSet=null;
      }
    }
 else     if (entityType.equals(BaseDBIngesterImplementer.EntityTypeEnum.GENERIC.name())) {
      stmt=connection.prepareStatement(PROVSqlQuery.GET_GENERIC_ENTITY_BY_ID);
      stmt.setString(1,entityId);
      resultSet=stmt.executeQuery();
      while (resultSet.next()) {
        String genericEntityUri=resultSet.getString(""String_Node_Str"");
        entity=newEntity(QueryConstants.FILE_IDENTIFIER + entityId,genericEntityUri,QueryConstants.ENTITY_BLOCK);
        addCustomAttributes(PROVSqlQuery.GET_EXE_ENTITY_ATTRIBUTES_BY_ID,entityId,entity,connection);
      }
      if (stmt != null) {
        stmt.close();
        stmt=null;
      }
      if (resultSet != null) {
        resultSet.close();
        resultSet=null;
      }
    }
    l.debug(""String_Node_Str"");
  }
 catch (  SQLException e) {
    l.error(""String_Node_Str"");
    l.error(e.toString());
  }
 finally {
    if (stmt != null) {
      stmt.close();
    }
    if (resultSet != null) {
      resultSet.close();
    }
  }
  return entity;
}","/** 
 * Creates a prov entity using the given entity Id. First queries the exe_entity table to get the type of the entity and then queries the relevant table to get further information.
 * @param entityId - entity Id in the database
 * @return Entity instance or null if there's no such entity
 */
protected Entity createEntity(String entityId,Connection connection) throws SQLException {
  assert(entityId != null);
  l.debug(""String_Node_Str"");
  PreparedStatement stmt=null;
  ResultSet resultSet=null;
  Entity entity=null;
  try {
    stmt=connection.prepareStatement(PROVSqlQuery.GET_ENTITY_TYPE);
    stmt.setString(1,entityId);
    resultSet=stmt.executeQuery();
    String entityType;
    if (resultSet.next()) {
      entityType=resultSet.getString(""String_Node_Str"");
    }
 else {
      return null;
    }
    if (stmt != null) {
      stmt.close();
      stmt=null;
    }
    if (resultSet != null) {
      resultSet.close();
      resultSet=null;
    }
    if (entityType.equals(BaseDBIngesterImplementer.EntityTypeEnum.FILE.name())) {
      stmt=connection.prepareStatement(PROVSqlQuery.GET_FILE_BY_ID);
      stmt.setString(1,entityId);
      resultSet=stmt.executeQuery();
      while (resultSet.next()) {
        String fileURI=resultSet.getString(""String_Node_Str"");
        String size=resultSet.getString(""String_Node_Str"");
        String creationDate=resultSet.getString(""String_Node_Str"");
        String fileName=resultSet.getString(""String_Node_Str"");
        String md5=resultSet.getString(""String_Node_Str"");
        entity=newEntity(QueryConstants.FILE_IDENTIFIER + entityId,fileURI,QueryConstants.ENTITY_FILE);
        if (size != null) {
          Other sizeAtt=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),size,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,sizeAtt);
        }
        if (creationDate != null) {
          Other dateAtt=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),creationDate,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,dateAtt);
        }
        if (fileName != null) {
          Other nameAtt=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),fileName,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,nameAtt);
        }
        if (md5 != null) {
          Other md5Att=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),md5,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,md5Att);
        }
        addCustomAttributes(PROVSqlQuery.GET_EXE_ENTITY_ATTRIBUTES_BY_ID,entityId,entity,connection);
      }
      if (stmt != null) {
        stmt.close();
        stmt=null;
      }
      if (resultSet != null) {
        resultSet.close();
        resultSet=null;
      }
    }
 else     if (entityType.equals(BaseDBIngesterImplementer.EntityTypeEnum.BLOCK.name())) {
      stmt=connection.prepareStatement(PROVSqlQuery.GET_BLOCK_BY_ID);
      stmt.setString(1,entityId);
      resultSet=stmt.executeQuery();
      while (resultSet.next()) {
        String blockUri=resultSet.getString(""String_Node_Str"");
        String size=resultSet.getString(""String_Node_Str"");
        String blockContent=resultSet.getString(""String_Node_Str"");
        String md5=resultSet.getString(""String_Node_Str"");
        entity=newEntity(QueryConstants.BLOCK_IDENTIFIER + entityId,blockUri,QueryConstants.ENTITY_BLOCK);
        if (size != null) {
          Other sizeAtt=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),size,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,sizeAtt);
        }
        if (blockContent != null) {
          Other contentAtt=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),blockContent,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,contentAtt);
        }
        if (md5 != null) {
          Other md5Att=pFactory.newOther(getKomaduAttQName(""String_Node_Str""),md5,Name.QNAME_XSD_STRING);
          pFactory.addAttribute(entity,md5Att);
        }
        addCustomAttributes(PROVSqlQuery.GET_EXE_ENTITY_ATTRIBUTES_BY_ID,entityId,entity,connection);
      }
      if (stmt != null) {
        stmt.close();
        stmt=null;
      }
      if (resultSet != null) {
        resultSet.close();
        resultSet=null;
      }
    }
 else     if (entityType.equals(BaseDBIngesterImplementer.EntityTypeEnum.COLLECTION.name())) {
      stmt=connection.prepareStatement(PROVSqlQuery.GET_COLLECTION_BY_ID);
      stmt.setString(1,entityId);
      resultSet=stmt.executeQuery();
      while (resultSet.next()) {
        String collectionUri=resultSet.getString(""String_Node_Str"");
        entity=newEntity(QueryConstants.COLLECTION_IDENTIFIER + entityId,collectionUri,QueryConstants.ENTITY_COLLECTION);
        addCustomAttributes(PROVSqlQuery.GET_EXE_ENTITY_ATTRIBUTES_BY_ID,entityId,entity,connection);
      }
      if (stmt != null) {
        stmt.close();
        stmt=null;
      }
      if (resultSet != null) {
        resultSet.close();
        resultSet=null;
      }
    }
 else     if (entityType.equals(BaseDBIngesterImplementer.EntityTypeEnum.GENERIC.name())) {
      stmt=connection.prepareStatement(PROVSqlQuery.GET_GENERIC_ENTITY_BY_ID);
      stmt.setString(1,entityId);
      resultSet=stmt.executeQuery();
      while (resultSet.next()) {
        String genericEntityUri=resultSet.getString(""String_Node_Str"");
        entity=newEntity(QueryConstants.ENTITY_IDENTIFIER + entityId,genericEntityUri,QueryConstants.ENTITY_GENERIC);
        addCustomAttributes(PROVSqlQuery.GET_EXE_ENTITY_ATTRIBUTES_BY_ID,entityId,entity,connection);
      }
      if (stmt != null) {
        stmt.close();
        stmt=null;
      }
      if (resultSet != null) {
        resultSet.close();
        resultSet=null;
      }
    }
    l.debug(""String_Node_Str"");
  }
 catch (  SQLException e) {
    l.error(""String_Node_Str"");
    l.error(e.toString());
  }
 finally {
    if (stmt != null) {
      stmt.close();
    }
    if (resultSet != null) {
      resultSet.close();
    }
  }
  return entity;
}",0.9983299933199732
91136,"protected IngestionResult addNewBlockEntity(EntityType entityInfo,Connection connection) throws IngestException, SQLException {
  BlockType block=entityInfo.getBlock();
  IngestionResult ingestionResult=null;
  if (KomaduUtils.manageDBLock(DBLockConstants.LOCK_ACQUIRE,block.getBlockURI(),connection)) {
    Long baseEntityId=addNewBaseEntity(EntityTypeEnum.BLOCK,entityInfo.getAttributes(),entityInfo.getRole(),entityInfo.getLocation(),connection);
    TupleData tuple=new TupleData();
    tuple.addAttribute(""String_Node_Str"",baseEntityId,TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",block.getBlockURI(),TableAttributeData.DataType.STRING);
    String content=block.getBlockContent();
    String md5=KomaduUtils.calculateMD5(content);
    if (md5 != null)     tuple.addAttribute(""String_Node_Str"",md5,TableAttributeData.DataType.STRING);
    tuple.addAttribute(""String_Node_Str"",content.length(),TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",content,TableAttributeData.DataType.STRING);
    Long blockId=insertTuple(""String_Node_Str"",tuple,""String_Node_Str"",connection);
    ingestionResult=new IngestionResult(block.getBlockURI(),blockId);
    KomaduUtils.manageDBLock(DBLockConstants.LOCK_RELEASE,block.getBlockURI(),connection);
  }
  return ingestionResult;
}","protected IngestionResult addNewBlockEntity(EntityType entityInfo,Connection connection) throws IngestException, SQLException {
  BlockType block=entityInfo.getBlock();
  IngestionResult ingestionResult=null;
  if (KomaduUtils.manageDBLock(DBLockConstants.LOCK_ACQUIRE,block.getBlockURI(),connection)) {
    Long baseEntityId=addNewBaseEntity(EntityTypeEnum.BLOCK,entityInfo.getAttributes(),entityInfo.getRole(),entityInfo.getLocation(),connection);
    TupleData tuple=new TupleData();
    tuple.addAttribute(""String_Node_Str"",baseEntityId,TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",block.getBlockURI(),TableAttributeData.DataType.STRING);
    String content=block.getBlockContent();
    String md5=KomaduUtils.calculateMD5(content);
    if (md5 != null)     tuple.addAttribute(""String_Node_Str"",md5,TableAttributeData.DataType.STRING);
    tuple.addAttribute(""String_Node_Str"",content.length(),TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",content,TableAttributeData.DataType.STRING);
    insertTuple(""String_Node_Str"",tuple,""String_Node_Str"",connection);
    ingestionResult=new IngestionResult(block.getBlockURI(),baseEntityId);
    KomaduUtils.manageDBLock(DBLockConstants.LOCK_RELEASE,block.getBlockURI(),connection);
  }
  return ingestionResult;
}",0.9251134644478064
91137,"protected IngestionResult addNewGenericEntity(EntityType entityInfo,Connection connection) throws IngestException, SQLException {
  GenericEntityType genericEntity=entityInfo.getGenericEntity();
  IngestionResult ingestionResult=null;
  if (KomaduUtils.manageDBLock(DBLockConstants.LOCK_ACQUIRE,genericEntity.getEntityURI(),connection)) {
    Long baseEntityId=addNewBaseEntity(EntityTypeEnum.GENERIC,entityInfo.getAttributes(),entityInfo.getRole(),entityInfo.getLocation(),connection);
    TupleData tuple=new TupleData();
    tuple.addAttribute(""String_Node_Str"",baseEntityId,TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",genericEntity.getEntityURI(),TableAttributeData.DataType.STRING);
    Long genericId=insertTuple(""String_Node_Str"",tuple,""String_Node_Str"",connection);
    ingestionResult=new IngestionResult(genericEntity.getEntityURI(),genericId);
    KomaduUtils.manageDBLock(DBLockConstants.LOCK_RELEASE,genericEntity.getEntityURI(),connection);
  }
  return ingestionResult;
}","protected IngestionResult addNewGenericEntity(EntityType entityInfo,Connection connection) throws IngestException, SQLException {
  GenericEntityType genericEntity=entityInfo.getGenericEntity();
  IngestionResult ingestionResult=null;
  if (KomaduUtils.manageDBLock(DBLockConstants.LOCK_ACQUIRE,genericEntity.getEntityURI(),connection)) {
    Long baseEntityId=addNewBaseEntity(EntityTypeEnum.GENERIC,entityInfo.getAttributes(),entityInfo.getRole(),entityInfo.getLocation(),connection);
    TupleData tuple=new TupleData();
    tuple.addAttribute(""String_Node_Str"",baseEntityId,TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",genericEntity.getEntityURI(),TableAttributeData.DataType.STRING);
    insertTuple(""String_Node_Str"",tuple,""String_Node_Str"",connection);
    ingestionResult=new IngestionResult(genericEntity.getEntityURI(),baseEntityId);
    KomaduUtils.manageDBLock(DBLockConstants.LOCK_RELEASE,genericEntity.getEntityURI(),connection);
  }
  return ingestionResult;
}",0.984189723320158
91138,"protected IngestionResult addNewFileEntity(EntityType entityInfo,Connection connection) throws IngestException, SQLException {
  FileType file=entityInfo.getFile();
  IngestionResult ownerResult=null;
  if (file.getOwnerDN() != null) {
    AgentType ownerAgent=AgentType.Factory.newInstance();
    UserAgentType user=UserAgentType.Factory.newInstance();
    user.setAgentID(file.getOwnerDN());
    ownerAgent.setUserAgent(user);
    ownerAgent.setType(AgentEnumType.OTHER);
    ownerResult=addNewAgent(ownerAgent,connection);
  }
  IngestionResult ingestionResult=null;
  if (KomaduUtils.manageDBLock(DBLockConstants.LOCK_ACQUIRE,file.getFileURI(),connection)) {
    Long baseEntityId=addNewBaseEntity(EntityTypeEnum.FILE,entityInfo.getAttributes(),entityInfo.getRole(),entityInfo.getLocation(),connection);
    TupleData tuple=new TupleData();
    tuple.addAttribute(""String_Node_Str"",baseEntityId,TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",file.getFileURI(),TableAttributeData.DataType.STRING);
    if (ownerResult != null)     tuple.addAttribute(""String_Node_Str"",ownerResult.getDbId(),TableAttributeData.DataType.LONG);
    if (file.isSetCreateDate())     tuple.addAttribute(""String_Node_Str"",KomaduUtils.getTimestamp(file.getCreateDate()),TableAttributeData.DataType.TIMESTAMP);
    tuple.addAttribute(""String_Node_Str"",file.getSize(),TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",file.getMd5Sum(),TableAttributeData.DataType.STRING);
    tuple.addAttribute(""String_Node_Str"",file.getFileName(),TableAttributeData.DataType.STRING);
    Long fileId=insertTuple(""String_Node_Str"",tuple,""String_Node_Str"",connection);
    ingestionResult=new IngestionResult(file.getFileURI(),fileId);
    KomaduUtils.manageDBLock(DBLockConstants.LOCK_RELEASE,file.getFileURI(),connection);
  }
  return ingestionResult;
}","protected IngestionResult addNewFileEntity(EntityType entityInfo,Connection connection) throws IngestException, SQLException {
  FileType file=entityInfo.getFile();
  IngestionResult ownerResult=null;
  if (file.getOwnerDN() != null) {
    AgentType ownerAgent=AgentType.Factory.newInstance();
    UserAgentType user=UserAgentType.Factory.newInstance();
    user.setAgentID(file.getOwnerDN());
    ownerAgent.setUserAgent(user);
    ownerAgent.setType(AgentEnumType.OTHER);
    ownerResult=addNewAgent(ownerAgent,connection);
  }
  IngestionResult ingestionResult=null;
  if (KomaduUtils.manageDBLock(DBLockConstants.LOCK_ACQUIRE,file.getFileURI(),connection)) {
    Long baseEntityId=addNewBaseEntity(EntityTypeEnum.FILE,entityInfo.getAttributes(),entityInfo.getRole(),entityInfo.getLocation(),connection);
    TupleData tuple=new TupleData();
    tuple.addAttribute(""String_Node_Str"",baseEntityId,TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",file.getFileURI(),TableAttributeData.DataType.STRING);
    if (ownerResult != null)     tuple.addAttribute(""String_Node_Str"",ownerResult.getDbId(),TableAttributeData.DataType.LONG);
    if (file.isSetCreateDate())     tuple.addAttribute(""String_Node_Str"",KomaduUtils.getTimestamp(file.getCreateDate()),TableAttributeData.DataType.TIMESTAMP);
    tuple.addAttribute(""String_Node_Str"",file.getSize(),TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",file.getMd5Sum(),TableAttributeData.DataType.STRING);
    tuple.addAttribute(""String_Node_Str"",file.getFileName(),TableAttributeData.DataType.STRING);
    insertTuple(""String_Node_Str"",tuple,""String_Node_Str"",connection);
    ingestionResult=new IngestionResult(file.getFileURI(),baseEntityId);
    KomaduUtils.manageDBLock(DBLockConstants.LOCK_RELEASE,file.getFileURI(),connection);
  }
  return ingestionResult;
}",0.9469737546866632
91139,"/** 
 * Creates a PROV Activity by querying the database using the given query and param. If the query uses the activity URI, param should be activity URI. And if the query uses the activity ID, param should be activity ID.
 */
protected int createActivity(Connection connection,String query,String param) throws QueryException, SQLException {
  PreparedStatement stmt=null;
  ResultSet resultSet=null;
  int activityID=-1;
  try {
    stmt=connection.prepareStatement(query);
    stmt.setString(1,param);
    resultSet=stmt.executeQuery();
    while (resultSet.next()) {
      activityID=resultSet.getInt(""String_Node_Str"");
      String activityUri=resultSet.getString(""String_Node_Str"");
      String activityType=resultSet.getString(""String_Node_Str"");
      String contextWorkflowUri=resultSet.getString(""String_Node_Str"");
      String contextServiceUri=resultSet.getString(""String_Node_Str"");
      String timestep=resultSet.getString(""String_Node_Str"");
      String contextWfNodeIdToken=resultSet.getString(""String_Node_Str"");
      Activity activity=pFactory.newActivity(getIdQName(QueryConstants.ACTIVITY_IDENTIFIER + activityID));
      if (infoDetailLevel != null && infoDetailLevel.equals(DetailEnumType.FINE)) {
        pFactory.addAttribute(activity,pFactory.newOther(getKomaduAttQName(""String_Node_Str""),activityUri,Name.QNAME_XSD_STRING));
        pFactory.addAttribute(activity,pFactory.newOther(getKomaduAttQName(""String_Node_Str""),activityType,Name.QNAME_XSD_STRING));
        if (contextWorkflowUri != null) {
          pFactory.addAttribute(activity,pFactory.newOther(getKomaduAttQName(""String_Node_Str""),contextWorkflowUri,Name.QNAME_XSD_STRING));
        }
        if (contextServiceUri != null) {
          pFactory.addAttribute(activity,pFactory.newOther(getKomaduAttQName(""String_Node_Str""),contextServiceUri,Name.QNAME_XSD_STRING));
        }
        if (timestep != null) {
          pFactory.addAttribute(activity,pFactory.newOther(getKomaduAttQName(""String_Node_Str""),timestep,Name.QNAME_XSD_STRING));
        }
        if (contextWfNodeIdToken != null) {
          pFactory.addAttribute(activity,pFactory.newOther(getKomaduAttQName(""String_Node_Str""),timestep,Name.QNAME_XSD_STRING));
        }
        addCustomAttributes(PROVSqlQuery.GET_EXE_ACTIVITY_ATTRIBUTES_BY_ID,""String_Node_Str"" + activityID,activity,connection);
      }
      activities.put(activityID,activity);
    }
    l.debug(""String_Node_Str"");
  }
 catch (  SQLException e) {
    l.error(""String_Node_Str"");
    l.error(e.toString());
  }
 finally {
    if (stmt != null) {
      stmt.close();
    }
    if (resultSet != null) {
      resultSet.close();
    }
  }
  return activityID;
}","/** 
 * Creates a PROV Activity by querying the database using the given query and param. If the query uses the activity URI, param should be activity URI. And if the query uses the activity ID, param should be activity ID.
 */
protected int createActivity(Connection connection,String query,String param) throws QueryException, SQLException {
  PreparedStatement stmt=null;
  ResultSet resultSet=null;
  int activityID=-1;
  try {
    stmt=connection.prepareStatement(query);
    stmt.setString(1,param);
    resultSet=stmt.executeQuery();
    while (resultSet.next()) {
      activityID=resultSet.getInt(""String_Node_Str"");
      String activityUri=resultSet.getString(""String_Node_Str"");
      String activityType=resultSet.getString(""String_Node_Str"");
      String contextWorkflowUri=resultSet.getString(""String_Node_Str"");
      String contextServiceUri=resultSet.getString(""String_Node_Str"");
      String timestep=resultSet.getString(""String_Node_Str"");
      String contextWfNodeIdToken=resultSet.getString(""String_Node_Str"");
      Activity activity=pFactory.newActivity(getIdQName(QueryConstants.ACTIVITY_IDENTIFIER + activityID));
      if (infoDetailLevel != null && infoDetailLevel.equals(DetailEnumType.FINE)) {
        pFactory.addAttribute(activity,pFactory.newOther(getKomaduAttQName(""String_Node_Str""),activityUri,Name.QNAME_XSD_STRING));
        pFactory.addAttribute(activity,pFactory.newOther(getKomaduAttQName(""String_Node_Str""),activityType,Name.QNAME_XSD_STRING));
        if (contextWorkflowUri != null) {
          pFactory.addAttribute(activity,pFactory.newOther(getKomaduAttQName(""String_Node_Str""),contextWorkflowUri,Name.QNAME_XSD_STRING));
        }
        if (contextServiceUri != null) {
          pFactory.addAttribute(activity,pFactory.newOther(getKomaduAttQName(""String_Node_Str""),contextServiceUri,Name.QNAME_XSD_STRING));
        }
        if (timestep != null) {
          pFactory.addAttribute(activity,pFactory.newOther(getKomaduAttQName(""String_Node_Str""),timestep,Name.QNAME_XSD_STRING));
        }
        if (contextWfNodeIdToken != null) {
          pFactory.addAttribute(activity,pFactory.newOther(getKomaduAttQName(""String_Node_Str""),contextWfNodeIdToken,Name.QNAME_XSD_STRING));
        }
        addCustomAttributes(PROVSqlQuery.GET_EXE_ACTIVITY_ATTRIBUTES_BY_ID,""String_Node_Str"" + activityID,activity,connection);
      }
      activities.put(activityID,activity);
    }
    l.debug(""String_Node_Str"");
  }
 catch (  SQLException e) {
    l.error(""String_Node_Str"");
    l.error(e.toString());
  }
 finally {
    if (stmt != null) {
      stmt.close();
    }
    if (resultSet != null) {
      resultSet.close();
    }
  }
  return activityID;
}",0.9948013367991088
91140,"/** 
 * @param msgconf
 */
public Query(MessageConfig msgconf){
  try {
    this.msgconf=msgconf;
    this.sender=new Sender(msgconf,MessagingOperationTypes.SEND_QUERY_REQUEST);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * @param msgconf
 */
public Query(MessageConfig msgconf,String msgconfPath){
  try {
    this.msgconf=msgconf;
    this.sender=new Sender(msgconf,MessagingOperationTypes.SEND_QUERY_REQUEST);
    String schemaPath=PropertyReader.getInstance(msgconfPath).getProperty(""String_Node_Str"");
    this.schemaFile=new File(schemaPath);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.7551342812006319
91141,"/** 
 * Send Query to Komadu Server through Message Bus.
 * @param QueryFile
 * @throws IOException
 */
public String sendQueryRequest(File QueryFile) throws IOException {
  try {
    XmlObject query=XmlObject.Factory.parse(QueryFile);
    if (!query.validate()) {
      throw new XmlException(""String_Node_Str"");
    }
 else {
      String ResponseRoutingKey=UUID.randomUUID().toString();
      try {
        new MessagingQueue().new QueueBind(this.msgconf,this.msgconf.getQueryResponseExchangeName(),this.msgconf.getQueryResponseQueueName(),ResponseRoutingKey);
        this.sender.sendMessage(ResponseRoutingKey + ""String_Node_Str"" + query.xmlText(new XmlOptions().setSavePrettyPrint()));
        return ResponseRoutingKey;
      }
 catch (      ShutdownSignalException e) {
        e.printStackTrace();
      }
catch (      IOException e) {
        e.printStackTrace();
      }
catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
 catch (  XmlException e) {
    e.printStackTrace();
  }
  return null;
}","/** 
 * Send Query to Komadu Server through Message Bus.
 * @param QueryFile
 * @throws IOException
 */
public String sendQueryRequest(File QueryFile) throws IOException {
  try {
    XmlObject query=XmlObject.Factory.parse(QueryFile);
    if (!Validation.validate(query,schemaFile)) {
      throw new XmlException(""String_Node_Str"");
    }
 else {
      String ResponseRoutingKey=UUID.randomUUID().toString();
      try {
        new MessagingQueue().new QueueBind(this.msgconf,this.msgconf.getQueryResponseExchangeName(),this.msgconf.getQueryResponseQueueName(),ResponseRoutingKey);
        this.sender.sendMessage(ResponseRoutingKey + ""String_Node_Str"" + query.xmlText(new XmlOptions().setSavePrettyPrint()));
        return ResponseRoutingKey;
      }
 catch (      ShutdownSignalException e) {
        e.printStackTrace();
      }
catch (      IOException e) {
        e.printStackTrace();
      }
catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
 catch (  XmlException e) {
    e.printStackTrace();
  }
  return null;
}",0.9805040418449834
91142,"public static void main(String[] args){
  if (args.length != 2) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    return;
  }
  String MessageConfigPath=args[0];
  String pathToQueryFile=args[1];
  long startTime=System.currentTimeMillis();
  MessageConfig msgconf=new MessageConfig(MessageConfigPath);
  Query query=new Query(msgconf);
  String queryResult=query.query(new File(pathToQueryFile));
  query.closeConnection();
  System.out.println(""String_Node_Str"" + queryResult);
  long endTime=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (endTime - startTime));
}","public static void main(String[] args){
  if (args.length != 2) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    return;
  }
  String MessageConfigPath=args[0];
  String pathToQueryFile=args[1];
  long startTime=System.currentTimeMillis();
  MessageConfig msgconf=new MessageConfig(MessageConfigPath);
  Query query=new Query(msgconf,MessageConfigPath);
  String queryResult=query.query(new File(pathToQueryFile));
  query.closeConnection();
  System.out.println(""String_Node_Str"" + queryResult);
  long endTime=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (endTime - startTime));
}",0.9859375
91143,"public static void main(String[] args){
  if (args.length != 2) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    return;
  }
  String MessageConfigPath=args[0];
  String pathToQueryFile=args[1];
  int iternation=Integer.parseInt(args[2]);
  long startTime=System.currentTimeMillis();
  MessageConfig msgconf=new MessageConfig(MessageConfigPath);
  Query query=new Query(msgconf);
  for (int i=0; i < iternation; i++) {
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ query.query(new File(pathToQueryFile)));
  }
  query.closeConnection();
  long endTime=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (endTime - startTime));
}","public static void main(String[] args){
  if (args.length != 2) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    return;
  }
  String MessageConfigPath=args[0];
  String pathToQueryFile=args[1];
  int iternation=Integer.parseInt(args[2]);
  long startTime=System.currentTimeMillis();
  MessageConfig msgconf=new MessageConfig(MessageConfigPath);
  Query query=new Query(msgconf,MessageConfigPath);
  for (int i=0; i < iternation; i++) {
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ query.query(new File(pathToQueryFile)));
  }
  query.closeConnection();
  long endTime=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (endTime - startTime));
}",0.9874651810584958
91144,"private static EntityType createCollectionEntity(String collectionURI,int runId) throws Exception {
  EntityType entity=EntityType.Factory.newInstance();
  CollectionType collection=CollectionType.Factory.newInstance();
  collection.setCollectionURI(collectionURI);
  String collFile1URI=""String_Node_Str"" + runId;
  EntityType collEntity1=createFileEntity(collFile1URI);
  MembersType members=MembersType.Factory.newInstance();
  EntityType[] memberArray=new EntityType[]{collEntity1};
  members.setMemberArray(memberArray);
  collection.setMembers(members);
  entity.setCollection(collection);
  return entity;
}","private static EntityType createCollectionEntity(String collectionURI,int runId) throws Exception {
  EntityType entity=EntityType.Factory.newInstance();
  CollectionType collection=CollectionType.Factory.newInstance();
  collection.setCollectionURI(collectionURI);
  String collFile1URI=""String_Node_Str"" + runId;
  EntityType collEntity1=createFileEntity(collFile1URI);
  MembersType members=MembersType.Factory.newInstance();
  EntityType[] memberArray=new EntityType[]{collEntity1};
  members.setMemberArray(memberArray);
  collection.setMembers(members);
  entity.setCollection(collection);
  AttributesType attributes=AttributesType.Factory.newInstance();
  AttributeType[] attributesArr=new AttributeType[1];
  AttributeType att1=createAttribute(""String_Node_Str"",""String_Node_Str"");
  attributesArr[0]=att1;
  attributes.setAttributeArray(attributesArr);
  entity.setAttributes(attributes);
  return entity;
}",0.8020901371652515
91145,"protected IngestionResult addNewCollection(EntityType entityInfo,Connection connection) throws IngestException, SQLException {
  CollectionType collection=entityInfo.getCollection();
  IngestionResult ingestionResult=null;
  if (KomaduUtils.manageDBLock(DBLockConstants.LOCK_ACQUIRE,collection.getCollectionURI(),connection)) {
    Long baseEntityId=addNewBaseEntity(EntityTypeEnum.COLLECTION,entityInfo.getAttributes(),entityInfo.getRole(),entityInfo.getLocation(),connection);
    TupleData tuple=new TupleData();
    tuple.addAttribute(""String_Node_Str"",baseEntityId,TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",collection.getCollectionURI(),TableAttributeData.DataType.STRING);
    Long collectionId=insertTuple(""String_Node_Str"",tuple,""String_Node_Str"",connection);
    KomaduUtils.manageDBLock(DBLockConstants.LOCK_RELEASE,collection.getCollectionURI(),connection);
    MembersType members=collection.getMembers();
    for (    EntityType member : members.getMemberArray()) {
      IngestionResult memberResult=addNewEntity(member,connection);
      addNewMembership(collectionId,memberResult.getDbId(),connection);
    }
    ingestionResult=new IngestionResult(collection.getCollectionURI(),collectionId);
  }
  return ingestionResult;
}","protected IngestionResult addNewCollection(EntityType entityInfo,Connection connection) throws IngestException, SQLException {
  CollectionType collection=entityInfo.getCollection();
  IngestionResult ingestionResult=null;
  if (KomaduUtils.manageDBLock(DBLockConstants.LOCK_ACQUIRE,collection.getCollectionURI(),connection)) {
    Long baseEntityId=addNewBaseEntity(EntityTypeEnum.COLLECTION,entityInfo.getAttributes(),entityInfo.getRole(),entityInfo.getLocation(),connection);
    TupleData tuple=new TupleData();
    tuple.addAttribute(""String_Node_Str"",baseEntityId,TableAttributeData.DataType.LONG);
    tuple.addAttribute(""String_Node_Str"",collection.getCollectionURI(),TableAttributeData.DataType.STRING);
    insertTuple(""String_Node_Str"",tuple,""String_Node_Str"",connection);
    KomaduUtils.manageDBLock(DBLockConstants.LOCK_RELEASE,collection.getCollectionURI(),connection);
    MembersType members=collection.getMembers();
    for (    EntityType member : members.getMemberArray()) {
      IngestionResult memberResult=addNewEntity(member,connection);
      addNewMembership(baseEntityId,memberResult.getDbId(),connection);
    }
    ingestionResult=new IngestionResult(collection.getCollectionURI(),baseEntityId);
  }
  return ingestionResult;
}",0.9770932069510267
91146,"private static Function<LinkedTrackPoint,LinkedTrackPoint> changeTime(final long startTime,final double multiplier){
  return new Function<LinkedTrackPoint,LinkedTrackPoint>(){
    @Override public LinkedTrackPoint apply(    LinkedTrackPoint in){
      long newTime=(long)(startTime + (in.getTime().longValue() - startTime) * multiplier);
      return DefaultLinkedWayPoint.of(new DefaultWayPoint(in.getLatitude(),in.getLongitude(),in.getElevation(),Long.valueOf(newTime)),in.getLink());
    }
  }
;
}","private static Function<LinkedTrackPoint,LinkedTrackPoint> changeTime(final long startTime,final double multiplier){
  return new Function<LinkedTrackPoint,LinkedTrackPoint>(){
    @Override public LinkedTrackPoint apply(    LinkedTrackPoint in){
      long newTime=(long)(startTime + (in.getTime().longValue() - startTime) * multiplier);
      return DefaultLinkedWayPoint.of(new DefaultWayPoint(in.getLatitude(),in.getLongitude(),in.getElevation(),Long.valueOf(newTime)),in.getLink(),in.getOverallDistance(),in.getOverallDuration());
    }
  }
;
}",0.9542857142857144
91147,"@Override public LinkedTrackPoint apply(LinkedTrackPoint in){
  long newTime=(long)(startTime + (in.getTime().longValue() - startTime) * multiplier);
  return DefaultLinkedWayPoint.of(new DefaultWayPoint(in.getLatitude(),in.getLongitude(),in.getElevation(),Long.valueOf(newTime)),in.getLink());
}","@Override public LinkedTrackPoint apply(LinkedTrackPoint in){
  long newTime=(long)(startTime + (in.getTime().longValue() - startTime) * multiplier);
  return DefaultLinkedWayPoint.of(new DefaultWayPoint(in.getLatitude(),in.getLongitude(),in.getElevation(),Long.valueOf(newTime)),in.getLink(),in.getOverallDistance(),in.getOverallDuration());
}",0.925
91148,"private String buildUrl(Operation operation,String from,List<String> args){
  String url=operation.getUrl();
  int i=0;
  for (  Field field : operation.getFields()) {
    String value;
    if (field.getField().equalsIgnoreCase(""String_Node_Str"")) {
      value=from;
      url=url.replace(""String_Node_Str"" + field.getField(),from);
    }
 else {
      value=args.get(i);
      i++;
    }
    try {
      url=url.replace(""String_Node_Str"" + field.getField(),URLEncoder.encode(value,""String_Node_Str""));
    }
 catch (    UnsupportedEncodingException e) {
      logger.error(""String_Node_Str"",value,e);
    }
  }
  return url;
}","private String buildUrl(Operation operation,String from,List<String> args){
  String url=operation.getUrl();
  int i=0;
  for (  Field field : operation.getFields()) {
    String value;
    if (field.getField().equalsIgnoreCase(""String_Node_Str"")) {
      value=from;
      try {
        url=url.replace(""String_Node_Str"" + field.getField(),URLEncoder.encode(from,""String_Node_Str""));
      }
 catch (      UnsupportedEncodingException e) {
        logger.error(""String_Node_Str"",value,e);
      }
    }
 else {
      value=args.get(i);
      i++;
    }
    try {
      url=url.replace(""String_Node_Str"" + field.getField(),URLEncoder.encode(value,""String_Node_Str""));
    }
 catch (    UnsupportedEncodingException e) {
      logger.error(""String_Node_Str"",value,e);
    }
  }
  return url;
}",0.6887323943661972
91149,"@Override public void process(MucHolder chatroom,MessageWrapper message){
  String[] args=getParsedCommand().getArgs();
  String baseurl=""String_Node_Str"";
  if (args != null && args.length > 0) {
    String callee=args[0];
    String response=String.format(""String_Node_Str"",callee,baseurl,callee);
  }
 else {
    String response=String.format(""String_Node_Str"");
  }
  chatroom.sendMessage(response);
}","@Override public void process(MucHolder chatroom,MessageWrapper message){
  String[] args=getParsedCommand().getArgs();
  String baseurl=""String_Node_Str"";
  if (args != null && args.length > 0) {
    String callee=args[0];
    String response=String.format(""String_Node_Str"",callee,baseurl,callee);
    chatroom.sendMessage(response);
  }
 else {
    String response=String.format(""String_Node_Str"");
    chatroom.sendMessage(response);
  }
}",0.875
91150,"protected String pickAttack(int argsLength){
  final int validArg=argsLength % getAttacks().size();
  final String[] attacks=getAttacks().get(validArg);
  return attacks[randomizer.nextInt(attacks.length)];
}","protected String pickAttack(int argsLength){
  final String[] attacks;
  if (argsLength >= getAttacks().size()) {
    attacks=getAttacks().get(getAttacks().size() - 1);
  }
 else {
    attacks=getAttacks().get(argsLength);
  }
  return attacks[randomizer.nextInt(attacks.length)];
}",0.5183673469387755
91151,"@Override public void actionPerformed(ActionEvent arg0){
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      MainRecorder.file=file.getText();
      System.out.println(MainRecorder.file);
      if (MainRecorder.file != null) {
        UI.gui.setState(Frame.ICONIFIED);
        MainRecorder.record();
      }
    }
  }
);
}","@Override public void actionPerformed(ActionEvent arg0){
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      String fileStr=file.getText();
      fileStr=fileStr.replace(""String_Node_Str"",""String_Node_Str"");
      System.out.println(MainRecorder.file);
      if (MainRecorder.file != null) {
        UI.gui.setState(Frame.ICONIFIED);
        MainRecorder.record();
      }
    }
  }
);
}",0.8685258964143426
91152,"public void run(){
  MainRecorder.file=file.getText();
  System.out.println(MainRecorder.file);
  if (MainRecorder.file != null) {
    UI.gui.setState(Frame.ICONIFIED);
    MainRecorder.record();
  }
}","public void run(){
  String fileStr=file.getText();
  fileStr=fileStr.replace(""String_Node_Str"",""String_Node_Str"");
  System.out.println(MainRecorder.file);
  if (MainRecorder.file != null) {
    UI.gui.setState(Frame.ICONIFIED);
    MainRecorder.record();
  }
}",0.7948164146868251
91153,"public static void play() throws IllegalArgumentException {
  try {
    BufferedReader in=new BufferedReader(new FileReader(filepath));
    Robot player=new Robot();
    GlobalScreen.registerNativeHook();
    GlobalScreen.getInstance().addNativeKeyListener(new KeyListener());
    ImageIcon img=new ImageIcon(System.getProperty(""String_Node_Str"") + ""String_Node_Str"");
    UI.gui.setIconImage(img.getImage());
    String input=in.readLine();
    int x;
    int y;
    int button;
    int scroll;
    int keycode;
    int time;
    String[] split;
    while (input != null && !exit) {
      split=input.split(""String_Node_Str"");
      System.err.println(""String_Node_Str"" + input + ""String_Node_Str"");
      if (split[0].equals(""String_Node_Str"")) {
        x=Integer.parseInt(split[1]);
        y=Integer.parseInt(split[2]);
        player.mouseMove(x,y);
      }
 else       if (split[0].equals(""String_Node_Str"")) {
        button=Integer.parseInt(split[1]);
        player.mousePress(InputEvent.getMaskForButton(button));
      }
 else       if (split[0].equals(""String_Node_Str"")) {
        button=Integer.parseInt(split[1]);
        player.mouseRelease(InputEvent.getMaskForButton(button));
      }
 else       if (split[0].equals(""String_Node_Str"")) {
        scroll=Integer.parseInt(split[1]);
        for (int i=0; i < scroll; i++) {
          player.mouseWheel(1);
        }
      }
 else       if (split[0].equals(""String_Node_Str"")) {
        keycode=Integer.parseInt(split[1]);
        player.keyPress(keycode);
      }
 else       if (split[0].equals(""String_Node_Str"")) {
        keycode=Integer.parseInt(split[1]);
        player.keyRelease(keycode);
      }
 else       if (split[0].equals(""String_Node_Str"")) {
        time=Integer.parseInt(split[1]);
        while (time > 60000) {
          time-=60000;
          player.delay(60000);
        }
        player.delay(Math.abs(time));
      }
 else       if (split[0].equals(""String_Node_Str"")) {
        exit=true;
      }
      input=in.readLine();
    }
    UI.gui.resetIcon();
    UI.gui.setState(Frame.NORMAL);
    GlobalScreen.unregisterNativeHook();
    exit=false;
    in.close();
  }
 catch (  IOException iox) {
    System.err.println(""String_Node_Str"" + filepath + ""String_Node_Str"");
    System.err.println(iox.getMessage());
    System.exit(1);
  }
catch (  AWTException awtx) {
    System.err.println(""String_Node_Str"");
    System.err.println(awtx.getMessage());
    System.exit(1);
  }
catch (  NativeHookException nhx) {
    System.err.println(""String_Node_Str"");
    System.err.println(nhx.getMessage());
    System.exit(1);
  }
}","public static void play() throws IllegalArgumentException {
  try {
    BufferedReader in=new BufferedReader(new FileReader(filepath));
    Robot player=new Robot();
    GlobalScreen.registerNativeHook();
    KeyListener exitListen=new KeyListener();
    GlobalScreen.getInstance().addNativeKeyListener(exitListen);
    ImageIcon img=new ImageIcon(System.getProperty(""String_Node_Str"") + ""String_Node_Str"");
    UI.gui.setIconImage(img.getImage());
    String input=in.readLine();
    int x;
    int y;
    int button;
    int scroll;
    int keycode;
    int time;
    String[] split;
    while (input != null && !MainPlayer.exit) {
      split=input.split(""String_Node_Str"");
      System.err.println(""String_Node_Str"" + input + ""String_Node_Str"");
      if (split[0].equals(""String_Node_Str"")) {
        x=Integer.parseInt(split[1]);
        y=Integer.parseInt(split[2]);
        player.mouseMove(x,y);
      }
 else       if (split[0].equals(""String_Node_Str"")) {
        button=Integer.parseInt(split[1]);
        player.mousePress(InputEvent.getMaskForButton(button));
      }
 else       if (split[0].equals(""String_Node_Str"")) {
        button=Integer.parseInt(split[1]);
        player.mouseRelease(InputEvent.getMaskForButton(button));
      }
 else       if (split[0].equals(""String_Node_Str"")) {
        scroll=Integer.parseInt(split[1]);
        player.mouseWheel(scroll);
      }
 else       if (split[0].equals(""String_Node_Str"")) {
        keycode=Integer.parseInt(split[1]);
        player.keyPress(keycode);
      }
 else       if (split[0].equals(""String_Node_Str"")) {
        keycode=Integer.parseInt(split[1]);
        player.keyRelease(keycode);
      }
 else       if (split[0].equals(""String_Node_Str"")) {
        time=Integer.parseInt(split[1]);
        while (time > 60000) {
          time-=60000;
          player.delay(60000);
        }
        player.delay(Math.abs(time));
      }
 else       if (split[0].equals(""String_Node_Str"")) {
        MainPlayer.exit=true;
      }
      input=in.readLine();
    }
    UI.gui.resetIcon();
    UI.gui.setState(Frame.NORMAL);
    GlobalScreen.getInstance().removeNativeKeyListener(exitListen);
    GlobalScreen.unregisterNativeHook();
    MainPlayer.exit=false;
    in.close();
  }
 catch (  IOException iox) {
    System.err.println(""String_Node_Str"" + filepath + ""String_Node_Str"");
    System.err.println(iox.getMessage());
    System.exit(1);
  }
catch (  AWTException awtx) {
    System.err.println(""String_Node_Str"");
    System.err.println(awtx.getMessage());
    System.exit(1);
  }
catch (  NativeHookException nhx) {
    System.err.println(""String_Node_Str"");
    System.err.println(nhx.getMessage());
    System.exit(1);
  }
}",0.9537767756482526
91154,"public static void record(){
  try {
    GlobalScreen.registerNativeHook();
  }
 catch (  NativeHookException nhx) {
    System.err.println(""String_Node_Str"");
    System.err.println(nhx.getMessage());
    System.exit(1);
  }
  System.out.println(root);
  time=System.nanoTime();
  GlobalScreen.getInstance().addNativeKeyListener(new KeyRecorder(root + file));
  GlobalScreen.getInstance().addNativeMouseListener(new MouseRecorder(root + file));
  GlobalScreen.getInstance().addNativeMouseMotionListener(new MouseRecorder(root + file));
  GlobalScreen.getInstance().addNativeMouseWheelListener(new ScrollRecorder(root + file));
  while (GlobalScreen.isNativeHookRegistered()) {
  }
  UI.gui.resetIcon();
  UI.gui.setState(Frame.NORMAL);
}","public static void record(){
  try {
    GlobalScreen.registerNativeHook();
  }
 catch (  NativeHookException nhx) {
    System.err.println(""String_Node_Str"");
    System.err.println(nhx.getMessage());
    System.exit(1);
  }
  System.out.println(root);
  time=System.nanoTime();
  KeyRecorder keyListener=new KeyRecorder(root + file);
  MouseRecorder mouseListener=new MouseRecorder(root + file);
  MouseRecorder mouseMotionListener=new MouseRecorder(root + file);
  ScrollRecorder mouseWheelListener=new ScrollRecorder(root + file);
  GlobalScreen.getInstance().addNativeKeyListener(keyListener);
  GlobalScreen.getInstance().addNativeMouseListener(mouseListener);
  GlobalScreen.getInstance().addNativeMouseMotionListener(mouseMotionListener);
  GlobalScreen.getInstance().addNativeMouseWheelListener(mouseWheelListener);
  while (GlobalScreen.isNativeHookRegistered()) {
  }
  GlobalScreen.getInstance().removeNativeKeyListener(keyListener);
  GlobalScreen.getInstance().removeNativeMouseListener(mouseListener);
  GlobalScreen.getInstance().removeNativeMouseMotionListener(mouseMotionListener);
  GlobalScreen.getInstance().removeNativeMouseWheelListener(mouseWheelListener);
  UI.gui.resetIcon();
  UI.gui.setState(Frame.NORMAL);
}",0.5336708860759494
91155,"@Override public void nativeMouseDragged(NativeMouseEvent e){
  if (MouseRecorder.mousePressed) {
    nativeMouseMoved(e);
  }
}","@Override public void nativeMouseDragged(NativeMouseEvent e){
  nativeMouseMoved(e);
}",0.8037383177570093
91156,"@Override public void nativeMouseReleased(NativeMouseEvent e){
  MouseRecorder.mousePressed=false;
  try {
    long time=System.nanoTime();
    long prevTime=MainRecorder.getTime();
    MainRecorder.setTime(time);
    time=Math.abs(time - prevTime);
    int timeMs=(int)(time / MainRecorder.convertRate);
    BufferedWriter out=new BufferedWriter(new FileWriter(filepath,true));
    int button=e.getButton();
    if (button == 2) {
      button=3;
    }
 else     if (button == 3) {
      button=2;
    }
    out.write(""String_Node_Str"" + button);
    out.newLine();
    out.write(""String_Node_Str"" + timeMs);
    out.newLine();
    out.close();
  }
 catch (  IOException iox) {
    System.err.println(""String_Node_Str"");
    System.err.println(iox.getMessage());
    try {
      BufferedWriter out=new BufferedWriter(new FileWriter(""String_Node_Str"",true));
      out.write(""String_Node_Str"");
      out.newLine();
      out.close();
    }
 catch (    IOException idox) {
    }
    System.exit(1);
  }
}","@Override public void nativeMouseReleased(NativeMouseEvent e){
  try {
    long time=System.nanoTime();
    long prevTime=MainRecorder.getTime();
    MainRecorder.setTime(time);
    time=Math.abs(time - prevTime);
    int timeMs=(int)(time / MainRecorder.convertRate);
    BufferedWriter out=new BufferedWriter(new FileWriter(filepath,true));
    int button=e.getButton();
    if (button == 2) {
      button=3;
    }
 else     if (button == 3) {
      button=2;
    }
    out.write(""String_Node_Str"" + button);
    out.newLine();
    out.write(""String_Node_Str"" + timeMs);
    out.newLine();
    out.close();
  }
 catch (  IOException iox) {
    System.err.println(""String_Node_Str"");
    System.err.println(iox.getMessage());
    try {
      BufferedWriter out=new BufferedWriter(new FileWriter(""String_Node_Str"",true));
      out.write(""String_Node_Str"");
      out.newLine();
      out.close();
    }
 catch (    IOException idox) {
    }
    System.exit(1);
  }
}",0.9817444219066938
91157,"@Override public void nativeMousePressed(NativeMouseEvent e){
  MouseRecorder.mousePressed=true;
  try {
    long time=System.nanoTime();
    long prevTime=MainRecorder.getTime();
    MainRecorder.setTime(time);
    time=Math.abs(time - prevTime);
    int timeMs=(int)(time / MainRecorder.convertRate);
    BufferedWriter out=new BufferedWriter(new FileWriter(filepath,true));
    int button=e.getButton();
    if (button == 2) {
      button=3;
    }
 else     if (button == 3) {
      button=2;
    }
    out.write(""String_Node_Str"" + button);
    out.newLine();
    out.write(""String_Node_Str"" + timeMs);
    out.newLine();
    out.close();
  }
 catch (  IOException iox) {
    System.err.println(""String_Node_Str"");
    System.err.println(iox.getMessage());
    try {
      BufferedWriter out=new BufferedWriter(new FileWriter(""String_Node_Str"",true));
      out.write(""String_Node_Str"");
      out.newLine();
      out.close();
    }
 catch (    IOException idox) {
    }
    System.exit(1);
  }
}","@Override public void nativeMousePressed(NativeMouseEvent e){
  try {
    long time=System.nanoTime();
    long prevTime=MainRecorder.getTime();
    MainRecorder.setTime(time);
    time=Math.abs(time - prevTime);
    int timeMs=(int)(time / MainRecorder.convertRate);
    BufferedWriter out=new BufferedWriter(new FileWriter(filepath,true));
    int button=e.getButton();
    if (button == 2) {
      button=3;
    }
 else     if (button == 3) {
      button=2;
    }
    out.write(""String_Node_Str"" + button);
    out.newLine();
    out.write(""String_Node_Str"" + timeMs);
    out.newLine();
    out.close();
  }
 catch (  IOException iox) {
    System.err.println(""String_Node_Str"");
    System.err.println(iox.getMessage());
    try {
      BufferedWriter out=new BufferedWriter(new FileWriter(""String_Node_Str"",true));
      out.write(""String_Node_Str"");
      out.newLine();
      out.close();
    }
 catch (    IOException idox) {
    }
    System.exit(1);
  }
}",0.9822244794311832
91158,"@Override public void nativeMouseWheelMoved(NativeMouseWheelEvent e){
  try {
    BufferedWriter out=new BufferedWriter(new FileWriter(filepath,true));
    int notch=e.getWheelRotation();
    out.write(""String_Node_Str"" + notch);
    out.newLine();
    out.close();
  }
 catch (  IOException iox) {
    System.err.println(""String_Node_Str"");
    System.err.println(iox.getMessage());
    System.exit(1);
  }
}","@Override public void nativeMouseWheelMoved(NativeMouseWheelEvent e){
  try {
    long time=System.nanoTime();
    long prevTime=MainRecorder.getTime();
    MainRecorder.setTime(time);
    time=Math.abs(time - prevTime);
    int timeMs=(int)(time / MainRecorder.convertRate);
    BufferedWriter out=new BufferedWriter(new FileWriter(filepath,true));
    int notch=e.getWheelRotation();
    out.write(""String_Node_Str"" + notch);
    out.newLine();
    out.write(""String_Node_Str"" + timeMs);
    out.newLine();
    out.close();
  }
 catch (  IOException iox) {
    System.err.println(""String_Node_Str"");
    System.err.println(iox.getMessage());
    System.exit(1);
  }
}",0.7588126159554731
91159,"@Test public void shouldResolveAllDependencies() throws Exception {
  DependencyResolverMojo resolverMojo=getResolverMojo();
  resolverMojo.setProxySrcDir(proxyRoot.getPath());
  resolverMojo.setProxyDestDir(target.getPath());
  resolverMojo.setProxyRefs(new String[]{proxyRef.getPath()});
  resolverMojo.execute();
  final File policiesDir=new File(target.getPath() + ""String_Node_Str"");
  final File resDir=new File(target.getPath() + ""String_Node_Str"");
  final File jsResDir=new File(target.getPath() + ""String_Node_Str"");
  final File proxiesDir=new File(target.getPath() + ""String_Node_Str"");
  assertThat(policiesDir.exists(),is(true));
  assertThat(resDir.exists(),is(true));
  assertThat(jsResDir.exists(),is(true));
  assertThat(proxiesDir.exists(),is(true));
  assertThat(new File(policiesDir,""String_Node_Str"").exists(),is(false));
  assertThat(new File(resDir,""String_Node_Str"").exists(),is(true));
  assertThat(policiesDir.list().length,is(61));
  assertPolicies(policiesDir);
}","@Test public void shouldResolveAllDependencies() throws Exception {
  DependencyResolverMojo resolverMojo=getResolverMojo();
  resolverMojo.setProxySrcDir(proxyRoot.getPath());
  resolverMojo.setProxyDestDir(target.getPath());
  resolverMojo.setProxyRefs(new String[]{proxyRef.getPath()});
  resolverMojo.execute();
  final File policiesDir=new File(target.getPath() + ""String_Node_Str"");
  final File resDir=new File(target.getPath() + ""String_Node_Str"");
  final File jsResDir=new File(target.getPath() + ""String_Node_Str"");
  final File proxiesDir=new File(target.getPath() + ""String_Node_Str"");
  assertThat(policiesDir.exists(),is(true));
  assertThat(resDir.exists(),is(true));
  assertThat(jsResDir.exists(),is(true));
  assertThat(proxiesDir.exists(),is(true));
  assertThat(new File(policiesDir,""String_Node_Str"").exists(),is(false));
  assertThat(new File(resDir,""String_Node_Str"").exists(),is(true));
  assertThat(policiesDir.list().length,is(61));
  assertPolicies(policiesDir);
  assertJSFiles(jsResDir);
}",0.9865738438587768
91160,"@Test public void shouldResolveAllDependencies() throws Exception {
  DependencyResolverMojo resolverMojo=getResolverMojo();
  resolverMojo.setProxySrcDir(proxyRoot.getPath());
  resolverMojo.setProxyDestDir(target.getPath());
  resolverMojo.setProxyRefs(new String[]{proxyRef.getPath()});
  resolverMojo.execute();
  final File policiesDir=new File(target.getPath() + ""String_Node_Str"");
  final File resDir=new File(target.getPath() + ""String_Node_Str"");
  final File jsResDir=new File(target.getPath() + ""String_Node_Str"");
  final File proxiesDir=new File(target.getPath() + ""String_Node_Str"");
  assertThat(policiesDir.exists(),is(true));
  assertThat(resDir.exists(),is(true));
  assertThat(jsResDir.exists(),is(true));
  assertThat(proxiesDir.exists(),is(true));
  assertThat(new File(policiesDir,""String_Node_Str"").exists(),is(false));
  assertThat(new File(resDir,""String_Node_Str"").exists(),is(true));
  assertThat(policiesDir.list().length,is(61));
  assertPolicies(policiesDir);
}","@Test public void shouldResolveAllDependencies() throws Exception {
  DependencyResolverMojo resolverMojo=getResolverMojo();
  resolverMojo.setProxySrcDir(proxyRoot.getPath());
  resolverMojo.setProxyDestDir(target.getPath());
  resolverMojo.setProxyRefs(new String[]{proxyRef.getPath()});
  resolverMojo.execute();
  final File policiesDir=new File(target.getPath() + ""String_Node_Str"");
  final File resDir=new File(target.getPath() + ""String_Node_Str"");
  final File jsResDir=new File(target.getPath() + ""String_Node_Str"");
  final File proxiesDir=new File(target.getPath() + ""String_Node_Str"");
  assertThat(policiesDir.exists(),is(true));
  assertThat(resDir.exists(),is(true));
  assertThat(jsResDir.exists(),is(true));
  assertThat(proxiesDir.exists(),is(true));
  assertThat(new File(policiesDir,""String_Node_Str"").exists(),is(false));
  assertThat(new File(resDir,""String_Node_Str"").exists(),is(true));
  assertThat(policiesDir.list().length,is(61));
  assertPolicies(policiesDir);
  assertJSFiles(jsResDir);
}",0.9865738438587768
91161,"/** 
 * @param overriddenMethods if != null add all methods to collection otherwise return on first match
 * @return true if method found
 */
private static boolean collectOverriddenMethods(MethodDeclaration md,List<Method> overriddenMethods){
  final MethodSymbolData sdata=md.getSymbolData();
  if (sdata == null || isStatic(sdata.getMethod()) || isPrivate(sdata.getMethod())) {
    return false;
  }
 else {
    boolean result=false;
    final Class<?> declaringClass=sdata.getMethod().getDeclaringClass();
    final Class<?> parentClass=declaringClass.getSuperclass();
    final Class<?>[] interfaces=declaringClass.getInterfaces();
    if (parentClass != null || interfaces.length > 0) {
      final SymbolData[] args=getParameterSymbolData(md);
      List<Class<?>> scopesToCheck=new LinkedList<Class<?>>();
      if (parentClass != null) {
        scopesToCheck.add(parentClass);
      }
      for (int i=0; i < interfaces.length; i++) {
        scopesToCheck.add(interfaces[i]);
      }
      final Iterator<Class<?>> it=scopesToCheck.iterator();
      while (it.hasNext() && !result) {
        final Class<?> clazzToAnalyze=it.next();
        final Method foundMethod=MethodInspector.findMethod(clazzToAnalyze,args,md.getName());
        if (foundMethod != null) {
          if (foundMethod.getDeclaringClass().isAssignableFrom(clazzToAnalyze)) {
            List<Type> types=ClassInspector.getInterfaceOrSuperclassImplementations(declaringClass,clazzToAnalyze);
            Class<?> returnType=null;
            if (types != null && !types.isEmpty()) {
              if (types.get(0) instanceof Class) {
                returnType=(Class<?>)types.get(0);
              }
            }
            if (matchesReturnAndParameters(foundMethod,returnType,args)) {
              if (overriddenMethods != null) {
                overriddenMethods.add(foundMethod);
              }
 else {
                result=true;
              }
            }
          }
        }
      }
    }
    return overriddenMethods != null ? !overriddenMethods.isEmpty() : result;
  }
}","/** 
 * Returns if any of the overriddenMethods overrides an specific method declaration.
 * @param md the method declaration
 * @param overriddenMethods if != null add all methods to collection otherwise return on first match
 * @return true if at least one method of the overriddenMethods overrides an specific method declaration.
 */
private static boolean collectOverriddenMethods(MethodDeclaration md,List<Method> overriddenMethods){
  final MethodSymbolData sdata=md.getSymbolData();
  if (sdata == null || isStatic(sdata.getMethod()) || isPrivate(sdata.getMethod())) {
    return false;
  }
 else {
    boolean result=false;
    final Class<?> declaringClass=sdata.getMethod().getDeclaringClass();
    final Class<?> parentClass=declaringClass.getSuperclass();
    final Class<?>[] interfaces=declaringClass.getInterfaces();
    if (parentClass != null || interfaces.length > 0) {
      final SymbolData[] args=getParameterSymbolData(md);
      List<Class<?>> scopesToCheck=new LinkedList<Class<?>>();
      if (parentClass != null) {
        scopesToCheck.add(parentClass);
      }
      for (int i=0; i < interfaces.length; i++) {
        scopesToCheck.add(interfaces[i]);
      }
      final Iterator<Class<?>> it=scopesToCheck.iterator();
      while (it.hasNext() && !result) {
        final Class<?> clazzToAnalyze=it.next();
        final Method foundMethod=MethodInspector.findMethod(clazzToAnalyze,args,md.getName());
        if (foundMethod != null) {
          if (foundMethod.getDeclaringClass().isAssignableFrom(clazzToAnalyze)) {
            List<Type> types=ClassInspector.getInterfaceOrSuperclassImplementations(declaringClass,clazzToAnalyze);
            Class<?> returnType=null;
            if (types != null && !types.isEmpty()) {
              if (types.get(0) instanceof Class) {
                returnType=(Class<?>)types.get(0);
              }
            }
            if (matchesReturnAndParameters(foundMethod,returnType,args)) {
              if (overriddenMethods != null) {
                overriddenMethods.add(foundMethod);
              }
 else {
                result=true;
              }
            }
          }
        }
      }
    }
    return overriddenMethods != null ? !overriddenMethods.isEmpty() : result;
  }
}",0.9495042656213972
91162,"/** 
 * @return the methods overridden by given method declaration 
 */
public static List<Method> findOverriddenMethods(MethodDeclaration md){
  final List<Method> methods=new ArrayList<Method>();
  collectOverriddenMethods(md,methods);
  return methods.isEmpty() ? Collections.<Method>emptyList() : Collections.unmodifiableList(methods);
}","/** 
 * Returns the methods overridden by given method declaration
 * @param md the method declaration
 * @return the methods overridden by given method declaration
 */
public static List<Method> findOverriddenMethods(MethodDeclaration md){
  final List<Method> methods=new ArrayList<Method>();
  collectOverriddenMethods(md,methods);
  return methods.isEmpty() ? Collections.<Method>emptyList() : Collections.unmodifiableList(methods);
}",0.8677792041078306
91163,"/** 
 * @return true if method declaration overrides or implements another method 
 */
public static boolean isMethodOverride(MethodDeclaration md){
  return collectOverriddenMethods(md,null);
}","/** 
 * Returns if a method declaration overrides or implements another method.
 * @param md the method declaration
 * @return true if method declaration overrides or implements another method
 */
public static boolean isMethodOverride(MethodDeclaration md){
  return collectOverriddenMethods(md,null);
}",0.7751004016064257
91164,"/** 
 * Sets the type of the method call arguments. In case of foo(1) => int foo(1, 1, 1) => int, int, int Then according the analyzed method, analyzes it can be called from the types. foo(int.. x) foo(int x) foo(Object x)
 * @param typeArgs
 */
public void setTypeArgs(SymbolType[] typeArgs){
  this.typeArgs=typeArgs;
}","/** 
 * Sets the type of the method call arguments. In case of For foo(1) returns int For foo(1, 1, 1) returns int, int, int Then according the analyzed method, analyzes it can be called from the types. foo(int.. x) foo(int x) foo(Object x)
 * @param typeArgs the type of the method call arguments.
 */
public void setTypeArgs(SymbolType[] typeArgs){
  this.typeArgs=typeArgs;
}",0.8955650929899857
91165,"/** 
 * @return intersection of raw types of classes and all super classes and interfaces 
 */
public static List<? extends Class<?>> intersectRawTypes(Class<?> clazz1,Class<?> clazz2){
  if (clazz2 == null) {
    clazz2=Object.class;
  }
  if (clazz1 == null) {
    clazz1=Object.class;
  }
  if (clazz1.isPrimitive()) {
    clazz1=Types.getWrapperClass(clazz1.getName());
  }
  if (clazz2.isPrimitive()) {
    clazz2=Types.getWrapperClass(clazz2.getName());
  }
  if (clazz1.equals(clazz2)) {
    return singletonList(clazz1);
  }
  if (Types.isAssignable(clazz2,clazz1)) {
    return singletonList(clazz1);
  }
  if (Types.isAssignable(clazz1,clazz2)) {
    return singletonList(clazz2);
  }
  final Set<Class<?>> common=commonClasses(clazz1,clazz2);
  final List<Class<?>> list=list(removeSubClasses(common));
  return list.isEmpty() ? LIST_OF_OBJECT_CLASS : list;
}","/** 
 * Looks for intersection of raw types of classes and all super classes and interfaces.
 * @param clazz1 one of the classes to intersect
 * @param clazz2 one of the classes to intersect
 * @return intersection of raw types of classes and all super classes and interfaces
 */
public static List<? extends Class<?>> intersectRawTypes(Class<?> clazz1,Class<?> clazz2){
  if (clazz2 == null) {
    clazz2=Object.class;
  }
  if (clazz1 == null) {
    clazz1=Object.class;
  }
  if (clazz1.isPrimitive()) {
    clazz1=Types.getWrapperClass(clazz1.getName());
  }
  if (clazz2.isPrimitive()) {
    clazz2=Types.getWrapperClass(clazz2.getName());
  }
  if (clazz1.equals(clazz2)) {
    return singletonList(clazz1);
  }
  if (Types.isAssignable(clazz2,clazz1)) {
    return singletonList(clazz1);
  }
  if (Types.isAssignable(clazz1,clazz2)) {
    return singletonList(clazz2);
  }
  final Set<Class<?>> common=commonClasses(clazz1,clazz2);
  final List<Class<?>> list=list(removeSubClasses(common));
  return list.isEmpty() ? LIST_OF_OBJECT_CLASS : list;
}",0.9028571428571428
91166,"/** 
 * @deprecated use {@link #intersectRawTypes} 
 */
@Deprecated public static List<Class<?>> getTheNearestSuperClasses(List<Class<?>> classes,List<Class<?>> otherClasses){
  return new ArrayList<>(intersectRawTypes(classes,otherClasses));
}","/** 
 * Looks for intersection of raw types of classes and all super classes and interfaces
 * @deprecated use {@link #intersectRawTypes}
 * @param classes the first set of classes to intersect
 * @param otherClasses the second set of classes to intersect
 * @return #interectRawTypes(classes, otherClasses)
 */
@Deprecated public static List<Class<?>> getTheNearestSuperClasses(List<Class<?>> classes,List<Class<?>> otherClasses){
  return new ArrayList<>(intersectRawTypes(classes,otherClasses));
}",0.2446236559139785
91167,"/** 
 * @deprecated use {@link #intersectRawTypes} 
 */
@Deprecated public static Class<?> getTheNearestSuperClass(Class<?> clazz1,Class<?> clazz2){
  return intersectRawTypes(clazz1,clazz2).get(0);
}","/** 
 * Looks for intersection of raw types of classes and all super classes and interfaces
 * @param clazz1 one of the classes to intersect.
 * @param clazz2 one of the classes to intersect.
 * @deprecated use {@link #intersectRawTypes}
 * @return #interectRawTypes(clazz1, clazz2).get(0)
 */
@Deprecated public static Class<?> getTheNearestSuperClass(Class<?> clazz1,Class<?> clazz2){
  return intersectRawTypes(clazz1,clazz2).get(0);
}",0.2695924764890282
91168,"/** 
 * For anonymous creations the initial symbol data is symbol data of super class. That needs to be replaced with symbol data of anonymous class. If we don't have symbol data we assume we need one. ;-)
 */
public static boolean needsSymbolData(ObjectCreationExpr n){
  final SymbolType st=symbolDataType(n);
  return st == null || !st.isLoadedAnonymousClass();
}","/** 
 * For anonymous creations the initial symbol data is symbol data of super class. That needs to be replaced with symbol data of anonymous class. If we don't have symbol data we assume we need one. ;-)
 * @param n object creation expression
 * @return if the expression does NOT contains a resolved type
 */
public static boolean needsSymbolData(ObjectCreationExpr n){
  final SymbolType st=symbolDataType(n);
  return st == null || !st.isLoadedAnonymousClass();
}",0.8776978417266187
91169,"public SymbolType cloneAsTypeVariable(String typeVariable){
  return clone(name != null ? name : name(upperBounds,lowerBounds),arrayCount,typeVariable,null,null);
}","public SymbolType cloneAsTypeVariable(String typeVariable){
  return clone(marker,name != null ? name : name(upperBounds,lowerBounds),arrayCount,typeVariable,null,null);
}",0.9791044776119404
91170,"/** 
 * clone with name replaced 
 */
public SymbolType withName(String name){
  return clone(name,arrayCount,typeVariable,null,null);
}","/** 
 * clone with name replaced 
 */
public SymbolType withName(String name){
  return clone(marker,name,arrayCount,typeVariable,null,null);
}",0.974910394265233
91171,"private static String name(List<SymbolType> upperBounds,List<SymbolType> lowerBounds){
  String name=null;
  if (upperBounds != null && !upperBounds.isEmpty()) {
    name=upperBounds.get(0).getName();
  }
 else   if (lowerBounds != null) {
    name=""String_Node_Str"";
  }
  return name;
}","private static String name(List<SymbolType> upperBounds,List<SymbolType> lowerBounds){
  String name=null;
  if (upperBounds != null) {
    if (!upperBounds.isEmpty()) {
      name=upperBounds.get(0).getName();
    }
  }
 else   if (lowerBounds != null) {
    name=""String_Node_Str"";
  }
  return name;
}",0.9594594594594594
91172,"private SymbolType(String name,int arrayCount){
  this.name=name;
  this.arrayCount=arrayCount;
}","private SymbolType(String name,int arrayCount){
  this(Marker.None,name);
  this.arrayCount=arrayCount;
}",0.9108910891089108
91173,"public SymbolType cloneAsArray(String name,int arrayCount){
  return clone(name,arrayCount,typeVariable,null,null);
}","public SymbolType cloneAsArray(String name,int arrayCount){
  return clone(marker,name,arrayCount,typeVariable,null,null);
}",0.970954356846473
91174,"private SymbolType clone(final String name,final int arrayCount,final String typeVariable,Stack<SymbolType> parent,Stack<SymbolType> created){
  SymbolType result=new SymbolType(name);
  result.setClazz(clazz);
  result.setArrayCount(arrayCount);
  result.setField(field);
  result.setMethod(method);
  result.typeVariable=typeVariable;
  if (parent == null) {
    parent=new Stack<>();
    created=new Stack<>();
  }
  Iterator<SymbolType> it=parent.iterator();
  Iterator<SymbolType> it2=created.iterator();
  boolean found=false;
  while (it.hasNext() && !found) {
    SymbolType next=it.next();
    SymbolType created2=it2.next();
    if (next == this) {
      result=created2;
      found=true;
    }
  }
  if (!found) {
    parent.push(this);
    created.push(result);
    if (parameterizedTypes != null) {
      List<SymbolType> list=new LinkedList<>();
      for (      SymbolData type : parameterizedTypes) {
        list.add(((SymbolType)type).clone(parent,created));
      }
      result.setParameterizedTypes(list);
    }
 else {
      result.setParameterizedTypes(null);
    }
    if (upperBounds != null) {
      List<SymbolType> list=new LinkedList<>();
      for (      SymbolData type : upperBounds) {
        list.add(((SymbolType)type).clone(parent,created));
      }
      result.upperBounds=list;
    }
    if (lowerBounds != null) {
      List<SymbolType> list=new LinkedList<>();
      for (      SymbolData type : lowerBounds) {
        list.add(((SymbolType)type).clone(parent,created));
      }
      result.lowerBounds=list;
    }
    parent.pop();
    created.pop();
  }
  return result;
}","private SymbolType clone(final Marker marker,final String name,final int arrayCount,final String typeVariable,Stack<SymbolType> parent,Stack<SymbolType> created){
  SymbolType result=new SymbolType(marker,name);
  result.setClazz(clazz);
  result.setArrayCount(arrayCount);
  result.setField(field);
  result.setMethod(method);
  result.typeVariable=typeVariable;
  if (parent == null) {
    parent=new Stack<>();
    created=new Stack<>();
  }
  Iterator<SymbolType> it=parent.iterator();
  Iterator<SymbolType> it2=created.iterator();
  boolean found=false;
  while (it.hasNext() && !found) {
    SymbolType next=it.next();
    SymbolType created2=it2.next();
    if (next == this) {
      result=created2;
      found=true;
    }
  }
  if (!found) {
    parent.push(this);
    created.push(result);
    if (parameterizedTypes != null) {
      List<SymbolType> list=new LinkedList<>();
      for (      SymbolData type : parameterizedTypes) {
        list.add(((SymbolType)type).clone(parent,created));
      }
      result.setParameterizedTypes(list);
    }
 else {
      result.setParameterizedTypes(null);
    }
    if (upperBounds != null) {
      List<SymbolType> list=new LinkedList<>();
      for (      SymbolData type : upperBounds) {
        list.add(((SymbolType)type).clone(parent,created));
      }
      result.upperBounds=list;
    }
    if (lowerBounds != null) {
      List<SymbolType> list=new LinkedList<>();
      for (      SymbolData type : lowerBounds) {
        list.add(((SymbolType)type).clone(parent,created));
      }
      result.lowerBounds=list;
    }
    parent.pop();
    created.pop();
  }
  return result;
}",0.9917203311867524
91175,"@Override public Scope visit(EnumConstantDeclaration n,SymbolTable symbolTable){
  final Symbol<?> s=symbolTable.findSymbol(n.getName(),ReferenceType.ENUM_LITERAL);
  s.setInnerScope(new Scope(s));
  symbolTable.pushScope(s.getInnerScope());
  SymbolType parentType=symbolTable.getType(""String_Node_Str"",ReferenceType.VARIABLE);
  List<SymbolAction> actions=new LinkedList<SymbolAction>();
  actions.add(new LoadTypeParamsAction());
  actions.add(new LoadTypeDeclarationsAction(typeTable));
  actions.add(new LoadFieldDeclarationsAction(actionProvider));
  actions.add(new LoadMethodDeclarationsAction(actionProvider,expressionTypeAnalyzer));
  if (actionProvider != null) {
    actions.addAll(actionProvider.getActions(n));
  }
  symbolTable.pushSymbol(""String_Node_Str"",ReferenceType.VARIABLE,parentType,n.getParentNode(),(List<SymbolAction>)null);
  String name=symbolTable.generateAnonymousClass();
  final SymbolType type=new SymbolType(name);
  symbolTable.pushSymbol(name,ReferenceType.TYPE,type,n,actions);
  symbolTable.pushSymbol(""String_Node_Str"",ReferenceType.VARIABLE,type,n,actions);
  n.setSymbolData(type);
  symbolTable.popScope(true);
  return s.getInnerScope();
}","@Override public Scope visit(EnumConstantDeclaration n,SymbolTable symbolTable){
  final Symbol<?> s=symbolTable.findSymbol(n.getName(),ReferenceType.ENUM_LITERAL);
  s.setInnerScope(new Scope(s));
  symbolTable.pushScope(s.getInnerScope());
  SymbolType parentType=symbolTable.getType(""String_Node_Str"",ReferenceType.VARIABLE);
  List<SymbolAction> actions=new LinkedList<SymbolAction>();
  actions.add(new LoadTypeParamsAction());
  actions.add(new LoadTypeDeclarationsAction(typeTable));
  actions.add(new LoadFieldDeclarationsAction(actionProvider));
  actions.add(new LoadMethodDeclarationsAction(actionProvider,expressionTypeAnalyzer));
  if (actionProvider != null) {
    actions.addAll(actionProvider.getActions(n));
  }
  symbolTable.pushSymbol(""String_Node_Str"",ReferenceType.VARIABLE,parentType,n.getParentNode(),(List<SymbolAction>)null);
  String name=symbolTable.generateAnonymousClass();
  final SymbolType type=SymbolType.enumConstantOf(name);
  symbolTable.pushSymbol(name,ReferenceType.TYPE,type,n,actions);
  symbolTable.pushSymbol(""String_Node_Str"",ReferenceType.VARIABLE,type,n,actions);
  n.setSymbolData(type);
  symbolTable.popScope(true);
  return s.getInnerScope();
}",0.983578947368421
91176,"public void setTypeArgs(SymbolType[] typeArgs){
  this.typeArgs=typeArgs;
}","/** 
 * Sets the type of the method call arguments. In case of foo(1) => int foo(1, 1, 1) => int, int, int Then according the analyzed method, analyzes it can be called from the types. foo(int.. x) foo(int x) foo(Object x)
 * @param typeArgs
 */
public void setTypeArgs(SymbolType[] typeArgs){
  this.typeArgs=typeArgs;
}",0.3787878787878788
91177,"@Override public boolean filter(T elem) throws Exception {
  int elemParameterCount=0;
  Type[] genericParameterTypes=null;
  Class<?> declaringClass=null;
  if (elem instanceof Method) {
    elemParameterCount=((Method)elem).getParameterTypes().length;
    genericParameterTypes=((Method)elem).getGenericParameterTypes();
    declaringClass=((Method)elem).getDeclaringClass();
  }
 else   if (elem instanceof Constructor) {
    elemParameterCount=((Constructor<?>)elem).getParameterTypes().length;
    genericParameterTypes=((Constructor<?>)elem).getGenericParameterTypes();
    declaringClass=((Constructor<?>)elem).getDeclaringClass();
  }
 else {
    return false;
  }
  Object equivalentMethod=null;
  sd=(SymbolType)expression.getScope().getSymbolData();
  if (sd == null) {
    expression.getScope().accept(typeResolver,ctx);
    sd=(SymbolType)expression.getScope().getSymbolData();
    if (!expression.getIdentifier().equals(""String_Node_Str"")) {
      if (methodsArray == null) {
        Set<Method> methods=MethodInspector.getVisibleMethods(sd.getClazz(),thisClass);
        methodsArray=new Method[methods.size()];
        methods.toArray(methodsArray);
        ExecutableSorter sorter=new ExecutableSorter();
        List<Method> sortedMethods=sorter.sort(methodsArray,null);
        sortedMethods.toArray(methodsArray);
      }
      ArrayFilter<Method> filter=new ArrayFilter<Method>(methodsArray);
      filter.appendPredicate(new MethodsByNamePredicate(expression.getIdentifier()));
      methodCallCandidates=filter.filter();
    }
  }
  boolean found=false;
  if (!expression.getIdentifier().equals(""String_Node_Str"")) {
    Iterator<Method> it=methodCallCandidates.iterator();
    while (it.hasNext() && !found) {
      Method md=it.next();
      int mdParameterCount=md.getParameterTypes().length;
      Map<String,SymbolType> typeMapping=getTypeMapping();
      FunctionalGenericsBuilder<MethodReferenceExpr> builder=new FunctionalGenericsBuilder<MethodReferenceExpr>(md,typeResolver,typeMapping);
      builder.build(expression);
      SymbolType[] args=builder.getArgs();
      if (!Modifier.isStatic(md.getModifiers())) {
        if (mdParameterCount == elemParameterCount - 1) {
          SymbolType[] genericArgs=new SymbolType[genericParameterTypes.length];
          boolean allAreGenerics=true;
          for (int i=0; i < genericParameterTypes.length && allAreGenerics; i++) {
            if (genericParameterTypes[i] instanceof TypeVariable<?>) {
              TypeVariable<?> td=(TypeVariable<?>)genericParameterTypes[i];
              genericArgs[i]=typeMapping.get(td.getName());
              allAreGenerics=genericArgs[i] != null;
            }
 else {
              allAreGenerics=false;
            }
          }
          if (allAreGenerics) {
            setTypeArgs(genericArgs);
            found=super.filter(elem);
          }
 else {
            SymbolType[] staticArgs=new SymbolType[args.length + 1];
            for (int i=0; i < args.length; i++) {
              staticArgs[i + 1]=args[i];
            }
            staticArgs[0]=(SymbolType)sd;
            args=staticArgs;
            setTypeArgs(args);
            found=super.filter(elem);
          }
        }
 else {
          Expression scope=expression.getScope();
          SymbolType stype=(SymbolType)scope.getSymbolData();
          boolean isField=stype.getField() != null;
          boolean isVariable=false;
          boolean isSuper=scope instanceof SuperExpr;
          if (!isField && !isSuper) {
            String name=scope.toString();
            isVariable=(symTable.findSymbol(name,ReferenceType.VARIABLE) != null);
          }
          if ((isField || isVariable || isSuper) && mdParameterCount == elemParameterCount) {
            setTypeArgs(args);
            found=super.filter(elem);
          }
        }
      }
 else       if (mdParameterCount == elemParameterCount) {
        setTypeArgs(args);
        found=super.filter(elem);
      }
      if (found) {
        equivalentMethod=md;
      }
    }
  }
 else {
    Constructor<?>[] constructors=sd.getClazz().getDeclaredConstructors();
    for (int i=0; i < constructors.length && !found; i++) {
      FunctionalGenericsBuilder<MethodReferenceExpr> builder=new FunctionalGenericsBuilder<MethodReferenceExpr>(constructors[i],typeResolver,getTypeMapping());
      builder.build(expression);
      SymbolType[] args=builder.getArgs();
      setTypeArgs(args);
      found=super.filter(elem);
      if (found) {
        equivalentMethod=constructors[i];
      }
    }
  }
  if (found && elem instanceof Method) {
    Map<String,SymbolType> mapping=getTypeMapping();
    SymbolType realResultType=null;
    if (equivalentMethod instanceof Method) {
      realResultType=SymbolType.valueOf((Method)equivalentMethod,mapping);
      java.lang.reflect.Type genericReturnType=((Method)elem).getGenericReturnType();
      resolveTypeMapping(genericReturnType,realResultType,mapping);
    }
    realResultType=SymbolType.valueOf(declaringClass,mapping);
    expression.setSymbolData(realResultType);
    SymbolType st=SymbolType.valueOf((Method)elem,mapping);
    expression.setReferencedMethodSymbolData(st);
    expression.setReferencedArgsSymbolData(getTypeArgs());
  }
  return found;
}","@Override public boolean filter(T elem) throws Exception {
  int elemParameterCount=0;
  Type[] genericParameterTypes=null;
  Class<?> declaringClass=null;
  Map<String,SymbolType> typeMapping=getTypeMapping();
  FunctionalGenericsBuilder<MethodReferenceExpr> builder=null;
  if (elem instanceof Method) {
    elemParameterCount=((Method)elem).getParameterTypes().length;
    genericParameterTypes=((Method)elem).getGenericParameterTypes();
    declaringClass=((Method)elem).getDeclaringClass();
    builder=new FunctionalGenericsBuilder<>(((Method)elem),typeResolver,typeMapping);
  }
 else   if (elem instanceof Constructor) {
    elemParameterCount=((Constructor<?>)elem).getParameterTypes().length;
    genericParameterTypes=((Constructor<?>)elem).getGenericParameterTypes();
    declaringClass=((Constructor<?>)elem).getDeclaringClass();
    builder=new FunctionalGenericsBuilder<>(((Constructor<?>)elem),typeResolver,typeMapping);
  }
 else {
    return false;
  }
  builder.build(expression);
  Object equivalentMethod=null;
  sd=(SymbolType)expression.getScope().getSymbolData();
  if (sd == null) {
    expression.getScope().accept(typeResolver,ctx);
    sd=(SymbolType)expression.getScope().getSymbolData();
    if (!expression.getIdentifier().equals(""String_Node_Str"")) {
      if (methodsArray == null) {
        Set<Method> methods=MethodInspector.getVisibleMethods(sd.getClazz(),thisClass);
        methodsArray=new Method[methods.size()];
        methods.toArray(methodsArray);
        ExecutableSorter sorter=new ExecutableSorter();
        List<Method> sortedMethods=sorter.sort(methodsArray,null);
        sortedMethods.toArray(methodsArray);
      }
      ArrayFilter<Method> filter=new ArrayFilter<Method>(methodsArray);
      filter.appendPredicate(new MethodsByNamePredicate(expression.getIdentifier()));
      methodCallCandidates=filter.filter();
    }
  }
  boolean found=false;
  if (!expression.getIdentifier().equals(""String_Node_Str"")) {
    Iterator<Method> it=methodCallCandidates.iterator();
    SymbolType[] args=builder.getArgs();
    while (it.hasNext() && !found) {
      Method md=it.next();
      int mdParameterCount=md.getParameterTypes().length;
      if (!Modifier.isStatic(md.getModifiers())) {
        if (mdParameterCount == elemParameterCount - 1) {
          SymbolType[] genericArgs=new SymbolType[genericParameterTypes.length];
          boolean allAreGenerics=true;
          for (int i=0; i < genericParameterTypes.length && allAreGenerics; i++) {
            if (genericParameterTypes[i] instanceof TypeVariable<?>) {
              TypeVariable<?> td=(TypeVariable<?>)genericParameterTypes[i];
              genericArgs[i]=typeMapping.get(td.getName());
              allAreGenerics=genericArgs[i] != null;
            }
 else {
              allAreGenerics=false;
            }
          }
          if (allAreGenerics) {
            setTypeArgs(genericArgs);
            found=super.filter(elem);
          }
 else {
            SymbolType[] staticArgs=new SymbolType[args.length + 1];
            for (int i=0; i < args.length; i++) {
              staticArgs[i + 1]=args[i];
            }
            staticArgs[0]=(SymbolType)sd;
            args=staticArgs;
            setTypeArgs(args);
            found=super.filter(elem);
          }
        }
 else {
          Expression scope=expression.getScope();
          SymbolType stype=(SymbolType)scope.getSymbolData();
          boolean isField=stype.getField() != null;
          boolean isVariable=false;
          boolean isSuper=scope instanceof SuperExpr;
          if (!isField && !isSuper) {
            String name=scope.toString();
            isVariable=(symTable.findSymbol(name,ReferenceType.VARIABLE) != null);
          }
          if ((isField || isVariable || isSuper) && mdParameterCount == elemParameterCount) {
            setTypeArgs(args);
            found=super.filter(elem);
          }
        }
      }
 else       if (mdParameterCount == elemParameterCount) {
        setTypeArgs(args);
        found=super.filter(elem);
      }
      if (found) {
        equivalentMethod=md;
      }
    }
  }
 else {
    SymbolType[] args=builder.getArgs();
    setTypeArgs(args);
    found=super.filter(elem);
  }
  if (found && elem instanceof Method) {
    Map<String,SymbolType> mapping=getTypeMapping();
    SymbolType realResultType=null;
    if (equivalentMethod != null && equivalentMethod instanceof Method) {
      realResultType=SymbolType.valueOf((Method)equivalentMethod,mapping);
      java.lang.reflect.Type genericReturnType=((Method)elem).getGenericReturnType();
      resolveTypeMapping(genericReturnType,realResultType,mapping);
    }
    realResultType=SymbolType.valueOf(declaringClass,mapping);
    expression.setSymbolData(realResultType);
    SymbolType st=SymbolType.valueOf((Method)elem,mapping);
    expression.setReferencedMethodSymbolData(st);
    expression.setReferencedArgsSymbolData(getTypeArgs());
  }
  return found;
}",0.7446766946669271
91178,"private static SymbolType valueOfClass(Class<?> type,SymbolType arg,Map<String,SymbolType> updatedTypeMapping,Map<String,SymbolType> typeMapping) throws InvalidTypeException {
  SymbolType returnType;
  Class<?> aux=type;
  returnType=new SymbolType();
  int arrayCount=0;
  while (aux.isArray()) {
    arrayCount++;
    aux=aux.getComponentType();
  }
  returnType.setArrayCount(arrayCount);
  returnType.setName(aux.getName());
  Type[] typeParams=aux.getTypeParameters();
  if (typeParams.length > 0) {
    List<SymbolType> params=new LinkedList<SymbolType>();
    List<SymbolType> implParams=new LinkedList<SymbolType>();
    boolean isParameterizedImplementation=false;
    List<SymbolType> parameterizedTypes=null;
    Iterator<SymbolType> it=null;
    if (arg != null) {
      Class<?> argClass=arg.getClazz();
      parameterizedTypes=arg.getParameterizedTypes();
      if (parameterizedTypes != null) {
        it=parameterizedTypes.iterator();
      }
      List<Type> implementations=ClassInspector.getInterfaceOrSuperclassImplementations(argClass,aux);
      Iterator<Type> itTypes=implementations.iterator();
      Type[] typeParamsAux=typeParams;
      Map<String,SymbolType> auxMap=new HashMap<String,SymbolType>(typeMapping);
      while (itTypes.hasNext()) {
        Type implementation=itTypes.next();
        if (implementation instanceof ParameterizedType) {
          ParameterizedType ptype=(ParameterizedType)implementation;
          Map<String,SymbolType> typeMappingVars=arg.getTypeMappingVariables();
          Type[] targuments=ptype.getActualTypeArguments();
          for (int i=0; i < targuments.length; i++) {
            SymbolType st=null;
            if (targuments[i] instanceof TypeVariable) {
              String name=((TypeVariable<?>)targuments[i]).getName();
              if (typeMappingVars != null && typeMappingVars.containsKey(name)) {
                st=typeMappingVars.get(name);
              }
 else               if (it != null && it.hasNext()) {
                st=it.next();
              }
 else {
                st=new SymbolType(Object.class);
              }
            }
 else {
              st=SymbolType.valueOf(targuments[i],auxMap);
            }
            if (st != null) {
              implParams.add(st);
            }
          }
          isParameterizedImplementation=true;
          it=implParams.iterator();
          params=implParams;
          implParams=new LinkedList<SymbolType>();
          parameterizedTypes=params;
        }
 else         if (implementation instanceof Class<?>) {
          Class<?> auxClass=(Class<?>)implementation;
          boolean isRecursiveThenOmit=false;
          if (type instanceof Class<?>) {
            isRecursiveThenOmit=((Class<?>)type).getName().equals(auxClass.getName());
          }
          if (!isRecursiveThenOmit) {
            typeParamsAux=auxClass.getTypeParameters();
            loadTypeParams(it,typeParamsAux,parameterizedTypes,typeMapping,auxMap);
          }
        }
      }
    }
    if (!isParameterizedImplementation) {
      if (parameterizedTypes != null) {
        it=parameterizedTypes.iterator();
      }
      for (int i=0; i < typeParams.length; i++) {
        SymbolType ref=null;
        if (it != null && it.hasNext()) {
          ref=it.next();
        }
        boolean isRecursiveThenOmit=false;
        if (typeParams[i] instanceof TypeVariable) {
          TypeVariable<?> tv=(TypeVariable<?>)typeParams[i];
          Type[] types=tv.getBounds();
          if (types.length == 1) {
            if (types[0] instanceof Class<?> && type instanceof Class<?>) {
              isRecursiveThenOmit=((Class<?>)type).getName().equals(((Class<?>)types[0]).getName());
            }
          }
        }
        if (!isRecursiveThenOmit) {
          SymbolType tp=valueOf(typeParams[i],ref,updatedTypeMapping,typeMapping);
          if (tp != null) {
            params.add(tp);
          }
        }
 else {
          params.add(returnType);
        }
      }
    }
    if (!params.isEmpty()) {
      returnType.setParameterizedTypes(params);
    }
  }
  return returnType;
}","private static SymbolType valueOfClass(Class<?> type,SymbolType arg,Map<String,SymbolType> updatedTypeMapping,Map<String,SymbolType> typeMapping) throws InvalidTypeException {
  SymbolType returnType;
  Class<?> aux=type;
  returnType=new SymbolType();
  int arrayCount=0;
  while (aux.isArray()) {
    arrayCount++;
    aux=aux.getComponentType();
  }
  returnType.setArrayCount(arrayCount);
  returnType.setName(aux.getName());
  Type[] typeParams=aux.getTypeParameters();
  if (typeParams.length > 0) {
    List<SymbolType> params=new LinkedList<SymbolType>();
    List<SymbolType> implParams=new LinkedList<SymbolType>();
    boolean isParameterizedImplementation=false;
    List<SymbolType> parameterizedTypes=null;
    Iterator<SymbolType> it=null;
    if (arg != null) {
      Class<?> argClass=arg.getClazz();
      parameterizedTypes=arg.getParameterizedTypes();
      if (parameterizedTypes != null) {
        it=parameterizedTypes.iterator();
      }
      List<Type> implementations=ClassInspector.getInterfaceOrSuperclassImplementations(argClass,aux);
      Iterator<Type> itTypes=implementations.iterator();
      Type[] typeParamsAux=typeParams;
      Map<String,SymbolType> auxMap=new HashMap<String,SymbolType>(typeMapping);
      while (itTypes.hasNext()) {
        Type implementation=itTypes.next();
        if (implementation instanceof ParameterizedType) {
          ParameterizedType ptype=(ParameterizedType)implementation;
          Map<String,SymbolType> typeMappingVars=arg.getTypeMappingVariables();
          Type[] targuments=ptype.getActualTypeArguments();
          for (int i=0; i < targuments.length; i++) {
            SymbolType st=null;
            if (targuments[i] instanceof TypeVariable) {
              String name=((TypeVariable<?>)targuments[i]).getName();
              if (typeMappingVars != null && typeMappingVars.containsKey(name)) {
                st=typeMappingVars.get(name);
              }
 else               if (it != null && it.hasNext()) {
                st=it.next();
              }
 else {
                st=new SymbolType(Object.class);
              }
            }
 else {
              st=SymbolType.valueOf(targuments[i],auxMap);
            }
            if (st != null) {
              implParams.add(st);
            }
          }
          isParameterizedImplementation=true;
          it=implParams.iterator();
          params=implParams;
          implParams=new LinkedList<SymbolType>();
          parameterizedTypes=params;
        }
 else         if (implementation instanceof Class<?>) {
          Class<?> auxClass=(Class<?>)implementation;
          boolean isRecursiveThenOmit=false;
          if (type instanceof Class<?>) {
            isRecursiveThenOmit=((Class<?>)type).getName().equals(auxClass.getName());
          }
          if (!isRecursiveThenOmit) {
            typeParamsAux=auxClass.getTypeParameters();
            loadTypeParams(it,typeParamsAux,parameterizedTypes,typeMapping,auxMap);
          }
        }
      }
    }
    if (!isParameterizedImplementation) {
      if (parameterizedTypes != null) {
        it=parameterizedTypes.iterator();
      }
      for (int i=0; i < typeParams.length; i++) {
        SymbolType ref=null;
        if (it != null && it.hasNext()) {
          ref=it.next();
        }
        boolean isRecursiveThenOmit=false;
        if (typeParams[i] instanceof TypeVariable) {
          TypeVariable<?> tv=(TypeVariable<?>)typeParams[i];
          Type[] types=tv.getBounds();
          if (types.length == 1) {
            if (types[0] instanceof Class<?> && type instanceof Class<?>) {
              isRecursiveThenOmit=((Class<?>)type).getName().equals(((Class<?>)types[0]).getName());
            }
          }
        }
        if (!isRecursiveThenOmit) {
          SymbolType tp=valueOf(typeParams[i],ref,updatedTypeMapping,typeMapping);
          if (arg != null || !Object.class.getName().equals(tp.getName())) {
            if (tp != null) {
              params.add(tp);
            }
          }
        }
 else {
          params.add(returnType);
        }
      }
    }
    if (!params.isEmpty()) {
      returnType.setParameterizedTypes(params);
    }
  }
  return returnType;
}",0.9881394512998682
91179,"@Test public void testRawTypes() throws Exception {
  compile(""String_Node_Str"");
  SymbolTable symTable=getSymbolTable();
  symTable.pushScope();
  SymbolType st=new SymbolType(getClassLoader().loadClass(""String_Node_Str""));
  symTable.pushSymbol(""String_Node_Str"",ReferenceType.VARIABLE,st,null);
  FieldAccessExpr expr=(FieldAccessExpr)ASTManager.parse(Expression.class,""String_Node_Str"");
  HashMap<String,Object> ctx=new HashMap<String,Object>();
  expressionAnalyzer.visit(expr,ctx);
  SymbolType type=(SymbolType)expr.getSymbolData();
  Assert.assertNotNull(type);
  Assert.assertEquals(""String_Node_Str"",type.getName());
  Assert.assertNotNull(type.getParameterizedTypes());
  Assert.assertEquals(""String_Node_Str"",type.getParameterizedTypes().get(0).getName());
}","@Test public void testRawTypes() throws Exception {
  compile(""String_Node_Str"" + ""String_Node_Str"");
  SymbolTable symTable=getSymbolTable();
  symTable.pushScope();
  SymbolType st=new SymbolType(getClassLoader().loadClass(""String_Node_Str""));
  symTable.pushSymbol(""String_Node_Str"",ReferenceType.VARIABLE,st,null);
  SymbolType qualified=getSymbolType(""String_Node_Str"");
  Assert.assertNotNull(qualified);
  Assert.assertEquals(""String_Node_Str"",qualified.getName());
  Assert.assertNotNull(qualified.getParameterizedTypes());
  Assert.assertEquals(""String_Node_Str"",qualified.getParameterizedTypes().get(0).getName());
  FieldAccessExpr expr=(FieldAccessExpr)ASTManager.parse(Expression.class,""String_Node_Str"");
  HashMap<String,Object> ctx=new HashMap<String,Object>();
  expressionAnalyzer.visit(expr,ctx);
  SymbolType type=(SymbolType)expr.getSymbolData();
  Assert.assertNotNull(type);
  Assert.assertEquals(""String_Node_Str"",type.getName());
  Assert.assertNull(type.getParameterizedTypes());
}",0.7655986509274874
91180,"@Override public String toString(){
  StringBuffer result=new StringBuffer();
  result.append(name);
  if (parameterizedTypes != null) {
    result.append(""String_Node_Str"");
    Iterator<? extends SymbolData> it=parameterizedTypes.iterator();
    while (it.hasNext()) {
      SymbolType next=(SymbolType)it.next();
      result.append(next.toString());
      if (it.hasNext()) {
        result.append(""String_Node_Str"");
      }
    }
    result.append(""String_Node_Str"");
  }
  for (int i=0; i < arrayCount; i++) {
    result.append(""String_Node_Str"");
  }
  return result.toString();
}","@Override public String toString(){
  StringBuffer result=new StringBuffer();
  addString(result,new ArrayDeque<SymbolType>());
  return result.toString();
}",0.3677852348993288
91181,"@Override public String toString(){
  StringBuffer result=new StringBuffer();
  result.append(name);
  if (parameterizedTypes != null) {
    result.append(""String_Node_Str"");
    Iterator<? extends SymbolData> it=parameterizedTypes.iterator();
    while (it.hasNext()) {
      SymbolType next=(SymbolType)it.next();
      result.append(next.toString());
      if (it.hasNext()) {
        result.append(""String_Node_Str"");
      }
    }
    result.append(""String_Node_Str"");
  }
  for (int i=0; i < arrayCount; i++) {
    result.append(""String_Node_Str"");
  }
  return result.toString();
}","@Override public String toString(){
  StringBuffer result=new StringBuffer();
  addString(result,new ArrayDeque<SymbolType>());
  return result.toString();
}",0.3677852348993288
91182,"public void loadExtendsOrImplements(List<ClassOrInterfaceType> extendsList){
  if (extendsList != null) {
    Symbol<?> superSym=table.findSymbol(""String_Node_Str"");
    Map<String,SymbolType> typeParams=null;
    Scope superScope=null;
    if (superSym != null) {
      superScope=superSym.getInnerScope();
      if (superScope != null) {
        typeParams=superScope.getTypeParams();
      }
    }
    for (    ClassOrInterfaceType type : extendsList) {
      String name=type.getName();
      ClassOrInterfaceType scope=type.getScope();
      if (scope != null) {
        name=scope.toString() + ""String_Node_Str"" + name;
      }
      Symbol<?> s=table.findSymbol(name,ReferenceType.TYPE);
      if (s != null) {
        Scope inner=s.getInnerScope();
        Object location=s.getLocation();
        if (location != null && location instanceof TypeDeclaration) {
          ((TypeDeclaration)location).accept(this,inner);
          List<SymbolType> parameters=s.getType().getParameterizedTypes();
          if (parameters != null && typeParams != null) {
            List<Symbol<?>> symbols=inner.getSymbolsByType(ReferenceType.VARIABLE);
            table.pushScope(superScope);
            for (            Symbol<?> sym : symbols) {
              String symName=sym.getName();
              if (!""String_Node_Str"".equals(symName) && !""String_Node_Str"".equals(symName)) {
                SymbolType refactorized=sym.getType().refactor(typeParams);
                table.pushSymbol(symName,ReferenceType.VARIABLE,refactorized,sym.getLocation());
              }
            }
            table.popScope(true);
          }
        }
 else {
          Class<?> clazz=s.getType().getClazz();
          Set<Field> fields=FieldInspector.getNonPrivateFields(clazz);
          List<SymbolType> params=table.getType(""String_Node_Str"").getParameterizedTypes();
          for (          Field field : fields) {
            try {
              Map<String,SymbolType> typeMapping=null;
              if (typeParams != null) {
                typeMapping=new HashMap<String,SymbolType>(typeParams);
                GenericBuilderFromGenericClasses builder=new GenericBuilderFromGenericClasses(field.getDeclaringClass(),params);
                builder.build(typeMapping);
              }
              table.pushSymbol(field.getName(),ReferenceType.VARIABLE,SymbolType.valueOf(field.getGenericType(),typeMapping),null,true);
            }
 catch (            InvalidTypeException e) {
              throw new RuntimeException(e);
            }
          }
        }
      }
    }
  }
}","public void loadExtendsOrImplements(List<ClassOrInterfaceType> extendsList){
  if (extendsList != null) {
    Symbol<?> superSym=table.findSymbol(""String_Node_Str"");
    Map<String,SymbolType> typeParams=null;
    Scope superScope=null;
    if (superSym != null) {
      superScope=superSym.getInnerScope();
      if (superScope != null) {
        typeParams=superScope.getTypeParams();
      }
    }
    for (    ClassOrInterfaceType type : extendsList) {
      String name=type.getName();
      ClassOrInterfaceType scope=type.getScope();
      if (scope != null) {
        name=scope.toString() + ""String_Node_Str"" + name;
      }
      Symbol<?> s=table.findSymbol(name,ReferenceType.TYPE);
      if (s != null) {
        Scope inner=s.getInnerScope();
        Object location=s.getLocation();
        if (location != null && location instanceof TypeDeclaration) {
          ((TypeDeclaration)location).accept(this,inner);
          List<SymbolType> parameters=s.getType().getParameterizedTypes();
          if (parameters != null && typeParams != null) {
            List<Symbol<?>> symbols=inner.getSymbolsByType(ReferenceType.VARIABLE);
            table.pushScope(superScope);
            for (            Symbol<?> sym : symbols) {
              String symName=sym.getName();
              if (!""String_Node_Str"".equals(symName) && !""String_Node_Str"".equals(symName)) {
                SymbolType refactorized=sym.getType().refactor(typeParams);
                table.pushSymbol(symName,ReferenceType.VARIABLE,refactorized,sym.getLocation());
              }
            }
            table.popScope(true);
          }
        }
 else {
          Class<?> clazz=s.getType().getClazz();
          loadFieldsFromClass(clazz,typeParams);
        }
      }
 else {
        Class<?> clazz=null;
        if (type.getParentNode() instanceof ObjectCreationExpr) {
          ObjectCreationExpr parent=(ObjectCreationExpr)type.getParentNode();
          clazz=parent.getSymbolData().getClazz().getSuperclass();
        }
 else {
          SymbolType stype=ASTSymbolTypeResolver.getInstance().valueOf(type);
          clazz=stype.getClazz();
        }
        loadFieldsFromClass(clazz,typeParams);
      }
    }
  }
}",0.7450980392156863
91183,"public static SymbolType findFieldType(SymbolTable symTable,SymbolType scope,String fieldName){
  SymbolType result=null;
  if (scope != null) {
    List<Class<?>> classes=scope.getBoundClasses();
    Iterator<Class<?>> it=classes.iterator();
    while (it.hasNext() && result == null) {
      try {
        Class<?> clazz=it.next();
        Field field=null;
        if (scope.getArrayCount() > 0 && fieldName.equals(""String_Node_Str"")) {
          result=new SymbolType(""String_Node_Str"");
        }
 else {
          try {
            field=clazz.getDeclaredField(fieldName);
          }
 catch (          NoSuchFieldException fe) {
            field=getField0(clazz.getPackage(),clazz,fieldName);
            if (field == null) {
              SymbolType st=symTable.getType(""String_Node_Str"");
              Class<?> internal=ClassInspector.findClassMember(st.getClazz().getPackage(),fieldName,clazz);
              if (internal != null) {
                result=new SymbolType(internal);
              }
            }
          }
          if (result == null) {
            Map<String,SymbolType> typeMapping=new HashMap<String,SymbolType>();
            GenericBuilderFromGenericClasses builder=new GenericBuilderFromGenericClasses(clazz,scope.getParameterizedTypes());
            builder.build(typeMapping);
            result=SymbolType.valueOf(field.getGenericType(),typeMapping);
            result.setField(field);
          }
        }
      }
 catch (      Exception e) {
        throw new NoSuchExpressionTypeException(e);
      }
    }
  }
  return result;
}","public static SymbolType findFieldType(SymbolTable symTable,SymbolType scope,String fieldName){
  SymbolType result=null;
  if (scope != null) {
    List<Class<?>> classes=scope.getBoundClasses();
    Iterator<Class<?>> it=classes.iterator();
    while (it.hasNext() && result == null) {
      try {
        Class<?> clazz=it.next();
        Field field=null;
        if (scope.getArrayCount() > 0 && fieldName.equals(""String_Node_Str"")) {
          result=new SymbolType(""String_Node_Str"");
        }
 else {
          try {
            field=clazz.getDeclaredField(fieldName);
          }
 catch (          NoSuchFieldException fe) {
            field=getField0(clazz.getPackage(),clazz,fieldName);
            if (field == null) {
              SymbolType st=symTable.getType(""String_Node_Str"");
              Class<?> internal=ClassInspector.findClassMember(st.getClazz().getPackage(),fieldName,clazz);
              if (internal != null) {
                result=new SymbolType(internal);
              }
            }
          }
          if (result == null && field != null) {
            Map<String,SymbolType> typeMapping=new HashMap<String,SymbolType>();
            GenericBuilderFromGenericClasses builder=new GenericBuilderFromGenericClasses(clazz,scope.getParameterizedTypes());
            builder.build(typeMapping);
            result=SymbolType.valueOf(field.getGenericType(),typeMapping);
            result.setField(field);
          }
        }
      }
 catch (      Exception e) {
        throw new NoSuchExpressionTypeException(e);
      }
    }
  }
  if (result == null) {
    throw new RuntimeException(""String_Node_Str"" + fieldName + ""String_Node_Str"");
  }
  return result;
}",0.9517998779743746
91184,"private void updateTypeMapping(java.lang.reflect.Type type,SymbolTable genericsSymbolTable,SymbolType parameterizedType,boolean genericArgs,Set<String> processedTypeVariables) throws InvalidTypeException {
  if (parameterizedType != null) {
    if (type instanceof TypeVariable) {
      TypeVariable<?> tv=(TypeVariable<?>)type;
      String vname=tv.getName();
      if (!processedTypeVariables.contains(vname)) {
        processedTypeVariables.add(vname);
        Symbol<?> s=genericsSymbolTable.findSymbol(vname);
        if (s != null) {
          boolean isInTheTopScope=genericsSymbolTable.getScopes().peek().findSymbol(vname) != null;
          SymbolType st=s.getType();
          if (st != null) {
            SymbolType refactor=s.getType().refactor(vname,parameterizedType,genericArgs || isInTheTopScope);
            refactor.setTemplateVariable(vname);
            s.setType(refactor);
          }
 else {
            s.setType(parameterizedType);
          }
        }
 else {
          genericsSymbolTable.pushSymbol(vname,ReferenceType.TYPE,parameterizedType,null);
        }
        java.lang.reflect.Type[] bounds=tv.getBounds();
        List<SymbolType> paramBounds=parameterizedType.getBounds();
        if (paramBounds != null) {
          for (int i=0; i < bounds.length; i++) {
            updateTypeMapping(bounds[i],genericsSymbolTable,paramBounds.get(i),genericArgs,processedTypeVariables);
          }
        }
      }
    }
 else     if (type instanceof WildcardType) {
      WildcardType wildcard=(WildcardType)type;
      java.lang.reflect.Type[] bounds=wildcard.getUpperBounds();
      List<SymbolType> paramBounds=parameterizedType.getBounds();
      if (paramBounds != null) {
        for (int i=0; i < bounds.length; i++) {
          updateTypeMapping(bounds[i],genericsSymbolTable,paramBounds.get(i),genericArgs,processedTypeVariables);
        }
      }
      bounds=wildcard.getLowerBounds();
      paramBounds=parameterizedType.getLowerBounds();
      if (paramBounds != null) {
        for (int i=0; i < bounds.length; i++) {
          updateTypeMapping(bounds[i],genericsSymbolTable,paramBounds.get(i),genericArgs,processedTypeVariables);
        }
      }
    }
 else     if (type instanceof ParameterizedType) {
      ParameterizedType paramType=(ParameterizedType)type;
      java.lang.reflect.Type[] typeArgs=paramType.getActualTypeArguments();
      List<SymbolType> paramTypeParams=parameterizedType.getParameterizedTypes();
      if (paramTypeParams != null) {
        for (int i=0; i < typeArgs.length; i++) {
          SymbolType st=null;
          if (i < paramTypeParams.size()) {
            st=paramTypeParams.get(i);
          }
          updateTypeMapping(typeArgs[i],genericsSymbolTable,st,genericArgs,processedTypeVariables);
        }
      }
    }
 else     if (type instanceof GenericArrayType) {
      GenericArrayType arrayType=(GenericArrayType)type;
      SymbolType st=parameterizedType.clone();
      st.setArrayCount(parameterizedType.getArrayCount() - 1);
      updateTypeMapping(arrayType.getGenericComponentType(),genericsSymbolTable,st,genericArgs,processedTypeVariables);
    }
 else     if (type instanceof Class) {
      Class<?> clazz=(Class<?>)type;
      Map<String,SymbolType> updateMapping=new LinkedHashMap<String,SymbolType>();
      SymbolType rewrittenType=SymbolType.valueOf(clazz,parameterizedType,updateMapping,null);
      java.lang.reflect.TypeVariable[] tparams=clazz.getTypeParameters();
      List<SymbolType> paramTypes=rewrittenType.getParameterizedTypes();
      if (paramTypes != null) {
        Iterator<SymbolType> it=paramTypes.iterator();
        for (int i=0; i < tparams.length && it.hasNext(); i++) {
          SymbolType st=it.next();
          if (st != null) {
            st.setTemplateVariable(tparams[i].getName());
            updateTypeMapping(tparams[i],genericsSymbolTable,st,true,new HashSet<String>());
          }
        }
      }
    }
  }
}","private void updateTypeMapping(java.lang.reflect.Type type,SymbolTable genericsSymbolTable,SymbolType parameterizedType,boolean genericArgs,Set<String> processedTypeVariables) throws InvalidTypeException {
  if (parameterizedType != null) {
    if (type instanceof TypeVariable) {
      TypeVariable<?> tv=(TypeVariable<?>)type;
      String vname=tv.getName();
      if (!processedTypeVariables.contains(vname)) {
        processedTypeVariables.add(vname);
        Symbol<?> s=genericsSymbolTable.findSymbol(vname);
        if (s != null) {
          boolean isInTheTopScope=genericsSymbolTable.getScopes().peek().findSymbol(vname) != null;
          SymbolType st=s.getType();
          if (st != null) {
            SymbolType refactor=s.getType().refactor(vname,parameterizedType,genericArgs || isInTheTopScope);
            refactor.setTemplateVariable(vname);
            s.setType(refactor);
          }
 else {
            s.setType(parameterizedType);
          }
        }
 else {
          genericsSymbolTable.pushSymbol(vname,ReferenceType.TYPE,parameterizedType,null);
        }
        java.lang.reflect.Type[] bounds=tv.getBounds();
        List<SymbolType> paramBounds=parameterizedType.getBounds();
        if (paramBounds != null) {
          for (int i=0; i < bounds.length; i++) {
            updateTypeMapping(bounds[i],genericsSymbolTable,paramBounds.get(i),genericArgs,processedTypeVariables);
          }
        }
      }
    }
 else     if (type instanceof WildcardType) {
      WildcardType wildcard=(WildcardType)type;
      java.lang.reflect.Type[] bounds=wildcard.getUpperBounds();
      List<SymbolType> paramBounds=parameterizedType.getBounds();
      if (paramBounds != null) {
        for (int i=0; i < bounds.length; i++) {
          updateTypeMapping(bounds[i],genericsSymbolTable,paramBounds.get(i),genericArgs,processedTypeVariables);
        }
      }
      bounds=wildcard.getLowerBounds();
      paramBounds=parameterizedType.getLowerBounds();
      if (paramBounds != null) {
        for (int i=0; i < bounds.length; i++) {
          updateTypeMapping(bounds[i],genericsSymbolTable,paramBounds.get(i),genericArgs,processedTypeVariables);
        }
      }
    }
 else     if (type instanceof ParameterizedType) {
      ParameterizedType paramType=(ParameterizedType)type;
      java.lang.reflect.Type[] typeArgs=paramType.getActualTypeArguments();
      List<SymbolType> paramTypeParams=parameterizedType.getParameterizedTypes();
      if (paramTypeParams != null) {
        for (int i=0; i < typeArgs.length; i++) {
          SymbolType st=null;
          if (i < paramTypeParams.size()) {
            st=paramTypeParams.get(i);
          }
          updateTypeMapping(typeArgs[i],genericsSymbolTable,st,genericArgs,processedTypeVariables);
        }
      }
    }
 else     if (type instanceof GenericArrayType) {
      GenericArrayType arrayType=(GenericArrayType)type;
      SymbolType st=parameterizedType.clone();
      st.setArrayCount(parameterizedType.getArrayCount() - 1);
      updateTypeMapping(arrayType.getGenericComponentType(),genericsSymbolTable,st,genericArgs,processedTypeVariables);
    }
 else     if (type instanceof Class) {
      Class<?> clazz=(Class<?>)type;
      Map<String,SymbolType> updateMapping=new LinkedHashMap<String,SymbolType>();
      SymbolType rewrittenType=SymbolType.valueOf(clazz,parameterizedType,updateMapping,null);
      java.lang.reflect.TypeVariable[] tparams=clazz.getTypeParameters();
      List<SymbolType> paramTypes=rewrittenType.getParameterizedTypes();
      if (paramTypes != null) {
        Iterator<SymbolType> it=paramTypes.iterator();
        HashSet<String> processed=new HashSet<String>();
        for (int i=0; i < tparams.length && it.hasNext(); i++) {
          SymbolType st=it.next();
          if (st != null) {
            st.setTemplateVariable(tparams[i].getName());
            updateTypeMapping(tparams[i],genericsSymbolTable,st,true,processed);
          }
        }
      }
    }
  }
}",0.9890744694210724
91185,"@Override public SymbolData merge(SymbolData other){
  SymbolType result=null;
  if (other == null) {
    result=this;
  }
 else {
    if (other.getArrayCount() == getArrayCount()) {
      List<Class<?>> bounds=ClassInspector.getTheNearestSuperClasses(getBoundClasses(),other.getBoundClasses());
      if (bounds.isEmpty()) {
        result=null;
      }
 else       if (bounds.size() == 1) {
        result=new SymbolType(bounds.get(0));
      }
 else {
        List<SymbolType> boundsList=new LinkedList<SymbolType>();
        for (        Class<?> bound : bounds) {
          boundsList.add(new SymbolType(bound));
        }
        result=new SymbolType(boundsList);
      }
      if (result != null) {
        if (lowerBounds != null) {
          result.lowerBounds=new LinkedList<SymbolType>();
          for (          SymbolType st : lowerBounds) {
            result.lowerBounds.add(st.clone());
          }
        }
        result.arrayCount=other.getArrayCount();
      }
    }
 else {
      result=new SymbolType(Object.class);
    }
  }
  return result;
}","@Override public SymbolData merge(SymbolData other){
  SymbolType result=null;
  if (other == null || equals(other)) {
    result=this;
  }
 else {
    if (other.getArrayCount() == getArrayCount()) {
      List<Class<?>> bounds=ClassInspector.getTheNearestSuperClasses(getBoundClasses(),other.getBoundClasses());
      if (bounds.isEmpty()) {
        result=null;
      }
 else       if (bounds.size() == 1) {
        result=new SymbolType(bounds.get(0));
      }
 else {
        List<SymbolType> boundsList=new LinkedList<SymbolType>();
        for (        Class<?> bound : bounds) {
          boundsList.add(new SymbolType(bound));
        }
        result=new SymbolType(boundsList);
      }
      if (result != null) {
        if (lowerBounds != null) {
          result.lowerBounds=new LinkedList<SymbolType>();
          for (          SymbolType st : lowerBounds) {
            result.lowerBounds.add(st.clone());
          }
        }
        result.arrayCount=other.getArrayCount();
      }
    }
 else {
      result=new SymbolType(Object.class);
    }
  }
  return result;
}",0.9921113689095128
91186,"public static boolean isMoreSpecficFor(Class<?> clazz2,Class<?> clazz1,Class<?> reference){
  boolean isMethod2First=true;
  Integer order2=Types.basicTypeEvaluationOrder(clazz2);
  Integer order1=Types.basicTypeEvaluationOrder(clazz1);
  if (order1 != null && order2 != null) {
    return (order2 <= order1) || ((reference == null || !reference.isPrimitive()) && !clazz2.isPrimitive() && clazz1.isPrimitive());
  }
  boolean isAssignable=Types.isAssignable(clazz2,clazz1);
  if (!isAssignable) {
    if (Types.isAssignable(clazz1,clazz2)) {
      isMethod2First=false;
    }
 else {
      int h2=ClassInspector.getClassHierarchyHeight(clazz2);
      int h1=ClassInspector.getClassHierarchyHeight(clazz1);
      if (h1 == h2) {
        isMethod2First=clazz2 != null && clazz1 != null && clazz2.isArray() && !clazz1.isArray();
        if (!isMethod2First) {
          isMethod2First=clazz2 != null && reference != null && !clazz2.isArray() && !clazz2.isPrimitive() && clazz2.isAssignableFrom(reference);
        }
      }
 else {
        isMethod2First=h2 > h1;
      }
    }
  }
 else {
    isMethod2First=true;
  }
  return isMethod2First;
}","public static boolean isMoreSpecficFor(Class<?> clazz2,Class<?> clazz1,Class<?> reference){
  boolean isMethod2First=true;
  Integer order2=Types.basicTypeEvaluationOrder(clazz2);
  Integer order1=Types.basicTypeEvaluationOrder(clazz1);
  if (order1 != null && order2 != null) {
    return (order2 <= order1) || ((reference == null || !reference.isPrimitive()) && !clazz2.isPrimitive() && clazz1.isPrimitive());
  }
  boolean isAssignable=Types.isAssignable(clazz2,clazz1);
  if (!isAssignable) {
    if (Types.isAssignable(clazz1,clazz2)) {
      isMethod2First=false;
    }
 else {
      int h2=ClassInspector.getClassHierarchyHeight(clazz2);
      int h1=ClassInspector.getClassHierarchyHeight(clazz1);
      if (h1 == h2) {
        isMethod2First=clazz2 != null && clazz1 != null && (clazz2.isArray() && !clazz1.isArray() || (!clazz2.isInterface() && clazz1.isInterface()));
        if (!isMethod2First) {
          isMethod2First=clazz2 != null && reference != null && !clazz2.isArray() && !clazz2.isPrimitive() && clazz2.isAssignableFrom(reference);
        }
      }
 else {
        isMethod2First=h2 > h1;
      }
    }
  }
 else {
    isMethod2First=true;
  }
  return isMethod2First;
}",0.97732135216089
91187,"public List<T> sort(T[] methods,Class<?>[] args){
  Map<String,List<T>> map=new HashMap<String,List<T>>();
  this.args=args;
  LinkedList<T> result=new LinkedList<T>();
  for (  T method : methods) {
    List<T> aux=map.get(method.getName());
    if (aux == null) {
      aux=new LinkedList<T>();
      map.put(method.getName(),aux);
    }
    aux.add(method);
  }
  Set<String> entries=map.keySet();
  for (  String entry : entries) {
    List<T> aux=map.get(entry);
    ArrayList<T> sortedList=new ArrayList<T>();
    Iterator<T> it=aux.iterator();
    while (it.hasNext()) {
      ListIterator<T> li=sortedList.listIterator(sortedList.size());
      T method=it.next();
      boolean inserted=false;
      if (sortedList.isEmpty()) {
        sortedList.add(method);
      }
 else {
        int pos=sortedList.size() - 1;
        while (!inserted && li.hasPrevious()) {
          T previous=li.previous();
          if (compare(method,previous) == 1) {
            sortedList.add(pos + 1,method);
            inserted=true;
          }
          pos--;
        }
        if (!inserted) {
          sortedList.add(0,method);
        }
      }
    }
    result.addAll(sortedList);
  }
  return result;
}","public List<T> sort(T[] methods,Class<?>[] args){
  Map<String,List<T>> map=new HashMap<String,List<T>>();
  this.args=args;
  LinkedList<T> result=new LinkedList<T>();
  for (  T method : methods) {
    List<T> aux=map.get(method.getName());
    if (aux == null) {
      aux=new LinkedList<T>();
      map.put(method.getName(),aux);
    }
    aux.add(method);
  }
  Set<String> entries=map.keySet();
  for (  String entry : entries) {
    List<T> aux=map.get(entry);
    ArrayList<T> sortedList=new ArrayList<T>();
    Iterator<T> it=aux.iterator();
    while (it.hasNext()) {
      Iterator<T> li=sortedList.iterator();
      T method=it.next();
      boolean inserted=false;
      if (sortedList.isEmpty()) {
        sortedList.add(method);
      }
 else {
        int pos=0;
        while (!inserted && li.hasNext()) {
          T previous=li.next();
          if (compare(method,previous) == -1) {
            inserted=true;
          }
 else {
            pos++;
          }
        }
        sortedList.add(pos,method);
      }
    }
    result.addAll(sortedList);
  }
  return result;
}",0.740095777100566
91188,"@Override public boolean filter(Executable elem) throws Exception {
  Executable equivalentMethod=null;
  sd=(SymbolType)expression.getScope().getSymbolData();
  if (sd == null) {
    expression.getScope().accept(typeResolver,ctx);
    sd=(SymbolType)expression.getScope().getSymbolData();
    if (!expression.getIdentifier().equals(""String_Node_Str"")) {
      ArrayFilter<Method> filter=new ArrayFilter<Method>(sd.getClazz().getMethods());
      filter.appendPredicate(new MethodsByNamePredicate(expression.getIdentifier()));
      methodCallCandidates=filter.filter();
    }
  }
  boolean found=false;
  if (!expression.getIdentifier().equals(""String_Node_Str"")) {
    Iterator<Method> it=methodCallCandidates.iterator();
    while (it.hasNext() && !found) {
      Method md=it.next();
      int mdParameterCount=md.getParameterTypes().length;
      int elemParameterCount=elem.getParameterTypes().length;
      FunctionalGenericsBuilder<MethodReferenceExpr> builder=new FunctionalGenericsBuilder<MethodReferenceExpr>(md,typeResolver,getTypeMapping());
      builder.build(expression);
      SymbolType[] args=builder.getArgs();
      if (!Modifier.isStatic(md.getModifiers())) {
        if (mdParameterCount == elemParameterCount - 1) {
          SymbolType[] staticArgs=new SymbolType[args.length + 1];
          for (int i=0; i < args.length; i++) {
            staticArgs[i + 1]=args[i];
          }
          staticArgs[0]=(SymbolType)sd;
          args=staticArgs;
          setTypeArgs(args);
          found=super.filter(elem);
        }
 else {
          Expression scope=expression.getScope();
          SymbolType stype=(SymbolType)scope.getSymbolData();
          boolean isField=stype.getField() != null;
          boolean isVariable=false;
          if (!isField) {
            String name=scope.toString();
            isVariable=(symTable.findSymbol(name,ReferenceType.VARIABLE) != null);
          }
          if ((isField || isVariable) && mdParameterCount == elemParameterCount) {
            setTypeArgs(args);
            found=super.filter(elem);
          }
        }
      }
 else       if (mdParameterCount == elemParameterCount) {
        setTypeArgs(args);
        found=super.filter(elem);
      }
      if (found) {
        equivalentMethod=md;
      }
    }
  }
 else {
    Constructor<?>[] constructors=sd.getClazz().getConstructors();
    for (int i=0; i < constructors.length && !found; i++) {
      FunctionalGenericsBuilder<MethodReferenceExpr> builder=new FunctionalGenericsBuilder<MethodReferenceExpr>(constructors[i],typeResolver,getTypeMapping());
      builder.build(expression);
      SymbolType[] args=builder.getArgs();
      setTypeArgs(args);
      found=super.filter(elem);
      if (found) {
        equivalentMethod=constructors[i];
      }
    }
  }
  if (found && elem instanceof Method) {
    Map<String,SymbolType> mapping=getTypeMapping();
    SymbolType realResultType=null;
    if (equivalentMethod instanceof Method) {
      realResultType=SymbolType.valueOf((Method)equivalentMethod,mapping);
      java.lang.reflect.Type genericReturnType=((Method)elem).getGenericReturnType();
      resolveTypeMapping(genericReturnType,realResultType,mapping);
    }
    realResultType=SymbolType.valueOf(elem.getDeclaringClass(),mapping);
    expression.setSymbolData(realResultType);
    SymbolType st=SymbolType.valueOf((Method)elem,mapping);
    expression.setReferencedMethodSymbolData(st);
    expression.setReferencedArgsSymbolData(getTypeArgs());
  }
  return found;
}","@Override public boolean filter(Executable elem) throws Exception {
  Executable equivalentMethod=null;
  sd=(SymbolType)expression.getScope().getSymbolData();
  if (sd == null) {
    expression.getScope().accept(typeResolver,ctx);
    sd=(SymbolType)expression.getScope().getSymbolData();
    if (!expression.getIdentifier().equals(""String_Node_Str"")) {
      ArrayFilter<Method> filter=new ArrayFilter<Method>(sd.getClazz().getMethods());
      filter.appendPredicate(new MethodsByNamePredicate(expression.getIdentifier()));
      methodCallCandidates=filter.filter();
    }
  }
  boolean found=false;
  if (!expression.getIdentifier().equals(""String_Node_Str"")) {
    Iterator<Method> it=methodCallCandidates.iterator();
    while (it.hasNext() && !found) {
      Method md=it.next();
      int mdParameterCount=md.getParameterTypes().length;
      int elemParameterCount=elem.getParameterTypes().length;
      Map<String,SymbolType> typeMapping=getTypeMapping();
      FunctionalGenericsBuilder<MethodReferenceExpr> builder=new FunctionalGenericsBuilder<MethodReferenceExpr>(md,typeResolver,typeMapping);
      builder.build(expression);
      SymbolType[] args=builder.getArgs();
      if (!Modifier.isStatic(md.getModifiers())) {
        if (mdParameterCount == elemParameterCount - 1) {
          Type[] genericParameterTypes=elem.getGenericParameterTypes();
          SymbolType[] genericArgs=new SymbolType[genericParameterTypes.length];
          boolean allAreGenerics=true;
          for (int i=0; i < genericParameterTypes.length && allAreGenerics; i++) {
            if (genericParameterTypes[i] instanceof TypeVariable<?>) {
              TypeVariable<?> td=(TypeVariable<?>)genericParameterTypes[i];
              genericArgs[i]=typeMapping.get(td.getName());
              allAreGenerics=genericArgs[i] != null;
            }
 else {
              allAreGenerics=false;
            }
          }
          if (allAreGenerics) {
            setTypeArgs(genericArgs);
            found=super.filter(elem);
          }
 else {
            SymbolType[] staticArgs=new SymbolType[args.length + 1];
            for (int i=0; i < args.length; i++) {
              staticArgs[i + 1]=args[i];
            }
            staticArgs[0]=(SymbolType)sd;
            args=staticArgs;
            setTypeArgs(args);
            found=super.filter(elem);
          }
        }
 else {
          Expression scope=expression.getScope();
          SymbolType stype=(SymbolType)scope.getSymbolData();
          boolean isField=stype.getField() != null;
          boolean isVariable=false;
          if (!isField) {
            String name=scope.toString();
            isVariable=(symTable.findSymbol(name,ReferenceType.VARIABLE) != null);
          }
          if ((isField || isVariable) && mdParameterCount == elemParameterCount) {
            setTypeArgs(args);
            found=super.filter(elem);
          }
        }
      }
 else       if (mdParameterCount == elemParameterCount) {
        setTypeArgs(args);
        found=super.filter(elem);
      }
      if (found) {
        equivalentMethod=md;
      }
    }
  }
 else {
    Constructor<?>[] constructors=sd.getClazz().getConstructors();
    for (int i=0; i < constructors.length && !found; i++) {
      FunctionalGenericsBuilder<MethodReferenceExpr> builder=new FunctionalGenericsBuilder<MethodReferenceExpr>(constructors[i],typeResolver,getTypeMapping());
      builder.build(expression);
      SymbolType[] args=builder.getArgs();
      setTypeArgs(args);
      found=super.filter(elem);
      if (found) {
        equivalentMethod=constructors[i];
      }
    }
  }
  if (found && elem instanceof Method) {
    Map<String,SymbolType> mapping=getTypeMapping();
    SymbolType realResultType=null;
    if (equivalentMethod instanceof Method) {
      realResultType=SymbolType.valueOf((Method)equivalentMethod,mapping);
      java.lang.reflect.Type genericReturnType=((Method)elem).getGenericReturnType();
      resolveTypeMapping(genericReturnType,realResultType,mapping);
    }
    realResultType=SymbolType.valueOf(elem.getDeclaringClass(),mapping);
    expression.setSymbolData(realResultType);
    SymbolType st=SymbolType.valueOf((Method)elem,mapping);
    expression.setReferencedMethodSymbolData(st);
    expression.setReferencedArgsSymbolData(getTypeArgs());
  }
  return found;
}",0.8852750603481133
91189,"public static Method getLambdaMethod(Class<?> clazz){
  if (clazz == null || clazz.equals(Object.class)) {
    return null;
  }
  if (!clazz.isInterface()) {
    return null;
  }
  Method[] declMethods=clazz.getDeclaredMethods();
  for (int i=0; i < declMethods.length; i++) {
    int modifiers=declMethods[i].getModifiers();
    if (!Modifier.isPrivate(modifiers) && !Modifier.isAbstract(modifiers) && !declMethods[i].isBridge()&& !declMethods[i].isSynthetic()&& !ModifierSet.isStatic(modifiers)) {
      return declMethods[i];
    }
  }
  return getLambdaMethod(clazz.getSuperclass());
}","public static Method getLambdaMethod(Class<?> clazz,int paramsSize){
  if (clazz == null || clazz.equals(Object.class)) {
    return null;
  }
  boolean isAbstract=Modifier.isAbstract(clazz.getModifiers());
  if (!clazz.isInterface() && !isAbstract) {
    return null;
  }
  Method[] declMethods=clazz.getDeclaredMethods();
  for (int i=0; i < declMethods.length; i++) {
    int modifiers=declMethods[i].getModifiers();
    boolean isDefault=Modifier.isPublic(modifiers) && !Modifier.isStatic(modifiers) && !Modifier.isAbstract(modifiers);
    if (!isDefault && declMethods[i].getParameters().length == paramsSize) {
      return declMethods[i];
    }
  }
  Method result=getLambdaMethod(clazz.getSuperclass(),paramsSize);
  if (isAbstract) {
    Class<?>[] interfaces=clazz.getInterfaces();
    for (int i=0; i < interfaces.length && result == null; i++) {
      result=getLambdaMethod(interfaces[i],paramsSize);
    }
  }
  return result;
}",0.565643370346179
91190,"public static boolean isMoreSpecficFor(Class<?> clazz2,Class<?> clazz1,Class<?> reference){
  boolean isMethod2First=true;
  Integer order2=Types.basicTypeEvaluationOrder(clazz2);
  Integer order1=Types.basicTypeEvaluationOrder(clazz1);
  if (order1 != null && order2 != null) {
    return (order2 <= order1) || ((reference == null || !reference.isPrimitive()) && !clazz2.isPrimitive() && clazz1.isPrimitive());
  }
  boolean isAssignable=Types.isAssignable(clazz2,clazz1);
  if (!isAssignable) {
    if (Types.isAssignable(clazz1,clazz2)) {
      isMethod2First=false;
    }
 else {
      int h2=ClassInspector.getClassHierarchyHeight(clazz2);
      int h1=ClassInspector.getClassHierarchyHeight(clazz1);
      if (h1 == h2) {
        isMethod2First=clazz2 != null && clazz1 != null && (clazz2.isArray() && !clazz1.isArray() || (!clazz2.isInterface() && clazz1.isInterface()));
        if (!isMethod2First) {
          isMethod2First=clazz2 != null && reference != null && !clazz2.isArray() && !clazz2.isPrimitive() && clazz2.isAssignableFrom(reference);
        }
      }
 else {
        isMethod2First=h2 > h1;
      }
    }
  }
 else {
    isMethod2First=true;
  }
  return isMethod2First;
}","public static boolean isMoreSpecficFor(Class<?> clazz2,Class<?> clazz1,Class<?> reference){
  boolean isMethod2First=true;
  Integer order2=Types.basicTypeEvaluationOrder(clazz2);
  Integer order1=Types.basicTypeEvaluationOrder(clazz1);
  if (order1 != null && order2 != null) {
    if ((clazz2.isPrimitive() && clazz1.isPrimitive()) || (!clazz2.isPrimitive() && !clazz1.isPrimitive()) || reference == null) {
      return (order2 <= order1);
    }
    boolean referenceIsPrimitive=reference != null && reference.isPrimitive();
    boolean clazz2First=(referenceIsPrimitive && clazz2.isPrimitive() && !clazz1.isPrimitive()) || ((!referenceIsPrimitive) && !clazz2.isPrimitive() && clazz1.isPrimitive());
    return clazz2First;
  }
  boolean isAssignable=Types.isAssignable(clazz2,clazz1);
  if (!isAssignable) {
    if (Types.isAssignable(clazz1,clazz2)) {
      isMethod2First=false;
    }
 else {
      int h2=ClassInspector.getClassHierarchyHeight(clazz2);
      int h1=ClassInspector.getClassHierarchyHeight(clazz1);
      if (h1 == h2) {
        isMethod2First=clazz2 != null && clazz1 != null && (clazz2.isArray() && !clazz1.isArray() || (!clazz2.isInterface() && clazz1.isInterface()));
        if (!isMethod2First) {
          isMethod2First=clazz2 != null && reference != null && !clazz2.isArray() && !clazz2.isPrimitive() && clazz2.isAssignableFrom(reference);
        }
      }
 else {
        isMethod2First=h2 > h1;
      }
    }
  }
 else {
    isMethod2First=true;
  }
  return isMethod2First;
}",0.822181146025878
91191,"public static Set<Method> getVisibleMethods(Class<?> clazz,Class<?> invocationClass){
  Set<Method> result=new HashSet<Method>();
  HashMap<String,Set<Method>> aux=new HashMap<String,Set<Method>>();
  if (clazz == null || clazz.equals(Object.class)) {
    return result;
  }
  Method[] declMethods=clazz.getDeclaredMethods();
  for (int i=0; i < declMethods.length; i++) {
    boolean isVisible=clazz.getName().equals(invocationClass.getName());
    int modifiers=declMethods[i].getModifiers();
    boolean samePackage=clazz.getPackage() == null && invocationClass.getPackage() == null;
    samePackage=samePackage || (clazz.getPackage() != null && invocationClass.getPackage() != null && clazz.getPackage().getName().equals(invocationClass.getPackage().getName()));
    isVisible=isVisible || Modifier.isPublic(modifiers) || (!Modifier.isPrivate(modifiers) && samePackage);
    if (isVisible && !declMethods[i].isBridge() && !declMethods[i].isSynthetic()) {
      result.add(declMethods[i]);
      Set<Method> auxSet=aux.get(declMethods[i].getName());
      if (auxSet == null) {
        auxSet=new HashSet<Method>();
      }
      auxSet.add(declMethods[i]);
      aux.put(declMethods[i].getName(),auxSet);
    }
  }
  Set<Method> superClassMethods=getVisibleMethods(clazz.getSuperclass(),invocationClass);
  for (  Method superMethod : superClassMethods) {
    Set<Method> auxSet=aux.get(superMethod.getName());
    boolean found=false;
    if (auxSet == null) {
      auxSet=new HashSet<Method>();
    }
 else {
      Class<?>[] superParams=superMethod.getParameterTypes();
      Iterator<Method> it=auxSet.iterator();
      while (it.hasNext() && !found) {
        Method prev=it.next();
        Class<?>[] prevParams=prev.getParameterTypes();
        if (prevParams.length == superParams.length) {
          if (prevParams.length > 0) {
            boolean compatibleArgs=false;
            for (int i=0; i < prevParams.length && compatibleArgs; i++) {
              compatibleArgs=superParams[i].isAssignableFrom(prevParams[i]);
            }
            found=compatibleArgs;
          }
 else {
            found=true;
          }
        }
      }
    }
    if (!found) {
      aux.put(superMethod.getName(),auxSet);
      result.add(superMethod);
    }
  }
  return result;
}","public static Set<Method> getVisibleMethods(Class<?> clazz,Class<?> invocationClass){
  Set<Method> result=new HashSet<Method>();
  HashMap<String,Set<Method>> aux=new HashMap<String,Set<Method>>();
  if (clazz == null || clazz.equals(Object.class)) {
    return result;
  }
  Method[] declMethods=clazz.getDeclaredMethods();
  for (int i=0; i < declMethods.length; i++) {
    boolean isVisible=clazz.getName().equals(invocationClass.getName());
    int modifiers=declMethods[i].getModifiers();
    boolean samePackage=clazz.getPackage() == null && invocationClass.getPackage() == null;
    samePackage=samePackage || (clazz.getPackage() != null && invocationClass.getPackage() != null && clazz.getPackage().getName().equals(invocationClass.getPackage().getName()));
    isVisible=isVisible || Modifier.isPublic(modifiers) || (!Modifier.isPrivate(modifiers) && samePackage);
    if (isVisible && !declMethods[i].isBridge() && !declMethods[i].isSynthetic()) {
      result.add(declMethods[i]);
      Set<Method> auxSet=aux.get(declMethods[i].getName());
      if (auxSet == null) {
        auxSet=new HashSet<Method>();
      }
      auxSet.add(declMethods[i]);
      aux.put(declMethods[i].getName(),auxSet);
    }
  }
  if (clazz.isInterface()) {
    Class<?>[] interfaces=clazz.getInterfaces();
    for (int i=0; i < interfaces.length; i++) {
      Set<Method> auxSet=getVisibleMethods(interfaces[i],invocationClass);
      result.addAll(auxSet);
    }
  }
 else {
    Set<Method> superClassMethods=getVisibleMethods(clazz.getSuperclass(),invocationClass);
    for (    Method superMethod : superClassMethods) {
      Set<Method> auxSet=aux.get(superMethod.getName());
      boolean found=false;
      if (auxSet == null) {
        auxSet=new HashSet<Method>();
      }
 else {
        Class<?>[] superParams=superMethod.getParameterTypes();
        Iterator<Method> it=auxSet.iterator();
        while (it.hasNext() && !found) {
          Method prev=it.next();
          Class<?>[] prevParams=prev.getParameterTypes();
          if (prevParams.length == superParams.length) {
            if (prevParams.length > 0) {
              boolean compatibleArgs=false;
              for (int i=0; i < prevParams.length && compatibleArgs; i++) {
                compatibleArgs=superParams[i].isAssignableFrom(prevParams[i]);
              }
              found=compatibleArgs;
            }
 else {
              found=true;
            }
          }
        }
      }
      if (!found) {
        aux.put(superMethod.getName(),auxSet);
        result.add(superMethod);
      }
    }
  }
  return result;
}",0.7400736799017601
91192,"public void loadExtendsOrImplements(List<ClassOrInterfaceType> extendsList){
  if (extendsList != null) {
    for (    ClassOrInterfaceType type : extendsList) {
      String name=type.accept(nameBuilder,null);
      Symbol<?> s=table.findSymbol(name,ReferenceType.TYPE);
      if (s == null) {
        SymbolType st=ASTSymbolTypeResolver.getInstance().valueOf(type);
        if (st == null || st.getClazz() == null) {
          throw new RuntimeException(""String_Node_Str"" + name);
        }
        name=st.getClazz().getCanonicalName();
        s=table.findSymbol(name,ReferenceType.TYPE);
      }
      if (s != null) {
        Object location=s.getLocation();
        if (location != null && location instanceof TypeDeclaration) {
          TypeDeclaration superClass=((TypeDeclaration)location);
          superClass.accept(this,s.getInnerScope());
        }
 else {
          Class<?> clazz=s.getType().getClazz();
          Set<Method> methods=MethodInspector.getNonPrivateMethods(clazz);
          Symbol<?> parent=table.findSymbol(""String_Node_Str"",ReferenceType.VARIABLE);
          if (parent == null) {
            parent=table.pushSymbol(""String_Node_Str"",ReferenceType.TYPE,new SymbolType(clazz),null);
          }
          Scope parentScope=parent.getInnerScope();
          if (parentScope == null) {
            parentScope=new Scope(parent);
            parent.setInnerScope(parentScope);
          }
          SymbolType typeArg=ASTSymbolTypeResolver.getInstance().valueOf(type);
          List<SymbolType> params=typeArg.getParameterizedTypes();
          table.pushScope(parentScope);
          for (          Method method : methods) {
            Map<String,SymbolType> parameterTypes=null;
            try {
              java.lang.reflect.Type[] genericParameterTypes=method.getGenericParameterTypes();
              SymbolType[] methodArgs=new SymbolType[genericParameterTypes.length];
              if (params != null) {
                parameterTypes=new HashMap<String,SymbolType>();
                TypeVariable<?>[] typeParams=method.getDeclaringClass().getTypeParameters();
                for (int i=0; i < params.size() && i < typeParams.length; i++) {
                  SymbolType.valueOf(typeParams[i],params.get(i),parameterTypes,null);
                }
              }
              for (int i=0; i < genericParameterTypes.length; i++) {
                methodArgs[i]=SymbolType.valueOf(genericParameterTypes[i],parameterTypes);
              }
              MethodSymbol methodSymbol=new MethodSymbol(method.getName(),SymbolType.valueOf(method,parameterTypes),null,s.getType(),methodArgs,false,method.isVarArgs(),method,null);
              table.pushSymbol(methodSymbol);
            }
 catch (            Exception e) {
              throw new RuntimeException(e);
            }
          }
          table.popScope(true);
        }
      }
    }
  }
}","public void loadExtendsOrImplements(List<ClassOrInterfaceType> extendsList){
  if (extendsList != null) {
    for (    ClassOrInterfaceType type : extendsList) {
      String name=type.accept(nameBuilder,null);
      Symbol<?> s=table.findSymbol(name,ReferenceType.TYPE);
      if (s == null) {
        SymbolType st=ASTSymbolTypeResolver.getInstance().valueOf(type);
        if (st == null || st.getClazz() == null) {
          throw new RuntimeException(""String_Node_Str"" + name);
        }
        name=st.getClazz().getCanonicalName();
        s=table.findSymbol(name,ReferenceType.TYPE);
      }
      if (s != null) {
        Object location=s.getLocation();
        if (location != null && location instanceof TypeDeclaration) {
          TypeDeclaration superClass=((TypeDeclaration)location);
          superClass.accept(this,s.getInnerScope());
        }
 else {
          Class<?> clazz=s.getType().getClazz();
          Set<Method> methods=MethodInspector.getInheritedMethods(clazz);
          Symbol<?> parent=table.findSymbol(""String_Node_Str"",ReferenceType.VARIABLE);
          if (parent == null) {
            parent=table.pushSymbol(""String_Node_Str"",ReferenceType.TYPE,new SymbolType(clazz),null);
          }
          Scope parentScope=parent.getInnerScope();
          if (parentScope == null) {
            parentScope=new Scope(parent);
            parent.setInnerScope(parentScope);
          }
          SymbolType typeArg=ASTSymbolTypeResolver.getInstance().valueOf(type);
          List<SymbolType> params=typeArg.getParameterizedTypes();
          table.pushScope(parentScope);
          for (          Method method : methods) {
            Map<String,SymbolType> parameterTypes=null;
            try {
              java.lang.reflect.Type[] genericParameterTypes=method.getGenericParameterTypes();
              SymbolType[] methodArgs=new SymbolType[genericParameterTypes.length];
              if (params != null) {
                parameterTypes=new HashMap<String,SymbolType>();
                TypeVariable<?>[] typeParams=method.getDeclaringClass().getTypeParameters();
                for (int i=0; i < params.size() && i < typeParams.length; i++) {
                  SymbolType.valueOf(typeParams[i],params.get(i),parameterTypes,null);
                }
              }
              for (int i=0; i < genericParameterTypes.length; i++) {
                methodArgs[i]=SymbolType.valueOf(genericParameterTypes[i],parameterTypes);
              }
              MethodSymbol methodSymbol=new MethodSymbol(method.getName(),SymbolType.valueOf(method,parameterTypes),null,s.getType(),methodArgs,false,method.isVarArgs(),method,null);
              table.pushSymbol(methodSymbol);
            }
 catch (            Exception e) {
              throw new RuntimeException(e);
            }
          }
          table.popScope(true);
        }
      }
    }
  }
}",0.9967190467967536
91193,"@Override public boolean filter(Executable elem) throws Exception {
  Executable equivalentMethod=null;
  sd=(SymbolType)expression.getScope().getSymbolData();
  if (sd == null) {
    expression.getScope().accept(typeResolver,ctx);
    sd=(SymbolType)expression.getScope().getSymbolData();
    if (!expression.getIdentifier().equals(""String_Node_Str"")) {
      if (methodsArray == null) {
        Set<Method> methods=MethodInspector.getVisibleMethods(sd.getClazz(),thisClass);
        methodsArray=new Method[methods.size()];
        methods.toArray(methodsArray);
        ExecutableSorter<Method> sorter=new ExecutableSorter<Method>();
        List<Method> sortedMethods=sorter.sort(methodsArray,null);
        sortedMethods.toArray(methodsArray);
      }
      ArrayFilter<Method> filter=new ArrayFilter<Method>(methodsArray);
      filter.appendPredicate(new MethodsByNamePredicate(expression.getIdentifier()));
      methodCallCandidates=filter.filter();
    }
  }
  boolean found=false;
  if (!expression.getIdentifier().equals(""String_Node_Str"")) {
    Iterator<Method> it=methodCallCandidates.iterator();
    while (it.hasNext() && !found) {
      Method md=it.next();
      int mdParameterCount=md.getParameterTypes().length;
      int elemParameterCount=elem.getParameterTypes().length;
      Map<String,SymbolType> typeMapping=getTypeMapping();
      FunctionalGenericsBuilder<MethodReferenceExpr> builder=new FunctionalGenericsBuilder<MethodReferenceExpr>(md,typeResolver,typeMapping);
      builder.build(expression);
      SymbolType[] args=builder.getArgs();
      if (!Modifier.isStatic(md.getModifiers())) {
        if (mdParameterCount == elemParameterCount - 1) {
          Type[] genericParameterTypes=elem.getGenericParameterTypes();
          SymbolType[] genericArgs=new SymbolType[genericParameterTypes.length];
          boolean allAreGenerics=true;
          for (int i=0; i < genericParameterTypes.length && allAreGenerics; i++) {
            if (genericParameterTypes[i] instanceof TypeVariable<?>) {
              TypeVariable<?> td=(TypeVariable<?>)genericParameterTypes[i];
              genericArgs[i]=typeMapping.get(td.getName());
              allAreGenerics=genericArgs[i] != null;
            }
 else {
              allAreGenerics=false;
            }
          }
          if (allAreGenerics) {
            setTypeArgs(genericArgs);
            found=super.filter(elem);
          }
 else {
            SymbolType[] staticArgs=new SymbolType[args.length + 1];
            for (int i=0; i < args.length; i++) {
              staticArgs[i + 1]=args[i];
            }
            staticArgs[0]=(SymbolType)sd;
            args=staticArgs;
            setTypeArgs(args);
            found=super.filter(elem);
          }
        }
 else {
          Expression scope=expression.getScope();
          SymbolType stype=(SymbolType)scope.getSymbolData();
          boolean isField=stype.getField() != null;
          boolean isVariable=false;
          if (!isField) {
            String name=scope.toString();
            isVariable=(symTable.findSymbol(name,ReferenceType.VARIABLE) != null);
          }
          if ((isField || isVariable) && mdParameterCount == elemParameterCount) {
            setTypeArgs(args);
            found=super.filter(elem);
          }
        }
      }
 else       if (mdParameterCount == elemParameterCount) {
        setTypeArgs(args);
        found=super.filter(elem);
      }
      if (found) {
        equivalentMethod=md;
      }
    }
  }
 else {
    Constructor<?>[] constructors=sd.getClazz().getDeclaredConstructors();
    for (int i=0; i < constructors.length && !found; i++) {
      FunctionalGenericsBuilder<MethodReferenceExpr> builder=new FunctionalGenericsBuilder<MethodReferenceExpr>(constructors[i],typeResolver,getTypeMapping());
      builder.build(expression);
      SymbolType[] args=builder.getArgs();
      setTypeArgs(args);
      found=super.filter(elem);
      if (found) {
        equivalentMethod=constructors[i];
      }
    }
  }
  if (found && elem instanceof Method) {
    Map<String,SymbolType> mapping=getTypeMapping();
    SymbolType realResultType=null;
    if (equivalentMethod instanceof Method) {
      realResultType=SymbolType.valueOf((Method)equivalentMethod,mapping);
      java.lang.reflect.Type genericReturnType=((Method)elem).getGenericReturnType();
      resolveTypeMapping(genericReturnType,realResultType,mapping);
    }
    realResultType=SymbolType.valueOf(elem.getDeclaringClass(),mapping);
    expression.setSymbolData(realResultType);
    SymbolType st=SymbolType.valueOf((Method)elem,mapping);
    expression.setReferencedMethodSymbolData(st);
    expression.setReferencedArgsSymbolData(getTypeArgs());
  }
  return found;
}","@Override public boolean filter(Executable elem) throws Exception {
  Executable equivalentMethod=null;
  sd=(SymbolType)expression.getScope().getSymbolData();
  if (sd == null) {
    expression.getScope().accept(typeResolver,ctx);
    sd=(SymbolType)expression.getScope().getSymbolData();
    if (!expression.getIdentifier().equals(""String_Node_Str"")) {
      if (methodsArray == null) {
        Set<Method> methods=MethodInspector.getVisibleMethods(sd.getClazz(),thisClass);
        methodsArray=new Method[methods.size()];
        methods.toArray(methodsArray);
        ExecutableSorter<Method> sorter=new ExecutableSorter<Method>();
        List<Method> sortedMethods=sorter.sort(methodsArray,null);
        sortedMethods.toArray(methodsArray);
      }
      ArrayFilter<Method> filter=new ArrayFilter<Method>(methodsArray);
      filter.appendPredicate(new MethodsByNamePredicate(expression.getIdentifier()));
      methodCallCandidates=filter.filter();
    }
  }
  boolean found=false;
  if (!expression.getIdentifier().equals(""String_Node_Str"")) {
    Iterator<Method> it=methodCallCandidates.iterator();
    while (it.hasNext() && !found) {
      Method md=it.next();
      int mdParameterCount=md.getParameterTypes().length;
      int elemParameterCount=elem.getParameterTypes().length;
      Map<String,SymbolType> typeMapping=getTypeMapping();
      FunctionalGenericsBuilder<MethodReferenceExpr> builder=new FunctionalGenericsBuilder<MethodReferenceExpr>(md,typeResolver,typeMapping);
      builder.build(expression);
      SymbolType[] args=builder.getArgs();
      if (!Modifier.isStatic(md.getModifiers())) {
        if (mdParameterCount == elemParameterCount - 1) {
          Type[] genericParameterTypes=elem.getGenericParameterTypes();
          SymbolType[] genericArgs=new SymbolType[genericParameterTypes.length];
          boolean allAreGenerics=true;
          for (int i=0; i < genericParameterTypes.length && allAreGenerics; i++) {
            if (genericParameterTypes[i] instanceof TypeVariable<?>) {
              TypeVariable<?> td=(TypeVariable<?>)genericParameterTypes[i];
              genericArgs[i]=typeMapping.get(td.getName());
              allAreGenerics=genericArgs[i] != null;
            }
 else {
              allAreGenerics=false;
            }
          }
          if (allAreGenerics) {
            setTypeArgs(genericArgs);
            found=super.filter(elem);
          }
 else {
            SymbolType[] staticArgs=new SymbolType[args.length + 1];
            for (int i=0; i < args.length; i++) {
              staticArgs[i + 1]=args[i];
            }
            staticArgs[0]=(SymbolType)sd;
            args=staticArgs;
            setTypeArgs(args);
            found=super.filter(elem);
          }
        }
 else {
          Expression scope=expression.getScope();
          SymbolType stype=(SymbolType)scope.getSymbolData();
          boolean isField=stype.getField() != null;
          boolean isVariable=false;
          boolean isSuper=scope instanceof SuperExpr;
          if (!isField && !isSuper) {
            String name=scope.toString();
            isVariable=(symTable.findSymbol(name,ReferenceType.VARIABLE) != null);
          }
          if ((isField || isVariable || isSuper) && mdParameterCount == elemParameterCount) {
            setTypeArgs(args);
            found=super.filter(elem);
          }
        }
      }
 else       if (mdParameterCount == elemParameterCount) {
        setTypeArgs(args);
        found=super.filter(elem);
      }
      if (found) {
        equivalentMethod=md;
      }
    }
  }
 else {
    Constructor<?>[] constructors=sd.getClazz().getDeclaredConstructors();
    for (int i=0; i < constructors.length && !found; i++) {
      FunctionalGenericsBuilder<MethodReferenceExpr> builder=new FunctionalGenericsBuilder<MethodReferenceExpr>(constructors[i],typeResolver,getTypeMapping());
      builder.build(expression);
      SymbolType[] args=builder.getArgs();
      setTypeArgs(args);
      found=super.filter(elem);
      if (found) {
        equivalentMethod=constructors[i];
      }
    }
  }
  if (found && elem instanceof Method) {
    Map<String,SymbolType> mapping=getTypeMapping();
    SymbolType realResultType=null;
    if (equivalentMethod instanceof Method) {
      realResultType=SymbolType.valueOf((Method)equivalentMethod,mapping);
      java.lang.reflect.Type genericReturnType=((Method)elem).getGenericReturnType();
      resolveTypeMapping(genericReturnType,realResultType,mapping);
    }
    realResultType=SymbolType.valueOf(elem.getDeclaringClass(),mapping);
    expression.setSymbolData(realResultType);
    SymbolType st=SymbolType.valueOf((Method)elem,mapping);
    expression.setReferencedMethodSymbolData(st);
    expression.setReferencedArgsSymbolData(getTypeArgs());
  }
  return found;
}",0.991953182150695
91194,"public static Set<Method> getVisibleMethods(Class<?> clazz,Class<?> invocationClass){
  Set<Method> result=new HashSet<Method>();
  HashMap<String,Set<Method>> aux=new HashMap<String,Set<Method>>();
  if (clazz == null || clazz.equals(Object.class)) {
    return result;
  }
  Method[] declMethods=clazz.getDeclaredMethods();
  for (int i=0; i < declMethods.length; i++) {
    boolean isVisible=clazz.getName().equals(invocationClass.getName());
    int modifiers=declMethods[i].getModifiers();
    boolean samePackage=clazz.getPackage() == null && invocationClass.getPackage() == null;
    samePackage=samePackage || (clazz.getPackage() != null && invocationClass.getPackage() != null && clazz.getPackage().getName().equals(invocationClass.getPackage().getName()));
    isVisible=isVisible || Modifier.isPublic(modifiers) || (Modifier.isProtected(modifiers) && samePackage);
    if (isVisible && !Modifier.isAbstract(modifiers) && !declMethods[i].isBridge()&& !declMethods[i].isSynthetic()) {
      result.add(declMethods[i]);
      Set<Method> auxSet=aux.get(declMethods[i].getName());
      if (auxSet == null) {
        auxSet=new HashSet<Method>();
      }
      auxSet.add(declMethods[i]);
      aux.put(declMethods[i].getName(),auxSet);
    }
  }
  Set<Method> superClassMethods=getNonPrivateMethods(clazz.getSuperclass());
  for (  Method superMethod : superClassMethods) {
    Set<Method> auxSet=aux.get(superMethod.getName());
    boolean found=false;
    if (auxSet == null) {
      auxSet=new HashSet<Method>();
    }
 else {
      Class<?>[] superParams=superMethod.getParameterTypes();
      Iterator<Method> it=auxSet.iterator();
      while (it.hasNext() && !found) {
        Method prev=it.next();
        Class<?>[] prevParams=prev.getParameterTypes();
        if (prevParams.length == superParams.length) {
          if (prevParams.length > 0) {
            boolean compatibleArgs=false;
            for (int i=0; i < prevParams.length && compatibleArgs; i++) {
              compatibleArgs=superParams[i].isAssignableFrom(prevParams[i]);
            }
            found=compatibleArgs;
          }
 else {
            found=true;
          }
        }
      }
    }
    if (!found) {
      aux.put(superMethod.getName(),auxSet);
      result.add(superMethod);
    }
  }
  return result;
}","public static Set<Method> getVisibleMethods(Class<?> clazz,Class<?> invocationClass){
  Set<Method> result=new HashSet<Method>();
  HashMap<String,Set<Method>> aux=new HashMap<String,Set<Method>>();
  if (clazz == null || clazz.equals(Object.class)) {
    return result;
  }
  Method[] declMethods=clazz.getDeclaredMethods();
  for (int i=0; i < declMethods.length; i++) {
    boolean isVisible=clazz.getName().equals(invocationClass.getName());
    int modifiers=declMethods[i].getModifiers();
    boolean samePackage=clazz.getPackage() == null && invocationClass.getPackage() == null;
    samePackage=samePackage || (clazz.getPackage() != null && invocationClass.getPackage() != null && clazz.getPackage().getName().equals(invocationClass.getPackage().getName()));
    isVisible=isVisible || Modifier.isPublic(modifiers) || (!Modifier.isPrivate(modifiers) && samePackage);
    if (isVisible && !declMethods[i].isBridge() && !declMethods[i].isSynthetic()) {
      result.add(declMethods[i]);
      Set<Method> auxSet=aux.get(declMethods[i].getName());
      if (auxSet == null) {
        auxSet=new HashSet<Method>();
      }
      auxSet.add(declMethods[i]);
      aux.put(declMethods[i].getName(),auxSet);
    }
  }
  Set<Method> superClassMethods=getVisibleMethods(clazz.getSuperclass(),invocationClass);
  for (  Method superMethod : superClassMethods) {
    Set<Method> auxSet=aux.get(superMethod.getName());
    boolean found=false;
    if (auxSet == null) {
      auxSet=new HashSet<Method>();
    }
 else {
      Class<?>[] superParams=superMethod.getParameterTypes();
      Iterator<Method> it=auxSet.iterator();
      while (it.hasNext() && !found) {
        Method prev=it.next();
        Class<?>[] prevParams=prev.getParameterTypes();
        if (prevParams.length == superParams.length) {
          if (prevParams.length > 0) {
            boolean compatibleArgs=false;
            for (int i=0; i < prevParams.length && compatibleArgs; i++) {
              compatibleArgs=superParams[i].isAssignableFrom(prevParams[i]);
            }
            found=compatibleArgs;
          }
 else {
            found=true;
          }
        }
      }
    }
    if (!found) {
      aux.put(superMethod.getName(),auxSet);
      result.add(superMethod);
    }
  }
  return result;
}",0.8750544188071397
91195,"public Symbol<?> findSymbol(String name,SymbolType scope,SymbolType[] args,ReferenceType... referenceType){
  Symbol<?> result=null;
  if (args == null) {
    return findSymbol(name,referenceType);
  }
 else {
    List<Symbol<?>> values=symbols.get(name);
    if (values != null) {
      Iterator<Symbol<?>> it=values.iterator();
      Map<Integer,Executable> execs=new HashMap<Integer,Executable>();
      int i=0;
      while (it.hasNext()) {
        Symbol<?> symbol=it.next();
        if (symbol instanceof MethodSymbol) {
          MethodSymbol aux=(MethodSymbol)symbol;
          Executable m=aux.getReferencedMethod();
          if (m == null) {
            m=aux.getReferencedConstructor();
          }
          if (m != null) {
            execs.put(i,m);
          }
        }
        i++;
      }
      if (execs.isEmpty()) {
        result=null;
      }
 else       if (execs.size() == 1) {
        result=values.get(execs.keySet().iterator().next());
      }
 else {
        Executable[] methods=new Executable[execs.size()];
        List<Executable> sortedMethods=sorter.sort(execs.values().toArray(methods),SymbolType.toClassArray(args));
        ArrayFilter<Executable> filter=new ArrayFilter<Executable>(sortedMethods.toArray(methods));
        CompatibleArgsPredicate<Executable> cap=new CompatibleArgsPredicate<Executable>(args);
        cap.setTypeMapping(getTypeParams());
        filter.appendPredicate(cap);
        Executable exec=null;
        ;
        try {
          exec=filter.filterOne();
        }
 catch (        Exception e) {
          throw new RuntimeException(e);
        }
        Set<Integer> keys=execs.keySet();
        Iterator<Integer> itKeys=keys.iterator();
        while (itKeys.hasNext() && result == null) {
          Integer key=itKeys.next();
          if (execs.get(key) == exec) {
            result=values.get(key);
          }
        }
      }
    }
    if (result == null) {
      values=symbols.get(""String_Node_Str"");
      if (values != null) {
        Scope innerScope=values.get(0).getInnerScope();
        if (innerScope != null) {
          result=innerScope.findSymbol(name,scope,args,referenceType);
        }
      }
    }
    if (result != null) {
      MethodSymbol sm=(MethodSymbol)result;
      result=sm.buildTypeParameters(typeParams);
    }
  }
  return result;
}","public Symbol<?> findSymbol(String name,SymbolType scope,SymbolType[] args,List<Predicate<?>> predicates,ReferenceType... referenceType){
  Symbol<?> result=null;
  if (args == null) {
    return findSymbol(name,referenceType);
  }
 else {
    List<Symbol<?>> values=symbols.get(name);
    if (values != null) {
      Iterator<Symbol<?>> it=values.iterator();
      Map<Integer,Executable> execs=new HashMap<Integer,Executable>();
      int i=0;
      while (it.hasNext()) {
        Symbol<?> symbol=it.next();
        if (symbol instanceof MethodSymbol) {
          MethodSymbol aux=(MethodSymbol)symbol;
          Executable m=aux.getReferencedMethod();
          if (m == null) {
            m=aux.getReferencedConstructor();
          }
          if (m != null) {
            execs.put(i,m);
          }
        }
        i++;
      }
      if (execs.isEmpty()) {
        result=null;
      }
 else {
        Executable exec=runPredicates(predicates,execs,args);
        Set<Integer> keys=execs.keySet();
        Iterator<Integer> itKeys=keys.iterator();
        while (itKeys.hasNext() && result == null) {
          Integer key=itKeys.next();
          if (execs.get(key) == exec) {
            result=values.get(key);
          }
        }
      }
    }
    if (result == null) {
      values=symbols.get(""String_Node_Str"");
      if (values != null) {
        Scope innerScope=values.get(0).getInnerScope();
        if (innerScope != null) {
          result=innerScope.findSymbol(name,scope,args,predicates,referenceType);
        }
      }
    }
    if (result != null) {
      MethodSymbol sm=(MethodSymbol)result;
      result=sm.buildTypeParameters(typeParams);
    }
  }
  return result;
}",0.6310319227913883
91196,"public Symbol<?> findSymbol(String symbolName,SymbolType symbolScope,SymbolType[] args,ReferenceType... referenceType){
  int j=indexStructure.size() - 1;
  Symbol<?> result=null;
  Scope selectedScope=null;
  if (symbolScope != null) {
    Class<?> clazz=symbolScope.getClazz();
    Symbol<?> scopeSymbol=null;
    if (clazz.isAnonymousClass()) {
      scopeSymbol=findSymbol(symbolScope.getClazz().getName(),ReferenceType.TYPE);
    }
 else {
      scopeSymbol=indexStructure.get(0).findSymbol(symbolScope.getClazz().getCanonicalName(),ReferenceType.TYPE);
    }
    if (scopeSymbol != null) {
      if (scopeSymbol.getInnerScope() != null) {
        return scopeSymbol.getInnerScope().findSymbol(symbolName,symbolScope,args,referenceType);
      }
 else       return null;
    }
  }
  if (selectedScope == null) {
    j=indexStructure.size() - 1;
  }
  while (j >= 0 && result == null) {
    Scope scope=indexStructure.get(j);
    Symbol<?> rootSymbol=scope.getRootSymbol();
    if (selectedScope != null && rootSymbol != null) {
      SymbolDefinition sd=rootSymbol.getLocation();
      if (sd instanceof SymbolDataAware<?>) {
        symbolScope=(SymbolType)((SymbolDataAware<?>)sd).getSymbolData();
      }
    }
    result=scope.findSymbol(symbolName,symbolScope,args,referenceType);
    j--;
  }
  return result;
}","public Symbol<?> findSymbol(String symbolName,SymbolType symbolScope,SymbolType[] args,List<Predicate<?>> predicates,ReferenceType... referenceType){
  int j=indexStructure.size() - 1;
  Symbol<?> result=null;
  Scope selectedScope=null;
  if (symbolScope != null) {
    Class<?> clazz=symbolScope.getClazz();
    Symbol<?> scopeSymbol=null;
    if (clazz.isAnonymousClass()) {
      scopeSymbol=findSymbol(symbolScope.getClazz().getName(),ReferenceType.TYPE);
    }
 else {
      scopeSymbol=indexStructure.get(0).findSymbol(symbolScope.getClazz().getCanonicalName(),ReferenceType.TYPE);
    }
    if (scopeSymbol != null) {
      if (scopeSymbol.getInnerScope() != null) {
        return scopeSymbol.getInnerScope().findSymbol(symbolName,symbolScope,args,predicates,referenceType);
      }
 else       return null;
    }
  }
  if (selectedScope == null) {
    j=indexStructure.size() - 1;
  }
  while (j >= 0 && result == null) {
    Scope scope=indexStructure.get(j);
    Symbol<?> rootSymbol=scope.getRootSymbol();
    if (selectedScope != null && rootSymbol != null) {
      SymbolDefinition sd=rootSymbol.getLocation();
      if (sd instanceof SymbolDataAware<?>) {
        symbolScope=(SymbolType)((SymbolDataAware<?>)sd).getSymbolData();
      }
    }
    result=scope.findSymbol(symbolName,symbolScope,args,predicates,referenceType);
    j--;
  }
  return result;
}",0.9807121661721068
91197,"public boolean filter(Executable method) throws Exception {
  boolean found=false;
  boolean containsLambda=false;
  SymbolType[] inferredTypes=null;
  if (previousPredicate != null) {
    inferredTypes=previousPredicate.getInferredMethodArgs();
  }
  if (args != null && !args.isEmpty()) {
    Iterator<Expression> it=args.iterator();
    int i=0;
    while (it.hasNext() && !found) {
      SymbolType argType=null;
      if (inferredTypes != null) {
        argType=inferredTypes[i];
      }
      Expression current=it.next();
      if (current instanceof LambdaExpr || current instanceof MethodReferenceExpr) {
        containsLambda=true;
        Class<?> interfaceToInspect=null;
        if (params[i].isInterface()) {
          interfaceToInspect=params[i];
        }
 else         if (isVarArgs && i == params.length - 1) {
          Class<?> componentType=params[i].getComponentType();
          if (componentType.isInterface()) {
            interfaceToInspect=componentType;
          }
        }
        if (interfaceToInspect != null) {
          if (current instanceof LambdaExpr) {
            found=filter((LambdaExpr)current,interfaceToInspect,argType,method);
            if (found) {
              calculatedTypeArgs[i]=(SymbolType)current.getSymbolData();
            }
          }
 else {
            found=filter((MethodReferenceExpr)current,interfaceToInspect,argType,method);
            if (found) {
              calculatedTypeArgs[i]=(SymbolType)current.getSymbolData();
            }
          }
        }
      }
      if (i < params.length - 1) {
        i++;
      }
    }
  }
  return (found && containsLambda) || !containsLambda;
}","public boolean filter(Executable method) throws Exception {
  boolean found=false;
  boolean containsLambda=false;
  SymbolType[] inferredTypes=null;
  if (previousPredicate != null) {
    inferredTypes=previousPredicate.getInferredMethodArgs();
  }
  if (args != null && !args.isEmpty()) {
    Iterator<Expression> it=args.iterator();
    int i=0;
    java.lang.reflect.Type[] genericTypes=method.getGenericParameterTypes();
    while (it.hasNext() && !found) {
      SymbolType argType=null;
      if (inferredTypes != null) {
        argType=inferredTypes[i];
      }
      Expression current=it.next();
      if (current instanceof LambdaExpr || current instanceof MethodReferenceExpr) {
        containsLambda=true;
        Class<?> interfaceToInspect=null;
        if (params[i].isInterface()) {
          interfaceToInspect=params[i];
        }
 else         if (isVarArgs && i == params.length - 1) {
          Class<?> componentType=params[i].getComponentType();
          if (componentType.isInterface()) {
            interfaceToInspect=componentType;
          }
        }
        if (interfaceToInspect != null) {
          if (current instanceof LambdaExpr) {
            found=filter((LambdaExpr)current,interfaceToInspect,genericTypes[i],argType,method);
            if (found) {
              calculatedTypeArgs[i]=(SymbolType)current.getSymbolData();
            }
          }
 else {
            found=filter((MethodReferenceExpr)current,interfaceToInspect,genericTypes[i],argType,method);
            if (found) {
              calculatedTypeArgs[i]=(SymbolType)current.getSymbolData();
            }
          }
        }
      }
      if (i < params.length - 1) {
        i++;
      }
    }
  }
  return (found && containsLambda) || !containsLambda;
}",0.9682862961885366
91198,"public Map<String,SymbolType> createMapping(Class<?> interfaceToInspect,SymbolType inferredArg,Executable method) throws Exception {
  Map<String,SymbolType> typeMapping=new HashMap<String,SymbolType>();
  GenericsBuilderFromClassParameterTypes builder=new GenericsBuilderFromClassParameterTypes(typeMapping,scope,symTable);
  builder.build(method.getDeclaringClass());
  typeMapping=builder.getTypeMapping();
  Map<String,SymbolType> update=new HashMap<String,SymbolType>();
  if (inferredArg != null) {
    SymbolType.valueOf(interfaceToInspect,inferredArg,update,null);
  }
  Map<String,SymbolType> subset=new HashMap<String,SymbolType>();
  Set<String> keys=update.keySet();
  for (  String key : keys) {
    SymbolType st1=update.get(key);
    Class<?> clazz=st1.getClazz();
    if (Object.class.equals(clazz)) {
      SymbolType aux=typeMapping.get(key);
      if (aux != null) {
        subset.put(key,aux);
      }
    }
  }
  update.clear();
  if (inferredArg != null) {
    SymbolType.valueOf(interfaceToInspect,inferredArg,update,subset);
  }
  update.putAll(subset);
  return update;
}","public Map<String,SymbolType> createMapping(Class<?> classToInspect,java.lang.reflect.Type interfaceToInspect,SymbolType inferredArg,Executable method) throws Exception {
  Map<String,SymbolType> typeMapping=new HashMap<String,SymbolType>();
  GenericsBuilderFromClassParameterTypes builder=new GenericsBuilderFromClassParameterTypes(typeMapping,scope,symTable);
  builder.build(method.getDeclaringClass());
  typeMapping=builder.getTypeMapping();
  Map<String,SymbolType> update=new HashMap<String,SymbolType>();
  Map<String,List<String>> equivalences=new HashMap<String,List<String>>();
  createEquivalenceMapping(classToInspect,interfaceToInspect,equivalences);
  Set<String> keys=equivalences.keySet();
  for (  String key : keys) {
    if (typeMapping.containsKey(key)) {
      List<String> list=equivalences.get(key);
      for (      String key2 : list) {
        update.put(key2,typeMapping.get(key));
      }
    }
  }
  keys=typeMapping.keySet();
  for (  String key : keys) {
    if (!equivalences.containsKey(key)) {
      update.put(key,typeMapping.get(key));
    }
  }
  if (inferredArg != null) {
    Map<String,SymbolType> paramsTypeMapping=new HashMap<String,SymbolType>();
    SymbolType.valueOf(classToInspect,inferredArg,paramsTypeMapping,null);
    Map<String,SymbolType> subset=new HashMap<String,SymbolType>();
    keys=paramsTypeMapping.keySet();
    for (    String key : keys) {
      SymbolType st1=paramsTypeMapping.get(key);
      Class<?> clazz=st1.getClazz();
      if (!Object.class.equals(clazz)) {
        subset.put(key,st1);
      }
    }
    update.putAll(subset);
  }
  return update;
}",0.5745775165319618
91199,"@Override public boolean filter(Method method) throws Exception {
  SymbolData returnType=expr.getBody().getSymbolData();
  if (returnType == null) {
    try {
      expr.accept(typeResolver,ctx);
    }
 catch (    Exception e) {
      return false;
    }
    returnType=expr.getBody().getSymbolData();
    if (returnType == null) {
      returnType=new SymbolType(void.class);
    }
  }
  Map<String,SymbolType> updateMapping=new HashMap<String,SymbolType>();
  SymbolType st=null;
  if (void.class.equals(method.getReturnType())) {
    st=new SymbolType(void.class);
  }
 else {
    st=SymbolType.valueOf(method.getGenericReturnType(),(SymbolType)returnType,updateMapping,null);
  }
  Map<String,SymbolType> aux=new HashMap<String,SymbolType>(typeMapping);
  aux.putAll(updateMapping);
  boolean isCompatible=(""String_Node_Str"".equals(st.getName()) && (expr.getBody() instanceof ExpressionStmt)) || (st.isCompatible((SymbolType)returnType));
  if (isCompatible) {
    expr.setSymbolData(SymbolType.valueOf(method.getDeclaringClass(),aux));
  }
  return isCompatible;
}","@Override public boolean filter(Method method) throws Exception {
  SymbolData returnType=expr.getBody().getSymbolData();
  if (returnType == null) {
    int scopeLevel=symTable.getScopeLevel();
    try {
      expr.accept(typeResolver,ctx);
    }
 catch (    Exception e) {
      int currentScopeLevel=symTable.getScopeLevel();
      while (currentScopeLevel > scopeLevel) {
        symTable.popScope(true);
        currentScopeLevel--;
      }
      return false;
    }
    returnType=expr.getBody().getSymbolData();
    if (returnType == null) {
      returnType=new SymbolType(void.class);
    }
  }
  Map<String,SymbolType> updateMapping=new HashMap<String,SymbolType>();
  SymbolType st=null;
  if (void.class.equals(method.getReturnType())) {
    st=new SymbolType(void.class);
  }
 else {
    st=SymbolType.valueOf(method.getGenericReturnType(),(SymbolType)returnType,updateMapping,null);
  }
  Map<String,SymbolType> aux=new HashMap<String,SymbolType>(typeMapping);
  aux.putAll(updateMapping);
  boolean isCompatible=(""String_Node_Str"".equals(st.getName()) && (expr.getBody() instanceof ExpressionStmt)) || (st.isCompatible((SymbolType)returnType));
  if (isCompatible) {
    expr.setSymbolData(SymbolType.valueOf(method.getDeclaringClass(),aux));
  }
  return isCompatible;
}",0.9083191850594228
91200,"public CompatibleLambdaResultPredicate(LambdaExpr expr,VoidVisitor<A> typeResolver,A ctx,Map<String,SymbolType> typeMapping){
  this.expr=expr;
  this.typeResolver=typeResolver;
  this.ctx=ctx;
  this.typeMapping=typeMapping;
}","public CompatibleLambdaResultPredicate(LambdaExpr expr,VoidVisitor<A> typeResolver,A ctx,Map<String,SymbolType> typeMapping,SymbolTable symTable){
  this.expr=expr;
  this.typeResolver=typeResolver;
  this.ctx=ctx;
  this.typeMapping=typeMapping;
  this.symTable=symTable;
}",0.906187624750499
91201,"@Override public boolean filter(Executable elem) throws Exception {
  Executable equivalentMethod=null;
  sd=(SymbolType)expression.getScope().getSymbolData();
  if (sd == null) {
    expression.getScope().accept(typeResolver,ctx);
    sd=(SymbolType)expression.getScope().getSymbolData();
    if (!expression.getIdentifier().equals(""String_Node_Str"")) {
      ArrayFilter<Method> filter=new ArrayFilter<Method>(sd.getClazz().getMethods());
      filter.appendPredicate(new MethodsByNamePredicate(expression.getIdentifier()));
      methodCallCandidates=filter.filter();
    }
  }
  boolean found=false;
  if (!expression.getIdentifier().equals(""String_Node_Str"")) {
    Iterator<Method> it=methodCallCandidates.iterator();
    while (it.hasNext() && !found) {
      Method md=it.next();
      int mdParameterCount=md.getParameterTypes().length;
      int elemParameterCount=elem.getParameterTypes().length;
      FunctionalGenericsBuilder<MethodReferenceExpr> builder=new FunctionalGenericsBuilder<MethodReferenceExpr>(md,typeResolver,getTypeMapping());
      builder.build(expression);
      SymbolType[] args=builder.getArgs();
      if (!Modifier.isStatic(md.getModifiers())) {
        if (mdParameterCount == elemParameterCount - 1) {
          SymbolType[] staticArgs=new SymbolType[args.length + 1];
          for (int i=0; i < args.length; i++) {
            staticArgs[i + 1]=args[i];
          }
          staticArgs[0]=(SymbolType)sd;
          args=staticArgs;
          setTypeArgs(args);
          found=super.filter(elem);
        }
 else {
          String typeName=expression.getScope().toString();
          if (symTable.findSymbol(typeName,ReferenceType.VARIABLE) != null && mdParameterCount == elemParameterCount) {
            setTypeArgs(args);
            found=super.filter(elem);
          }
        }
      }
 else       if (mdParameterCount == elemParameterCount) {
        setTypeArgs(args);
        found=super.filter(elem);
      }
      if (found) {
        equivalentMethod=md;
      }
    }
  }
 else {
    Constructor<?>[] constructors=sd.getClazz().getConstructors();
    for (int i=0; i < constructors.length && !found; i++) {
      FunctionalGenericsBuilder<MethodReferenceExpr> builder=new FunctionalGenericsBuilder<MethodReferenceExpr>(constructors[i],typeResolver,getTypeMapping());
      builder.build(expression);
      SymbolType[] args=builder.getArgs();
      setTypeArgs(args);
      found=super.filter(elem);
      if (found) {
        equivalentMethod=constructors[i];
      }
    }
  }
  if (found && elem instanceof Method) {
    Map<String,SymbolType> mapping=getTypeMapping();
    SymbolType realResultType=null;
    if (equivalentMethod instanceof Method) {
      realResultType=SymbolType.valueOf((Method)equivalentMethod,mapping);
      java.lang.reflect.Type genericReturnType=((Method)elem).getGenericReturnType();
      resolveTypeMapping(genericReturnType,realResultType,mapping);
    }
    realResultType=SymbolType.valueOf(elem.getDeclaringClass(),mapping);
    expression.setSymbolData(realResultType);
    SymbolType st=SymbolType.valueOf((Method)elem,mapping);
    expression.setReferencedMethodSymbolData(st);
    expression.setReferencedArgsSymbolData(getTypeArgs());
  }
  return found;
}","@Override public boolean filter(Executable elem) throws Exception {
  Executable equivalentMethod=null;
  sd=(SymbolType)expression.getScope().getSymbolData();
  if (sd == null) {
    expression.getScope().accept(typeResolver,ctx);
    sd=(SymbolType)expression.getScope().getSymbolData();
    if (!expression.getIdentifier().equals(""String_Node_Str"")) {
      ArrayFilter<Method> filter=new ArrayFilter<Method>(sd.getClazz().getMethods());
      filter.appendPredicate(new MethodsByNamePredicate(expression.getIdentifier()));
      methodCallCandidates=filter.filter();
    }
  }
  boolean found=false;
  if (!expression.getIdentifier().equals(""String_Node_Str"")) {
    Iterator<Method> it=methodCallCandidates.iterator();
    while (it.hasNext() && !found) {
      Method md=it.next();
      int mdParameterCount=md.getParameterTypes().length;
      int elemParameterCount=elem.getParameterTypes().length;
      FunctionalGenericsBuilder<MethodReferenceExpr> builder=new FunctionalGenericsBuilder<MethodReferenceExpr>(md,typeResolver,getTypeMapping());
      builder.build(expression);
      SymbolType[] args=builder.getArgs();
      if (!Modifier.isStatic(md.getModifiers())) {
        if (mdParameterCount == elemParameterCount - 1) {
          SymbolType[] staticArgs=new SymbolType[args.length + 1];
          for (int i=0; i < args.length; i++) {
            staticArgs[i + 1]=args[i];
          }
          staticArgs[0]=(SymbolType)sd;
          args=staticArgs;
          setTypeArgs(args);
          found=super.filter(elem);
        }
 else {
          Expression scope=expression.getScope();
          SymbolType stype=(SymbolType)scope.getSymbolData();
          boolean isField=stype.getField() != null;
          boolean isVariable=false;
          if (!isField) {
            String name=scope.toString();
            isVariable=(symTable.findSymbol(name,ReferenceType.VARIABLE) != null);
          }
          if ((isField || isVariable) && mdParameterCount == elemParameterCount) {
            setTypeArgs(args);
            found=super.filter(elem);
          }
        }
      }
 else       if (mdParameterCount == elemParameterCount) {
        setTypeArgs(args);
        found=super.filter(elem);
      }
      if (found) {
        equivalentMethod=md;
      }
    }
  }
 else {
    Constructor<?>[] constructors=sd.getClazz().getConstructors();
    for (int i=0; i < constructors.length && !found; i++) {
      FunctionalGenericsBuilder<MethodReferenceExpr> builder=new FunctionalGenericsBuilder<MethodReferenceExpr>(constructors[i],typeResolver,getTypeMapping());
      builder.build(expression);
      SymbolType[] args=builder.getArgs();
      setTypeArgs(args);
      found=super.filter(elem);
      if (found) {
        equivalentMethod=constructors[i];
      }
    }
  }
  if (found && elem instanceof Method) {
    Map<String,SymbolType> mapping=getTypeMapping();
    SymbolType realResultType=null;
    if (equivalentMethod instanceof Method) {
      realResultType=SymbolType.valueOf((Method)equivalentMethod,mapping);
      java.lang.reflect.Type genericReturnType=((Method)elem).getGenericReturnType();
      resolveTypeMapping(genericReturnType,realResultType,mapping);
    }
    realResultType=SymbolType.valueOf(elem.getDeclaringClass(),mapping);
    expression.setSymbolData(realResultType);
    SymbolType st=SymbolType.valueOf((Method)elem,mapping);
    expression.setReferencedMethodSymbolData(st);
    expression.setReferencedArgsSymbolData(getTypeArgs());
  }
  return found;
}",0.9371310507674144
91202,"public static SymbolType findFieldType(SymbolTable symTable,SymbolType scope,String fieldName){
  SymbolType result=null;
  if (scope != null) {
    List<Class<?>> classes=scope.getBoundClasses();
    Iterator<Class<?>> it=classes.iterator();
    while (it.hasNext() && result == null) {
      try {
        Class<?> clazz=it.next();
        Field field=null;
        if (scope.getArrayCount() > 0 && fieldName.equals(""String_Node_Str"")) {
          result=new SymbolType(""String_Node_Str"");
        }
 else {
          try {
            field=clazz.getDeclaredField(fieldName);
          }
 catch (          NoSuchFieldException fe) {
            field=getField0(clazz.getPackage(),clazz,fieldName);
            if (field == null) {
              SymbolType st=symTable.getType(""String_Node_Str"");
              Class<?> internal=ClassInspector.findClassMember(st.getClazz().getPackage(),fieldName,clazz);
              if (internal != null) {
                result=new SymbolType(internal);
              }
            }
          }
          if (result == null) {
            Map<String,SymbolType> typeMapping=new HashMap<String,SymbolType>();
            GenericBuilderFromGenericClasses builder=new GenericBuilderFromGenericClasses(clazz,scope.getParameterizedTypes());
            builder.build(typeMapping);
            result=SymbolType.valueOf(field.getGenericType(),typeMapping);
          }
        }
      }
 catch (      Exception e) {
        throw new NoSuchExpressionTypeException(e);
      }
    }
  }
  return result;
}","public static SymbolType findFieldType(SymbolTable symTable,SymbolType scope,String fieldName){
  SymbolType result=null;
  if (scope != null) {
    List<Class<?>> classes=scope.getBoundClasses();
    Iterator<Class<?>> it=classes.iterator();
    while (it.hasNext() && result == null) {
      try {
        Class<?> clazz=it.next();
        Field field=null;
        if (scope.getArrayCount() > 0 && fieldName.equals(""String_Node_Str"")) {
          result=new SymbolType(""String_Node_Str"");
        }
 else {
          try {
            field=clazz.getDeclaredField(fieldName);
          }
 catch (          NoSuchFieldException fe) {
            field=getField0(clazz.getPackage(),clazz,fieldName);
            if (field == null) {
              SymbolType st=symTable.getType(""String_Node_Str"");
              Class<?> internal=ClassInspector.findClassMember(st.getClazz().getPackage(),fieldName,clazz);
              if (internal != null) {
                result=new SymbolType(internal);
              }
            }
          }
          if (result == null) {
            Map<String,SymbolType> typeMapping=new HashMap<String,SymbolType>();
            GenericBuilderFromGenericClasses builder=new GenericBuilderFromGenericClasses(clazz,scope.getParameterizedTypes());
            builder.build(typeMapping);
            result=SymbolType.valueOf(field.getGenericType(),typeMapping);
            result.setField(field);
          }
        }
      }
 catch (      Exception e) {
        throw new NoSuchExpressionTypeException(e);
      }
    }
  }
  return result;
}",0.9884393063583816
91203,"private SymbolType clone(Stack<SymbolType> parent,Stack<SymbolType> created){
  SymbolType result=new SymbolType();
  result.setName(name);
  result.setClazz(clazz);
  result.setArrayCount(arrayCount);
  result.templateVariable=templateVariable;
  if (parent == null) {
    parent=new Stack<SymbolType>();
    created=new Stack<SymbolType>();
  }
  Iterator<SymbolType> it=parent.iterator();
  Iterator<SymbolType> it2=created.iterator();
  boolean found=false;
  while (it.hasNext() && !found) {
    SymbolType next=it.next();
    SymbolType created2=it2.next();
    if (next == this) {
      result=created2;
      found=true;
    }
  }
  if (!found) {
    parent.push(this);
    created.push(result);
    if (parameterizedTypes != null) {
      List<SymbolType> list=new LinkedList<SymbolType>();
      for (      SymbolData type : parameterizedTypes) {
        list.add(((SymbolType)type).clone(parent,created));
      }
      result.setParameterizedTypes(list);
    }
    if (upperBounds != null) {
      List<SymbolType> list=new LinkedList<SymbolType>();
      for (      SymbolData type : upperBounds) {
        list.add(((SymbolType)type).clone(parent,created));
      }
      result.upperBounds=list;
    }
    if (lowerBounds != null) {
      List<SymbolType> list=new LinkedList<SymbolType>();
      for (      SymbolData type : lowerBounds) {
        list.add(((SymbolType)type).clone(parent,created));
      }
      result.lowerBounds=list;
    }
    parent.pop();
    created.pop();
  }
  return result;
}","private SymbolType clone(Stack<SymbolType> parent,Stack<SymbolType> created){
  SymbolType result=new SymbolType();
  result.setName(name);
  result.setClazz(clazz);
  result.setArrayCount(arrayCount);
  result.setField(field);
  result.setMethod(method);
  result.templateVariable=templateVariable;
  if (parent == null) {
    parent=new Stack<SymbolType>();
    created=new Stack<SymbolType>();
  }
  Iterator<SymbolType> it=parent.iterator();
  Iterator<SymbolType> it2=created.iterator();
  boolean found=false;
  while (it.hasNext() && !found) {
    SymbolType next=it.next();
    SymbolType created2=it2.next();
    if (next == this) {
      result=created2;
      found=true;
    }
  }
  if (!found) {
    parent.push(this);
    created.push(result);
    if (parameterizedTypes != null) {
      List<SymbolType> list=new LinkedList<SymbolType>();
      for (      SymbolData type : parameterizedTypes) {
        list.add(((SymbolType)type).clone(parent,created));
      }
      result.setParameterizedTypes(list);
    }
    if (upperBounds != null) {
      List<SymbolType> list=new LinkedList<SymbolType>();
      for (      SymbolData type : upperBounds) {
        list.add(((SymbolType)type).clone(parent,created));
      }
      result.upperBounds=list;
    }
    if (lowerBounds != null) {
      List<SymbolType> list=new LinkedList<SymbolType>();
      for (      SymbolData type : lowerBounds) {
        list.add(((SymbolType)type).clone(parent,created));
      }
      result.lowerBounds=list;
    }
    parent.pop();
    created.pop();
  }
  return result;
}",0.982546864899806
91204,"private void typeMappingUpdate(Type type,SymbolType typeArg) throws InvalidTypeException {
  if (type instanceof TypeVariable) {
    String name=((TypeVariable<?>)type).getName();
    Symbol<?> s=typeParamsSymbolTable.findSymbol(name,ReferenceType.TYPE,ReferenceType.TYPE_PARAM);
    SymbolType st=null;
    if (s != null) {
      st=s.getType();
    }
    if ((s == null || st == null) || (st.isTemplateVariable() && s.getReferenceType().equals(ReferenceType.TYPE_PARAM)) || (Object.class.equals(st.getClazz()) && !s.getReferenceType().equals(ReferenceType.TYPE))) {
      typeParamsSymbolTable.pushSymbol(name,ReferenceType.TYPE,typeArg,null);
    }
 else {
      if (s.getReferenceType().equals(ReferenceType.TYPE)) {
        SymbolType aux=(SymbolType)st.merge(typeArg);
        s.setType(aux);
      }
 else {
        typeParamsSymbolTable.pushSymbol(name,ReferenceType.TYPE,typeArg,null);
      }
    }
  }
 else   if (type instanceof ParameterizedType) {
    ParameterizedType paramType=(ParameterizedType)type;
    Type[] args=paramType.getActualTypeArguments();
    if (typeArg != null) {
      Map<String,SymbolType> updateMapping=new LinkedHashMap<String,SymbolType>();
      SymbolType rewrittenType=SymbolType.valueOf(paramType.getRawType(),typeArg,updateMapping,null);
      List<SymbolType> callParams=typeArg.getParameterizedTypes();
      List<SymbolType> rewrittenParams=rewrittenType.getParameterizedTypes();
      if (rewrittenParams != null) {
        Iterator<SymbolType> itP=rewrittenParams.iterator();
        Iterator<SymbolType> auxIt=null;
        if (callParams != null) {
          auxIt=callParams.iterator();
        }
        int i=0;
        while (itP.hasNext() && i < args.length) {
          SymbolType st=itP.next();
          if ((st.getName() == null || Object.class.equals(st.getClazz()))) {
            if (auxIt != null && auxIt.hasNext()) {
              typeMappingUpdate(args[i],auxIt.next());
            }
 else {
              typeMappingUpdate(args[i],st);
            }
          }
 else {
            typeMappingUpdate(args[i],st);
          }
          i++;
        }
      }
    }
  }
 else   if (type instanceof WildcardType) {
    if (typeArg != null) {
      WildcardType wildcardType=(WildcardType)type;
      Type[] upper=wildcardType.getUpperBounds();
      List<SymbolType> bounds=typeArg.getBounds();
      if (bounds == null) {
        bounds=new LinkedList<SymbolType>();
        bounds.add(typeArg);
      }
      for (int i=0; i < upper.length; i++) {
        typeMappingUpdate(upper[i],bounds.get(i));
      }
      Type[] lower=wildcardType.getLowerBounds();
      List<SymbolType> lowerBounds=typeArg.getLowerBounds();
      if (lowerBounds != null) {
        bounds=lowerBounds;
      }
      if (bounds != null) {
        for (int i=0; i < lower.length; i++) {
          typeMappingUpdate(lower[i],bounds.get(i));
        }
      }
    }
  }
 else   if (type instanceof GenericArrayType) {
    if (typeArg != null) {
      GenericArrayType arrayType=(GenericArrayType)type;
      SymbolType aux=typeArg.clone();
      if (typeArg.getArrayCount() > 0) {
        aux.setArrayCount(typeArg.getArrayCount() - 1);
      }
      typeMappingUpdate(arrayType.getGenericComponentType(),aux);
    }
  }
 else   if (type instanceof Class<?>) {
    if (typeArg != null) {
      Class<?> clazz=(Class<?>)type;
      Map<String,SymbolType> updateMapping=new LinkedHashMap<String,SymbolType>();
      SymbolType rewrittenType=SymbolType.valueOf(clazz,typeArg,updateMapping,null);
      TypeVariable[] tvs=clazz.getTypeParameters();
      List<SymbolType> paramTypes=rewrittenType.getParameterizedTypes();
      if (paramTypes != null) {
        Iterator<SymbolType> it=paramTypes.iterator();
        for (int i=0; i < tvs.length && it.hasNext(); i++) {
          SymbolType st=it.next();
          if (st != null) {
            typeMappingUpdate(tvs[i],st);
          }
        }
      }
    }
  }
}","private void typeMappingUpdate(Type type,SymbolType typeArg) throws InvalidTypeException {
  if (type instanceof TypeVariable) {
    String name=((TypeVariable<?>)type).getName();
    Symbol<?> s=typeParamsSymbolTable.findSymbol(name,ReferenceType.TYPE,ReferenceType.TYPE_PARAM);
    SymbolType st=null;
    if (s != null) {
      st=s.getType();
    }
    if ((s == null || st == null) || (st.isTemplateVariable() && s.getReferenceType().equals(ReferenceType.TYPE_PARAM)) || (Object.class.equals(st.getClazz()) && !s.getReferenceType().equals(ReferenceType.TYPE))) {
      typeParamsSymbolTable.pushSymbol(name,ReferenceType.TYPE,typeArg,null);
    }
 else {
      if (s.getReferenceType().equals(ReferenceType.TYPE)) {
        SymbolType aux=(SymbolType)st.merge(typeArg);
        s.setType(aux);
      }
 else {
        typeParamsSymbolTable.pushSymbol(name,ReferenceType.TYPE,typeArg,null);
      }
    }
  }
 else   if (type instanceof ParameterizedType) {
    ParameterizedType paramType=(ParameterizedType)type;
    Type[] args=paramType.getActualTypeArguments();
    if (typeArg != null) {
      Map<String,SymbolType> updateMapping=new LinkedHashMap<String,SymbolType>();
      SymbolType rewrittenType=SymbolType.valueOf(paramType.getRawType(),typeArg,updateMapping,null);
      List<SymbolType> callParams=typeArg.getParameterizedTypes();
      String name=rewrittenType.getName();
      if (name == null || !""String_Node_Str"".equals(name)) {
        List<SymbolType> rewrittenParams=rewrittenType.getParameterizedTypes();
        if (rewrittenParams != null) {
          Iterator<SymbolType> itP=rewrittenParams.iterator();
          Iterator<SymbolType> auxIt=null;
          if (callParams != null) {
            auxIt=callParams.iterator();
          }
          int i=0;
          while (itP.hasNext() && i < args.length) {
            SymbolType st=itP.next();
            if ((st.getName() == null || Object.class.equals(st.getClazz()))) {
              if (auxIt != null && auxIt.hasNext()) {
                typeMappingUpdate(args[i],auxIt.next());
              }
 else {
                typeMappingUpdate(args[i],st);
              }
            }
 else {
              typeMappingUpdate(args[i],st);
            }
            i++;
          }
        }
      }
    }
  }
 else   if (type instanceof WildcardType) {
    if (typeArg != null) {
      WildcardType wildcardType=(WildcardType)type;
      Type[] upper=wildcardType.getUpperBounds();
      List<SymbolType> bounds=typeArg.getBounds();
      if (bounds == null) {
        bounds=new LinkedList<SymbolType>();
        bounds.add(typeArg);
      }
      for (int i=0; i < upper.length; i++) {
        typeMappingUpdate(upper[i],bounds.get(i));
      }
      Type[] lower=wildcardType.getLowerBounds();
      List<SymbolType> lowerBounds=typeArg.getLowerBounds();
      if (lowerBounds != null) {
        bounds=lowerBounds;
      }
      if (bounds != null) {
        for (int i=0; i < lower.length; i++) {
          typeMappingUpdate(lower[i],bounds.get(i));
        }
      }
    }
  }
 else   if (type instanceof GenericArrayType) {
    if (typeArg != null) {
      GenericArrayType arrayType=(GenericArrayType)type;
      SymbolType aux=typeArg.clone();
      if (typeArg.getArrayCount() > 0) {
        aux.setArrayCount(typeArg.getArrayCount() - 1);
      }
      typeMappingUpdate(arrayType.getGenericComponentType(),aux);
    }
  }
 else   if (type instanceof Class<?>) {
    if (typeArg != null) {
      Class<?> clazz=(Class<?>)type;
      Map<String,SymbolType> updateMapping=new LinkedHashMap<String,SymbolType>();
      SymbolType rewrittenType=SymbolType.valueOf(clazz,typeArg,updateMapping,null);
      TypeVariable[] tvs=clazz.getTypeParameters();
      List<SymbolType> paramTypes=rewrittenType.getParameterizedTypes();
      if (paramTypes != null) {
        Iterator<SymbolType> it=paramTypes.iterator();
        for (int i=0; i < tvs.length && it.hasNext(); i++) {
          SymbolType st=it.next();
          if (st != null) {
            typeMappingUpdate(tvs[i],st);
          }
        }
      }
    }
  }
}",0.980654761904762
91205,"private void updateTypeMapping(java.lang.reflect.Type type,SymbolTable genericsSymbolTable,SymbolType parameterizedType,boolean genericArgs) throws InvalidTypeException {
  if (parameterizedType != null) {
    if (type instanceof TypeVariable) {
      TypeVariable<?> tv=(TypeVariable<?>)type;
      String vname=tv.getName();
      Symbol<?> s=genericsSymbolTable.findSymbol(vname);
      if (s != null) {
        boolean isInTheTopScope=genericsSymbolTable.getScopes().peek().findSymbol(vname) != null;
        SymbolType refactor=s.getType().refactor(vname,parameterizedType,genericArgs || isInTheTopScope);
        s.setType(refactor);
      }
 else {
        genericsSymbolTable.pushSymbol(vname,ReferenceType.TYPE,parameterizedType,null);
      }
      java.lang.reflect.Type[] bounds=tv.getBounds();
      List<SymbolType> paramBounds=parameterizedType.getBounds();
      if (paramBounds != null) {
        for (int i=0; i < bounds.length; i++) {
          if (!parameterizedType.equals(paramBounds.get(i))) {
            updateTypeMapping(bounds[i],genericsSymbolTable,paramBounds.get(i),genericArgs);
          }
        }
      }
    }
 else     if (type instanceof WildcardType) {
      WildcardType wildcard=(WildcardType)type;
      java.lang.reflect.Type[] bounds=wildcard.getUpperBounds();
      List<SymbolType> paramBounds=parameterizedType.getBounds();
      if (paramBounds != null) {
        for (int i=0; i < bounds.length; i++) {
          updateTypeMapping(bounds[i],genericsSymbolTable,paramBounds.get(i),genericArgs);
        }
      }
      bounds=wildcard.getLowerBounds();
      paramBounds=parameterizedType.getLowerBounds();
      if (paramBounds != null) {
        for (int i=0; i < bounds.length; i++) {
          updateTypeMapping(bounds[i],genericsSymbolTable,paramBounds.get(i),genericArgs);
        }
      }
    }
 else     if (type instanceof ParameterizedType) {
      ParameterizedType paramType=(ParameterizedType)type;
      java.lang.reflect.Type[] typeArgs=paramType.getActualTypeArguments();
      List<SymbolType> paramTypeParams=parameterizedType.getParameterizedTypes();
      if (paramTypeParams != null) {
        for (int i=0; i < typeArgs.length; i++) {
          SymbolType st=null;
          if (i < paramTypeParams.size()) {
            st=paramTypeParams.get(i);
          }
          updateTypeMapping(typeArgs[i],genericsSymbolTable,st,genericArgs);
        }
      }
    }
 else     if (type instanceof GenericArrayType) {
      GenericArrayType arrayType=(GenericArrayType)type;
      SymbolType st=parameterizedType.clone();
      st.setArrayCount(parameterizedType.getArrayCount() - 1);
      updateTypeMapping(arrayType.getGenericComponentType(),genericsSymbolTable,st,genericArgs);
    }
 else     if (type instanceof Class) {
      Class<?> clazz=(Class<?>)type;
      Map<String,SymbolType> updateMapping=new LinkedHashMap<String,SymbolType>();
      SymbolType rewrittenType=SymbolType.valueOf(clazz,parameterizedType,updateMapping,null);
      java.lang.reflect.TypeVariable[] tparams=clazz.getTypeParameters();
      List<SymbolType> paramTypes=rewrittenType.getParameterizedTypes();
      if (paramTypes != null) {
        Iterator<SymbolType> it=paramTypes.iterator();
        for (int i=0; i < tparams.length && it.hasNext(); i++) {
          SymbolType st=it.next();
          if (st != null) {
            st.setTemplateVariable(tparams[i].getName());
            updateTypeMapping(tparams[i],genericsSymbolTable,st,true);
          }
        }
      }
    }
  }
}","private void updateTypeMapping(java.lang.reflect.Type type,SymbolTable genericsSymbolTable,SymbolType parameterizedType,boolean genericArgs) throws InvalidTypeException {
  if (parameterizedType != null) {
    if (type instanceof TypeVariable) {
      TypeVariable<?> tv=(TypeVariable<?>)type;
      String vname=tv.getName();
      Symbol<?> s=genericsSymbolTable.findSymbol(vname);
      if (s != null) {
        boolean isInTheTopScope=genericsSymbolTable.getScopes().peek().findSymbol(vname) != null;
        SymbolType st=s.getType();
        if (st != null) {
          SymbolType refactor=s.getType().refactor(vname,parameterizedType,genericArgs || isInTheTopScope);
          s.setType(refactor);
        }
 else {
          s.setType(parameterizedType);
        }
      }
 else {
        genericsSymbolTable.pushSymbol(vname,ReferenceType.TYPE,parameterizedType,null);
      }
      java.lang.reflect.Type[] bounds=tv.getBounds();
      List<SymbolType> paramBounds=parameterizedType.getBounds();
      if (paramBounds != null) {
        for (int i=0; i < bounds.length; i++) {
          if (!parameterizedType.equals(paramBounds.get(i))) {
            updateTypeMapping(bounds[i],genericsSymbolTable,paramBounds.get(i),genericArgs);
          }
        }
      }
    }
 else     if (type instanceof WildcardType) {
      WildcardType wildcard=(WildcardType)type;
      java.lang.reflect.Type[] bounds=wildcard.getUpperBounds();
      List<SymbolType> paramBounds=parameterizedType.getBounds();
      if (paramBounds != null) {
        for (int i=0; i < bounds.length; i++) {
          updateTypeMapping(bounds[i],genericsSymbolTable,paramBounds.get(i),genericArgs);
        }
      }
      bounds=wildcard.getLowerBounds();
      paramBounds=parameterizedType.getLowerBounds();
      if (paramBounds != null) {
        for (int i=0; i < bounds.length; i++) {
          updateTypeMapping(bounds[i],genericsSymbolTable,paramBounds.get(i),genericArgs);
        }
      }
    }
 else     if (type instanceof ParameterizedType) {
      ParameterizedType paramType=(ParameterizedType)type;
      java.lang.reflect.Type[] typeArgs=paramType.getActualTypeArguments();
      List<SymbolType> paramTypeParams=parameterizedType.getParameterizedTypes();
      if (paramTypeParams != null) {
        for (int i=0; i < typeArgs.length; i++) {
          SymbolType st=null;
          if (i < paramTypeParams.size()) {
            st=paramTypeParams.get(i);
          }
          updateTypeMapping(typeArgs[i],genericsSymbolTable,st,genericArgs);
        }
      }
    }
 else     if (type instanceof GenericArrayType) {
      GenericArrayType arrayType=(GenericArrayType)type;
      SymbolType st=parameterizedType.clone();
      st.setArrayCount(parameterizedType.getArrayCount() - 1);
      updateTypeMapping(arrayType.getGenericComponentType(),genericsSymbolTable,st,genericArgs);
    }
 else     if (type instanceof Class) {
      Class<?> clazz=(Class<?>)type;
      Map<String,SymbolType> updateMapping=new LinkedHashMap<String,SymbolType>();
      SymbolType rewrittenType=SymbolType.valueOf(clazz,parameterizedType,updateMapping,null);
      java.lang.reflect.TypeVariable[] tparams=clazz.getTypeParameters();
      List<SymbolType> paramTypes=rewrittenType.getParameterizedTypes();
      if (paramTypes != null) {
        Iterator<SymbolType> it=paramTypes.iterator();
        for (int i=0; i < tparams.length && it.hasNext(); i++) {
          SymbolType st=it.next();
          if (st != null) {
            st.setTemplateVariable(tparams[i].getName());
            updateTypeMapping(tparams[i],genericsSymbolTable,st,true);
          }
        }
      }
    }
  }
}",0.9760022194479124
91206,"@Override public void doPush(Symbol<?> symbol,SymbolTable table) throws Exception {
  if (symbol.getName().equals(""String_Node_Str"")) {
    Node node=symbol.getLocation();
    if (node instanceof EnumDeclaration) {
      EnumDeclaration ed=(EnumDeclaration)node;
      List<EnumConstantDeclaration> entries=ed.getEntries();
      for (      EnumConstantDeclaration ecd : entries) {
        table.pushSymbol(ecd.getName(),ReferenceType.ENUM_LITERAL,symbol.getType(),ecd);
      }
    }
  }
}","@Override public void doPush(Symbol<?> symbol,SymbolTable table) throws Exception {
  if (symbol.getName().equals(""String_Node_Str"")) {
    Node node=symbol.getLocation();
    if (node instanceof EnumDeclaration) {
      EnumDeclaration ed=(EnumDeclaration)node;
      List<EnumConstantDeclaration> entries=ed.getEntries();
      if (entries != null) {
        for (        EnumConstantDeclaration ecd : entries) {
          table.pushSymbol(ecd.getName(),ReferenceType.ENUM_LITERAL,symbol.getType(),ecd);
        }
      }
    }
  }
}",0.9482926829268292
91207,"public String generateAnonymousClass(){
  int j=indexStructure.size() - 2;
  String suffixName=null;
  while (j > 0 && suffixName == null) {
    Scope sc=indexStructure.get(j);
    Symbol<?> rootSymbol=sc.getRootSymbol();
    if (rootSymbol != null) {
      SymbolDefinition sd=rootSymbol.getLocation();
      if (sd instanceof ObjectCreationExpr || sd instanceof TypeDeclaration || sd instanceof TypeDeclarationStmt) {
        sc.incrInnerAnonymousClassCounter();
        int num=sc.getInnerAnonymousClassCounter();
        suffixName=""String_Node_Str"" + num;
        return ((SymbolDataAware<?>)sd).getSymbolData().getName() + suffixName;
      }
    }
    j--;
  }
  return null;
}","public String generateAnonymousClass(){
  return getTypeAnonymousClassPreffix(false);
}",0.2049286640726329
91208,"public void loadExtendsOrImplements(List<ClassOrInterfaceType> extendsList){
  if (extendsList != null) {
    for (    ClassOrInterfaceType type : extendsList) {
      String name=type.accept(nameBuilder,null);
      Symbol<?> s=table.findSymbol(name,ReferenceType.TYPE);
      if (s == null) {
        SymbolType st=ASTSymbolTypeResolver.getInstance().valueOf(type);
        name=st.getClazz().getCanonicalName();
        s=table.findSymbol(name,ReferenceType.TYPE);
      }
      if (s != null) {
        Object location=s.getLocation();
        if (location != null && location instanceof TypeDeclaration) {
          TypeDeclaration superClass=((TypeDeclaration)location);
          superClass.accept(this,s.getInnerScope());
        }
 else {
          Class<?> clazz=s.getType().getClazz();
          Set<Method> methods=MethodInspector.getNonPrivateMethods(clazz);
          Symbol<?> parent=table.findSymbol(""String_Node_Str"",ReferenceType.VARIABLE);
          if (parent == null) {
            parent=table.pushSymbol(""String_Node_Str"",ReferenceType.TYPE,new SymbolType(clazz),null);
          }
          Scope parentScope=parent.getInnerScope();
          if (parentScope == null) {
            parentScope=new Scope(parent);
            parent.setInnerScope(parentScope);
          }
          SymbolType typeArg=ASTSymbolTypeResolver.getInstance().valueOf(type);
          List<SymbolType> params=typeArg.getParameterizedTypes();
          table.pushScope(parentScope);
          for (          Method method : methods) {
            Map<String,SymbolType> parameterTypes=null;
            try {
              java.lang.reflect.Type[] genericParameterTypes=method.getGenericParameterTypes();
              SymbolType[] methodArgs=new SymbolType[genericParameterTypes.length];
              if (params != null) {
                parameterTypes=new HashMap<String,SymbolType>();
                TypeVariable<?>[] typeParams=method.getDeclaringClass().getTypeParameters();
                for (int i=0; i < typeParams.length; i++) {
                  SymbolType.valueOf(typeParams[i],params.get(i),parameterTypes,null);
                }
              }
              for (int i=0; i < genericParameterTypes.length; i++) {
                methodArgs[i]=SymbolType.valueOf(genericParameterTypes[i],parameterTypes);
              }
              MethodSymbol methodSymbol=new MethodSymbol(method.getName(),SymbolType.valueOf(method,parameterTypes),null,s.getType(),methodArgs,false,method.isVarArgs(),method,null);
              table.pushSymbol(methodSymbol);
            }
 catch (            Exception e) {
              throw new RuntimeException(e);
            }
          }
          table.popScope(true);
        }
      }
    }
  }
}","public void loadExtendsOrImplements(List<ClassOrInterfaceType> extendsList){
  if (extendsList != null) {
    for (    ClassOrInterfaceType type : extendsList) {
      String name=type.accept(nameBuilder,null);
      Symbol<?> s=table.findSymbol(name,ReferenceType.TYPE);
      if (s == null) {
        SymbolType st=ASTSymbolTypeResolver.getInstance().valueOf(type);
        name=st.getClazz().getCanonicalName();
        s=table.findSymbol(name,ReferenceType.TYPE);
      }
      if (s != null) {
        Object location=s.getLocation();
        if (location != null && location instanceof TypeDeclaration) {
          TypeDeclaration superClass=((TypeDeclaration)location);
          superClass.accept(this,s.getInnerScope());
        }
 else {
          Class<?> clazz=s.getType().getClazz();
          Set<Method> methods=MethodInspector.getNonPrivateMethods(clazz);
          Symbol<?> parent=table.findSymbol(""String_Node_Str"",ReferenceType.VARIABLE);
          if (parent == null) {
            parent=table.pushSymbol(""String_Node_Str"",ReferenceType.TYPE,new SymbolType(clazz),null);
          }
          Scope parentScope=parent.getInnerScope();
          if (parentScope == null) {
            parentScope=new Scope(parent);
            parent.setInnerScope(parentScope);
          }
          SymbolType typeArg=ASTSymbolTypeResolver.getInstance().valueOf(type);
          List<SymbolType> params=typeArg.getParameterizedTypes();
          table.pushScope(parentScope);
          for (          Method method : methods) {
            Map<String,SymbolType> parameterTypes=null;
            try {
              java.lang.reflect.Type[] genericParameterTypes=method.getGenericParameterTypes();
              SymbolType[] methodArgs=new SymbolType[genericParameterTypes.length];
              if (params != null) {
                parameterTypes=new HashMap<String,SymbolType>();
                TypeVariable<?>[] typeParams=method.getDeclaringClass().getTypeParameters();
                for (int i=0; i < params.size() && i < typeParams.length; i++) {
                  SymbolType.valueOf(typeParams[i],params.get(i),parameterTypes,null);
                }
              }
              for (int i=0; i < genericParameterTypes.length; i++) {
                methodArgs[i]=SymbolType.valueOf(genericParameterTypes[i],parameterTypes);
              }
              MethodSymbol methodSymbol=new MethodSymbol(method.getName(),SymbolType.valueOf(method,parameterTypes),null,s.getType(),methodArgs,false,method.isVarArgs(),method,null);
              table.pushSymbol(methodSymbol);
            }
 catch (            Exception e) {
              throw new RuntimeException(e);
            }
          }
          table.popScope(true);
        }
      }
    }
  }
}",0.9961963412425284
91209,"@Override public SymbolData merge(SymbolData other){
  SymbolType result=null;
  if (other == null) {
    result=this;
  }
 else {
    List<Class<?>> bounds=ClassInspector.getTheNearestSuperClasses(getBoundClasses(),other.getBoundClasses());
    if (bounds.isEmpty()) {
      result=null;
    }
 else     if (bounds.size() == 1) {
      result=new SymbolType(bounds.get(0));
    }
 else {
      List<SymbolType> boundsList=new LinkedList<SymbolType>();
      for (      Class<?> bound : bounds) {
        boundsList.add(new SymbolType(bound));
      }
      result=new SymbolType(boundsList);
    }
    if (lowerBounds != null) {
      result.lowerBounds=new LinkedList<SymbolType>();
      for (      SymbolType st : lowerBounds) {
        result.lowerBounds.add(st.clone());
      }
    }
  }
  return result;
}","@Override public SymbolData merge(SymbolData other){
  SymbolType result=null;
  if (other == null) {
    result=this;
  }
 else {
    if (other.getArrayCount() == getArrayCount()) {
      List<Class<?>> bounds=ClassInspector.getTheNearestSuperClasses(getBoundClasses(),other.getBoundClasses());
      if (bounds.isEmpty()) {
        result=null;
      }
 else       if (bounds.size() == 1) {
        result=new SymbolType(bounds.get(0));
      }
 else {
        List<SymbolType> boundsList=new LinkedList<SymbolType>();
        for (        Class<?> bound : bounds) {
          boundsList.add(new SymbolType(bound));
        }
        result=new SymbolType(boundsList);
      }
      if (result != null) {
        if (lowerBounds != null) {
          result.lowerBounds=new LinkedList<SymbolType>();
          for (          SymbolType st : lowerBounds) {
            result.lowerBounds.add(st.clone());
          }
        }
        result.arrayCount=other.getArrayCount();
      }
    }
 else {
      result=new SymbolType(Object.class);
    }
  }
  return result;
}",0.7917109458023379
91210,"private void addType(String name){
  if (classLoader != null && name != null) {
    try {
      Class<?> clazz=Class.forName(name,false,classLoader);
      if (typeNames.add(name)) {
        typeTable.put(clazz.getSimpleName(),name);
      }
      Class<?>[] innerClasses=clazz.getDeclaredClasses();
      if (innerClasses != null) {
        for (int i=0; i < innerClasses.length; i++) {
          if (typeNames.add(innerClasses[i].getName())) {
            typeTable.put(innerClasses[i].getSimpleName(),innerClasses[i].getName());
          }
        }
      }
    }
 catch (    ClassNotFoundException e) {
      int index=name.lastIndexOf(""String_Node_Str"");
      if (index != -1) {
        name=name.substring(0,index) + ""String_Node_Str"" + name.substring(index + 1);
        try {
          Class<?> clazz=Class.forName(name,false,classLoader);
          if (typeNames.add(name)) {
            typeTable.put(clazz.getSimpleName(),name);
          }
        }
 catch (        ClassNotFoundException e1) {
          throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str"",e);
        }
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str"",e);
      }
    }
  }
}","private void addType(String name){
  if (classLoader != null && name != null) {
    try {
      Class<?> clazz=Class.forName(name,false,classLoader);
      if (typeNames.add(name)) {
        typeTable.put(clazz.getSimpleName(),name);
      }
      Class<?>[] innerClasses=clazz.getDeclaredClasses();
      if (innerClasses != null) {
        for (int i=0; i < innerClasses.length; i++) {
          if (typeNames.add(innerClasses[i].getName())) {
            typeTable.put(innerClasses[i].getSimpleName(),innerClasses[i].getName());
          }
        }
      }
    }
 catch (    ClassNotFoundException e) {
      loadInnerClass(name);
    }
catch (    IncompatibleClassChangeError e2) {
      int index=name.lastIndexOf(""String_Node_Str"");
      if (index != -1) {
        addType(name.substring(0,index));
      }
    }
  }
}",0.7079473427596294
91211,"/** 
 * Called when this app is activated by CicadaService.  onDraw() will be triggered at the conlusion of this method.
 * @param mode the mode that the app is being activated in
 */
public abstract void onActivate(AppType mode);","/** 
 * Called when this app is activated by CicadaService.  onDraw() will be triggered at the conclusion of this method.
 * @param mode the mode that the app is being activated in
 */
public abstract void onActivate(AppType mode);",0.9978308026030368
91212,"private void minimizeToTray(){
  if (!SystemTray.isSupported()) {
    System.out.println(""String_Node_Str"");
    return;
  }
  final PopupMenu popup=new PopupMenu();
  final TrayIcon trayIcon=new TrayIcon(Toolkit.getDefaultToolkit().getImage(""String_Node_Str""),""String_Node_Str"",popup);
  final SystemTray tray=SystemTray.getSystemTray();
  MenuItem showItem=new MenuItem(""String_Node_Str"");
  MenuItem hideItem=new MenuItem(""String_Node_Str"");
  MenuItem exitItem=new MenuItem(""String_Node_Str"");
  showItem.addActionListener(showListener);
  hideItem.addActionListener(hideListener);
  exitItem.addActionListener(exitListener);
  popup.add(showItem);
  popup.addSeparator();
  popup.add(hideItem);
  popup.addSeparator();
  popup.add(exitItem);
  trayIcon.setPopupMenu(popup);
  try {
    tray.add(trayIcon);
  }
 catch (  AWTException ex) {
    System.out.println(ex.toString() + ""String_Node_Str"");
  }
}","private void minimizeToTray(){
  if (!SystemTray.isSupported()) {
    Mediator.getLogger(DaemonManager.class.getName()).log(Level.INFO,""String_Node_Str"");
    return;
  }
  final PopupMenu popup=new PopupMenu();
  final TrayIcon trayIcon=new TrayIcon(Toolkit.getDefaultToolkit().getImage(""String_Node_Str""),""String_Node_Str"",popup);
  final SystemTray tray=SystemTray.getSystemTray();
  MenuItem showItem=new MenuItem(""String_Node_Str"");
  MenuItem hideItem=new MenuItem(""String_Node_Str"");
  MenuItem exitItem=new MenuItem(""String_Node_Str"");
  showItem.addActionListener(showListener);
  hideItem.addActionListener(hideListener);
  exitItem.addActionListener(exitListener);
  popup.add(showItem);
  popup.addSeparator();
  popup.add(hideItem);
  popup.addSeparator();
  popup.add(exitItem);
  trayIcon.setPopupMenu(popup);
  try {
    tray.add(trayIcon);
  }
 catch (  AWTException ex) {
    Mediator.getLogger(DaemonManager.class.getName()).log(Level.INFO,null,ex);
  }
}",0.8916046758767269
91213,"public ShadowResultSet mine(Table table) throws InaccessibleConfigurationFileException, SQLException, DriverNotFoundException {
  ShadowResultSet srs=null;
  try {
    String sql=""String_Node_Str"";
    for (    Column c : table.getColumnList()) {
      sql+=c.getId() + ""String_Node_Str"";
    }
    sql=sql.substring(0,sql.length() - 2);
    sql+=""String_Node_Str"";
    ResultSet rs=statement.executeQuery(sql);
    Mediator.getLogger(ShadowDataMiner.class.getName()).log(Level.FINEST,sql);
    srs=new ShadowResultSet(rs);
  }
  finally {
  }
  return srs;
}","public ShadowResultSet mine(Table table) throws InaccessibleConfigurationFileException, SQLException, DriverNotFoundException {
  ShadowResultSet srs=null;
  try {
    String sql=""String_Node_Str"";
    for (    Column c : table.getColumnList()) {
      sql+=c.getId() + ""String_Node_Str"";
    }
    sql=sql.substring(0,sql.length() - 2);
    sql+=""String_Node_Str"";
    Mediator.getLogger(ShadowDataMiner.class.getName()).log(Level.FINEST,sql);
    ResultSet rs=statement.executeQuery(sql);
    srs=new ShadowResultSet(rs);
  }
  finally {
  }
  return srs;
}",0.9177101967799642
91214,"/** 
 * Gets all the rows from a source table, returned as a ResultSet
 * @param table
 * @return
 * @throws SQLException 
 */
public SourceResultSet mine(Table table) throws SQLException {
  SourceResultSet srs=null;
  try {
    String compositePK=getQueryCustomizer().buildCompositePrimaryKey(table);
    String asciiCompositePK=getQueryCustomizer().buildAsciiCompositePrimaryKey(compositePK);
    String sql=""String_Node_Str"" + asciiCompositePK + ""String_Node_Str""+ compositePK+ ""String_Node_Str"";
    String prefix=getQueryCustomizer().getOpenningSafetyPad();
    String suffix=getQueryCustomizer().getClosingSafetyPad();
    for (    Column column : table.getColumnList()) {
      sql+=""String_Node_Str"" + prefix + column.getName()+ suffix+ ""String_Node_Str""+ column.getId();
    }
    sql+=""String_Node_Str"" + prefix + table.getName()+ suffix+ ""String_Node_Str""+ compositePK+ ""String_Node_Str"";
    ResultSet rs=statement.executeQuery(sql);
    Mediator.getLogger(SourceDataMiner.class.getName()).log(Level.FINEST,sql);
    srs=new SourceResultSet(rs);
  }
  finally {
  }
  return srs;
}","/** 
 * Gets all the rows from a source table, returned as a ResultSet
 * @param table
 * @return
 * @throws SQLException
 */
public SourceResultSet mine(Table table) throws SQLException {
  SourceResultSet srs=null;
  try {
    String compositePK=getQueryCustomizer().buildCompositePrimaryKey(table);
    String asciiCompositePK=getQueryCustomizer().buildAsciiCompositePrimaryKey(compositePK);
    String sql=""String_Node_Str"" + asciiCompositePK + ""String_Node_Str""+ compositePK+ ""String_Node_Str"";
    String prefix=getQueryCustomizer().getOpenningSafetyPad();
    String suffix=getQueryCustomizer().getClosingSafetyPad();
    for (    Column column : table.getColumnList()) {
      sql+=""String_Node_Str"" + prefix + column.getName()+ suffix+ ""String_Node_Str""+ column.getId();
    }
    sql+=""String_Node_Str"" + prefix + table.getName()+ suffix+ ""String_Node_Str""+ compositePK+ ""String_Node_Str"";
    Mediator.getLogger(SourceDataMiner.class.getName()).log(Level.FINEST,sql);
    ResultSet rs=statement.executeQuery(sql);
    srs=new SourceResultSet(rs);
  }
  finally {
  }
  return srs;
}",0.9565614997713764
91215,"public void synchronize() throws InaccessibleConfigurationFileException, DriverNotFoundException, SQLException {
  try {
    List<SchemaTransaction> schemaTransactionList=new SchemaSynchronizer().generate();
    connectToShadow();
    connection.setAutoCommit(false);
    Statement statement=connection.createStatement();
    for (    SchemaTransaction schemaTransaction : schemaTransactionList) {
      Mediator.getLogger(SchemaSynchronizer.class.getName()).log(Level.FINEST,TransactionConverter.convertToSQL(schemaTransaction));
      System.out.println(TransactionConverter.convertToSQL(schemaTransaction));
      if (statement.executeUpdate(TransactionConverter.convertToSQL(schemaTransaction),Statement.RETURN_GENERATED_KEYS) == 1) {
        ResultSet rs=statement.getGeneratedKeys();
        if (rs.next()) {
          if (schemaTransaction.getTarget().getClass() == Database.class) {
            ((Database)schemaTransaction.getTarget()).setId(rs.getInt(1));
          }
 else           if (schemaTransaction.getTarget().getClass() == Table.class) {
            ((Table)schemaTransaction.getTarget()).setId(rs.getInt(1));
          }
 else           if (schemaTransaction.getTarget().getClass() == Column.class) {
            ((Column)schemaTransaction.getTarget()).setId(rs.getInt(1));
          }
        }
      }
    }
    connection.commit();
    statement.close();
  }
  finally {
    disconnectFromShadow();
  }
}","public void synchronize() throws InaccessibleConfigurationFileException, DriverNotFoundException, SQLException {
  try {
    List<SchemaTransaction> schemaTransactionList=new SchemaSynchronizer().generate();
    connectToShadow();
    connection.setAutoCommit(false);
    Statement statement=connection.createStatement();
    for (    SchemaTransaction schemaTransaction : schemaTransactionList) {
      Mediator.getLogger(SchemaSynchronizer.class.getName()).log(Level.FINEST,TransactionConverter.convertToSQL(schemaTransaction));
      if (statement.executeUpdate(TransactionConverter.convertToSQL(schemaTransaction),Statement.RETURN_GENERATED_KEYS) == 1) {
        ResultSet rs=statement.getGeneratedKeys();
        if (rs.next()) {
          if (schemaTransaction.getTarget().getClass() == Database.class) {
            ((Database)schemaTransaction.getTarget()).setId(rs.getInt(1));
          }
 else           if (schemaTransaction.getTarget().getClass() == Table.class) {
            ((Table)schemaTransaction.getTarget()).setId(rs.getInt(1));
          }
 else           if (schemaTransaction.getTarget().getClass() == Column.class) {
            ((Column)schemaTransaction.getTarget()).setId(rs.getInt(1));
          }
        }
      }
    }
    connection.commit();
    statement.close();
  }
  finally {
    disconnectFromShadow();
  }
}",0.9711607786589762
91216,"private void populateTableList(Database db,boolean replicable) throws SQLException {
  Statement statement=connection.createStatement();
  String sql=""String_Node_Str"";
  ResultSet rs=statement.executeQuery(sql);
  Mediator.getLogger(ShadowSchemaMiner.class.getName()).log(Level.FINEST,sql);
  while (rs.next()) {
    Table table=new Table(rs.getInt(""String_Node_Str""),rs.getString(""String_Node_Str""),rs.getString(""String_Node_Str""));
    table.setDatabase(db);
    if (replicable) {
      populateColumnList(table);
    }
 else {
      populateReplicableColumnList(table);
    }
    db.getTableList().add(table);
  }
  rs.close();
  statement.close();
}","private void populateTableList(Database db,boolean replicable) throws SQLException {
  Statement statement=connection.createStatement();
  String sql=""String_Node_Str"" + db.getId() + ""String_Node_Str"";
  Mediator.getLogger(ShadowSchemaMiner.class.getName()).log(Level.FINEST,sql);
  ResultSet rs=statement.executeQuery(sql);
  while (rs.next()) {
    Table table=new Table(rs.getInt(""String_Node_Str""),rs.getString(""String_Node_Str""),rs.getString(""String_Node_Str""));
    table.setDatabase(db);
    if (replicable) {
      populateColumnList(table);
    }
 else {
      populateReplicableColumnList(table);
    }
    db.getTableList().add(table);
  }
  rs.close();
  statement.close();
}",0.9097688292319164
91217,"private Database extractDatabase() throws SQLException {
  Database db=null;
  Statement statement=connection.createStatement();
  String sql=""String_Node_Str"" + database + ""String_Node_Str"";
  ResultSet rs=statement.executeQuery(sql);
  Mediator.getLogger(ShadowSchemaMiner.class.getName()).log(Level.FINEST,sql);
  if (rs.next()) {
    db=new Database(rs.getInt(""String_Node_Str""),rs.getString(""String_Node_Str""));
  }
  rs.close();
  statement.close();
  return db;
}","private Database extractDatabase() throws SQLException {
  Database db=null;
  Statement statement=connection.createStatement();
  String sql=""String_Node_Str"" + database + ""String_Node_Str"";
  Mediator.getLogger(ShadowSchemaMiner.class.getName()).log(Level.FINEST,sql);
  ResultSet rs=statement.executeQuery(sql);
  if (rs.next()) {
    db=new Database(rs.getInt(""String_Node_Str""),rs.getString(""String_Node_Str""));
  }
  rs.close();
  statement.close();
  return db;
}",0.6978723404255319
91218,"private void populateColumnList(Table table) throws SQLException {
  Statement statement=connection.createStatement();
  String sql=""String_Node_Str"";
  ResultSet rs=statement.executeQuery(sql);
  Mediator.getLogger(ShadowSchemaMiner.class.getName()).log(Level.FINEST,sql);
  while (rs.next()) {
    Column column=new Column(rs.getInt(""String_Node_Str""),rs.getString(""String_Node_Str""),rs.getInt(""String_Node_Str""),rs.getString(""String_Node_Str""),rs.getInt(""String_Node_Str""),rs.getBoolean(""String_Node_Str""));
    column.setTable(table);
    table.getColumnList().add(column);
  }
  rs.close();
  statement.close();
}","private void populateColumnList(Table table) throws SQLException {
  Statement statement=connection.createStatement();
  String sql=""String_Node_Str"" + table.getId() + ""String_Node_Str"";
  Mediator.getLogger(ShadowSchemaMiner.class.getName()).log(Level.FINEST,sql);
  ResultSet rs=statement.executeQuery(sql);
  while (rs.next()) {
    Column column=new Column(rs.getInt(""String_Node_Str""),rs.getString(""String_Node_Str""),rs.getInt(""String_Node_Str""),rs.getString(""String_Node_Str""),rs.getInt(""String_Node_Str""),rs.getBoolean(""String_Node_Str""));
    column.setTable(table);
    table.getColumnList().add(column);
  }
  rs.close();
  statement.close();
}",0.9025157232704404
91219,"private void populateReplicableColumnList(Table table) throws SQLException {
  Statement statement=connection.createStatement();
  String sql=""String_Node_Str"" + table.getId() + ""String_Node_Str"";
  ResultSet rs=statement.executeQuery(sql);
  Mediator.getLogger(ShadowSchemaMiner.class.getName()).log(Level.FINEST,sql);
  while (rs.next()) {
    Column cs=new Column(rs.getInt(""String_Node_Str""),rs.getString(""String_Node_Str""),rs.getInt(""String_Node_Str""),rs.getString(""String_Node_Str""),rs.getInt(""String_Node_Str""),rs.getBoolean(""String_Node_Str""));
    cs.setTable(table);
    table.getColumnList().add(cs);
  }
  rs.close();
  statement.close();
}","private void populateReplicableColumnList(Table table) throws SQLException {
  Statement statement=connection.createStatement();
  String sql=""String_Node_Str"" + table.getId() + ""String_Node_Str"";
  Mediator.getLogger(ShadowSchemaMiner.class.getName()).log(Level.FINEST,sql);
  ResultSet rs=statement.executeQuery(sql);
  while (rs.next()) {
    Column cs=new Column(rs.getInt(""String_Node_Str""),rs.getString(""String_Node_Str""),rs.getInt(""String_Node_Str""),rs.getString(""String_Node_Str""),rs.getInt(""String_Node_Str""),rs.getBoolean(""String_Node_Str""));
    cs.setTable(table);
    table.getColumnList().add(cs);
  }
  rs.close();
  statement.close();
}",0.9325153374233128
91220,"@Override public void run(){
  try {
    Date since=null;
    if (lookback > 0) {
      Date now=new Date();
      since=new Date(now.getTime() - lookback);
    }
    List<RecordSource> recordSourceList=new ResourceManager().loadRecordSources();
    if (""String_Node_Str"".equalsIgnoreCase(method)) {
      while (true) {
        work(recordSourceList,since);
        Thread.sleep(interval);
      }
    }
 else {
      DateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
      while (true) {
        String currentTime=dateFormat.format(new Date());
        if (currentTime.equalsIgnoreCase(timeOfDay)) {
          work(recordSourceList,since);
        }
      }
    }
  }
 catch (  InterruptedException ex) {
    Mediator.getLogger(Daemon.class.getName()).log(Level.SEVERE,null,ex);
    System.exit(1);
  }
catch (  BadRecordSourceException ex) {
    Mediator.getLogger(Daemon.class.getName()).log(Level.SEVERE,null,ex);
    System.exit(1);
  }
catch (  ParserConfigurationException ex) {
    Mediator.getLogger(Daemon.class.getName()).log(Level.SEVERE,null,ex);
    System.exit(1);
  }
catch (  SAXException ex) {
    Mediator.getLogger(Daemon.class.getName()).log(Level.SEVERE,null,ex);
    System.exit(1);
  }
catch (  IOException ex) {
    Mediator.getLogger(Daemon.class.getName()).log(Level.SEVERE,null,ex);
    System.exit(1);
  }
catch (  SQLException ex) {
    Mediator.getLogger(Daemon.class.getName()).log(Level.SEVERE,null,ex);
    System.exit(1);
  }
}","@Override public void run(){
  try {
    Date since=null;
    if (lookback > 0) {
      Date now=new Date();
      since=new Date(now.getTime() - lookback);
    }
    List<RecordSource> recordSourceList=new ResourceManager().loadRecordSources();
    if (""String_Node_Str"".equalsIgnoreCase(method)) {
      while (true) {
        work(recordSourceList,since);
        Thread.sleep(interval);
      }
    }
 else {
      DateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
      while (true) {
        String currentTime=dateFormat.format(new Date());
        if (currentTime.equalsIgnoreCase(timeOfDay)) {
          work(recordSourceList,since);
        }
      }
    }
  }
 catch (  InterruptedException ex) {
    Mediator.getLogger(Daemon.class.getName()).log(Level.SEVERE,null,ex);
  }
catch (  BadRecordSourceException ex) {
    Mediator.getLogger(Daemon.class.getName()).log(Level.SEVERE,null,ex);
    System.exit(1);
  }
catch (  ParserConfigurationException ex) {
    Mediator.getLogger(Daemon.class.getName()).log(Level.SEVERE,null,ex);
    System.exit(1);
  }
catch (  SAXException ex) {
    Mediator.getLogger(Daemon.class.getName()).log(Level.SEVERE,null,ex);
    System.exit(1);
  }
catch (  IOException ex) {
    Mediator.getLogger(Daemon.class.getName()).log(Level.SEVERE,null,ex);
  }
catch (  SQLException ex) {
    Mediator.getLogger(Daemon.class.getName()).log(Level.SEVERE,null,ex);
  }
}",0.9792674498963372
91221,"private static void log(Level level,String msg,boolean quit,int exitCode){
  Logger.getLogger(CpadDataExtract.class.getName()).log(level,msg);
  if (quit) {
    System.exit(exitCode);
  }
}","private static void log(Level level,String msg,boolean quit,int exitCode){
  Mediator.getLogger(CpadDataExtract.class.getName()).log(level,msg);
  if (quit) {
    System.exit(exitCode);
  }
}",0.9736842105263158
91222,"public static void work(){
  OutputStreamWriter out=null;
  Connection con=null;
  Connection shadowCon=null;
  Statement stmt=null;
  Statement shadowStmt=null;
  HeaderData header=new HeaderData();
  VisitData visits[]=new VisitData[MAX_VISIT_CNT];
  for (int i=0; i < MAX_VISIT_CNT; i++) {
    visits[i]=new VisitData();
  }
  try {
    Properties sourceProps=loadProperties(""String_Node_Str"");
    Properties shadowProps=loadProperties(""String_Node_Str"");
    out=new OutputStreamWriter(new FileOutputStream(companionProps.getProperty(""String_Node_Str"")),""String_Node_Str"");
    Class.forName(sourceProps.getProperty(""String_Node_Str""));
    con=DriverManager.getConnection(sourceProps.getProperty(""String_Node_Str""));
    stmt=con.createStatement();
    Class.forName(shadowProps.getProperty(""String_Node_Str""));
    shadowCon=DriverManager.getConnection(shadowProps.getProperty(""String_Node_Str""),shadowProps.getProperty(""String_Node_Str""),shadowProps.getProperty(""String_Node_Str""));
    shadowStmt=shadowCon.createStatement();
    String tableList=""String_Node_Str"" + sourceProps.getProperty(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
    if (""String_Node_Str"".equals(tableList) || tableList == null) {
      log(Level.SEVERE,""String_Node_Str"",1);
    }
    java.util.Date now=Calendar.getInstance().getTime();
    String transSince=new SimpleDateFormat(""String_Node_Str"").format(now.getTime() - new Long(companionProps.getProperty(""String_Node_Str"")) * 1000);
    if (""String_Node_Str"".equals(transSince) || transSince == null) {
      log(Level.SEVERE,""String_Node_Str"" + transSince + ""String_Node_Str"",1);
    }
    ResultSet rs=shadowStmt.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + tableList + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ transSince+ ""String_Node_Str"");
    ArrayList<String> shadowPids=new ArrayList<String>();
    while (rs.next()) {
      shadowPids.add(rs.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
    }
    rs=stmt.executeQuery(""String_Node_Str"" + ""String_Node_Str"");
    ArrayList<String> cpadPids=new ArrayList<String>();
    while (rs.next()) {
      cpadPids.add(rs.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
    }
    ArrayList<String> cpadPidsToRemove=new ArrayList<String>();
    for (int i=0; i < cpadPids.size(); i++) {
      if (!shadowPids.contains(cpadPids.get(i))) {
        cpadPidsToRemove.add(cpadPids.get(i));
      }
    }
    cpadPids.removeAll(cpadPidsToRemove);
    int recCnt=cpadPids.size();
    if (recCnt == 0) {
      log(Level.INFO,""String_Node_Str"" + transSince + ""String_Node_Str"",false);
    }
    Logger.getLogger(CpadDataExtract.class.getName()).log(Level.INFO,""String_Node_Str"",new Object[]{recCnt,recCnt == 1 ? ""String_Node_Str"" : ""String_Node_Str""});
    PreparedStatement headerStmts[]=new PreparedStatement[6];
    headerStmts[0]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    headerStmts[1]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    headerStmts[2]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    headerStmts[3]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    headerStmts[4]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    headerStmts[5]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"");
    PreparedStatement visitStmts[]=new PreparedStatement[9];
    visitStmts[0]=con.prepareStatement(""String_Node_Str"");
    visitStmts[1]=con.prepareStatement(""String_Node_Str"" + MAX_VISIT_CNT + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    visitStmts[2]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    visitStmts[3]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    visitStmts[4]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    visitStmts[5]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    visitStmts[6]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    visitStmts[7]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    visitStmts[8]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    int cnt=0;
    for (int a=0; a < cpadPids.size(); a++) {
      int pid=Integer.parseInt(cpadPids.get(a));
      header.reset();
      ExtractHeaderData(headerStmts,pid,header,companionProps);
      for (int i=0; i < MAX_VISIT_CNT; i++) {
        visits[i].reset();
      }
      ExtractVisitData(visitStmts,pid,visits);
      String finalCsv=""String_Node_Str"";
      finalCsv+=header.printHeaderDelim(""String_Node_Str"");
      finalCsv+=""String_Node_Str"";
      for (int i=0; i < FILLER_CNT; i++) {
        finalCsv+=""String_Node_Str"";
      }
      for (int i=0; i < visits.length; i++) {
        finalCsv+=visits[i].printHeaderDelim(""String_Node_Str"");
        if (i < visits.length - 1) {
          finalCsv+=""String_Node_Str"";
        }
      }
      out.write(finalCsv + ""String_Node_Str"");
      if (++cnt % 100 == 0) {
        Logger.getLogger(CpadDataExtract.class.getName()).log(Level.INFO,""String_Node_Str"",cnt);
      }
    }
    if (""String_Node_Str"".equalsIgnoreCase(companionProps.getProperty(""String_Node_Str""))) {
      if (!""String_Node_Str"".equals(companionProps.getProperty(""String_Node_Str"")) && companionProps.getProperty(""String_Node_Str"") != null) {
        if (sendMessage(companionProps.getProperty(""String_Node_Str""),companionProps.getProperty(""String_Node_Str""))) {
          Logger.getLogger(CpadDataExtract.class.getName()).log(Level.INFO,""String_Node_Str"");
        }
 else {
          Logger.getLogger(CpadDataExtract.class.getName()).log(Level.INFO,""String_Node_Str"");
        }
      }
 else {
        Logger.getLogger(CpadDataExtract.class.getName()).log(Level.INFO,""String_Node_Str"");
      }
    }
    Logger.getLogger(CpadDataExtract.class.getName()).log(Level.INFO,""String_Node_Str"");
  }
 catch (  ClassNotFoundException e) {
    System.out.println(e.toString());
  }
catch (  SQLException e) {
    System.out.println(e.toString());
  }
catch (  IOException e) {
    System.out.println(e.toString());
  }
 finally {
    try {
      if (out != null) {
        out.close();
      }
      if (con != null) {
        con.close();
      }
      if (stmt != null) {
        stmt.close();
      }
      if (shadowCon != null) {
        shadowCon.close();
      }
      if (shadowStmt != null) {
        shadowStmt.close();
      }
    }
 catch (    Exception ex) {
      Logger.getLogger(CpadDataExtract.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex.getMessage());
    }
  }
}","public static void work(){
  OutputStreamWriter out=null;
  Connection con=null;
  Connection shadowCon=null;
  Statement stmt=null;
  Statement shadowStmt=null;
  HeaderData header=new HeaderData();
  VisitData visits[]=new VisitData[MAX_VISIT_CNT];
  for (int i=0; i < MAX_VISIT_CNT; i++) {
    visits[i]=new VisitData();
  }
  try {
    Properties sourceProps=loadProperties(""String_Node_Str"");
    Properties shadowProps=loadProperties(""String_Node_Str"");
    out=new OutputStreamWriter(new FileOutputStream(companionProps.getProperty(""String_Node_Str"")),""String_Node_Str"");
    Class.forName(sourceProps.getProperty(""String_Node_Str""));
    con=DriverManager.getConnection(sourceProps.getProperty(""String_Node_Str""));
    stmt=con.createStatement();
    Class.forName(shadowProps.getProperty(""String_Node_Str""));
    shadowCon=DriverManager.getConnection(shadowProps.getProperty(""String_Node_Str""),shadowProps.getProperty(""String_Node_Str""),shadowProps.getProperty(""String_Node_Str""));
    shadowStmt=shadowCon.createStatement();
    String tableList=""String_Node_Str"" + sourceProps.getProperty(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
    if (""String_Node_Str"".equals(tableList) || tableList == null) {
      log(Level.SEVERE,""String_Node_Str"",1);
    }
    java.util.Date now=Calendar.getInstance().getTime();
    String transSince=new SimpleDateFormat(""String_Node_Str"").format(now.getTime() - new Long(companionProps.getProperty(""String_Node_Str"")) * 1000);
    if (""String_Node_Str"".equals(transSince) || transSince == null) {
      log(Level.SEVERE,""String_Node_Str"" + transSince + ""String_Node_Str"",1);
    }
    ResultSet rs=shadowStmt.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + tableList + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ transSince+ ""String_Node_Str"");
    ArrayList<String> shadowPids=new ArrayList<String>();
    while (rs.next()) {
      shadowPids.add(rs.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
    }
    rs=stmt.executeQuery(""String_Node_Str"" + ""String_Node_Str"");
    ArrayList<String> cpadPids=new ArrayList<String>();
    while (rs.next()) {
      cpadPids.add(rs.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
    }
    ArrayList<String> cpadPidsToRemove=new ArrayList<String>();
    for (int i=0; i < cpadPids.size(); i++) {
      if (!shadowPids.contains(cpadPids.get(i))) {
        cpadPidsToRemove.add(cpadPids.get(i));
      }
    }
    cpadPids.removeAll(cpadPidsToRemove);
    int recCnt=cpadPids.size();
    if (recCnt == 0) {
      log(Level.INFO,""String_Node_Str"" + transSince + ""String_Node_Str"",false);
    }
    Mediator.getLogger(CpadDataExtract.class.getName()).log(Level.INFO,""String_Node_Str"",new Object[]{recCnt,recCnt == 1 ? ""String_Node_Str"" : ""String_Node_Str""});
    PreparedStatement headerStmts[]=new PreparedStatement[6];
    headerStmts[0]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    headerStmts[1]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    headerStmts[2]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    headerStmts[3]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    headerStmts[4]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    headerStmts[5]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"");
    PreparedStatement visitStmts[]=new PreparedStatement[9];
    visitStmts[0]=con.prepareStatement(""String_Node_Str"");
    visitStmts[1]=con.prepareStatement(""String_Node_Str"" + MAX_VISIT_CNT + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    visitStmts[2]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    visitStmts[3]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    visitStmts[4]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    visitStmts[5]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    visitStmts[6]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    visitStmts[7]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    visitStmts[8]=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    int cnt=0;
    for (int a=0; a < cpadPids.size(); a++) {
      int pid=Integer.parseInt(cpadPids.get(a));
      header.reset();
      ExtractHeaderData(headerStmts,pid,header,companionProps);
      for (int i=0; i < MAX_VISIT_CNT; i++) {
        visits[i].reset();
      }
      ExtractVisitData(visitStmts,pid,visits);
      String finalCsv=""String_Node_Str"";
      finalCsv+=header.printHeaderDelim(""String_Node_Str"");
      finalCsv+=""String_Node_Str"";
      for (int i=0; i < FILLER_CNT; i++) {
        finalCsv+=""String_Node_Str"";
      }
      for (int i=0; i < visits.length; i++) {
        finalCsv+=visits[i].printHeaderDelim(""String_Node_Str"");
        if (i < visits.length - 1) {
          finalCsv+=""String_Node_Str"";
        }
      }
      out.write(finalCsv + ""String_Node_Str"");
      if (++cnt % 100 == 0) {
        Mediator.getLogger(CpadDataExtract.class.getName()).log(Level.INFO,""String_Node_Str"",cnt);
      }
    }
    if (""String_Node_Str"".equalsIgnoreCase(companionProps.getProperty(""String_Node_Str""))) {
      if (!""String_Node_Str"".equals(companionProps.getProperty(""String_Node_Str"")) && companionProps.getProperty(""String_Node_Str"") != null) {
        if (sendMessage(companionProps.getProperty(""String_Node_Str""),companionProps.getProperty(""String_Node_Str""))) {
          Mediator.getLogger(CpadDataExtract.class.getName()).log(Level.INFO,""String_Node_Str"");
        }
 else {
          Mediator.getLogger(CpadDataExtract.class.getName()).log(Level.INFO,""String_Node_Str"");
        }
      }
 else {
        Mediator.getLogger(CpadDataExtract.class.getName()).log(Level.INFO,""String_Node_Str"");
      }
    }
    Mediator.getLogger(CpadDataExtract.class.getName()).log(Level.INFO,""String_Node_Str"");
  }
 catch (  ClassNotFoundException e) {
    System.out.println(e.toString());
  }
catch (  SQLException e) {
    System.out.println(e.toString());
  }
catch (  IOException e) {
    System.out.println(e.toString());
  }
 finally {
    try {
      if (out != null) {
        out.close();
      }
      if (con != null) {
        con.close();
      }
      if (stmt != null) {
        stmt.close();
      }
      if (shadowCon != null) {
        shadowCon.close();
      }
      if (shadowStmt != null) {
        shadowStmt.close();
      }
    }
 catch (    Exception ex) {
      Mediator.getLogger(CpadDataExtract.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex.getMessage());
    }
  }
}",0.994614694191563
91223,"private static boolean sendMessage(String url,String filename){
  int returnStatus=HttpStatus.SC_CREATED;
  HttpClient httpclient=new HttpClient();
  HttpConnectionManager connectionManager=httpclient.getHttpConnectionManager();
  connectionManager.getParams().setSoTimeout(120000);
  PostMethod httpPost=new PostMethod(url);
  RequestEntity requestEntity=null;
  try {
    FileInputStream message=new FileInputStream(filename);
    Base64InputStream message64=new Base64InputStream(message,true,-1,null);
    requestEntity=new InputStreamRequestEntity(message64,""String_Node_Str"");
  }
 catch (  FileNotFoundException e) {
    Logger.getLogger(CpadDataExtract.class.getName()).log(Level.SEVERE,""String_Node_Str"",e);
  }
  httpPost.setRequestEntity(requestEntity);
  try {
    httpclient.executeMethod(httpPost);
    returnStatus=httpPost.getStatusCode();
  }
 catch (  SocketTimeoutException e) {
    returnStatus=HttpStatus.SC_REQUEST_TIMEOUT;
    Logger.getLogger(CpadDataExtract.class.getName()).log(Level.SEVERE,""String_Node_Str"",e);
  }
catch (  HttpException e) {
    returnStatus=HttpStatus.SC_INTERNAL_SERVER_ERROR;
    Logger.getLogger(CpadDataExtract.class.getName()).log(Level.SEVERE,""String_Node_Str"",e);
  }
catch (  ConnectException e) {
    returnStatus=HttpStatus.SC_SERVICE_UNAVAILABLE;
    Logger.getLogger(CpadDataExtract.class.getName()).log(Level.SEVERE,""String_Node_Str"",e);
  }
catch (  UnknownHostException e) {
    returnStatus=HttpStatus.SC_NOT_FOUND;
    Logger.getLogger(CpadDataExtract.class.getName()).log(Level.SEVERE,""String_Node_Str"",e);
  }
catch (  IOException e) {
    returnStatus=HttpStatus.SC_GATEWAY_TIMEOUT;
    Logger.getLogger(CpadDataExtract.class.getName()).log(Level.SEVERE,""String_Node_Str"",e);
  }
 finally {
    httpPost.releaseConnection();
  }
  return returnStatus == HttpStatus.SC_OK;
}","private static boolean sendMessage(String url,String filename){
  int returnStatus=HttpStatus.SC_CREATED;
  HttpClient httpclient=new HttpClient();
  HttpConnectionManager connectionManager=httpclient.getHttpConnectionManager();
  connectionManager.getParams().setSoTimeout(120000);
  PostMethod httpPost=new PostMethod(url);
  RequestEntity requestEntity=null;
  try {
    FileInputStream message=new FileInputStream(filename);
    Base64InputStream message64=new Base64InputStream(message,true,-1,null);
    requestEntity=new InputStreamRequestEntity(message64,""String_Node_Str"");
  }
 catch (  FileNotFoundException e) {
    Mediator.getLogger(CpadDataExtract.class.getName()).log(Level.SEVERE,""String_Node_Str"",e);
  }
  httpPost.setRequestEntity(requestEntity);
  try {
    httpclient.executeMethod(httpPost);
    returnStatus=httpPost.getStatusCode();
  }
 catch (  SocketTimeoutException e) {
    returnStatus=HttpStatus.SC_REQUEST_TIMEOUT;
    Mediator.getLogger(CpadDataExtract.class.getName()).log(Level.SEVERE,""String_Node_Str"",e);
  }
catch (  HttpException e) {
    returnStatus=HttpStatus.SC_INTERNAL_SERVER_ERROR;
    Mediator.getLogger(CpadDataExtract.class.getName()).log(Level.SEVERE,""String_Node_Str"",e);
  }
catch (  ConnectException e) {
    returnStatus=HttpStatus.SC_SERVICE_UNAVAILABLE;
    Mediator.getLogger(CpadDataExtract.class.getName()).log(Level.SEVERE,""String_Node_Str"",e);
  }
catch (  UnknownHostException e) {
    returnStatus=HttpStatus.SC_NOT_FOUND;
    Mediator.getLogger(CpadDataExtract.class.getName()).log(Level.SEVERE,""String_Node_Str"",e);
  }
catch (  IOException e) {
    returnStatus=HttpStatus.SC_GATEWAY_TIMEOUT;
    Mediator.getLogger(CpadDataExtract.class.getName()).log(Level.SEVERE,""String_Node_Str"",e);
  }
 finally {
    httpPost.releaseConnection();
  }
  return returnStatus == HttpStatus.SC_OK;
}",0.980498374864572
91224,"public static void main(String[] args){
  try {
    companionProps=loadProperties(""String_Node_Str"");
    String method=companionProps.getProperty(""String_Node_Str"");
    int interval=Integer.parseInt(companionProps.getProperty(""String_Node_Str""));
    String timeOfDay=companionProps.getProperty(""String_Node_Str"");
    if (""String_Node_Str"".equalsIgnoreCase(""String_Node_Str"")) {
      while (true) {
        CpadDataExtract.work();
        Thread.sleep(interval);
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(""String_Node_Str"")) {
      DateFormat sdf=new SimpleDateFormat(""String_Node_Str"");
      String currentTime=sdf.format(new java.util.Date());
      while (true) {
        if (currentTime.equalsIgnoreCase(timeOfDay)) {
          CpadDataExtract.work();
        }
      }
    }
 else {
      log(Level.SEVERE,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",1);
    }
  }
 catch (  InterruptedException ex) {
    Logger.getLogger(CpadDataExtract.class.getName()).log(Level.SEVERE,null,ex);
  }
catch (  FileNotFoundException ex) {
    Logger.getLogger(CpadDataExtract.class.getName()).log(Level.SEVERE,null,ex);
  }
}","public static void main(String[] args){
  try {
    new Mediator();
    companionProps=loadProperties(""String_Node_Str"");
    String method=companionProps.getProperty(""String_Node_Str"");
    int interval=Integer.parseInt(companionProps.getProperty(""String_Node_Str""));
    String timeOfDay=companionProps.getProperty(""String_Node_Str"");
    if (""String_Node_Str"".equalsIgnoreCase(method)) {
      while (true) {
        CpadDataExtract.work();
        Thread.sleep(interval);
      }
    }
 else {
      DateFormat sdf=new SimpleDateFormat(""String_Node_Str"");
      String currentTime=sdf.format(new java.util.Date());
      while (true) {
        if (currentTime.equalsIgnoreCase(timeOfDay)) {
          CpadDataExtract.work();
        }
      }
    }
  }
 catch (  InterruptedException ex) {
    Mediator.getLogger(CpadDataExtract.class.getName()).log(Level.SEVERE,null,ex);
  }
catch (  FileNotFoundException ex) {
    Mediator.getLogger(CpadDataExtract.class.getName()).log(Level.SEVERE,null,ex);
  }
}",0.7006015733456733
91225,"private static Properties loadProperties(String propertiesFile) throws FileNotFoundException {
  try {
    Properties properties=new Properties();
    File propFile=new File(propertiesFile);
    String propFilePath=propFile.getAbsolutePath();
    FileInputStream fis=new FileInputStream(propFilePath);
    properties.load(fis);
    return properties;
  }
 catch (  IOException ex) {
    Logger.getLogger(CpadDataExtract.class.getName()).log(Level.SEVERE,""String_Node_Str"" + propertiesFile,ex);
    throw new FileNotFoundException(""String_Node_Str"" + propertiesFile);
  }
}","private static Properties loadProperties(String propertiesFile) throws FileNotFoundException {
  try {
    Properties properties=new Properties();
    File propFile=new File(propertiesFile);
    String propFilePath=propFile.getAbsolutePath();
    FileInputStream fis=new FileInputStream(propFilePath);
    properties.load(fis);
    return properties;
  }
 catch (  IOException ex) {
    Mediator.getLogger(CpadDataExtract.class.getName()).log(Level.SEVERE,""String_Node_Str"" + propertiesFile,ex);
    throw new FileNotFoundException(""String_Node_Str"" + propertiesFile);
  }
}",0.9895287958115184
91226,"/** 
 * Reset hard from unclean condition. <p> WorkDir: Empty <br/> Index: f/g <br/> Merge: x
 * @throws Exception
 */
@Test public void testResetHardFromIndexEntryWithoutFileToTreeWithoutFile() throws Exception {
  ChangeRecorder recorder=new ChangeRecorder();
  ListenerHandle handle=null;
  try (Git git=new Git(db)){
    handle=db.getListenerList().addWorkingTreeModifiedListener(recorder);
    writeTrashFile(""String_Node_Str"",""String_Node_Str"");
    git.add().addFilepattern(""String_Node_Str"").call();
    RevCommit id1=git.commit().setMessage(""String_Node_Str"").call();
    writeTrashFile(""String_Node_Str"",""String_Node_Str"");
    git.rm().addFilepattern(""String_Node_Str"").call();
    recorder.assertEvent(ChangeRecorder.EMPTY,new String[]{""String_Node_Str""});
    git.add().addFilepattern(""String_Node_Str"").call();
    git.commit().setMessage(""String_Node_Str"").call();
    deleteTrashFile(""String_Node_Str"");
    deleteTrashFile(""String_Node_Str"");
    git.reset().setMode(ResetType.HARD).setRef(id1.getName()).call();
    assertIndex(mkmap(""String_Node_Str"",""String_Node_Str""));
    recorder.assertEvent(new String[]{""String_Node_Str""},ChangeRecorder.EMPTY);
  }
  finally {
    if (handle != null) {
      handle.remove();
    }
  }
}","/** 
 * Reset hard from unclean condition. <p> WorkDir: Empty <br> Index: f/g <br> Merge: x
 * @throws Exception
 */
@Test public void testResetHardFromIndexEntryWithoutFileToTreeWithoutFile() throws Exception {
  ChangeRecorder recorder=new ChangeRecorder();
  ListenerHandle handle=null;
  try (Git git=new Git(db)){
    handle=db.getListenerList().addWorkingTreeModifiedListener(recorder);
    writeTrashFile(""String_Node_Str"",""String_Node_Str"");
    git.add().addFilepattern(""String_Node_Str"").call();
    RevCommit id1=git.commit().setMessage(""String_Node_Str"").call();
    writeTrashFile(""String_Node_Str"",""String_Node_Str"");
    git.rm().addFilepattern(""String_Node_Str"").call();
    recorder.assertEvent(ChangeRecorder.EMPTY,new String[]{""String_Node_Str""});
    git.add().addFilepattern(""String_Node_Str"").call();
    git.commit().setMessage(""String_Node_Str"").call();
    deleteTrashFile(""String_Node_Str"");
    deleteTrashFile(""String_Node_Str"");
    git.reset().setMode(ResetType.HARD).setRef(id1.getName()).call();
    assertIndex(mkmap(""String_Node_Str"",""String_Node_Str""));
    recorder.assertEvent(new String[]{""String_Node_Str""},ChangeRecorder.EMPTY);
  }
  finally {
    if (handle != null) {
      handle.remove();
    }
  }
}",0.9991974317817014
91227,"/** 
 * Assert which renames should have happened, in traversal order.
 * @param expectedRenames the rename specs, each one in the form ""srcPath->destPath""
 */
protected void assertRenames(String... expectedRenames){
  Assert.assertEquals(""String_Node_Str"" + expectedRenames.length + ""String_Node_Str""+ diffCollector.diffs.size(),expectedRenames.length,diffCollector.diffs.size());
  for (int i=0; i < expectedRenames.length; i++) {
    DiffEntry diff=diffCollector.diffs.get(i);
    Assert.assertNotNull(diff);
    String[] split=expectedRenames[i].split(""String_Node_Str"");
    Assert.assertNotNull(split);
    Assert.assertEquals(2,split.length);
    String src=split[0];
    String target=split[1];
    Assert.assertEquals(src,diff.getOldPath());
    Assert.assertEquals(target,diff.getNewPath());
  }
}","/** 
 * Assert which renames should have happened, in traversal order.
 * @param expectedRenames the rename specs, each one in the form ""srcPath-&gt;destPath""
 */
protected void assertRenames(String... expectedRenames){
  Assert.assertEquals(""String_Node_Str"" + expectedRenames.length + ""String_Node_Str""+ diffCollector.diffs.size(),expectedRenames.length,diffCollector.diffs.size());
  for (int i=0; i < expectedRenames.length; i++) {
    DiffEntry diff=diffCollector.diffs.get(i);
    Assert.assertNotNull(diff);
    String[] split=expectedRenames[i].split(""String_Node_Str"");
    Assert.assertNotNull(split);
    Assert.assertEquals(2,split.length);
    String src=split[0];
    String target=split[1];
    Assert.assertEquals(src,diff.getOldPath());
    Assert.assertEquals(target,diff.getNewPath());
  }
}",0.9969078540507113
91228,"/** 
 * Steps: 1.Add file 'b' 2.Commit 3.Create branch '1' 4.Add symlink 'a' 5.Commit 6.Checkout branch '1' The working tree should not contain 'a' -> FileMode.MISSING after the checkout.
 * @throws Exception
 */
@Test public void fileModeTestMissingThenSymlink() throws Exception {
  try (Git git=new Git(db);TreeWalk tw=new TreeWalk(db)){
    writeTrashFile(""String_Node_Str"",""String_Node_Str"");
    git.add().addFilepattern(""String_Node_Str"").call();
    RevCommit commit1=git.commit().setMessage(""String_Node_Str"").call();
    Ref branch_1=git.branchCreate().setName(""String_Node_Str"").call();
    FileUtils.createSymLink(new File(db.getWorkTree(),""String_Node_Str""),""String_Node_Str"");
    git.add().addFilepattern(""String_Node_Str"").call();
    RevCommit commit2=git.commit().setMessage(""String_Node_Str"").call();
    git.checkout().setName(branch_1.getName()).call();
    tw.addTree(commit1.getTree());
    tw.addTree(commit2.getTree());
    List<DiffEntry> scan=DiffEntry.scan(tw);
    assertEquals(1,scan.size());
    assertEquals(FileMode.SYMLINK,scan.get(0).getNewMode());
    assertEquals(FileMode.MISSING,scan.get(0).getOldMode());
  }
 }","/** 
 * Steps: 1.Add file 'b' 2.Commit 3.Create branch '1' 4.Add symlink 'a' 5.Commit 6.Checkout branch '1' The working tree should not contain 'a' -&gt; FileMode.MISSING after the checkout.
 * @throws Exception
 */
@Test public void fileModeTestMissingThenSymlink() throws Exception {
  try (Git git=new Git(db);TreeWalk tw=new TreeWalk(db)){
    writeTrashFile(""String_Node_Str"",""String_Node_Str"");
    git.add().addFilepattern(""String_Node_Str"").call();
    RevCommit commit1=git.commit().setMessage(""String_Node_Str"").call();
    Ref branch_1=git.branchCreate().setName(""String_Node_Str"").call();
    FileUtils.createSymLink(new File(db.getWorkTree(),""String_Node_Str""),""String_Node_Str"");
    git.add().addFilepattern(""String_Node_Str"").call();
    RevCommit commit2=git.commit().setMessage(""String_Node_Str"").call();
    git.checkout().setName(branch_1.getName()).call();
    tw.addTree(commit1.getTree());
    tw.addTree(commit2.getTree());
    List<DiffEntry> scan=DiffEntry.scan(tw);
    assertEquals(1,scan.size());
    assertEquals(FileMode.SYMLINK,scan.get(0).getNewMode());
    assertEquals(FileMode.MISSING,scan.get(0).getOldMode());
  }
 }",0.9978308026030368
91229,"/** 
 * Get <code>RefSpec</code>s. </p>
 * @return the ref specs
 */
public List<RefSpec> getRefSpecs(){
  return refSpecs;
}","/** 
 * Get   {@code RefSpec}s.
 * @return the ref specs
 */
public List<RefSpec> getRefSpecs(){
  return refSpecs;
}",0.9173553719008264
91230,"/** 
 * Get time to live for garbage packs.
 * @return garbage packs older than this limit (in milliseconds) will bepruned as part of the garbage collection process if the value is > 0, otherwise garbage packs are retained.
 */
public long getGarbageTtlMillis(){
  return garbageTtlMillis;
}","/** 
 * Get time to live for garbage packs.
 * @return garbage packs older than this limit (in milliseconds) will bepruned as part of the garbage collection process if the value is &gt; 0, otherwise garbage packs are retained.
 */
public long getGarbageTtlMillis(){
  return garbageTtlMillis;
}",0.9914529914529916
91231,"/** 
 * Set the   {@code gc --auto} option.With this option, gc checks whether any housekeeping is required; if not, it exits without performing any work. Some JGit commands run {@code gc --auto} after performing operations that could create manyloose objects. <p/> Housekeeping is required if there are too many loose objects or too many packs in the repository. If the number of loose objects exceeds the value of the gc.auto option JGit GC consolidates all existing packs into a single pack (equivalent to  {@code -A} option), whereas git-core wouldcombine all loose objects into a single pack using  {@code repack -d -l}. Setting the value of   {@code gc.auto} to 0 disables automatic packing ofloose objects. <p/> If the number of packs exceeds the value of  {@code gc.autoPackLimit}, then existing packs (except those marked with a .keep file) are consolidated into a single pack by using the   {@code -A} option of repack.Setting  {@code gc.autoPackLimit} to 0 disables automatic consolidation ofpacks. <p/> Like git the following jgit commands run auto gc: <ul> <li>fetch</li> <li>merge</li> <li>rebase</li> <li>receive-pack</li> </ul> The auto gc for receive-pack can be suppressed by setting the config option  {@code receive.autogc = false}
 * @param auto defines whether gc should do automatic housekeeping
 */
public void setAuto(boolean auto){
  this.automatic=auto;
}","/** 
 * Set the   {@code gc --auto} option.With this option, gc checks whether any housekeeping is required; if not, it exits without performing any work. Some JGit commands run {@code gc --auto} after performing operations that could create manyloose objects. <p> Housekeeping is required if there are too many loose objects or too many packs in the repository. If the number of loose objects exceeds the value of the gc.auto option JGit GC consolidates all existing packs into a single pack (equivalent to  {@code -A} option), whereas git-core wouldcombine all loose objects into a single pack using  {@code repack -d -l}. Setting the value of   {@code gc.auto} to 0 disables automatic packing ofloose objects. <p> If the number of packs exceeds the value of  {@code gc.autoPackLimit}, then existing packs (except those marked with a .keep file) are consolidated into a single pack by using the   {@code -A} option of repack.Setting  {@code gc.autoPackLimit} to 0 disables automatic consolidation ofpacks. <p> Like git the following jgit commands run auto gc: <ul> <li>fetch</li> <li>merge</li> <li>rebase</li> <li>receive-pack</li> </ul> The auto gc for receive-pack can be suppressed by setting the config option  {@code receive.autogc = false}
 * @param auto defines whether gc should do automatic housekeeping
 */
public void setAuto(boolean auto){
  this.automatic=auto;
}",0.9989134371604492
91232,"/** 
 * Get the remote this branch is configured to fetch from/push to>
 * @return the remote this branch is configured to fetch from/push to, or{@code null} if not defined
 * @since 3.5
 */
public String getRemote(){
  return config.getString(ConfigConstants.CONFIG_BRANCH_SECTION,branchName,ConfigConstants.CONFIG_KEY_REMOTE);
}","/** 
 * Get the remote this branch is configured to fetch from/push to
 * @return the remote this branch is configured to fetch from/push to, or{@code null} if not defined
 * @since 3.5
 */
public String getRemote(){
  return config.getString(ConfigConstants.CONFIG_BRANCH_SECTION,branchName,ConfigConstants.CONFIG_KEY_REMOTE);
}",0.9984825493171472
91233,"/** 
 * Normalizes the passed branch name into a possible valid branch name. The validity of the returned name should be checked by a subsequent call to  {@link #isValidRefName(String)}. <p/> Future implementations of this method could be more restrictive or more lenient about the validity of specific characters in the returned name. <p/> The current implementation returns the trimmed input string if this is already a valid branch name. Otherwise it returns a trimmed string with special characters not allowed by   {@link #isValidRefName(String)}replaced by hyphens ('-') and blanks replaced by underscores ('_'). Leading and trailing slashes, dots, hyphens, and underscores are removed.
 * @param name to normalize
 * @return The normalized name or an empty String if it is {@code null} orempty.
 * @since 4.7
 * @see #isValidRefName(String)
 */
public static String normalizeBranchName(String name){
  if (name == null || name.isEmpty()) {
    return ""String_Node_Str"";
  }
  String result=name.trim();
  String fullName=result.startsWith(Constants.R_HEADS) ? result : Constants.R_HEADS + result;
  if (isValidRefName(fullName)) {
    return result;
  }
  result=result.replaceAll(""String_Node_Str"",""String_Node_Str"");
  StringBuilder b=new StringBuilder();
  char p='/';
  for (int i=0, len=result.length(); i < len; i++) {
    char c=result.charAt(i);
    if (c < ' ' || c == 127) {
      continue;
    }
switch (c) {
case '\\':
case '^':
case '~':
case ':':
case '?':
case '*':
case '[':
case '@':
case '<':
case '>':
case '|':
case '""':
      c='-';
    break;
default :
  break;
}
switch (c) {
case '/':
if (p == '/') {
  continue;
}
p='/';
break;
case '.':
case '_':
case '-':
if (p == '/' || p == '-') {
continue;
}
p='-';
break;
default :
p=c;
break;
}
b.append(c);
}
result=b.toString().replaceFirst(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
return FORBIDDEN_BRANCH_NAME_COMPONENTS.matcher(result).replaceAll(""String_Node_Str"");
}","/** 
 * Normalizes the passed branch name into a possible valid branch name. The validity of the returned name should be checked by a subsequent call to  {@link #isValidRefName(String)}. <p> Future implementations of this method could be more restrictive or more lenient about the validity of specific characters in the returned name. <p> The current implementation returns the trimmed input string if this is already a valid branch name. Otherwise it returns a trimmed string with special characters not allowed by   {@link #isValidRefName(String)}replaced by hyphens ('-') and blanks replaced by underscores ('_'). Leading and trailing slashes, dots, hyphens, and underscores are removed.
 * @param name to normalize
 * @return The normalized name or an empty String if it is {@code null} orempty.
 * @since 4.7
 * @see #isValidRefName(String)
 */
public static String normalizeBranchName(String name){
  if (name == null || name.isEmpty()) {
    return ""String_Node_Str"";
  }
  String result=name.trim();
  String fullName=result.startsWith(Constants.R_HEADS) ? result : Constants.R_HEADS + result;
  if (isValidRefName(fullName)) {
    return result;
  }
  result=result.replaceAll(""String_Node_Str"",""String_Node_Str"");
  StringBuilder b=new StringBuilder();
  char p='/';
  for (int i=0, len=result.length(); i < len; i++) {
    char c=result.charAt(i);
    if (c < ' ' || c == 127) {
      continue;
    }
switch (c) {
case '\\':
case '^':
case '~':
case ':':
case '?':
case '*':
case '[':
case '@':
case '<':
case '>':
case '|':
case '""':
      c='-';
    break;
default :
  break;
}
switch (c) {
case '/':
if (p == '/') {
  continue;
}
p='/';
break;
case '.':
case '_':
case '-':
if (p == '/' || p == '-') {
continue;
}
p='-';
break;
default :
p=c;
break;
}
b.append(c);
}
result=b.toString().replaceFirst(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
return FORBIDDEN_BRANCH_NAME_COMPONENTS.matcher(result).replaceAll(""String_Node_Str"");
}",0.9994972347913524
91234,"/** 
 * Check whether any housekeeping is required; if yes, run garbage collection; if not, exit without performing any work. Some JGit commands run autoGC after performing operations that could create many loose objects. <p/> Currently this option is supported for repositories of type  {@code FileRepository} only. See{@link org.eclipse.jgit.internal.storage.file.GC#setAuto(boolean)} forconfiguration details.
 * @param monitor to report progress
 * @since 4.6
 */
public void autoGC(ProgressMonitor monitor){
}","/** 
 * Check whether any housekeeping is required; if yes, run garbage collection; if not, exit without performing any work. Some JGit commands run autoGC after performing operations that could create many loose objects. <p> Currently this option is supported for repositories of type  {@code FileRepository} only. See{@link org.eclipse.jgit.internal.storage.file.GC#setAuto(boolean)} forconfiguration details.
 * @param monitor to report progress
 * @since 4.6
 */
public void autoGC(ProgressMonitor monitor){
}",0.9990262901655308
91235,"/** 
 * <Get the URI as an ASCII string.
 * @return the URI as an ASCII string. Password is not included.
 */
public String toASCIIString(){
  return format(false,true);
}","/** 
 * Get the URI as an ASCII string.
 * @return the URI as an ASCII string. Password is not included.
 */
public String toASCIIString(){
  return format(false,true);
}",0.997067448680352
91236,"/** 
 * {@inheritDoc}<p> Retrieve the git attributes for the current entry. <h4>Git attribute computation</h4> <ul> <li>Get the attributes matching the current path entry from the info file (see   {@link AttributesNodeProvider#getInfoAttributesNode()}).</li> <li>Completes the list of attributes using the .gitattributes files located on the current path (the further the directory that contains .gitattributes is from the path in question, the lower its precedence). For a checkin operation, it will look first on the working tree (if any). If there is no attributes file, it will fallback on the index. For a checkout operation, it will first use the index entry and then fallback on the working tree if none.</li> <li>In the end, completes the list of matching attributes using the global attribute file define in the configuration (see  {@link AttributesNodeProvider#getGlobalAttributesNode()})</li> </ul> <h4>Iterator constraints</h4> <p> In order to have a correct list of attributes for the current entry, this  {@link TreeWalk} requires to have at least one{@link AttributesNodeProvider} and a {@link DirCacheIterator} set up. An{@link AttributesNodeProvider} is used to retrieve the attributes fromthe info attributes file and the global attributes file. The {@link DirCacheIterator} is used to retrieve the .gitattributes filesstored in the index. A  {@link WorkingTreeIterator} can also be providedto access the local version of the .gitattributes files. If none is provided it will fallback on the  {@link DirCacheIterator}. </p>
 * @since 4.2
 */
@Override public Attributes getAttributes(){
  if (attrs != null)   return attrs;
  if (attributesNodeProvider == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  try {
    if (attributesHandler == null) {
      attributesHandler=new AttributesHandler(this);
    }
    attrs=attributesHandler.getAttributes();
    return attrs;
  }
 catch (  IOException e) {
    throw new JGitInternalException(""String_Node_Str"",e);
  }
}","/** 
 * {@inheritDoc}<p> Retrieve the git attributes for the current entry. <h3>Git attribute computation</h3> <ul> <li>Get the attributes matching the current path entry from the info file (see   {@link AttributesNodeProvider#getInfoAttributesNode()}).</li> <li>Completes the list of attributes using the .gitattributes files located on the current path (the further the directory that contains .gitattributes is from the path in question, the lower its precedence). For a checkin operation, it will look first on the working tree (if any). If there is no attributes file, it will fallback on the index. For a checkout operation, it will first use the index entry and then fallback on the working tree if none.</li> <li>In the end, completes the list of matching attributes using the global attribute file define in the configuration (see  {@link AttributesNodeProvider#getGlobalAttributesNode()})</li> </ul> <h3>Iterator constraints</h3> <p> In order to have a correct list of attributes for the current entry, this  {@link TreeWalk} requires to have at least one{@link AttributesNodeProvider} and a {@link DirCacheIterator} set up. An{@link AttributesNodeProvider} is used to retrieve the attributes fromthe info attributes file and the global attributes file. The {@link DirCacheIterator} is used to retrieve the .gitattributes filesstored in the index. A  {@link WorkingTreeIterator} can also be providedto access the local version of the .gitattributes files. If none is provided it will fallback on the  {@link DirCacheIterator}. </p>
 * @since 4.2
 */
@Override public Attributes getAttributes(){
  if (attrs != null)   return attrs;
  if (attributesNodeProvider == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  try {
    if (attributesHandler == null) {
      attributesHandler=new AttributesHandler(this);
    }
    attrs=attributesHandler.getAttributes();
    return attrs;
  }
 catch (  IOException e) {
    throw new JGitInternalException(""String_Node_Str"",e);
  }
}",0.99800299550674
91237,"/** 
 * Expresses <code>other</code> as a relative file path from <code>base</code> <p> For example, if called with the two following paths : <pre> <code>base = ""c:\\Users\\jdoe\\eclipse\\git\\project""</code> <code>other = ""c:\\Users\\jdoe\\eclipse\\git\\another_project\\pom.xml""</code> </pre> This will return ""..\\another_project\\pom.xml"". </p> <p> <b>Note</b> that this will return the empty String if <code>base</code> and <code>other</code> are equal. </p>
 * @param base The path against which <code>other</code> should be relativized. This will be assumed to denote the path to a folder and not a file.
 * @param other The path that will be made relative to <code>base</code>.
 * @param dirSeparator A string that separates components of the path. In practice, this is ""/"" or ""\\"".
 * @param caseSensitive Whether to consider differently-cased directory names as distinct
 * @return A relative path that, when resolved against <code>base</code>,will yield the original <code>other</code>.
 * @since 4.8
 */
public static String relativizePath(String base,String other,String dirSeparator,boolean caseSensitive){
  if (base.equals(other))   return ""String_Node_Str"";
  final String[] baseSegments=base.split(Pattern.quote(dirSeparator));
  final String[] otherSegments=other.split(Pattern.quote(dirSeparator));
  int commonPrefix=0;
  while (commonPrefix < baseSegments.length && commonPrefix < otherSegments.length) {
    if (caseSensitive && baseSegments[commonPrefix].equals(otherSegments[commonPrefix]))     commonPrefix++;
 else     if (!caseSensitive && baseSegments[commonPrefix].equalsIgnoreCase(otherSegments[commonPrefix]))     commonPrefix++;
 else     break;
  }
  final StringBuilder builder=new StringBuilder();
  for (int i=commonPrefix; i < baseSegments.length; i++)   builder.append(""String_Node_Str"").append(dirSeparator);
  for (int i=commonPrefix; i < otherSegments.length; i++) {
    builder.append(otherSegments[i]);
    if (i < otherSegments.length - 1)     builder.append(dirSeparator);
  }
  return builder.toString();
}","/** 
 * Expresses <code>other</code> as a relative file path from <code>base</code> <p> For example, if called with the two following paths : <pre> <code>base = ""c:\\Users\\jdoe\\eclipse\\git\\project""</code> <code>other = ""c:\\Users\\jdoe\\eclipse\\git\\another_project\\pom.xml""</code> </pre> This will return ""..\\another_project\\pom.xml"". <p> <b>Note</b> that this will return the empty String if <code>base</code> and <code>other</code> are equal. </p>
 * @param base The path against which <code>other</code> should be relativized. This will be assumed to denote the path to a folder and not a file.
 * @param other The path that will be made relative to <code>base</code>.
 * @param dirSeparator A string that separates components of the path. In practice, this is ""/"" or ""\\"".
 * @param caseSensitive Whether to consider differently-cased directory names as distinct
 * @return A relative path that, when resolved against <code>base</code>,will yield the original <code>other</code>.
 * @since 4.8
 */
public static String relativizePath(String base,String other,String dirSeparator,boolean caseSensitive){
  if (base.equals(other))   return ""String_Node_Str"";
  final String[] baseSegments=base.split(Pattern.quote(dirSeparator));
  final String[] otherSegments=other.split(Pattern.quote(dirSeparator));
  int commonPrefix=0;
  while (commonPrefix < baseSegments.length && commonPrefix < otherSegments.length) {
    if (caseSensitive && baseSegments[commonPrefix].equals(otherSegments[commonPrefix]))     commonPrefix++;
 else     if (!caseSensitive && baseSegments[commonPrefix].equalsIgnoreCase(otherSegments[commonPrefix]))     commonPrefix++;
 else     break;
  }
  final StringBuilder builder=new StringBuilder();
  for (int i=commonPrefix; i < baseSegments.length; i++)   builder.append(""String_Node_Str"").append(dirSeparator);
  for (int i=commonPrefix; i < otherSegments.length; i++) {
    builder.append(otherSegments[i]);
    if (i < otherSegments.length - 1)     builder.append(dirSeparator);
  }
  return builder.toString();
}",0.9987807851743478
91238,"/** 
 * @return the matching candidates (or at least a subset of them). 
 */
public Collection<ObjectId> getCandidates(){
  return candidates;
}","/** 
 * Get the matching candidates (or at least a subset of them)
 * @return the matching candidates (or at least a subset of them)
 */
public Collection<ObjectId> getCandidates(){
  return candidates;
}",0.8160919540229885
91239,"/** 
 * @return the AbbreviatedObjectId that has more than one result. 
 */
public AbbreviatedObjectId getAbbreviatedObjectId(){
  return missing;
}","/** 
 * Get the   {@code AbbreviatedObjectId} that has more than one result
 * @return the {@code AbbreviatedObjectId} that has more than one result
 */
public AbbreviatedObjectId getAbbreviatedObjectId(){
  return missing;
}",0.6219839142091153
91240,"/** 
 * @param message
 */
public CancelledException(String message){
  super(message);
}","/** 
 * Constructor for CancelledException
 * @param message error message
 */
public CancelledException(String message){
  super(message);
}",0.7739130434782608
91241,"/** 
 * @return the relative paths of the conflicting files (relative to theworking directory root).
 * @since 4.4
 */
public String[] getConflictingFiles(){
  return conflicting;
}","/** 
 * Get the relative paths of the conflicting files
 * @return the relative paths of the conflicting files (relative to theworking directory root).
 * @since 4.4
 */
public String[] getConflictingFiles(){
  return conflicting;
}",0.8765133171912833
91242,"/** 
 * Construct a CheckoutConflictException for the specified set of files
 * @param files
 */
public CheckoutConflictException(String[] files){
  super(MessageFormat.format(JGitText.get().checkoutConflictWithFiles,buildList(files)));
  conflicting=files;
}","/** 
 * Construct a CheckoutConflictException for the specified set of files
 * @param files an array of relative file paths
 */
public CheckoutConflictException(String[] files){
  super(MessageFormat.format(JGitText.get().checkoutConflictWithFiles,buildList(files)));
  conflicting=files;
}",0.9418181818181818
91243,"/** 
 * @param returnCode return code returned by the command
 * @param message error message
 * @param cause exception causing this exception
 */
public CommandFailedException(int returnCode,String message,Throwable cause){
  super(message,cause);
  this.returnCode=returnCode;
}","/** 
 * Constructor for CommandFailedException
 * @param returnCode return code returned by the command
 * @param message error message
 * @param cause exception causing this exception
 */
public CommandFailedException(int returnCode,String message,Throwable cause){
  super(message,cause);
  this.returnCode=returnCode;
}",0.9302325581395348
91244,"/** 
 * @return return code returned by the command
 */
public int getReturnCode(){
  return returnCode;
}","/** 
 * Get return code returned by the command
 * @return return code returned by the command
 */
public int getReturnCode(){
  return returnCode;
}",0.8313725490196079
91245,"/** 
 * Specific error condition identified by   {@link ObjectChecker}.
 * @return error condition or null.
 * @since 4.2
 */
@Nullable public ObjectChecker.ErrorType getErrorType(){
  return errorType;
}","/** 
 * Specific error condition identified by  {@link org.eclipse.jgit.lib.ObjectChecker}.
 * @return error condition or null.
 * @since 4.2
 */
@Nullable public ObjectChecker.ErrorType getErrorType(){
  return errorType;
}",0.9485981308411215
91246,"/** 
 * Indicates that the thread computing a diff was interrupted. 
 */
public DiffInterruptedException(){
  super();
}","/** 
 * Indicates that the thread computing a diff was interrupted.
 */
public DiffInterruptedException(){
  super();
}",0.99581589958159
91247,"/** 
 * @return another path that has a conflict. 
 */
public String getPath2(){
  return path2;
}","/** 
 * Get another path that has a conflict
 * @return another path that has a conflict
 */
public String getPath2(){
  return path2;
}",0.8205128205128205
91248,"/** 
 * @return one of the paths that has a conflict. 
 */
public String getPath1(){
  return path1;
}","/** 
 * Get one of the paths that has a conflict
 * @return one of the paths that has a conflict
 */
public String getPath1(){
  return path1;
}",0.8130081300813008
91249,"/** 
 * @param msg
 */
public IllegalTodoFileModification(final String msg){
  super(msg);
}","/** 
 * Constructor for IllegalTodoFileModification
 * @param msg error message
 */
public IllegalTodoFileModification(final String msg){
  super(msg);
}",0.7510204081632653
91250,"/** 
 * @param id the invalid id.
 * @since 4.1
 */
public InvalidObjectIdException(String id){
  super(MessageFormat.format(JGitText.get().invalidId,id));
}","/** 
 * Constructor for InvalidObjectIdException
 * @param id the invalid id.
 * @since 4.1
 */
public InvalidObjectIdException(String id){
  super(MessageFormat.format(JGitText.get().invalidId,id));
}",0.6033519553072626
91251,"/** 
 * @param message explains what was wrong with the pattern.
 * @param pattern the invalid pattern.
 */
public InvalidPatternException(String message,String pattern){
  super(message);
  this.pattern=pattern;
}","/** 
 * Constructor for InvalidPatternException
 * @param message explains what was wrong with the pattern.
 * @param pattern the invalid pattern.
 */
public InvalidPatternException(String message,String pattern){
  super(message);
  this.pattern=pattern;
}",0.9087048832271762
91252,"/** 
 * @return the invalid pattern.
 */
public String getPattern(){
  return pattern;
}","/** 
 * Get the invalid pattern
 * @return the invalid pattern.
 */
public String getPattern(){
  return pattern;
}",0.8669950738916257
91253,"/** 
 * @return either the hex encoded name of the object, or 'unknown object'. 
 */
protected String getObjectName(){
  if (getObjectId() != null)   return getObjectId().name();
  return JGitText.get().unknownObject;
}","/** 
 * Get the hex encoded name of the object, or 'unknown object'
 * @return either the hex encoded name of the object, or 'unknown object'
 */
protected String getObjectName(){
  if (getObjectId() != null)   return getObjectId().name();
  return JGitText.get().unknownObject;
}",0.8697394789579158
91254,"/** 
 * @return identity of the object that is too large; may be null. 
 */
public ObjectId getObjectId(){
  return objectId;
}","/** 
 * Get identity of the object that is too large; may be null
 * @return identity of the object that is too large; may be null
 */
public ObjectId getObjectId(){
  return objectId;
}",0.7987220447284346
91255,"/** 
 * @return the ObjectId that was not found. 
 */
public ObjectId getObjectId(){
  return missing;
}","/** 
 * Get the ObjectId that was not found
 * @return the ObjectId that was not found
 */
public ObjectId getObjectId(){
  return missing;
}",0.8326530612244898
91256,"/** 
 * @param indexOfOpeningBracket the position of the [ character which has no ] character.
 * @param openingBracket the unclosed bracket.
 * @param closingBracket the missing closing bracket.
 * @param pattern the invalid pattern.
 */
public NoClosingBracketException(final int indexOfOpeningBracket,final String openingBracket,final String closingBracket,final String pattern){
  super(createMessage(indexOfOpeningBracket,openingBracket,closingBracket),pattern);
}","/** 
 * Constructor for NoClosingBracketException
 * @param indexOfOpeningBracket the position of the [ character which has no ] character.
 * @param openingBracket the unclosed bracket.
 * @param closingBracket the missing closing bracket.
 * @param pattern the invalid pattern.
 */
public NoClosingBracketException(final int indexOfOpeningBracket,final String openingBracket,final String closingBracket,final String pattern){
  super(createMessage(indexOfOpeningBracket,openingBracket,closingBracket),pattern);
}",0.9542217700915564
91257,"/** 
 * @return the reason why no merge base could be found
 */
public MergeBaseFailureReason getReason(){
  return reason;
}","/** 
 * Get the reason why no merge base could be found
 * @return the reason why no merge base could be found
 */
public MergeBaseFailureReason getReason(){
  return reason;
}",0.8305647840531561
91258,"/** 
 * Creates an exception indicating there is no work tree for a repository. 
 */
public NoWorkTreeException(){
  super(JGitText.get().bareRepositoryNoWorkdirAndIndex);
}","/** 
 * Creates an exception indicating there is no work tree for a repository.
 */
public NoWorkTreeException(){
  super(JGitText.get().bareRepositoryNoWorkdirAndIndex);
}",0.9971014492753624
91259,"@Test public void testCloneBareRepositoryDefaultDirectory() throws IOException, URISyntaxException, JGitInternalException, GitAPIException {
  CloneCommand command=Git.cloneRepository().setURI(fileUri()).setBare(true);
  command.verifyDirectories(new URIish(fileUri()));
  File directory=command.getDirectory();
  assertEquals(git.getRepository().getWorkTree().getName() + Constants.DOT_GIT_EXT,directory.getName());
}","@Test public void testCloneBareRepositoryDefaultDirectory() throws URISyntaxException, JGitInternalException {
  CloneCommand command=Git.cloneRepository().setURI(fileUri()).setBare(true);
  command.verifyDirectories(new URIish(fileUri()));
  File directory=command.getDirectory();
  assertEquals(git.getRepository().getWorkTree().getName() + Constants.DOT_GIT_EXT,directory.getName());
}",0.9627791563275434
91260,"@Test public void testCloneRepositoryDefaultDirectory() throws IOException, URISyntaxException, JGitInternalException, GitAPIException {
  CloneCommand command=Git.cloneRepository().setURI(fileUri());
  command.verifyDirectories(new URIish(fileUri()));
  File directory=command.getDirectory();
  assertEquals(git.getRepository().getWorkTree().getName(),directory.getName());
}","@Test public void testCloneRepositoryDefaultDirectory() throws URISyntaxException, JGitInternalException {
  CloneCommand command=Git.cloneRepository().setURI(fileUri());
  command.verifyDirectories(new URIish(fileUri()));
  File directory=command.getDirectory();
  assertEquals(git.getRepository().getWorkTree().getName(),directory.getName());
}",0.9584487534626038
91261,"static int count(String s,char c,boolean ignoreFirstLast){
  int start=0;
  int count=0;
  while (true) {
    start=s.indexOf(c,start);
    if (start == -1)     break;
    if (!ignoreFirstLast || (start != 0 && start != s.length()))     count++;
    start++;
  }
  return count;
}","static int count(String s,char c,boolean ignoreFirstLast){
  int start=0;
  int count=0;
  int length=s.length();
  while (start < length) {
    start=s.indexOf(c,start);
    if (start == -1) {
      break;
    }
    if (!ignoreFirstLast || (start != 0 && start != length - 1)) {
      count++;
    }
    start++;
  }
  return count;
}",0.8585365853658536
91262,"static int count(String s,char c,boolean ignoreFirstLast){
  int start=0;
  int count=0;
  while (true) {
    start=s.indexOf(c,start);
    if (start == -1)     break;
    if (!ignoreFirstLast || (start != 0 && start != s.length()))     count++;
    start++;
  }
  return count;
}","static int count(String s,char c,boolean ignoreFirstLast){
  int start=0;
  int count=0;
  int length=s.length();
  while (start < length) {
    start=s.indexOf(c,start);
    if (start == -1) {
      break;
    }
    if (!ignoreFirstLast || (start != 0 && start != length - 1)) {
      count++;
    }
    start++;
  }
  return count;
}",0.8585365853658536
91263,"/** 
 * Describes the specified commit. Target defaults to HEAD if no commit was set explicitly.
 * @return if there's a tag that points to the commit being described, thistag name is returned. Otherwise additional suffix is added to the nearest tag, just like git-describe(1). <p> If none of the ancestors of the commit being described has any tags at all, then this method returns null, indicating that there's no way to describe this tag.
 */
@Override public String call() throws GitAPIException {
  try {
    checkCallable();
    if (target == null)     setTarget(Constants.HEAD);
    Map<ObjectId,Ref> tags=new HashMap<>();
    for (    Ref r : repo.getRefDatabase().getRefs(R_TAGS).values()) {
      ObjectId key=repo.peel(r).getPeeledObjectId();
      if (key == null)       key=r.getObjectId();
      tags.put(key,r);
    }
    final RevFlagSet allFlags=new RevFlagSet();
    /** 
 * Tracks the depth of each tag as we find them.
 */
class Candidate {
      final Ref tag;
      final RevFlag flag;
      /** 
 * This field counts number of commits that are reachable from the tip but not reachable from the tag.
 */
      int depth;
      Candidate(      RevCommit commit,      Ref tag){
        this.tag=tag;
        this.flag=w.newFlag(tag.getName());
        allFlags.add(flag);
        w.carry(flag);
        commit.add(flag);
        commit.carry(flag);
      }
      /** 
 * Does this tag contain the given commit?
 */
      boolean reaches(      RevCommit c){
        return c.has(flag);
      }
      String describe(      ObjectId tip) throws IOException {
        return longDescription(tag,depth,tip);
      }
    }
    List<Candidate> candidates=new ArrayList<>();
    Ref tagOnTarget=tags.get(target);
    if (tagMatches(tagOnTarget)) {
      return longDesc ? longDescription(tagOnTarget,0,target) : tagOnTarget.getName().substring(R_TAGS.length());
    }
    w.markStart(target);
    int seen=0;
    RevCommit c;
    while ((c=w.next()) != null) {
      if (!c.hasAny(allFlags)) {
        Ref t=tags.get(c);
        if (tagMatches(t)) {
          Candidate cd=new Candidate(c,t);
          candidates.add(cd);
          cd.depth=seen;
        }
      }
      for (      Candidate cd : candidates) {
        if (!cd.reaches(c))         cd.depth++;
      }
      if (candidates.size() >= maxCandidates)       break;
      seen++;
    }
    while ((c=w.next()) != null) {
      if (c.hasAll(allFlags)) {
        for (        RevCommit p : c.getParents())         p.add(RevFlag.SEEN);
      }
 else {
        for (        Candidate cd : candidates) {
          if (!cd.reaches(c))           cd.depth++;
        }
      }
    }
    if (candidates.isEmpty())     return null;
    Candidate best=Collections.min(candidates,new Comparator<Candidate>(){
      @Override public int compare(      Candidate o1,      Candidate o2){
        return o1.depth - o2.depth;
      }
    }
);
    return best.describe(target);
  }
 catch (  IOException e) {
    throw new JGitInternalException(e.getMessage(),e);
  }
 finally {
    setCallable(false);
    w.close();
  }
}","/** 
 * Describes the specified commit. Target defaults to HEAD if no commit was set explicitly.
 * @return if there's a tag that points to the commit being described, thistag name is returned. Otherwise additional suffix is added to the nearest tag, just like git-describe(1). <p> If none of the ancestors of the commit being described has any tags at all, then this method returns null, indicating that there's no way to describe this tag.
 */
@Override public String call() throws GitAPIException {
  try {
    checkCallable();
    if (target == null)     setTarget(Constants.HEAD);
    Collection<Ref> tagList=repo.getRefDatabase().getRefs(R_TAGS).values();
    Map<ObjectId,List<Ref>> tags=tagList.stream().collect(Collectors.groupingBy(this::getObjectIdFromRef));
    final RevFlagSet allFlags=new RevFlagSet();
    /** 
 * Tracks the depth of each tag as we find them.
 */
class Candidate {
      final Ref tag;
      final RevFlag flag;
      /** 
 * This field counts number of commits that are reachable from the tip but not reachable from the tag.
 */
      int depth;
      Candidate(      RevCommit commit,      Ref tag){
        this.tag=tag;
        this.flag=w.newFlag(tag.getName());
        allFlags.add(flag);
        w.carry(flag);
        commit.add(flag);
        commit.carry(flag);
      }
      /** 
 * Does this tag contain the given commit?
 */
      boolean reaches(      RevCommit c){
        return c.has(flag);
      }
      String describe(      ObjectId tip) throws IOException {
        return longDescription(tag,depth,tip);
      }
    }
    List<Candidate> candidates=new ArrayList<>();
    Optional<Ref> bestMatch=getBestMatch(tags.get(target));
    if (bestMatch.isPresent()) {
      return longDesc ? longDescription(bestMatch.get(),0,target) : bestMatch.get().getName().substring(R_TAGS.length());
    }
    w.markStart(target);
    int seen=0;
    RevCommit c;
    while ((c=w.next()) != null) {
      if (!c.hasAny(allFlags)) {
        bestMatch=getBestMatch(tags.get(c));
        if (bestMatch.isPresent()) {
          Candidate cd=new Candidate(c,bestMatch.get());
          candidates.add(cd);
          cd.depth=seen;
        }
      }
      for (      Candidate cd : candidates) {
        if (!cd.reaches(c))         cd.depth++;
      }
      if (candidates.size() >= maxCandidates)       break;
      seen++;
    }
    while ((c=w.next()) != null) {
      if (c.hasAll(allFlags)) {
        for (        RevCommit p : c.getParents())         p.add(RevFlag.SEEN);
      }
 else {
        for (        Candidate cd : candidates) {
          if (!cd.reaches(c))           cd.depth++;
        }
      }
    }
    if (candidates.isEmpty())     return null;
    Candidate best=Collections.min(candidates,new Comparator<Candidate>(){
      @Override public int compare(      Candidate o1,      Candidate o2){
        return o1.depth - o2.depth;
      }
    }
);
    return best.describe(target);
  }
 catch (  IOException e) {
    throw new JGitInternalException(e.getMessage(),e);
  }
 finally {
    setCallable(false);
    w.close();
  }
}",0.9069654164637116
91264,"void stopBuffering() throws IOException {
  if (buffer != null) {
    buffer.writeTo(rawOut);
    buffer=null;
    out=rawOut;
  }
}","void stopBuffering() throws IOException {
  if (out != rawOut) {
    ((ByteArrayOutputStream)out).writeTo(rawOut);
    out=rawOut;
  }
}",0.7686567164179104
91265,"ResponseBufferedOutputStream(OutputStream rawOut){
  this.rawOut=rawOut;
  this.out=this.buffer=new ByteArrayOutputStream();
}","ResponseBufferedOutputStream(OutputStream rawOut){
  this.rawOut=rawOut;
  this.out=new ByteArrayOutputStream();
}",0.95
91266,"void stopBuffering() throws IOException {
  if (buffer != null) {
    buffer.writeTo(rawOut);
    buffer=null;
    out=rawOut;
  }
}","void stopBuffering() throws IOException {
  if (out != rawOut) {
    ((ByteArrayOutputStream)out).writeTo(rawOut);
    out=rawOut;
  }
}",0.7686567164179104
91267,"ResponseBufferedOutputStream(OutputStream rawOut){
  this.rawOut=rawOut;
  this.out=this.buffer=new ByteArrayOutputStream();
}","ResponseBufferedOutputStream(OutputStream rawOut){
  this.rawOut=rawOut;
  this.out=new ByteArrayOutputStream();
}",0.95
91268,"@Test public void testContains(){
  final RevFlag flag1=rw.newFlag(""String_Node_Str"");
  final RevFlag flag2=rw.newFlag(""String_Node_Str"");
  final RevFlagSet set=new RevFlagSet();
  set.add(flag1);
  assertTrue(set.contains(flag1));
  assertFalse(set.contains(flag2));
  assertFalse(set.contains(""String_Node_Str""));
}","@Test public void testContains(){
  final RevFlag flag1=rw.newFlag(""String_Node_Str"");
  final RevFlag flag2=rw.newFlag(""String_Node_Str"");
  final RevFlagSet set=new RevFlagSet();
  set.add(flag1);
  assertTrue(set.contains(flag1));
  assertFalse(set.contains(flag2));
}",0.91864406779661
91269,"public RefLeaseSpec(final String ref,final String expected){
  this.ref=ref;
  this.expected=expected;
}","/** 
 * @param ref ref being pushed
 * @param expected the expected value of the ref
 */
public RefLeaseSpec(String ref,String expected){
  this.ref=ref;
  this.expected=expected;
}",0.6456140350877193
91270,"/** 
 * Loosen objects in a pack file which are not also in the newly-created pack files.
 */
private void loosen(ObjectDirectoryInserter inserter,ObjectReader reader,PackFile pack,HashSet<ObjectId> existing) throws IOException {
  for (  PackIndex.MutableEntry entry : pack) {
    ObjectId oid=entry.toObjectId();
    if (existing.contains(oid)) {
      continue;
    }
    existing.add(oid);
    ObjectLoader loader=reader.open(oid);
    inserter.insert(loader.getType(),loader.getSize(),loader.openStream(),true);
  }
}","/** 
 * Loosen objects in a pack file which are not also in the newly-created pack files.
 * @param inserter
 * @param reader
 * @param pack
 * @param existing
 * @throws IOException
 */
private void loosen(ObjectDirectoryInserter inserter,ObjectReader reader,PackFile pack,HashSet<ObjectId> existing) throws IOException {
  for (  PackIndex.MutableEntry entry : pack) {
    ObjectId oid=entry.toObjectId();
    if (existing.contains(oid)) {
      continue;
    }
    existing.add(oid);
    ObjectLoader loader=reader.open(oid);
    inserter.insert(loader.getType(),loader.getSize(),loader.openStream(),true);
  }
}",0.9182058047493404
91271,"/** 
 * Insert a loose object into the database.  If createDuplicate is true, write the loose object even if we already have it in the loose or packed ODB.
 */
ObjectId insert(int type,long len,InputStream is,boolean createDuplicate) throws IOException {
  if (len <= buffer().length) {
    byte[] buf=buffer();
    int actLen=IO.readFully(is,buf,0);
    return insert(type,buf,0,actLen,createDuplicate);
  }
 else {
    MessageDigest md=digest();
    File tmp=toTemp(md,type,len,is);
    ObjectId id=ObjectId.fromRaw(md.digest());
    return insertOneObject(tmp,id,createDuplicate);
  }
}","/** 
 * Insert a loose object into the database. If createDuplicate is true, write the loose object even if we already have it in the loose or packed ODB.
 * @param type
 * @param len
 * @param is
 * @param createDuplicate
 * @return ObjectId
 * @throws IOException
 */
ObjectId insert(int type,long len,InputStream is,boolean createDuplicate) throws IOException {
  if (len <= buffer().length) {
    byte[] buf=buffer();
    int actLen=IO.readFully(is,buf,0);
    return insert(type,buf,0,actLen,createDuplicate);
  }
 else {
    MessageDigest md=digest();
    File tmp=toTemp(md,type,len,is);
    ObjectId id=ObjectId.fromRaw(md.digest());
    return insertOneObject(tmp,id,createDuplicate);
  }
}",0.8074534161490683
91272,"public int run() throws IOException {
  try {
    byte[] buf=new byte[8192];
    int length=in.read(buf);
    if (length != -1) {
      aOut.write(buf,0,length);
      size+=length;
      return length;
    }
 else {
      aOut.close();
      AnyLongObjectId loid=aOut.getId();
      aOut=null;
      Path mediaFile=lfsUtil.getMediaFile(loid);
      if (Files.isRegularFile(mediaFile)) {
        long fsSize=Files.size(mediaFile);
        if (fsSize != size) {
          throw new CorruptMediaFile(mediaFile,size,fsSize);
        }
 else {
          FileUtils.delete(tmpFile.toFile());
        }
      }
 else {
        FileUtils.mkdirs(mediaFile.getParent().toFile(),true);
        FileUtils.rename(tmpFile.toFile(),mediaFile.toFile(),StandardCopyOption.ATOMIC_MOVE);
      }
      LfsPointer lfsPointer=new LfsPointer(loid,size);
      lfsPointer.encode(out);
      out.close();
      return -1;
    }
  }
 catch (  IOException e) {
    if (aOut != null) {
      aOut.abort();
    }
    out.close();
    throw e;
  }
}","public int run() throws IOException {
  try {
    byte[] buf=new byte[8192];
    int length=in.read(buf);
    if (length != -1) {
      aOut.write(buf,0,length);
      size+=length;
      return length;
    }
 else {
      aOut.close();
      AnyLongObjectId loid=aOut.getId();
      aOut=null;
      Path mediaFile=lfsUtil.getMediaFile(loid);
      if (Files.isRegularFile(mediaFile)) {
        long fsSize=Files.size(mediaFile);
        if (fsSize != size) {
          throw new CorruptMediaFile(mediaFile,size,fsSize);
        }
 else {
          FileUtils.delete(tmpFile.toFile());
        }
      }
 else {
        Path parent=mediaFile.getParent();
        if (parent != null) {
          FileUtils.mkdirs(parent.toFile(),true);
        }
        FileUtils.rename(tmpFile.toFile(),mediaFile.toFile(),StandardCopyOption.ATOMIC_MOVE);
      }
      LfsPointer lfsPointer=new LfsPointer(loid,size);
      lfsPointer.encode(out);
      out.close();
      return -1;
    }
  }
 catch (  IOException e) {
    if (aOut != null) {
      aOut.abort();
    }
    out.close();
    throw e;
  }
}",0.9469194312796207
91273,"public boolean accept(Path file) throws IOException {
  return Files.isRegularFile(file) && PATTERN_LOOSE_OBJECT.matcher(file.getFileName().toString()).matches();
}","public boolean accept(Path file) throws IOException {
  Path fileName=file.getFileName();
  return Files.isRegularFile(file) && fileName != null && PATTERN_LOOSE_OBJECT.matcher(fileName.toString()).matches();
}",0.7647058823529411
91274,"/** 
 * Quickly estimate number of loose objects, SHA1 is distributed evenly so counting objects in one directory (bucket 17) is sufficient
 * @return {@code true} if number of loose objects > gc.auto (default 6700)
 */
boolean tooManyLooseObjects(){
  int auto=repo.getConfig().getInt(ConfigConstants.CONFIG_GC_SECTION,ConfigConstants.CONFIG_KEY_AUTO,DEFAULT_AUTOLIMIT);
  if (auto <= 0) {
    return false;
  }
  int n=0;
  int threshold=(auto + 255) / 256;
  Path dir=repo.getObjectsDirectory().toPath().resolve(""String_Node_Str"");
  if (!Files.exists(dir)) {
    return false;
  }
  try (DirectoryStream<Path> stream=Files.newDirectoryStream(dir,new DirectoryStream.Filter<Path>(){
    public boolean accept(    Path file) throws IOException {
      return Files.isRegularFile(file) && PATTERN_LOOSE_OBJECT.matcher(file.getFileName().toString()).matches();
    }
  }
)){
    for (Iterator<Path> iter=stream.iterator(); iter.hasNext(); iter.next()) {
      if (++n > threshold) {
        return true;
      }
    }
  }
 catch (  IOException e) {
    LOG.error(e.getMessage(),e);
  }
  return false;
}","/** 
 * Quickly estimate number of loose objects, SHA1 is distributed evenly so counting objects in one directory (bucket 17) is sufficient
 * @return {@code true} if number of loose objects > gc.auto (default 6700)
 */
boolean tooManyLooseObjects(){
  int auto=repo.getConfig().getInt(ConfigConstants.CONFIG_GC_SECTION,ConfigConstants.CONFIG_KEY_AUTO,DEFAULT_AUTOLIMIT);
  if (auto <= 0) {
    return false;
  }
  int n=0;
  int threshold=(auto + 255) / 256;
  Path dir=repo.getObjectsDirectory().toPath().resolve(""String_Node_Str"");
  if (!Files.exists(dir)) {
    return false;
  }
  try (DirectoryStream<Path> stream=Files.newDirectoryStream(dir,new DirectoryStream.Filter<Path>(){
    public boolean accept(    Path file) throws IOException {
      Path fileName=file.getFileName();
      return Files.isRegularFile(file) && fileName != null && PATTERN_LOOSE_OBJECT.matcher(fileName.toString()).matches();
    }
  }
)){
    for (Iterator<Path> iter=stream.iterator(); iter.hasNext(); iter.next()) {
      if (++n > threshold) {
        return true;
      }
    }
  }
 catch (  IOException e) {
    LOG.error(e.getMessage(),e);
  }
  return false;
}",0.9627659574468084
91275,"public void assertWorkDir(Map<String,String> i) throws CorruptObjectException, IOException {
  try (TreeWalk walk=new TreeWalk(db)){
    walk.setRecursive(false);
    walk.addTree(new FileTreeIterator(db));
    String expectedValue;
    String path;
    int nrFiles=0;
    FileTreeIterator ft;
    while (walk.next()) {
      ft=walk.getTree(0,FileTreeIterator.class);
      path=ft.getEntryPathString();
      expectedValue=i.get(path);
      File file=new File(db.getWorkTree(),path);
      assertTrue(file.exists());
      if (file.isFile()) {
        assertNotNull(""String_Node_Str"" + path + ""String_Node_Str"",expectedValue);
        FileInputStream is=new FileInputStream(file);
        byte[] buffer=new byte[(int)file.length()];
        int offset=0;
        int numRead=0;
        while (offset < buffer.length && (numRead=is.read(buffer,offset,buffer.length - offset)) >= 0) {
          offset+=numRead;
        }
        is.close();
        assertArrayEquals(""String_Node_Str"" + path + ""String_Node_Str"",buffer,i.get(path).getBytes());
        nrFiles++;
      }
 else       if (file.isDirectory()) {
        if (file.list().length == 0) {
          assertEquals(""String_Node_Str"" + path + ""String_Node_Str"",""String_Node_Str"",i.get(path));
          nrFiles++;
        }
      }
      if (walk.isSubtree()) {
        walk.enterSubtree();
      }
    }
    assertEquals(""String_Node_Str"",i.size(),nrFiles);
  }
 }","public void assertWorkDir(Map<String,String> i) throws CorruptObjectException, IOException {
  try (TreeWalk walk=new TreeWalk(db)){
    walk.setRecursive(false);
    walk.addTree(new FileTreeIterator(db));
    String expectedValue;
    String path;
    int nrFiles=0;
    FileTreeIterator ft;
    while (walk.next()) {
      ft=walk.getTree(0,FileTreeIterator.class);
      path=ft.getEntryPathString();
      expectedValue=i.get(path);
      File file=new File(db.getWorkTree(),path);
      assertTrue(file.exists());
      if (file.isFile()) {
        assertNotNull(""String_Node_Str"" + path + ""String_Node_Str"",expectedValue);
        FileInputStream is=new FileInputStream(file);
        byte[] buffer=new byte[(int)file.length()];
        int offset=0;
        int numRead=0;
        while (offset < buffer.length && (numRead=is.read(buffer,offset,buffer.length - offset)) >= 0) {
          offset+=numRead;
        }
        is.close();
        assertArrayEquals(""String_Node_Str"" + path + ""String_Node_Str"",buffer,i.get(path).getBytes());
        nrFiles++;
      }
 else       if (file.isDirectory()) {
        String[] files=file.list();
        if (files != null && files.length == 0) {
          assertEquals(""String_Node_Str"" + path + ""String_Node_Str"",""String_Node_Str"",i.get(path));
          nrFiles++;
        }
      }
      if (walk.isSubtree()) {
        walk.enterSubtree();
      }
    }
    assertEquals(""String_Node_Str"",i.size(),nrFiles);
  }
 }",0.973365617433414
91276,"@Test public void emptyRefDirectoryDeleted() throws Exception {
  String ref=""String_Node_Str"";
  tr.branch(ref).commit().create();
  String name=repo.findRef(ref).getName();
  Path dir=repo.getDirectory().toPath().resolve(name).getParent();
  gc.packRefs();
  assertFalse(Files.exists(dir));
}","@Test public void emptyRefDirectoryDeleted() throws Exception {
  String ref=""String_Node_Str"";
  tr.branch(ref).commit().create();
  String name=repo.findRef(ref).getName();
  Path dir=repo.getDirectory().toPath().resolve(name).getParent();
  assertNotNull(dir);
  gc.packRefs();
  assertFalse(Files.exists(dir));
}",0.9639344262295082
91277,"/** 
 * Test packfile scanning while a gc is done from the outside (different process or different Repository instance). This situation occurs e.g. if a gerrit server is serving fetch requests while native git is doing a garbage collection. The test shows that when core.trustfolderstat==true jgit may miss to detect that a new packfile was created. This situation is persistent until a new full rescan of the pack directory is triggered. The test works with two Repository instances working on the same disk location. One (db) for all write operations (creating commits, doing gc) and another one (receivingDB) which just reads and which in the end shows the bug
 * @throws Exception
 */
@Test public void testScanningForPackfiles() throws Exception {
  ObjectId unknownID=ObjectId.fromString(""String_Node_Str"");
  GC gc=new GC(db);
  gc.setExpireAgeMillis(0);
  gc.setPackExpireAgeMillis(0);
  try (FileRepository receivingDB=new FileRepository(db.getDirectory())){
    FileBasedConfig cfg=receivingDB.getConfig();
    cfg.setBoolean(ConfigConstants.CONFIG_CORE_SECTION,null,ConfigConstants.CONFIG_KEY_TRUSTFOLDERSTAT,true);
    cfg.save();
    ObjectId id=commitFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getId();
    gc.gc();
    assertFalse(receivingDB.hasObject(unknownID));
    assertTrue(receivingDB.getObjectDatabase().hasPackedObject(id));
    File packsFolder=new File(receivingDB.getObjectsDirectory(),""String_Node_Str"");
    File tmpFile=new File(packsFolder,""String_Node_Str"");
    RevCommit id2=commitFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    fsTick(null);
    assertTrue(tmpFile.createNewFile());
    assertFalse(receivingDB.hasObject(unknownID));
    gc.gc();
    Thread.sleep(2600);
    File[] ret=packsFolder.listFiles(new FilenameFilter(){
      @Override public boolean accept(      File dir,      String name){
        return name.endsWith(""String_Node_Str"");
      }
    }
);
    assertTrue(ret.length == 1);
    Assume.assumeTrue(tmpFile.lastModified() == ret[0].lastModified());
    assertFalse(receivingDB.hasObject(unknownID));
    assertTrue(receivingDB.hasObject(id2));
  }
 }","/** 
 * Test packfile scanning while a gc is done from the outside (different process or different Repository instance). This situation occurs e.g. if a gerrit server is serving fetch requests while native git is doing a garbage collection. The test shows that when core.trustfolderstat==true jgit may miss to detect that a new packfile was created. This situation is persistent until a new full rescan of the pack directory is triggered. The test works with two Repository instances working on the same disk location. One (db) for all write operations (creating commits, doing gc) and another one (receivingDB) which just reads and which in the end shows the bug
 * @throws Exception
 */
@Test public void testScanningForPackfiles() throws Exception {
  ObjectId unknownID=ObjectId.fromString(""String_Node_Str"");
  GC gc=new GC(db);
  gc.setExpireAgeMillis(0);
  gc.setPackExpireAgeMillis(0);
  try (FileRepository receivingDB=new FileRepository(db.getDirectory())){
    FileBasedConfig cfg=receivingDB.getConfig();
    cfg.setBoolean(ConfigConstants.CONFIG_CORE_SECTION,null,ConfigConstants.CONFIG_KEY_TRUSTFOLDERSTAT,true);
    cfg.save();
    ObjectId id=commitFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getId();
    gc.gc();
    assertFalse(receivingDB.hasObject(unknownID));
    assertTrue(receivingDB.getObjectDatabase().hasPackedObject(id));
    File packsFolder=new File(receivingDB.getObjectsDirectory(),""String_Node_Str"");
    File tmpFile=new File(packsFolder,""String_Node_Str"");
    RevCommit id2=commitFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    fsTick(null);
    assertTrue(tmpFile.createNewFile());
    assertFalse(receivingDB.hasObject(unknownID));
    gc.gc();
    Thread.sleep(2600);
    File[] ret=packsFolder.listFiles(new FilenameFilter(){
      @Override public boolean accept(      File dir,      String name){
        return name.endsWith(""String_Node_Str"");
      }
    }
);
    assertTrue(ret != null && ret.length == 1);
    Assume.assumeTrue(tmpFile.lastModified() == ret[0].lastModified());
    assertFalse(receivingDB.hasObject(unknownID));
    assertTrue(receivingDB.hasObject(id2));
  }
 }",0.9965156794425089
91278,"protected KnownUser loadUserInfo(String usrname){
  return null;
}","protected KnownUser loadUserInfo(@SuppressWarnings(""String_Node_Str"") String usrname){
  return null;
}",0.7810650887573964
91279,"private void auth(ServletContextHandler ctx,Authenticator authType){
  final String role=""String_Node_Str"";
  MappedLoginService users=new MappedLoginService(){
    @Override protected UserIdentity loadUser(    String who){
      return null;
    }
    @Override protected void loadUsers() throws IOException {
      putUser(username,new Password(password),new String[]{role});
    }
    protected String[] loadRoleInfo(    KnownUser user){
      return null;
    }
    protected KnownUser loadUserInfo(    String usrname){
      return null;
    }
  }
;
  ConstraintMapping cm=new ConstraintMapping();
  cm.setConstraint(new Constraint());
  cm.getConstraint().setAuthenticate(true);
  cm.getConstraint().setDataConstraint(Constraint.DC_NONE);
  cm.getConstraint().setRoles(new String[]{role});
  cm.setPathSpec(""String_Node_Str"");
  ConstraintSecurityHandler sec=new ConstraintSecurityHandler();
  sec.setRealmName(realm);
  sec.setAuthenticator(authType);
  sec.setLoginService(users);
  sec.setConstraintMappings(new ConstraintMapping[]{cm});
  sec.setHandler(ctx);
  contexts.removeHandler(ctx);
  contexts.addHandler(sec);
}","private void auth(ServletContextHandler ctx,Authenticator authType){
  final String role=""String_Node_Str"";
  MappedLoginService users=new TestMappedLoginService(role);
  ConstraintMapping cm=new ConstraintMapping();
  cm.setConstraint(new Constraint());
  cm.getConstraint().setAuthenticate(true);
  cm.getConstraint().setDataConstraint(Constraint.DC_NONE);
  cm.getConstraint().setRoles(new String[]{role});
  cm.setPathSpec(""String_Node_Str"");
  ConstraintSecurityHandler sec=new ConstraintSecurityHandler();
  sec.setRealmName(realm);
  sec.setAuthenticator(authType);
  sec.setLoginService(users);
  sec.setConstraintMappings(new ConstraintMapping[]{cm});
  sec.setHandler(ctx);
  contexts.removeHandler(ctx);
  contexts.addHandler(sec);
}",0.7844183564567769
91280,"protected String[] loadRoleInfo(KnownUser user){
  return null;
}","protected String[] loadRoleInfo(@SuppressWarnings(""String_Node_Str"") KnownUser user){
  return null;
}",0.7784431137724551
91281,"/** 
 * Sets the recommendation for shallowness.
 * @since 4.4
 */
public void setRecommendShallow(String recommendShallow){
  this.recommendShallow=recommendShallow;
}","/** 
 * Sets the recommendation for shallowness.
 * @param recommendShallow recommendation for shallowness
 * @since 4.4
 */
public void setRecommendShallow(String recommendShallow){
  this.recommendShallow=recommendShallow;
}",0.8527918781725888
91282,"/** 
 * Set the url of the sub repo.
 * @param url
 * @return this for chaining.
 * @since 4.4
 */
public RepoProject setGroups(String groups){
  this.groups.clear();
  this.groups.addAll(Arrays.asList(groups.split(""String_Node_Str"")));
  return this;
}","/** 
 * Set the url of the sub repo.
 * @param groups comma separated group list
 * @return this for chaining.
 * @since 4.4
 */
public RepoProject setGroups(String groups){
  this.groups.clear();
  this.groups.addAll(Arrays.asList(groups.split(""String_Node_Str"")));
  return this;
}",0.9328358208955224
91283,"private static void addHostHeader(URL url,Map<String,String> headers){
  String hostHeader=url.getHost();
  int port=url.getPort();
  if (port > -1) {
    hostHeader.concat(""String_Node_Str"" + Integer.toString(port));
  }
  headers.put(""String_Node_Str"",hostHeader);
}","private static void addHostHeader(URL url,Map<String,String> headers){
  StringBuilder hostHeader=new StringBuilder(url.getHost());
  int port=url.getPort();
  if (port > -1) {
    hostHeader.append(""String_Node_Str"").append(port);
  }
  headers.put(""String_Node_Str"",hostHeader.toString());
}",0.8021390374331551
91284,"/** 
 * Get the HTTP response code from the request. <p> Roughly the same as <code>c.getResponseCode()</code> but the ConnectException is translated to be more understandable.
 * @param c connection the code should be obtained from.
 * @return r HTTP status code, usually 200 to indicate success. See{@link HttpConnection} for other defined constants.
 * @throws IOException communications error prevented obtaining the response code.
 */
public static int response(final java.net.HttpURLConnection c) throws IOException {
  try {
    return c.getResponseCode();
  }
 catch (  ConnectException ce) {
    final String host=c.getURL().getHost();
    if (""String_Node_Str"".equals(ce.getMessage()))     throw new ConnectException(MessageFormat.format(JGitText.get().connectionTimeOut,host));
    throw new ConnectException(ce.getMessage() + ""String_Node_Str"" + host);
  }
}","/** 
 * Get the HTTP response code from the request. <p> Roughly the same as <code>c.getResponseCode()</code> but the ConnectException is translated to be more understandable.
 * @param c connection the code should be obtained from.
 * @return r HTTP status code, usually 200 to indicate success. See{@link HttpConnection} for other defined constants.
 * @throws IOException communications error prevented obtaining the response code.
 */
public static int response(final java.net.HttpURLConnection c) throws IOException {
  try {
    return c.getResponseCode();
  }
 catch (  ConnectException ce) {
    final URL url=c.getURL();
    final String host=(url == null) ? ""String_Node_Str"" : url.getHost();
    if (""String_Node_Str"".equals(ce.getMessage()))     throw new ConnectException(MessageFormat.format(JGitText.get().connectionTimeOut,host));
    throw new ConnectException(ce.getMessage() + ""String_Node_Str"" + host);
  }
}",0.9337785197551476
91285,"@Override protected void run() throws Exception {
  if (squash && ff == FastForwardMode.NO_FF)   throw die(CLIText.get().cannotCombineSquashWithNoff);
  if (strategyName != null) {
    mergeStrategy=MergeStrategy.get(strategyName);
    if (mergeStrategy == null)     throw die(MessageFormat.format(CLIText.get().unknownMergeStrategy,strategyName));
  }
  final Ref srcRef=db.getRef(ref);
  final ObjectId src=db.resolve(ref + ""String_Node_Str"");
  if (src == null)   throw die(MessageFormat.format(CLIText.get().refDoesNotExistOrNoCommit,ref));
  Ref oldHead=getOldHead();
  MergeResult result;
  try (Git git=new Git(db)){
    MergeCommand mergeCmd=git.merge().setStrategy(mergeStrategy).setSquash(squash).setFastForward(ff).setCommit(!noCommit);
    if (srcRef != null)     mergeCmd.include(srcRef);
 else     mergeCmd.include(src);
    if (message != null)     mergeCmd.setMessage(message);
    try {
      result=mergeCmd.call();
    }
 catch (    CheckoutConflictException e) {
      result=new MergeResult(e.getConflictingPaths());
    }
  }
 switch (result.getMergeStatus()) {
case ALREADY_UP_TO_DATE:
    if (squash)     outw.print(CLIText.get().nothingToSquash);
  outw.println(CLIText.get().alreadyUpToDate);
break;
case FAST_FORWARD:
ObjectId oldHeadId=oldHead.getObjectId();
outw.println(MessageFormat.format(CLIText.get().updating,oldHeadId.abbreviate(7).name(),result.getNewHead().abbreviate(7).name()));
outw.println(result.getMergeStatus().toString());
break;
case CHECKOUT_CONFLICT:
outw.println(CLIText.get().mergeCheckoutConflict);
for (String collidingPath : result.getCheckoutConflicts()) outw.println(""String_Node_Str"" + collidingPath);
outw.println(CLIText.get().mergeCheckoutFailed);
break;
case CONFLICTING:
for (String collidingPath : result.getConflicts().keySet()) outw.println(MessageFormat.format(CLIText.get().mergeConflict,collidingPath));
outw.println(CLIText.get().mergeFailed);
break;
case FAILED:
for (Map.Entry<String,MergeFailureReason> entry : result.getFailingPaths().entrySet()) switch (entry.getValue()) {
case DIRTY_WORKTREE:
case DIRTY_INDEX:
outw.println(CLIText.get().dontOverwriteLocalChanges);
outw.println(""String_Node_Str"" + entry.getKey());
break;
case COULD_NOT_DELETE:
outw.println(CLIText.get().cannotDeleteFile);
outw.println(""String_Node_Str"" + entry.getKey());
break;
}
break;
case MERGED:
String name;
if (!isMergedInto(oldHead,src)) name=mergeStrategy.getName();
 else name=""String_Node_Str"";
outw.println(MessageFormat.format(CLIText.get().mergeMadeBy,name));
break;
case MERGED_NOT_COMMITTED:
outw.println(CLIText.get().mergeWentWellStoppedBeforeCommitting);
break;
case MERGED_SQUASHED:
case FAST_FORWARD_SQUASHED:
case MERGED_SQUASHED_NOT_COMMITTED:
outw.println(CLIText.get().mergedSquashed);
outw.println(CLIText.get().mergeWentWellStoppedBeforeCommitting);
break;
case ABORTED:
throw die(CLIText.get().ffNotPossibleAborting);
case NOT_SUPPORTED:
outw.println(MessageFormat.format(CLIText.get().unsupportedOperation,result.toString()));
}
}","@Override protected void run() throws Exception {
  if (squash && ff == FastForwardMode.NO_FF)   throw die(CLIText.get().cannotCombineSquashWithNoff);
  if (strategyName != null) {
    mergeStrategy=MergeStrategy.get(strategyName);
    if (mergeStrategy == null)     throw die(MessageFormat.format(CLIText.get().unknownMergeStrategy,strategyName));
  }
  final Ref srcRef=db.getRef(ref);
  final ObjectId src=db.resolve(ref + ""String_Node_Str"");
  if (src == null)   throw die(MessageFormat.format(CLIText.get().refDoesNotExistOrNoCommit,ref));
  Ref oldHead=getOldHead();
  MergeResult result;
  try (Git git=new Git(db)){
    MergeCommand mergeCmd=git.merge().setStrategy(mergeStrategy).setSquash(squash).setFastForward(ff).setCommit(!noCommit);
    if (srcRef != null)     mergeCmd.include(srcRef);
 else     mergeCmd.include(src);
    if (message != null)     mergeCmd.setMessage(message);
    try {
      result=mergeCmd.call();
    }
 catch (    CheckoutConflictException e) {
      result=new MergeResult(e.getConflictingPaths());
    }
  }
 switch (result.getMergeStatus()) {
case ALREADY_UP_TO_DATE:
    if (squash)     outw.print(CLIText.get().nothingToSquash);
  outw.println(CLIText.get().alreadyUpToDate);
break;
case FAST_FORWARD:
ObjectId oldHeadId=oldHead.getObjectId();
if (oldHeadId != null) {
String oldId=oldHeadId.abbreviate(7).name();
String newId=result.getNewHead().abbreviate(7).name();
outw.println(MessageFormat.format(CLIText.get().updating,oldId,newId));
}
outw.println(result.getMergeStatus().toString());
break;
case CHECKOUT_CONFLICT:
outw.println(CLIText.get().mergeCheckoutConflict);
for (String collidingPath : result.getCheckoutConflicts()) outw.println(""String_Node_Str"" + collidingPath);
outw.println(CLIText.get().mergeCheckoutFailed);
break;
case CONFLICTING:
for (String collidingPath : result.getConflicts().keySet()) outw.println(MessageFormat.format(CLIText.get().mergeConflict,collidingPath));
outw.println(CLIText.get().mergeFailed);
break;
case FAILED:
for (Map.Entry<String,MergeFailureReason> entry : result.getFailingPaths().entrySet()) switch (entry.getValue()) {
case DIRTY_WORKTREE:
case DIRTY_INDEX:
outw.println(CLIText.get().dontOverwriteLocalChanges);
outw.println(""String_Node_Str"" + entry.getKey());
break;
case COULD_NOT_DELETE:
outw.println(CLIText.get().cannotDeleteFile);
outw.println(""String_Node_Str"" + entry.getKey());
break;
}
break;
case MERGED:
String name;
if (!isMergedInto(oldHead,src)) name=mergeStrategy.getName();
 else name=""String_Node_Str"";
outw.println(MessageFormat.format(CLIText.get().mergeMadeBy,name));
break;
case MERGED_NOT_COMMITTED:
outw.println(CLIText.get().mergeWentWellStoppedBeforeCommitting);
break;
case MERGED_SQUASHED:
case FAST_FORWARD_SQUASHED:
case MERGED_SQUASHED_NOT_COMMITTED:
outw.println(CLIText.get().mergedSquashed);
outw.println(CLIText.get().mergeWentWellStoppedBeforeCommitting);
break;
case ABORTED:
throw die(CLIText.get().ffNotPossibleAborting);
case NOT_SUPPORTED:
outw.println(MessageFormat.format(CLIText.get().unsupportedOperation,result.toString()));
}
}",0.968899127859141
91286,"@Override protected void run() throws Exception {
  if (all) {
    Map<String,Ref> allRefs=db.getRefDatabase().getRefs(ALL);
    for (    final Ref r : allRefs.values()) {
      outw.println(r.getObjectId().name());
    }
  }
 else {
    if (verify && commits.size() > 1) {
      throw new CmdLineException(CLIText.get().needSingleRevision);
    }
    for (    final ObjectId o : commits) {
      outw.println(o.name());
    }
  }
}","@Override protected void run() throws Exception {
  if (all) {
    Map<String,Ref> allRefs=db.getRefDatabase().getRefs(ALL);
    for (    final Ref r : allRefs.values()) {
      ObjectId objectId=r.getObjectId();
      if (objectId == null) {
        throw new NullPointerException();
      }
      outw.println(objectId.name());
    }
  }
 else {
    if (verify && commits.size() > 1) {
      throw new CmdLineException(CLIText.get().needSingleRevision);
    }
    for (    final ObjectId o : commits) {
      outw.println(o.name());
    }
  }
}",0.8425357873210634
91287,"/** 
 * Write the prepared pack to the supplied stream. <p> At first, this method collects and sorts objects to pack, then deltas search is performed if set up accordingly, finally pack stream is written. </p> <p> All reused objects data checksum (Adler32/CRC32) is computed and validated against existing checksum. </p>
 * @param compressMonitor progress monitor to report object compression work.
 * @param writeMonitor progress monitor to report the number of objects written.
 * @param packStream output stream of pack data. The stream should be buffered by the caller. The caller is responsible for closing the stream.
 * @throws IOException an error occurred reading a local object's data to include in the pack, or writing compressed object data to the output stream.
 * @throws WriteAbortedException the write operation is aborted by {@link PackWriter.ObjectCountCallback}.
 */
public void writePack(ProgressMonitor compressMonitor,ProgressMonitor writeMonitor,OutputStream packStream) throws IOException {
  if (compressMonitor == null)   compressMonitor=NullProgressMonitor.INSTANCE;
  if (writeMonitor == null)   writeMonitor=NullProgressMonitor.INSTANCE;
  excludeInPacks=null;
  excludeInPackLast=null;
  boolean needSearchForReuse=reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());
  if (compressMonitor instanceof BatchingProgressMonitor) {
    long delay=1000;
    if (needSearchForReuse && config.isDeltaCompress())     delay=500;
    ((BatchingProgressMonitor)compressMonitor).setDelayStart(delay,TimeUnit.MILLISECONDS);
  }
  if (needSearchForReuse)   searchForReuse(compressMonitor);
  if (config.isDeltaCompress())   searchForDeltas(compressMonitor);
  crc32=new CRC32();
  final PackOutputStream out=new PackOutputStream(writeMonitor,isIndexDisabled() ? packStream : new CheckedOutputStream(packStream,crc32),this);
  long objCnt=getObjectCount();
  stats.totalObjects=objCnt;
  if (callback != null)   callback.setObjectCount(objCnt);
  beginPhase(PackingPhase.WRITING,writeMonitor,objCnt);
  long writeStart=System.currentTimeMillis();
  try {
    out.writeFileHeader(PACK_VERSION_GENERATED,objCnt);
    out.flush();
    writeObjects(out);
    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {
      for (      Statistics.ObjectType typeStat : stats.objectTypes) {
        if (typeStat == null)         continue;
        stats.thinPackBytes+=typeStat.bytes;
      }
    }
    stats.reusedPacks=Collections.unmodifiableList(cachedPacks);
    for (    CachedPack pack : cachedPacks) {
      long deltaCnt=pack.getDeltaCount();
      stats.reusedObjects+=pack.getObjectCount();
      stats.reusedDeltas+=deltaCnt;
      stats.totalDeltas+=deltaCnt;
      reuseSupport.copyPackAsIs(out,pack);
    }
    writeChecksum(out);
    out.flush();
  }
  finally {
    stats.timeWriting=System.currentTimeMillis() - writeStart;
    stats.depth=depth;
    for (    Statistics.ObjectType typeStat : stats.objectTypes) {
      if (typeStat == null)       continue;
      typeStat.cntDeltas+=typeStat.reusedDeltas;
      stats.reusedObjects+=typeStat.reusedObjects;
      stats.reusedDeltas+=typeStat.reusedDeltas;
      stats.totalDeltas+=typeStat.cntDeltas;
    }
  }
  stats.totalBytes=out.length();
  reader.close();
  endPhase(writeMonitor);
}","/** 
 * Write the prepared pack to the supplied stream. <p> At first, this method collects and sorts objects to pack, then deltas search is performed if set up accordingly, finally pack stream is written. </p> <p> All reused objects data checksum (Adler32/CRC32) is computed and validated against existing checksum. </p>
 * @param compressMonitor progress monitor to report object compression work.
 * @param writeMonitor progress monitor to report the number of objects written.
 * @param packStream output stream of pack data. The stream should be buffered by the caller. The caller is responsible for closing the stream.
 * @throws IOException an error occurred reading a local object's data to include in the pack, or writing compressed object data to the output stream.
 * @throws WriteAbortedException the write operation is aborted by {@link ObjectCountCallback}.
 */
public void writePack(ProgressMonitor compressMonitor,ProgressMonitor writeMonitor,OutputStream packStream) throws IOException {
  if (compressMonitor == null)   compressMonitor=NullProgressMonitor.INSTANCE;
  if (writeMonitor == null)   writeMonitor=NullProgressMonitor.INSTANCE;
  excludeInPacks=null;
  excludeInPackLast=null;
  boolean needSearchForReuse=reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());
  if (compressMonitor instanceof BatchingProgressMonitor) {
    long delay=1000;
    if (needSearchForReuse && config.isDeltaCompress())     delay=500;
    ((BatchingProgressMonitor)compressMonitor).setDelayStart(delay,TimeUnit.MILLISECONDS);
  }
  if (needSearchForReuse)   searchForReuse(compressMonitor);
  if (config.isDeltaCompress())   searchForDeltas(compressMonitor);
  crc32=new CRC32();
  final PackOutputStream out=new PackOutputStream(writeMonitor,isIndexDisabled() ? packStream : new CheckedOutputStream(packStream,crc32),this);
  long objCnt=getObjectCount();
  stats.totalObjects=objCnt;
  if (callback != null)   callback.setObjectCount(objCnt);
  beginPhase(PackingPhase.WRITING,writeMonitor,objCnt);
  long writeStart=System.currentTimeMillis();
  try {
    out.writeFileHeader(PACK_VERSION_GENERATED,objCnt);
    out.flush();
    writeObjects(out);
    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {
      for (      Statistics.ObjectType typeStat : stats.objectTypes) {
        if (typeStat == null)         continue;
        stats.thinPackBytes+=typeStat.bytes;
      }
    }
    stats.reusedPacks=Collections.unmodifiableList(cachedPacks);
    for (    CachedPack pack : cachedPacks) {
      long deltaCnt=pack.getDeltaCount();
      stats.reusedObjects+=pack.getObjectCount();
      stats.reusedDeltas+=deltaCnt;
      stats.totalDeltas+=deltaCnt;
      reuseSupport.copyPackAsIs(out,pack);
    }
    writeChecksum(out);
    out.flush();
  }
  finally {
    stats.timeWriting=System.currentTimeMillis() - writeStart;
    stats.depth=depth;
    for (    Statistics.ObjectType typeStat : stats.objectTypes) {
      if (typeStat == null)       continue;
      typeStat.cntDeltas+=typeStat.reusedDeltas;
      stats.reusedObjects+=typeStat.reusedObjects;
      stats.reusedDeltas+=typeStat.reusedDeltas;
      stats.totalDeltas+=typeStat.cntDeltas;
    }
  }
  stats.totalBytes=out.length();
  reader.close();
  endPhase(writeMonitor);
}",0.9983315637797664
91288,"/** 
 * Write the prepared pack to the supplied stream. <p> At first, this method collects and sorts objects to pack, then deltas search is performed if set up accordingly, finally pack stream is written. </p> <p> All reused objects data checksum (Adler32/CRC32) is computed and validated against existing checksum. </p>
 * @param compressMonitor progress monitor to report object compression work.
 * @param writeMonitor progress monitor to report the number of objects written.
 * @param packStream output stream of pack data. The stream should be buffered by the caller. The caller is responsible for closing the stream.
 * @throws IOException an error occurred reading a local object's data to include in the pack, or writing compressed object data to the output stream.
 * @throws WriteAbortedException the write operation is aborted by {@link PackWriter.ObjectCountCallback}.
 */
public void writePack(ProgressMonitor compressMonitor,ProgressMonitor writeMonitor,OutputStream packStream) throws IOException {
  if (compressMonitor == null)   compressMonitor=NullProgressMonitor.INSTANCE;
  if (writeMonitor == null)   writeMonitor=NullProgressMonitor.INSTANCE;
  excludeInPacks=null;
  excludeInPackLast=null;
  boolean needSearchForReuse=reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());
  if (compressMonitor instanceof BatchingProgressMonitor) {
    long delay=1000;
    if (needSearchForReuse && config.isDeltaCompress())     delay=500;
    ((BatchingProgressMonitor)compressMonitor).setDelayStart(delay,TimeUnit.MILLISECONDS);
  }
  if (needSearchForReuse)   searchForReuse(compressMonitor);
  if (config.isDeltaCompress())   searchForDeltas(compressMonitor);
  crc32=new CRC32();
  final PackOutputStream out=new PackOutputStream(writeMonitor,isIndexDisabled() ? packStream : new CheckedOutputStream(packStream,crc32),this);
  long objCnt=getObjectCount();
  stats.totalObjects=objCnt;
  if (callback != null)   callback.setObjectCount(objCnt);
  beginPhase(PackingPhase.WRITING,writeMonitor,objCnt);
  long writeStart=System.currentTimeMillis();
  try {
    out.writeFileHeader(PACK_VERSION_GENERATED,objCnt);
    out.flush();
    writeObjects(out);
    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {
      for (      Statistics.ObjectType typeStat : stats.objectTypes) {
        if (typeStat == null)         continue;
        stats.thinPackBytes+=typeStat.bytes;
      }
    }
    stats.reusedPacks=Collections.unmodifiableList(cachedPacks);
    for (    CachedPack pack : cachedPacks) {
      long deltaCnt=pack.getDeltaCount();
      stats.reusedObjects+=pack.getObjectCount();
      stats.reusedDeltas+=deltaCnt;
      stats.totalDeltas+=deltaCnt;
      reuseSupport.copyPackAsIs(out,pack);
    }
    writeChecksum(out);
    out.flush();
  }
  finally {
    stats.timeWriting=System.currentTimeMillis() - writeStart;
    stats.depth=depth;
    for (    Statistics.ObjectType typeStat : stats.objectTypes) {
      if (typeStat == null)       continue;
      typeStat.cntDeltas+=typeStat.reusedDeltas;
      stats.reusedObjects+=typeStat.reusedObjects;
      stats.reusedDeltas+=typeStat.reusedDeltas;
      stats.totalDeltas+=typeStat.cntDeltas;
    }
  }
  stats.totalBytes=out.length();
  reader.close();
  endPhase(writeMonitor);
}","/** 
 * Write the prepared pack to the supplied stream. <p> At first, this method collects and sorts objects to pack, then deltas search is performed if set up accordingly, finally pack stream is written. </p> <p> All reused objects data checksum (Adler32/CRC32) is computed and validated against existing checksum. </p>
 * @param compressMonitor progress monitor to report object compression work.
 * @param writeMonitor progress monitor to report the number of objects written.
 * @param packStream output stream of pack data. The stream should be buffered by the caller. The caller is responsible for closing the stream.
 * @throws IOException an error occurred reading a local object's data to include in the pack, or writing compressed object data to the output stream.
 * @throws WriteAbortedException the write operation is aborted by {@link ObjectCountCallback}.
 */
public void writePack(ProgressMonitor compressMonitor,ProgressMonitor writeMonitor,OutputStream packStream) throws IOException {
  if (compressMonitor == null)   compressMonitor=NullProgressMonitor.INSTANCE;
  if (writeMonitor == null)   writeMonitor=NullProgressMonitor.INSTANCE;
  excludeInPacks=null;
  excludeInPackLast=null;
  boolean needSearchForReuse=reuseSupport != null && (reuseDeltas || config.isReuseObjects() || !cachedPacks.isEmpty());
  if (compressMonitor instanceof BatchingProgressMonitor) {
    long delay=1000;
    if (needSearchForReuse && config.isDeltaCompress())     delay=500;
    ((BatchingProgressMonitor)compressMonitor).setDelayStart(delay,TimeUnit.MILLISECONDS);
  }
  if (needSearchForReuse)   searchForReuse(compressMonitor);
  if (config.isDeltaCompress())   searchForDeltas(compressMonitor);
  crc32=new CRC32();
  final PackOutputStream out=new PackOutputStream(writeMonitor,isIndexDisabled() ? packStream : new CheckedOutputStream(packStream,crc32),this);
  long objCnt=getObjectCount();
  stats.totalObjects=objCnt;
  if (callback != null)   callback.setObjectCount(objCnt);
  beginPhase(PackingPhase.WRITING,writeMonitor,objCnt);
  long writeStart=System.currentTimeMillis();
  try {
    out.writeFileHeader(PACK_VERSION_GENERATED,objCnt);
    out.flush();
    writeObjects(out);
    if (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {
      for (      Statistics.ObjectType typeStat : stats.objectTypes) {
        if (typeStat == null)         continue;
        stats.thinPackBytes+=typeStat.bytes;
      }
    }
    stats.reusedPacks=Collections.unmodifiableList(cachedPacks);
    for (    CachedPack pack : cachedPacks) {
      long deltaCnt=pack.getDeltaCount();
      stats.reusedObjects+=pack.getObjectCount();
      stats.reusedDeltas+=deltaCnt;
      stats.totalDeltas+=deltaCnt;
      reuseSupport.copyPackAsIs(out,pack);
    }
    writeChecksum(out);
    out.flush();
  }
  finally {
    stats.timeWriting=System.currentTimeMillis() - writeStart;
    stats.depth=depth;
    for (    Statistics.ObjectType typeStat : stats.objectTypes) {
      if (typeStat == null)       continue;
      typeStat.cntDeltas+=typeStat.reusedDeltas;
      stats.reusedObjects+=typeStat.reusedObjects;
      stats.reusedDeltas+=typeStat.reusedDeltas;
      stats.totalDeltas+=typeStat.cntDeltas;
    }
  }
  stats.totalBytes=out.length();
  reader.close();
  endPhase(writeMonitor);
}",0.9983315637797664
91289,"/** 
 * Executes the   {@code Reset} command. Each instance of this class shouldonly be used for one invocation of the command. Don't call this method twice on an instance.
 * @return the Ref after reset
 * @throws GitAPIException
 */
public Ref call() throws GitAPIException, CheckoutConflictException {
  checkCallable();
  try {
    RepositoryState state=repo.getRepositoryState();
    final boolean merging=state.equals(RepositoryState.MERGING) || state.equals(RepositoryState.MERGING_RESOLVED);
    final boolean cherryPicking=state.equals(RepositoryState.CHERRY_PICKING) || state.equals(RepositoryState.CHERRY_PICKING_RESOLVED);
    final boolean reverting=state.equals(RepositoryState.REVERTING) || state.equals(RepositoryState.REVERTING_RESOLVED);
    final ObjectId commitId=resolveRefToCommitId();
    if (ref != null && commitId == null) {
      throw new JGitInternalException(""String_Node_Str"" + ref + ""String_Node_Str"");
    }
    final ObjectId commitTree;
    if (commitId != null)     commitTree=parseCommit(commitId).getTree();
 else     commitTree=null;
    if (!filepaths.isEmpty()) {
      resetIndexForPaths(commitTree);
      setCallable(false);
      return repo.getRef(Constants.HEAD);
    }
    final Ref result;
    if (commitId != null) {
      final RefUpdate ru=repo.updateRef(Constants.HEAD);
      ru.setNewObjectId(commitId);
      String refName=Repository.shortenRefName(getRefOrHEAD());
      String message=refName + ""String_Node_Str"" + Constants.HEAD;
      ru.setRefLogMessage(message,false);
      if (ru.forceUpdate() == RefUpdate.Result.LOCK_FAILURE)       throw new JGitInternalException(MessageFormat.format(JGitText.get().cannotLock,ru.getName()));
      ObjectId origHead=ru.getOldObjectId();
      if (origHead != null)       repo.writeOrigHead(origHead);
      result=ru.getRef();
    }
 else {
      result=repo.getRef(Constants.HEAD);
    }
    if (mode == null)     mode=ResetType.MIXED;
switch (mode) {
case HARD:
      checkoutIndex(commitTree);
    break;
case MIXED:
  resetIndex(commitTree);
break;
case SOFT:
break;
case KEEP:
case MERGE:
throw new UnsupportedOperationException();
}
if (mode != ResetType.SOFT) {
if (merging) resetMerge();
 else if (cherryPicking) resetCherryPick();
 else if (reverting) resetRevert();
 else if (repo.readSquashCommitMsg() != null) repo.writeSquashCommitMsg(null);
}
setCallable(false);
return result;
}
 catch (IOException e) {
throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfResetCommand,e);
}
}","/** 
 * Executes the   {@code Reset} command. Each instance of this class shouldonly be used for one invocation of the command. Don't call this method twice on an instance.
 * @return the Ref after reset
 * @throws GitAPIException
 */
public Ref call() throws GitAPIException, CheckoutConflictException {
  checkCallable();
  try {
    RepositoryState state=repo.getRepositoryState();
    final boolean merging=state.equals(RepositoryState.MERGING) || state.equals(RepositoryState.MERGING_RESOLVED);
    final boolean cherryPicking=state.equals(RepositoryState.CHERRY_PICKING) || state.equals(RepositoryState.CHERRY_PICKING_RESOLVED);
    final boolean reverting=state.equals(RepositoryState.REVERTING) || state.equals(RepositoryState.REVERTING_RESOLVED);
    final ObjectId commitId=resolveRefToCommitId();
    if (ref != null && commitId == null) {
      throw new JGitInternalException(""String_Node_Str"" + ref + ""String_Node_Str"");
    }
    final ObjectId commitTree;
    if (commitId != null)     commitTree=parseCommit(commitId).getTree();
 else     commitTree=null;
    if (!filepaths.isEmpty()) {
      resetIndexForPaths(commitTree);
      setCallable(false);
      return repo.getRef(Constants.HEAD);
    }
    final Ref result;
    if (commitId != null) {
      final RefUpdate ru=repo.updateRef(Constants.HEAD);
      ru.setNewObjectId(commitId);
      String refName=Repository.shortenRefName(getRefOrHEAD());
      String message=refName + ""String_Node_Str"" + Constants.HEAD;
      ru.setRefLogMessage(message,false);
      if (ru.forceUpdate() == RefUpdate.Result.LOCK_FAILURE)       throw new JGitInternalException(MessageFormat.format(JGitText.get().cannotLock,ru.getName()));
      ObjectId origHead=ru.getOldObjectId();
      if (origHead != null)       repo.writeOrigHead(origHead);
      result=ru.getRef();
    }
 else {
      result=repo.getRef(Constants.HEAD);
    }
    if (mode == null)     mode=ResetType.MIXED;
switch (mode) {
case HARD:
      checkoutIndex(commitTree);
    break;
case MIXED:
  resetIndex(commitTree);
break;
case SOFT:
break;
case KEEP:
case MERGE:
throw new UnsupportedOperationException();
}
if (mode != ResetType.SOFT) {
if (merging) resetMerge();
 else if (cherryPicking) resetCherryPick();
 else if (reverting) resetRevert();
 else if (repo.readSquashCommitMsg() != null) repo.writeSquashCommitMsg(null);
}
setCallable(false);
return result;
}
 catch (IOException e) {
throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfResetCommand,e.getMessage()),e);
}
}",0.992712231632854
91290,"/** 
 * Returns information about the conflicts which occurred during a  {@link MergeCommand}. The returned value maps the path of a conflicting file to a two-dimensional int-array of line-numbers telling where in the file conflict markers for which merged commit can be found. <p> If the returned value contains a mapping ""path""-&gt;[x][y]=z then this means <ul> <li>the file with path ""path"" contains conflicts</li> <li>if y &lt; ""number of merged commits"": for conflict number x in this file the chunk which was copied from commit number y starts on line number z. All numberings and line numbers start with 0.</li> <li>if y == ""number of merged commits"": the first non-conflicting line after conflict number x starts at line number z</li> </ul> <p> Example code how to parse this data: <pre> MergeResult m=...; Map&lt;String, int[][]&gt; allConflicts = m.getConflicts(); for (String path : allConflicts.keySet()) { int[][] c = allConflicts.get(path); System.out.println(""Conflicts in file "" + path); for (int i = 0; i < c.length; ++i) { System.out.println(""  Conflict #"" + i); for (int j = 0; j &lt;	 (c[i].length) - 1; ++j) { if (c[i][j] >= 0) System.out.println(""    Chunk for "" + m.getMergedCommits()[j] + "" starts on line #"" + c[i][j]); } } } </pre>
 * @return the conflicts or <code>null</code> if no conflict occurred
 */
public Map<String,int[][]> getConflicts(){
  return conflicts;
}","/** 
 * Returns information about the conflicts which occurred during a  {@link MergeCommand}. The returned value maps the path of a conflicting file to a two-dimensional int-array of line-numbers telling where in the file conflict markers for which merged commit can be found. <p> If the returned value contains a mapping ""path""-&gt;[x][y]=z then this means <ul> <li>the file with path ""path"" contains conflicts</li> <li>if y &lt; ""number of merged commits"": for conflict number x in this file the chunk which was copied from commit number y starts on line number z. All numberings and line numbers start with 0.</li> <li>if y == ""number of merged commits"": the first non-conflicting line after conflict number x starts at line number z</li> </ul> <p> Example code how to parse this data: <pre> MergeResult m=...; Map&lt;String, int[][]&gt; allConflicts = m.getConflicts(); for (String path : allConflicts.keySet()) { int[][] c = allConflicts.get(path); System.out.println(""Conflicts in file "" + path); for (int i = 0; i &lt; c.length; ++i) { System.out.println(""  Conflict #"" + i); for (int j = 0; j &lt; (c[i].length) - 1; ++j) { if (c[i][j] &gt;= 0) System.out.println(""    Chunk for "" + m.getMergedCommits()[j] + "" starts on line #"" + c[i][j]); } } } </pre>
 * @return the conflicts or <code>null</code> if no conflict occurred
 */
public Map<String,int[][]> getConflicts(){
  return conflicts;
}",0.9960672148730784
91291,"/** 
 * Processes one path and tries to merge. This method will do all do all trivial (not content) merges and will also detect if a merge will fail. The merge will fail when one of the following is true <ul> <li>the index entry does not match the entry in ours. When merging one branch into the current HEAD, ours will point to HEAD and theirs will point to the other branch. It is assumed that the index matches the HEAD because it will only not match HEAD if it was populated before the merge operation. But the merge commit should not accidentally contain modifications done before the merge. Check the <a href= ""http://www.kernel.org/pub/software/scm/git/docs/git-read-tree.html#_3_way_merge"" >git read-tree</a> documentation for further explanations.</li> <li>A conflict was detected and the working-tree file is dirty. When a conflict is detected the content-merge algorithm will try to write a merged version into the working-tree. If the file is dirty we would override unsaved data.</li>
 * @param base the common base for ours and theirs
 * @param ours the ours side of the merge. When merging a branch into the HEAD ours will point to HEAD
 * @param theirs the theirs side of the merge. When merging a branch into the current HEAD theirs will point to the branch which is merged into HEAD.
 * @param index the index entry
 * @param work the file in the working tree
 * @param ignoreConflicts see {@link ResolveMerger#mergeTrees(AbstractTreeIterator,RevTree,RevTree,boolean)}
 * @return <code>false</code> if the merge will fail because the index entrydidn't match ours or the working-dir file was dirty and a conflict occurred
 * @throws MissingObjectException
 * @throws IncorrectObjectTypeException
 * @throws CorruptObjectException
 * @throws IOException
 * @since 3.5
 */
protected boolean processEntry(CanonicalTreeParser base,CanonicalTreeParser ours,CanonicalTreeParser theirs,DirCacheBuildIterator index,WorkingTreeIterator work,boolean ignoreConflicts) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {
  enterSubtree=true;
  final int modeO=tw.getRawMode(T_OURS);
  final int modeT=tw.getRawMode(T_THEIRS);
  final int modeB=tw.getRawMode(T_BASE);
  if (modeO == 0 && modeT == 0 && modeB == 0)   return true;
  if (isIndexDirty())   return false;
  DirCacheEntry ourDce=null;
  if (index == null || index.getDirCacheEntry() == null) {
    if (nonTree(modeO)) {
      ourDce=new DirCacheEntry(tw.getRawPath());
      ourDce.setObjectId(tw.getObjectId(T_OURS));
      ourDce.setFileMode(tw.getFileMode(T_OURS));
    }
  }
 else {
    ourDce=index.getDirCacheEntry();
  }
  if (nonTree(modeO) && nonTree(modeT) && tw.idEqual(T_OURS,T_THEIRS)) {
    if (modeO == modeT) {
      keep(ourDce);
      return true;
    }
 else {
      int newMode=mergeFileModes(modeB,modeO,modeT);
      if (newMode != FileMode.MISSING.getBits()) {
        if (newMode == modeO)         keep(ourDce);
 else {
          if (isWorktreeDirty(work,ourDce))           return false;
          DirCacheEntry e=add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_0,0,0);
          toBeCheckedOut.put(tw.getPathString(),e);
        }
        return true;
      }
 else {
        add(tw.getRawPath(),base,DirCacheEntry.STAGE_1,0,0);
        add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2,0,0);
        add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3,0,0);
        unmergedPaths.add(tw.getPathString());
        mergeResults.put(tw.getPathString(),new MergeResult<RawText>(Collections.<RawText>emptyList()));
      }
      return true;
    }
  }
  if (nonTree(modeO) && modeB == modeT && tw.idEqual(T_BASE,T_THEIRS)) {
    keep(ourDce);
    return true;
  }
  if (modeB == modeO && tw.idEqual(T_BASE,T_OURS)) {
    if (isWorktreeDirty(work,ourDce))     return false;
    if (nonTree(modeT)) {
      DirCacheEntry e=add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_0,0,0);
      if (e != null)       toBeCheckedOut.put(tw.getPathString(),e);
      return true;
    }
 else     if (modeT == 0 && modeB != 0) {
      if (tw.getTreeCount() > T_FILE && tw.getRawMode(T_FILE) == 0)       return true;
      toBeDeleted.add(tw.getPathString());
      return true;
    }
  }
  if (tw.isSubtree()) {
    if (nonTree(modeO) && !nonTree(modeT)) {
      if (nonTree(modeB))       add(tw.getRawPath(),base,DirCacheEntry.STAGE_1,0,0);
      add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2,0,0);
      unmergedPaths.add(tw.getPathString());
      enterSubtree=false;
      return true;
    }
    if (nonTree(modeT) && !nonTree(modeO)) {
      if (nonTree(modeB))       add(tw.getRawPath(),base,DirCacheEntry.STAGE_1,0,0);
      add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3,0,0);
      unmergedPaths.add(tw.getPathString());
      enterSubtree=false;
      return true;
    }
    if (!nonTree(modeO))     return true;
  }
  if (nonTree(modeO) && nonTree(modeT)) {
    if (isWorktreeDirty(work,ourDce))     return false;
    if (isGitLink(modeO) || isGitLink(modeT)) {
      add(tw.getRawPath(),base,DirCacheEntry.STAGE_1,0,0);
      add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2,0,0);
      add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3,0,0);
      unmergedPaths.add(tw.getPathString());
      return true;
    }
    MergeResult<RawText> result=contentMerge(base,ours,theirs);
    if (ignoreConflicts)     result.setContainsConflicts(false);
    File of=writeMergedFile(result);
    updateIndex(base,ours,theirs,result,of);
    if (result.containsConflicts() && !ignoreConflicts)     unmergedPaths.add(tw.getPathString());
    modifiedFiles.add(tw.getPathString());
  }
 else   if (modeO != modeT) {
    if (((modeO != 0 && !tw.idEqual(T_BASE,T_OURS)) || (modeT != 0 && !tw.idEqual(T_BASE,T_THEIRS)))) {
      add(tw.getRawPath(),base,DirCacheEntry.STAGE_1,0,0);
      add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2,0,0);
      DirCacheEntry e=add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3,0,0);
      if (modeO == 0) {
        if (isWorktreeDirty(work,ourDce))         return false;
        if (nonTree(modeT)) {
          if (e != null)           toBeCheckedOut.put(tw.getPathString(),e);
        }
      }
      unmergedPaths.add(tw.getPathString());
      mergeResults.put(tw.getPathString(),contentMerge(base,ours,theirs));
    }
  }
  return true;
}","/** 
 * Processes one path and tries to merge. This method will do all do all trivial (not content) merges and will also detect if a merge will fail. The merge will fail when one of the following is true <ul> <li>the index entry does not match the entry in ours. When merging one branch into the current HEAD, ours will point to HEAD and theirs will point to the other branch. It is assumed that the index matches the HEAD because it will only not match HEAD if it was populated before the merge operation. But the merge commit should not accidentally contain modifications done before the merge. Check the <a href= ""http://www.kernel.org/pub/software/scm/git/docs/git-read-tree.html#_3_way_merge"" >git read-tree</a> documentation for further explanations.</li> <li>A conflict was detected and the working-tree file is dirty. When a conflict is detected the content-merge algorithm will try to write a merged version into the working-tree. If the file is dirty we would override unsaved data.</li> </ul>
 * @param base the common base for ours and theirs
 * @param ours the ours side of the merge. When merging a branch into the HEAD ours will point to HEAD
 * @param theirs the theirs side of the merge. When merging a branch into the current HEAD theirs will point to the branch which is merged into HEAD.
 * @param index the index entry
 * @param work the file in the working tree
 * @param ignoreConflicts see {@link ResolveMerger#mergeTrees(AbstractTreeIterator,RevTree,RevTree,boolean)}
 * @return <code>false</code> if the merge will fail because the index entrydidn't match ours or the working-dir file was dirty and a conflict occurred
 * @throws MissingObjectException
 * @throws IncorrectObjectTypeException
 * @throws CorruptObjectException
 * @throws IOException
 * @since 3.5
 */
protected boolean processEntry(CanonicalTreeParser base,CanonicalTreeParser ours,CanonicalTreeParser theirs,DirCacheBuildIterator index,WorkingTreeIterator work,boolean ignoreConflicts) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {
  enterSubtree=true;
  final int modeO=tw.getRawMode(T_OURS);
  final int modeT=tw.getRawMode(T_THEIRS);
  final int modeB=tw.getRawMode(T_BASE);
  if (modeO == 0 && modeT == 0 && modeB == 0)   return true;
  if (isIndexDirty())   return false;
  DirCacheEntry ourDce=null;
  if (index == null || index.getDirCacheEntry() == null) {
    if (nonTree(modeO)) {
      ourDce=new DirCacheEntry(tw.getRawPath());
      ourDce.setObjectId(tw.getObjectId(T_OURS));
      ourDce.setFileMode(tw.getFileMode(T_OURS));
    }
  }
 else {
    ourDce=index.getDirCacheEntry();
  }
  if (nonTree(modeO) && nonTree(modeT) && tw.idEqual(T_OURS,T_THEIRS)) {
    if (modeO == modeT) {
      keep(ourDce);
      return true;
    }
 else {
      int newMode=mergeFileModes(modeB,modeO,modeT);
      if (newMode != FileMode.MISSING.getBits()) {
        if (newMode == modeO)         keep(ourDce);
 else {
          if (isWorktreeDirty(work,ourDce))           return false;
          DirCacheEntry e=add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_0,0,0);
          toBeCheckedOut.put(tw.getPathString(),e);
        }
        return true;
      }
 else {
        add(tw.getRawPath(),base,DirCacheEntry.STAGE_1,0,0);
        add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2,0,0);
        add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3,0,0);
        unmergedPaths.add(tw.getPathString());
        mergeResults.put(tw.getPathString(),new MergeResult<RawText>(Collections.<RawText>emptyList()));
      }
      return true;
    }
  }
  if (nonTree(modeO) && modeB == modeT && tw.idEqual(T_BASE,T_THEIRS)) {
    keep(ourDce);
    return true;
  }
  if (modeB == modeO && tw.idEqual(T_BASE,T_OURS)) {
    if (isWorktreeDirty(work,ourDce))     return false;
    if (nonTree(modeT)) {
      DirCacheEntry e=add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_0,0,0);
      if (e != null)       toBeCheckedOut.put(tw.getPathString(),e);
      return true;
    }
 else     if (modeT == 0 && modeB != 0) {
      if (tw.getTreeCount() > T_FILE && tw.getRawMode(T_FILE) == 0)       return true;
      toBeDeleted.add(tw.getPathString());
      return true;
    }
  }
  if (tw.isSubtree()) {
    if (nonTree(modeO) && !nonTree(modeT)) {
      if (nonTree(modeB))       add(tw.getRawPath(),base,DirCacheEntry.STAGE_1,0,0);
      add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2,0,0);
      unmergedPaths.add(tw.getPathString());
      enterSubtree=false;
      return true;
    }
    if (nonTree(modeT) && !nonTree(modeO)) {
      if (nonTree(modeB))       add(tw.getRawPath(),base,DirCacheEntry.STAGE_1,0,0);
      add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3,0,0);
      unmergedPaths.add(tw.getPathString());
      enterSubtree=false;
      return true;
    }
    if (!nonTree(modeO))     return true;
  }
  if (nonTree(modeO) && nonTree(modeT)) {
    if (isWorktreeDirty(work,ourDce))     return false;
    if (isGitLink(modeO) || isGitLink(modeT)) {
      add(tw.getRawPath(),base,DirCacheEntry.STAGE_1,0,0);
      add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2,0,0);
      add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3,0,0);
      unmergedPaths.add(tw.getPathString());
      return true;
    }
    MergeResult<RawText> result=contentMerge(base,ours,theirs);
    if (ignoreConflicts)     result.setContainsConflicts(false);
    File of=writeMergedFile(result);
    updateIndex(base,ours,theirs,result,of);
    if (result.containsConflicts() && !ignoreConflicts)     unmergedPaths.add(tw.getPathString());
    modifiedFiles.add(tw.getPathString());
  }
 else   if (modeO != modeT) {
    if (((modeO != 0 && !tw.idEqual(T_BASE,T_OURS)) || (modeT != 0 && !tw.idEqual(T_BASE,T_THEIRS)))) {
      add(tw.getRawPath(),base,DirCacheEntry.STAGE_1,0,0);
      add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2,0,0);
      DirCacheEntry e=add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3,0,0);
      if (modeO == 0) {
        if (isWorktreeDirty(work,ourDce))         return false;
        if (nonTree(modeT)) {
          if (e != null)           toBeCheckedOut.put(tw.getPathString(),e);
        }
      }
      unmergedPaths.add(tw.getPathString());
      mergeResults.put(tw.getPathString(),contentMerge(base,ours,theirs));
    }
  }
  return true;
}",0.9995224450811844
91292,"/** 
 * Get the default SSH session
 * @return a remote session
 * @throws TransportException in case of error with opening SSH session
 */
protected RemoteSession getSession() throws TransportException {
  if (sock != null)   return sock;
  final int tms=getTimeout() > 0 ? getTimeout() * 1000 : 0;
  sock=sch.getSession(uri,getCredentialsProvider(),local.getFS(),tms);
  return sock;
}","/** 
 * Get the default SSH session
 * @return a remote session
 * @throws TransportException in case of error with opening SSH session
 */
protected RemoteSession getSession() throws TransportException {
  if (sock != null)   return sock;
  final int tms=getTimeout() > 0 ? getTimeout() * 1000 : 0;
  final FS fs=local == null ? FS.detect() : local.getFS();
  sock=sch.getSession(uri,getCredentialsProvider(),fs,tms);
  return sock;
}",0.9099756690997568
91293,"/** 
 * Create a new transport instance.
 * @param local the repository this instance will fetch into, or push out of. This must be the repository passed to {@link #open(Repository,URIish)}.
 * @param uri the URI used to access the remote repository. This must be the URI passed to  {@link #open(Repository,URIish)}.
 */
protected SshTransport(Repository local,URIish uri){
  super(local,uri);
  sch=SshSessionFactory.getInstance();
}","/** 
 * Create a new transport instance without a local repository.
 * @param uri the URI used to access the remote repository. This must be theURI passed to  {@link #open(URIish)}.
 * @since 3.5
 */
protected SshTransport(URIish uri){
  super(uri);
  sch=SshSessionFactory.getInstance();
}",0.4696132596685083
91294,"/** 
 * Create a new transport instance.
 * @param local the repository this instance will fetch into, or push out of. This must be the repository passed to {@link #open(Repository,URIish)}.
 * @param uri the URI used to access the remote repository. This must be the URI passed to  {@link #open(Repository,URIish)}.
 */
protected TcpTransport(Repository local,URIish uri){
  super(local,uri);
}","/** 
 * Create a new transport instance without a local repository.
 * @param uri the URI used to access the remote repository. This must be theURI passed to  {@link #open(URIish)}.
 * @since 3.5
 */
protected TcpTransport(URIish uri){
  super(uri);
}",0.4705882352941176
91295,"TransportGitAnon(final Repository local,final URIish uri){
  super(local,uri);
}","TransportGitAnon(final URIish uri){
  super(uri);
}",0.7786259541984732
91296,"public Transport open(URIish uri,Repository local,String remoteName) throws NotSupportedException {
  return new TransportGitAnon(local,uri);
}","@Override public Transport open(URIish uri) throws NotSupportedException, TransportException {
  return new TransportGitAnon(uri);
}",0.7418181818181818
91297,"TransportGitSsh(final Repository local,final URIish uri){
  super(local,uri);
  if (useExtSession()) {
    setSshSessionFactory(new SshSessionFactory(){
      @Override public RemoteSession getSession(      URIish uri2,      CredentialsProvider credentialsProvider,      FS fs,      int tms) throws TransportException {
        return new ExtSession();
      }
    }
);
  }
}","TransportGitSsh(final URIish uri){
  super(uri);
  initSshSessionFactory();
}",0.336283185840708
91298,"public Transport open(URIish uri,Repository local,String remoteName) throws NotSupportedException {
  return new TransportGitSsh(local,uri);
}","@Override public Transport open(URIish uri) throws NotSupportedException, TransportException {
  return new TransportGitSsh(uri);
}",0.73992673992674
91299,"/** 
 * Get the default SSH session
 * @return a remote session
 * @throws TransportException in case of error with opening SSH session
 */
protected RemoteSession getSession() throws TransportException {
  if (sock != null)   return sock;
  final int tms=getTimeout() > 0 ? getTimeout() * 1000 : 0;
  sock=sch.getSession(uri,getCredentialsProvider(),local.getFS(),tms);
  return sock;
}","/** 
 * Get the default SSH session
 * @return a remote session
 * @throws TransportException in case of error with opening SSH session
 */
protected RemoteSession getSession() throws TransportException {
  if (sock != null)   return sock;
  final int tms=getTimeout() > 0 ? getTimeout() * 1000 : 0;
  final FS fs=local == null ? FS.detect() : local.getFS();
  sock=sch.getSession(uri,getCredentialsProvider(),fs,tms);
  return sock;
}",0.9099756690997568
91300,"/** 
 * Create a new transport instance.
 * @param local the repository this instance will fetch into, or push out of. This must be the repository passed to {@link #open(Repository,URIish)}.
 * @param uri the URI used to access the remote repository. This must be the URI passed to  {@link #open(Repository,URIish)}.
 */
protected SshTransport(Repository local,URIish uri){
  super(local,uri);
  sch=SshSessionFactory.getInstance();
}","/** 
 * Create a new transport instance without a local repository.
 * @param uri the URI used to access the remote repository. This must be theURI passed to  {@link #open(URIish)}.
 * @since 3.5
 */
protected SshTransport(URIish uri){
  super(uri);
  sch=SshSessionFactory.getInstance();
}",0.4696132596685083
91301,"/** 
 * Create a new transport instance.
 * @param local the repository this instance will fetch into, or push out of. This must be the repository passed to {@link #open(Repository,URIish)}.
 * @param uri the URI used to access the remote repository. This must be the URI passed to  {@link #open(Repository,URIish)}.
 */
protected TcpTransport(Repository local,URIish uri){
  super(local,uri);
}","/** 
 * Create a new transport instance without a local repository.
 * @param uri the URI used to access the remote repository. This must be theURI passed to  {@link #open(URIish)}.
 * @since 3.5
 */
protected TcpTransport(URIish uri){
  super(uri);
}",0.4705882352941176
91302,"TransportGitAnon(final Repository local,final URIish uri){
  super(local,uri);
}","TransportGitAnon(final URIish uri){
  super(uri);
}",0.7786259541984732
91303,"public Transport open(URIish uri,Repository local,String remoteName) throws NotSupportedException {
  return new TransportGitAnon(local,uri);
}","@Override public Transport open(URIish uri) throws NotSupportedException, TransportException {
  return new TransportGitAnon(uri);
}",0.7418181818181818
91304,"TransportGitSsh(final Repository local,final URIish uri){
  super(local,uri);
  if (useExtSession()) {
    setSshSessionFactory(new SshSessionFactory(){
      @Override public RemoteSession getSession(      URIish uri2,      CredentialsProvider credentialsProvider,      FS fs,      int tms) throws TransportException {
        return new ExtSession();
      }
    }
);
  }
}","TransportGitSsh(final URIish uri){
  super(uri);
  initSshSessionFactory();
}",0.336283185840708
91305,"public Transport open(URIish uri,Repository local,String remoteName) throws NotSupportedException {
  return new TransportGitSsh(local,uri);
}","@Override public Transport open(URIish uri) throws NotSupportedException, TransportException {
  return new TransportGitSsh(uri);
}",0.73992673992674
91306,"static void carryFlags(RevCommit c,final int carry){
  for (; ; ) {
    final RevCommit[] pList=c.parents;
    if (pList == null)     return;
    final int n=pList.length;
    if (n == 0)     return;
    for (int i=1; i < n; i++) {
      final RevCommit p=pList[i];
      if ((p.flags & carry) == carry)       continue;
      p.flags|=carry;
      carryFlags(p,carry);
    }
    c=pList[0];
    if ((c.flags & carry) == carry)     return;
    c.flags|=carry;
  }
}","static void carryFlags(RevCommit c,int carry){
  FIFORevQueue q=carryFlags1(c,carry,0);
  if (q != null)   slowCarryFlags(q,carry);
}",0.3350083752093802
91307,"/** 
 * Test if the supplied path matches (being suffix of) the current entry's path. <p> This method tests that the supplied path is exactly equal to the current entry, or is relative to one of entry's parent directories. It is faster to use this method then to use   {@link #getPathString()} to first createa String object, then test <code>endsWith</code> or some other type of string match function.
 * @param p path buffer to test.
 * @param pLen number of bytes from <code>buf</code> to test.
 * @return true if p is suffix of the current path;false if otherwise
 */
public boolean isPathSuffix(final byte[] p,final int pLen){
  final AbstractTreeIterator t=currentHead;
  final byte[] c=t.path;
  final int cLen=t.pathLen;
  int ci;
  for (ci=1; ci < cLen && ci < pLen; ci++) {
    if (c[cLen - ci] != p[pLen - ci])     return false;
  }
  return true;
}","/** 
 * Test if the supplied path matches (being suffix of) the current entry's path. <p> This method tests that the supplied path is exactly equal to the current entry, or is relative to one of entry's parent directories. It is faster to use this method then to use   {@link #getPathString()} to first createa String object, then test <code>endsWith</code> or some other type of string match function.
 * @param p path buffer to test.
 * @param pLen number of bytes from <code>buf</code> to test.
 * @return true if p is suffix of the current path;false if otherwise
 */
public boolean isPathSuffix(final byte[] p,final int pLen){
  final AbstractTreeIterator t=currentHead;
  final byte[] c=t.path;
  final int cLen=t.pathLen;
  for (int i=1; i <= pLen; i++) {
    if (i > cLen)     return false;
    if (c[cLen - i] != p[pLen - i])     return false;
  }
  return true;
}",0.9578765147143682
91308,"/** 
 * Test if the supplied path matches (being suffix of) the current entry's path. <p> This method tests that the supplied path is exactly equal to the current entry, or is relative to one of entry's parent directories. It is faster to use this method then to use   {@link #getPathString()} to first createa String object, then test <code>endsWith</code> or some other type of string match function.
 * @param p path buffer to test.
 * @param pLen number of bytes from <code>buf</code> to test.
 * @return true if p is suffix of the current path;false if otherwise
 */
public boolean isPathSuffix(final byte[] p,final int pLen){
  final AbstractTreeIterator t=currentHead;
  final byte[] c=t.path;
  final int cLen=t.pathLen;
  int ci;
  for (ci=1; ci < cLen && ci < pLen; ci++) {
    if (c[cLen - ci] != p[pLen - ci])     return false;
  }
  return true;
}","/** 
 * Test if the supplied path matches (being suffix of) the current entry's path. <p> This method tests that the supplied path is exactly equal to the current entry, or is relative to one of entry's parent directories. It is faster to use this method then to use   {@link #getPathString()} to first createa String object, then test <code>endsWith</code> or some other type of string match function.
 * @param p path buffer to test.
 * @param pLen number of bytes from <code>buf</code> to test.
 * @return true if p is suffix of the current path;false if otherwise
 */
public boolean isPathSuffix(final byte[] p,final int pLen){
  final AbstractTreeIterator t=currentHead;
  final byte[] c=t.path;
  final int cLen=t.pathLen;
  for (int i=1; i <= pLen; i++) {
    if (i > cLen)     return false;
    if (c[cLen - i] != p[pLen - i])     return false;
  }
  return true;
}",0.9578765147143682
91309,"/** 
 * Test if the supplied path matches (being suffix of) the current entry's path. <p> This method tests that the supplied path is exactly equal to the current entry, or is relative to one of entry's parent directories. It is faster to use this method then to use   {@link #getPathString()} to first createa String object, then test <code>endsWith</code> or some other type of string match function.
 * @param p path buffer to test.
 * @param pLen number of bytes from <code>buf</code> to test.
 * @return true if p is suffix of the current path;false if otherwise
 */
public boolean isPathSuffix(final byte[] p,final int pLen){
  final AbstractTreeIterator t=currentHead;
  final byte[] c=t.path;
  final int cLen=t.pathLen;
  int ci;
  for (ci=1; ci < cLen && ci < pLen; ci++) {
    if (c[cLen - ci] != p[pLen - ci])     return false;
  }
  return true;
}","/** 
 * Test if the supplied path matches (being suffix of) the current entry's path. <p> This method tests that the supplied path is exactly equal to the current entry, or is relative to one of entry's parent directories. It is faster to use this method then to use   {@link #getPathString()} to first createa String object, then test <code>endsWith</code> or some other type of string match function.
 * @param p path buffer to test.
 * @param pLen number of bytes from <code>buf</code> to test.
 * @return true if p is suffix of the current path;false if otherwise
 */
public boolean isPathSuffix(final byte[] p,final int pLen){
  final AbstractTreeIterator t=currentHead;
  final byte[] c=t.path;
  final int cLen=t.pathLen;
  for (int i=1; i <= pLen; i++) {
    if (i > cLen)     return false;
    if (c[cLen - i] != p[pLen - i])     return false;
  }
  return true;
}",0.9578765147143682
91310,"/** 
 * Match a character sequence against this pattern.
 * @param rcs the sequence to match. Must not be null but the length of the sequence is permitted to be 0.
 * @return offset within <code>rcs</code> of the first occurrence of thispattern; -1 if this pattern does not appear at any position of <code>rcs</code>.
 */
public int match(final RawCharSequence rcs){
  final int needleLen=needle.length;
  final byte first=needle[0];
  final byte[] text=rcs.buffer;
  int matchPos=rcs.startPtr;
  final int maxPos=rcs.endPtr - needleLen;
  OUTER:   for (; matchPos < maxPos; matchPos++) {
    if (neq(first,text[matchPos])) {
      while (++matchPos < maxPos && neq(first,text[matchPos])) {
      }
      if (matchPos == maxPos)       return -1;
    }
    int si=++matchPos;
    for (int j=1; j < needleLen; j++, si++) {
      if (neq(needle[j],text[si]))       continue OUTER;
    }
    return matchPos - 1;
  }
  return -1;
}","/** 
 * Match a character sequence against this pattern.
 * @param rcs the sequence to match. Must not be null but the length of the sequence is permitted to be 0.
 * @return offset within <code>rcs</code> of the first occurrence of thispattern; -1 if this pattern does not appear at any position of <code>rcs</code>.
 */
public int match(final RawCharSequence rcs){
  final int needleLen=needle.length;
  final byte first=needle[0];
  final byte[] text=rcs.buffer;
  int matchPos=rcs.startPtr;
  final int maxPos=rcs.endPtr - needleLen;
  OUTER:   for (; matchPos <= maxPos; matchPos++) {
    if (neq(first,text[matchPos])) {
      while (++matchPos <= maxPos && neq(first,text[matchPos])) {
      }
      if (matchPos > maxPos)       return -1;
    }
    int si=matchPos + 1;
    for (int j=1; j < needleLen; j++, si++) {
      if (neq(needle[j],text[si]))       continue OUTER;
    }
    return matchPos;
  }
  return -1;
}",0.984349703184026
91311,"/** 
 * Create reverse index from straight/forward pack index, by indexing all its entries.
 * @param packIndex forward index - entries to (reverse) index.
 */
public PackReverseIndex(final PackIndex packIndex){
  index=packIndex;
  final long cnt=index.getObjectCount();
  final long n64=index.getOffset64Count();
  final long n32=cnt - n64;
  if (n32 > Integer.MAX_VALUE || n64 > Integer.MAX_VALUE || cnt > 0xffffffffL)   throw new IllegalArgumentException(JGitText.get().hugeIndexesAreNotSupportedByJgitYet);
  offsets32=new int[(int)n32];
  offsets64=new long[(int)n64];
  nth32=new int[offsets32.length];
  nth64=new int[offsets64.length];
  int i32=0;
  int i64=0;
  for (  final MutableEntry me : index) {
    final long o=me.getOffset();
    if (o < Integer.MAX_VALUE)     offsets32[i32++]=(int)o;
 else     offsets64[i64++]=o;
  }
  Arrays.sort(offsets32);
  Arrays.sort(offsets64);
  int nth=0;
  for (  final MutableEntry me : index) {
    final long o=me.getOffset();
    if (o < Integer.MAX_VALUE)     nth32[Arrays.binarySearch(offsets32,(int)o)]=nth++;
 else     nth64[Arrays.binarySearch(offsets64,o)]=nth++;
  }
}","/** 
 * Create reverse index from straight/forward pack index, by indexing all its entries.
 * @param packIndex forward index - entries to (reverse) index.
 */
public PackReverseIndex(final PackIndex packIndex){
  index=packIndex;
  final long cnt=index.getObjectCount();
  final long n64=index.getOffset64Count();
  final long n32=cnt - n64;
  if (n32 > Integer.MAX_VALUE || n64 > Integer.MAX_VALUE || cnt > 0xffffffffL)   throw new IllegalArgumentException(JGitText.get().hugeIndexesAreNotSupportedByJgitYet);
  offsets32=new int[(int)n32];
  offsets64=new long[(int)n64];
  nth32=new int[offsets32.length];
  nth64=new int[offsets64.length];
  int i32=0;
  int i64=0;
  for (  final MutableEntry me : index) {
    final long o=me.getOffset();
    if (o <= Integer.MAX_VALUE)     offsets32[i32++]=(int)o;
 else     offsets64[i64++]=o;
  }
  Arrays.sort(offsets32);
  Arrays.sort(offsets64);
  int nth=0;
  for (  final MutableEntry me : index) {
    final long o=me.getOffset();
    if (o <= Integer.MAX_VALUE)     nth32[Arrays.binarySearch(offsets32,(int)o)]=nth++;
 else     nth64[Arrays.binarySearch(offsets64,o)]=nth++;
  }
}",0.9991150442477876
91312,"private String format(final boolean includePassword,boolean escapeNonAscii){
  final StringBuilder r=new StringBuilder();
  if (getScheme() != null) {
    r.append(getScheme());
    r.append(""String_Node_Str"");
  }
  if (getUser() != null) {
    r.append(escape(getUser(),true,escapeNonAscii));
    if (includePassword && getPass() != null) {
      r.append(':');
      r.append(escape(getPass(),true,escapeNonAscii));
    }
  }
  if (getHost() != null) {
    if (getUser() != null)     r.append('@');
    r.append(escape(getHost(),false,escapeNonAscii));
    if (getScheme() != null && getPort() > 0) {
      r.append(':');
      r.append(getPort());
    }
  }
  if (getPath() != null) {
    if (getScheme() != null) {
      if (!getPath().startsWith(""String_Node_Str""))       r.append('/');
    }
 else     if (getHost() != null)     r.append(':');
    if (getScheme() != null)     if (escapeNonAscii)     r.append(escape(getPath(),false,escapeNonAscii));
 else     r.append(getRawPath());
 else     r.append(getPath());
  }
  return r.toString();
}","private String format(final boolean includePassword,boolean escapeNonAscii){
  final StringBuilder r=new StringBuilder();
  if (getScheme() != null) {
    r.append(getScheme());
    r.append(""String_Node_Str"");
  }
  if (getUser() != null) {
    r.append(escape(getUser(),true,escapeNonAscii));
    if (includePassword && getPass() != null) {
      r.append(':');
      r.append(escape(getPass(),true,escapeNonAscii));
    }
  }
  if (getHost() != null) {
    if (getUser() != null && getUser().length() > 0)     r.append('@');
    r.append(escape(getHost(),false,escapeNonAscii));
    if (getScheme() != null && getPort() > 0) {
      r.append(':');
      r.append(getPort());
    }
  }
  if (getPath() != null) {
    if (getScheme() != null) {
      if (!getPath().startsWith(""String_Node_Str""))       r.append('/');
    }
 else     if (getHost() != null)     r.append(':');
    if (getScheme() != null)     if (escapeNonAscii)     r.append(escape(getPath(),false,escapeNonAscii));
 else     r.append(getRawPath());
 else     r.append(getPath());
  }
  return r.toString();
}",0.987781954887218
91313,"/** 
 * Save the configuration as a Git text style configuration file. <p> <b>Warning:</b> Although this method uses the traditional Git file locking approach to protect against concurrent writes of the configuration file, it does not ensure that the file has not been modified since the last read, which means updates performed by other objects accessing the same backing file may be lost.
 * @throws IOException the file could not be written.
 */
public void save() throws IOException {
  final byte[] out;
  final String text=toText();
  if (utf8Bom) {
    final ByteArrayOutputStream bos=new ByteArrayOutputStream();
    bos.write(0xEF);
    bos.write(0xBB);
    bos.write(0xBF);
    bos.write(text.getBytes(RawParseUtils.UTF8_CHARSET));
    out=bos.toByteArray();
  }
 else {
    out=Constants.encode(text);
  }
  final LockFile lf=new LockFile(getFile(),fs);
  if (!lf.lock())   throw new LockFailedException(getFile());
  try {
    lf.setNeedSnapshot(true);
    lf.write(out);
    if (!lf.commit())     throw new IOException(MessageFormat.format(JGitText.get().cannotCommitWriteTo,getFile()));
  }
  finally {
    lf.unlock();
  }
  snapshot=lf.getCommitSnapshot();
  hash=hash(out);
  fireConfigChangedEvent();
}","/** 
 * Save the configuration as a Git text style configuration file. <p> <b>Warning:</b> Although this method uses the traditional Git file locking approach to protect against concurrent writes of the configuration file, it does not ensure that the file has not been modified since the last read, which means updates performed by other objects accessing the same backing file may be lost.
 * @throws IOException the file could not be written.
 */
public void save() throws IOException {
  final byte[] out;
  final String text=toText();
  if (utf8Bom) {
    final ByteArrayOutputStream bos=new ByteArrayOutputStream();
    bos.write(0xEF);
    bos.write(0xBB);
    bos.write(0xBF);
    bos.write(text.getBytes(RawParseUtils.UTF8_CHARSET.name()));
    out=bos.toByteArray();
  }
 else {
    out=Constants.encode(text);
  }
  final LockFile lf=new LockFile(getFile(),fs);
  if (!lf.lock())   throw new LockFailedException(getFile());
  try {
    lf.setNeedSnapshot(true);
    lf.write(out);
    if (!lf.commit())     throw new IOException(MessageFormat.format(JGitText.get().cannotCommitWriteTo,getFile()));
  }
  finally {
    lf.unlock();
  }
  snapshot=lf.getCommitSnapshot();
  hash=hash(out);
  fireConfigChangedEvent();
}",0.9971393543114018
91314,"/** 
 * Processes one path and tries to merge. This method will do all do all trivial (not content) merges and will also detect if a merge will fail. The merge will fail when one of the following is true <ul> <li>the index entry does not match the entry in ours. When merging one branch into the current HEAD, ours will point to HEAD and theirs will point to the other branch. It is assumed that the index matches the HEAD because it will only not match HEAD if it was populated before the merge operation. But the merge commit should not accidentally contain modifications done before the merge. Check the <a href= ""http://www.kernel.org/pub/software/scm/git/docs/git-read-tree.html#_3_way_merge"" >git read-tree</a> documentation for further explanations.</li> <li>A conflict was detected and the working-tree file is dirty. When a conflict is detected the content-merge algorithm will try to write a merged version into the working-tree. If the file is dirty we would override unsaved data.</li>
 * @param base the common base for ours and theirs
 * @param ours the ours side of the merge. When merging a branch into the HEAD ours will point to HEAD
 * @param theirs the theirs side of the merge. When merging a branch into the current HEAD theirs will point to the branch which is merged into HEAD.
 * @param index the index entry
 * @param work the file in the working tree
 * @return <code>false</code> if the merge will fail because the index entrydidn't match ours or the working-dir file was dirty and a conflict occurred
 * @throws MissingObjectException
 * @throws IncorrectObjectTypeException
 * @throws CorruptObjectException
 * @throws IOException
 */
private boolean processEntry(CanonicalTreeParser base,CanonicalTreeParser ours,CanonicalTreeParser theirs,DirCacheBuildIterator index,WorkingTreeIterator work) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {
  enterSubtree=true;
  final int modeO=tw.getRawMode(T_OURS);
  final int modeT=tw.getRawMode(T_THEIRS);
  final int modeB=tw.getRawMode(T_BASE);
  if (modeO == 0 && modeT == 0 && modeB == 0)   return true;
  if (isIndexDirty())   return false;
  DirCacheEntry ourDce=null;
  if (index == null || index.getDirCacheEntry() == null) {
    if (nonTree(modeO)) {
      ourDce=new DirCacheEntry(tw.getRawPath());
      ourDce.setObjectId(tw.getObjectId(T_OURS));
      ourDce.setFileMode(tw.getFileMode(T_OURS));
    }
  }
 else {
    ourDce=index.getDirCacheEntry();
  }
  if (nonTree(modeO) && nonTree(modeT) && tw.idEqual(T_OURS,T_THEIRS)) {
    if (modeO == modeT) {
      keep(ourDce);
      return true;
    }
 else {
      int newMode=mergeFileModes(modeB,modeO,modeT);
      if (newMode != FileMode.MISSING.getBits()) {
        if (newMode == modeO)         keep(ourDce);
 else {
          if (isWorktreeDirty(work))           return false;
          DirCacheEntry e=add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_0,0,0);
          toBeCheckedOut.put(tw.getPathString(),e);
        }
        return true;
      }
 else {
        add(tw.getRawPath(),base,DirCacheEntry.STAGE_1,0,0);
        add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2,0,0);
        add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3,0,0);
        unmergedPaths.add(tw.getPathString());
        mergeResults.put(tw.getPathString(),new MergeResult<RawText>(Collections.<RawText>emptyList()));
      }
      return true;
    }
  }
  if (nonTree(modeO) && modeB == modeT && tw.idEqual(T_BASE,T_THEIRS)) {
    keep(ourDce);
    return true;
  }
  if (modeB == modeO && tw.idEqual(T_BASE,T_OURS)) {
    if (isWorktreeDirty(work))     return false;
    if (nonTree(modeT)) {
      DirCacheEntry e=add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_0,0,0);
      if (e != null)       toBeCheckedOut.put(tw.getPathString(),e);
      return true;
    }
 else     if (modeT == 0 && modeB != 0) {
      toBeDeleted.add(tw.getPathString());
      return true;
    }
  }
  if (tw.isSubtree()) {
    if (nonTree(modeO) && !nonTree(modeT)) {
      if (nonTree(modeB))       add(tw.getRawPath(),base,DirCacheEntry.STAGE_1,0,0);
      add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2,0,0);
      unmergedPaths.add(tw.getPathString());
      enterSubtree=false;
      return true;
    }
    if (nonTree(modeT) && !nonTree(modeO)) {
      if (nonTree(modeB))       add(tw.getRawPath(),base,DirCacheEntry.STAGE_1,0,0);
      add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3,0,0);
      unmergedPaths.add(tw.getPathString());
      enterSubtree=false;
      return true;
    }
    if (!nonTree(modeO))     return true;
  }
  if (nonTree(modeO) && nonTree(modeT)) {
    if (isWorktreeDirty(work))     return false;
    MergeResult<RawText> result=contentMerge(base,ours,theirs);
    File of=writeMergedFile(result);
    updateIndex(base,ours,theirs,result,of);
    if (result.containsConflicts())     unmergedPaths.add(tw.getPathString());
    modifiedFiles.add(tw.getPathString());
  }
 else   if (modeO != modeT) {
    if (((modeO != 0 && !tw.idEqual(T_BASE,T_OURS)) || (modeT != 0 && !tw.idEqual(T_BASE,T_THEIRS)))) {
      add(tw.getRawPath(),base,DirCacheEntry.STAGE_1,0,0);
      add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2,0,0);
      DirCacheEntry e=add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3,0,0);
      if (modeO == 0) {
        if (isWorktreeDirty(work))         return false;
        if (nonTree(modeT)) {
          if (e != null)           toBeCheckedOut.put(tw.getPathString(),e);
        }
      }
      unmergedPaths.add(tw.getPathString());
      mergeResults.put(tw.getPathString(),contentMerge(base,ours,theirs));
    }
  }
  return true;
}","/** 
 * Processes one path and tries to merge. This method will do all do all trivial (not content) merges and will also detect if a merge will fail. The merge will fail when one of the following is true <ul> <li>the index entry does not match the entry in ours. When merging one branch into the current HEAD, ours will point to HEAD and theirs will point to the other branch. It is assumed that the index matches the HEAD because it will only not match HEAD if it was populated before the merge operation. But the merge commit should not accidentally contain modifications done before the merge. Check the <a href= ""http://www.kernel.org/pub/software/scm/git/docs/git-read-tree.html#_3_way_merge"" >git read-tree</a> documentation for further explanations.</li> <li>A conflict was detected and the working-tree file is dirty. When a conflict is detected the content-merge algorithm will try to write a merged version into the working-tree. If the file is dirty we would override unsaved data.</li>
 * @param base the common base for ours and theirs
 * @param ours the ours side of the merge. When merging a branch into the HEAD ours will point to HEAD
 * @param theirs the theirs side of the merge. When merging a branch into the current HEAD theirs will point to the branch which is merged into HEAD.
 * @param index the index entry
 * @param work the file in the working tree
 * @return <code>false</code> if the merge will fail because the index entrydidn't match ours or the working-dir file was dirty and a conflict occurred
 * @throws MissingObjectException
 * @throws IncorrectObjectTypeException
 * @throws CorruptObjectException
 * @throws IOException
 */
private boolean processEntry(CanonicalTreeParser base,CanonicalTreeParser ours,CanonicalTreeParser theirs,DirCacheBuildIterator index,WorkingTreeIterator work) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {
  enterSubtree=true;
  final int modeO=tw.getRawMode(T_OURS);
  final int modeT=tw.getRawMode(T_THEIRS);
  final int modeB=tw.getRawMode(T_BASE);
  if (modeO == 0 && modeT == 0 && modeB == 0)   return true;
  if (isIndexDirty())   return false;
  DirCacheEntry ourDce=null;
  if (index == null || index.getDirCacheEntry() == null) {
    if (nonTree(modeO)) {
      ourDce=new DirCacheEntry(tw.getRawPath());
      ourDce.setObjectId(tw.getObjectId(T_OURS));
      ourDce.setFileMode(tw.getFileMode(T_OURS));
    }
  }
 else {
    ourDce=index.getDirCacheEntry();
  }
  if (nonTree(modeO) && nonTree(modeT) && tw.idEqual(T_OURS,T_THEIRS)) {
    if (modeO == modeT) {
      keep(ourDce);
      return true;
    }
 else {
      int newMode=mergeFileModes(modeB,modeO,modeT);
      if (newMode != FileMode.MISSING.getBits()) {
        if (newMode == modeO)         keep(ourDce);
 else {
          if (isWorktreeDirty(work))           return false;
          DirCacheEntry e=add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_0,0,0);
          toBeCheckedOut.put(tw.getPathString(),e);
        }
        return true;
      }
 else {
        add(tw.getRawPath(),base,DirCacheEntry.STAGE_1,0,0);
        add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2,0,0);
        add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3,0,0);
        unmergedPaths.add(tw.getPathString());
        mergeResults.put(tw.getPathString(),new MergeResult<RawText>(Collections.<RawText>emptyList()));
      }
      return true;
    }
  }
  if (nonTree(modeO) && modeB == modeT && tw.idEqual(T_BASE,T_THEIRS)) {
    keep(ourDce);
    return true;
  }
  if (modeB == modeO && tw.idEqual(T_BASE,T_OURS)) {
    if (isWorktreeDirty(work))     return false;
    if (nonTree(modeT)) {
      DirCacheEntry e=add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_0,0,0);
      if (e != null)       toBeCheckedOut.put(tw.getPathString(),e);
      return true;
    }
 else     if (modeT == 0 && modeB != 0) {
      toBeDeleted.add(tw.getPathString());
      return true;
    }
  }
  if (tw.isSubtree()) {
    if (nonTree(modeO) && !nonTree(modeT)) {
      if (nonTree(modeB))       add(tw.getRawPath(),base,DirCacheEntry.STAGE_1,0,0);
      add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2,0,0);
      unmergedPaths.add(tw.getPathString());
      enterSubtree=false;
      return true;
    }
    if (nonTree(modeT) && !nonTree(modeO)) {
      if (nonTree(modeB))       add(tw.getRawPath(),base,DirCacheEntry.STAGE_1,0,0);
      add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3,0,0);
      unmergedPaths.add(tw.getPathString());
      enterSubtree=false;
      return true;
    }
    if (!nonTree(modeO))     return true;
  }
  if (nonTree(modeO) && nonTree(modeT)) {
    if (isWorktreeDirty(work))     return false;
    if (isGitLink(modeO) || isGitLink(modeT)) {
      add(tw.getRawPath(),base,DirCacheEntry.STAGE_1,0,0);
      add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2,0,0);
      add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3,0,0);
      unmergedPaths.add(tw.getPathString());
      return true;
    }
    MergeResult<RawText> result=contentMerge(base,ours,theirs);
    File of=writeMergedFile(result);
    updateIndex(base,ours,theirs,result,of);
    if (result.containsConflicts())     unmergedPaths.add(tw.getPathString());
    modifiedFiles.add(tw.getPathString());
  }
 else   if (modeO != modeT) {
    if (((modeO != 0 && !tw.idEqual(T_BASE,T_OURS)) || (modeT != 0 && !tw.idEqual(T_BASE,T_THEIRS)))) {
      add(tw.getRawPath(),base,DirCacheEntry.STAGE_1,0,0);
      add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2,0,0);
      DirCacheEntry e=add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3,0,0);
      if (modeO == 0) {
        if (isWorktreeDirty(work))         return false;
        if (nonTree(modeT)) {
          if (e != null)           toBeCheckedOut.put(tw.getPathString(),e);
        }
      }
      unmergedPaths.add(tw.getPathString());
      mergeResults.put(tw.getPathString(),contentMerge(base,ours,theirs));
    }
  }
  return true;
}",0.9743146242324656
91315,"/** 
 * Creates a new InputStream, wrapping the specified stream
 * @param in raw input stream
 */
public EolCanonicalizingInputStream(InputStream in,boolean detectBinary){
  this.in=in;
  this.detectBinary=detectBinary;
}","/** 
 * Creates a new InputStream, wrapping the specified stream
 * @param in raw input stream
 * @param detectBinary whether binaries should be detected
 */
public EolCanonicalizingInputStream(InputStream in,boolean detectBinary){
  this.in=in;
  this.detectBinary=detectBinary;
}",0.882703777335984
91316,"@Test public void testSkip() throws IOException {
  final UnionInputStream u=new UnionInputStream();
  u.add(new ByteArrayInputStream(new byte[]{1,0,2}));
  u.add(new ByteArrayInputStream(new byte[]{3}));
  u.add(new ByteArrayInputStream(new byte[]{4,5}));
  assertEquals(0,u.skip(0));
  assertEquals(4,u.skip(4));
  assertEquals(4,u.read());
  assertEquals(1,u.skip(5));
  assertEquals(0,u.skip(5));
  assertEquals(-1,u.read());
  u.add(new ByteArrayInputStream(new byte[]{20,30}){
    public long skip(    long n){
      return 0;
    }
  }
);
  assertEquals(2,u.skip(8));
  assertEquals(-1,u.read());
}","@Test public void testSkip() throws IOException {
  final UnionInputStream u=new UnionInputStream();
  u.add(new ByteArrayInputStream(new byte[]{1,0,2}));
  u.add(new ByteArrayInputStream(new byte[]{3}));
  u.add(new ByteArrayInputStream(new byte[]{4,5}));
  assertEquals(0,u.skip(0));
  assertEquals(3,u.skip(3));
  assertEquals(3,u.read());
  assertEquals(2,u.skip(5));
  assertEquals(0,u.skip(5));
  assertEquals(-1,u.read());
  u.add(new ByteArrayInputStream(new byte[]{20,30}){
    public long skip(    long n){
      return 0;
    }
  }
);
  assertEquals(2,u.skip(8));
  assertEquals(-1,u.read());
}",0.9173553719008264
91317,"@Test public void testReadByteBlocks() throws IOException {
  final UnionInputStream u=new UnionInputStream();
  u.add(new ByteArrayInputStream(new byte[]{1,0,2}));
  u.add(new ByteArrayInputStream(new byte[]{3}));
  u.add(new ByteArrayInputStream(new byte[]{4,5}));
  final byte[] r=new byte[5];
  assertEquals(5,u.read(r,0,5));
  assertTrue(Arrays.equals(new byte[]{1,0,2,3,4},r));
  assertEquals(1,u.read(r,0,5));
  assertEquals(5,r[0]);
  assertEquals(-1,u.read(r,0,5));
}","@Test public void testReadByteBlocks() throws IOException {
  final UnionInputStream u=new UnionInputStream();
  u.add(new ByteArrayInputStream(new byte[]{1,0,2}));
  u.add(new ByteArrayInputStream(new byte[]{3}));
  u.add(new ByteArrayInputStream(new byte[]{4,5}));
  final byte[] r=new byte[5];
  assertEquals(3,u.read(r,0,5));
  assertTrue(Arrays.equals(new byte[]{1,0,2},slice(r,3)));
  assertEquals(1,u.read(r,0,5));
  assertEquals(3,r[0]);
  assertEquals(2,u.read(r,0,5));
  assertTrue(Arrays.equals(new byte[]{4,5},slice(r,2)));
  assertEquals(-1,u.read(r,0,5));
}",0.792741165234002
91318,"@Test public void testArrayConstructor() throws IOException {
  final UnionInputStream u=new UnionInputStream(new ByteArrayInputStream(new byte[]{1,0,2}),new ByteArrayInputStream(new byte[]{3}),new ByteArrayInputStream(new byte[]{4,5}));
  final byte[] r=new byte[5];
  assertEquals(5,u.read(r,0,5));
  assertTrue(Arrays.equals(new byte[]{1,0,2,3,4},r));
  assertEquals(1,u.read(r,0,5));
  assertEquals(5,r[0]);
  assertEquals(-1,u.read(r,0,5));
}","@Test public void testArrayConstructor() throws IOException {
  final UnionInputStream u=new UnionInputStream(new ByteArrayInputStream(new byte[]{1,0,2}),new ByteArrayInputStream(new byte[]{3}),new ByteArrayInputStream(new byte[]{4,5}));
  final byte[] r=new byte[5];
  assertEquals(3,u.read(r,0,5));
  assertTrue(Arrays.equals(new byte[]{1,0,2},slice(r,3)));
  assertEquals(1,u.read(r,0,5));
  assertEquals(3,r[0]);
  assertEquals(2,u.read(r,0,5));
  assertTrue(Arrays.equals(new byte[]{4,5},slice(r,2)));
  assertEquals(-1,u.read(r,0,5));
}",0.7805864509605662
91319,"@Override public int read(byte[] b,int off,int len) throws IOException {
  int cnt=0;
  while (0 < len) {
    final InputStream in=head();
    final int n=in.read(b,off,len);
    if (0 < n) {
      cnt+=n;
      off+=n;
      len-=n;
    }
 else     if (in == EOF)     return 0 < cnt ? cnt : -1;
 else     pop();
  }
  return cnt;
}","@Override public int read(byte[] b,int off,int len) throws IOException {
  int cnt=0;
  while (0 < len) {
    final InputStream in=head();
    final int n=in.read(b,off,len);
    if (0 < n) {
      cnt+=n;
      off+=n;
      len-=n;
    }
 else     if (in == EOF)     return 0 < cnt ? cnt : -1;
 else {
      pop();
      if (0 < cnt)       break;
    }
  }
  return cnt;
}",0.9093484419263456
91320,"@Override public long skip(long len) throws IOException {
  long cnt=0;
  while (0 < len) {
    final InputStream in=head();
    final long n=in.skip(len);
    if (0 < n) {
      cnt+=n;
      len-=n;
    }
 else     if (in == EOF) {
      return cnt;
    }
 else {
      final int r=in.read();
      if (r < 0) {
        pop();
      }
 else {
        cnt+=1;
        len-=1;
      }
    }
  }
  return cnt;
}","@Override public long skip(long len) throws IOException {
  long cnt=0;
  while (0 < len) {
    final InputStream in=head();
    final long n=in.skip(len);
    if (0 < n) {
      cnt+=n;
      len-=n;
    }
 else     if (in == EOF) {
      return cnt;
    }
 else {
      final int r=in.read();
      if (r < 0) {
        pop();
        if (0 < cnt)         break;
      }
 else {
        cnt+=1;
        len-=1;
      }
    }
  }
  return cnt;
}",0.9579439252336448
91321,"/** 
 * Start a mutation task.
 * @param < T > any type the task might return.
 * @param task the mutation task. The result of the task is discarded, so callers should perform result validation within the task.
 * @param size number of bytes that are buffered within the task.
 * @throws DhtException a prior task has completed, and failed.
 */
protected <T>void start(final Callable<T> task,int size) throws DhtException {
  final int permits=permitsForSize(size);
  final Callable<T> op=new Callable<T>(){
    public T call() throws Exception {
      try {
        return task.call();
      }
  finally {
        spaceAvailable.release(permits);
      }
    }
  }
;
  if (flushing && finalTask == null) {
    finalTask=op;
    return;
  }
  if (!flushing)   checkRunningTasks(false);
  running.add(executor.submit(op));
}","/** 
 * Start a mutation task.
 * @param < T > any type the task might return.
 * @param task the mutation task. The result of the task is discarded, so callers should perform result validation within the task.
 * @param size number of bytes that are buffered within the task.
 * @throws DhtException a prior task has completed, and failed.
 */
protected <T>void start(final Callable<T> task,int size) throws DhtException {
  final int permits=permitsForSize(size);
  final Callable<T> op=new Callable<T>(){
    public T call() throws Exception {
      try {
        return task.call();
      }
  finally {
        spaceAvailable.release(permits);
      }
    }
  }
;
  if (flushing && finalTask == null) {
    finalTask=op;
    return;
  }
synchronized (runningLock) {
    if (!flushing)     checkRunningTasks(false);
    running.add(executor.submit(op));
  }
}",0.9768545994065282
91322,"public void flush() throws DhtException {
  try {
    flushing=true;
    if (0 < queuedCount) {
      startQueuedOperations(queuedCount);
      queuedCount=0;
    }
    if (finalTask != null) {
      try {
        waitFor(finalTask);
      }
  finally {
        finalTask=null;
      }
    }
    checkRunningTasks(true);
  }
  finally {
    flushing=false;
  }
}","public void flush() throws DhtException {
  try {
    flushing=true;
    if (0 < queuedCount) {
      startQueuedOperations(queuedCount);
      queuedCount=0;
    }
    if (finalTask != null) {
      try {
        waitFor(finalTask);
      }
  finally {
        finalTask=null;
      }
    }
synchronized (runningLock) {
      checkRunningTasks(true);
    }
  }
  finally {
    flushing=false;
  }
}",0.9513797634691196
91323,"/** 
 * Initialize a buffer with a backing executor service.
 * @param executor service to run mutation tasks on.
 * @param bufferSize maximum number of bytes to have pending at once.
 */
protected AbstractWriteBuffer(ExecutorService executor,int bufferSize){
  this.executor=executor;
  this.bufferSize=bufferSize;
  this.running=new LinkedList<Future<?>>();
  this.spaceAvailable=new Semaphore(bufferSize);
}","/** 
 * Initialize a buffer with a backing executor service.
 * @param executor service to run mutation tasks on.
 * @param bufferSize maximum number of bytes to have pending at once.
 */
protected AbstractWriteBuffer(ExecutorService executor,int bufferSize){
  this.executor=executor;
  this.bufferSize=bufferSize;
  this.running=new LinkedList<Future<?>>();
  this.runningLock=new Object();
  this.spaceAvailable=new Semaphore(bufferSize);
}",0.9613130128956624
91324,"public void abort() throws DhtException {
  checkRunningTasks(true);
}","public void abort() throws DhtException {
synchronized (runningLock) {
    checkRunningTasks(true);
  }
}",0.8
91325,"/** 
 * Wrap a callback to update the buffer. <p> Flushing the buffer will wait for the returned callback to complete.
 * @param < T > any type the task might return.
 * @param callback callback invoked when the task has finished.
 * @param size number of bytes that are buffered within the task.
 * @return wrapped callback that will update the buffer state when thecallback is invoked.
 * @throws DhtException a prior task has completed, and failed.
 */
protected <T>AsyncCallback<T> wrap(final AsyncCallback<T> callback,int size) throws DhtException {
  int permits=permitsForSize(size);
  WrappedCallback<T> op=new WrappedCallback<T>(callback,permits);
  checkRunningTasks(false);
  running.add(op);
  return op;
}","/** 
 * Wrap a callback to update the buffer. <p> Flushing the buffer will wait for the returned callback to complete.
 * @param < T > any type the task might return.
 * @param callback callback invoked when the task has finished.
 * @param size number of bytes that are buffered within the task.
 * @return wrapped callback that will update the buffer state when thecallback is invoked.
 * @throws DhtException a prior task has completed, and failed.
 */
protected <T>AsyncCallback<T> wrap(final AsyncCallback<T> callback,int size) throws DhtException {
  int permits=permitsForSize(size);
  WrappedCallback<T> op=new WrappedCallback<T>(callback,permits);
synchronized (runningLock) {
    checkRunningTasks(false);
    running.add(op);
  }
  return op;
}",0.9748811948404617
91326,"@Test public void testEdit_InsertNearCommonTail(){
  EditList r=diff(t(""String_Node_Str""),t(""String_Node_Str""));
  assertEquals(new Edit(1,1,1,2),r.get(0));
  assertEquals(new Edit(3,3,4,7),r.get(1));
  assertEquals(2,r.size());
}","@Test public void testEdit_InsertNearCommonTail(){
  EditList r=diff(t(""String_Node_Str""),t(""String_Node_Str""));
  assertEquals(new Edit(1,1,1,2),r.get(0));
  assertEquals(new Edit(4,4,5,8),r.get(1));
  assertEquals(2,r.size());
}",0.9782608695652174
91327,"/** 
 * Compare two sequences and identify a list of edits between them.
 * @param < S > type of sequence being compared.
 * @param cmp the comparator supplying the element equivalence function.
 * @param a the first (also known as old or pre-image) sequence. Edits returned by this algorithm will reference indexes using the 'A' side:  {@link Edit#getBeginA()},   {@link Edit#getEndA()}.
 * @param b the second (also known as new or post-image) sequence. Edits returned by this algorithm will reference indexes using the 'B' side:  {@link Edit#getBeginB()},   {@link Edit#getEndB()}.
 * @return a modifiable edit list comparing the two sequences. If empty, thesequences are identical according to  {@code cmp}'s rules. The result list is never null.
 */
public <S extends Sequence>EditList diff(SequenceComparator<? super S> cmp,S a,S b){
  Edit region=cmp.reduceCommonStartEnd(a,b,coverEdit(a,b));
switch (region.getType()) {
case INSERT:
case DELETE:
    return EditList.singleton(region);
case REPLACE:
{
    SubsequenceComparator<S> cs=new SubsequenceComparator<S>(cmp);
    Subsequence<S> as=Subsequence.a(a,region);
    Subsequence<S> bs=Subsequence.b(b,region);
    EditList e=Subsequence.toBase(diffNonCommon(cs,as,bs),as,bs);
    Edit last=e.get(e.size() - 1);
    if (last.getType() == Edit.Type.INSERT) {
      while (last.endB < b.size() && cmp.equals(b,last.beginB,b,region.endB)) {
        last.beginA++;
        last.endA++;
        last.beginB++;
        last.endB++;
      }
    }
    return e;
  }
case EMPTY:
return new EditList(0);
default :
throw new IllegalStateException();
}
}","/** 
 * Compare two sequences and identify a list of edits between them.
 * @param < S > type of sequence being compared.
 * @param cmp the comparator supplying the element equivalence function.
 * @param a the first (also known as old or pre-image) sequence. Edits returned by this algorithm will reference indexes using the 'A' side:  {@link Edit#getBeginA()},   {@link Edit#getEndA()}.
 * @param b the second (also known as new or post-image) sequence. Edits returned by this algorithm will reference indexes using the 'B' side:  {@link Edit#getBeginB()},   {@link Edit#getEndB()}.
 * @return a modifiable edit list comparing the two sequences. If empty, thesequences are identical according to  {@code cmp}'s rules. The result list is never null.
 */
public <S extends Sequence>EditList diff(SequenceComparator<? super S> cmp,S a,S b){
  Edit region=cmp.reduceCommonStartEnd(a,b,coverEdit(a,b));
switch (region.getType()) {
case INSERT:
case DELETE:
    return EditList.singleton(region);
case REPLACE:
{
    SubsequenceComparator<S> cs=new SubsequenceComparator<S>(cmp);
    Subsequence<S> as=Subsequence.a(a,region);
    Subsequence<S> bs=Subsequence.b(b,region);
    EditList e=Subsequence.toBase(diffNonCommon(cs,as,bs),as,bs);
    Edit last=e.get(e.size() - 1);
    if (last.getType() == Edit.Type.INSERT) {
      while (last.endB < b.size() && cmp.equals(b,last.beginB,b,last.endB)) {
        last.beginA++;
        last.endA++;
        last.beginB++;
        last.endB++;
      }
    }
    return e;
  }
case EMPTY:
return new EditList(0);
default :
throw new IllegalStateException();
}
}",0.996875
91328,"@Test public void testEdit_InsertNearCommonTail(){
  EditList r=diff(t(""String_Node_Str""),t(""String_Node_Str""));
  assertEquals(new Edit(1,1,1,2),r.get(0));
  assertEquals(new Edit(3,3,4,7),r.get(1));
  assertEquals(2,r.size());
}","@Test public void testEdit_InsertNearCommonTail(){
  EditList r=diff(t(""String_Node_Str""),t(""String_Node_Str""));
  assertEquals(new Edit(1,1,1,2),r.get(0));
  assertEquals(new Edit(4,4,5,8),r.get(1));
  assertEquals(2,r.size());
}",0.9782608695652174
91329,"/** 
 * Compare two sequences and identify a list of edits between them.
 * @param < S > type of sequence being compared.
 * @param cmp the comparator supplying the element equivalence function.
 * @param a the first (also known as old or pre-image) sequence. Edits returned by this algorithm will reference indexes using the 'A' side:  {@link Edit#getBeginA()},   {@link Edit#getEndA()}.
 * @param b the second (also known as new or post-image) sequence. Edits returned by this algorithm will reference indexes using the 'B' side:  {@link Edit#getBeginB()},   {@link Edit#getEndB()}.
 * @return a modifiable edit list comparing the two sequences. If empty, thesequences are identical according to  {@code cmp}'s rules. The result list is never null.
 */
public <S extends Sequence>EditList diff(SequenceComparator<? super S> cmp,S a,S b){
  Edit region=cmp.reduceCommonStartEnd(a,b,coverEdit(a,b));
switch (region.getType()) {
case INSERT:
case DELETE:
    return EditList.singleton(region);
case REPLACE:
{
    SubsequenceComparator<S> cs=new SubsequenceComparator<S>(cmp);
    Subsequence<S> as=Subsequence.a(a,region);
    Subsequence<S> bs=Subsequence.b(b,region);
    EditList e=Subsequence.toBase(diffNonCommon(cs,as,bs),as,bs);
    Edit last=e.get(e.size() - 1);
    if (last.getType() == Edit.Type.INSERT) {
      while (last.endB < b.size() && cmp.equals(b,last.beginB,b,region.endB)) {
        last.beginA++;
        last.endA++;
        last.beginB++;
        last.endB++;
      }
    }
    return e;
  }
case EMPTY:
return new EditList(0);
default :
throw new IllegalStateException();
}
}","/** 
 * Compare two sequences and identify a list of edits between them.
 * @param < S > type of sequence being compared.
 * @param cmp the comparator supplying the element equivalence function.
 * @param a the first (also known as old or pre-image) sequence. Edits returned by this algorithm will reference indexes using the 'A' side:  {@link Edit#getBeginA()},   {@link Edit#getEndA()}.
 * @param b the second (also known as new or post-image) sequence. Edits returned by this algorithm will reference indexes using the 'B' side:  {@link Edit#getBeginB()},   {@link Edit#getEndB()}.
 * @return a modifiable edit list comparing the two sequences. If empty, thesequences are identical according to  {@code cmp}'s rules. The result list is never null.
 */
public <S extends Sequence>EditList diff(SequenceComparator<? super S> cmp,S a,S b){
  Edit region=cmp.reduceCommonStartEnd(a,b,coverEdit(a,b));
switch (region.getType()) {
case INSERT:
case DELETE:
    return EditList.singleton(region);
case REPLACE:
{
    SubsequenceComparator<S> cs=new SubsequenceComparator<S>(cmp);
    Subsequence<S> as=Subsequence.a(a,region);
    Subsequence<S> bs=Subsequence.b(b,region);
    EditList e=Subsequence.toBase(diffNonCommon(cs,as,bs),as,bs);
    Edit last=e.get(e.size() - 1);
    if (last.getType() == Edit.Type.INSERT) {
      while (last.endB < b.size() && cmp.equals(b,last.beginB,b,last.endB)) {
        last.beginA++;
        last.endA++;
        last.beginB++;
        last.endB++;
      }
    }
    return e;
  }
case EMPTY:
return new EditList(0);
default :
throw new IllegalStateException();
}
}",0.996875
91330,"static void sendError(int statusCode,HttpServletRequest req,HttpServletResponse rsp) throws IOException {
  String svc=req.getParameter(""String_Node_Str"");
  String accept=req.getHeader(HDR_ACCEPT);
  if (svc != null && svc.startsWith(""String_Node_Str"") && accept != null && accept.contains(""String_Node_Str"" + svc + ""String_Node_Str"")) {
    rsp.setContentType(""String_Node_Str"" + svc + ""String_Node_Str"");
    SmartOutputStream buf=new SmartOutputStream(req,rsp);
    PacketLineOut out=new PacketLineOut(buf);
    out.writeString(""String_Node_Str"" + svc + ""String_Node_Str"");
    out.end();
    out.writeString(""String_Node_Str"" + translate(statusCode));
    buf.close();
    return;
  }
  if (accept != null && accept.contains(UploadPackServlet.RSP_TYPE)) {
    rsp.setContentType(UploadPackServlet.RSP_TYPE);
    SmartOutputStream buf=new SmartOutputStream(req,rsp);
    PacketLineOut out=new PacketLineOut(buf);
    out.writeString(""String_Node_Str"" + translate(statusCode));
    buf.close();
    return;
  }
  rsp.sendError(statusCode);
}","static void sendError(int statusCode,HttpServletRequest req,HttpServletResponse rsp) throws IOException {
  String svc=req.getParameter(""String_Node_Str"");
  if (req.getRequestURI().endsWith(""String_Node_Str"") && isService(svc)) {
    rsp.setContentType(""String_Node_Str"" + svc + ""String_Node_Str"");
    SmartOutputStream buf=new SmartOutputStream(req,rsp);
    PacketLineOut out=new PacketLineOut(buf);
    out.writeString(""String_Node_Str"" + svc + ""String_Node_Str"");
    out.end();
    out.writeString(""String_Node_Str"" + translate(statusCode));
    buf.close();
    return;
  }
  String accept=req.getHeader(HDR_ACCEPT);
  if (accept != null && accept.contains(UploadPackServlet.RSP_TYPE)) {
    rsp.setContentType(UploadPackServlet.RSP_TYPE);
    SmartOutputStream buf=new SmartOutputStream(req,rsp);
    PacketLineOut out=new PacketLineOut(buf);
    out.writeString(""String_Node_Str"" + translate(statusCode));
    buf.close();
    return;
  }
  rsp.sendError(statusCode);
}",0.4518042511122095
91331,"static void sendError(int statusCode,HttpServletRequest req,HttpServletResponse rsp) throws IOException {
  String svc=req.getParameter(""String_Node_Str"");
  String accept=req.getHeader(HDR_ACCEPT);
  if (svc != null && svc.startsWith(""String_Node_Str"") && accept != null && accept.contains(""String_Node_Str"" + svc + ""String_Node_Str"")) {
    rsp.setContentType(""String_Node_Str"" + svc + ""String_Node_Str"");
    SmartOutputStream buf=new SmartOutputStream(req,rsp);
    PacketLineOut out=new PacketLineOut(buf);
    out.writeString(""String_Node_Str"" + svc + ""String_Node_Str"");
    out.end();
    out.writeString(""String_Node_Str"" + translate(statusCode));
    buf.close();
    return;
  }
  if (accept != null && accept.contains(UploadPackServlet.RSP_TYPE)) {
    rsp.setContentType(UploadPackServlet.RSP_TYPE);
    SmartOutputStream buf=new SmartOutputStream(req,rsp);
    PacketLineOut out=new PacketLineOut(buf);
    out.writeString(""String_Node_Str"" + translate(statusCode));
    buf.close();
    return;
  }
  rsp.sendError(statusCode);
}","static void sendError(int statusCode,HttpServletRequest req,HttpServletResponse rsp) throws IOException {
  String svc=req.getParameter(""String_Node_Str"");
  if (req.getRequestURI().endsWith(""String_Node_Str"") && isService(svc)) {
    rsp.setContentType(""String_Node_Str"" + svc + ""String_Node_Str"");
    SmartOutputStream buf=new SmartOutputStream(req,rsp);
    PacketLineOut out=new PacketLineOut(buf);
    out.writeString(""String_Node_Str"" + svc + ""String_Node_Str"");
    out.end();
    out.writeString(""String_Node_Str"" + translate(statusCode));
    buf.close();
    return;
  }
  String accept=req.getHeader(HDR_ACCEPT);
  if (accept != null && accept.contains(UploadPackServlet.RSP_TYPE)) {
    rsp.setContentType(UploadPackServlet.RSP_TYPE);
    SmartOutputStream buf=new SmartOutputStream(req,rsp);
    PacketLineOut out=new PacketLineOut(buf);
    out.writeString(""String_Node_Str"" + translate(statusCode));
    buf.close();
    return;
  }
  rsp.sendError(statusCode);
}",0.4518042511122095
91332,"/** 
 * Executes the   {@code commit} command with all the options and parameterscollected by the setter methods of this class. Each instance of this class should only be used for one invocation of the command (means: one call to  {@link #call()})
 * @return a {@link RevCommit} object representing the successful commit.
 * @throws NoHeadException when called on a git repo without a HEAD reference
 * @throws NoMessageException when called without specifying a commit message
 * @throws UnmergedPathException when the current index contained unmerged pathes (conflicts)
 * @throws WrongRepositoryStateException when repository is not in the right state for committing
 * @throws JGitInternalException a low-level exception of JGit has occurred. The original exception can be retrieved by calling {@link Exception#getCause()}. Expect only  {@code IOException's} to be wrapped. Subclasses of{@link IOException} (e.g. {@link UnmergedPathException}) are typically not wrapped here but thrown as original exception
 */
public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {
  checkCallable();
  RepositoryState state=repo.getRepositoryState();
  if (!state.canCommit())   throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState,state.name()));
  processOptions(state);
  try {
    if (all && !repo.isBare() && repo.getWorkTree() != null) {
      Git git=new Git(repo);
      try {
        git.add().addFilepattern(""String_Node_Str"").setUpdate(true).call();
      }
 catch (      NoFilepatternException e) {
        throw new JGitInternalException(e.getMessage(),e);
      }
    }
    Ref head=repo.getRef(Constants.HEAD);
    if (head == null)     throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);
    ObjectId headId=repo.resolve(Constants.HEAD + ""String_Node_Str"");
    if (headId != null)     parents.add(0,headId);
    DirCache index=repo.lockDirCache();
    try {
      ObjectInserter odi=repo.newObjectInserter();
      try {
        ObjectId indexTreeId=index.writeTree(odi);
        CommitBuilder commit=new CommitBuilder();
        commit.setCommitter(committer);
        commit.setAuthor(author);
        commit.setMessage(message);
        commit.setParentIds(parents);
        commit.setTreeId(indexTreeId);
        ObjectId commitId=odi.insert(commit);
        odi.flush();
        RevWalk revWalk=new RevWalk(repo);
        try {
          RevCommit revCommit=revWalk.parseCommit(commitId);
          RefUpdate ru=repo.updateRef(Constants.HEAD);
          ru.setNewObjectId(commitId);
          ru.setRefLogMessage(""String_Node_Str"" + revCommit.getShortMessage(),false);
          ru.setExpectedOldObjectId(headId);
          Result rc=ru.update();
switch (rc) {
case NEW:
case FAST_FORWARD:
{
              setCallable(false);
              if (state == RepositoryState.MERGING_RESOLVED) {
                repo.writeMergeCommitMsg(null);
                repo.writeMergeHeads(null);
              }
              return revCommit;
            }
case REJECTED:
case LOCK_FAILURE:
          throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD,ru.getRef(),rc);
default :
        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed,Constants.HEAD,commitId.toString(),rc));
    }
  }
  finally {
    revWalk.release();
  }
}
  finally {
  odi.release();
}
}
  finally {
index.unlock();
}
}
 catch (UnmergedPathException e) {
throw e;
}
catch (IOException e) {
throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand,e);
}
}","/** 
 * Executes the   {@code commit} command with all the options and parameterscollected by the setter methods of this class. Each instance of this class should only be used for one invocation of the command (means: one call to  {@link #call()})
 * @return a {@link RevCommit} object representing the successful commit.
 * @throws NoHeadException when called on a git repo without a HEAD reference
 * @throws NoMessageException when called without specifying a commit message
 * @throws UnmergedPathException when the current index contained unmerged paths (conflicts)
 * @throws WrongRepositoryStateException when repository is not in the right state for committing
 * @throws JGitInternalException a low-level exception of JGit has occurred. The original exception can be retrieved by calling {@link Exception#getCause()}. Expect only  {@code IOException's} to be wrapped. Subclasses of{@link IOException} (e.g. {@link UnmergedPathException}) are typically not wrapped here but thrown as original exception
 */
public RevCommit call() throws NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException {
  checkCallable();
  RepositoryState state=repo.getRepositoryState();
  if (!state.canCommit())   throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotCommitOnARepoWithState,state.name()));
  processOptions(state);
  try {
    if (all && !repo.isBare() && repo.getWorkTree() != null) {
      Git git=new Git(repo);
      try {
        git.add().addFilepattern(""String_Node_Str"").setUpdate(true).call();
      }
 catch (      NoFilepatternException e) {
        throw new JGitInternalException(e.getMessage(),e);
      }
    }
    Ref head=repo.getRef(Constants.HEAD);
    if (head == null)     throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);
    ObjectId headId=repo.resolve(Constants.HEAD + ""String_Node_Str"");
    if (headId != null)     parents.add(0,headId);
    DirCache index=repo.lockDirCache();
    try {
      ObjectInserter odi=repo.newObjectInserter();
      try {
        ObjectId indexTreeId=index.writeTree(odi);
        CommitBuilder commit=new CommitBuilder();
        commit.setCommitter(committer);
        commit.setAuthor(author);
        commit.setMessage(message);
        commit.setParentIds(parents);
        commit.setTreeId(indexTreeId);
        ObjectId commitId=odi.insert(commit);
        odi.flush();
        RevWalk revWalk=new RevWalk(repo);
        try {
          RevCommit revCommit=revWalk.parseCommit(commitId);
          RefUpdate ru=repo.updateRef(Constants.HEAD);
          ru.setNewObjectId(commitId);
          ru.setRefLogMessage(""String_Node_Str"" + revCommit.getShortMessage(),false);
          ru.setExpectedOldObjectId(headId);
          Result rc=ru.update();
switch (rc) {
case NEW:
case FAST_FORWARD:
{
              setCallable(false);
              if (state == RepositoryState.MERGING_RESOLVED) {
                repo.writeMergeCommitMsg(null);
                repo.writeMergeHeads(null);
              }
              return revCommit;
            }
case REJECTED:
case LOCK_FAILURE:
          throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD,ru.getRef(),rc);
default :
        throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed,Constants.HEAD,commitId.toString(),rc));
    }
  }
  finally {
    revWalk.release();
  }
}
  finally {
  odi.release();
}
}
  finally {
index.unlock();
}
}
 catch (UnmergedPathException e) {
throw e;
}
catch (IOException e) {
throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand,e);
}
}",0.9998658258419428
91333,"/** 
 * Executes the   {@code Merge} command with all the options and parameterscollected by the setter methods (e.g.  {@link #include(Ref)}) of this class. Each instance of this class should only be used for one invocation of the command. Don't call this method twice on an instance.
 * @return the result of the merge
 */
public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {
  checkCallable();
  if (commits.size() != 1)   throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads,mergeStrategy.getName(),Integer.valueOf(commits.size())));
  RevWalk revWalk=null;
  try {
    Ref head=repo.getRef(Constants.HEAD);
    if (head == null)     throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);
    StringBuilder refLogMessage=new StringBuilder(""String_Node_Str"");
    revWalk=new RevWalk(repo);
    RevCommit headCommit=revWalk.lookupCommit(head.getObjectId());
    Ref ref=commits.get(0);
    refLogMessage.append(ref.getName());
    ObjectId objectId=ref.getPeeledObjectId();
    if (objectId == null)     objectId=ref.getObjectId();
    RevCommit srcCommit=revWalk.lookupCommit(objectId);
    if (revWalk.isMergedInto(srcCommit,headCommit)) {
      setCallable(false);
      return new MergeResult(headCommit,srcCommit,new ObjectId[]{headCommit,srcCommit},MergeStatus.ALREADY_UP_TO_DATE,mergeStrategy,null,null);
    }
 else     if (revWalk.isMergedInto(headCommit,srcCommit)) {
      refLogMessage.append(""String_Node_Str"" + MergeStatus.FAST_FORWARD);
      DirCacheCheckout dco=new DirCacheCheckout(repo,headCommit.getTree(),repo.lockDirCache(),srcCommit.getTree());
      dco.setFailOnConflict(true);
      dco.checkout();
      updateHead(refLogMessage,srcCommit,head.getObjectId());
      setCallable(false);
      return new MergeResult(srcCommit,srcCommit,new ObjectId[]{headCommit,srcCommit},MergeStatus.FAST_FORWARD,mergeStrategy,null,null);
    }
 else {
      repo.writeMergeCommitMsg(new MergeMessageFormatter().format(commits,head));
      repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));
      ThreeWayMerger merger=(ThreeWayMerger)mergeStrategy.newMerger(repo);
      boolean noProblems;
      Map<String,org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults=null;
      Map<String,MergeFailureReason> failingPaths=null;
      if (merger instanceof ResolveMerger) {
        ResolveMerger resolveMerger=(ResolveMerger)merger;
        resolveMerger.setCommitNames(new String[]{""String_Node_Str"",""String_Node_Str"",ref.getName()});
        resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));
        noProblems=merger.merge(headCommit,srcCommit);
        lowLevelResults=resolveMerger.getMergeResults();
        failingPaths=resolveMerger.getFailingPathes();
      }
 else       noProblems=merger.merge(headCommit,srcCommit);
      if (noProblems) {
        DirCacheCheckout dco=new DirCacheCheckout(repo,headCommit.getTree(),repo.lockDirCache(),merger.getResultTreeId());
        dco.setFailOnConflict(true);
        dco.checkout();
        RevCommit newHead=new Git(getRepository()).commit().call();
        return new MergeResult(newHead.getId(),null,new ObjectId[]{headCommit.getId(),srcCommit.getId()},MergeStatus.MERGED,mergeStrategy,null,null);
      }
 else {
        if (failingPaths != null) {
          repo.writeMergeCommitMsg(null);
          repo.writeMergeHeads(null);
          return new MergeResult(null,merger.getBaseCommit(0,1),new ObjectId[]{headCommit.getId(),srcCommit.getId()},MergeStatus.FAILED,mergeStrategy,lowLevelResults,null);
        }
 else         return new MergeResult(null,merger.getBaseCommit(0,1),new ObjectId[]{headCommit.getId(),srcCommit.getId()},MergeStatus.CONFLICTING,mergeStrategy,lowLevelResults,null);
      }
    }
  }
 catch (  IOException e) {
    throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,e),e);
  }
 finally {
    if (revWalk != null)     revWalk.release();
  }
}","/** 
 * Executes the   {@code Merge} command with all the options and parameterscollected by the setter methods (e.g.  {@link #include(Ref)}) of this class. Each instance of this class should only be used for one invocation of the command. Don't call this method twice on an instance.
 * @return the result of the merge
 */
public MergeResult call() throws NoHeadException, ConcurrentRefUpdateException, CheckoutConflictException, InvalidMergeHeadsException, WrongRepositoryStateException, NoMessageException {
  checkCallable();
  if (commits.size() != 1)   throw new InvalidMergeHeadsException(commits.isEmpty() ? JGitText.get().noMergeHeadSpecified : MessageFormat.format(JGitText.get().mergeStrategyDoesNotSupportHeads,mergeStrategy.getName(),Integer.valueOf(commits.size())));
  RevWalk revWalk=null;
  try {
    Ref head=repo.getRef(Constants.HEAD);
    if (head == null)     throw new NoHeadException(JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);
    StringBuilder refLogMessage=new StringBuilder(""String_Node_Str"");
    revWalk=new RevWalk(repo);
    RevCommit headCommit=revWalk.lookupCommit(head.getObjectId());
    Ref ref=commits.get(0);
    refLogMessage.append(ref.getName());
    ObjectId objectId=ref.getPeeledObjectId();
    if (objectId == null)     objectId=ref.getObjectId();
    RevCommit srcCommit=revWalk.lookupCommit(objectId);
    if (revWalk.isMergedInto(srcCommit,headCommit)) {
      setCallable(false);
      return new MergeResult(headCommit,srcCommit,new ObjectId[]{headCommit,srcCommit},MergeStatus.ALREADY_UP_TO_DATE,mergeStrategy,null,null);
    }
 else     if (revWalk.isMergedInto(headCommit,srcCommit)) {
      refLogMessage.append(""String_Node_Str"" + MergeStatus.FAST_FORWARD);
      DirCacheCheckout dco=new DirCacheCheckout(repo,headCommit.getTree(),repo.lockDirCache(),srcCommit.getTree());
      dco.setFailOnConflict(true);
      dco.checkout();
      updateHead(refLogMessage,srcCommit,head.getObjectId());
      setCallable(false);
      return new MergeResult(srcCommit,srcCommit,new ObjectId[]{headCommit,srcCommit},MergeStatus.FAST_FORWARD,mergeStrategy,null,null);
    }
 else {
      repo.writeMergeCommitMsg(new MergeMessageFormatter().format(commits,head));
      repo.writeMergeHeads(Arrays.asList(ref.getObjectId()));
      ThreeWayMerger merger=(ThreeWayMerger)mergeStrategy.newMerger(repo);
      boolean noProblems;
      Map<String,org.eclipse.jgit.merge.MergeResult<?>> lowLevelResults=null;
      Map<String,MergeFailureReason> failingPaths=null;
      if (merger instanceof ResolveMerger) {
        ResolveMerger resolveMerger=(ResolveMerger)merger;
        resolveMerger.setCommitNames(new String[]{""String_Node_Str"",""String_Node_Str"",ref.getName()});
        resolveMerger.setWorkingTreeIterator(new FileTreeIterator(repo));
        noProblems=merger.merge(headCommit,srcCommit);
        lowLevelResults=resolveMerger.getMergeResults();
        failingPaths=resolveMerger.getFailingPaths();
      }
 else       noProblems=merger.merge(headCommit,srcCommit);
      if (noProblems) {
        DirCacheCheckout dco=new DirCacheCheckout(repo,headCommit.getTree(),repo.lockDirCache(),merger.getResultTreeId());
        dco.setFailOnConflict(true);
        dco.checkout();
        RevCommit newHead=new Git(getRepository()).commit().call();
        return new MergeResult(newHead.getId(),null,new ObjectId[]{headCommit.getId(),srcCommit.getId()},MergeStatus.MERGED,mergeStrategy,null,null);
      }
 else {
        if (failingPaths != null) {
          repo.writeMergeCommitMsg(null);
          repo.writeMergeHeads(null);
          return new MergeResult(null,merger.getBaseCommit(0,1),new ObjectId[]{headCommit.getId(),srcCommit.getId()},MergeStatus.FAILED,mergeStrategy,lowLevelResults,null);
        }
 else         return new MergeResult(null,merger.getBaseCommit(0,1),new ObjectId[]{headCommit.getId(),srcCommit.getId()},MergeStatus.CONFLICTING,mergeStrategy,lowLevelResults,null);
      }
    }
  }
 catch (  IOException e) {
    throw new JGitInternalException(MessageFormat.format(JGitText.get().exceptionCaughtDuringExecutionOfMergeCommand,e),e);
  }
 finally {
    if (revWalk != null)     revWalk.release();
  }
}",0.9998808814770695
91334,"/** 
 * @return a list of updated pathes and objectIds
 */
public Map<String,ObjectId> getUpdated(){
  return updated;
}","/** 
 * @return a list of updated paths and objectIds
 */
public Map<String,ObjectId> getUpdated(){
  return updated;
}",0.99581589958159
91335,"@Override protected boolean mergeImpl() throws IOException {
  boolean implicitDirCache=false;
  if (dircache == null) {
    dircache=getRepository().lockDirCache();
    implicitDirCache=true;
  }
  try {
    builder=dircache.builder();
    DirCacheBuildIterator buildIt=new DirCacheBuildIterator(builder);
    tw=new NameConflictTreeWalk(db);
    tw.addTree(mergeBase());
    tw.addTree(sourceTrees[0]);
    tw.addTree(sourceTrees[1]);
    tw.addTree(buildIt);
    if (workingTreeIterator != null)     tw.addTree(workingTreeIterator);
    while (tw.next()) {
      if (!processEntry(tw.getTree(T_BASE,CanonicalTreeParser.class),tw.getTree(T_OURS,CanonicalTreeParser.class),tw.getTree(T_THEIRS,CanonicalTreeParser.class),tw.getTree(T_INDEX,DirCacheBuildIterator.class),(workingTreeIterator == null) ? null : tw.getTree(T_FILE,WorkingTreeIterator.class))) {
        cleanUp();
        return false;
      }
      if (tw.isSubtree() && enterSubtree)       tw.enterSubtree();
    }
    if (!inCore) {
      if (!builder.commit()) {
        cleanUp();
        throw new IndexWriteException();
      }
      builder=null;
      checkout();
    }
 else {
      builder.finish();
      builder=null;
    }
    if (getUnmergedPathes().isEmpty()) {
      resultTree=dircache.writeTree(oi);
      return true;
    }
 else {
      resultTree=null;
      return false;
    }
  }
  finally {
    if (implicitDirCache)     dircache.unlock();
  }
}","@Override protected boolean mergeImpl() throws IOException {
  boolean implicitDirCache=false;
  if (dircache == null) {
    dircache=getRepository().lockDirCache();
    implicitDirCache=true;
  }
  try {
    builder=dircache.builder();
    DirCacheBuildIterator buildIt=new DirCacheBuildIterator(builder);
    tw=new NameConflictTreeWalk(db);
    tw.addTree(mergeBase());
    tw.addTree(sourceTrees[0]);
    tw.addTree(sourceTrees[1]);
    tw.addTree(buildIt);
    if (workingTreeIterator != null)     tw.addTree(workingTreeIterator);
    while (tw.next()) {
      if (!processEntry(tw.getTree(T_BASE,CanonicalTreeParser.class),tw.getTree(T_OURS,CanonicalTreeParser.class),tw.getTree(T_THEIRS,CanonicalTreeParser.class),tw.getTree(T_INDEX,DirCacheBuildIterator.class),(workingTreeIterator == null) ? null : tw.getTree(T_FILE,WorkingTreeIterator.class))) {
        cleanUp();
        return false;
      }
      if (tw.isSubtree() && enterSubtree)       tw.enterSubtree();
    }
    if (!inCore) {
      if (!builder.commit()) {
        cleanUp();
        throw new IndexWriteException();
      }
      builder=null;
      checkout();
    }
 else {
      builder.finish();
      builder=null;
    }
    if (getUnmergedPaths().isEmpty()) {
      resultTree=dircache.writeTree(oi);
      return true;
    }
 else {
      resultTree=null;
      return false;
    }
  }
  finally {
    if (implicitDirCache)     dircache.unlock();
  }
}",0.999650959860384
91336,"/** 
 * @return the paths of files which have been modified by this merge. Afile will be modified if a content-merge works on this path or if the merge algorithm decides to take the theirs-version. This is a superset of the files listed by  {@link #getUnmergedPathes()}.
 */
public List<String> getModifiedFiles(){
  return modifiedFiles;
}","/** 
 * @return the paths of files which have been modified by this merge. Afile will be modified if a content-merge works on this path or if the merge algorithm decides to take the theirs-version. This is a superset of the files listed by  {@link #getUnmergedPaths()}.
 */
public List<String> getModifiedFiles(){
  return modifiedFiles;
}",0.9985272459499264
91337,"/** 
 * Processes one path and tries to merge. This method will do all do all trivial (not content) merges and will also detect if a merge will fail. The merge will fail when one of the following is true <ul> <li>the index entry does not match the entry in ours. When merging one branch into the current HEAD, ours will point to HEAD and theirs will point to the other branch. It is assumed that the index matches the HEAD because it will only not match HEAD if it was populated before the merge operation. But the merge commit should not accidentally contain modifications done before the merge. Check the <a href= ""http://www.kernel.org/pub/software/scm/git/docs/git-read-tree.html#_3_way_merge"" >git read-tree</a> documentation for further explanations.</li> <li>A conflict was detected and the working-tree file is dirty. When a conflict is detected the content-merge algorithm will try to write a merged version into the working-tree. If the file is dirty we would override unsaved data.</li>
 * @param base the common base for ours and theirs
 * @param ours the ours side of the merge. When merging a branch into the HEAD ours will point to HEAD
 * @param theirs the theirs side of the merge. When merging a branch into the current HEAD theirs will point to the branch which is merged into HEAD.
 * @param index the index entry
 * @param work the file in the working tree
 * @return <code>false</code> if the merge will fail because the index entrydidn't match ours or the working-dir file was dirty and a conflict occured
 * @throws MissingObjectException
 * @throws IncorrectObjectTypeException
 * @throws CorruptObjectException
 * @throws IOException
 */
private boolean processEntry(CanonicalTreeParser base,CanonicalTreeParser ours,CanonicalTreeParser theirs,DirCacheBuildIterator index,WorkingTreeIterator work) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {
  enterSubtree=true;
  final int modeO=tw.getRawMode(T_OURS);
  final int modeI=tw.getRawMode(T_INDEX);
  if (nonTree(modeI) && !(tw.idEqual(T_INDEX,T_OURS) && modeO == modeI)) {
    failingPathes.put(tw.getPathString(),MergeFailureReason.DIRTY_INDEX);
    return false;
  }
  final int modeT=tw.getRawMode(T_THEIRS);
  if (nonTree(modeO) && modeO == modeT && tw.idEqual(T_OURS,T_THEIRS)) {
    add(tw.getRawPath(),ours,DirCacheEntry.STAGE_0);
    return true;
  }
  final int modeB=tw.getRawMode(T_BASE);
  if (nonTree(modeO) && modeB == modeT && tw.idEqual(T_BASE,T_THEIRS)) {
    add(tw.getRawPath(),ours,DirCacheEntry.STAGE_0);
    return true;
  }
  if (modeB == modeO && tw.idEqual(T_BASE,T_OURS)) {
    if (nonTree(modeT)) {
      DirCacheEntry e=add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_0);
      if (e != null)       toBeCheckedOut.put(tw.getPathString(),e);
      return true;
    }
 else     if ((modeT == 0) && (modeB != 0)) {
      toBeCheckedOut.put(tw.getPathString(),null);
      return true;
    }
  }
  if (tw.isSubtree()) {
    if (nonTree(modeO) && !nonTree(modeT)) {
      if (nonTree(modeB))       add(tw.getRawPath(),base,DirCacheEntry.STAGE_1);
      add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2);
      unmergedPathes.add(tw.getPathString());
      enterSubtree=false;
      return true;
    }
    if (nonTree(modeT) && !nonTree(modeO)) {
      if (nonTree(modeB))       add(tw.getRawPath(),base,DirCacheEntry.STAGE_1);
      add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3);
      unmergedPathes.add(tw.getPathString());
      enterSubtree=false;
      return true;
    }
    if (!nonTree(modeO))     return true;
  }
  if (nonTree(modeO) && nonTree(modeT)) {
    if (!inCore) {
      if (work != null && (!nonTree(work.getEntryRawMode()) || work.isModified(index.getDirCacheEntry(),true))) {
        failingPathes.put(tw.getPathString(),MergeFailureReason.DIRTY_WORKTREE);
        return false;
      }
    }
    if (!contentMerge(base,ours,theirs)) {
      unmergedPathes.add(tw.getPathString());
    }
    modifiedFiles.add(tw.getPathString());
  }
  return true;
}","/** 
 * Processes one path and tries to merge. This method will do all do all trivial (not content) merges and will also detect if a merge will fail. The merge will fail when one of the following is true <ul> <li>the index entry does not match the entry in ours. When merging one branch into the current HEAD, ours will point to HEAD and theirs will point to the other branch. It is assumed that the index matches the HEAD because it will only not match HEAD if it was populated before the merge operation. But the merge commit should not accidentally contain modifications done before the merge. Check the <a href= ""http://www.kernel.org/pub/software/scm/git/docs/git-read-tree.html#_3_way_merge"" >git read-tree</a> documentation for further explanations.</li> <li>A conflict was detected and the working-tree file is dirty. When a conflict is detected the content-merge algorithm will try to write a merged version into the working-tree. If the file is dirty we would override unsaved data.</li>
 * @param base the common base for ours and theirs
 * @param ours the ours side of the merge. When merging a branch into the HEAD ours will point to HEAD
 * @param theirs the theirs side of the merge. When merging a branch into the current HEAD theirs will point to the branch which is merged into HEAD.
 * @param index the index entry
 * @param work the file in the working tree
 * @return <code>false</code> if the merge will fail because the index entrydidn't match ours or the working-dir file was dirty and a conflict occured
 * @throws MissingObjectException
 * @throws IncorrectObjectTypeException
 * @throws CorruptObjectException
 * @throws IOException
 */
private boolean processEntry(CanonicalTreeParser base,CanonicalTreeParser ours,CanonicalTreeParser theirs,DirCacheBuildIterator index,WorkingTreeIterator work) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {
  enterSubtree=true;
  final int modeO=tw.getRawMode(T_OURS);
  final int modeI=tw.getRawMode(T_INDEX);
  if (nonTree(modeI) && !(tw.idEqual(T_INDEX,T_OURS) && modeO == modeI)) {
    failingPaths.put(tw.getPathString(),MergeFailureReason.DIRTY_INDEX);
    return false;
  }
  final int modeT=tw.getRawMode(T_THEIRS);
  if (nonTree(modeO) && modeO == modeT && tw.idEqual(T_OURS,T_THEIRS)) {
    add(tw.getRawPath(),ours,DirCacheEntry.STAGE_0);
    return true;
  }
  final int modeB=tw.getRawMode(T_BASE);
  if (nonTree(modeO) && modeB == modeT && tw.idEqual(T_BASE,T_THEIRS)) {
    add(tw.getRawPath(),ours,DirCacheEntry.STAGE_0);
    return true;
  }
  if (modeB == modeO && tw.idEqual(T_BASE,T_OURS)) {
    if (nonTree(modeT)) {
      DirCacheEntry e=add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_0);
      if (e != null)       toBeCheckedOut.put(tw.getPathString(),e);
      return true;
    }
 else     if ((modeT == 0) && (modeB != 0)) {
      toBeCheckedOut.put(tw.getPathString(),null);
      return true;
    }
  }
  if (tw.isSubtree()) {
    if (nonTree(modeO) && !nonTree(modeT)) {
      if (nonTree(modeB))       add(tw.getRawPath(),base,DirCacheEntry.STAGE_1);
      add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2);
      unmergedPaths.add(tw.getPathString());
      enterSubtree=false;
      return true;
    }
    if (nonTree(modeT) && !nonTree(modeO)) {
      if (nonTree(modeB))       add(tw.getRawPath(),base,DirCacheEntry.STAGE_1);
      add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3);
      unmergedPaths.add(tw.getPathString());
      enterSubtree=false;
      return true;
    }
    if (!nonTree(modeO))     return true;
  }
  if (nonTree(modeO) && nonTree(modeT)) {
    if (!inCore) {
      if (work != null && (!nonTree(work.getEntryRawMode()) || work.isModified(index.getDirCacheEntry(),true))) {
        failingPaths.put(tw.getPathString(),MergeFailureReason.DIRTY_WORKTREE);
        return false;
      }
    }
    if (!contentMerge(base,ours,theirs)) {
      unmergedPaths.add(tw.getPathString());
    }
    modifiedFiles.add(tw.getPathString());
  }
  return true;
}",0.9993786504287312
91338,"private void checkout() throws NoWorkTreeException, IOException {
  for (  Map.Entry<String,DirCacheEntry> entry : toBeCheckedOut.entrySet()) {
    File f=new File(db.getWorkTree(),entry.getKey());
    if (entry.getValue() != null) {
      createDir(f.getParentFile());
      DirCacheCheckout.checkoutEntry(db,f,entry.getValue());
    }
 else {
      if (!f.delete())       failingPathes.put(entry.getKey(),MergeFailureReason.COULD_NOT_DELETE);
    }
    modifiedFiles.add(entry.getKey());
  }
}","private void checkout() throws NoWorkTreeException, IOException {
  for (  Map.Entry<String,DirCacheEntry> entry : toBeCheckedOut.entrySet()) {
    File f=new File(db.getWorkTree(),entry.getKey());
    if (entry.getValue() != null) {
      createDir(f.getParentFile());
      DirCacheCheckout.checkoutEntry(db,f,entry.getValue());
    }
 else {
      if (!f.delete())       failingPaths.put(entry.getKey(),MergeFailureReason.COULD_NOT_DELETE);
    }
    modifiedFiles.add(entry.getKey());
  }
}",0.9989888776541962
91339,"/** 
 * Processes one path and tries to merge. This method will do all do all trivial (not content) merges and will also detect if a merge will fail. The merge will fail when one of the following is true <ul> <li>the index entry does not match the entry in ours. When merging one branch into the current HEAD, ours will point to HEAD and theirs will point to the other branch. It is assumed that the index matches the HEAD because it will only not match HEAD if it was populated before the merge operation. But the merge commit should not accidentally contain modifications done before the merge. Check the <a href= ""http://www.kernel.org/pub/software/scm/git/docs/git-read-tree.html#_3_way_merge"" >git read-tree</a> documentation for further explanations.</li> <li>A conflict was detected and the working-tree file is dirty. When a conflict is detected the content-merge algorithm will try to write a merged version into the working-tree. If the file is dirty we would override unsaved data.</li>
 * @param base the common base for ours and theirs
 * @param ours the ours side of the merge. When merging a branch into the HEAD ours will point to HEAD
 * @param theirs the theirs side of the merge. When merging a branch into the current HEAD theirs will point to the branch which is merged into HEAD.
 * @param index the index entry
 * @param work the file in the working tree
 * @return <code>false</code> if the merge will fail because the index entrydidn't match ours or the working-dir file was dirty and a conflict occured
 * @throws MissingObjectException
 * @throws IncorrectObjectTypeException
 * @throws CorruptObjectException
 * @throws IOException
 */
private boolean processEntry(CanonicalTreeParser base,CanonicalTreeParser ours,CanonicalTreeParser theirs,DirCacheBuildIterator index,WorkingTreeIterator work) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {
  enterSubtree=true;
  final int modeO=tw.getRawMode(T_OURS);
  final int modeI=tw.getRawMode(T_INDEX);
  if (nonTree(modeI) && !(tw.idEqual(T_INDEX,T_OURS) && modeO == modeI)) {
    failingPathes.put(tw.getPathString(),MergeFailureReason.DIRTY_INDEX);
    return false;
  }
  final int modeT=tw.getRawMode(T_THEIRS);
  if (nonTree(modeO) && modeO == modeT && tw.idEqual(T_OURS,T_THEIRS)) {
    add(tw.getRawPath(),ours,DirCacheEntry.STAGE_0);
    return true;
  }
  final int modeB=tw.getRawMode(T_BASE);
  if (nonTree(modeO) && modeB == modeT && tw.idEqual(T_BASE,T_THEIRS)) {
    add(tw.getRawPath(),ours,DirCacheEntry.STAGE_0);
    return true;
  }
  if (modeB == modeO && tw.idEqual(T_BASE,T_OURS)) {
    if (nonTree(modeT)) {
      DirCacheEntry e=add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_0);
      if (e != null)       toBeCheckedOut.put(tw.getPathString(),e);
      return true;
    }
 else     if (modeT == 0) {
      toBeCheckedOut.put(tw.getPathString(),null);
      return true;
    }
  }
  if (tw.isSubtree()) {
    if (nonTree(modeO) && !nonTree(modeT)) {
      if (nonTree(modeB))       add(tw.getRawPath(),base,DirCacheEntry.STAGE_1);
      add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2);
      unmergedPathes.add(tw.getPathString());
      enterSubtree=false;
      return true;
    }
    if (nonTree(modeT) && !nonTree(modeO)) {
      if (nonTree(modeB))       add(tw.getRawPath(),base,DirCacheEntry.STAGE_1);
      add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3);
      unmergedPathes.add(tw.getPathString());
      enterSubtree=false;
      return true;
    }
    if (!nonTree(modeO))     return true;
  }
  if (nonTree(modeO) && nonTree(modeT)) {
    if (!inCore) {
      if (work != null && (!nonTree(work.getEntryRawMode()) || work.isModified(index.getDirCacheEntry(),true,true,db.getFS()))) {
        failingPathes.put(tw.getPathString(),MergeFailureReason.DIRTY_WORKTREE);
        return false;
      }
    }
    if (!contentMerge(base,ours,theirs)) {
      unmergedPathes.add(tw.getPathString());
    }
    modifiedFiles.add(tw.getPathString());
  }
  return true;
}","/** 
 * Processes one path and tries to merge. This method will do all do all trivial (not content) merges and will also detect if a merge will fail. The merge will fail when one of the following is true <ul> <li>the index entry does not match the entry in ours. When merging one branch into the current HEAD, ours will point to HEAD and theirs will point to the other branch. It is assumed that the index matches the HEAD because it will only not match HEAD if it was populated before the merge operation. But the merge commit should not accidentally contain modifications done before the merge. Check the <a href= ""http://www.kernel.org/pub/software/scm/git/docs/git-read-tree.html#_3_way_merge"" >git read-tree</a> documentation for further explanations.</li> <li>A conflict was detected and the working-tree file is dirty. When a conflict is detected the content-merge algorithm will try to write a merged version into the working-tree. If the file is dirty we would override unsaved data.</li>
 * @param base the common base for ours and theirs
 * @param ours the ours side of the merge. When merging a branch into the HEAD ours will point to HEAD
 * @param theirs the theirs side of the merge. When merging a branch into the current HEAD theirs will point to the branch which is merged into HEAD.
 * @param index the index entry
 * @param work the file in the working tree
 * @return <code>false</code> if the merge will fail because the index entrydidn't match ours or the working-dir file was dirty and a conflict occured
 * @throws MissingObjectException
 * @throws IncorrectObjectTypeException
 * @throws CorruptObjectException
 * @throws IOException
 */
private boolean processEntry(CanonicalTreeParser base,CanonicalTreeParser ours,CanonicalTreeParser theirs,DirCacheBuildIterator index,WorkingTreeIterator work) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {
  enterSubtree=true;
  final int modeO=tw.getRawMode(T_OURS);
  final int modeI=tw.getRawMode(T_INDEX);
  if (nonTree(modeI) && !(tw.idEqual(T_INDEX,T_OURS) && modeO == modeI)) {
    failingPathes.put(tw.getPathString(),MergeFailureReason.DIRTY_INDEX);
    return false;
  }
  final int modeT=tw.getRawMode(T_THEIRS);
  if (nonTree(modeO) && modeO == modeT && tw.idEqual(T_OURS,T_THEIRS)) {
    add(tw.getRawPath(),ours,DirCacheEntry.STAGE_0);
    return true;
  }
  final int modeB=tw.getRawMode(T_BASE);
  if (nonTree(modeO) && modeB == modeT && tw.idEqual(T_BASE,T_THEIRS)) {
    add(tw.getRawPath(),ours,DirCacheEntry.STAGE_0);
    return true;
  }
  if (modeB == modeO && tw.idEqual(T_BASE,T_OURS)) {
    if (nonTree(modeT)) {
      DirCacheEntry e=add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_0);
      if (e != null)       toBeCheckedOut.put(tw.getPathString(),e);
      return true;
    }
 else     if ((modeT == 0) && (modeB != 0)) {
      toBeCheckedOut.put(tw.getPathString(),null);
      return true;
    }
  }
  if (tw.isSubtree()) {
    if (nonTree(modeO) && !nonTree(modeT)) {
      if (nonTree(modeB))       add(tw.getRawPath(),base,DirCacheEntry.STAGE_1);
      add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2);
      unmergedPathes.add(tw.getPathString());
      enterSubtree=false;
      return true;
    }
    if (nonTree(modeT) && !nonTree(modeO)) {
      if (nonTree(modeB))       add(tw.getRawPath(),base,DirCacheEntry.STAGE_1);
      add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3);
      unmergedPathes.add(tw.getPathString());
      enterSubtree=false;
      return true;
    }
    if (!nonTree(modeO))     return true;
  }
  if (nonTree(modeO) && nonTree(modeT)) {
    if (!inCore) {
      if (work != null && (!nonTree(work.getEntryRawMode()) || work.isModified(index.getDirCacheEntry(),true,true,db.getFS()))) {
        failingPathes.put(tw.getPathString(),MergeFailureReason.DIRTY_WORKTREE);
        return false;
      }
    }
    if (!contentMerge(base,ours,theirs)) {
      unmergedPathes.add(tw.getPathString());
    }
    modifiedFiles.add(tw.getPathString());
  }
  return true;
}",0.9977684106124474
91340,"/** 
 * Processes one path and tries to merge. This method will do all do all trivial (not content) merges and will also detect if a merge will fail. The merge will fail when one of the following is true <ul> <li>the index entry does not match the entry in ours. When merging one branch into the current HEAD, ours will point to HEAD and theirs will point to the other branch. It is assumed that the index matches the HEAD because it will only not match HEAD if it was populated before the merge operation. But the merge commit should not accidentally contain modifications done before the merge. Check the <a href= ""http://www.kernel.org/pub/software/scm/git/docs/git-read-tree.html#_3_way_merge"" >git read-tree</a> documentation for further explanations.</li> <li>A conflict was detected and the working-tree file is dirty. When a conflict is detected the content-merge algorithm will try to write a merged version into the working-tree. If the file is dirty we would override unsaved data.</li>
 * @param base the common base for ours and theirs
 * @param ours the ours side of the merge. When merging a branch into the HEAD ours will point to HEAD
 * @param theirs the theirs side of the merge. When merging a branch into the current HEAD theirs will point to the branch which is merged into HEAD.
 * @param index the index entry
 * @param work the file in the working tree
 * @return <code>false</code> if the merge will fail because the index entrydidn't match ours or the working-dir file was dirty and a conflict occured
 * @throws MissingObjectException
 * @throws IncorrectObjectTypeException
 * @throws CorruptObjectException
 * @throws IOException
 */
private boolean processEntry(CanonicalTreeParser base,CanonicalTreeParser ours,CanonicalTreeParser theirs,DirCacheBuildIterator index,WorkingTreeIterator work) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {
  enterSubtree=true;
  final int modeO=tw.getRawMode(T_OURS);
  final int modeI=tw.getRawMode(T_INDEX);
  if (nonTree(modeI) && !(tw.idEqual(T_INDEX,T_OURS) && modeO == modeI)) {
    failingPathes.put(tw.getPathString(),MergeFailureReason.DIRTY_INDEX);
    return false;
  }
  final int modeT=tw.getRawMode(T_THEIRS);
  if (nonTree(modeO) && modeO == modeT && tw.idEqual(T_OURS,T_THEIRS)) {
    add(tw.getRawPath(),ours,DirCacheEntry.STAGE_0);
    return true;
  }
  final int modeB=tw.getRawMode(T_BASE);
  if (nonTree(modeO) && modeB == modeT && tw.idEqual(T_BASE,T_THEIRS)) {
    add(tw.getRawPath(),ours,DirCacheEntry.STAGE_0);
    return true;
  }
  if (modeB == modeO && tw.idEqual(T_BASE,T_OURS)) {
    if (nonTree(modeT)) {
      DirCacheEntry e=add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_0);
      if (e != null)       toBeCheckedOut.put(tw.getPathString(),e);
      return true;
    }
 else     if (modeT == 0) {
      toBeCheckedOut.put(tw.getPathString(),null);
      return true;
    }
  }
  if (tw.isSubtree()) {
    if (nonTree(modeO) && !nonTree(modeT)) {
      if (nonTree(modeB))       add(tw.getRawPath(),base,DirCacheEntry.STAGE_1);
      add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2);
      unmergedPathes.add(tw.getPathString());
      enterSubtree=false;
      return true;
    }
    if (nonTree(modeT) && !nonTree(modeO)) {
      if (nonTree(modeB))       add(tw.getRawPath(),base,DirCacheEntry.STAGE_1);
      add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3);
      unmergedPathes.add(tw.getPathString());
      enterSubtree=false;
      return true;
    }
    if (!nonTree(modeO))     return true;
  }
  if (nonTree(modeO) && nonTree(modeT)) {
    if (!inCore) {
      if (work != null && (!nonTree(work.getEntryRawMode()) || work.isModified(index.getDirCacheEntry(),true,true,db.getFS()))) {
        failingPathes.put(tw.getPathString(),MergeFailureReason.DIRTY_WORKTREE);
        return false;
      }
    }
    if (!contentMerge(base,ours,theirs)) {
      unmergedPathes.add(tw.getPathString());
    }
    modifiedFiles.add(tw.getPathString());
  }
  return true;
}","/** 
 * Processes one path and tries to merge. This method will do all do all trivial (not content) merges and will also detect if a merge will fail. The merge will fail when one of the following is true <ul> <li>the index entry does not match the entry in ours. When merging one branch into the current HEAD, ours will point to HEAD and theirs will point to the other branch. It is assumed that the index matches the HEAD because it will only not match HEAD if it was populated before the merge operation. But the merge commit should not accidentally contain modifications done before the merge. Check the <a href= ""http://www.kernel.org/pub/software/scm/git/docs/git-read-tree.html#_3_way_merge"" >git read-tree</a> documentation for further explanations.</li> <li>A conflict was detected and the working-tree file is dirty. When a conflict is detected the content-merge algorithm will try to write a merged version into the working-tree. If the file is dirty we would override unsaved data.</li>
 * @param base the common base for ours and theirs
 * @param ours the ours side of the merge. When merging a branch into the HEAD ours will point to HEAD
 * @param theirs the theirs side of the merge. When merging a branch into the current HEAD theirs will point to the branch which is merged into HEAD.
 * @param index the index entry
 * @param work the file in the working tree
 * @return <code>false</code> if the merge will fail because the index entrydidn't match ours or the working-dir file was dirty and a conflict occured
 * @throws MissingObjectException
 * @throws IncorrectObjectTypeException
 * @throws CorruptObjectException
 * @throws IOException
 */
private boolean processEntry(CanonicalTreeParser base,CanonicalTreeParser ours,CanonicalTreeParser theirs,DirCacheBuildIterator index,WorkingTreeIterator work) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {
  enterSubtree=true;
  final int modeO=tw.getRawMode(T_OURS);
  final int modeI=tw.getRawMode(T_INDEX);
  if (nonTree(modeI) && !(tw.idEqual(T_INDEX,T_OURS) && modeO == modeI)) {
    failingPathes.put(tw.getPathString(),MergeFailureReason.DIRTY_INDEX);
    return false;
  }
  final int modeT=tw.getRawMode(T_THEIRS);
  if (nonTree(modeO) && modeO == modeT && tw.idEqual(T_OURS,T_THEIRS)) {
    add(tw.getRawPath(),ours,DirCacheEntry.STAGE_0);
    return true;
  }
  final int modeB=tw.getRawMode(T_BASE);
  if (nonTree(modeO) && modeB == modeT && tw.idEqual(T_BASE,T_THEIRS)) {
    add(tw.getRawPath(),ours,DirCacheEntry.STAGE_0);
    return true;
  }
  if (modeB == modeO && tw.idEqual(T_BASE,T_OURS)) {
    if (nonTree(modeT)) {
      DirCacheEntry e=add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_0);
      if (e != null)       toBeCheckedOut.put(tw.getPathString(),e);
      return true;
    }
 else     if ((modeT == 0) && (modeB != 0)) {
      toBeCheckedOut.put(tw.getPathString(),null);
      return true;
    }
  }
  if (tw.isSubtree()) {
    if (nonTree(modeO) && !nonTree(modeT)) {
      if (nonTree(modeB))       add(tw.getRawPath(),base,DirCacheEntry.STAGE_1);
      add(tw.getRawPath(),ours,DirCacheEntry.STAGE_2);
      unmergedPathes.add(tw.getPathString());
      enterSubtree=false;
      return true;
    }
    if (nonTree(modeT) && !nonTree(modeO)) {
      if (nonTree(modeB))       add(tw.getRawPath(),base,DirCacheEntry.STAGE_1);
      add(tw.getRawPath(),theirs,DirCacheEntry.STAGE_3);
      unmergedPathes.add(tw.getPathString());
      enterSubtree=false;
      return true;
    }
    if (!nonTree(modeO))     return true;
  }
  if (nonTree(modeO) && nonTree(modeT)) {
    if (!inCore) {
      if (work != null && (!nonTree(work.getEntryRawMode()) || work.isModified(index.getDirCacheEntry(),true,true,db.getFS()))) {
        failingPathes.put(tw.getPathString(),MergeFailureReason.DIRTY_WORKTREE);
        return false;
      }
    }
    if (!contentMerge(base,ours,theirs)) {
      unmergedPathes.add(tw.getPathString());
    }
    modifiedFiles.add(tw.getPathString());
  }
  return true;
}",0.9977684106124474
91341,"/** 
 * Here the main work is done. This method is called for each existing path in head, index and merge. This method decides what to do with the corresponding index entry: keep it, update it, remove it or mark a conflict.
 * @param h the entry for the head
 * @param m the entry for the merge
 * @param i the entry for the index
 * @param f the file in the working tree
 * @throws IOException
 */
void processEntry(AbstractTreeIterator h,AbstractTreeIterator m,DirCacheBuildIterator i,WorkingTreeIterator f) throws IOException {
  DirCacheEntry dce;
  String name=walk.getPathString();
  if (i == null && m == null && h == null) {
    if (walk.isDirectoryFileConflict())     conflict(name,null,h,m);
    return;
  }
  ObjectId iId=(i == null ? null : i.getEntryObjectId());
  ObjectId mId=(m == null ? null : m.getEntryObjectId());
  ObjectId hId=(h == null ? null : h.getEntryObjectId());
  int ffMask=0;
  if (h != null)   ffMask=FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;
  if (i != null)   ffMask|=FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0 : 0x0F0;
  if (m != null)   ffMask|=FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D : 0x00F;
  if (((ffMask & 0x222) != 0x000) && (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {
switch (ffMask) {
case 0xDDF:
      if (isModified(name)) {
        conflict(name,i.getDirCacheEntry(),h,m);
      }
 else {
        update(name,m.getEntryObjectId(),m.getEntryFileMode());
      }
    break;
case 0xDFD:
  remove(name);
break;
case 0xF0D:
remove(name);
break;
case 0xDFF:
case 0xFDD:
break;
case 0xD0F:
update(name,mId,m.getEntryFileMode());
break;
case 0xDF0:
case 0x0FD:
conflict(name,(i != null) ? i.getDirCacheEntry() : null,h,m);
break;
case 0xFDF:
if (hId.equals(mId)) {
if (isModified(name)) conflict(name,i.getDirCacheEntry(),h,m);
 else update(name,mId,m.getEntryFileMode());
}
 else if (!isModified(name)) update(name,mId,m.getEntryFileMode());
 else conflict(name,i.getDirCacheEntry(),h,m);
break;
case 0xFD0:
keep(i.getDirCacheEntry());
break;
case 0xFFD:
if (hId.equals(iId)) {
dce=i.getDirCacheEntry();
if (f == null || f.isModified(dce,true,config_filemode(),repo.getFS())) conflict(name,i.getDirCacheEntry(),h,m);
 else remove(name);
}
 else conflict(name,i.getDirCacheEntry(),h,m);
break;
case 0x0DF:
if (!isModified(name)) update(name,mId,m.getEntryFileMode());
 else conflict(name,i.getDirCacheEntry(),h,m);
break;
default :
keep(i.getDirCacheEntry());
}
return;
}
if ((ffMask & 0x222) == 0) return;
if ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {
conflict(name,null,h,m);
}
if (i == null) {
if (h == null) update(name,mId,m.getEntryFileMode());
 else if (m == null) remove(name);
 else update(name,mId,m.getEntryFileMode());
}
 else {
dce=i.getDirCacheEntry();
if (h == null) {
if (m == null || mId.equals(iId)) {
if (m == null && walk.isDirectoryFileConflict()) {
if (dce != null && (f == null || f.isModified(dce,true,config_filemode(),repo.getFS()))) conflict(name,i.getDirCacheEntry(),h,m);
 else remove(name);
}
 else keep(i.getDirCacheEntry());
}
 else conflict(name,i.getDirCacheEntry(),h,m);
}
 else if (m == null) {
if (hId.equals(iId)) {
if (f == null || f.isModified(dce,true,config_filemode(),repo.getFS())) conflict(name,i.getDirCacheEntry(),h,m);
 else remove(name);
}
 else conflict(name,i.getDirCacheEntry(),h,m);
}
 else {
if (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId)) conflict(name,i.getDirCacheEntry(),h,m);
 else if (hId.equals(iId) && !mId.equals(iId)) {
if (dce != null && (f == null || f.isModified(dce,true,config_filemode(),repo.getFS()))) conflict(name,i.getDirCacheEntry(),h,m);
 else update(name,mId,m.getEntryFileMode());
}
 else {
keep(i.getDirCacheEntry());
}
}
}
}","/** 
 * Here the main work is done. This method is called for each existing path in head, index and merge. This method decides what to do with the corresponding index entry: keep it, update it, remove it or mark a conflict.
 * @param h the entry for the head
 * @param m the entry for the merge
 * @param i the entry for the index
 * @param f the file in the working tree
 * @throws IOException
 */
void processEntry(AbstractTreeIterator h,AbstractTreeIterator m,DirCacheBuildIterator i,WorkingTreeIterator f) throws IOException {
  DirCacheEntry dce;
  String name=walk.getPathString();
  if (i == null && m == null && h == null) {
    if (walk.isDirectoryFileConflict())     conflict(name,null,null,null);
    return;
  }
  ObjectId iId=(i == null ? null : i.getEntryObjectId());
  ObjectId mId=(m == null ? null : m.getEntryObjectId());
  ObjectId hId=(h == null ? null : h.getEntryObjectId());
  int ffMask=0;
  if (h != null)   ffMask=FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;
  if (i != null)   ffMask|=FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0 : 0x0F0;
  if (m != null)   ffMask|=FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D : 0x00F;
  if (((ffMask & 0x222) != 0x000) && (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {
switch (ffMask) {
case 0xDDF:
      if (isModified(name)) {
        conflict(name,i.getDirCacheEntry(),h,m);
      }
 else {
        update(name,m.getEntryObjectId(),m.getEntryFileMode());
      }
    break;
case 0xDFD:
  remove(name);
break;
case 0xF0D:
remove(name);
break;
case 0xDFF:
case 0xFDD:
break;
case 0xD0F:
update(name,mId,m.getEntryFileMode());
break;
case 0xDF0:
case 0x0FD:
conflict(name,(i != null) ? i.getDirCacheEntry() : null,h,m);
break;
case 0xFDF:
if (hId.equals(mId)) {
if (isModified(name)) conflict(name,i.getDirCacheEntry(),h,m);
 else update(name,mId,m.getEntryFileMode());
}
 else if (!isModified(name)) update(name,mId,m.getEntryFileMode());
 else conflict(name,i.getDirCacheEntry(),h,m);
break;
case 0xFD0:
keep(i.getDirCacheEntry());
break;
case 0xFFD:
if (hId.equals(iId)) {
dce=i.getDirCacheEntry();
if (f == null || f.isModified(dce,true,config_filemode(),repo.getFS())) conflict(name,i.getDirCacheEntry(),h,m);
 else remove(name);
}
 else conflict(name,i.getDirCacheEntry(),h,m);
break;
case 0x0DF:
if (!isModified(name)) update(name,mId,m.getEntryFileMode());
 else conflict(name,i.getDirCacheEntry(),h,m);
break;
default :
keep(i.getDirCacheEntry());
}
return;
}
if ((ffMask & 0x222) == 0) return;
if ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {
conflict(name,null,h,m);
}
if (i == null) {
if (h == null) update(name,mId,m.getEntryFileMode());
 else if (m == null) remove(name);
 else update(name,mId,m.getEntryFileMode());
}
 else {
dce=i.getDirCacheEntry();
if (h == null) {
if (m == null || mId.equals(iId)) {
if (m == null && walk.isDirectoryFileConflict()) {
if (dce != null && (f == null || f.isModified(dce,true,config_filemode(),repo.getFS()))) conflict(name,i.getDirCacheEntry(),h,m);
 else remove(name);
}
 else keep(i.getDirCacheEntry());
}
 else conflict(name,i.getDirCacheEntry(),h,m);
}
 else if (m == null) {
if (hId.equals(iId)) {
if (f == null || f.isModified(dce,true,config_filemode(),repo.getFS())) conflict(name,i.getDirCacheEntry(),h,m);
 else remove(name);
}
 else conflict(name,i.getDirCacheEntry(),h,m);
}
 else {
if (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId)) conflict(name,i.getDirCacheEntry(),h,m);
 else if (hId.equals(iId) && !mId.equals(iId)) {
if (dce != null && (f == null || f.isModified(dce,true,config_filemode(),repo.getFS()))) conflict(name,i.getDirCacheEntry(),h,m);
 else update(name,mId,m.getEntryFileMode());
}
 else {
keep(i.getDirCacheEntry());
}
}
}
}",0.998415632426723
91342,"/** 
 * Here the main work is done. This method is called for each existing path in head, index and merge. This method decides what to do with the corresponding index entry: keep it, update it, remove it or mark a conflict.
 * @param h the entry for the head
 * @param m the entry for the merge
 * @param i the entry for the index
 * @param f the file in the working tree
 * @throws IOException
 */
void processEntry(AbstractTreeIterator h,AbstractTreeIterator m,DirCacheBuildIterator i,WorkingTreeIterator f) throws IOException {
  DirCacheEntry dce;
  String name=walk.getPathString();
  if (i == null && m == null && h == null) {
    if (walk.isDirectoryFileConflict())     conflict(name,null,h,m);
    return;
  }
  ObjectId iId=(i == null ? null : i.getEntryObjectId());
  ObjectId mId=(m == null ? null : m.getEntryObjectId());
  ObjectId hId=(h == null ? null : h.getEntryObjectId());
  int ffMask=0;
  if (h != null)   ffMask=FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;
  if (i != null)   ffMask|=FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0 : 0x0F0;
  if (m != null)   ffMask|=FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D : 0x00F;
  if (((ffMask & 0x222) != 0x000) && (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {
switch (ffMask) {
case 0xDDF:
      if (isModified(name)) {
        conflict(name,i.getDirCacheEntry(),h,m);
      }
 else {
        update(name,m.getEntryObjectId(),m.getEntryFileMode());
      }
    break;
case 0xDFD:
  remove(name);
break;
case 0xF0D:
remove(name);
break;
case 0xDFF:
case 0xFDD:
break;
case 0xD0F:
update(name,mId,m.getEntryFileMode());
break;
case 0xDF0:
case 0x0FD:
conflict(name,(i != null) ? i.getDirCacheEntry() : null,h,m);
break;
case 0xFDF:
if (hId.equals(mId)) {
if (isModified(name)) conflict(name,i.getDirCacheEntry(),h,m);
 else update(name,mId,m.getEntryFileMode());
}
 else if (!isModified(name)) update(name,mId,m.getEntryFileMode());
 else conflict(name,i.getDirCacheEntry(),h,m);
break;
case 0xFD0:
keep(i.getDirCacheEntry());
break;
case 0xFFD:
if (hId.equals(iId)) {
dce=i.getDirCacheEntry();
if (f == null || f.isModified(dce,true,config_filemode(),repo.getFS())) conflict(name,i.getDirCacheEntry(),h,m);
 else remove(name);
}
 else conflict(name,i.getDirCacheEntry(),h,m);
break;
case 0x0DF:
if (!isModified(name)) update(name,mId,m.getEntryFileMode());
 else conflict(name,i.getDirCacheEntry(),h,m);
break;
default :
keep(i.getDirCacheEntry());
}
return;
}
if ((ffMask & 0x222) == 0) return;
if ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {
conflict(name,null,h,m);
}
if (i == null) {
if (h == null) update(name,mId,m.getEntryFileMode());
 else if (m == null) remove(name);
 else update(name,mId,m.getEntryFileMode());
}
 else {
dce=i.getDirCacheEntry();
if (h == null) {
if (m == null || mId.equals(iId)) {
if (m == null && walk.isDirectoryFileConflict()) {
if (dce != null && (f == null || f.isModified(dce,true,config_filemode(),repo.getFS()))) conflict(name,i.getDirCacheEntry(),h,m);
 else remove(name);
}
 else keep(i.getDirCacheEntry());
}
 else conflict(name,i.getDirCacheEntry(),h,m);
}
 else if (m == null) {
if (hId.equals(iId)) {
if (f == null || f.isModified(dce,true,config_filemode(),repo.getFS())) conflict(name,i.getDirCacheEntry(),h,m);
 else remove(name);
}
 else conflict(name,i.getDirCacheEntry(),h,m);
}
 else {
if (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId)) conflict(name,i.getDirCacheEntry(),h,m);
 else if (hId.equals(iId) && !mId.equals(iId)) {
if (dce != null && (f == null || f.isModified(dce,true,config_filemode(),repo.getFS()))) conflict(name,i.getDirCacheEntry(),h,m);
 else update(name,mId,m.getEntryFileMode());
}
 else {
keep(i.getDirCacheEntry());
}
}
}
}","/** 
 * Here the main work is done. This method is called for each existing path in head, index and merge. This method decides what to do with the corresponding index entry: keep it, update it, remove it or mark a conflict.
 * @param h the entry for the head
 * @param m the entry for the merge
 * @param i the entry for the index
 * @param f the file in the working tree
 * @throws IOException
 */
void processEntry(AbstractTreeIterator h,AbstractTreeIterator m,DirCacheBuildIterator i,WorkingTreeIterator f) throws IOException {
  DirCacheEntry dce;
  String name=walk.getPathString();
  if (i == null && m == null && h == null) {
    if (walk.isDirectoryFileConflict())     conflict(name,null,null,null);
    return;
  }
  ObjectId iId=(i == null ? null : i.getEntryObjectId());
  ObjectId mId=(m == null ? null : m.getEntryObjectId());
  ObjectId hId=(h == null ? null : h.getEntryObjectId());
  int ffMask=0;
  if (h != null)   ffMask=FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;
  if (i != null)   ffMask|=FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0 : 0x0F0;
  if (m != null)   ffMask|=FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D : 0x00F;
  if (((ffMask & 0x222) != 0x000) && (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {
switch (ffMask) {
case 0xDDF:
      if (isModified(name)) {
        conflict(name,i.getDirCacheEntry(),h,m);
      }
 else {
        update(name,m.getEntryObjectId(),m.getEntryFileMode());
      }
    break;
case 0xDFD:
  remove(name);
break;
case 0xF0D:
remove(name);
break;
case 0xDFF:
case 0xFDD:
break;
case 0xD0F:
update(name,mId,m.getEntryFileMode());
break;
case 0xDF0:
case 0x0FD:
conflict(name,(i != null) ? i.getDirCacheEntry() : null,h,m);
break;
case 0xFDF:
if (hId.equals(mId)) {
if (isModified(name)) conflict(name,i.getDirCacheEntry(),h,m);
 else update(name,mId,m.getEntryFileMode());
}
 else if (!isModified(name)) update(name,mId,m.getEntryFileMode());
 else conflict(name,i.getDirCacheEntry(),h,m);
break;
case 0xFD0:
keep(i.getDirCacheEntry());
break;
case 0xFFD:
if (hId.equals(iId)) {
dce=i.getDirCacheEntry();
if (f == null || f.isModified(dce,true,config_filemode(),repo.getFS())) conflict(name,i.getDirCacheEntry(),h,m);
 else remove(name);
}
 else conflict(name,i.getDirCacheEntry(),h,m);
break;
case 0x0DF:
if (!isModified(name)) update(name,mId,m.getEntryFileMode());
 else conflict(name,i.getDirCacheEntry(),h,m);
break;
default :
keep(i.getDirCacheEntry());
}
return;
}
if ((ffMask & 0x222) == 0) return;
if ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {
conflict(name,null,h,m);
}
if (i == null) {
if (h == null) update(name,mId,m.getEntryFileMode());
 else if (m == null) remove(name);
 else update(name,mId,m.getEntryFileMode());
}
 else {
dce=i.getDirCacheEntry();
if (h == null) {
if (m == null || mId.equals(iId)) {
if (m == null && walk.isDirectoryFileConflict()) {
if (dce != null && (f == null || f.isModified(dce,true,config_filemode(),repo.getFS()))) conflict(name,i.getDirCacheEntry(),h,m);
 else remove(name);
}
 else keep(i.getDirCacheEntry());
}
 else conflict(name,i.getDirCacheEntry(),h,m);
}
 else if (m == null) {
if (hId.equals(iId)) {
if (f == null || f.isModified(dce,true,config_filemode(),repo.getFS())) conflict(name,i.getDirCacheEntry(),h,m);
 else remove(name);
}
 else conflict(name,i.getDirCacheEntry(),h,m);
}
 else {
if (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId)) conflict(name,i.getDirCacheEntry(),h,m);
 else if (hId.equals(iId) && !mId.equals(iId)) {
if (dce != null && (f == null || f.isModified(dce,true,config_filemode(),repo.getFS()))) conflict(name,i.getDirCacheEntry(),h,m);
 else update(name,mId,m.getEntryFileMode());
}
 else {
keep(i.getDirCacheEntry());
}
}
}
}",0.998415632426723
91343,"/** 
 * Does the three way merge between a common base and two sequences.
 * @param < S > type of sequence.
 * @param cmp comparison method for this execution.
 * @param base the common base sequence
 * @param ours the first sequence to be merged
 * @param theirs the second sequence to be merged
 * @return the resulting content
 */
public static <S extends Sequence>MergeResult<S> merge(SequenceComparator<S> cmp,S base,S ours,S theirs){
  List<S> sequences=new ArrayList<S>(3);
  sequences.add(base);
  sequences.add(ours);
  sequences.add(theirs);
  MergeResult result=new MergeResult<S>(sequences);
  EditList oursEdits=MyersDiff.INSTANCE.diff(cmp,base,ours);
  Iterator<Edit> baseToOurs=oursEdits.iterator();
  EditList theirsEdits=MyersDiff.INSTANCE.diff(cmp,base,theirs);
  Iterator<Edit> baseToTheirs=theirsEdits.iterator();
  int current=0;
  Edit oursEdit=nextEdit(baseToOurs);
  Edit theirsEdit=nextEdit(baseToTheirs);
  while (theirsEdit != END_EDIT || oursEdit != END_EDIT) {
    if (oursEdit.getEndA() <= theirsEdit.getBeginA()) {
      if (current != oursEdit.getBeginA()) {
        result.add(0,current,oursEdit.getBeginA(),ConflictState.NO_CONFLICT);
      }
      result.add(1,oursEdit.getBeginB(),oursEdit.getEndB(),ConflictState.NO_CONFLICT);
      current=oursEdit.getEndA();
      oursEdit=nextEdit(baseToOurs);
    }
 else     if (theirsEdit.getEndA() <= oursEdit.getBeginA()) {
      if (current != theirsEdit.getBeginA()) {
        result.add(0,current,theirsEdit.getBeginA(),ConflictState.NO_CONFLICT);
      }
      result.add(2,theirsEdit.getBeginB(),theirsEdit.getEndB(),ConflictState.NO_CONFLICT);
      current=theirsEdit.getEndA();
      theirsEdit=nextEdit(baseToTheirs);
    }
 else {
      if (oursEdit.getBeginA() != current && theirsEdit.getBeginA() != current) {
        result.add(0,current,Math.min(oursEdit.getBeginA(),theirsEdit.getBeginA()),ConflictState.NO_CONFLICT);
      }
      int oursBeginB=oursEdit.getBeginB();
      int theirsBeginB=theirsEdit.getBeginB();
      if (oursEdit.getBeginA() < theirsEdit.getBeginA()) {
        theirsBeginB-=theirsEdit.getBeginA() - oursEdit.getBeginA();
      }
 else {
        oursBeginB-=oursEdit.getBeginA() - theirsEdit.getBeginA();
      }
      Edit nextOursEdit=nextEdit(baseToOurs);
      Edit nextTheirsEdit=nextEdit(baseToTheirs);
      for (; ; ) {
        if (oursEdit.getEndA() > nextTheirsEdit.getBeginA()) {
          theirsEdit=nextTheirsEdit;
          nextTheirsEdit=nextEdit(baseToTheirs);
        }
 else         if (theirsEdit.getEndA() > nextOursEdit.getBeginA()) {
          oursEdit=nextOursEdit;
          nextOursEdit=nextEdit(baseToOurs);
        }
 else {
          break;
        }
      }
      int oursEndB=oursEdit.getEndB();
      int theirsEndB=theirsEdit.getEndB();
      if (oursEdit.getEndA() < theirsEdit.getEndA()) {
        oursEndB+=theirsEdit.getEndA() - oursEdit.getEndA();
      }
 else {
        theirsEndB+=oursEdit.getEndA() - theirsEdit.getEndA();
      }
      int conflictLen=Math.min(oursEndB - oursBeginB,theirsEndB - theirsBeginB);
      int commonPrefix=0;
      while (commonPrefix < conflictLen && cmp.equals(ours,oursBeginB + commonPrefix,theirs,theirsBeginB + commonPrefix))       commonPrefix++;
      conflictLen-=commonPrefix;
      int commonSuffix=0;
      while (commonSuffix < conflictLen && cmp.equals(ours,oursEndB - commonSuffix - 1,theirs,theirsEndB - commonSuffix - 1))       commonSuffix++;
      conflictLen-=commonSuffix;
      if (commonPrefix > 0)       result.add(1,oursBeginB,oursBeginB + commonPrefix,ConflictState.NO_CONFLICT);
      if (conflictLen > 0) {
        result.add(1,oursBeginB + commonPrefix,oursEndB - commonSuffix,ConflictState.FIRST_CONFLICTING_RANGE);
        result.add(2,theirsBeginB + commonPrefix,theirsEndB - commonSuffix,ConflictState.NEXT_CONFLICTING_RANGE);
      }
      if (commonSuffix > 0)       result.add(1,oursEndB - commonSuffix,oursEndB,ConflictState.NO_CONFLICT);
      current=Math.max(oursEdit.getEndA(),theirsEdit.getEndA());
      oursEdit=nextOursEdit;
      theirsEdit=nextTheirsEdit;
    }
  }
  if (current < base.size()) {
    result.add(0,current,base.size(),ConflictState.NO_CONFLICT);
  }
  return result;
}","/** 
 * Does the three way merge between a common base and two sequences.
 * @param < S > type of sequence.
 * @param cmp comparison method for this execution.
 * @param base the common base sequence
 * @param ours the first sequence to be merged
 * @param theirs the second sequence to be merged
 * @return the resulting content
 */
public static <S extends Sequence>MergeResult<S> merge(SequenceComparator<S> cmp,S base,S ours,S theirs){
  List<S> sequences=new ArrayList<S>(3);
  sequences.add(base);
  sequences.add(ours);
  sequences.add(theirs);
  MergeResult result=new MergeResult<S>(sequences);
  EditList oursEdits=MyersDiff.INSTANCE.diff(cmp,base,ours);
  Iterator<Edit> baseToOurs=oursEdits.iterator();
  EditList theirsEdits=MyersDiff.INSTANCE.diff(cmp,base,theirs);
  Iterator<Edit> baseToTheirs=theirsEdits.iterator();
  int current=0;
  Edit oursEdit=nextEdit(baseToOurs);
  Edit theirsEdit=nextEdit(baseToTheirs);
  while (theirsEdit != END_EDIT || oursEdit != END_EDIT) {
    if (oursEdit.getEndA() <= theirsEdit.getBeginA()) {
      if (current != oursEdit.getBeginA()) {
        result.add(0,current,oursEdit.getBeginA(),ConflictState.NO_CONFLICT);
      }
      result.add(1,oursEdit.getBeginB(),oursEdit.getEndB(),ConflictState.NO_CONFLICT);
      current=oursEdit.getEndA();
      oursEdit=nextEdit(baseToOurs);
    }
 else     if (theirsEdit.getEndA() <= oursEdit.getBeginA()) {
      if (current != theirsEdit.getBeginA()) {
        result.add(0,current,theirsEdit.getBeginA(),ConflictState.NO_CONFLICT);
      }
      result.add(2,theirsEdit.getBeginB(),theirsEdit.getEndB(),ConflictState.NO_CONFLICT);
      current=theirsEdit.getEndA();
      theirsEdit=nextEdit(baseToTheirs);
    }
 else {
      if (oursEdit.getBeginA() != current && theirsEdit.getBeginA() != current) {
        result.add(0,current,Math.min(oursEdit.getBeginA(),theirsEdit.getBeginA()),ConflictState.NO_CONFLICT);
      }
      int oursBeginB=oursEdit.getBeginB();
      int theirsBeginB=theirsEdit.getBeginB();
      if (oursEdit.getBeginA() < theirsEdit.getBeginA()) {
        theirsBeginB-=theirsEdit.getBeginA() - oursEdit.getBeginA();
      }
 else {
        oursBeginB-=oursEdit.getBeginA() - theirsEdit.getBeginA();
      }
      Edit nextOursEdit=nextEdit(baseToOurs);
      Edit nextTheirsEdit=nextEdit(baseToTheirs);
      for (; ; ) {
        if (oursEdit.getEndA() > nextTheirsEdit.getBeginA()) {
          theirsEdit=nextTheirsEdit;
          nextTheirsEdit=nextEdit(baseToTheirs);
        }
 else         if (theirsEdit.getEndA() > nextOursEdit.getBeginA()) {
          oursEdit=nextOursEdit;
          nextOursEdit=nextEdit(baseToOurs);
        }
 else {
          break;
        }
      }
      int oursEndB=oursEdit.getEndB();
      int theirsEndB=theirsEdit.getEndB();
      if (oursEdit.getEndA() < theirsEdit.getEndA()) {
        oursEndB+=theirsEdit.getEndA() - oursEdit.getEndA();
      }
 else {
        theirsEndB+=oursEdit.getEndA() - theirsEdit.getEndA();
      }
      int minBSize=oursEndB - oursBeginB;
      int BSizeDelta=minBSize - (theirsEndB - theirsBeginB);
      if (BSizeDelta > 0)       minBSize-=BSizeDelta;
      int commonPrefix=0;
      while (commonPrefix < minBSize && cmp.equals(ours,oursBeginB + commonPrefix,theirs,theirsBeginB + commonPrefix))       commonPrefix++;
      minBSize-=commonPrefix;
      int commonSuffix=0;
      while (commonSuffix < minBSize && cmp.equals(ours,oursEndB - commonSuffix - 1,theirs,theirsEndB - commonSuffix - 1))       commonSuffix++;
      minBSize-=commonSuffix;
      if (commonPrefix > 0)       result.add(1,oursBeginB,oursBeginB + commonPrefix,ConflictState.NO_CONFLICT);
      if (minBSize > 0 || BSizeDelta != 0) {
        result.add(1,oursBeginB + commonPrefix,oursEndB - commonSuffix,ConflictState.FIRST_CONFLICTING_RANGE);
        result.add(2,theirsBeginB + commonPrefix,theirsEndB - commonSuffix,ConflictState.NEXT_CONFLICTING_RANGE);
      }
      if (commonSuffix > 0)       result.add(1,oursEndB - commonSuffix,oursEndB,ConflictState.NO_CONFLICT);
      current=Math.max(oursEdit.getEndA(),theirsEdit.getEndA());
      oursEdit=nextOursEdit;
      theirsEdit=nextTheirsEdit;
    }
  }
  if (current < base.size()) {
    result.add(0,current,base.size(),ConflictState.NO_CONFLICT);
  }
  return result;
}",0.9534883720930232
91344,"/** 
 * Does the three way merge between a common base and two sequences.
 * @param < S > type of sequence.
 * @param cmp comparison method for this execution.
 * @param base the common base sequence
 * @param ours the first sequence to be merged
 * @param theirs the second sequence to be merged
 * @return the resulting content
 */
public static <S extends Sequence>MergeResult<S> merge(SequenceComparator<S> cmp,S base,S ours,S theirs){
  List<S> sequences=new ArrayList<S>(3);
  sequences.add(base);
  sequences.add(ours);
  sequences.add(theirs);
  MergeResult result=new MergeResult<S>(sequences);
  EditList oursEdits=MyersDiff.INSTANCE.diff(cmp,base,ours);
  Iterator<Edit> baseToOurs=oursEdits.iterator();
  EditList theirsEdits=MyersDiff.INSTANCE.diff(cmp,base,theirs);
  Iterator<Edit> baseToTheirs=theirsEdits.iterator();
  int current=0;
  Edit oursEdit=nextEdit(baseToOurs);
  Edit theirsEdit=nextEdit(baseToTheirs);
  while (theirsEdit != END_EDIT || oursEdit != END_EDIT) {
    if (oursEdit.getEndA() <= theirsEdit.getBeginA()) {
      if (current != oursEdit.getBeginA()) {
        result.add(0,current,oursEdit.getBeginA(),ConflictState.NO_CONFLICT);
      }
      result.add(1,oursEdit.getBeginB(),oursEdit.getEndB(),ConflictState.NO_CONFLICT);
      current=oursEdit.getEndA();
      oursEdit=nextEdit(baseToOurs);
    }
 else     if (theirsEdit.getEndA() <= oursEdit.getBeginA()) {
      if (current != theirsEdit.getBeginA()) {
        result.add(0,current,theirsEdit.getBeginA(),ConflictState.NO_CONFLICT);
      }
      result.add(2,theirsEdit.getBeginB(),theirsEdit.getEndB(),ConflictState.NO_CONFLICT);
      current=theirsEdit.getEndA();
      theirsEdit=nextEdit(baseToTheirs);
    }
 else {
      if (oursEdit.getBeginA() != current && theirsEdit.getBeginA() != current) {
        result.add(0,current,Math.min(oursEdit.getBeginA(),theirsEdit.getBeginA()),ConflictState.NO_CONFLICT);
      }
      int oursBeginB=oursEdit.getBeginB();
      int theirsBeginB=theirsEdit.getBeginB();
      if (oursEdit.getBeginA() < theirsEdit.getBeginA()) {
        theirsBeginB-=theirsEdit.getBeginA() - oursEdit.getBeginA();
      }
 else {
        oursBeginB-=oursEdit.getBeginA() - theirsEdit.getBeginA();
      }
      Edit nextOursEdit=nextEdit(baseToOurs);
      Edit nextTheirsEdit=nextEdit(baseToTheirs);
      for (; ; ) {
        if (oursEdit.getEndA() > nextTheirsEdit.getBeginA()) {
          theirsEdit=nextTheirsEdit;
          nextTheirsEdit=nextEdit(baseToTheirs);
        }
 else         if (theirsEdit.getEndA() > nextOursEdit.getBeginA()) {
          oursEdit=nextOursEdit;
          nextOursEdit=nextEdit(baseToOurs);
        }
 else {
          break;
        }
      }
      int oursEndB=oursEdit.getEndB();
      int theirsEndB=theirsEdit.getEndB();
      if (oursEdit.getEndA() < theirsEdit.getEndA()) {
        oursEndB+=theirsEdit.getEndA() - oursEdit.getEndA();
      }
 else {
        theirsEndB+=oursEdit.getEndA() - theirsEdit.getEndA();
      }
      int conflictLen=Math.min(oursEndB - oursBeginB,theirsEndB - theirsBeginB);
      int commonPrefix=0;
      while (commonPrefix < conflictLen && cmp.equals(ours,oursBeginB + commonPrefix,theirs,theirsBeginB + commonPrefix))       commonPrefix++;
      conflictLen-=commonPrefix;
      int commonSuffix=0;
      while (commonSuffix < conflictLen && cmp.equals(ours,oursEndB - commonSuffix - 1,theirs,theirsEndB - commonSuffix - 1))       commonSuffix++;
      conflictLen-=commonSuffix;
      if (commonPrefix > 0)       result.add(1,oursBeginB,oursBeginB + commonPrefix,ConflictState.NO_CONFLICT);
      if (conflictLen > 0) {
        result.add(1,oursBeginB + commonPrefix,oursEndB - commonSuffix,ConflictState.FIRST_CONFLICTING_RANGE);
        result.add(2,theirsBeginB + commonPrefix,theirsEndB - commonSuffix,ConflictState.NEXT_CONFLICTING_RANGE);
      }
      if (commonSuffix > 0)       result.add(1,oursEndB - commonSuffix,oursEndB,ConflictState.NO_CONFLICT);
      current=Math.max(oursEdit.getEndA(),theirsEdit.getEndA());
      oursEdit=nextOursEdit;
      theirsEdit=nextTheirsEdit;
    }
  }
  if (current < base.size()) {
    result.add(0,current,base.size(),ConflictState.NO_CONFLICT);
  }
  return result;
}","/** 
 * Does the three way merge between a common base and two sequences.
 * @param < S > type of sequence.
 * @param cmp comparison method for this execution.
 * @param base the common base sequence
 * @param ours the first sequence to be merged
 * @param theirs the second sequence to be merged
 * @return the resulting content
 */
public static <S extends Sequence>MergeResult<S> merge(SequenceComparator<S> cmp,S base,S ours,S theirs){
  List<S> sequences=new ArrayList<S>(3);
  sequences.add(base);
  sequences.add(ours);
  sequences.add(theirs);
  MergeResult result=new MergeResult<S>(sequences);
  EditList oursEdits=MyersDiff.INSTANCE.diff(cmp,base,ours);
  Iterator<Edit> baseToOurs=oursEdits.iterator();
  EditList theirsEdits=MyersDiff.INSTANCE.diff(cmp,base,theirs);
  Iterator<Edit> baseToTheirs=theirsEdits.iterator();
  int current=0;
  Edit oursEdit=nextEdit(baseToOurs);
  Edit theirsEdit=nextEdit(baseToTheirs);
  while (theirsEdit != END_EDIT || oursEdit != END_EDIT) {
    if (oursEdit.getEndA() <= theirsEdit.getBeginA()) {
      if (current != oursEdit.getBeginA()) {
        result.add(0,current,oursEdit.getBeginA(),ConflictState.NO_CONFLICT);
      }
      result.add(1,oursEdit.getBeginB(),oursEdit.getEndB(),ConflictState.NO_CONFLICT);
      current=oursEdit.getEndA();
      oursEdit=nextEdit(baseToOurs);
    }
 else     if (theirsEdit.getEndA() <= oursEdit.getBeginA()) {
      if (current != theirsEdit.getBeginA()) {
        result.add(0,current,theirsEdit.getBeginA(),ConflictState.NO_CONFLICT);
      }
      result.add(2,theirsEdit.getBeginB(),theirsEdit.getEndB(),ConflictState.NO_CONFLICT);
      current=theirsEdit.getEndA();
      theirsEdit=nextEdit(baseToTheirs);
    }
 else {
      if (oursEdit.getBeginA() != current && theirsEdit.getBeginA() != current) {
        result.add(0,current,Math.min(oursEdit.getBeginA(),theirsEdit.getBeginA()),ConflictState.NO_CONFLICT);
      }
      int oursBeginB=oursEdit.getBeginB();
      int theirsBeginB=theirsEdit.getBeginB();
      if (oursEdit.getBeginA() < theirsEdit.getBeginA()) {
        theirsBeginB-=theirsEdit.getBeginA() - oursEdit.getBeginA();
      }
 else {
        oursBeginB-=oursEdit.getBeginA() - theirsEdit.getBeginA();
      }
      Edit nextOursEdit=nextEdit(baseToOurs);
      Edit nextTheirsEdit=nextEdit(baseToTheirs);
      for (; ; ) {
        if (oursEdit.getEndA() > nextTheirsEdit.getBeginA()) {
          theirsEdit=nextTheirsEdit;
          nextTheirsEdit=nextEdit(baseToTheirs);
        }
 else         if (theirsEdit.getEndA() > nextOursEdit.getBeginA()) {
          oursEdit=nextOursEdit;
          nextOursEdit=nextEdit(baseToOurs);
        }
 else {
          break;
        }
      }
      int oursEndB=oursEdit.getEndB();
      int theirsEndB=theirsEdit.getEndB();
      if (oursEdit.getEndA() < theirsEdit.getEndA()) {
        oursEndB+=theirsEdit.getEndA() - oursEdit.getEndA();
      }
 else {
        theirsEndB+=oursEdit.getEndA() - theirsEdit.getEndA();
      }
      int minBSize=oursEndB - oursBeginB;
      int BSizeDelta=minBSize - (theirsEndB - theirsBeginB);
      if (BSizeDelta > 0)       minBSize-=BSizeDelta;
      int commonPrefix=0;
      while (commonPrefix < minBSize && cmp.equals(ours,oursBeginB + commonPrefix,theirs,theirsBeginB + commonPrefix))       commonPrefix++;
      minBSize-=commonPrefix;
      int commonSuffix=0;
      while (commonSuffix < minBSize && cmp.equals(ours,oursEndB - commonSuffix - 1,theirs,theirsEndB - commonSuffix - 1))       commonSuffix++;
      minBSize-=commonSuffix;
      if (commonPrefix > 0)       result.add(1,oursBeginB,oursBeginB + commonPrefix,ConflictState.NO_CONFLICT);
      if (minBSize > 0 || BSizeDelta != 0) {
        result.add(1,oursBeginB + commonPrefix,oursEndB - commonSuffix,ConflictState.FIRST_CONFLICTING_RANGE);
        result.add(2,theirsBeginB + commonPrefix,theirsEndB - commonSuffix,ConflictState.NEXT_CONFLICTING_RANGE);
      }
      if (commonSuffix > 0)       result.add(1,oursEndB - commonSuffix,oursEndB,ConflictState.NO_CONFLICT);
      current=Math.max(oursEdit.getEndA(),theirsEdit.getEndA());
      oursEdit=nextOursEdit;
      theirsEdit=nextTheirsEdit;
    }
  }
  if (current < base.size()) {
    result.add(0,current,base.size(),ConflictState.NO_CONFLICT);
  }
  return result;
}",0.9534883720930232
91345,"@Override public byte[] idBuffer(){
  if (currentSubtree != null)   return subtreeId;
  if (currentEntry != null)   return currentEntry.idBuffer();
  return zeroid;
}","@Override public byte[] idBuffer(){
  if (currentSubtree != null)   return currentSubtree.isValid() ? subtreeId : zeroid;
  if (currentEntry != null)   return currentEntry.idBuffer();
  return zeroid;
}",0.9021739130434784
91346,"private void parseEntry(){
  currentEntry=cache.getEntry(ptr);
  final byte[] cep=currentEntry.path;
  if (nextSubtreePos != tree.getChildCount()) {
    final DirCacheTree s=tree.getChild(nextSubtreePos);
    if (s.contains(cep,pathOffset,cep.length)) {
      currentSubtree=s;
      nextSubtreePos++;
      if (s.isValid())       s.getObjectId().copyRawTo(subtreeId,0);
 else       Arrays.fill(subtreeId,(byte)0);
      mode=FileMode.TREE.getBits();
      path=cep;
      pathLen=pathOffset + s.nameLength();
      return;
    }
  }
  mode=currentEntry.getRawMode();
  path=cep;
  pathLen=cep.length;
  currentSubtree=null;
}","private void parseEntry(){
  currentEntry=cache.getEntry(ptr);
  final byte[] cep=currentEntry.path;
  if (nextSubtreePos != tree.getChildCount()) {
    final DirCacheTree s=tree.getChild(nextSubtreePos);
    if (s.contains(cep,pathOffset,cep.length)) {
      currentSubtree=s;
      nextSubtreePos++;
      if (s.isValid())       s.getObjectId().copyRawTo(subtreeId,0);
      mode=FileMode.TREE.getBits();
      path=cep;
      pathLen=pathOffset + s.nameLength();
      return;
    }
  }
  mode=currentEntry.getRawMode();
  path=cep;
  pathLen=cep.length;
  currentSubtree=null;
}",0.9635761589403974
91347,"/** 
 * Compare two tree's current ObjectId values for equality.
 * @param nthA first tree to compare the object id from.
 * @param nthB second tree to compare the object id from.
 * @return result of<code>getObjectId(nthA).equals(getObjectId(nthB))</code>.
 * @see #getObjectId(int)
 */
public boolean idEqual(final int nthA,final int nthB){
  final AbstractTreeIterator ch=currentHead;
  final AbstractTreeIterator a=trees[nthA];
  final AbstractTreeIterator b=trees[nthB];
  if (a.matches == ch && b.matches == ch)   return a.idEqual(b);
  if (a.matches != ch && b.matches != ch) {
    return true;
  }
  return false;
}","/** 
 * Compare two tree's current ObjectId values for equality.
 * @param nthA first tree to compare the object id from.
 * @param nthB second tree to compare the object id from.
 * @return result of<code>getObjectId(nthA).equals(getObjectId(nthB))</code>.
 * @see #getObjectId(int)
 */
public boolean idEqual(final int nthA,final int nthB){
  final AbstractTreeIterator ch=currentHead;
  final AbstractTreeIterator a=trees[nthA];
  final AbstractTreeIterator b=trees[nthB];
  if (a.matches != ch && b.matches != ch) {
    return true;
  }
  if (!a.hasId() || !b.hasId())   return false;
  if (a.matches == ch && b.matches == ch)   return a.idEqual(b);
  return false;
}",0.8438948995363215
91348,"private static int common(long[] srcHash,int srcIdx,long[] dstHash,int dstIdx){
  if (srcIdx == srcHash.length || dstIdx == dstHash.length)   return 0;
  int common=0;
  int srcKey=keyOf(srcHash[srcIdx]);
  int dstKey=keyOf(dstHash[dstIdx]);
  for (; ; ) {
    if (srcKey == dstKey) {
      common+=countOf(dstHash[dstIdx]);
      if (++srcIdx == srcHash.length)       break;
      srcKey=keyOf(srcHash[srcIdx]);
      if (++dstIdx == dstHash.length)       break;
      dstKey=keyOf(dstHash[dstIdx]);
    }
 else     if (srcKey < dstKey) {
      if (++srcIdx == srcHash.length)       break;
      srcKey=keyOf(srcHash[srcIdx]);
    }
 else {
      if (++dstIdx == dstHash.length)       break;
      dstKey=keyOf(dstHash[dstIdx]);
    }
  }
  return common;
}","private static int common(long[] srcHash,int srcIdx,long[] dstHash,int dstIdx){
  if (srcIdx == srcHash.length || dstIdx == dstHash.length)   return 0;
  int common=0;
  int srcKey=keyOf(srcHash[srcIdx]);
  int dstKey=keyOf(dstHash[dstIdx]);
  for (; ; ) {
    if (srcKey == dstKey) {
      common+=Math.min(countOf(srcHash[srcIdx]),countOf(dstHash[dstIdx]));
      if (++srcIdx == srcHash.length)       break;
      srcKey=keyOf(srcHash[srcIdx]);
      if (++dstIdx == dstHash.length)       break;
      dstKey=keyOf(dstHash[dstIdx]);
    }
 else     if (srcKey < dstKey) {
      if (++srcIdx == srcHash.length)       break;
      srcKey=keyOf(srcHash[srcIdx]);
    }
 else {
      if (++dstIdx == dstHash.length)       break;
      dstKey=keyOf(dstHash[dstIdx]);
    }
  }
  return common;
}",0.9580915538362348
91349,"private void inflate(final Source src,final long inflatedSize,final byte[] dst,final boolean keep) throws IOException {
  final Inflater inf=inflater;
  try {
    int off=0;
    long cnt=0;
    int p=fill(src,24);
    inf.setInput(buf,p,bAvail);
    do {
      int r=inf.inflate(dst,off,dst.length - off);
      if (r == 0) {
        if (inf.finished())         break;
        if (inf.needsInput()) {
          if (p >= 0) {
            crc.update(buf,p,bAvail);
            use(bAvail);
          }
          p=fill(src,24);
          inf.setInput(buf,p,bAvail);
        }
 else {
          throw new CorruptObjectException(MessageFormat.format(JGitText.get().packfileCorruptionDetected,JGitText.get().unknownZlibError));
        }
      }
      cnt+=r;
      if (keep)       off+=r;
    }
 while (cnt < inflatedSize);
    if (!inf.finished() || cnt != inflatedSize) {
      throw new CorruptObjectException(MessageFormat.format(JGitText.get().packfileCorruptionDetected,JGitText.get().wrongDecompressedLength));
    }
    int left=bAvail - inf.getRemaining();
    if (left > 0) {
      crc.update(buf,p,left);
      use(left);
    }
  }
 catch (  DataFormatException dfe) {
    throw new CorruptObjectException(MessageFormat.format(JGitText.get().packfileCorruptionDetected,dfe.getMessage()));
  }
 finally {
    inf.reset();
  }
}","private void inflate(final Source src,final long inflatedSize,final byte[] dst,final boolean keep) throws IOException {
  final Inflater inf=inflater;
  try {
    int off=0;
    long cnt=0;
    int p=fill(src,24);
    inf.setInput(buf,p,bAvail);
    for (; ; ) {
      int r=inf.inflate(dst,off,dst.length - off);
      if (r == 0) {
        if (inf.finished())         break;
        if (inf.needsInput()) {
          if (p >= 0) {
            crc.update(buf,p,bAvail);
            use(bAvail);
          }
          p=fill(src,24);
          inf.setInput(buf,p,bAvail);
        }
 else {
          throw new CorruptObjectException(MessageFormat.format(JGitText.get().packfileCorruptionDetected,JGitText.get().unknownZlibError));
        }
      }
      cnt+=r;
      if (keep)       off+=r;
    }
    if (cnt != inflatedSize) {
      throw new CorruptObjectException(MessageFormat.format(JGitText.get().packfileCorruptionDetected,JGitText.get().wrongDecompressedLength));
    }
    int left=bAvail - inf.getRemaining();
    if (left > 0) {
      crc.update(buf,p,left);
      use(left);
    }
  }
 catch (  DataFormatException dfe) {
    throw new CorruptObjectException(MessageFormat.format(JGitText.get().packfileCorruptionDetected,dfe.getMessage()));
  }
 finally {
    inf.reset();
  }
}",0.9718202589489718
91350,"/** 
 * Query the Eclipse Foundation's IPzilla database for CQ records. <p> Updates the local   {@code .eclipse_iplog} configuration file with currentinformation by deleting CQs which are no longer relevant, and adding or updating any CQs which currently exist in the database.
 * @param file local file to update with current CQ records.
 * @param base base https:// URL of the IPzilla server.
 * @param username username to login to IPzilla as. Must be a Bugzilla username of someone authorized to query the project's IPzilla records.
 * @param password password for  {@code username}.
 * @throws IOException IPzilla cannot be queried, or the local file cannot be read from or written to.
 * @throws ConfigInvalidException the local file cannot be read, as it is not a valid configuration file format.
 */
public void syncCQs(File file,URL base,String username,String password) throws IOException, ConfigInvalidException {
  if (!file.getParentFile().exists())   file.getParentFile().mkdirs();
  LockFile lf=new LockFile(file);
  if (!lf.lock())   throw new IOException(MessageFormat.format(IpLogText.get().cannotLock,file));
  try {
    FileBasedConfig cfg=new FileBasedConfig(file);
    cfg.load();
    loadFrom(cfg);
    IPZillaQuery ipzilla=new IPZillaQuery(base,username,password);
    Set<CQ> current=ipzilla.getCQs(projects);
    for (    CQ cq : sort(current,CQ.COMPARATOR)) {
      String id=Long.toString(cq.getID());
      set(cfg,S_CQ,id,K_DESCRIPTION,cq.getDescription());
      set(cfg,S_CQ,id,K_LICENSE,cq.getLicense());
      set(cfg,S_CQ,id,K_USE,cq.getUse());
      set(cfg,S_CQ,id,K_STATE,cq.getState());
      set(cfg,S_CQ,id,K_COMMENTS,cq.getComments());
    }
    for (    CQ cq : cqs) {
      if (!current.contains(cq))       cfg.unsetSection(S_CQ,Long.toString(cq.getID()));
    }
    lf.write(Constants.encode(cfg.toText()));
    if (!lf.commit())     throw new IOException(MessageFormat.format(IpLogText.get().cannotWrite,file));
  }
  finally {
    lf.unlock();
  }
}","/** 
 * Query the Eclipse Foundation's IPzilla database for CQ records. <p> Updates the local   {@code .eclipse_iplog} configuration file with currentinformation by deleting CQs which are no longer relevant, and adding or updating any CQs which currently exist in the database.
 * @param file local file to update with current CQ records.
 * @param fs the file system abstraction which will be necessary to perform certain file system operations.
 * @param base base https:// URL of the IPzilla server.
 * @param username username to login to IPzilla as. Must be a Bugzilla username of someone authorized to query the project's IPzilla records.
 * @param password password for  {@code username}.
 * @throws IOException IPzilla cannot be queried, or the local file cannot be read from or written to.
 * @throws ConfigInvalidException the local file cannot be read, as it is not a valid configuration file format.
 */
public void syncCQs(File file,FS fs,URL base,String username,String password) throws IOException, ConfigInvalidException {
  if (!file.getParentFile().exists())   file.getParentFile().mkdirs();
  LockFile lf=new LockFile(file,fs);
  if (!lf.lock())   throw new IOException(MessageFormat.format(IpLogText.get().cannotLock,file));
  try {
    FileBasedConfig cfg=new FileBasedConfig(file,fs);
    cfg.load();
    loadFrom(cfg);
    IPZillaQuery ipzilla=new IPZillaQuery(base,username,password);
    Set<CQ> current=ipzilla.getCQs(projects);
    for (    CQ cq : sort(current,CQ.COMPARATOR)) {
      String id=Long.toString(cq.getID());
      set(cfg,S_CQ,id,K_DESCRIPTION,cq.getDescription());
      set(cfg,S_CQ,id,K_LICENSE,cq.getLicense());
      set(cfg,S_CQ,id,K_USE,cq.getUse());
      set(cfg,S_CQ,id,K_STATE,cq.getState());
      set(cfg,S_CQ,id,K_COMMENTS,cq.getComments());
    }
    for (    CQ cq : cqs) {
      if (!current.contains(cq))       cfg.unsetSection(S_CQ,Long.toString(cq.getID()));
    }
    lf.write(Constants.encode(cfg.toText()));
    if (!lf.commit())     throw new IOException(MessageFormat.format(IpLogText.get().cannotWrite,file));
  }
  finally {
    lf.unlock();
  }
}",0.970817120622568
91351,"@Override protected void setUp() throws Exception {
  super.setUp();
  if (shutdownHook == null) {
    shutdownHook=new Thread(){
      @Override public void run(){
        System.gc();
        recursiveDelete(""String_Node_Str"",trash,false,false);
      }
    }
;
    Runtime.getRuntime().addShutdownHook(shutdownHook);
  }
  recursiveDelete(testName(),trash,true,false);
  mockSystemReader=new MockSystemReader();
  mockSystemReader.userGitConfig=new FileBasedConfig(new File(trash,""String_Node_Str""));
  ceilTestDirectories(getCeilings());
  SystemReader.setInstance(mockSystemReader);
  final long now=mockSystemReader.getCurrentTime();
  final int tz=mockSystemReader.getTimezone(now);
  author=new PersonIdent(""String_Node_Str"",""String_Node_Str"");
  author=new PersonIdent(author,now,tz);
  committer=new PersonIdent(""String_Node_Str"",""String_Node_Str"");
  committer=new PersonIdent(committer,now,tz);
  final WindowCacheConfig c=new WindowCacheConfig();
  c.setPackedGitLimit(128 * WindowCacheConfig.KB);
  c.setPackedGitWindowSize(8 * WindowCacheConfig.KB);
  c.setPackedGitMMAP(useMMAP);
  c.setDeltaBaseCacheLimit(8 * WindowCacheConfig.KB);
  WindowCache.reconfigure(c);
}","@Override protected void setUp() throws Exception {
  super.setUp();
  if (shutdownHook == null) {
    shutdownHook=new Thread(){
      @Override public void run(){
        System.gc();
        recursiveDelete(""String_Node_Str"",trash,false,false);
      }
    }
;
    Runtime.getRuntime().addShutdownHook(shutdownHook);
  }
  recursiveDelete(testName(),trash,true,false);
  mockSystemReader=new MockSystemReader();
  mockSystemReader.userGitConfig=new FileBasedConfig(new File(trash,""String_Node_Str""),FS.DETECTED);
  ceilTestDirectories(getCeilings());
  SystemReader.setInstance(mockSystemReader);
  final long now=mockSystemReader.getCurrentTime();
  final int tz=mockSystemReader.getTimezone(now);
  author=new PersonIdent(""String_Node_Str"",""String_Node_Str"");
  author=new PersonIdent(author,now,tz);
  committer=new PersonIdent(""String_Node_Str"",""String_Node_Str"");
  committer=new PersonIdent(committer,now,tz);
  final WindowCacheConfig c=new WindowCacheConfig();
  c.setPackedGitLimit(128 * WindowCacheConfig.KB);
  c.setPackedGitWindowSize(8 * WindowCacheConfig.KB);
  c.setPackedGitMMAP(useMMAP);
  c.setDeltaBaseCacheLimit(8 * WindowCacheConfig.KB);
  WindowCache.reconfigure(c);
}",0.9949452401010952
91352,"public MockSystemReader(){
  init(Constants.OS_USER_NAME_KEY);
  init(Constants.GIT_AUTHOR_NAME_KEY);
  init(Constants.GIT_AUTHOR_EMAIL_KEY);
  init(Constants.GIT_COMMITTER_NAME_KEY);
  init(Constants.GIT_COMMITTER_EMAIL_KEY);
  userGitConfig=new FileBasedConfig(null){
    @Override public void load() throws IOException, ConfigInvalidException {
    }
    @Override public boolean isOutdated(){
      return false;
    }
  }
;
}","public MockSystemReader(){
  init(Constants.OS_USER_NAME_KEY);
  init(Constants.GIT_AUTHOR_NAME_KEY);
  init(Constants.GIT_AUTHOR_EMAIL_KEY);
  init(Constants.GIT_COMMITTER_NAME_KEY);
  init(Constants.GIT_COMMITTER_EMAIL_KEY);
  userGitConfig=new FileBasedConfig(null,null){
    @Override public void load() throws IOException, ConfigInvalidException {
    }
    @Override public boolean isOutdated(){
      return false;
    }
  }
;
}",0.9942196531791908
91353,"private void writeFile(final File p,final byte[] bin) throws IOException, ObjectWritingException {
  final LockFile lck=new LockFile(p);
  if (!lck.lock())   throw new ObjectWritingException(""String_Node_Str"" + p);
  try {
    lck.write(bin);
  }
 catch (  IOException ioe) {
    throw new ObjectWritingException(""String_Node_Str"" + p);
  }
  if (!lck.commit())   throw new ObjectWritingException(""String_Node_Str"" + p);
}","private void writeFile(final File p,final byte[] bin) throws IOException, ObjectWritingException {
  final LockFile lck=new LockFile(p,db.getFS());
  if (!lck.lock())   throw new ObjectWritingException(""String_Node_Str"" + p);
  try {
    lck.write(bin);
  }
 catch (  IOException ioe) {
    throw new ObjectWritingException(""String_Node_Str"" + p);
  }
  if (!lck.commit())   throw new ObjectWritingException(""String_Node_Str"" + p);
}",0.9871345029239766
91354,"private void detachHead() throws IOException {
  final String head=db.getFullBranch();
  final ObjectId id=db.resolve(Constants.HEAD);
  if (!ObjectId.isId(head) && id != null) {
    final LockFile lf;
    lf=new LockFile(new File(db.getDirectory(),Constants.HEAD));
    if (!lf.lock())     throw new IOException(MessageFormat.format(CLIText.get().cannotLock,Constants.HEAD));
    lf.write(id);
    if (!lf.commit())     throw new IOException(CLIText.get().cannotDeatchHEAD);
  }
}","private void detachHead() throws IOException {
  final String head=db.getFullBranch();
  final ObjectId id=db.resolve(Constants.HEAD);
  if (!ObjectId.isId(head) && id != null) {
    final LockFile lf;
    lf=new LockFile(new File(db.getDirectory(),Constants.HEAD),db.getFS());
    if (!lf.lock())     throw new IOException(MessageFormat.format(CLIText.get().cannotLock,Constants.HEAD));
    lf.write(id);
    if (!lf.commit())     throw new IOException(CLIText.get().cannotDeatchHEAD);
  }
}",0.9886947584789312
91355,"@Override protected void writeFile(final String name,final byte[] content) throws IOException {
  final File file=new File(db.getDirectory(),name);
  final LockFile lck=new LockFile(file);
  if (!lck.lock())   throw new ObjectWritingException(MessageFormat.format(CLIText.get().cantWrite,file));
  try {
    lck.write(content);
  }
 catch (  IOException ioe) {
    throw new ObjectWritingException(MessageFormat.format(CLIText.get().cantWrite,file));
  }
  if (!lck.commit())   throw new ObjectWritingException(MessageFormat.format(CLIText.get().cantWrite,file));
}","@Override protected void writeFile(final String name,final byte[] content) throws IOException {
  final File file=new File(db.getDirectory(),name);
  final LockFile lck=new LockFile(file,db.getFS());
  if (!lck.lock())   throw new ObjectWritingException(MessageFormat.format(CLIText.get().cantWrite,file));
  try {
    lck.write(content);
  }
 catch (  IOException ioe) {
    throw new ObjectWritingException(MessageFormat.format(CLIText.get().cantWrite,file));
  }
  if (!lck.commit())   throw new ObjectWritingException(MessageFormat.format(CLIText.get().cantWrite,file));
}",0.990359333917616
91356,"private void recreateRefs() throws Exception {
  final Map<String,Ref> refs=computeNewRefs();
  new RefWriter(refs.values()){
    @Override protected void writeFile(    final String name,    final byte[] content) throws IOException {
      final File file=new File(db.getDirectory(),name);
      final LockFile lck=new LockFile(file);
      if (!lck.lock())       throw new ObjectWritingException(MessageFormat.format(CLIText.get().cantWrite,file));
      try {
        lck.write(content);
      }
 catch (      IOException ioe) {
        throw new ObjectWritingException(MessageFormat.format(CLIText.get().cantWrite,file));
      }
      if (!lck.commit())       throw new ObjectWritingException(MessageFormat.format(CLIText.get().cantWrite,file));
    }
  }
.writePackedRefs();
}","private void recreateRefs() throws Exception {
  final Map<String,Ref> refs=computeNewRefs();
  new RefWriter(refs.values()){
    @Override protected void writeFile(    final String name,    final byte[] content) throws IOException {
      final File file=new File(db.getDirectory(),name);
      final LockFile lck=new LockFile(file,db.getFS());
      if (!lck.lock())       throw new ObjectWritingException(MessageFormat.format(CLIText.get().cantWrite,file));
      try {
        lck.write(content);
      }
 catch (      IOException ioe) {
        throw new ObjectWritingException(MessageFormat.format(CLIText.get().cantWrite,file));
      }
      if (!lck.commit())       throw new ObjectWritingException(MessageFormat.format(CLIText.get().cantWrite,file));
    }
  }
.writePackedRefs();
}",0.993006993006993
91357,"@Override protected void run() throws Exception {
  if (CookieHandler.getDefault() == null)   CookieHandler.setDefault(new SimpleCookieManager());
  final IpLogGenerator log=new IpLogGenerator();
  if (commitId == null) {
    System.err.println(MessageFormat.format(CLIText.get().warningNoCommitGivenOnCommandLine,Constants.HEAD));
    commitId=db.resolve(Constants.HEAD);
  }
  final RevWalk rw=new RevWalk(db);
  final RevObject start=rw.parseAny(commitId);
  if (version == null && start instanceof RevTag)   version=((RevTag)start).getTagName();
 else   if (version == null)   throw die(MessageFormat.format(CLIText.get().notATagVersionIsRequired,start.name()));
  log.scan(db,rw.parseCommit(start),version);
  if (output != null) {
    if (!output.getParentFile().exists())     output.getParentFile().mkdirs();
    LockFile lf=new LockFile(output);
    if (!lf.lock())     throw die(MessageFormat.format(CLIText.get().cannotLock,output));
    try {
      OutputStream os=lf.getOutputStream();
      try {
        log.writeTo(os);
      }
  finally {
        os.close();
      }
      if (!lf.commit())       throw die(MessageFormat.format(CLIText.get().cannotWrite,output));
    }
  finally {
      lf.unlock();
    }
  }
 else {
    log.writeTo(System.out);
    System.out.flush();
  }
}","@Override protected void run() throws Exception {
  if (CookieHandler.getDefault() == null)   CookieHandler.setDefault(new SimpleCookieManager());
  final IpLogGenerator log=new IpLogGenerator();
  if (commitId == null) {
    System.err.println(MessageFormat.format(CLIText.get().warningNoCommitGivenOnCommandLine,Constants.HEAD));
    commitId=db.resolve(Constants.HEAD);
  }
  final RevWalk rw=new RevWalk(db);
  final RevObject start=rw.parseAny(commitId);
  if (version == null && start instanceof RevTag)   version=((RevTag)start).getTagName();
 else   if (version == null)   throw die(MessageFormat.format(CLIText.get().notATagVersionIsRequired,start.name()));
  log.scan(db,rw.parseCommit(start),version);
  if (output != null) {
    if (!output.getParentFile().exists())     output.getParentFile().mkdirs();
    LockFile lf=new LockFile(output,db.getFS());
    if (!lf.lock())     throw die(MessageFormat.format(CLIText.get().cannotLock,output));
    try {
      OutputStream os=lf.getOutputStream();
      try {
        log.writeTo(os);
      }
  finally {
        os.close();
      }
      if (!lf.commit())       throw die(MessageFormat.format(CLIText.get().cannotWrite,output));
    }
  finally {
      lf.unlock();
    }
  }
 else {
    log.writeTo(System.out);
    System.out.flush();
  }
}",0.9957643434732384
91358,"@Override protected void run() throws Exception {
  if (CookieHandler.getDefault() == null)   CookieHandler.setDefault(new SimpleCookieManager());
  final URL ipzilla=new URL(url);
  if (username == null) {
    final PasswordAuthentication auth=Authenticator.requestPasswordAuthentication(ipzilla.getHost(),null,ipzilla.getPort(),ipzilla.getProtocol(),CLIText.get().IPZillaPasswordPrompt,ipzilla.getProtocol(),ipzilla,Authenticator.RequestorType.SERVER);
    username=auth.getUserName();
    password=new String(auth.getPassword());
  }
  if (output == null)   output=new File(db.getWorkTree(),IpLogMeta.IPLOG_CONFIG_FILE);
  IpLogMeta meta=new IpLogMeta();
  meta.syncCQs(output,ipzilla,username,password);
}","@Override protected void run() throws Exception {
  if (CookieHandler.getDefault() == null)   CookieHandler.setDefault(new SimpleCookieManager());
  final URL ipzilla=new URL(url);
  if (username == null) {
    final PasswordAuthentication auth=Authenticator.requestPasswordAuthentication(ipzilla.getHost(),null,ipzilla.getPort(),ipzilla.getProtocol(),CLIText.get().IPZillaPasswordPrompt,ipzilla.getProtocol(),ipzilla,Authenticator.RequestorType.SERVER);
    username=auth.getUserName();
    password=new String(auth.getPassword());
  }
  if (output == null)   output=new File(db.getWorkTree(),IpLogMeta.IPLOG_CONFIG_FILE);
  IpLogMeta meta=new IpLogMeta();
  meta.syncCQs(output,db.getFS(),ipzilla,username,password);
}",0.992302309307208
91359,"@Override public int parseArguments(final Parameters params) throws CmdLineException {
  final String name=params.getParameter(0);
  if (new File(name).isDirectory()) {
    setter.addValue(new FileTreeIterator(new File(name),FS.DETECTED));
    return 1;
  }
  if (new File(name).isFile()) {
    final DirCache dirc;
    try {
      dirc=DirCache.read(new File(name));
    }
 catch (    IOException e) {
      throw new CmdLineException(MessageFormat.format(CLIText.get().notAnIndexFile,name),e);
    }
    setter.addValue(new DirCacheIterator(dirc));
    return 1;
  }
  final ObjectId id;
  try {
    id=clp.getRepository().resolve(name);
  }
 catch (  IOException e) {
    throw new CmdLineException(e.getMessage());
  }
  if (id == null)   throw new CmdLineException(MessageFormat.format(CLIText.get().notATree,name));
  final CanonicalTreeParser p=new CanonicalTreeParser();
  final ObjectReader curs=clp.getRepository().newObjectReader();
  try {
    p.reset(curs,clp.getRevWalk().parseTree(id));
  }
 catch (  MissingObjectException e) {
    throw new CmdLineException(MessageFormat.format(CLIText.get().notATree,name));
  }
catch (  IncorrectObjectTypeException e) {
    throw new CmdLineException(MessageFormat.format(CLIText.get().notATree,name));
  }
catch (  IOException e) {
    throw new CmdLineException(MessageFormat.format(CLIText.get().cannotReadBecause,name,e.getMessage()));
  }
 finally {
    curs.release();
  }
  setter.addValue(p);
  return 1;
}","@Override public int parseArguments(final Parameters params) throws CmdLineException {
  final String name=params.getParameter(0);
  if (new File(name).isDirectory()) {
    setter.addValue(new FileTreeIterator(new File(name),FS.DETECTED));
    return 1;
  }
  if (new File(name).isFile()) {
    final DirCache dirc;
    try {
      dirc=DirCache.read(new File(name),FS.DETECTED);
    }
 catch (    IOException e) {
      throw new CmdLineException(MessageFormat.format(CLIText.get().notAnIndexFile,name),e);
    }
    setter.addValue(new DirCacheIterator(dirc));
    return 1;
  }
  final ObjectId id;
  try {
    id=clp.getRepository().resolve(name);
  }
 catch (  IOException e) {
    throw new CmdLineException(e.getMessage());
  }
  if (id == null)   throw new CmdLineException(MessageFormat.format(CLIText.get().notATree,name));
  final CanonicalTreeParser p=new CanonicalTreeParser();
  final ObjectReader curs=clp.getRepository().newObjectReader();
  try {
    p.reset(curs,clp.getRevWalk().parseTree(id));
  }
 catch (  MissingObjectException e) {
    throw new CmdLineException(MessageFormat.format(CLIText.get().notATree,name));
  }
catch (  IncorrectObjectTypeException e) {
    throw new CmdLineException(MessageFormat.format(CLIText.get().notATree,name));
  }
catch (  IOException e) {
    throw new CmdLineException(MessageFormat.format(CLIText.get().cannotReadBecause,name,e.getMessage()));
  }
 finally {
    curs.release();
  }
  setter.addValue(p);
  return 1;
}",0.9959294436906376
91360,"public void testLockMissing_TempIndex() throws Exception {
  final File idx=new File(db.getDirectory(),""String_Node_Str"");
  final File lck=new File(db.getDirectory(),""String_Node_Str"");
  assertFalse(idx.exists());
  assertFalse(lck.exists());
  final DirCache dc=DirCache.lock(idx);
  assertNotNull(dc);
  assertFalse(idx.exists());
  assertTrue(lck.exists());
  assertEquals(0,dc.getEntryCount());
  dc.unlock();
  assertFalse(idx.exists());
  assertFalse(lck.exists());
}","public void testLockMissing_TempIndex() throws Exception {
  final File idx=new File(db.getDirectory(),""String_Node_Str"");
  final File lck=new File(db.getDirectory(),""String_Node_Str"");
  assertFalse(idx.exists());
  assertFalse(lck.exists());
  final DirCache dc=DirCache.lock(idx,db.getFS());
  assertNotNull(dc);
  assertFalse(idx.exists());
  assertTrue(lck.exists());
  assertEquals(0,dc.getEntryCount());
  dc.unlock();
  assertFalse(idx.exists());
  assertFalse(lck.exists());
}",0.988553590010406
91361,"public void testReadMissing_TempIndex() throws Exception {
  final File idx=new File(db.getDirectory(),""String_Node_Str"");
  assertFalse(idx.exists());
  final DirCache dc=DirCache.read(idx);
  assertNotNull(dc);
  assertEquals(0,dc.getEntryCount());
}","public void testReadMissing_TempIndex() throws Exception {
  final File idx=new File(db.getDirectory(),""String_Node_Str"");
  assertFalse(idx.exists());
  final DirCache dc=DirCache.read(idx,db.getFS());
  assertNotNull(dc);
  assertEquals(0,dc.getEntryCount());
}",0.9786407766990292
91362,"public void testUnsupportedRequiredExtension() throws Exception {
  final DirCache dc=new DirCache(pathOf(""String_Node_Str""));
  try {
    dc.read();
    fail(""String_Node_Str"");
  }
 catch (  CorruptObjectException err) {
    assertEquals(""String_Node_Str"" + ""String_Node_Str"",err.getMessage());
  }
}","public void testUnsupportedRequiredExtension() throws Exception {
  final DirCache dc=new DirCache(pathOf(""String_Node_Str""),FS.DETECTED);
  try {
    dc.read();
    fail(""String_Node_Str"");
  }
 catch (  CorruptObjectException err) {
    assertEquals(""String_Node_Str"" + ""String_Node_Str"",err.getMessage());
  }
}",0.9805194805194806
91363,"public void testTreeWalk_LsFiles() throws Exception {
  final Repository db=createBareRepository();
  final Map<String,CGitIndexRecord> ls=readLsFiles();
  final DirCache dc=new DirCache(index);
  assertEquals(0,dc.getEntryCount());
  dc.read();
  assertEquals(ls.size(),dc.getEntryCount());
{
    final Iterator<CGitIndexRecord> rItr=ls.values().iterator();
    final TreeWalk tw=new TreeWalk(db);
    tw.reset();
    tw.setRecursive(true);
    tw.addTree(new DirCacheIterator(dc));
    while (rItr.hasNext()) {
      final DirCacheIterator dcItr;
      assertTrue(tw.next());
      dcItr=tw.getTree(0,DirCacheIterator.class);
      assertNotNull(dcItr);
      assertEqual(rItr.next(),dcItr.getDirCacheEntry());
    }
  }
}","public void testTreeWalk_LsFiles() throws Exception {
  final Repository db=createBareRepository();
  final Map<String,CGitIndexRecord> ls=readLsFiles();
  final DirCache dc=new DirCache(index,db.getFS());
  assertEquals(0,dc.getEntryCount());
  dc.read();
  assertEquals(ls.size(),dc.getEntryCount());
{
    final Iterator<CGitIndexRecord> rItr=ls.values().iterator();
    final TreeWalk tw=new TreeWalk(db);
    tw.reset();
    tw.setRecursive(true);
    tw.addTree(new DirCacheIterator(dc));
    while (rItr.hasNext()) {
      final DirCacheIterator dcItr;
      assertTrue(tw.next());
      dcItr=tw.getTree(0,DirCacheIterator.class);
      assertNotNull(dcItr);
      assertEqual(rItr.next(),dcItr.getDirCacheEntry());
    }
  }
}",0.9924605894448252
91364,"public void testReadIndex_DirCacheTree() throws Exception {
  final Map<String,CGitIndexRecord> cList=readLsFiles();
  final Map<String,CGitLsTreeRecord> cTree=readLsTree();
  final DirCache dc=new DirCache(index);
  assertEquals(0,dc.getEntryCount());
  dc.read();
  assertEquals(cList.size(),dc.getEntryCount());
  final DirCacheTree jTree=dc.getCacheTree(false);
  assertNotNull(jTree);
  assertEquals(""String_Node_Str"",jTree.getNameString());
  assertEquals(""String_Node_Str"",jTree.getPathString());
  assertTrue(jTree.isValid());
  assertEquals(ObjectId.fromString(""String_Node_Str""),jTree.getObjectId());
  assertEquals(cList.size(),jTree.getEntrySpan());
  final ArrayList<CGitLsTreeRecord> subtrees=new ArrayList<CGitLsTreeRecord>();
  for (  final CGitLsTreeRecord r : cTree.values()) {
    if (FileMode.TREE.equals(r.mode))     subtrees.add(r);
  }
  assertEquals(subtrees.size(),jTree.getChildCount());
  for (int i=0; i < jTree.getChildCount(); i++) {
    final DirCacheTree sj=jTree.getChild(i);
    final CGitLsTreeRecord sc=subtrees.get(i);
    assertEquals(sc.path,sj.getNameString());
    assertEquals(sc.path + ""String_Node_Str"",sj.getPathString());
    assertTrue(sj.isValid());
    assertEquals(sc.id,sj.getObjectId());
  }
}","public void testReadIndex_DirCacheTree() throws Exception {
  final Map<String,CGitIndexRecord> cList=readLsFiles();
  final Map<String,CGitLsTreeRecord> cTree=readLsTree();
  final DirCache dc=new DirCache(index,FS.DETECTED);
  assertEquals(0,dc.getEntryCount());
  dc.read();
  assertEquals(cList.size(),dc.getEntryCount());
  final DirCacheTree jTree=dc.getCacheTree(false);
  assertNotNull(jTree);
  assertEquals(""String_Node_Str"",jTree.getNameString());
  assertEquals(""String_Node_Str"",jTree.getPathString());
  assertTrue(jTree.isValid());
  assertEquals(ObjectId.fromString(""String_Node_Str""),jTree.getObjectId());
  assertEquals(cList.size(),jTree.getEntrySpan());
  final ArrayList<CGitLsTreeRecord> subtrees=new ArrayList<CGitLsTreeRecord>();
  for (  final CGitLsTreeRecord r : cTree.values()) {
    if (FileMode.TREE.equals(r.mode))     subtrees.add(r);
  }
  assertEquals(subtrees.size(),jTree.getChildCount());
  for (int i=0; i < jTree.getChildCount(); i++) {
    final DirCacheTree sj=jTree.getChild(i);
    final CGitLsTreeRecord sc=subtrees.get(i);
    assertEquals(sc.path,sj.getNameString());
    assertEquals(sc.path + ""String_Node_Str"",sj.getPathString());
    assertTrue(sj.isValid());
    assertEquals(sc.id,sj.getObjectId());
  }
}",0.9952038369304556
91365,"public void testUnsupportedOptionalExtension() throws Exception {
  final DirCache dc=new DirCache(pathOf(""String_Node_Str""));
  dc.read();
  assertEquals(1,dc.getEntryCount());
  assertEquals(""String_Node_Str"",dc.getEntry(0).getPathString());
}","public void testUnsupportedOptionalExtension() throws Exception {
  final DirCache dc=new DirCache(pathOf(""String_Node_Str""),FS.DETECTED);
  dc.read();
  assertEquals(1,dc.getEntryCount());
  assertEquals(""String_Node_Str"",dc.getEntry(0).getPathString());
}",0.9760956175298804
91366,"public void testReadIndex_LsFiles() throws Exception {
  final Map<String,CGitIndexRecord> ls=readLsFiles();
  final DirCache dc=new DirCache(index);
  assertEquals(0,dc.getEntryCount());
  dc.read();
  assertEquals(ls.size(),dc.getEntryCount());
{
    final Iterator<CGitIndexRecord> rItr=ls.values().iterator();
    for (int i=0; rItr.hasNext(); i++)     assertEqual(rItr.next(),dc.getEntry(i));
  }
}","public void testReadIndex_LsFiles() throws Exception {
  final Map<String,CGitIndexRecord> ls=readLsFiles();
  final DirCache dc=new DirCache(index,FS.DETECTED);
  assertEquals(0,dc.getEntryCount());
  dc.read();
  assertEquals(ls.size(),dc.getEntryCount());
{
    final Iterator<CGitIndexRecord> rItr=ls.values().iterator();
    for (int i=0; rItr.hasNext(); i++)     assertEqual(rItr.next(),dc.getEntry(i));
  }
}",0.9853300733496332
91367,"public void testCorruptChecksumAtFooter() throws Exception {
  final DirCache dc=new DirCache(pathOf(""String_Node_Str""));
  try {
    dc.read();
    fail(""String_Node_Str"");
  }
 catch (  CorruptObjectException err) {
    assertEquals(""String_Node_Str"",err.getMessage());
  }
}","public void testCorruptChecksumAtFooter() throws Exception {
  final DirCache dc=new DirCache(pathOf(""String_Node_Str""),FS.DETECTED);
  try {
    dc.read();
    fail(""String_Node_Str"");
  }
 catch (  CorruptObjectException err) {
    assertEquals(""String_Node_Str"",err.getMessage());
  }
}",0.978798586572438
91368,"public void tryRenameWhenLocked(String toLock,String fromName,String toName,String headPointsTo) throws IOException {
  writeSymref(Constants.HEAD,headPointsTo);
  ObjectId oldfromId=db.resolve(fromName);
  ObjectId oldHeadId=db.resolve(Constants.HEAD);
  writeReflog(db,oldfromId,oldfromId,""String_Node_Str"",fromName);
  List<org.eclipse.jgit.storage.file.ReflogReader.Entry> oldFromLog=db.getReflogReader(fromName).getReverseEntries();
  List<org.eclipse.jgit.storage.file.ReflogReader.Entry> oldHeadLog=oldHeadId != null ? db.getReflogReader(Constants.HEAD).getReverseEntries() : null;
  assertTrue(""String_Node_Str"",new File(db.getDirectory(),""String_Node_Str"" + fromName).exists());
  LockFile lockFile=new LockFile(new File(db.getDirectory(),toLock));
  try {
    assertTrue(lockFile.lock());
    RefRename renameRef=db.renameRef(fromName,toName);
    Result result=renameRef.rename();
    assertEquals(Result.LOCK_FAILURE,result);
    assertExists(false,toName);
    if (!toLock.equals(toName))     assertExists(false,toName + ""String_Node_Str"");
    assertExists(true,toLock + ""String_Node_Str"");
    if (!toLock.equals(fromName))     assertExists(false,""String_Node_Str"" + fromName + ""String_Node_Str"");
    assertExists(false,""String_Node_Str"" + toName + ""String_Node_Str"");
    assertEquals(oldHeadId,db.resolve(Constants.HEAD));
    assertEquals(oldfromId,db.resolve(fromName));
    assertNull(db.resolve(toName));
    assertEquals(oldFromLog.toString(),db.getReflogReader(fromName).getReverseEntries().toString());
    if (oldHeadId != null)     assertEquals(oldHeadLog.toString(),db.getReflogReader(Constants.HEAD).getReverseEntries().toString());
  }
  finally {
    lockFile.unlock();
  }
}","public void tryRenameWhenLocked(String toLock,String fromName,String toName,String headPointsTo) throws IOException {
  writeSymref(Constants.HEAD,headPointsTo);
  ObjectId oldfromId=db.resolve(fromName);
  ObjectId oldHeadId=db.resolve(Constants.HEAD);
  writeReflog(db,oldfromId,oldfromId,""String_Node_Str"",fromName);
  List<org.eclipse.jgit.storage.file.ReflogReader.Entry> oldFromLog=db.getReflogReader(fromName).getReverseEntries();
  List<org.eclipse.jgit.storage.file.ReflogReader.Entry> oldHeadLog=oldHeadId != null ? db.getReflogReader(Constants.HEAD).getReverseEntries() : null;
  assertTrue(""String_Node_Str"",new File(db.getDirectory(),""String_Node_Str"" + fromName).exists());
  LockFile lockFile=new LockFile(new File(db.getDirectory(),toLock),db.getFS());
  try {
    assertTrue(lockFile.lock());
    RefRename renameRef=db.renameRef(fromName,toName);
    Result result=renameRef.rename();
    assertEquals(Result.LOCK_FAILURE,result);
    assertExists(false,toName);
    if (!toLock.equals(toName))     assertExists(false,toName + ""String_Node_Str"");
    assertExists(true,toLock + ""String_Node_Str"");
    if (!toLock.equals(fromName))     assertExists(false,""String_Node_Str"" + fromName + ""String_Node_Str"");
    assertExists(false,""String_Node_Str"" + toName + ""String_Node_Str"");
    assertEquals(oldHeadId,db.resolve(Constants.HEAD));
    assertEquals(oldfromId,db.resolve(fromName));
    assertNull(db.resolve(toName));
    assertEquals(oldFromLog.toString(),db.getReflogReader(fromName).getReverseEntries().toString());
    if (oldHeadId != null)     assertEquals(oldHeadLog.toString(),db.getReflogReader(Constants.HEAD).getReverseEntries().toString());
  }
  finally {
    lockFile.unlock();
  }
}",0.9967864446392054
91369,"/** 
 * Try modify a ref that is locked
 * @throws IOException
 */
public void testUpdateRefLockFailureLocked() throws IOException {
  ObjectId opid=db.resolve(""String_Node_Str"");
  ObjectId pid=db.resolve(""String_Node_Str"");
  RefUpdate updateRef=db.updateRef(""String_Node_Str"");
  updateRef.setNewObjectId(pid);
  LockFile lockFile1=new LockFile(new File(db.getDirectory(),""String_Node_Str""));
  try {
    assertTrue(lockFile1.lock());
    Result update=updateRef.update();
    assertEquals(Result.LOCK_FAILURE,update);
    assertEquals(opid,db.resolve(""String_Node_Str""));
    LockFile lockFile2=new LockFile(new File(db.getDirectory(),""String_Node_Str""));
    assertFalse(lockFile2.lock());
  }
  finally {
    lockFile1.unlock();
  }
}","/** 
 * Try modify a ref that is locked
 * @throws IOException
 */
public void testUpdateRefLockFailureLocked() throws IOException {
  ObjectId opid=db.resolve(""String_Node_Str"");
  ObjectId pid=db.resolve(""String_Node_Str"");
  RefUpdate updateRef=db.updateRef(""String_Node_Str"");
  updateRef.setNewObjectId(pid);
  LockFile lockFile1=new LockFile(new File(db.getDirectory(),""String_Node_Str""),db.getFS());
  try {
    assertTrue(lockFile1.lock());
    Result update=updateRef.update();
    assertEquals(Result.LOCK_FAILURE,update);
    assertEquals(opid,db.resolve(""String_Node_Str""));
    LockFile lockFile2=new LockFile(new File(db.getDirectory(),""String_Node_Str""),db.getFS());
    assertFalse(lockFile2.lock());
  }
  finally {
    lockFile1.unlock();
  }
}",0.985352862849534
91370,"private FileBasedConfig configFor(File gitDir) throws IOException, ConfigInvalidException {
  FileBasedConfig cfg=new FileBasedConfig(new File(gitDir,""String_Node_Str""));
  cfg.load();
  return cfg;
}","private FileBasedConfig configFor(File gitDir) throws IOException, ConfigInvalidException {
  File configPath=new File(gitDir,""String_Node_Str"");
  FileBasedConfig cfg=new FileBasedConfig(configPath,FS.DETECTED);
  cfg.load();
  return cfg;
}",0.7104072398190046
91371,"public void test006_ReadUglyConfig() throws IOException, ConfigInvalidException {
  final File cfg=new File(db.getDirectory(),""String_Node_Str"");
  final FileBasedConfig c=new FileBasedConfig(cfg);
  final FileWriter pw=new FileWriter(cfg);
  final String configStr=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  pw.write(configStr);
  pw.close();
  c.load();
  assertEquals(""String_Node_Str"",c.getString(""String_Node_Str"",null,""String_Node_Str""));
  assertEquals(""String_Node_Str"",c.getString(""String_Node_Str"",null,""String_Node_Str""));
  assertEquals(""String_Node_Str"",c.getString(""String_Node_Str"",null,""String_Node_Str""));
  assertEquals(""String_Node_Str"",c.getString(""String_Node_Str"",null,""String_Node_Str""));
  c.save();
  final FileReader fr=new FileReader(cfg);
  final char[] cbuf=new char[configStr.length()];
  fr.read(cbuf);
  fr.close();
  assertEquals(configStr,new String(cbuf));
}","public void test006_ReadUglyConfig() throws IOException, ConfigInvalidException {
  final File cfg=new File(db.getDirectory(),""String_Node_Str"");
  final FileBasedConfig c=new FileBasedConfig(cfg,db.getFS());
  final FileWriter pw=new FileWriter(cfg);
  final String configStr=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  pw.write(configStr);
  pw.close();
  c.load();
  assertEquals(""String_Node_Str"",c.getString(""String_Node_Str"",null,""String_Node_Str""));
  assertEquals(""String_Node_Str"",c.getString(""String_Node_Str"",null,""String_Node_Str""));
  assertEquals(""String_Node_Str"",c.getString(""String_Node_Str"",null,""String_Node_Str""));
  assertEquals(""String_Node_Str"",c.getString(""String_Node_Str"",null,""String_Node_Str""));
  c.save();
  final FileReader fr=new FileReader(cfg);
  final char[] cbuf=new char[configStr.length()];
  fr.read(cbuf);
  fr.close();
  assertEquals(configStr,new String(cbuf));
}",0.9943502824858758
91372,"/** 
 * Try to establish an update lock on the cache file.
 * @return true if the lock is now held by the caller; false if it is heldby someone else.
 * @throws IOException the output file could not be created. The caller does not hold the lock.
 */
public boolean lock() throws IOException {
  if (liveFile == null)   throw new IOException(JGitText.get().dirCacheDoesNotHaveABackingFile);
  final LockFile tmp=new LockFile(liveFile);
  if (tmp.lock()) {
    tmp.setNeedStatInformation(true);
    myLock=tmp;
    return true;
  }
  return false;
}","/** 
 * Try to establish an update lock on the cache file.
 * @return true if the lock is now held by the caller; false if it is heldby someone else.
 * @throws IOException the output file could not be created. The caller does not hold the lock.
 */
public boolean lock() throws IOException {
  if (liveFile == null)   throw new IOException(JGitText.get().dirCacheDoesNotHaveABackingFile);
  final LockFile tmp=new LockFile(liveFile,fs);
  if (tmp.lock()) {
    tmp.setNeedStatInformation(true);
    myLock=tmp;
    return true;
  }
  return false;
}",0.9972652689152234
91373,"/** 
 * Create a new empty index which is never stored on disk.
 * @return an empty cache which has no backing store file. The cache may notbe read or written, but it may be queried and updated (in memory).
 */
public static DirCache newInCore(){
  return new DirCache(null);
}","/** 
 * Create a new empty index which is never stored on disk.
 * @return an empty cache which has no backing store file. The cache may notbe read or written, but it may be queried and updated (in memory).
 */
public static DirCache newInCore(){
  return new DirCache(null,null);
}",0.9910554561717352
91374,"/** 
 * Create a new in-core index representation. <p> The new index will be empty. Callers may wish to read from the on disk file first with   {@link #read()}.
 * @param indexLocation location of the index file on disk.
 */
public DirCache(final File indexLocation){
  liveFile=indexLocation;
  clear();
}","/** 
 * Create a new in-core index representation. <p> The new index will be empty. Callers may wish to read from the on disk file first with   {@link #read()}.
 * @param indexLocation location of the index file on disk.
 * @param fs the file system abstraction which will be necessary to perform certain file system operations.
 */
public DirCache(final File indexLocation,final FS fs){
  liveFile=indexLocation;
  this.fs=fs;
  clear();
}",0.8203753351206434
91375,"/** 
 * Parse and load the repository specific configuration. <p> The default implementation reads   {@code gitDir/config}, or returns an empty configuration if gitDir was not set.
 * @return the repository's configuration.
 * @throws IOException the configuration is not available.
 */
protected Config loadConfig() throws IOException {
  if (getGitDir() != null) {
    File path=safeFS().resolve(getGitDir(),""String_Node_Str"");
    FileBasedConfig cfg=new FileBasedConfig(path);
    try {
      cfg.load();
    }
 catch (    ConfigInvalidException err) {
      throw new IllegalArgumentException(MessageFormat.format(JGitText.get().repositoryConfigFileInvalid,path.getAbsolutePath(),err.getMessage()));
    }
    return cfg;
  }
 else {
    return new Config();
  }
}","/** 
 * Parse and load the repository specific configuration. <p> The default implementation reads   {@code gitDir/config}, or returns an empty configuration if gitDir was not set.
 * @return the repository's configuration.
 * @throws IOException the configuration is not available.
 */
protected Config loadConfig() throws IOException {
  if (getGitDir() != null) {
    File path=safeFS().resolve(getGitDir(),""String_Node_Str"");
    FileBasedConfig cfg=new FileBasedConfig(path,safeFS());
    try {
      cfg.load();
    }
 catch (    ConfigInvalidException err) {
      throw new IllegalArgumentException(MessageFormat.format(JGitText.get().repositoryConfigFileInvalid,path.getAbsolutePath(),err.getMessage()));
    }
    return cfg;
  }
 else {
    return new Config();
  }
}",0.9941822882999354
91376,"/** 
 * Create a new in-core index representation, lock it, and read from disk. <p> The new index will be locked and then read before it is returned to the caller. Read failures are reported as exceptions and therefore prevent the method from returning a partially populated index.
 * @return a cache representing the contents of the specified index file (ifit exists) or an empty cache if the file does not exist.
 * @throws NoWorkTreeException if this is bare, which implies it has no working directory. See  {@link #isBare()}.
 * @throws IOException the index file is present but could not be read, or the lock could not be obtained.
 * @throws CorruptObjectException the index file is using a format or extension that this library does not support.
 */
public DirCache lockDirCache() throws NoWorkTreeException, CorruptObjectException, IOException {
  return DirCache.lock(getIndexFile());
}","/** 
 * Create a new in-core index representation, lock it, and read from disk. <p> The new index will be locked and then read before it is returned to the caller. Read failures are reported as exceptions and therefore prevent the method from returning a partially populated index.
 * @return a cache representing the contents of the specified index file (ifit exists) or an empty cache if the file does not exist.
 * @throws NoWorkTreeException if this is bare, which implies it has no working directory. See  {@link #isBare()}.
 * @throws IOException the index file is present but could not be read, or the lock could not be obtained.
 * @throws CorruptObjectException the index file is using a format or extension that this library does not support.
 */
public DirCache lockDirCache() throws NoWorkTreeException, CorruptObjectException, IOException {
  return DirCache.lock(getIndexFile(),getFS());
}",0.9955506117908788
91377,"/** 
 * Create a new in-core index representation and read an index from disk. <p> The new index will be read before it is returned to the caller. Read failures are reported as exceptions and therefore prevent the method from returning a partially populated index.
 * @return a cache representing the contents of the specified index file (ifit exists) or an empty cache if the file does not exist.
 * @throws NoWorkTreeException if this is bare, which implies it has no working directory. See  {@link #isBare()}.
 * @throws IOException the index file is present but could not be read.
 * @throws CorruptObjectException the index file is using a format or extension that this library does not support.
 */
public DirCache readDirCache() throws NoWorkTreeException, CorruptObjectException, IOException {
  return DirCache.read(getIndexFile());
}","/** 
 * Create a new in-core index representation and read an index from disk. <p> The new index will be read before it is returned to the caller. Read failures are reported as exceptions and therefore prevent the method from returning a partially populated index.
 * @return a cache representing the contents of the specified index file (ifit exists) or an empty cache if the file does not exist.
 * @throws NoWorkTreeException if this is bare, which implies it has no working directory. See  {@link #isBare()}.
 * @throws IOException the index file is present but could not be read.
 * @throws CorruptObjectException the index file is using a format or extension that this library does not support.
 */
public DirCache readDirCache() throws NoWorkTreeException, CorruptObjectException, IOException {
  return DirCache.read(getIndexFile(),getFS());
}",0.9952774498229044
91378,"int score(SimilarityIndex dst){
  long max=Math.max(fileSize,dst.fileSize);
  return (int)((common(dst) * 100L) / max);
}","int score(SimilarityIndex dst){
  long max=Math.max(fileSize,dst.fileSize);
  if (max == 0)   return 100;
  return (int)((common(dst) * 100L) / max);
}",0.8897058823529411
91379,"private void sendPack() throws IOException {
  final boolean thin=options.contains(OPTION_THIN_PACK);
  final boolean progress=!options.contains(OPTION_NO_PROGRESS);
  final boolean sideband=options.contains(OPTION_SIDE_BAND) || options.contains(OPTION_SIDE_BAND_64K);
  ProgressMonitor pm=NullProgressMonitor.INSTANCE;
  OutputStream packOut=rawOut;
  if (sideband) {
    int bufsz=SideBandOutputStream.SMALL_BUF;
    if (options.contains(OPTION_SIDE_BAND_64K))     bufsz=SideBandOutputStream.MAX_BUF;
    packOut=new SideBandOutputStream(SideBandOutputStream.CH_DATA,bufsz,rawOut);
    if (progress)     pm=new SideBandProgressMonitor(new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS,bufsz,rawOut));
  }
  final PackWriter pw;
  pw=new PackWriter(db);
  try {
    pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));
    pw.setThin(thin);
    pw.preparePack(pm,wantAll,commonBase);
    if (options.contains(OPTION_INCLUDE_TAG)) {
      for (      final Ref r : refs.values()) {
        final RevObject o;
        try {
          o=walk.parseAny(r.getObjectId());
        }
 catch (        IOException e) {
          continue;
        }
        if (o.has(WANT) || !(o instanceof RevTag))         continue;
        final RevTag t=(RevTag)o;
        if (!pw.willInclude(t) && pw.willInclude(t.getObject()))         pw.addObject(t);
      }
    }
    pw.writePack(pm,NullProgressMonitor.INSTANCE,packOut);
  }
  finally {
    pw.release();
  }
  packOut.flush();
  if (sideband)   pckOut.end();
}","private void sendPack() throws IOException {
  final boolean thin=options.contains(OPTION_THIN_PACK);
  final boolean progress=!options.contains(OPTION_NO_PROGRESS);
  final boolean sideband=options.contains(OPTION_SIDE_BAND) || options.contains(OPTION_SIDE_BAND_64K);
  ProgressMonitor pm=NullProgressMonitor.INSTANCE;
  OutputStream packOut=rawOut;
  if (sideband) {
    int bufsz=SideBandOutputStream.SMALL_BUF;
    if (options.contains(OPTION_SIDE_BAND_64K))     bufsz=SideBandOutputStream.MAX_BUF;
    packOut=new SideBandOutputStream(SideBandOutputStream.CH_DATA,bufsz,rawOut);
    if (progress)     pm=new SideBandProgressMonitor(new SideBandOutputStream(SideBandOutputStream.CH_PROGRESS,bufsz,rawOut));
  }
  final PackWriter pw=new PackWriter(db);
  try {
    pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));
    pw.setThin(thin);
    pw.preparePack(pm,wantAll,commonBase);
    if (options.contains(OPTION_INCLUDE_TAG)) {
      for (      final Ref r : refs.values()) {
        final RevObject o;
        try {
          o=walk.parseAny(r.getObjectId());
        }
 catch (        IOException e) {
          continue;
        }
        if (o.has(WANT) || !(o instanceof RevTag))         continue;
        final RevTag t=(RevTag)o;
        if (!pw.willInclude(t) && pw.willInclude(t.getObject()))         pw.addObject(t);
      }
    }
    pw.writePack(pm,NullProgressMonitor.INSTANCE,packOut);
  }
  finally {
    pw.release();
  }
  packOut.flush();
  if (sideband)   pckOut.end();
}",0.9980106100795756
91380,"@Override public void close(){
  endOut();
  if (errorThread != null) {
    try {
      errorThread.join();
    }
 catch (    InterruptedException e) {
    }
 finally {
      errorThread=null;
    }
  }
  super.close();
  if (channel != null) {
    try {
      exitStatus=channel.getExitStatus();
      if (channel.isConnected())       channel.disconnect();
    }
  finally {
      channel=null;
    }
  }
}","@Override public void close(){
  endOut();
  if (errorThread != null) {
    try {
      errorThread.halt();
    }
 catch (    InterruptedException e) {
    }
 finally {
      errorThread=null;
    }
  }
  super.close();
  if (channel != null) {
    try {
      exitStatus=channel.getExitStatus();
      if (channel.isConnected())       channel.disconnect();
    }
  finally {
      channel=null;
    }
  }
}",0.9901719901719902
91381,"@Override public void run(){
  try {
    final byte[] buf=new byte[BUFFER_SIZE];
    for (; ; ) {
      try {
        if (needFlush())         dst.flush();
        final int n;
        try {
          n=src.read(buf);
        }
 catch (        InterruptedIOException wakey) {
          continue;
        }
        if (n < 0)         break;
        for (; ; ) {
          try {
            dst.write(buf,0,n);
          }
 catch (          InterruptedIOException wakey) {
            continue;
          }
          break;
        }
      }
 catch (      IOException e) {
        break;
      }
    }
  }
  finally {
    try {
      src.close();
    }
 catch (    IOException e) {
    }
    try {
      dst.close();
    }
 catch (    IOException e) {
    }
  }
}","@Override public void run(){
  try {
    final byte[] buf=new byte[BUFFER_SIZE];
    for (; ; ) {
      try {
        if (needFlush())         dst.flush();
        if (done)         break;
        final int n;
        try {
          n=src.read(buf);
        }
 catch (        InterruptedIOException wakey) {
          continue;
        }
        if (n < 0)         break;
        for (; ; ) {
          try {
            dst.write(buf,0,n);
          }
 catch (          InterruptedIOException wakey) {
            continue;
          }
          break;
        }
      }
 catch (      IOException e) {
        break;
      }
    }
  }
  finally {
    try {
      src.close();
    }
 catch (    IOException e) {
    }
    try {
      dst.close();
    }
 catch (    IOException e) {
    }
  }
}",0.9787781350482316
91382,"@SuppressWarnings(""String_Node_Str"") @Override public <T>T generateValue(){
  return (T)dateFormat.format(dateFunction.generateValue());
}","@SuppressWarnings(""String_Node_Str"") @Override public <T>T generateValue(){
  Calendar date=dateFunction.generateValue();
  return (T)dateFormat.format(date.getTime());
}",0.7857142857142857
91383,"public DateAsStringFunction(DateFunction dateFunction,String pattern){
  this.dateFunction=dateFunction;
  dateFormat=new SimpleDateFormat(pattern);
}","public DateAsStringFunction(AtomicFunction dateFunction,String pattern){
  this.dateFunction=dateFunction;
  dateFormat=new SimpleDateFormat(pattern);
}",0.9735099337748344
91384,"@Test public void shouldFormatDateWithGivenPattern() throws ParseException {
  String dateString=""String_Node_Str"";
  String pattern=""String_Node_Str"";
  SimpleDateFormat dateFormat=new SimpleDateFormat(pattern);
  Date date=dateFormat.parse(dateString);
  DateFunction dateFunction=mock(DateFunction.class);
  when(dateFunction.generateValue()).thenReturn(date);
  DateAsStringFunction dateAsStringFunction=new DateAsStringFunction(dateFunction,pattern);
  assertEquals(dateString,dateAsStringFunction.generateValue());
}","@Test public void shouldFormatDateWithGivenPattern() throws ParseException {
  String dateString=""String_Node_Str"";
  String pattern=""String_Node_Str"";
  SimpleDateFormat dateFormat=new SimpleDateFormat(pattern);
  Calendar date=Calendar.getInstance();
  date.setTime(dateFormat.parse(dateString));
  DateFunction dateFunction=mock(DateFunction.class);
  when(dateFunction.generateValue()).thenReturn(date);
  DateAsStringFunction dateAsStringFunction=new DateAsStringFunction(dateFunction,pattern);
  assertEquals(dateString,dateAsStringFunction.generateValue());
}",0.9025735294117648
91385,"public static Field invokeRecursiveField(Class<?> clazz,String attribute){
  Field field=null;
  Class<?> superClass=null;
  Class<?> targetBeanClass=getTargetClass(clazz);
  for (  String propertyItem : attribute.split(""String_Node_Str"")) {
    do {
      superClass=targetBeanClass.getSuperclass();
      try {
        field=targetBeanClass.getDeclaredField(propertyItem);
        targetBeanClass=field.getType();
      }
 catch (      NoSuchFieldException e) {
        targetBeanClass=superClass;
      }
    }
 while (superClass != null && !superClass.equals(Object.class));
  }
  if (field == null) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",clazz.getName(),attribute));
  }
  return field;
}","public static Field invokeRecursiveField(Class<?> clazz,String attribute){
  Field field=null;
  Class<?> targetBeanClass=getTargetClass(clazz);
  for (  String propertyItem : attribute.split(""String_Node_Str"")) {
    field=new Mirror().on(targetBeanClass).reflect().field(propertyItem);
    if (field == null)     throw new IllegalArgumentException(String.format(""String_Node_Str"",clazz.getName(),attribute));
    targetBeanClass=field.getType();
  }
  return field;
}",0.5016722408026756
91386,"@Override @SuppressWarnings(""String_Node_Str"") public <T>T generateValue(){
  RandomFunction random=new RandomFunction(Integer.class,new Range(1,9));
  int a=random.generateValue();
  int b=random.generateValue();
  int c=random.generateValue();
  int d=random.generateValue();
  int e=random.generateValue();
  int f=random.generateValue();
  int g=random.generateValue();
  int h=random.generateValue();
  int i=random.generateValue();
  int j=(a * 10 + b * 9 + c * 8 + d * 7 + e * 6 + f * 5 + g * 4 + h * 3 + i * 2);
  j=j % 11;
  j=j <= 1 ? 0 : 11 - j;
  int m=(a * 11 + b * 10 + c * 9 + d * 8 + e * 7 + f * 6 + g * 5 + h * 4 + i * 3 + j * 2);
  m=m % 11;
  m=m <= 1 ? 0 : 11 - m;
  return (T)String.format(formatted ? ""String_Node_Str"" : ""String_Node_Str"",a,b,c,d,e,f,g,h,i,j,m);
}","@Override @SuppressWarnings(""String_Node_Str"") public <T>T generateValue(){
  RandomFunction random=new RandomFunction(Integer.class,new Range(1,9));
  Integer a=random.generateValue();
  Integer b=random.generateValue();
  Integer c=random.generateValue();
  Integer d=random.generateValue();
  Integer e=random.generateValue();
  Integer f=random.generateValue();
  Integer g=random.generateValue();
  Integer h=random.generateValue();
  Integer i=random.generateValue();
  Integer j=(a * 10 + b * 9 + c * 8 + d * 7 + e * 6 + f * 5 + g * 4 + h * 3 + i * 2);
  j=j % 11;
  j=j <= 1 ? 0 : 11 - j;
  Integer m=(a * 11 + b * 10 + c * 9 + d * 8 + e * 7 + f * 6 + g * 5 + h * 4 + i * 3 + j * 2);
  m=m % 11;
  m=m <= 1 ? 0 : 11 - m;
  return (T)String.format(formatted ? ""String_Node_Str"" : ""String_Node_Str"",a,b,c,d,e,f,g,h,i,j,m);
}",0.7524752475247525
91387,"public static Class<?> invokeRecursiveType(Object bean,String attribute){
  return invokeRecursiveType(getTargetClass(bean.getClass()),attribute);
}","public static Class<?> invokeRecursiveType(Object bean,String attribute){
  Field field=invokeRecursiveField(bean,attribute);
  return field.getType();
}",0.7574750830564784
91388,"private static Object prepareInvokeRecursiveSetter(Object bean,String attribute,Object value){
  Object targetBean=bean;
  Object lastBean=null;
  int lastAttributeIdx=attribute.lastIndexOf(""String_Node_Str"");
  String path=null;
  if (lastAttributeIdx > 0) {
    path=StringUtils.defaultIfEmpty(attribute.substring(0,lastAttributeIdx),null);
  }
  if (path != null) {
    for (    String propertyItem : path.split(""String_Node_Str"")) {
      lastBean=targetBean;
      targetBean=ReflectionUtils.invokeGetter(targetBean,propertyItem);
      if (targetBean == null) {
        try {
          targetBean=newInstance(invokeRecursiveType(lastBean.getClass(),propertyItem));
          ReflectionUtils.invokeSetter(lastBean,propertyItem,targetBean,true);
        }
 catch (        Exception e) {
          throw new IllegalArgumentException(""String_Node_Str"" + propertyItem + ""String_Node_Str""+ lastBean.getClass().getCanonicalName());
        }
      }
    }
  }
  return targetBean;
}","private static Object prepareInvokeRecursiveSetter(Object bean,String attribute,Object value){
  Object targetBean=bean;
  Object lastBean=null;
  int lastAttributeIdx=attribute.lastIndexOf(""String_Node_Str"");
  String path=null;
  if (lastAttributeIdx > 0) {
    path=StringUtils.defaultIfEmpty(attribute.substring(0,lastAttributeIdx),null);
  }
  if (path != null) {
    for (    String propertyItem : path.split(""String_Node_Str"")) {
      lastBean=targetBean;
      targetBean=ReflectionUtils.invokeGetter(targetBean,propertyItem);
      if (targetBean == null) {
        try {
          targetBean=newInstance(invokeRecursiveType(lastBean,propertyItem));
          ReflectionUtils.invokeSetter(lastBean,propertyItem,targetBean,true);
        }
 catch (        Exception e) {
          throw new IllegalArgumentException(""String_Node_Str"" + propertyItem + ""String_Node_Str""+ lastBean.getClass().getCanonicalName());
        }
      }
    }
  }
  return targetBean;
}",0.9943618657098924
91389,"/** 
 * @param resource  the resource to request
 * @param args      optional string expansion arguments (passed to String#format(String, Object...)
 * @throws java.util.IllegalFormatException - If a format string contains an illegal syntax,
 * @return the request
 * @see String#format(String,Object)
 */
public static Request to(String resource,Object... args){
  if (args != null && args.length > 0) {
    resource=String.format(resource,args);
  }
  return new Request(resource);
}","/** 
 * @param resource  the resource to request
 * @param args      optional string expansion arguments (passed to String#format(String, Object...)
 * @throws java.util.IllegalFormatException - If a format string contains an illegal syntax,
 * @return the request
 * @see String#format(String,Object)
 */
public static Request to(String resource,Object... args){
  if (args != null && args.length > 0) {
    resource=String.format(Locale.ENGLISH,resource,args);
  }
  return new Request(resource);
}",0.9847715736040608
91390,"@Override public void resourceChanged(IResourceChangeEvent event){
  Set<IResource> resources=new HashSet<>();
  IMarkerDelta[] markerDeltas=event.findMarkerDeltas(IMarker.PROBLEM,true);
  for (  IMarkerDelta delta : markerDeltas) {
    IResource resource=delta.getResource();
    while (resource.getType() != IResource.ROOT && resources.add(resource)) {
      resource=resource.getParent();
    }
  }
  if (!resources.isEmpty()) {
    updateLabels(resources);
  }
}","@Override public void resourceChanged(IResourceChangeEvent event){
  Set<IPath> paths=new HashSet<>();
  IMarkerDelta[] markerDeltas=event.findMarkerDeltas(IMarker.PROBLEM,true);
  for (  IMarkerDelta delta : markerDeltas) {
    IResource resource=delta.getResource();
    if (resource == null) {
      continue;
    }
    RepositoryMapping mapping=RepositoryMapping.getMapping(resource);
    if (mapping == null || mapping.getRepository().isBare()) {
      continue;
    }
    IPath path=resource.getLocation();
    if (path == null) {
      continue;
    }
    File workTree=mapping.getWorkTree();
    if (workTree == null) {
      continue;
    }
    int n=new Path(workTree.getAbsolutePath()).segmentCount();
    for (int i=path.segmentCount(); i > n; i--) {
      paths.add(path);
      path=path.removeLastSegments(1);
    }
  }
  if (!paths.isEmpty()) {
    updateLabels(paths);
  }
}",0.4244657332350773
91391,"private void updateLabels(Set<IResource> changedResources){
  List<Object> elements=getAffectedElements(changedResources);
  if (!elements.isEmpty()) {
    final Object[] updateElements=elements.toArray(new Object[elements.size()]);
    Display display=viewer.getControl().getDisplay();
    display.asyncExec(new Runnable(){
      @Override public void run(){
        fireLabelProviderChanged(new LabelProviderChangedEvent(ProblemLabelDecorator.this,updateElements));
      }
    }
);
  }
}","private void updateLabels(Set<IPath> changedPaths){
  List<Object> elements=getAffectedElements(changedPaths);
  if (!elements.isEmpty()) {
    final Object[] updateElements=elements.toArray(new Object[elements.size()]);
    Display display=viewer.getControl().getDisplay();
    display.asyncExec(new Runnable(){
      @Override public void run(){
        fireLabelProviderChanged(new LabelProviderChangedEvent(ProblemLabelDecorator.this,updateElements));
      }
    }
);
  }
}",0.962809917355372
91392,"private void getAffectedElements(Set<IResource> resources,Object[] elements,IStructuredContentProvider contentProvider,List<Object> result){
  for (  Object element : elements) {
    IResource resource=AdapterUtils.adapt(element,IResource.class);
    if (resource != null && resources.contains(resource)) {
      result.add(element);
      if (contentProvider instanceof ITreeContentProvider) {
        getAffectedElements(resources,((ITreeContentProvider)contentProvider).getChildren(element),contentProvider,result);
      }
    }
  }
}","private void getAffectedElements(Set<IPath> paths,Object[] elements,IStructuredContentProvider contentProvider,List<Object> result){
  for (  Object element : elements) {
    IPath path=AdapterUtils.adapt(element,IPath.class);
    if (path == null) {
      IResource resource=AdapterUtils.adapt(element,IResource.class);
      if (resource != null) {
        path=resource.getLocation();
      }
    }
    if (path != null && paths.contains(path)) {
      result.add(element);
      if (contentProvider instanceof ITreeContentProvider) {
        getAffectedElements(paths,((ITreeContentProvider)contentProvider).getChildren(element),contentProvider,result);
      }
    }
  }
}",0.7736625514403292
91393,"boolean doFetch(){
  final RefSpec spec=new RefSpec().setSource(refText.getText()).setDestination(Constants.FETCH_HEAD);
  final String uri=uriCombo.getText();
  final CheckoutMode mode=getCheckoutMode();
  final boolean doCheckoutNewBranch=(mode == CheckoutMode.CREATE_BRANCH) && branchCheckoutButton.getSelection();
  final boolean doActivateAdditionalRefs=showAdditionalRefs();
  final String textForTag=tagText.getText();
  final String textForBranch=branchText.getText();
  Job job=new WorkspaceJob(UIText.FetchGerritChangePage_GetChangeTaskName){
    @Override public IStatus runInWorkspace(    IProgressMonitor monitor){
      try {
        SubMonitor progress=SubMonitor.convert(monitor,UIText.FetchGerritChangePage_GetChangeTaskName,getTotalWork(mode));
        RevCommit commit=fetchChange(uri,spec,progress.newChild(1));
switch (mode) {
case CHECKOUT_FETCH_HEAD:
          checkout(commit.name(),progress.newChild(1));
        break;
case CREATE_TAG:
      createTag(spec,textForTag,commit,progress.newChild(1));
    checkout(commit.name(),progress.newChild(1));
  break;
case CREATE_BRANCH:
createBranch(textForBranch,doCheckoutNewBranch,commit,progress.newChild(1));
break;
default :
}
if (doActivateAdditionalRefs) {
activateAdditionalRefs();
}
if (mode == CheckoutMode.NOCHECKOUT) {
repository.fireEvent(new FetchHeadChangedEvent());
}
storeLastUsedUri(uri);
}
 catch (CoreException ce) {
return ce.getStatus();
}
catch (Exception e) {
return Activator.createErrorStatus(e.getLocalizedMessage(),e);
}
 finally {
monitor.done();
}
return Status.OK_STATUS;
}
private int getTotalWork(final CheckoutMode m){
switch (m) {
case CHECKOUT_FETCH_HEAD:
case CREATE_BRANCH:
return 2;
case CREATE_TAG:
return 3;
default :
return 1;
}
}
@Override public boolean belongsTo(Object family){
if (JobFamilies.FETCH.equals(family)) return true;
return super.belongsTo(family);
}
}
;
job.setUser(true);
job.schedule();
return true;
}","boolean doFetch(){
  final RefSpec spec=new RefSpec().setSource(refText.getText()).setDestination(Constants.FETCH_HEAD);
  final String uri=uriCombo.getText();
  final CheckoutMode mode=getCheckoutMode();
  final boolean doCheckoutNewBranch=(mode == CheckoutMode.CREATE_BRANCH) && branchCheckoutButton.getSelection();
  final boolean doActivateAdditionalRefs=showAdditionalRefs();
  final String textForTag=tagText.getText();
  final String textForBranch=branchText.getText();
  Job job=new WorkspaceJob(UIText.FetchGerritChangePage_GetChangeTaskName){
    @Override public IStatus runInWorkspace(    IProgressMonitor monitor){
      try {
        SubMonitor progress=SubMonitor.convert(monitor,UIText.FetchGerritChangePage_GetChangeTaskName,getTotalWork(mode));
        RevCommit commit=fetchChange(uri,spec,progress.newChild(1));
switch (mode) {
case CHECKOUT_FETCH_HEAD:
          checkout(commit.name(),progress.newChild(1));
        break;
case CREATE_TAG:
      createTag(spec,textForTag,commit,progress.newChild(1));
    checkout(commit.name(),progress.newChild(1));
  break;
case CREATE_BRANCH:
createBranch(textForBranch,doCheckoutNewBranch,commit,progress.newChild(1));
break;
default :
break;
}
if (doActivateAdditionalRefs) {
activateAdditionalRefs();
}
if (mode == CheckoutMode.NOCHECKOUT) {
repository.fireEvent(new FetchHeadChangedEvent());
}
storeLastUsedUri(uri);
}
 catch (CoreException ce) {
return ce.getStatus();
}
catch (Exception e) {
return Activator.createErrorStatus(e.getLocalizedMessage(),e);
}
 finally {
monitor.done();
}
return Status.OK_STATUS;
}
private int getTotalWork(final CheckoutMode m){
switch (m) {
case CHECKOUT_FETCH_HEAD:
case CREATE_BRANCH:
return 2;
case CREATE_TAG:
return 3;
default :
return 1;
}
}
@Override public boolean belongsTo(Object family){
if (JobFamilies.FETCH.equals(family)) return true;
return super.belongsTo(family);
}
}
;
job.setUser(true);
job.schedule();
return true;
}",0.9981888745148771
91394,"@Override public IStatus runInWorkspace(IProgressMonitor monitor){
  try {
    SubMonitor progress=SubMonitor.convert(monitor,UIText.FetchGerritChangePage_GetChangeTaskName,getTotalWork(mode));
    RevCommit commit=fetchChange(uri,spec,progress.newChild(1));
switch (mode) {
case CHECKOUT_FETCH_HEAD:
      checkout(commit.name(),progress.newChild(1));
    break;
case CREATE_TAG:
  createTag(spec,textForTag,commit,progress.newChild(1));
checkout(commit.name(),progress.newChild(1));
break;
case CREATE_BRANCH:
createBranch(textForBranch,doCheckoutNewBranch,commit,progress.newChild(1));
break;
default :
}
if (doActivateAdditionalRefs) {
activateAdditionalRefs();
}
if (mode == CheckoutMode.NOCHECKOUT) {
repository.fireEvent(new FetchHeadChangedEvent());
}
storeLastUsedUri(uri);
}
 catch (CoreException ce) {
return ce.getStatus();
}
catch (Exception e) {
return Activator.createErrorStatus(e.getLocalizedMessage(),e);
}
 finally {
monitor.done();
}
return Status.OK_STATUS;
}","@Override public IStatus runInWorkspace(IProgressMonitor monitor){
  try {
    SubMonitor progress=SubMonitor.convert(monitor,UIText.FetchGerritChangePage_GetChangeTaskName,getTotalWork(mode));
    RevCommit commit=fetchChange(uri,spec,progress.newChild(1));
switch (mode) {
case CHECKOUT_FETCH_HEAD:
      checkout(commit.name(),progress.newChild(1));
    break;
case CREATE_TAG:
  createTag(spec,textForTag,commit,progress.newChild(1));
checkout(commit.name(),progress.newChild(1));
break;
case CREATE_BRANCH:
createBranch(textForBranch,doCheckoutNewBranch,commit,progress.newChild(1));
break;
default :
break;
}
if (doActivateAdditionalRefs) {
activateAdditionalRefs();
}
if (mode == CheckoutMode.NOCHECKOUT) {
repository.fireEvent(new FetchHeadChangedEvent());
}
storeLastUsedUri(uri);
}
 catch (CoreException ce) {
return ce.getStatus();
}
catch (Exception e) {
return Activator.createErrorStatus(e.getLocalizedMessage(),e);
}
 finally {
monitor.done();
}
return Status.OK_STATUS;
}",0.99644128113879
91395,"@Test public void testRebaseFailOnDirtyWorkingDirectory() throws Exception {
  ErrorDialog.AUTOMATED_MODE=false;
  Git git=Git.wrap(repository);
  init();
  setContentAddAndCommit(""String_Node_Str"");
  createFeature(FEATURE_NAME);
  setContentAddAndCommit(""String_Node_Str"");
  setTestFileContent(""String_Node_Str"");
  rebaseFeature();
  acceptError(RebaseResult.Status.UNCOMMITTED_CHANGES);
  Status status=git.status().call();
  Object[] uncommitted=status.getUncommittedChanges().toArray();
  assertEquals(1,uncommitted.length);
  assertEquals(FILE1_PATH,uncommitted[0]);
}","@Test public void testRebaseFailOnDirtyWorkingDirectory() throws Exception {
  disableAutomatedMode();
  Git git=Git.wrap(repository);
  init();
  setContentAddAndCommit(""String_Node_Str"");
  createFeature(FEATURE_NAME);
  setContentAddAndCommit(""String_Node_Str"");
  setTestFileContent(""String_Node_Str"");
  rebaseFeature();
  acceptError(RebaseResult.Status.UNCOMMITTED_CHANGES);
  Status status=git.status().call();
  Object[] uncommitted=status.getUncommittedChanges().toArray();
  assertEquals(1,uncommitted.length);
  assertEquals(FILE1_PATH,uncommitted[0]);
}",0.9544658493870404
91396,"@Test public void testRebaseFailOnConflict() throws Exception {
  ErrorDialog.AUTOMATED_MODE=false;
  Git git=Git.wrap(repository);
  init();
  createFeature(FEATURE_NAME);
  setContentAddAndCommit(""String_Node_Str"");
  checkoutBranch(DEVELOP);
  setContentAddAndCommit(""String_Node_Str"");
  checkoutFeature(FEATURE_NAME);
  rebaseFeature();
  acceptError(RebaseResult.Status.STOPPED);
  Status status=git.status().call();
  Object[] conflicting=status.getConflicting().toArray();
  assertEquals(1,conflicting.length);
  assertEquals(FILE1_PATH,conflicting[0]);
  assertEquals(""String_Node_Str"",bot.activeView().getReference().getId());
}","@Test public void testRebaseFailOnConflict() throws Exception {
  disableAutomatedMode();
  Git git=Git.wrap(repository);
  init();
  createFeature(FEATURE_NAME);
  setContentAddAndCommit(""String_Node_Str"");
  checkoutBranch(DEVELOP);
  setContentAddAndCommit(""String_Node_Str"");
  checkoutFeature(FEATURE_NAME);
  rebaseFeature();
  acceptError(RebaseResult.Status.STOPPED);
  Status status=git.status().call();
  Object[] conflicting=status.getConflicting().toArray();
  assertEquals(1,conflicting.length);
  assertEquals(FILE1_PATH,conflicting[0]);
  assertEquals(""String_Node_Str"",bot.activeView().getReference().getId());
}",0.9589257503949448
91397,"/** 
 * Draw the overlays for the receiver.
 * @param overlaysArray
 */
private void drawOverlays(ImageDescriptor[] overlaysArray){
  for (int i=0; i < overlays.length; i++) {
    ImageDescriptor overlay=overlaysArray[i];
    if (overlay == null)     continue;
    ImageData overlayData=overlay.getImageData();
    if (overlayData == null)     overlayData=ImageDescriptor.getMissingImageDescriptor().getImageData();
switch (i) {
case IDecoration.TOP_LEFT:
      drawImage(overlayData,0,0);
    break;
case IDecoration.TOP_RIGHT:
  drawImage(overlayData,size.x - overlayData.width,0);
break;
case IDecoration.BOTTOM_LEFT:
drawImage(overlayData,0,size.y - overlayData.height);
break;
case IDecoration.BOTTOM_RIGHT:
drawImage(overlayData,size.x - overlayData.width,size.y - overlayData.height);
break;
}
}
}","/** 
 * Draw the overlays for the receiver.
 * @param overlaysArray
 */
private void drawOverlays(ImageDescriptor[] overlaysArray){
  for (int i=0; i < overlays.length; i++) {
    ImageDescriptor overlay=overlaysArray[i];
    if (overlay == null)     continue;
    ImageData overlayData=overlay.getImageData();
    if (overlayData == null)     overlayData=ImageDescriptor.getMissingImageDescriptor().getImageData();
switch (i) {
case IDecoration.TOP_LEFT:
      drawImage(overlayData,0,0);
    break;
case IDecoration.TOP_RIGHT:
  drawImage(overlayData,size.x - overlayData.width,0);
break;
case IDecoration.BOTTOM_LEFT:
drawImage(overlayData,0,size.y - overlayData.height);
break;
case IDecoration.BOTTOM_RIGHT:
drawImage(overlayData,size.x - overlayData.width,size.y - overlayData.height);
break;
default :
break;
}
}
}",0.9895384615384616
91398,"/** 
 * Creates a grid layout with the specified number of columns and the standard spacings.
 * @param numColumns the number of columns
 * @param converter the pixel converter
 * @param margins one of <code>MARGINS_DEFAULT</code>, <code>MARGINS_NONE</code> or <code>MARGINS_DIALOG</code>.
 * @return the created grid layout
 */
public static GridLayout createGridLayout(int numColumns,PixelConverter converter,int margins){
  Assert.isTrue(margins == MARGINS_DEFAULT || margins == MARGINS_NONE || margins == MARGINS_DIALOG);
  final GridLayout layout=new GridLayout(numColumns,false);
  layout.horizontalSpacing=converter.convertHorizontalDLUsToPixels(IDialogConstants.HORIZONTAL_SPACING);
  layout.verticalSpacing=converter.convertVerticalDLUsToPixels(IDialogConstants.VERTICAL_SPACING);
switch (margins) {
case MARGINS_NONE:
    layout.marginLeft=layout.marginRight=0;
  layout.marginTop=layout.marginBottom=0;
break;
case MARGINS_DIALOG:
layout.marginLeft=layout.marginRight=converter.convertHorizontalDLUsToPixels(IDialogConstants.HORIZONTAL_MARGIN);
layout.marginTop=layout.marginBottom=converter.convertVerticalDLUsToPixels(IDialogConstants.VERTICAL_MARGIN);
break;
case MARGINS_DEFAULT:
layout.marginLeft=layout.marginRight=layout.marginWidth;
layout.marginTop=layout.marginBottom=layout.marginHeight;
}
layout.marginWidth=layout.marginHeight=0;
return layout;
}","/** 
 * Creates a grid layout with the specified number of columns and the standard spacings.
 * @param numColumns the number of columns
 * @param converter the pixel converter
 * @param margins one of <code>MARGINS_DEFAULT</code>, <code>MARGINS_NONE</code> or <code>MARGINS_DIALOG</code>.
 * @return the created grid layout
 */
public static GridLayout createGridLayout(int numColumns,PixelConverter converter,int margins){
  Assert.isTrue(margins == MARGINS_DEFAULT || margins == MARGINS_NONE || margins == MARGINS_DIALOG);
  final GridLayout layout=new GridLayout(numColumns,false);
  layout.horizontalSpacing=converter.convertHorizontalDLUsToPixels(IDialogConstants.HORIZONTAL_SPACING);
  layout.verticalSpacing=converter.convertVerticalDLUsToPixels(IDialogConstants.VERTICAL_SPACING);
switch (margins) {
case MARGINS_NONE:
    layout.marginLeft=layout.marginRight=0;
  layout.marginTop=layout.marginBottom=0;
break;
case MARGINS_DIALOG:
layout.marginLeft=layout.marginRight=converter.convertHorizontalDLUsToPixels(IDialogConstants.HORIZONTAL_MARGIN);
layout.marginTop=layout.marginBottom=converter.convertVerticalDLUsToPixels(IDialogConstants.VERTICAL_MARGIN);
break;
case MARGINS_DEFAULT:
layout.marginLeft=layout.marginRight=layout.marginWidth;
layout.marginTop=layout.marginBottom=layout.marginHeight;
break;
default :
break;
}
layout.marginWidth=layout.marginHeight=0;
return layout;
}",0.9913169319826338
91399,"@Override protected void buttonPressed(int buttonId){
switch (buttonId) {
case IDialogConstants.PROCEED_ID:
    CommitUI commitUI=new CommitUI(getShell(),repository,new IResource[0],true);
  shouldContinue=commitUI.commit();
break;
case IDialogConstants.ABORT_ID:
final ResetOperation operation=new ResetOperation(repository,Constants.HEAD,ResetType.HARD);
String jobname=NLS.bind(UIText.ResetAction_reset,Constants.HEAD);
JobUtil.scheduleUserWorkspaceJob(operation,jobname,JobFamilies.RESET);
shouldContinue=true;
break;
case IDialogConstants.SKIP_ID:
StashCreateUI stashCreateUI=new StashCreateUI(repository);
shouldContinue=stashCreateUI.createStash(getShell());
break;
case IDialogConstants.CANCEL_ID:
}
super.buttonPressed(buttonId);
}","@Override protected void buttonPressed(int buttonId){
switch (buttonId) {
case IDialogConstants.PROCEED_ID:
    CommitUI commitUI=new CommitUI(getShell(),repository,new IResource[0],true);
  shouldContinue=commitUI.commit();
break;
case IDialogConstants.ABORT_ID:
final ResetOperation operation=new ResetOperation(repository,Constants.HEAD,ResetType.HARD);
String jobname=NLS.bind(UIText.ResetAction_reset,Constants.HEAD);
JobUtil.scheduleUserWorkspaceJob(operation,jobname,JobFamilies.RESET);
shouldContinue=true;
break;
case IDialogConstants.SKIP_ID:
StashCreateUI stashCreateUI=new StashCreateUI(repository);
shouldContinue=stashCreateUI.createStash(getShell());
break;
case IDialogConstants.CANCEL_ID:
default :
break;
}
super.buttonPressed(buttonId);
}",0.9886439545758184
91400,"@Override public void createControl(Composite parent){
  Composite main=new Composite(parent,SWT.NO_RADIO_GROUP);
  main.setLayout(new GridLayout(1,false));
  SelectionListener sl=new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      tv.getTree().setEnabled(!newProjectWizard.getSelection());
      if (importExisting.getSelection())       wizardSelection=EXISTING_PROJECTS_WIZARD;
 else       if (newProjectWizard.getSelection())       wizardSelection=NEW_WIZARD;
 else       if (generalWizard.getSelection())       wizardSelection=GENERAL_WIZARD;
 else       wizardSelection=EXISTING_PROJECTS_WIZARD;
      checkPage();
    }
  }
;
  Group wizardType=new Group(main,SWT.SHADOW_ETCHED_IN);
  GridDataFactory.fillDefaults().grab(true,false).applyTo(wizardType);
  wizardType.setText(UIText.GitSelectWizardPage_ProjectCreationHeader);
  wizardType.setLayout(new GridLayout(1,false));
  importExisting=new Button(wizardType,SWT.RADIO);
  importExisting.setText(UIText.GitSelectWizardPage_ImportExistingButton);
  importExisting.addSelectionListener(sl);
  newProjectWizard=new Button(wizardType,SWT.RADIO);
  newProjectWizard.setText(UIText.GitSelectWizardPage_UseNewProjectsWizardButton);
  newProjectWizard.addSelectionListener(sl);
  generalWizard=new Button(wizardType,SWT.RADIO);
  generalWizard.setText(UIText.GitSelectWizardPage_ImportAsGeneralButton);
  generalWizard.addSelectionListener(sl);
  IDialogSettings settings=Activator.getDefault().getDialogSettings();
  try {
    wizardSelection=settings.getInt(PREF_WIZ);
  }
 catch (  NumberFormatException e) {
    wizardSelection=EXISTING_PROJECTS_WIZARD;
  }
switch (wizardSelection) {
case EXISTING_PROJECTS_WIZARD:
    importExisting.setSelection(true);
  break;
case GENERAL_WIZARD:
generalWizard.setSelection(true);
break;
case NEW_WIZARD:
newProjectWizard.setSelection(true);
break;
}
tv=new TreeViewer(main,SWT.SINGLE | SWT.H_SCROLL | SWT.V_SCROLL| SWT.BORDER);
RepositoriesViewContentProvider cp=new RepositoriesViewContentProvider();
tv.setContentProvider(cp);
GridDataFactory.fillDefaults().grab(true,true).hint(SWT.DEFAULT,200).applyTo(tv.getTree());
tv.setLabelProvider(new RepositoriesViewLabelProvider());
tv.addSelectionChangedListener(new ISelectionChangedListener(){
@Override public void selectionChanged(SelectionChangedEvent event){
checkPage();
}
}
);
if (initialRepository != null) {
List<WorkingDirNode> input=new ArrayList<>();
WorkingDirNode node=new WorkingDirNode(null,initialRepository);
input.add(node);
tv.setInput(input);
tv.expandToLevel(2);
if (initialPath == null) tv.setSelection(new StructuredSelection(input.get(0)));
 else {
RepositoryTreeNode parentNode=node;
IPath fullPath=new Path(initialPath);
IPath workdirPath=new Path(initialRepository.getWorkTree().getPath());
if (workdirPath.isPrefixOf(fullPath)) {
IPath relPath=fullPath.removeFirstSegments(workdirPath.segmentCount());
for (String segment : relPath.segments()) {
for (Object child : cp.getChildren(parentNode)) {
if (child instanceof FolderNode) {
  FolderNode childFolder=(FolderNode)child;
  if (childFolder.getObject().getName().equals(segment)) {
    parentNode=childFolder;
    break;
  }
}
}
}
tv.setSelection(new StructuredSelection(parentNode));
}
}
}
tv.getTree().setEnabled(!newProjectWizard.getSelection());
Dialog.applyDialogFont(main);
setControl(main);
}","@Override public void createControl(Composite parent){
  Composite main=new Composite(parent,SWT.NO_RADIO_GROUP);
  main.setLayout(new GridLayout(1,false));
  SelectionListener sl=new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      tv.getTree().setEnabled(!newProjectWizard.getSelection());
      if (importExisting.getSelection())       wizardSelection=EXISTING_PROJECTS_WIZARD;
 else       if (newProjectWizard.getSelection())       wizardSelection=NEW_WIZARD;
 else       if (generalWizard.getSelection())       wizardSelection=GENERAL_WIZARD;
 else       wizardSelection=EXISTING_PROJECTS_WIZARD;
      checkPage();
    }
  }
;
  Group wizardType=new Group(main,SWT.SHADOW_ETCHED_IN);
  GridDataFactory.fillDefaults().grab(true,false).applyTo(wizardType);
  wizardType.setText(UIText.GitSelectWizardPage_ProjectCreationHeader);
  wizardType.setLayout(new GridLayout(1,false));
  importExisting=new Button(wizardType,SWT.RADIO);
  importExisting.setText(UIText.GitSelectWizardPage_ImportExistingButton);
  importExisting.addSelectionListener(sl);
  newProjectWizard=new Button(wizardType,SWT.RADIO);
  newProjectWizard.setText(UIText.GitSelectWizardPage_UseNewProjectsWizardButton);
  newProjectWizard.addSelectionListener(sl);
  generalWizard=new Button(wizardType,SWT.RADIO);
  generalWizard.setText(UIText.GitSelectWizardPage_ImportAsGeneralButton);
  generalWizard.addSelectionListener(sl);
  IDialogSettings settings=Activator.getDefault().getDialogSettings();
  try {
    wizardSelection=settings.getInt(PREF_WIZ);
  }
 catch (  NumberFormatException e) {
    wizardSelection=EXISTING_PROJECTS_WIZARD;
  }
switch (wizardSelection) {
default :
case EXISTING_PROJECTS_WIZARD:
    importExisting.setSelection(true);
  break;
case GENERAL_WIZARD:
generalWizard.setSelection(true);
break;
case NEW_WIZARD:
newProjectWizard.setSelection(true);
break;
}
tv=new TreeViewer(main,SWT.SINGLE | SWT.H_SCROLL | SWT.V_SCROLL| SWT.BORDER);
RepositoriesViewContentProvider cp=new RepositoriesViewContentProvider();
tv.setContentProvider(cp);
GridDataFactory.fillDefaults().grab(true,true).hint(SWT.DEFAULT,200).applyTo(tv.getTree());
tv.setLabelProvider(new RepositoriesViewLabelProvider());
tv.addSelectionChangedListener(new ISelectionChangedListener(){
@Override public void selectionChanged(SelectionChangedEvent event){
checkPage();
}
}
);
if (initialRepository != null) {
List<WorkingDirNode> input=new ArrayList<>();
WorkingDirNode node=new WorkingDirNode(null,initialRepository);
input.add(node);
tv.setInput(input);
tv.expandToLevel(2);
if (initialPath == null) tv.setSelection(new StructuredSelection(input.get(0)));
 else {
RepositoryTreeNode parentNode=node;
IPath fullPath=new Path(initialPath);
IPath workdirPath=new Path(initialRepository.getWorkTree().getPath());
if (workdirPath.isPrefixOf(fullPath)) {
IPath relPath=fullPath.removeFirstSegments(workdirPath.segmentCount());
for (String segment : relPath.segments()) {
for (Object child : cp.getChildren(parentNode)) {
if (child instanceof FolderNode) {
  FolderNode childFolder=(FolderNode)child;
  if (childFolder.getObject().getName().equals(segment)) {
    parentNode=childFolder;
    break;
  }
}
}
}
tv.setSelection(new StructuredSelection(parentNode));
}
}
}
tv.getTree().setEnabled(!newProjectWizard.getSelection());
Dialog.applyDialogFont(main);
setControl(main);
}",0.9985167606051616
91401,"private void decorateText(IDecoration decoration,IDecoratableResource resource){
  String format=""String_Node_Str"";
switch (resource.getType()) {
case IResource.FILE:
    format=store.getString(UIPreferences.DECORATOR_FILETEXT_DECORATION);
  break;
case IResource.FOLDER:
case DecoratableResourceMapping.RESOURCE_MAPPING:
if (resource.isRepositoryContainer()) {
  format=store.getString(UIPreferences.DECORATOR_SUBMODULETEXT_DECORATION);
}
 else {
  format=store.getString(UIPreferences.DECORATOR_FOLDERTEXT_DECORATION);
}
break;
case DecoratableResourceMapping.WORKING_SET:
if (resource.getRepositoryName() != null && resource.getBranch() != null) format=store.getString(UIPreferences.DECORATOR_PROJECTTEXT_DECORATION);
 else format=store.getString(UIPreferences.DECORATOR_FOLDERTEXT_DECORATION);
break;
case IResource.PROJECT:
format=store.getString(UIPreferences.DECORATOR_PROJECTTEXT_DECORATION);
break;
}
Map<String,String> bindings=new HashMap<>();
bindings.put(BINDING_RESOURCE_NAME,resource.getName());
bindings.put(BINDING_REPOSITORY_NAME,resource.getRepositoryName());
bindings.put(BINDING_BRANCH_NAME,resource.getBranch());
bindings.put(BINDING_BRANCH_STATUS,resource.getBranchStatus());
bindings.put(BINDING_DIRTY_FLAG,resource.isDirty() ? ""String_Node_Str"" : null);
bindings.put(BINDING_STAGED_FLAG,resource.isStaged() ? ""String_Node_Str"" : null);
bindings.put(BINDING_SHORT_MESSAGE,resource.getCommitMessage());
decorate(decoration,format,bindings);
}","private void decorateText(IDecoration decoration,IDecoratableResource resource){
  String format=""String_Node_Str"";
switch (resource.getType()) {
default :
case IResource.FILE:
    format=store.getString(UIPreferences.DECORATOR_FILETEXT_DECORATION);
  break;
case IResource.FOLDER:
case DecoratableResourceMapping.RESOURCE_MAPPING:
if (resource.isRepositoryContainer()) {
  format=store.getString(UIPreferences.DECORATOR_SUBMODULETEXT_DECORATION);
}
 else {
  format=store.getString(UIPreferences.DECORATOR_FOLDERTEXT_DECORATION);
}
break;
case DecoratableResourceMapping.WORKING_SET:
if (resource.getRepositoryName() != null && resource.getBranch() != null) format=store.getString(UIPreferences.DECORATOR_PROJECTTEXT_DECORATION);
 else format=store.getString(UIPreferences.DECORATOR_FOLDERTEXT_DECORATION);
break;
case IResource.PROJECT:
format=store.getString(UIPreferences.DECORATOR_PROJECTTEXT_DECORATION);
break;
}
Map<String,String> bindings=new HashMap<>();
bindings.put(BINDING_RESOURCE_NAME,resource.getName());
bindings.put(BINDING_REPOSITORY_NAME,resource.getRepositoryName());
bindings.put(BINDING_BRANCH_NAME,resource.getBranch());
bindings.put(BINDING_BRANCH_STATUS,resource.getBranchStatus());
bindings.put(BINDING_DIRTY_FLAG,resource.isDirty() ? ""String_Node_Str"" : null);
bindings.put(BINDING_STAGED_FLAG,resource.isStaged() ? ""String_Node_Str"" : null);
bindings.put(BINDING_SHORT_MESSAGE,resource.getCommitMessage());
decorate(decoration,format,bindings);
}",0.9965986394557824
91402,"@Override protected void buttonPressed(int buttonId){
switch (buttonId) {
case IDialogConstants.PROCEED_ID:
    CommonUtils.runCommand(ActionCommands.COMMIT_ACTION,new StructuredSelection(repository));
  break;
case IDialogConstants.ABORT_ID:
CommonUtils.runCommand(ResetCommand.ID,new StructuredSelection(new RepositoryNode(null,repository)));
break;
case IDialogConstants.SKIP_ID:
CommonUtils.runCommand(ActionCommands.STASH_CREATE,new StructuredSelection(new RepositoryNode(null,repository)));
break;
}
super.buttonPressed(buttonId);
}","@Override protected void buttonPressed(int buttonId){
switch (buttonId) {
case IDialogConstants.PROCEED_ID:
    CommonUtils.runCommand(ActionCommands.COMMIT_ACTION,new StructuredSelection(repository));
  break;
case IDialogConstants.ABORT_ID:
CommonUtils.runCommand(ResetCommand.ID,new StructuredSelection(new RepositoryNode(null,repository)));
break;
case IDialogConstants.SKIP_ID:
CommonUtils.runCommand(ActionCommands.STASH_CREATE,new StructuredSelection(new RepositoryNode(null,repository)));
break;
default :
break;
}
super.buttonPressed(buttonId);
}",0.9844464775846294
91403,"StorageSizeFieldEditor(String name,String labelText,Composite parent,int min,int max){
  init(name,labelText);
  setTextLimit(10);
  setEmptyStringAllowed(false);
  setErrorMessage(JFaceResources.getString(""String_Node_Str""));
  createControl(parent);
  minValidValue=min;
  maxValidValue=max;
}","StorageSizeFieldEditor(String name,String labelText,Composite parent,int min,int max){
  Assert.isTrue(min > 0 && min < max);
  init(name,labelText);
  setTextLimit(10);
  setEmptyStringAllowed(false);
  setErrorMessage(JFaceResources.format(""String_Node_Str"",Integer.valueOf(min),Integer.valueOf(max)));
  createControl(parent);
  minValidValue=min;
  maxValidValue=max;
}",0.8562874251497006
91404,"private int parse(final String str){
  String n=str.trim();
  if (n.length() == 0)   return 0;
  int mul=1;
switch (Character.toLowerCase(n.charAt(n.length() - 1))) {
case 'g':
    mul=GB;
  break;
case 'm':
mul=MB;
break;
case 'k':
mul=KB;
break;
}
if (mul > 1) n=n.substring(0,n.length() - 1).trim();
if (n.length() == 0) return 0;
try {
return mul * Integer.parseInt(n);
}
 catch (NumberFormatException nfe) {
return 0;
}
}","private int parse(final String str){
  String n=str.trim();
  if (n.length() == 0)   return 0;
  int mul=1;
  char lastChar=n.charAt(n.length() - 1);
switch (Character.toLowerCase(lastChar)) {
case 'g':
    mul=GB;
  break;
case 'm':
mul=MB;
break;
case 'k':
mul=KB;
break;
default :
if (Character.isDigit(lastChar)) {
break;
}
return 0;
}
if (mul > 1) n=n.substring(0,n.length() - 1).trim();
if (n.length() == 0) return 0;
try {
return mul * Integer.parseInt(n);
}
 catch (NumberFormatException nfe) {
return 0;
}
}",0.8535031847133758
91405,"@Override public void resourceChanged(IResourceChangeEvent event){
  Set<IResource> resources=new HashSet<>();
  IMarkerDelta[] markerDeltas=event.findMarkerDeltas(IMarker.PROBLEM,true);
  for (  IMarkerDelta delta : markerDeltas)   resources.add(delta.getResource());
  if (!resources.isEmpty())   updateLabels(resources);
}","@Override public void resourceChanged(IResourceChangeEvent event){
  Set<IResource> resources=new HashSet<>();
  IMarkerDelta[] markerDeltas=event.findMarkerDeltas(IMarker.PROBLEM,true);
  for (  IMarkerDelta delta : markerDeltas) {
    IResource resource=delta.getResource();
    while (resource.getType() != IResource.ROOT && resources.add(resource)) {
      resource=resource.getParent();
    }
  }
  if (!resources.isEmpty()) {
    updateLabels(resources);
  }
}",0.7787610619469026
91406,"private void updateLabels(Set<IResource> changedResources){
  List<Object> elements=getAffectedElements(changedResources);
  if (!elements.isEmpty()) {
    final Object[] updateElements=elements.toArray(new Object[elements.size()]);
    Display display=viewer.getControl().getDisplay();
    display.asyncExec(new Runnable(){
      @Override public void run(){
        viewer.update(updateElements,null);
      }
    }
);
  }
}","private void updateLabels(Set<IResource> changedResources){
  List<Object> elements=getAffectedElements(changedResources);
  if (!elements.isEmpty()) {
    final Object[] updateElements=elements.toArray(new Object[elements.size()]);
    Display display=viewer.getControl().getDisplay();
    display.asyncExec(new Runnable(){
      @Override public void run(){
        fireLabelProviderChanged(new LabelProviderChangedEvent(ProblemLabelDecorator.this,updateElements));
      }
    }
);
  }
}",0.8668122270742358
91407,"@Override public void dispose(){
  resourceManager.dispose();
  if (this.viewer != null)   ResourcesPlugin.getWorkspace().removeResourceChangeListener(this);
  super.dispose();
}","@Override public void dispose(){
  super.dispose();
  resourceManager.dispose();
  if (this.viewer != null)   ResourcesPlugin.getWorkspace().removeResourceChangeListener(this);
}",0.8932584269662921
91408,"@Override public void run(){
  viewer.update(updateElements,null);
}","@Override public void run(){
  fireLabelProviderChanged(new LabelProviderChangedEvent(ProblemLabelDecorator.this,updateElements));
}",0.58
91409,"private List<Object> getAffectedElements(Set<IResource> resources){
  List<Object> result=new ArrayList<>();
  if (viewer.getContentProvider() instanceof IStructuredContentProvider) {
    IStructuredContentProvider contentProvider=(IStructuredContentProvider)viewer.getContentProvider();
    Object[] elements=contentProvider.getElements(null);
    for (    Object element : elements) {
      IResource resource=AdapterUtils.adapt(element,IResource.class);
      if (resource != null && resources.contains(resource))       result.add(element);
    }
  }
  return result;
}","private void getAffectedElements(Set<IResource> resources,Object[] elements,IStructuredContentProvider contentProvider,List<Object> result){
  for (  Object element : elements) {
    IResource resource=AdapterUtils.adapt(element,IResource.class);
    if (resource != null && resources.contains(resource)) {
      result.add(element);
      if (contentProvider instanceof ITreeContentProvider) {
        getAffectedElements(resources,((ITreeContentProvider)contentProvider).getChildren(element),contentProvider,result);
      }
    }
  }
}",0.1117117117117117
91410,"@Override public int getProblemSeverity(){
  if (container == null)   return SEVERITY_NONE;
  try {
    return container.findMaxProblemSeverity(IMarker.PROBLEM,true,IResource.DEPTH_ONE);
  }
 catch (  CoreException e) {
    return SEVERITY_NONE;
  }
}","@Override public int getProblemSeverity(){
  if (container == null)   return SEVERITY_NONE;
  try {
    return container.findMaxProblemSeverity(IMarker.PROBLEM,true,IResource.DEPTH_INFINITE);
  }
 catch (  CoreException e) {
    return SEVERITY_NONE;
  }
}",0.9822485207100592
91411,"@Override public void createPartControl(final Composite parent){
  GridLayoutFactory.fillDefaults().applyTo(parent);
  toolkit=new FormToolkit(parent.getDisplay());
  parent.addDisposeListener(new DisposeListener(){
    @Override public void widgetDisposed(    DisposeEvent e){
      if (commitMessageComponent.isAmending() || userEnteredCommitMessage())       saveCommitMessageComponentState();
 else       deleteCommitMessageComponentState();
      resources.dispose();
      toolkit.dispose();
    }
  }
);
  form=toolkit.createForm(parent);
  parent.addControlListener(new ControlListener(){
    private int[] defaultWeights={1,1};
    @Override public void controlResized(    ControlEvent e){
      org.eclipse.swt.graphics.Rectangle b=parent.getBounds();
      int oldOrientation=mainSashForm.getOrientation();
      if ((oldOrientation == SWT.HORIZONTAL) && (b.height > b.width)) {
        mainSashForm.setOrientation(SWT.VERTICAL);
        mainSashForm.setWeights(defaultWeights);
      }
 else       if ((oldOrientation == SWT.VERTICAL) && (b.height <= b.width)) {
        mainSashForm.setOrientation(SWT.HORIZONTAL);
        mainSashForm.setWeights(defaultWeights);
      }
    }
    @Override public void controlMoved(    ControlEvent e){
    }
  }
);
  form.setImage(getImage(UIIcons.REPOSITORY));
  form.setText(UIText.StagingView_NoSelectionTitle);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(form);
  toolkit.decorateFormHeading(form);
  GridLayoutFactory.swtDefaults().applyTo(form.getBody());
  mainSashForm=new SashForm(form.getBody(),SWT.HORIZONTAL);
  saveSashFormWeightsOnDisposal(mainSashForm,HORIZONTAL_SASH_FORM_WEIGHT);
  toolkit.adapt(mainSashForm,true,true);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(mainSashForm);
  stagingSashForm=new SashForm(mainSashForm,getStagingFormOrientation());
  saveSashFormWeightsOnDisposal(stagingSashForm,STAGING_SASH_FORM_WEIGHT);
  toolkit.adapt(stagingSashForm,true,true);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(stagingSashForm);
  unstagedSection=toolkit.createSection(stagingSashForm,ExpandableComposite.TITLE_BAR);
  unstagedSection.setLayoutData(GridDataFactory.fillDefaults().grab(true,true).create());
  createUnstagedToolBarComposite();
  Composite unstagedComposite=toolkit.createComposite(unstagedSection);
  toolkit.paintBordersFor(unstagedComposite);
  unstagedSection.setClient(unstagedComposite);
  GridLayoutFactory.fillDefaults().extendedMargins(2,2,2,2).applyTo(unstagedComposite);
  unstagedViewer=createTree(unstagedComposite);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(unstagedViewer.getControl());
  unstagedViewer.getTree().setData(FormToolkit.KEY_DRAW_BORDER,FormToolkit.TREE_BORDER);
  unstagedViewer.setLabelProvider(createLabelProvider(unstagedViewer));
  unstagedViewer.setContentProvider(createStagingContentProvider(true));
  unstagedViewer.addDragSupport(DND.DROP_MOVE | DND.DROP_COPY | DND.DROP_LINK,new Transfer[]{LocalSelectionTransfer.getTransfer(),FileTransfer.getInstance()},new StagingDragListener(unstagedViewer));
  unstagedViewer.addDropSupport(DND.DROP_MOVE,new Transfer[]{LocalSelectionTransfer.getTransfer()},new DropTargetAdapter(){
    @Override public void drop(    DropTargetEvent event){
      event.detail=DND.DROP_COPY;
      if (event.data instanceof IStructuredSelection) {
        final IStructuredSelection selection=(IStructuredSelection)event.data;
        unstage(selection);
      }
    }
    @Override public void dragOver(    DropTargetEvent event){
      event.detail=DND.DROP_MOVE;
    }
  }
);
  unstagedViewer.addOpenListener(new IOpenListener(){
    @Override public void open(    OpenEvent event){
      compareWith(event);
    }
  }
);
  unstagedViewer.setComparator(new StagingEntryComparator(getSortCheckState(),getPreferenceStore().getBoolean(UIPreferences.STAGING_VIEW_FILENAME_MODE)));
  enableAutoExpand(unstagedViewer);
  addListenerToDisableAutoExpandOnCollapse(unstagedViewer);
  Composite rebaseAndCommitComposite=toolkit.createComposite(mainSashForm);
  rebaseAndCommitComposite.setLayout(GridLayoutFactory.fillDefaults().create());
  rebaseSection=toolkit.createSection(rebaseAndCommitComposite,ExpandableComposite.TITLE_BAR);
  rebaseSection.setText(UIText.StagingView_RebaseLabel);
  Composite rebaseComposite=toolkit.createComposite(rebaseSection);
  toolkit.paintBordersFor(rebaseComposite);
  rebaseSection.setClient(rebaseComposite);
  rebaseSection.setLayoutData(GridDataFactory.fillDefaults().create());
  rebaseComposite.setLayout(GridLayoutFactory.fillDefaults().numColumns(3).equalWidth(true).create());
  GridDataFactory buttonGridData=GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER);
  this.rebaseAbortButton=toolkit.createButton(rebaseComposite,UIText.StagingView_RebaseAbort,SWT.PUSH);
  rebaseAbortButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      rebaseAbort();
    }
  }
);
  rebaseAbortButton.setImage(getImage(UIIcons.REBASE_ABORT));
  buttonGridData.applyTo(rebaseAbortButton);
  this.rebaseSkipButton=toolkit.createButton(rebaseComposite,UIText.StagingView_RebaseSkip,SWT.PUSH);
  rebaseSkipButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      rebaseSkip();
    }
  }
);
  rebaseSkipButton.setImage(getImage(UIIcons.REBASE_SKIP));
  buttonGridData.applyTo(rebaseSkipButton);
  this.rebaseContinueButton=toolkit.createButton(rebaseComposite,UIText.StagingView_RebaseContinue,SWT.PUSH);
  rebaseContinueButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      rebaseContinue();
    }
  }
);
  rebaseContinueButton.setImage(getImage(UIIcons.REBASE_CONTINUE));
  buttonGridData.applyTo(rebaseContinueButton);
  showControl(rebaseSection,false);
  commitMessageSection=toolkit.createSection(rebaseAndCommitComposite,ExpandableComposite.TITLE_BAR);
  commitMessageSection.setText(UIText.StagingView_CommitMessage);
  commitMessageSection.setLayoutData(GridDataFactory.fillDefaults().grab(true,true).create());
  Composite commitMessageToolbarComposite=toolkit.createComposite(commitMessageSection);
  commitMessageToolbarComposite.setBackground(null);
  commitMessageToolbarComposite.setLayout(createRowLayoutWithoutMargin());
  commitMessageSection.setTextClient(commitMessageToolbarComposite);
  ToolBarManager commitMessageToolBarManager=new ToolBarManager(SWT.FLAT | SWT.HORIZONTAL);
  amendPreviousCommitAction=new Action(UIText.StagingView_Ammend_Previous_Commit,IAction.AS_CHECK_BOX){
    @Override public void run(){
      commitMessageComponent.setAmendingButtonSelection(isChecked());
      updateMessage();
    }
  }
;
  amendPreviousCommitAction.setImageDescriptor(UIIcons.AMEND_COMMIT);
  commitMessageToolBarManager.add(amendPreviousCommitAction);
  signedOffByAction=new Action(UIText.StagingView_Add_Signed_Off_By,IAction.AS_CHECK_BOX){
    @Override public void run(){
      commitMessageComponent.setSignedOffButtonSelection(isChecked());
    }
  }
;
  signedOffByAction.setImageDescriptor(UIIcons.SIGNED_OFF);
  commitMessageToolBarManager.add(signedOffByAction);
  addChangeIdAction=new Action(UIText.StagingView_Add_Change_ID,IAction.AS_CHECK_BOX){
    @Override public void run(){
      commitMessageComponent.setChangeIdButtonSelection(isChecked());
    }
  }
;
  addChangeIdAction.setImageDescriptor(UIIcons.GERRIT);
  commitMessageToolBarManager.add(addChangeIdAction);
  commitMessageToolBarManager.createControl(commitMessageToolbarComposite);
  Composite commitMessageComposite=toolkit.createComposite(commitMessageSection);
  commitMessageSection.setClient(commitMessageComposite);
  GridLayoutFactory.fillDefaults().numColumns(1).applyTo(commitMessageComposite);
  warningLabel=new ToggleableWarningLabel(commitMessageComposite,SWT.NONE);
  GridDataFactory.fillDefaults().grab(true,false).exclude(true).applyTo(warningLabel);
  Composite commitMessageTextComposite=toolkit.createComposite(commitMessageComposite);
  toolkit.paintBordersFor(commitMessageTextComposite);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(commitMessageTextComposite);
  GridLayoutFactory.fillDefaults().numColumns(1).extendedMargins(2,2,2,2).applyTo(commitMessageTextComposite);
  final CommitProposalProcessor commitProposalProcessor=new CommitProposalProcessor(){
    @Override protected Collection<String> computeFileNameProposals(){
      return getStagedFileNames();
    }
    @Override protected Collection<String> computeMessageProposals(){
      return CommitMessageHistory.getCommitHistory();
    }
  }
;
  commitMessageText=new CommitMessageArea(commitMessageTextComposite,EMPTY_STRING,toolkit.getBorderStyle()){
    @Override protected CommitProposalProcessor getCommitProposalProcessor(){
      return commitProposalProcessor;
    }
    @Override protected IHandlerService getHandlerService(){
      return CommonUtils.getService(getSite(),IHandlerService.class);
    }
  }
;
  commitMessageText.setData(FormToolkit.KEY_DRAW_BORDER,FormToolkit.TEXT_BORDER);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(commitMessageText);
  UIUtils.addBulbDecorator(commitMessageText.getTextWidget(),UIText.CommitDialog_ContentAssist);
  Composite composite=toolkit.createComposite(commitMessageComposite);
  toolkit.paintBordersFor(composite);
  GridDataFactory.fillDefaults().grab(true,false).applyTo(composite);
  GridLayoutFactory.swtDefaults().numColumns(2).applyTo(composite);
  toolkit.createLabel(composite,UIText.StagingView_Author).setForeground(toolkit.getColors().getColor(IFormColors.TB_TOGGLE));
  authorText=toolkit.createText(composite,null);
  authorText.setData(FormToolkit.KEY_DRAW_BORDER,FormToolkit.TEXT_BORDER);
  authorText.setLayoutData(GridDataFactory.fillDefaults().grab(true,false).create());
  toolkit.createLabel(composite,UIText.StagingView_Committer).setForeground(toolkit.getColors().getColor(IFormColors.TB_TOGGLE));
  committerText=toolkit.createText(composite,null);
  committerText.setData(FormToolkit.KEY_DRAW_BORDER,FormToolkit.TEXT_BORDER);
  committerText.setLayoutData(GridDataFactory.fillDefaults().grab(true,false).create());
  Composite buttonsContainer=toolkit.createComposite(composite);
  GridDataFactory.fillDefaults().grab(true,false).span(2,1).indent(0,8).applyTo(buttonsContainer);
  GridLayoutFactory.fillDefaults().numColumns(2).applyTo(buttonsContainer);
  ignoreErrors=toolkit.createButton(buttonsContainer,UIText.StagingView_IgnoreErrors,SWT.CHECK);
  ignoreErrors.setSelection(false);
  ignoreErrors.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      updateMessage();
      updateCommitButtons();
    }
  }
);
  getPreferenceStore().addPropertyChangeListener(new IPropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent event){
      if (isDisposed()) {
        getPreferenceStore().removePropertyChangeListener(this);
        return;
      }
      asyncExec(new Runnable(){
        @Override public void run(){
          updateIgnoreErrorsButtonVisibility();
          updateMessage();
          updateCommitButtons();
        }
      }
);
    }
  }
);
  GridDataFactory.fillDefaults().align(SWT.BEGINNING,SWT.BEGINNING).grab(true,true).applyTo(ignoreErrors);
  updateIgnoreErrorsButtonVisibility();
  Label filler=toolkit.createLabel(buttonsContainer,""String_Node_Str"");
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,true).applyTo(filler);
  Composite commitButtonsContainer=toolkit.createComposite(buttonsContainer);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).applyTo(commitButtonsContainer);
  GridLayoutFactory.fillDefaults().numColumns(2).equalWidth(true).applyTo(commitButtonsContainer);
  this.commitAndPushButton=toolkit.createButton(commitButtonsContainer,UIText.StagingView_CommitAndPush,SWT.PUSH);
  commitAndPushButton.setImage(getImage(UIIcons.PUSH));
  commitAndPushButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      commit(true);
    }
  }
);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).applyTo(commitAndPushButton);
  this.commitButton=toolkit.createButton(commitButtonsContainer,UIText.StagingView_Commit,SWT.PUSH);
  commitButton.setImage(getImage(UIIcons.COMMIT));
  commitButton.setText(UIText.StagingView_Commit);
  commitButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      commit(false);
    }
  }
);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).applyTo(commitButton);
  stagedSection=toolkit.createSection(stagingSashForm,ExpandableComposite.TITLE_BAR);
  createStagedToolBarComposite();
  Composite stagedComposite=toolkit.createComposite(stagedSection);
  toolkit.paintBordersFor(stagedComposite);
  stagedSection.setClient(stagedComposite);
  GridLayoutFactory.fillDefaults().extendedMargins(2,2,2,2).applyTo(stagedComposite);
  stagedViewer=createTree(stagedComposite);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(stagedViewer.getControl());
  stagedViewer.getTree().setData(FormToolkit.KEY_DRAW_BORDER,FormToolkit.TREE_BORDER);
  stagedViewer.setLabelProvider(createLabelProvider(stagedViewer));
  stagedViewer.setContentProvider(createStagingContentProvider(false));
  stagedViewer.addDragSupport(DND.DROP_MOVE | DND.DROP_COPY | DND.DROP_LINK,new Transfer[]{LocalSelectionTransfer.getTransfer(),FileTransfer.getInstance()},new StagingDragListener(stagedViewer));
  stagedViewer.addDropSupport(DND.DROP_MOVE,new Transfer[]{LocalSelectionTransfer.getTransfer()},new DropTargetAdapter(){
    @Override public void drop(    DropTargetEvent event){
      event.detail=DND.DROP_COPY;
      if (event.data instanceof IStructuredSelection) {
        final IStructuredSelection selection=(IStructuredSelection)event.data;
        stage(selection);
      }
    }
    @Override public void dragOver(    DropTargetEvent event){
      event.detail=DND.DROP_MOVE;
    }
  }
);
  stagedViewer.addOpenListener(new IOpenListener(){
    @Override public void open(    OpenEvent event){
      compareWith(event);
    }
  }
);
  stagedViewer.setComparator(new StagingEntryComparator(getSortCheckState(),getPreferenceStore().getBoolean(UIPreferences.STAGING_VIEW_FILENAME_MODE)));
  enableAutoExpand(stagedViewer);
  addListenerToDisableAutoExpandOnCollapse(stagedViewer);
  selectionChangedListener=new ISelectionListener(){
    @Override public void selectionChanged(    IWorkbenchPart part,    ISelection selection){
      if (part == getSite().getPart()) {
        return;
      }
      if (selection instanceof StructuredSelection) {
        reactOnSelection((StructuredSelection)selection);
      }
    }
  }
;
  partListener=new PartListener();
  IPreferenceStore preferenceStore=getPreferenceStore();
  if (preferenceStore.contains(UIPreferences.STAGING_VIEW_SYNC_SELECTION))   reactOnSelection=preferenceStore.getBoolean(UIPreferences.STAGING_VIEW_SYNC_SELECTION);
 else   preferenceStore.setDefault(UIPreferences.STAGING_VIEW_SYNC_SELECTION,true);
  preferenceStore.addPropertyChangeListener(uiPrefsListener);
  InstanceScope.INSTANCE.getNode(org.eclipse.egit.core.Activator.getPluginId()).addPreferenceChangeListener(prefListener);
  updateSectionText();
  updateToolbar();
  enableCommitWidgets(false);
  refreshAction.setEnabled(false);
  createPopupMenu(unstagedViewer);
  createPopupMenu(stagedViewer);
  final ICommitMessageComponentNotifications listener=new ICommitMessageComponentNotifications(){
    @Override public void updateSignedOffToggleSelection(    boolean selection){
      signedOffByAction.setChecked(selection);
    }
    @Override public void updateChangeIdToggleSelection(    boolean selection){
      addChangeIdAction.setChecked(selection);
      commitAndPushButton.setImage(getImage(selection ? UIIcons.GERRIT : UIIcons.PUSH));
    }
    @Override public void statusUpdated(){
      updateMessage();
    }
  }
;
  commitMessageComponent=new CommitMessageComponent(listener);
  commitMessageComponent.attachControls(commitMessageText,authorText,committerText);
  commitMessageText.getTextWidget().addVerifyKeyListener(new VerifyKeyListener(){
    @Override public void verifyKey(    VerifyEvent event){
      if (UIUtils.isSubmitKeyEvent(event)) {
        event.doit=false;
        commit(false);
      }
    }
  }
);
  commitMessageText.getTextWidget().addFocusListener(new FocusListener(){
    @Override public void focusGained(    FocusEvent e){
      String commitButtonTooltip=MessageFormat.format(UIText.StagingView_CommitToolTip,UIUtils.SUBMIT_KEY_STROKE.format());
      commitButton.setToolTipText(commitButtonTooltip);
    }
    @Override public void focusLost(    FocusEvent e){
      commitButton.setToolTipText(null);
    }
  }
);
  IWorkbenchPartSite site=getSite();
  ISelectionService srv=CommonUtils.getService(site,ISelectionService.class);
  srv.addPostSelectionListener(selectionChangedListener);
  CommonUtils.getService(site,IPartService.class).addPartListener(partListener);
  UIUtils.notifySelectionChangedWithCurrentSelection(selectionChangedListener,site);
  site.setSelectionProvider(unstagedViewer);
  ViewerFilter filter=new ViewerFilter(){
    @Override public boolean select(    Viewer viewer,    Object parentElement,    Object element){
      StagingViewContentProvider contentProvider=getContentProvider((TreeViewer)viewer);
      if (element instanceof StagingEntry)       return contentProvider.isInFilter((StagingEntry)element);
 else       if (element instanceof StagingFolderEntry)       return contentProvider.hasVisibleChildren((StagingFolderEntry)element);
      return true;
    }
  }
;
  unstagedViewer.addFilter(filter);
  stagedViewer.addFilter(filter);
  restoreSashFormWeights();
  reactOnInitialSelection();
  IWorkbenchSiteProgressService service=CommonUtils.getService(getSite(),IWorkbenchSiteProgressService.class);
  if (service != null && reactOnSelection)   service.showBusyForFamily(org.eclipse.egit.core.JobFamilies.INDEX_DIFF_CACHE_UPDATE);
}","@Override public void createPartControl(final Composite parent){
  GridLayoutFactory.fillDefaults().applyTo(parent);
  toolkit=new FormToolkit(parent.getDisplay());
  parent.addDisposeListener(new DisposeListener(){
    @Override public void widgetDisposed(    DisposeEvent e){
      if (commitMessageComponent.isAmending() || userEnteredCommitMessage())       saveCommitMessageComponentState();
 else       deleteCommitMessageComponentState();
      resources.dispose();
      toolkit.dispose();
    }
  }
);
  form=toolkit.createForm(parent);
  parent.addControlListener(new ControlListener(){
    private int[] defaultWeights={1,1};
    @Override public void controlResized(    ControlEvent e){
      org.eclipse.swt.graphics.Rectangle b=parent.getBounds();
      int oldOrientation=mainSashForm.getOrientation();
      if ((oldOrientation == SWT.HORIZONTAL) && (b.height > b.width)) {
        mainSashForm.setOrientation(SWT.VERTICAL);
        mainSashForm.setWeights(defaultWeights);
      }
 else       if ((oldOrientation == SWT.VERTICAL) && (b.height <= b.width)) {
        mainSashForm.setOrientation(SWT.HORIZONTAL);
        mainSashForm.setWeights(defaultWeights);
      }
    }
    @Override public void controlMoved(    ControlEvent e){
    }
  }
);
  form.setImage(getImage(UIIcons.REPOSITORY));
  form.setText(UIText.StagingView_NoSelectionTitle);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(form);
  toolkit.decorateFormHeading(form);
  GridLayoutFactory.swtDefaults().applyTo(form.getBody());
  mainSashForm=new SashForm(form.getBody(),SWT.HORIZONTAL);
  saveSashFormWeightsOnDisposal(mainSashForm,HORIZONTAL_SASH_FORM_WEIGHT);
  toolkit.adapt(mainSashForm,true,true);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(mainSashForm);
  stagingSashForm=new SashForm(mainSashForm,getStagingFormOrientation());
  saveSashFormWeightsOnDisposal(stagingSashForm,STAGING_SASH_FORM_WEIGHT);
  toolkit.adapt(stagingSashForm,true,true);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(stagingSashForm);
  unstagedSection=toolkit.createSection(stagingSashForm,ExpandableComposite.TITLE_BAR);
  unstagedSection.setLayoutData(GridDataFactory.fillDefaults().grab(true,true).create());
  createUnstagedToolBarComposite();
  Composite unstagedComposite=toolkit.createComposite(unstagedSection);
  toolkit.paintBordersFor(unstagedComposite);
  unstagedSection.setClient(unstagedComposite);
  GridLayoutFactory.fillDefaults().extendedMargins(2,2,2,2).applyTo(unstagedComposite);
  unstagedViewer=createTree(unstagedComposite);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(unstagedViewer.getControl());
  unstagedViewer.getTree().setData(FormToolkit.KEY_DRAW_BORDER,FormToolkit.TREE_BORDER);
  unstagedViewer.setLabelProvider(createLabelProvider(unstagedViewer));
  unstagedViewer.setContentProvider(createStagingContentProvider(true));
  unstagedViewer.addDragSupport(DND.DROP_MOVE | DND.DROP_COPY | DND.DROP_LINK,new Transfer[]{LocalSelectionTransfer.getTransfer(),FileTransfer.getInstance()},new StagingDragListener(unstagedViewer));
  unstagedViewer.addDropSupport(DND.DROP_MOVE,new Transfer[]{LocalSelectionTransfer.getTransfer()},new DropTargetAdapter(){
    @Override public void drop(    DropTargetEvent event){
      event.detail=DND.DROP_COPY;
      if (event.data instanceof IStructuredSelection) {
        final IStructuredSelection selection=(IStructuredSelection)event.data;
        unstage(selection);
      }
    }
    @Override public void dragOver(    DropTargetEvent event){
      event.detail=DND.DROP_MOVE;
    }
  }
);
  unstagedViewer.addOpenListener(new IOpenListener(){
    @Override public void open(    OpenEvent event){
      compareWith(event);
    }
  }
);
  unstagedViewer.setComparator(new StagingEntryComparator(getSortCheckState(),getPreferenceStore().getBoolean(UIPreferences.STAGING_VIEW_FILENAME_MODE)));
  enableAutoExpand(unstagedViewer);
  addListenerToDisableAutoExpandOnCollapse(unstagedViewer);
  Composite rebaseAndCommitComposite=toolkit.createComposite(mainSashForm);
  rebaseAndCommitComposite.setLayout(GridLayoutFactory.fillDefaults().create());
  rebaseSection=toolkit.createSection(rebaseAndCommitComposite,ExpandableComposite.TITLE_BAR);
  rebaseSection.setText(UIText.StagingView_RebaseLabel);
  Composite rebaseComposite=toolkit.createComposite(rebaseSection);
  toolkit.paintBordersFor(rebaseComposite);
  rebaseSection.setClient(rebaseComposite);
  rebaseSection.setLayoutData(GridDataFactory.fillDefaults().create());
  rebaseComposite.setLayout(GridLayoutFactory.fillDefaults().numColumns(3).equalWidth(true).create());
  GridDataFactory buttonGridData=GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER);
  this.rebaseAbortButton=toolkit.createButton(rebaseComposite,UIText.StagingView_RebaseAbort,SWT.PUSH);
  rebaseAbortButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      rebaseAbort();
    }
  }
);
  rebaseAbortButton.setImage(getImage(UIIcons.REBASE_ABORT));
  buttonGridData.applyTo(rebaseAbortButton);
  this.rebaseSkipButton=toolkit.createButton(rebaseComposite,UIText.StagingView_RebaseSkip,SWT.PUSH);
  rebaseSkipButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      rebaseSkip();
    }
  }
);
  rebaseSkipButton.setImage(getImage(UIIcons.REBASE_SKIP));
  buttonGridData.applyTo(rebaseSkipButton);
  this.rebaseContinueButton=toolkit.createButton(rebaseComposite,UIText.StagingView_RebaseContinue,SWT.PUSH);
  rebaseContinueButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      rebaseContinue();
    }
  }
);
  rebaseContinueButton.setImage(getImage(UIIcons.REBASE_CONTINUE));
  buttonGridData.applyTo(rebaseContinueButton);
  showControl(rebaseSection,false);
  commitMessageSection=toolkit.createSection(rebaseAndCommitComposite,ExpandableComposite.TITLE_BAR);
  commitMessageSection.setText(UIText.StagingView_CommitMessage);
  commitMessageSection.setLayoutData(GridDataFactory.fillDefaults().grab(true,true).create());
  Composite commitMessageToolbarComposite=toolkit.createComposite(commitMessageSection);
  commitMessageToolbarComposite.setBackground(null);
  commitMessageToolbarComposite.setLayout(createRowLayoutWithoutMargin());
  commitMessageSection.setTextClient(commitMessageToolbarComposite);
  ToolBarManager commitMessageToolBarManager=new ToolBarManager(SWT.FLAT | SWT.HORIZONTAL);
  amendPreviousCommitAction=new Action(UIText.StagingView_Ammend_Previous_Commit,IAction.AS_CHECK_BOX){
    @Override public void run(){
      commitMessageComponent.setAmendingButtonSelection(isChecked());
      updateMessage();
    }
  }
;
  amendPreviousCommitAction.setImageDescriptor(UIIcons.AMEND_COMMIT);
  commitMessageToolBarManager.add(amendPreviousCommitAction);
  signedOffByAction=new Action(UIText.StagingView_Add_Signed_Off_By,IAction.AS_CHECK_BOX){
    @Override public void run(){
      commitMessageComponent.setSignedOffButtonSelection(isChecked());
    }
  }
;
  signedOffByAction.setImageDescriptor(UIIcons.SIGNED_OFF);
  commitMessageToolBarManager.add(signedOffByAction);
  addChangeIdAction=new Action(UIText.StagingView_Add_Change_ID,IAction.AS_CHECK_BOX){
    @Override public void run(){
      commitMessageComponent.setChangeIdButtonSelection(isChecked());
    }
  }
;
  addChangeIdAction.setImageDescriptor(UIIcons.GERRIT);
  commitMessageToolBarManager.add(addChangeIdAction);
  commitMessageToolBarManager.createControl(commitMessageToolbarComposite);
  Composite commitMessageComposite=toolkit.createComposite(commitMessageSection);
  commitMessageSection.setClient(commitMessageComposite);
  GridLayoutFactory.fillDefaults().numColumns(1).applyTo(commitMessageComposite);
  warningLabel=new ToggleableWarningLabel(commitMessageComposite,SWT.NONE);
  GridDataFactory.fillDefaults().grab(true,false).exclude(true).applyTo(warningLabel);
  Composite commitMessageTextComposite=toolkit.createComposite(commitMessageComposite);
  toolkit.paintBordersFor(commitMessageTextComposite);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(commitMessageTextComposite);
  GridLayoutFactory.fillDefaults().numColumns(1).extendedMargins(2,2,2,2).applyTo(commitMessageTextComposite);
  final CommitProposalProcessor commitProposalProcessor=new CommitProposalProcessor(){
    @Override protected Collection<String> computeFileNameProposals(){
      return getStagedFileNames();
    }
    @Override protected Collection<String> computeMessageProposals(){
      return CommitMessageHistory.getCommitHistory();
    }
  }
;
  commitMessageText=new CommitMessageArea(commitMessageTextComposite,EMPTY_STRING,toolkit.getBorderStyle()){
    @Override protected CommitProposalProcessor getCommitProposalProcessor(){
      return commitProposalProcessor;
    }
    @Override protected IHandlerService getHandlerService(){
      return CommonUtils.getService(getSite(),IHandlerService.class);
    }
  }
;
  commitMessageText.setData(FormToolkit.KEY_DRAW_BORDER,FormToolkit.TEXT_BORDER);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(commitMessageText);
  UIUtils.addBulbDecorator(commitMessageText.getTextWidget(),UIText.CommitDialog_ContentAssist);
  Composite composite=toolkit.createComposite(commitMessageComposite);
  toolkit.paintBordersFor(composite);
  GridDataFactory.fillDefaults().grab(true,false).applyTo(composite);
  GridLayoutFactory.swtDefaults().numColumns(2).applyTo(composite);
  toolkit.createLabel(composite,UIText.StagingView_Author).setForeground(toolkit.getColors().getColor(IFormColors.TB_TOGGLE));
  authorText=toolkit.createText(composite,null);
  authorText.setData(FormToolkit.KEY_DRAW_BORDER,FormToolkit.TEXT_BORDER);
  authorText.setLayoutData(GridDataFactory.fillDefaults().grab(true,false).create());
  toolkit.createLabel(composite,UIText.StagingView_Committer).setForeground(toolkit.getColors().getColor(IFormColors.TB_TOGGLE));
  committerText=toolkit.createText(composite,null);
  committerText.setData(FormToolkit.KEY_DRAW_BORDER,FormToolkit.TEXT_BORDER);
  committerText.setLayoutData(GridDataFactory.fillDefaults().grab(true,false).create());
  Composite buttonsContainer=toolkit.createComposite(composite);
  GridDataFactory.fillDefaults().grab(true,false).span(2,1).indent(0,8).applyTo(buttonsContainer);
  GridLayoutFactory.fillDefaults().numColumns(2).applyTo(buttonsContainer);
  ignoreErrors=toolkit.createButton(buttonsContainer,UIText.StagingView_IgnoreErrors,SWT.CHECK);
  ignoreErrors.setSelection(false);
  ignoreErrors.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      updateMessage();
      updateCommitButtons();
    }
  }
);
  getPreferenceStore().addPropertyChangeListener(new IPropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent event){
      if (isDisposed()) {
        getPreferenceStore().removePropertyChangeListener(this);
        return;
      }
      asyncExec(new Runnable(){
        @Override public void run(){
          updateIgnoreErrorsButtonVisibility();
          updateMessage();
          updateCommitButtons();
        }
      }
);
    }
  }
);
  GridDataFactory.fillDefaults().align(SWT.BEGINNING,SWT.BEGINNING).grab(true,true).applyTo(ignoreErrors);
  updateIgnoreErrorsButtonVisibility();
  Label filler=toolkit.createLabel(buttonsContainer,""String_Node_Str"");
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,true).applyTo(filler);
  Composite commitButtonsContainer=toolkit.createComposite(buttonsContainer);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).applyTo(commitButtonsContainer);
  GridLayoutFactory.fillDefaults().numColumns(2).equalWidth(true).applyTo(commitButtonsContainer);
  this.commitAndPushButton=toolkit.createButton(commitButtonsContainer,UIText.StagingView_CommitAndPush,SWT.PUSH);
  commitAndPushButton.setImage(getImage(UIIcons.PUSH));
  commitAndPushButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      commit(true);
    }
  }
);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).applyTo(commitAndPushButton);
  this.commitButton=toolkit.createButton(commitButtonsContainer,UIText.StagingView_Commit,SWT.PUSH);
  commitButton.setImage(getImage(UIIcons.COMMIT));
  commitButton.setText(UIText.StagingView_Commit);
  commitButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      commit(false);
    }
  }
);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).applyTo(commitButton);
  stagedSection=toolkit.createSection(stagingSashForm,ExpandableComposite.TITLE_BAR);
  createStagedToolBarComposite();
  Composite stagedComposite=toolkit.createComposite(stagedSection);
  toolkit.paintBordersFor(stagedComposite);
  stagedSection.setClient(stagedComposite);
  GridLayoutFactory.fillDefaults().extendedMargins(2,2,2,2).applyTo(stagedComposite);
  stagedViewer=createTree(stagedComposite);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(stagedViewer.getControl());
  stagedViewer.getTree().setData(FormToolkit.KEY_DRAW_BORDER,FormToolkit.TREE_BORDER);
  IBaseLabelProvider labelProvider=createLabelProvider(stagedViewer);
  labelProvider.addListener(new ILabelProviderListener(){
    @Override public void labelProviderChanged(    LabelProviderChangedEvent event){
      updateCommitButtons();
    }
  }
);
  stagedViewer.setLabelProvider(labelProvider);
  stagedViewer.setContentProvider(createStagingContentProvider(false));
  stagedViewer.addDragSupport(DND.DROP_MOVE | DND.DROP_COPY | DND.DROP_LINK,new Transfer[]{LocalSelectionTransfer.getTransfer(),FileTransfer.getInstance()},new StagingDragListener(stagedViewer));
  stagedViewer.addDropSupport(DND.DROP_MOVE,new Transfer[]{LocalSelectionTransfer.getTransfer()},new DropTargetAdapter(){
    @Override public void drop(    DropTargetEvent event){
      event.detail=DND.DROP_COPY;
      if (event.data instanceof IStructuredSelection) {
        final IStructuredSelection selection=(IStructuredSelection)event.data;
        stage(selection);
      }
    }
    @Override public void dragOver(    DropTargetEvent event){
      event.detail=DND.DROP_MOVE;
    }
  }
);
  stagedViewer.addOpenListener(new IOpenListener(){
    @Override public void open(    OpenEvent event){
      compareWith(event);
    }
  }
);
  stagedViewer.setComparator(new StagingEntryComparator(getSortCheckState(),getPreferenceStore().getBoolean(UIPreferences.STAGING_VIEW_FILENAME_MODE)));
  enableAutoExpand(stagedViewer);
  addListenerToDisableAutoExpandOnCollapse(stagedViewer);
  selectionChangedListener=new ISelectionListener(){
    @Override public void selectionChanged(    IWorkbenchPart part,    ISelection selection){
      if (part == getSite().getPart()) {
        return;
      }
      if (selection instanceof StructuredSelection) {
        reactOnSelection((StructuredSelection)selection);
      }
    }
  }
;
  partListener=new PartListener();
  IPreferenceStore preferenceStore=getPreferenceStore();
  if (preferenceStore.contains(UIPreferences.STAGING_VIEW_SYNC_SELECTION))   reactOnSelection=preferenceStore.getBoolean(UIPreferences.STAGING_VIEW_SYNC_SELECTION);
 else   preferenceStore.setDefault(UIPreferences.STAGING_VIEW_SYNC_SELECTION,true);
  preferenceStore.addPropertyChangeListener(uiPrefsListener);
  InstanceScope.INSTANCE.getNode(org.eclipse.egit.core.Activator.getPluginId()).addPreferenceChangeListener(prefListener);
  updateSectionText();
  updateToolbar();
  enableCommitWidgets(false);
  refreshAction.setEnabled(false);
  createPopupMenu(unstagedViewer);
  createPopupMenu(stagedViewer);
  final ICommitMessageComponentNotifications listener=new ICommitMessageComponentNotifications(){
    @Override public void updateSignedOffToggleSelection(    boolean selection){
      signedOffByAction.setChecked(selection);
    }
    @Override public void updateChangeIdToggleSelection(    boolean selection){
      addChangeIdAction.setChecked(selection);
      commitAndPushButton.setImage(getImage(selection ? UIIcons.GERRIT : UIIcons.PUSH));
    }
    @Override public void statusUpdated(){
      updateMessage();
    }
  }
;
  commitMessageComponent=new CommitMessageComponent(listener);
  commitMessageComponent.attachControls(commitMessageText,authorText,committerText);
  commitMessageText.getTextWidget().addVerifyKeyListener(new VerifyKeyListener(){
    @Override public void verifyKey(    VerifyEvent event){
      if (UIUtils.isSubmitKeyEvent(event)) {
        event.doit=false;
        commit(false);
      }
    }
  }
);
  commitMessageText.getTextWidget().addFocusListener(new FocusListener(){
    @Override public void focusGained(    FocusEvent e){
      String commitButtonTooltip=MessageFormat.format(UIText.StagingView_CommitToolTip,UIUtils.SUBMIT_KEY_STROKE.format());
      commitButton.setToolTipText(commitButtonTooltip);
    }
    @Override public void focusLost(    FocusEvent e){
      commitButton.setToolTipText(null);
    }
  }
);
  IWorkbenchPartSite site=getSite();
  ISelectionService srv=CommonUtils.getService(site,ISelectionService.class);
  srv.addPostSelectionListener(selectionChangedListener);
  CommonUtils.getService(site,IPartService.class).addPartListener(partListener);
  UIUtils.notifySelectionChangedWithCurrentSelection(selectionChangedListener,site);
  site.setSelectionProvider(unstagedViewer);
  ViewerFilter filter=new ViewerFilter(){
    @Override public boolean select(    Viewer viewer,    Object parentElement,    Object element){
      StagingViewContentProvider contentProvider=getContentProvider((TreeViewer)viewer);
      if (element instanceof StagingEntry)       return contentProvider.isInFilter((StagingEntry)element);
 else       if (element instanceof StagingFolderEntry)       return contentProvider.hasVisibleChildren((StagingFolderEntry)element);
      return true;
    }
  }
;
  unstagedViewer.addFilter(filter);
  stagedViewer.addFilter(filter);
  restoreSashFormWeights();
  reactOnInitialSelection();
  IWorkbenchSiteProgressService service=CommonUtils.getService(getSite(),IWorkbenchSiteProgressService.class);
  if (service != null && reactOnSelection)   service.showBusyForFamily(org.eclipse.egit.core.JobFamilies.INDEX_DIFF_CACHE_UPDATE);
}",0.9928151891818058
91412,"@Override public void resourceChanged(IResourceChangeEvent event){
  Set<IResource> resources=new HashSet<>();
  IMarkerDelta[] markerDeltas=event.findMarkerDeltas(IMarker.PROBLEM,true);
  for (  IMarkerDelta delta : markerDeltas)   resources.add(delta.getResource());
  if (!resources.isEmpty())   updateLabels(resources);
}","@Override public void resourceChanged(IResourceChangeEvent event){
  Set<IResource> resources=new HashSet<>();
  IMarkerDelta[] markerDeltas=event.findMarkerDeltas(IMarker.PROBLEM,true);
  for (  IMarkerDelta delta : markerDeltas) {
    IResource resource=delta.getResource();
    while (resource.getType() != IResource.ROOT && resources.add(resource)) {
      resource=resource.getParent();
    }
  }
  if (!resources.isEmpty()) {
    updateLabels(resources);
  }
}",0.7787610619469026
91413,"private void updateLabels(Set<IResource> changedResources){
  List<Object> elements=getAffectedElements(changedResources);
  if (!elements.isEmpty()) {
    final Object[] updateElements=elements.toArray(new Object[elements.size()]);
    Display display=viewer.getControl().getDisplay();
    display.asyncExec(new Runnable(){
      @Override public void run(){
        viewer.update(updateElements,null);
      }
    }
);
  }
}","private void updateLabels(Set<IResource> changedResources){
  List<Object> elements=getAffectedElements(changedResources);
  if (!elements.isEmpty()) {
    final Object[] updateElements=elements.toArray(new Object[elements.size()]);
    Display display=viewer.getControl().getDisplay();
    display.asyncExec(new Runnable(){
      @Override public void run(){
        fireLabelProviderChanged(new LabelProviderChangedEvent(ProblemLabelDecorator.this,updateElements));
      }
    }
);
  }
}",0.8668122270742358
91414,"@Override public void dispose(){
  resourceManager.dispose();
  if (this.viewer != null)   ResourcesPlugin.getWorkspace().removeResourceChangeListener(this);
  super.dispose();
}","@Override public void dispose(){
  super.dispose();
  resourceManager.dispose();
  if (this.viewer != null)   ResourcesPlugin.getWorkspace().removeResourceChangeListener(this);
}",0.8932584269662921
91415,"@Override public void run(){
  viewer.update(updateElements,null);
}","@Override public void run(){
  fireLabelProviderChanged(new LabelProviderChangedEvent(ProblemLabelDecorator.this,updateElements));
}",0.58
91416,"private List<Object> getAffectedElements(Set<IResource> resources){
  List<Object> result=new ArrayList<>();
  if (viewer.getContentProvider() instanceof IStructuredContentProvider) {
    IStructuredContentProvider contentProvider=(IStructuredContentProvider)viewer.getContentProvider();
    Object[] elements=contentProvider.getElements(null);
    for (    Object element : elements) {
      IResource resource=AdapterUtils.adapt(element,IResource.class);
      if (resource != null && resources.contains(resource))       result.add(element);
    }
  }
  return result;
}","private void getAffectedElements(Set<IResource> resources,Object[] elements,IStructuredContentProvider contentProvider,List<Object> result){
  for (  Object element : elements) {
    IResource resource=AdapterUtils.adapt(element,IResource.class);
    if (resource != null && resources.contains(resource)) {
      result.add(element);
      if (contentProvider instanceof ITreeContentProvider) {
        getAffectedElements(resources,((ITreeContentProvider)contentProvider).getChildren(element),contentProvider,result);
      }
    }
  }
}",0.1117117117117117
91417,"@Override public int getProblemSeverity(){
  if (container == null)   return SEVERITY_NONE;
  try {
    return container.findMaxProblemSeverity(IMarker.PROBLEM,true,IResource.DEPTH_ONE);
  }
 catch (  CoreException e) {
    return SEVERITY_NONE;
  }
}","@Override public int getProblemSeverity(){
  if (container == null)   return SEVERITY_NONE;
  try {
    return container.findMaxProblemSeverity(IMarker.PROBLEM,true,IResource.DEPTH_INFINITE);
  }
 catch (  CoreException e) {
    return SEVERITY_NONE;
  }
}",0.9822485207100592
91418,"@Override public void createPartControl(final Composite parent){
  GridLayoutFactory.fillDefaults().applyTo(parent);
  toolkit=new FormToolkit(parent.getDisplay());
  parent.addDisposeListener(new DisposeListener(){
    @Override public void widgetDisposed(    DisposeEvent e){
      if (commitMessageComponent.isAmending() || userEnteredCommitMessage())       saveCommitMessageComponentState();
 else       deleteCommitMessageComponentState();
      resources.dispose();
      toolkit.dispose();
    }
  }
);
  form=toolkit.createForm(parent);
  parent.addControlListener(new ControlListener(){
    private int[] defaultWeights={1,1};
    @Override public void controlResized(    ControlEvent e){
      org.eclipse.swt.graphics.Rectangle b=parent.getBounds();
      int oldOrientation=mainSashForm.getOrientation();
      if ((oldOrientation == SWT.HORIZONTAL) && (b.height > b.width)) {
        mainSashForm.setOrientation(SWT.VERTICAL);
        mainSashForm.setWeights(defaultWeights);
      }
 else       if ((oldOrientation == SWT.VERTICAL) && (b.height <= b.width)) {
        mainSashForm.setOrientation(SWT.HORIZONTAL);
        mainSashForm.setWeights(defaultWeights);
      }
    }
    @Override public void controlMoved(    ControlEvent e){
    }
  }
);
  form.setImage(getImage(UIIcons.REPOSITORY));
  form.setText(UIText.StagingView_NoSelectionTitle);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(form);
  toolkit.decorateFormHeading(form);
  GridLayoutFactory.swtDefaults().applyTo(form.getBody());
  mainSashForm=new SashForm(form.getBody(),SWT.HORIZONTAL);
  saveSashFormWeightsOnDisposal(mainSashForm,HORIZONTAL_SASH_FORM_WEIGHT);
  toolkit.adapt(mainSashForm,true,true);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(mainSashForm);
  stagingSashForm=new SashForm(mainSashForm,getStagingFormOrientation());
  saveSashFormWeightsOnDisposal(stagingSashForm,STAGING_SASH_FORM_WEIGHT);
  toolkit.adapt(stagingSashForm,true,true);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(stagingSashForm);
  unstagedSection=toolkit.createSection(stagingSashForm,ExpandableComposite.TITLE_BAR);
  unstagedSection.setLayoutData(GridDataFactory.fillDefaults().grab(true,true).create());
  createUnstagedToolBarComposite();
  Composite unstagedComposite=toolkit.createComposite(unstagedSection);
  toolkit.paintBordersFor(unstagedComposite);
  unstagedSection.setClient(unstagedComposite);
  GridLayoutFactory.fillDefaults().extendedMargins(2,2,2,2).applyTo(unstagedComposite);
  unstagedViewer=createTree(unstagedComposite);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(unstagedViewer.getControl());
  unstagedViewer.getTree().setData(FormToolkit.KEY_DRAW_BORDER,FormToolkit.TREE_BORDER);
  unstagedViewer.setLabelProvider(createLabelProvider(unstagedViewer));
  unstagedViewer.setContentProvider(createStagingContentProvider(true));
  unstagedViewer.addDragSupport(DND.DROP_MOVE | DND.DROP_COPY | DND.DROP_LINK,new Transfer[]{LocalSelectionTransfer.getTransfer(),FileTransfer.getInstance()},new StagingDragListener(unstagedViewer));
  unstagedViewer.addDropSupport(DND.DROP_MOVE,new Transfer[]{LocalSelectionTransfer.getTransfer()},new DropTargetAdapter(){
    @Override public void drop(    DropTargetEvent event){
      event.detail=DND.DROP_COPY;
      if (event.data instanceof IStructuredSelection) {
        final IStructuredSelection selection=(IStructuredSelection)event.data;
        unstage(selection);
      }
    }
    @Override public void dragOver(    DropTargetEvent event){
      event.detail=DND.DROP_MOVE;
    }
  }
);
  unstagedViewer.addOpenListener(new IOpenListener(){
    @Override public void open(    OpenEvent event){
      compareWith(event);
    }
  }
);
  unstagedViewer.setComparator(new StagingEntryComparator(getSortCheckState(),getPreferenceStore().getBoolean(UIPreferences.STAGING_VIEW_FILENAME_MODE)));
  enableAutoExpand(unstagedViewer);
  addListenerToDisableAutoExpandOnCollapse(unstagedViewer);
  Composite rebaseAndCommitComposite=toolkit.createComposite(mainSashForm);
  rebaseAndCommitComposite.setLayout(GridLayoutFactory.fillDefaults().create());
  rebaseSection=toolkit.createSection(rebaseAndCommitComposite,ExpandableComposite.TITLE_BAR);
  rebaseSection.setText(UIText.StagingView_RebaseLabel);
  Composite rebaseComposite=toolkit.createComposite(rebaseSection);
  toolkit.paintBordersFor(rebaseComposite);
  rebaseSection.setClient(rebaseComposite);
  rebaseSection.setLayoutData(GridDataFactory.fillDefaults().create());
  rebaseComposite.setLayout(GridLayoutFactory.fillDefaults().numColumns(3).equalWidth(true).create());
  GridDataFactory buttonGridData=GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER);
  this.rebaseAbortButton=toolkit.createButton(rebaseComposite,UIText.StagingView_RebaseAbort,SWT.PUSH);
  rebaseAbortButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      rebaseAbort();
    }
  }
);
  rebaseAbortButton.setImage(getImage(UIIcons.REBASE_ABORT));
  buttonGridData.applyTo(rebaseAbortButton);
  this.rebaseSkipButton=toolkit.createButton(rebaseComposite,UIText.StagingView_RebaseSkip,SWT.PUSH);
  rebaseSkipButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      rebaseSkip();
    }
  }
);
  rebaseSkipButton.setImage(getImage(UIIcons.REBASE_SKIP));
  buttonGridData.applyTo(rebaseSkipButton);
  this.rebaseContinueButton=toolkit.createButton(rebaseComposite,UIText.StagingView_RebaseContinue,SWT.PUSH);
  rebaseContinueButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      rebaseContinue();
    }
  }
);
  rebaseContinueButton.setImage(getImage(UIIcons.REBASE_CONTINUE));
  buttonGridData.applyTo(rebaseContinueButton);
  showControl(rebaseSection,false);
  commitMessageSection=toolkit.createSection(rebaseAndCommitComposite,ExpandableComposite.TITLE_BAR);
  commitMessageSection.setText(UIText.StagingView_CommitMessage);
  commitMessageSection.setLayoutData(GridDataFactory.fillDefaults().grab(true,true).create());
  Composite commitMessageToolbarComposite=toolkit.createComposite(commitMessageSection);
  commitMessageToolbarComposite.setBackground(null);
  commitMessageToolbarComposite.setLayout(createRowLayoutWithoutMargin());
  commitMessageSection.setTextClient(commitMessageToolbarComposite);
  ToolBarManager commitMessageToolBarManager=new ToolBarManager(SWT.FLAT | SWT.HORIZONTAL);
  amendPreviousCommitAction=new Action(UIText.StagingView_Ammend_Previous_Commit,IAction.AS_CHECK_BOX){
    @Override public void run(){
      commitMessageComponent.setAmendingButtonSelection(isChecked());
      updateMessage();
    }
  }
;
  amendPreviousCommitAction.setImageDescriptor(UIIcons.AMEND_COMMIT);
  commitMessageToolBarManager.add(amendPreviousCommitAction);
  signedOffByAction=new Action(UIText.StagingView_Add_Signed_Off_By,IAction.AS_CHECK_BOX){
    @Override public void run(){
      commitMessageComponent.setSignedOffButtonSelection(isChecked());
    }
  }
;
  signedOffByAction.setImageDescriptor(UIIcons.SIGNED_OFF);
  commitMessageToolBarManager.add(signedOffByAction);
  addChangeIdAction=new Action(UIText.StagingView_Add_Change_ID,IAction.AS_CHECK_BOX){
    @Override public void run(){
      commitMessageComponent.setChangeIdButtonSelection(isChecked());
    }
  }
;
  addChangeIdAction.setImageDescriptor(UIIcons.GERRIT);
  commitMessageToolBarManager.add(addChangeIdAction);
  commitMessageToolBarManager.createControl(commitMessageToolbarComposite);
  Composite commitMessageComposite=toolkit.createComposite(commitMessageSection);
  commitMessageSection.setClient(commitMessageComposite);
  GridLayoutFactory.fillDefaults().numColumns(1).applyTo(commitMessageComposite);
  warningLabel=new ToggleableWarningLabel(commitMessageComposite,SWT.NONE);
  GridDataFactory.fillDefaults().grab(true,false).exclude(true).applyTo(warningLabel);
  Composite commitMessageTextComposite=toolkit.createComposite(commitMessageComposite);
  toolkit.paintBordersFor(commitMessageTextComposite);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(commitMessageTextComposite);
  GridLayoutFactory.fillDefaults().numColumns(1).extendedMargins(2,2,2,2).applyTo(commitMessageTextComposite);
  final CommitProposalProcessor commitProposalProcessor=new CommitProposalProcessor(){
    @Override protected Collection<String> computeFileNameProposals(){
      return getStagedFileNames();
    }
    @Override protected Collection<String> computeMessageProposals(){
      return CommitMessageHistory.getCommitHistory();
    }
  }
;
  commitMessageText=new CommitMessageArea(commitMessageTextComposite,EMPTY_STRING,toolkit.getBorderStyle()){
    @Override protected CommitProposalProcessor getCommitProposalProcessor(){
      return commitProposalProcessor;
    }
    @Override protected IHandlerService getHandlerService(){
      return CommonUtils.getService(getSite(),IHandlerService.class);
    }
  }
;
  commitMessageText.setData(FormToolkit.KEY_DRAW_BORDER,FormToolkit.TEXT_BORDER);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(commitMessageText);
  UIUtils.addBulbDecorator(commitMessageText.getTextWidget(),UIText.CommitDialog_ContentAssist);
  Composite composite=toolkit.createComposite(commitMessageComposite);
  toolkit.paintBordersFor(composite);
  GridDataFactory.fillDefaults().grab(true,false).applyTo(composite);
  GridLayoutFactory.swtDefaults().numColumns(2).applyTo(composite);
  toolkit.createLabel(composite,UIText.StagingView_Author).setForeground(toolkit.getColors().getColor(IFormColors.TB_TOGGLE));
  authorText=toolkit.createText(composite,null);
  authorText.setData(FormToolkit.KEY_DRAW_BORDER,FormToolkit.TEXT_BORDER);
  authorText.setLayoutData(GridDataFactory.fillDefaults().grab(true,false).create());
  toolkit.createLabel(composite,UIText.StagingView_Committer).setForeground(toolkit.getColors().getColor(IFormColors.TB_TOGGLE));
  committerText=toolkit.createText(composite,null);
  committerText.setData(FormToolkit.KEY_DRAW_BORDER,FormToolkit.TEXT_BORDER);
  committerText.setLayoutData(GridDataFactory.fillDefaults().grab(true,false).create());
  Composite buttonsContainer=toolkit.createComposite(composite);
  GridDataFactory.fillDefaults().grab(true,false).span(2,1).indent(0,8).applyTo(buttonsContainer);
  GridLayoutFactory.fillDefaults().numColumns(2).applyTo(buttonsContainer);
  ignoreErrors=toolkit.createButton(buttonsContainer,UIText.StagingView_IgnoreErrors,SWT.CHECK);
  ignoreErrors.setSelection(false);
  ignoreErrors.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      updateMessage();
      updateCommitButtons();
    }
  }
);
  getPreferenceStore().addPropertyChangeListener(new IPropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent event){
      if (isDisposed()) {
        getPreferenceStore().removePropertyChangeListener(this);
        return;
      }
      asyncExec(new Runnable(){
        @Override public void run(){
          updateIgnoreErrorsButtonVisibility();
          updateMessage();
          updateCommitButtons();
        }
      }
);
    }
  }
);
  GridDataFactory.fillDefaults().align(SWT.BEGINNING,SWT.BEGINNING).grab(true,true).applyTo(ignoreErrors);
  updateIgnoreErrorsButtonVisibility();
  Label filler=toolkit.createLabel(buttonsContainer,""String_Node_Str"");
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,true).applyTo(filler);
  Composite commitButtonsContainer=toolkit.createComposite(buttonsContainer);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).applyTo(commitButtonsContainer);
  GridLayoutFactory.fillDefaults().numColumns(2).equalWidth(true).applyTo(commitButtonsContainer);
  this.commitAndPushButton=toolkit.createButton(commitButtonsContainer,UIText.StagingView_CommitAndPush,SWT.PUSH);
  commitAndPushButton.setImage(getImage(UIIcons.PUSH));
  commitAndPushButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      commit(true);
    }
  }
);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).applyTo(commitAndPushButton);
  this.commitButton=toolkit.createButton(commitButtonsContainer,UIText.StagingView_Commit,SWT.PUSH);
  commitButton.setImage(getImage(UIIcons.COMMIT));
  commitButton.setText(UIText.StagingView_Commit);
  commitButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      commit(false);
    }
  }
);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).applyTo(commitButton);
  stagedSection=toolkit.createSection(stagingSashForm,ExpandableComposite.TITLE_BAR);
  createStagedToolBarComposite();
  Composite stagedComposite=toolkit.createComposite(stagedSection);
  toolkit.paintBordersFor(stagedComposite);
  stagedSection.setClient(stagedComposite);
  GridLayoutFactory.fillDefaults().extendedMargins(2,2,2,2).applyTo(stagedComposite);
  stagedViewer=createTree(stagedComposite);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(stagedViewer.getControl());
  stagedViewer.getTree().setData(FormToolkit.KEY_DRAW_BORDER,FormToolkit.TREE_BORDER);
  stagedViewer.setLabelProvider(createLabelProvider(stagedViewer));
  stagedViewer.setContentProvider(createStagingContentProvider(false));
  stagedViewer.addDragSupport(DND.DROP_MOVE | DND.DROP_COPY | DND.DROP_LINK,new Transfer[]{LocalSelectionTransfer.getTransfer(),FileTransfer.getInstance()},new StagingDragListener(stagedViewer));
  stagedViewer.addDropSupport(DND.DROP_MOVE,new Transfer[]{LocalSelectionTransfer.getTransfer()},new DropTargetAdapter(){
    @Override public void drop(    DropTargetEvent event){
      event.detail=DND.DROP_COPY;
      if (event.data instanceof IStructuredSelection) {
        final IStructuredSelection selection=(IStructuredSelection)event.data;
        stage(selection);
      }
    }
    @Override public void dragOver(    DropTargetEvent event){
      event.detail=DND.DROP_MOVE;
    }
  }
);
  stagedViewer.addOpenListener(new IOpenListener(){
    @Override public void open(    OpenEvent event){
      compareWith(event);
    }
  }
);
  stagedViewer.setComparator(new StagingEntryComparator(getSortCheckState(),getPreferenceStore().getBoolean(UIPreferences.STAGING_VIEW_FILENAME_MODE)));
  enableAutoExpand(stagedViewer);
  addListenerToDisableAutoExpandOnCollapse(stagedViewer);
  selectionChangedListener=new ISelectionListener(){
    @Override public void selectionChanged(    IWorkbenchPart part,    ISelection selection){
      if (part == getSite().getPart()) {
        return;
      }
      if (selection instanceof StructuredSelection) {
        reactOnSelection((StructuredSelection)selection);
      }
    }
  }
;
  partListener=new PartListener();
  IPreferenceStore preferenceStore=getPreferenceStore();
  if (preferenceStore.contains(UIPreferences.STAGING_VIEW_SYNC_SELECTION))   reactOnSelection=preferenceStore.getBoolean(UIPreferences.STAGING_VIEW_SYNC_SELECTION);
 else   preferenceStore.setDefault(UIPreferences.STAGING_VIEW_SYNC_SELECTION,true);
  preferenceStore.addPropertyChangeListener(uiPrefsListener);
  InstanceScope.INSTANCE.getNode(org.eclipse.egit.core.Activator.getPluginId()).addPreferenceChangeListener(prefListener);
  updateSectionText();
  updateToolbar();
  enableCommitWidgets(false);
  refreshAction.setEnabled(false);
  createPopupMenu(unstagedViewer);
  createPopupMenu(stagedViewer);
  final ICommitMessageComponentNotifications listener=new ICommitMessageComponentNotifications(){
    @Override public void updateSignedOffToggleSelection(    boolean selection){
      signedOffByAction.setChecked(selection);
    }
    @Override public void updateChangeIdToggleSelection(    boolean selection){
      addChangeIdAction.setChecked(selection);
      commitAndPushButton.setImage(getImage(selection ? UIIcons.GERRIT : UIIcons.PUSH));
    }
    @Override public void statusUpdated(){
      updateMessage();
    }
  }
;
  commitMessageComponent=new CommitMessageComponent(listener);
  commitMessageComponent.attachControls(commitMessageText,authorText,committerText);
  commitMessageText.getTextWidget().addVerifyKeyListener(new VerifyKeyListener(){
    @Override public void verifyKey(    VerifyEvent event){
      if (UIUtils.isSubmitKeyEvent(event)) {
        event.doit=false;
        commit(false);
      }
    }
  }
);
  commitMessageText.getTextWidget().addFocusListener(new FocusListener(){
    @Override public void focusGained(    FocusEvent e){
      String commitButtonTooltip=MessageFormat.format(UIText.StagingView_CommitToolTip,UIUtils.SUBMIT_KEY_STROKE.format());
      commitButton.setToolTipText(commitButtonTooltip);
    }
    @Override public void focusLost(    FocusEvent e){
      commitButton.setToolTipText(null);
    }
  }
);
  IWorkbenchPartSite site=getSite();
  ISelectionService srv=CommonUtils.getService(site,ISelectionService.class);
  srv.addPostSelectionListener(selectionChangedListener);
  CommonUtils.getService(site,IPartService.class).addPartListener(partListener);
  UIUtils.notifySelectionChangedWithCurrentSelection(selectionChangedListener,site);
  site.setSelectionProvider(unstagedViewer);
  ViewerFilter filter=new ViewerFilter(){
    @Override public boolean select(    Viewer viewer,    Object parentElement,    Object element){
      StagingViewContentProvider contentProvider=getContentProvider((TreeViewer)viewer);
      if (element instanceof StagingEntry)       return contentProvider.isInFilter((StagingEntry)element);
 else       if (element instanceof StagingFolderEntry)       return contentProvider.hasVisibleChildren((StagingFolderEntry)element);
      return true;
    }
  }
;
  unstagedViewer.addFilter(filter);
  stagedViewer.addFilter(filter);
  restoreSashFormWeights();
  reactOnInitialSelection();
  IWorkbenchSiteProgressService service=CommonUtils.getService(getSite(),IWorkbenchSiteProgressService.class);
  if (service != null && reactOnSelection)   service.showBusyForFamily(org.eclipse.egit.core.JobFamilies.INDEX_DIFF_CACHE_UPDATE);
}","@Override public void createPartControl(final Composite parent){
  GridLayoutFactory.fillDefaults().applyTo(parent);
  toolkit=new FormToolkit(parent.getDisplay());
  parent.addDisposeListener(new DisposeListener(){
    @Override public void widgetDisposed(    DisposeEvent e){
      if (commitMessageComponent.isAmending() || userEnteredCommitMessage())       saveCommitMessageComponentState();
 else       deleteCommitMessageComponentState();
      resources.dispose();
      toolkit.dispose();
    }
  }
);
  form=toolkit.createForm(parent);
  parent.addControlListener(new ControlListener(){
    private int[] defaultWeights={1,1};
    @Override public void controlResized(    ControlEvent e){
      org.eclipse.swt.graphics.Rectangle b=parent.getBounds();
      int oldOrientation=mainSashForm.getOrientation();
      if ((oldOrientation == SWT.HORIZONTAL) && (b.height > b.width)) {
        mainSashForm.setOrientation(SWT.VERTICAL);
        mainSashForm.setWeights(defaultWeights);
      }
 else       if ((oldOrientation == SWT.VERTICAL) && (b.height <= b.width)) {
        mainSashForm.setOrientation(SWT.HORIZONTAL);
        mainSashForm.setWeights(defaultWeights);
      }
    }
    @Override public void controlMoved(    ControlEvent e){
    }
  }
);
  form.setImage(getImage(UIIcons.REPOSITORY));
  form.setText(UIText.StagingView_NoSelectionTitle);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(form);
  toolkit.decorateFormHeading(form);
  GridLayoutFactory.swtDefaults().applyTo(form.getBody());
  mainSashForm=new SashForm(form.getBody(),SWT.HORIZONTAL);
  saveSashFormWeightsOnDisposal(mainSashForm,HORIZONTAL_SASH_FORM_WEIGHT);
  toolkit.adapt(mainSashForm,true,true);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(mainSashForm);
  stagingSashForm=new SashForm(mainSashForm,getStagingFormOrientation());
  saveSashFormWeightsOnDisposal(stagingSashForm,STAGING_SASH_FORM_WEIGHT);
  toolkit.adapt(stagingSashForm,true,true);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(stagingSashForm);
  unstagedSection=toolkit.createSection(stagingSashForm,ExpandableComposite.TITLE_BAR);
  unstagedSection.setLayoutData(GridDataFactory.fillDefaults().grab(true,true).create());
  createUnstagedToolBarComposite();
  Composite unstagedComposite=toolkit.createComposite(unstagedSection);
  toolkit.paintBordersFor(unstagedComposite);
  unstagedSection.setClient(unstagedComposite);
  GridLayoutFactory.fillDefaults().extendedMargins(2,2,2,2).applyTo(unstagedComposite);
  unstagedViewer=createTree(unstagedComposite);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(unstagedViewer.getControl());
  unstagedViewer.getTree().setData(FormToolkit.KEY_DRAW_BORDER,FormToolkit.TREE_BORDER);
  unstagedViewer.setLabelProvider(createLabelProvider(unstagedViewer));
  unstagedViewer.setContentProvider(createStagingContentProvider(true));
  unstagedViewer.addDragSupport(DND.DROP_MOVE | DND.DROP_COPY | DND.DROP_LINK,new Transfer[]{LocalSelectionTransfer.getTransfer(),FileTransfer.getInstance()},new StagingDragListener(unstagedViewer));
  unstagedViewer.addDropSupport(DND.DROP_MOVE,new Transfer[]{LocalSelectionTransfer.getTransfer()},new DropTargetAdapter(){
    @Override public void drop(    DropTargetEvent event){
      event.detail=DND.DROP_COPY;
      if (event.data instanceof IStructuredSelection) {
        final IStructuredSelection selection=(IStructuredSelection)event.data;
        unstage(selection);
      }
    }
    @Override public void dragOver(    DropTargetEvent event){
      event.detail=DND.DROP_MOVE;
    }
  }
);
  unstagedViewer.addOpenListener(new IOpenListener(){
    @Override public void open(    OpenEvent event){
      compareWith(event);
    }
  }
);
  unstagedViewer.setComparator(new StagingEntryComparator(getSortCheckState(),getPreferenceStore().getBoolean(UIPreferences.STAGING_VIEW_FILENAME_MODE)));
  enableAutoExpand(unstagedViewer);
  addListenerToDisableAutoExpandOnCollapse(unstagedViewer);
  Composite rebaseAndCommitComposite=toolkit.createComposite(mainSashForm);
  rebaseAndCommitComposite.setLayout(GridLayoutFactory.fillDefaults().create());
  rebaseSection=toolkit.createSection(rebaseAndCommitComposite,ExpandableComposite.TITLE_BAR);
  rebaseSection.setText(UIText.StagingView_RebaseLabel);
  Composite rebaseComposite=toolkit.createComposite(rebaseSection);
  toolkit.paintBordersFor(rebaseComposite);
  rebaseSection.setClient(rebaseComposite);
  rebaseSection.setLayoutData(GridDataFactory.fillDefaults().create());
  rebaseComposite.setLayout(GridLayoutFactory.fillDefaults().numColumns(3).equalWidth(true).create());
  GridDataFactory buttonGridData=GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER);
  this.rebaseAbortButton=toolkit.createButton(rebaseComposite,UIText.StagingView_RebaseAbort,SWT.PUSH);
  rebaseAbortButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      rebaseAbort();
    }
  }
);
  rebaseAbortButton.setImage(getImage(UIIcons.REBASE_ABORT));
  buttonGridData.applyTo(rebaseAbortButton);
  this.rebaseSkipButton=toolkit.createButton(rebaseComposite,UIText.StagingView_RebaseSkip,SWT.PUSH);
  rebaseSkipButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      rebaseSkip();
    }
  }
);
  rebaseSkipButton.setImage(getImage(UIIcons.REBASE_SKIP));
  buttonGridData.applyTo(rebaseSkipButton);
  this.rebaseContinueButton=toolkit.createButton(rebaseComposite,UIText.StagingView_RebaseContinue,SWT.PUSH);
  rebaseContinueButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      rebaseContinue();
    }
  }
);
  rebaseContinueButton.setImage(getImage(UIIcons.REBASE_CONTINUE));
  buttonGridData.applyTo(rebaseContinueButton);
  showControl(rebaseSection,false);
  commitMessageSection=toolkit.createSection(rebaseAndCommitComposite,ExpandableComposite.TITLE_BAR);
  commitMessageSection.setText(UIText.StagingView_CommitMessage);
  commitMessageSection.setLayoutData(GridDataFactory.fillDefaults().grab(true,true).create());
  Composite commitMessageToolbarComposite=toolkit.createComposite(commitMessageSection);
  commitMessageToolbarComposite.setBackground(null);
  commitMessageToolbarComposite.setLayout(createRowLayoutWithoutMargin());
  commitMessageSection.setTextClient(commitMessageToolbarComposite);
  ToolBarManager commitMessageToolBarManager=new ToolBarManager(SWT.FLAT | SWT.HORIZONTAL);
  amendPreviousCommitAction=new Action(UIText.StagingView_Ammend_Previous_Commit,IAction.AS_CHECK_BOX){
    @Override public void run(){
      commitMessageComponent.setAmendingButtonSelection(isChecked());
      updateMessage();
    }
  }
;
  amendPreviousCommitAction.setImageDescriptor(UIIcons.AMEND_COMMIT);
  commitMessageToolBarManager.add(amendPreviousCommitAction);
  signedOffByAction=new Action(UIText.StagingView_Add_Signed_Off_By,IAction.AS_CHECK_BOX){
    @Override public void run(){
      commitMessageComponent.setSignedOffButtonSelection(isChecked());
    }
  }
;
  signedOffByAction.setImageDescriptor(UIIcons.SIGNED_OFF);
  commitMessageToolBarManager.add(signedOffByAction);
  addChangeIdAction=new Action(UIText.StagingView_Add_Change_ID,IAction.AS_CHECK_BOX){
    @Override public void run(){
      commitMessageComponent.setChangeIdButtonSelection(isChecked());
    }
  }
;
  addChangeIdAction.setImageDescriptor(UIIcons.GERRIT);
  commitMessageToolBarManager.add(addChangeIdAction);
  commitMessageToolBarManager.createControl(commitMessageToolbarComposite);
  Composite commitMessageComposite=toolkit.createComposite(commitMessageSection);
  commitMessageSection.setClient(commitMessageComposite);
  GridLayoutFactory.fillDefaults().numColumns(1).applyTo(commitMessageComposite);
  warningLabel=new ToggleableWarningLabel(commitMessageComposite,SWT.NONE);
  GridDataFactory.fillDefaults().grab(true,false).exclude(true).applyTo(warningLabel);
  Composite commitMessageTextComposite=toolkit.createComposite(commitMessageComposite);
  toolkit.paintBordersFor(commitMessageTextComposite);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(commitMessageTextComposite);
  GridLayoutFactory.fillDefaults().numColumns(1).extendedMargins(2,2,2,2).applyTo(commitMessageTextComposite);
  final CommitProposalProcessor commitProposalProcessor=new CommitProposalProcessor(){
    @Override protected Collection<String> computeFileNameProposals(){
      return getStagedFileNames();
    }
    @Override protected Collection<String> computeMessageProposals(){
      return CommitMessageHistory.getCommitHistory();
    }
  }
;
  commitMessageText=new CommitMessageArea(commitMessageTextComposite,EMPTY_STRING,toolkit.getBorderStyle()){
    @Override protected CommitProposalProcessor getCommitProposalProcessor(){
      return commitProposalProcessor;
    }
    @Override protected IHandlerService getHandlerService(){
      return CommonUtils.getService(getSite(),IHandlerService.class);
    }
  }
;
  commitMessageText.setData(FormToolkit.KEY_DRAW_BORDER,FormToolkit.TEXT_BORDER);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(commitMessageText);
  UIUtils.addBulbDecorator(commitMessageText.getTextWidget(),UIText.CommitDialog_ContentAssist);
  Composite composite=toolkit.createComposite(commitMessageComposite);
  toolkit.paintBordersFor(composite);
  GridDataFactory.fillDefaults().grab(true,false).applyTo(composite);
  GridLayoutFactory.swtDefaults().numColumns(2).applyTo(composite);
  toolkit.createLabel(composite,UIText.StagingView_Author).setForeground(toolkit.getColors().getColor(IFormColors.TB_TOGGLE));
  authorText=toolkit.createText(composite,null);
  authorText.setData(FormToolkit.KEY_DRAW_BORDER,FormToolkit.TEXT_BORDER);
  authorText.setLayoutData(GridDataFactory.fillDefaults().grab(true,false).create());
  toolkit.createLabel(composite,UIText.StagingView_Committer).setForeground(toolkit.getColors().getColor(IFormColors.TB_TOGGLE));
  committerText=toolkit.createText(composite,null);
  committerText.setData(FormToolkit.KEY_DRAW_BORDER,FormToolkit.TEXT_BORDER);
  committerText.setLayoutData(GridDataFactory.fillDefaults().grab(true,false).create());
  Composite buttonsContainer=toolkit.createComposite(composite);
  GridDataFactory.fillDefaults().grab(true,false).span(2,1).indent(0,8).applyTo(buttonsContainer);
  GridLayoutFactory.fillDefaults().numColumns(2).applyTo(buttonsContainer);
  ignoreErrors=toolkit.createButton(buttonsContainer,UIText.StagingView_IgnoreErrors,SWT.CHECK);
  ignoreErrors.setSelection(false);
  ignoreErrors.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      updateMessage();
      updateCommitButtons();
    }
  }
);
  getPreferenceStore().addPropertyChangeListener(new IPropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent event){
      if (isDisposed()) {
        getPreferenceStore().removePropertyChangeListener(this);
        return;
      }
      asyncExec(new Runnable(){
        @Override public void run(){
          updateIgnoreErrorsButtonVisibility();
          updateMessage();
          updateCommitButtons();
        }
      }
);
    }
  }
);
  GridDataFactory.fillDefaults().align(SWT.BEGINNING,SWT.BEGINNING).grab(true,true).applyTo(ignoreErrors);
  updateIgnoreErrorsButtonVisibility();
  Label filler=toolkit.createLabel(buttonsContainer,""String_Node_Str"");
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,true).applyTo(filler);
  Composite commitButtonsContainer=toolkit.createComposite(buttonsContainer);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).applyTo(commitButtonsContainer);
  GridLayoutFactory.fillDefaults().numColumns(2).equalWidth(true).applyTo(commitButtonsContainer);
  this.commitAndPushButton=toolkit.createButton(commitButtonsContainer,UIText.StagingView_CommitAndPush,SWT.PUSH);
  commitAndPushButton.setImage(getImage(UIIcons.PUSH));
  commitAndPushButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      commit(true);
    }
  }
);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).applyTo(commitAndPushButton);
  this.commitButton=toolkit.createButton(commitButtonsContainer,UIText.StagingView_Commit,SWT.PUSH);
  commitButton.setImage(getImage(UIIcons.COMMIT));
  commitButton.setText(UIText.StagingView_Commit);
  commitButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      commit(false);
    }
  }
);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).applyTo(commitButton);
  stagedSection=toolkit.createSection(stagingSashForm,ExpandableComposite.TITLE_BAR);
  createStagedToolBarComposite();
  Composite stagedComposite=toolkit.createComposite(stagedSection);
  toolkit.paintBordersFor(stagedComposite);
  stagedSection.setClient(stagedComposite);
  GridLayoutFactory.fillDefaults().extendedMargins(2,2,2,2).applyTo(stagedComposite);
  stagedViewer=createTree(stagedComposite);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(stagedViewer.getControl());
  stagedViewer.getTree().setData(FormToolkit.KEY_DRAW_BORDER,FormToolkit.TREE_BORDER);
  IBaseLabelProvider labelProvider=createLabelProvider(stagedViewer);
  labelProvider.addListener(new ILabelProviderListener(){
    @Override public void labelProviderChanged(    LabelProviderChangedEvent event){
      updateCommitButtons();
    }
  }
);
  stagedViewer.setLabelProvider(labelProvider);
  stagedViewer.setContentProvider(createStagingContentProvider(false));
  stagedViewer.addDragSupport(DND.DROP_MOVE | DND.DROP_COPY | DND.DROP_LINK,new Transfer[]{LocalSelectionTransfer.getTransfer(),FileTransfer.getInstance()},new StagingDragListener(stagedViewer));
  stagedViewer.addDropSupport(DND.DROP_MOVE,new Transfer[]{LocalSelectionTransfer.getTransfer()},new DropTargetAdapter(){
    @Override public void drop(    DropTargetEvent event){
      event.detail=DND.DROP_COPY;
      if (event.data instanceof IStructuredSelection) {
        final IStructuredSelection selection=(IStructuredSelection)event.data;
        stage(selection);
      }
    }
    @Override public void dragOver(    DropTargetEvent event){
      event.detail=DND.DROP_MOVE;
    }
  }
);
  stagedViewer.addOpenListener(new IOpenListener(){
    @Override public void open(    OpenEvent event){
      compareWith(event);
    }
  }
);
  stagedViewer.setComparator(new StagingEntryComparator(getSortCheckState(),getPreferenceStore().getBoolean(UIPreferences.STAGING_VIEW_FILENAME_MODE)));
  enableAutoExpand(stagedViewer);
  addListenerToDisableAutoExpandOnCollapse(stagedViewer);
  selectionChangedListener=new ISelectionListener(){
    @Override public void selectionChanged(    IWorkbenchPart part,    ISelection selection){
      if (part == getSite().getPart()) {
        return;
      }
      if (selection instanceof StructuredSelection) {
        reactOnSelection((StructuredSelection)selection);
      }
    }
  }
;
  partListener=new PartListener();
  IPreferenceStore preferenceStore=getPreferenceStore();
  if (preferenceStore.contains(UIPreferences.STAGING_VIEW_SYNC_SELECTION))   reactOnSelection=preferenceStore.getBoolean(UIPreferences.STAGING_VIEW_SYNC_SELECTION);
 else   preferenceStore.setDefault(UIPreferences.STAGING_VIEW_SYNC_SELECTION,true);
  preferenceStore.addPropertyChangeListener(uiPrefsListener);
  InstanceScope.INSTANCE.getNode(org.eclipse.egit.core.Activator.getPluginId()).addPreferenceChangeListener(prefListener);
  updateSectionText();
  updateToolbar();
  enableCommitWidgets(false);
  refreshAction.setEnabled(false);
  createPopupMenu(unstagedViewer);
  createPopupMenu(stagedViewer);
  final ICommitMessageComponentNotifications listener=new ICommitMessageComponentNotifications(){
    @Override public void updateSignedOffToggleSelection(    boolean selection){
      signedOffByAction.setChecked(selection);
    }
    @Override public void updateChangeIdToggleSelection(    boolean selection){
      addChangeIdAction.setChecked(selection);
      commitAndPushButton.setImage(getImage(selection ? UIIcons.GERRIT : UIIcons.PUSH));
    }
    @Override public void statusUpdated(){
      updateMessage();
    }
  }
;
  commitMessageComponent=new CommitMessageComponent(listener);
  commitMessageComponent.attachControls(commitMessageText,authorText,committerText);
  commitMessageText.getTextWidget().addVerifyKeyListener(new VerifyKeyListener(){
    @Override public void verifyKey(    VerifyEvent event){
      if (UIUtils.isSubmitKeyEvent(event)) {
        event.doit=false;
        commit(false);
      }
    }
  }
);
  commitMessageText.getTextWidget().addFocusListener(new FocusListener(){
    @Override public void focusGained(    FocusEvent e){
      String commitButtonTooltip=MessageFormat.format(UIText.StagingView_CommitToolTip,UIUtils.SUBMIT_KEY_STROKE.format());
      commitButton.setToolTipText(commitButtonTooltip);
    }
    @Override public void focusLost(    FocusEvent e){
      commitButton.setToolTipText(null);
    }
  }
);
  IWorkbenchPartSite site=getSite();
  ISelectionService srv=CommonUtils.getService(site,ISelectionService.class);
  srv.addPostSelectionListener(selectionChangedListener);
  CommonUtils.getService(site,IPartService.class).addPartListener(partListener);
  UIUtils.notifySelectionChangedWithCurrentSelection(selectionChangedListener,site);
  site.setSelectionProvider(unstagedViewer);
  ViewerFilter filter=new ViewerFilter(){
    @Override public boolean select(    Viewer viewer,    Object parentElement,    Object element){
      StagingViewContentProvider contentProvider=getContentProvider((TreeViewer)viewer);
      if (element instanceof StagingEntry)       return contentProvider.isInFilter((StagingEntry)element);
 else       if (element instanceof StagingFolderEntry)       return contentProvider.hasVisibleChildren((StagingFolderEntry)element);
      return true;
    }
  }
;
  unstagedViewer.addFilter(filter);
  stagedViewer.addFilter(filter);
  restoreSashFormWeights();
  reactOnInitialSelection();
  IWorkbenchSiteProgressService service=CommonUtils.getService(getSite(),IWorkbenchSiteProgressService.class);
  if (service != null && reactOnSelection)   service.showBusyForFamily(org.eclipse.egit.core.JobFamilies.INDEX_DIFF_CACHE_UPDATE);
}",0.9928151891818058
91419,"private RepositoryMapping(final @NonNull IContainer mappedContainer,final @NonNull IPath location,final @NonNull File gitDir){
  container=mappedContainer;
  containerPathString=container.getProjectRelativePath().toPortableString();
  if (!gitDir.isAbsolute()) {
    gitDirPathString=Path.fromOSString(gitDir.getPath()).removeTrailingSeparator().toPortableString();
    return;
  }
  java.nio.file.Path gPath=gitDir.toPath();
  java.nio.file.Path lPath=location.toFile().toPath();
  if (lPath.getNameCount() > 0 && gPath.getNameCount() > 0 && gPath.getRoot().equals(lPath.getRoot()) && gPath.getName(0).equals(lPath.getName(0))) {
    gPath=lPath.relativize(gPath);
  }
  gitDirPathString=Path.fromOSString(gPath.toString()).removeTrailingSeparator().toPortableString();
}","private RepositoryMapping(final @NonNull IContainer mappedContainer,final @NonNull IPath location,final @NonNull File gitDir){
  container=mappedContainer;
  containerPathString=container.getProjectRelativePath().toPortableString();
  if (!gitDir.isAbsolute()) {
    gitDirPathString=Path.fromOSString(gitDir.getPath()).removeTrailingSeparator().toPortableString();
    return;
  }
  java.nio.file.Path gPath=gitDir.toPath();
  java.nio.file.Path lPath=location.toFile().toPath();
  if (lPath.getNameCount() > 0 && gPath.getNameCount() > 0 && (gPath.getRoot() == lPath.getRoot() || gPath.getRoot() != null && gPath.getRoot().equals(lPath.getRoot())) && gPath.getName(0).equals(lPath.getName(0))) {
    gPath=lPath.relativize(gPath);
  }
  gitDirPathString=Path.fromOSString(gPath.toString()).removeTrailingSeparator().toPortableString();
}",0.94723774053383
91420,"private ISaveablesLifecycleListener getSaveablesLifecycleListener(IWorkbenchPart part){
  ISaveablesLifecycleListener listener=(ISaveablesLifecycleListener)Utils.getAdapter(part,ISaveablesLifecycleListener.class);
  if (listener == null)   listener=CommonUtils.getService(part.getSite(),ISaveablesLifecycleListener.class);
  return listener;
}","private ISaveablesLifecycleListener getSaveablesLifecycleListener(IWorkbenchPart part){
  ISaveablesLifecycleListener listener=AdapterUtils.adapt(part,ISaveablesLifecycleListener.class);
  if (listener == null)   listener=CommonUtils.getService(part.getSite(),ISaveablesLifecycleListener.class);
  return listener;
}",0.9256449165402124
91421,"@Nullable @Override public String asReference(URI uri,String projectName){
  try {
    GitURI gitURI=new GitURI(uri);
    return asReference(gitURI.getRepository().toString(),gitURI.getTag(),gitURI.getPath().toString());
  }
 catch (  IllegalArgumentException e) {
    Activator.error(e.getMessage(),e);
    return null;
  }
}","@Nullable @Override public String asReference(URI uri,String projectName){
  try {
    GitURI gitURI=new GitURI(uri);
    return asReference(gitURI.getRepository().toString(),gitURI.getTag(),gitURI.getPath().toString());
  }
 catch (  IllegalArgumentException e) {
    Activator.logError(e.getMessage(),e);
    return null;
  }
}",0.9923664122137404
91422,"/** 
 * Refreshes all resources that changed in the index since the last call to this method. This is suitable for incremental updates on index changed events For bare repositories this does nothing.
 */
private void refreshIndexDelta(){
  Repository repository=getRepository();
  if (repository == null || repository.isBare()) {
    return;
  }
  try {
    DirCache currentIndex=DirCache.read(repository.getIndexFile(),repository.getFS());
    DirCache oldIndex=lastIndex;
    lastIndex=currentIndex;
    if (oldIndex == null) {
      refresh();
      return;
    }
    Set<String> paths=new TreeSet<String>();
    try (TreeWalk walk=new TreeWalk(repository)){
      walk.addTree(new DirCacheIterator(oldIndex));
      walk.addTree(new DirCacheIterator(currentIndex));
      walk.setFilter(new InterIndexDiffFilter());
      while (walk.next()) {
        if (walk.isSubtree())         walk.enterSubtree();
 else         paths.add(walk.getPathString());
      }
    }
     if (!paths.isEmpty())     refreshFiles(paths);
  }
 catch (  IOException ex) {
    Activator.error(MessageFormat.format(CoreText.IndexDiffCacheEntry_errorCalculatingIndexDelta,repository),ex);
    scheduleReloadJob(""String_Node_Str"");
  }
}","/** 
 * Refreshes all resources that changed in the index since the last call to this method. This is suitable for incremental updates on index changed events For bare repositories this does nothing.
 */
private void refreshIndexDelta(){
  Repository repository=getRepository();
  if (repository == null || repository.isBare()) {
    return;
  }
  try {
    DirCache currentIndex=DirCache.read(repository.getIndexFile(),repository.getFS());
    DirCache oldIndex=lastIndex;
    lastIndex=currentIndex;
    if (oldIndex == null) {
      refresh();
      return;
    }
    Set<String> paths=new TreeSet<String>();
    try (TreeWalk walk=new TreeWalk(repository)){
      walk.addTree(new DirCacheIterator(oldIndex));
      walk.addTree(new DirCacheIterator(currentIndex));
      walk.setFilter(new InterIndexDiffFilter());
      while (walk.next()) {
        if (walk.isSubtree())         walk.enterSubtree();
 else         paths.add(walk.getPathString());
      }
    }
     if (!paths.isEmpty())     refreshFiles(paths);
  }
 catch (  IOException ex) {
    Activator.logError(MessageFormat.format(CoreText.IndexDiffCacheEntry_errorCalculatingIndexDelta,repository),ex);
    scheduleReloadJob(""String_Node_Str"");
  }
}",0.9979415397282831
91423,"private void setAuthorAndCommitter(CommitCommand commitCommand) throws TeamException {
  final Date commitDate=new Date();
  final TimeZone timeZone=TimeZone.getDefault();
  final PersonIdent enteredAuthor=RawParseUtils.parsePersonIdent(author);
  final PersonIdent enteredCommitter=RawParseUtils.parsePersonIdent(committer);
  if (enteredAuthor == null)   throw new TeamException(NLS.bind(CoreText.CommitOperation_errorParsingPersonIdent,author));
  if (enteredCommitter == null)   throw new TeamException(NLS.bind(CoreText.CommitOperation_errorParsingPersonIdent,committer));
  PersonIdent authorIdent;
  if (repo.getRepositoryState().equals(RepositoryState.CHERRY_PICKING_RESOLVED)) {
    try (RevWalk rw=new RevWalk(repo)){
      ObjectId cherryPickHead=repo.readCherryPickHead();
      authorIdent=rw.parseCommit(cherryPickHead).getAuthorIdent();
    }
 catch (    IOException e) {
      Activator.error(CoreText.CommitOperation_ParseCherryPickCommitFailed,e);
      throw new IllegalStateException(e);
    }
  }
 else {
    authorIdent=new PersonIdent(enteredAuthor,commitDate,timeZone);
  }
  final PersonIdent committerIdent=new PersonIdent(enteredCommitter,commitDate,timeZone);
  if (amending) {
    RepositoryUtil repoUtil=Activator.getDefault().getRepositoryUtil();
    RevCommit headCommit=repoUtil.parseHeadCommit(repo);
    if (headCommit != null) {
      final PersonIdent headAuthor=headCommit.getAuthorIdent();
      authorIdent=new PersonIdent(enteredAuthor,headAuthor.getWhen(),headAuthor.getTimeZone());
    }
  }
  commitCommand.setAuthor(authorIdent);
  commitCommand.setCommitter(committerIdent);
}","private void setAuthorAndCommitter(CommitCommand commitCommand) throws TeamException {
  final Date commitDate=new Date();
  final TimeZone timeZone=TimeZone.getDefault();
  final PersonIdent enteredAuthor=RawParseUtils.parsePersonIdent(author);
  final PersonIdent enteredCommitter=RawParseUtils.parsePersonIdent(committer);
  if (enteredAuthor == null)   throw new TeamException(NLS.bind(CoreText.CommitOperation_errorParsingPersonIdent,author));
  if (enteredCommitter == null)   throw new TeamException(NLS.bind(CoreText.CommitOperation_errorParsingPersonIdent,committer));
  PersonIdent authorIdent;
  if (repo.getRepositoryState().equals(RepositoryState.CHERRY_PICKING_RESOLVED)) {
    try (RevWalk rw=new RevWalk(repo)){
      ObjectId cherryPickHead=repo.readCherryPickHead();
      authorIdent=rw.parseCommit(cherryPickHead).getAuthorIdent();
    }
 catch (    IOException e) {
      Activator.logError(CoreText.CommitOperation_ParseCherryPickCommitFailed,e);
      throw new IllegalStateException(e);
    }
  }
 else {
    authorIdent=new PersonIdent(enteredAuthor,commitDate,timeZone);
  }
  final PersonIdent committerIdent=new PersonIdent(enteredCommitter,commitDate,timeZone);
  if (amending) {
    RepositoryUtil repoUtil=Activator.getDefault().getRepositoryUtil();
    RevCommit headCommit=repoUtil.parseHeadCommit(repo);
    if (headCommit != null) {
      final PersonIdent headAuthor=headCommit.getAuthorIdent();
      authorIdent=new PersonIdent(enteredAuthor,headAuthor.getWhen(),headAuthor.getTimeZone());
    }
  }
  commitCommand.setAuthor(authorIdent);
  commitCommand.setCommitter(committerIdent);
}",0.9984601170311056
91424,"/** 
 * Touches all descendants named "".git"" so that they'll be included in a subsequent resource delta.
 * @param project to process
 * @param monitor for progress reporting and cancellation, may be  {@code null}if neither is desired
 */
private void touchGitResources(IProject project,IProgressMonitor monitor){
  final SubMonitor progress=SubMonitor.convert(monitor,1);
  try {
    project.accept(new IResourceProxyVisitor(){
      @Override public boolean visit(      IResourceProxy resource) throws CoreException {
        int type=resource.getType();
        if ((type == IResource.FILE || type == IResource.FOLDER) && Constants.DOT_GIT.equals(resource.getName())) {
          progress.setWorkRemaining(2);
          resource.requestResource().touch(progress.newChild(1));
          return false;
        }
        return true;
      }
    }
,IResource.NONE);
  }
 catch (  CoreException e) {
    Activator.error(e.getMessage(),e);
  }
}","/** 
 * Touches all descendants named "".git"" so that they'll be included in a subsequent resource delta.
 * @param project to process
 * @param monitor for progress reporting and cancellation, may be  {@code null}if neither is desired
 */
private void touchGitResources(IProject project,IProgressMonitor monitor){
  final SubMonitor progress=SubMonitor.convert(monitor,1);
  try {
    project.accept(new IResourceProxyVisitor(){
      @Override public boolean visit(      IResourceProxy resource) throws CoreException {
        int type=resource.getType();
        if ((type == IResource.FILE || type == IResource.FOLDER) && Constants.DOT_GIT.equals(resource.getName())) {
          progress.setWorkRemaining(2);
          resource.requestResource().touch(progress.newChild(1));
          return false;
        }
        return true;
      }
    }
,IResource.NONE);
  }
 catch (  CoreException e) {
    Activator.logError(e.getMessage(),e);
  }
}",0.9973530968766544
91425,"@Override protected void fetchContents(IProgressMonitor monitor) throws TeamException {
  CommitBlobStorage content=new CommitBlobStorage(repo,getPath(),getObjectId(),getCommitId());
  try {
    setContents(content.getContents(),monitor);
  }
 catch (  CoreException e) {
    Activator.error(""String_Node_Str"",e);
  }
}","@Override protected void fetchContents(IProgressMonitor monitor) throws TeamException {
  CommitBlobStorage content=new CommitBlobStorage(repo,getPath(),getObjectId(),getCommitId());
  try {
    setContents(content.getContents(),monitor);
  }
 catch (  CoreException e) {
    Activator.logError(""String_Node_Str"",e);
  }
}",0.9921996879875196
91426,"/** 
 * @param repo repository which should be scanned
 * @return list of changes in git staging area
 */
public static Map<String,Change> build(Repository repo){
  try (TreeWalk tw=new TreeWalk(repo)){
    tw.addTree(new DirCacheIterator(repo.readDirCache()));
    ObjectId headId=repo.resolve(HEAD);
    RevCommit headCommit=null;
    if (headId != null) {
      try (RevWalk rw=new RevWalk(repo)){
        headCommit=rw.parseCommit(headId);
      }
     }
    AbbreviatedObjectId commitId;
    if (headCommit != null) {
      tw.addTree(headCommit.getTree());
      commitId=AbbreviatedObjectId.fromObjectId(headCommit);
    }
 else {
      tw.addTree(new EmptyTreeIterator());
      commitId=AbbreviatedObjectId.fromObjectId(zeroId());
    }
    tw.setRecursive(true);
    headCommit=null;
    MutableObjectId idBuf=new MutableObjectId();
    Map<String,Change> result=new HashMap<String,Change>();
    while (tw.next()) {
      if (!shouldIncludeEntry(tw))       continue;
      Change change=new Change();
      change.name=tw.getNameString();
      change.remoteCommitId=commitId;
      tw.getObjectId(idBuf,0);
      change.objectId=AbbreviatedObjectId.fromObjectId(idBuf);
      tw.getObjectId(idBuf,1);
      change.remoteObjectId=AbbreviatedObjectId.fromObjectId(idBuf);
      calculateAndSetChangeKind(RIGHT,change);
      result.put(tw.getPathString(),change);
    }
    return result;
  }
 catch (  IOException e) {
    Activator.error(e.getMessage(),e);
    return new HashMap<String,Change>(0);
  }
}","/** 
 * @param repo repository which should be scanned
 * @return list of changes in git staging area
 */
public static Map<String,Change> build(Repository repo){
  try (TreeWalk tw=new TreeWalk(repo)){
    tw.addTree(new DirCacheIterator(repo.readDirCache()));
    ObjectId headId=repo.resolve(HEAD);
    RevCommit headCommit=null;
    if (headId != null) {
      try (RevWalk rw=new RevWalk(repo)){
        headCommit=rw.parseCommit(headId);
      }
     }
    AbbreviatedObjectId commitId;
    if (headCommit != null) {
      tw.addTree(headCommit.getTree());
      commitId=AbbreviatedObjectId.fromObjectId(headCommit);
    }
 else {
      tw.addTree(new EmptyTreeIterator());
      commitId=AbbreviatedObjectId.fromObjectId(zeroId());
    }
    tw.setRecursive(true);
    headCommit=null;
    MutableObjectId idBuf=new MutableObjectId();
    Map<String,Change> result=new HashMap<String,Change>();
    while (tw.next()) {
      if (!shouldIncludeEntry(tw))       continue;
      Change change=new Change();
      change.name=tw.getNameString();
      change.remoteCommitId=commitId;
      tw.getObjectId(idBuf,0);
      change.objectId=AbbreviatedObjectId.fromObjectId(idBuf);
      tw.getObjectId(idBuf,1);
      change.remoteObjectId=AbbreviatedObjectId.fromObjectId(idBuf);
      calculateAndSetChangeKind(RIGHT,change);
      result.put(tw.getPathString(),change);
    }
    return result;
  }
 catch (  IOException e) {
    Activator.logError(e.getMessage(),e);
    return new HashMap<String,Change>(0);
  }
}",0.99835255354201
91427,"/** 
 * @param repo with should be scanned
 * @return list of changes in working tree
 */
public static Map<String,Change> build(Repository repo){
  try (TreeWalk tw=new TreeWalk(repo)){
    int fileNth=tw.addTree(new FileTreeIterator(repo));
    int cacheNth=tw.addTree(new DirCacheIterator(repo.readDirCache()));
    tw.setFilter(new IndexDiffFilter(cacheNth,fileNth));
    tw.setRecursive(true);
    Map<String,Change> result=new HashMap<String,Change>();
    MutableObjectId idBuf=new MutableObjectId();
    while (tw.next()) {
      Change change=new Change();
      change.name=tw.getNameString();
      tw.getObjectId(idBuf,0);
      change.objectId=AbbreviatedObjectId.fromObjectId(idBuf);
      tw.getObjectId(idBuf,1);
      change.remoteObjectId=AbbreviatedObjectId.fromObjectId(idBuf);
      calculateAndSetChangeKind(RIGHT,change);
      result.put(tw.getPathString(),change);
    }
    return result;
  }
 catch (  IOException e) {
    Activator.error(e.getMessage(),e);
    return new HashMap<String,GitCommitsModelCache.Change>(0);
  }
}","/** 
 * @param repo with should be scanned
 * @return list of changes in working tree
 */
public static Map<String,Change> build(Repository repo){
  try (TreeWalk tw=new TreeWalk(repo)){
    int fileNth=tw.addTree(new FileTreeIterator(repo));
    int cacheNth=tw.addTree(new DirCacheIterator(repo.readDirCache()));
    tw.setFilter(new IndexDiffFilter(cacheNth,fileNth));
    tw.setRecursive(true);
    Map<String,Change> result=new HashMap<String,Change>();
    MutableObjectId idBuf=new MutableObjectId();
    while (tw.next()) {
      Change change=new Change();
      change.name=tw.getNameString();
      tw.getObjectId(idBuf,0);
      change.objectId=AbbreviatedObjectId.fromObjectId(idBuf);
      tw.getObjectId(idBuf,1);
      change.remoteObjectId=AbbreviatedObjectId.fromObjectId(idBuf);
      calculateAndSetChangeKind(RIGHT,change);
      result.put(tw.getPathString(),change);
    }
    return result;
  }
 catch (  IOException e) {
    Activator.logError(e.getMessage(),e);
    return new HashMap<String,GitCommitsModelCache.Change>(0);
  }
}",0.997629208155524
91428,"/** 
 * Get the status of whether the commit operation should be enabled or disabled. <p> This method checks the current state of the widgets and must always be called from the UI-thread. <p> The returned status includes a message and type denoting why committing cannot be completed.
 * @return non-null commit status
 */
public CommitStatus getStatus(){
  if (!commitAllowed)   return new CommitStatus(cannotCommitMessage,IMessageProvider.ERROR);
  String authorValue=authorText.getText();
  if (authorValue.length() == 0 || RawParseUtils.parsePersonIdent(authorValue) == null)   return new CommitStatus(UIText.CommitMessageComponent_MessageInvalidAuthor,IMessageProvider.ERROR);
  String committerValue=committerText.getText();
  if (committerValue.length() == 0 || RawParseUtils.parsePersonIdent(committerValue) == null) {
    return new CommitStatus(UIText.CommitMessageComponent_MessageInvalidCommitter,IMessageProvider.ERROR);
  }
  if (amending && amendingCommitInRemoteBranch)   return new CommitStatus(UIText.CommitMessageComponent_AmendingCommitInRemoteBranch,IMessageProvider.WARNING);
  if (org.eclipse.egit.ui.Activator.getDefault().getPreferenceStore().getBoolean(UIPreferences.COMMIT_DIALOG_WARN_ABOUT_MESSAGE_SECOND_LINE)) {
    String message=commitText.getCommitMessage();
    String formatIssue=formatIssuesInCommitMessage(message);
    if (formatIssue != null) {
      return new CommitStatus(formatIssue,IMessageProvider.WARNING);
    }
  }
  return CommitStatus.OK;
}","/** 
 * Get the status of whether the commit operation should be enabled or disabled. <p> This method checks the current state of the widgets and must always be called from the UI-thread. <p> The returned status includes a message and type denoting why committing cannot be completed.
 * @return non-null commit status
 */
public CommitStatus getStatus(){
  if (!commitAllowed)   return new CommitStatus(cannotCommitMessage,IMessageProvider.ERROR);
  String authorValue=authorText.getText();
  if (authorValue.length() == 0 || RawParseUtils.parsePersonIdent(authorValue) == null)   return new CommitStatus(UIText.CommitMessageComponent_MessageInvalidAuthor,IMessageProvider.ERROR);
  String committerValue=committerText.getText();
  if (committerValue.length() == 0 || RawParseUtils.parsePersonIdent(committerValue) == null) {
    return new CommitStatus(UIText.CommitMessageComponent_MessageInvalidCommitter,IMessageProvider.ERROR);
  }
  if (amending && amendingCommitInRemoteBranch)   return new CommitStatus(UIText.CommitMessageComponent_AmendingCommitInRemoteBranch,IMessageProvider.WARNING);
  if (Activator.getDefault().getPreferenceStore().getBoolean(UIPreferences.COMMIT_DIALOG_WARN_ABOUT_MESSAGE_SECOND_LINE)) {
    String message=commitText.getCommitMessage();
    String formatIssue=formatIssuesInCommitMessage(message);
    if (formatIssue != null) {
      return new CommitStatus(formatIssue,IMessageProvider.WARNING);
    }
  }
  return CommitStatus.OK;
}",0.9932432432432432
91429,"/** 
 * @param paths
 * @return the calculated commit message
 */
private String calculateCommitMessage(Collection<String> paths){
  if (commitMessage != null) {
    return commitMessage;
  }
  if (amending)   return previousCommitMessage;
  String calculatedCommitMessage=null;
  Set<IResource> resources=new HashSet<IResource>();
  for (  String path : paths) {
    IFile file=findFile(path);
    if (file != null)     resources.add(file.getProject());
  }
  try {
    ICommitMessageProvider messageProvider=getCommitMessageProvider();
    if (messageProvider != null) {
      IResource[] resourcesArray=resources.toArray(new IResource[0]);
      calculatedCommitMessage=messageProvider.getMessage(resourcesArray);
    }
  }
 catch (  CoreException coreException) {
    Activator.error(coreException.getLocalizedMessage(),coreException);
  }
  if (calculatedCommitMessage != null)   return calculatedCommitMessage;
 else   return EMPTY_STRING;
}","/** 
 * @param paths
 * @return the calculated commit message
 */
private String calculateCommitMessage(Collection<String> paths){
  if (commitMessage != null) {
    return commitMessage;
  }
  if (amending)   return previousCommitMessage;
  String calculatedCommitMessage=null;
  Set<IResource> resources=new HashSet<IResource>();
  for (  String path : paths) {
    IFile file=findFile(path);
    if (file != null)     resources.add(file.getProject());
  }
  try {
    ICommitMessageProvider messageProvider=getCommitMessageProvider();
    if (messageProvider != null) {
      IResource[] resourcesArray=resources.toArray(new IResource[0]);
      calculatedCommitMessage=messageProvider.getMessage(resourcesArray);
    }
  }
 catch (  CoreException coreException) {
    Activator.logError(coreException.getLocalizedMessage(),coreException);
  }
  if (calculatedCommitMessage != null)   return calculatedCommitMessage;
 else   return EMPTY_STRING;
}",0.9973642593568792
91430,"/** 
 * Sets the defaults for change id and signed off
 */
public void setDefaults(){
  if (repository != null)   createChangeId=GerritUtil.getCreateChangeId(repository.getConfig());
  signedOff=org.eclipse.egit.ui.Activator.getDefault().getPreferenceStore().getBoolean(UIPreferences.COMMIT_DIALOG_SIGNED_OFF_BY);
}","/** 
 * Sets the defaults for change id and signed off
 */
public void setDefaults(){
  if (repository != null)   createChangeId=GerritUtil.getCreateChangeId(repository.getConfig());
  signedOff=Activator.getDefault().getPreferenceStore().getBoolean(UIPreferences.COMMIT_DIALOG_SIGNED_OFF_BY);
}",0.9672131147540984
91431,"/** 
 * Tests that a   {@link RepositoryMapping} internally uses a relative path ifat all possible.
 */
@Test public void shouldResolveAsRelativePath(){
  IProject proj=project.getProject();
  IPath projectPath=proj.getLocation().removeTrailingSeparator();
  String gitHereTest=""String_Node_Str"";
  String gitTest=""String_Node_Str"";
  String gitSubdirTest=""String_Node_Str"";
  String gitSubmoduleTest=""String_Node_Str"";
  String gitAbsolute=projectPath.uptoSegment(0).append(projectPath.segment(0) + ""String_Node_Str"").append(""String_Node_Str"").toOSString();
  String parents=""String_Node_Str"";
  while (projectPath.segmentCount() > 2) {
    String pathString=projectPath.toOSString();
    assertRepoMappingPath(proj,pathString,gitHereTest,parents);
    assertRepoMappingPath(proj,pathString,gitTest,parents);
    assertRepoMappingPath(proj,pathString,gitSubdirTest,parents);
    assertRepoMappingPath(proj,pathString,gitSubmoduleTest,parents);
    assertRepoMappingPath(proj,pathString,gitAbsolute,""String_Node_Str"");
    projectPath=projectPath.removeLastSegments(1);
    parents+=""String_Node_Str"";
  }
}","/** 
 * Tests that a   {@link RepositoryMapping} internally uses a relative path ifat all possible.
 */
@Test public void shouldResolveAsRelativePath(){
  IProject proj=project.getProject();
  IPath projectPath=proj.getLocation().removeTrailingSeparator();
  String gitHereTest=""String_Node_Str"";
  String gitTest=""String_Node_Str"";
  String gitSubdirTest=""String_Node_Str"";
  String gitSubmoduleTest=""String_Node_Str"";
  String gitAbsolute=projectPath.uptoSegment(0).append(projectPath.segment(0) + ""String_Node_Str"").append(""String_Node_Str"").toPortableString();
  String parents=""String_Node_Str"";
  while (projectPath.segmentCount() > 2) {
    String pathString=projectPath.toOSString();
    assertRepoMappingPath(proj,pathString,gitHereTest,parents);
    assertRepoMappingPath(proj,pathString,gitTest,parents);
    assertRepoMappingPath(proj,pathString,gitSubdirTest,parents);
    assertRepoMappingPath(proj,pathString,gitSubmoduleTest,parents);
    assertRepoMappingPath(proj,pathString,gitAbsolute,""String_Node_Str"");
    projectPath=projectPath.removeLastSegments(1);
    parents+=""String_Node_Str"";
  }
}",0.9954954954954957
91432,"private void assertRepoMappingPath(IProject testProject,String path,String testDir,String parents){
  String testDirOS=testDir.replace('/',File.separatorChar);
  File testFile=new File(testDirOS);
  if (!testFile.isAbsolute()) {
    testFile=new File(new File(path),testDirOS);
  }
  RepositoryMapping mapping=RepositoryMapping.create(testProject,testFile);
  assertEquals(parents + testDir,mapping.getGitDirPath().toPortableString());
}","private void assertRepoMappingPath(IProject testProject,String pathOS,String testDirPortable,String parentsPortable){
  String testDirOS=testDirPortable.replace('/',File.separatorChar);
  File testFile=new File(testDirOS);
  if (!testFile.isAbsolute()) {
    testFile=new File(new File(pathOS),testDirOS);
  }
  RepositoryMapping mapping=RepositoryMapping.create(testProject,testFile);
  assertEquals(parentsPortable + testDirPortable,mapping.getGitDirPath().toPortableString());
}",0.8867102396514162
91433,"@Override protected void createFieldEditors(){
  String[][] values=new String[DATA.size()][2];
  int i=0;
  for (  Map.Entry<GitDateFormatter.Format,FormatInfo> entry : DATA.entrySet()) {
    values[i][0]=entry.getValue().name;
    values[i][1]=entry.getKey() == null ? UIPreferences.DATE_FORMAT_CUSTOM : entry.getKey().name();
    i++;
  }
  final Composite pane=getFieldEditorParent();
  formatChooser=new ComboFieldEditor(UIPreferences.DATE_FORMAT_CHOICE,UIText.DateFormatPreferencePage_formatChooser_label,values,pane);
  addField(formatChooser);
  dateFormat=new StringFieldEditor(UIPreferences.DATE_FORMAT,UIText.DateFormatPreferencePage_formatInput_label,StringFieldEditor.UNLIMITED,StringFieldEditor.VALIDATE_ON_KEY_STROKE,pane){
    @Override protected boolean doCheckState(){
      if (!getTextControl(pane).isEnabled()) {
        return true;
      }
      try {
        updatePreview(new SimpleDateFormat(getStringValue().trim()));
        return true;
      }
 catch (      IllegalArgumentException e) {
        dateFormatPreview.setText(""String_Node_Str"");
        return false;
      }
    }
    @Override protected void doLoad(){
    }
    @Override protected void doStore(){
      if (getTextControl(pane).isEnabled() && doCheckState()) {
        super.doStore();
      }
    }
    @Override public void setStringValue(    String value){
      super.setStringValue(value);
      refreshValidState();
    }
  }
;
  dateFormat.setEmptyStringAllowed(false);
  dateFormat.setErrorMessage(UIText.DateFormatPreferencePage_invalidDateFormat_message);
  addField(dateFormat);
  Label dpLabel=SWTUtils.createLabel(pane,UIText.DateFormatPreferencePage_datePreview_label);
  dpLabel.setLayoutData(SWTUtils.createGridData(SWT.DEFAULT,SWT.DEFAULT,false,false));
  dateFormatPreview=SWTUtils.createLabel(pane,null,1);
  Label dummyLabel=SWTUtils.createLabel(pane,""String_Node_Str"");
  dummyLabel.setLayoutData(SWTUtils.createGridData(SWT.DEFAULT,SWT.DEFAULT,false,false));
  formatExplanation=new Label(pane,SWT.LEFT | SWT.WRAP);
  GridData layout=SWTUtils.createGridData(SWT.DEFAULT,SWT.DEFAULT,false,true);
  formatExplanation.setLayoutData(layout);
  lastCustomValue=getPreferenceStore().getString(UIPreferences.DATE_FORMAT);
  String initialValue=getPreferenceStore().getString(UIPreferences.DATE_FORMAT_CHOICE);
  GitDateFormatter.Format initialFormat=fromString(initialValue);
  FormatInfo info=DATA.get(initialFormat);
  dateFormat.setEnabled(initialFormat == null,pane);
  dateFormat.setStringValue(initialFormat == null ? lastCustomValue : info.format);
  formatExplanation.setText(info.explanation);
}","@Override protected void createFieldEditors(){
  String[][] values=new String[DATA.size()][2];
  int i=0;
  for (  Map.Entry<GitDateFormatter.Format,FormatInfo> entry : DATA.entrySet()) {
    values[i][0]=entry.getValue().name;
    values[i][1]=entry.getKey() == null ? UIPreferences.DATE_FORMAT_CUSTOM : entry.getKey().name();
    i++;
  }
  final Composite pane=getFieldEditorParent();
  formatChooser=new ComboFieldEditor(UIPreferences.DATE_FORMAT_CHOICE,UIText.DateFormatPreferencePage_formatChooser_label,values,pane);
  addField(formatChooser);
  dateFormat=new StringFieldEditor(UIPreferences.DATE_FORMAT,UIText.DateFormatPreferencePage_formatInput_label,StringFieldEditor.UNLIMITED,StringFieldEditor.VALIDATE_ON_KEY_STROKE,pane){
    @Override protected boolean doCheckState(){
      if (!getTextControl(pane).isEnabled()) {
        return true;
      }
      try {
        updatePreview(new SimpleDateFormat(getStringValue().trim()));
        return true;
      }
 catch (      IllegalArgumentException e) {
        dateFormatPreview.setText(""String_Node_Str"");
        return false;
      }
    }
    @Override protected void doLoad(){
    }
    @Override protected void doStore(){
      if (getTextControl(pane).isEnabled() && doCheckState()) {
        super.doStore();
      }
    }
    @Override public void setStringValue(    String value){
      super.setStringValue(value);
      refreshValidState();
    }
  }
;
  dateFormat.setEmptyStringAllowed(false);
  dateFormat.setErrorMessage(UIText.DateFormatPreferencePage_invalidDateFormat_message);
  addField(dateFormat);
  Label dpLabel=SWTUtils.createLabel(pane,UIText.DateFormatPreferencePage_datePreview_label);
  dpLabel.setLayoutData(SWTUtils.createGridData(SWT.DEFAULT,SWT.DEFAULT,false,false));
  dateFormatPreview=SWTUtils.createLabel(pane,null,1);
  Label dummyLabel=SWTUtils.createLabel(pane,""String_Node_Str"");
  dummyLabel.setLayoutData(SWTUtils.createGridData(SWT.DEFAULT,SWT.DEFAULT,false,false));
  formatExplanation=new Label(pane,SWT.LEFT | SWT.WRAP);
  GridData layout=SWTUtils.createGridData(SWT.DEFAULT,SWT.DEFAULT,false,true);
  formatExplanation.setLayoutData(layout);
  lastCustomValue=getPreferenceStore().getString(UIPreferences.DATE_FORMAT);
  String initialValue=getPreferenceStore().getString(UIPreferences.DATE_FORMAT_CHOICE);
  updateFields(initialValue);
}",0.942195367573011
91434,"/** 
 * Checks if the existing resource with given path can be automatically added to the .gitignore file.
 * @param path Path to be checked, file or directory must exist on the disk
 * @return true if the file or directory at given path exists, is insideknown git repository and does not match any existing ignore rule, false otherwise
 * @throws IOException
 * @since 4.1.0
 */
public static boolean canBeAutoIgnored(IPath path) throws IOException {
  Repository repository=Activator.getDefault().getRepositoryCache().getRepository(path);
  if (repository == null || repository.isBare()) {
    return false;
  }
  WorkingTreeIterator treeIterator=IteratorService.createInitialIterator(repository);
  if (treeIterator == null) {
    return false;
  }
  String repoRelativePath=path.makeRelativeTo(new Path(repository.getWorkTree().getAbsolutePath())).toString();
  if (repoRelativePath.length() == 0 || repoRelativePath.equals(path)) {
    return false;
  }
  try (TreeWalk walk=new TreeWalk(repository)){
    walk.addTree(treeIterator);
    walk.setFilter(PathFilter.create(repoRelativePath));
    while (walk.next()) {
      WorkingTreeIterator workingTreeIterator=walk.getTree(0,WorkingTreeIterator.class);
      if (walk.getPathString().equals(repoRelativePath)) {
        return !workingTreeIterator.isEntryIgnored();
      }
      if (workingTreeIterator.getEntryFileMode().equals(FileMode.TREE)) {
        walk.enterSubtree();
      }
    }
  }
   return false;
}","/** 
 * Checks if the existing resource with given path can be automatically added to the .gitignore file.
 * @param path Path to be checked, file or directory must exist on the disk
 * @return true if the file or directory at given path exists, is insideknown git repository and does not match any existing ignore rule, false otherwise
 * @throws IOException
 * @since 4.1.0
 */
public static boolean canBeAutoIgnored(IPath path) throws IOException {
  Repository repository=Activator.getDefault().getRepositoryCache().getRepository(path);
  if (repository == null || repository.isBare()) {
    return false;
  }
  WorkingTreeIterator treeIterator=IteratorService.createInitialIterator(repository);
  if (treeIterator == null) {
    return false;
  }
  String repoRelativePath=path.makeRelativeTo(new Path(repository.getWorkTree().getAbsolutePath())).toString();
  if (repoRelativePath.length() == 0 || repoRelativePath.equals(path.toString())) {
    return false;
  }
  try (TreeWalk walk=new TreeWalk(repository)){
    walk.addTree(treeIterator);
    walk.setFilter(PathFilter.create(repoRelativePath));
    while (walk.next()) {
      WorkingTreeIterator workingTreeIterator=walk.getTree(0,WorkingTreeIterator.class);
      if (walk.getPathString().equals(repoRelativePath)) {
        return !workingTreeIterator.isEntryIgnored();
      }
      if (workingTreeIterator.getEntryFileMode().equals(FileMode.TREE)) {
        walk.enterSubtree();
      }
    }
  }
   return false;
}",0.9962749746020996
91435,"private boolean isStaged(Repository repository,IPath location,boolean checkIndex){
  if (location == null || location.toFile().isDirectory() || repository.isBare()) {
    return false;
  }
  IPath workDir=new Path(repository.getWorkTree().getAbsolutePath());
  String resRelPath=location.makeRelativeTo(workDir).toString();
  if (resRelPath.length() == 0 || resRelPath.equals(location)) {
    return false;
  }
  if (!checkIndex) {
    return true;
  }
  try {
    FileTreeIterator fileTreeIterator=new FileTreeIterator(repository);
    IndexDiff indexDiff=new IndexDiff(repository,Constants.HEAD,fileTreeIterator);
    indexDiff.setFilter(PathFilterGroup.createFromStrings(Collections.singletonList(resRelPath)));
    indexDiff.diff();
    return indexDiff.getAdded().contains(resRelPath) || indexDiff.getChanged().contains(resRelPath) || indexDiff.getRemoved().contains(resRelPath);
  }
 catch (  IOException e) {
    Activator.error(NLS.bind(UIText.GitHistoryPage_errorLookingUpPath,location.toString()),e);
    return false;
  }
}","private boolean isStaged(Repository repository,IPath location,boolean checkIndex){
  if (location == null || location.toFile().isDirectory() || repository.isBare()) {
    return false;
  }
  IPath workDir=new Path(repository.getWorkTree().getAbsolutePath());
  String resRelPath=location.makeRelativeTo(workDir).toString();
  if (resRelPath.length() == 0 || resRelPath.equals(location.toString())) {
    return false;
  }
  if (!checkIndex) {
    return true;
  }
  try {
    FileTreeIterator fileTreeIterator=new FileTreeIterator(repository);
    IndexDiff indexDiff=new IndexDiff(repository,Constants.HEAD,fileTreeIterator);
    indexDiff.setFilter(PathFilterGroup.createFromStrings(Collections.singletonList(resRelPath)));
    indexDiff.diff();
    return indexDiff.getAdded().contains(resRelPath) || indexDiff.getChanged().contains(resRelPath) || indexDiff.getRemoved().contains(resRelPath);
  }
 catch (  IOException e) {
    Activator.error(NLS.bind(UIText.GitHistoryPage_errorLookingUpPath,location.toString()),e);
    return false;
  }
}",0.9947089947089948
91436,"@Override public void execute(IProgressMonitor monitor) throws CoreException {
  String branchName=repository.getConfig().getReleaseBranchName(versionName);
  try {
    if (releaseExists()) {
      throw new CoreException(error(format(CoreText.ReleaseStartOperation_releaseNameAlreadyExists,versionName)));
    }
    if (!repository.isDevelop()) {
      throw new CoreException(error(NLS.bind(CoreText.ReleaseStartOperation_notOn,repository.getConfig().getDevelop())));
    }
  }
 catch (  IOException e) {
    throw new CoreException(error(e.getMessage(),e));
  }
  RevCommit commit=repository.findCommit(startCommitSha1);
  if (commit == null) {
    throw new IllegalStateException(NLS.bind(CoreText.ReleaseStartOperation_unableToFindCommit,commit));
  }
  start(monitor,branchName,commit);
}","@Override public void execute(IProgressMonitor monitor) throws CoreException {
  String branchName=repository.getConfig().getReleaseBranchName(versionName);
  try {
    if (releaseExists()) {
      throw new CoreException(error(format(CoreText.ReleaseStartOperation_releaseNameAlreadyExists,versionName)));
    }
    if (!repository.isDevelop()) {
      throw new CoreException(error(NLS.bind(CoreText.ReleaseStartOperation_notOn,repository.getConfig().getDevelop())));
    }
  }
 catch (  IOException e) {
    throw new CoreException(error(e.getMessage(),e));
  }
  RevCommit commit=repository.findCommit(startCommitSha1);
  if (commit == null) {
    throw new IllegalStateException(NLS.bind(CoreText.ReleaseStartOperation_unableToFindCommit,startCommitSha1));
  }
  start(monitor,branchName,commit);
}",0.986850344395742
91437,"private String makeRepoRelative(Repository repository,IResource res){
  return stripWorkDir(repository.getWorkTree(),res.getLocation().toFile());
}","@Nullable private String makeRepoRelative(Repository repository,IResource res){
  if (repository.isBare()) {
    return null;
  }
  IPath location=res.getLocation();
  if (location == null) {
    return null;
  }
  return stripWorkDir(repository.getWorkTree(),location.toFile());
}",0.6074766355140186
91438,"/** 
 * Creates a decoratable resource mapping (used for e.g. working sets)
 * @param mapping the resource mapping to decorate
 * @throws IOException
 */
public DecoratableResourceMapping(ResourceMapping mapping) throws IOException {
  super(null);
  this.mapping=mapping;
  IProject[] projects=mapping.getProjects();
  if (projects == null || projects.length == 0)   return;
  Set<Repository> repositories=new HashSet<Repository>(projects.length);
  for (  IProject prj : projects) {
    RepositoryMapping repoMapping=RepositoryMapping.getMapping(prj);
    if (repoMapping == null)     continue;
    IndexDiffData diffData=GitLightweightDecorator.getIndexDiffDataOrNull(prj);
    if (diffData == null)     continue;
    tracked=true;
    Repository repository=repoMapping.getRepository();
    String repoRelative=makeRepoRelative(repository,prj) + ""String_Node_Str"";
    Set<String> modified=diffData.getModified();
    Set<String> conflicting=diffData.getConflicting();
    if (containsPrefix(modified,repoRelative))     dirty=true;
    if (containsPrefix(conflicting,repoRelative))     conflicts=true;
    repositories.add(repository);
  }
  if (repositories.size() == 1) {
    Repository repository=repositories.iterator().next();
    repositoryName=DecoratableResourceHelper.getRepositoryName(repository);
    branch=DecoratableResourceHelper.getShortBranch(repository);
    branchStatus=DecoratableResourceHelper.getBranchStatus(repository);
  }
 else   if (repositories.size() > 1) {
    Set<String> branches=new HashSet<String>(2);
    for (    Repository repository : repositories) {
      branches.add(DecoratableResourceHelper.getShortBranch(repository));
      if (branches.size() > 1)       break;
    }
    if (branches.size() == 1) {
      repositoryName=MULTIPLE;
      branch=branches.iterator().next();
    }
  }
}","/** 
 * Creates a decoratable resource mapping (used for e.g. working sets)
 * @param mapping the resource mapping to decorate
 * @throws IOException
 */
public DecoratableResourceMapping(ResourceMapping mapping) throws IOException {
  super(null);
  this.mapping=mapping;
  IProject[] projects=mapping.getProjects();
  if (projects == null || projects.length == 0)   return;
  Set<Repository> repositories=new HashSet<Repository>(projects.length);
  for (  IProject prj : projects) {
    RepositoryMapping repoMapping=RepositoryMapping.getMapping(prj);
    if (repoMapping == null)     continue;
    IndexDiffData diffData=GitLightweightDecorator.getIndexDiffDataOrNull(prj);
    if (diffData == null)     continue;
    tracked=true;
    Repository repository=repoMapping.getRepository();
    String repoRelative=makeRepoRelative(repository,prj);
    if (repoRelative == null) {
      continue;
    }
    repoRelative+=""String_Node_Str"";
    Set<String> modified=diffData.getModified();
    Set<String> conflicting=diffData.getConflicting();
    if (containsPrefix(modified,repoRelative))     dirty=true;
    if (containsPrefix(conflicting,repoRelative))     conflicts=true;
    repositories.add(repository);
  }
  if (repositories.size() == 1) {
    Repository repository=repositories.iterator().next();
    repositoryName=DecoratableResourceHelper.getRepositoryName(repository);
    branch=DecoratableResourceHelper.getShortBranch(repository);
    branchStatus=DecoratableResourceHelper.getBranchStatus(repository);
  }
 else   if (repositories.size() > 1) {
    Set<String> branches=new HashSet<String>(2);
    for (    Repository repository : repositories) {
      branches.add(DecoratableResourceHelper.getShortBranch(repository));
      if (branches.size() > 1)       break;
    }
    if (branches.size() == 1) {
      repositoryName=MULTIPLE;
      branch=branches.iterator().next();
    }
  }
}",0.9799196787148594
91439,"protected IResourceMappingMerger createMerger() throws CoreException {
  final ModelProvider provider=ModelProvider.getModelProviderDescriptor(SampleModelProvider.SAMPLE_PROVIDER_ID).getModelProvider();
  return (ResourceMappingMerger)Platform.getAdapterManager().getAdapter(provider,IResourceMappingMerger.class);
}","protected IResourceMappingMerger createMerger() throws CoreException {
  final ModelProvider provider=ModelProvider.getModelProviderDescriptor(SampleModelProvider.SAMPLE_PROVIDER_ID).getModelProvider();
  return Utils.getAdapter(provider,IResourceMappingMerger.class);
}",0.9044368600682594
91440,"private ResourceMapping getMappingAdapter(IResource resource){
  return (ResourceMapping)resource.getAdapter(ResourceMapping.class);
}","private ResourceMapping getMappingAdapter(IResource resource){
  return Utils.getAdapter(resource,ResourceMapping.class);
}",0.8560311284046692
91441,"private void assertProjectInWorkingSet(String workingSetName,String projectName){
  IWorkingSetManager workingSetManager=PlatformUI.getWorkbench().getWorkingSetManager();
  IWorkingSet workingSet=workingSetManager.getWorkingSet(workingSetName);
  IAdaptable[] elements=workingSet.getElements();
  assertEquals(""String_Node_Str"",1,elements.length);
  IProject project=(IProject)elements[0].getAdapter(IProject.class);
  assertEquals(""String_Node_Str"",projectName,project.getName());
}","private void assertProjectInWorkingSet(String workingSetName,String projectName){
  IWorkingSetManager workingSetManager=PlatformUI.getWorkbench().getWorkingSetManager();
  IWorkingSet workingSet=workingSetManager.getWorkingSet(workingSetName);
  IAdaptable[] elements=workingSet.getElements();
  assertEquals(""String_Node_Str"",1,elements.length);
  IProject project=Utils.getAdapter(elements[0],IProject.class);
  assertEquals(""String_Node_Str"",projectName,project.getName());
}",0.9584199584199584
91442,"/** 
 * Adapt object to given target class type
 * @param object
 * @param target
 * @param < V > type of target
 * @return adapted
 */
@SuppressWarnings(""String_Node_Str"") public static <V>V adapt(Object object,Class<V> target){
  if (object == null)   return null;
  if (target.isInstance(object))   return (V)object;
  if (object instanceof IAdaptable)   return (V)((IAdaptable)object).getAdapter(target);
  return null;
}","/** 
 * Adapt object to given target class type
 * @param object
 * @param target
 * @param < V > type of target
 * @return adapted
 */
@SuppressWarnings(""String_Node_Str"") public static <V>V adapt(Object object,Class<V> target){
  if (object == null)   return null;
  if (target.isInstance(object))   return (V)object;
  if (object instanceof IAdaptable)   return Utils.getAdapter(((IAdaptable)object),target);
  return null;
}",0.9613130128956624
91443,"private RevCommit getRevCommit(IFileRevision revision){
  if (revision instanceof CommitFileRevision)   return ((CommitFileRevision)revision).getRevCommit();
 else   if (revision instanceof IAdaptable) {
    final IResourceVariant variant=(IResourceVariant)((IAdaptable)revision).getAdapter(IResourceVariant.class);
    if (variant instanceof GitRemoteResource) {
      final RevCommit commit=((GitRemoteResource)variant).getCommitId();
      try {
        return walk.parseCommit(commit);
      }
 catch (      IOException e) {
        Activator.logError(NLS.bind(CoreText.GitFileHistory_invalidCommit,commit.getName(),resource.getName()),e);
      }
    }
  }
  return null;
}","private RevCommit getRevCommit(IFileRevision revision){
  if (revision instanceof CommitFileRevision)   return ((CommitFileRevision)revision).getRevCommit();
 else   if (revision instanceof IAdaptable) {
    final IResourceVariant variant=Utils.getAdapter(((IAdaptable)revision),IResourceVariant.class);
    if (variant instanceof GitRemoteResource) {
      final RevCommit commit=((GitRemoteResource)variant).getCommitId();
      try {
        return walk.parseCommit(commit);
      }
 catch (      IOException e) {
        Activator.logError(NLS.bind(CoreText.GitFileHistory_invalidCommit,commit.getName(),resource.getName()),e);
      }
    }
  }
  return null;
}",0.9642857142857144
91444,"private String getGitPath(IFileRevision revision){
  if (revision instanceof CommitFileRevision)   return ((CommitFileRevision)revision).getGitPath();
 else   if (revision instanceof IAdaptable) {
    final IResourceVariant variant=(IResourceVariant)((IAdaptable)revision).getAdapter(IResourceVariant.class);
    if (variant instanceof GitRemoteResource)     return ((GitRemoteResource)variant).getPath();
  }
  return null;
}","private String getGitPath(IFileRevision revision){
  if (revision instanceof CommitFileRevision)   return ((CommitFileRevision)revision).getGitPath();
 else   if (revision instanceof IAdaptable) {
    final IResourceVariant variant=Utils.getAdapter(((IAdaptable)revision),IResourceVariant.class);
    if (variant instanceof GitRemoteResource)     return ((GitRemoteResource)variant).getPath();
  }
  return null;
}",0.6333333333333333
91445,"private void map(final RepositoryMapping m){
  final IResource r;
  final File git;
  final IResource dotGit;
  IContainer c=null;
  m.clear();
  r=getProject().findMember(m.getContainerPath());
  if (r instanceof IContainer) {
    c=(IContainer)r;
  }
 else   if (r != null) {
    c=(IContainer)r.getAdapter(IContainer.class);
  }
  if (c == null) {
    logAndUnmapGoneMappedResource(m);
    return;
  }
  m.setContainer(c);
  git=m.getGitDirAbsolutePath().toFile();
  if (!git.isDirectory() || !new File(git,""String_Node_Str"").isFile()) {
    logAndUnmapGoneMappedResource(m);
    return;
  }
  try {
    m.setRepository(Activator.getDefault().getRepositoryCache().lookupRepository(git));
  }
 catch (  IOException ioe) {
    logAndUnmapGoneMappedResource(m);
    return;
  }
  m.fireRepositoryChanged();
  trace(""String_Node_Str"" + c + ""String_Node_Str""+ m.getRepository());
  try {
    c.setSessionProperty(MAPPING_KEY,m);
  }
 catch (  CoreException err) {
    Activator.logError(CoreText.GitProjectData_failedToCacheRepoMapping,err);
  }
  dotGit=c.findMember(Constants.DOT_GIT);
  if (dotGit != null && dotGit.getLocation().toFile().equals(git)) {
    protect(dotGit);
  }
}","private void map(final RepositoryMapping m){
  final IResource r;
  final File git;
  final IResource dotGit;
  IContainer c=null;
  m.clear();
  r=getProject().findMember(m.getContainerPath());
  if (r instanceof IContainer) {
    c=(IContainer)r;
  }
 else   if (r != null) {
    c=Utils.getAdapter(r,IContainer.class);
  }
  if (c == null) {
    logAndUnmapGoneMappedResource(m);
    return;
  }
  m.setContainer(c);
  git=m.getGitDirAbsolutePath().toFile();
  if (!git.isDirectory() || !new File(git,""String_Node_Str"").isFile()) {
    logAndUnmapGoneMappedResource(m);
    return;
  }
  try {
    m.setRepository(Activator.getDefault().getRepositoryCache().lookupRepository(git));
  }
 catch (  IOException ioe) {
    logAndUnmapGoneMappedResource(m);
    return;
  }
  m.fireRepositoryChanged();
  trace(""String_Node_Str"" + c + ""String_Node_Str""+ m.getRepository());
  try {
    c.setSessionProperty(MAPPING_KEY,m);
  }
 catch (  CoreException err) {
    Activator.logError(CoreText.GitProjectData_failedToCacheRepoMapping,err);
  }
  dotGit=c.findMember(Constants.DOT_GIT);
  if (dotGit != null && dotGit.getLocation().toFile().equals(git)) {
    protect(dotGit);
  }
}",0.9915110356536504
91446,"/** 
 * Look up best active binding's keystroke for the given command
 * @param commandId The identifier of the command for which the best active binding's keystroke should be retrieved; must not be null.
 * @return {@code KeyStroke} for the best active binding for the specifiedcommandId or  {@code null} if no binding is defined or if thebinding service returns a  {@code TriggerSequence} containing morethan one  {@code Trigger}.
 */
public static KeyStroke getKeystrokeOfBestActiveBindingFor(String commandId){
  IBindingService bindingService=(IBindingService)PlatformUI.getWorkbench().getAdapter(IBindingService.class);
  TriggerSequence ts=bindingService.getBestActiveBindingFor(commandId);
  if (ts == null)   return null;
  Trigger[] triggers=ts.getTriggers();
  if (triggers.length == 1 && triggers[0] instanceof KeyStroke)   return (KeyStroke)triggers[0];
 else   return null;
}","/** 
 * Look up best active binding's keystroke for the given command
 * @param commandId The identifier of the command for which the best active binding's keystroke should be retrieved; must not be null.
 * @return {@code KeyStroke} for the best active binding for the specifiedcommandId or  {@code null} if no binding is defined or if thebinding service returns a  {@code TriggerSequence} containing morethan one  {@code Trigger}.
 */
public static KeyStroke getKeystrokeOfBestActiveBindingFor(String commandId){
  IBindingService bindingService=CommonUtils.getAdapter(PlatformUI.getWorkbench(),IBindingService.class);
  TriggerSequence ts=bindingService.getBestActiveBindingFor(commandId);
  if (ts == null)   return null;
  Trigger[] triggers=ts.getTriggers();
  if (triggers.length == 1 && triggers[0] instanceof KeyStroke)   return (KeyStroke)triggers[0];
 else   return null;
}",0.9712351945854484
91447,"private static String getShowInMenuLabel(){
  IBindingService bindingService=(IBindingService)PlatformUI.getWorkbench().getAdapter(IBindingService.class);
  if (bindingService != null) {
    String keyBinding=bindingService.getBestActiveBindingFormattedFor(IWorkbenchCommandConstants.NAVIGATE_SHOW_IN_QUICK_MENU);
    if (keyBinding != null)     return UIText.UIUtils_ShowInMenuLabel + '\t' + keyBinding;
  }
  return UIText.UIUtils_ShowInMenuLabel;
}","private static String getShowInMenuLabel(){
  IBindingService bindingService=CommonUtils.getAdapter(PlatformUI.getWorkbench(),IBindingService.class);
  if (bindingService != null) {
    String keyBinding=bindingService.getBestActiveBindingFormattedFor(IWorkbenchCommandConstants.NAVIGATE_SHOW_IN_QUICK_MENU);
    if (keyBinding != null)     return UIText.UIUtils_ShowInMenuLabel + '\t' + keyBinding;
  }
  return UIText.UIUtils_ShowInMenuLabel;
}",0.9409141583054628
91448,"/** 
 * @param element
 * @param adapterType
 * @return the adapted element, or null
 */
public static <T>T getAdapter(Object element,Class<T> adapterType){
  if (adapterType.isInstance(element)) {
    return adapterType.cast(element);
  }
  if (element instanceof IAdaptable) {
    Object adapted=((IAdaptable)element).getAdapter(adapterType);
    if (adapterType.isInstance(adapted)) {
      return adapterType.cast(adapted);
    }
  }
  Object adapted=Platform.getAdapterManager().getAdapter(element,adapterType);
  if (adapterType.isInstance(adapted)) {
    return adapterType.cast(adapted);
  }
  return null;
}","/** 
 * Returns the adapter corresponding to the given adapter class. <p> Workaround for ""Unnecessary cast"" errors, see bug 460685. Can be removed when EGit depends on Eclipse 4.5 or higher.
 * @param adaptable the adaptable
 * @param adapterClass the adapter class to look up
 * @return a object of the given class, or <code>null</code> if this objectdoes not have an adapter for the given class
 */
@SuppressWarnings(""String_Node_Str"") public static <T>T getAdapter(IAdaptable adaptable,Class<T> adapterClass){
  Object adapter=adaptable.getAdapter(adapterClass);
  return (T)adapter;
}",0.1461794019933555
91449,"/** 
 * @param element
 * @param adapterType
 * @param load
 * @return the adapted element, or null
 */
private static Object getAdapter(Object element,Class adapterType,boolean load){
  if (adapterType.isInstance(element))   return element;
  if (element instanceof IAdaptable) {
    Object adapted=((IAdaptable)element).getAdapter(adapterType);
    if (adapterType.isInstance(adapted))     return adapted;
  }
  if (load) {
    Object adapted=Platform.getAdapterManager().loadAdapter(element,adapterType.getName());
    if (adapterType.isInstance(adapted))     return adapted;
  }
 else {
    Object adapted=Platform.getAdapterManager().getAdapter(element,adapterType);
    if (adapterType.isInstance(adapted))     return adapted;
  }
  return null;
}","/** 
 * @param element
 * @param adapterType
 * @param load
 * @return the adapted element, or null
 */
private static Object getAdapter(Object element,Class adapterType,boolean load){
  if (adapterType.isInstance(element))   return element;
  if (element instanceof IAdaptable) {
    Object adapted=CommonUtils.getAdapter(((IAdaptable)element),adapterType);
    if (adapterType.isInstance(adapted))     return adapted;
  }
  if (load) {
    Object adapted=Platform.getAdapterManager().loadAdapter(element,adapterType.getName());
    if (adapterType.isInstance(adapted))     return adapted;
  }
 else {
    Object adapted=Platform.getAdapterManager().getAdapter(element,adapterType);
    if (adapterType.isInstance(adapted))     return adapted;
  }
  return null;
}",0.9762845849802372
91450,"@Override public Image getImage(Object element){
  if (element instanceof Repository)   return RepositoryTreeNodeType.REPO.getIcon();
  if (element instanceof RefNode)   return getRefIcon(((RefNode)element).getObject());
  if (element instanceof Ref)   return getRefIcon((Ref)element);
  if (element instanceof GitModelBlob || element instanceof GitModelTree) {
    Object adapter=((IAdaptable)element).getAdapter(IResource.class);
    return getWorkbenchLabelProvider().getImage(adapter);
  }
  if (element instanceof GitModelCommit || element instanceof GitModelCache || element instanceof GitModelWorkingTree|| element instanceof RepositoryCommit)   return getChangesetIcon();
  if (element instanceof GitModelRepository)   return getImage(((GitModelRepository)element).getRepository());
  if (element instanceof ProjectRecord)   return PlatformUI.getWorkbench().getSharedImages().getImage(SharedImages.IMG_OBJ_PROJECT);
  return super.getImage(element);
}","@Override public Image getImage(Object element){
  if (element instanceof Repository)   return RepositoryTreeNodeType.REPO.getIcon();
  if (element instanceof RefNode)   return getRefIcon(((RefNode)element).getObject());
  if (element instanceof Ref)   return getRefIcon((Ref)element);
  if (element instanceof GitModelBlob || element instanceof GitModelTree) {
    Object adapter=CommonUtils.getAdapter(((IAdaptable)element),IResource.class);
    return getWorkbenchLabelProvider().getImage(adapter);
  }
  if (element instanceof GitModelCommit || element instanceof GitModelCache || element instanceof GitModelWorkingTree|| element instanceof RepositoryCommit)   return getChangesetIcon();
  if (element instanceof GitModelRepository)   return getImage(((GitModelRepository)element).getRepository());
  if (element instanceof ProjectRecord)   return PlatformUI.getWorkbench().getSharedImages().getImage(SharedImages.IMG_OBJ_PROJECT);
  return super.getImage(element);
}",0.978238341968912
91451,"private boolean isTextFileBufferInWorkDir(Saveable saveable){
  IDocument document=(IDocument)saveable.getAdapter(IDocument.class);
  if (document == null)   return true;
  ITextFileBuffer textFileBuffer=FileBuffers.getTextFileBufferManager().getTextFileBuffer(document);
  if (textFileBuffer != null)   return isInWorkDir(textFileBuffer.getLocation());
  return false;
}","private boolean isTextFileBufferInWorkDir(Saveable saveable){
  IDocument document=CommonUtils.getAdapter(saveable,IDocument.class);
  if (document == null)   return true;
  ITextFileBuffer textFileBuffer=FileBuffers.getTextFileBufferManager().getTextFileBuffer(document);
  if (textFileBuffer != null)   return isInWorkDir(textFileBuffer.getLocation());
  return false;
}",0.9475100942126514
91452,"/** 
 * Get the currently selected repositories. All selected projects must map to a repository.
 * @return repositories for selection, or an empty array
 */
protected Repository[] getRepositories(){
  IProject[] selectedProjects=getProjectsForSelectedResources();
  if (selectedProjects.length > 0)   return getRepositoriesFor(selectedProjects);
  IStructuredSelection selection=getSelection();
  if (!selection.isEmpty()) {
    Set<Repository> repos=new LinkedHashSet<Repository>();
    for (    Object o : selection.toArray())     if (o instanceof Repository)     repos.add((Repository)o);
 else     if (o instanceof PlatformObject) {
      Repository repo=(Repository)((PlatformObject)o).getAdapter(Repository.class);
      if (repo != null)       repos.add(repo);
    }
    return repos.toArray(new Repository[repos.size()]);
  }
  return new Repository[0];
}","/** 
 * Get the currently selected repositories. All selected projects must map to a repository.
 * @return repositories for selection, or an empty array
 */
protected Repository[] getRepositories(){
  IProject[] selectedProjects=getProjectsForSelectedResources();
  if (selectedProjects.length > 0)   return getRepositoriesFor(selectedProjects);
  IStructuredSelection selection=getSelection();
  if (!selection.isEmpty()) {
    Set<Repository> repos=new LinkedHashSet<Repository>();
    for (    Object o : selection.toArray())     if (o instanceof Repository)     repos.add((Repository)o);
 else     if (o instanceof PlatformObject) {
      Repository repo=CommonUtils.getAdapter(((PlatformObject)o),Repository.class);
      if (repo != null)       repos.add(repo);
    }
    return repos.toArray(new Repository[repos.size()]);
  }
  return new Repository[0];
}",0.9722222222222222
91453,"private IResource getSelection(){
  ISelection sel=srv.getSelection();
  if (!(sel instanceof IStructuredSelection))   return null;
  Object selected=((IStructuredSelection)sel).getFirstElement();
  if (selected instanceof IAdaptable)   return (IResource)((IAdaptable)selected).getAdapter(IResource.class);
  if (selected instanceof IResource)   return (IResource)selected;
  return null;
}","private IResource getSelection(){
  ISelection sel=srv.getSelection();
  if (!(sel instanceof IStructuredSelection))   return null;
  Object selected=((IStructuredSelection)sel).getFirstElement();
  if (selected instanceof IAdaptable)   return CommonUtils.getAdapter(((IAdaptable)selected),IResource.class);
  if (selected instanceof IResource)   return (IResource)selected;
  return null;
}",0.9142125480153648
91454,"public static StagingViewTester openStagingView() throws Exception {
  Activator.getDefault().getPreferenceStore().setValue(UIPreferences.STAGING_VIEW_FILENAME_MODE,false);
  SWTBotView view=TestUtil.showView(StagingView.VIEW_ID);
  TestUtil.joinJobs(org.eclipse.egit.core.JobFamilies.INDEX_DIFF_CACHE_UPDATE);
  return new StagingViewTester(view);
}","public static StagingViewTester openStagingView() throws Exception {
  Activator.getDefault().getPreferenceStore().setValue(UIPreferences.STAGING_VIEW_FILENAME_MODE,false);
  SWTBotView view=TestUtil.showView(StagingView.VIEW_ID);
  TestUtil.joinJobs(org.eclipse.egit.core.JobFamilies.INDEX_DIFF_CACHE_UPDATE);
  TestUtil.processUIEvents();
  return new StagingViewTester(view);
}",0.958904109589041
91455,"public void stageFile(String path){
  SWTBotTree unstagedTree=stagingView.bot().tree(0);
  TestUtil.getNode(unstagedTree.getAllItems(),path).select();
  JobJoiner jobJoiner=JobJoiner.startListening(org.eclipse.egit.core.JobFamilies.INDEX_DIFF_CACHE_UPDATE,30,TimeUnit.SECONDS);
  ContextMenuHelper.clickContextMenu(unstagedTree,UIText.StagingView_StageItemMenuLabel);
  jobJoiner.join();
}","public void stageFile(String path){
  SWTBotTree unstagedTree=stagingView.bot().tree(0);
  TestUtil.waitUntilTreeHasNodeContainsText(stagingView.bot(),unstagedTree,path,10000);
  TestUtil.getNode(unstagedTree.getAllItems(),path).select();
  JobJoiner jobJoiner=JobJoiner.startListening(org.eclipse.egit.core.JobFamilies.INDEX_DIFF_CACHE_UPDATE,30,TimeUnit.SECONDS);
  ContextMenuHelper.clickContextMenu(unstagedTree,UIText.StagingView_StageItemMenuLabel);
  jobJoiner.join();
}",0.8983833718244804
91456,"public static SWTBotView showView(final String viewId){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      IWorkbenchWindow workbenchWindow=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
      IWorkbenchPage workbenchPage=workbenchWindow.getActivePage();
      try {
        workbenchPage.showView(viewId);
      }
 catch (      PartInitException e) {
        throw new RuntimeException(""String_Node_Str"" + viewId + ""String_Node_Str"",e);
      }
    }
  }
);
  SWTWorkbenchBot bot=new SWTWorkbenchBot();
  SWTBotView viewbot=bot.viewById(viewId);
  assertNotNull(""String_Node_Str"" + viewId + ""String_Node_Str"",viewbot);
  return viewbot;
}","public static SWTBotView showView(final String viewId){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      IWorkbenchWindow workbenchWindow=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
      IWorkbenchPage workbenchPage=workbenchWindow.getActivePage();
      try {
        workbenchPage.showView(viewId);
        processUIEvents();
      }
 catch (      PartInitException e) {
        throw new RuntimeException(""String_Node_Str"" + viewId + ""String_Node_Str"",e);
      }
    }
  }
);
  SWTWorkbenchBot bot=new SWTWorkbenchBot();
  SWTBotView viewbot=bot.viewById(viewId);
  assertNotNull(""String_Node_Str"" + viewId + ""String_Node_Str"",viewbot);
  return viewbot;
}",0.9803063457330417
91457,"protected static void setTestFileContent(String newContent) throws Exception {
  IProject prj=ResourcesPlugin.getWorkspace().getRoot().getProject(PROJ1);
  if (!prj.isAccessible())   throw new IllegalStateException(""String_Node_Str"");
  IFile file=prj.getFile(new Path(""String_Node_Str""));
  file.setContents(new ByteArrayInputStream(newContent.getBytes(prj.getDefaultCharset())),0,null);
}","protected static void setTestFileContent(String newContent) throws Exception {
  IProject prj=ResourcesPlugin.getWorkspace().getRoot().getProject(PROJ1);
  if (!prj.isAccessible())   throw new IllegalStateException(""String_Node_Str"");
  IFile file=prj.getFile(new Path(""String_Node_Str""));
  file.refreshLocal(0,null);
  file.setContents(new ByteArrayInputStream(newContent.getBytes(prj.getDefaultCharset())),0,null);
}",0.9641532756489494
91458,"public void run(){
  if (text.isDisposed())   return;
  setDocument(new Document(job.getFormatResult().getCommitInfo()));
  List<StyleRange> styleRangeList=new ArrayList<StyleRange>();
  for (  StyleRange styleRange : job.getFormatResult().getStyleRange())   styleRangeList.add(styleRange);
  StyleRange[] hyperlinkDetectorStyleRanges=UIUtils.getHyperlinkDetectorStyleRanges(CommitMessageViewer.this,fHyperlinkDetectors);
  for (  StyleRange styleRange : hyperlinkDetectorStyleRanges)   styleRangeList.add(styleRange);
  StyleRange[] styleRanges=new StyleRange[styleRangeList.size()];
  styleRangeList.toArray(styleRanges);
  Arrays.sort(styleRanges,new Comparator<StyleRange>(){
    public int compare(    StyleRange o1,    StyleRange o2){
      if (o2.start > o1.start)       return -1;
      if (o1.start > o2.start)       return 1;
      return 0;
    }
  }
);
  text.setStyleRanges(styleRanges);
}","public void run(){
  applyFormatJobResultInUI(job.getFormatResult());
}",0.1048304213771839
91459,"void addDoneListenerToFormatJob(){
  formatJob.addJobChangeListener(new JobChangeAdapter(){
    public void done(    IJobChangeEvent event){
      if (!event.getResult().isOK())       return;
      final StyledText text=getTextWidget();
      if (text == null || text.isDisposed())       return;
      final FormatJob job=(FormatJob)event.getJob();
      text.getDisplay().asyncExec(new Runnable(){
        public void run(){
          if (text.isDisposed())           return;
          setDocument(new Document(job.getFormatResult().getCommitInfo()));
          List<StyleRange> styleRangeList=new ArrayList<StyleRange>();
          for (          StyleRange styleRange : job.getFormatResult().getStyleRange())           styleRangeList.add(styleRange);
          StyleRange[] hyperlinkDetectorStyleRanges=UIUtils.getHyperlinkDetectorStyleRanges(CommitMessageViewer.this,fHyperlinkDetectors);
          for (          StyleRange styleRange : hyperlinkDetectorStyleRanges)           styleRangeList.add(styleRange);
          StyleRange[] styleRanges=new StyleRange[styleRangeList.size()];
          styleRangeList.toArray(styleRanges);
          Arrays.sort(styleRanges,new Comparator<StyleRange>(){
            public int compare(            StyleRange o1,            StyleRange o2){
              if (o2.start > o1.start)               return -1;
              if (o1.start > o2.start)               return 1;
              return 0;
            }
          }
);
          text.setStyleRanges(styleRanges);
        }
      }
);
    }
  }
);
}","void addDoneListenerToFormatJob(){
  formatJob.addJobChangeListener(new JobChangeAdapter(){
    public void done(    IJobChangeEvent event){
      if (!event.getResult().isOK())       return;
      final StyledText text=getTextWidget();
      if (text == null || text.isDisposed())       return;
      final FormatJob job=(FormatJob)event.getJob();
      text.getDisplay().asyncExec(new Runnable(){
        public void run(){
          applyFormatJobResultInUI(job.getFormatResult());
        }
      }
);
    }
  }
);
}",0.4682501211827435
91460,"public void done(IJobChangeEvent event){
  if (!event.getResult().isOK())   return;
  final StyledText text=getTextWidget();
  if (text == null || text.isDisposed())   return;
  final FormatJob job=(FormatJob)event.getJob();
  text.getDisplay().asyncExec(new Runnable(){
    public void run(){
      if (text.isDisposed())       return;
      setDocument(new Document(job.getFormatResult().getCommitInfo()));
      List<StyleRange> styleRangeList=new ArrayList<StyleRange>();
      for (      StyleRange styleRange : job.getFormatResult().getStyleRange())       styleRangeList.add(styleRange);
      StyleRange[] hyperlinkDetectorStyleRanges=UIUtils.getHyperlinkDetectorStyleRanges(CommitMessageViewer.this,fHyperlinkDetectors);
      for (      StyleRange styleRange : hyperlinkDetectorStyleRanges)       styleRangeList.add(styleRange);
      StyleRange[] styleRanges=new StyleRange[styleRangeList.size()];
      styleRangeList.toArray(styleRanges);
      Arrays.sort(styleRanges,new Comparator<StyleRange>(){
        public int compare(        StyleRange o1,        StyleRange o2){
          if (o2.start > o1.start)           return -1;
          if (o1.start > o2.start)           return 1;
          return 0;
        }
      }
);
      text.setStyleRanges(styleRanges);
    }
  }
);
}","public void done(IJobChangeEvent event){
  if (!event.getResult().isOK())   return;
  final StyledText text=getTextWidget();
  if (text == null || text.isDisposed())   return;
  final FormatJob job=(FormatJob)event.getJob();
  text.getDisplay().asyncExec(new Runnable(){
    public void run(){
      applyFormatJobResultInUI(job.getFormatResult());
    }
  }
);
}",0.3944343617664851
91461,"/** 
 * verifies that repository contains exactly the given files with the given content. Usage example:<br> <code> assertRepositoryContainsFiles(repository, ""foo/a.txt"", ""content of A"", ""foo/b.txt"", ""content of B"") </code>
 * @param repository
 * @param args
 * @throws Exception
 */
public void assertRepositoryContainsFilesWithContent(Repository repository,String... args) throws Exception {
  HashMap<String,String> expectedfiles=mkmap(args);
  TreeWalk treeWalk=new TreeWalk(repository);
  treeWalk.addTree(repository.resolve(""String_Node_Str""));
  treeWalk.setRecursive(true);
  while (treeWalk.next()) {
    String path=treeWalk.getPathString();
    assertTrue(expectedfiles.containsKey(path));
    ObjectId objectId=treeWalk.getObjectId(0);
    byte[] expectedContent=expectedfiles.get(path).getBytes(""String_Node_Str"");
    byte[] repoContent=treeWalk.getObjectReader().open(objectId).getBytes();
    if (!Arrays.equals(repoContent,expectedContent)) {
      fail(""String_Node_Str"" + path + ""String_Node_Str""+ new String(repoContent,""String_Node_Str"")+ ""String_Node_Str""+ new String(expectedContent));
    }
    expectedfiles.remove(path);
  }
  if (expectedfiles.size() > 0) {
    StringBuilder message=new StringBuilder(""String_Node_Str"");
    for (    String path : expectedfiles.keySet()) {
      message.append(path);
      message.append(""String_Node_Str"");
    }
    fail(message.toString());
  }
}","/** 
 * verifies that repository contains exactly the given files with the given content. Usage example:<br> <code> assertRepositoryContainsFiles(repository, ""foo/a.txt"", ""content of A"", ""foo/b.txt"", ""content of B"") </code>
 * @param repository
 * @param args
 * @throws Exception
 */
public void assertRepositoryContainsFilesWithContent(Repository repository,String... args) throws Exception {
  HashMap<String,String> expectedfiles=mkmap(args);
  TreeWalk treeWalk=new TreeWalk(repository);
  treeWalk.addTree(repository.resolve(""String_Node_Str""));
  treeWalk.setRecursive(true);
  while (treeWalk.next()) {
    String path=treeWalk.getPathString();
    assertTrue(expectedfiles.containsKey(path));
    ObjectId objectId=treeWalk.getObjectId(0);
    byte[] expectedContent=expectedfiles.get(path).getBytes(""String_Node_Str"");
    byte[] repoContent=treeWalk.getObjectReader().open(objectId).getBytes();
    if (!Arrays.equals(repoContent,expectedContent)) {
      fail(""String_Node_Str"" + path + ""String_Node_Str""+ new String(repoContent,""String_Node_Str"")+ ""String_Node_Str""+ new String(expectedContent,""String_Node_Str""));
    }
    expectedfiles.remove(path);
  }
  if (expectedfiles.size() > 0) {
    StringBuilder message=new StringBuilder(""String_Node_Str"");
    for (    String path : expectedfiles.keySet()) {
      message.append(path);
      message.append(""String_Node_Str"");
    }
    fail(message.toString());
  }
}",0.9936708860759492
91462,"/** 
 * Updates prefixes to workspace paths
 * @param sb
 * @param diffFmt
 */
public void updateWorkspacePatchPrefixes(StringBuilder sb,DiffFormatter diffFmt){
  RawText rt=new RawText(sb.toString().getBytes());
  final String oldPrefix=diffFmt.getOldPrefix();
  final String newPrefix=diffFmt.getNewPrefix();
  StringBuilder newSb=new StringBuilder();
  final Pattern diffPattern=Pattern.compile(""String_Node_Str"" + oldPrefix + ""String_Node_Str""+ newPrefix+ ""String_Node_Str"");
  final Pattern oldPattern=Pattern.compile(""String_Node_Str"" + oldPrefix + ""String_Node_Str"");
  final Pattern newPattern=Pattern.compile(""String_Node_Str"" + newPrefix + ""String_Node_Str"");
  int i=0;
  while (i < rt.size()) {
    String line=rt.getString(i);
    Matcher diffMatcher=diffPattern.matcher(line);
    Matcher oldMatcher=oldPattern.matcher(line);
    Matcher newMatcher=newPattern.matcher(line);
    if (diffMatcher.find()) {
      String group=diffMatcher.group(2);
      IProject project=getProject(group);
      IPath newPath=computeWorkspacePath(new Path(group),project);
      line=line.replaceAll(diffMatcher.group(1),newPath.toString());
      group=diffMatcher.group(4);
      newPath=computeWorkspacePath(new Path(group),project);
      line=line.replaceAll(diffMatcher.group(3),newPath.toString());
    }
 else     if (oldMatcher.find()) {
      String group=oldMatcher.group(2);
      IProject project=getProject(group);
      IPath newPath=computeWorkspacePath(new Path(group),project);
      line=line.replaceAll(oldMatcher.group(1),newPath.toString());
    }
 else     if (newMatcher.find()) {
      String group=newMatcher.group(2);
      IProject project=getProject(group);
      IPath newPath=computeWorkspacePath(new Path(group),project);
      line=line.replaceAll(newMatcher.group(1),newPath.toString());
    }
    newSb.append(line);
    i++;
    if (i < rt.size() || !rt.isMissingNewlineAtEnd())     newSb.append(rt.getLineDelimiter());
  }
  sb.setLength(0);
  sb.append(newSb);
}","/** 
 * Updates prefixes to workspace paths
 * @param sb
 * @param diffFmt
 */
public void updateWorkspacePatchPrefixes(StringBuilder sb,DiffFormatter diffFmt){
  RawText rt;
  try {
    rt=new RawText(sb.toString().getBytes(""String_Node_Str""));
  }
 catch (  UnsupportedEncodingException e) {
    throw new RuntimeException(e);
  }
  final String oldPrefix=diffFmt.getOldPrefix();
  final String newPrefix=diffFmt.getNewPrefix();
  StringBuilder newSb=new StringBuilder();
  final Pattern diffPattern=Pattern.compile(""String_Node_Str"" + oldPrefix + ""String_Node_Str""+ newPrefix+ ""String_Node_Str"");
  final Pattern oldPattern=Pattern.compile(""String_Node_Str"" + oldPrefix + ""String_Node_Str"");
  final Pattern newPattern=Pattern.compile(""String_Node_Str"" + newPrefix + ""String_Node_Str"");
  int i=0;
  while (i < rt.size()) {
    String line=rt.getString(i);
    Matcher diffMatcher=diffPattern.matcher(line);
    Matcher oldMatcher=oldPattern.matcher(line);
    Matcher newMatcher=newPattern.matcher(line);
    if (diffMatcher.find()) {
      String group=diffMatcher.group(2);
      IProject project=getProject(group);
      IPath newPath=computeWorkspacePath(new Path(group),project);
      line=line.replaceAll(diffMatcher.group(1),newPath.toString());
      group=diffMatcher.group(4);
      newPath=computeWorkspacePath(new Path(group),project);
      line=line.replaceAll(diffMatcher.group(3),newPath.toString());
    }
 else     if (oldMatcher.find()) {
      String group=oldMatcher.group(2);
      IProject project=getProject(group);
      IPath newPath=computeWorkspacePath(new Path(group),project);
      line=line.replaceAll(oldMatcher.group(1),newPath.toString());
    }
 else     if (newMatcher.find()) {
      String group=newMatcher.group(2);
      IProject project=getProject(group);
      IPath newPath=computeWorkspacePath(new Path(group),project);
      line=line.replaceAll(newMatcher.group(1),newPath.toString());
    }
    newSb.append(line);
    i++;
    if (i < rt.size() || !rt.isMissingNewlineAtEnd())     newSb.append(rt.getLineDelimiter());
  }
  sb.setLength(0);
  sb.append(newSb);
}",0.9693579766536964
91463,"private void updateGitIgnore(File gitIgnore,String entry) throws CoreException {
  try {
    String ignoreLine=entry;
    if (!gitIgnore.exists())     if (!gitIgnore.createNewFile()) {
      String error=NLS.bind(CoreText.IgnoreOperation_creatingFailed,gitIgnore.getAbsolutePath());
      throw new CoreException(Activator.error(error,null));
    }
 else     ignoreLine=getEntry(gitIgnore,ignoreLine);
    FileOutputStream os=new FileOutputStream(gitIgnore,true);
    try {
      os.write(ignoreLine.getBytes());
    }
  finally {
      os.close();
    }
  }
 catch (  IOException e) {
    String error=NLS.bind(CoreText.IgnoreOperation_updatingFailed,gitIgnore.getAbsolutePath());
    throw new CoreException(Activator.error(error,e));
  }
}","private void updateGitIgnore(File gitIgnore,String entry) throws CoreException {
  try {
    String ignoreLine=entry;
    if (!gitIgnore.exists())     if (!gitIgnore.createNewFile()) {
      String error=NLS.bind(CoreText.IgnoreOperation_creatingFailed,gitIgnore.getAbsolutePath());
      throw new CoreException(Activator.error(error,null));
    }
 else     ignoreLine=getEntry(gitIgnore,ignoreLine);
    FileOutputStream os=new FileOutputStream(gitIgnore,true);
    try {
      os.write(ignoreLine.getBytes(""String_Node_Str""));
    }
  finally {
      os.close();
    }
  }
 catch (  IOException e) {
    String error=NLS.bind(CoreText.IgnoreOperation_updatingFailed,gitIgnore.getAbsolutePath());
    throw new CoreException(Activator.error(error,e));
  }
}",0.988674217188541
91464,"/** 
 * verifies that repository contains exactly the given files with the given content. Usage example:<br> <code> assertRepositoryContainsFiles(repository, ""foo/a.txt"", ""content of A"", ""foo/b.txt"", ""content of B"") </code>
 * @param repository
 * @param args
 * @throws Exception
 */
public static void assertRepositoryContainsFilesWithContent(Repository repository,String... args) throws Exception {
  HashMap<String,String> expectedfiles=mkmap(args);
  TreeWalk treeWalk=new TreeWalk(repository);
  treeWalk.addTree(repository.resolve(""String_Node_Str""));
  treeWalk.setRecursive(true);
  while (treeWalk.next()) {
    String path=treeWalk.getPathString();
    assertTrue(expectedfiles.containsKey(path));
    ObjectId objectId=treeWalk.getObjectId(0);
    byte[] expectedContent=expectedfiles.get(path).getBytes(""String_Node_Str"");
    byte[] repoContent=treeWalk.getObjectReader().open(objectId).getBytes();
    if (!Arrays.equals(repoContent,expectedContent))     fail(""String_Node_Str"" + path + ""String_Node_Str""+ new String(repoContent,""String_Node_Str"")+ ""String_Node_Str""+ new String(expectedContent));
    expectedfiles.remove(path);
  }
  if (expectedfiles.size() > 0) {
    StringBuilder message=new StringBuilder(""String_Node_Str"");
    for (    String path : expectedfiles.keySet()) {
      message.append(path);
      message.append(""String_Node_Str"");
    }
    fail(message.toString());
  }
}","/** 
 * verifies that repository contains exactly the given files with the given content. Usage example:<br> <code> assertRepositoryContainsFiles(repository, ""foo/a.txt"", ""content of A"", ""foo/b.txt"", ""content of B"") </code>
 * @param repository
 * @param args
 * @throws Exception
 */
public static void assertRepositoryContainsFilesWithContent(Repository repository,String... args) throws Exception {
  HashMap<String,String> expectedfiles=mkmap(args);
  TreeWalk treeWalk=new TreeWalk(repository);
  treeWalk.addTree(repository.resolve(""String_Node_Str""));
  treeWalk.setRecursive(true);
  while (treeWalk.next()) {
    String path=treeWalk.getPathString();
    assertTrue(expectedfiles.containsKey(path));
    ObjectId objectId=treeWalk.getObjectId(0);
    byte[] expectedContent=expectedfiles.get(path).getBytes(""String_Node_Str"");
    byte[] repoContent=treeWalk.getObjectReader().open(objectId).getBytes();
    if (!Arrays.equals(repoContent,expectedContent))     fail(""String_Node_Str"" + path + ""String_Node_Str""+ new String(repoContent,""String_Node_Str"")+ ""String_Node_Str""+ new String(expectedContent,""String_Node_Str""));
    expectedfiles.remove(path);
  }
  if (expectedfiles.size() > 0) {
    StringBuilder message=new StringBuilder(""String_Node_Str"");
    for (    String path : expectedfiles.keySet()) {
      message.append(path);
      message.append(""String_Node_Str"");
    }
    fail(message.toString());
  }
}",0.9936575052854124
91465,"@Before public void setUp() throws Exception {
  IWorkspaceRoot root=ResourcesPlugin.getWorkspace().getRoot();
  FileUtils.mkdir(new File(root.getLocation().toFile(),""String_Node_Str""),true);
  gitDir=new File(new File(root.getLocation().toFile(),""String_Node_Str""),Constants.DOT_GIT);
  repository=FileRepositoryBuilder.create(gitDir);
  repository.create();
  project=root.getProject(TEST_PROJECT);
  project.create(null);
  project.open(null);
  IProjectDescription description=project.getDescription();
  description.setLocation(root.getLocation().append(TEST_PROJECT_LOC));
  project.move(description,IResource.FORCE,null);
  project2=root.getProject(TEST_PROJECT2);
  project2.create(null);
  project2.open(null);
  gitDir2=new File(project2.getLocation().toFile().getAbsoluteFile(),Constants.DOT_GIT);
  repository2=FileRepositoryBuilder.create(gitDir2);
  repository2.create();
  RepositoryMapping mapping=new RepositoryMapping(project,gitDir);
  RepositoryMapping mapping2=new RepositoryMapping(project2,gitDir2);
  GitProjectData projectData=new GitProjectData(project);
  GitProjectData projectData2=new GitProjectData(project2);
  projectData.setRepositoryMappings(Collections.singletonList(mapping));
  projectData.store();
  projectData2.setRepositoryMappings(Collections.singletonList(mapping2));
  projectData2.store();
  GitProjectData.add(project,projectData);
  GitProjectData.add(project2,projectData2);
  RepositoryProvider.map(project,GitProvider.class.getName());
  RepositoryProvider.map(project2,GitProvider.class.getName());
  File f=new File(repository.getWorkTree(),TEST_PROJECT + ""String_Node_Str"" + TEST_FILE);
  Writer fileWriter=new OutputStreamWriter(new FileOutputStream(f),""String_Node_Str"");
  fileWriter.write(""String_Node_Str"");
  fileWriter.close();
  FileWriter fileWriter2=new FileWriter(new File(repository2.getWorkTree(),TEST_FILE2));
  fileWriter2.write(""String_Node_Str"");
  fileWriter2.close();
  project.refreshLocal(IResource.DEPTH_INFINITE,null);
  project2.refreshLocal(IResource.DEPTH_INFINITE,null);
  git=new Git(repository);
  git.add().addFilepattern(""String_Node_Str"").call();
  git.commit().setMessage(""String_Node_Str"").call();
  git=new Git(repository2);
  git.add().addFilepattern(""String_Node_Str"").call();
  git.commit().setMessage(""String_Node_Str"").call();
  git.branchRename().setNewName(""String_Node_Str"").call();
}","@Before public void setUp() throws Exception {
  IWorkspaceRoot root=ResourcesPlugin.getWorkspace().getRoot();
  FileUtils.mkdir(new File(root.getLocation().toFile(),""String_Node_Str""),true);
  gitDir=new File(new File(root.getLocation().toFile(),""String_Node_Str""),Constants.DOT_GIT);
  repository=FileRepositoryBuilder.create(gitDir);
  repository.create();
  project=root.getProject(TEST_PROJECT);
  project.create(null);
  project.open(null);
  IProjectDescription description=project.getDescription();
  description.setLocation(root.getLocation().append(TEST_PROJECT_LOC));
  project.move(description,IResource.FORCE,null);
  project2=root.getProject(TEST_PROJECT2);
  project2.create(null);
  project2.open(null);
  gitDir2=new File(project2.getLocation().toFile().getAbsoluteFile(),Constants.DOT_GIT);
  repository2=FileRepositoryBuilder.create(gitDir2);
  repository2.create();
  RepositoryMapping mapping=new RepositoryMapping(project,gitDir);
  RepositoryMapping mapping2=new RepositoryMapping(project2,gitDir2);
  GitProjectData projectData=new GitProjectData(project);
  GitProjectData projectData2=new GitProjectData(project2);
  projectData.setRepositoryMappings(Collections.singletonList(mapping));
  projectData.store();
  projectData2.setRepositoryMappings(Collections.singletonList(mapping2));
  projectData2.store();
  GitProjectData.add(project,projectData);
  GitProjectData.add(project2,projectData2);
  RepositoryProvider.map(project,GitProvider.class.getName());
  RepositoryProvider.map(project2,GitProvider.class.getName());
  JGitTestUtil.write(new File(repository.getWorkTree(),TEST_PROJECT + ""String_Node_Str"" + TEST_FILE),""String_Node_Str"");
  JGitTestUtil.write(new File(repository2.getWorkTree(),TEST_FILE2),""String_Node_Str"");
  project.refreshLocal(IResource.DEPTH_INFINITE,null);
  project2.refreshLocal(IResource.DEPTH_INFINITE,null);
  git=new Git(repository);
  git.add().addFilepattern(""String_Node_Str"").call();
  git.commit().setMessage(""String_Node_Str"").call();
  git=new Git(repository2);
  git.add().addFilepattern(""String_Node_Str"").call();
  git.commit().setMessage(""String_Node_Str"").call();
  git.branchRename().setNewName(""String_Node_Str"").call();
}",0.946518227461253
91466,"private void writeToFile(final String fileName,String content) throws IOException {
  Writer output=new BufferedWriter(new FileWriter(fileName));
  try {
    output.write(content);
  }
  finally {
    output.close();
  }
}","private void writeToFile(final String fileName,String content) throws IOException {
  Writer output=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName),RawParseUtils.UTF8_CHARSET));
  try {
    output.write(content);
  }
  finally {
    output.close();
  }
}",0.8622754491017964
91467,"private void buildDiffs(final StringBuilder d,final List<StyleRange> styles,IProgressMonitor monitor,boolean trace) throws OperationCanceledException, IOException {
  final String[] currentEncoding=new String[1];
  if (trace)   GitTraceLocation.getTrace().traceEntry(GitTraceLocation.HISTORYVIEW.getLocation());
  if (commit.getParentCount() > 1) {
    d.append(UIText.CommitMessageViewer_CanNotRenderDiffMessage);
    return;
  }
  try {
    monitor.beginTask(UIText.CommitMessageViewer_BuildDiffListTaskName,currentDiffs.size());
    BufferedOutputStream bos=new SafeBufferedOutputStream(new ByteArrayOutputStream(){
      @Override public synchronized void write(      byte[] b,      int off,      int len){
        super.write(b,off,len);
        if (currentEncoding[0] == null)         d.append(toString());
 else         try {
          d.append(toString(currentEncoding[0]));
        }
 catch (        UnsupportedEncodingException e) {
          d.append(toString());
        }
        reset();
      }
    }
);
    final DiffFormatter diffFmt=new MessageViewerFormatter(bos,styles,d,hunkheaderColor,linesAddedColor,linesRemovedColor);
    for (    FileDiff currentDiff : currentDiffs) {
      if (monitor.isCanceled())       throw new OperationCanceledException();
      if (currentDiff.getBlobs().length == 2) {
        String path=currentDiff.getNewPath();
        monitor.setTaskName(NLS.bind(UIText.CommitMessageViewer_BuildDiffTaskName,path));
        currentEncoding[0]=CompareCoreUtils.getResourceEncoding(db,path);
        d.append(LF);
        int start=d.length();
        String pathLine=formatPathLine(path);
        int len=pathLine.length();
        d.append(pathLine).append(LF);
        styles.add(new StyleRange(start,len,darkGrey,null));
        currentDiff.outputDiff(d,db,diffFmt,true);
        diffFmt.flush();
      }
      monitor.worked(1);
    }
  }
  finally {
    monitor.done();
    if (trace)     GitTraceLocation.getTrace().traceExit(GitTraceLocation.HISTORYVIEW.getLocation());
  }
}","private void buildDiffs(final StringBuilder d,final List<StyleRange> styles,IProgressMonitor monitor,boolean trace) throws OperationCanceledException, IOException {
  final String[] currentEncoding=new String[1];
  if (trace)   GitTraceLocation.getTrace().traceEntry(GitTraceLocation.HISTORYVIEW.getLocation());
  if (commit.getParentCount() > 1) {
    d.append(UIText.CommitMessageViewer_CanNotRenderDiffMessage);
    return;
  }
  try {
    monitor.beginTask(UIText.CommitMessageViewer_BuildDiffListTaskName,currentDiffs.size());
    BufferedOutputStream bos=new SafeBufferedOutputStream(new ByteArrayOutputStream(){
      @Override public synchronized void write(      byte[] b,      int off,      int len){
        super.write(b,off,len);
        try {
          if (currentEncoding[0] == null)           d.append(toString(""String_Node_Str""));
 else           d.append(toString(currentEncoding[0]));
        }
 catch (        UnsupportedEncodingException e) {
          d.append(toString());
        }
        reset();
      }
    }
);
    final DiffFormatter diffFmt=new MessageViewerFormatter(bos,styles,d,hunkheaderColor,linesAddedColor,linesRemovedColor);
    for (    FileDiff currentDiff : currentDiffs) {
      if (monitor.isCanceled())       throw new OperationCanceledException();
      if (currentDiff.getBlobs().length == 2) {
        String path=currentDiff.getNewPath();
        monitor.setTaskName(NLS.bind(UIText.CommitMessageViewer_BuildDiffTaskName,path));
        currentEncoding[0]=CompareCoreUtils.getResourceEncoding(db,path);
        d.append(LF);
        int start=d.length();
        String pathLine=formatPathLine(path);
        int len=pathLine.length();
        d.append(pathLine).append(LF);
        styles.add(new StyleRange(start,len,darkGrey,null));
        currentDiff.outputDiff(d,db,diffFmt,true);
        diffFmt.flush();
      }
      monitor.worked(1);
    }
  }
  finally {
    monitor.done();
    if (trace)     GitTraceLocation.getTrace().traceExit(GitTraceLocation.HISTORYVIEW.getLocation());
  }
}",0.9830258302583026
91468,"@Override public synchronized void write(byte[] b,int off,int len){
  super.write(b,off,len);
  if (currentEncoding[0] == null)   d.append(toString());
 else   try {
    d.append(toString(currentEncoding[0]));
  }
 catch (  UnsupportedEncodingException e) {
    d.append(toString());
  }
  reset();
}","@Override public synchronized void write(byte[] b,int off,int len){
  super.write(b,off,len);
  try {
    if (currentEncoding[0] == null)     d.append(toString(""String_Node_Str""));
 else     d.append(toString(currentEncoding[0]));
  }
 catch (  UnsupportedEncodingException e) {
    d.append(toString());
  }
  reset();
}",0.9082125603864736
91469,"private void writeToFile(final File file,String content) throws IOException {
  Writer output=new BufferedWriter(new FileWriter(file));
  try {
    output.write(content);
  }
  finally {
    output.close();
  }
}","private void writeToFile(final File file,String content) throws IOException {
  Writer output=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file),RawParseUtils.UTF8_CHARSET));
  try {
    output.write(content);
  }
  finally {
    output.close();
  }
}",0.8482328482328483
91470,"/** 
 * {@inheritDoc} 
 */
@Override public boolean isDirty(){
  return fDirty || (sharedDocumentAdapter != null && sharedDocumentAdapter.hasBufferedContents());
}","/** 
 * {@inheritDoc} 
 */
@Override public synchronized boolean isDirty(){
  return fDirty || (sharedDocumentAdapter != null && sharedDocumentAdapter.hasBufferedContents());
}",0.9616519174041298
91471,"private void revalidateImpl(final RepositorySelection newRepoSelection){
  if (label.isDisposed() || !isCurrentPage())   return;
  final ListRemoteOperation listRemoteOp;
  try {
    final URIish uri=newRepoSelection.getURI();
    final Repository db=FileRepositoryBuilder.create(new File(""String_Node_Str""));
    int timeout=Activator.getDefault().getPreferenceStore().getInt(UIPreferences.REMOTE_CONNECTION_TIMEOUT);
    listRemoteOp=new ListRemoteOperation(db,uri,timeout);
    if (credentials != null)     listRemoteOp.setCredentialsProvider(new EGitCredentialsProvider(credentials.getUser(),credentials.getPassword()));
    getContainer().run(true,true,new IRunnableWithProgress(){
      public void run(      IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
        listRemoteOp.run(monitor);
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    Throwable why=e.getCause();
    transportError(why);
    if (showDetailedFailureDialog())     SourceBranchFailureDialog.show(getShell(),transportError);
    return;
  }
catch (  IOException e) {
    transportError(UIText.SourceBranchPage_cannotCreateTemp);
    return;
  }
catch (  InterruptedException e) {
    transportError(UIText.SourceBranchPage_remoteListingCancelled);
    return;
  }
  final Ref idHEAD=listRemoteOp.getRemoteRef(Constants.HEAD);
  head=null;
  boolean headIsMaster=false;
  final String masterBranchRef=Constants.R_HEADS + Constants.MASTER;
  for (  final Ref r : listRemoteOp.getRemoteRefs()) {
    final String n=r.getName();
    if (!n.startsWith(Constants.R_HEADS))     continue;
    availableRefs.add(r);
    if (idHEAD == null || headIsMaster)     continue;
    if (r.getObjectId().equals(idHEAD.getObjectId())) {
      headIsMaster=masterBranchRef.equals(r.getName());
      if (head == null || headIsMaster)       head=r;
    }
  }
  Collections.sort(availableRefs,new Comparator<Ref>(){
    public int compare(    final Ref o1,    final Ref o2){
      return o1.getName().compareTo(o2.getName());
    }
  }
);
  if (idHEAD != null && head == null) {
    head=idHEAD;
    availableRefs.add(0,idHEAD);
  }
  validatedRepoSelection=newRepoSelection;
  refsViewer.setInput(availableRefs);
  refsViewer.setAllChecked(true);
  checkPage();
  checkForEmptyRepo();
}","private void revalidateImpl(final RepositorySelection newRepoSelection){
  if (label.isDisposed() || !isCurrentPage())   return;
  final ListRemoteOperation listRemoteOp;
  final URIish uri=newRepoSelection.getURI();
  try {
    final Repository db=FileRepositoryBuilder.create(new File(""String_Node_Str""));
    int timeout=Activator.getDefault().getPreferenceStore().getInt(UIPreferences.REMOTE_CONNECTION_TIMEOUT);
    listRemoteOp=new ListRemoteOperation(db,uri,timeout);
    if (credentials != null)     listRemoteOp.setCredentialsProvider(new EGitCredentialsProvider(credentials.getUser(),credentials.getPassword()));
    getContainer().run(true,true,new IRunnableWithProgress(){
      public void run(      IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
        listRemoteOp.run(monitor);
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    Throwable why=e.getCause();
    transportError(why);
    if (showDetailedFailureDialog())     SourceBranchFailureDialog.show(getShell(),uri);
    return;
  }
catch (  IOException e) {
    transportError(UIText.SourceBranchPage_cannotCreateTemp);
    return;
  }
catch (  InterruptedException e) {
    transportError(UIText.SourceBranchPage_remoteListingCancelled);
    return;
  }
  final Ref idHEAD=listRemoteOp.getRemoteRef(Constants.HEAD);
  head=null;
  boolean headIsMaster=false;
  final String masterBranchRef=Constants.R_HEADS + Constants.MASTER;
  for (  final Ref r : listRemoteOp.getRemoteRefs()) {
    final String n=r.getName();
    if (!n.startsWith(Constants.R_HEADS))     continue;
    availableRefs.add(r);
    if (idHEAD == null || headIsMaster)     continue;
    if (r.getObjectId().equals(idHEAD.getObjectId())) {
      headIsMaster=masterBranchRef.equals(r.getName());
      if (head == null || headIsMaster)       head=r;
    }
  }
  Collections.sort(availableRefs,new Comparator<Ref>(){
    public int compare(    final Ref o1,    final Ref o2){
      return o1.getName().compareTo(o2.getName());
    }
  }
);
  if (idHEAD != null && head == null) {
    head=idHEAD;
    availableRefs.add(0,idHEAD);
  }
  validatedRepoSelection=newRepoSelection;
  refsViewer.setInput(availableRefs);
  refsViewer.setAllChecked(true);
  checkPage();
  checkForEmptyRepo();
}",0.9757058437294812
91472,"@Override protected Control createMessageArea(Composite composite){
  Composite main=new Composite(composite,SWT.NONE);
  main.setLayout(new GridLayout(2,false));
  GridDataFactory.fillDefaults().indent(0,0).grab(true,true).applyTo(main);
  super.createMessageArea(main);
  StyledText text=new StyledText(main,SWT.FULL_SELECTION | SWT.WRAP);
  text.setEnabled(false);
  text.setBackground(main.getBackground());
  String messageText=NLS.bind(UIText.CloneFailureDialog_checkList,cause);
  int newLinesCount=messageText.split(""String_Node_Str"").length;
  Bullet bullet=createBullet(main);
  text.setText(messageText);
  text.setLineBullet(newLinesCount - 4,2,bullet);
  return main;
}","@Override protected Control createMessageArea(Composite composite){
  Composite main=new Composite(composite,SWT.NONE);
  main.setLayout(new GridLayout(2,false));
  GridDataFactory.fillDefaults().indent(0,0).grab(true,true).applyTo(main);
  super.createMessageArea(main);
  StyledText text=new StyledText(main,SWT.FULL_SELECTION | SWT.WRAP);
  text.setEnabled(false);
  text.setBackground(main.getBackground());
  String messageText=NLS.bind(UIText.CloneFailureDialog_checkList,uri.toString());
  int bullets=2;
  if (!uri.getPath().endsWith(""String_Node_Str"")) {
    messageText=messageText + UIText.CloneFailureDialog_checkList_git;
    bullets+=1;
  }
  if (""String_Node_Str"".equals(uri.getScheme())) {
    messageText=messageText + UIText.CloneFailureDialog_checkList_ssh;
    bullets+=1;
  }
 else   if (""String_Node_Str"".equals(uri.getScheme())) {
    messageText=messageText + UIText.CloneFailureDialog_checkList_https;
    bullets+=1;
  }
  int newLinesCount=messageText.split(""String_Node_Str"").length;
  Bullet bullet=createBullet(main);
  text.setText(messageText);
  text.setLineBullet(newLinesCount - bullets,bullets,bullet);
  return main;
}",0.7316276537833424
91473,"/** 
 * Creates and shows custom error dialog for failed ls-remotes operation
 * @param parentShell
 * @param cause full failure cause message
 */
public static void show(Shell parentShell,String cause){
  SourceBranchFailureDialog dialog=new SourceBranchFailureDialog(parentShell,cause);
  dialog.setShellStyle(dialog.getShellStyle() | SWT.SHEET | SWT.RESIZE);
  dialog.open();
}","/** 
 * Creates and shows custom error dialog for failed ls-remotes operation
 * @param parentShell
 * @param uri the uri of the remote repository
 */
public static void show(Shell parentShell,URIish uri){
  SourceBranchFailureDialog dialog=new SourceBranchFailureDialog(parentShell,uri);
  dialog.setShellStyle(dialog.getShellStyle() | SWT.SHEET | SWT.RESIZE);
  dialog.open();
}",0.8736842105263158
91474,"private SourceBranchFailureDialog(Shell parentShell,String cause){
  super(parentShell,UIText.CloneFailureDialog_tile,null,null,MessageDialog.ERROR,new String[]{IDialogConstants.OK_LABEL},0);
  this.cause=cause;
}","private SourceBranchFailureDialog(Shell parentShell,URIish uri){
  super(parentShell,UIText.CloneFailureDialog_tile,null,null,MessageDialog.ERROR,new String[]{IDialogConstants.OK_LABEL},0);
  this.uri=uri;
}",0.9095238095238096
91475,"private IgnoreOperation executeIgnore(IPath... paths) throws Exception {
  IgnoreOperation operation=new IgnoreOperation(Arrays.asList(paths));
  operation.execute(new NullProgressMonitor());
  return operation;
}","private IgnoreOperation executeIgnore(IPath... paths) throws Exception {
  final IgnoreOperation operation=new IgnoreOperation(Arrays.asList(paths));
  Job job=new Job(""String_Node_Str""){
    @Override protected IStatus run(    IProgressMonitor monitor){
      try {
        operation.execute(monitor);
      }
 catch (      CoreException e) {
        return e.getStatus();
      }
      return Status.OK_STATUS;
    }
  }
;
  job.setRule(operation.getSchedulingRule());
  job.schedule();
  job.join();
  if (!job.getResult().isOK())   fail(""String_Node_Str"" + job.getResult());
  return operation;
}",0.4698646986469865
91476,"private void addIgnore(IProgressMonitor monitor,IPath path) throws UnsupportedEncodingException, CoreException, IOException {
  IPath parent=path.removeLastSegments(1);
  IWorkspaceRoot root=ResourcesPlugin.getWorkspace().getRoot();
  IContainer container=root.getContainerForLocation(parent);
  String entry=""String_Node_Str"" + path.lastSegment() + ""String_Node_Str"";
  if (container == null || container instanceof IWorkspaceRoot) {
    Repository repository=RepositoryMapping.getMapping(path).getRepository();
    IPath gitIgnorePath=parent.append(Constants.GITIGNORE_FILENAME);
    IPath repoPath=new Path(repository.getWorkTree().getAbsolutePath());
    if (!repoPath.isPrefixOf(gitIgnorePath)) {
      String message=NLS.bind(CoreText.IgnoreOperation_parentOutsideRepo,path.toOSString(),repoPath.toOSString());
      IStatus status=Activator.error(message,null);
      throw new CoreException(status);
    }
    File gitIgnore=new File(gitIgnorePath.toOSString());
    updateGitIgnore(gitIgnore,entry);
    gitignoreOutsideWSChanged=true;
  }
 else {
    IFile gitignore=container.getFile(new Path(Constants.GITIGNORE_FILENAME));
    entry=getEntry(gitignore.getLocation().toFile(),entry);
    IProgressMonitor subMonitor=new SubProgressMonitor(monitor,1);
    ByteArrayInputStream entryBytes=asStream(entry);
    if (gitignore.exists())     gitignore.appendContents(entryBytes,true,true,subMonitor);
 else     gitignore.create(entryBytes,true,subMonitor);
  }
}","private void addIgnore(IProgressMonitor monitor,IPath path) throws UnsupportedEncodingException, CoreException, IOException {
  IPath parent=path.removeLastSegments(1);
  IResource resource=ResourceUtil.getResourceForLocation(path);
  IContainer container=null;
  if (resource != null)   container=resource.getParent();
  String entry=""String_Node_Str"" + path.lastSegment() + ""String_Node_Str"";
  if (container == null || container instanceof IWorkspaceRoot) {
    Repository repository=RepositoryMapping.getMapping(path).getRepository();
    IPath gitIgnorePath=parent.append(Constants.GITIGNORE_FILENAME);
    IPath repoPath=new Path(repository.getWorkTree().getAbsolutePath());
    if (!repoPath.isPrefixOf(gitIgnorePath)) {
      String message=NLS.bind(CoreText.IgnoreOperation_parentOutsideRepo,path.toOSString(),repoPath.toOSString());
      IStatus status=Activator.error(message,null);
      throw new CoreException(status);
    }
    File gitIgnore=new File(gitIgnorePath.toOSString());
    updateGitIgnore(gitIgnore,entry);
    gitignoreOutsideWSChanged=true;
  }
 else {
    IFile gitignore=container.getFile(new Path(Constants.GITIGNORE_FILENAME));
    entry=getEntry(gitignore.getLocation().toFile(),entry);
    IProgressMonitor subMonitor=new SubProgressMonitor(monitor,1);
    ByteArrayInputStream entryBytes=asStream(entry);
    if (gitignore.exists())     gitignore.appendContents(entryBytes,true,true,subMonitor);
 else     gitignore.create(entryBytes,true,subMonitor);
  }
}",0.9385550303848752
91477,"private IgnoreOperation executeIgnore(IPath... paths) throws Exception {
  IgnoreOperation operation=new IgnoreOperation(Arrays.asList(paths));
  operation.execute(new NullProgressMonitor());
  return operation;
}","private IgnoreOperation executeIgnore(IPath... paths) throws Exception {
  final IgnoreOperation operation=new IgnoreOperation(Arrays.asList(paths));
  Job job=new Job(""String_Node_Str""){
    @Override protected IStatus run(    IProgressMonitor monitor){
      try {
        operation.execute(monitor);
      }
 catch (      CoreException e) {
        return e.getStatus();
      }
      return Status.OK_STATUS;
    }
  }
;
  job.setRule(operation.getSchedulingRule());
  job.schedule();
  job.join();
  if (!job.getResult().isOK())   fail(""String_Node_Str"" + job.getResult());
  return operation;
}",0.4698646986469865
91478,"private void addIgnore(IProgressMonitor monitor,IPath path) throws UnsupportedEncodingException, CoreException, IOException {
  IPath parent=path.removeLastSegments(1);
  IWorkspaceRoot root=ResourcesPlugin.getWorkspace().getRoot();
  IContainer container=root.getContainerForLocation(parent);
  String entry=""String_Node_Str"" + path.lastSegment() + ""String_Node_Str"";
  if (container == null || container instanceof IWorkspaceRoot) {
    Repository repository=RepositoryMapping.getMapping(path).getRepository();
    IPath gitIgnorePath=parent.append(Constants.GITIGNORE_FILENAME);
    IPath repoPath=new Path(repository.getWorkTree().getAbsolutePath());
    if (!repoPath.isPrefixOf(gitIgnorePath)) {
      String message=NLS.bind(CoreText.IgnoreOperation_parentOutsideRepo,path.toOSString(),repoPath.toOSString());
      IStatus status=Activator.error(message,null);
      throw new CoreException(status);
    }
    File gitIgnore=new File(gitIgnorePath.toOSString());
    updateGitIgnore(gitIgnore,entry);
    gitignoreOutsideWSChanged=true;
  }
 else {
    IFile gitignore=container.getFile(new Path(Constants.GITIGNORE_FILENAME));
    entry=getEntry(gitignore.getLocation().toFile(),entry);
    IProgressMonitor subMonitor=new SubProgressMonitor(monitor,1);
    ByteArrayInputStream entryBytes=asStream(entry);
    if (gitignore.exists())     gitignore.appendContents(entryBytes,true,true,subMonitor);
 else     gitignore.create(entryBytes,true,subMonitor);
  }
}","private void addIgnore(IProgressMonitor monitor,IPath path) throws UnsupportedEncodingException, CoreException, IOException {
  IPath parent=path.removeLastSegments(1);
  IResource resource=ResourceUtil.getResourceForLocation(path);
  IContainer container=null;
  if (resource != null)   container=resource.getParent();
  String entry=""String_Node_Str"" + path.lastSegment() + ""String_Node_Str"";
  if (container == null || container instanceof IWorkspaceRoot) {
    Repository repository=RepositoryMapping.getMapping(path).getRepository();
    IPath gitIgnorePath=parent.append(Constants.GITIGNORE_FILENAME);
    IPath repoPath=new Path(repository.getWorkTree().getAbsolutePath());
    if (!repoPath.isPrefixOf(gitIgnorePath)) {
      String message=NLS.bind(CoreText.IgnoreOperation_parentOutsideRepo,path.toOSString(),repoPath.toOSString());
      IStatus status=Activator.error(message,null);
      throw new CoreException(status);
    }
    File gitIgnore=new File(gitIgnorePath.toOSString());
    updateGitIgnore(gitIgnore,entry);
    gitignoreOutsideWSChanged=true;
  }
 else {
    IFile gitignore=container.getFile(new Path(Constants.GITIGNORE_FILENAME));
    entry=getEntry(gitignore.getLocation().toFile(),entry);
    IProgressMonitor subMonitor=new SubProgressMonitor(monitor,1);
    ByteArrayInputStream entryBytes=asStream(entry);
    if (gitignore.exists())     gitignore.appendContents(entryBytes,true,true,subMonitor);
 else     gitignore.create(entryBytes,true,subMonitor);
  }
}",0.9385550303848752
91479,"private String getProjectRelativePath(Repository db,String repoPath){
  IWorkspace workspace=ResourcesPlugin.getWorkspace();
  IWorkspaceRoot root=workspace.getRoot();
  IPath absolutePath=new Path(db.getWorkTree().getAbsolutePath()).append(repoPath);
  IResource resource=root.getFileForLocation(absolutePath);
  return resource.getProjectRelativePath().toString();
}","private String getProjectRelativePath(Repository db,String repoPath){
  IWorkspace workspace=ResourcesPlugin.getWorkspace();
  IWorkspaceRoot root=workspace.getRoot();
  IPath absolutePath=new Path(db.getWorkTree().getAbsolutePath()).append(repoPath);
  IResource resource=root.getFileForLocation(absolutePath);
  if (resource == null)   return null;
  return resource.getProjectRelativePath().toString();
}",0.9496774193548388
91480,"/** 
 * Get the repository mapping for a path if it exists.
 * @param path
 * @return the RepositoryMapping for this path,or null for non GitProvider.
 */
public static RepositoryMapping getMapping(IPath path){
  IProject[] projects=ResourcesPlugin.getWorkspace().getRoot().getProjects();
  for (  IProject project : projects) {
    if (isNonWorkspace(project))     continue;
    RepositoryMapping mapping=getMapping(project);
    if (mapping == null)     continue;
    Path workingTree=new Path(mapping.getWorkTree().toString());
    IPath relative=path.makeRelativeTo(workingTree);
    String firstSegment=relative.segment(0);
    if (firstSegment == null || !""String_Node_Str"".equals(firstSegment))     return mapping;
  }
  return null;
}","/** 
 * Get the repository mapping for a path if it exists.
 * @param path
 * @return the RepositoryMapping for this path,or null for non GitProvider.
 */
public static RepositoryMapping getMapping(IPath path){
  IProject[] projects=ResourcesPlugin.getWorkspace().getRoot().getProjects();
  for (  IProject project : projects) {
    if (isNonWorkspace(project))     continue;
    RepositoryMapping mapping=getMapping(project);
    if (mapping == null)     continue;
    IPath workingTree=new Path(mapping.getWorkTree().toString());
    if (workingTree.isPrefixOf(path))     return mapping;
  }
  return null;
}",0.8047337278106509
91481,"/** 
 * @param parent parent object
 * @param repo repository associated with this object
 * @param cache list of changes associated with this object
 * @param fileFactory leaf instance factory
 */
protected GitModelCache(GitModelRepository parent,Repository repo,Map<String,Change> cache,FileModelFactory fileFactory){
  super(parent);
  this.repo=repo;
  this.cache=cache;
  this.fileFactory=fileFactory;
  cacheTreeMap=new HashMap<String,GitModelCacheTree>();
  location=new Path(repo.getWorkTree().toString());
}","/** 
 * @param parent parent object
 * @param repo repository associated with this object
 * @param changes list of changes associated with this object
 * @param fileFactory leaf instance factory
 */
protected GitModelCache(GitModelRepository parent,final Repository repo,Map<String,Change> changes,final FileModelFactory fileFactory){
  super(parent);
  this.repo=repo;
  this.location=new Path(repo.getWorkTree().toString());
  this.children=TreeBuilder.build(this,repo,changes,fileFactory,new TreeModelFactory(){
    public GitModelTree createTreeModel(    GitModelObjectContainer parentObject,    IPath fullPath,    int kind){
      return new GitModelCacheTree(parentObject,repo,fullPath,fileFactory);
    }
  }
);
}",0.6531932093775262
91482,"@Override public GitModelObject[] getChildren(){
  List<GitModelObject> result=new ArrayList<GitModelObject>();
  for (  Entry<String,Change> cacheEntry : cache.entrySet()) {
    GitModelObject entry=extractFromCache(cacheEntry.getValue(),cacheEntry.getKey());
    if (entry == null)     continue;
    result.add(entry);
  }
  return result.toArray(new GitModelObject[result.size()]);
}","@Override public GitModelObject[] getChildren(){
  return children;
}",0.2813186813186813
91483,"@Override public void dispose(){
  for (  GitModelTree modelTree : cacheTreeMap.values())   modelTree.dispose();
  cache.clear();
  cacheTreeMap.clear();
}","@Override public void dispose(){
  if (children != null) {
    for (    GitModelObject object : children)     object.dispose();
    children=null;
  }
}",0.5798045602605864
91484,"/** 
 * @param parent parent object
 * @param repo repository associated with this object parent object
 * @param fullPath absolute path of object
 * @param factory
 */
public GitModelCacheTree(GitModelObjectContainer parent,Repository repo,IPath fullPath,FileModelFactory factory){
  super(parent,fullPath,RIGHT | CHANGE);
  this.repo=repo;
  this.factory=factory;
  cacheTreeMap=new HashMap<String,GitModelObject>();
}","/** 
 * @param parent parent object
 * @param repo repository associated with this object parent object
 * @param fullPath absolute path of object
 * @param factory
 */
public GitModelCacheTree(GitModelObjectContainer parent,Repository repo,IPath fullPath,FileModelFactory factory){
  super(parent,fullPath,RIGHT | CHANGE);
  this.factory=factory;
}",0.871261378413524
91485,"/** 
 * @param shell
 * @param repo
 * @param result
 */
public PullResultDialog(Shell shell,Repository repo,PullResult result){
  super(shell);
  setShellStyle(getShellStyle() & ~SWT.APPLICATION_MODAL | SWT.SHELL_TRIM);
  setBlockOnOpen(false);
  this.repo=repo;
  this.result=result;
  hasUpdates=hasFetchResults() || hasMergeResults() || hasRebaseResults();
}","/** 
 * @param shell
 * @param repo
 * @param result
 */
public PullResultDialog(Shell shell,Repository repo,PullResult result){
  super(shell);
  setShellStyle(getShellStyle() & ~SWT.APPLICATION_MODAL | SWT.SHELL_TRIM);
  setBlockOnOpen(false);
  this.repo=repo;
  this.result=result;
  persistSize=hasFetchResults() || hasMergeResults();
}",0.9388335704125178
91486,"@Override protected Control createDialogArea(Composite parent){
  Composite main=new Composite(parent,SWT.NONE);
  GridLayoutFactory.swtDefaults().applyTo(main);
  GridDataFactory.fillDefaults().indent(0,0).grab(true,true).applyTo(main);
  Group fetchResultGroup=new Group(main,SWT.SHADOW_ETCHED_IN);
  fetchResultGroup.setText(UIText.PullResultDialog_FetchResultGroupHeader);
  GridLayoutFactory.fillDefaults().applyTo(fetchResultGroup);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(fetchResultGroup);
  FetchResult fRes=result.getFetchResult();
  if (hasFetchResults()) {
    GridLayoutFactory.fillDefaults().applyTo(fetchResultGroup);
    FetchResultDialog dlg=new FetchResultDialog(getParentShell(),repo,fRes,result.getFetchedFrom());
    Control fresult=dlg.createFetchResultTable(fetchResultGroup);
    Object layoutData=fresult.getLayoutData();
    if (layoutData instanceof GridData)     GridDataFactory.createFrom((GridData)layoutData).hint(SWT.DEFAULT,130).applyTo(fresult);
  }
 else {
    GridLayoutFactory.swtDefaults().applyTo(fetchResultGroup);
    Label noResult=new Label(fetchResultGroup,SWT.NONE);
    if (result.getFetchedFrom().equals(""String_Node_Str""))     noResult.setText(UIText.PullResultDialog_NothingToFetchFromLocal);
 else     noResult.setText(NLS.bind(UIText.FetchResultDialog_labelEmptyResult,result.getFetchedFrom()));
  }
  Group mergeResultGroup=new Group(main,SWT.SHADOW_ETCHED_IN);
  mergeResultGroup.setText(UIText.PullResultDialog_MergeResultGroupHeader);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(mergeResultGroup);
  if (hasMergeResults()) {
    GridLayoutFactory.fillDefaults().applyTo(mergeResultGroup);
    MergeResultDialog dlg=new MergeResultDialog(getParentShell(),repo,result.getMergeResult());
    dlg.createDialogArea(mergeResultGroup);
  }
 else   if (hasRebaseResults()) {
    Status status=result.getRebaseResult().getStatus();
    GridLayoutFactory.fillDefaults().applyTo(mergeResultGroup);
switch (status) {
case OK:
case FAST_FORWARD:
case UP_TO_DATE:
case FAILED:
case ABORTED:
      break;
case STOPPED:
    Label errorLabel=new Label(mergeResultGroup,SWT.NONE);
  errorLabel.setImage(PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_OBJS_ERROR_TSK));
Text errorText=new Text(mergeResultGroup,SWT.READ_ONLY);
errorText.setText(UIText.PullResultDialog_RebaseStoppedMessage);
break;
}
Label statusLabel=new Label(mergeResultGroup,SWT.NONE);
statusLabel.setText(UIText.PullResultDialog_RebaseStatusLabel);
Text statusText=new Text(mergeResultGroup,SWT.READ_ONLY);
statusText.setText(status.name());
}
 else {
GridLayoutFactory.swtDefaults().applyTo(mergeResultGroup);
Label noResult=new Label(mergeResultGroup,SWT.NONE);
noResult.setText(UIText.PullResultDialog_MergeAlreadyUpToDateMessage);
}
return main;
}","@Override protected Control createDialogArea(Composite parent){
  Composite main=new Composite(parent,SWT.NONE);
  GridLayoutFactory.swtDefaults().applyTo(main);
  GridDataFactory.fillDefaults().indent(0,0).grab(true,true).applyTo(main);
  Group fetchResultGroup=new Group(main,SWT.SHADOW_ETCHED_IN);
  fetchResultGroup.setText(UIText.PullResultDialog_FetchResultGroupHeader);
  GridLayoutFactory.fillDefaults().applyTo(fetchResultGroup);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(fetchResultGroup);
  FetchResult fRes=result.getFetchResult();
  if (hasFetchResults()) {
    GridLayoutFactory.fillDefaults().applyTo(fetchResultGroup);
    FetchResultDialog dlg=new FetchResultDialog(getParentShell(),repo,fRes,result.getFetchedFrom());
    Control fresult=dlg.createFetchResultTable(fetchResultGroup);
    Object layoutData=fresult.getLayoutData();
    if (layoutData instanceof GridData)     GridDataFactory.createFrom((GridData)layoutData).hint(SWT.DEFAULT,130).applyTo(fresult);
  }
 else {
    GridLayoutFactory.swtDefaults().applyTo(fetchResultGroup);
    Label noResult=new Label(fetchResultGroup,SWT.NONE);
    if (result.getFetchedFrom().equals(""String_Node_Str""))     noResult.setText(UIText.PullResultDialog_NothingToFetchFromLocal);
 else     noResult.setText(NLS.bind(UIText.FetchResultDialog_labelEmptyResult,result.getFetchedFrom()));
  }
  Group mergeResultGroup=new Group(main,SWT.SHADOW_ETCHED_IN);
  mergeResultGroup.setText(UIText.PullResultDialog_MergeResultGroupHeader);
  if (hasMergeResults()) {
    GridDataFactory.fillDefaults().grab(true,true).applyTo(mergeResultGroup);
    GridLayoutFactory.fillDefaults().applyTo(mergeResultGroup);
    MergeResultDialog dlg=new MergeResultDialog(getParentShell(),repo,result.getMergeResult());
    dlg.createDialogArea(mergeResultGroup);
  }
 else   if (hasRebaseResults()) {
    GridDataFactory.fillDefaults().grab(true,false).applyTo(mergeResultGroup);
    GridLayoutFactory.swtDefaults().applyTo(mergeResultGroup);
    Status status=result.getRebaseResult().getStatus();
switch (status) {
case OK:
case FAST_FORWARD:
case UP_TO_DATE:
case FAILED:
case ABORTED:
      break;
case STOPPED:
    Label errorLabel=new Label(mergeResultGroup,SWT.NONE);
  errorLabel.setImage(PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_OBJS_ERROR_TSK));
Text errorText=new Text(mergeResultGroup,SWT.READ_ONLY);
errorText.setText(UIText.PullResultDialog_RebaseStoppedMessage);
break;
}
Label statusLabel=new Label(mergeResultGroup,SWT.NONE);
statusLabel.setText(UIText.PullResultDialog_RebaseStatusLabel);
Text statusText=new Text(mergeResultGroup,SWT.READ_ONLY);
statusText.setText(status.name());
}
 else {
GridDataFactory.fillDefaults().grab(true,false).applyTo(mergeResultGroup);
GridLayoutFactory.swtDefaults().applyTo(mergeResultGroup);
Label noResult=new Label(mergeResultGroup,SWT.NONE);
noResult.setText(UIText.PullResultDialog_MergeAlreadyUpToDateMessage);
}
return main;
}",0.8551652535040665
91487,"@Override protected int getDialogBoundsStrategy(){
  return hasUpdates ? DIALOG_PERSISTLOCATION | DIALOG_PERSISTSIZE : DIALOG_PERSISTLOCATION;
}","@Override protected int getDialogBoundsStrategy(){
  int strategy=DIALOG_PERSISTLOCATION;
  if (persistSize)   strategy|=DIALOG_PERSISTSIZE;
  return strategy;
}",0.5377049180327869
91488,"@Override protected IStatus run(IProgressMonitor monitor){
  waitForWorkspaceLock();
  if (monitor.isCanceled())   return Status.CANCEL_STATUS;
  lock.lock();
  try {
    long startTime=System.currentTimeMillis();
    IndexDiffData result=calcIndexDiffData(monitor,getName(),filesToUpdate,resourcesToUpdate);
    if (monitor.isCanceled())     return Status.CANCEL_STATUS;
    indexDiffData=result;
    if (GitTraceLocation.INDEXDIFFCACHE.isActive()) {
      long time=System.currentTimeMillis() - startTime;
      StringBuilder message=new StringBuilder(NLS.bind(""String_Node_Str"",Integer.valueOf(resourcesToUpdate.size()),Long.valueOf(time)));
      GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),message.append(indexDiffData.toString()).toString());
    }
    notifyListeners();
    return Status.OK_STATUS;
  }
 catch (  RuntimeException e) {
    if (GitTraceLocation.INDEXDIFFCACHE.isActive())     GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),""String_Node_Str"",e);
    scheduleReloadJob(""String_Node_Str"");
    return Status.OK_STATUS;
  }
 finally {
    lock.unlock();
  }
}","@Override protected IStatus run(IProgressMonitor monitor){
  waitForWorkspaceLock(monitor);
  if (monitor.isCanceled())   return Status.CANCEL_STATUS;
  lock.lock();
  try {
    long startTime=System.currentTimeMillis();
    IndexDiffData result=calcIndexDiffData(monitor,getName(),filesToUpdate,resourcesToUpdate);
    if (monitor.isCanceled())     return Status.CANCEL_STATUS;
    indexDiffData=result;
    if (GitTraceLocation.INDEXDIFFCACHE.isActive()) {
      long time=System.currentTimeMillis() - startTime;
      StringBuilder message=new StringBuilder(NLS.bind(""String_Node_Str"",Integer.valueOf(resourcesToUpdate.size()),Long.valueOf(time)));
      GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),message.append(indexDiffData.toString()).toString());
    }
    notifyListeners();
    return Status.OK_STATUS;
  }
 catch (  RuntimeException e) {
    if (GitTraceLocation.INDEXDIFFCACHE.isActive())     GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),""String_Node_Str"",e);
    scheduleReloadJob(""String_Node_Str"");
    return Status.OK_STATUS;
  }
 finally {
    lock.unlock();
  }
}",0.9969578444154716
91489,"private void scheduleReloadJob(final String trigger){
  if (reloadJob != null)   reloadJob.cancel();
  if (!checkRepository())   return;
  reloadJob=new Job(getReloadJobName()){
    @Override protected IStatus run(    IProgressMonitor monitor){
      waitForWorkspaceLock();
      if (monitor.isCanceled())       return Status.CANCEL_STATUS;
      lock.lock();
      try {
        long startTime=System.currentTimeMillis();
        IndexDiff result=calcIndexDiff(monitor,getName());
        if (monitor.isCanceled())         return Status.CANCEL_STATUS;
        indexDiffData=new IndexDiffData(result);
        if (GitTraceLocation.INDEXDIFFCACHE.isActive()) {
          long time=System.currentTimeMillis() - startTime;
          StringBuilder message=new StringBuilder(getTraceMessage(time));
          GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),message.append(indexDiffData.toString()).toString());
        }
        notifyListeners();
        return Status.OK_STATUS;
      }
 catch (      RuntimeException e) {
        if (GitTraceLocation.INDEXDIFFCACHE.isActive())         GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),""String_Node_Str"",e);
        scheduleReloadJob(""String_Node_Str"");
        return Status.OK_STATUS;
      }
 finally {
        lock.unlock();
      }
    }
    private String getTraceMessage(    long time){
      return NLS.bind(""String_Node_Str"",new Object[]{Long.valueOf(time),trigger,repository.getWorkTree().getName()});
    }
    @Override public boolean belongsTo(    Object family){
      if (family.equals(JobFamilies.INDEX_DIFF_CACHE_UPDATE))       return true;
      return super.belongsTo(family);
    }
  }
;
  reloadJob.schedule();
}","private void scheduleReloadJob(final String trigger){
  if (reloadJob != null)   reloadJob.cancel();
  if (!checkRepository())   return;
  reloadJob=new Job(getReloadJobName()){
    @Override protected IStatus run(    IProgressMonitor monitor){
      waitForWorkspaceLock(monitor);
      if (monitor.isCanceled())       return Status.CANCEL_STATUS;
      lock.lock();
      try {
        long startTime=System.currentTimeMillis();
        IndexDiff result=calcIndexDiff(monitor,getName());
        if (monitor.isCanceled())         return Status.CANCEL_STATUS;
        indexDiffData=new IndexDiffData(result);
        if (GitTraceLocation.INDEXDIFFCACHE.isActive()) {
          long time=System.currentTimeMillis() - startTime;
          StringBuilder message=new StringBuilder(getTraceMessage(time));
          GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),message.append(indexDiffData.toString()).toString());
        }
        notifyListeners();
        return Status.OK_STATUS;
      }
 catch (      RuntimeException e) {
        if (GitTraceLocation.INDEXDIFFCACHE.isActive())         GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),""String_Node_Str"",e);
        scheduleReloadJob(""String_Node_Str"");
        return Status.OK_STATUS;
      }
 finally {
        lock.unlock();
      }
    }
    private String getTraceMessage(    long time){
      return NLS.bind(""String_Node_Str"",new Object[]{Long.valueOf(time),trigger,repository.getWorkTree().getName()});
    }
    @Override public boolean belongsTo(    Object family){
      if (family.equals(JobFamilies.INDEX_DIFF_CACHE_UPDATE))       return true;
      return super.belongsTo(family);
    }
  }
;
  reloadJob.schedule();
}",0.997997138769671
91490,"private void scheduleUpdateJob(final Collection<String> filesToUpdate,final Collection<IResource> resourcesToUpdate){
  if (!checkRepository())   return;
  Job job=new Job(getReloadJobName()){
    @Override protected IStatus run(    IProgressMonitor monitor){
      waitForWorkspaceLock();
      if (monitor.isCanceled())       return Status.CANCEL_STATUS;
      lock.lock();
      try {
        long startTime=System.currentTimeMillis();
        IndexDiffData result=calcIndexDiffData(monitor,getName(),filesToUpdate,resourcesToUpdate);
        if (monitor.isCanceled())         return Status.CANCEL_STATUS;
        indexDiffData=result;
        if (GitTraceLocation.INDEXDIFFCACHE.isActive()) {
          long time=System.currentTimeMillis() - startTime;
          StringBuilder message=new StringBuilder(NLS.bind(""String_Node_Str"",Integer.valueOf(resourcesToUpdate.size()),Long.valueOf(time)));
          GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),message.append(indexDiffData.toString()).toString());
        }
        notifyListeners();
        return Status.OK_STATUS;
      }
 catch (      RuntimeException e) {
        if (GitTraceLocation.INDEXDIFFCACHE.isActive())         GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),""String_Node_Str"",e);
        scheduleReloadJob(""String_Node_Str"");
        return Status.OK_STATUS;
      }
 finally {
        lock.unlock();
      }
    }
    @Override public boolean belongsTo(    Object family){
      if (family.equals(JobFamilies.INDEX_DIFF_CACHE_UPDATE))       return true;
      return super.belongsTo(family);
    }
  }
;
  job.schedule();
}","private void scheduleUpdateJob(final Collection<String> filesToUpdate,final Collection<IResource> resourcesToUpdate){
  if (!checkRepository())   return;
  Job job=new Job(getReloadJobName()){
    @Override protected IStatus run(    IProgressMonitor monitor){
      waitForWorkspaceLock(monitor);
      if (monitor.isCanceled())       return Status.CANCEL_STATUS;
      lock.lock();
      try {
        long startTime=System.currentTimeMillis();
        IndexDiffData result=calcIndexDiffData(monitor,getName(),filesToUpdate,resourcesToUpdate);
        if (monitor.isCanceled())         return Status.CANCEL_STATUS;
        indexDiffData=result;
        if (GitTraceLocation.INDEXDIFFCACHE.isActive()) {
          long time=System.currentTimeMillis() - startTime;
          StringBuilder message=new StringBuilder(NLS.bind(""String_Node_Str"",Integer.valueOf(resourcesToUpdate.size()),Long.valueOf(time)));
          GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),message.append(indexDiffData.toString()).toString());
        }
        notifyListeners();
        return Status.OK_STATUS;
      }
 catch (      RuntimeException e) {
        if (GitTraceLocation.INDEXDIFFCACHE.isActive())         GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),""String_Node_Str"",e);
        scheduleReloadJob(""String_Node_Str"");
        return Status.OK_STATUS;
      }
 finally {
        lock.unlock();
      }
    }
    @Override public boolean belongsTo(    Object family){
      if (family.equals(JobFamilies.INDEX_DIFF_CACHE_UPDATE))       return true;
      return super.belongsTo(family);
    }
  }
;
  job.schedule();
}",0.9979035639412998
91491,"private void waitForWorkspaceLock(){
  try {
    ResourcesPlugin.getWorkspace().run(new IWorkspaceRunnable(){
      public void run(      IProgressMonitor monitor) throws CoreException {
      }
    }
,new NullProgressMonitor());
  }
 catch (  CoreException e) {
    throw new RuntimeException(e);
  }
}","private void waitForWorkspaceLock(IProgressMonitor monitor){
  try {
    ResourcesPlugin.getWorkspace().run(new IWorkspaceRunnable(){
      public void run(      IProgressMonitor innerMonitor) throws CoreException {
      }
    }
,monitor);
  }
 catch (  OperationCanceledException e) {
    return;
  }
catch (  CoreException e) {
    throw new RuntimeException(e);
  }
}",0.7181008902077152
91492,"@Override protected IStatus run(IProgressMonitor monitor){
  waitForWorkspaceLock();
  if (monitor.isCanceled())   return Status.CANCEL_STATUS;
  lock.lock();
  try {
    long startTime=System.currentTimeMillis();
    IndexDiffData result=calcIndexDiffData(monitor,getName(),filesToUpdate,resourcesToUpdate);
    if (monitor.isCanceled())     return Status.CANCEL_STATUS;
    indexDiffData=result;
    if (GitTraceLocation.INDEXDIFFCACHE.isActive()) {
      long time=System.currentTimeMillis() - startTime;
      StringBuilder message=new StringBuilder(NLS.bind(""String_Node_Str"",Integer.valueOf(resourcesToUpdate.size()),Long.valueOf(time)));
      GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),message.append(indexDiffData.toString()).toString());
    }
    notifyListeners();
    return Status.OK_STATUS;
  }
 catch (  RuntimeException e) {
    if (GitTraceLocation.INDEXDIFFCACHE.isActive())     GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),""String_Node_Str"",e);
    scheduleReloadJob(""String_Node_Str"");
    return Status.OK_STATUS;
  }
 finally {
    lock.unlock();
  }
}","@Override protected IStatus run(IProgressMonitor monitor){
  waitForWorkspaceLock(monitor);
  if (monitor.isCanceled())   return Status.CANCEL_STATUS;
  lock.lock();
  try {
    long startTime=System.currentTimeMillis();
    IndexDiffData result=calcIndexDiffData(monitor,getName(),filesToUpdate,resourcesToUpdate);
    if (monitor.isCanceled())     return Status.CANCEL_STATUS;
    indexDiffData=result;
    if (GitTraceLocation.INDEXDIFFCACHE.isActive()) {
      long time=System.currentTimeMillis() - startTime;
      StringBuilder message=new StringBuilder(NLS.bind(""String_Node_Str"",Integer.valueOf(resourcesToUpdate.size()),Long.valueOf(time)));
      GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),message.append(indexDiffData.toString()).toString());
    }
    notifyListeners();
    return Status.OK_STATUS;
  }
 catch (  RuntimeException e) {
    if (GitTraceLocation.INDEXDIFFCACHE.isActive())     GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),""String_Node_Str"",e);
    scheduleReloadJob(""String_Node_Str"");
    return Status.OK_STATUS;
  }
 finally {
    lock.unlock();
  }
}",0.9969578444154716
91493,"private void scheduleReloadJob(final String trigger){
  if (reloadJob != null)   reloadJob.cancel();
  if (!checkRepository())   return;
  reloadJob=new Job(getReloadJobName()){
    @Override protected IStatus run(    IProgressMonitor monitor){
      waitForWorkspaceLock();
      if (monitor.isCanceled())       return Status.CANCEL_STATUS;
      lock.lock();
      try {
        long startTime=System.currentTimeMillis();
        IndexDiff result=calcIndexDiff(monitor,getName());
        if (monitor.isCanceled())         return Status.CANCEL_STATUS;
        indexDiffData=new IndexDiffData(result);
        if (GitTraceLocation.INDEXDIFFCACHE.isActive()) {
          long time=System.currentTimeMillis() - startTime;
          StringBuilder message=new StringBuilder(getTraceMessage(time));
          GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),message.append(indexDiffData.toString()).toString());
        }
        notifyListeners();
        return Status.OK_STATUS;
      }
 catch (      RuntimeException e) {
        if (GitTraceLocation.INDEXDIFFCACHE.isActive())         GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),""String_Node_Str"",e);
        scheduleReloadJob(""String_Node_Str"");
        return Status.OK_STATUS;
      }
 finally {
        lock.unlock();
      }
    }
    private String getTraceMessage(    long time){
      return NLS.bind(""String_Node_Str"",new Object[]{Long.valueOf(time),trigger,repository.getWorkTree().getName()});
    }
    @Override public boolean belongsTo(    Object family){
      if (family.equals(JobFamilies.INDEX_DIFF_CACHE_UPDATE))       return true;
      return super.belongsTo(family);
    }
  }
;
  reloadJob.schedule();
}","private void scheduleReloadJob(final String trigger){
  if (reloadJob != null)   reloadJob.cancel();
  if (!checkRepository())   return;
  reloadJob=new Job(getReloadJobName()){
    @Override protected IStatus run(    IProgressMonitor monitor){
      waitForWorkspaceLock(monitor);
      if (monitor.isCanceled())       return Status.CANCEL_STATUS;
      lock.lock();
      try {
        long startTime=System.currentTimeMillis();
        IndexDiff result=calcIndexDiff(monitor,getName());
        if (monitor.isCanceled())         return Status.CANCEL_STATUS;
        indexDiffData=new IndexDiffData(result);
        if (GitTraceLocation.INDEXDIFFCACHE.isActive()) {
          long time=System.currentTimeMillis() - startTime;
          StringBuilder message=new StringBuilder(getTraceMessage(time));
          GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),message.append(indexDiffData.toString()).toString());
        }
        notifyListeners();
        return Status.OK_STATUS;
      }
 catch (      RuntimeException e) {
        if (GitTraceLocation.INDEXDIFFCACHE.isActive())         GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),""String_Node_Str"",e);
        scheduleReloadJob(""String_Node_Str"");
        return Status.OK_STATUS;
      }
 finally {
        lock.unlock();
      }
    }
    private String getTraceMessage(    long time){
      return NLS.bind(""String_Node_Str"",new Object[]{Long.valueOf(time),trigger,repository.getWorkTree().getName()});
    }
    @Override public boolean belongsTo(    Object family){
      if (family.equals(JobFamilies.INDEX_DIFF_CACHE_UPDATE))       return true;
      return super.belongsTo(family);
    }
  }
;
  reloadJob.schedule();
}",0.997997138769671
91494,"private void scheduleUpdateJob(final Collection<String> filesToUpdate,final Collection<IResource> resourcesToUpdate){
  if (!checkRepository())   return;
  Job job=new Job(getReloadJobName()){
    @Override protected IStatus run(    IProgressMonitor monitor){
      waitForWorkspaceLock();
      if (monitor.isCanceled())       return Status.CANCEL_STATUS;
      lock.lock();
      try {
        long startTime=System.currentTimeMillis();
        IndexDiffData result=calcIndexDiffData(monitor,getName(),filesToUpdate,resourcesToUpdate);
        if (monitor.isCanceled())         return Status.CANCEL_STATUS;
        indexDiffData=result;
        if (GitTraceLocation.INDEXDIFFCACHE.isActive()) {
          long time=System.currentTimeMillis() - startTime;
          StringBuilder message=new StringBuilder(NLS.bind(""String_Node_Str"",Integer.valueOf(resourcesToUpdate.size()),Long.valueOf(time)));
          GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),message.append(indexDiffData.toString()).toString());
        }
        notifyListeners();
        return Status.OK_STATUS;
      }
 catch (      RuntimeException e) {
        if (GitTraceLocation.INDEXDIFFCACHE.isActive())         GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),""String_Node_Str"",e);
        scheduleReloadJob(""String_Node_Str"");
        return Status.OK_STATUS;
      }
 finally {
        lock.unlock();
      }
    }
    @Override public boolean belongsTo(    Object family){
      if (family.equals(JobFamilies.INDEX_DIFF_CACHE_UPDATE))       return true;
      return super.belongsTo(family);
    }
  }
;
  job.schedule();
}","private void scheduleUpdateJob(final Collection<String> filesToUpdate,final Collection<IResource> resourcesToUpdate){
  if (!checkRepository())   return;
  Job job=new Job(getReloadJobName()){
    @Override protected IStatus run(    IProgressMonitor monitor){
      waitForWorkspaceLock(monitor);
      if (monitor.isCanceled())       return Status.CANCEL_STATUS;
      lock.lock();
      try {
        long startTime=System.currentTimeMillis();
        IndexDiffData result=calcIndexDiffData(monitor,getName(),filesToUpdate,resourcesToUpdate);
        if (monitor.isCanceled())         return Status.CANCEL_STATUS;
        indexDiffData=result;
        if (GitTraceLocation.INDEXDIFFCACHE.isActive()) {
          long time=System.currentTimeMillis() - startTime;
          StringBuilder message=new StringBuilder(NLS.bind(""String_Node_Str"",Integer.valueOf(resourcesToUpdate.size()),Long.valueOf(time)));
          GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),message.append(indexDiffData.toString()).toString());
        }
        notifyListeners();
        return Status.OK_STATUS;
      }
 catch (      RuntimeException e) {
        if (GitTraceLocation.INDEXDIFFCACHE.isActive())         GitTraceLocation.getTrace().trace(GitTraceLocation.INDEXDIFFCACHE.getLocation(),""String_Node_Str"",e);
        scheduleReloadJob(""String_Node_Str"");
        return Status.OK_STATUS;
      }
 finally {
        lock.unlock();
      }
    }
    @Override public boolean belongsTo(    Object family){
      if (family.equals(JobFamilies.INDEX_DIFF_CACHE_UPDATE))       return true;
      return super.belongsTo(family);
    }
  }
;
  job.schedule();
}",0.9979035639412998
91495,"private void waitForWorkspaceLock(){
  try {
    ResourcesPlugin.getWorkspace().run(new IWorkspaceRunnable(){
      public void run(      IProgressMonitor monitor) throws CoreException {
      }
    }
,new NullProgressMonitor());
  }
 catch (  CoreException e) {
    throw new RuntimeException(e);
  }
}","private void waitForWorkspaceLock(IProgressMonitor monitor){
  try {
    ResourcesPlugin.getWorkspace().run(new IWorkspaceRunnable(){
      public void run(      IProgressMonitor innerMonitor) throws CoreException {
      }
    }
,monitor);
  }
 catch (  OperationCanceledException e) {
    return;
  }
catch (  CoreException e) {
    throw new RuntimeException(e);
  }
}",0.7181008902077152
91496,"@BeforeClass public static void disableSecureStoragePasswordProviders(){
  List availableModules=PasswordProviderSelector.getInstance().findAvailableModules(null);
  StringBuffer tmp=new StringBuffer();
  for (  Object module : availableModules) {
    ExtStorageModule storageModule=(ExtStorageModule)module;
    tmp.append(storageModule.moduleID).append(""String_Node_Str"");
  }
  IEclipsePreferences node=ConfigurationScope.INSTANCE.getNode(""String_Node_Str"");
  node.put(IStorageConstants.DISABLED_PROVIDERS_KEY,tmp.toString());
}","@BeforeClass public static void disableSecureStoragePasswordProviders(){
  List availableModules=PasswordProviderSelector.getInstance().findAvailableModules(null);
  StringBuffer tmp=new StringBuffer();
  for (  Object module : availableModules) {
    ExtStorageModule storageModule=(ExtStorageModule)module;
    tmp.append(storageModule.moduleID).append(""String_Node_Str"");
  }
  IEclipsePreferences node=new ConfigurationScope().getNode(""String_Node_Str"");
  node.put(IStorageConstants.DISABLED_PROVIDERS_KEY,tmp.toString());
}",0.9858623939679548
91497,"@Override protected Control createCustomArea(Composite parent){
  if (result.getStatus() != Status.STOPPED) {
    createToggleButton(parent);
    return null;
  }
  Composite main=new Composite(parent,SWT.NONE);
  main.setLayout(new GridLayout(1,false));
  GridDataFactory.fillDefaults().indent(0,0).grab(true,true).applyTo(main);
  Group commitGroup=new Group(main,SWT.SHADOW_ETCHED_IN);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(commitGroup);
  commitGroup.setText(UIText.RebaseResultDialog_DetailsGroup);
  commitGroup.setLayout(new GridLayout(1,false));
  Label commitIdLabel=new Label(commitGroup,SWT.NONE);
  commitIdLabel.setText(UIText.RebaseResultDialog_CommitIdLabel);
  Text commitId=new Text(commitGroup,SWT.READ_ONLY | SWT.BORDER);
  GridDataFactory.fillDefaults().grab(true,false).applyTo(commitId);
  Label commitMessageLabel=new Label(commitGroup,SWT.NONE);
  commitMessageLabel.setText(UIText.RebaseResultDialog_CommitMessageLabel);
  TextViewer commitMessage=new TextViewer(commitGroup,SWT.H_SCROLL | SWT.V_SCROLL | SWT.MULTI| SWT.BORDER| SWT.READ_ONLY);
  GridDataFactory.fillDefaults().grab(true,true).hint(SWT.DEFAULT,60).applyTo(commitMessage.getControl());
  boolean conflictListFailure=false;
  DirCache dc=null;
  RevWalk rw=null;
  try {
    rw=new RevWalk(repo);
    RevCommit commit=rw.parseCommit(result.getCurrentCommit());
    commitMessage.getTextWidget().setText(commit.getFullMessage());
    commitId.setText(commit.name());
    dc=repo.lockDirCache();
    for (int i=0; i < dc.getEntryCount(); i++) {
      if (dc.getEntry(i).getStage() > 0)       conflictPaths.add(dc.getEntry(i).getPathString());
    }
    if (conflictPaths.size() > 0) {
      message=NLS.bind(UIText.RebaseResultDialog_Conflicting,Integer.valueOf(conflictPaths.size()));
      messageLabel.setText(message);
    }
  }
 catch (  IOException e) {
    conflictListFailure=true;
  }
 finally {
    if (rw != null)     rw.release();
    if (dc != null)     dc.unlock();
  }
  if (conflictListFailure) {
    Label failureLabel=new Label(main,SWT.NONE);
    failureLabel.setText(UIText.RebaseResultDialog_ConflictListFailureMessage);
  }
 else {
    Label conflictListLabel=new Label(main,SWT.NONE);
    conflictListLabel.setText(UIText.RebaseResultDialog_DiffDetailsLabel);
    TableViewer conflictList=new TableViewer(main,SWT.BORDER);
    GridDataFactory.fillDefaults().span(2,1).grab(true,true).applyTo(conflictList.getTable());
    conflictList.setContentProvider(ArrayContentProvider.getInstance());
    conflictList.setInput(conflictPaths);
  }
  Group actionGroup=new Group(main,SWT.SHADOW_ETCHED_IN);
  GridDataFactory.fillDefaults().grab(true,false).applyTo(actionGroup);
  actionGroup.setText(UIText.RebaseResultDialog_ActionGroupTitle);
  actionGroup.setLayout(new GridLayout(1,false));
  nextStepsGroup=new Group(main,SWT.SHADOW_ETCHED_IN);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(nextStepsGroup);
  nextStepsGroup.setText(UIText.RebaseResultDialog_NextSteps);
  nextStepsGroup.setLayout(new GridLayout(1,false));
  final TextViewer nextSteps=new TextViewer(nextStepsGroup,SWT.MULTI | SWT.BORDER | SWT.READ_ONLY);
  GridDataFactory.fillDefaults().grab(true,true).hint(SWT.DEFAULT,60).applyTo(nextSteps.getControl());
  nextSteps.getTextWidget().setText(UIText.RebaseResultDialog_NextStepsAfterResolveConflicts);
  startMergeButton=new Button(actionGroup,SWT.RADIO);
  startMergeButton.setText(UIText.RebaseResultDialog_StartMergeRadioText);
  startMergeButton.addSelectionListener(new SelectionListener(){
    public void widgetSelected(    SelectionEvent e){
      if (startMergeButton.getSelection()) {
        nextSteps.getTextWidget().setText(UIText.RebaseResultDialog_NextStepsAfterResolveConflicts);
      }
    }
    public void widgetDefaultSelected(    SelectionEvent e){
    }
  }
);
  skipCommitButton=new Button(actionGroup,SWT.RADIO);
  skipCommitButton.setText(UIText.RebaseResultDialog_SkipCommitButton);
  skipCommitButton.addSelectionListener(new SelectionListener(){
    public void widgetSelected(    SelectionEvent e){
      if (skipCommitButton.getSelection())       nextSteps.getTextWidget().setText(""String_Node_Str"");
    }
    public void widgetDefaultSelected(    SelectionEvent e){
    }
  }
);
  abortRebaseButton=new Button(actionGroup,SWT.RADIO);
  abortRebaseButton.setText(UIText.RebaseResultDialog_AbortRebaseRadioText);
  abortRebaseButton.addSelectionListener(new SelectionListener(){
    public void widgetSelected(    SelectionEvent e){
      if (abortRebaseButton.getSelection())       nextSteps.getTextWidget().setText(""String_Node_Str"");
    }
    public void widgetDefaultSelected(    SelectionEvent e){
    }
  }
);
  doNothingButton=new Button(actionGroup,SWT.RADIO);
  doNothingButton.setText(UIText.RebaseResultDialog_DoNothingRadioText);
  doNothingButton.addSelectionListener(new SelectionListener(){
    public void widgetSelected(    SelectionEvent e){
      if (doNothingButton.getSelection())       nextSteps.getTextWidget().setText(UIText.RebaseResultDialog_NextStepsDoNothing);
    }
    public void widgetDefaultSelected(    SelectionEvent e){
    }
  }
);
  startMergeButton.setSelection(true);
  commitGroup.pack();
  applyDialogFont(main);
  return main;
}","@Override protected Control createCustomArea(Composite parent){
  if (result.getStatus() != Status.STOPPED) {
    createToggleButton(parent);
    return null;
  }
  Composite main=new Composite(parent,SWT.NONE);
  main.setLayout(new GridLayout(1,false));
  GridDataFactory.fillDefaults().indent(0,0).grab(true,true).applyTo(main);
  Group commitGroup=new Group(main,SWT.SHADOW_ETCHED_IN);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(commitGroup);
  commitGroup.setText(UIText.RebaseResultDialog_DetailsGroup);
  commitGroup.setLayout(new GridLayout(1,false));
  Label commitIdLabel=new Label(commitGroup,SWT.NONE);
  commitIdLabel.setText(UIText.RebaseResultDialog_CommitIdLabel);
  Text commitId=new Text(commitGroup,SWT.READ_ONLY | SWT.BORDER);
  GridDataFactory.fillDefaults().grab(true,false).applyTo(commitId);
  Label commitMessageLabel=new Label(commitGroup,SWT.NONE);
  commitMessageLabel.setText(UIText.RebaseResultDialog_CommitMessageLabel);
  TextViewer commitMessage=new TextViewer(commitGroup,SWT.H_SCROLL | SWT.V_SCROLL | SWT.MULTI| SWT.BORDER| SWT.READ_ONLY);
  GridDataFactory.fillDefaults().grab(true,true).hint(SWT.DEFAULT,60).applyTo(commitMessage.getControl());
  boolean conflictListFailure=false;
  DirCache dc=null;
  RevWalk rw=null;
  try {
    rw=new RevWalk(repo);
    RevCommit commit=rw.parseCommit(result.getCurrentCommit());
    commitMessage.getTextWidget().setText(commit.getFullMessage());
    commitId.setText(commit.name());
    dc=repo.lockDirCache();
    for (int i=0; i < dc.getEntryCount(); i++) {
      if (dc.getEntry(i).getStage() > 0)       conflictPaths.add(dc.getEntry(i).getPathString());
    }
    if (conflictPaths.size() > 0) {
      message=NLS.bind(UIText.RebaseResultDialog_Conflicting,Integer.valueOf(conflictPaths.size()));
      messageLabel.setText(message);
    }
  }
 catch (  IOException e) {
    conflictListFailure=true;
  }
 finally {
    if (rw != null)     rw.release();
    if (dc != null)     dc.unlock();
  }
  boolean mergeToolAvailable=true;
  final CheckResult checkResult;
  if (!conflictListFailure) {
    checkResult=FileChecker.checkFiles(repo,conflictPaths);
    mergeToolAvailable=checkResult.isOk();
  }
 else {
    checkResult=null;
    mergeToolAvailable=false;
  }
  if (conflictListFailure) {
    Label failureLabel=new Label(main,SWT.NONE);
    failureLabel.setText(UIText.RebaseResultDialog_ConflictListFailureMessage);
  }
 else {
    if (checkResult != null && !checkResult.isOk()) {
      Label failureLabel=new Label(main,SWT.NONE);
      failureLabel.setText(getProblemDescription(checkResult));
    }
    Label conflictListLabel=new Label(main,SWT.NONE);
    conflictListLabel.setText(UIText.RebaseResultDialog_DiffDetailsLabel);
    TableViewer conflictList=new TableViewer(main,SWT.BORDER);
    GridDataFactory.fillDefaults().span(2,1).grab(true,true).applyTo(conflictList.getTable());
    conflictList.setContentProvider(ArrayContentProvider.getInstance());
    conflictList.setInput(conflictPaths);
    conflictList.setLabelProvider(new LabelProvider(){
      @Override public String getText(      Object element){
        String path=(String)element;
        if (checkResult != null && !checkResult.isOk()) {
          CheckResultEntry entry=checkResult.getEntry(path);
          if (entry != null) {
            if (!entry.inWorkspace)             return UIText.RebaseResultDialog_notInWorkspace + SPACE + path;
            if (!entry.shared)             return UIText.RebaseResultDialog_notShared + SPACE + path;
          }
        }
        return super.getText(element);
      }
    }
);
  }
  Group actionGroup=new Group(main,SWT.SHADOW_ETCHED_IN);
  GridDataFactory.fillDefaults().grab(true,false).applyTo(actionGroup);
  actionGroup.setText(UIText.RebaseResultDialog_ActionGroupTitle);
  actionGroup.setLayout(new GridLayout(1,false));
  nextStepsGroup=new Group(main,SWT.SHADOW_ETCHED_IN);
  GridDataFactory.fillDefaults().grab(true,true).applyTo(nextStepsGroup);
  nextStepsGroup.setText(UIText.RebaseResultDialog_NextSteps);
  nextStepsGroup.setLayout(new GridLayout(1,false));
  final TextViewer nextSteps=new TextViewer(nextStepsGroup,SWT.MULTI | SWT.BORDER | SWT.READ_ONLY);
  GridDataFactory.fillDefaults().grab(true,true).hint(SWT.DEFAULT,60).applyTo(nextSteps.getControl());
  nextSteps.getTextWidget().setText(UIText.RebaseResultDialog_NextStepsAfterResolveConflicts);
  startMergeButton=new Button(actionGroup,SWT.RADIO);
  startMergeButton.setText(UIText.RebaseResultDialog_StartMergeRadioText);
  startMergeButton.setEnabled(mergeToolAvailable);
  startMergeButton.addSelectionListener(new SelectionListener(){
    public void widgetSelected(    SelectionEvent e){
      if (startMergeButton.getSelection()) {
        nextSteps.getTextWidget().setText(UIText.RebaseResultDialog_NextStepsAfterResolveConflicts);
      }
    }
    public void widgetDefaultSelected(    SelectionEvent e){
    }
  }
);
  skipCommitButton=new Button(actionGroup,SWT.RADIO);
  skipCommitButton.setText(UIText.RebaseResultDialog_SkipCommitButton);
  skipCommitButton.addSelectionListener(new SelectionListener(){
    public void widgetSelected(    SelectionEvent e){
      if (skipCommitButton.getSelection())       nextSteps.getTextWidget().setText(""String_Node_Str"");
    }
    public void widgetDefaultSelected(    SelectionEvent e){
    }
  }
);
  abortRebaseButton=new Button(actionGroup,SWT.RADIO);
  abortRebaseButton.setText(UIText.RebaseResultDialog_AbortRebaseRadioText);
  abortRebaseButton.addSelectionListener(new SelectionListener(){
    public void widgetSelected(    SelectionEvent e){
      if (abortRebaseButton.getSelection())       nextSteps.getTextWidget().setText(""String_Node_Str"");
    }
    public void widgetDefaultSelected(    SelectionEvent e){
    }
  }
);
  doNothingButton=new Button(actionGroup,SWT.RADIO);
  doNothingButton.setText(UIText.RebaseResultDialog_DoNothingRadioText);
  doNothingButton.addSelectionListener(new SelectionListener(){
    public void widgetSelected(    SelectionEvent e){
      if (doNothingButton.getSelection())       nextSteps.getTextWidget().setText(UIText.RebaseResultDialog_NextStepsDoNothing);
    }
    public void widgetDefaultSelected(    SelectionEvent e){
    }
  }
);
  if (mergeToolAvailable)   startMergeButton.setSelection(true);
 else   doNothingButton.setSelection(true);
  commitGroup.pack();
  applyDialogFont(main);
  return main;
}",0.8975501113585747
91498,"/** 
 * Find directories containing .project files recursively starting at given directory
 * @param files
 * @param directory
 * @param visistedDirs
 * @param monitor
 * @return true if projects files found, false otherwise
 */
public static boolean findProjectFiles(final Collection<File> files,final File directory,final Set<String> visistedDirs,final IProgressMonitor monitor){
  if (directory == null)   return false;
  IProgressMonitor pm=monitor;
  if (pm == null)   pm=new NullProgressMonitor();
 else   if (pm.isCanceled())   return false;
  monitor.subTask(NLS.bind(CoreText.ProjectUtil_taskCheckingDirectory,directory.getPath()));
  final File[] contents=directory.listFiles();
  if (contents == null || contents.length == 0)   return false;
  Set<String> directoriesVisited;
  if (visistedDirs == null) {
    directoriesVisited=new HashSet<String>();
    try {
      directoriesVisited.add(directory.getCanonicalPath());
    }
 catch (    IOException exception) {
      Activator.logError(exception.getLocalizedMessage(),exception);
    }
  }
 else   directoriesVisited=visistedDirs;
  final String dotProject=IProjectDescription.DESCRIPTION_FILE_NAME;
  for (int i=0; i < contents.length; i++) {
    File file=contents[i];
    if (file.isFile() && file.getName().equals(dotProject)) {
      files.add(file);
      return true;
    }
  }
  for (int i=0; i < contents.length; i++) {
    if (!contents[i].isDirectory())     continue;
    if (contents[i].getName().equals(METADATA_FOLDER))     continue;
    try {
      String canonicalPath=contents[i].getCanonicalPath();
      if (!directoriesVisited.add(canonicalPath)) {
        continue;
      }
    }
 catch (    IOException exception) {
      Activator.logError(exception.getLocalizedMessage(),exception);
    }
    findProjectFiles(files,contents[i],directoriesVisited,pm);
  }
  return true;
}","/** 
 * Find directories containing .project files recursively starting at given directory
 * @param files
 * @param directory
 * @param visistedDirs
 * @param monitor
 * @return true if projects files found, false otherwise
 */
public static boolean findProjectFiles(final Collection<File> files,final File directory,final Set<String> visistedDirs,final IProgressMonitor monitor){
  if (directory == null)   return false;
  IProgressMonitor pm=monitor;
  if (pm == null)   pm=new NullProgressMonitor();
 else   if (pm.isCanceled())   return false;
  pm.subTask(NLS.bind(CoreText.ProjectUtil_taskCheckingDirectory,directory.getPath()));
  final File[] contents=directory.listFiles();
  if (contents == null || contents.length == 0)   return false;
  Set<String> directoriesVisited;
  if (visistedDirs == null) {
    directoriesVisited=new HashSet<String>();
    try {
      directoriesVisited.add(directory.getCanonicalPath());
    }
 catch (    IOException exception) {
      Activator.logError(exception.getLocalizedMessage(),exception);
    }
  }
 else   directoriesVisited=visistedDirs;
  final String dotProject=IProjectDescription.DESCRIPTION_FILE_NAME;
  for (int i=0; i < contents.length; i++) {
    File file=contents[i];
    if (file.isFile() && file.getName().equals(dotProject)) {
      files.add(file);
      return true;
    }
  }
  for (int i=0; i < contents.length; i++) {
    if (!contents[i].isDirectory())     continue;
    if (contents[i].getName().equals(METADATA_FOLDER))     continue;
    try {
      String canonicalPath=contents[i].getCanonicalPath();
      if (!directoriesVisited.add(canonicalPath)) {
        continue;
      }
    }
 catch (    IOException exception) {
      Activator.logError(exception.getLocalizedMessage(),exception);
    }
    findProjectFiles(files,contents[i],directoriesVisited,pm);
  }
  return true;
}",0.9981167608286252
91499,"/** 
 * Find directories containing .project files recursively starting at given directory
 * @param files
 * @param directory
 * @param visistedDirs
 * @param monitor
 * @return true if projects files found, false otherwise
 */
public static boolean findProjectFiles(final Collection<File> files,final File directory,final Set<String> visistedDirs,final IProgressMonitor monitor){
  IProgressMonitor pm=monitor;
  if (pm == null)   pm=new NullProgressMonitor();
 else   if (pm.isCanceled())   return false;
  monitor.subTask(NLS.bind(CoreText.ProjectUtil_taskCheckingDirectory,directory.getPath()));
  final File[] contents=directory.listFiles();
  if (contents == null || contents.length == 0)   return false;
  Set<String> directoriesVisited;
  if (visistedDirs == null) {
    directoriesVisited=new HashSet<String>();
    try {
      directoriesVisited.add(directory.getCanonicalPath());
    }
 catch (    IOException exception) {
      Activator.logError(exception.getLocalizedMessage(),exception);
    }
  }
 else   directoriesVisited=visistedDirs;
  final String dotProject=IProjectDescription.DESCRIPTION_FILE_NAME;
  for (int i=0; i < contents.length; i++) {
    File file=contents[i];
    if (file.isFile() && file.getName().equals(dotProject)) {
      files.add(file);
      return true;
    }
  }
  for (int i=0; i < contents.length; i++) {
    if (!contents[i].isDirectory())     continue;
    if (contents[i].getName().equals(METADATA_FOLDER))     continue;
    try {
      String canonicalPath=contents[i].getCanonicalPath();
      if (!directoriesVisited.add(canonicalPath)) {
        continue;
      }
    }
 catch (    IOException exception) {
      Activator.logError(exception.getLocalizedMessage(),exception);
    }
    findProjectFiles(files,contents[i],directoriesVisited,pm);
  }
  return true;
}","/** 
 * Find directories containing .project files recursively starting at given directory
 * @param files
 * @param directory
 * @param visistedDirs
 * @param monitor
 * @return true if projects files found, false otherwise
 */
public static boolean findProjectFiles(final Collection<File> files,final File directory,final Set<String> visistedDirs,final IProgressMonitor monitor){
  if (directory == null)   return false;
  IProgressMonitor pm=monitor;
  if (pm == null)   pm=new NullProgressMonitor();
 else   if (pm.isCanceled())   return false;
  monitor.subTask(NLS.bind(CoreText.ProjectUtil_taskCheckingDirectory,directory.getPath()));
  final File[] contents=directory.listFiles();
  if (contents == null || contents.length == 0)   return false;
  Set<String> directoriesVisited;
  if (visistedDirs == null) {
    directoriesVisited=new HashSet<String>();
    try {
      directoriesVisited.add(directory.getCanonicalPath());
    }
 catch (    IOException exception) {
      Activator.logError(exception.getLocalizedMessage(),exception);
    }
  }
 else   directoriesVisited=visistedDirs;
  final String dotProject=IProjectDescription.DESCRIPTION_FILE_NAME;
  for (int i=0; i < contents.length; i++) {
    File file=contents[i];
    if (file.isFile() && file.getName().equals(dotProject)) {
      files.add(file);
      return true;
    }
  }
  for (int i=0; i < contents.length; i++) {
    if (!contents[i].isDirectory())     continue;
    if (contents[i].getName().equals(METADATA_FOLDER))     continue;
    try {
      String canonicalPath=contents[i].getCanonicalPath();
      if (!directoriesVisited.add(canonicalPath)) {
        continue;
      }
    }
 catch (    IOException exception) {
      Activator.logError(exception.getLocalizedMessage(),exception);
    }
    findProjectFiles(files,contents[i],directoriesVisited,pm);
  }
  return true;
}",0.9888617223580548
91500,"/** 
 * Find directories containing .project files recursively starting at given directory
 * @param files
 * @param directory
 * @param visistedDirs
 * @param monitor
 * @return true if projects files found, false otherwise
 */
public static boolean findProjectFiles(final Collection<File> files,final File directory,final Set<String> visistedDirs,final IProgressMonitor monitor){
  if (directory == null)   return false;
  IProgressMonitor pm=monitor;
  if (pm == null)   pm=new NullProgressMonitor();
 else   if (pm.isCanceled())   return false;
  monitor.subTask(NLS.bind(CoreText.ProjectUtil_taskCheckingDirectory,directory.getPath()));
  final File[] contents=directory.listFiles();
  if (contents == null || contents.length == 0)   return false;
  Set<String> directoriesVisited;
  if (visistedDirs == null) {
    directoriesVisited=new HashSet<String>();
    try {
      directoriesVisited.add(directory.getCanonicalPath());
    }
 catch (    IOException exception) {
      Activator.logError(exception.getLocalizedMessage(),exception);
    }
  }
 else   directoriesVisited=visistedDirs;
  final String dotProject=IProjectDescription.DESCRIPTION_FILE_NAME;
  for (int i=0; i < contents.length; i++) {
    File file=contents[i];
    if (file.isFile() && file.getName().equals(dotProject)) {
      files.add(file);
      return true;
    }
  }
  for (int i=0; i < contents.length; i++) {
    if (!contents[i].isDirectory())     continue;
    if (contents[i].getName().equals(METADATA_FOLDER))     continue;
    try {
      String canonicalPath=contents[i].getCanonicalPath();
      if (!directoriesVisited.add(canonicalPath)) {
        continue;
      }
    }
 catch (    IOException exception) {
      Activator.logError(exception.getLocalizedMessage(),exception);
    }
    findProjectFiles(files,contents[i],directoriesVisited,pm);
  }
  return true;
}","/** 
 * Find directories containing .project files recursively starting at given directory
 * @param files
 * @param directory
 * @param visistedDirs
 * @param monitor
 * @return true if projects files found, false otherwise
 */
public static boolean findProjectFiles(final Collection<File> files,final File directory,final Set<String> visistedDirs,final IProgressMonitor monitor){
  if (directory == null)   return false;
  IProgressMonitor pm=monitor;
  if (pm == null)   pm=new NullProgressMonitor();
 else   if (pm.isCanceled())   return false;
  pm.subTask(NLS.bind(CoreText.ProjectUtil_taskCheckingDirectory,directory.getPath()));
  final File[] contents=directory.listFiles();
  if (contents == null || contents.length == 0)   return false;
  Set<String> directoriesVisited;
  if (visistedDirs == null) {
    directoriesVisited=new HashSet<String>();
    try {
      directoriesVisited.add(directory.getCanonicalPath());
    }
 catch (    IOException exception) {
      Activator.logError(exception.getLocalizedMessage(),exception);
    }
  }
 else   directoriesVisited=visistedDirs;
  final String dotProject=IProjectDescription.DESCRIPTION_FILE_NAME;
  for (int i=0; i < contents.length; i++) {
    File file=contents[i];
    if (file.isFile() && file.getName().equals(dotProject)) {
      files.add(file);
      return true;
    }
  }
  for (int i=0; i < contents.length; i++) {
    if (!contents[i].isDirectory())     continue;
    if (contents[i].getName().equals(METADATA_FOLDER))     continue;
    try {
      String canonicalPath=contents[i].getCanonicalPath();
      if (!directoriesVisited.add(canonicalPath)) {
        continue;
      }
    }
 catch (    IOException exception) {
      Activator.logError(exception.getLocalizedMessage(),exception);
    }
    findProjectFiles(files,contents[i],directoriesVisited,pm);
  }
  return true;
}",0.9981167608286252
91501,"/** 
 * Find directories containing .project files recursively starting at given directory
 * @param files
 * @param directory
 * @param visistedDirs
 * @param monitor
 * @return true if projects files found, false otherwise
 */
public static boolean findProjectFiles(final Collection<File> files,final File directory,final Set<String> visistedDirs,final IProgressMonitor monitor){
  IProgressMonitor pm=monitor;
  if (pm == null)   pm=new NullProgressMonitor();
 else   if (pm.isCanceled())   return false;
  monitor.subTask(NLS.bind(CoreText.ProjectUtil_taskCheckingDirectory,directory.getPath()));
  final File[] contents=directory.listFiles();
  if (contents == null || contents.length == 0)   return false;
  Set<String> directoriesVisited;
  if (visistedDirs == null) {
    directoriesVisited=new HashSet<String>();
    try {
      directoriesVisited.add(directory.getCanonicalPath());
    }
 catch (    IOException exception) {
      Activator.logError(exception.getLocalizedMessage(),exception);
    }
  }
 else   directoriesVisited=visistedDirs;
  final String dotProject=IProjectDescription.DESCRIPTION_FILE_NAME;
  for (int i=0; i < contents.length; i++) {
    File file=contents[i];
    if (file.isFile() && file.getName().equals(dotProject)) {
      files.add(file);
      return true;
    }
  }
  for (int i=0; i < contents.length; i++) {
    if (!contents[i].isDirectory())     continue;
    if (contents[i].getName().equals(METADATA_FOLDER))     continue;
    try {
      String canonicalPath=contents[i].getCanonicalPath();
      if (!directoriesVisited.add(canonicalPath)) {
        continue;
      }
    }
 catch (    IOException exception) {
      Activator.logError(exception.getLocalizedMessage(),exception);
    }
    findProjectFiles(files,contents[i],directoriesVisited,pm);
  }
  return true;
}","/** 
 * Find directories containing .project files recursively starting at given directory
 * @param files
 * @param directory
 * @param visistedDirs
 * @param monitor
 * @return true if projects files found, false otherwise
 */
public static boolean findProjectFiles(final Collection<File> files,final File directory,final Set<String> visistedDirs,final IProgressMonitor monitor){
  if (directory == null)   return false;
  IProgressMonitor pm=monitor;
  if (pm == null)   pm=new NullProgressMonitor();
 else   if (pm.isCanceled())   return false;
  monitor.subTask(NLS.bind(CoreText.ProjectUtil_taskCheckingDirectory,directory.getPath()));
  final File[] contents=directory.listFiles();
  if (contents == null || contents.length == 0)   return false;
  Set<String> directoriesVisited;
  if (visistedDirs == null) {
    directoriesVisited=new HashSet<String>();
    try {
      directoriesVisited.add(directory.getCanonicalPath());
    }
 catch (    IOException exception) {
      Activator.logError(exception.getLocalizedMessage(),exception);
    }
  }
 else   directoriesVisited=visistedDirs;
  final String dotProject=IProjectDescription.DESCRIPTION_FILE_NAME;
  for (int i=0; i < contents.length; i++) {
    File file=contents[i];
    if (file.isFile() && file.getName().equals(dotProject)) {
      files.add(file);
      return true;
    }
  }
  for (int i=0; i < contents.length; i++) {
    if (!contents[i].isDirectory())     continue;
    if (contents[i].getName().equals(METADATA_FOLDER))     continue;
    try {
      String canonicalPath=contents[i].getCanonicalPath();
      if (!directoriesVisited.add(canonicalPath)) {
        continue;
      }
    }
 catch (    IOException exception) {
      Activator.logError(exception.getLocalizedMessage(),exception);
    }
    findProjectFiles(files,contents[i],directoriesVisited,pm);
  }
  return true;
}",0.9888617223580548
91502,"/** 
 * Creates a wizard which is used to export the changes introduced by a commit.
 * @param commit
 * @param db
 */
public GitCreatePatchWizard(RevCommit commit,Repository db){
  this.commit=commit;
  this.db=db;
  setDialogSettings(DialogSettings.getOrCreateSection(Activator.getDefault().getDialogSettings(),""String_Node_Str""));
}","/** 
 * Creates a wizard which is used to export the changes introduced by a commit.
 * @param commit
 * @param db
 */
public GitCreatePatchWizard(RevCommit commit,Repository db){
  this.commit=commit;
  this.db=db;
  setDialogSettings(getOrCreateSection(Activator.getDefault().getDialogSettings(),""String_Node_Str""));
}",0.9770992366412212
91503,"private void reactOnSelection(ISelection selection){
  if (selection instanceof StructuredSelection) {
    StructuredSelection ssel=(StructuredSelection)selection;
    if (ssel.size() != 1)     return;
    if (ssel.getFirstElement() instanceof IResource)     showResource((IResource)ssel.getFirstElement());
    if (ssel.getFirstElement() instanceof IAdaptable) {
      IResource adapted=(IResource)((IAdaptable)ssel.getFirstElement()).getAdapter(IResource.class);
      if (adapted != null)       showResource(adapted);
    }
 else     if (ssel.getFirstElement() instanceof RepositoryTreeNode) {
      RepositoryTreeNode repoNode=(RepositoryTreeNode)ssel.getFirstElement();
      reload(repoNode.getRepository());
    }
  }
}","private void reactOnSelection(ISelection selection){
  if (selection instanceof StructuredSelection) {
    StructuredSelection ssel=(StructuredSelection)selection;
    if (ssel.size() != 1)     return;
    Object firstElement=ssel.getFirstElement();
    if (firstElement instanceof IResource)     showResource((IResource)firstElement);
 else     if (firstElement instanceof RepositoryTreeNode) {
      RepositoryTreeNode repoNode=(RepositoryTreeNode)firstElement;
      reload(repoNode.getRepository());
    }
 else     if (firstElement instanceof IAdaptable) {
      IResource adapted=(IResource)((IAdaptable)firstElement).getAdapter(IResource.class);
      if (adapted != null)       showResource(adapted);
    }
  }
}",0.5408022130013831
91504,"GitFileHistory(final IResource rsrc,final int flags,final IProgressMonitor monitor){
  resource=rsrc;
  final RepositoryMapping rm=RepositoryMapping.getMapping(resource);
  if (rm == null) {
    Activator.logError(NLS.bind(CoreText.GitFileHistory_gitNotAttached,resource.getProject().getName()),null);
    db=null;
    walk=null;
  }
 else {
    db=rm.getRepository();
    walk=new KidWalk(db);
    gitPath=rm.getRepoRelativePath(resource);
    walk.setTreeFilter(AndTreeFilter.create(PathFilterGroup.createFromStrings(Collections.singleton(gitPath)),TreeFilter.ANY_DIFF));
  }
  revisions=buildRevisions(monitor,flags);
}","GitFileHistory(final IResource rsrc,final int flags,final IProgressMonitor monitor){
  resource=rsrc;
  final RepositoryMapping rm=RepositoryMapping.getMapping(resource);
  if (rm == null) {
    Activator.logError(NLS.bind(CoreText.GitFileHistory_gitNotAttached,resource.getProject().getName()),null);
    db=null;
    walk=null;
  }
 else {
    db=rm.getRepository();
    walk=new KidWalk(db);
    gitPath=rm.getRepoRelativePath(resource);
    if (gitPath == null || gitPath.isEmpty()) {
      walk.setTreeFilter(TreeFilter.ANY_DIFF);
    }
 else {
      walk.setTreeFilter(AndTreeFilter.create(PathFilterGroup.createFromStrings(Collections.singleton(gitPath)),TreeFilter.ANY_DIFF));
    }
  }
  revisions=buildRevisions(monitor,flags);
}",0.7832476120499633
91505,"private ITypedElement getHeadTypedElement(final IFile baseFile) throws IOException {
  final RepositoryMapping mapping=RepositoryMapping.getMapping(baseFile.getProject());
  final Repository repository=mapping.getRepository();
  final String gitPath=mapping.getRepoRelativePath(baseFile);
  DirCache dc=repository.lockDirCache();
  final DirCacheEntry entry=dc.getEntry(gitPath);
  dc.unlock();
  if (entry == null) {
    return new GitCompareFileRevisionEditorInput.EmptyTypedElement(NLS.bind(UIText.CompareWithIndexAction_FileNotInIndex,baseFile.getName()));
  }
  IFileRevision nextFile=GitFileRevision.inIndex(repository,gitPath);
  String encoding=CompareUtils.getResourceEncoding(baseFile);
  final EditableRevision next=new EditableRevision(nextFile,encoding);
  IContentChangeListener listener=new IContentChangeListener(){
    public void contentChanged(    IContentChangeNotifier source){
      final byte[] newContent=next.getModifiedContent();
      DirCache cache=null;
      try {
        cache=repository.lockDirCache();
        DirCacheEditor editor=cache.editor();
        editor.add(new PathEdit(gitPath){
          @Override public void apply(          DirCacheEntry ent){
            ent.copyMetaData(entry);
            ObjectInserter inserter=repository.newObjectInserter();
            ent.copyMetaData(entry);
            ent.setLength(newContent.length);
            ent.setLastModified(System.currentTimeMillis());
            InputStream in=new ByteArrayInputStream(newContent);
            try {
              ent.setObjectId(inserter.insert(Constants.OBJ_BLOB,newContent.length,in));
              inserter.flush();
            }
 catch (            IOException ex) {
              throw new RuntimeException(ex);
            }
 finally {
              try {
                in.close();
              }
 catch (              IOException e) {
              }
            }
          }
        }
);
        try {
          editor.commit();
        }
 catch (        RuntimeException e) {
          if (e.getCause() instanceof IOException)           throw (IOException)e.getCause();
 else           throw e;
        }
      }
 catch (      IOException e) {
        Activator.handleError(UIText.CompareWithIndexAction_errorOnAddToIndex,e,true);
      }
 finally {
        if (cache != null)         cache.unlock();
      }
    }
  }
;
  next.addContentChangeListener(listener);
  return next;
}","private ITypedElement getHeadTypedElement(final IFile baseFile) throws IOException {
  final RepositoryMapping mapping=RepositoryMapping.getMapping(baseFile.getProject());
  final Repository repository=mapping.getRepository();
  final String gitPath=mapping.getRepoRelativePath(baseFile);
  DirCache dc=repository.lockDirCache();
  final DirCacheEntry entry=dc.getEntry(gitPath);
  dc.unlock();
  if (entry == null) {
    return new GitCompareFileRevisionEditorInput.EmptyTypedElement(NLS.bind(UIText.CompareWithIndexAction_FileNotInIndex,baseFile.getName()));
  }
  IFileRevision nextFile=GitFileRevision.inIndex(repository,gitPath);
  String encoding=CompareCoreUtils.getResourceEncoding(baseFile);
  final EditableRevision next=new EditableRevision(nextFile,encoding);
  IContentChangeListener listener=new IContentChangeListener(){
    public void contentChanged(    IContentChangeNotifier source){
      final byte[] newContent=next.getModifiedContent();
      DirCache cache=null;
      try {
        cache=repository.lockDirCache();
        DirCacheEditor editor=cache.editor();
        editor.add(new PathEdit(gitPath){
          @Override public void apply(          DirCacheEntry ent){
            ent.copyMetaData(entry);
            ObjectInserter inserter=repository.newObjectInserter();
            ent.copyMetaData(entry);
            ent.setLength(newContent.length);
            ent.setLastModified(System.currentTimeMillis());
            InputStream in=new ByteArrayInputStream(newContent);
            try {
              ent.setObjectId(inserter.insert(Constants.OBJ_BLOB,newContent.length,in));
              inserter.flush();
            }
 catch (            IOException ex) {
              throw new RuntimeException(ex);
            }
 finally {
              try {
                in.close();
              }
 catch (              IOException e) {
              }
            }
          }
        }
);
        try {
          editor.commit();
        }
 catch (        RuntimeException e) {
          if (e.getCause() instanceof IOException)           throw (IOException)e.getCause();
 else           throw e;
        }
      }
 catch (      IOException e) {
        Activator.handleError(UIText.CompareWithIndexAction_errorOnAddToIndex,e,true);
      }
 finally {
        if (cache != null)         cache.unlock();
      }
    }
  }
;
  next.addContentChangeListener(listener);
  return next;
}",0.9991738950846758
91506,"public boolean moveFolder(final IResourceTree tree,final IFolder srcf,final IFolder dstf,final int updateFlags,final IProgressMonitor monitor){
  final boolean force=(updateFlags & IResource.FORCE) == IResource.FORCE;
  if (!force && !tree.isSynchronized(srcf,IResource.DEPTH_ZERO))   return false;
  final RepositoryMapping srcm=RepositoryMapping.getMapping(srcf);
  if (srcm == null)   return false;
  final RepositoryMapping dstm=RepositoryMapping.getMapping(dstf);
  try {
    final String sPath=srcm.getRepoRelativePath(srcf);
    if (dstm != null && dstm.getRepository() == srcm.getRepository()) {
      final String dPath=srcm.getRepoRelativePath(dstf) + ""String_Node_Str"";
      MoveResult result=moveIndexContent(dPath,srcm,sPath);
switch (result) {
case SUCCESS:
        break;
case FAILED:
      tree.failed(new Status(IStatus.ERROR,Activator.getPluginId(),0,CoreText.MoveDeleteHook_operationError,null));
    break;
case UNTRACKED:
  return FINISH_FOR_ME;
}
tree.standardMoveFolder(srcf,dstf,updateFlags,monitor);
}
}
 catch (IOException e) {
tree.failed(new Status(IStatus.ERROR,Activator.getPluginId(),0,CoreText.MoveDeleteHook_operationError,e));
}
return true;
}","public boolean moveFolder(final IResourceTree tree,final IFolder srcf,final IFolder dstf,final int updateFlags,final IProgressMonitor monitor){
  final boolean force=(updateFlags & IResource.FORCE) == IResource.FORCE;
  if (!force && !tree.isSynchronized(srcf,IResource.DEPTH_ZERO))   return false;
  final RepositoryMapping srcm=RepositoryMapping.getMapping(srcf);
  if (srcm == null)   return false;
  final RepositoryMapping dstm=RepositoryMapping.getMapping(dstf);
  try {
    final String sPath=srcm.getRepoRelativePath(srcf);
    if (dstm != null && dstm.getRepository() == srcm.getRepository()) {
      final String dPath=srcm.getRepoRelativePath(dstf) + ""String_Node_Str"";
      MoveResult result=moveIndexContent(dPath,srcm,sPath);
switch (result) {
case SUCCESS:
        break;
case FAILED:
      tree.failed(new Status(IStatus.ERROR,Activator.getPluginId(),0,CoreText.MoveDeleteHook_operationError,null));
    return I_AM_DONE;
case UNTRACKED:
  return FINISH_FOR_ME;
}
}
tree.standardMoveFolder(srcf,dstf,updateFlags,monitor);
}
 catch (IOException e) {
tree.failed(new Status(IStatus.ERROR,Activator.getPluginId(),0,CoreText.MoveDeleteHook_operationError,e));
}
return true;
}",0.9894381073088298
91507,"@Override public IProject[] addToWorkspace(final String[] referenceStrings,final ProjectSetSerializationContext context,final IProgressMonitor monitor) throws TeamException {
  final Map<URIish,Map<String,Set<ProjectReference>>> repositories=new LinkedHashMap<URIish,Map<String,Set<ProjectReference>>>();
  for (  final String reference : referenceStrings) {
    try {
      final ProjectReference projectReference=new ProjectReference(reference);
      Map<String,Set<ProjectReference>> repositoryBranches=repositories.get(projectReference.repository);
      if (repositoryBranches == null) {
        repositoryBranches=new HashMap<String,Set<ProjectReference>>();
        repositories.put(projectReference.repository,repositoryBranches);
      }
      Set<ProjectReference> projectReferences=repositoryBranches.get(projectReference.branch);
      if (projectReferences == null) {
        projectReferences=new TreeSet<ProjectReference>(new ProjectReferenceComparator());
        repositoryBranches.put(projectReference.branch,projectReferences);
      }
      projectReferences.add(projectReference);
    }
 catch (    final IllegalArgumentException e) {
      throw new TeamException(reference,e);
    }
catch (    final URISyntaxException e) {
      throw new TeamException(reference,e);
    }
  }
  final ArrayList<IProject> importedProjects=new ArrayList<IProject>();
  for (  final URIish gitUrl : repositories.keySet()) {
    Map<String,Set<ProjectReference>> branches=repositories.get(gitUrl);
    for (    final String branch : branches.keySet()) {
      final Set<ProjectReference> projects=branches.get(branch);
      try {
        final IPath workDir=getWorkingDir(gitUrl,branch,branches.keySet());
        if (workDir.toFile().exists()) {
          final Collection<String> projectNames=new LinkedList<String>();
          for (          final ProjectReference projectReference : projects)           projectNames.add(projectReference.projectDir);
          throw new TeamException(NLS.bind(CoreText.GitProjectSetCapability_CloneToExistingDirectory,new Object[]{workDir,projectNames,gitUrl}));
        }
        int timeout=60;
        String refName=Constants.R_HEADS + branch;
        final CloneOperation cloneOperation=new CloneOperation(gitUrl,true,null,workDir.toFile(),refName,Constants.DEFAULT_REMOTE_NAME,timeout);
        cloneOperation.run(monitor);
        final File repositoryPath=workDir.append(Constants.DOT_GIT_EXT).toFile();
        Activator.getDefault().getRepositoryUtil().addConfiguredRepository(repositoryPath);
        final IWorkspace workspace=ResourcesPlugin.getWorkspace();
        final IWorkspaceRoot root=workspace.getRoot();
        for (        final ProjectReference projectToImport : projects) {
          final IPath projectDir=workDir.append(projectToImport.projectDir);
          final IProjectDescription projectDescription=workspace.loadProjectDescription(projectDir.append(IProjectDescription.DESCRIPTION_FILE_NAME));
          final IProject project=root.getProject(projectDescription.getName());
          project.create(projectDescription,monitor);
          importedProjects.add(project);
          project.open(monitor);
          final ConnectProviderOperation connectProviderOperation=new ConnectProviderOperation(project,repositoryPath);
          connectProviderOperation.execute(monitor);
        }
      }
 catch (      final InvocationTargetException e) {
        throw TeamException.asTeamException(e);
      }
catch (      final CoreException e) {
        throw TeamException.asTeamException(e);
      }
catch (      final InterruptedException e) {
        return new IProject[0];
      }
    }
  }
  final IProject[] result=importedProjects.toArray(new IProject[importedProjects.size()]);
  return result;
}","@Override public IProject[] addToWorkspace(final String[] referenceStrings,final ProjectSetSerializationContext context,final IProgressMonitor monitor) throws TeamException {
  final Map<URIish,Map<String,Set<ProjectReference>>> repositories=new LinkedHashMap<URIish,Map<String,Set<ProjectReference>>>();
  for (  final String reference : referenceStrings) {
    try {
      final ProjectReference projectReference=new ProjectReference(reference);
      Map<String,Set<ProjectReference>> repositoryBranches=repositories.get(projectReference.repository);
      if (repositoryBranches == null) {
        repositoryBranches=new HashMap<String,Set<ProjectReference>>();
        repositories.put(projectReference.repository,repositoryBranches);
      }
      Set<ProjectReference> projectReferences=repositoryBranches.get(projectReference.branch);
      if (projectReferences == null) {
        projectReferences=new TreeSet<ProjectReference>(new ProjectReferenceComparator());
        repositoryBranches.put(projectReference.branch,projectReferences);
      }
      projectReferences.add(projectReference);
    }
 catch (    final IllegalArgumentException e) {
      throw new TeamException(reference,e);
    }
catch (    final URISyntaxException e) {
      throw new TeamException(reference,e);
    }
  }
  final ArrayList<IProject> importedProjects=new ArrayList<IProject>();
  for (  final Map.Entry<URIish,Map<String,Set<ProjectReference>>> entry : repositories.entrySet()) {
    final URIish gitUrl=entry.getKey();
    final Map<String,Set<ProjectReference>> branches=entry.getValue();
    for (    final Map.Entry<String,Set<ProjectReference>> branchEntry : branches.entrySet()) {
      final String branch=branchEntry.getKey();
      final Set<ProjectReference> projects=branchEntry.getValue();
      try {
        final IPath workDir=getWorkingDir(gitUrl,branch,branches.keySet());
        if (workDir.toFile().exists()) {
          final Collection<String> projectNames=new LinkedList<String>();
          for (          final ProjectReference projectReference : projects)           projectNames.add(projectReference.projectDir);
          throw new TeamException(NLS.bind(CoreText.GitProjectSetCapability_CloneToExistingDirectory,new Object[]{workDir,projectNames,gitUrl}));
        }
        int timeout=60;
        String refName=Constants.R_HEADS + branch;
        final CloneOperation cloneOperation=new CloneOperation(gitUrl,true,null,workDir.toFile(),refName,Constants.DEFAULT_REMOTE_NAME,timeout);
        cloneOperation.run(monitor);
        final File repositoryPath=workDir.append(Constants.DOT_GIT_EXT).toFile();
        Activator.getDefault().getRepositoryUtil().addConfiguredRepository(repositoryPath);
        final IWorkspace workspace=ResourcesPlugin.getWorkspace();
        final IWorkspaceRoot root=workspace.getRoot();
        for (        final ProjectReference projectToImport : projects) {
          final IPath projectDir=workDir.append(projectToImport.projectDir);
          final IProjectDescription projectDescription=workspace.loadProjectDescription(projectDir.append(IProjectDescription.DESCRIPTION_FILE_NAME));
          final IProject project=root.getProject(projectDescription.getName());
          project.create(projectDescription,monitor);
          importedProjects.add(project);
          project.open(monitor);
          final ConnectProviderOperation connectProviderOperation=new ConnectProviderOperation(project,repositoryPath);
          connectProviderOperation.execute(monitor);
        }
      }
 catch (      final InvocationTargetException e) {
        throw TeamException.asTeamException(e);
      }
catch (      final CoreException e) {
        throw TeamException.asTeamException(e);
      }
catch (      final InterruptedException e) {
        return new IProject[0];
      }
    }
  }
  final IProject[] result=importedProjects.toArray(new IProject[importedProjects.size()]);
  return result;
}",0.9417551126067822
91508,"@SuppressWarnings(""String_Node_Str"") ProjectReference(final String reference) throws URISyntaxException, IllegalArgumentException {
  final String[] tokens=reference.split(Pattern.quote(SEPARATOR));
  if (tokens.length != 4)   throw new IllegalArgumentException(NLS.bind(CoreText.GitProjectSetCapability_InvalidTokensCount,new Object[]{4,tokens.length,tokens}));
  this.version=tokens[0];
  this.repository=new URIish(tokens[1]);
  if (!""String_Node_Str"".equals(tokens[2]))   this.branch=tokens[2];
  this.projectDir=tokens[3];
}","@SuppressWarnings(""String_Node_Str"") ProjectReference(final String reference) throws URISyntaxException, IllegalArgumentException {
  final String[] tokens=reference.split(Pattern.quote(SEPARATOR));
  if (tokens.length != 4)   throw new IllegalArgumentException(NLS.bind(CoreText.GitProjectSetCapability_InvalidTokensCount,new Object[]{4,tokens.length,tokens}));
  this.repository=new URIish(tokens[1]);
  if (!""String_Node_Str"".equals(tokens[2]))   this.branch=tokens[2];
  this.projectDir=tokens[3];
}",0.9748062015503876
91509,"/** 
 * Get styled text
 * @return styled string
 */
public StyledString getStyledText(Object object){
  StyledString styled=new StyledString();
  final String remote=getDstRefName();
  final String local=getSrcRefName();
  styled.append(shortenRef(remote));
  if (!tag) {
    styled.append(""String_Node_Str"",StyledString.QUALIFIER_STYLER);
    styled.append(shortenRef(local),StyledString.QUALIFIER_STYLER);
  }
  styled.append(' ');
  if (result.getURIs().size() > 1)   styled.append(MessageFormat.format(UIText.RefUpdateElement_UrisDecoration,uri.toString()),StyledString.QUALIFIER_STYLER);
  styled.append(' ');
switch (getStatus()) {
case OK:
    if (update.isDelete())     styled.append(UIText.PushResultTable_statusOkDeleted,StyledString.DECORATIONS_STYLER);
 else {
      final Ref oldRef=getAdvertisedRemoteRef();
      if (oldRef == null) {
        if (tag)         styled.append(UIText.PushResultTable_statusOkNewTag,StyledString.DECORATIONS_STYLER);
 else         styled.append(UIText.PushResultTable_statusOkNewBranch,StyledString.DECORATIONS_STYLER);
      }
 else {
        String separator=update.isFastForward() ? ""String_Node_Str"" : ""String_Node_Str"";
        styled.append(MessageFormat.format(UIText.RefUpdateElement_CommitRangeDecoration,update.getNewObjectId().abbreviate(7).name(),separator,oldRef.getObjectId().abbreviate(7).name()),StyledString.DECORATIONS_STYLER);
        styled.append(' ');
        styled.append(MessageFormat.format(UIText.RefUpdateElement_CommitCountDecoration,Integer.valueOf(getChildren(this).length)),StyledString.COUNTER_STYLER);
      }
    }
  break;
case UP_TO_DATE:
styled.append(UIText.PushResultTable_statusUpToDate,StyledString.DECORATIONS_STYLER);
break;
case NON_EXISTING:
styled.append(UIText.PushResultTable_statusNoMatch,StyledString.DECORATIONS_STYLER);
break;
case REJECTED_NODELETE:
case REJECTED_NONFASTFORWARD:
case REJECTED_REMOTE_CHANGED:
styled.append(UIText.PushResultTable_statusRejected,StyledString.DECORATIONS_STYLER);
break;
case REJECTED_OTHER_REASON:
styled.append(UIText.PushResultTable_statusRemoteRejected,StyledString.DECORATIONS_STYLER);
break;
default :
break;
}
return styled;
}","/** 
 * Get styled text
 * @param object
 * @return styled string
 */
public StyledString getStyledText(Object object){
  StyledString styled=new StyledString();
  final String remote=getDstRefName();
  final String local=getSrcRefName();
  styled.append(shortenRef(remote));
  if (!tag) {
    styled.append(""String_Node_Str"",StyledString.QUALIFIER_STYLER);
    styled.append(shortenRef(local),StyledString.QUALIFIER_STYLER);
  }
  styled.append(' ');
  if (result.getURIs().size() > 1)   styled.append(MessageFormat.format(UIText.RefUpdateElement_UrisDecoration,uri.toString()),StyledString.QUALIFIER_STYLER);
  styled.append(' ');
switch (getStatus()) {
case OK:
    if (update.isDelete())     styled.append(UIText.PushResultTable_statusOkDeleted,StyledString.DECORATIONS_STYLER);
 else {
      final Ref oldRef=getAdvertisedRemoteRef();
      if (oldRef == null) {
        if (tag)         styled.append(UIText.PushResultTable_statusOkNewTag,StyledString.DECORATIONS_STYLER);
 else         styled.append(UIText.PushResultTable_statusOkNewBranch,StyledString.DECORATIONS_STYLER);
      }
 else {
        String separator=update.isFastForward() ? ""String_Node_Str"" : ""String_Node_Str"";
        styled.append(MessageFormat.format(UIText.RefUpdateElement_CommitRangeDecoration,update.getNewObjectId().abbreviate(7).name(),separator,oldRef.getObjectId().abbreviate(7).name()),StyledString.DECORATIONS_STYLER);
        styled.append(' ');
        styled.append(MessageFormat.format(UIText.RefUpdateElement_CommitCountDecoration,Integer.valueOf(getChildren(this).length)),StyledString.COUNTER_STYLER);
      }
    }
  break;
case UP_TO_DATE:
styled.append(UIText.PushResultTable_statusUpToDate,StyledString.DECORATIONS_STYLER);
break;
case NON_EXISTING:
styled.append(UIText.PushResultTable_statusNoMatch,StyledString.DECORATIONS_STYLER);
break;
case REJECTED_NODELETE:
case REJECTED_NONFASTFORWARD:
case REJECTED_REMOTE_CHANGED:
styled.append(UIText.PushResultTable_statusRejected,StyledString.DECORATIONS_STYLER);
break;
case REJECTED_OTHER_REASON:
styled.append(UIText.PushResultTable_statusRemoteRejected,StyledString.DECORATIONS_STYLER);
break;
default :
break;
}
return styled;
}",0.9960874568469504
91510,"/** 
 * Get styled text
 * @return styled string
 */
public StyledString getStyledText(Object object){
  StyledString styled=new StyledString();
  final String remote=getDstRefName();
  final String local=getSrcRefName();
  styled.append(shortenRef(remote));
  if (!tag) {
    styled.append(""String_Node_Str"",StyledString.QUALIFIER_STYLER);
    styled.append(shortenRef(local),StyledString.QUALIFIER_STYLER);
  }
  styled.append(' ');
  if (result.getURIs().size() > 1)   styled.append(MessageFormat.format(UIText.RefUpdateElement_UrisDecoration,uri.toString()),StyledString.QUALIFIER_STYLER);
  styled.append(' ');
switch (getStatus()) {
case OK:
    if (update.isDelete())     styled.append(UIText.PushResultTable_statusOkDeleted,StyledString.DECORATIONS_STYLER);
 else {
      final Ref oldRef=getAdvertisedRemoteRef();
      if (oldRef == null) {
        if (tag)         styled.append(UIText.PushResultTable_statusOkNewTag,StyledString.DECORATIONS_STYLER);
 else         styled.append(UIText.PushResultTable_statusOkNewBranch,StyledString.DECORATIONS_STYLER);
      }
 else {
        String separator=update.isFastForward() ? ""String_Node_Str"" : ""String_Node_Str"";
        styled.append(MessageFormat.format(UIText.RefUpdateElement_CommitRangeDecoration,update.getNewObjectId().abbreviate(7).name(),separator,oldRef.getObjectId().abbreviate(7).name()),StyledString.DECORATIONS_STYLER);
        styled.append(' ');
        styled.append(MessageFormat.format(UIText.RefUpdateElement_CommitCountDecoration,Integer.valueOf(getChildren(this).length)),StyledString.COUNTER_STYLER);
      }
    }
  break;
case UP_TO_DATE:
styled.append(UIText.PushResultTable_statusUpToDate,StyledString.DECORATIONS_STYLER);
break;
case NON_EXISTING:
styled.append(UIText.PushResultTable_statusNoMatch,StyledString.DECORATIONS_STYLER);
break;
case REJECTED_NODELETE:
case REJECTED_NONFASTFORWARD:
case REJECTED_REMOTE_CHANGED:
styled.append(UIText.PushResultTable_statusRejected,StyledString.DECORATIONS_STYLER);
break;
case REJECTED_OTHER_REASON:
styled.append(UIText.PushResultTable_statusRemoteRejected,StyledString.DECORATIONS_STYLER);
break;
default :
break;
}
return styled;
}","/** 
 * Get styled text
 * @param object
 * @return styled string
 */
public StyledString getStyledText(Object object){
  StyledString styled=new StyledString();
  final String remote=getDstRefName();
  final String local=getSrcRefName();
  styled.append(shortenRef(remote));
  if (!tag) {
    styled.append(""String_Node_Str"",StyledString.QUALIFIER_STYLER);
    styled.append(shortenRef(local),StyledString.QUALIFIER_STYLER);
  }
  styled.append(' ');
  if (result.getURIs().size() > 1)   styled.append(MessageFormat.format(UIText.RefUpdateElement_UrisDecoration,uri.toString()),StyledString.QUALIFIER_STYLER);
  styled.append(' ');
switch (getStatus()) {
case OK:
    if (update.isDelete())     styled.append(UIText.PushResultTable_statusOkDeleted,StyledString.DECORATIONS_STYLER);
 else {
      final Ref oldRef=getAdvertisedRemoteRef();
      if (oldRef == null) {
        if (tag)         styled.append(UIText.PushResultTable_statusOkNewTag,StyledString.DECORATIONS_STYLER);
 else         styled.append(UIText.PushResultTable_statusOkNewBranch,StyledString.DECORATIONS_STYLER);
      }
 else {
        String separator=update.isFastForward() ? ""String_Node_Str"" : ""String_Node_Str"";
        styled.append(MessageFormat.format(UIText.RefUpdateElement_CommitRangeDecoration,update.getNewObjectId().abbreviate(7).name(),separator,oldRef.getObjectId().abbreviate(7).name()),StyledString.DECORATIONS_STYLER);
        styled.append(' ');
        styled.append(MessageFormat.format(UIText.RefUpdateElement_CommitCountDecoration,Integer.valueOf(getChildren(this).length)),StyledString.COUNTER_STYLER);
      }
    }
  break;
case UP_TO_DATE:
styled.append(UIText.PushResultTable_statusUpToDate,StyledString.DECORATIONS_STYLER);
break;
case NON_EXISTING:
styled.append(UIText.PushResultTable_statusNoMatch,StyledString.DECORATIONS_STYLER);
break;
case REJECTED_NODELETE:
case REJECTED_NONFASTFORWARD:
case REJECTED_REMOTE_CHANGED:
styled.append(UIText.PushResultTable_statusRejected,StyledString.DECORATIONS_STYLER);
break;
case REJECTED_OTHER_REASON:
styled.append(UIText.PushResultTable_statusRemoteRejected,StyledString.DECORATIONS_STYLER);
break;
default :
break;
}
return styled;
}",0.9960874568469504
91511,"/** 
 * @param pm the monitor to be used for reporting progress and responding to cancellation. The monitor is never <code>null</code>
 * @throws InvocationTargetException
 * @throws InterruptedException
 */
public void run(final IProgressMonitor pm) throws InvocationTargetException, InterruptedException {
  final IProgressMonitor monitor;
  if (pm == null)   monitor=new NullProgressMonitor();
 else   monitor=pm;
  EclipseGitProgressTransformer gitMonitor=new EclipseGitProgressTransformer(monitor);
  Repository repository=null;
  try {
    monitor.beginTask(NLS.bind(CoreText.CloneOperation_title,uri),5000);
    CloneCommand cloneRepository=Git.cloneRepository();
    cloneRepository.setCredentialsProvider(credentialsProvider);
    if (refName != null)     cloneRepository.setBranch(refName);
    cloneRepository.setDirectory(workdir);
    cloneRepository.setProgressMonitor(gitMonitor);
    cloneRepository.setRemote(remoteName);
    cloneRepository.setURI(uri.toString());
    cloneRepository.setTimeout(timeout);
    cloneRepository.setCloneAllBranches(allSelected);
    if (selectedBranches != null) {
      List<String> branches=new ArrayList<String>();
      for (      Ref branch : selectedBranches)       branches.add(branch.getName());
      cloneRepository.setBranchesToClone(branches);
    }
    Git git=cloneRepository.call();
    repository=git.getRepository();
    if (postCloneTasks != null)     for (    PostCloneTask task : postCloneTasks)     task.execute(git.getRepository(),monitor);
  }
 catch (  final Exception e) {
    try {
      if (repository != null)       repository.close();
      FileUtils.delete(workdir,FileUtils.RECURSIVE);
    }
 catch (    IOException ioe) {
      throw new InvocationTargetException(ioe);
    }
    if (monitor.isCanceled())     throw new InterruptedException();
 else     throw new InvocationTargetException(e);
  }
 finally {
    monitor.done();
    if (repository != null)     repository.close();
  }
}","/** 
 * @param pm the monitor to be used for reporting progress and responding to cancellation. The monitor is never <code>null</code>
 * @throws InvocationTargetException
 * @throws InterruptedException
 */
public void run(final IProgressMonitor pm) throws InvocationTargetException, InterruptedException {
  final IProgressMonitor monitor;
  if (pm == null)   monitor=new NullProgressMonitor();
 else   monitor=pm;
  EclipseGitProgressTransformer gitMonitor=new EclipseGitProgressTransformer(monitor);
  Repository repository=null;
  try {
    monitor.beginTask(NLS.bind(CoreText.CloneOperation_title,uri),5000);
    CloneCommand cloneRepository=Git.cloneRepository();
    cloneRepository.setCredentialsProvider(credentialsProvider);
    if (refName != null)     cloneRepository.setBranch(refName);
    cloneRepository.setDirectory(workdir);
    cloneRepository.setProgressMonitor(gitMonitor);
    cloneRepository.setRemote(remoteName);
    cloneRepository.setURI(uri.toString());
    cloneRepository.setTimeout(timeout);
    cloneRepository.setCloneAllBranches(allSelected);
    if (selectedBranches != null) {
      List<String> branches=new ArrayList<String>();
      for (      Ref branch : selectedBranches)       branches.add(branch.getName());
      cloneRepository.setBranchesToClone(branches);
    }
    Git git=cloneRepository.call();
    repository=git.getRepository();
synchronized (this) {
      if (postCloneTasks != null)       for (      PostCloneTask task : postCloneTasks)       task.execute(git.getRepository(),monitor);
    }
  }
 catch (  final Exception e) {
    try {
      if (repository != null)       repository.close();
      FileUtils.delete(workdir,FileUtils.RECURSIVE);
    }
 catch (    IOException ioe) {
      throw new InvocationTargetException(ioe);
    }
    if (monitor.isCanceled())     throw new InterruptedException();
 else     throw new InvocationTargetException(e);
  }
 finally {
    monitor.done();
    if (repository != null)     repository.close();
  }
}",0.9909319899244332
91512,"public Object execute(ExecutionEvent event) throws ExecutionException {
  Repository repo=getRepository(event);
  BasicConfigurationDialog.show(repo);
  RevCommit commit=(RevCommit)getSelection(getPage()).getFirstElement();
  RevCommit newHead;
  RevertCommand revert;
  Git git=new Git(repo);
  try {
    revert=git.revert().include(commit.getId());
    newHead=revert.call();
    if (newHead != null && revert.getRevertedRefs().isEmpty())     MessageDialog.openWarning(getPart(event).getSite().getShell(),UIText.RevertHandler_NoRevertTitle,UIText.RevertHandler_AlreadyRevertedMessae);
  }
 catch (  Exception e) {
    throw new ExecutionException(UIText.RevertOperation_InternalError,e);
  }
  if (newHead == null)   throw new ExecutionException(UIText.RevertOperation_Failed);
  return null;
}","public Object execute(ExecutionEvent event) throws ExecutionException {
  Repository repo=getRepository(event);
  BasicConfigurationDialog.show(repo);
  RevCommit commit=(RevCommit)getSelection(getPage()).getFirstElement();
  RevCommit newHead;
  RevertCommand revert;
  Git git=new Git(repo);
  try {
    revert=git.revert().include(commit.getId());
    newHead=revert.call();
    if (newHead != null && revert.getRevertedRefs().isEmpty())     MessageDialog.openWarning(getPart(event).getSite().getShell(),UIText.RevertHandler_NoRevertTitle,UIText.RevertHandler_AlreadyRevertedMessae);
  }
 catch (  Exception e) {
    Activator.handleError(UIText.RevertOperation_InternalError,e,true);
    return null;
  }
  if (newHead == null)   Activator.showError(UIText.RevertOperation_Failed,null);
  return null;
}",0.9270118527760448
91513,"public Object execute(ExecutionEvent event) throws ExecutionException {
  Repository repo=getRepository(event);
  BasicConfigurationDialog.show(repo);
  RevCommit commit=(RevCommit)getSelection(getPage()).getFirstElement();
  RevCommit newHead;
  RevertCommand revert;
  Git git=new Git(repo);
  try {
    revert=git.revert().include(commit.getId());
    newHead=revert.call();
    if (newHead != null && revert.getRevertedRefs().isEmpty())     MessageDialog.openWarning(getPart(event).getSite().getShell(),UIText.RevertHandler_NoRevertTitle,UIText.RevertHandler_AlreadyRevertedMessae);
  }
 catch (  Exception e) {
    throw new ExecutionException(UIText.RevertOperation_InternalError,e);
  }
  if (newHead == null)   throw new ExecutionException(UIText.RevertOperation_Failed);
  return null;
}","public Object execute(ExecutionEvent event) throws ExecutionException {
  Repository repo=getRepository(event);
  BasicConfigurationDialog.show(repo);
  RevCommit commit=(RevCommit)getSelection(getPage()).getFirstElement();
  RevCommit newHead;
  RevertCommand revert;
  Git git=new Git(repo);
  try {
    revert=git.revert().include(commit.getId());
    newHead=revert.call();
    if (newHead != null && revert.getRevertedRefs().isEmpty())     MessageDialog.openWarning(getPart(event).getSite().getShell(),UIText.RevertHandler_NoRevertTitle,UIText.RevertHandler_AlreadyRevertedMessae);
  }
 catch (  Exception e) {
    Activator.handleError(UIText.RevertOperation_InternalError,e,true);
    return null;
  }
  if (newHead == null)   Activator.showError(UIText.RevertOperation_Failed,null);
  return null;
}",0.9270118527760448
91514,"@Override public boolean equals(Object obj){
  if (obj == this)   return true;
  if (obj instanceof GitModelBlob && !(obj instanceof GitModelCacheFile) && !(obj instanceof GitModelWorkingFile)) {
    GitModelBlob objBlob=(GitModelBlob)obj;
    boolean equalsRemoteId;
    ObjectId objRemoteId=objBlob.remoteId;
    if (objRemoteId != null)     equalsRemoteId=objRemoteId.equals(remoteId);
 else     equalsRemoteId=remoteId == null;
    return objBlob.baseId.equals(baseId) && equalsRemoteId && objBlob.location.equals(location);
  }
  return false;
}","@Override public boolean equals(Object obj){
  if (obj == this)   return true;
  if (obj == null)   return false;
  if (obj.getClass() != getClass())   return false;
  GitModelBlob objBlob=(GitModelBlob)obj;
  boolean equalsRemoteId;
  ObjectId objRemoteId=objBlob.remoteId;
  if (objRemoteId != null)   equalsRemoteId=objRemoteId.equals(remoteId);
 else   equalsRemoteId=remoteId == null;
  return objBlob.baseId.equals(baseId) && equalsRemoteId && objBlob.location.equals(location);
}",0.1949806949806949
91515,"@Override public boolean equals(Object obj){
  if (obj == this)   return true;
  if (obj instanceof GitModelCacheFile) {
    GitModelCacheFile objBlob=(GitModelCacheFile)obj;
    return objBlob.baseId.equals(baseId) && objBlob.remoteId.equals(remoteId) && objBlob.getLocation().equals(getLocation());
  }
  return false;
}","@Override public boolean equals(Object obj){
  if (obj == this)   return true;
  if (obj == null)   return false;
  if (obj.getClass() != getClass())   return false;
  GitModelCacheFile objBlob=(GitModelCacheFile)obj;
  return objBlob.baseId.equals(baseId) && objBlob.remoteId.equals(remoteId) && objBlob.getLocation().equals(getLocation());
}",0.7488721804511278
91516,"@Override public boolean equals(Object obj){
  if (obj == this)   return true;
  if (obj instanceof GitModelCacheTree) {
    GitModelCacheTree objTree=(GitModelCacheTree)obj;
    return objTree.getLocation().equals(getLocation()) && objTree.getBaseId().equals(getBaseId());
  }
  return false;
}","@Override public boolean equals(Object obj){
  if (obj == this)   return true;
  if (obj == null)   return false;
  if (obj.getClass() != getClass())   return false;
  GitModelCacheTree objTree=(GitModelCacheTree)obj;
  return objTree.getLocation().equals(getLocation()) && objTree.getBaseId().equals(getBaseId());
}",0.7266775777414075
91517,"@Override public boolean equals(Object obj){
  if (obj == this)   return true;
  if (obj instanceof GitModelCommit && !(obj instanceof GitModelTree) && !(obj instanceof GitModelBlob)) {
    GitModelCommit objCommit=(GitModelCommit)obj;
    return objCommit.getBaseCommit().equals(baseCommit) && objCommit.getParent().equals(getParent());
  }
  return false;
}","@Override public boolean equals(Object obj){
  if (obj == this)   return true;
  if (obj == null)   return false;
  if (obj.getClass() != getClass())   return false;
  GitModelCommit objCommit=(GitModelCommit)obj;
  return objCommit.getBaseCommit().equals(baseCommit) && objCommit.getParent().equals(getParent());
}",0.3887240356083086
91518,"@Override public boolean equals(Object obj){
  if (obj == this)   return true;
  if (obj instanceof GitModelTree && !(obj instanceof GitModelCacheTree)) {
    GitModelTree objTree=(GitModelTree)obj;
    return objTree.location.equals(location) && objTree.baseCommit.equals(baseCommit);
  }
  return false;
}","@Override public boolean equals(Object obj){
  if (obj == this)   return true;
  if (obj == null)   return false;
  if (obj.getClass() != getClass())   return false;
  GitModelTree objTree=(GitModelTree)obj;
  return objTree.location.equals(location) && objTree.baseCommit.equals(baseCommit);
}",0.3826955074875208
91519,"@Override public boolean equals(Object obj){
  if (obj == this)   return true;
  if (obj instanceof GitModelWorkingFile)   return ((GitModelWorkingFile)obj).getLocation().equals(getLocation());
  return false;
}","@Override public boolean equals(Object obj){
  if (obj == this)   return true;
  if (obj == null)   return false;
  if (obj.getClass() != getClass())   return false;
  return ((GitModelWorkingFile)obj).getLocation().equals(getLocation());
}",0.6740576496674058
91520,"@Override public boolean equals(Object obj){
  if (obj == this)   return true;
  if (obj instanceof GitModelWorkingTree) {
    GitModelCache left=(GitModelCache)obj;
    return left.getParent().equals(getParent());
  }
  return false;
}","@Override public boolean equals(Object obj){
  if (obj == this)   return true;
  if (obj == null)   return false;
  if (obj.getClass() != getClass())   return false;
  GitModelCache left=(GitModelCache)obj;
  return left.getParent().equals(getParent());
}",0.6476578411405295
91521,"/** 
 * @param pm the monitor to be used for reporting progress and responding to cancellation. The monitor is never <code>null</code>
 * @throws InvocationTargetException
 * @throws InterruptedException
 */
public void run(final IProgressMonitor pm) throws InvocationTargetException, InterruptedException {
  final IProgressMonitor monitor;
  if (pm == null)   monitor=new NullProgressMonitor();
 else   monitor=pm;
  EclipseGitProgressTransformer gitMonitor=new EclipseGitProgressTransformer(monitor);
  Repository repository=null;
  try {
    monitor.beginTask(NLS.bind(CoreText.CloneOperation_title,uri),5000);
    CloneCommand cloneRepository=Git.cloneRepository();
    cloneRepository.setCredentialsProvider(credentialsProvider);
    if (refName != null)     cloneRepository.setBranch(refName);
    cloneRepository.setDirectory(workdir);
    cloneRepository.setProgressMonitor(gitMonitor);
    cloneRepository.setRemote(remoteName);
    cloneRepository.setURI(uri.toString());
    cloneRepository.setTimeout(timeout);
    cloneRepository.setCloneAllBranches(allSelected);
    if (selectedBranches != null) {
      List<String> branches=new ArrayList<String>();
      for (      Ref branch : selectedBranches)       branches.add(branch.getName());
      cloneRepository.setBranchesToClone(branches);
    }
    Git git=cloneRepository.call();
    repository=git.getRepository();
    if (postCloneTasks != null)     for (    PostCloneTask task : postCloneTasks)     task.execute(git.getRepository(),monitor);
  }
 catch (  final Exception e) {
    try {
      if (repository != null)       repository.close();
      FileUtils.delete(workdir,FileUtils.RECURSIVE);
    }
 catch (    IOException ioe) {
      throw new InvocationTargetException(ioe);
    }
    if (monitor.isCanceled())     throw new InterruptedException();
 else     throw new InvocationTargetException(e);
  }
 finally {
    monitor.done();
    if (repository != null)     repository.close();
  }
}","/** 
 * @param pm the monitor to be used for reporting progress and responding to cancellation. The monitor is never <code>null</code>
 * @throws InvocationTargetException
 * @throws InterruptedException
 */
public void run(final IProgressMonitor pm) throws InvocationTargetException, InterruptedException {
  final IProgressMonitor monitor;
  if (pm == null)   monitor=new NullProgressMonitor();
 else   monitor=pm;
  EclipseGitProgressTransformer gitMonitor=new EclipseGitProgressTransformer(monitor);
  Repository repository=null;
  try {
    monitor.beginTask(NLS.bind(CoreText.CloneOperation_title,uri),5000);
    CloneCommand cloneRepository=Git.cloneRepository();
    cloneRepository.setCredentialsProvider(credentialsProvider);
    if (refName != null)     cloneRepository.setBranch(refName);
    cloneRepository.setDirectory(workdir);
    cloneRepository.setProgressMonitor(gitMonitor);
    cloneRepository.setRemote(remoteName);
    cloneRepository.setURI(uri.toString());
    cloneRepository.setTimeout(timeout);
    cloneRepository.setCloneAllBranches(allSelected);
    if (selectedBranches != null) {
      List<String> branches=new ArrayList<String>();
      for (      Ref branch : selectedBranches)       branches.add(branch.getName());
      cloneRepository.setBranchesToClone(branches);
    }
    Git git=cloneRepository.call();
    repository=git.getRepository();
synchronized (this) {
      if (postCloneTasks != null)       for (      PostCloneTask task : postCloneTasks)       task.execute(git.getRepository(),monitor);
    }
  }
 catch (  final Exception e) {
    try {
      if (repository != null)       repository.close();
      FileUtils.delete(workdir,FileUtils.RECURSIVE);
    }
 catch (    IOException ioe) {
      throw new InvocationTargetException(ioe);
    }
    if (monitor.isCanceled())     throw new InterruptedException();
 else     throw new InvocationTargetException(e);
  }
 finally {
    monitor.done();
    if (repository != null)     repository.close();
  }
}",0.9909319899244332
91522,"public Object execute(ExecutionEvent event) throws ExecutionException {
  RevCommit commit=(RevCommit)getSelection(getPage()).getFirstElement();
  RevCommit newHead;
  Repository repo=getRepository(event);
  CherryPickResult cherryPickResult;
  Git git=new Git(repo);
  Shell parent=getPart(event).getSite().getShell();
  try {
    cherryPickResult=git.cherryPick().include(commit.getId()).call();
    newHead=cherryPickResult.getNewHead();
    if (newHead != null && cherryPickResult.getCherryPickedRefs().isEmpty())     MessageDialog.openWarning(parent,UIText.CherryPickHandler_NoCherryPickPerformedTitle,UIText.CherryPickHandler_NoCherryPickPerformedMessage);
  }
 catch (  Exception e) {
    throw new ExecutionException(UIText.CherryPickOperation_InternalError,e);
  }
  if (newHead == null)   if (cherryPickResult.getStatus() == CherryPickStatus.CONFLICTING)   MessageDialog.openWarning(parent,UIText.CherryPickHandler_CherryPickConflictsTitle,UIText.CherryPickHandler_CherryPickConflictsMessage);
 else   throw new ExecutionException(UIText.CherryPickOperation_Failed);
  return null;
}","public Object execute(ExecutionEvent event) throws ExecutionException {
  RevCommit commit=(RevCommit)getSelection(getPage()).getFirstElement();
  RevCommit newHead;
  Repository repo=getRepository(event);
  CherryPickResult cherryPickResult;
  Git git=new Git(repo);
  Shell parent=getPart(event).getSite().getShell();
  try {
    cherryPickResult=git.cherryPick().include(commit.getId()).call();
    newHead=cherryPickResult.getNewHead();
    if (newHead != null && cherryPickResult.getCherryPickedRefs().isEmpty())     MessageDialog.openWarning(parent,UIText.CherryPickHandler_NoCherryPickPerformedTitle,UIText.CherryPickHandler_NoCherryPickPerformedMessage);
  }
 catch (  Exception e) {
    throw new ExecutionException(UIText.CherryPickOperation_InternalError,e);
  }
  if (newHead == null) {
    CherryPickStatus status=cherryPickResult.getStatus();
switch (status) {
case CONFLICTING:
      MessageDialog.openWarning(parent,UIText.CherryPickHandler_CherryPickConflictsTitle,UIText.CherryPickHandler_CherryPickConflictsMessage);
    break;
case FAILED:
  IStatus details=getErrorList(cherryPickResult.getFailingPaths());
Activator.showErrorStatus(UIText.CherryPickHandler_CherryPickFailedMessage,details);
break;
case OK:
break;
}
}
return null;
}",0.853855986365573
91523,"public Object execute(ExecutionEvent event) throws ExecutionException {
  RevCommit commit=(RevCommit)getSelection(getPage()).getFirstElement();
  RevCommit newHead;
  Repository repo=getRepository(event);
  CherryPickResult cherryPickResult;
  Git git=new Git(repo);
  Shell parent=getPart(event).getSite().getShell();
  try {
    cherryPickResult=git.cherryPick().include(commit.getId()).call();
    newHead=cherryPickResult.getNewHead();
    if (newHead != null && cherryPickResult.getCherryPickedRefs().isEmpty())     MessageDialog.openWarning(parent,UIText.CherryPickHandler_NoCherryPickPerformedTitle,UIText.CherryPickHandler_NoCherryPickPerformedMessage);
  }
 catch (  Exception e) {
    throw new ExecutionException(UIText.CherryPickOperation_InternalError,e);
  }
  if (newHead == null)   if (cherryPickResult.getStatus() == CherryPickStatus.CONFLICTING)   MessageDialog.openWarning(parent,UIText.CherryPickHandler_CherryPickConflictsTitle,UIText.CherryPickHandler_CherryPickConflictsMessage);
 else   throw new ExecutionException(UIText.CherryPickOperation_Failed);
  return null;
}","public Object execute(ExecutionEvent event) throws ExecutionException {
  RevCommit commit=(RevCommit)getSelection(getPage()).getFirstElement();
  RevCommit newHead;
  Repository repo=getRepository(event);
  CherryPickResult cherryPickResult;
  Git git=new Git(repo);
  Shell parent=getPart(event).getSite().getShell();
  try {
    cherryPickResult=git.cherryPick().include(commit.getId()).call();
    newHead=cherryPickResult.getNewHead();
    if (newHead != null && cherryPickResult.getCherryPickedRefs().isEmpty())     MessageDialog.openWarning(parent,UIText.CherryPickHandler_NoCherryPickPerformedTitle,UIText.CherryPickHandler_NoCherryPickPerformedMessage);
  }
 catch (  Exception e) {
    throw new ExecutionException(UIText.CherryPickOperation_InternalError,e);
  }
  if (newHead == null) {
    CherryPickStatus status=cherryPickResult.getStatus();
switch (status) {
case CONFLICTING:
      MessageDialog.openWarning(parent,UIText.CherryPickHandler_CherryPickConflictsTitle,UIText.CherryPickHandler_CherryPickConflictsMessage);
    break;
case FAILED:
  IStatus details=getErrorList(cherryPickResult.getFailingPaths());
Activator.showErrorStatus(UIText.CherryPickHandler_CherryPickFailedMessage,details);
break;
case OK:
break;
}
}
return null;
}",0.853855986365573
91524,"private void fillTreeItemWithGitDirectory(RepositoryMapping m,TreeItem treeItem2,boolean isAlternative){
  if (m.getGitDir() == null)   treeItem2.setText(2,UIText.ExistingOrNewPage_SymbolicValueEmptyMapping);
 else {
    IPath container=m.getContainerPath();
    if (!container.isEmpty())     container=Path.fromOSString(""String_Node_Str"");
    IPath relativePath=container.append(m.getGitDir());
    if (isAlternative) {
      IPath withoutLastSegment=relativePath.removeLastSegments(1);
      IPath path;
      if (withoutLastSegment.isEmpty())       path=Path.fromPortableString(""String_Node_Str"");
 else       path=withoutLastSegment;
      treeItem2.setText(0,path.toString());
    }
    treeItem2.setText(2,relativePath.toString());
    try {
      IProject project=m.getContainer().getProject();
      FileRepository repo=new FileRepository(m.getGitDirAbsolutePath().toFile());
      File workTree=repo.getWorkTree();
      IPath workTreePath=Path.fromOSString(workTree.getAbsolutePath());
      if (workTreePath.isPrefixOf(project.getLocation())) {
        IPath makeRelativeTo=project.getLocation().makeRelativeTo(workTreePath);
        String repoRelativePath=makeRelativeTo.append(""String_Node_Str"").toPortableString();
        ObjectId headCommitId=repo.resolve(Constants.HEAD);
        if (headCommitId != null) {
          RevWalk revWalk=new RevWalk(repo);
          RevCommit headCommit=revWalk.parseCommit(headCommitId);
          RevTree headTree=headCommit.getTree();
          TreeWalk projectInRepo=TreeWalk.forPath(repo,repoRelativePath,headTree);
          if (projectInRepo != null) {
            treeItem2.setChecked(true);
          }
          revWalk.dispose();
        }
      }
      repo.close();
    }
 catch (    IOException e1) {
      Activator.logError(""String_Node_Str"",e1);
    }
  }
}","private void fillTreeItemWithGitDirectory(RepositoryMapping m,TreeItem treeItem,boolean isAlternative){
  if (m.getGitDir() == null)   treeItem.setText(2,UIText.ExistingOrNewPage_SymbolicValueEmptyMapping);
 else {
    IPath container=m.getContainerPath();
    if (!container.isEmpty())     container=Path.fromOSString(""String_Node_Str"");
    IPath relativePath=container.append(m.getGitDir());
    if (isAlternative) {
      IPath withoutLastSegment=relativePath.removeLastSegments(1);
      IPath path;
      if (withoutLastSegment.isEmpty())       path=Path.fromPortableString(""String_Node_Str"");
 else       path=withoutLastSegment;
      treeItem.setText(0,path.toString());
    }
    treeItem.setText(2,relativePath.toOSString());
    try {
      IProject project=m.getContainer().getProject();
      FileRepository repo=new FileRepository(m.getGitDirAbsolutePath().toFile());
      File workTree=repo.getWorkTree();
      IPath workTreePath=Path.fromOSString(workTree.getAbsolutePath());
      if (workTreePath.isPrefixOf(project.getLocation())) {
        IPath makeRelativeTo=project.getLocation().makeRelativeTo(workTreePath);
        String repoRelativePath=makeRelativeTo.append(""String_Node_Str"").toPortableString();
        ObjectId headCommitId=repo.resolve(Constants.HEAD);
        if (headCommitId != null) {
          RevWalk revWalk=new RevWalk(repo);
          RevCommit headCommit=revWalk.parseCommit(headCommitId);
          RevTree headTree=headCommit.getTree();
          TreeWalk projectInRepo=TreeWalk.forPath(repo,repoRelativePath,headTree);
          if (projectInRepo != null) {
            treeItem.setChecked(true);
          }
          revWalk.dispose();
        }
      }
      repo.close();
    }
 catch (    IOException e1) {
      Activator.logError(""String_Node_Str"",e1);
    }
  }
}",0.9980785067252264
91525,"private void fillOptionsMapFromOptions(){
  Map<String,String> oldValues=new HashMap<String,String>();
  for (  Properties props : optionsMap.values())   for (  Object keyObject : props.keySet()) {
    String key=(String)keyObject;
    oldValues.put(key,props.getProperty(key));
  }
  optionsMap.clear();
  for (  PluginNode plugin : PLUGIN_LIST) {
    Properties props=new Properties();
    try {
      InputStream is=Platform.getBundle(plugin.getPlugin()).getResource(""String_Node_Str"").openStream();
      props.load(is);
    }
 catch (    IOException e) {
      Activator.handleError(e.getMessage(),e,true);
    }
    optionsMap.put(plugin,props);
  }
  Map<String,String> newValues=new HashMap<String,String>();
  for (  Properties props : optionsMap.values())   for (  Object keyObject : props.keySet()) {
    String key=(String)keyObject;
    oldValues.put(key,props.getProperty(key));
  }
  boolean dirty=false;
  if (oldValues.keySet().containsAll(newValues.keySet()) && newValues.keySet().containsAll(oldValues.keySet())) {
    for (    String key : oldValues.keySet()) {
      if (!oldValues.get(key).equals(newValues.get(key))) {
        dirty=true;
        break;
      }
    }
  }
 else {
    dirty=true;
  }
  if (dirty)   setDirty(true);
}","private void fillOptionsMapFromOptions(){
  Map<String,String> oldValues=new HashMap<String,String>();
  for (  Properties props : optionsMap.values())   for (  Object keyObject : props.keySet()) {
    String key=(String)keyObject;
    oldValues.put(key,props.getProperty(key));
  }
  optionsMap.clear();
  for (  PluginNode plugin : PLUGIN_LIST) {
    Properties props=new Properties();
    try {
      InputStream is=Platform.getBundle(plugin.getPlugin()).getResource(""String_Node_Str"").openStream();
      props.load(is);
    }
 catch (    IOException e) {
      Activator.handleError(e.getMessage(),e,true);
    }
    optionsMap.put(plugin,props);
  }
  Map<String,String> newValues=new HashMap<String,String>();
  for (  Properties props : optionsMap.values())   for (  Object keyObject : props.keySet()) {
    String key=(String)keyObject;
    oldValues.put(key,props.getProperty(key));
  }
  boolean dirty=false;
  if (oldValues.keySet().containsAll(newValues.keySet()) && newValues.keySet().containsAll(oldValues.keySet())) {
    for (    Entry<String,String> oldValueEntry : oldValues.entrySet()) {
      String key=oldValueEntry.getKey();
      String newValue=newValues.get(key);
      if (!oldValueEntry.getValue().equals(newValue)) {
        dirty=true;
        break;
      }
    }
  }
 else {
    dirty=true;
  }
  if (dirty)   setDirty(true);
}",0.9369024856596558
91526,"@Override public boolean performFinish(){
  GitSynchronizeDataSet gsdSet=new GitSynchronizeDataSet();
  Map<Repository,String> branches=page.getSelectedBranches();
  for (  Repository repo : branches.keySet())   try {
    gsdSet.add(new GitSynchronizeData(repo,Constants.HEAD,branches.get(repo),false));
  }
 catch (  IOException e) {
    Activator.logError(e.getMessage(),e);
  }
  new GitSynchronize(gsdSet);
  return true;
}","@Override public boolean performFinish(){
  GitSynchronizeDataSet gsdSet=new GitSynchronizeDataSet();
  Map<Repository,String> branches=page.getSelectedBranches();
  for (  Entry<Repository,String> branchesEntry : branches.entrySet())   try {
    gsdSet.add(new GitSynchronizeData(branchesEntry.getKey(),Constants.HEAD,branchesEntry.getValue(),false));
  }
 catch (  IOException e) {
    Activator.logError(e.getMessage(),e);
  }
  new GitSynchronize(gsdSet);
  return true;
}",0.901439645625692
91527,"/** 
 * @return the calculated commit message
 */
private String calculateCommitMessage(){
  if (commitMessage != null) {
    return commitMessage;
  }
  String calculatedCommitMessage=null;
  Set<IResource> resources=new HashSet<IResource>();
  for (  CommitItem item : items) {
    IResource resource=item.file.getProject();
    resources.add(resource);
  }
  try {
    ICommitMessageProvider messageProvider=getCommitMessageProvider();
    if (messageProvider != null) {
      IResource[] resourcesArray=resources.toArray(new IResource[0]);
      calculatedCommitMessage=messageProvider.getMessage(resourcesArray);
    }
  }
 catch (  CoreException coreException) {
    Activator.error(coreException.getLocalizedMessage(),coreException);
  }
  return calculatedCommitMessage;
}","/** 
 * @return the calculated commit message
 */
private String calculateCommitMessage(){
  String calculatedCommitMessage=null;
  Set<IResource> resources=new HashSet<IResource>();
  for (  CommitItem item : items) {
    IResource resource=item.file.getProject();
    resources.add(resource);
  }
  try {
    ICommitMessageProvider messageProvider=getCommitMessageProvider();
    if (messageProvider != null) {
      IResource[] resourcesArray=resources.toArray(new IResource[0]);
      calculatedCommitMessage=messageProvider.getMessage(resourcesArray);
    }
  }
 catch (  CoreException coreException) {
    Activator.error(coreException.getLocalizedMessage(),coreException);
  }
  return calculatedCommitMessage;
}",0.9593062041360908
91528,"@Override public boolean inputSet(){
  try {
    if (trace)     GitTraceLocation.getTrace().traceEntry(GitTraceLocation.HISTORYVIEW.getLocation());
    if (this.input != null)     return true;
    cancelRefreshJob();
    setErrorMessage(null);
    Object o=super.getInput();
    if (o == null) {
      setErrorMessage(UIText.GitHistoryPage_NoInputMessage);
      return false;
    }
    if (o instanceof IResource) {
      RepositoryMapping mapping=RepositoryMapping.getMapping((IResource)o);
      if (mapping != null) {
        Repository repo=mapping.getRepository();
        input=new HistoryPageInput(repo,new IResource[]{(IResource)o});
      }
    }
 else     if (o instanceof RepositoryTreeNode) {
      RepositoryTreeNode repoNode=(RepositoryTreeNode)o;
switch (repoNode.getType()) {
case FILE:
        File file=((FileNode)repoNode).getObject();
      input=new HistoryPageInput(repoNode.getRepository(),new File[]{file});
    break;
case FOLDER:
  File folder=((FolderNode)repoNode).getObject();
input=new HistoryPageInput(repoNode.getRepository(),new File[]{folder});
break;
default :
input=new HistoryPageInput(repoNode.getRepository());
}
}
 else if (o instanceof HistoryPageInput) input=(HistoryPageInput)o;
 else if (o instanceof IAdaptable) {
IResource resource=(IResource)((IAdaptable)o).getAdapter(IResource.class);
if (resource != null) {
RepositoryMapping mapping=RepositoryMapping.getMapping(resource);
Repository repo=mapping.getRepository();
input=new HistoryPageInput(repo,new IResource[]{resource});
}
}
if (input == null) {
this.name=""String_Node_Str"";
setErrorMessage(UIText.GitHistoryPage_NoInputMessage);
return false;
}
final IResource[] inResources=input.getItems();
final File[] inFiles=input.getFileList();
if (inResources != null && inResources.length == 0) {
this.name=""String_Node_Str"";
setErrorMessage(UIText.GitHistoryPage_NoInputMessage);
return false;
}
this.name=calculateName(input);
boolean filtersActive=inResources != null || inFiles != null;
actions.showAllRepoVersionsAction.setEnabled(filtersActive);
actions.showAllProjectVersionsAction.setEnabled(filtersActive);
actions.showAllFolderVersionsAction.setEnabled(inResources != null);
actions.showAllResourceVersionsAction.setEnabled(filtersActive);
try {
initAndStartRevWalk(true);
}
 catch (IllegalStateException e) {
Activator.handleError(e.getMessage(),e.getCause(),true);
return false;
}
return true;
}
  finally {
if (trace) GitTraceLocation.getTrace().traceExit(GitTraceLocation.HISTORYVIEW.getLocation());
}
}","@Override public boolean inputSet(){
  try {
    if (trace)     GitTraceLocation.getTrace().traceEntry(GitTraceLocation.HISTORYVIEW.getLocation());
    if (this.input != null)     return true;
    cancelRefreshJob();
    setErrorMessage(null);
    Object o=super.getInput();
    if (o == null) {
      setErrorMessage(UIText.GitHistoryPage_NoInputMessage);
      return false;
    }
    if (o instanceof IResource) {
      RepositoryMapping mapping=RepositoryMapping.getMapping((IResource)o);
      if (mapping != null) {
        Repository repo=mapping.getRepository();
        input=new HistoryPageInput(repo,new IResource[]{(IResource)o});
      }
    }
 else     if (o instanceof RepositoryTreeNode) {
      RepositoryTreeNode repoNode=(RepositoryTreeNode)o;
switch (repoNode.getType()) {
case FILE:
        File file=((FileNode)repoNode).getObject();
      input=new HistoryPageInput(repoNode.getRepository(),new File[]{file});
    break;
case FOLDER:
  File folder=((FolderNode)repoNode).getObject();
input=new HistoryPageInput(repoNode.getRepository(),new File[]{folder});
break;
default :
input=new HistoryPageInput(repoNode.getRepository());
}
}
 else if (o instanceof HistoryPageInput) input=(HistoryPageInput)o;
 else if (o instanceof IAdaptable) {
IResource resource=(IResource)((IAdaptable)o).getAdapter(IResource.class);
if (resource != null) {
RepositoryMapping mapping=RepositoryMapping.getMapping(resource);
Repository repo=mapping.getRepository();
input=new HistoryPageInput(repo,new IResource[]{resource});
}
}
if (input == null) {
this.name=""String_Node_Str"";
setErrorMessage(UIText.GitHistoryPage_NoInputMessage);
return false;
}
final IResource[] inResources=input.getItems();
final File[] inFiles=input.getFileList();
if (inResources != null && inResources.length == 0) {
this.name=""String_Node_Str"";
setErrorMessage(UIText.GitHistoryPage_NoInputMessage);
return false;
}
this.name=calculateName(input);
boolean filtersActive=inResources != null || inFiles != null;
actions.showAllRepoVersionsAction.setEnabled(filtersActive);
actions.showAllProjectVersionsAction.setEnabled(filtersActive);
actions.showAllFolderVersionsAction.setEnabled(inResources != null);
actions.showAllResourceVersionsAction.setEnabled(filtersActive);
try {
initAndStartRevWalk(true);
}
 catch (IllegalStateException e) {
Activator.handleError(e.getMessage(),e,true);
return false;
}
return true;
}
  finally {
if (trace) GitTraceLocation.getTrace().traceExit(GitTraceLocation.HISTORYVIEW.getLocation());
}
}",0.9978083283522614
91529,"@Test public void testTagDialogShowExistingTags() throws Exception {
  SWTBotShell tagDialog=openTagDialog();
  int index=tagDialog.bot().tableWithLabel(UIText.CreateTagDialog_existingTags).indexOf(""String_Node_Str"");
  assertTrue(""String_Node_Str"",index >= 0);
}","@Test public void testTagDialogShowExistingTags() throws Exception {
  SWTBotShell tagDialog=openTagDialog();
  SWTBotTable table=tagDialog.bot().tableWithLabel(UIText.CreateTagDialog_existingTags);
  TestUtil.waitUntilTableHasRowWithText(tagDialog.bot(),table,""String_Node_Str"",10000);
}",0.7295825771324864
91530,"@Test public void testCloneRepoButton() throws Exception {
  clearView();
  refreshAndWait();
  assertEmpty();
  getOrOpenView().toolbarButton(myUtil.getPluginLocalizedValue(""String_Node_Str"")).click();
  SWTBotShell shell=bot.shell(UIText.GitCloneWizard_title).activate();
  shell.bot().textInGroup(UIText.RepositorySelectionPage_groupLocation,0).setText(repositoryFile.getPath());
  shell.bot().button(IDialogConstants.NEXT_LABEL).click();
  waitInUI();
  shell.bot().button(IDialogConstants.NEXT_LABEL).click();
  waitInUI();
  SWTBotText pathText=shell.bot().text(0);
  pathText.setText(pathText.getText() + ""String_Node_Str"");
  shell.bot().button(IDialogConstants.FINISH_LABEL).click();
  waitInUI();
  refreshAndWait();
  assertHasClonedRepo();
}","@Test public void testCloneRepoButton() throws Exception {
  clearView();
  refreshAndWait();
  assertEmpty();
  getOrOpenView().toolbarButton(myUtil.getPluginLocalizedValue(""String_Node_Str"")).click();
  SWTBotShell shell=bot.shell(UIText.GitCloneWizard_title).activate();
  shell.bot().textInGroup(UIText.RepositorySelectionPage_groupLocation,0).setText(repositoryFile.getPath());
  shell.bot().button(IDialogConstants.NEXT_LABEL).click();
  waitInUI();
  shell.bot().button(IDialogConstants.NEXT_LABEL).click();
  waitInUI();
  SWTBotText pathText=shell.bot().text(0);
  pathText.setText(pathText.getText() + ""String_Node_Str"");
  shell.bot().button(IDialogConstants.FINISH_LABEL).click();
  refreshAndWait();
  assertHasClonedRepo();
}",0.9906166219839142
91531,"private void assertHasClonedRepo() throws Exception {
  final SWTBotTree tree=getOrOpenView().bot().tree();
  final SWTBotTreeItem[] items=tree.getAllItems();
  boolean found=false;
  for (  SWTBotTreeItem item : items) {
    if (item.getText().startsWith(repositoryFile.getParentFile().getName() + ""String_Node_Str"")) {
      found=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"",found);
}","private void assertHasClonedRepo() throws Exception {
  final SWTBotTree tree=getOrOpenView().bot().tree();
  String text=repositoryFile.getParentFile().getName() + ""String_Node_Str"";
  TestUtil.waitUntilTreeHasNodeWithText(bot,tree,text,10000);
}",0.551617873651772
91532,"@Test public void testDeleteSingleBranch() throws Exception {
  SWTBotTree tree=getOrOpenView().bot().tree();
  refreshAndWait();
  SWTBotTreeItem localBranchesItem=myRepoViewUtil.getLocalBranchesItem(tree,repositoryFile).expand();
  SWTBotTreeItem masterNode=localBranchesItem.getNode(""String_Node_Str"");
  masterNode.select();
  ContextMenuHelper.clickContextMenu(tree,myUtil.getPluginLocalizedValue(""String_Node_Str""));
  TestUtil.joinJobs(JobFamilies.CHECKOUT);
  ContextMenuHelper.clickContextMenu(tree,myUtil.getPluginLocalizedValue(""String_Node_Str""));
  SWTBotShell createBranchShell=bot.shell(UIText.CreateBranchWizard_NewBranchTitle);
  createBranchShell.bot().textWithId(""String_Node_Str"").setText(""String_Node_Str"");
  createBranchShell.bot().checkBox().deselect();
  createBranchShell.bot().button(IDialogConstants.FINISH_LABEL).click();
  refreshAndWait();
  localBranchesItem.getNode(""String_Node_Str"").select();
  ContextMenuHelper.clickContextMenu(tree,myUtil.getPluginLocalizedValue(""String_Node_Str""));
  refreshAndWait();
  SWTBotTreeItem[] items=myRepoViewUtil.getLocalBranchesItem(tree,repositoryFile).getItems();
  assertEquals(""String_Node_Str"",2,items.length);
  assertEquals(""String_Node_Str"",items[0].getText());
  assertEquals(""String_Node_Str"",items[1].getText());
}","@Test public void testDeleteSingleBranch() throws Exception {
  SWTBotTree tree=getOrOpenView().bot().tree();
  refreshAndWait();
  SWTBotTreeItem localBranchesItem=myRepoViewUtil.getLocalBranchesItem(tree,repositoryFile).expand();
  SWTBotTreeItem masterNode=localBranchesItem.getNode(""String_Node_Str"");
  masterNode.select();
  ContextMenuHelper.clickContextMenu(tree,myUtil.getPluginLocalizedValue(""String_Node_Str""));
  TestUtil.joinJobs(JobFamilies.CHECKOUT);
  ContextMenuHelper.clickContextMenu(tree,myUtil.getPluginLocalizedValue(""String_Node_Str""));
  SWTBotShell createBranchShell=bot.shell(UIText.CreateBranchWizard_NewBranchTitle);
  createBranchShell.bot().textWithId(""String_Node_Str"").setText(""String_Node_Str"");
  createBranchShell.bot().checkBox().deselect();
  createBranchShell.bot().button(IDialogConstants.FINISH_LABEL).click();
  refreshAndWait();
  localBranchesItem=myRepoViewUtil.getLocalBranchesItem(tree,repositoryFile).expand();
  localBranchesItem.getNode(""String_Node_Str"").select();
  ContextMenuHelper.clickContextMenu(tree,myUtil.getPluginLocalizedValue(""String_Node_Str""));
  refreshAndWait();
  SWTBotTreeItem[] items=myRepoViewUtil.getLocalBranchesItem(tree,repositoryFile).getItems();
  assertEquals(""String_Node_Str"",2,items.length);
  assertEquals(""String_Node_Str"",items[0].getText());
  assertEquals(""String_Node_Str"",items[1].getText());
}",0.9675009338812104
91533,"/** 
 * Import wizard golden path test
 * @throws Exception
 */
@Test public void testImportWizard() throws Exception {
  deleteAllProjects();
  assertProjectExistence(PROJ1,false);
  SWTBotTree tree=getOrOpenView().bot().tree();
  SWTBotTreeItem item=myRepoViewUtil.getRootItem(tree,repositoryFile);
  String wizardTitle=NLS.bind(UIText.GitCreateProjectViaWizardWizard_WizardTitle,repositoryFile.getPath());
  item.select();
  ContextMenuHelper.clickContextMenu(tree,myUtil.getPluginLocalizedValue(""String_Node_Str""));
  SWTBotShell shell=bot.shell(wizardTitle);
  bot.radio(UIText.GitSelectWizardPage_ImportExistingButton).click();
  bot.radio(UIText.GitSelectWizardPage_AutoShareButton).click();
  TableCollection selected=shell.bot().tree().selection();
  String wizardNode=selected.get(0,0);
  assertEquals(myRepoViewUtil.getWorkdirItem(tree,repositoryFile).getText(),wizardNode);
  waitInUI();
  shell.close();
  myRepoViewUtil.getWorkdirItem(tree,repositoryFile).expand().getNode(Constants.DOT_GIT).select();
  ContextMenuHelper.clickContextMenu(tree,myUtil.getPluginLocalizedValue(""String_Node_Str""));
  shell=bot.shell(wizardTitle);
  selected=shell.bot().tree().selection();
  wizardNode=selected.get(0,0);
  assertEquals(Constants.DOT_GIT,wizardNode);
  shell.bot().button(IDialogConstants.NEXT_LABEL).click();
  waitInUI();
  assertTrue(shell.bot().tree().getAllItems().length == 0);
  shell.bot().button(IDialogConstants.BACK_LABEL).click();
  shell.bot().tree().getAllItems()[0].getNode(PROJ1).select();
  shell.bot().button(IDialogConstants.NEXT_LABEL).click();
  waitInUI();
  assertTrue(shell.bot().tree().getAllItems().length == 1);
  assertTrue(!shell.bot().button(IDialogConstants.FINISH_LABEL).isEnabled());
  shell.bot().button(UIText.WizardProjectsImportPage_selectAll).click();
  assertTrue(shell.bot().button(IDialogConstants.FINISH_LABEL).isEnabled());
  shell.bot().button(IDialogConstants.FINISH_LABEL).click();
  waitInUI();
  assertProjectExistence(PROJ1,true);
}","/** 
 * Import wizard golden path test
 * @throws Exception
 */
@Test public void testImportWizard() throws Exception {
  deleteAllProjects();
  assertProjectExistence(PROJ1,false);
  SWTBotTree tree=getOrOpenView().bot().tree();
  SWTBotTreeItem item=myRepoViewUtil.getRootItem(tree,repositoryFile);
  String wizardTitle=NLS.bind(UIText.GitCreateProjectViaWizardWizard_WizardTitle,repositoryFile.getPath());
  item.select();
  ContextMenuHelper.clickContextMenu(tree,myUtil.getPluginLocalizedValue(""String_Node_Str""));
  SWTBotShell shell=bot.shell(wizardTitle);
  bot.radio(UIText.GitSelectWizardPage_ImportExistingButton).click();
  bot.radio(UIText.GitSelectWizardPage_AutoShareButton).click();
  TableCollection selected=shell.bot().tree().selection();
  String wizardNode=selected.get(0,0);
  assertEquals(myRepoViewUtil.getWorkdirItem(tree,repositoryFile).getText(),wizardNode);
  waitInUI();
  shell.close();
  myRepoViewUtil.getWorkdirItem(tree,repositoryFile).expand().getNode(Constants.DOT_GIT).select();
  ContextMenuHelper.clickContextMenu(tree,myUtil.getPluginLocalizedValue(""String_Node_Str""));
  shell=bot.shell(wizardTitle);
  selected=shell.bot().tree().selection();
  wizardNode=selected.get(0,0);
  assertEquals(Constants.DOT_GIT,wizardNode);
  shell.bot().button(IDialogConstants.NEXT_LABEL).click();
  shell.bot().label(""String_Node_Str"");
  assertTrue(shell.bot().tree().getAllItems().length == 0);
  shell.bot().button(IDialogConstants.BACK_LABEL).click();
  shell.bot().tree().getAllItems()[0].getNode(PROJ1).select();
  shell.bot().button(IDialogConstants.NEXT_LABEL).click();
  waitInUI();
  assertTrue(shell.bot().tree().getAllItems().length == 1);
  assertTrue(!shell.bot().button(IDialogConstants.FINISH_LABEL).isEnabled());
  shell.bot().button(UIText.WizardProjectsImportPage_selectAll).click();
  assertTrue(shell.bot().button(IDialogConstants.FINISH_LABEL).isEnabled());
  shell.bot().button(IDialogConstants.FINISH_LABEL).click();
  waitInUI();
  assertProjectExistence(PROJ1,true);
}",0.9890329012961117
91534,"@Test public void shouldReturnListOfChanges() throws Exception {
  resetRepository(PROJ1);
  changeFilesInProject();
  showDialog(PROJ1,""String_Node_Str"",""String_Node_Str"");
  bot.shell(""String_Node_Str"" + REPO1 + File.separator+ ""String_Node_Str"").activate();
  bot.comboBox(0).setSelection(UIText.SynchronizeWithAction_localRepoName);
  bot.comboBox(1).setSelection(HEAD);
  bot.comboBox(2).setSelection(UIText.SynchronizeWithAction_localRepoName);
  bot.comboBox(3).setSelection(MASTER);
  bot.checkBox(""String_Node_Str"").click();
  bot.button(IDialogConstants.OK_LABEL).click();
  bot.sleep(1000);
  SWTBotTree syncViewTree=bot.viewByTitle(""String_Node_Str"").bot().tree();
  assertEquals(1,syncViewTree.getAllItems().length);
  SWTBotTreeItem[] syncItems=syncViewTree.getAllItems();
  assertEquals(UIText.GitModelWorkingTree_workingTree,syncItems[0].getText());
}","@Test public void shouldReturnListOfChanges() throws Exception {
  resetRepository(PROJ1);
  changeFilesInProject();
  showDialog(PROJ1,""String_Node_Str"",""String_Node_Str"");
  bot.shell(""String_Node_Str"" + REPO1 + File.separator+ ""String_Node_Str"").activate();
  bot.comboBox(0).setSelection(UIText.SynchronizeWithAction_localRepoName);
  bot.comboBox(1).setSelection(HEAD);
  bot.comboBox(2).setSelection(UIText.SynchronizeWithAction_localRepoName);
  bot.comboBox(3).setSelection(MASTER);
  bot.checkBox(""String_Node_Str"").click();
  bot.button(IDialogConstants.OK_LABEL).click();
  bot.sleep(1000);
  SWTBotTree syncViewTree=bot.viewByTitle(""String_Node_Str"").bot().tree();
  bot.waitUntil(Conditions.treeHasRows(syncViewTree,1),10000);
  SWTBotTreeItem[] syncItems=syncViewTree.getAllItems();
  assertEquals(UIText.GitModelWorkingTree_workingTree,syncItems[0].getText());
}",0.8681192660550459
91535,"private void saveOriginalChangeId(){
  int changeIdOffset=findOffsetOfChangeIdLine(previousCommitMessage);
  if (changeIdOffset > 0) {
    int endOfChangeId=findNextEOL(changeIdOffset,previousCommitMessage);
    int sha1Offset=changeIdOffset + ""String_Node_Str"".length();
    try {
      originalChangeId=ObjectId.fromString(previousCommitMessage.substring(sha1Offset,endOfChangeId));
    }
 catch (    IllegalArgumentException e) {
      originalChangeId=null;
    }
  }
 else   originalChangeId=null;
}","private void saveOriginalChangeId(){
  int changeIdOffset=findOffsetOfChangeIdLine(previousCommitMessage);
  if (changeIdOffset > 0) {
    int endOfChangeId=findNextEOL(changeIdOffset,previousCommitMessage);
    if (endOfChangeId < 0)     endOfChangeId=previousCommitMessage.length() - 1;
    int sha1Offset=changeIdOffset + ""String_Node_Str"".length();
    try {
      originalChangeId=ObjectId.fromString(previousCommitMessage.substring(sha1Offset,endOfChangeId));
    }
 catch (    IllegalArgumentException e) {
      originalChangeId=null;
    }
  }
 else   originalChangeId=null;
}",0.9256198347107438
91536,"@Test public void testTagDialogShowExistingTags() throws Exception {
  SWTBotShell tagDialog=openTagDialog();
  int index=tagDialog.bot().tableWithLabel(UIText.CreateTagDialog_existingTags).indexOf(""String_Node_Str"");
  assertTrue(""String_Node_Str"",index >= 0);
}","@Test public void testTagDialogShowExistingTags() throws Exception {
  SWTBotShell tagDialog=openTagDialog();
  SWTBotTable table=tagDialog.bot().tableWithLabel(UIText.CreateTagDialog_existingTags);
  TestUtil.waitUntilTableHasRowWithText(tagDialog.bot(),table,""String_Node_Str"",10000);
}",0.7295825771324864
91537,"@Test public void testCloneRepoButton() throws Exception {
  clearView();
  refreshAndWait();
  assertEmpty();
  getOrOpenView().toolbarButton(myUtil.getPluginLocalizedValue(""String_Node_Str"")).click();
  SWTBotShell shell=bot.shell(UIText.GitCloneWizard_title).activate();
  shell.bot().textInGroup(UIText.RepositorySelectionPage_groupLocation,0).setText(repositoryFile.getPath());
  shell.bot().button(IDialogConstants.NEXT_LABEL).click();
  waitInUI();
  shell.bot().button(IDialogConstants.NEXT_LABEL).click();
  waitInUI();
  SWTBotText pathText=shell.bot().text(0);
  pathText.setText(pathText.getText() + ""String_Node_Str"");
  shell.bot().button(IDialogConstants.FINISH_LABEL).click();
  waitInUI();
  refreshAndWait();
  assertHasClonedRepo();
}","@Test public void testCloneRepoButton() throws Exception {
  clearView();
  refreshAndWait();
  assertEmpty();
  getOrOpenView().toolbarButton(myUtil.getPluginLocalizedValue(""String_Node_Str"")).click();
  SWTBotShell shell=bot.shell(UIText.GitCloneWizard_title).activate();
  shell.bot().textInGroup(UIText.RepositorySelectionPage_groupLocation,0).setText(repositoryFile.getPath());
  shell.bot().button(IDialogConstants.NEXT_LABEL).click();
  waitInUI();
  shell.bot().button(IDialogConstants.NEXT_LABEL).click();
  waitInUI();
  SWTBotText pathText=shell.bot().text(0);
  pathText.setText(pathText.getText() + ""String_Node_Str"");
  shell.bot().button(IDialogConstants.FINISH_LABEL).click();
  refreshAndWait();
  assertHasClonedRepo();
}",0.9906166219839142
91538,"private void assertHasClonedRepo() throws Exception {
  final SWTBotTree tree=getOrOpenView().bot().tree();
  final SWTBotTreeItem[] items=tree.getAllItems();
  boolean found=false;
  for (  SWTBotTreeItem item : items) {
    if (item.getText().startsWith(repositoryFile.getParentFile().getName() + ""String_Node_Str"")) {
      found=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"",found);
}","private void assertHasClonedRepo() throws Exception {
  final SWTBotTree tree=getOrOpenView().bot().tree();
  String text=repositoryFile.getParentFile().getName() + ""String_Node_Str"";
  TestUtil.waitUntilTreeHasNodeWithText(bot,tree,text,10000);
}",0.551617873651772
91539,"@Test public void testDeleteSingleBranch() throws Exception {
  SWTBotTree tree=getOrOpenView().bot().tree();
  refreshAndWait();
  SWTBotTreeItem localBranchesItem=myRepoViewUtil.getLocalBranchesItem(tree,repositoryFile).expand();
  SWTBotTreeItem masterNode=localBranchesItem.getNode(""String_Node_Str"");
  masterNode.select();
  ContextMenuHelper.clickContextMenu(tree,myUtil.getPluginLocalizedValue(""String_Node_Str""));
  TestUtil.joinJobs(JobFamilies.CHECKOUT);
  ContextMenuHelper.clickContextMenu(tree,myUtil.getPluginLocalizedValue(""String_Node_Str""));
  SWTBotShell createBranchShell=bot.shell(UIText.CreateBranchWizard_NewBranchTitle);
  createBranchShell.bot().textWithId(""String_Node_Str"").setText(""String_Node_Str"");
  createBranchShell.bot().checkBox().deselect();
  createBranchShell.bot().button(IDialogConstants.FINISH_LABEL).click();
  refreshAndWait();
  localBranchesItem.getNode(""String_Node_Str"").select();
  ContextMenuHelper.clickContextMenu(tree,myUtil.getPluginLocalizedValue(""String_Node_Str""));
  refreshAndWait();
  SWTBotTreeItem[] items=myRepoViewUtil.getLocalBranchesItem(tree,repositoryFile).getItems();
  assertEquals(""String_Node_Str"",2,items.length);
  assertEquals(""String_Node_Str"",items[0].getText());
  assertEquals(""String_Node_Str"",items[1].getText());
}","@Test public void testDeleteSingleBranch() throws Exception {
  SWTBotTree tree=getOrOpenView().bot().tree();
  refreshAndWait();
  SWTBotTreeItem localBranchesItem=myRepoViewUtil.getLocalBranchesItem(tree,repositoryFile).expand();
  SWTBotTreeItem masterNode=localBranchesItem.getNode(""String_Node_Str"");
  masterNode.select();
  ContextMenuHelper.clickContextMenu(tree,myUtil.getPluginLocalizedValue(""String_Node_Str""));
  TestUtil.joinJobs(JobFamilies.CHECKOUT);
  ContextMenuHelper.clickContextMenu(tree,myUtil.getPluginLocalizedValue(""String_Node_Str""));
  SWTBotShell createBranchShell=bot.shell(UIText.CreateBranchWizard_NewBranchTitle);
  createBranchShell.bot().textWithId(""String_Node_Str"").setText(""String_Node_Str"");
  createBranchShell.bot().checkBox().deselect();
  createBranchShell.bot().button(IDialogConstants.FINISH_LABEL).click();
  refreshAndWait();
  localBranchesItem=myRepoViewUtil.getLocalBranchesItem(tree,repositoryFile).expand();
  localBranchesItem.getNode(""String_Node_Str"").select();
  ContextMenuHelper.clickContextMenu(tree,myUtil.getPluginLocalizedValue(""String_Node_Str""));
  refreshAndWait();
  SWTBotTreeItem[] items=myRepoViewUtil.getLocalBranchesItem(tree,repositoryFile).getItems();
  assertEquals(""String_Node_Str"",2,items.length);
  assertEquals(""String_Node_Str"",items[0].getText());
  assertEquals(""String_Node_Str"",items[1].getText());
}",0.9675009338812104
91540,"/** 
 * Import wizard golden path test
 * @throws Exception
 */
@Test public void testImportWizard() throws Exception {
  deleteAllProjects();
  assertProjectExistence(PROJ1,false);
  SWTBotTree tree=getOrOpenView().bot().tree();
  SWTBotTreeItem item=myRepoViewUtil.getRootItem(tree,repositoryFile);
  String wizardTitle=NLS.bind(UIText.GitCreateProjectViaWizardWizard_WizardTitle,repositoryFile.getPath());
  item.select();
  ContextMenuHelper.clickContextMenu(tree,myUtil.getPluginLocalizedValue(""String_Node_Str""));
  SWTBotShell shell=bot.shell(wizardTitle);
  bot.radio(UIText.GitSelectWizardPage_ImportExistingButton).click();
  bot.radio(UIText.GitSelectWizardPage_AutoShareButton).click();
  TableCollection selected=shell.bot().tree().selection();
  String wizardNode=selected.get(0,0);
  assertEquals(myRepoViewUtil.getWorkdirItem(tree,repositoryFile).getText(),wizardNode);
  waitInUI();
  shell.close();
  myRepoViewUtil.getWorkdirItem(tree,repositoryFile).expand().getNode(Constants.DOT_GIT).select();
  ContextMenuHelper.clickContextMenu(tree,myUtil.getPluginLocalizedValue(""String_Node_Str""));
  shell=bot.shell(wizardTitle);
  selected=shell.bot().tree().selection();
  wizardNode=selected.get(0,0);
  assertEquals(Constants.DOT_GIT,wizardNode);
  shell.bot().button(IDialogConstants.NEXT_LABEL).click();
  waitInUI();
  assertTrue(shell.bot().tree().getAllItems().length == 0);
  shell.bot().button(IDialogConstants.BACK_LABEL).click();
  shell.bot().tree().getAllItems()[0].getNode(PROJ1).select();
  shell.bot().button(IDialogConstants.NEXT_LABEL).click();
  waitInUI();
  assertTrue(shell.bot().tree().getAllItems().length == 1);
  assertTrue(!shell.bot().button(IDialogConstants.FINISH_LABEL).isEnabled());
  shell.bot().button(UIText.WizardProjectsImportPage_selectAll).click();
  assertTrue(shell.bot().button(IDialogConstants.FINISH_LABEL).isEnabled());
  shell.bot().button(IDialogConstants.FINISH_LABEL).click();
  waitInUI();
  assertProjectExistence(PROJ1,true);
}","/** 
 * Import wizard golden path test
 * @throws Exception
 */
@Test public void testImportWizard() throws Exception {
  deleteAllProjects();
  assertProjectExistence(PROJ1,false);
  SWTBotTree tree=getOrOpenView().bot().tree();
  SWTBotTreeItem item=myRepoViewUtil.getRootItem(tree,repositoryFile);
  String wizardTitle=NLS.bind(UIText.GitCreateProjectViaWizardWizard_WizardTitle,repositoryFile.getPath());
  item.select();
  ContextMenuHelper.clickContextMenu(tree,myUtil.getPluginLocalizedValue(""String_Node_Str""));
  SWTBotShell shell=bot.shell(wizardTitle);
  bot.radio(UIText.GitSelectWizardPage_ImportExistingButton).click();
  bot.radio(UIText.GitSelectWizardPage_AutoShareButton).click();
  TableCollection selected=shell.bot().tree().selection();
  String wizardNode=selected.get(0,0);
  assertEquals(myRepoViewUtil.getWorkdirItem(tree,repositoryFile).getText(),wizardNode);
  waitInUI();
  shell.close();
  myRepoViewUtil.getWorkdirItem(tree,repositoryFile).expand().getNode(Constants.DOT_GIT).select();
  ContextMenuHelper.clickContextMenu(tree,myUtil.getPluginLocalizedValue(""String_Node_Str""));
  shell=bot.shell(wizardTitle);
  selected=shell.bot().tree().selection();
  wizardNode=selected.get(0,0);
  assertEquals(Constants.DOT_GIT,wizardNode);
  shell.bot().button(IDialogConstants.NEXT_LABEL).click();
  shell.bot().label(""String_Node_Str"");
  assertTrue(shell.bot().tree().getAllItems().length == 0);
  shell.bot().button(IDialogConstants.BACK_LABEL).click();
  shell.bot().tree().getAllItems()[0].getNode(PROJ1).select();
  shell.bot().button(IDialogConstants.NEXT_LABEL).click();
  waitInUI();
  assertTrue(shell.bot().tree().getAllItems().length == 1);
  assertTrue(!shell.bot().button(IDialogConstants.FINISH_LABEL).isEnabled());
  shell.bot().button(UIText.WizardProjectsImportPage_selectAll).click();
  assertTrue(shell.bot().button(IDialogConstants.FINISH_LABEL).isEnabled());
  shell.bot().button(IDialogConstants.FINISH_LABEL).click();
  waitInUI();
  assertProjectExistence(PROJ1,true);
}",0.9890329012961117
91541,"@Test public void shouldReturnListOfChanges() throws Exception {
  resetRepository(PROJ1);
  changeFilesInProject();
  showDialog(PROJ1,""String_Node_Str"",""String_Node_Str"");
  bot.shell(""String_Node_Str"" + REPO1 + File.separator+ ""String_Node_Str"").activate();
  bot.comboBox(0).setSelection(UIText.SynchronizeWithAction_localRepoName);
  bot.comboBox(1).setSelection(HEAD);
  bot.comboBox(2).setSelection(UIText.SynchronizeWithAction_localRepoName);
  bot.comboBox(3).setSelection(MASTER);
  bot.checkBox(""String_Node_Str"").click();
  bot.button(IDialogConstants.OK_LABEL).click();
  bot.sleep(1000);
  SWTBotTree syncViewTree=bot.viewByTitle(""String_Node_Str"").bot().tree();
  assertEquals(1,syncViewTree.getAllItems().length);
  SWTBotTreeItem[] syncItems=syncViewTree.getAllItems();
  assertEquals(UIText.GitModelWorkingTree_workingTree,syncItems[0].getText());
}","@Test public void shouldReturnListOfChanges() throws Exception {
  resetRepository(PROJ1);
  changeFilesInProject();
  showDialog(PROJ1,""String_Node_Str"",""String_Node_Str"");
  bot.shell(""String_Node_Str"" + REPO1 + File.separator+ ""String_Node_Str"").activate();
  bot.comboBox(0).setSelection(UIText.SynchronizeWithAction_localRepoName);
  bot.comboBox(1).setSelection(HEAD);
  bot.comboBox(2).setSelection(UIText.SynchronizeWithAction_localRepoName);
  bot.comboBox(3).setSelection(MASTER);
  bot.checkBox(""String_Node_Str"").click();
  bot.button(IDialogConstants.OK_LABEL).click();
  bot.sleep(1000);
  SWTBotTree syncViewTree=bot.viewByTitle(""String_Node_Str"").bot().tree();
  bot.waitUntil(Conditions.treeHasRows(syncViewTree,1),10000);
  SWTBotTreeItem[] syncItems=syncViewTree.getAllItems();
  assertEquals(UIText.GitModelWorkingTree_workingTree,syncItems[0].getText());
}",0.8681192660550459
91542,"private void saveOriginalChangeId(){
  int changeIdOffset=findOffsetOfChangeIdLine(previousCommitMessage);
  if (changeIdOffset > 0) {
    int endOfChangeId=findNextEOL(changeIdOffset,previousCommitMessage);
    int sha1Offset=changeIdOffset + ""String_Node_Str"".length();
    try {
      originalChangeId=ObjectId.fromString(previousCommitMessage.substring(sha1Offset,endOfChangeId));
    }
 catch (    IllegalArgumentException e) {
      originalChangeId=null;
    }
  }
 else   originalChangeId=null;
}","private void saveOriginalChangeId(){
  int changeIdOffset=findOffsetOfChangeIdLine(previousCommitMessage);
  if (changeIdOffset > 0) {
    int endOfChangeId=findNextEOL(changeIdOffset,previousCommitMessage);
    if (endOfChangeId < 0)     endOfChangeId=previousCommitMessage.length() - 1;
    int sha1Offset=changeIdOffset + ""String_Node_Str"".length();
    try {
      originalChangeId=ObjectId.fromString(previousCommitMessage.substring(sha1Offset,endOfChangeId));
    }
 catch (    IllegalArgumentException e) {
      originalChangeId=null;
    }
  }
 else   originalChangeId=null;
}",0.9256198347107438
91543,"void populate() throws IOException {
  if (GitTraceLocation.QUICKDIFF.isActive())   GitTraceLocation.getTrace().traceEntry(GitTraceLocation.QUICKDIFF.getLocation(),resource);
  TreeWalk tw=null;
  RevWalk rw=null;
  try {
    RepositoryMapping mapping=RepositoryMapping.getMapping(resource);
    if (mapping == null) {
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    final String gitPath=mapping.getRepoRelativePath(resource);
    final Repository repository=mapping.getRepository();
    String baseline=GitQuickDiffProvider.baseline.get(repository);
    if (baseline == null)     baseline=Constants.HEAD;
    ObjectId commitId=repository.resolve(baseline);
    if (commitId != null) {
      if (commitId.equals(lastCommit)) {
        if (GitTraceLocation.QUICKDIFF.isActive())         GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"");
        return;
      }
    }
 else {
      String msg=NLS.bind(UIText.GitDocument_errorResolveQuickdiff,new Object[]{baseline,resource,repository});
      Activator.logError(msg,new Throwable());
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    rw=new RevWalk(repository);
    RevCommit baselineCommit;
    try {
      baselineCommit=rw.parseCommit(commitId);
    }
 catch (    IOException err) {
      String msg=NLS.bind(UIText.GitDocument_errorLoadCommit,new Object[]{commitId,baseline,resource,repository});
      Activator.logError(msg,err);
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    RevTree treeId=baselineCommit.getTree();
    if (treeId.equals(lastTree)) {
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"");
      return;
    }
    tw=TreeWalk.forPath(repository,gitPath,treeId);
    if (tw == null) {
      setResolved(null,null,null,""String_Node_Str"");
      String msg=NLS.bind(UIText.GitDocument_errorLoadTree,new Object[]{treeId,baseline,resource,repository});
      Activator.logError(msg,new Throwable());
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    ObjectId id=tw.getObjectId(0);
    if (id.equals(ObjectId.zeroId())) {
      setResolved(null,null,null,""String_Node_Str"");
      String msg=NLS.bind(UIText.GitDocument_errorLoadTree,new Object[]{treeId,baseline,resource,repository});
      Activator.logError(msg,new Throwable());
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    if (!id.equals(lastBlob)) {
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"" + baseline);
      ObjectLoader loader=repository.open(id,Constants.OBJ_BLOB);
      byte[] bytes=loader.getBytes();
      String charset;
      charset=CompareUtils.getResourceEncoding(resource);
      String s=new String(bytes,charset);
      setResolved(commitId,treeId,id,s);
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"" + s.length() + ""String_Node_Str"");
    }
 else {
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"");
    }
  }
  finally {
    if (tw != null)     tw.release();
    if (rw != null)     rw.release();
    if (GitTraceLocation.QUICKDIFF.isActive())     GitTraceLocation.getTrace().traceExit(GitTraceLocation.QUICKDIFF.getLocation());
  }
}","void populate() throws IOException {
  if (GitTraceLocation.QUICKDIFF.isActive())   GitTraceLocation.getTrace().traceEntry(GitTraceLocation.QUICKDIFF.getLocation(),resource);
  TreeWalk tw=null;
  RevWalk rw=null;
  try {
    RepositoryMapping mapping=RepositoryMapping.getMapping(resource);
    if (mapping == null) {
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    final String gitPath=mapping.getRepoRelativePath(resource);
    final Repository repository=mapping.getRepository();
    String baseline=GitQuickDiffProvider.baseline.get(repository);
    if (baseline == null)     baseline=Constants.HEAD;
    ObjectId commitId=repository.resolve(baseline);
    if (commitId != null) {
      if (commitId.equals(lastCommit)) {
        if (GitTraceLocation.QUICKDIFF.isActive())         GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"");
        return;
      }
    }
 else {
      String msg=NLS.bind(UIText.GitDocument_errorResolveQuickdiff,new Object[]{baseline,resource,repository});
      Activator.logError(msg,new Throwable());
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    rw=new RevWalk(repository);
    RevCommit baselineCommit;
    try {
      baselineCommit=rw.parseCommit(commitId);
    }
 catch (    IOException err) {
      String msg=NLS.bind(UIText.GitDocument_errorLoadCommit,new Object[]{commitId,baseline,resource,repository});
      Activator.logError(msg,err);
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    RevTree treeId=baselineCommit.getTree();
    if (treeId.equals(lastTree)) {
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"");
      return;
    }
    tw=TreeWalk.forPath(repository,gitPath,treeId);
    if (tw == null) {
      setResolved(null,null,null,""String_Node_Str"");
      String msg=NLS.bind(UIText.GitDocument_errorLoadTree,new Object[]{treeId.getName(),baseline,resource,repository});
      Activator.logError(msg,new Throwable());
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    ObjectId id=tw.getObjectId(0);
    if (id.equals(ObjectId.zeroId())) {
      setResolved(null,null,null,""String_Node_Str"");
      String msg=NLS.bind(UIText.GitDocument_errorLoadTree,new Object[]{treeId.getName(),baseline,resource,repository});
      Activator.logError(msg,new Throwable());
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    if (!id.equals(lastBlob)) {
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"" + baseline);
      ObjectLoader loader=repository.open(id,Constants.OBJ_BLOB);
      byte[] bytes=loader.getBytes();
      String charset;
      charset=CompareUtils.getResourceEncoding(resource);
      String s=new String(bytes,charset);
      setResolved(commitId,treeId,id,s);
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"" + s.length() + ""String_Node_Str"");
    }
 else {
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"");
    }
  }
  finally {
    if (tw != null)     tw.release();
    if (rw != null)     rw.release();
    if (GitTraceLocation.QUICKDIFF.isActive())     GitTraceLocation.getTrace().traceExit(GitTraceLocation.QUICKDIFF.getLocation());
  }
}",0.9972051425377306
91544,"void populate() throws IOException {
  if (GitTraceLocation.QUICKDIFF.isActive())   GitTraceLocation.getTrace().traceEntry(GitTraceLocation.QUICKDIFF.getLocation(),resource);
  TreeWalk tw=null;
  RevWalk rw=null;
  try {
    RepositoryMapping mapping=RepositoryMapping.getMapping(resource);
    if (mapping == null) {
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    final String gitPath=mapping.getRepoRelativePath(resource);
    final Repository repository=mapping.getRepository();
    String baseline=GitQuickDiffProvider.baseline.get(repository);
    if (baseline == null)     baseline=Constants.HEAD;
    ObjectId commitId=repository.resolve(baseline);
    if (commitId != null) {
      if (commitId.equals(lastCommit)) {
        if (GitTraceLocation.QUICKDIFF.isActive())         GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"");
        return;
      }
    }
 else {
      String msg=NLS.bind(UIText.GitDocument_errorResolveQuickdiff,new Object[]{baseline,resource,repository});
      Activator.logError(msg,new Throwable());
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    rw=new RevWalk(repository);
    RevCommit baselineCommit;
    try {
      baselineCommit=rw.parseCommit(commitId);
    }
 catch (    IOException err) {
      String msg=NLS.bind(UIText.GitDocument_errorLoadCommit,new Object[]{commitId,baseline,resource,repository});
      Activator.logError(msg,err);
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    RevTree treeId=baselineCommit.getTree();
    if (treeId.equals(lastTree)) {
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"");
      return;
    }
    tw=TreeWalk.forPath(repository,gitPath,treeId);
    ObjectId id=tw.getObjectId(0);
    if (id.equals(ObjectId.zeroId())) {
      setResolved(null,null,null,""String_Node_Str"");
      String msg=NLS.bind(UIText.GitDocument_errorLoadTree,new Object[]{treeId,baseline,resource,repository});
      Activator.logError(msg,new Throwable());
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    if (!id.equals(lastBlob)) {
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"" + baseline);
      ObjectLoader loader=repository.open(id,Constants.OBJ_BLOB);
      byte[] bytes=loader.getBytes();
      String charset;
      charset=CompareUtils.getResourceEncoding(resource);
      String s=new String(bytes,charset);
      setResolved(commitId,treeId,id,s);
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"" + s.length() + ""String_Node_Str"");
    }
 else {
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"");
    }
  }
  finally {
    if (tw != null)     tw.release();
    if (rw != null)     rw.release();
    if (GitTraceLocation.QUICKDIFF.isActive())     GitTraceLocation.getTrace().traceExit(GitTraceLocation.QUICKDIFF.getLocation());
  }
}","void populate() throws IOException {
  if (GitTraceLocation.QUICKDIFF.isActive())   GitTraceLocation.getTrace().traceEntry(GitTraceLocation.QUICKDIFF.getLocation(),resource);
  TreeWalk tw=null;
  RevWalk rw=null;
  try {
    RepositoryMapping mapping=RepositoryMapping.getMapping(resource);
    if (mapping == null) {
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    final String gitPath=mapping.getRepoRelativePath(resource);
    final Repository repository=mapping.getRepository();
    String baseline=GitQuickDiffProvider.baseline.get(repository);
    if (baseline == null)     baseline=Constants.HEAD;
    ObjectId commitId=repository.resolve(baseline);
    if (commitId != null) {
      if (commitId.equals(lastCommit)) {
        if (GitTraceLocation.QUICKDIFF.isActive())         GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"");
        return;
      }
    }
 else {
      String msg=NLS.bind(UIText.GitDocument_errorResolveQuickdiff,new Object[]{baseline,resource,repository});
      Activator.logError(msg,new Throwable());
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    rw=new RevWalk(repository);
    RevCommit baselineCommit;
    try {
      baselineCommit=rw.parseCommit(commitId);
    }
 catch (    IOException err) {
      String msg=NLS.bind(UIText.GitDocument_errorLoadCommit,new Object[]{commitId,baseline,resource,repository});
      Activator.logError(msg,err);
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    RevTree treeId=baselineCommit.getTree();
    if (treeId.equals(lastTree)) {
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"");
      return;
    }
    tw=TreeWalk.forPath(repository,gitPath,treeId);
    if (tw == null) {
      setResolved(null,null,null,""String_Node_Str"");
      String msg=NLS.bind(UIText.GitDocument_errorLoadTree,new Object[]{treeId,baseline,resource,repository});
      Activator.logError(msg,new Throwable());
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    ObjectId id=tw.getObjectId(0);
    if (id.equals(ObjectId.zeroId())) {
      setResolved(null,null,null,""String_Node_Str"");
      String msg=NLS.bind(UIText.GitDocument_errorLoadTree,new Object[]{treeId,baseline,resource,repository});
      Activator.logError(msg,new Throwable());
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    if (!id.equals(lastBlob)) {
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"" + baseline);
      ObjectLoader loader=repository.open(id,Constants.OBJ_BLOB);
      byte[] bytes=loader.getBytes();
      String charset;
      charset=CompareUtils.getResourceEncoding(resource);
      String s=new String(bytes,charset);
      setResolved(commitId,treeId,id,s);
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"" + s.length() + ""String_Node_Str"");
    }
 else {
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"");
    }
  }
  finally {
    if (tw != null)     tw.release();
    if (rw != null)     rw.release();
    if (GitTraceLocation.QUICKDIFF.isActive())     GitTraceLocation.getTrace().traceExit(GitTraceLocation.QUICKDIFF.getLocation());
  }
}",0.9551976573938508
91545,"void populate() throws IOException {
  if (GitTraceLocation.QUICKDIFF.isActive())   GitTraceLocation.getTrace().traceEntry(GitTraceLocation.QUICKDIFF.getLocation(),resource);
  TreeWalk tw=null;
  RevWalk rw=null;
  try {
    RepositoryMapping mapping=RepositoryMapping.getMapping(resource);
    if (mapping == null) {
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    final String gitPath=mapping.getRepoRelativePath(resource);
    final Repository repository=mapping.getRepository();
    String baseline=GitQuickDiffProvider.baseline.get(repository);
    if (baseline == null)     baseline=Constants.HEAD;
    ObjectId commitId=repository.resolve(baseline);
    if (commitId != null) {
      if (commitId.equals(lastCommit)) {
        if (GitTraceLocation.QUICKDIFF.isActive())         GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"");
        return;
      }
    }
 else {
      String msg=NLS.bind(UIText.GitDocument_errorResolveQuickdiff,new Object[]{baseline,resource,repository});
      Activator.logError(msg,new Throwable());
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    rw=new RevWalk(repository);
    RevCommit baselineCommit;
    try {
      baselineCommit=rw.parseCommit(commitId);
    }
 catch (    IOException err) {
      String msg=NLS.bind(UIText.GitDocument_errorLoadCommit,new Object[]{commitId,baseline,resource,repository});
      Activator.logError(msg,err);
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    RevTree treeId=baselineCommit.getTree();
    if (treeId.equals(lastTree)) {
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"");
      return;
    }
    tw=TreeWalk.forPath(repository,gitPath,treeId);
    ObjectId id=tw.getObjectId(0);
    if (id.equals(ObjectId.zeroId())) {
      setResolved(null,null,null,""String_Node_Str"");
      String msg=NLS.bind(UIText.GitDocument_errorLoadTree,new Object[]{treeId,baseline,resource,repository});
      Activator.logError(msg,new Throwable());
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    if (!id.equals(lastBlob)) {
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"" + baseline);
      ObjectLoader loader=repository.open(id,Constants.OBJ_BLOB);
      byte[] bytes=loader.getBytes();
      String charset;
      charset=CompareUtils.getResourceEncoding(resource);
      String s=new String(bytes,charset);
      setResolved(commitId,treeId,id,s);
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"" + s.length() + ""String_Node_Str"");
    }
 else {
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"");
    }
  }
  finally {
    if (tw != null)     tw.release();
    if (rw != null)     rw.release();
    if (GitTraceLocation.QUICKDIFF.isActive())     GitTraceLocation.getTrace().traceExit(GitTraceLocation.QUICKDIFF.getLocation());
  }
}","void populate() throws IOException {
  if (GitTraceLocation.QUICKDIFF.isActive())   GitTraceLocation.getTrace().traceEntry(GitTraceLocation.QUICKDIFF.getLocation(),resource);
  TreeWalk tw=null;
  RevWalk rw=null;
  try {
    RepositoryMapping mapping=RepositoryMapping.getMapping(resource);
    if (mapping == null) {
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    final String gitPath=mapping.getRepoRelativePath(resource);
    final Repository repository=mapping.getRepository();
    String baseline=GitQuickDiffProvider.baseline.get(repository);
    if (baseline == null)     baseline=Constants.HEAD;
    ObjectId commitId=repository.resolve(baseline);
    if (commitId != null) {
      if (commitId.equals(lastCommit)) {
        if (GitTraceLocation.QUICKDIFF.isActive())         GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"");
        return;
      }
    }
 else {
      String msg=NLS.bind(UIText.GitDocument_errorResolveQuickdiff,new Object[]{baseline,resource,repository});
      Activator.logError(msg,new Throwable());
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    rw=new RevWalk(repository);
    RevCommit baselineCommit;
    try {
      baselineCommit=rw.parseCommit(commitId);
    }
 catch (    IOException err) {
      String msg=NLS.bind(UIText.GitDocument_errorLoadCommit,new Object[]{commitId,baseline,resource,repository});
      Activator.logError(msg,err);
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    RevTree treeId=baselineCommit.getTree();
    if (treeId.equals(lastTree)) {
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"");
      return;
    }
    tw=TreeWalk.forPath(repository,gitPath,treeId);
    if (tw == null) {
      setResolved(null,null,null,""String_Node_Str"");
      String msg=NLS.bind(UIText.GitDocument_errorLoadTree,new Object[]{treeId,baseline,resource,repository});
      Activator.logError(msg,new Throwable());
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    ObjectId id=tw.getObjectId(0);
    if (id.equals(ObjectId.zeroId())) {
      setResolved(null,null,null,""String_Node_Str"");
      String msg=NLS.bind(UIText.GitDocument_errorLoadTree,new Object[]{treeId,baseline,resource,repository});
      Activator.logError(msg,new Throwable());
      setResolved(null,null,null,""String_Node_Str"");
      return;
    }
    if (!id.equals(lastBlob)) {
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"" + baseline);
      ObjectLoader loader=repository.open(id,Constants.OBJ_BLOB);
      byte[] bytes=loader.getBytes();
      String charset;
      charset=CompareUtils.getResourceEncoding(resource);
      String s=new String(bytes,charset);
      setResolved(commitId,treeId,id,s);
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"" + s.length() + ""String_Node_Str"");
    }
 else {
      if (GitTraceLocation.QUICKDIFF.isActive())       GitTraceLocation.getTrace().trace(GitTraceLocation.QUICKDIFF.getLocation(),""String_Node_Str"");
    }
  }
  finally {
    if (tw != null)     tw.release();
    if (rw != null)     rw.release();
    if (GitTraceLocation.QUICKDIFF.isActive())     GitTraceLocation.getTrace().traceExit(GitTraceLocation.QUICKDIFF.getLocation());
  }
}",0.9551976573938508
91546,"public ITypedElement getRight(){
  return CompareUtils.getFileRevisionTypedElement(gitPath,baseCommit,repo,baseId);
}","public ITypedElement getRight(){
  return CompareUtils.getFileRevisionTypedElement(gitPath,remoteCommit,repo,baseId);
}",0.9661016949152542
91547,"public ITypedElement getLeft(){
  return CompareUtils.getFileRevisionTypedElement(gitPath,remoteCommit,repo,remoteId);
}","public ITypedElement getLeft(){
  return CompareUtils.getFileRevisionTypedElement(gitPath,baseCommit,repo,remoteId);
}",0.9663865546218487
91548,"private String getAbbreviatedId(GitModelCommit commit){
  RevCommit remoteCommit=commit.getRemoteCommit();
  ObjectReader reader=commit.getRepository().newObjectReader();
  ObjectId commitId=remoteCommit.getId();
  AbbreviatedObjectId shortId;
  try {
    shortId=reader.abbreviate(commitId,6);
  }
 catch (  IOException e) {
    shortId=AbbreviatedObjectId.fromObjectId(ObjectId.zeroId());
    Activator.logError(e.getMessage(),e);
  }
 finally {
    reader.release();
  }
  return shortId.name();
}","private String getAbbreviatedId(GitModelCommit commit){
  RevCommit remoteCommit=commit.getBaseCommit();
  ObjectReader reader=commit.getRepository().newObjectReader();
  ObjectId commitId=remoteCommit.getId();
  AbbreviatedObjectId shortId;
  try {
    shortId=reader.abbreviate(commitId,6);
  }
 catch (  IOException e) {
    shortId=AbbreviatedObjectId.fromObjectId(ObjectId.zeroId());
    Activator.logError(e.getMessage(),e);
  }
 finally {
    reader.release();
  }
  return shortId.name();
}",0.9919839679358716
91549,"@Override public int compare(Viewer viewer,Object e1,Object e2){
  if (e1 instanceof GitModelWorkingTree)   return -1;
  if (e2 instanceof GitModelWorkingTree)   return 1;
  if (e1 instanceof GitModelCache)   return -2;
  if (e2 instanceof GitModelCache)   return 2;
  if (e1 instanceof GitModelCommit && e2 instanceof GitModelCommit) {
    RevCommit rc1=((GitModelCommit)e1).getRemoteCommit();
    RevCommit rc2=((GitModelCommit)e2).getRemoteCommit();
    return rc2.getCommitTime() - rc1.getCommitTime();
  }
  return super.compare(viewer,e1,e2);
}","@Override public int compare(Viewer viewer,Object e1,Object e2){
  if (e1 instanceof GitModelWorkingTree)   return -1;
  if (e2 instanceof GitModelWorkingTree)   return 1;
  if (e1 instanceof GitModelCache)   return -2;
  if (e2 instanceof GitModelCache)   return 2;
  if (e1 instanceof GitModelCommit && e2 instanceof GitModelCommit) {
    RevCommit rc1=((GitModelCommit)e1).getBaseCommit();
    RevCommit rc2=((GitModelCommit)e2).getBaseCommit();
    return rc2.getCommitTime() - rc1.getCommitTime();
  }
  return super.compare(viewer,e1,e2);
}",0.9854014598540146
91550,"@Override public ResourceTraversal[] getTraversals(ResourceMappingContext context,IProgressMonitor monitor) throws CoreException {
  Repository repo=gitRepo.getRepository();
  List<ResourceTraversal> result=new ArrayList<ResourceTraversal>();
  for (  GitModelObject obj : gitRepo.getChildren())   if (obj instanceof GitModelCommit || obj instanceof GitModelCache) {
    RevCommit revCommit;
    if (obj instanceof GitModelCommit)     revCommit=((GitModelCommit)obj).getRemoteCommit();
 else     revCommit=((GitModelCache)obj).getRemoteCommit();
    result.add(new GitTreeTraversal(repo,revCommit));
  }
  return result.toArray(new ResourceTraversal[result.size()]);
}","@Override public ResourceTraversal[] getTraversals(ResourceMappingContext context,IProgressMonitor monitor) throws CoreException {
  Repository repo=gitRepo.getRepository();
  List<ResourceTraversal> result=new ArrayList<ResourceTraversal>();
  for (  GitModelObject obj : gitRepo.getChildren())   if (obj instanceof GitModelCommit || obj instanceof GitModelCache) {
    RevCommit revCommit;
    if (obj instanceof GitModelCommit)     revCommit=((GitModelCommit)obj).getBaseCommit();
 else     revCommit=((GitModelCache)obj).getBaseCommit();
    result.add(new GitTreeTraversal(repo,revCommit));
  }
  return result.toArray(new ResourceTraversal[result.size()]);
}",0.987987987987988
91551,"private GitModelObject extractFromCache(TreeWalk tw) throws IOException {
  DirCacheIterator cacheIterator=tw.getTree(dirCacheIteratorNth,DirCacheIterator.class);
  if (cacheIterator == null)   return null;
  DirCacheEntry cacheEntry=cacheIterator.getDirCacheEntry();
  if (cacheEntry == null)   return null;
  if (shouldIncludeEntry(tw)) {
    String path=new String(tw.getRawPath());
    ObjectId repoId=tw.getObjectId(BASE_NTH);
    ObjectId cacheId=tw.getObjectId(REMOTE_NTH);
    if (path.split(""String_Node_Str"").length > 1)     return handleCacheTree(repoId,cacheId,path);
    return fileFactory.createFileModel(this,remoteCommit,repoId,cacheId,path);
  }
  return null;
}","private GitModelObject extractFromCache(TreeWalk tw) throws IOException {
  DirCacheIterator cacheIterator=tw.getTree(dirCacheIteratorNth,DirCacheIterator.class);
  if (cacheIterator == null)   return null;
  DirCacheEntry cacheEntry=cacheIterator.getDirCacheEntry();
  if (cacheEntry == null)   return null;
  if (shouldIncludeEntry(tw)) {
    String path=new String(tw.getRawPath());
    ObjectId repoId=tw.getObjectId(BASE_NTH);
    ObjectId cacheId=tw.getObjectId(REMOTE_NTH);
    if (path.split(""String_Node_Str"").length > 1)     return handleCacheTree(repoId,cacheId,path);
    return fileFactory.createFileModel(this,baseCommit,repoId,cacheId,path);
  }
  return null;
}",0.9941002949852508
91552,"private GitModelObject handleCacheTree(ObjectId repoId,ObjectId cacheId,String path) throws IOException {
  String pathKey=path.split(""String_Node_Str"")[0];
  GitModelCacheTree cacheTree=cacheTreeMap.get(pathKey);
  if (cacheTree == null) {
    cacheTree=new GitModelCacheTree(this,remoteCommit,repoId,cacheId,pathKey,fileFactory);
    cacheTreeMap.put(pathKey,cacheTree);
  }
  cacheTree.addChild(repoId,cacheId,path.substring(path.indexOf('/') + 1));
  return cacheTree;
}","private GitModelObject handleCacheTree(ObjectId repoId,ObjectId cacheId,String path) throws IOException {
  String pathKey=path.split(""String_Node_Str"")[0];
  GitModelCacheTree cacheTree=cacheTreeMap.get(pathKey);
  if (cacheTree == null) {
    cacheTree=new GitModelCacheTree(this,baseCommit,repoId,cacheId,pathKey,fileFactory);
    cacheTreeMap.put(pathKey,cacheTree);
  }
  cacheTree.addChild(repoId,cacheId,path.substring(path.indexOf('/') + 1));
  return cacheTree;
}",0.9915433403805496
91553,"void addChild(ObjectId repoId,ObjectId cacheId,String path) throws IOException {
  String[] entrys=path.split(""String_Node_Str"");
  String pathKey=entrys[0];
  if (entrys.length > 1) {
    GitModelCacheTree cacheEntry=(GitModelCacheTree)cacheTreeMap.get(pathKey);
    if (cacheEntry == null) {
      cacheEntry=new GitModelCacheTree(this,remoteCommit,repoId,cacheId,pathKey,factory);
      cacheTreeMap.put(pathKey,cacheEntry);
    }
    cacheEntry.addChild(repoId,cacheId,path.substring(path.indexOf('/') + 1));
  }
 else   cacheTreeMap.put(pathKey,factory.createFileModel(this,remoteCommit,repoId,cacheId,pathKey));
}","void addChild(ObjectId repoId,ObjectId cacheId,String path) throws IOException {
  String[] entrys=path.split(""String_Node_Str"");
  String pathKey=entrys[0];
  if (entrys.length > 1) {
    GitModelCacheTree cacheEntry=(GitModelCacheTree)cacheTreeMap.get(pathKey);
    if (cacheEntry == null) {
      cacheEntry=new GitModelCacheTree(this,baseCommit,repoId,cacheId,pathKey,factory);
      cacheTreeMap.put(pathKey,cacheEntry);
    }
    cacheEntry.addChild(repoId,cacheId,path.substring(path.indexOf('/') + 1));
  }
 else   cacheTreeMap.put(pathKey,factory.createFileModel(this,baseCommit,repoId,cacheId,pathKey));
}",0.987034035656402
91554,"@Override public int hashCode(){
  int result=getLocation().hashCode() ^ remoteCommit.hashCode();
  if (baseCommit != null)   result^=baseCommit.hashCode();
  return result;
}","@Override public int hashCode(){
  int result=getLocation().hashCode() ^ baseCommit.hashCode();
  if (remoteCommit != null)   result^=remoteCommit.hashCode();
  return result;
}",0.9318181818181818
91555,"@Override protected GitModelObject[] getChildrenImpl(){
  TreeWalk tw=createTreeWalk();
  List<GitModelObject> result=new ArrayList<GitModelObject>();
  try {
    RevTree actualTree=remoteCommit.getTree();
    int actualNth=tw.addTree(actualTree);
    int baseNth=-1;
    if (baseCommit != null)     baseNth=tw.addTree(baseCommit.getTree());
    int ancestorNth=tw.addTree(ancestorCommit.getTree());
    while (tw.next()) {
      GitModelObject obj=getModelObject(tw,ancestorNth,baseNth,actualNth);
      if (obj != null)       result.add(obj);
    }
  }
 catch (  IOException e) {
    Activator.logError(e.getMessage(),e);
  }
  return result.toArray(new GitModelObject[result.size()]);
}","@Override protected GitModelObject[] getChildrenImpl(){
  TreeWalk tw=createTreeWalk();
  List<GitModelObject> result=new ArrayList<GitModelObject>();
  try {
    RevTree actualTree=baseCommit.getTree();
    int actualNth=tw.addTree(actualTree);
    int baseNth=-1;
    if (remoteCommit != null)     baseNth=tw.addTree(remoteCommit.getTree());
    int ancestorNth=tw.addTree(ancestorCommit.getTree());
    while (tw.next()) {
      GitModelObject obj=getModelObject(tw,ancestorNth,baseNth,actualNth);
      if (obj != null)       result.add(obj);
    }
  }
 catch (  IOException e) {
    Activator.logError(e.getMessage(),e);
  }
  return result.toArray(new GitModelObject[result.size()]);
}",0.982608695652174
91556,"@Override public String getName(){
  if (name == null)   name=remoteCommit.getShortMessage();
  return name;
}","@Override public String getName(){
  if (name == null)   name=baseCommit.getShortMessage();
  return name;
}",0.963302752293578
91557,"/** 
 * @param parent instance of parent object
 * @param commit commit connected with this container
 * @param direction indicate change direction
 * @throws IOException
 */
protected GitModelObjectContainer(GitModelObject parent,RevCommit commit,int direction) throws IOException {
  super(parent);
  kind=direction;
  remoteCommit=commit;
  ancestorCommit=calculateAncestor(remoteCommit);
  RevCommit[] parents=remoteCommit.getParents();
  if (parents != null && parents.length > 0)   baseCommit=remoteCommit.getParent(0);
 else {
    baseCommit=null;
  }
}","/** 
 * @param parent instance of parent object
 * @param commit commit connected with this container
 * @param direction indicate change direction
 * @throws IOException
 */
protected GitModelObjectContainer(GitModelObject parent,RevCommit commit,int direction) throws IOException {
  super(parent);
  kind=direction;
  baseCommit=commit;
  ancestorCommit=calculateAncestor(baseCommit);
  RevCommit[] parents=baseCommit.getParents();
  if (parents != null && parents.length > 0)   remoteCommit=baseCommit.getParent(0);
 else {
    remoteCommit=null;
  }
}",0.942652329749104
91558,"private void calculateKind(){
  ObjectId base=baseCommit != null ? baseCommit.getId() : zeroId();
  if (base.equals(zeroId()))   kind=kind | ADDITION;
 else   if (remoteCommit.equals(zeroId()))   kind=kind | DELETION;
 else   kind=kind | CHANGE;
}","private void calculateKind(){
  ObjectId remote=remoteCommit != null ? remoteCommit.getId() : zeroId();
  if (remote.equals(zeroId()))   kind=kind | ADDITION;
 else   if (baseCommit.equals(zeroId()))   kind=kind | DELETION;
 else   kind=kind | CHANGE;
}",0.912
91559,"/** 
 * @param tw instance of {@link TreeWalk} that should be used
 * @param ancestorNth
 * @param baseNth
 * @param actualNth
 * @return {@link GitModelObject} instance of given parameters
 * @throws IOException
 */
protected GitModelObject getModelObject(TreeWalk tw,int ancestorNth,int baseNth,int actualNth) throws IOException {
  String objName=tw.getNameString();
  ObjectId objBaseId;
  if (baseNth > -1)   objBaseId=tw.getObjectId(baseNth);
 else   objBaseId=ObjectId.zeroId();
  ObjectId objRemoteId=tw.getObjectId(actualNth);
  ObjectId objAncestorId=tw.getObjectId(ancestorNth);
  int objectType=tw.getFileMode(actualNth).getObjectType();
  if (objectType == Constants.OBJ_BLOB)   return new GitModelBlob(this,getRemoteCommit(),objAncestorId,objBaseId,objRemoteId,objName);
 else   if (objectType == Constants.OBJ_TREE)   return new GitModelTree(this,getRemoteCommit(),objAncestorId,objBaseId,objRemoteId,objName);
  return null;
}","/** 
 * @param tw instance of {@link TreeWalk} that should be used
 * @param ancestorNth
 * @param baseNth
 * @param actualNth
 * @return {@link GitModelObject} instance of given parameters
 * @throws IOException
 */
protected GitModelObject getModelObject(TreeWalk tw,int ancestorNth,int baseNth,int actualNth) throws IOException {
  String objName=tw.getNameString();
  ObjectId objBaseId;
  if (baseNth > -1)   objBaseId=tw.getObjectId(baseNth);
 else   objBaseId=ObjectId.zeroId();
  ObjectId objRemoteId=tw.getObjectId(actualNth);
  ObjectId objAncestorId=tw.getObjectId(ancestorNth);
  int objectType=tw.getFileMode(actualNth).getObjectType();
  if (objectType == Constants.OBJ_BLOB)   return new GitModelBlob(this,getBaseCommit(),objAncestorId,objBaseId,objRemoteId,objName);
 else   if (objectType == Constants.OBJ_TREE)   return new GitModelTree(this,getBaseCommit(),objAncestorId,objBaseId,objRemoteId,objName);
  return null;
}",0.952127659574468
91560,"/** 
 * Check internal state for page completion status.
 */
private void checkPage(){
  final String dstpath=directoryText.getText();
  if (dstpath.length() == 0) {
    setErrorMessage(NLS.bind(UIText.CloneDestinationPage_fieldRequired,UIText.CloneDestinationPage_promptDirectory));
    setPageComplete(false);
    return;
  }
  final File absoluteFile=new File(dstpath).getAbsoluteFile();
  if (!isEmptyDir(absoluteFile)) {
    setErrorMessage(NLS.bind(UIText.CloneDestinationPage_errorNotEmptyDir,absoluteFile.getPath()));
    setPageComplete(false);
    return;
  }
  if (!canCreateSubdir(absoluteFile.getParentFile())) {
    setErrorMessage(NLS.bind(UIText.GitCloneWizard_errorCannotCreate,absoluteFile.getPath()));
    setPageComplete(false);
    return;
  }
  if (!availableRefs.isEmpty() && initialBranch.getSelectionIndex() < 0) {
    setErrorMessage(NLS.bind(UIText.CloneDestinationPage_fieldRequired,UIText.CloneDestinationPage_promptInitialBranch));
    setPageComplete(false);
    return;
  }
  if (remoteText.getText().length() == 0) {
    setErrorMessage(NLS.bind(UIText.CloneDestinationPage_fieldRequired,UIText.CloneDestinationPage_promptRemoteName));
    setPageComplete(false);
    return;
  }
  setErrorMessage(null);
  setPageComplete(true);
}","/** 
 * Check internal state for page completion status.
 */
private void checkPage(){
  final String dstpath=directoryText.getText();
  if (dstpath.length() == 0) {
    setErrorMessage(UIText.CloneDestinationPage_errorDirectoryRequired);
    setPageComplete(false);
    return;
  }
  final File absoluteFile=new File(dstpath).getAbsoluteFile();
  if (!isEmptyDir(absoluteFile)) {
    setErrorMessage(NLS.bind(UIText.CloneDestinationPage_errorNotEmptyDir,absoluteFile.getPath()));
    setPageComplete(false);
    return;
  }
  if (!canCreateSubdir(absoluteFile.getParentFile())) {
    setErrorMessage(NLS.bind(UIText.GitCloneWizard_errorCannotCreate,absoluteFile.getPath()));
    setPageComplete(false);
    return;
  }
  if (!availableRefs.isEmpty() && initialBranch.getSelectionIndex() < 0) {
    setErrorMessage(UIText.CloneDestinationPage_errorInitialBranchRequired);
    setPageComplete(false);
    return;
  }
  if (remoteText.getText().length() == 0) {
    setErrorMessage(UIText.CloneDestinationPage_errorRemoteNameRequired);
    setPageComplete(false);
    return;
  }
  setErrorMessage(null);
  setPageComplete(true);
}",0.3092352695361471
91561,"public final void selectionChanged(IAction action,ISelection selection){
  mySelection=selection;
  handler.setSelection(mySelection);
  action.setEnabled(isEnabled());
}","public final void selectionChanged(IAction action,ISelection selection){
  mySelection=selection;
  handler.setSelection(mySelection);
  if (action != null)   action.setEnabled(isEnabled());
}",0.9392265193370166
91562,"public final void selectionChanged(IAction action,ISelection selection){
  mySelection=selection;
  handler.setSelection(mySelection);
  action.setEnabled(isEnabled());
}","public final void selectionChanged(IAction action,ISelection selection){
  mySelection=selection;
  handler.setSelection(mySelection);
  if (action != null)   action.setEnabled(isEnabled());
}",0.9392265193370166
91563,"/** 
 * Check internal state for page completion status.
 */
private void checkPage(){
  final String dstpath=directoryText.getText();
  if (dstpath.length() == 0) {
    setErrorMessage(NLS.bind(UIText.CloneDestinationPage_fieldRequired,UIText.CloneDestinationPage_promptDirectory));
    setPageComplete(false);
    return;
  }
  final File absoluteFile=new File(dstpath).getAbsoluteFile();
  if (!isEmptyDir(absoluteFile)) {
    setErrorMessage(NLS.bind(UIText.CloneDestinationPage_errorNotEmptyDir,absoluteFile.getPath()));
    setPageComplete(false);
    return;
  }
  if (!canCreateSubdir(absoluteFile.getParentFile())) {
    setErrorMessage(NLS.bind(UIText.GitCloneWizard_errorCannotCreate,absoluteFile.getPath()));
    setPageComplete(false);
    return;
  }
  if (!availableRefs.isEmpty() && initialBranch.getSelectionIndex() < 0) {
    setErrorMessage(NLS.bind(UIText.CloneDestinationPage_fieldRequired,UIText.CloneDestinationPage_promptInitialBranch));
    setPageComplete(false);
    return;
  }
  if (remoteText.getText().length() == 0) {
    setErrorMessage(NLS.bind(UIText.CloneDestinationPage_fieldRequired,UIText.CloneDestinationPage_promptRemoteName));
    setPageComplete(false);
    return;
  }
  setErrorMessage(null);
  setPageComplete(true);
}","/** 
 * Check internal state for page completion status.
 */
private void checkPage(){
  final String dstpath=directoryText.getText();
  if (dstpath.length() == 0) {
    setErrorMessage(UIText.CloneDestinationPage_errorDirectoryRequired);
    setPageComplete(false);
    return;
  }
  final File absoluteFile=new File(dstpath).getAbsoluteFile();
  if (!isEmptyDir(absoluteFile)) {
    setErrorMessage(NLS.bind(UIText.CloneDestinationPage_errorNotEmptyDir,absoluteFile.getPath()));
    setPageComplete(false);
    return;
  }
  if (!canCreateSubdir(absoluteFile.getParentFile())) {
    setErrorMessage(NLS.bind(UIText.GitCloneWizard_errorCannotCreate,absoluteFile.getPath()));
    setPageComplete(false);
    return;
  }
  if (!availableRefs.isEmpty() && initialBranch.getSelectionIndex() < 0) {
    setErrorMessage(UIText.CloneDestinationPage_errorInitialBranchRequired);
    setPageComplete(false);
    return;
  }
  if (remoteText.getText().length() == 0) {
    setErrorMessage(UIText.CloneDestinationPage_errorRemoteNameRequired);
    setPageComplete(false);
    return;
  }
  setErrorMessage(null);
  setPageComplete(true);
}",0.3092352695361471
91564,"public Object execute(ExecutionEvent event) throws ExecutionException {
  boolean compareMode=Boolean.TRUE.toString().equals(event.getParameter(HistoryViewCommands.COMPARE_MODE_PARAM));
  IStructuredSelection selection=getSelection(getPage());
  if (selection.size() < 1)   return null;
  Object input=getPage().getInputInternal().getSingleFile();
  if (input == null)   return null;
  boolean errorOccured=false;
  List<ObjectId> ids=new ArrayList<ObjectId>();
  String gitPath=null;
  if (input instanceof IFile) {
    IFile resource=(IFile)input;
    final RepositoryMapping map=RepositoryMapping.getMapping(resource);
    gitPath=map.getRepoRelativePath(resource);
    Iterator<?> it=selection.iterator();
    while (it.hasNext()) {
      RevCommit commit=(RevCommit)it.next();
      IFileRevision rev=null;
      try {
        rev=CompareUtils.getFileRevision(gitPath,commit,map.getRepository(),null);
      }
 catch (      IOException e) {
        Activator.logError(NLS.bind(UIText.GitHistoryPage_errorLookingUpPath,gitPath,commit.getId()),e);
        errorOccured=true;
      }
      if (rev != null) {
        if (compareMode) {
          ITypedElement right=CompareUtils.getFileRevisionTypedElement(gitPath,commit,map.getRepository());
          final GitCompareFileRevisionEditorInput in=new GitCompareFileRevisionEditorInput(SaveableCompareEditorInput.createFileElement(resource),right,null);
          try {
            openInCompare(event,in);
          }
 catch (          Exception e) {
            errorOccured=true;
          }
        }
 else {
          try {
            EgitUiEditorUtils.openEditor(getPart(event).getSite().getPage(),rev,new NullProgressMonitor());
          }
 catch (          CoreException e) {
            Activator.logError(UIText.GitHistoryPage_openFailed,e);
            errorOccured=true;
          }
        }
      }
 else {
        ids.add(commit.getId());
      }
    }
  }
  if (input instanceof File) {
    File fileInput=(File)input;
    Repository repo=getRepository(event);
    gitPath=getRepoRelativePath(repo,fileInput);
    Iterator<?> it=selection.iterator();
    while (it.hasNext()) {
      RevCommit commit=(RevCommit)it.next();
      IFileRevision rev=null;
      try {
        rev=CompareUtils.getFileRevision(gitPath,commit,repo,null);
      }
 catch (      IOException e) {
        Activator.logError(NLS.bind(UIText.GitHistoryPage_errorLookingUpPath,gitPath,commit.getId()),e);
        errorOccured=true;
      }
      if (rev != null) {
        if (compareMode) {
          try {
            ITypedElement left=CompareUtils.getFileRevisionTypedElement(gitPath,new RevWalk(repo).parseCommit(repo.resolve(Constants.HEAD)),repo);
            ITypedElement right=CompareUtils.getFileRevisionTypedElement(gitPath,commit,repo);
            final GitCompareFileRevisionEditorInput in=new GitCompareFileRevisionEditorInput(left,right,null);
            openInCompare(event,in);
          }
 catch (          Exception e) {
            errorOccured=true;
          }
        }
 else {
          try {
            EgitUiEditorUtils.openEditor(getPart(event).getSite().getPage(),rev,new NullProgressMonitor());
          }
 catch (          CoreException e) {
            Activator.logError(UIText.GitHistoryPage_openFailed,e);
            errorOccured=true;
          }
        }
      }
 else {
        ids.add(commit.getId());
      }
    }
  }
  if (errorOccured)   Activator.showError(UIText.GitHistoryPage_openFailed,null);
  if (ids.size() > 0) {
    String idList=""String_Node_Str"";
    for (    ObjectId objectId : ids) {
      idList+=objectId.getName() + ""String_Node_Str"";
    }
    MessageDialog.openError(getPart(event).getSite().getShell(),UIText.GitHistoryPage_fileNotFound,NLS.bind(UIText.GitHistoryPage_notContainedInCommits,gitPath,idList));
  }
  return null;
}","public Object execute(ExecutionEvent event) throws ExecutionException {
  boolean compareMode=Boolean.TRUE.toString().equals(event.getParameter(HistoryViewCommands.COMPARE_MODE_PARAM));
  IStructuredSelection selection=getSelection(getPage());
  if (selection.size() < 1)   return null;
  Object input=getPage().getInputInternal().getSingleFile();
  if (input == null)   return null;
  boolean errorOccured=false;
  List<ObjectId> ids=new ArrayList<ObjectId>();
  String gitPath=null;
  if (input instanceof IFile) {
    IFile resource=(IFile)input;
    final RepositoryMapping map=RepositoryMapping.getMapping(resource);
    gitPath=map.getRepoRelativePath(resource);
    Iterator<?> it=selection.iterator();
    while (it.hasNext()) {
      RevCommit commit=(RevCommit)it.next();
      IFileRevision rev=null;
      try {
        rev=CompareUtils.getFileRevision(gitPath,commit,map.getRepository(),null);
      }
 catch (      IOException e) {
        Activator.logError(NLS.bind(UIText.GitHistoryPage_errorLookingUpPath,gitPath,commit.getId()),e);
        errorOccured=true;
      }
      if (rev != null) {
        if (compareMode) {
          ITypedElement right=CompareUtils.getFileRevisionTypedElement(gitPath,commit,map.getRepository());
          final GitCompareFileRevisionEditorInput in=new GitCompareFileRevisionEditorInput(SaveableCompareEditorInput.createFileElement(resource),right,null);
          try {
            openInCompare(event,in);
          }
 catch (          Exception e) {
            errorOccured=true;
          }
        }
 else {
          try {
            EgitUiEditorUtils.openEditor(getPart(event).getSite().getPage(),rev,new NullProgressMonitor());
          }
 catch (          CoreException e) {
            Activator.logError(UIText.GitHistoryPage_openFailed,e);
            errorOccured=true;
          }
        }
      }
 else {
        ids.add(commit.getId());
      }
    }
  }
  if (input instanceof File) {
    File fileInput=(File)input;
    Repository repo=getRepository(event);
    gitPath=getRepoRelativePath(repo,fileInput);
    Iterator<?> it=selection.iterator();
    while (it.hasNext()) {
      RevCommit commit=(RevCommit)it.next();
      IFileRevision rev=null;
      try {
        rev=CompareUtils.getFileRevision(gitPath,commit,repo,null);
      }
 catch (      IOException e) {
        Activator.logError(NLS.bind(UIText.GitHistoryPage_errorLookingUpPath,gitPath,commit.getId()),e);
        errorOccured=true;
      }
      if (rev != null) {
        if (compareMode) {
          try {
            ITypedElement left=CompareUtils.getFileRevisionTypedElement(gitPath,new RevWalk(repo).parseCommit(repo.resolve(Constants.HEAD)),repo);
            ITypedElement right=CompareUtils.getFileRevisionTypedElement(gitPath,commit,repo);
            final GitCompareFileRevisionEditorInput in=new GitCompareFileRevisionEditorInput(left,right,null);
            openInCompare(event,in);
          }
 catch (          IOException e) {
            errorOccured=true;
          }
        }
 else {
          try {
            EgitUiEditorUtils.openEditor(getPart(event).getSite().getPage(),rev,new NullProgressMonitor());
          }
 catch (          CoreException e) {
            Activator.logError(UIText.GitHistoryPage_openFailed,e);
            errorOccured=true;
          }
        }
      }
 else {
        ids.add(commit.getId());
      }
    }
  }
  if (errorOccured)   Activator.showError(UIText.GitHistoryPage_openFailed,null);
  if (ids.size() > 0) {
    String idList=""String_Node_Str"";
    for (    ObjectId objectId : ids) {
      idList+=objectId.getName() + ""String_Node_Str"";
    }
    MessageDialog.openError(getPart(event).getSite().getShell(),UIText.GitHistoryPage_fileNotFound,NLS.bind(UIText.GitHistoryPage_notContainedInCommits,gitPath,idList));
  }
  return null;
}",0.9997395833333332
91565,"public Object execute(ExecutionEvent event) throws ExecutionException {
  boolean compareMode=Boolean.TRUE.toString().equals(event.getParameter(HistoryViewCommands.COMPARE_MODE_PARAM));
  IStructuredSelection selection=getSelection(getPage());
  if (selection.size() < 1)   return null;
  Object input=getPage().getInputInternal().getSingleFile();
  if (input == null)   return null;
  boolean errorOccured=false;
  List<ObjectId> ids=new ArrayList<ObjectId>();
  String gitPath=null;
  if (input instanceof IFile) {
    IFile resource=(IFile)input;
    final RepositoryMapping map=RepositoryMapping.getMapping(resource);
    gitPath=map.getRepoRelativePath(resource);
    Iterator<?> it=selection.iterator();
    while (it.hasNext()) {
      RevCommit commit=(RevCommit)it.next();
      IFileRevision rev=null;
      try {
        rev=CompareUtils.getFileRevision(gitPath,commit,map.getRepository(),null);
      }
 catch (      IOException e) {
        Activator.logError(NLS.bind(UIText.GitHistoryPage_errorLookingUpPath,gitPath,commit.getId()),e);
        errorOccured=true;
      }
      if (rev != null) {
        if (compareMode) {
          ITypedElement right=CompareUtils.getFileRevisionTypedElement(gitPath,commit,map.getRepository());
          final GitCompareFileRevisionEditorInput in=new GitCompareFileRevisionEditorInput(SaveableCompareEditorInput.createFileElement(resource),right,null);
          try {
            openInCompare(event,in);
          }
 catch (          Exception e) {
            errorOccured=true;
          }
        }
 else {
          try {
            EgitUiEditorUtils.openEditor(getPart(event).getSite().getPage(),rev,new NullProgressMonitor());
          }
 catch (          CoreException e) {
            Activator.logError(UIText.GitHistoryPage_openFailed,e);
            errorOccured=true;
          }
        }
      }
 else {
        ids.add(commit.getId());
      }
    }
  }
  if (input instanceof File) {
    File fileInput=(File)input;
    Repository repo=getRepository(event);
    gitPath=getRepoRelativePath(repo,fileInput);
    Iterator<?> it=selection.iterator();
    while (it.hasNext()) {
      RevCommit commit=(RevCommit)it.next();
      IFileRevision rev=null;
      try {
        rev=CompareUtils.getFileRevision(gitPath,commit,repo,null);
      }
 catch (      IOException e) {
        Activator.logError(NLS.bind(UIText.GitHistoryPage_errorLookingUpPath,gitPath,commit.getId()),e);
        errorOccured=true;
      }
      if (rev != null) {
        if (compareMode) {
          try {
            ITypedElement left=CompareUtils.getFileRevisionTypedElement(gitPath,new RevWalk(repo).parseCommit(repo.resolve(Constants.HEAD)),repo);
            ITypedElement right=CompareUtils.getFileRevisionTypedElement(gitPath,commit,repo);
            final GitCompareFileRevisionEditorInput in=new GitCompareFileRevisionEditorInput(left,right,null);
            openInCompare(event,in);
          }
 catch (          Exception e) {
            errorOccured=true;
          }
        }
 else {
          try {
            EgitUiEditorUtils.openEditor(getPart(event).getSite().getPage(),rev,new NullProgressMonitor());
          }
 catch (          CoreException e) {
            Activator.logError(UIText.GitHistoryPage_openFailed,e);
            errorOccured=true;
          }
        }
      }
 else {
        ids.add(commit.getId());
      }
    }
  }
  if (errorOccured)   Activator.showError(UIText.GitHistoryPage_openFailed,null);
  if (ids.size() > 0) {
    String idList=""String_Node_Str"";
    for (    ObjectId objectId : ids) {
      idList+=objectId.getName() + ""String_Node_Str"";
    }
    MessageDialog.openError(getPart(event).getSite().getShell(),UIText.GitHistoryPage_fileNotFound,NLS.bind(UIText.GitHistoryPage_notContainedInCommits,gitPath,idList));
  }
  return null;
}","public Object execute(ExecutionEvent event) throws ExecutionException {
  boolean compareMode=Boolean.TRUE.toString().equals(event.getParameter(HistoryViewCommands.COMPARE_MODE_PARAM));
  IStructuredSelection selection=getSelection(getPage());
  if (selection.size() < 1)   return null;
  Object input=getPage().getInputInternal().getSingleFile();
  if (input == null)   return null;
  boolean errorOccured=false;
  List<ObjectId> ids=new ArrayList<ObjectId>();
  String gitPath=null;
  if (input instanceof IFile) {
    IFile resource=(IFile)input;
    final RepositoryMapping map=RepositoryMapping.getMapping(resource);
    gitPath=map.getRepoRelativePath(resource);
    Iterator<?> it=selection.iterator();
    while (it.hasNext()) {
      RevCommit commit=(RevCommit)it.next();
      IFileRevision rev=null;
      try {
        rev=CompareUtils.getFileRevision(gitPath,commit,map.getRepository(),null);
      }
 catch (      IOException e) {
        Activator.logError(NLS.bind(UIText.GitHistoryPage_errorLookingUpPath,gitPath,commit.getId()),e);
        errorOccured=true;
      }
      if (rev != null) {
        if (compareMode) {
          ITypedElement right=CompareUtils.getFileRevisionTypedElement(gitPath,commit,map.getRepository());
          final GitCompareFileRevisionEditorInput in=new GitCompareFileRevisionEditorInput(SaveableCompareEditorInput.createFileElement(resource),right,null);
          try {
            openInCompare(event,in);
          }
 catch (          Exception e) {
            errorOccured=true;
          }
        }
 else {
          try {
            EgitUiEditorUtils.openEditor(getPart(event).getSite().getPage(),rev,new NullProgressMonitor());
          }
 catch (          CoreException e) {
            Activator.logError(UIText.GitHistoryPage_openFailed,e);
            errorOccured=true;
          }
        }
      }
 else {
        ids.add(commit.getId());
      }
    }
  }
  if (input instanceof File) {
    File fileInput=(File)input;
    Repository repo=getRepository(event);
    gitPath=getRepoRelativePath(repo,fileInput);
    Iterator<?> it=selection.iterator();
    while (it.hasNext()) {
      RevCommit commit=(RevCommit)it.next();
      IFileRevision rev=null;
      try {
        rev=CompareUtils.getFileRevision(gitPath,commit,repo,null);
      }
 catch (      IOException e) {
        Activator.logError(NLS.bind(UIText.GitHistoryPage_errorLookingUpPath,gitPath,commit.getId()),e);
        errorOccured=true;
      }
      if (rev != null) {
        if (compareMode) {
          try {
            ITypedElement left=CompareUtils.getFileRevisionTypedElement(gitPath,new RevWalk(repo).parseCommit(repo.resolve(Constants.HEAD)),repo);
            ITypedElement right=CompareUtils.getFileRevisionTypedElement(gitPath,commit,repo);
            final GitCompareFileRevisionEditorInput in=new GitCompareFileRevisionEditorInput(left,right,null);
            openInCompare(event,in);
          }
 catch (          IOException e) {
            errorOccured=true;
          }
        }
 else {
          try {
            EgitUiEditorUtils.openEditor(getPart(event).getSite().getPage(),rev,new NullProgressMonitor());
          }
 catch (          CoreException e) {
            Activator.logError(UIText.GitHistoryPage_openFailed,e);
            errorOccured=true;
          }
        }
      }
 else {
        ids.add(commit.getId());
      }
    }
  }
  if (errorOccured)   Activator.showError(UIText.GitHistoryPage_openFailed,null);
  if (ids.size() > 0) {
    String idList=""String_Node_Str"";
    for (    ObjectId objectId : ids) {
      idList+=objectId.getName() + ""String_Node_Str"";
    }
    MessageDialog.openError(getPart(event).getSite().getShell(),UIText.GitHistoryPage_fileNotFound,NLS.bind(UIText.GitHistoryPage_notContainedInCommits,gitPath,idList));
  }
  return null;
}",0.9997395833333332
91566,"public ITypedElement getRight(){
  return CompareUtils.getFileRevisionTypedElement(gitPath,baseCommit,repo,baseId);
}","public ITypedElement getRight(){
  return CompareUtils.getFileRevisionTypedElement(gitPath,remoteCommit,repo,baseId);
}",0.9661016949152542
91567,"public ITypedElement getLeft(){
  return CompareUtils.getFileRevisionTypedElement(gitPath,remoteCommit,repo,remoteId);
}","public ITypedElement getLeft(){
  return CompareUtils.getFileRevisionTypedElement(gitPath,baseCommit,repo,remoteId);
}",0.9663865546218487
91568,"private String getAbbreviatedId(GitModelCommit commit){
  RevCommit remoteCommit=commit.getRemoteCommit();
  ObjectReader reader=commit.getRepository().newObjectReader();
  ObjectId commitId=remoteCommit.getId();
  AbbreviatedObjectId shortId;
  try {
    shortId=reader.abbreviate(commitId,6);
  }
 catch (  IOException e) {
    shortId=AbbreviatedObjectId.fromObjectId(ObjectId.zeroId());
    Activator.logError(e.getMessage(),e);
  }
 finally {
    reader.release();
  }
  return shortId.name();
}","private String getAbbreviatedId(GitModelCommit commit){
  RevCommit remoteCommit=commit.getBaseCommit();
  ObjectReader reader=commit.getRepository().newObjectReader();
  ObjectId commitId=remoteCommit.getId();
  AbbreviatedObjectId shortId;
  try {
    shortId=reader.abbreviate(commitId,6);
  }
 catch (  IOException e) {
    shortId=AbbreviatedObjectId.fromObjectId(ObjectId.zeroId());
    Activator.logError(e.getMessage(),e);
  }
 finally {
    reader.release();
  }
  return shortId.name();
}",0.9919839679358716
91569,"@Override public int compare(Viewer viewer,Object e1,Object e2){
  if (e1 instanceof GitModelWorkingTree)   return -1;
  if (e2 instanceof GitModelWorkingTree)   return 1;
  if (e1 instanceof GitModelCache)   return -2;
  if (e2 instanceof GitModelCache)   return 2;
  if (e1 instanceof GitModelCommit && e2 instanceof GitModelCommit) {
    RevCommit rc1=((GitModelCommit)e1).getRemoteCommit();
    RevCommit rc2=((GitModelCommit)e2).getRemoteCommit();
    return rc2.getCommitTime() - rc1.getCommitTime();
  }
  return super.compare(viewer,e1,e2);
}","@Override public int compare(Viewer viewer,Object e1,Object e2){
  if (e1 instanceof GitModelWorkingTree)   return -1;
  if (e2 instanceof GitModelWorkingTree)   return 1;
  if (e1 instanceof GitModelCache)   return -2;
  if (e2 instanceof GitModelCache)   return 2;
  if (e1 instanceof GitModelCommit && e2 instanceof GitModelCommit) {
    RevCommit rc1=((GitModelCommit)e1).getBaseCommit();
    RevCommit rc2=((GitModelCommit)e2).getBaseCommit();
    return rc2.getCommitTime() - rc1.getCommitTime();
  }
  return super.compare(viewer,e1,e2);
}",0.9854014598540146
91570,"@Override public ResourceTraversal[] getTraversals(ResourceMappingContext context,IProgressMonitor monitor) throws CoreException {
  Repository repo=gitRepo.getRepository();
  List<ResourceTraversal> result=new ArrayList<ResourceTraversal>();
  for (  GitModelObject obj : gitRepo.getChildren())   if (obj instanceof GitModelCommit || obj instanceof GitModelCache) {
    RevCommit revCommit;
    if (obj instanceof GitModelCommit)     revCommit=((GitModelCommit)obj).getRemoteCommit();
 else     revCommit=((GitModelCache)obj).getRemoteCommit();
    result.add(new GitTreeTraversal(repo,revCommit));
  }
  return result.toArray(new ResourceTraversal[result.size()]);
}","@Override public ResourceTraversal[] getTraversals(ResourceMappingContext context,IProgressMonitor monitor) throws CoreException {
  Repository repo=gitRepo.getRepository();
  List<ResourceTraversal> result=new ArrayList<ResourceTraversal>();
  for (  GitModelObject obj : gitRepo.getChildren())   if (obj instanceof GitModelCommit || obj instanceof GitModelCache) {
    RevCommit revCommit;
    if (obj instanceof GitModelCommit)     revCommit=((GitModelCommit)obj).getBaseCommit();
 else     revCommit=((GitModelCache)obj).getBaseCommit();
    result.add(new GitTreeTraversal(repo,revCommit));
  }
  return result.toArray(new ResourceTraversal[result.size()]);
}",0.987987987987988
91571,"private GitModelObject extractFromCache(TreeWalk tw) throws IOException {
  DirCacheIterator cacheIterator=tw.getTree(dirCacheIteratorNth,DirCacheIterator.class);
  if (cacheIterator == null)   return null;
  DirCacheEntry cacheEntry=cacheIterator.getDirCacheEntry();
  if (cacheEntry == null)   return null;
  if (shouldIncludeEntry(tw)) {
    String path=new String(tw.getRawPath());
    ObjectId repoId=tw.getObjectId(BASE_NTH);
    ObjectId cacheId=tw.getObjectId(REMOTE_NTH);
    if (path.split(""String_Node_Str"").length > 1)     return handleCacheTree(repoId,cacheId,path);
    return fileFactory.createFileModel(this,remoteCommit,repoId,cacheId,path);
  }
  return null;
}","private GitModelObject extractFromCache(TreeWalk tw) throws IOException {
  DirCacheIterator cacheIterator=tw.getTree(dirCacheIteratorNth,DirCacheIterator.class);
  if (cacheIterator == null)   return null;
  DirCacheEntry cacheEntry=cacheIterator.getDirCacheEntry();
  if (cacheEntry == null)   return null;
  if (shouldIncludeEntry(tw)) {
    String path=new String(tw.getRawPath());
    ObjectId repoId=tw.getObjectId(BASE_NTH);
    ObjectId cacheId=tw.getObjectId(REMOTE_NTH);
    if (path.split(""String_Node_Str"").length > 1)     return handleCacheTree(repoId,cacheId,path);
    return fileFactory.createFileModel(this,baseCommit,repoId,cacheId,path);
  }
  return null;
}",0.9941002949852508
91572,"private GitModelObject handleCacheTree(ObjectId repoId,ObjectId cacheId,String path) throws IOException {
  String pathKey=path.split(""String_Node_Str"")[0];
  GitModelCacheTree cacheTree=cacheTreeMap.get(pathKey);
  if (cacheTree == null) {
    cacheTree=new GitModelCacheTree(this,remoteCommit,repoId,cacheId,pathKey,fileFactory);
    cacheTreeMap.put(pathKey,cacheTree);
  }
  cacheTree.addChild(repoId,cacheId,path.substring(path.indexOf('/') + 1));
  return cacheTree;
}","private GitModelObject handleCacheTree(ObjectId repoId,ObjectId cacheId,String path) throws IOException {
  String pathKey=path.split(""String_Node_Str"")[0];
  GitModelCacheTree cacheTree=cacheTreeMap.get(pathKey);
  if (cacheTree == null) {
    cacheTree=new GitModelCacheTree(this,baseCommit,repoId,cacheId,pathKey,fileFactory);
    cacheTreeMap.put(pathKey,cacheTree);
  }
  cacheTree.addChild(repoId,cacheId,path.substring(path.indexOf('/') + 1));
  return cacheTree;
}",0.9915433403805496
91573,"void addChild(ObjectId repoId,ObjectId cacheId,String path) throws IOException {
  String[] entrys=path.split(""String_Node_Str"");
  String pathKey=entrys[0];
  if (entrys.length > 1) {
    GitModelCacheTree cacheEntry=(GitModelCacheTree)cacheTreeMap.get(pathKey);
    if (cacheEntry == null) {
      cacheEntry=new GitModelCacheTree(this,remoteCommit,repoId,cacheId,pathKey,factory);
      cacheTreeMap.put(pathKey,cacheEntry);
    }
    cacheEntry.addChild(repoId,cacheId,path.substring(path.indexOf('/') + 1));
  }
 else   cacheTreeMap.put(pathKey,factory.createFileModel(this,remoteCommit,repoId,cacheId,pathKey));
}","void addChild(ObjectId repoId,ObjectId cacheId,String path) throws IOException {
  String[] entrys=path.split(""String_Node_Str"");
  String pathKey=entrys[0];
  if (entrys.length > 1) {
    GitModelCacheTree cacheEntry=(GitModelCacheTree)cacheTreeMap.get(pathKey);
    if (cacheEntry == null) {
      cacheEntry=new GitModelCacheTree(this,baseCommit,repoId,cacheId,pathKey,factory);
      cacheTreeMap.put(pathKey,cacheEntry);
    }
    cacheEntry.addChild(repoId,cacheId,path.substring(path.indexOf('/') + 1));
  }
 else   cacheTreeMap.put(pathKey,factory.createFileModel(this,baseCommit,repoId,cacheId,pathKey));
}",0.987034035656402
91574,"@Override public int hashCode(){
  int result=getLocation().hashCode() ^ remoteCommit.hashCode();
  if (baseCommit != null)   result^=baseCommit.hashCode();
  return result;
}","@Override public int hashCode(){
  int result=getLocation().hashCode() ^ baseCommit.hashCode();
  if (remoteCommit != null)   result^=remoteCommit.hashCode();
  return result;
}",0.9318181818181818
91575,"@Override protected GitModelObject[] getChildrenImpl(){
  TreeWalk tw=createTreeWalk();
  List<GitModelObject> result=new ArrayList<GitModelObject>();
  try {
    RevTree actualTree=remoteCommit.getTree();
    int actualNth=tw.addTree(actualTree);
    int baseNth=-1;
    if (baseCommit != null)     baseNth=tw.addTree(baseCommit.getTree());
    int ancestorNth=tw.addTree(ancestorCommit.getTree());
    while (tw.next()) {
      GitModelObject obj=getModelObject(tw,ancestorNth,baseNth,actualNth);
      if (obj != null)       result.add(obj);
    }
  }
 catch (  IOException e) {
    Activator.logError(e.getMessage(),e);
  }
  return result.toArray(new GitModelObject[result.size()]);
}","@Override protected GitModelObject[] getChildrenImpl(){
  TreeWalk tw=createTreeWalk();
  List<GitModelObject> result=new ArrayList<GitModelObject>();
  try {
    RevTree actualTree=baseCommit.getTree();
    int actualNth=tw.addTree(actualTree);
    int baseNth=-1;
    if (remoteCommit != null)     baseNth=tw.addTree(remoteCommit.getTree());
    int ancestorNth=tw.addTree(ancestorCommit.getTree());
    while (tw.next()) {
      GitModelObject obj=getModelObject(tw,ancestorNth,baseNth,actualNth);
      if (obj != null)       result.add(obj);
    }
  }
 catch (  IOException e) {
    Activator.logError(e.getMessage(),e);
  }
  return result.toArray(new GitModelObject[result.size()]);
}",0.982608695652174
91576,"@Override public String getName(){
  if (name == null)   name=remoteCommit.getShortMessage();
  return name;
}","@Override public String getName(){
  if (name == null)   name=baseCommit.getShortMessage();
  return name;
}",0.963302752293578
91577,"/** 
 * @param parent instance of parent object
 * @param commit commit connected with this container
 * @param direction indicate change direction
 * @throws IOException
 */
protected GitModelObjectContainer(GitModelObject parent,RevCommit commit,int direction) throws IOException {
  super(parent);
  kind=direction;
  remoteCommit=commit;
  ancestorCommit=calculateAncestor(remoteCommit);
  RevCommit[] parents=remoteCommit.getParents();
  if (parents != null && parents.length > 0)   baseCommit=remoteCommit.getParent(0);
 else {
    baseCommit=null;
  }
}","/** 
 * @param parent instance of parent object
 * @param commit commit connected with this container
 * @param direction indicate change direction
 * @throws IOException
 */
protected GitModelObjectContainer(GitModelObject parent,RevCommit commit,int direction) throws IOException {
  super(parent);
  kind=direction;
  baseCommit=commit;
  ancestorCommit=calculateAncestor(baseCommit);
  RevCommit[] parents=baseCommit.getParents();
  if (parents != null && parents.length > 0)   remoteCommit=baseCommit.getParent(0);
 else {
    remoteCommit=null;
  }
}",0.942652329749104
91578,"private void calculateKind(){
  ObjectId base=baseCommit != null ? baseCommit.getId() : zeroId();
  if (base.equals(zeroId()))   kind=kind | ADDITION;
 else   if (remoteCommit.equals(zeroId()))   kind=kind | DELETION;
 else   kind=kind | CHANGE;
}","private void calculateKind(){
  ObjectId remote=remoteCommit != null ? remoteCommit.getId() : zeroId();
  if (remote.equals(zeroId()))   kind=kind | ADDITION;
 else   if (baseCommit.equals(zeroId()))   kind=kind | DELETION;
 else   kind=kind | CHANGE;
}",0.912
91579,"/** 
 * @param tw instance of {@link TreeWalk} that should be used
 * @param ancestorNth
 * @param baseNth
 * @param actualNth
 * @return {@link GitModelObject} instance of given parameters
 * @throws IOException
 */
protected GitModelObject getModelObject(TreeWalk tw,int ancestorNth,int baseNth,int actualNth) throws IOException {
  String objName=tw.getNameString();
  ObjectId objBaseId;
  if (baseNth > -1)   objBaseId=tw.getObjectId(baseNth);
 else   objBaseId=ObjectId.zeroId();
  ObjectId objRemoteId=tw.getObjectId(actualNth);
  ObjectId objAncestorId=tw.getObjectId(ancestorNth);
  int objectType=tw.getFileMode(actualNth).getObjectType();
  if (objectType == Constants.OBJ_BLOB)   return new GitModelBlob(this,getRemoteCommit(),objAncestorId,objBaseId,objRemoteId,objName);
 else   if (objectType == Constants.OBJ_TREE)   return new GitModelTree(this,getRemoteCommit(),objAncestorId,objBaseId,objRemoteId,objName);
  return null;
}","/** 
 * @param tw instance of {@link TreeWalk} that should be used
 * @param ancestorNth
 * @param baseNth
 * @param actualNth
 * @return {@link GitModelObject} instance of given parameters
 * @throws IOException
 */
protected GitModelObject getModelObject(TreeWalk tw,int ancestorNth,int baseNth,int actualNth) throws IOException {
  String objName=tw.getNameString();
  ObjectId objBaseId;
  if (baseNth > -1)   objBaseId=tw.getObjectId(baseNth);
 else   objBaseId=ObjectId.zeroId();
  ObjectId objRemoteId=tw.getObjectId(actualNth);
  ObjectId objAncestorId=tw.getObjectId(ancestorNth);
  int objectType=tw.getFileMode(actualNth).getObjectType();
  if (objectType == Constants.OBJ_BLOB)   return new GitModelBlob(this,getBaseCommit(),objAncestorId,objBaseId,objRemoteId,objName);
 else   if (objectType == Constants.OBJ_TREE)   return new GitModelTree(this,getBaseCommit(),objAncestorId,objBaseId,objRemoteId,objName);
  return null;
}",0.952127659574468
91580,"/** 
 * Allows access to the localized values of the EGit UI Plug-in <p>
 * @param key see  {@link #getPluginLocalizedValue(String)}
 * @param keepAmpersands if <code>true</code>, ampersands will be kept
 * @return see {@link #getPluginLocalizedValue(String)}
 * @throws MissingResourceException see  {@link #getPluginLocalizedValue(String)}
 */
public synchronized String getPluginLocalizedValue(String key,boolean keepAmpersands) throws MissingResourceException {
  if (myBundle == null) {
    ServiceTracker localizationTracker;
    BundleContext context=Activator.getDefault().getBundle().getBundleContext();
    localizationTracker=new ServiceTracker(context,BundleLocalization.class.getName(),null);
    localizationTracker.open();
    BundleLocalization location=(BundleLocalization)localizationTracker.getService();
    if (location != null)     myBundle=location.getLocalization(Activator.getDefault().getBundle(),Locale.getDefault().toString());
  }
  String raw=myBundle.getString(key);
  if (keepAmpersands || raw.indexOf(AMPERSAND) < 0)   return raw;
  StringBuilder sb=new StringBuilder(raw.length());
  for (int i=0; i < raw.length(); i++) {
    char c=raw.charAt(i);
    if (c != AMPERSAND)     sb.append(c);
  }
  return sb.toString();
}","/** 
 * Allows access to the localized values of the EGit UI Plug-in <p>
 * @param key see  {@link #getPluginLocalizedValue(String)}
 * @param keepAmpersands if <code>true</code>, ampersands will be kept
 * @return see {@link #getPluginLocalizedValue(String)}
 * @throws MissingResourceException see  {@link #getPluginLocalizedValue(String)}
 */
public synchronized String getPluginLocalizedValue(String key,boolean keepAmpersands) throws MissingResourceException {
  if (myBundle == null) {
    ServiceTracker localizationTracker;
    BundleContext context=Activator.getDefault().getBundle().getBundleContext();
    localizationTracker=new ServiceTracker(context,BundleLocalization.class.getName(),null);
    localizationTracker.open();
    BundleLocalization location=(BundleLocalization)localizationTracker.getService();
    if (location != null)     myBundle=location.getLocalization(Activator.getDefault().getBundle(),Locale.getDefault().toString());
  }
  if (myBundle != null) {
    String raw=myBundle.getString(key);
    if (keepAmpersands || raw.indexOf(AMPERSAND) < 0)     return raw;
    StringBuilder sb=new StringBuilder(raw.length());
    for (int i=0; i < raw.length(); i++) {
      char c=raw.charAt(i);
      if (c != AMPERSAND)       sb.append(c);
    }
    return sb.toString();
  }
  return null;
}",0.974737660318694
91581,"private ArrayList<String> buildFilterPaths(final IResource[] inResources,final File[] inFiles,final Repository db) throws IllegalStateException {
  final ArrayList<String> paths;
  if (inResources != null) {
    paths=new ArrayList<String>(inResources.length);
    for (    final IResource r : inResources) {
      final RepositoryMapping map=RepositoryMapping.getMapping(r);
      if (map == null)       continue;
      if (db != map.getRepository()) {
        throw new IllegalStateException(UIText.AbstractHistoryCommanndHandler_NoUniqueRepository);
      }
      if (showAllFilter == ShowFilter.SHOWALLFOLDER) {
        final String path=map.getRepoRelativePath(r.getParent());
        if (path != null && path.length() > 0)         paths.add(path);
      }
 else       if (showAllFilter == ShowFilter.SHOWALLPROJECT) {
        final String path=map.getRepoRelativePath(r.getProject());
        if (path != null && path.length() > 0)         paths.add(path);
      }
 else       if (showAllFilter == ShowFilter.SHOWALLREPO) {
      }
 else {
        final String path=map.getRepoRelativePath(r);
        if (path != null && path.length() > 0)         paths.add(path);
      }
    }
  }
 else   if (inFiles != null) {
    IPath workdirPath=new Path(db.getWorkTree().getPath());
    IPath gitDirPath=new Path(db.getDirectory().getPath());
    int segmentCount=workdirPath.segmentCount();
    paths=new ArrayList<String>(inFiles.length);
    for (    File file : inFiles) {
      IPath filePath;
      if (showAllFilter == ShowFilter.SHOWALLFOLDER) {
        filePath=new Path(file.getParentFile().getPath());
      }
 else       if (showAllFilter == ShowFilter.SHOWALLPROJECT || showAllFilter == ShowFilter.SHOWALLREPO) {
        continue;
      }
 else {
        filePath=new Path(file.getPath());
      }
      if (gitDirPath.isPrefixOf(filePath)) {
        throw new IllegalStateException(NLS.bind(UIText.GitHistoryPage_FileOrFolderPartOfGitDirMessage,filePath.toOSString()));
      }
      IPath pathToAdd=filePath.removeFirstSegments(segmentCount).setDevice(null);
      if (!pathToAdd.isEmpty()) {
        paths.add(pathToAdd.toString());
      }
    }
  }
 else {
    paths=new ArrayList<String>(0);
  }
  return paths;
}","private ArrayList<String> buildFilterPaths(final IResource[] inResources,final File[] inFiles,final Repository db) throws IllegalStateException {
  final ArrayList<String> paths;
  if (inResources != null) {
    paths=new ArrayList<String>(inResources.length);
    for (    final IResource r : inResources) {
      final RepositoryMapping map=RepositoryMapping.getMapping(r);
      if (map == null)       continue;
      if (db != map.getRepository()) {
        throw new IllegalStateException(UIText.AbstractHistoryCommanndHandler_NoUniqueRepository);
      }
      if (showAllFilter == ShowFilter.SHOWALLFOLDER) {
        final String path;
        if (r.getParent() instanceof IWorkspaceRoot)         path=map.getRepoRelativePath(r.getProject());
 else         path=map.getRepoRelativePath(r.getParent());
        if (path != null && path.length() > 0)         paths.add(path);
      }
 else       if (showAllFilter == ShowFilter.SHOWALLPROJECT) {
        final String path=map.getRepoRelativePath(r.getProject());
        if (path != null && path.length() > 0)         paths.add(path);
      }
 else       if (showAllFilter == ShowFilter.SHOWALLREPO) {
      }
 else {
        final String path=map.getRepoRelativePath(r);
        if (path != null && path.length() > 0)         paths.add(path);
      }
    }
  }
 else   if (inFiles != null) {
    IPath workdirPath=new Path(db.getWorkTree().getPath());
    IPath gitDirPath=new Path(db.getDirectory().getPath());
    int segmentCount=workdirPath.segmentCount();
    paths=new ArrayList<String>(inFiles.length);
    for (    File file : inFiles) {
      IPath filePath;
      if (showAllFilter == ShowFilter.SHOWALLFOLDER) {
        filePath=new Path(file.getParentFile().getPath());
      }
 else       if (showAllFilter == ShowFilter.SHOWALLPROJECT || showAllFilter == ShowFilter.SHOWALLREPO) {
        continue;
      }
 else {
        filePath=new Path(file.getPath());
      }
      if (gitDirPath.isPrefixOf(filePath)) {
        throw new IllegalStateException(NLS.bind(UIText.GitHistoryPage_FileOrFolderPartOfGitDirMessage,filePath.toOSString()));
      }
      IPath pathToAdd=filePath.removeFirstSegments(segmentCount).setDevice(null);
      if (!pathToAdd.isEmpty()) {
        paths.add(pathToAdd.toString());
      }
    }
  }
 else {
    paths=new ArrayList<String>(0);
  }
  return paths;
}",0.972313058643994
91582,"private ArrayList<String> buildFilterPaths(final IResource[] inResources,final File[] inFiles,final Repository db) throws IllegalStateException {
  final ArrayList<String> paths;
  if (inResources != null) {
    paths=new ArrayList<String>(inResources.length);
    for (    final IResource r : inResources) {
      final RepositoryMapping map=RepositoryMapping.getMapping(r);
      if (map == null)       continue;
      if (db != map.getRepository()) {
        throw new IllegalStateException(UIText.AbstractHistoryCommanndHandler_NoUniqueRepository);
      }
      if (showAllFilter == ShowFilter.SHOWALLFOLDER) {
        final String path=map.getRepoRelativePath(r.getParent());
        if (path != null && path.length() > 0)         paths.add(path);
      }
 else       if (showAllFilter == ShowFilter.SHOWALLPROJECT) {
        final String path=map.getRepoRelativePath(r.getProject());
        if (path != null && path.length() > 0)         paths.add(path);
      }
 else       if (showAllFilter == ShowFilter.SHOWALLREPO) {
      }
 else {
        final String path=map.getRepoRelativePath(r);
        if (path != null && path.length() > 0)         paths.add(path);
      }
    }
  }
 else   if (inFiles != null) {
    IPath workdirPath=new Path(db.getWorkTree().getPath());
    IPath gitDirPath=new Path(db.getDirectory().getPath());
    int segmentCount=workdirPath.segmentCount();
    paths=new ArrayList<String>(inFiles.length);
    for (    File file : inFiles) {
      IPath filePath;
      if (showAllFilter == ShowFilter.SHOWALLFOLDER) {
        filePath=new Path(file.getParentFile().getPath());
      }
 else       if (showAllFilter == ShowFilter.SHOWALLPROJECT || showAllFilter == ShowFilter.SHOWALLREPO) {
        continue;
      }
 else {
        filePath=new Path(file.getPath());
      }
      if (gitDirPath.isPrefixOf(filePath)) {
        throw new IllegalStateException(NLS.bind(UIText.GitHistoryPage_FileOrFolderPartOfGitDirMessage,filePath.toOSString()));
      }
      IPath pathToAdd=filePath.removeFirstSegments(segmentCount).setDevice(null);
      if (!pathToAdd.isEmpty()) {
        paths.add(pathToAdd.toString());
      }
    }
  }
 else {
    paths=new ArrayList<String>(0);
  }
  return paths;
}","private ArrayList<String> buildFilterPaths(final IResource[] inResources,final File[] inFiles,final Repository db) throws IllegalStateException {
  final ArrayList<String> paths;
  if (inResources != null) {
    paths=new ArrayList<String>(inResources.length);
    for (    final IResource r : inResources) {
      final RepositoryMapping map=RepositoryMapping.getMapping(r);
      if (map == null)       continue;
      if (db != map.getRepository()) {
        throw new IllegalStateException(UIText.AbstractHistoryCommanndHandler_NoUniqueRepository);
      }
      if (showAllFilter == ShowFilter.SHOWALLFOLDER) {
        final String path;
        if (r.getParent() instanceof IWorkspaceRoot)         path=map.getRepoRelativePath(r.getProject());
 else         path=map.getRepoRelativePath(r.getParent());
        if (path != null && path.length() > 0)         paths.add(path);
      }
 else       if (showAllFilter == ShowFilter.SHOWALLPROJECT) {
        final String path=map.getRepoRelativePath(r.getProject());
        if (path != null && path.length() > 0)         paths.add(path);
      }
 else       if (showAllFilter == ShowFilter.SHOWALLREPO) {
      }
 else {
        final String path=map.getRepoRelativePath(r);
        if (path != null && path.length() > 0)         paths.add(path);
      }
    }
  }
 else   if (inFiles != null) {
    IPath workdirPath=new Path(db.getWorkTree().getPath());
    IPath gitDirPath=new Path(db.getDirectory().getPath());
    int segmentCount=workdirPath.segmentCount();
    paths=new ArrayList<String>(inFiles.length);
    for (    File file : inFiles) {
      IPath filePath;
      if (showAllFilter == ShowFilter.SHOWALLFOLDER) {
        filePath=new Path(file.getParentFile().getPath());
      }
 else       if (showAllFilter == ShowFilter.SHOWALLPROJECT || showAllFilter == ShowFilter.SHOWALLREPO) {
        continue;
      }
 else {
        filePath=new Path(file.getPath());
      }
      if (gitDirPath.isPrefixOf(filePath)) {
        throw new IllegalStateException(NLS.bind(UIText.GitHistoryPage_FileOrFolderPartOfGitDirMessage,filePath.toOSString()));
      }
      IPath pathToAdd=filePath.removeFirstSegments(segmentCount).setDevice(null);
      if (!pathToAdd.isEmpty()) {
        paths.add(pathToAdd.toString());
      }
    }
  }
 else {
    paths=new ArrayList<String>(0);
  }
  return paths;
}",0.972313058643994
91583,"/** 
 * Creates a new branch
 * @param refName starting point for the new branch
 * @param newRefName
 * @throws IOException
 */
public void createBranch(String refName,String newRefName) throws IOException {
  RefUpdate updateRef;
  updateRef=repository.updateRef(newRefName);
  Ref startRef=repository.getRef(refName);
  ObjectId startAt=repository.resolve(refName);
  String startBranch;
  if (startRef != null)   startBranch=refName;
 else   startBranch=startAt.name();
  startBranch=repository.shortenRefName(startBranch);
  updateRef.setNewObjectId(startAt);
  updateRef.setRefLogMessage(""String_Node_Str"" + startBranch,false);
  updateRef.update();
}","/** 
 * Creates a new branch
 * @param refName starting point for the new branch
 * @param newRefName
 * @throws IOException
 */
public void createBranch(String refName,String newRefName) throws IOException {
  RefUpdate updateRef;
  updateRef=repository.updateRef(newRefName);
  Ref startRef=repository.getRef(refName);
  ObjectId startAt=repository.resolve(refName);
  String startBranch;
  if (startRef != null)   startBranch=refName;
 else   startBranch=startAt.name();
  startBranch=Repository.shortenRefName(startBranch);
  updateRef.setNewObjectId(startAt);
  updateRef.setRefLogMessage(""String_Node_Str"" + startBranch,false);
  updateRef.update();
}",0.9984779299847792
91584,"protected static void createStableBranch(Repository myRepository) throws IOException {
  String newRefName=""String_Node_Str"";
  RefUpdate updateRef=myRepository.updateRef(newRefName);
  Ref sourceBranch=myRepository.getRef(""String_Node_Str"");
  ObjectId startAt=sourceBranch.getObjectId();
  String startBranch=myRepository.shortenRefName(sourceBranch.getName());
  updateRef.setNewObjectId(startAt);
  updateRef.setRefLogMessage(""String_Node_Str"" + startBranch,false);
  updateRef.update();
}","protected static void createStableBranch(Repository myRepository) throws IOException {
  String newRefName=""String_Node_Str"";
  RefUpdate updateRef=myRepository.updateRef(newRefName);
  Ref sourceBranch=myRepository.getRef(""String_Node_Str"");
  ObjectId startAt=sourceBranch.getObjectId();
  String startBranch=Repository.shortenRefName(sourceBranch.getName());
  updateRef.setNewObjectId(startAt);
  updateRef.setRefLogMessage(""String_Node_Str"" + startBranch,false);
  updateRef.update();
}",0.9979674796747968
91585,"protected static void createStableBranch(Repository myRepository) throws IOException {
  String newRefName=""String_Node_Str"";
  RefUpdate updateRef=myRepository.updateRef(newRefName);
  Ref sourceBranch=myRepository.getRef(""String_Node_Str"");
  ObjectId startAt=sourceBranch.getObjectId();
  String startBranch=myRepository.shortenRefName(sourceBranch.getName());
  updateRef.setNewObjectId(startAt);
  updateRef.setRefLogMessage(""String_Node_Str"" + startBranch,false);
  updateRef.update();
}","protected static void createStableBranch(Repository myRepository) throws IOException {
  String newRefName=""String_Node_Str"";
  RefUpdate updateRef=myRepository.updateRef(newRefName);
  Ref sourceBranch=myRepository.getRef(""String_Node_Str"");
  ObjectId startAt=sourceBranch.getObjectId();
  String startBranch=Repository.shortenRefName(sourceBranch.getName());
  updateRef.setNewObjectId(startAt);
  updateRef.setRefLogMessage(""String_Node_Str"" + startBranch,false);
  updateRef.update();
}",0.9979674796747968
91586,"public StyledString getStyledText(Object element){
  if (!(element instanceof RepositoryTreeNode))   return null;
  RepositoryTreeNode node=(RepositoryTreeNode)element;
  try {
switch (node.getType()) {
case REPO:
      Repository repository=(Repository)node.getObject();
    File directory=repository.getDirectory();
  StyledString string=new StyledString(directory.getParentFile().getName());
string.append(""String_Node_Str"" + directory.getAbsolutePath(),StyledString.QUALIFIER_STYLER);
string.append(""String_Node_Str"" + repository.getBranch() + ""String_Node_Str"",StyledString.DECORATIONS_STYLER);
return string;
case ADDITIONALREF:
Ref ref=(Ref)node.getObject();
StyledString refName=new StyledString(node.getRepository().shortenRefName(ref.getName()));
if (ref.isSymbolic()) {
refName.append(""String_Node_Str"",StyledString.QUALIFIER_STYLER);
refName.append(ref.getLeaf().getName(),StyledString.QUALIFIER_STYLER);
refName.append(""String_Node_Str"",StyledString.QUALIFIER_STYLER);
refName.append(ObjectId.toString(ref.getLeaf().getObjectId()),StyledString.QUALIFIER_STYLER);
}
 else {
refName.append(""String_Node_Str"",StyledString.QUALIFIER_STYLER);
refName.append(ObjectId.toString(ref.getObjectId()),StyledString.QUALIFIER_STYLER);
}
return refName;
case WORKINGDIR:
StyledString dirString=new StyledString(UIText.RepositoriesView_WorkingDir_treenode);
dirString.append(""String_Node_Str"",StyledString.QUALIFIER_STYLER);
if (node.getRepository().isBare()) {
dirString.append(UIText.RepositoriesViewLabelProvider_BareRepositoryMessage,StyledString.QUALIFIER_STYLER);
}
 else {
dirString.append(node.getRepository().getWorkTree().getAbsolutePath(),StyledString.QUALIFIER_STYLER);
}
return dirString;
case PUSH:
case FETCH:
case FILE:
case FOLDER:
case BRANCHES:
case LOCAL:
case REMOTETRACKING:
case BRANCHHIERARCHY:
case TAGS:
case ADDITIONALREFS:
case REMOTES:
case REMOTE:
case ERROR:
case REF:
case TAG:
{
String label=getSimpleText(node);
if (label != null) return new StyledString(label);
}
}
}
 catch (IOException e) {
Activator.logError(e.getMessage(),e);
}
return null;
}","public StyledString getStyledText(Object element){
  if (!(element instanceof RepositoryTreeNode))   return null;
  RepositoryTreeNode node=(RepositoryTreeNode)element;
  try {
switch (node.getType()) {
case REPO:
      Repository repository=(Repository)node.getObject();
    File directory=repository.getDirectory();
  StyledString string=new StyledString(directory.getParentFile().getName());
string.append(""String_Node_Str"" + directory.getAbsolutePath(),StyledString.QUALIFIER_STYLER);
string.append(""String_Node_Str"" + repository.getBranch() + ""String_Node_Str"",StyledString.DECORATIONS_STYLER);
return string;
case ADDITIONALREF:
Ref ref=(Ref)node.getObject();
StyledString refName=new StyledString(Repository.shortenRefName(ref.getName()));
if (ref.isSymbolic()) {
refName.append(""String_Node_Str"",StyledString.QUALIFIER_STYLER);
refName.append(ref.getLeaf().getName(),StyledString.QUALIFIER_STYLER);
refName.append(""String_Node_Str"",StyledString.QUALIFIER_STYLER);
refName.append(ObjectId.toString(ref.getLeaf().getObjectId()),StyledString.QUALIFIER_STYLER);
}
 else {
refName.append(""String_Node_Str"",StyledString.QUALIFIER_STYLER);
refName.append(ObjectId.toString(ref.getObjectId()),StyledString.QUALIFIER_STYLER);
}
return refName;
case WORKINGDIR:
StyledString dirString=new StyledString(UIText.RepositoriesView_WorkingDir_treenode);
dirString.append(""String_Node_Str"",StyledString.QUALIFIER_STYLER);
if (node.getRepository().isBare()) {
dirString.append(UIText.RepositoriesViewLabelProvider_BareRepositoryMessage,StyledString.QUALIFIER_STYLER);
}
 else {
dirString.append(node.getRepository().getWorkTree().getAbsolutePath(),StyledString.QUALIFIER_STYLER);
}
return dirString;
case PUSH:
case FETCH:
case FILE:
case FOLDER:
case BRANCHES:
case LOCAL:
case REMOTETRACKING:
case BRANCHHIERARCHY:
case TAGS:
case ADDITIONALREFS:
case REMOTES:
case REMOTE:
case ERROR:
case REF:
case TAG:
{
String label=getSimpleText(node);
if (label != null) return new StyledString(label);
}
}
}
 catch (IOException e) {
Activator.logError(e.getMessage(),e);
}
return null;
}",0.9927710843373494
91587,"private String getSimpleText(RepositoryTreeNode node){
switch (node.getType()) {
case REPO:
    File directory=((Repository)node.getObject()).getDirectory();
  StringBuilder sb=new StringBuilder();
sb.append(directory.getParentFile().getName());
sb.append(""String_Node_Str"");
sb.append(directory.getAbsolutePath());
return sb.toString();
case FILE:
case FOLDER:
return ((File)node.getObject()).getName();
case BRANCHES:
return UIText.RepositoriesView_Branches_Nodetext;
case LOCAL:
return UIText.RepositoriesViewLabelProvider_LocalNodetext;
case REMOTETRACKING:
return UIText.RepositoriesViewLabelProvider_RemoteTrackingNodetext;
case BRANCHHIERARCHY:
IPath fullPath=(IPath)node.getObject();
return fullPath.lastSegment();
case TAGS:
return UIText.RepositoriesViewLabelProvider_TagsNodeText;
case ADDITIONALREFS:
return UIText.RepositoriesViewLabelProvider_SymbolicRefNodeText;
case REMOTES:
return UIText.RepositoriesView_RemotesNodeText;
case REF:
case TAG:
{
Ref ref=(Ref)node.getObject();
String refName=node.getRepository().shortenRefName(ref.getName());
if (node.getParent().getType() == RepositoryTreeNodeType.BRANCHHIERARCHY) {
int index=refName.lastIndexOf('/');
refName=refName.substring(index + 1);
}
return refName;
}
case ADDITIONALREF:
{
Ref ref=(Ref)node.getObject();
String refName=node.getRepository().shortenRefName(ref.getName());
if (ref.isSymbolic()) {
refName=refName + ""String_Node_Str"" + ref.getLeaf().getName()+ ""String_Node_Str""+ ObjectId.toString(ref.getLeaf().getObjectId());
}
 else {
refName=refName + ""String_Node_Str"" + ObjectId.toString(ref.getObjectId());
}
return refName;
}
case WORKINGDIR:
if (node.getRepository().isBare()) return UIText.RepositoriesView_WorkingDir_treenode + ""String_Node_Str"" + UIText.RepositoriesViewLabelProvider_BareRepositoryMessage;
 else return UIText.RepositoriesView_WorkingDir_treenode + ""String_Node_Str"" + node.getRepository().getWorkTree().getAbsolutePath();
case REMOTE:
case PUSH:
case FETCH:
case ERROR:
return (String)node.getObject();
}
return null;
}","private String getSimpleText(RepositoryTreeNode node){
switch (node.getType()) {
case REPO:
    File directory=((Repository)node.getObject()).getDirectory();
  StringBuilder sb=new StringBuilder();
sb.append(directory.getParentFile().getName());
sb.append(""String_Node_Str"");
sb.append(directory.getAbsolutePath());
return sb.toString();
case FILE:
case FOLDER:
return ((File)node.getObject()).getName();
case BRANCHES:
return UIText.RepositoriesView_Branches_Nodetext;
case LOCAL:
return UIText.RepositoriesViewLabelProvider_LocalNodetext;
case REMOTETRACKING:
return UIText.RepositoriesViewLabelProvider_RemoteTrackingNodetext;
case BRANCHHIERARCHY:
IPath fullPath=(IPath)node.getObject();
return fullPath.lastSegment();
case TAGS:
return UIText.RepositoriesViewLabelProvider_TagsNodeText;
case ADDITIONALREFS:
return UIText.RepositoriesViewLabelProvider_SymbolicRefNodeText;
case REMOTES:
return UIText.RepositoriesView_RemotesNodeText;
case REF:
case TAG:
{
Ref ref=(Ref)node.getObject();
String refName=Repository.shortenRefName(ref.getName());
if (node.getParent().getType() == RepositoryTreeNodeType.BRANCHHIERARCHY) {
int index=refName.lastIndexOf('/');
refName=refName.substring(index + 1);
}
return refName;
}
case ADDITIONALREF:
{
Ref ref=(Ref)node.getObject();
String refName=Repository.shortenRefName(ref.getName());
if (ref.isSymbolic()) {
refName=refName + ""String_Node_Str"" + ref.getLeaf().getName()+ ""String_Node_Str""+ ObjectId.toString(ref.getLeaf().getObjectId());
}
 else {
refName=refName + ""String_Node_Str"" + ObjectId.toString(ref.getObjectId());
}
return refName;
}
case WORKINGDIR:
if (node.getRepository().isBare()) return UIText.RepositoriesView_WorkingDir_treenode + ""String_Node_Str"" + UIText.RepositoriesViewLabelProvider_BareRepositoryMessage;
 else return UIText.RepositoriesView_WorkingDir_treenode + ""String_Node_Str"" + node.getRepository().getWorkTree().getAbsolutePath();
case REMOTE:
case PUSH:
case FETCH:
case ERROR:
return (String)node.getObject();
}
return null;
}",0.9950372208436724
91588,"public Object execute(ExecutionEvent event) throws ExecutionException {
  final List<RefNode> nodes=getSelectedNodes(event);
  RefNode refNode=nodes.get(0);
  Shell shell=getShell(event);
  String oldName=refNode.getObject().getName();
  String prefix;
  if (oldName.startsWith(Constants.R_HEADS))   prefix=Constants.R_HEADS;
 else   if (oldName.startsWith(Constants.R_REMOTES))   prefix=Constants.R_REMOTES;
 else   throw new ExecutionException(NLS.bind(UIText.RenameBranchCommand_WrongNameMessage,oldName));
  Repository db=refNode.getRepository();
  IInputValidator inputValidator=ValidationUtils.getRefNameInputValidator(db,prefix,true);
  String defaultValue=db.shortenRefName(oldName);
  InputDialog newNameDialog=new InputDialog(shell,UIText.RepositoriesView_RenameBranchTitle,NLS.bind(UIText.RepositoriesView_RenameBranchMessage,defaultValue),defaultValue,inputValidator);
  if (newNameDialog.open() == Window.OK) {
    try {
      String newName=newNameDialog.getValue();
      new RenameBranchOperation(db,refNode.getObject(),newName).execute(null);
    }
 catch (    CoreException e) {
      Activator.handleError(UIText.RepositoriesView_RenameBranchFailure,e,true);
    }
  }
  return null;
}","public Object execute(ExecutionEvent event) throws ExecutionException {
  final List<RefNode> nodes=getSelectedNodes(event);
  RefNode refNode=nodes.get(0);
  Shell shell=getShell(event);
  String oldName=refNode.getObject().getName();
  String prefix;
  if (oldName.startsWith(Constants.R_HEADS))   prefix=Constants.R_HEADS;
 else   if (oldName.startsWith(Constants.R_REMOTES))   prefix=Constants.R_REMOTES;
 else   throw new ExecutionException(NLS.bind(UIText.RenameBranchCommand_WrongNameMessage,oldName));
  Repository db=refNode.getRepository();
  IInputValidator inputValidator=ValidationUtils.getRefNameInputValidator(db,prefix,true);
  String defaultValue=Repository.shortenRefName(oldName);
  InputDialog newNameDialog=new InputDialog(shell,UIText.RepositoriesView_RenameBranchTitle,NLS.bind(UIText.RepositoriesView_RenameBranchMessage,defaultValue),defaultValue,inputValidator);
  if (newNameDialog.open() == Window.OK) {
    try {
      String newName=newNameDialog.getValue();
      new RenameBranchOperation(db,refNode.getObject(),newName).execute(null);
    }
 catch (    CoreException e) {
      Activator.handleError(UIText.RepositoriesView_RenameBranchFailure,e,true);
    }
  }
  return null;
}",0.9950331125827816
91589,"private List<IPath> getPathList() throws IOException {
  List<IPath> result=new ArrayList<IPath>();
  Set<String> children=getRepository().getRefDatabase().getRefs(getObject().toPortableString()).keySet();
  for (  String pathEntry : children) {
    result.add(getObject().append(new Path(pathEntry)));
  }
  return result;
}","private List<IPath> getPathList() throws IOException {
  List<IPath> result=new ArrayList<IPath>();
  Map<String,Ref> refsMap=getRepository().getRefDatabase().getRefs(getObject().toPortableString());
  for (  Map.Entry<String,Ref> entry : refsMap.entrySet()) {
    if (entry.getValue().isSymbolic())     continue;
    result.add(getObject().append(new Path(entry.getKey())));
  }
  return result;
}",0.710926694329184
91590,"/** 
 * Remove or delete the repository
 * @param event
 * @param delete if <code>true</code>, the repository will be deleted from disk
 */
protected void removeRepository(final ExecutionEvent event,final boolean delete){
  IWorkbenchSite activeSite=HandlerUtil.getActiveSite(event);
  IWorkbenchSiteProgressService service=(IWorkbenchSiteProgressService)activeSite.getService(IWorkbenchSiteProgressService.class);
  if (delete)   try {
    List<RepositoryNode> selectedNodes=getSelectedNodes(event);
    String title=UIText.RemoveCommand_DeleteConfirmTitle;
    if (selectedNodes.size() > 1) {
      String message=NLS.bind(UIText.RemoveCommand_DeleteConfirmSingleMessage,Integer.valueOf(selectedNodes.size()));
      if (!MessageDialog.openConfirm(getShell(event),title,message))       return;
    }
 else     if (selectedNodes.size() == 1) {
      String name=org.eclipse.egit.core.Activator.getDefault().getRepositoryUtil().getRepositoryName(selectedNodes.get(0).getObject());
      String message=NLS.bind(UIText.RemoveCommand_DeleteConfirmMultiMessage,name);
      if (!MessageDialog.openConfirm(getShell(event),title,message))       return;
    }
  }
 catch (  ExecutionException e) {
    Activator.handleError(e.getMessage(),e,false);
    return;
  }
  Job job=new Job(""String_Node_Str""){
    @Override protected IStatus run(    IProgressMonitor monitor){
      final List<IProject> projectsToDelete=new ArrayList<IProject>();
      monitor.setTaskName(UIText.RepositoriesView_DeleteRepoDeterminProjectsMessage);
      List<RepositoryNode> selectedNodes;
      try {
        selectedNodes=getSelectedNodes(event);
      }
 catch (      ExecutionException e) {
        Activator.logError(e.getMessage(),e);
        return new Status(IStatus.ERROR,Activator.getPluginId(),e.getMessage(),e);
      }
      for (      RepositoryNode node : selectedNodes) {
        if (node.getRepository().isBare())         continue;
        File workDir=node.getRepository().getWorkTree();
        final IPath wdPath=new Path(workDir.getAbsolutePath());
        for (        IProject prj : ResourcesPlugin.getWorkspace().getRoot().getProjects()) {
          if (monitor.isCanceled())           return Status.OK_STATUS;
          if (wdPath.isPrefixOf(prj.getLocation())) {
            projectsToDelete.add(prj);
          }
        }
      }
      final boolean[] confirmedCanceled=new boolean[]{false,false};
      if (!projectsToDelete.isEmpty()) {
        Display.getDefault().syncExec(new Runnable(){
          public void run(){
            try {
              confirmedCanceled[0]=confirmProjectDeletion(projectsToDelete,event);
            }
 catch (            OperationCanceledException e) {
              confirmedCanceled[1]=true;
            }
          }
        }
);
      }
      if (confirmedCanceled[1]) {
        return Status.OK_STATUS;
      }
      if (confirmedCanceled[0]) {
        IWorkspaceRunnable wsr=new IWorkspaceRunnable(){
          public void run(          IProgressMonitor actMonitor) throws CoreException {
            for (            IProject prj : projectsToDelete)             prj.delete(false,false,actMonitor);
          }
        }
;
        try {
          ResourcesPlugin.getWorkspace().run(wsr,ResourcesPlugin.getWorkspace().getRoot(),IWorkspace.AVOID_UPDATE,monitor);
        }
 catch (        CoreException e1) {
          Activator.logError(e1.getMessage(),e1);
        }
      }
      for (      RepositoryNode node : selectedNodes) {
        util.removeDir(node.getRepository().getDirectory());
      }
      Display.getDefault().asyncExec(new Runnable(){
        public void run(){
          RepositoriesView view;
          try {
            view=getView(event);
            view.getCommonViewer().refresh();
          }
 catch (          ExecutionException e) {
            Activator.logError(e.getMessage(),e);
          }
        }
      }
);
      if (delete) {
        try {
          for (          RepositoryNode node : selectedNodes) {
            Repository repo=node.getRepository();
            if (!repo.isBare())             deleteRecursive(repo.getWorkTree());
            deleteRecursive(repo.getDirectory());
          }
        }
 catch (        IOException e) {
          return Activator.createErrorStatus(e.getMessage(),e);
        }
      }
      return Status.OK_STATUS;
    }
    private void deleteRecursive(    File fileToDelete) throws IOException {
      if (fileToDelete == null)       return;
      if (fileToDelete.exists()) {
        if (fileToDelete.isDirectory()) {
          for (          File file : fileToDelete.listFiles()) {
            deleteRecursive(file);
          }
        }
        if (!fileToDelete.delete())         throw new IOException(NLS.bind(UIText.RemoveCommand_DeleteFailureMessage,fileToDelete.getAbsolutePath()));
      }
    }
  }
;
  service.schedule(job);
}","/** 
 * Remove or delete the repository
 * @param event
 * @param delete if <code>true</code>, the repository will be deleted from disk
 */
protected void removeRepository(final ExecutionEvent event,final boolean delete){
  IWorkbenchSite activeSite=HandlerUtil.getActiveSite(event);
  IWorkbenchSiteProgressService service=(IWorkbenchSiteProgressService)activeSite.getService(IWorkbenchSiteProgressService.class);
  final List<RepositoryNode> selectedNodes;
  try {
    selectedNodes=getSelectedNodes(event);
  }
 catch (  ExecutionException e) {
    Activator.handleError(e.getMessage(),e,true);
    return;
  }
  if (delete) {
    String title=UIText.RemoveCommand_DeleteConfirmTitle;
    if (selectedNodes.size() > 1) {
      String message=NLS.bind(UIText.RemoveCommand_DeleteConfirmSingleMessage,Integer.valueOf(selectedNodes.size()));
      if (!MessageDialog.openConfirm(getShell(event),title,message))       return;
    }
 else     if (selectedNodes.size() == 1) {
      String name=org.eclipse.egit.core.Activator.getDefault().getRepositoryUtil().getRepositoryName(selectedNodes.get(0).getObject());
      String message=NLS.bind(UIText.RemoveCommand_DeleteConfirmMultiMessage,name);
      if (!MessageDialog.openConfirm(getShell(event),title,message))       return;
    }
  }
  Job job=new Job(""String_Node_Str""){
    @Override protected IStatus run(    IProgressMonitor monitor){
      final List<IProject> projectsToDelete=new ArrayList<IProject>();
      monitor.setTaskName(UIText.RepositoriesView_DeleteRepoDeterminProjectsMessage);
      for (      RepositoryNode node : selectedNodes) {
        if (node.getRepository().isBare())         continue;
        File workDir=node.getRepository().getWorkTree();
        final IPath wdPath=new Path(workDir.getAbsolutePath());
        for (        IProject prj : ResourcesPlugin.getWorkspace().getRoot().getProjects()) {
          if (monitor.isCanceled())           return Status.OK_STATUS;
          if (wdPath.isPrefixOf(prj.getLocation())) {
            projectsToDelete.add(prj);
          }
        }
      }
      final boolean[] confirmedCanceled=new boolean[]{false,false};
      if (!projectsToDelete.isEmpty()) {
        Display.getDefault().syncExec(new Runnable(){
          public void run(){
            try {
              confirmedCanceled[0]=confirmProjectDeletion(projectsToDelete,event);
            }
 catch (            OperationCanceledException e) {
              confirmedCanceled[1]=true;
            }
          }
        }
);
      }
      if (confirmedCanceled[1]) {
        return Status.OK_STATUS;
      }
      if (confirmedCanceled[0]) {
        IWorkspaceRunnable wsr=new IWorkspaceRunnable(){
          public void run(          IProgressMonitor actMonitor) throws CoreException {
            for (            IProject prj : projectsToDelete)             prj.delete(false,false,actMonitor);
          }
        }
;
        try {
          ResourcesPlugin.getWorkspace().run(wsr,ResourcesPlugin.getWorkspace().getRoot(),IWorkspace.AVOID_UPDATE,monitor);
        }
 catch (        CoreException e1) {
          Activator.logError(e1.getMessage(),e1);
        }
      }
      for (      RepositoryNode node : selectedNodes) {
        util.removeDir(node.getRepository().getDirectory());
      }
      Display.getDefault().asyncExec(new Runnable(){
        public void run(){
          RepositoriesView view;
          try {
            view=getView(event);
            view.getCommonViewer().refresh();
          }
 catch (          ExecutionException e) {
            Activator.logError(e.getMessage(),e);
          }
        }
      }
);
      if (delete) {
        try {
          for (          RepositoryNode node : selectedNodes) {
            Repository repo=node.getRepository();
            if (!repo.isBare())             deleteRecursive(repo.getWorkTree());
            deleteRecursive(repo.getDirectory());
          }
        }
 catch (        IOException e) {
          return Activator.createErrorStatus(e.getMessage(),e);
        }
      }
      return Status.OK_STATUS;
    }
    private void deleteRecursive(    File fileToDelete) throws IOException {
      if (fileToDelete == null)       return;
      if (fileToDelete.exists()) {
        if (fileToDelete.isDirectory()) {
          for (          File file : fileToDelete.listFiles()) {
            deleteRecursive(file);
          }
        }
        if (!fileToDelete.delete())         throw new IOException(NLS.bind(UIText.RemoveCommand_DeleteFailureMessage,fileToDelete.getAbsolutePath()));
      }
    }
  }
;
  service.schedule(job);
}",0.940828402366864
91591,"public void run(){
  commit[0]=(RevCommit)table.widget.getSelection()[0].getData();
}","public void run(){
  TableItem tableItem=table.widget.getSelection()[0];
  ensureTableItemLoaded(tableItem);
  commit[0]=(RevCommit)tableItem.getData();
}",0.5606694560669456
91592,"@Test public void testAddTag() throws Exception {
  Repository repo=lookupRepository(repoFile);
  assertNull(repo.resolve(Constants.R_TAGS + ""String_Node_Str""));
  final SWTBotTable table=getHistoryViewTable(PROJ1);
  table.getTableItem(0).select();
  final RevCommit[] commit=new RevCommit[1];
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      commit[0]=(RevCommit)table.widget.getSelection()[0].getData();
    }
  }
);
  ContextMenuHelper.clickContextMenu(table,UIText.GitHistoryPage_CreateTagMenuLabel);
  SWTBotShell dialog=bot.shell(UIText.CreateTagDialog_NewTag);
  dialog.bot().textWithLabel(UIText.CreateTagDialog_tagName).setText(""String_Node_Str"");
  dialog.bot().textWithLabel(UIText.CreateTagDialog_tagMessage).setText(""String_Node_Str"");
  dialog.bot().button(IDialogConstants.OK_LABEL).click();
  waitInUI();
  assertNotNull(repo.resolve(Constants.R_TAGS + ""String_Node_Str""));
}","@Test public void testAddTag() throws Exception {
  Repository repo=lookupRepository(repoFile);
  assertNull(repo.resolve(Constants.R_TAGS + ""String_Node_Str""));
  final SWTBotTable table=getHistoryViewTable(PROJ1);
  table.getTableItem(0).select();
  final RevCommit[] commit=new RevCommit[1];
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      TableItem tableItem=table.widget.getSelection()[0];
      ensureTableItemLoaded(tableItem);
      commit[0]=(RevCommit)tableItem.getData();
    }
  }
);
  ContextMenuHelper.clickContextMenu(table,UIText.GitHistoryPage_CreateTagMenuLabel);
  SWTBotShell dialog=bot.shell(UIText.CreateTagDialog_NewTag);
  dialog.bot().textWithLabel(UIText.CreateTagDialog_tagName).setText(""String_Node_Str"");
  dialog.bot().textWithLabel(UIText.CreateTagDialog_tagMessage).setText(""String_Node_Str"");
  dialog.bot().button(IDialogConstants.OK_LABEL).click();
  waitInUI();
  assertNotNull(repo.resolve(Constants.R_TAGS + ""String_Node_Str""));
}",0.9337506520605112
91593,"@Test public void testCheckOut() throws Exception {
  Repository repo=lookupRepository(repoFile);
  assertEquals(Constants.MASTER,repo.getBranch());
  final SWTBotTable table=getHistoryViewTable(PROJ1);
  table.getTableItem(1).select();
  final RevCommit[] commit=new RevCommit[1];
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      commit[0]=(RevCommit)table.widget.getSelection()[0].getData();
    }
  }
);
  ContextMenuHelper.clickContextMenu(table,UIText.GitHistoryPage_CheckoutMenuLabel);
  waitInUI();
  assertEquals(commit[0].getId().name(),repo.getBranch());
}","@Test public void testCheckOut() throws Exception {
  Repository repo=lookupRepository(repoFile);
  assertEquals(Constants.MASTER,repo.getBranch());
  final SWTBotTable table=getHistoryViewTable(PROJ1);
  table.getTableItem(1).select();
  final RevCommit[] commit=new RevCommit[1];
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
      TableItem tableItem=table.widget.getSelection()[0];
      ensureTableItemLoaded(tableItem);
      commit[0]=(RevCommit)tableItem.getData();
    }
  }
);
  ContextMenuHelper.clickContextMenu(table,UIText.GitHistoryPage_CheckoutMenuLabel);
  waitInUI();
  assertEquals(commit[0].getId().name(),repo.getBranch());
}",0.6229249011857707
91594,"/** 
 * Remove or delete the repository
 * @param event
 * @param delete if <code>true</code>, the repository will be deleted from disk
 */
protected void removeRepository(final ExecutionEvent event,final boolean delete){
  IWorkbenchSite activeSite=HandlerUtil.getActiveSite(event);
  IWorkbenchSiteProgressService service=(IWorkbenchSiteProgressService)activeSite.getService(IWorkbenchSiteProgressService.class);
  if (delete)   try {
    List<RepositoryNode> selectedNodes=getSelectedNodes(event);
    String title=UIText.RemoveCommand_DeleteConfirmTitle;
    if (selectedNodes.size() > 1) {
      String message=NLS.bind(UIText.RemoveCommand_DeleteConfirmSingleMessage,Integer.valueOf(selectedNodes.size()));
      if (!MessageDialog.openConfirm(getShell(event),title,message))       return;
    }
 else     if (selectedNodes.size() == 1) {
      String name=org.eclipse.egit.core.Activator.getDefault().getRepositoryUtil().getRepositoryName(selectedNodes.get(0).getObject());
      String message=NLS.bind(UIText.RemoveCommand_DeleteConfirmMultiMessage,name);
      if (!MessageDialog.openConfirm(getShell(event),title,message))       return;
    }
  }
 catch (  ExecutionException e) {
    Activator.handleError(e.getMessage(),e,false);
    return;
  }
  Job job=new Job(""String_Node_Str""){
    @Override protected IStatus run(    IProgressMonitor monitor){
      final List<IProject> projectsToDelete=new ArrayList<IProject>();
      monitor.setTaskName(UIText.RepositoriesView_DeleteRepoDeterminProjectsMessage);
      List<RepositoryNode> selectedNodes;
      try {
        selectedNodes=getSelectedNodes(event);
      }
 catch (      ExecutionException e) {
        Activator.logError(e.getMessage(),e);
        return new Status(IStatus.ERROR,Activator.getPluginId(),e.getMessage(),e);
      }
      for (      RepositoryNode node : selectedNodes) {
        if (node.getRepository().isBare())         continue;
        File workDir=node.getRepository().getWorkTree();
        final IPath wdPath=new Path(workDir.getAbsolutePath());
        for (        IProject prj : ResourcesPlugin.getWorkspace().getRoot().getProjects()) {
          if (monitor.isCanceled())           return Status.OK_STATUS;
          if (wdPath.isPrefixOf(prj.getLocation())) {
            projectsToDelete.add(prj);
          }
        }
      }
      final boolean[] confirmedCanceled=new boolean[]{false,false};
      if (!projectsToDelete.isEmpty()) {
        Display.getDefault().syncExec(new Runnable(){
          public void run(){
            try {
              confirmedCanceled[0]=confirmProjectDeletion(projectsToDelete,event);
            }
 catch (            OperationCanceledException e) {
              confirmedCanceled[1]=true;
            }
          }
        }
);
      }
      if (confirmedCanceled[1]) {
        return Status.OK_STATUS;
      }
      if (confirmedCanceled[0]) {
        IWorkspaceRunnable wsr=new IWorkspaceRunnable(){
          public void run(          IProgressMonitor actMonitor) throws CoreException {
            for (            IProject prj : projectsToDelete)             prj.delete(false,false,actMonitor);
          }
        }
;
        try {
          ResourcesPlugin.getWorkspace().run(wsr,ResourcesPlugin.getWorkspace().getRoot(),IWorkspace.AVOID_UPDATE,monitor);
        }
 catch (        CoreException e1) {
          Activator.logError(e1.getMessage(),e1);
        }
      }
      for (      RepositoryNode node : selectedNodes) {
        util.removeDir(node.getRepository().getDirectory());
      }
      Display.getDefault().asyncExec(new Runnable(){
        public void run(){
          RepositoriesView view;
          try {
            view=getView(event);
            view.getCommonViewer().refresh();
          }
 catch (          ExecutionException e) {
            Activator.logError(e.getMessage(),e);
          }
        }
      }
);
      if (delete) {
        try {
          for (          RepositoryNode node : selectedNodes) {
            Repository repo=node.getRepository();
            if (!repo.isBare())             deleteRecursive(repo.getWorkTree());
            deleteRecursive(repo.getDirectory());
          }
        }
 catch (        IOException e) {
          return Activator.createErrorStatus(e.getMessage(),e);
        }
      }
      return Status.OK_STATUS;
    }
    private void deleteRecursive(    File fileToDelete) throws IOException {
      if (fileToDelete == null)       return;
      if (fileToDelete.exists()) {
        if (fileToDelete.isDirectory()) {
          for (          File file : fileToDelete.listFiles()) {
            deleteRecursive(file);
          }
        }
        if (!fileToDelete.delete())         throw new IOException(NLS.bind(UIText.RemoveCommand_DeleteFailureMessage,fileToDelete.getAbsolutePath()));
      }
    }
  }
;
  service.schedule(job);
}","/** 
 * Remove or delete the repository
 * @param event
 * @param delete if <code>true</code>, the repository will be deleted from disk
 */
protected void removeRepository(final ExecutionEvent event,final boolean delete){
  IWorkbenchSite activeSite=HandlerUtil.getActiveSite(event);
  IWorkbenchSiteProgressService service=(IWorkbenchSiteProgressService)activeSite.getService(IWorkbenchSiteProgressService.class);
  final List<RepositoryNode> selectedNodes;
  try {
    selectedNodes=getSelectedNodes(event);
  }
 catch (  ExecutionException e) {
    Activator.handleError(e.getMessage(),e,true);
    return;
  }
  if (delete) {
    String title=UIText.RemoveCommand_DeleteConfirmTitle;
    if (selectedNodes.size() > 1) {
      String message=NLS.bind(UIText.RemoveCommand_DeleteConfirmSingleMessage,Integer.valueOf(selectedNodes.size()));
      if (!MessageDialog.openConfirm(getShell(event),title,message))       return;
    }
 else     if (selectedNodes.size() == 1) {
      String name=org.eclipse.egit.core.Activator.getDefault().getRepositoryUtil().getRepositoryName(selectedNodes.get(0).getObject());
      String message=NLS.bind(UIText.RemoveCommand_DeleteConfirmMultiMessage,name);
      if (!MessageDialog.openConfirm(getShell(event),title,message))       return;
    }
  }
  Job job=new Job(""String_Node_Str""){
    @Override protected IStatus run(    IProgressMonitor monitor){
      final List<IProject> projectsToDelete=new ArrayList<IProject>();
      monitor.setTaskName(UIText.RepositoriesView_DeleteRepoDeterminProjectsMessage);
      for (      RepositoryNode node : selectedNodes) {
        if (node.getRepository().isBare())         continue;
        File workDir=node.getRepository().getWorkTree();
        final IPath wdPath=new Path(workDir.getAbsolutePath());
        for (        IProject prj : ResourcesPlugin.getWorkspace().getRoot().getProjects()) {
          if (monitor.isCanceled())           return Status.OK_STATUS;
          if (wdPath.isPrefixOf(prj.getLocation())) {
            projectsToDelete.add(prj);
          }
        }
      }
      final boolean[] confirmedCanceled=new boolean[]{false,false};
      if (!projectsToDelete.isEmpty()) {
        Display.getDefault().syncExec(new Runnable(){
          public void run(){
            try {
              confirmedCanceled[0]=confirmProjectDeletion(projectsToDelete,event);
            }
 catch (            OperationCanceledException e) {
              confirmedCanceled[1]=true;
            }
          }
        }
);
      }
      if (confirmedCanceled[1]) {
        return Status.OK_STATUS;
      }
      if (confirmedCanceled[0]) {
        IWorkspaceRunnable wsr=new IWorkspaceRunnable(){
          public void run(          IProgressMonitor actMonitor) throws CoreException {
            for (            IProject prj : projectsToDelete)             prj.delete(false,false,actMonitor);
          }
        }
;
        try {
          ResourcesPlugin.getWorkspace().run(wsr,ResourcesPlugin.getWorkspace().getRoot(),IWorkspace.AVOID_UPDATE,monitor);
        }
 catch (        CoreException e1) {
          Activator.logError(e1.getMessage(),e1);
        }
      }
      for (      RepositoryNode node : selectedNodes) {
        util.removeDir(node.getRepository().getDirectory());
      }
      Display.getDefault().asyncExec(new Runnable(){
        public void run(){
          RepositoriesView view;
          try {
            view=getView(event);
            view.getCommonViewer().refresh();
          }
 catch (          ExecutionException e) {
            Activator.logError(e.getMessage(),e);
          }
        }
      }
);
      if (delete) {
        try {
          for (          RepositoryNode node : selectedNodes) {
            Repository repo=node.getRepository();
            if (!repo.isBare())             deleteRecursive(repo.getWorkTree());
            deleteRecursive(repo.getDirectory());
          }
        }
 catch (        IOException e) {
          return Activator.createErrorStatus(e.getMessage(),e);
        }
      }
      return Status.OK_STATUS;
    }
    private void deleteRecursive(    File fileToDelete) throws IOException {
      if (fileToDelete == null)       return;
      if (fileToDelete.exists()) {
        if (fileToDelete.isDirectory()) {
          for (          File file : fileToDelete.listFiles()) {
            deleteRecursive(file);
          }
        }
        if (!fileToDelete.delete())         throw new IOException(NLS.bind(UIText.RemoveCommand_DeleteFailureMessage,fileToDelete.getAbsolutePath()));
      }
    }
  }
;
  service.schedule(job);
}",0.940828402366864
91595,"private void outputEclipseDiff(final StringBuilder d,final Repository db,final ObjectReader reader,final DiffFormatter diffFmt) throws IOException {
  if (!(getBlobs().length == 2))   throw new UnsupportedOperationException(""String_Node_Str"");
  String projectRelativePath=getProjectRelativePath(db,getPath());
  d.append(""String_Node_Str"").append(projectRelativePath).append(""String_Node_Str"").append(projectRelativePath).append(""String_Node_Str"");
  final ObjectId id1=getBlobs()[0];
  final ObjectId id2=getBlobs()[1];
  final FileMode mode1=getModes()[0];
  final FileMode mode2=getModes()[1];
  if (id1.equals(ObjectId.zeroId())) {
    d.append(""String_Node_Str"" + mode2).append(""String_Node_Str"");
  }
 else   if (id2.equals(ObjectId.zeroId())) {
    d.append(""String_Node_Str"" + mode1).append(""String_Node_Str"");
  }
 else   if (!mode1.equals(mode2)) {
    d.append(""String_Node_Str"" + mode1);
    d.append(""String_Node_Str"" + mode2).append(""String_Node_Str"");
  }
  d.append(""String_Node_Str"").append(reader.abbreviate(id1).name()).append(""String_Node_Str"").append(reader.abbreviate(id2).name()).append(mode1.equals(mode2) ? ""String_Node_Str"" + mode1 : ""String_Node_Str"").append(""String_Node_Str"");
  if (id1.equals(ObjectId.zeroId()))   d.append(""String_Node_Str"");
 else {
    d.append(""String_Node_Str"");
    d.append(getProjectRelativePath(db,getPath()));
    d.append(""String_Node_Str"");
  }
  if (id2.equals(ObjectId.zeroId()))   d.append(""String_Node_Str"");
 else {
    d.append(""String_Node_Str"");
    d.append(getProjectRelativePath(db,getPath()));
    d.append(""String_Node_Str"");
  }
  final RawText a=getRawText(id1,reader);
  final RawText b=getRawText(id2,reader);
  final MyersDiff diff=new MyersDiff(RawTextComparator.DEFAULT,a,b);
  diffFmt.format(diff.getEdits(),a,b);
}","private void outputEclipseDiff(final StringBuilder d,final Repository db,final ObjectReader reader,final DiffFormatter diffFmt) throws IOException {
  if (!(getBlobs().length == 2))   throw new UnsupportedOperationException(""String_Node_Str"");
  String projectRelativePath=getProjectRelativePath(db,getPath());
  d.append(""String_Node_Str"").append(projectRelativePath).append(""String_Node_Str"").append(projectRelativePath).append(""String_Node_Str"");
  final ObjectId id1=getBlobs()[0];
  final ObjectId id2=getBlobs()[1];
  final FileMode mode1=getModes()[0];
  final FileMode mode2=getModes()[1];
  if (id1.equals(ObjectId.zeroId())) {
    d.append(""String_Node_Str"" + mode2).append(""String_Node_Str"");
  }
 else   if (id2.equals(ObjectId.zeroId())) {
    d.append(""String_Node_Str"" + mode1).append(""String_Node_Str"");
  }
 else   if (!mode1.equals(mode2)) {
    d.append(""String_Node_Str"" + mode1);
    d.append(""String_Node_Str"" + mode2).append(""String_Node_Str"");
  }
  d.append(""String_Node_Str"").append(reader.abbreviate(id1).name()).append(""String_Node_Str"").append(reader.abbreviate(id2).name()).append(mode1.equals(mode2) ? ""String_Node_Str"" + mode1 : ""String_Node_Str"").append(""String_Node_Str"");
  if (id1.equals(ObjectId.zeroId()))   d.append(""String_Node_Str"");
 else {
    d.append(""String_Node_Str"");
    d.append(getProjectRelativePath(db,getPath()));
    d.append(""String_Node_Str"");
  }
  if (id2.equals(ObjectId.zeroId()))   d.append(""String_Node_Str"");
 else {
    d.append(""String_Node_Str"");
    d.append(getProjectRelativePath(db,getPath()));
    d.append(""String_Node_Str"");
  }
  final RawText a=getRawText(id1,reader);
  final RawText b=getRawText(id2,reader);
  EditList editList=MyersDiff.INSTANCE.diff(RawTextComparator.DEFAULT,a,b);
  diffFmt.format(editList,a,b);
}",0.9793986636971048
91596,"private List<IPath> getPathList() throws IOException {
  List<IPath> result=new ArrayList<IPath>();
  Set<String> children=getRepository().getRefDatabase().getRefs(getObject().toPortableString()).keySet();
  for (  String pathEntry : children) {
    result.add(getObject().append(new Path(pathEntry)));
  }
  return result;
}","private List<IPath> getPathList() throws IOException {
  List<IPath> result=new ArrayList<IPath>();
  Map<String,Ref> refsMap=getRepository().getRefDatabase().getRefs(getObject().toPortableString());
  for (  Map.Entry<String,Ref> entry : refsMap.entrySet()) {
    if (entry.getValue().isSymbolic())     continue;
    result.add(getObject().append(new Path(entry.getKey())));
  }
  return result;
}",0.710926694329184
91597,"@Test @Ignore public void testPushToPushDestination() throws Exception {
  pushTo(""String_Node_Str"",true);
  pushTo(""String_Node_Str"",false);
}","@Test public void testPushToPushDestination() throws Exception {
  pushTo(""String_Node_Str"",true);
  pushTo(""String_Node_Str"",false);
}",0.9712230215827338
91598,"private void revalidateImpl(final RepositorySelection newRepoSelection){
  final ListRemoteOperation listRemotesOp;
  try {
    final URIish uri;
    uri=newRepoSelection.getURI();
    listRemotesOp=new ListRemoteOperation(local,uri);
    getContainer().run(true,true,new IRunnableWithProgress(){
      public void run(      IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
        listRemotesOp.run(monitor);
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    final Throwable cause=e.getCause();
    transportError(cause.getMessage());
    ErrorDialog.openError(getShell(),UIText.RefSpecPage_errorTransportDialogTitle,UIText.RefSpecPage_errorTransportDialogMessage,new Status(IStatus.ERROR,Activator.getPluginId(),0,cause.getMessage(),cause));
    return;
  }
catch (  InterruptedException e) {
    transportError(UIText.RefSpecPage_operationCancelled);
    return;
  }
  this.validatedRepoSelection=newRepoSelection;
  final String actRemoteName;
  if (configName == null)   actRemoteName=validatedRepoSelection.getConfigName();
 else   actRemoteName=configName;
  specsPanel.setAssistanceData(local,listRemotesOp.getRemoteRefs(),actRemoteName);
  if (newRepoSelection.isConfigSelected()) {
    saveButton.setVisible(true);
    saveButton.setText(NLS.bind(UIText.RefSpecPage_saveSpecifications,actRemoteName));
    saveButton.getParent().layout();
    if (!pushPage) {
      tagsAutoFollowButton.setSelection(false);
      tagsFetchTagsButton.setSelection(false);
      tagsNoTagsButton.setSelection(false);
      final TagOpt tagOpt=newRepoSelection.getConfig().getTagOpt();
switch (tagOpt) {
case AUTO_FOLLOW:
        tagsAutoFollowButton.setSelection(true);
      break;
case FETCH_TAGS:
    tagsFetchTagsButton.setSelection(true);
  break;
case NO_TAGS:
tagsNoTagsButton.setSelection(true);
break;
}
}
}
 else if (!pushPage) tagsAutoFollowButton.setSelection(true);
checkPage();
}","private void revalidateImpl(final RepositorySelection newRepoSelection){
  final ListRemoteOperation listRemotesOp;
  try {
    final URIish uri;
    uri=newRepoSelection.getURI(pushPage);
    listRemotesOp=new ListRemoteOperation(local,uri);
    getContainer().run(true,true,new IRunnableWithProgress(){
      public void run(      IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
        listRemotesOp.run(monitor);
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    final Throwable cause=e.getCause();
    transportError(cause.getMessage());
    ErrorDialog.openError(getShell(),UIText.RefSpecPage_errorTransportDialogTitle,UIText.RefSpecPage_errorTransportDialogMessage,new Status(IStatus.ERROR,Activator.getPluginId(),0,cause.getMessage(),cause));
    return;
  }
catch (  InterruptedException e) {
    transportError(UIText.RefSpecPage_operationCancelled);
    return;
  }
  this.validatedRepoSelection=newRepoSelection;
  final String actRemoteName;
  if (configName == null)   actRemoteName=validatedRepoSelection.getConfigName();
 else   actRemoteName=configName;
  specsPanel.setAssistanceData(local,listRemotesOp.getRemoteRefs(),actRemoteName);
  if (newRepoSelection.isConfigSelected()) {
    saveButton.setVisible(true);
    saveButton.setText(NLS.bind(UIText.RefSpecPage_saveSpecifications,actRemoteName));
    saveButton.getParent().layout();
    if (!pushPage) {
      tagsAutoFollowButton.setSelection(false);
      tagsFetchTagsButton.setSelection(false);
      tagsNoTagsButton.setSelection(false);
      final TagOpt tagOpt=newRepoSelection.getConfig().getTagOpt();
switch (tagOpt) {
case AUTO_FOLLOW:
        tagsAutoFollowButton.setSelection(true);
      break;
case FETCH_TAGS:
    tagsFetchTagsButton.setSelection(true);
  break;
case NO_TAGS:
tagsNoTagsButton.setSelection(true);
break;
}
}
}
 else if (!pushPage) tagsAutoFollowButton.setSelection(true);
checkPage();
}",0.997937080969572
91599,"/** 
 * @return list of all selected URIs - either the one specified as customURI or all URIs from selected configuration. May be null in case of no valid selection.
 */
public List<URIish> getPushURIs(){
  if (isURISelected())   return Collections.singletonList(uri);
  if (isConfigSelected())   return config.getPushURIs();
  return null;
}","/** 
 * @return list of all push URIs - either the one specified as custom URI orall push URIs of the selected configuration; if not push URIs were specified, the first URI is returned
 */
public List<URIish> getPushURIs(){
  if (isURISelected())   return Collections.singletonList(uri);
  if (isConfigSelected()) {
    List<URIish> pushUris=new ArrayList<URIish>();
    pushUris.addAll(config.getPushURIs());
    if (pushUris.isEmpty())     pushUris.add(config.getURIs().get(0));
    return pushUris;
  }
  return null;
}",0.5115740740740741
91600,"/** 
 * @return the selected URI (if specified by user as valid custom URI) orfirst URI from selected configuration (if specified by user as May be null if there is no valid selection.
 */
public URIish getURI(){
  if (isConfigSelected())   return config.getURIs().get(0);
  return uri;
}","/** 
 * @return the selected URI, <code>null</code> if a configuration wasselected
 */
public URIish getURI(){
  if (isConfigSelected())   return null;
  return uri;
}",0.6241758241758242
91601,"private String getSourceString(){
  final RepositorySelection repoSelection=repoPage.getSelection();
  if (repoSelection.isConfigSelected())   return repoSelection.getConfigName();
  return repoSelection.getURI().toString();
}","private String getSourceString(){
  final RepositorySelection repoSelection=repoPage.getSelection();
  if (repoSelection.isConfigSelected())   return repoSelection.getConfigName();
  return repoSelection.getURI(false).toString();
}",0.9890590809628008
91602,"@Override public boolean performFinish(){
  if (repoPage.getSelection().isConfigSelected() && refSpecPage.isSaveRequested())   saveConfig();
  final Transport transport;
  final RepositorySelection repoSelection=repoPage.getSelection();
  try {
    if (repoSelection.isConfigSelected())     transport=Transport.open(localDb,repoSelection.getConfig());
 else     transport=Transport.open(localDb,repoSelection.getURI());
  }
 catch (  final NotSupportedException e) {
    ErrorDialog.openError(getShell(),UIText.FetchWizard_transportNotSupportedTitle,UIText.FetchWizard_transportNotSupportedMessage,new Status(IStatus.ERROR,org.eclipse.egit.ui.Activator.getPluginId(),e.getMessage(),e));
    return false;
  }
  transport.setTagOpt(refSpecPage.getTagOpt());
  final Job fetchJob=new FetchJob(transport,refSpecPage.getRefSpecs(),getSourceString());
  fetchJob.setUser(true);
  fetchJob.schedule();
  repoPage.saveUriInPrefs();
  return true;
}","@Override public boolean performFinish(){
  if (repoPage.getSelection().isConfigSelected() && refSpecPage.isSaveRequested())   saveConfig();
  final Transport transport;
  final RepositorySelection repoSelection=repoPage.getSelection();
  try {
    if (repoSelection.isConfigSelected())     transport=Transport.open(localDb,repoSelection.getConfig());
 else     transport=Transport.open(localDb,repoSelection.getURI(false));
  }
 catch (  final NotSupportedException e) {
    ErrorDialog.openError(getShell(),UIText.FetchWizard_transportNotSupportedTitle,UIText.FetchWizard_transportNotSupportedMessage,new Status(IStatus.ERROR,org.eclipse.egit.ui.Activator.getPluginId(),e.getMessage(),e));
    return false;
  }
  transport.setTagOpt(refSpecPage.getTagOpt());
  final Job fetchJob=new FetchJob(transport,refSpecPage.getRefSpecs(),getSourceString());
  fetchJob.setUser(true);
  fetchJob.schedule();
  repoPage.saveUriInPrefs();
  return true;
}",0.9973502914679384
91603,"private void revalidateImpl(){
  if (getControl().isDisposed() || !isCurrentPage())   return;
  final List<RefSpec> fetchSpecs;
  if (displayedRepoSelection.isConfigSelected())   fetchSpecs=displayedRepoSelection.getConfig().getPushRefSpecs();
 else   fetchSpecs=null;
  final PushOperation operation;
  try {
    final Collection<RemoteRefUpdate> updates=Transport.findRemoteRefUpdatesFor(local,displayedRefSpecs,fetchSpecs);
    if (updates.isEmpty()) {
      setErrorMessage(UIText.ConfirmationPage_errorRefsChangedNoMatch);
      setPageComplete(false);
      return;
    }
    final PushOperationSpecification spec=new PushOperationSpecification();
    for (    final URIish uri : displayedRepoSelection.getAllURIs())     spec.addURIRefUpdates(uri,copyUpdates(updates));
    operation=new PushOperation(local,spec,true,displayedRepoSelection.getConfig());
    getContainer().run(true,true,new IRunnableWithProgress(){
      public void run(      IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
        operation.run(monitor);
      }
    }
);
  }
 catch (  final IOException e) {
    setErrorMessage(NLS.bind(UIText.ConfirmationPage_errorCantResolveSpecs,e.getMessage()));
    return;
  }
catch (  final InvocationTargetException e) {
    setErrorMessage(NLS.bind(UIText.ConfirmationPage_errorUnexpected,e.getCause().getMessage()));
    return;
  }
catch (  final InterruptedException e) {
    setErrorMessage(UIText.ConfirmationPage_errorInterrupted);
    setPageComplete(true);
    displayedRefSpecs=null;
    displayedRepoSelection=null;
    return;
  }
  final PushOperationResult result=operation.getOperationResult();
  resultPanel.setData(local,result);
  if (result.isSuccessfulConnectionForAnyURI()) {
    setPageComplete(true);
    confirmedResult=result;
  }
 else {
    final String message=NLS.bind(UIText.ConfirmationPage_cantConnectToAny,result.getErrorStringForAllURis());
    setErrorMessage(message);
    ErrorDialog.openError(getShell(),UIText.ConfirmationPage_cantConnectToAnyTitle,null,new Status(IStatus.ERROR,Activator.getPluginId(),message));
  }
}","private void revalidateImpl(){
  if (getControl().isDisposed() || !isCurrentPage())   return;
  final List<RefSpec> fetchSpecs;
  if (displayedRepoSelection.isConfigSelected())   fetchSpecs=displayedRepoSelection.getConfig().getPushRefSpecs();
 else   fetchSpecs=null;
  final PushOperation operation;
  try {
    final Collection<RemoteRefUpdate> updates=Transport.findRemoteRefUpdatesFor(local,displayedRefSpecs,fetchSpecs);
    if (updates.isEmpty()) {
      setErrorMessage(UIText.ConfirmationPage_errorRefsChangedNoMatch);
      setPageComplete(false);
      return;
    }
    final PushOperationSpecification spec=new PushOperationSpecification();
    for (    final URIish uri : displayedRepoSelection.getPushURIs())     spec.addURIRefUpdates(uri,copyUpdates(updates));
    operation=new PushOperation(local,spec,true,displayedRepoSelection.getConfig());
    getContainer().run(true,true,new IRunnableWithProgress(){
      public void run(      IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
        operation.run(monitor);
      }
    }
);
  }
 catch (  final IOException e) {
    setErrorMessage(NLS.bind(UIText.ConfirmationPage_errorCantResolveSpecs,e.getMessage()));
    return;
  }
catch (  final InvocationTargetException e) {
    setErrorMessage(NLS.bind(UIText.ConfirmationPage_errorUnexpected,e.getCause().getMessage()));
    return;
  }
catch (  final InterruptedException e) {
    setErrorMessage(UIText.ConfirmationPage_errorInterrupted);
    setPageComplete(true);
    displayedRefSpecs=null;
    displayedRepoSelection=null;
    return;
  }
  final PushOperationResult result=operation.getOperationResult();
  resultPanel.setData(local,result);
  if (result.isSuccessfulConnectionForAnyURI()) {
    setPageComplete(true);
    confirmedResult=result;
  }
 else {
    final String message=NLS.bind(UIText.ConfirmationPage_cantConnectToAny,result.getErrorStringForAllURis());
    setErrorMessage(message);
    ErrorDialog.openError(getShell(),UIText.ConfirmationPage_cantConnectToAnyTitle,null,new Status(IStatus.ERROR,Activator.getPluginId(),message));
  }
}",0.9983431952662722
91604,"private String getDestinationString(){
  final RepositorySelection repoSelection=repoPage.getSelection();
  final String destination;
  if (repoSelection.isConfigSelected())   destination=repoSelection.getConfigName();
 else   destination=repoSelection.getURI().toString();
  return destination;
}","private String getDestinationString(){
  final RepositorySelection repoSelection=repoPage.getSelection();
  final String destination;
  if (repoSelection.isConfigSelected())   destination=repoSelection.getConfigName();
 else   destination=repoSelection.getURI(true).toString();
  return destination;
}",0.9297658862876256
91605,"private PushOperation createPushOperation(){
  try {
    final PushOperationSpecification spec;
    final RemoteConfig config=repoPage.getSelection().getConfig();
    if (confirmPage.isConfirmed()) {
      final PushOperationResult confirmedResult=confirmPage.getConfirmedResult();
      spec=confirmedResult.deriveSpecification(confirmPage.isRequireUnchangedSelected());
    }
 else {
      final Collection<RefSpec> fetchSpecs;
      if (config != null)       fetchSpecs=config.getPushRefSpecs();
 else       fetchSpecs=null;
      final Collection<RemoteRefUpdate> updates=Transport.findRemoteRefUpdatesFor(localDb,refSpecPage.getRefSpecs(),fetchSpecs);
      if (updates.isEmpty()) {
        ErrorDialog.openError(getShell(),UIText.PushWizard_missingRefsTitle,null,new Status(IStatus.ERROR,Activator.getPluginId(),UIText.PushWizard_missingRefsMessage));
        return null;
      }
      spec=new PushOperationSpecification();
      for (      final URIish uri : repoPage.getSelection().getAllURIs())       spec.addURIRefUpdates(uri,ConfirmationPage.copyUpdates(updates));
    }
    return new PushOperation(localDb,spec,false,config);
  }
 catch (  final IOException e) {
    ErrorDialog.openError(getShell(),UIText.PushWizard_cantPrepareUpdatesTitle,UIText.PushWizard_cantPrepareUpdatesMessage,new Status(IStatus.ERROR,Activator.getPluginId(),e.getMessage(),e));
    return null;
  }
}","private PushOperation createPushOperation(){
  try {
    final PushOperationSpecification spec;
    final RemoteConfig config=repoPage.getSelection().getConfig();
    if (confirmPage.isConfirmed()) {
      final PushOperationResult confirmedResult=confirmPage.getConfirmedResult();
      spec=confirmedResult.deriveSpecification(confirmPage.isRequireUnchangedSelected());
    }
 else {
      final Collection<RefSpec> fetchSpecs;
      if (config != null)       fetchSpecs=config.getPushRefSpecs();
 else       fetchSpecs=null;
      final Collection<RemoteRefUpdate> updates=Transport.findRemoteRefUpdatesFor(localDb,refSpecPage.getRefSpecs(),fetchSpecs);
      if (updates.isEmpty()) {
        ErrorDialog.openError(getShell(),UIText.PushWizard_missingRefsTitle,null,new Status(IStatus.ERROR,Activator.getPluginId(),UIText.PushWizard_missingRefsMessage));
        return null;
      }
      spec=new PushOperationSpecification();
      for (      final URIish uri : repoPage.getSelection().getPushURIs())       spec.addURIRefUpdates(uri,ConfirmationPage.copyUpdates(updates));
    }
    return new PushOperation(localDb,spec,false,config);
  }
 catch (  final IOException e) {
    ErrorDialog.openError(getShell(),UIText.PushWizard_cantPrepareUpdatesTitle,UIText.PushWizard_cantPrepareUpdatesMessage,new Status(IStatus.ERROR,Activator.getPluginId(),e.getMessage(),e));
    return null;
  }
}",0.9974865350089768
91606,"@Test @Ignore public void testPushToPushDestination() throws Exception {
  pushTo(""String_Node_Str"",true);
  pushTo(""String_Node_Str"",false);
}","@Test public void testPushToPushDestination() throws Exception {
  pushTo(""String_Node_Str"",true);
  pushTo(""String_Node_Str"",false);
}",0.9712230215827338
91607,"private void revalidateImpl(final RepositorySelection newRepoSelection){
  final ListRemoteOperation listRemotesOp;
  try {
    final URIish uri;
    uri=newRepoSelection.getURI();
    listRemotesOp=new ListRemoteOperation(local,uri);
    getContainer().run(true,true,new IRunnableWithProgress(){
      public void run(      IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
        listRemotesOp.run(monitor);
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    final Throwable cause=e.getCause();
    transportError(cause.getMessage());
    ErrorDialog.openError(getShell(),UIText.RefSpecPage_errorTransportDialogTitle,UIText.RefSpecPage_errorTransportDialogMessage,new Status(IStatus.ERROR,Activator.getPluginId(),0,cause.getMessage(),cause));
    return;
  }
catch (  InterruptedException e) {
    transportError(UIText.RefSpecPage_operationCancelled);
    return;
  }
  this.validatedRepoSelection=newRepoSelection;
  final String actRemoteName;
  if (configName == null)   actRemoteName=validatedRepoSelection.getConfigName();
 else   actRemoteName=configName;
  specsPanel.setAssistanceData(local,listRemotesOp.getRemoteRefs(),actRemoteName);
  if (newRepoSelection.isConfigSelected()) {
    saveButton.setVisible(true);
    saveButton.setText(NLS.bind(UIText.RefSpecPage_saveSpecifications,actRemoteName));
    saveButton.getParent().layout();
    if (!pushPage) {
      tagsAutoFollowButton.setSelection(false);
      tagsFetchTagsButton.setSelection(false);
      tagsNoTagsButton.setSelection(false);
      final TagOpt tagOpt=newRepoSelection.getConfig().getTagOpt();
switch (tagOpt) {
case AUTO_FOLLOW:
        tagsAutoFollowButton.setSelection(true);
      break;
case FETCH_TAGS:
    tagsFetchTagsButton.setSelection(true);
  break;
case NO_TAGS:
tagsNoTagsButton.setSelection(true);
break;
}
}
}
 else if (!pushPage) tagsAutoFollowButton.setSelection(true);
checkPage();
}","private void revalidateImpl(final RepositorySelection newRepoSelection){
  final ListRemoteOperation listRemotesOp;
  try {
    final URIish uri;
    uri=newRepoSelection.getURI(pushPage);
    listRemotesOp=new ListRemoteOperation(local,uri);
    getContainer().run(true,true,new IRunnableWithProgress(){
      public void run(      IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
        listRemotesOp.run(monitor);
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    final Throwable cause=e.getCause();
    transportError(cause.getMessage());
    ErrorDialog.openError(getShell(),UIText.RefSpecPage_errorTransportDialogTitle,UIText.RefSpecPage_errorTransportDialogMessage,new Status(IStatus.ERROR,Activator.getPluginId(),0,cause.getMessage(),cause));
    return;
  }
catch (  InterruptedException e) {
    transportError(UIText.RefSpecPage_operationCancelled);
    return;
  }
  this.validatedRepoSelection=newRepoSelection;
  final String actRemoteName;
  if (configName == null)   actRemoteName=validatedRepoSelection.getConfigName();
 else   actRemoteName=configName;
  specsPanel.setAssistanceData(local,listRemotesOp.getRemoteRefs(),actRemoteName);
  if (newRepoSelection.isConfigSelected()) {
    saveButton.setVisible(true);
    saveButton.setText(NLS.bind(UIText.RefSpecPage_saveSpecifications,actRemoteName));
    saveButton.getParent().layout();
    if (!pushPage) {
      tagsAutoFollowButton.setSelection(false);
      tagsFetchTagsButton.setSelection(false);
      tagsNoTagsButton.setSelection(false);
      final TagOpt tagOpt=newRepoSelection.getConfig().getTagOpt();
switch (tagOpt) {
case AUTO_FOLLOW:
        tagsAutoFollowButton.setSelection(true);
      break;
case FETCH_TAGS:
    tagsFetchTagsButton.setSelection(true);
  break;
case NO_TAGS:
tagsNoTagsButton.setSelection(true);
break;
}
}
}
 else if (!pushPage) tagsAutoFollowButton.setSelection(true);
checkPage();
}",0.997937080969572
91608,"/** 
 * @return list of all selected URIs - either the one specified as customURI or all URIs from selected configuration. May be null in case of no valid selection.
 */
public List<URIish> getPushURIs(){
  if (isURISelected())   return Collections.singletonList(uri);
  if (isConfigSelected())   return config.getPushURIs();
  return null;
}","/** 
 * @return list of all push URIs - either the one specified as custom URI orall push URIs of the selected configuration; if not push URIs were specified, the first URI is returned
 */
public List<URIish> getPushURIs(){
  if (isURISelected())   return Collections.singletonList(uri);
  if (isConfigSelected()) {
    List<URIish> pushUris=new ArrayList<URIish>();
    pushUris.addAll(config.getPushURIs());
    if (pushUris.isEmpty())     pushUris.add(config.getURIs().get(0));
    return pushUris;
  }
  return null;
}",0.5115740740740741
91609,"/** 
 * @return the selected URI (if specified by user as valid custom URI) orfirst URI from selected configuration (if specified by user as May be null if there is no valid selection.
 */
public URIish getURI(){
  if (isConfigSelected())   return config.getURIs().get(0);
  return uri;
}","/** 
 * @return the selected URI, <code>null</code> if a configuration wasselected
 */
public URIish getURI(){
  if (isConfigSelected())   return null;
  return uri;
}",0.6241758241758242
91610,"private String getSourceString(){
  final RepositorySelection repoSelection=repoPage.getSelection();
  if (repoSelection.isConfigSelected())   return repoSelection.getConfigName();
  return repoSelection.getURI().toString();
}","private String getSourceString(){
  final RepositorySelection repoSelection=repoPage.getSelection();
  if (repoSelection.isConfigSelected())   return repoSelection.getConfigName();
  return repoSelection.getURI(false).toString();
}",0.9890590809628008
91611,"@Override public boolean performFinish(){
  if (repoPage.getSelection().isConfigSelected() && refSpecPage.isSaveRequested())   saveConfig();
  final Transport transport;
  final RepositorySelection repoSelection=repoPage.getSelection();
  try {
    if (repoSelection.isConfigSelected())     transport=Transport.open(localDb,repoSelection.getConfig());
 else     transport=Transport.open(localDb,repoSelection.getURI());
  }
 catch (  final NotSupportedException e) {
    ErrorDialog.openError(getShell(),UIText.FetchWizard_transportNotSupportedTitle,UIText.FetchWizard_transportNotSupportedMessage,new Status(IStatus.ERROR,org.eclipse.egit.ui.Activator.getPluginId(),e.getMessage(),e));
    return false;
  }
  transport.setTagOpt(refSpecPage.getTagOpt());
  final Job fetchJob=new FetchJob(transport,refSpecPage.getRefSpecs(),getSourceString());
  fetchJob.setUser(true);
  fetchJob.schedule();
  repoPage.saveUriInPrefs();
  return true;
}","@Override public boolean performFinish(){
  if (repoPage.getSelection().isConfigSelected() && refSpecPage.isSaveRequested())   saveConfig();
  final Transport transport;
  final RepositorySelection repoSelection=repoPage.getSelection();
  try {
    if (repoSelection.isConfigSelected())     transport=Transport.open(localDb,repoSelection.getConfig());
 else     transport=Transport.open(localDb,repoSelection.getURI(false));
  }
 catch (  final NotSupportedException e) {
    ErrorDialog.openError(getShell(),UIText.FetchWizard_transportNotSupportedTitle,UIText.FetchWizard_transportNotSupportedMessage,new Status(IStatus.ERROR,org.eclipse.egit.ui.Activator.getPluginId(),e.getMessage(),e));
    return false;
  }
  transport.setTagOpt(refSpecPage.getTagOpt());
  final Job fetchJob=new FetchJob(transport,refSpecPage.getRefSpecs(),getSourceString());
  fetchJob.setUser(true);
  fetchJob.schedule();
  repoPage.saveUriInPrefs();
  return true;
}",0.9973502914679384
91612,"private void revalidateImpl(){
  if (getControl().isDisposed() || !isCurrentPage())   return;
  final List<RefSpec> fetchSpecs;
  if (displayedRepoSelection.isConfigSelected())   fetchSpecs=displayedRepoSelection.getConfig().getPushRefSpecs();
 else   fetchSpecs=null;
  final PushOperation operation;
  try {
    final Collection<RemoteRefUpdate> updates=Transport.findRemoteRefUpdatesFor(local,displayedRefSpecs,fetchSpecs);
    if (updates.isEmpty()) {
      setErrorMessage(UIText.ConfirmationPage_errorRefsChangedNoMatch);
      setPageComplete(false);
      return;
    }
    final PushOperationSpecification spec=new PushOperationSpecification();
    for (    final URIish uri : displayedRepoSelection.getAllURIs())     spec.addURIRefUpdates(uri,copyUpdates(updates));
    operation=new PushOperation(local,spec,true,displayedRepoSelection.getConfig());
    getContainer().run(true,true,new IRunnableWithProgress(){
      public void run(      IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
        operation.run(monitor);
      }
    }
);
  }
 catch (  final IOException e) {
    setErrorMessage(NLS.bind(UIText.ConfirmationPage_errorCantResolveSpecs,e.getMessage()));
    return;
  }
catch (  final InvocationTargetException e) {
    setErrorMessage(NLS.bind(UIText.ConfirmationPage_errorUnexpected,e.getCause().getMessage()));
    return;
  }
catch (  final InterruptedException e) {
    setErrorMessage(UIText.ConfirmationPage_errorInterrupted);
    setPageComplete(true);
    displayedRefSpecs=null;
    displayedRepoSelection=null;
    return;
  }
  final PushOperationResult result=operation.getOperationResult();
  resultPanel.setData(local,result);
  if (result.isSuccessfulConnectionForAnyURI()) {
    setPageComplete(true);
    confirmedResult=result;
  }
 else {
    final String message=NLS.bind(UIText.ConfirmationPage_cantConnectToAny,result.getErrorStringForAllURis());
    setErrorMessage(message);
    ErrorDialog.openError(getShell(),UIText.ConfirmationPage_cantConnectToAnyTitle,null,new Status(IStatus.ERROR,Activator.getPluginId(),message));
  }
}","private void revalidateImpl(){
  if (getControl().isDisposed() || !isCurrentPage())   return;
  final List<RefSpec> fetchSpecs;
  if (displayedRepoSelection.isConfigSelected())   fetchSpecs=displayedRepoSelection.getConfig().getPushRefSpecs();
 else   fetchSpecs=null;
  final PushOperation operation;
  try {
    final Collection<RemoteRefUpdate> updates=Transport.findRemoteRefUpdatesFor(local,displayedRefSpecs,fetchSpecs);
    if (updates.isEmpty()) {
      setErrorMessage(UIText.ConfirmationPage_errorRefsChangedNoMatch);
      setPageComplete(false);
      return;
    }
    final PushOperationSpecification spec=new PushOperationSpecification();
    for (    final URIish uri : displayedRepoSelection.getPushURIs())     spec.addURIRefUpdates(uri,copyUpdates(updates));
    operation=new PushOperation(local,spec,true,displayedRepoSelection.getConfig());
    getContainer().run(true,true,new IRunnableWithProgress(){
      public void run(      IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
        operation.run(monitor);
      }
    }
);
  }
 catch (  final IOException e) {
    setErrorMessage(NLS.bind(UIText.ConfirmationPage_errorCantResolveSpecs,e.getMessage()));
    return;
  }
catch (  final InvocationTargetException e) {
    setErrorMessage(NLS.bind(UIText.ConfirmationPage_errorUnexpected,e.getCause().getMessage()));
    return;
  }
catch (  final InterruptedException e) {
    setErrorMessage(UIText.ConfirmationPage_errorInterrupted);
    setPageComplete(true);
    displayedRefSpecs=null;
    displayedRepoSelection=null;
    return;
  }
  final PushOperationResult result=operation.getOperationResult();
  resultPanel.setData(local,result);
  if (result.isSuccessfulConnectionForAnyURI()) {
    setPageComplete(true);
    confirmedResult=result;
  }
 else {
    final String message=NLS.bind(UIText.ConfirmationPage_cantConnectToAny,result.getErrorStringForAllURis());
    setErrorMessage(message);
    ErrorDialog.openError(getShell(),UIText.ConfirmationPage_cantConnectToAnyTitle,null,new Status(IStatus.ERROR,Activator.getPluginId(),message));
  }
}",0.9983431952662722
91613,"private String getDestinationString(){
  final RepositorySelection repoSelection=repoPage.getSelection();
  final String destination;
  if (repoSelection.isConfigSelected())   destination=repoSelection.getConfigName();
 else   destination=repoSelection.getURI().toString();
  return destination;
}","private String getDestinationString(){
  final RepositorySelection repoSelection=repoPage.getSelection();
  final String destination;
  if (repoSelection.isConfigSelected())   destination=repoSelection.getConfigName();
 else   destination=repoSelection.getURI(true).toString();
  return destination;
}",0.9297658862876256
91614,"private PushOperation createPushOperation(){
  try {
    final PushOperationSpecification spec;
    final RemoteConfig config=repoPage.getSelection().getConfig();
    if (confirmPage.isConfirmed()) {
      final PushOperationResult confirmedResult=confirmPage.getConfirmedResult();
      spec=confirmedResult.deriveSpecification(confirmPage.isRequireUnchangedSelected());
    }
 else {
      final Collection<RefSpec> fetchSpecs;
      if (config != null)       fetchSpecs=config.getPushRefSpecs();
 else       fetchSpecs=null;
      final Collection<RemoteRefUpdate> updates=Transport.findRemoteRefUpdatesFor(localDb,refSpecPage.getRefSpecs(),fetchSpecs);
      if (updates.isEmpty()) {
        ErrorDialog.openError(getShell(),UIText.PushWizard_missingRefsTitle,null,new Status(IStatus.ERROR,Activator.getPluginId(),UIText.PushWizard_missingRefsMessage));
        return null;
      }
      spec=new PushOperationSpecification();
      for (      final URIish uri : repoPage.getSelection().getAllURIs())       spec.addURIRefUpdates(uri,ConfirmationPage.copyUpdates(updates));
    }
    return new PushOperation(localDb,spec,false,config);
  }
 catch (  final IOException e) {
    ErrorDialog.openError(getShell(),UIText.PushWizard_cantPrepareUpdatesTitle,UIText.PushWizard_cantPrepareUpdatesMessage,new Status(IStatus.ERROR,Activator.getPluginId(),e.getMessage(),e));
    return null;
  }
}","private PushOperation createPushOperation(){
  try {
    final PushOperationSpecification spec;
    final RemoteConfig config=repoPage.getSelection().getConfig();
    if (confirmPage.isConfirmed()) {
      final PushOperationResult confirmedResult=confirmPage.getConfirmedResult();
      spec=confirmedResult.deriveSpecification(confirmPage.isRequireUnchangedSelected());
    }
 else {
      final Collection<RefSpec> fetchSpecs;
      if (config != null)       fetchSpecs=config.getPushRefSpecs();
 else       fetchSpecs=null;
      final Collection<RemoteRefUpdate> updates=Transport.findRemoteRefUpdatesFor(localDb,refSpecPage.getRefSpecs(),fetchSpecs);
      if (updates.isEmpty()) {
        ErrorDialog.openError(getShell(),UIText.PushWizard_missingRefsTitle,null,new Status(IStatus.ERROR,Activator.getPluginId(),UIText.PushWizard_missingRefsMessage));
        return null;
      }
      spec=new PushOperationSpecification();
      for (      final URIish uri : repoPage.getSelection().getPushURIs())       spec.addURIRefUpdates(uri,ConfirmationPage.copyUpdates(updates));
    }
    return new PushOperation(localDb,spec,false,config);
  }
 catch (  final IOException e) {
    ErrorDialog.openError(getShell(),UIText.PushWizard_cantPrepareUpdatesTitle,UIText.PushWizard_cantPrepareUpdatesMessage,new Status(IStatus.ERROR,Activator.getPluginId(),e.getMessage(),e));
    return null;
  }
}",0.9974865350089768
91615,"public void run(){
  try {
    MessageDialog.openInformation(getActiveShell(event),UIText.MergeAction_MergeResultTitle,op.getResult().toString());
  }
 catch (  ExecutionException e) {
    Activator.handleError(op.getResult().toString(),null,true);
  }
}","public void run(){
  Shell shell=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();
  MessageDialog.openInformation(shell,UIText.MergeAction_MergeResultTitle,op.getResult().toString());
}",0.5274725274725275
91616,"public Object execute(final ExecutionEvent event) throws ExecutionException {
  RepositoryTreeNode node=getSelectedNodes(event).get(0);
  final Repository repository=node.getRepository();
  if (!canMerge(repository))   return null;
  String targetRef;
  if (node instanceof RefNode) {
    String refName=((RefNode)node).getObject().getName();
    try {
      if (repository.getFullBranch().equals(refName))       targetRef=null;
 else       targetRef=refName;
    }
 catch (    IOException e) {
      targetRef=null;
    }
  }
 else   if (node instanceof TagNode)   targetRef=((TagNode)node).getObject().getName();
 else   targetRef=null;
  final String refName;
  if (targetRef != null)   refName=targetRef;
 else {
    MergeTargetSelectionDialog mergeTargetSelectionDialog=new MergeTargetSelectionDialog(getShell(event),repository);
    if (mergeTargetSelectionDialog.open() == IDialogConstants.OK_ID) {
      refName=mergeTargetSelectionDialog.getRefName();
    }
 else {
      return null;
    }
  }
  String jobname=NLS.bind(UIText.MergeAction_JobNameMerge,refName);
  final MergeOperation op=new MergeOperation(repository,refName);
  Job job=new Job(jobname){
    @Override protected IStatus run(    IProgressMonitor monitor){
      try {
        op.execute(monitor);
      }
 catch (      final CoreException e) {
        return e.getStatus();
      }
      return Status.OK_STATUS;
    }
  }
;
  job.setUser(true);
  job.addJobChangeListener(new JobChangeAdapter(){
    @Override public void done(    IJobChangeEvent jobEvent){
      IStatus result=jobEvent.getJob().getResult();
      if (result.getSeverity() == IStatus.CANCEL) {
        Display.getDefault().asyncExec(new Runnable(){
          public void run(){
            try {
              MessageDialog.openInformation(getActiveShell(event),UIText.MergeAction_MergeCanceledTitle,UIText.MergeAction_MergeCanceledMessage);
            }
 catch (            ExecutionException e) {
              Activator.handleError(UIText.MergeAction_MergeCanceledMessage,null,true);
            }
          }
        }
);
      }
 else       if (!result.isOK()) {
        Activator.handleError(result.getMessage(),result.getException(),true);
      }
 else {
        Display.getDefault().asyncExec(new Runnable(){
          public void run(){
            try {
              MessageDialog.openInformation(getActiveShell(event),UIText.MergeAction_MergeResultTitle,op.getResult().toString());
            }
 catch (            ExecutionException e) {
              Activator.handleError(op.getResult().toString(),null,true);
            }
          }
        }
);
      }
    }
  }
);
  job.schedule();
  return null;
}","public Object execute(final ExecutionEvent event) throws ExecutionException {
  RepositoryTreeNode node=getSelectedNodes(event).get(0);
  final Repository repository=node.getRepository();
  if (!canMerge(repository))   return null;
  String targetRef;
  if (node instanceof RefNode) {
    String refName=((RefNode)node).getObject().getName();
    try {
      if (repository.getFullBranch().equals(refName))       targetRef=null;
 else       targetRef=refName;
    }
 catch (    IOException e) {
      targetRef=null;
    }
  }
 else   if (node instanceof TagNode)   targetRef=((TagNode)node).getObject().getName();
 else   targetRef=null;
  final String refName;
  if (targetRef != null)   refName=targetRef;
 else {
    MergeTargetSelectionDialog mergeTargetSelectionDialog=new MergeTargetSelectionDialog(getShell(event),repository);
    if (mergeTargetSelectionDialog.open() == IDialogConstants.OK_ID) {
      refName=mergeTargetSelectionDialog.getRefName();
    }
 else {
      return null;
    }
  }
  String jobname=NLS.bind(UIText.MergeAction_JobNameMerge,refName);
  final MergeOperation op=new MergeOperation(repository,refName);
  Job job=new Job(jobname){
    @Override protected IStatus run(    IProgressMonitor monitor){
      try {
        op.execute(monitor);
      }
 catch (      final CoreException e) {
        return e.getStatus();
      }
      return Status.OK_STATUS;
    }
  }
;
  job.setUser(true);
  job.setRule(op.getSchedulingRule());
  job.addJobChangeListener(new JobChangeAdapter(){
    @Override public void done(    IJobChangeEvent jobEvent){
      IStatus result=jobEvent.getJob().getResult();
      if (result.getSeverity() == IStatus.CANCEL) {
        Display.getDefault().asyncExec(new Runnable(){
          public void run(){
            Shell shell=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();
            MessageDialog.openInformation(shell,UIText.MergeAction_MergeCanceledTitle,UIText.MergeAction_MergeCanceledMessage);
          }
        }
);
      }
 else       if (!result.isOK()) {
        Activator.handleError(result.getMessage(),result.getException(),true);
      }
 else {
        Display.getDefault().asyncExec(new Runnable(){
          public void run(){
            Shell shell=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();
            MessageDialog.openInformation(shell,UIText.MergeAction_MergeResultTitle,op.getResult().toString());
          }
        }
);
      }
    }
  }
);
  job.schedule();
  return null;
}",0.7543961352657005
91617,"@Override public void done(IJobChangeEvent jobEvent){
  IStatus result=jobEvent.getJob().getResult();
  if (result.getSeverity() == IStatus.CANCEL) {
    Display.getDefault().asyncExec(new Runnable(){
      public void run(){
        try {
          MessageDialog.openInformation(getActiveShell(event),UIText.MergeAction_MergeCanceledTitle,UIText.MergeAction_MergeCanceledMessage);
        }
 catch (        ExecutionException e) {
          Activator.handleError(UIText.MergeAction_MergeCanceledMessage,null,true);
        }
      }
    }
);
  }
 else   if (!result.isOK()) {
    Activator.handleError(result.getMessage(),result.getException(),true);
  }
 else {
    Display.getDefault().asyncExec(new Runnable(){
      public void run(){
        try {
          MessageDialog.openInformation(getActiveShell(event),UIText.MergeAction_MergeResultTitle,op.getResult().toString());
        }
 catch (        ExecutionException e) {
          Activator.handleError(op.getResult().toString(),null,true);
        }
      }
    }
);
  }
}","@Override public void done(IJobChangeEvent jobEvent){
  IStatus result=jobEvent.getJob().getResult();
  if (result.getSeverity() == IStatus.CANCEL) {
    Display.getDefault().asyncExec(new Runnable(){
      public void run(){
        Shell shell=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();
        MessageDialog.openInformation(shell,UIText.MergeAction_MergeCanceledTitle,UIText.MergeAction_MergeCanceledMessage);
      }
    }
);
  }
 else   if (!result.isOK()) {
    Activator.handleError(result.getMessage(),result.getException(),true);
  }
 else {
    Display.getDefault().asyncExec(new Runnable(){
      public void run(){
        Shell shell=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();
        MessageDialog.openInformation(shell,UIText.MergeAction_MergeResultTitle,op.getResult().toString());
      }
    }
);
  }
}",0.5116033755274262
91618,"public void run(){
  try {
    MessageDialog.openInformation(getShell(event),UIText.MergeAction_MergeResultTitle,op.getResult().toString());
  }
 catch (  ExecutionException e) {
    Activator.handleError(op.getResult().toString(),null,true);
  }
}","public void run(){
  Shell shell=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();
  MessageDialog.openInformation(shell,UIText.MergeAction_MergeResultTitle,op.getResult().toString());
}",0.534521158129176
91619,"public Object execute(final ExecutionEvent event) throws ExecutionException {
  final Repository repository=getRepository(true,event);
  if (repository == null)   return null;
  if (!canMerge(repository,event))   return null;
  MergeTargetSelectionDialog mergeTargetSelectionDialog=new MergeTargetSelectionDialog(getShell(event),repository);
  if (mergeTargetSelectionDialog.open() == IDialogConstants.OK_ID) {
    final String refName=mergeTargetSelectionDialog.getRefName();
    String jobname=NLS.bind(UIText.MergeAction_JobNameMerge,refName);
    final MergeOperation op=new MergeOperation(repository,refName);
    Job job=new Job(jobname){
      @Override protected IStatus run(      IProgressMonitor monitor){
        try {
          op.execute(monitor);
        }
 catch (        final CoreException e) {
          return e.getStatus();
        }
        return Status.OK_STATUS;
      }
    }
;
    job.setUser(true);
    job.addJobChangeListener(new JobChangeAdapter(){
      @Override public void done(      IJobChangeEvent cevent){
        IStatus result=cevent.getJob().getResult();
        if (result.getSeverity() == IStatus.CANCEL) {
          Display.getDefault().asyncExec(new Runnable(){
            public void run(){
              try {
                MessageDialog.openInformation(getShell(event),UIText.MergeAction_MergeCanceledTitle,UIText.MergeAction_MergeCanceledMessage);
              }
 catch (              ExecutionException e) {
                Activator.handleError(UIText.MergeAction_MergeCanceledMessage,null,true);
              }
            }
          }
);
        }
 else         if (!result.isOK()) {
          Activator.handleError(result.getMessage(),result.getException(),true);
        }
 else {
          Display.getDefault().asyncExec(new Runnable(){
            public void run(){
              try {
                MessageDialog.openInformation(getShell(event),UIText.MergeAction_MergeResultTitle,op.getResult().toString());
              }
 catch (              ExecutionException e) {
                Activator.handleError(op.getResult().toString(),null,true);
              }
            }
          }
);
        }
      }
    }
);
    job.schedule();
  }
  return null;
}","public Object execute(final ExecutionEvent event) throws ExecutionException {
  final Repository repository=getRepository(true,event);
  if (repository == null)   return null;
  if (!canMerge(repository,event))   return null;
  MergeTargetSelectionDialog mergeTargetSelectionDialog=new MergeTargetSelectionDialog(getShell(event),repository);
  if (mergeTargetSelectionDialog.open() == IDialogConstants.OK_ID) {
    final String refName=mergeTargetSelectionDialog.getRefName();
    String jobname=NLS.bind(UIText.MergeAction_JobNameMerge,refName);
    final MergeOperation op=new MergeOperation(repository,refName);
    Job job=new Job(jobname){
      @Override protected IStatus run(      IProgressMonitor monitor){
        try {
          op.execute(monitor);
        }
 catch (        final CoreException e) {
          return e.getStatus();
        }
        return Status.OK_STATUS;
      }
    }
;
    job.setUser(true);
    job.setRule(op.getSchedulingRule());
    job.addJobChangeListener(new JobChangeAdapter(){
      @Override public void done(      IJobChangeEvent cevent){
        IStatus result=cevent.getJob().getResult();
        if (result.getSeverity() == IStatus.CANCEL) {
          Display.getDefault().asyncExec(new Runnable(){
            public void run(){
              Shell shell=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();
              MessageDialog.openInformation(shell,UIText.MergeAction_MergeCanceledTitle,UIText.MergeAction_MergeCanceledMessage);
            }
          }
);
        }
 else         if (!result.isOK()) {
          Activator.handleError(result.getMessage(),result.getException(),true);
        }
 else {
          Display.getDefault().asyncExec(new Runnable(){
            public void run(){
              Shell shell=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();
              MessageDialog.openInformation(shell,UIText.MergeAction_MergeResultTitle,op.getResult().toString());
            }
          }
);
        }
      }
    }
);
    job.schedule();
  }
  return null;
}",0.7053883834849545
91620,"@Override public void done(IJobChangeEvent cevent){
  IStatus result=cevent.getJob().getResult();
  if (result.getSeverity() == IStatus.CANCEL) {
    Display.getDefault().asyncExec(new Runnable(){
      public void run(){
        try {
          MessageDialog.openInformation(getShell(event),UIText.MergeAction_MergeCanceledTitle,UIText.MergeAction_MergeCanceledMessage);
        }
 catch (        ExecutionException e) {
          Activator.handleError(UIText.MergeAction_MergeCanceledMessage,null,true);
        }
      }
    }
);
  }
 else   if (!result.isOK()) {
    Activator.handleError(result.getMessage(),result.getException(),true);
  }
 else {
    Display.getDefault().asyncExec(new Runnable(){
      public void run(){
        try {
          MessageDialog.openInformation(getShell(event),UIText.MergeAction_MergeResultTitle,op.getResult().toString());
        }
 catch (        ExecutionException e) {
          Activator.handleError(op.getResult().toString(),null,true);
        }
      }
    }
);
  }
}","@Override public void done(IJobChangeEvent cevent){
  IStatus result=cevent.getJob().getResult();
  if (result.getSeverity() == IStatus.CANCEL) {
    Display.getDefault().asyncExec(new Runnable(){
      public void run(){
        Shell shell=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();
        MessageDialog.openInformation(shell,UIText.MergeAction_MergeCanceledTitle,UIText.MergeAction_MergeCanceledMessage);
      }
    }
);
  }
 else   if (!result.isOK()) {
    Activator.handleError(result.getMessage(),result.getException(),true);
  }
 else {
    Display.getDefault().asyncExec(new Runnable(){
      public void run(){
        Shell shell=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();
        MessageDialog.openInformation(shell,UIText.MergeAction_MergeResultTitle,op.getResult().toString());
      }
    }
);
  }
}",0.5127931769722814
91621,"/** 
 * Execute operation and store result. Operation is executed independently on each remote repository. <p>
 * @param actMonitor the monitor to be used for reporting progress and responding to cancellation. The monitor is never <code>null</code>
 * @throws InvocationTargetException Cause of this exceptions may include {@link TransportException},   {@link NotSupportedException} orsome unexpected  {@link RuntimeException}.
 */
public void run(IProgressMonitor actMonitor) throws InvocationTargetException {
  if (operationResult != null)   throw new IllegalStateException(CoreText.OperationAlreadyExecuted);
  for (  URIish uri : this.specification.getURIs()) {
    for (    RemoteRefUpdate update : this.specification.getRefUpdates(uri))     if (update.getStatus() != Status.NOT_ATTEMPTED)     throw new IllegalStateException(CoreText.RemoteRefUpdateCantBeReused);
  }
  IProgressMonitor monitor;
  if (actMonitor == null)   monitor=new NullProgressMonitor();
 else   monitor=actMonitor;
  final int totalWork=specification.getURIsNumber() * WORK_UNITS_PER_TRANSPORT;
  if (dryRun)   monitor.beginTask(CoreText.PushOperation_taskNameDryRun,totalWork);
 else   monitor.beginTask(CoreText.PushOperation_taskNameNormalRun,totalWork);
  operationResult=new PushOperationResult();
  for (  final URIish uri : specification.getURIs()) {
    final SubProgressMonitor subMonitor=new SubProgressMonitor(monitor,WORK_UNITS_PER_TRANSPORT,SubProgressMonitor.PREPEND_MAIN_LABEL_TO_SUBTASK);
    Transport transport=null;
    try {
      if (monitor.isCanceled()) {
        operationResult.addOperationResult(uri,CoreText.PushOperation_resultCancelled);
        continue;
      }
      transport=Transport.open(localDb,uri);
      if (rc != null)       transport.applyConfig(rc);
      transport.setDryRun(dryRun);
      final EclipseGitProgressTransformer gitSubMonitor=new EclipseGitProgressTransformer(subMonitor);
      final PushResult pr=transport.push(gitSubMonitor,specification.getRefUpdates(uri));
      operationResult.addOperationResult(uri,pr);
    }
 catch (    final NoRemoteRepositoryException e) {
      operationResult.addOperationResult(uri,NLS.bind(CoreText.PushOperation_resultNoServiceError,e.getMessage()));
    }
catch (    final TransportException e) {
      operationResult.addOperationResult(uri,NLS.bind(CoreText.PushOperation_resultTransportError,e.getMessage()));
    }
catch (    final NotSupportedException e) {
      operationResult.addOperationResult(uri,NLS.bind(CoreText.PushOperation_resultNotSupported,e.getMessage()));
    }
 finally {
      if (transport != null) {
        transport.close();
      }
      subMonitor.beginTask(""String_Node_Str"",WORK_UNITS_PER_TRANSPORT);
      subMonitor.done();
      subMonitor.done();
    }
  }
  monitor.done();
}","/** 
 * Execute operation and store result. Operation is executed independently on each remote repository. <p>
 * @param actMonitor the monitor to be used for reporting progress and responding to cancellation. The monitor is never <code>null</code>
 * @throws InvocationTargetException Cause of this exceptions may include {@link TransportException},   {@link NotSupportedException} orsome unexpected  {@link RuntimeException}.
 */
public void run(IProgressMonitor actMonitor) throws InvocationTargetException {
  if (operationResult != null)   throw new IllegalStateException(CoreText.OperationAlreadyExecuted);
  for (  URIish uri : this.specification.getURIs()) {
    for (    RemoteRefUpdate update : this.specification.getRefUpdates(uri))     if (update.getStatus() != Status.NOT_ATTEMPTED)     throw new IllegalStateException(CoreText.RemoteRefUpdateCantBeReused);
  }
  IProgressMonitor monitor;
  if (actMonitor == null)   monitor=new NullProgressMonitor();
 else   monitor=actMonitor;
  final int totalWork=specification.getURIsNumber() * WORK_UNITS_PER_TRANSPORT;
  if (dryRun)   monitor.beginTask(CoreText.PushOperation_taskNameDryRun,totalWork);
 else   monitor.beginTask(CoreText.PushOperation_taskNameNormalRun,totalWork);
  operationResult=new PushOperationResult();
  for (  final URIish uri : specification.getURIs()) {
    final SubProgressMonitor subMonitor=new SubProgressMonitor(monitor,WORK_UNITS_PER_TRANSPORT,SubProgressMonitor.PREPEND_MAIN_LABEL_TO_SUBTASK);
    Transport transport=null;
    try {
      if (monitor.isCanceled()) {
        operationResult.addOperationResult(uri,CoreText.PushOperation_resultCancelled);
        continue;
      }
      transport=Transport.open(localDb,uri);
      if (rc != null)       transport.applyConfig(rc);
      transport.setDryRun(dryRun);
      final EclipseGitProgressTransformer gitSubMonitor=new EclipseGitProgressTransformer(subMonitor);
      final PushResult pr=transport.push(gitSubMonitor,specification.getRefUpdates(uri));
      operationResult.addOperationResult(uri,pr);
      monitor.worked(WORK_UNITS_PER_TRANSPORT);
    }
 catch (    final NoRemoteRepositoryException e) {
      operationResult.addOperationResult(uri,NLS.bind(CoreText.PushOperation_resultNoServiceError,e.getMessage()));
    }
catch (    final TransportException e) {
      operationResult.addOperationResult(uri,NLS.bind(CoreText.PushOperation_resultTransportError,e.getMessage()));
    }
catch (    final NotSupportedException e) {
      operationResult.addOperationResult(uri,NLS.bind(CoreText.PushOperation_resultNotSupported,e.getMessage()));
    }
 finally {
      if (transport != null) {
        transport.close();
      }
      subMonitor.beginTask(""String_Node_Str"",WORK_UNITS_PER_TRANSPORT);
      subMonitor.done();
      subMonitor.done();
    }
  }
  monitor.done();
}",0.7685185185185185
91622,"private void openFileInEditor(FileDiff d){
  try {
    IWorkbenchWindow window=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
    IWorkbenchPage page=window.getActivePage();
    IFileRevision rev=CompareUtils.getFileRevision(d.path,d.commit,db,d.blobs[1]);
    if (rev != null)     EgitUiEditorUtils.openEditor(page,rev,new NullProgressMonitor());
 else {
      String message=NLS.bind(UIText.CommitFileDiffViewer_notContainedInCommit,d.path,d.commit.getId().getName());
      Activator.showError(message,null);
    }
  }
 catch (  IOException e) {
    Activator.logError(UIText.GitHistoryPage_openFailed,e);
    Activator.showError(UIText.GitHistoryPage_openFailed,null);
  }
catch (  CoreException e) {
    Activator.logError(UIText.GitHistoryPage_openFailed,e);
    Activator.showError(UIText.GitHistoryPage_openFailed,null);
  }
}","private void openFileInEditor(FileDiff d){
  try {
    IWorkbenchWindow window=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
    IWorkbenchPage page=window.getActivePage();
    IFileRevision rev=CompareUtils.getFileRevision(d.path,d.change.equals(""String_Node_Str"") ? d.commit.getParent(0) : d.commit,db,d.change.equals(""String_Node_Str"") ? d.blobs[0] : d.blobs[1]);
    if (rev != null)     EgitUiEditorUtils.openEditor(page,rev,new NullProgressMonitor());
 else {
      String message=NLS.bind(UIText.CommitFileDiffViewer_notContainedInCommit,d.path,d.commit.getId().getName());
      Activator.showError(message,null);
    }
  }
 catch (  IOException e) {
    Activator.logError(UIText.GitHistoryPage_openFailed,e);
    Activator.showError(UIText.GitHistoryPage_openFailed,null);
  }
catch (  CoreException e) {
    Activator.logError(UIText.GitHistoryPage_openFailed,e);
    Activator.showError(UIText.GitHistoryPage_openFailed,null);
  }
}",0.9380925822643614
91623,"private void openFileInEditor(FileDiff d){
  try {
    IWorkbenchWindow window=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
    IWorkbenchPage page=window.getActivePage();
    IFileRevision rev=CompareUtils.getFileRevision(d.path,d.commit,db,d.blobs[1]);
    if (rev != null)     EgitUiEditorUtils.openEditor(page,rev,new NullProgressMonitor());
 else {
      String message=NLS.bind(UIText.CommitFileDiffViewer_notContainedInCommit,d.path,d.commit.getId().getName());
      Activator.showError(message,null);
    }
  }
 catch (  IOException e) {
    Activator.logError(UIText.GitHistoryPage_openFailed,e);
    Activator.showError(UIText.GitHistoryPage_openFailed,null);
  }
catch (  CoreException e) {
    Activator.logError(UIText.GitHistoryPage_openFailed,e);
    Activator.showError(UIText.GitHistoryPage_openFailed,null);
  }
}","private void openFileInEditor(FileDiff d){
  try {
    IWorkbenchWindow window=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
    IWorkbenchPage page=window.getActivePage();
    IFileRevision rev=CompareUtils.getFileRevision(d.path,d.change.equals(""String_Node_Str"") ? d.commit.getParent(0) : d.commit,db,d.change.equals(""String_Node_Str"") ? d.blobs[0] : d.blobs[1]);
    if (rev != null)     EgitUiEditorUtils.openEditor(page,rev,new NullProgressMonitor());
 else {
      String message=NLS.bind(UIText.CommitFileDiffViewer_notContainedInCommit,d.path,d.commit.getId().getName());
      Activator.showError(message,null);
    }
  }
 catch (  IOException e) {
    Activator.logError(UIText.GitHistoryPage_openFailed,e);
    Activator.showError(UIText.GitHistoryPage_openFailed,null);
  }
catch (  CoreException e) {
    Activator.logError(UIText.GitHistoryPage_openFailed,e);
    Activator.showError(UIText.GitHistoryPage_openFailed,null);
  }
}",0.9380925822643614
91624,"/** 
 * Comparing two folders that have different path should return false.
 * @throws Exception
 */
@Test @SuppressWarnings(""String_Node_Str"") public void shouldReturnFalseWhenComparingContainerAndContainer() throws Exception {
  GitResourceVariantComparator grvc=new GitResourceVariantComparator(null);
  IPath localPath=createMock(IPath.class);
  replay(localPath);
  IContainer local=createMock(IContainer.class);
  expect(local.exists()).andReturn(true);
  expect(local.getFullPath()).andReturn(localPath);
  replay(local);
  File file=testRepo.createFile(iProject,""String_Node_Str"" + File.separator + ""String_Node_Str"");
  RevCommit commit=testRepo.addAndCommit(iProject,file,""String_Node_Str"");
  String path=Repository.stripWorkDir(repo.getWorkTree(),file);
  GitFolderResourceVariant remote=new GitFolderResourceVariant(repo,commit.getTree(),path);
  assertFalse(grvc.compare(local,remote));
  verify(local,localPath);
}","/** 
 * Comparing two folders that have different path should return false.
 * @throws Exception
 */
@Test @SuppressWarnings(""String_Node_Str"") public void shouldReturnFalseWhenComparingContainerAndContainer() throws Exception {
  GitResourceVariantComparator grvc=new GitResourceVariantComparator(null);
  IPath localPath=createMock(IPath.class);
  replay(localPath);
  IContainer local=createMock(IContainer.class);
  expect(local.exists()).andReturn(true).times(2);
  expect(local.getFullPath()).andReturn(localPath);
  replay(local);
  File file=testRepo.createFile(iProject,""String_Node_Str"" + File.separator + ""String_Node_Str"");
  RevCommit commit=testRepo.addAndCommit(iProject,file,""String_Node_Str"");
  String path=Repository.stripWorkDir(repo.getWorkTree(),file);
  GitFolderResourceVariant remote=new GitFolderResourceVariant(repo,commit.getTree(),path);
  assertFalse(grvc.compare(local,remote));
  verify(local,localPath);
}",0.995179432244242
91625,"/** 
 * When comparing two folders that have same path, compare() method should return true.
 * @throws Exception
 */
@Test @SuppressWarnings(""String_Node_Str"") public void shouldReturnTrueWhenComparingContainerAndContainer() throws Exception {
  GitResourceVariantComparator grvc=new GitResourceVariantComparator(null);
  File file=testRepo.createFile(iProject,""String_Node_Str"" + File.separator + ""String_Node_Str"");
  RevCommit commit=testRepo.addAndCommit(iProject,file,""String_Node_Str"");
  String path=Repository.stripWorkDir(repo.getWorkTree(),file);
  IPath iPath=new Path(File.separator + path);
  IContainer local=createMock(IContainer.class);
  expect(local.exists()).andReturn(true);
  expect(local.getFullPath()).andReturn(iPath).anyTimes();
  replay(local);
  GitFolderResourceVariant remote=new GitFolderResourceVariant(repo,commit.getTree(),path);
  assertTrue(grvc.compare(local,remote));
  verify(local);
}","/** 
 * When comparing two folders that have same path, compare() method should return true.
 * @throws Exception
 */
@Test @SuppressWarnings(""String_Node_Str"") public void shouldReturnTrueWhenComparingContainerAndContainer() throws Exception {
  GitResourceVariantComparator grvc=new GitResourceVariantComparator(null);
  File file=testRepo.createFile(iProject,""String_Node_Str"" + File.separator + ""String_Node_Str"");
  RevCommit commit=testRepo.addAndCommit(iProject,file,""String_Node_Str"");
  String path=Repository.stripWorkDir(repo.getWorkTree(),file);
  IPath iPath=new Path(File.separator + path);
  IContainer local=createMock(IContainer.class);
  expect(local.exists()).andReturn(true).times(2);
  expect(local.getFullPath()).andReturn(iPath).anyTimes();
  replay(local);
  GitFolderResourceVariant remote=new GitFolderResourceVariant(repo,commit.getTree(),path);
  assertTrue(grvc.compare(local,remote));
  verify(local);
}",0.9951534733441034
91626,"private void checkPage(){
  String projectName=projectText.getText();
  setErrorMessage(null);
  try {
    if (!myDirectory.exists()) {
      setErrorMessage(NLS.bind(UIText.GitCreateGeneralProjectPage_DirNotExistMessage,myDirectory.getPath()));
      return;
    }
    if (!myDirectory.isDirectory()) {
      setErrorMessage(NLS.bind(UIText.GitCreateGeneralProjectPage_FileNotDirMessage,myDirectory.getPath()));
      return;
    }
    if (myDirectory.list(new FilenameFilter(){
      public boolean accept(      File dir,      String name){
        if (name.equals(""String_Node_Str""))         return true;
        return false;
      }
    }
).length > 0) {
      setErrorMessage(NLS.bind(UIText.GitCreateGeneralProjectPage_FileExistsInDirMessage,""String_Node_Str"",myDirectory.getPath()));
      return;
    }
    if (projectName.length() == 0) {
      setErrorMessage(UIText.GitCreateGeneralProjectPage_EnterProjectNameMessage);
      return;
    }
    IStatus result=ResourcesPlugin.getWorkspace().validateName(projectName,IResource.PROJECT);
    if (!result.isOK()) {
      setErrorMessage(result.getMessage());
      return;
    }
    if (isProjectInWorkspace(projectName)) {
      setErrorMessage(NLS.bind(UIText.GitCreateGeneralProjectPage_PorjectAlreadyExistsMessage,projectName));
      return;
    }
    IProject newProject=ResourcesPlugin.getWorkspace().getRoot().getProject(projectName);
    IStatus locationResult=ResourcesPlugin.getWorkspace().validateProjectLocation(newProject,new Path(myDirectory.getPath()));
    if (!locationResult.isOK()) {
      setErrorMessage(locationResult.getMessage());
      return;
    }
  }
  finally {
    setPageComplete(getErrorMessage() == null);
  }
}","private void checkPage(){
  String projectName=projectText.getText();
  setErrorMessage(null);
  try {
    if (!myDirectory.exists()) {
      setErrorMessage(NLS.bind(UIText.GitCreateGeneralProjectPage_DirNotExistMessage,myDirectory.getPath()));
      return;
    }
    if (!myDirectory.isDirectory()) {
      setErrorMessage(NLS.bind(UIText.GitCreateGeneralProjectPage_FileNotDirMessage,myDirectory.getPath()));
      return;
    }
    if (myDirectory.list(new FilenameFilter(){
      public boolean accept(      File dir,      String name){
        if (name.equals(""String_Node_Str""))         return true;
        return false;
      }
    }
).length > 0) {
      setErrorMessage(NLS.bind(UIText.GitCreateGeneralProjectPage_FileExistsInDirMessage,""String_Node_Str"",myDirectory.getPath()));
      return;
    }
    if (projectName.length() == 0) {
      setErrorMessage(UIText.GitCreateGeneralProjectPage_EnterProjectNameMessage);
      return;
    }
    IStatus result=ResourcesPlugin.getWorkspace().validateName(projectName,IResource.PROJECT);
    if (!result.isOK()) {
      setErrorMessage(result.getMessage());
      return;
    }
    if (isProjectInWorkspace(projectName)) {
      setErrorMessage(NLS.bind(UIText.GitCreateGeneralProjectPage_PorjectAlreadyExistsMessage,projectName));
      return;
    }
    if (!defaultLocation) {
      IProject newProject=ResourcesPlugin.getWorkspace().getRoot().getProject(projectName);
      IStatus locationResult=ResourcesPlugin.getWorkspace().validateProjectLocation(newProject,new Path(myDirectory.getPath()));
      if (!locationResult.isOK()) {
        setErrorMessage(locationResult.getMessage());
        return;
      }
    }
  }
  finally {
    setPageComplete(getErrorMessage() == null);
  }
}",0.9826187717265352
91627,"public void createControl(Composite parent){
  initializeDialogUnits(parent);
  Composite workArea=new Composite(parent,SWT.NONE);
  setControl(workArea);
  workArea.setLayout(new GridLayout(2,false));
  workArea.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL));
  new Label(workArea,SWT.NONE).setText(UIText.GitCreateGeneralProjectPage_ProjectNameLabel);
  projectText=new Text(workArea,SWT.BORDER);
  GridDataFactory.fillDefaults().grab(true,false).applyTo(projectText);
  projectText.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      checkPage();
    }
  }
);
  new Label(workArea,SWT.NONE).setText(UIText.GitCreateGeneralProjectPage_DirLabel);
  directoryText=new Text(workArea,SWT.BORDER);
  directoryText.setEnabled(false);
  GridDataFactory.fillDefaults().grab(true,false).applyTo(directoryText);
  Dialog.applyDialogFont(workArea);
}","public void createControl(Composite parent){
  initializeDialogUnits(parent);
  Composite workArea=new Composite(parent,SWT.NONE);
  setControl(workArea);
  workArea.setLayout(new GridLayout(2,false));
  workArea.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL));
  new Label(workArea,SWT.NONE).setText(UIText.GitCreateGeneralProjectPage_ProjectNameLabel);
  projectText=new Text(workArea,SWT.BORDER);
  GridDataFactory.fillDefaults().grab(true,false).applyTo(projectText);
  if (defaultLocation)   projectText.setEnabled(false);
 else   projectText.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      checkPage();
    }
  }
);
  new Label(workArea,SWT.NONE).setText(UIText.GitCreateGeneralProjectPage_DirLabel);
  directoryText=new Text(workArea,SWT.BORDER);
  directoryText.setEnabled(false);
  GridDataFactory.fillDefaults().grab(true,false).applyTo(directoryText);
  Dialog.applyDialogFont(workArea);
}",0.9679089026915114
91628,"/** 
 */
public void importProjects(){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
switch (mySelectionPage.getWizardSelection()) {
case GitSelectWizardPage.EXISTING_PROJECTS_WIZARD:
        myProjectsImportPage.createProjects();
      break;
case GitSelectWizardPage.NEW_WIZARD:
    new NewWizardAction(PlatformUI.getWorkbench().getActiveWorkbenchWindow()).run();
  break;
case GitSelectWizardPage.GENERAL_WIZARD:
try {
  final String projectName=myCreateGeneralProjectPage.getProjectName();
  getContainer().run(true,false,new WorkspaceModifyOperation(){
    @Override protected void execute(    IProgressMonitor monitor) throws CoreException, InvocationTargetException, InterruptedException {
      final IProjectDescription desc=ResourcesPlugin.getWorkspace().newProjectDescription(projectName);
      desc.setLocation(new Path(myGitDir));
      IProject prj=ResourcesPlugin.getWorkspace().getRoot().getProject(desc.getName());
      prj.create(desc,monitor);
      prj.open(monitor);
      ResourcesPlugin.getWorkspace().getRoot().refreshLocal(IResource.DEPTH_ONE,monitor);
    }
  }
);
}
 catch (InvocationTargetException e1) {
  Activator.handleError(e1.getMessage(),e1.getTargetException(),true);
}
catch (InterruptedException e1) {
  Activator.handleError(e1.getMessage(),e1,true);
}
break;
}
}
}
);
}","/** 
 */
public void importProjects(){
  Display.getDefault().syncExec(new Runnable(){
    public void run(){
switch (mySelectionPage.getWizardSelection()) {
case GitSelectWizardPage.EXISTING_PROJECTS_WIZARD:
        myProjectsImportPage.createProjects();
      break;
case GitSelectWizardPage.NEW_WIZARD:
    new NewWizardAction(PlatformUI.getWorkbench().getActiveWorkbenchWindow()).run();
  break;
case GitSelectWizardPage.GENERAL_WIZARD:
try {
  final String projectName=myCreateGeneralProjectPage.getProjectName();
  final boolean defaultLocation=myCreateGeneralProjectPage.isDefaultLocation();
  getContainer().run(true,false,new WorkspaceModifyOperation(){
    @Override protected void execute(    IProgressMonitor monitor) throws CoreException, InvocationTargetException, InterruptedException {
      final IProjectDescription desc=ResourcesPlugin.getWorkspace().newProjectDescription(projectName);
      if (!defaultLocation)       desc.setLocation(new Path(myGitDir));
      IProject prj=ResourcesPlugin.getWorkspace().getRoot().getProject(desc.getName());
      prj.create(desc,monitor);
      prj.open(monitor);
      ResourcesPlugin.getWorkspace().getRoot().refreshLocal(IResource.DEPTH_ONE,monitor);
    }
  }
);
}
 catch (InvocationTargetException e1) {
  Activator.handleError(e1.getMessage(),e1.getTargetException(),true);
}
catch (InterruptedException e1) {
  Activator.handleError(e1.getMessage(),e1,true);
}
break;
}
}
}
);
}",0.9611510791366906
91629,"public void run(){
switch (mySelectionPage.getWizardSelection()) {
case GitSelectWizardPage.EXISTING_PROJECTS_WIZARD:
    myProjectsImportPage.createProjects();
  break;
case GitSelectWizardPage.NEW_WIZARD:
new NewWizardAction(PlatformUI.getWorkbench().getActiveWorkbenchWindow()).run();
break;
case GitSelectWizardPage.GENERAL_WIZARD:
try {
final String projectName=myCreateGeneralProjectPage.getProjectName();
getContainer().run(true,false,new WorkspaceModifyOperation(){
@Override protected void execute(IProgressMonitor monitor) throws CoreException, InvocationTargetException, InterruptedException {
  final IProjectDescription desc=ResourcesPlugin.getWorkspace().newProjectDescription(projectName);
  desc.setLocation(new Path(myGitDir));
  IProject prj=ResourcesPlugin.getWorkspace().getRoot().getProject(desc.getName());
  prj.create(desc,monitor);
  prj.open(monitor);
  ResourcesPlugin.getWorkspace().getRoot().refreshLocal(IResource.DEPTH_ONE,monitor);
}
}
);
}
 catch (InvocationTargetException e1) {
Activator.handleError(e1.getMessage(),e1.getTargetException(),true);
}
catch (InterruptedException e1) {
Activator.handleError(e1.getMessage(),e1,true);
}
break;
}
}","public void run(){
switch (mySelectionPage.getWizardSelection()) {
case GitSelectWizardPage.EXISTING_PROJECTS_WIZARD:
    myProjectsImportPage.createProjects();
  break;
case GitSelectWizardPage.NEW_WIZARD:
new NewWizardAction(PlatformUI.getWorkbench().getActiveWorkbenchWindow()).run();
break;
case GitSelectWizardPage.GENERAL_WIZARD:
try {
final String projectName=myCreateGeneralProjectPage.getProjectName();
final boolean defaultLocation=myCreateGeneralProjectPage.isDefaultLocation();
getContainer().run(true,false,new WorkspaceModifyOperation(){
@Override protected void execute(IProgressMonitor monitor) throws CoreException, InvocationTargetException, InterruptedException {
  final IProjectDescription desc=ResourcesPlugin.getWorkspace().newProjectDescription(projectName);
  if (!defaultLocation)   desc.setLocation(new Path(myGitDir));
  IProject prj=ResourcesPlugin.getWorkspace().getRoot().getProject(desc.getName());
  prj.create(desc,monitor);
  prj.open(monitor);
  ResourcesPlugin.getWorkspace().getRoot().refreshLocal(IResource.DEPTH_ONE,monitor);
}
}
);
}
 catch (InvocationTargetException e1) {
Activator.handleError(e1.getMessage(),e1.getTargetException(),true);
}
catch (InterruptedException e1) {
Activator.handleError(e1.getMessage(),e1,true);
}
break;
}
}",0.9585028478437754
91630,"@Override protected void execute(IProgressMonitor monitor) throws CoreException, InvocationTargetException, InterruptedException {
  final IProjectDescription desc=ResourcesPlugin.getWorkspace().newProjectDescription(projectName);
  desc.setLocation(new Path(myGitDir));
  IProject prj=ResourcesPlugin.getWorkspace().getRoot().getProject(desc.getName());
  prj.create(desc,monitor);
  prj.open(monitor);
  ResourcesPlugin.getWorkspace().getRoot().refreshLocal(IResource.DEPTH_ONE,monitor);
}","@Override protected void execute(IProgressMonitor monitor) throws CoreException, InvocationTargetException, InterruptedException {
  final IProjectDescription desc=ResourcesPlugin.getWorkspace().newProjectDescription(projectName);
  if (!defaultLocation)   desc.setLocation(new Path(myGitDir));
  IProject prj=ResourcesPlugin.getWorkspace().getRoot().getProject(desc.getName());
  prj.create(desc,monitor);
  prj.open(monitor);
  ResourcesPlugin.getWorkspace().getRoot().refreshLocal(IResource.DEPTH_ONE,monitor);
}",0.9761431411530817
91631,"/** 
 * Returns a status that represents the exceptions collected. If the collector is empty <code>IStatus.OK</code> is returned. Otherwise a MultiStatus containing all collected exceptions is returned.
 * @return a multistatus containing the exceptions collected or IStatus.OKif the collector is empty.
 */
public IStatus getStatus(){
  if (statuses.isEmpty()) {
    return Status.OK_STATUS;
  }
 else {
    final MultiStatus multiStatus=new MultiStatus(pluginId,severity,message,null);
    final Iterator it=statuses.iterator();
    while (it.hasNext()) {
      final IStatus status=(IStatus)it.next();
      multiStatus.merge(status);
    }
    return multiStatus;
  }
}","/** 
 * Returns a status that represents the exceptions collected. If the collector is empty <code>IStatus.OK</code> is returned. Otherwise a MultiStatus containing all collected exceptions is returned.
 * @return a multistatus containing the exceptions collected or IStatus.OKif the collector is empty.
 */
public IStatus getStatus(){
  if (statuses != null && statuses.isEmpty()) {
    return Status.OK_STATUS;
  }
 else {
    final MultiStatus multiStatus=new MultiStatus(pluginId,severity,message,null);
    final Iterator it=statuses.iterator();
    while (it.hasNext()) {
      final IStatus status=(IStatus)it.next();
      multiStatus.merge(status);
    }
    return multiStatus;
  }
}",0.985358711566618
91632,"/** 
 * @return destination {@link Tree}
 * @throws IOException
 */
public Tree mapDstTree() throws IOException {
  return mapTree(dstRev);
}","/** 
 * @return destination Tree
 * @throws IOException
 */
public Tree mapDstTree() throws IOException {
  return mapTree(dstRev);
}",0.9708029197080292
91633,"/** 
 * @return source {@link Tree}
 * @throws IOException
 */
public Tree mapSrcTree() throws IOException {
  return mapTree(srcRev);
}","/** 
 * @return source Tree
 * @throws IOException
 */
public Tree mapSrcTree() throws IOException {
  return mapTree(srcRev);
}",0.9696969696969696
91634,"/** 
 * Construct a resource not for a   {@link TreeEntry}
 * @param e The {@link TreeEntry}
 */
public GitResourceNode(TreeEntry e){
  entry=e;
}","/** 
 * Construct a resource not for a TreeEntry
 * @param e The TreeEntry
 */
public GitResourceNode(TreeEntry e){
  entry=e;
}",0.9343065693430656
91635,"/** 
 * @return destination {@link Tree}
 * @throws IOException
 */
public Tree mapDstTree() throws IOException {
  return mapTree(dstRev);
}","/** 
 * @return destination Tree
 * @throws IOException
 */
public Tree mapDstTree() throws IOException {
  return mapTree(dstRev);
}",0.9708029197080292
91636,"/** 
 * @return source {@link Tree}
 * @throws IOException
 */
public Tree mapSrcTree() throws IOException {
  return mapTree(srcRev);
}","/** 
 * @return source Tree
 * @throws IOException
 */
public Tree mapSrcTree() throws IOException {
  return mapTree(srcRev);
}",0.9696969696969696
91637,"/** 
 * Construct a resource not for a   {@link TreeEntry}
 * @param e The {@link TreeEntry}
 */
public GitResourceNode(TreeEntry e){
  entry=e;
}","/** 
 * Construct a resource not for a TreeEntry
 * @param e The TreeEntry
 */
public GitResourceNode(TreeEntry e){
  entry=e;
}",0.9343065693430656
91638,"public void execute(IAction action) throws InvocationTargetException {
  final IResource resource=getSelectedResources()[0];
  final RepositoryMapping mapping=RepositoryMapping.getMapping(resource.getProject());
  final Repository repository=mapping.getRepository();
  final String gitPath=mapping.getRepoRelativePath(resource);
  final IFile baseFile=(IFile)resource;
  final ITypedElement base=SaveableCompareEditorInput.createFileElement(baseFile);
  ITypedElement next;
  try {
    Ref head=repository.getRef(Constants.HEAD);
    RevWalk rw=new RevWalk(repository);
    RevCommit commit=rw.parseCommit(head.getObjectId());
    next=new GitCompareFileRevisionEditorInput.EmptyTypedElement(NLS.bind(UIText.GitHistoryPage_FileNotInCommit,resource.getName(),commit));
    TreeWalk w=TreeWalk.forPath(repository,gitPath,commit.getTree());
    if (w != null) {
      final IFileRevision nextFile=GitFileRevision.inCommit(repository,commit,gitPath,null);
      next=new FileRevisionTypedElement(nextFile);
    }
  }
 catch (  IOException e) {
    throw new InvocationTargetException(e);
  }
  final GitCompareFileRevisionEditorInput in=new GitCompareFileRevisionEditorInput(base,next,null);
  CompareUI.openCompareEditor(in);
}","public void execute(IAction action) throws InvocationTargetException {
  final IResource resource=getSelectedResources()[0];
  final RepositoryMapping mapping=RepositoryMapping.getMapping(resource.getProject());
  final Repository repository=mapping.getRepository();
  final String gitPath=mapping.getRepoRelativePath(resource);
  final IFile baseFile=(IFile)resource;
  final ITypedElement base=SaveableCompareEditorInput.createFileElement(baseFile);
  ITypedElement next;
  try {
    Ref head=repository.getRef(Constants.HEAD);
    RevWalk rw=new RevWalk(repository);
    RevCommit commit=rw.parseCommit(head.getObjectId());
    next=CompareUtils.getFileRevisionTypedElement(gitPath,commit,repository);
  }
 catch (  IOException e) {
    throw new InvocationTargetException(e);
  }
  final GitCompareFileRevisionEditorInput in=new GitCompareFileRevisionEditorInput(base,next,null);
  CompareUI.openCompareEditor(in);
}",0.6585820895522388
91639,"private void discardChange(IResource res) throws IOException {
  IProject[] proj=new IProject[]{res.getProject()};
  Repository repository=getRepositoriesFor(proj)[0];
  String resRelPath=RepositoryMapping.getMapping(res).getRepoRelativePath(res);
  Entry e=repository.getIndex().getEntry(resRelPath);
  if (e != null && e.getStage() == 0 && e.isModified(repository.getWorkDir())) {
    repository.getIndex().checkoutEntry(repository.getWorkDir(),e);
    try {
      res.refreshLocal(0,new NullProgressMonitor());
    }
 catch (    CoreException e1) {
      MessageDialog.openError(getShell(),UIText.DiscardChangesAction_refreshErrorTitle,UIText.DiscardChangesAction_refreshErrorMessage);
    }
    repository.getIndex().write();
  }
}","private void discardChange(IResource res) throws IOException {
  IProject[] proj=new IProject[]{res.getProject()};
  Repository repository=getRepositoriesFor(proj)[0];
  String resRelPath=RepositoryMapping.getMapping(res).getRepoRelativePath(res);
  Entry e=repository.getIndex().getEntry(resRelPath);
  if (e != null && e.getStage() == 0 && e.isModified(repository.getWorkDir())) {
    repository.getIndex().checkoutEntry(repository.getWorkDir(),e);
    try {
      res.refreshLocal(0,new NullProgressMonitor());
    }
 catch (    CoreException e1) {
      Activator.handleError(UIText.DiscardChangesAction_refreshErrorMessage,e1,true);
    }
    repository.getIndex().write();
  }
}",0.8076109936575053
91640,"private void performDiscardChanges(){
  ArrayList<IResource> allFiles=new ArrayList<IResource>();
  for (  IResource res : getSelectedResources()) {
    allFiles.addAll(getAllMembers(res));
  }
  for (  IResource res : allFiles) {
    try {
      discardChange(res);
    }
 catch (    IOException e1) {
      MessageDialog.openError(getShell(),UIText.DiscardChangesAction_unexpectedErrorTitle,UIText.DiscardChangesAction_unexpectedErrorMessage);
    }
catch (    RuntimeException e2) {
      MessageDialog.openError(getShell(),UIText.DiscardChangesAction_unexpectedErrorTitle,UIText.DiscardChangesAction_unexpectedIndexErrorMessage);
    }
  }
}","private void performDiscardChanges(){
  ArrayList<IResource> allFiles=new ArrayList<IResource>();
  for (  IResource res : getSelectedResources()) {
    allFiles.addAll(getAllMembers(res));
  }
  for (  IResource res : allFiles) {
    try {
      discardChange(res);
    }
 catch (    IOException e1) {
      Activator.handleError(UIText.DiscardChangesAction_unexpectedErrorMessage,e1,true);
    }
catch (    RuntimeException e2) {
      Activator.handleError(UIText.DiscardChangesAction_unexpectedIndexErrorMessage,e2,true);
    }
  }
}",0.7191201353637902
91641,"@Override public void execute(IAction action){
  final Repository repository=getRepository(true);
  if (repository == null)   return;
  if (!repository.getRepositoryState().canResetHead()) {
    MessageDialog.openError(getShell(),UIText.ResetAction_errorResettingHead,NLS.bind(UIText.ResetAction_repositoryState,repository.getRepositoryState().getDescription()));
    return;
  }
  BranchSelectionDialog branchSelectionDialog=new BranchSelectionDialog(getShell(),repository,true);
  if (branchSelectionDialog.open() == IDialogConstants.OK_ID) {
    final String refName=branchSelectionDialog.getRefName();
    final ResetType type=branchSelectionDialog.getResetType();
    try {
      getTargetPart().getSite().getWorkbenchWindow().run(true,false,new IRunnableWithProgress(){
        public void run(        final IProgressMonitor monitor) throws InvocationTargetException {
          try {
            new ResetOperation(repository,refName,type).run(monitor);
            GitLightweightDecorator.refresh();
          }
 catch (          CoreException e) {
            if (GitTraceLocation.UI.isActive())             GitTraceLocation.getTrace().trace(GitTraceLocation.UI.getLocation(),e.getMessage(),e);
            throw new InvocationTargetException(e);
          }
        }
      }
);
    }
 catch (    InvocationTargetException e) {
      MessageDialog.openError(getShell(),UIText.ResetAction_resetFailed,e.getMessage());
    }
catch (    InterruptedException e) {
      MessageDialog.openError(getShell(),UIText.ResetAction_resetFailed,e.getMessage());
    }
  }
}","@Override public void execute(IAction action){
  final Repository repository=getRepository(true);
  if (repository == null)   return;
  if (!repository.getRepositoryState().canResetHead()) {
    MessageDialog.openError(getShell(),UIText.ResetAction_errorResettingHead,NLS.bind(UIText.ResetAction_repositoryState,repository.getRepositoryState().getDescription()));
    return;
  }
  BranchSelectionDialog branchSelectionDialog=new BranchSelectionDialog(getShell(),repository,true);
  if (branchSelectionDialog.open() == IDialogConstants.OK_ID) {
    final String refName=branchSelectionDialog.getRefName();
    final ResetType type=branchSelectionDialog.getResetType();
    try {
      getTargetPart().getSite().getWorkbenchWindow().run(true,false,new IRunnableWithProgress(){
        public void run(        final IProgressMonitor monitor) throws InvocationTargetException {
          try {
            new ResetOperation(repository,refName,type).run(monitor);
            GitLightweightDecorator.refresh();
          }
 catch (          CoreException e) {
            if (GitTraceLocation.UI.isActive())             GitTraceLocation.getTrace().trace(GitTraceLocation.UI.getLocation(),e.getMessage(),e);
            throw new InvocationTargetException(e);
          }
        }
      }
);
    }
 catch (    InvocationTargetException e) {
      Activator.handleError(UIText.ResetAction_resetFailed,e,true);
    }
catch (    InterruptedException e) {
      Activator.handleError(UIText.ResetAction_resetFailed,e,true);
    }
  }
}",0.9593285990961912
91642,"@Override public void execute(IAction action){
  try {
    final TrackOperation op=new TrackOperation(Arrays.asList(getSelectedResources()));
    getTargetPart().getSite().getWorkbenchWindow().run(true,false,new IRunnableWithProgress(){
      public void run(      IProgressMonitor arg0) throws InvocationTargetException, InterruptedException {
        try {
          op.run(arg0);
        }
 catch (        CoreException e) {
          throw new InvocationTargetException(e);
        }
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    Activator.logError(UIText.Track_error,e);
    MessageDialog.openError(getShell(),UIText.Track_error,UIText.Track_see_log);
  }
catch (  InterruptedException e) {
    MessageDialog.openError(getShell(),UIText.Track_error,e.getMessage());
  }
}","@Override public void execute(IAction action){
  try {
    final TrackOperation op=new TrackOperation(Arrays.asList(getSelectedResources()));
    getTargetPart().getSite().getWorkbenchWindow().run(true,false,new IRunnableWithProgress(){
      public void run(      IProgressMonitor arg0) throws InvocationTargetException, InterruptedException {
        try {
          op.run(arg0);
        }
 catch (        CoreException e) {
          throw new InvocationTargetException(e);
        }
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    Activator.handleError(UIText.Track_error,e,true);
  }
catch (  InterruptedException e) {
    Activator.handleError(UIText.Track_error,e,true);
  }
}",0.8411214953271028
91643,"@Override public void setFocus(){
}","@Override public void setFocus(){
  tv.getTree().setFocus();
}",0.7216494845360825
91644,"/** 
 * Create the selection buttons in the listComposite.
 * @param listComposite
 */
private void createSelectionButtons(Composite listComposite){
  Composite buttonsComposite=new Composite(listComposite,SWT.NONE);
  GridLayout layout=new GridLayout();
  layout.marginWidth=0;
  layout.marginHeight=0;
  buttonsComposite.setLayout(layout);
  buttonsComposite.setLayoutData(new GridData(GridData.VERTICAL_ALIGN_BEGINNING));
  Button selectAll=new Button(buttonsComposite,SWT.PUSH);
  selectAll.setText(UIText.WizardProjectsImportPage_selectAll);
  selectAll.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent e){
      checkedItems.clear();
      for (      final TreeItem item : projectsList.getTree().getItems()) {
        item.setChecked(true);
        checkedItems.add(item.getData());
      }
      setPageComplete(true);
    }
  }
);
  Dialog.applyDialogFont(selectAll);
  setButtonLayoutData(selectAll);
  Button deselectAll=new Button(buttonsComposite,SWT.PUSH);
  deselectAll.setText(UIText.WizardProjectsImportPage_deselectAll);
  deselectAll.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent e){
      checkedItems.clear();
      for (      final TreeItem item : projectsList.getTree().getItems()) {
        item.setChecked(false);
      }
      projectsList.setInput(this);
      setPageComplete(false);
    }
  }
);
  Dialog.applyDialogFont(deselectAll);
  setButtonLayoutData(deselectAll);
}","/** 
 * Create the selection buttons in the listComposite.
 * @param listComposite
 */
private void createSelectionButtons(Composite listComposite){
  Composite buttonsComposite=new Composite(listComposite,SWT.NONE);
  GridLayout layout=new GridLayout();
  layout.marginWidth=0;
  layout.marginHeight=0;
  buttonsComposite.setLayout(layout);
  buttonsComposite.setLayoutData(new GridData(GridData.VERTICAL_ALIGN_BEGINNING));
  selectAll=new Button(buttonsComposite,SWT.PUSH);
  selectAll.setText(UIText.WizardProjectsImportPage_selectAll);
  selectAll.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent e){
      checkedItems.clear();
      for (      final TreeItem item : projectsList.getTree().getItems()) {
        item.setChecked(true);
        checkedItems.add(item.getData());
      }
      setPageComplete(true);
    }
  }
);
  Dialog.applyDialogFont(selectAll);
  setButtonLayoutData(selectAll);
  deselectAll=new Button(buttonsComposite,SWT.PUSH);
  deselectAll.setText(UIText.WizardProjectsImportPage_deselectAll);
  deselectAll.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent e){
      checkedItems.clear();
      for (      final TreeItem item : projectsList.getTree().getItems()) {
        item.setChecked(false);
      }
      projectsList.setInput(this);
      setPageComplete(false);
    }
  }
);
  Dialog.applyDialogFont(deselectAll);
  setButtonLayoutData(deselectAll);
}",0.9952956989247312
91645,"/** 
 * Create the checkbox list for the found projects.
 * @param workArea
 */
private void createProjectsList(Composite workArea){
  checkedItems.clear();
  Label title=new Label(workArea,SWT.NONE);
  title.setText(UIText.WizardProjectsImportPage_ProjectsListTitle);
  Composite listComposite=new Composite(workArea,SWT.NONE);
  GridLayout layout=new GridLayout();
  layout.numColumns=2;
  layout.marginWidth=0;
  layout.makeColumnsEqualWidth=false;
  listComposite.setLayout(layout);
  listComposite.setLayoutData(new GridData(GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL | GridData.FILL_BOTH));
  PatternFilter filter=new PatternFilter(){
    @Override public boolean isElementVisible(    Viewer viewer,    Object element){
      if (checkedItems.contains(element)) {
        return true;
      }
      return super.isElementVisible(viewer,element);
    }
  }
;
  FilteredTree filteredTree=new FilteredTree(listComposite,SWT.CHECK | SWT.BORDER,filter);
  filteredTree.setInitialText(UIText.WizardProjectsImportPage_filterText);
  projectsList=filteredTree.getViewer();
  GridData listData=new GridData(GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL | GridData.FILL_BOTH);
  projectsList.getControl().setLayoutData(listData);
  projectsList.setContentProvider(new ITreeContentProvider(){
    public Object[] getChildren(    Object parentElement){
      return null;
    }
    public Object[] getElements(    Object inputElement){
      return getValidProjects();
    }
    public boolean hasChildren(    Object element){
      return false;
    }
    public Object getParent(    Object element){
      return null;
    }
    public void dispose(){
    }
    public void inputChanged(    Viewer viewer,    Object oldInput,    Object newInput){
    }
  }
);
  projectsList.getTree().addMouseListener(new MouseAdapter(){
    @Override public void mouseUp(    MouseEvent e){
      if (e.widget instanceof Tree) {
        TreeItem item=((Tree)e.widget).getItem(new Point(e.x,e.y));
        if (item != null) {
          if (item.getChecked())           checkedItems.add(item.getData());
 else           checkedItems.remove(item.getData());
          setPageComplete(!checkedItems.isEmpty());
        }
      }
    }
  }
);
  projectsList.setLabelProvider(new LabelProvider(){
    public String getText(    Object element){
      for (      final TreeItem item : projectsList.getTree().getItems()) {
        if (checkedItems.contains(item.getData()))         item.setChecked(true);
 else         item.setChecked(false);
      }
      return ((ProjectRecord)element).getProjectLabel();
    }
  }
);
  projectsList.setInput(this);
  projectsList.setComparator(new ViewerComparator());
  createSelectionButtons(listComposite);
}","/** 
 * Create the checkbox list for the found projects.
 * @param workArea
 */
private void createProjectsList(Composite workArea){
  checkedItems.clear();
  Label title=new Label(workArea,SWT.NONE);
  title.setText(UIText.WizardProjectsImportPage_ProjectsListTitle);
  Composite listComposite=new Composite(workArea,SWT.NONE);
  GridLayout layout=new GridLayout();
  layout.numColumns=2;
  layout.marginWidth=0;
  layout.makeColumnsEqualWidth=false;
  listComposite.setLayout(layout);
  listComposite.setLayoutData(new GridData(GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL | GridData.FILL_BOTH));
  PatternFilter filter=new PatternFilter(){
    @Override public boolean isElementVisible(    Viewer viewer,    Object element){
      if (checkedItems.contains(element)) {
        return true;
      }
      return super.isElementVisible(viewer,element);
    }
    @Override public void setPattern(    String patternString){
      super.setPattern(patternString);
      Display.getDefault().asyncExec(new Runnable(){
        public void run(){
          enableSelectAllButtons();
        }
      }
);
    }
  }
;
  FilteredTree filteredTree=new FilteredTree(listComposite,SWT.CHECK | SWT.BORDER,filter);
  filteredTree.setInitialText(UIText.WizardProjectsImportPage_filterText);
  projectsList=filteredTree.getViewer();
  GridData listData=new GridData(GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL | GridData.FILL_BOTH);
  projectsList.getControl().setLayoutData(listData);
  projectsList.setContentProvider(new ITreeContentProvider(){
    public Object[] getChildren(    Object parentElement){
      return null;
    }
    public Object[] getElements(    Object inputElement){
      return getValidProjects();
    }
    public boolean hasChildren(    Object element){
      return false;
    }
    public Object getParent(    Object element){
      return null;
    }
    public void dispose(){
    }
    public void inputChanged(    Viewer viewer,    Object oldInput,    Object newInput){
    }
  }
);
  projectsList.getTree().addMouseListener(new MouseAdapter(){
    @Override public void mouseUp(    MouseEvent e){
      if (e.widget instanceof Tree) {
        TreeItem item=((Tree)e.widget).getItem(new Point(e.x,e.y));
        if (item != null) {
          if (item.getChecked())           checkedItems.add(item.getData());
 else           checkedItems.remove(item.getData());
          setPageComplete(!checkedItems.isEmpty());
        }
      }
    }
  }
);
  projectsList.setLabelProvider(new LabelProvider(){
    public String getText(    Object element){
      for (      final TreeItem item : projectsList.getTree().getItems()) {
        if (checkedItems.contains(item.getData()))         item.setChecked(true);
 else         item.setChecked(false);
      }
      return ((ProjectRecord)element).getProjectLabel();
    }
  }
);
  projectsList.setInput(this);
  projectsList.setComparator(new ViewerComparator());
  createSelectionButtons(listComposite);
}",0.9568874868559412
91646,"/** 
 * Update the list of projects based on path. This will not check any projects.
 * @param path
 */
void setProjectsList(final String path){
  if (path == null || path.length() == 0) {
    setMessage(UIText.WizardProjectsImportPage_ImportProjectsDescription);
    selectedProjects=new ProjectRecord[0];
    projectsList.refresh(true);
    setPageComplete(checkedItems.size() > 0);
    lastPath=path;
    return;
  }
  final File directory=new File(path);
  long modified=directory.lastModified();
  if (path.equals(lastPath) && lastModified == modified) {
    return;
  }
  lastPath=path;
  lastModified=modified;
  try {
    getContainer().run(true,true,new IRunnableWithProgress(){
      public void run(      IProgressMonitor monitor){
        monitor.beginTask(UIText.WizardProjectsImportPage_SearchingMessage,100);
        selectedProjects=new ProjectRecord[0];
        Collection<File> files=new ArrayList<File>();
        monitor.worked(10);
        if (directory.isDirectory()) {
          if (!collectProjectFilesFromDirectory(files,directory,null,monitor)) {
            return;
          }
          Iterator<File> filesIterator=files.iterator();
          selectedProjects=new ProjectRecord[files.size()];
          int index=0;
          monitor.worked(50);
          monitor.subTask(UIText.WizardProjectsImportPage_ProcessingMessage);
          while (filesIterator.hasNext()) {
            File file=filesIterator.next();
            selectedProjects[index]=new ProjectRecord(file);
            checkedItems.add(selectedProjects[index]);
            index++;
          }
        }
 else {
          monitor.worked(60);
        }
        monitor.done();
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    IDEWorkbenchPlugin.log(e.getMessage(),e);
  }
catch (  InterruptedException e) {
  }
  projectsList.refresh(true);
  if (getValidProjects().length < selectedProjects.length) {
    setMessage(UIText.WizardProjectsImportPage_projectsInWorkspace,WARNING);
  }
 else {
    setMessage(UIText.WizardProjectsImportPage_ImportProjectsDescription);
  }
  setPageComplete(checkedItems.size() > 0);
}","/** 
 * Update the list of projects based on path. This will not check any projects.
 * @param path
 */
void setProjectsList(final String path){
  if (path == null || path.length() == 0) {
    setMessage(UIText.WizardProjectsImportPage_ImportProjectsDescription);
    selectedProjects=new ProjectRecord[0];
    projectsList.refresh(true);
    setPageComplete(checkedItems.size() > 0);
    lastPath=path;
    return;
  }
  final File directory=new File(path);
  long modified=directory.lastModified();
  if (path.equals(lastPath) && lastModified == modified) {
    return;
  }
  lastPath=path;
  lastModified=modified;
  try {
    getContainer().run(true,true,new IRunnableWithProgress(){
      public void run(      IProgressMonitor monitor){
        monitor.beginTask(UIText.WizardProjectsImportPage_SearchingMessage,100);
        selectedProjects=new ProjectRecord[0];
        Collection<File> files=new ArrayList<File>();
        monitor.worked(10);
        if (directory.isDirectory()) {
          if (!collectProjectFilesFromDirectory(files,directory,null,monitor)) {
            return;
          }
          Iterator<File> filesIterator=files.iterator();
          selectedProjects=new ProjectRecord[files.size()];
          int index=0;
          monitor.worked(50);
          monitor.subTask(UIText.WizardProjectsImportPage_ProcessingMessage);
          while (filesIterator.hasNext()) {
            File file=filesIterator.next();
            selectedProjects[index]=new ProjectRecord(file);
            checkedItems.add(selectedProjects[index]);
            index++;
          }
        }
 else {
          monitor.worked(60);
        }
        monitor.done();
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    IDEWorkbenchPlugin.log(e.getMessage(),e);
  }
catch (  InterruptedException e) {
  }
  projectsList.refresh(true);
  if (getValidProjects().length < selectedProjects.length) {
    setMessage(UIText.WizardProjectsImportPage_projectsInWorkspace,WARNING);
  }
 else {
    setMessage(UIText.WizardProjectsImportPage_ImportProjectsDescription);
  }
  enableSelectAllButtons();
  setPageComplete(checkedItems.size() > 0);
}",0.9934609995329284
91647,"@Override public void setFocus(){
}","@Override public void setFocus(){
  tv.getTree().setFocus();
}",0.7216494845360825
91648,"/** 
 * Create the selection buttons in the listComposite.
 * @param listComposite
 */
private void createSelectionButtons(Composite listComposite){
  Composite buttonsComposite=new Composite(listComposite,SWT.NONE);
  GridLayout layout=new GridLayout();
  layout.marginWidth=0;
  layout.marginHeight=0;
  buttonsComposite.setLayout(layout);
  buttonsComposite.setLayoutData(new GridData(GridData.VERTICAL_ALIGN_BEGINNING));
  Button selectAll=new Button(buttonsComposite,SWT.PUSH);
  selectAll.setText(UIText.WizardProjectsImportPage_selectAll);
  selectAll.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent e){
      checkedItems.clear();
      for (      final TreeItem item : projectsList.getTree().getItems()) {
        item.setChecked(true);
        checkedItems.add(item.getData());
      }
      setPageComplete(true);
    }
  }
);
  Dialog.applyDialogFont(selectAll);
  setButtonLayoutData(selectAll);
  Button deselectAll=new Button(buttonsComposite,SWT.PUSH);
  deselectAll.setText(UIText.WizardProjectsImportPage_deselectAll);
  deselectAll.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent e){
      checkedItems.clear();
      for (      final TreeItem item : projectsList.getTree().getItems()) {
        item.setChecked(false);
      }
      projectsList.setInput(this);
      setPageComplete(false);
    }
  }
);
  Dialog.applyDialogFont(deselectAll);
  setButtonLayoutData(deselectAll);
}","/** 
 * Create the selection buttons in the listComposite.
 * @param listComposite
 */
private void createSelectionButtons(Composite listComposite){
  Composite buttonsComposite=new Composite(listComposite,SWT.NONE);
  GridLayout layout=new GridLayout();
  layout.marginWidth=0;
  layout.marginHeight=0;
  buttonsComposite.setLayout(layout);
  buttonsComposite.setLayoutData(new GridData(GridData.VERTICAL_ALIGN_BEGINNING));
  selectAll=new Button(buttonsComposite,SWT.PUSH);
  selectAll.setText(UIText.WizardProjectsImportPage_selectAll);
  selectAll.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent e){
      checkedItems.clear();
      for (      final TreeItem item : projectsList.getTree().getItems()) {
        item.setChecked(true);
        checkedItems.add(item.getData());
      }
      setPageComplete(true);
    }
  }
);
  Dialog.applyDialogFont(selectAll);
  setButtonLayoutData(selectAll);
  deselectAll=new Button(buttonsComposite,SWT.PUSH);
  deselectAll.setText(UIText.WizardProjectsImportPage_deselectAll);
  deselectAll.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent e){
      checkedItems.clear();
      for (      final TreeItem item : projectsList.getTree().getItems()) {
        item.setChecked(false);
      }
      projectsList.setInput(this);
      setPageComplete(false);
    }
  }
);
  Dialog.applyDialogFont(deselectAll);
  setButtonLayoutData(deselectAll);
}",0.9952956989247312
91649,"/** 
 * Create the checkbox list for the found projects.
 * @param workArea
 */
private void createProjectsList(Composite workArea){
  checkedItems.clear();
  Label title=new Label(workArea,SWT.NONE);
  title.setText(UIText.WizardProjectsImportPage_ProjectsListTitle);
  Composite listComposite=new Composite(workArea,SWT.NONE);
  GridLayout layout=new GridLayout();
  layout.numColumns=2;
  layout.marginWidth=0;
  layout.makeColumnsEqualWidth=false;
  listComposite.setLayout(layout);
  listComposite.setLayoutData(new GridData(GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL | GridData.FILL_BOTH));
  PatternFilter filter=new PatternFilter(){
    @Override public boolean isElementVisible(    Viewer viewer,    Object element){
      if (checkedItems.contains(element)) {
        return true;
      }
      return super.isElementVisible(viewer,element);
    }
  }
;
  FilteredTree filteredTree=new FilteredTree(listComposite,SWT.CHECK | SWT.BORDER,filter);
  filteredTree.setInitialText(UIText.WizardProjectsImportPage_filterText);
  projectsList=filteredTree.getViewer();
  GridData listData=new GridData(GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL | GridData.FILL_BOTH);
  projectsList.getControl().setLayoutData(listData);
  projectsList.setContentProvider(new ITreeContentProvider(){
    public Object[] getChildren(    Object parentElement){
      return null;
    }
    public Object[] getElements(    Object inputElement){
      return getValidProjects();
    }
    public boolean hasChildren(    Object element){
      return false;
    }
    public Object getParent(    Object element){
      return null;
    }
    public void dispose(){
    }
    public void inputChanged(    Viewer viewer,    Object oldInput,    Object newInput){
    }
  }
);
  projectsList.getTree().addMouseListener(new MouseAdapter(){
    @Override public void mouseUp(    MouseEvent e){
      if (e.widget instanceof Tree) {
        TreeItem item=((Tree)e.widget).getItem(new Point(e.x,e.y));
        if (item != null) {
          if (item.getChecked())           checkedItems.add(item.getData());
 else           checkedItems.remove(item.getData());
          setPageComplete(!checkedItems.isEmpty());
        }
      }
    }
  }
);
  projectsList.setLabelProvider(new LabelProvider(){
    public String getText(    Object element){
      for (      final TreeItem item : projectsList.getTree().getItems()) {
        if (checkedItems.contains(item.getData()))         item.setChecked(true);
 else         item.setChecked(false);
      }
      return ((ProjectRecord)element).getProjectLabel();
    }
  }
);
  projectsList.setInput(this);
  projectsList.setComparator(new ViewerComparator());
  createSelectionButtons(listComposite);
}","/** 
 * Create the checkbox list for the found projects.
 * @param workArea
 */
private void createProjectsList(Composite workArea){
  checkedItems.clear();
  Label title=new Label(workArea,SWT.NONE);
  title.setText(UIText.WizardProjectsImportPage_ProjectsListTitle);
  Composite listComposite=new Composite(workArea,SWT.NONE);
  GridLayout layout=new GridLayout();
  layout.numColumns=2;
  layout.marginWidth=0;
  layout.makeColumnsEqualWidth=false;
  listComposite.setLayout(layout);
  listComposite.setLayoutData(new GridData(GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL | GridData.FILL_BOTH));
  PatternFilter filter=new PatternFilter(){
    @Override public boolean isElementVisible(    Viewer viewer,    Object element){
      if (checkedItems.contains(element)) {
        return true;
      }
      return super.isElementVisible(viewer,element);
    }
    @Override public void setPattern(    String patternString){
      super.setPattern(patternString);
      Display.getDefault().asyncExec(new Runnable(){
        public void run(){
          enableSelectAllButtons();
        }
      }
);
    }
  }
;
  FilteredTree filteredTree=new FilteredTree(listComposite,SWT.CHECK | SWT.BORDER,filter);
  filteredTree.setInitialText(UIText.WizardProjectsImportPage_filterText);
  projectsList=filteredTree.getViewer();
  GridData listData=new GridData(GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL | GridData.FILL_BOTH);
  projectsList.getControl().setLayoutData(listData);
  projectsList.setContentProvider(new ITreeContentProvider(){
    public Object[] getChildren(    Object parentElement){
      return null;
    }
    public Object[] getElements(    Object inputElement){
      return getValidProjects();
    }
    public boolean hasChildren(    Object element){
      return false;
    }
    public Object getParent(    Object element){
      return null;
    }
    public void dispose(){
    }
    public void inputChanged(    Viewer viewer,    Object oldInput,    Object newInput){
    }
  }
);
  projectsList.getTree().addMouseListener(new MouseAdapter(){
    @Override public void mouseUp(    MouseEvent e){
      if (e.widget instanceof Tree) {
        TreeItem item=((Tree)e.widget).getItem(new Point(e.x,e.y));
        if (item != null) {
          if (item.getChecked())           checkedItems.add(item.getData());
 else           checkedItems.remove(item.getData());
          setPageComplete(!checkedItems.isEmpty());
        }
      }
    }
  }
);
  projectsList.setLabelProvider(new LabelProvider(){
    public String getText(    Object element){
      for (      final TreeItem item : projectsList.getTree().getItems()) {
        if (checkedItems.contains(item.getData()))         item.setChecked(true);
 else         item.setChecked(false);
      }
      return ((ProjectRecord)element).getProjectLabel();
    }
  }
);
  projectsList.setInput(this);
  projectsList.setComparator(new ViewerComparator());
  createSelectionButtons(listComposite);
}",0.9568874868559412
91650,"/** 
 * Update the list of projects based on path. This will not check any projects.
 * @param path
 */
void setProjectsList(final String path){
  if (path == null || path.length() == 0) {
    setMessage(UIText.WizardProjectsImportPage_ImportProjectsDescription);
    selectedProjects=new ProjectRecord[0];
    projectsList.refresh(true);
    setPageComplete(checkedItems.size() > 0);
    lastPath=path;
    return;
  }
  final File directory=new File(path);
  long modified=directory.lastModified();
  if (path.equals(lastPath) && lastModified == modified) {
    return;
  }
  lastPath=path;
  lastModified=modified;
  try {
    getContainer().run(true,true,new IRunnableWithProgress(){
      public void run(      IProgressMonitor monitor){
        monitor.beginTask(UIText.WizardProjectsImportPage_SearchingMessage,100);
        selectedProjects=new ProjectRecord[0];
        Collection<File> files=new ArrayList<File>();
        monitor.worked(10);
        if (directory.isDirectory()) {
          if (!collectProjectFilesFromDirectory(files,directory,null,monitor)) {
            return;
          }
          Iterator<File> filesIterator=files.iterator();
          selectedProjects=new ProjectRecord[files.size()];
          int index=0;
          monitor.worked(50);
          monitor.subTask(UIText.WizardProjectsImportPage_ProcessingMessage);
          while (filesIterator.hasNext()) {
            File file=filesIterator.next();
            selectedProjects[index]=new ProjectRecord(file);
            checkedItems.add(selectedProjects[index]);
            index++;
          }
        }
 else {
          monitor.worked(60);
        }
        monitor.done();
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    IDEWorkbenchPlugin.log(e.getMessage(),e);
  }
catch (  InterruptedException e) {
  }
  projectsList.refresh(true);
  if (getValidProjects().length < selectedProjects.length) {
    setMessage(UIText.WizardProjectsImportPage_projectsInWorkspace,WARNING);
  }
 else {
    setMessage(UIText.WizardProjectsImportPage_ImportProjectsDescription);
  }
  setPageComplete(checkedItems.size() > 0);
}","/** 
 * Update the list of projects based on path. This will not check any projects.
 * @param path
 */
void setProjectsList(final String path){
  if (path == null || path.length() == 0) {
    setMessage(UIText.WizardProjectsImportPage_ImportProjectsDescription);
    selectedProjects=new ProjectRecord[0];
    projectsList.refresh(true);
    setPageComplete(checkedItems.size() > 0);
    lastPath=path;
    return;
  }
  final File directory=new File(path);
  long modified=directory.lastModified();
  if (path.equals(lastPath) && lastModified == modified) {
    return;
  }
  lastPath=path;
  lastModified=modified;
  try {
    getContainer().run(true,true,new IRunnableWithProgress(){
      public void run(      IProgressMonitor monitor){
        monitor.beginTask(UIText.WizardProjectsImportPage_SearchingMessage,100);
        selectedProjects=new ProjectRecord[0];
        Collection<File> files=new ArrayList<File>();
        monitor.worked(10);
        if (directory.isDirectory()) {
          if (!collectProjectFilesFromDirectory(files,directory,null,monitor)) {
            return;
          }
          Iterator<File> filesIterator=files.iterator();
          selectedProjects=new ProjectRecord[files.size()];
          int index=0;
          monitor.worked(50);
          monitor.subTask(UIText.WizardProjectsImportPage_ProcessingMessage);
          while (filesIterator.hasNext()) {
            File file=filesIterator.next();
            selectedProjects[index]=new ProjectRecord(file);
            checkedItems.add(selectedProjects[index]);
            index++;
          }
        }
 else {
          monitor.worked(60);
        }
        monitor.done();
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    IDEWorkbenchPlugin.log(e.getMessage(),e);
  }
catch (  InterruptedException e) {
  }
  projectsList.refresh(true);
  if (getValidProjects().length < selectedProjects.length) {
    setMessage(UIText.WizardProjectsImportPage_projectsInWorkspace,WARNING);
  }
 else {
    setMessage(UIText.WizardProjectsImportPage_ImportProjectsDescription);
  }
  enableSelectAllButtons();
  setPageComplete(checkedItems.size() > 0);
}",0.9934609995329284
91651,"public void run(){
  handle(e,UIText.BranchAction_errorSwitchingBranches,UIText.BranchAction_unableToSwitchBranches);
}","public void run(){
  handle(new TeamException(e.getStatus()),UIText.BranchAction_errorSwitchingBranches,UIText.BranchAction_unableToSwitchBranches);
}",0.8847583643122676
91652,"@Override public void execute(IAction action) throws InvocationTargetException {
  final Repository repository=getRepository(true);
  if (repository == null)   return;
  if (!repository.getRepositoryState().canCheckout()) {
    MessageDialog.openError(getShell(),UIText.BranchAction_cannotCheckout,NLS.bind(UIText.BranchAction_repositoryState,repository.getRepositoryState().getDescription()));
    return;
  }
  BranchSelectionDialog dialog=new BranchSelectionDialog(getShell(),repository);
  dialog.setShowResetType(false);
  if (dialog.open() != IDialogConstants.OK_ID) {
    return;
  }
  final String refName=dialog.getRefName();
  try {
    getTargetPart().getSite().getWorkbenchWindow().run(true,false,new IRunnableWithProgress(){
      public void run(      final IProgressMonitor monitor) throws InvocationTargetException {
        try {
          new BranchOperation(repository,refName).run(monitor);
          GitLightweightDecorator.refresh();
        }
 catch (        final CoreException e) {
          if (GitTraceLocation.UI.isActive())           GitTraceLocation.getTrace().trace(GitTraceLocation.UI.getLocation(),e.getMessage(),e);
          Display.getDefault().asyncExec(new Runnable(){
            public void run(){
              handle(e,UIText.BranchAction_errorSwitchingBranches,UIText.BranchAction_unableToSwitchBranches);
            }
          }
);
        }
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    if (GitTraceLocation.UI.isActive())     GitTraceLocation.getTrace().trace(GitTraceLocation.UI.getLocation(),e.getMessage(),e);
  }
catch (  InterruptedException e) {
    if (GitTraceLocation.UI.isActive())     GitTraceLocation.getTrace().trace(GitTraceLocation.UI.getLocation(),e.getMessage(),e);
  }
}","@Override public void execute(IAction action) throws InvocationTargetException, InterruptedException {
  final Repository repository=getRepository(true);
  if (repository == null)   return;
  if (!repository.getRepositoryState().canCheckout()) {
    MessageDialog.openError(getShell(),UIText.BranchAction_cannotCheckout,NLS.bind(UIText.BranchAction_repositoryState,repository.getRepositoryState().getDescription()));
    return;
  }
  BranchSelectionDialog dialog=new BranchSelectionDialog(getShell(),repository);
  dialog.setShowResetType(false);
  if (dialog.open() != IDialogConstants.OK_ID) {
    return;
  }
  final String refName=dialog.getRefName();
  try {
    getTargetPart().getSite().getWorkbenchWindow().run(true,false,new IRunnableWithProgress(){
      public void run(      final IProgressMonitor monitor) throws InvocationTargetException {
        try {
          new BranchOperation(repository,refName).run(monitor);
          GitLightweightDecorator.refresh();
        }
 catch (        final CoreException e) {
          if (GitTraceLocation.UI.isActive())           GitTraceLocation.getTrace().trace(GitTraceLocation.UI.getLocation(),e.getMessage(),e);
          Display.getDefault().asyncExec(new Runnable(){
            public void run(){
              handle(new TeamException(e.getStatus()),UIText.BranchAction_errorSwitchingBranches,UIText.BranchAction_unableToSwitchBranches);
            }
          }
);
        }
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    if (GitTraceLocation.UI.isActive())     GitTraceLocation.getTrace().trace(GitTraceLocation.UI.getLocation(),e.getMessage(),e);
    throw e;
  }
catch (  InterruptedException e) {
    if (GitTraceLocation.UI.isActive())     GitTraceLocation.getTrace().trace(GitTraceLocation.UI.getLocation(),e.getMessage(),e);
    throw new InvocationTargetException(e);
  }
}",0.9690778575372724
91653,"@Override public void execute(IAction act){
  resetState();
  try {
    buildIndexHeadDiffList();
  }
 catch (  IOException e) {
    Utils.handleError(getTargetPart().getSite().getShell(),e,UIText.CommitAction_errorDuringCommit,UIText.CommitAction_errorComputingDiffs);
    return;
  }
  Repository[] repos=getRepositoriesFor(getProjectsForSelectedResources());
  Repository repository=null;
  amendAllowed=repos.length == 1;
  for (  Repository repo : repos) {
    repository=repo;
    if (!repo.getRepositoryState().canCommit()) {
      MessageDialog.openError(getTargetPart().getSite().getShell(),UIText.CommitAction_cannotCommit,NLS.bind(UIText.CommitAction_repositoryState,repo.getRepositoryState().getDescription()));
      return;
    }
  }
  loadPreviousCommit();
  if (files.isEmpty()) {
    if (amendAllowed && previousCommit != null) {
      boolean result=MessageDialog.openQuestion(getTargetPart().getSite().getShell(),UIText.CommitAction_noFilesToCommit,UIText.CommitAction_amendCommit);
      if (!result)       return;
      amending=true;
    }
 else {
      MessageDialog.openWarning(getTargetPart().getSite().getShell(),UIText.CommitAction_noFilesToCommit,UIText.CommitAction_amendNotPossible);
      return;
    }
  }
  String author=null;
  String committer=null;
  if (repository != null) {
    final RepositoryConfig config=repository.getConfig();
    author=config.getAuthorName();
    final String authorEmail=config.getAuthorEmail();
    author=author + ""String_Node_Str"" + authorEmail+ ""String_Node_Str"";
    committer=config.getCommitterName();
    final String committerEmail=config.getCommitterEmail();
    committer=committer + ""String_Node_Str"" + committerEmail+ ""String_Node_Str"";
  }
  CommitDialog commitDialog=new CommitDialog(getTargetPart().getSite().getShell());
  commitDialog.setAmending(amending);
  commitDialog.setAmendAllowed(amendAllowed);
  commitDialog.setFileList(files);
  commitDialog.setAuthor(author);
  commitDialog.setCommitter(committer);
  if (previousCommit != null) {
    commitDialog.setPreviousCommitMessage(previousCommit.getMessage());
    PersonIdent previousAuthor=previousCommit.getAuthor();
    commitDialog.setPreviousAuthor(previousAuthor.getName() + ""String_Node_Str"" + previousAuthor.getEmailAddress()+ ""String_Node_Str"");
  }
  if (commitDialog.open() != IDialogConstants.OK_ID)   return;
  String commitMessage=commitDialog.getCommitMessage();
  amending=commitDialog.isAmending();
  try {
    performCommit(commitDialog,commitMessage);
  }
 catch (  TeamException e) {
    Utils.handleError(getTargetPart().getSite().getShell(),e,UIText.CommitAction_errorDuringCommit,UIText.CommitAction_errorOnCommit);
  }
}","@Override public void execute(IAction act){
  resetState();
  try {
    buildIndexHeadDiffList();
  }
 catch (  IOException e) {
    handle(new TeamException(UIText.CommitAction_errorComputingDiffs,e),UIText.CommitAction_errorDuringCommit,UIText.CommitAction_errorComputingDiffs);
    return;
  }
  Repository[] repos=getRepositoriesFor(getProjectsForSelectedResources());
  Repository repository=null;
  amendAllowed=repos.length == 1;
  for (  Repository repo : repos) {
    repository=repo;
    if (!repo.getRepositoryState().canCommit()) {
      MessageDialog.openError(getTargetPart().getSite().getShell(),UIText.CommitAction_cannotCommit,NLS.bind(UIText.CommitAction_repositoryState,repo.getRepositoryState().getDescription()));
      return;
    }
  }
  loadPreviousCommit();
  if (files.isEmpty()) {
    if (amendAllowed && previousCommit != null) {
      boolean result=MessageDialog.openQuestion(getTargetPart().getSite().getShell(),UIText.CommitAction_noFilesToCommit,UIText.CommitAction_amendCommit);
      if (!result)       return;
      amending=true;
    }
 else {
      MessageDialog.openWarning(getTargetPart().getSite().getShell(),UIText.CommitAction_noFilesToCommit,UIText.CommitAction_amendNotPossible);
      return;
    }
  }
  String author=null;
  String committer=null;
  if (repository != null) {
    final RepositoryConfig config=repository.getConfig();
    author=config.getAuthorName();
    final String authorEmail=config.getAuthorEmail();
    author=author + ""String_Node_Str"" + authorEmail+ ""String_Node_Str"";
    committer=config.getCommitterName();
    final String committerEmail=config.getCommitterEmail();
    committer=committer + ""String_Node_Str"" + committerEmail+ ""String_Node_Str"";
  }
  CommitDialog commitDialog=new CommitDialog(getTargetPart().getSite().getShell());
  commitDialog.setAmending(amending);
  commitDialog.setAmendAllowed(amendAllowed);
  commitDialog.setFileList(files);
  commitDialog.setAuthor(author);
  commitDialog.setCommitter(committer);
  if (previousCommit != null) {
    commitDialog.setPreviousCommitMessage(previousCommit.getMessage());
    PersonIdent previousAuthor=previousCommit.getAuthor();
    commitDialog.setPreviousAuthor(previousAuthor.getName() + ""String_Node_Str"" + previousAuthor.getEmailAddress()+ ""String_Node_Str"");
  }
  if (commitDialog.open() != IDialogConstants.OK_ID)   return;
  String commitMessage=commitDialog.getCommitMessage();
  amending=commitDialog.isAmending();
  try {
    performCommit(commitDialog,commitMessage);
  }
 catch (  TeamException e) {
    handle(e,UIText.CommitAction_errorDuringCommit,UIText.CommitAction_errorOnCommit);
  }
}",0.9690373428410584
91654,"public void contentChanged(IContentChangeNotifier source){
  final byte[] newContent=next.getModifiedContent();
  try {
    final GitIndex index=repository.getIndex();
    final File file=new File(baseFile.getLocation().toString());
    index.add(mapping.getWorkDir(),file,newContent);
    index.write();
  }
 catch (  IOException e) {
    Utils.handleError(getTargetPart().getSite().getShell(),e,UIText.CompareWithIndexAction_errorOnAddToIndex,UIText.CompareWithIndexAction_errorOnAddToIndex);
    return;
  }
}","public void contentChanged(IContentChangeNotifier source){
  final byte[] newContent=next.getModifiedContent();
  try {
    final GitIndex index=repository.getIndex();
    final File file=new File(baseFile.getLocation().toString());
    index.add(mapping.getWorkDir(),file,newContent);
    index.write();
  }
 catch (  IOException e) {
    handle(new TeamException(UIText.CompareWithIndexAction_errorOnAddToIndex,e),UIText.CompareWithIndexAction_errorOnAddToIndex,UIText.CompareWithIndexAction_errorOnAddToIndex);
    return;
  }
}",0.8801534036433365
91655,"@Override public void execute(IAction action){
  final IResource resource=getSelectedResources()[0];
  final RepositoryMapping mapping=RepositoryMapping.getMapping(resource.getProject());
  final Repository repository=mapping.getRepository();
  final String gitPath=mapping.getRepoRelativePath(resource);
  final IFileRevision nextFile=GitFileRevision.inIndex(repository,gitPath);
  final IFile baseFile=(IFile)resource;
  final ITypedElement base=SaveableCompareEditorInput.createFileElement(baseFile);
  final EditableRevision next=new EditableRevision(nextFile);
  IContentChangeListener listener=new IContentChangeListener(){
    public void contentChanged(    IContentChangeNotifier source){
      final byte[] newContent=next.getModifiedContent();
      try {
        final GitIndex index=repository.getIndex();
        final File file=new File(baseFile.getLocation().toString());
        index.add(mapping.getWorkDir(),file,newContent);
        index.write();
      }
 catch (      IOException e) {
        Utils.handleError(getTargetPart().getSite().getShell(),e,UIText.CompareWithIndexAction_errorOnAddToIndex,UIText.CompareWithIndexAction_errorOnAddToIndex);
        return;
      }
    }
  }
;
  next.addContentChangeListener(listener);
  final GitCompareFileRevisionEditorInput in=new GitCompareFileRevisionEditorInput(base,next,null);
  CompareUI.openCompareEditor(in);
}","@Override public void execute(IAction action){
  final IResource resource=getSelectedResources()[0];
  final RepositoryMapping mapping=RepositoryMapping.getMapping(resource.getProject());
  final Repository repository=mapping.getRepository();
  final String gitPath=mapping.getRepoRelativePath(resource);
  final IFileRevision nextFile=GitFileRevision.inIndex(repository,gitPath);
  final IFile baseFile=(IFile)resource;
  final ITypedElement base=SaveableCompareEditorInput.createFileElement(baseFile);
  final EditableRevision next=new EditableRevision(nextFile);
  IContentChangeListener listener=new IContentChangeListener(){
    public void contentChanged(    IContentChangeNotifier source){
      final byte[] newContent=next.getModifiedContent();
      try {
        final GitIndex index=repository.getIndex();
        final File file=new File(baseFile.getLocation().toString());
        index.add(mapping.getWorkDir(),file,newContent);
        index.write();
      }
 catch (      IOException e) {
        handle(new TeamException(UIText.CompareWithIndexAction_errorOnAddToIndex,e),UIText.CompareWithIndexAction_errorOnAddToIndex,UIText.CompareWithIndexAction_errorOnAddToIndex);
        return;
      }
    }
  }
;
  next.addContentChangeListener(listener);
  final GitCompareFileRevisionEditorInput in=new GitCompareFileRevisionEditorInput(base,next,null);
  CompareUI.openCompareEditor(in);
}",0.956584140653032
91656,"public void run(){
  handle(e,UIText.BranchAction_errorSwitchingBranches,UIText.BranchAction_unableToSwitchBranches);
}","public void run(){
  handle(new TeamException(e.getStatus()),UIText.BranchAction_errorSwitchingBranches,UIText.BranchAction_unableToSwitchBranches);
}",0.8847583643122676
91657,"@Override public void execute(IAction action) throws InvocationTargetException {
  final Repository repository=getRepository(true);
  if (repository == null)   return;
  if (!repository.getRepositoryState().canCheckout()) {
    MessageDialog.openError(getShell(),UIText.BranchAction_cannotCheckout,NLS.bind(UIText.BranchAction_repositoryState,repository.getRepositoryState().getDescription()));
    return;
  }
  BranchSelectionDialog dialog=new BranchSelectionDialog(getShell(),repository);
  dialog.setShowResetType(false);
  if (dialog.open() != IDialogConstants.OK_ID) {
    return;
  }
  final String refName=dialog.getRefName();
  try {
    getTargetPart().getSite().getWorkbenchWindow().run(true,false,new IRunnableWithProgress(){
      public void run(      final IProgressMonitor monitor) throws InvocationTargetException {
        try {
          new BranchOperation(repository,refName).run(monitor);
          GitLightweightDecorator.refresh();
        }
 catch (        final CoreException e) {
          if (GitTraceLocation.UI.isActive())           GitTraceLocation.getTrace().trace(GitTraceLocation.UI.getLocation(),e.getMessage(),e);
          Display.getDefault().asyncExec(new Runnable(){
            public void run(){
              handle(e,UIText.BranchAction_errorSwitchingBranches,UIText.BranchAction_unableToSwitchBranches);
            }
          }
);
        }
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    if (GitTraceLocation.UI.isActive())     GitTraceLocation.getTrace().trace(GitTraceLocation.UI.getLocation(),e.getMessage(),e);
  }
catch (  InterruptedException e) {
    if (GitTraceLocation.UI.isActive())     GitTraceLocation.getTrace().trace(GitTraceLocation.UI.getLocation(),e.getMessage(),e);
  }
}","@Override public void execute(IAction action) throws InvocationTargetException, InterruptedException {
  final Repository repository=getRepository(true);
  if (repository == null)   return;
  if (!repository.getRepositoryState().canCheckout()) {
    MessageDialog.openError(getShell(),UIText.BranchAction_cannotCheckout,NLS.bind(UIText.BranchAction_repositoryState,repository.getRepositoryState().getDescription()));
    return;
  }
  BranchSelectionDialog dialog=new BranchSelectionDialog(getShell(),repository);
  dialog.setShowResetType(false);
  if (dialog.open() != IDialogConstants.OK_ID) {
    return;
  }
  final String refName=dialog.getRefName();
  try {
    getTargetPart().getSite().getWorkbenchWindow().run(true,false,new IRunnableWithProgress(){
      public void run(      final IProgressMonitor monitor) throws InvocationTargetException {
        try {
          new BranchOperation(repository,refName).run(monitor);
          GitLightweightDecorator.refresh();
        }
 catch (        final CoreException e) {
          if (GitTraceLocation.UI.isActive())           GitTraceLocation.getTrace().trace(GitTraceLocation.UI.getLocation(),e.getMessage(),e);
          Display.getDefault().asyncExec(new Runnable(){
            public void run(){
              handle(new TeamException(e.getStatus()),UIText.BranchAction_errorSwitchingBranches,UIText.BranchAction_unableToSwitchBranches);
            }
          }
);
        }
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    if (GitTraceLocation.UI.isActive())     GitTraceLocation.getTrace().trace(GitTraceLocation.UI.getLocation(),e.getMessage(),e);
    throw e;
  }
catch (  InterruptedException e) {
    if (GitTraceLocation.UI.isActive())     GitTraceLocation.getTrace().trace(GitTraceLocation.UI.getLocation(),e.getMessage(),e);
    throw new InvocationTargetException(e);
  }
}",0.9690778575372724
91658,"@Override public void execute(IAction act){
  resetState();
  try {
    buildIndexHeadDiffList();
  }
 catch (  IOException e) {
    Utils.handleError(getTargetPart().getSite().getShell(),e,UIText.CommitAction_errorDuringCommit,UIText.CommitAction_errorComputingDiffs);
    return;
  }
  Repository[] repos=getRepositoriesFor(getProjectsForSelectedResources());
  Repository repository=null;
  amendAllowed=repos.length == 1;
  for (  Repository repo : repos) {
    repository=repo;
    if (!repo.getRepositoryState().canCommit()) {
      MessageDialog.openError(getTargetPart().getSite().getShell(),UIText.CommitAction_cannotCommit,NLS.bind(UIText.CommitAction_repositoryState,repo.getRepositoryState().getDescription()));
      return;
    }
  }
  loadPreviousCommit();
  if (files.isEmpty()) {
    if (amendAllowed && previousCommit != null) {
      boolean result=MessageDialog.openQuestion(getTargetPart().getSite().getShell(),UIText.CommitAction_noFilesToCommit,UIText.CommitAction_amendCommit);
      if (!result)       return;
      amending=true;
    }
 else {
      MessageDialog.openWarning(getTargetPart().getSite().getShell(),UIText.CommitAction_noFilesToCommit,UIText.CommitAction_amendNotPossible);
      return;
    }
  }
  String author=null;
  String committer=null;
  if (repository != null) {
    final RepositoryConfig config=repository.getConfig();
    author=config.getAuthorName();
    final String authorEmail=config.getAuthorEmail();
    author=author + ""String_Node_Str"" + authorEmail+ ""String_Node_Str"";
    committer=config.getCommitterName();
    final String committerEmail=config.getCommitterEmail();
    committer=committer + ""String_Node_Str"" + committerEmail+ ""String_Node_Str"";
  }
  CommitDialog commitDialog=new CommitDialog(getTargetPart().getSite().getShell());
  commitDialog.setAmending(amending);
  commitDialog.setAmendAllowed(amendAllowed);
  commitDialog.setFileList(files);
  commitDialog.setAuthor(author);
  commitDialog.setCommitter(committer);
  if (previousCommit != null) {
    commitDialog.setPreviousCommitMessage(previousCommit.getMessage());
    PersonIdent previousAuthor=previousCommit.getAuthor();
    commitDialog.setPreviousAuthor(previousAuthor.getName() + ""String_Node_Str"" + previousAuthor.getEmailAddress()+ ""String_Node_Str"");
  }
  if (commitDialog.open() != IDialogConstants.OK_ID)   return;
  String commitMessage=commitDialog.getCommitMessage();
  amending=commitDialog.isAmending();
  try {
    performCommit(commitDialog,commitMessage);
  }
 catch (  TeamException e) {
    Utils.handleError(getTargetPart().getSite().getShell(),e,UIText.CommitAction_errorDuringCommit,UIText.CommitAction_errorOnCommit);
  }
}","@Override public void execute(IAction act){
  resetState();
  try {
    buildIndexHeadDiffList();
  }
 catch (  IOException e) {
    handle(new TeamException(UIText.CommitAction_errorComputingDiffs,e),UIText.CommitAction_errorDuringCommit,UIText.CommitAction_errorComputingDiffs);
    return;
  }
  Repository[] repos=getRepositoriesFor(getProjectsForSelectedResources());
  Repository repository=null;
  amendAllowed=repos.length == 1;
  for (  Repository repo : repos) {
    repository=repo;
    if (!repo.getRepositoryState().canCommit()) {
      MessageDialog.openError(getTargetPart().getSite().getShell(),UIText.CommitAction_cannotCommit,NLS.bind(UIText.CommitAction_repositoryState,repo.getRepositoryState().getDescription()));
      return;
    }
  }
  loadPreviousCommit();
  if (files.isEmpty()) {
    if (amendAllowed && previousCommit != null) {
      boolean result=MessageDialog.openQuestion(getTargetPart().getSite().getShell(),UIText.CommitAction_noFilesToCommit,UIText.CommitAction_amendCommit);
      if (!result)       return;
      amending=true;
    }
 else {
      MessageDialog.openWarning(getTargetPart().getSite().getShell(),UIText.CommitAction_noFilesToCommit,UIText.CommitAction_amendNotPossible);
      return;
    }
  }
  String author=null;
  String committer=null;
  if (repository != null) {
    final RepositoryConfig config=repository.getConfig();
    author=config.getAuthorName();
    final String authorEmail=config.getAuthorEmail();
    author=author + ""String_Node_Str"" + authorEmail+ ""String_Node_Str"";
    committer=config.getCommitterName();
    final String committerEmail=config.getCommitterEmail();
    committer=committer + ""String_Node_Str"" + committerEmail+ ""String_Node_Str"";
  }
  CommitDialog commitDialog=new CommitDialog(getTargetPart().getSite().getShell());
  commitDialog.setAmending(amending);
  commitDialog.setAmendAllowed(amendAllowed);
  commitDialog.setFileList(files);
  commitDialog.setAuthor(author);
  commitDialog.setCommitter(committer);
  if (previousCommit != null) {
    commitDialog.setPreviousCommitMessage(previousCommit.getMessage());
    PersonIdent previousAuthor=previousCommit.getAuthor();
    commitDialog.setPreviousAuthor(previousAuthor.getName() + ""String_Node_Str"" + previousAuthor.getEmailAddress()+ ""String_Node_Str"");
  }
  if (commitDialog.open() != IDialogConstants.OK_ID)   return;
  String commitMessage=commitDialog.getCommitMessage();
  amending=commitDialog.isAmending();
  try {
    performCommit(commitDialog,commitMessage);
  }
 catch (  TeamException e) {
    handle(e,UIText.CommitAction_errorDuringCommit,UIText.CommitAction_errorOnCommit);
  }
}",0.9690373428410584
91659,"public void contentChanged(IContentChangeNotifier source){
  final byte[] newContent=next.getModifiedContent();
  try {
    final GitIndex index=repository.getIndex();
    final File file=new File(baseFile.getLocation().toString());
    index.add(mapping.getWorkDir(),file,newContent);
    index.write();
  }
 catch (  IOException e) {
    Utils.handleError(getTargetPart().getSite().getShell(),e,UIText.CompareWithIndexAction_errorOnAddToIndex,UIText.CompareWithIndexAction_errorOnAddToIndex);
    return;
  }
}","public void contentChanged(IContentChangeNotifier source){
  final byte[] newContent=next.getModifiedContent();
  try {
    final GitIndex index=repository.getIndex();
    final File file=new File(baseFile.getLocation().toString());
    index.add(mapping.getWorkDir(),file,newContent);
    index.write();
  }
 catch (  IOException e) {
    handle(new TeamException(UIText.CompareWithIndexAction_errorOnAddToIndex,e),UIText.CompareWithIndexAction_errorOnAddToIndex,UIText.CompareWithIndexAction_errorOnAddToIndex);
    return;
  }
}",0.8801534036433365
91660,"@Override public void execute(IAction action){
  final IResource resource=getSelectedResources()[0];
  final RepositoryMapping mapping=RepositoryMapping.getMapping(resource.getProject());
  final Repository repository=mapping.getRepository();
  final String gitPath=mapping.getRepoRelativePath(resource);
  final IFileRevision nextFile=GitFileRevision.inIndex(repository,gitPath);
  final IFile baseFile=(IFile)resource;
  final ITypedElement base=SaveableCompareEditorInput.createFileElement(baseFile);
  final EditableRevision next=new EditableRevision(nextFile);
  IContentChangeListener listener=new IContentChangeListener(){
    public void contentChanged(    IContentChangeNotifier source){
      final byte[] newContent=next.getModifiedContent();
      try {
        final GitIndex index=repository.getIndex();
        final File file=new File(baseFile.getLocation().toString());
        index.add(mapping.getWorkDir(),file,newContent);
        index.write();
      }
 catch (      IOException e) {
        Utils.handleError(getTargetPart().getSite().getShell(),e,UIText.CompareWithIndexAction_errorOnAddToIndex,UIText.CompareWithIndexAction_errorOnAddToIndex);
        return;
      }
    }
  }
;
  next.addContentChangeListener(listener);
  final GitCompareFileRevisionEditorInput in=new GitCompareFileRevisionEditorInput(base,next,null);
  CompareUI.openCompareEditor(in);
}","@Override public void execute(IAction action){
  final IResource resource=getSelectedResources()[0];
  final RepositoryMapping mapping=RepositoryMapping.getMapping(resource.getProject());
  final Repository repository=mapping.getRepository();
  final String gitPath=mapping.getRepoRelativePath(resource);
  final IFileRevision nextFile=GitFileRevision.inIndex(repository,gitPath);
  final IFile baseFile=(IFile)resource;
  final ITypedElement base=SaveableCompareEditorInput.createFileElement(baseFile);
  final EditableRevision next=new EditableRevision(nextFile);
  IContentChangeListener listener=new IContentChangeListener(){
    public void contentChanged(    IContentChangeNotifier source){
      final byte[] newContent=next.getModifiedContent();
      try {
        final GitIndex index=repository.getIndex();
        final File file=new File(baseFile.getLocation().toString());
        index.add(mapping.getWorkDir(),file,newContent);
        index.write();
      }
 catch (      IOException e) {
        handle(new TeamException(UIText.CompareWithIndexAction_errorOnAddToIndex,e),UIText.CompareWithIndexAction_errorOnAddToIndex,UIText.CompareWithIndexAction_errorOnAddToIndex);
        return;
      }
    }
  }
;
  next.addContentChangeListener(listener);
  final GitCompareFileRevisionEditorInput in=new GitCompareFileRevisionEditorInput(base,next,null);
  CompareUI.openCompareEditor(in);
}",0.956584140653032
91661,"public void run(IProgressMonitor arg0) throws InvocationTargetException, InterruptedException {
  try {
    op.run(arg0);
  }
 catch (  CoreException e) {
    MessageDialog.openError(getShell(),""String_Node_Str"",e.getMessage());
  }
}","public void run(IProgressMonitor arg0) throws InvocationTargetException, InterruptedException {
  try {
    op.run(arg0);
  }
 catch (  CoreException e) {
    throw new InvocationTargetException(e);
  }
}",0.7671232876712328
91662,"/** 
 * Sets <code>module</code flag to <code>true</code> to classpath dependencies declared in module-info.java
 * @param facade a Maven facade project
 * @param classpath a classpath descriptor
 * @param monitor a progress monitor
 */
public static void configureClasspath(IMavenProjectFacade facade,IClasspathDescriptor classpath,IProgressMonitor monitor) throws CoreException {
  IJavaProject javaProject=JavaCore.create(facade.getProject());
  if (javaProject == null || !javaProject.exists()) {
    return;
  }
  if (monitor == null) {
    monitor=new NullProgressMonitor();
  }
  Set<String> requiredModules=getRequiredModules(javaProject,monitor);
  if (requiredModules.isEmpty() || classpath.getEntryDescriptors().isEmpty() || monitor.isCanceled()) {
    return;
  }
  List<IClasspathEntryDescriptor> entryDescriptors=classpath.getEntryDescriptors();
  Map<String,IClasspathEntryDescriptor> moduleMap=new HashMap<>(entryDescriptors.size());
  Map<IClasspathEntryDescriptor,String> descriptorsMap=new HashMap<>(entryDescriptors.size());
  for (  IClasspathEntryDescriptor entry : entryDescriptors) {
    if (monitor.isCanceled()) {
      return;
    }
    String moduleName=getModuleName(entry.getEntryKind(),entry.getPath(),monitor);
    moduleMap.put(moduleName,entry);
    descriptorsMap.put(entry,moduleName);
  }
  Set<String> visitedModules=new HashSet<>(entryDescriptors.size());
  collectTransitiveRequiredModules(requiredModules,visitedModules,moduleMap,monitor);
  if (monitor.isCanceled()) {
    return;
  }
  descriptorsMap.forEach((entry,module) -> {
    if (requiredModules.contains(module)) {
      entry.setClasspathAttribute(IClasspathAttribute.MODULE,Boolean.TRUE.toString());
    }
  }
);
}","/** 
 * Sets <code>module</code flag to <code>true</code> to classpath dependencies declared in module-info.java
 * @param facade    a Maven facade project
 * @param classpath a classpath descriptor
 * @param monitor   a progress monitor
 */
public static void configureClasspath(IMavenProjectFacade facade,IClasspathDescriptor classpath,IProgressMonitor monitor) throws CoreException {
  IJavaProject javaProject=JavaCore.create(facade.getProject());
  if (javaProject == null || !javaProject.exists()) {
    return;
  }
  if (monitor == null) {
    monitor=new NullProgressMonitor();
  }
  Set<String> requiredModules=new LinkedHashSet<>(getRequiredModules(javaProject,monitor));
  if (requiredModules.isEmpty() || classpath.getEntryDescriptors().isEmpty() || monitor.isCanceled()) {
    return;
  }
  List<IClasspathEntryDescriptor> entryDescriptors=classpath.getEntryDescriptors();
  Map<String,IClasspathEntryDescriptor> moduleMap=new HashMap<>(entryDescriptors.size());
  Map<IClasspathEntryDescriptor,String> descriptorsMap=new HashMap<>(entryDescriptors.size());
  for (  IClasspathEntryDescriptor entry : entryDescriptors) {
    if (monitor.isCanceled()) {
      return;
    }
    String moduleName=getModuleName(entry.getEntryKind(),entry.getPath(),monitor);
    moduleMap.put(moduleName,entry);
    descriptorsMap.put(entry,moduleName);
  }
  Set<String> visitedModules=new HashSet<>(entryDescriptors.size());
  collectTransitiveRequiredModules(requiredModules,visitedModules,moduleMap,monitor);
  if (monitor.isCanceled()) {
    return;
  }
  descriptorsMap.forEach((entry,module) -> {
    if (requiredModules.contains(module)) {
      entry.setClasspathAttribute(IClasspathAttribute.MODULE,Boolean.TRUE.toString());
    }
  }
);
}",0.992485549132948
91663,"protected int getArtifactScope(ILaunchConfiguration configuration) throws CoreException {
  String typeid=configuration.getType().getAttribute(""String_Node_Str"");
  if (JDT_JAVA_APPLICATION.equals(typeid)) {
    IResource[] resources=configuration.getMappedResources();
    if (resources == null || resources.length == 0) {
      return IClasspathManager.CLASSPATH_RUNTIME;
    }
    final Set<IPath> testSources=new HashSet<IPath>();
    IJavaProject javaProject=JavaRuntime.getJavaProject(configuration);
    IMavenProjectFacade facade=projectManager.create(javaProject.getProject(),new NullProgressMonitor());
    if (facade == null) {
      return IClasspathManager.CLASSPATH_RUNTIME;
    }
    testSources.addAll(Arrays.asList(facade.getTestCompileSourceLocations()));
    for (int i=0; i < resources.length; i++) {
      for (      IPath testPath : testSources) {
        if (testPath.isPrefixOf(resources[i].getProjectRelativePath())) {
          return IClasspathManager.CLASSPATH_TEST;
        }
      }
    }
    return IClasspathManager.CLASSPATH_RUNTIME;
  }
 else   if (JDT_JUNIT_TEST.equals(typeid) || JDT_TESTNG_TEST.equals(typeid)) {
    return IClasspathManager.CLASSPATH_TEST;
  }
 else {
    throw new CoreException(new Status(IStatus.ERROR,IMavenConstants.PLUGIN_ID,0,NLS.bind(Messages.MavenRuntimeClasspathProvider_error_unsupported,typeid),null));
  }
}","protected int getArtifactScope(ILaunchConfiguration configuration) throws CoreException {
  String typeid=configuration.getType().getAttribute(""String_Node_Str"");
  if (JDT_JAVA_APPLICATION.equals(typeid)) {
    IResource[] resources=configuration.getMappedResources();
    if (resources == null || resources.length == 0) {
      return IClasspathManager.CLASSPATH_RUNTIME;
    }
    final Set<IPath> testSources=new HashSet<IPath>();
    IJavaProject javaProject=JavaRuntime.getJavaProject(configuration);
    IMavenProjectFacade facade=projectManager.create(javaProject.getProject(),new NullProgressMonitor());
    if (facade == null) {
      return IClasspathManager.CLASSPATH_RUNTIME;
    }
    testSources.addAll(Arrays.asList(facade.getTestCompileSourceLocations()));
    testSources.addAll(getEclipseTestSources(javaProject));
    for (int i=0; i < resources.length; i++) {
      for (      IPath testPath : testSources) {
        if (testPath.isPrefixOf(resources[i].getProjectRelativePath())) {
          return IClasspathManager.CLASSPATH_TEST;
        }
      }
    }
    return IClasspathManager.CLASSPATH_RUNTIME;
  }
 else   if (JDT_JUNIT_TEST.equals(typeid) || JDT_TESTNG_TEST.equals(typeid)) {
    return IClasspathManager.CLASSPATH_TEST;
  }
 else {
    throw new CoreException(new Status(IStatus.ERROR,IMavenConstants.PLUGIN_ID,0,NLS.bind(Messages.MavenRuntimeClasspathProvider_error_unsupported,typeid),null));
  }
}",0.9786476868327402
91664,"@Override public void addErrorMarker(IResource resource,String type,MavenProblemInfo problem){
  IMarker marker=addMarker(resource,type,problem.getMessage(),problem.getLocation().getLineNumber(),problem.getSeverity());
  try {
    problem.processMarker(marker);
  }
 catch (  CoreException ex) {
    log.error(ex.getMessage(),ex);
  }
  MarkerUtils.decorateMarker(marker);
}","@Override public void addErrorMarker(IResource resource,String type,MavenProblemInfo problem){
  IMarker marker=addMarker(resource,type,problem.getMessage(),problem.getLocation().getLineNumber(),problem.getSeverity());
  if (marker == null) {
    return;
  }
  try {
    problem.processMarker(marker);
  }
 catch (  CoreException ex) {
    log.error(ex.getMessage(),ex);
  }
  MarkerUtils.decorateMarker(marker);
}",0.949238578680203
91665,"public String getMavenText(){
  if (element instanceof LifecycleStrategyMappingRequirement) {
    return NLS.bind(""String_Node_Str"",((LifecycleStrategyMappingRequirement)element).getLifecycleMappingId());
  }
 else   if (element instanceof MojoExecutionMappingRequirement) {
    MojoExecutionKey exec=((MojoExecutionMappingRequirement)element).getExecution();
    return NLS.bind(""String_Node_Str"",new String[]{exec.getArtifactId(),exec.getVersion(),exec.getGoal(),String.valueOf(content.size())});
  }
 else   if (element instanceof PackagingTypeMappingRequirement) {
    return NLS.bind(""String_Node_Str"",((PackagingTypeMappingRequirement)element).getPackaging());
  }
 else   if (element instanceof ProjectConfiguratorMappingRequirement) {
    return NLS.bind(""String_Node_Str"",((ProjectConfiguratorMappingRequirement)element).getProjectConfiguratorId());
  }
  throw new IllegalStateException();
}","public String getMavenText(){
  if (element instanceof LifecycleStrategyMappingRequirement) {
    return NLS.bind(""String_Node_Str"",((LifecycleStrategyMappingRequirement)element).getLifecycleMappingId());
  }
 else   if (element instanceof MojoExecutionMappingRequirement) {
    MojoExecutionKey exec=((MojoExecutionMappingRequirement)element).getExecution();
    return NLS.bind(""String_Node_Str"",new String[]{exec.getArtifactId(),exec.getVersion(),exec.getGoal(),String.valueOf(content.size())});
  }
 else   if (element instanceof PackagingTypeMappingRequirement) {
    return NLS.bind(""String_Node_Str"",((PackagingTypeMappingRequirement)element).getPackaging());
  }
 else   if (element instanceof ProjectConfiguratorMappingRequirement) {
    MojoExecutionKey exec=((ProjectConfiguratorMappingRequirement)element).getExecution();
    return NLS.bind(""String_Node_Str"",new String[]{exec.getArtifactId(),exec.getVersion(),exec.getGoal(),String.valueOf(content.size())});
  }
  throw new IllegalStateException();
}",0.8663883089770354
91666,"private static ILifecycleMappingRequirement toLifecycleMappingRequirement(IMarker marker,String packagingType){
  String type=marker.getAttribute(IMavenConstants.MARKER_ATTR_EDITOR_HINT,null);
  if (type == null) {
    return null;
  }
  ILifecycleMappingRequirement requirement=null;
  if (IMavenConstants.EDITOR_HINT_NOT_COVERED_MOJO_EXECUTION.equals(type)) {
    MojoExecutionKey mek=MarkerUtils.getMojoExecution(marker);
    if (mek != null) {
      requirement=new MojoExecutionMappingRequirement(mek,packagingType);
    }
  }
 else   if (IMavenConstants.EDITOR_HINT_UNKNOWN_LIFECYCLE_ID.equals(type)) {
    String lifecycleId=getLifecycleId(marker);
    if (lifecycleId != null) {
      requirement=new LifecycleStrategyMappingRequirement(null,lifecycleId);
    }
  }
 else   if (IMavenConstants.EDITOR_HINT_MISSING_CONFIGURATOR.equals(type)) {
    String configuratorId=getConfiguratorId(marker);
    if (configuratorId != null) {
      requirement=new ProjectConfiguratorMappingRequirement(null,configuratorId);
    }
  }
  return requirement;
}","private static ILifecycleMappingRequirement toLifecycleMappingRequirement(IMarker marker,String packagingType){
  String type=marker.getAttribute(IMavenConstants.MARKER_ATTR_EDITOR_HINT,null);
  if (type == null) {
    return null;
  }
  ILifecycleMappingRequirement requirement=null;
  if (IMavenConstants.EDITOR_HINT_NOT_COVERED_MOJO_EXECUTION.equals(type)) {
    MojoExecutionKey mek=MarkerUtils.getMojoExecution(marker);
    if (mek != null) {
      requirement=new MojoExecutionMappingRequirement(mek,packagingType);
    }
  }
 else   if (IMavenConstants.EDITOR_HINT_UNKNOWN_LIFECYCLE_ID.equals(type)) {
    String lifecycleId=getLifecycleId(marker);
    if (lifecycleId != null) {
      requirement=new LifecycleStrategyMappingRequirement(null,lifecycleId);
    }
  }
 else   if (IMavenConstants.EDITOR_HINT_MISSING_CONFIGURATOR.equals(type)) {
    String configuratorId=getConfiguratorId(marker);
    MojoExecutionKey mek=MarkerUtils.getMojoExecution(marker);
    if (configuratorId != null) {
      requirement=new ProjectConfiguratorMappingRequirement(mek,configuratorId);
    }
  }
  return requirement;
}",0.9677121771217712
91667,"/** 
 * Create contents of the wizard.
 * @param parent
 */
public void createControl(Composite parent){
  Composite container=new Composite(parent,SWT.NULL);
  setControl(container);
  container.setLayout(new GridLayout(1,false));
  Composite treeViewerContainer=new Composite(container,SWT.NULL);
  GridDataFactory.fillDefaults().grab(true,false).applyTo(treeViewerContainer);
  TreeColumnLayout treeColumnLayout=new TreeColumnLayout();
  treeViewerContainer.setLayout(treeColumnLayout);
  treeViewer=new TreeViewer(treeViewerContainer,SWT.BORDER | SWT.FULL_SELECTION);
  Tree tree=treeViewer.getTree();
  tree.setLinesVisible(true);
  tree.setHeaderVisible(true);
  tree.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true,1,1));
  TreeViewerColumn treeViewerColumn=new TreeViewerColumn(treeViewer,SWT.NONE);
  TreeColumn trclmnNewColumn=treeViewerColumn.getColumn();
  trclmnNewColumn.setText(Messages.LifecycleMappingPage_mavenBuildColumnTitle);
  treeColumnLayout.setColumnData(trclmnNewColumn,new ColumnWeightData(65,150,true));
  TreeViewerColumn columnViewerAction=new TreeViewerColumn(treeViewer,SWT.NONE);
  TreeColumn columnAction=columnViewerAction.getColumn();
  treeColumnLayout.setColumnData(columnAction,new ColumnWeightData(35,true));
  columnAction.setText(Messages.LifecycleMappingPage_actionColumnTitle);
  columnViewerAction.setEditingSupport(new EditingSupport(treeViewer){
    @SuppressWarnings(""String_Node_Str"") @Override protected void setValue(    Object element,    Object value){
      if (element instanceof ILifecycleMappingLabelProvider) {
        ILifecycleMappingLabelProvider prov=(ILifecycleMappingLabelProvider)element;
        int intVal=((Integer)value).intValue();
        List<IMavenDiscoveryProposal> all=mappingConfiguration.getProposals(prov.getKey());
        if (ignore.contains(element)) {
          ignore.remove(element);
        }
 else         if (ignoreAtDefinition.contains(element)) {
          ignoreAtDefinition.remove(element);
        }
 else         if (intVal == all.size() + NO_ACTION_IDX || shouldDeslectProposal(prov)) {
          IMavenDiscoveryProposal prop=mappingConfiguration.getSelectedProposal(prov.getKey());
          mappingConfiguration.removeSelectedProposal(prop);
        }
        if (intVal < all.size()) {
          IMavenDiscoveryProposal sel=all.get(intVal);
          if (sel != null) {
            mappingConfiguration.addSelectedProposal(sel);
          }
        }
 else {
switch (intVal - all.size()) {
case IGNORE_IDX:
            ignore.add(prov);
          break;
case IGNORE_PARENT_IDX:
        ignoreAtDefinition.add(prov);
    }
  }
  getViewer().refresh(true);
  updateErrorCount();
  getContainer().updateButtons();
}
}
@SuppressWarnings(""String_Node_Str"") @Override protected Object getValue(Object element){
if (element instanceof ILifecycleMappingLabelProvider) {
  ILifecycleMappingLabelProvider prov=(ILifecycleMappingLabelProvider)element;
  IMavenDiscoveryProposal prop=mappingConfiguration.getSelectedProposal(prov.getKey());
  List<IMavenDiscoveryProposal> all=mappingConfiguration.getProposals(prov.getKey());
  if (ignore.contains(element)) {
    return Integer.valueOf(all.size() + IGNORE_IDX);
  }
 else   if (ignoreAtDefinition.contains(element)) {
    return Integer.valueOf(all.size() + IGNORE_PARENT_IDX);
  }
 else {
    int index=all.indexOf(prop);
    return index >= 0 ? Integer.valueOf(index) : Integer.valueOf(all.size() + NO_ACTION_IDX);
  }
}
return Integer.valueOf(0);
}
@SuppressWarnings(""String_Node_Str"") @Override protected CellEditor getCellEditor(Object element){
if (element instanceof ILifecycleMappingLabelProvider) {
  ILifecycleMappingLabelProvider prov=(ILifecycleMappingLabelProvider)element;
  List<IMavenDiscoveryProposal> all=mappingConfiguration.getProposals(prov.getKey());
  List<String> values=new ArrayList<String>();
  for (  IMavenDiscoveryProposal prop : all) {
    values.add(NLS.bind(Messages.LifecycleMappingPage_installDescription,prop.toString()));
  }
  if (prov.isError(mappingConfiguration)) {
    values.add(Messages.LifecycleMappingPage_resolveLaterDescription);
  }
 else {
    values.add(EMPTY_STRING);
  }
  addIgnoreProposals(values,prov);
  ComboBoxCellEditor edit=new ComboBoxCellEditor(treeViewer.getTree(),values.toArray(new String[values.size()]));
  Control cont=edit.getControl();
  if (cont instanceof CCombo) {
    CCombo combo=(CCombo)cont;
    combo.setEditable(false);
  }
  return edit;
}
throw new IllegalStateException();
}
@SuppressWarnings(""String_Node_Str"") @Override protected boolean canEdit(Object element){
if (element instanceof AggregateMappingLabelProvider) {
  ILifecycleMappingLabelProvider prov=(ILifecycleMappingLabelProvider)element;
  List<IMavenDiscoveryProposal> all=mappingConfiguration.getProposals(prov.getKey());
  return all != null && !all.isEmpty() || prov.getKey() instanceof MojoExecutionMappingRequirement;
}
return false;
}
}
);
treeViewer.setContentProvider(new ITreeContentProvider(){
public void dispose(){
}
public void inputChanged(Viewer viewer,Object oldInput,Object newInput){
}
public Object[] getElements(Object inputElement){
if (inputElement instanceof LifecycleMappingDiscoveryRequest) {
  Map<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>> packagings=new HashMap<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>>();
  Map<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>> mojos=new HashMap<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>>();
  Map<IMavenProjectFacade,List<ILifecycleMappingRequirement>> projects=((LifecycleMappingDiscoveryRequest)inputElement).getProjects();
  for (  final Entry<IMavenProjectFacade,List<ILifecycleMappingRequirement>> entry : projects.entrySet()) {
    final String relPath=entry.getKey().getProject().getFile(IMavenConstants.POM_FILE_NAME).getFullPath().toPortableString();
    for (    final ILifecycleMappingRequirement requirement : entry.getValue()) {
      if (requirement != null) {
        List<ILifecycleMappingLabelProvider> val=mojos.get(requirement);
        if (val == null) {
          val=new ArrayList<ILifecycleMappingLabelProvider>();
          mojos.put(requirement,val);
        }
        val.add(new ILifecycleMappingLabelProvider(){
          public String getMavenText(){
            if (requirement instanceof MojoExecutionMappingRequirement) {
              String executionId=((MojoExecutionMappingRequirement)requirement).getExecutionId();
              if (""String_Node_Str"".equals(executionId)) {
                return NLS.bind(""String_Node_Str"",relPath);
              }
              return NLS.bind(""String_Node_Str"",executionId,relPath);
            }
            return null;
          }
          public boolean isError(          LifecycleMappingDiscoveryRequest mappingConfiguration){
            return !mappingConfiguration.isRequirementSatisfied(getKey());
          }
          public ILifecycleMappingRequirement getKey(){
            return requirement;
          }
          @SuppressWarnings(""String_Node_Str"") public Collection<MavenProject> getProjects(){
            MavenProject mavenProject;
            try {
              mavenProject=entry.getKey().getMavenProject(new NullProgressMonitor());
              return Collections.singleton(mavenProject);
            }
 catch (            CoreException e) {
              LOG.error(e.getMessage(),e);
              throw new RuntimeException(e.getMessage(),e);
            }
          }
        }
);
      }
    }
  }
  List<ILifecycleMappingLabelProvider> toRet=new ArrayList<ILifecycleMappingLabelProvider>();
  for (  Map.Entry<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>> ent : packagings.entrySet()) {
    toRet.add(new AggregateMappingLabelProvider(ent.getKey(),ent.getValue()));
  }
  for (  Map.Entry<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>> ent : mojos.entrySet()) {
    toRet.add(new AggregateMappingLabelProvider(ent.getKey(),ent.getValue()));
  }
  return toRet.toArray();
}
return null;
}
public Object[] getChildren(Object parentElement){
if (parentElement instanceof AggregateMappingLabelProvider) {
  return ((AggregateMappingLabelProvider)parentElement).getChildren();
}
return new Object[0];
}
public Object getParent(Object element){
return null;
}
public boolean hasChildren(Object element){
Object[] children=getChildren(element);
return children != null && children.length > 0;
}
}
);
treeViewer.setLabelProvider(new ITableLabelProvider(){
public void removeListener(ILabelProviderListener listener){
}
public boolean isLabelProperty(Object element,String property){
return false;
}
public void dispose(){
}
public void addListener(ILabelProviderListener listener){
}
@SuppressWarnings(""String_Node_Str"") public String getColumnText(Object element,int columnIndex){
if (element instanceof ILifecycleMappingLabelProvider) {
  ILifecycleMappingLabelProvider prov=(ILifecycleMappingLabelProvider)element;
  if (columnIndex == MAVEN_INFO_IDX) {
    String text=prov.getMavenText();
    if (prov instanceof AggregateMappingLabelProvider && !isHandled(prov)) {
      text=NLS.bind(Messages.LifecycleMappingPage_errorMavenBuild,new String[]{text,String.valueOf(((AggregateMappingLabelProvider)prov).getChildren().length)});
    }
    return text;
  }
 else   if (columnIndex == ACTION_INFO_IDX && element instanceof AggregateMappingLabelProvider) {
    IMavenDiscoveryProposal proposal=mappingConfiguration.getSelectedProposal(prov.getKey());
    if (ignore.contains(element)) {
      return Messages.LifecycleMappingPage_doNotExecutePom;
    }
 else     if (ignoreAtDefinition.contains(element)) {
      return Messages.LifecycleMappingPage_doNotExecuteParent;
    }
 else     if (proposal != null) {
      return NLS.bind(Messages.LifecycleMappingPage_installDescription,proposal.toString());
    }
 else     if (loading || !prov.isError(mappingConfiguration)) {
      return EMPTY_STRING;
    }
 else {
      return Messages.LifecycleMappingPage_resolveLaterDescription;
    }
  }
}
return null;
}
@SuppressWarnings(""String_Node_Str"") public Image getColumnImage(Object element,int columnIndex){
if (columnIndex != 0) {
  return null;
}
if (element instanceof AggregateMappingLabelProvider) {
  ILifecycleMappingLabelProvider prov=(ILifecycleMappingLabelProvider)element;
  if (prov.isError(mappingConfiguration)) {
    if (!isHandled(prov)) {
      return MavenImages.IMG_ERROR;
    }
  }
  return MavenImages.IMG_PASSED;
}
return MavenImages.IMG_POM;
}
}
);
treeViewer.addSelectionChangedListener(new ISelectionChangedListener(){
@SuppressWarnings(""String_Node_Str"") public void selectionChanged(SelectionChangedEvent event){
if (event.getSelection() instanceof IStructuredSelection && ((IStructuredSelection)event.getSelection()).size() == 1) {
  ILifecycleMappingLabelProvider prov=(ILifecycleMappingLabelProvider)((IStructuredSelection)event.getSelection()).getFirstElement();
  if (ignore.contains(prov)) {
    details.setText(Messages.LifecycleMappingPage_doNotExecutePomDescription);
    license.setText(EMPTY_STRING);
  }
 else   if (ignoreAtDefinition.contains(prov)) {
    details.setText(Messages.LifecycleMappingPage_doNotExecuteParentDescription);
    license.setText(EMPTY_STRING);
  }
 else {
    IMavenDiscoveryProposal proposal=mappingConfiguration.getSelectedProposal(prov.getKey());
    details.setText(proposal != null ? proposal.getDescription() : mappingConfiguration.getProposals(prov.getKey()).isEmpty() ? NLS.bind(Messages.LifecycleMappingPage_noMarketplaceEntryDescription,prov.getMavenText()) : EMPTY_STRING);
    license.setText(proposal == null ? EMPTY_STRING : proposal.getLicense());
  }
}
 else {
  resetDetails();
}
}
}
);
treeViewer.setComparator(new ViewerComparator(){
public int compare(Viewer viewer,Object e1,Object e2){
if (!(e1 instanceof ILifecycleMappingLabelProvider && e2 instanceof ILifecycleMappingLabelProvider)) {
  return super.compare(viewer,e1,e2);
}
int cat1=category(e1);
int cat2=category(e2);
if (cat1 != cat2) {
  return cat1 - cat2;
}
return ((ILifecycleMappingLabelProvider)e1).getMavenText().compareTo(((ILifecycleMappingLabelProvider)e2).getMavenText());
}
}
);
Composite composite=new Composite(container,SWT.NONE);
composite.setLayoutData(new GridData(SWT.FILL,SWT.CENTER,true,false,1,1));
composite.setLayout(new GridLayout(3,false));
errorCountLabel=new Label(composite,SWT.NONE);
errorCountLabel.setLayoutData(new GridData(SWT.FILL,SWT.CENTER,true,false,1,1));
Button btnNewButton_1=new Button(composite,SWT.NONE);
btnNewButton_1.addSelectionListener(new SelectionAdapter(){
@Override @SuppressWarnings(""String_Node_Str"") public void widgetSelected(SelectionEvent e){
mappingConfiguration.clearSelectedProposals();
ignore.clear();
ignoreAtDefinition.clear();
treeViewer.refresh();
getWizard().getContainer().updateButtons();
updateErrorCount();
}
}
);
btnNewButton_1.setText(Messages.LifecycleMappingPage_deselectAllButton);
autoSelectButton=new Button(composite,SWT.NONE);
autoSelectButton.addSelectionListener(new SelectionAdapter(){
@Override @SuppressWarnings(""String_Node_Str"") public void widgetSelected(SelectionEvent e){
resetDetails();
ignore.clear();
ignoreAtDefinition.clear();
discoverProposals();
}
}
);
autoSelectButton.setText(Messages.LifecycleMappingPage_autoSelectButton);
GC gc=new GC(container);
gc.setFont(JFaceResources.getDialogFont());
FontMetrics fontMetrics=gc.getFontMetrics();
gc.dispose();
Group grpDetails=new Group(container,SWT.NONE);
grpDetails.setLayout(new GridLayout(1,false));
grpDetails.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
grpDetails.setText(Messages.LifecycleMappingPage_descriptionLabel);
details=new Text(grpDetails,SWT.WRAP | SWT.READ_ONLY | SWT.V_SCROLL);
GridData gd=new GridData(SWT.FILL,SWT.FILL,true,true);
gd.heightHint=Dialog.convertHeightInCharsToPixels(fontMetrics,3);
gd.minimumHeight=Dialog.convertHeightInCharsToPixels(fontMetrics,1);
details.setLayoutData(gd);
Group grpLicense=new Group(container,SWT.NONE);
grpLicense.setLayout(new GridLayout(1,false));
grpLicense.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
grpLicense.setText(Messages.LifecycleMappingPage_licenseLabel);
license=new Text(grpLicense,SWT.READ_ONLY);
gd=new GridData(SWT.FILL,SWT.FILL,true,true);
gd.heightHint=Dialog.convertHeightInCharsToPixels(fontMetrics,1);
gd.minimumHeight=Dialog.convertHeightInCharsToPixels(fontMetrics,1);
license.setLayoutData(gd);
}","/** 
 * Create contents of the wizard.
 * @param parent
 */
public void createControl(Composite parent){
  Composite container=new Composite(parent,SWT.NULL);
  setControl(container);
  container.setLayout(new GridLayout(1,false));
  Composite treeViewerContainer=new Composite(container,SWT.NULL);
  GridDataFactory.fillDefaults().grab(true,false).applyTo(treeViewerContainer);
  TreeColumnLayout treeColumnLayout=new TreeColumnLayout();
  treeViewerContainer.setLayout(treeColumnLayout);
  treeViewer=new TreeViewer(treeViewerContainer,SWT.BORDER | SWT.FULL_SELECTION);
  Tree tree=treeViewer.getTree();
  tree.setLinesVisible(true);
  tree.setHeaderVisible(true);
  tree.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true,1,1));
  TreeViewerColumn treeViewerColumn=new TreeViewerColumn(treeViewer,SWT.NONE);
  TreeColumn trclmnNewColumn=treeViewerColumn.getColumn();
  trclmnNewColumn.setText(Messages.LifecycleMappingPage_mavenBuildColumnTitle);
  treeColumnLayout.setColumnData(trclmnNewColumn,new ColumnWeightData(65,150,true));
  TreeViewerColumn columnViewerAction=new TreeViewerColumn(treeViewer,SWT.NONE);
  TreeColumn columnAction=columnViewerAction.getColumn();
  treeColumnLayout.setColumnData(columnAction,new ColumnWeightData(35,true));
  columnAction.setText(Messages.LifecycleMappingPage_actionColumnTitle);
  columnViewerAction.setEditingSupport(new EditingSupport(treeViewer){
    @SuppressWarnings(""String_Node_Str"") @Override protected void setValue(    Object element,    Object value){
      if (element instanceof ILifecycleMappingLabelProvider) {
        ILifecycleMappingLabelProvider prov=(ILifecycleMappingLabelProvider)element;
        int intVal=((Integer)value).intValue();
        List<IMavenDiscoveryProposal> all=mappingConfiguration.getProposals(prov.getKey());
        if (ignore.contains(element)) {
          ignore.remove(element);
        }
 else         if (ignoreAtDefinition.contains(element)) {
          ignoreAtDefinition.remove(element);
        }
 else         if (intVal == all.size() + NO_ACTION_IDX || shouldDeslectProposal(prov)) {
          IMavenDiscoveryProposal prop=mappingConfiguration.getSelectedProposal(prov.getKey());
          mappingConfiguration.removeSelectedProposal(prop);
        }
        if (intVal < all.size()) {
          IMavenDiscoveryProposal sel=all.get(intVal);
          if (sel != null) {
            mappingConfiguration.addSelectedProposal(sel);
          }
        }
 else {
switch (intVal - all.size()) {
case IGNORE_IDX:
            ignore.add(prov);
          break;
case IGNORE_PARENT_IDX:
        ignoreAtDefinition.add(prov);
    }
  }
  getViewer().refresh(true);
  updateErrorCount();
  getContainer().updateButtons();
}
}
@SuppressWarnings(""String_Node_Str"") @Override protected Object getValue(Object element){
if (element instanceof ILifecycleMappingLabelProvider) {
  ILifecycleMappingLabelProvider prov=(ILifecycleMappingLabelProvider)element;
  IMavenDiscoveryProposal prop=mappingConfiguration.getSelectedProposal(prov.getKey());
  List<IMavenDiscoveryProposal> all=mappingConfiguration.getProposals(prov.getKey());
  if (ignore.contains(element)) {
    return Integer.valueOf(all.size() + IGNORE_IDX);
  }
 else   if (ignoreAtDefinition.contains(element)) {
    return Integer.valueOf(all.size() + IGNORE_PARENT_IDX);
  }
 else {
    int index=all.indexOf(prop);
    return index >= 0 ? Integer.valueOf(index) : Integer.valueOf(all.size() + NO_ACTION_IDX);
  }
}
return Integer.valueOf(0);
}
@SuppressWarnings(""String_Node_Str"") @Override protected CellEditor getCellEditor(Object element){
if (element instanceof ILifecycleMappingLabelProvider) {
  ILifecycleMappingLabelProvider prov=(ILifecycleMappingLabelProvider)element;
  List<IMavenDiscoveryProposal> all=mappingConfiguration.getProposals(prov.getKey());
  List<String> values=new ArrayList<String>();
  for (  IMavenDiscoveryProposal prop : all) {
    values.add(NLS.bind(Messages.LifecycleMappingPage_installDescription,prop.toString()));
  }
  if (prov.isError(mappingConfiguration)) {
    values.add(Messages.LifecycleMappingPage_resolveLaterDescription);
  }
 else {
    values.add(EMPTY_STRING);
  }
  addIgnoreProposals(values,prov);
  ComboBoxCellEditor edit=new ComboBoxCellEditor(treeViewer.getTree(),values.toArray(new String[values.size()]));
  Control cont=edit.getControl();
  if (cont instanceof CCombo) {
    CCombo combo=(CCombo)cont;
    combo.setEditable(false);
  }
  return edit;
}
throw new IllegalStateException();
}
@SuppressWarnings(""String_Node_Str"") @Override protected boolean canEdit(Object element){
if (element instanceof AggregateMappingLabelProvider) {
  ILifecycleMappingLabelProvider prov=(ILifecycleMappingLabelProvider)element;
  List<IMavenDiscoveryProposal> all=mappingConfiguration.getProposals(prov.getKey());
  return all != null && !all.isEmpty() || prov.getKey() instanceof MojoExecutionMappingRequirement;
}
return false;
}
}
);
treeViewer.setContentProvider(new ITreeContentProvider(){
public void dispose(){
}
public void inputChanged(Viewer viewer,Object oldInput,Object newInput){
}
public Object[] getElements(Object inputElement){
if (inputElement instanceof LifecycleMappingDiscoveryRequest) {
  Map<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>> packagings=new HashMap<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>>();
  Map<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>> mojos=new HashMap<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>>();
  Map<IMavenProjectFacade,List<ILifecycleMappingRequirement>> projects=((LifecycleMappingDiscoveryRequest)inputElement).getProjects();
  for (  final Entry<IMavenProjectFacade,List<ILifecycleMappingRequirement>> entry : projects.entrySet()) {
    final String relPath=entry.getKey().getProject().getFile(IMavenConstants.POM_FILE_NAME).getFullPath().toPortableString();
    for (    final ILifecycleMappingRequirement requirement : entry.getValue()) {
      if (requirement != null) {
        List<ILifecycleMappingLabelProvider> val=mojos.get(requirement);
        if (val == null) {
          val=new ArrayList<ILifecycleMappingLabelProvider>();
          mojos.put(requirement,val);
        }
        val.add(new ILifecycleMappingLabelProvider(){
          public String getMavenText(){
            String executionId=null;
            if (requirement instanceof MojoExecutionMappingRequirement) {
              executionId=((MojoExecutionMappingRequirement)requirement).getExecutionId();
            }
 else             if (requirement instanceof ProjectConfiguratorMappingRequirement) {
              executionId=((ProjectConfiguratorMappingRequirement)requirement).getExecution().getExecutionId();
            }
            if (executionId != null) {
              if (""String_Node_Str"".equals(executionId)) {
                return NLS.bind(""String_Node_Str"",relPath);
              }
              return NLS.bind(""String_Node_Str"",executionId,relPath);
            }
            return null;
          }
          public boolean isError(          LifecycleMappingDiscoveryRequest mappingConfiguration){
            return !mappingConfiguration.isRequirementSatisfied(getKey());
          }
          public ILifecycleMappingRequirement getKey(){
            return requirement;
          }
          @SuppressWarnings(""String_Node_Str"") public Collection<MavenProject> getProjects(){
            MavenProject mavenProject;
            try {
              mavenProject=entry.getKey().getMavenProject(new NullProgressMonitor());
              return Collections.singleton(mavenProject);
            }
 catch (            CoreException e) {
              LOG.error(e.getMessage(),e);
              throw new RuntimeException(e.getMessage(),e);
            }
          }
        }
);
      }
    }
  }
  List<ILifecycleMappingLabelProvider> toRet=new ArrayList<ILifecycleMappingLabelProvider>();
  for (  Map.Entry<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>> ent : packagings.entrySet()) {
    toRet.add(new AggregateMappingLabelProvider(ent.getKey(),ent.getValue()));
  }
  for (  Map.Entry<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>> ent : mojos.entrySet()) {
    toRet.add(new AggregateMappingLabelProvider(ent.getKey(),ent.getValue()));
  }
  return toRet.toArray();
}
return null;
}
public Object[] getChildren(Object parentElement){
if (parentElement instanceof AggregateMappingLabelProvider) {
  return ((AggregateMappingLabelProvider)parentElement).getChildren();
}
return new Object[0];
}
public Object getParent(Object element){
return null;
}
public boolean hasChildren(Object element){
Object[] children=getChildren(element);
return children != null && children.length > 0;
}
}
);
treeViewer.setLabelProvider(new ITableLabelProvider(){
public void removeListener(ILabelProviderListener listener){
}
public boolean isLabelProperty(Object element,String property){
return false;
}
public void dispose(){
}
public void addListener(ILabelProviderListener listener){
}
@SuppressWarnings(""String_Node_Str"") public String getColumnText(Object element,int columnIndex){
if (element instanceof ILifecycleMappingLabelProvider) {
  ILifecycleMappingLabelProvider prov=(ILifecycleMappingLabelProvider)element;
  if (columnIndex == MAVEN_INFO_IDX) {
    String text=prov.getMavenText();
    if (prov instanceof AggregateMappingLabelProvider && !isHandled(prov)) {
      text=NLS.bind(Messages.LifecycleMappingPage_errorMavenBuild,new String[]{text,String.valueOf(((AggregateMappingLabelProvider)prov).getChildren().length)});
    }
    return text;
  }
 else   if (columnIndex == ACTION_INFO_IDX && element instanceof AggregateMappingLabelProvider) {
    IMavenDiscoveryProposal proposal=mappingConfiguration.getSelectedProposal(prov.getKey());
    if (ignore.contains(element)) {
      return Messages.LifecycleMappingPage_doNotExecutePom;
    }
 else     if (ignoreAtDefinition.contains(element)) {
      return Messages.LifecycleMappingPage_doNotExecuteParent;
    }
 else     if (proposal != null) {
      return NLS.bind(Messages.LifecycleMappingPage_installDescription,proposal.toString());
    }
 else     if (loading || !prov.isError(mappingConfiguration)) {
      return EMPTY_STRING;
    }
 else {
      return Messages.LifecycleMappingPage_resolveLaterDescription;
    }
  }
}
return null;
}
@SuppressWarnings(""String_Node_Str"") public Image getColumnImage(Object element,int columnIndex){
if (columnIndex != 0) {
  return null;
}
if (element instanceof AggregateMappingLabelProvider) {
  ILifecycleMappingLabelProvider prov=(ILifecycleMappingLabelProvider)element;
  if (prov.isError(mappingConfiguration)) {
    if (!isHandled(prov)) {
      return MavenImages.IMG_ERROR;
    }
  }
  return MavenImages.IMG_PASSED;
}
return MavenImages.IMG_POM;
}
}
);
treeViewer.addSelectionChangedListener(new ISelectionChangedListener(){
@SuppressWarnings(""String_Node_Str"") public void selectionChanged(SelectionChangedEvent event){
if (event.getSelection() instanceof IStructuredSelection && ((IStructuredSelection)event.getSelection()).size() == 1) {
  ILifecycleMappingLabelProvider prov=(ILifecycleMappingLabelProvider)((IStructuredSelection)event.getSelection()).getFirstElement();
  if (ignore.contains(prov)) {
    details.setText(Messages.LifecycleMappingPage_doNotExecutePomDescription);
    license.setText(EMPTY_STRING);
  }
 else   if (ignoreAtDefinition.contains(prov)) {
    details.setText(Messages.LifecycleMappingPage_doNotExecuteParentDescription);
    license.setText(EMPTY_STRING);
  }
 else {
    IMavenDiscoveryProposal proposal=mappingConfiguration.getSelectedProposal(prov.getKey());
    details.setText(proposal != null ? proposal.getDescription() : mappingConfiguration.getProposals(prov.getKey()).isEmpty() ? NLS.bind(Messages.LifecycleMappingPage_noMarketplaceEntryDescription,prov.getMavenText()) : EMPTY_STRING);
    license.setText(proposal == null ? EMPTY_STRING : proposal.getLicense());
  }
}
 else {
  resetDetails();
}
}
}
);
treeViewer.setComparator(new ViewerComparator(){
public int compare(Viewer viewer,Object e1,Object e2){
if (!(e1 instanceof ILifecycleMappingLabelProvider && e2 instanceof ILifecycleMappingLabelProvider)) {
  return super.compare(viewer,e1,e2);
}
int cat1=category(e1);
int cat2=category(e2);
if (cat1 != cat2) {
  return cat1 - cat2;
}
return ((ILifecycleMappingLabelProvider)e1).getMavenText().compareTo(((ILifecycleMappingLabelProvider)e2).getMavenText());
}
}
);
Composite composite=new Composite(container,SWT.NONE);
composite.setLayoutData(new GridData(SWT.FILL,SWT.CENTER,true,false,1,1));
composite.setLayout(new GridLayout(3,false));
errorCountLabel=new Label(composite,SWT.NONE);
errorCountLabel.setLayoutData(new GridData(SWT.FILL,SWT.CENTER,true,false,1,1));
Button btnNewButton_1=new Button(composite,SWT.NONE);
btnNewButton_1.addSelectionListener(new SelectionAdapter(){
@Override @SuppressWarnings(""String_Node_Str"") public void widgetSelected(SelectionEvent e){
mappingConfiguration.clearSelectedProposals();
ignore.clear();
ignoreAtDefinition.clear();
treeViewer.refresh();
getWizard().getContainer().updateButtons();
updateErrorCount();
}
}
);
btnNewButton_1.setText(Messages.LifecycleMappingPage_deselectAllButton);
autoSelectButton=new Button(composite,SWT.NONE);
autoSelectButton.addSelectionListener(new SelectionAdapter(){
@Override @SuppressWarnings(""String_Node_Str"") public void widgetSelected(SelectionEvent e){
resetDetails();
ignore.clear();
ignoreAtDefinition.clear();
discoverProposals();
}
}
);
autoSelectButton.setText(Messages.LifecycleMappingPage_autoSelectButton);
GC gc=new GC(container);
gc.setFont(JFaceResources.getDialogFont());
FontMetrics fontMetrics=gc.getFontMetrics();
gc.dispose();
Group grpDetails=new Group(container,SWT.NONE);
grpDetails.setLayout(new GridLayout(1,false));
grpDetails.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
grpDetails.setText(Messages.LifecycleMappingPage_descriptionLabel);
details=new Text(grpDetails,SWT.WRAP | SWT.READ_ONLY | SWT.V_SCROLL);
GridData gd=new GridData(SWT.FILL,SWT.FILL,true,true);
gd.heightHint=Dialog.convertHeightInCharsToPixels(fontMetrics,3);
gd.minimumHeight=Dialog.convertHeightInCharsToPixels(fontMetrics,1);
details.setLayoutData(gd);
Group grpLicense=new Group(container,SWT.NONE);
grpLicense.setLayout(new GridLayout(1,false));
grpLicense.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false,1,1));
grpLicense.setText(Messages.LifecycleMappingPage_licenseLabel);
license=new Text(grpLicense,SWT.READ_ONLY);
gd=new GridData(SWT.FILL,SWT.FILL,true,true);
gd.heightHint=Dialog.convertHeightInCharsToPixels(fontMetrics,1);
gd.minimumHeight=Dialog.convertHeightInCharsToPixels(fontMetrics,1);
license.setLayoutData(gd);
}",0.9894449188727584
91668,"public String getMavenText(){
  if (requirement instanceof MojoExecutionMappingRequirement) {
    String executionId=((MojoExecutionMappingRequirement)requirement).getExecutionId();
    if (""String_Node_Str"".equals(executionId)) {
      return NLS.bind(""String_Node_Str"",relPath);
    }
    return NLS.bind(""String_Node_Str"",executionId,relPath);
  }
  return null;
}","public String getMavenText(){
  String executionId=null;
  if (requirement instanceof MojoExecutionMappingRequirement) {
    executionId=((MojoExecutionMappingRequirement)requirement).getExecutionId();
  }
 else   if (requirement instanceof ProjectConfiguratorMappingRequirement) {
    executionId=((ProjectConfiguratorMappingRequirement)requirement).getExecution().getExecutionId();
  }
  if (executionId != null) {
    if (""String_Node_Str"".equals(executionId)) {
      return NLS.bind(""String_Node_Str"",relPath);
    }
    return NLS.bind(""String_Node_Str"",executionId,relPath);
  }
  return null;
}",0.7430340557275542
91669,"public Object[] getElements(Object inputElement){
  if (inputElement instanceof LifecycleMappingDiscoveryRequest) {
    Map<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>> packagings=new HashMap<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>>();
    Map<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>> mojos=new HashMap<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>>();
    Map<IMavenProjectFacade,List<ILifecycleMappingRequirement>> projects=((LifecycleMappingDiscoveryRequest)inputElement).getProjects();
    for (    final Entry<IMavenProjectFacade,List<ILifecycleMappingRequirement>> entry : projects.entrySet()) {
      final String relPath=entry.getKey().getProject().getFile(IMavenConstants.POM_FILE_NAME).getFullPath().toPortableString();
      for (      final ILifecycleMappingRequirement requirement : entry.getValue()) {
        if (requirement != null) {
          List<ILifecycleMappingLabelProvider> val=mojos.get(requirement);
          if (val == null) {
            val=new ArrayList<ILifecycleMappingLabelProvider>();
            mojos.put(requirement,val);
          }
          val.add(new ILifecycleMappingLabelProvider(){
            public String getMavenText(){
              if (requirement instanceof MojoExecutionMappingRequirement) {
                String executionId=((MojoExecutionMappingRequirement)requirement).getExecutionId();
                if (""String_Node_Str"".equals(executionId)) {
                  return NLS.bind(""String_Node_Str"",relPath);
                }
                return NLS.bind(""String_Node_Str"",executionId,relPath);
              }
              return null;
            }
            public boolean isError(            LifecycleMappingDiscoveryRequest mappingConfiguration){
              return !mappingConfiguration.isRequirementSatisfied(getKey());
            }
            public ILifecycleMappingRequirement getKey(){
              return requirement;
            }
            @SuppressWarnings(""String_Node_Str"") public Collection<MavenProject> getProjects(){
              MavenProject mavenProject;
              try {
                mavenProject=entry.getKey().getMavenProject(new NullProgressMonitor());
                return Collections.singleton(mavenProject);
              }
 catch (              CoreException e) {
                LOG.error(e.getMessage(),e);
                throw new RuntimeException(e.getMessage(),e);
              }
            }
          }
);
        }
      }
    }
    List<ILifecycleMappingLabelProvider> toRet=new ArrayList<ILifecycleMappingLabelProvider>();
    for (    Map.Entry<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>> ent : packagings.entrySet()) {
      toRet.add(new AggregateMappingLabelProvider(ent.getKey(),ent.getValue()));
    }
    for (    Map.Entry<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>> ent : mojos.entrySet()) {
      toRet.add(new AggregateMappingLabelProvider(ent.getKey(),ent.getValue()));
    }
    return toRet.toArray();
  }
  return null;
}","public Object[] getElements(Object inputElement){
  if (inputElement instanceof LifecycleMappingDiscoveryRequest) {
    Map<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>> packagings=new HashMap<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>>();
    Map<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>> mojos=new HashMap<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>>();
    Map<IMavenProjectFacade,List<ILifecycleMappingRequirement>> projects=((LifecycleMappingDiscoveryRequest)inputElement).getProjects();
    for (    final Entry<IMavenProjectFacade,List<ILifecycleMappingRequirement>> entry : projects.entrySet()) {
      final String relPath=entry.getKey().getProject().getFile(IMavenConstants.POM_FILE_NAME).getFullPath().toPortableString();
      for (      final ILifecycleMappingRequirement requirement : entry.getValue()) {
        if (requirement != null) {
          List<ILifecycleMappingLabelProvider> val=mojos.get(requirement);
          if (val == null) {
            val=new ArrayList<ILifecycleMappingLabelProvider>();
            mojos.put(requirement,val);
          }
          val.add(new ILifecycleMappingLabelProvider(){
            public String getMavenText(){
              String executionId=null;
              if (requirement instanceof MojoExecutionMappingRequirement) {
                executionId=((MojoExecutionMappingRequirement)requirement).getExecutionId();
              }
 else               if (requirement instanceof ProjectConfiguratorMappingRequirement) {
                executionId=((ProjectConfiguratorMappingRequirement)requirement).getExecution().getExecutionId();
              }
              if (executionId != null) {
                if (""String_Node_Str"".equals(executionId)) {
                  return NLS.bind(""String_Node_Str"",relPath);
                }
                return NLS.bind(""String_Node_Str"",executionId,relPath);
              }
              return null;
            }
            public boolean isError(            LifecycleMappingDiscoveryRequest mappingConfiguration){
              return !mappingConfiguration.isRequirementSatisfied(getKey());
            }
            public ILifecycleMappingRequirement getKey(){
              return requirement;
            }
            @SuppressWarnings(""String_Node_Str"") public Collection<MavenProject> getProjects(){
              MavenProject mavenProject;
              try {
                mavenProject=entry.getKey().getMavenProject(new NullProgressMonitor());
                return Collections.singleton(mavenProject);
              }
 catch (              CoreException e) {
                LOG.error(e.getMessage(),e);
                throw new RuntimeException(e.getMessage(),e);
              }
            }
          }
);
        }
      }
    }
    List<ILifecycleMappingLabelProvider> toRet=new ArrayList<ILifecycleMappingLabelProvider>();
    for (    Map.Entry<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>> ent : packagings.entrySet()) {
      toRet.add(new AggregateMappingLabelProvider(ent.getKey(),ent.getValue()));
    }
    for (    Map.Entry<ILifecycleMappingRequirement,List<ILifecycleMappingLabelProvider>> ent : mojos.entrySet()) {
      toRet.add(new AggregateMappingLabelProvider(ent.getKey(),ent.getValue()));
    }
    return toRet.toArray();
  }
  return null;
}",0.9507139567019808
91670,"public static void instantiateProjectConfigurators(MavenProject mavenProject,LifecycleMappingResult result,Map<MojoExecutionKey,List<IPluginExecutionMetadata>> map){
  if (map == null) {
    Map<String,AbstractProjectConfigurator> configurators=Collections.emptyMap();
    result.setProjectConfigurators(configurators);
    return;
  }
  ProblemSeverity notCoveredMojoExecutionSeverity=ProblemSeverity.get(MavenPlugin.getMavenConfiguration().getNotCoveredMojoExecutionSeverity());
  boolean reportNotCoveredMojoExecutionProblems=!ProblemSeverity.ignore.equals(notCoveredMojoExecutionSeverity);
  Map<String,AbstractProjectConfigurator> configurators=new LinkedHashMap<String,AbstractProjectConfigurator>();
  for (  Map.Entry<MojoExecutionKey,List<IPluginExecutionMetadata>> entry : map.entrySet()) {
    MojoExecutionKey executionKey=entry.getKey();
    List<IPluginExecutionMetadata> executionMetadatas=entry.getValue();
    if (executionMetadatas == null || executionMetadatas.isEmpty()) {
      if (reportNotCoveredMojoExecutionProblems && isInterestingPhase(executionKey.getLifecyclePhase())) {
        SourceLocation markerLocation=SourceLocationHelper.findLocation(mavenProject,executionKey);
        result.addProblem(new NotCoveredMojoExecution(executionKey,notCoveredMojoExecutionSeverity.getSeverity(),markerLocation));
      }
      continue;
    }
    for (    IPluginExecutionMetadata metadata : executionMetadatas) {
      String message=LifecycleMappingFactory.getActionMessage(metadata);
switch (metadata.getAction()) {
case error:
{
          if (message == null) {
            message=NLS.bind(Messages.LifecycleConfigurationPluginExecutionErrorMessage,executionKey.toString());
          }
          SourceLocation markerLocation=SourceLocationHelper.findLocation(mavenProject,executionKey);
          result.addProblem(new ActionMessageProblemInfo(message,IMarker.SEVERITY_ERROR,executionKey,markerLocation,isPomMapping(metadata)));
          break;
        }
case execute:
      if (message != null) {
        SourceLocation markerLocation=SourceLocationHelper.findLocation(mavenProject,executionKey);
        result.addProblem(new ActionMessageProblemInfo(message,IMarker.SEVERITY_WARNING,executionKey,markerLocation,isPomMapping(metadata)));
      }
    break;
case configurator:
  String configuratorId=LifecycleMappingFactory.getProjectConfiguratorId(metadata);
try {
  if (!configurators.containsKey(configuratorId)) {
    configurators.put(configuratorId,LifecycleMappingFactory.createProjectConfigurator(metadata));
  }
}
 catch (LifecycleMappingConfigurationException e) {
  log.debug(""String_Node_Str"",configuratorId,e);
  SourceLocation markerLocation=SourceLocationHelper.findLocation(mavenProject,executionKey);
  result.addProblem(new MissingConfiguratorProblemInfo(configuratorId,markerLocation));
  if (reportNotCoveredMojoExecutionProblems) {
    result.addProblem(new NotCoveredMojoExecution(executionKey,notCoveredMojoExecutionSeverity.getSeverity(),markerLocation));
  }
}
break;
case ignore:
if (message != null) {
SourceLocation markerLocation=SourceLocationHelper.findLocation(mavenProject,executionKey);
result.addProblem(new ActionMessageProblemInfo(message,IMarker.SEVERITY_WARNING,executionKey,markerLocation,isPomMapping(metadata)));
}
break;
default :
}
}
}
result.setProjectConfigurators(configurators);
}","public static void instantiateProjectConfigurators(MavenProject mavenProject,LifecycleMappingResult result,Map<MojoExecutionKey,List<IPluginExecutionMetadata>> map){
  if (map == null) {
    Map<String,AbstractProjectConfigurator> configurators=Collections.emptyMap();
    result.setProjectConfigurators(configurators);
    return;
  }
  ProblemSeverity notCoveredMojoExecutionSeverity=ProblemSeverity.get(MavenPlugin.getMavenConfiguration().getNotCoveredMojoExecutionSeverity());
  boolean reportNotCoveredMojoExecutionProblems=!ProblemSeverity.ignore.equals(notCoveredMojoExecutionSeverity);
  Map<String,AbstractProjectConfigurator> configurators=new LinkedHashMap<String,AbstractProjectConfigurator>();
  for (  Map.Entry<MojoExecutionKey,List<IPluginExecutionMetadata>> entry : map.entrySet()) {
    MojoExecutionKey executionKey=entry.getKey();
    List<IPluginExecutionMetadata> executionMetadatas=entry.getValue();
    if (executionMetadatas == null || executionMetadatas.isEmpty()) {
      if (reportNotCoveredMojoExecutionProblems && isInterestingPhase(executionKey.getLifecyclePhase())) {
        SourceLocation markerLocation=SourceLocationHelper.findLocation(mavenProject,executionKey);
        result.addProblem(new NotCoveredMojoExecution(executionKey,notCoveredMojoExecutionSeverity.getSeverity(),markerLocation));
      }
      continue;
    }
    for (    IPluginExecutionMetadata metadata : executionMetadatas) {
      String message=LifecycleMappingFactory.getActionMessage(metadata);
switch (metadata.getAction()) {
case error:
{
          if (message == null) {
            message=NLS.bind(Messages.LifecycleConfigurationPluginExecutionErrorMessage,executionKey.toString());
          }
          SourceLocation markerLocation=SourceLocationHelper.findLocation(mavenProject,executionKey);
          result.addProblem(new ActionMessageProblemInfo(message,IMarker.SEVERITY_ERROR,executionKey,markerLocation,isPomMapping(metadata)));
          break;
        }
case execute:
      if (message != null) {
        SourceLocation markerLocation=SourceLocationHelper.findLocation(mavenProject,executionKey);
        result.addProblem(new ActionMessageProblemInfo(message,IMarker.SEVERITY_WARNING,executionKey,markerLocation,isPomMapping(metadata)));
      }
    break;
case configurator:
  String configuratorId=LifecycleMappingFactory.getProjectConfiguratorId(metadata);
try {
  if (!configurators.containsKey(configuratorId)) {
    configurators.put(configuratorId,LifecycleMappingFactory.createProjectConfigurator(metadata));
  }
}
 catch (LifecycleMappingConfigurationException e) {
  log.debug(""String_Node_Str"",configuratorId,e);
  if (reportNotCoveredMojoExecutionProblems) {
    SourceLocation markerLocation=SourceLocationHelper.findLocation(mavenProject,executionKey);
    result.addProblem(new MissingConfiguratorProblemInfo(configuratorId,executionKey,notCoveredMojoExecutionSeverity.getSeverity(),markerLocation));
  }
}
break;
case ignore:
if (message != null) {
SourceLocation markerLocation=SourceLocationHelper.findLocation(mavenProject,executionKey);
result.addProblem(new ActionMessageProblemInfo(message,IMarker.SEVERITY_WARNING,executionKey,markerLocation,isPomMapping(metadata)));
}
break;
default :
}
}
}
result.setProjectConfigurators(configurators);
}",0.9750300842358604
91671,"public MissingConfiguratorProblemInfo(String configuratorId,SourceLocation markerLocation){
  super(NLS.bind(Messages.ProjectConfiguratorNotAvailable,configuratorId),markerLocation);
  this.configuratorId=configuratorId;
}","public MissingConfiguratorProblemInfo(String configuratorId,MojoExecutionKey mojoExecutionKey,int severity,SourceLocation markerLocation){
  super(NLS.bind(Messages.ProjectConfiguratorNotAvailable,configuratorId,mojoExecutionKey.toString()),severity,mojoExecutionKey,markerLocation);
  this.configuratorId=configuratorId;
}",0.8146788990825689
91672,"private int computeOutOfDateProjectsCount(){
  int outOfDateProjectsCount=0;
  for (  IProject p : projects) {
    if (requiresUpdate(p) && !codebaseViewer.getChecked(p)) {
      outOfDateProjectsCount++;
    }
  }
  return outOfDateProjectsCount;
}","private int computeOutOfDateProjectsCount(){
  int outOfDateProjectsCount=0;
  for (  IProject p : projectPaths.values()) {
    if (requiresUpdate(p) && !codebaseViewer.getChecked(p)) {
      outOfDateProjectsCount++;
    }
  }
  return outOfDateProjectsCount;
}",0.9706457925636008
91673,"private void includeOutOfDateProjects(){
  for (  IProject project : projects) {
    if (requiresUpdate(project)) {
      codebaseViewer.setSubtreeChecked(project,true);
    }
  }
  updateSelectedProjects();
}","private void includeOutOfDateProjects(){
  for (  IProject project : projectPaths.values()) {
    if (requiresUpdate(project)) {
      codebaseViewer.setChecked(project,true);
    }
  }
  updateSelectedProjects();
}",0.9481132075471698
91674,"void addErrorMarker(IProject project,Exception e){
  String msg=e.getMessage();
  String rootCause=M2EUtils.getRootCauseMessage(e);
  if (!e.equals(msg)) {
    msg=msg + ""String_Node_Str"" + rootCause;
  }
  markerManager.addMarker(project,IMavenConstants.MARKER_BUILD_ID,msg,1,IMarker.SEVERITY_ERROR);
}","void addErrorMarker(IProject project,Exception e){
  String msg=e.getMessage();
  String rootCause=M2EUtils.getRootCauseMessage(e);
  if (msg != null && !msg.equals(rootCause)) {
    msg=msg + ""String_Node_Str"" + rootCause;
  }
  markerManager.addMarker(project,IMavenConstants.MARKER_BUILD_ID,msg,1,IMarker.SEVERITY_ERROR);
}",0.9507154213036566
91675,"public Void call(IMavenExecutionContext context,IProgressMonitor monitor) throws CoreException {
  if (projectFacade.getMavenProject(monitor) == null) {
    return null;
  }
  ILifecycleMapping lifecycleMapping=configurationManager.getLifecycleMapping(projectFacade);
  if (lifecycleMapping == null) {
    return null;
  }
  Map<MojoExecutionKey,List<AbstractBuildParticipant>> buildParticipantsByMojoExecutionKey=lifecycleMapping.getBuildParticipants(projectFacade,monitor);
  MavenProject mavenProject=null;
  try {
    mavenProject=projectFacade.getMavenProject(monitor);
  }
 catch (  CoreException ce) {
    addErrorMarker(project,ce);
    return null;
  }
  builder.clean(context.getSession(),projectFacade,buildParticipantsByMojoExecutionKey,monitor);
  return null;
}","public T call(IMavenExecutionContext context,IProgressMonitor monitor) throws CoreException {
  ILifecycleMapping lifecycleMapping=configurationManager.getLifecycleMapping(projectFacade);
  if (lifecycleMapping == null) {
    return null;
  }
  Map<MojoExecutionKey,List<AbstractBuildParticipant>> buildParticipantsByMojoExecutionKey=lifecycleMapping.getBuildParticipants(projectFacade,monitor);
  return method(context,projectFacade,buildParticipantsByMojoExecutionKey,kind,args,monitor);
}",0.6461295418641391
91676,"protected IProject[] build(final int kind,final Map<String,String> args,final IProgressMonitor monitor) throws CoreException {
  final IProject project=getProject();
  log.debug(""String_Node_Str"",project.getName());
  final long start=System.currentTimeMillis();
  markerManager.deleteMarkers(project,kind == FULL_BUILD,IMavenConstants.MARKER_BUILD_ID);
  if (!project.hasNature(IMavenConstants.NATURE_ID)) {
    return null;
  }
  final IFile pomResource=project.getFile(IMavenConstants.POM_FILE_NAME);
  if (pomResource == null) {
    log.error(""String_Node_Str"",project.getName());
    return null;
  }
  return maven.execute(new ICallable<IProject[]>(){
    public IProject[] call(    IMavenExecutionContext context,    IProgressMonitor monitor) throws CoreException {
      final IMavenProjectFacade projectFacade=getProjectFacade(pomResource,project,monitor);
      if (projectFacade == null) {
        return null;
      }
      return projectManager.execute(projectFacade,new ICallable<IProject[]>(){
        public IProject[] call(        IMavenExecutionContext context,        IProgressMonitor monitor) throws CoreException {
          try {
            projectFacade.getMavenProject(monitor);
          }
 catch (          CoreException ce) {
            addErrorMarker(project,ce);
            monitor.done();
            return null;
          }
          ILifecycleMapping lifecycleMapping=configurationManager.getLifecycleMapping(projectFacade);
          if (lifecycleMapping == null) {
            return null;
          }
          Map<MojoExecutionKey,List<AbstractBuildParticipant>> buildParticipantsByMojoExecutionKey=lifecycleMapping.getBuildParticipants(projectFacade,monitor);
          Set<IProject> dependencies=builder.build(context.getSession(),projectFacade,kind,args,buildParticipantsByMojoExecutionKey,monitor);
          log.debug(""String_Node_Str"",project.getName(),System.currentTimeMillis() - start);
          if (dependencies.isEmpty()) {
            return null;
          }
          return dependencies.toArray(new IProject[dependencies.size()]);
        }
      }
,monitor);
    }
  }
,monitor);
}","protected IProject[] build(final int kind,final Map<String,String> args,final IProgressMonitor monitor) throws CoreException {
  log.debug(""String_Node_Str"",getProject().getName());
  final long start=System.currentTimeMillis();
  try {
    return methodBuild.execute(kind,args,monitor);
  }
  finally {
    log.debug(""String_Node_Str"",getProject().getName(),System.currentTimeMillis() - start);
  }
}",0.196927924379677
91677,"void addErrorMarker(IProject project,Exception e){
  String msg=e.getMessage();
  String rootCause=M2EUtils.getRootCauseMessage(e);
  if (!e.equals(msg)) {
    msg=msg + ""String_Node_Str"" + rootCause;
  }
  IMavenMarkerManager markerManager=MavenPluginActivator.getDefault().getMavenMarkerManager();
  markerManager.addMarker(project,IMavenConstants.MARKER_BUILD_ID,msg,1,IMarker.SEVERITY_ERROR);
}","void addErrorMarker(IProject project,Exception e){
  String msg=e.getMessage();
  String rootCause=M2EUtils.getRootCauseMessage(e);
  if (!e.equals(msg)) {
    msg=msg + ""String_Node_Str"" + rootCause;
  }
  markerManager.addMarker(project,IMavenConstants.MARKER_BUILD_ID,msg,1,IMarker.SEVERITY_ERROR);
}",0.8644793152639088
91678,"protected void clean(final IProgressMonitor monitor) throws CoreException {
  final IProject project=getProject();
  markerManager.deleteMarkers(project,IMavenConstants.MARKER_BUILD_ID);
  if (!project.hasNature(IMavenConstants.NATURE_ID)) {
    return;
  }
  final IFile pomResource=project.getFile(IMavenConstants.POM_FILE_NAME);
  if (pomResource == null) {
    return;
  }
  maven.execute(new ICallable<Void>(){
    public Void call(    IMavenExecutionContext context,    IProgressMonitor monitor) throws CoreException {
      final IMavenProjectFacade projectFacade=projectManager.create(getProject(),monitor);
      if (projectFacade == null) {
        return null;
      }
      return projectManager.execute(projectFacade,new ICallable<Void>(){
        public Void call(        IMavenExecutionContext context,        IProgressMonitor monitor) throws CoreException {
          if (projectFacade.getMavenProject(monitor) == null) {
            return null;
          }
          ILifecycleMapping lifecycleMapping=configurationManager.getLifecycleMapping(projectFacade);
          if (lifecycleMapping == null) {
            return null;
          }
          Map<MojoExecutionKey,List<AbstractBuildParticipant>> buildParticipantsByMojoExecutionKey=lifecycleMapping.getBuildParticipants(projectFacade,monitor);
          MavenProject mavenProject=null;
          try {
            mavenProject=projectFacade.getMavenProject(monitor);
          }
 catch (          CoreException ce) {
            addErrorMarker(project,ce);
            return null;
          }
          builder.clean(context.getSession(),projectFacade,buildParticipantsByMojoExecutionKey,monitor);
          return null;
        }
      }
,monitor);
    }
  }
,monitor);
}","protected void clean(final IProgressMonitor monitor) throws CoreException {
  log.debug(""String_Node_Str"",getProject().getName());
  final long start=System.currentTimeMillis();
  try {
    methodClean.execute(CLEAN_BUILD,Collections.<String,String>emptyMap(),monitor);
  }
  finally {
    log.debug(""String_Node_Str"",getProject().getName(),System.currentTimeMillis() - start);
  }
}",0.1127289807421324
91679,"IMavenProjectFacade getProjectFacade(final IFile pomResource,final IProject project,final IProgressMonitor monitor) throws CoreException {
  boolean force=false;
  IResourceDelta delta=getDelta(project);
  if (delta != null) {
    delta=delta.findMember(pomResource.getFullPath());
    force=delta != null && delta.getKind() == IResourceDelta.CHANGED;
  }
  IMavenProjectFacade projectFacade=projectManager.create(getProject(),monitor);
  if (force || projectFacade == null || projectFacade.isStale()) {
    projectManager.refresh(Collections.singleton(pomResource),monitor);
    projectFacade=projectManager.create(project,monitor);
    if (projectFacade == null) {
      return null;
    }
  }
  return projectFacade;
}","IMavenProjectFacade getProjectFacade(final IProject project,final IProgressMonitor monitor) throws CoreException {
  final IFile pomResource=project.getFile(IMavenConstants.POM_FILE_NAME);
  boolean force=false;
  IResourceDelta delta=getDelta(project);
  if (delta != null) {
    delta=delta.findMember(pomResource.getFullPath());
    force=delta != null && delta.getKind() == IResourceDelta.CHANGED;
  }
  IMavenProjectFacade projectFacade=projectManager.getProject(project);
  if (force || projectFacade == null || projectFacade.isStale()) {
    projectManager.refresh(Collections.singleton(pomResource),monitor);
    projectFacade=projectManager.getProject(project);
    if (projectFacade == null) {
      return null;
    }
  }
  return projectFacade;
}",0.54631507775524
91680,"public MavenExecutionResult readMavenProject(File pomFile,ProjectBuildingRequest configuration) throws CoreException {
  long start=System.currentTimeMillis();
  log.debug(""String_Node_Str"",pomFile.getAbsoluteFile());
  MavenExecutionResult result=new DefaultMavenExecutionResult();
  try {
    configuration.setValidationLevel(ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL);
    ProjectBuildingResult projectBuildingResult=lookup(ProjectBuilder.class).build(pomFile,configuration);
    result.setProject(projectBuildingResult.getProject());
    result.setDependencyResolutionResult(projectBuildingResult.getDependencyResolutionResult());
  }
 catch (  ProjectBuildingException ex) {
    if (ex.getResults() != null && ex.getResults().size() == 1) {
      ProjectBuildingResult projectBuildingResult=ex.getResults().get(0);
      result.setProject(projectBuildingResult.getProject());
      result.setDependencyResolutionResult(projectBuildingResult.getDependencyResolutionResult());
    }
    result.addException(ex);
  }
 finally {
    log.debug(""String_Node_Str"",pomFile.getAbsoluteFile(),System.currentTimeMillis() - start);
  }
  return result;
}","public MavenExecutionResult readMavenProject(File pomFile,ProjectBuildingRequest configuration) throws CoreException {
  long start=System.currentTimeMillis();
  log.debug(""String_Node_Str"",pomFile.getAbsoluteFile());
  MavenExecutionResult result=new DefaultMavenExecutionResult();
  try {
    configuration.setValidationLevel(ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL);
    ProjectBuildingResult projectBuildingResult=lookup(ProjectBuilder.class).build(pomFile,configuration);
    result.setProject(projectBuildingResult.getProject());
    result.setDependencyResolutionResult(projectBuildingResult.getDependencyResolutionResult());
  }
 catch (  ProjectBuildingException ex) {
    if (ex.getResults() != null && ex.getResults().size() == 1) {
      ProjectBuildingResult projectBuildingResult=ex.getResults().get(0);
      result.setProject(projectBuildingResult.getProject());
      result.setDependencyResolutionResult(projectBuildingResult.getDependencyResolutionResult());
    }
    result.addException(ex);
  }
catch (  RuntimeException e) {
    result.addException(e);
  }
 finally {
    log.debug(""String_Node_Str"",pomFile.getAbsoluteFile(),System.currentTimeMillis() - start);
  }
  return result;
}",0.9733615221987316
91681,"public void updateClasspath(IProject project,IProgressMonitor monitor){
  IJavaProject javaProject=JavaCore.create(project);
  if (javaProject != null) {
    try {
      IClasspathEntry containerEntry=getMavenContainerEntry(javaProject);
      IPath path=containerEntry != null ? containerEntry.getPath() : new Path(CONTAINER_ID);
      IClasspathEntry[] classpath=getClasspath(project,monitor);
      IClasspathContainer container=new MavenClasspathContainer(path,classpath);
      JavaCore.setClasspathContainer(container.getPath(),new IJavaProject[]{javaProject},new IClasspathContainer[]{container},monitor);
      forcePackageExplorerRefresh(javaProject);
      saveContainerState(project,container);
    }
 catch (    CoreException ex) {
      log.error(ex.getMessage(),ex);
    }
  }
}","public void updateClasspath(IProject project,IProgressMonitor monitor){
  IJavaProject javaProject=JavaCore.create(project);
  if (javaProject != null) {
    try {
      IClasspathEntry containerEntry=getMavenContainerEntry(javaProject);
      IPath path=containerEntry != null ? containerEntry.getPath() : new Path(CONTAINER_ID);
      IClasspathEntry[] classpath=getClasspath(project,monitor);
      IClasspathContainer container=new MavenClasspathContainer(path,classpath);
      JavaCore.setClasspathContainer(container.getPath(),new IJavaProject[]{javaProject},new IClasspathContainer[]{container},monitor);
      saveContainerState(project,container);
    }
 catch (    CoreException ex) {
      log.error(ex.getMessage(),ex);
    }
  }
}",0.96875
91682,"protected AbstractProjectScanner<MavenProjectInfo> getProjectScanner(){
  File root=workspaceRoot.getLocation().toFile();
  MavenModelManager modelManager=MavenPlugin.getMavenModelManager();
  if (showLocation) {
    String location=rootDirectoryCombo.getText().trim();
    if (location.length() > 0) {
      return new LocalProjectScanner(root,location,false,modelManager);
    }
  }
 else   if (locations != null && !locations.isEmpty()) {
    return new LocalProjectScanner(root,locations,true,modelManager);
  }
  return new AbstractProjectScanner<MavenProjectInfo>(){
    @Override public String getDescription(){
      return ""String_Node_Str"";
    }
    @Override public void run(    IProgressMonitor monitor) throws InterruptedException {
    }
  }
;
}","protected AbstractProjectScanner<MavenProjectInfo> getProjectScanner(){
  File root=workspaceRoot.getLocation().toFile();
  MavenModelManager modelManager=MavenPlugin.getMavenModelManager();
  if (showLocation) {
    String location=rootDirectoryCombo.getText().trim();
    if (location.length() > 0) {
      return new LocalProjectScanner(root,location,false,modelManager);
    }
  }
 else   if (locations != null && !locations.isEmpty()) {
    return new LocalProjectScanner(root,locations,false,modelManager);
  }
  return new AbstractProjectScanner<MavenProjectInfo>(){
    @Override public String getDescription(){
      return ""String_Node_Str"";
    }
    @Override public void run(    IProgressMonitor monitor) throws InterruptedException {
    }
  }
;
}",0.995397764628534
91683,"public ActionMessageProblemInfo(String message,int severity,MojoExecutionKey mojoExecutionKey,SourceLocation markerLocation){
  super(message,severity,markerLocation);
  this.mojoExecutionKey=mojoExecutionKey;
}","public ActionMessageProblemInfo(String message,int severity,MojoExecutionKey mojoExecutionKey,SourceLocation markerLocation,boolean pomMapping){
  super(message,severity,mojoExecutionKey,markerLocation);
  this.pomMapping=pomMapping;
}",0.8026905829596412
91684,"private static List<PluginExecutionMetadata> applyParametersFilter(MavenSession session,List<PluginExecutionMetadata> metadatas,MavenProject mavenProject,MojoExecution execution) throws CoreException {
  IMaven maven=MavenPlugin.getMaven();
  List<PluginExecutionMetadata> result=new ArrayList<PluginExecutionMetadata>();
  all_metadatas:   for (  PluginExecutionMetadata metadata : metadatas) {
    Map<String,String> parameters=metadata.getFilter().getParameters();
    if (!parameters.isEmpty()) {
      for (      String name : parameters.keySet()) {
        String value=parameters.get(name);
        MojoExecution setupExecution=maven.setupMojoExecution(session,mavenProject,execution);
        if (!eq(value,maven.getMojoParameterValue(session,setupExecution,name,String.class))) {
          continue all_metadatas;
        }
      }
    }
    result.add(metadata);
  }
  return result;
}","private static List<PluginExecutionMetadata> applyParametersFilter(MavenSession session,List<PluginExecutionMetadata> metadatas,MavenProject mavenProject,MojoExecution execution) throws CoreException {
  IMaven maven=MavenPlugin.getMaven();
  List<PluginExecutionMetadata> result=new ArrayList<PluginExecutionMetadata>();
  all_metadatas:   for (  PluginExecutionMetadata metadata : metadatas) {
    @SuppressWarnings(""String_Node_Str"") Map<String,String> parameters=metadata.getFilter().getParameters();
    if (!parameters.isEmpty()) {
      for (      String name : parameters.keySet()) {
        String value=parameters.get(name);
        MojoExecution setupExecution=maven.setupMojoExecution(session,mavenProject,execution);
        if (!eq(value,maven.getMojoParameterValue(session,setupExecution,name,String.class))) {
          continue all_metadatas;
        }
      }
    }
    result.add(metadata);
  }
  return result;
}",0.9797482211275316
91685,"public static void instantiateProjectConfigurators(MavenProject mavenProject,LifecycleMappingResult result,Map<MojoExecutionKey,List<IPluginExecutionMetadata>> map){
  if (map == null) {
    Map<String,AbstractProjectConfigurator> configurators=Collections.emptyMap();
    result.setProjectConfigurators(configurators);
    return;
  }
  Map<String,AbstractProjectConfigurator> configurators=new LinkedHashMap<String,AbstractProjectConfigurator>();
  for (  Map.Entry<MojoExecutionKey,List<IPluginExecutionMetadata>> entry : map.entrySet()) {
    MojoExecutionKey executionKey=entry.getKey();
    List<IPluginExecutionMetadata> executionMetadatas=entry.getValue();
    if (executionMetadatas == null || executionMetadatas.isEmpty()) {
      if (isInterestingPhase(executionKey.getLifecyclePhase())) {
        SourceLocation markerLocation=SourceLocationHelper.findLocation(mavenProject,executionKey);
        result.addProblem(new NotCoveredMojoExecution(executionKey,markerLocation));
      }
      continue;
    }
    for (    IPluginExecutionMetadata metadata : executionMetadatas) {
      String message=LifecycleMappingFactory.getActionMessage(metadata);
switch (metadata.getAction()) {
case error:
{
          if (message == null) {
            message=NLS.bind(Messages.LifecycleConfigurationPluginExecutionErrorMessage,executionKey.toString());
          }
          SourceLocation markerLocation=SourceLocationHelper.findLocation(mavenProject,executionKey);
          result.addProblem(new ActionMessageProblemInfo(message,IMarker.SEVERITY_ERROR,executionKey,markerLocation));
          break;
        }
case execute:
      if (message != null) {
        SourceLocation markerLocation=SourceLocationHelper.findLocation(mavenProject,executionKey);
        result.addProblem(new ActionMessageProblemInfo(message,IMarker.SEVERITY_WARNING,executionKey,markerLocation));
      }
    break;
case configurator:
  String configuratorId=LifecycleMappingFactory.getProjectConfiguratorId(metadata);
try {
  if (!configurators.containsKey(configuratorId)) {
    configurators.put(configuratorId,LifecycleMappingFactory.createProjectConfigurator(metadata));
  }
}
 catch (LifecycleMappingConfigurationException e) {
  log.debug(""String_Node_Str"",configuratorId,e);
  SourceLocation markerLocation=SourceLocationHelper.findLocation(mavenProject,executionKey);
  result.addProblem(new MissingConfiguratorProblemInfo(configuratorId,markerLocation));
  result.addProblem(new NotCoveredMojoExecution(executionKey,markerLocation));
}
break;
case ignore:
if (message != null) {
SourceLocation markerLocation=SourceLocationHelper.findLocation(mavenProject,executionKey);
result.addProblem(new ActionMessageProblemInfo(message,IMarker.SEVERITY_WARNING,executionKey,markerLocation));
}
break;
default :
}
}
}
result.setProjectConfigurators(configurators);
}","public static void instantiateProjectConfigurators(MavenProject mavenProject,LifecycleMappingResult result,Map<MojoExecutionKey,List<IPluginExecutionMetadata>> map){
  if (map == null) {
    Map<String,AbstractProjectConfigurator> configurators=Collections.emptyMap();
    result.setProjectConfigurators(configurators);
    return;
  }
  Map<String,AbstractProjectConfigurator> configurators=new LinkedHashMap<String,AbstractProjectConfigurator>();
  for (  Map.Entry<MojoExecutionKey,List<IPluginExecutionMetadata>> entry : map.entrySet()) {
    MojoExecutionKey executionKey=entry.getKey();
    List<IPluginExecutionMetadata> executionMetadatas=entry.getValue();
    if (executionMetadatas == null || executionMetadatas.isEmpty()) {
      if (isInterestingPhase(executionKey.getLifecyclePhase())) {
        SourceLocation markerLocation=SourceLocationHelper.findLocation(mavenProject,executionKey);
        result.addProblem(new NotCoveredMojoExecution(executionKey,markerLocation));
      }
      continue;
    }
    for (    IPluginExecutionMetadata metadata : executionMetadatas) {
      String message=LifecycleMappingFactory.getActionMessage(metadata);
switch (metadata.getAction()) {
case error:
{
          if (message == null) {
            message=NLS.bind(Messages.LifecycleConfigurationPluginExecutionErrorMessage,executionKey.toString());
          }
          SourceLocation markerLocation=SourceLocationHelper.findLocation(mavenProject,executionKey);
          result.addProblem(new ActionMessageProblemInfo(message,IMarker.SEVERITY_ERROR,executionKey,markerLocation,isPomMapping(metadata)));
          break;
        }
case execute:
      if (message != null) {
        SourceLocation markerLocation=SourceLocationHelper.findLocation(mavenProject,executionKey);
        result.addProblem(new ActionMessageProblemInfo(message,IMarker.SEVERITY_WARNING,executionKey,markerLocation,isPomMapping(metadata)));
      }
    break;
case configurator:
  String configuratorId=LifecycleMappingFactory.getProjectConfiguratorId(metadata);
try {
  if (!configurators.containsKey(configuratorId)) {
    configurators.put(configuratorId,LifecycleMappingFactory.createProjectConfigurator(metadata));
  }
}
 catch (LifecycleMappingConfigurationException e) {
  log.debug(""String_Node_Str"",configuratorId,e);
  SourceLocation markerLocation=SourceLocationHelper.findLocation(mavenProject,executionKey);
  result.addProblem(new MissingConfiguratorProblemInfo(configuratorId,markerLocation));
  result.addProblem(new NotCoveredMojoExecution(executionKey,markerLocation));
}
break;
case ignore:
if (message != null) {
SourceLocation markerLocation=SourceLocationHelper.findLocation(mavenProject,executionKey);
result.addProblem(new ActionMessageProblemInfo(message,IMarker.SEVERITY_WARNING,executionKey,markerLocation,isPomMapping(metadata)));
}
break;
default :
}
}
}
result.setProjectConfigurators(configurators);
}",0.988010425716768
91686,"public void processMarker(IMarker marker) throws CoreException {
  super.processMarker(marker);
  marker.setAttribute(IMavenConstants.MARKER_ATTR_EDITOR_HINT,IMavenConstants.EDITOR_HINT_NOT_COVERED_MOJO_EXECUTION);
  marker.setAttribute(IMavenConstants.MARKER_ATTR_GROUP_ID,mojoExecutionKey.getGroupId());
  marker.setAttribute(IMavenConstants.MARKER_ATTR_ARTIFACT_ID,mojoExecutionKey.getArtifactId());
  marker.setAttribute(IMavenConstants.MARKER_ATTR_EXECUTION_ID,mojoExecutionKey.getExecutionId());
  marker.setAttribute(IMavenConstants.MARKER_ATTR_GOAL,mojoExecutionKey.getGoal());
  marker.setAttribute(IMavenConstants.MARKER_ATTR_VERSION,mojoExecutionKey.getVersion());
  marker.setAttribute(IMavenConstants.MARKER_ATTR_LIFECYCLE_PHASE,mojoExecutionKey.getLifecyclePhase());
}","public void processMarker(IMarker marker) throws CoreException {
  super.processMarker(marker);
  marker.setAttribute(IMavenConstants.MARKER_ATTR_EDITOR_HINT,IMavenConstants.EDITOR_HINT_NOT_COVERED_MOJO_EXECUTION);
}",0.4328657314629258
91687,"public NotCoveredMojoExecution(MojoExecutionKey mojoExecutionKey,SourceLocation markerLocation){
  super(NLS.bind(Messages.LifecycleConfigurationPluginExecutionNotCovered,mojoExecutionKey.toString()),markerLocation);
  this.mojoExecutionKey=mojoExecutionKey;
}","public NotCoveredMojoExecution(MojoExecutionKey mojoExecutionKey,SourceLocation markerLocation){
  super(NLS.bind(Messages.LifecycleConfigurationPluginExecutionNotCovered,mojoExecutionKey.toString()),mojoExecutionKey,markerLocation);
}",0.8808080808080808
91688,"public IMarkerResolution[] getResolutions(IMarker marker){
  String hint=marker.getAttribute(IMavenConstants.MARKER_ATTR_EDITOR_HINT,null);
  if (hint != null) {
    if (IMavenConstants.EDITOR_HINT_MISSING_SCHEMA.equals(hint)) {
      return new IMarkerResolution[]{new XMLSchemaMarkerResolution()};
    }
    if (IMavenConstants.EDITOR_HINT_PARENT_VERSION.equals(hint)) {
      return new IMarkerResolution[]{new PomQuickAssistProcessor.IdPartRemovalProposal(marker,true)};
    }
    if (IMavenConstants.EDITOR_HINT_PARENT_GROUP_ID.equals(hint)) {
      return new IMarkerResolution[]{new PomQuickAssistProcessor.IdPartRemovalProposal(marker,false)};
    }
    if (hint.equals(IMavenConstants.EDITOR_HINT_MANAGED_DEPENDENCY_OVERRIDE)) {
      return new IMarkerResolution[]{new PomQuickAssistProcessor.ManagedVersionRemovalProposal(marker,true),new PomQuickAssistProcessor.IgnoreWarningProposal(marker,IMavenConstants.MARKER_IGNORE_MANAGED)};
    }
    if (hint.equals(IMavenConstants.EDITOR_HINT_MANAGED_PLUGIN_OVERRIDE)) {
      return new IMarkerResolution[]{new PomQuickAssistProcessor.ManagedVersionRemovalProposal(marker,false),new PomQuickAssistProcessor.IgnoreWarningProposal(marker,IMavenConstants.MARKER_IGNORE_MANAGED)};
    }
    if (hint.equals(IMavenConstants.EDITOR_HINT_NOT_COVERED_MOJO_EXECUTION)) {
      return new IMarkerResolution[]{new LifecycleMappingProposal(marker,PluginExecutionAction.ignore)};
    }
  }
  return new IMarkerResolution[0];
}","public IMarkerResolution[] getResolutions(IMarker marker){
  String hint=marker.getAttribute(IMavenConstants.MARKER_ATTR_EDITOR_HINT,null);
  if (hint != null) {
    if (IMavenConstants.EDITOR_HINT_MISSING_SCHEMA.equals(hint)) {
      return new IMarkerResolution[]{new XMLSchemaMarkerResolution()};
    }
    if (IMavenConstants.EDITOR_HINT_PARENT_VERSION.equals(hint)) {
      return new IMarkerResolution[]{new PomQuickAssistProcessor.IdPartRemovalProposal(marker,true)};
    }
    if (IMavenConstants.EDITOR_HINT_PARENT_GROUP_ID.equals(hint)) {
      return new IMarkerResolution[]{new PomQuickAssistProcessor.IdPartRemovalProposal(marker,false)};
    }
    if (hint.equals(IMavenConstants.EDITOR_HINT_MANAGED_DEPENDENCY_OVERRIDE)) {
      return new IMarkerResolution[]{new PomQuickAssistProcessor.ManagedVersionRemovalProposal(marker,true),new PomQuickAssistProcessor.IgnoreWarningProposal(marker,IMavenConstants.MARKER_IGNORE_MANAGED)};
    }
    if (hint.equals(IMavenConstants.EDITOR_HINT_MANAGED_PLUGIN_OVERRIDE)) {
      return new IMarkerResolution[]{new PomQuickAssistProcessor.ManagedVersionRemovalProposal(marker,false),new PomQuickAssistProcessor.IgnoreWarningProposal(marker,IMavenConstants.MARKER_IGNORE_MANAGED)};
    }
    if (hint.equals(IMavenConstants.EDITOR_HINT_NOT_COVERED_MOJO_EXECUTION)) {
      return new IMarkerResolution[]{new LifecycleMappingProposal(marker,PluginExecutionAction.ignore)};
    }
    if (marker.getAttribute(IMarker.SEVERITY,IMarker.SEVERITY_ERROR) == IMarker.SEVERITY_ERROR && hint.equals(IMavenConstants.EDITOR_HINT_IMPLICIT_LIFECYCLEMAPPING)) {
      return new IMarkerResolution[]{new LifecycleMappingProposal(marker,PluginExecutionAction.ignore)};
    }
  }
  return new IMarkerResolution[0];
}",0.9132732359341
91689,"public static IHyperlink createHyperlink(final MarkerRegion mark){
  return new IHyperlink(){
    public IRegion getHyperlinkRegion(){
      return new Region(mark.getOffset(),mark.getLength());
    }
    public String getTypeLabel(){
      return ""String_Node_Str"";
    }
    public String getHyperlinkText(){
      return NLS.bind(""String_Node_Str"",mark.getAnnotation().getText());
    }
    public void open(){
      IMarker marker=mark.getAnnotation().getMarker();
      String loc=marker.getAttribute(IMavenConstants.MARKER_CAUSE_RESOURCE_PATH,null);
      if (loc != null) {
        IFileStore fileStore=EFS.getLocalFileSystem().getStore(new Path(loc));
        int row=marker.getAttribute(IMavenConstants.MARKER_CAUSE_LINE_NUMBER,0);
        int column=marker.getAttribute(IMavenConstants.MARKER_CAUSE_COLUMN_START,0);
        String name=marker.getAttribute(IMavenConstants.MARKER_CAUSE_RESOURCE_ID,null);
        String hint=marker.getAttribute(IMavenConstants.MARKER_ATTR_EDITOR_HINT,null);
        if (IMavenConstants.EDITOR_HINT_NOT_COVERED_MOJO_EXECUTION.equals(hint)) {
        }
        openXmlEditor(fileStore,row,column,name);
      }
    }
  }
;
}","public static IHyperlink createHyperlink(final MarkerRegion mark){
  return new IHyperlink(){
    public IRegion getHyperlinkRegion(){
      return new Region(mark.getOffset(),mark.getLength());
    }
    public String getTypeLabel(){
      return ""String_Node_Str"";
    }
    public String getHyperlinkText(){
      return NLS.bind(""String_Node_Str"",mark.getAnnotation().getText());
    }
    public void open(){
      IMarker marker=mark.getAnnotation().getMarker();
      String loc=marker.getAttribute(IMavenConstants.MARKER_CAUSE_RESOURCE_PATH,null);
      if (loc != null) {
        IFileStore fileStore=EFS.getLocalFileSystem().getStore(new Path(loc));
        int row=marker.getAttribute(IMavenConstants.MARKER_CAUSE_LINE_NUMBER,0);
        int column=marker.getAttribute(IMavenConstants.MARKER_CAUSE_COLUMN_START,0);
        String name=marker.getAttribute(IMavenConstants.MARKER_CAUSE_RESOURCE_ID,null);
        openXmlEditor(fileStore,row,column,name);
      }
    }
  }
;
}",0.916279069767442
91690,"public ICompletionProposal[] computeQuickAssistProposals(IQuickAssistInvocationContext context){
  List<ICompletionProposal> proposals=new ArrayList<ICompletionProposal>();
  Iterator<Annotation> annotationIterator=context.getSourceViewer().getAnnotationModel().getAnnotationIterator();
  while (annotationIterator.hasNext()) {
    Annotation annotation=annotationIterator.next();
    if (annotation instanceof MarkerAnnotation) {
      MarkerAnnotation mark=(MarkerAnnotation)annotation;
      try {
        Position position=context.getSourceViewer().getAnnotationModel().getPosition(annotation);
        int lineNum=context.getSourceViewer().getDocument().getLineOfOffset(position.getOffset()) + 1;
        int currentLineNum=context.getSourceViewer().getDocument().getLineOfOffset(context.getOffset()) + 1;
        if (currentLineNum == lineNum) {
          String hint=mark.getMarker().getAttribute(IMavenConstants.MARKER_ATTR_EDITOR_HINT,null);
          if (hint != null) {
            if (hint.equals(IMavenConstants.EDITOR_HINT_PARENT_GROUP_ID)) {
              proposals.add(new IdPartRemovalProposal(context,false,mark));
            }
 else             if (hint.equals(IMavenConstants.EDITOR_HINT_PARENT_VERSION)) {
              proposals.add(new IdPartRemovalProposal(context,true,mark));
            }
 else             if (hint.equals(IMavenConstants.EDITOR_HINT_MANAGED_DEPENDENCY_OVERRIDE)) {
              proposals.add(new ManagedVersionRemovalProposal(context,true,mark));
              proposals.add(new IgnoreWarningProposal(context,mark,IMavenConstants.MARKER_IGNORE_MANAGED));
            }
 else             if (hint.equals(IMavenConstants.EDITOR_HINT_MANAGED_PLUGIN_OVERRIDE)) {
              proposals.add(new ManagedVersionRemovalProposal(context,false,mark));
              proposals.add(new IgnoreWarningProposal(context,mark,IMavenConstants.MARKER_IGNORE_MANAGED));
            }
 else             if (hint.equals(IMavenConstants.EDITOR_HINT_MISSING_SCHEMA)) {
              proposals.add(new SchemaCompletionProposal(context,mark));
            }
 else             if (hint.equals(IMavenConstants.EDITOR_HINT_NOT_COVERED_MOJO_EXECUTION)) {
              extractedFromMarkers(proposals,mark);
              proposals.add(new LifecycleMappingProposal(context,mark,PluginExecutionAction.ignore));
            }
          }
        }
      }
 catch (      Exception e) {
        MvnIndexPlugin.getDefault().getLog().log(new Status(IStatus.ERROR,MvnIndexPlugin.PLUGIN_ID,""String_Node_Str"",e));
      }
    }
  }
  if (proposals.size() > 0) {
    return proposals.toArray(new ICompletionProposal[0]);
  }
  return null;
}","public ICompletionProposal[] computeQuickAssistProposals(IQuickAssistInvocationContext context){
  List<ICompletionProposal> proposals=new ArrayList<ICompletionProposal>();
  Iterator<Annotation> annotationIterator=context.getSourceViewer().getAnnotationModel().getAnnotationIterator();
  while (annotationIterator.hasNext()) {
    Annotation annotation=annotationIterator.next();
    if (annotation instanceof MarkerAnnotation) {
      MarkerAnnotation mark=(MarkerAnnotation)annotation;
      try {
        Position position=context.getSourceViewer().getAnnotationModel().getPosition(annotation);
        int lineNum=context.getSourceViewer().getDocument().getLineOfOffset(position.getOffset()) + 1;
        int currentLineNum=context.getSourceViewer().getDocument().getLineOfOffset(context.getOffset()) + 1;
        if (currentLineNum == lineNum) {
          String hint=mark.getMarker().getAttribute(IMavenConstants.MARKER_ATTR_EDITOR_HINT,null);
          if (hint != null) {
            if (hint.equals(IMavenConstants.EDITOR_HINT_PARENT_GROUP_ID)) {
              proposals.add(new IdPartRemovalProposal(context,false,mark));
            }
 else             if (hint.equals(IMavenConstants.EDITOR_HINT_PARENT_VERSION)) {
              proposals.add(new IdPartRemovalProposal(context,true,mark));
            }
 else             if (hint.equals(IMavenConstants.EDITOR_HINT_MANAGED_DEPENDENCY_OVERRIDE)) {
              proposals.add(new ManagedVersionRemovalProposal(context,true,mark));
              proposals.add(new IgnoreWarningProposal(context,mark,IMavenConstants.MARKER_IGNORE_MANAGED));
            }
 else             if (hint.equals(IMavenConstants.EDITOR_HINT_MANAGED_PLUGIN_OVERRIDE)) {
              proposals.add(new ManagedVersionRemovalProposal(context,false,mark));
              proposals.add(new IgnoreWarningProposal(context,mark,IMavenConstants.MARKER_IGNORE_MANAGED));
            }
 else             if (hint.equals(IMavenConstants.EDITOR_HINT_MISSING_SCHEMA)) {
              proposals.add(new SchemaCompletionProposal(context,mark));
            }
 else             if (hint.equals(IMavenConstants.EDITOR_HINT_NOT_COVERED_MOJO_EXECUTION)) {
              extractedFromMarkers(proposals,mark);
              proposals.add(new LifecycleMappingProposal(context,mark,PluginExecutionAction.ignore));
            }
 else             if (mark.getMarker().getAttribute(IMarker.SEVERITY,IMarker.SEVERITY_ERROR) == IMarker.SEVERITY_ERROR && hint.equals(IMavenConstants.EDITOR_HINT_IMPLICIT_LIFECYCLEMAPPING)) {
              extractedFromMarkers(proposals,mark);
              proposals.add(new LifecycleMappingProposal(context,mark,PluginExecutionAction.ignore));
            }
          }
        }
      }
 catch (      Exception e) {
        MvnIndexPlugin.getDefault().getLog().log(new Status(IStatus.ERROR,MvnIndexPlugin.PLUGIN_ID,""String_Node_Str"",e));
      }
    }
  }
  if (proposals.size() > 0) {
    return proposals.toArray(new ICompletionProposal[0]);
  }
  return null;
}",0.9363507779349364
91691,"protected void okPressed(){
  ISelection selection=codebaseViewer.getSelection();
  if (selection instanceof IStructuredSelection) {
    Object[] obj=((IStructuredSelection)selection).toArray();
    IProject[] projects=new IProject[obj.length];
    for (int i=0; i < obj.length; i++) {
      projects[i]=(IProject)obj[i];
    }
    selectedProjects=projects;
  }
  isOffline=offline.getSelection();
  isForceUpdate=forceUpdate.getSelection();
  super.okPressed();
}","protected void okPressed(){
  Object[] obj=codebaseViewer.getCheckedElements();
  IProject[] projects=new IProject[obj.length];
  for (int i=0; i < obj.length; i++) {
    projects[i]=(IProject)obj[i];
  }
  selectedProjects=projects;
  isOffline=offline.getSelection();
  isForceUpdate=forceUpdate.getSelection();
  super.okPressed();
}",0.3395755305867665
91692,"protected MavenExecutionRequest getConfiguredExecutionRequest(DependencyResolutionContext context,IProjectRegistry state,IFile pom,ResolverConfiguration resolverConfiguration) throws CoreException {
  MavenExecutionRequest mavenRequest=DefaultMavenExecutionRequest.copy(context.getExecutionRequest());
  configureExecutionRequest(mavenRequest,state,pom,resolverConfiguration);
  getMaven().populateDefaults(mavenRequest);
  mavenRequest.setOffline(context.getRequest().isOffline());
  mavenRequest.setUpdateSnapshots(context.isForce(pom));
  return mavenRequest;
}","protected MavenExecutionRequest getConfiguredExecutionRequest(DependencyResolutionContext context,IProjectRegistry state,IFile pom,ResolverConfiguration resolverConfiguration) throws CoreException {
  MavenExecutionRequest mavenRequest=DefaultMavenExecutionRequest.copy(context.getExecutionRequest());
  configureExecutionRequest(mavenRequest,state,pom,resolverConfiguration);
  getMaven().populateDefaults(mavenRequest);
  mavenRequest.setOffline(context.getRequest().isOffline());
  mavenRequest.setUpdateSnapshots(context.isForce(pom) && context.getRequest().isUpdateSnapshots());
  return mavenRequest;
}",0.962457337883959
91693,"public static void persist(IMavenProjectFacade facade,IProgressMonitor monitor){
  try {
    LifecycleMappingConfiguration configuration=newLifecycleMappingConfiguration(facade,monitor);
    if (configuration == null) {
      return;
    }
    File configFile=getConfigurationFile(facade.getProject());
    ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(configFile));
    try {
      oos.writeObject(configuration);
      oos.flush();
    }
  finally {
      IOUtil.close(oos);
    }
  }
 catch (  CoreException ex) {
    log.warn(""String_Node_Str"",facade.toString(),ex);
  }
catch (  IOException ex) {
    log.warn(""String_Node_Str"",facade.toString(),ex);
  }
}","private static void persist(IProject project,LifecycleMappingConfiguration configuration){
  try {
    File configFile=getConfigurationFile(project);
    ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(configFile));
    try {
      oos.writeObject(configuration);
      oos.flush();
    }
  finally {
      IOUtil.close(oos);
    }
  }
 catch (  IOException ex) {
    log.warn(""String_Node_Str"",project.toString(),ex);
  }
}",0.6008888888888889
91694,"private IProject create(MavenProjectInfo projectInfo,ProjectImportConfiguration configuration,IProgressMonitor monitor) throws CoreException {
  IWorkspace workspace=ResourcesPlugin.getWorkspace();
  IWorkspaceRoot root=workspace.getRoot();
  File pomFile=projectInfo.getPomFile();
  Model model=projectInfo.getModel();
  if (model == null) {
    model=maven.readModel(pomFile);
    projectInfo.setModel(model);
  }
  String projectName=configuration.getProjectName(model);
  File projectDir=pomFile.getParentFile();
  String projectParent=projectDir.getParentFile().getAbsolutePath();
  if (projectInfo.getBasedirRename() == MavenProjectInfo.RENAME_REQUIRED) {
    File newProject=new File(projectDir.getParent(),projectName);
    if (!projectDir.equals(newProject)) {
      boolean renamed=projectDir.renameTo(newProject);
      if (!renamed) {
        StringBuilder msg=new StringBuilder();
        msg.append(NLS.bind(Messages.ProjectConfigurationManager_error_rename,projectDir.getAbsolutePath())).append('.');
        if (newProject.exists()) {
          msg.append(NLS.bind(Messages.ProjectConfigurationManager_error_targetDir,newProject.getAbsolutePath()));
        }
        throw new CoreException(new Status(IStatus.ERROR,IMavenConstants.PLUGIN_ID,-1,msg.toString(),null));
      }
      projectInfo.setPomFile(getCanonicalPomFile(newProject));
      projectDir=newProject;
    }
  }
 else {
    if (projectParent.equals(root.getLocation().toFile().getAbsolutePath())) {
      projectName=projectDir.getName();
    }
  }
  monitor.subTask(NLS.bind(Messages.ProjectConfigurationManager_task_importing2,projectName));
  IProject project=root.getProject(projectName);
  if (project.exists()) {
    log.error(""String_Node_Str"" + projectName + ""String_Node_Str"");
    return null;
  }
  if (projectDir.equals(root.getLocation().toFile())) {
    log.error(""String_Node_Str"" + projectName + ""String_Node_Str"");
    return null;
  }
  if (projectParent.equals(root.getLocation().toFile().getAbsolutePath())) {
    project.create(monitor);
  }
 else {
    IProjectDescription description=workspace.newProjectDescription(projectName);
    description.setLocation(new Path(projectDir.getAbsolutePath()));
    project.create(description,monitor);
  }
  if (!project.isOpen()) {
    project.open(monitor);
  }
  ResolverConfiguration resolverConfiguration=configuration.getResolverConfiguration();
  enableBasicMavenNature(project,resolverConfiguration,monitor);
  return project;
}","private IProject create(MavenProjectInfo projectInfo,ProjectImportConfiguration configuration,IProgressMonitor monitor) throws CoreException {
  IWorkspace workspace=ResourcesPlugin.getWorkspace();
  IWorkspaceRoot root=workspace.getRoot();
  File pomFile=projectInfo.getPomFile();
  Model model=projectInfo.getModel();
  if (model == null) {
    model=maven.readModel(pomFile);
    projectInfo.setModel(model);
  }
  String projectName=configuration.getProjectName(model);
  File projectDir=pomFile.getParentFile();
  String projectParent=projectDir.getParentFile().getAbsolutePath();
  if (projectInfo.getBasedirRename() == MavenProjectInfo.RENAME_REQUIRED) {
    File newProject=new File(projectDir.getParent(),projectName);
    if (!projectDir.equals(newProject)) {
      boolean renamed=projectDir.renameTo(newProject);
      if (!renamed) {
        StringBuilder msg=new StringBuilder();
        msg.append(NLS.bind(Messages.ProjectConfigurationManager_error_rename,projectDir.getAbsolutePath())).append('.');
        if (newProject.exists()) {
          msg.append(NLS.bind(Messages.ProjectConfigurationManager_error_targetDir,newProject.getAbsolutePath()));
        }
        throw new CoreException(new Status(IStatus.ERROR,IMavenConstants.PLUGIN_ID,-1,msg.toString(),null));
      }
      projectInfo.setPomFile(getCanonicalPomFile(newProject));
      projectDir=newProject;
    }
  }
 else {
    if (projectParent.equals(root.getLocation().toFile().getAbsolutePath())) {
      projectName=projectDir.getName();
    }
  }
  monitor.subTask(NLS.bind(Messages.ProjectConfigurationManager_task_importing2,projectName));
  IProject project=root.getProject(projectName);
  if (project.exists()) {
    log.error(""String_Node_Str"" + projectName + ""String_Node_Str"");
    return null;
  }
  if (projectDir.equals(root.getLocation().toFile())) {
    log.error(""String_Node_Str"" + projectName + ""String_Node_Str"");
    return null;
  }
  if (projectParent.equals(root.getLocation().toFile().getAbsolutePath())) {
    project.create(monitor);
  }
 else {
    IProjectDescription description=workspace.newProjectDescription(projectName);
    description.setLocation(new Path(projectDir.getAbsolutePath()));
    project.create(description,monitor);
  }
  if (!project.isOpen()) {
    project.open(monitor);
  }
  ResolverConfiguration resolverConfiguration=configuration.getResolverConfiguration();
  enableBasicMavenNature(project,resolverConfiguration,monitor);
  LifecycleMappingConfiguration.persistEmpty(project);
  return project;
}",0.9890329012961117
91695,"private static IMarker findMarker(String type,String message,Integer lineNumber,String resourceRelativePath,List<IMarker> markers) throws Exception {
  for (  IMarker marker : markers) {
    if (type != null && !type.equals(marker.getType())) {
      continue;
    }
    if (!marker.getAttribute(IMarker.MESSAGE,""String_Node_Str"").startsWith(message)) {
      continue;
    }
    if (lineNumber != null && !lineNumber.equals(marker.getAttribute(IMarker.LINE_NUMBER))) {
      continue;
    }
    if (type != null && type.startsWith(IMavenConstants.MARKER_ID)) {
      Assert.assertEquals(""String_Node_Str"" + toString(marker),false,marker.getAttribute(IMarker.TRANSIENT));
    }
    if (resourceRelativePath == null) {
      resourceRelativePath=""String_Node_Str"";
    }
    Assert.assertEquals(""String_Node_Str"" + toString(marker),resourceRelativePath,marker.getResource().getProjectRelativePath().toString());
    return marker;
  }
  return null;
}","private static IMarker findMarker(String type,String message,Integer lineNumber,String resourceRelativePath,List<IMarker> markers) throws Exception {
  for (  IMarker marker : markers) {
    if (type != null && !type.equals(marker.getType())) {
      continue;
    }
    if (message != null && !marker.getAttribute(IMarker.MESSAGE,""String_Node_Str"").startsWith(message)) {
      continue;
    }
    if (lineNumber != null && !lineNumber.equals(marker.getAttribute(IMarker.LINE_NUMBER))) {
      continue;
    }
    if (type != null && type.startsWith(IMavenConstants.MARKER_ID)) {
      Assert.assertEquals(""String_Node_Str"" + toString(marker),false,marker.getAttribute(IMarker.TRANSIENT));
    }
    if (resourceRelativePath == null) {
      resourceRelativePath=""String_Node_Str"";
    }
    Assert.assertEquals(""String_Node_Str"" + toString(marker),resourceRelativePath,marker.getResource().getProjectRelativePath().toString());
    return marker;
  }
  return null;
}",0.99009900990099
91696,"private boolean warnIncompleteMapping(){
  if (!skipIncompleteWarning()) {
    MessageDialogWithToggle dialog=MessageDialogWithToggle.open(MessageDialog.CONFIRM,getShell(),Messages.MavenImportWizard_titleIncompleteMapping,Messages.MavenImportWizard_messageIncompleteMapping,""String_Node_Str"",false,null,null,SWT.SHEET);
    M2EUIPluginActivator.getDefault().getPreferenceStore().setValue(MavenPreferenceConstants.P_WARN_INCOMPLETE_MAPPING,dialog.getToggleState());
    return dialog.getReturnCode() == Window.OK;
  }
  return true;
}","private boolean warnIncompleteMapping(){
  if (!skipIncompleteWarning()) {
    MessageDialogWithToggle dialog=MessageDialogWithToggle.open(MessageDialog.CONFIRM,getShell(),Messages.MavenImportWizard_titleIncompleteMapping,Messages.MavenImportWizard_messageIncompleteMapping,""String_Node_Str"",false,null,null,SWT.SHEET);
    if (dialog.getReturnCode() == Window.OK) {
      M2EUIPluginActivator.getDefault().getPreferenceStore().setValue(MavenPreferenceConstants.P_WARN_INCOMPLETE_MAPPING,dialog.getToggleState());
      return true;
    }
    return false;
  }
  return true;
}",0.8666666666666667
91697,"public RefactoringStatus checkFinalConditions(IProgressMonitor pm) throws CoreException, OperationCanceledException {
  changes=new ArrayList<Change>();
  Set<ArtifactKey> locatedKeys=new HashSet<ArtifactKey>();
  List<IStatus> statuses=new ArrayList<IStatus>();
  SubMonitor monitor=SubMonitor.convert(pm,getHierarchy().size());
  List<Operation> exclusionOp=new ArrayList<Operation>();
  Visitor visitor=locate(exclusionPoint,monitor.newChild(1));
  for (  Entry<Dependency,Set<ArtifactKey>> entry : visitor.getSourceMap().entrySet()) {
    locatedKeys.addAll(entry.getValue());
    if (contains(entry.getValue(),entry.getKey())) {
      exclusionOp.add(new RemoveDependencyOperation(entry.getKey()));
    }
 else {
      for (      ArtifactKey key : entry.getValue()) {
        exclusionOp.add(new AddExclusionOperation(entry.getKey(),key));
      }
    }
  }
  for (  MavenProject project : getDescendants()) {
    visitor=locate(project,monitor.newChild(1));
    List<Operation> operations=new ArrayList<Operation>();
    for (    Entry<Dependency,Set<ArtifactKey>> entry : visitor.getSourceMap().entrySet()) {
      locatedKeys.addAll(entry.getValue());
      Dependency dependency=entry.getKey();
      operations.add(new RemoveDependencyOperation(dependency));
      if (!contains(entry.getValue(),dependency)) {
        exclusionOp.add(new AddDependencyOperation(dependency));
        for (        ArtifactKey key : entry.getValue()) {
          exclusionOp.add(new AddExclusionOperation(dependency,key));
        }
      }
    }
    if (operations.size() > 0) {
      IFile pom=getFile(project);
      changes.add(PomHelper.createChange(pom,new CompoundOperation(operations.toArray(new Operation[operations.size()])),getName(pom)));
    }
  }
  for (  MavenProject project : getAncestors()) {
    visitor=locate(project,monitor.newChild(1));
    for (    Entry<Dependency,Set<ArtifactKey>> entry : locate(project,monitor.newChild(1)).getSourceMap().entrySet()) {
      locatedKeys.addAll(entry.getValue());
      Dependency dependency=entry.getKey();
      if (contains(entry.getValue(),dependency)) {
        if (project.getFile() != null) {
          statuses.add(new Status(IStatus.INFO,PLUGIN_ID,NLS.bind(Messages.ExcludeArtifactRefactoring_removeDependencyFrom,toString(dependency),getMavenProjectFacade(project).getPom().getFullPath())));
          IFile pom=getFile(project);
          changes.add(PomHelper.createChange(getFile(project),new RemoveDependencyOperation(dependency),getName(pom)));
        }
      }
 else {
        exclusionOp.add(new AddDependencyOperation(dependency));
        for (        ArtifactKey key : entry.getValue()) {
          exclusionOp.add(new AddExclusionOperation(dependency,key));
        }
      }
    }
  }
  if (!exclusionOp.isEmpty()) {
    changes.add(PomHelper.createChange(getFile(exclusionPoint),new CompoundOperation(exclusionOp.toArray(new Operation[exclusionOp.size()])),getName(pomFile)));
  }
  if (statuses.size() == 1) {
    return RefactoringStatus.create(statuses.get(0));
  }
 else   if (statuses.size() > 1) {
    return RefactoringStatus.create(new MultiStatus(PLUGIN_ID,0,statuses.toArray(new IStatus[statuses.size()]),Messages.ExcludeArtifactRefactoring_errorCreatingRefactoring,null));
  }
 else   if (locatedKeys.isEmpty()) {
    return RefactoringStatus.createFatalErrorStatus(Messages.ExcludeArtifactRefactoring_noTargets);
  }
 else   if (locatedKeys.size() != keys.length) {
    StringBuilder sb=new StringBuilder();
    for (    ArtifactKey key : keys) {
      if (!locatedKeys.contains(key)) {
        sb.append(key.toString()).append(',');
      }
    }
    sb.deleteCharAt(sb.length() - 1);
    return RefactoringStatus.createErrorStatus(NLS.bind(Messages.ExcludeArtifactRefactoring_failedToLocateArtifact,sb.toString()));
  }
  return new RefactoringStatus();
}","public RefactoringStatus checkFinalConditions(IProgressMonitor pm) throws CoreException, OperationCanceledException {
  changes=new ArrayList<Change>();
  Set<ArtifactKey> locatedKeys=new HashSet<ArtifactKey>();
  List<IStatus> statuses=new ArrayList<IStatus>();
  SubMonitor monitor=SubMonitor.convert(pm,getHierarchy().size());
  List<Operation> exclusionOp=new ArrayList<Operation>();
  Visitor visitor=locate(exclusionPoint,monitor.newChild(1));
  for (  Entry<Dependency,Set<ArtifactKey>> entry : visitor.getSourceMap().entrySet()) {
    locatedKeys.addAll(entry.getValue());
    Dependency dependency=entry.getKey();
    if (contains(entry.getValue(),dependency)) {
      exclusionOp.add(new RemoveDependencyOperation(dependency));
    }
 else {
      for (      ArtifactKey key : entry.getValue()) {
        if (!hasExclusion(exclusionPoint,dependency,key)) {
          exclusionOp.add(new AddExclusionOperation(dependency,key));
        }
      }
    }
  }
  for (  MavenProject project : getDescendants()) {
    visitor=locate(project,monitor.newChild(1));
    List<Operation> operations=new ArrayList<Operation>();
    for (    Entry<Dependency,Set<ArtifactKey>> entry : visitor.getSourceMap().entrySet()) {
      locatedKeys.addAll(entry.getValue());
      Dependency dependency=entry.getKey();
      operations.add(new RemoveDependencyOperation(dependency));
      if (!contains(entry.getValue(),dependency)) {
        if (!hasDependency(exclusionPoint,dependency)) {
          exclusionOp.add(new AddDependencyOperation(dependency));
        }
        for (        ArtifactKey key : entry.getValue()) {
          if (!hasExclusion(exclusionPoint,dependency,key)) {
            exclusionOp.add(new AddExclusionOperation(dependency,key));
          }
        }
      }
    }
    if (operations.size() > 0) {
      IFile pom=getFile(project);
      changes.add(PomHelper.createChange(pom,new CompoundOperation(operations.toArray(new Operation[operations.size()])),getName(pom)));
    }
  }
  for (  MavenProject project : getAncestors()) {
    visitor=locate(project,monitor.newChild(1));
    for (    Entry<Dependency,Set<ArtifactKey>> entry : locate(project,monitor.newChild(1)).getSourceMap().entrySet()) {
      locatedKeys.addAll(entry.getValue());
      Dependency dependency=entry.getKey();
      if (contains(entry.getValue(),dependency)) {
        if (project.getFile() != null) {
          statuses.add(new Status(IStatus.INFO,PLUGIN_ID,NLS.bind(Messages.ExcludeArtifactRefactoring_removeDependencyFrom,toString(dependency),getMavenProjectFacade(project).getPom().getFullPath())));
          IFile pom=getFile(project);
          changes.add(PomHelper.createChange(getFile(project),new RemoveDependencyOperation(dependency),getName(pom)));
        }
      }
 else {
        exclusionOp.add(new AddDependencyOperation(dependency));
        for (        ArtifactKey key : entry.getValue()) {
          if (!hasExclusion(exclusionPoint,dependency,key)) {
            exclusionOp.add(new AddExclusionOperation(dependency,key));
          }
        }
      }
    }
  }
  if (!exclusionOp.isEmpty()) {
    IFile pom=getFile(exclusionPoint);
    changes.add(PomHelper.createChange(pom,new CompoundOperation(exclusionOp.toArray(new Operation[exclusionOp.size()])),getName(pom)));
  }
  if (statuses.size() == 1) {
    return RefactoringStatus.create(statuses.get(0));
  }
 else   if (statuses.size() > 1) {
    return RefactoringStatus.create(new MultiStatus(PLUGIN_ID,0,statuses.toArray(new IStatus[statuses.size()]),Messages.ExcludeArtifactRefactoring_errorCreatingRefactoring,null));
  }
 else   if (locatedKeys.isEmpty()) {
    return RefactoringStatus.createFatalErrorStatus(Messages.ExcludeArtifactRefactoring_noTargets);
  }
 else   if (locatedKeys.size() != keys.length) {
    StringBuilder sb=new StringBuilder();
    for (    ArtifactKey key : keys) {
      if (!locatedKeys.contains(key)) {
        sb.append(key.toString()).append(',');
      }
    }
    sb.deleteCharAt(sb.length() - 1);
    return RefactoringStatus.createErrorStatus(NLS.bind(Messages.ExcludeArtifactRefactoring_failedToLocateArtifact,sb.toString()));
  }
  return new RefactoringStatus();
}",0.8665006226650063
91698,"private Collection<MavenProject> getDescendants(){
  List<MavenProject> descendants=new ArrayList<MavenProject>();
  boolean add=true;
  for (  MavenProject project : getHierarchy()) {
    if (project == exclusionPoint) {
      add=!add;
    }
 else     if (add) {
      descendants.add(project);
    }
  }
  return descendants;
}","private Collection<MavenProject> getDescendants(){
  List<MavenProject> descendants=new ArrayList<MavenProject>();
  for (  MavenProject project : getHierarchy()) {
    if (project == exclusionPoint) {
      break;
    }
 else {
      descendants.add(project);
    }
  }
  return descendants;
}",0.8846153846153846
91699,"public boolean implement(List<IMavenDiscoveryProposal> proposals,IRunnableWithProgress postInstallHook,IRunnableContext context,Collection<String> projectsToConfigure){
  try {
    MavenDiscoveryInstallOperation runner=new MavenDiscoveryInstallOperation(toCatalogItems(proposals),postInstallHook,true,projectsToConfigure);
    context.run(true,true,runner);
    int openInstallWizard=MavenDiscoveryUi.openInstallWizard(runner.getOperation(),true);
    return openInstallWizard == Window.OK;
  }
 catch (  InvocationTargetException e) {
    IStatus status=new Status(IStatus.ERROR,DiscoveryActivator.PLUGIN_ID,NLS.bind(Messages.ConnectorDiscoveryWizard_installProblems,new Object[]{e.getCause().getMessage()}),e.getCause());
    StatusManager.getManager().handle(status,StatusManager.SHOW | StatusManager.BLOCK | StatusManager.LOG);
    return false;
  }
catch (  InterruptedException e) {
    return false;
  }
}","public boolean implement(List<IMavenDiscoveryProposal> proposals,IRunnableWithProgress postInstallHook,IRunnableContext context,Collection<String> projectsToConfigure){
  try {
    MavenDiscoveryInstallOperation runner=new MavenDiscoveryInstallOperation(toCatalogItems(proposals),postInstallHook,true,false,projectsToConfigure);
    context.run(true,true,runner);
    int openInstallWizard=MavenDiscoveryUi.openInstallWizard(runner.getOperation(),true);
    return openInstallWizard == Window.OK;
  }
 catch (  InvocationTargetException e) {
    IStatus status=new Status(IStatus.ERROR,DiscoveryActivator.PLUGIN_ID,NLS.bind(Messages.ConnectorDiscoveryWizard_installProblems,new Object[]{e.getCause().getMessage()}),e.getCause());
    StatusManager.getManager().handle(status,StatusManager.SHOW | StatusManager.BLOCK | StatusManager.LOG);
    return false;
  }
catch (  InterruptedException e) {
    return false;
  }
}",0.99672131147541
91700,"private RestartInstallOperation createAndResolve(IProgressMonitor monitor,final IInstallableUnit[] ius,URI[] repositories,boolean requireRestart) throws CoreException {
  SubMonitor mon=SubMonitor.convert(monitor,ius.length);
  try {
    RestartInstallOperation op=new RestartInstallOperation(session,Arrays.asList(ius),postInstallHook,projectsToConfigure,requireRestart ? ProvisioningJob.RESTART_ONLY : ProvisioningJob.RESTART_NONE);
    IStatus operationStatus=op.resolveModal(mon);
    if (operationStatus.getSeverity() > IStatus.WARNING) {
      throw new CoreException(operationStatus);
    }
    return op;
  }
  finally {
    mon.done();
  }
}","private RestartInstallOperation createAndResolve(IProgressMonitor monitor,final IInstallableUnit[] ius,URI[] repositories,boolean requireRestart) throws CoreException {
  SubMonitor mon=SubMonitor.convert(monitor,ius.length);
  try {
    RestartInstallOperation op=new RestartInstallOperation(session,Arrays.asList(ius),postInstallHook,projectsToConfigure,requireRestart ? ProvisioningJob.RESTART_ONLY : ProvisioningJob.RESTART_NONE);
    if (shouldResolve) {
      IStatus operationStatus=op.resolveModal(mon);
      if (operationStatus.getSeverity() > IStatus.WARNING) {
        throw new CoreException(operationStatus);
      }
    }
    return op;
  }
  finally {
    mon.done();
  }
}",0.970873786407767
91701,"public MavenDiscoveryInstallOperation(List<CatalogItem> installableConnectors,IRunnableWithProgress postInstallHook,boolean restart,Collection<String> projectsToConfigure){
  this.installableConnectors=installableConnectors;
  this.postInstallHook=postInstallHook;
  this.restart=restart;
  this.session=ProvisioningUI.getDefaultUI().getSession();
  this.projectsToConfigure=projectsToConfigure;
}","public MavenDiscoveryInstallOperation(List<CatalogItem> installableConnectors,IRunnableWithProgress postInstallHook,boolean restart,boolean shouldResolve,Collection<String> projectsToConfigure){
  this.installableConnectors=installableConnectors;
  this.postInstallHook=postInstallHook;
  this.restart=restart;
  this.session=ProvisioningUI.getDefaultUI().getSession();
  this.shouldResolve=shouldResolve;
  this.projectsToConfigure=projectsToConfigure;
}",0.931924882629108
91702,"public void process(Document document){
  Element depElement=PomHelper.findDependency(document,dependency);
  if (depElement != null) {
    Element exclusionsElement=getChild(depElement,EXCLUSIONS);
    Element exclusionElement=createElement(exclusionsElement,EXCLUSION);
    createElementWithText(exclusionElement,ARTIFACT_ID,exclusion.getArtifactId());
    createElementWithText(exclusionElement,GROUP_ID,exclusion.getGroupId());
    format(exclusionElement);
  }
}","public void process(Document document){
  Element depElement=PomHelper.findDependency(document,dependency);
  if (depElement != null) {
    Element exclusionsElement=getChild(depElement,EXCLUSIONS);
    if (null == PomEdits.findChild(exclusionsElement,EXCLUSION,childEquals(GROUP_ID,exclusion.getGroupId()),childEquals(ARTIFACT_ID,exclusion.getArtifactId()))) {
      Element exclusionElement=createElement(exclusionsElement,EXCLUSION);
      createElementWithText(exclusionElement,ARTIFACT_ID,exclusion.getArtifactId());
      createElementWithText(exclusionElement,GROUP_ID,exclusion.getGroupId());
      format(exclusionElement);
    }
  }
 else {
    log.debug(""String_Node_Str"" + dependency + ""String_Node_Str""+ exclusion.toString());
  }
}",0.4636963696369637
91703,"public RefactoringStatus checkFinalConditions(IProgressMonitor pm) throws CoreException, OperationCanceledException {
  changes=new ArrayList<Change>();
  locatedKeys=new HashSet<ArtifactKey>();
  List<IStatus> statuses=new ArrayList<IStatus>();
  SubMonitor monitor=SubMonitor.convert(pm,getHierarchy().size());
  List<Operation> exclusionOp=new ArrayList<Operation>();
  Visitor visitor=locate(exclusionPoint,monitor.newChild(1));
  for (  Entry<Dependency,Set<ArtifactKey>> entry : visitor.getSourceMap().entrySet()) {
    exclusionPoint.getOriginalModel().getDependencies();
    locatedKeys.addAll(entry.getValue());
    if (contains(entry.getValue(),entry.getKey())) {
      exclusionOp.add(new RemoveDependencyOperation(entry.getKey()));
    }
 else {
      for (      ArtifactKey key : entry.getValue()) {
        exclusionOp.add(new AddExclusionOperation(entry.getKey(),key));
      }
    }
  }
  for (  MavenProject project : getDescendants()) {
    visitor=locate(project,monitor.newChild(1));
    for (    Entry<Dependency,Set<ArtifactKey>> entry : visitor.getSourceMap().entrySet()) {
      locatedKeys.addAll(entry.getValue());
      if (contains(entry.getValue(),entry.getKey())) {
        changes.add(PomHelper.createChange(getFile(project),new RemoveDependencyOperation(entry.getKey()),""String_Node_Str""));
      }
 else {
        CompositeChange change=new CompositeChange(""String_Node_Str"");
        change.add(PomHelper.createChange(getFile(project),new RemoveDependencyOperation(entry.getKey()),""String_Node_Str""));
        exclusionOp.add(new AddDependencyOperation(entry.getKey()));
        for (        ArtifactKey key : entry.getValue()) {
          exclusionOp.add(new AddExclusionOperation(entry.getKey(),key));
        }
      }
    }
    if (!visitor.getStatus().isOK()) {
      statuses.add(visitor.getStatus());
    }
  }
  for (  MavenProject project : getAncestors()) {
    visitor=locate(project,monitor.newChild(1));
    for (    Entry<Dependency,Set<ArtifactKey>> entry : locate(project,monitor.newChild(1)).getSourceMap().entrySet()) {
      locatedKeys.addAll(entry.getValue());
      if (contains(entry.getValue(),entry.getKey())) {
        if (project.getFile() != null) {
          changes.add(PomHelper.createChange(getFile(project),new RemoveDependencyOperation(entry.getKey()),""String_Node_Str""));
        }
      }
 else {
        exclusionOp.add(new AddDependencyOperation(entry.getKey()));
        for (        ArtifactKey key : entry.getValue()) {
          exclusionOp.add(new AddExclusionOperation(entry.getKey(),key));
        }
      }
    }
    if (!visitor.getStatus().isOK()) {
      statuses.add(visitor.getStatus());
    }
  }
  changes.add(PomHelper.createChange(getFile(exclusionPoint),new CompoundOperation(exclusionOp.toArray(new Operation[exclusionOp.size()])),getName()));
  if (statuses.size() == 1) {
    return RefactoringStatus.create(statuses.get(0));
  }
 else   if (statuses.size() > 1) {
    return RefactoringStatus.create(new MultiStatus(""String_Node_Str"",0,statuses.toArray(new IStatus[statuses.size()]),""String_Node_Str"",null));
  }
 else   if (locatedKeys.isEmpty()) {
    return RefactoringStatus.createFatalErrorStatus(Messages.AbstractPomHeirarchyRefactoring_noTargets);
  }
 else   if (locatedKeys.size() != keys.length) {
    StringBuilder sb=new StringBuilder();
    for (    ArtifactKey key : keys) {
      if (!locatedKeys.contains(key)) {
        sb.append(key.toString()).append(',');
      }
    }
    sb.deleteCharAt(sb.length() - 1);
    return RefactoringStatus.createErrorStatus(NLS.bind(Messages.ExcludeArtifactRefactoring_failedToLocateArtifact,sb.toString()));
  }
  return new RefactoringStatus();
}","public RefactoringStatus checkFinalConditions(IProgressMonitor pm) throws CoreException, OperationCanceledException {
  changes=new ArrayList<Change>();
  Set<ArtifactKey> locatedKeys=new HashSet<ArtifactKey>();
  List<IStatus> statuses=new ArrayList<IStatus>();
  SubMonitor monitor=SubMonitor.convert(pm,getHierarchy().size());
  List<Operation> exclusionOp=new ArrayList<Operation>();
  Visitor visitor=locate(exclusionPoint,monitor.newChild(1));
  for (  Entry<Dependency,Set<ArtifactKey>> entry : visitor.getSourceMap().entrySet()) {
    locatedKeys.addAll(entry.getValue());
    if (contains(entry.getValue(),entry.getKey())) {
      exclusionOp.add(new RemoveDependencyOperation(entry.getKey()));
    }
 else {
      for (      ArtifactKey key : entry.getValue()) {
        exclusionOp.add(new AddExclusionOperation(entry.getKey(),key));
      }
    }
  }
  for (  MavenProject project : getDescendants()) {
    visitor=locate(project,monitor.newChild(1));
    for (    Entry<Dependency,Set<ArtifactKey>> entry : visitor.getSourceMap().entrySet()) {
      locatedKeys.addAll(entry.getValue());
      if (contains(entry.getValue(),entry.getKey())) {
        changes.add(PomHelper.createChange(getFile(project),new RemoveDependencyOperation(entry.getKey()),""String_Node_Str""));
      }
 else {
        CompositeChange change=new CompositeChange(""String_Node_Str"");
        change.add(PomHelper.createChange(getFile(project),new RemoveDependencyOperation(entry.getKey()),""String_Node_Str""));
        exclusionOp.add(new AddDependencyOperation(entry.getKey()));
        for (        ArtifactKey key : entry.getValue()) {
          exclusionOp.add(new AddExclusionOperation(entry.getKey(),key));
        }
      }
    }
  }
  for (  MavenProject project : getAncestors()) {
    visitor=locate(project,monitor.newChild(1));
    for (    Entry<Dependency,Set<ArtifactKey>> entry : locate(project,monitor.newChild(1)).getSourceMap().entrySet()) {
      locatedKeys.addAll(entry.getValue());
      Dependency dependency=entry.getKey();
      if (contains(entry.getValue(),dependency)) {
        if (project.getFile() != null) {
          statuses.add(new Status(IStatus.INFO,PLUGIN_ID,NLS.bind(""String_Node_Str"",toString(dependency),getMavenProjectFacade(project).getPom().getFullPath())));
          changes.add(PomHelper.createChange(getFile(project),new RemoveDependencyOperation(dependency),""String_Node_Str""));
        }
      }
 else {
        exclusionOp.add(new AddDependencyOperation(dependency));
        for (        ArtifactKey key : entry.getValue()) {
          exclusionOp.add(new AddExclusionOperation(dependency,key));
        }
      }
    }
  }
  if (!exclusionOp.isEmpty()) {
    changes.add(PomHelper.createChange(getFile(exclusionPoint),new CompoundOperation(exclusionOp.toArray(new Operation[exclusionOp.size()])),getName()));
  }
  if (statuses.size() == 1) {
    return RefactoringStatus.create(statuses.get(0));
  }
 else   if (statuses.size() > 1) {
    return RefactoringStatus.create(new MultiStatus(PLUGIN_ID,0,statuses.toArray(new IStatus[statuses.size()]),""String_Node_Str"",null));
  }
 else   if (locatedKeys.isEmpty()) {
    return RefactoringStatus.createFatalErrorStatus(Messages.AbstractPomHeirarchyRefactoring_noTargets);
  }
 else   if (locatedKeys.size() != keys.length) {
    StringBuilder sb=new StringBuilder();
    for (    ArtifactKey key : keys) {
      if (!locatedKeys.contains(key)) {
        sb.append(key.toString()).append(',');
      }
    }
    sb.deleteCharAt(sb.length() - 1);
    return RefactoringStatus.createErrorStatus(NLS.bind(Messages.ExcludeArtifactRefactoring_failedToLocateArtifact,sb.toString()));
  }
  return new RefactoringStatus();
}",0.921162947937796
91704,"private void updateState(){
  ExcludeArtifactRefactoring refactoring=(ExcludeArtifactRefactoring)getRefactoring();
  if (hierarchy.getSelection()) {
    MavenProject project=fromSelection(pomHierarchy.getSelection());
    setPageComplete(project != null && project.getFile() != null);
    if (project != null && project.getFile() == null) {
      setStatus(""String_Node_Str"");
    }
 else {
      setStatus(null);
      refactoring.setExclusionPoint(fromSelection(pomHierarchy.getSelection()));
    }
  }
 else {
    setStatus(null);
    refactoring.setExclusionPoint(facade.getMavenProject());
  }
}","private void updateState(){
  ExcludeArtifactRefactoring refactoring=(ExcludeArtifactRefactoring)getRefactoring();
  if (hierarchy.getSelection()) {
    MavenProject project=fromSelection(pomHierarchy.getSelection());
    updateStatusBar(project);
    refactoring.setExclusionPoint(project);
  }
 else {
    updateStatusBar(facade.getMavenProject());
    refactoring.setExclusionPoint(facade.getMavenProject());
  }
}",0.6705998033431662
91705,"private void setStatus(String msg){
  if (msg == null) {
    label.setImage(null);
    label.setText(""String_Node_Str"");
  }
 else {
    label.setText(msg);
    label.setImage(PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_OBJS_ERROR_TSK));
  }
}","private void setStatus(String msg){
  if (msg == null) {
    status.setImage(null);
    status.setText(""String_Node_Str"");
  }
 else {
    status.setText(msg);
    status.setImage(PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_OBJS_ERROR_TSK));
  }
}",0.8419117647058824
91706,"public void createControl(Composite parent){
  Composite composite=new Composite(parent,SWT.NULL);
  setControl(composite);
  composite.setLayout(new GridLayout(1,false));
  currentPom=new Button(composite,SWT.RADIO);
  currentPom.setLayoutData(new GridData(SWT.LEFT,SWT.CENTER,false,false));
  currentPom.setText(""String_Node_Str"");
  currentPom.setSelection(true);
  currentPom.addSelectionListener(this);
  hierarchy=new Button(composite,SWT.RADIO);
  hierarchy.setLayoutData(new GridData(SWT.LEFT,SWT.TOP,false,false));
  hierarchy.setText(""String_Node_Str"");
  hierarchy.addSelectionListener(this);
  pomHierarchy=new PomHierarchyComposite(composite,SWT.BORDER);
  GridData gd_pomHierarchy=new GridData(SWT.FILL,SWT.FILL,true,true);
  gd_pomHierarchy.horizontalIndent=15;
  pomHierarchy.setLayoutData(gd_pomHierarchy);
  pomHierarchy.setEnabled(false);
  pomHierarchy.addSelectionChangedListener(this);
  label=new CLabel(composite,SWT.NONE);
  label.setLayoutData(new GridData(SWT.LEFT,SWT.CENTER,true,false));
  Display.getCurrent().asyncExec(new Runnable(){
    public void run(){
      pomHierarchy.computeHeirarchy(facade,getContainer());
      ((ExcludeArtifactRefactoring)getRefactoring()).setHierarchy(pomHierarchy.getHierarchy());
    }
  }
);
}","public void createControl(Composite parent){
  Composite composite=new Composite(parent,SWT.NULL);
  setControl(composite);
  composite.setLayout(new GridLayout(1,false));
  Label label=new Label(composite,SWT.NONE);
  label.setLayoutData(new GridData(SWT.LEFT,SWT.TOP,true,false));
  label.setText(""String_Node_Str"");
  currentPom=new Button(composite,SWT.RADIO);
  GridData gd_currentPom=new GridData(SWT.LEFT,SWT.CENTER,false,false,1,1);
  gd_currentPom.horizontalIndent=15;
  currentPom.setLayoutData(gd_currentPom);
  currentPom.setText(facade.getArtifactKey().toString());
  currentPom.setSelection(true);
  currentPom.addSelectionListener(this);
  hierarchy=new Button(composite,SWT.RADIO);
  GridData gd_hierarchy=new GridData(SWT.LEFT,SWT.TOP,false,false);
  gd_hierarchy.horizontalIndent=15;
  hierarchy.setLayoutData(gd_hierarchy);
  hierarchy.setText(""String_Node_Str"");
  hierarchy.addSelectionListener(this);
  pomHierarchy=new PomHierarchyComposite(composite,SWT.BORDER);
  GridData gd_pomHierarchy=new GridData(SWT.FILL,SWT.FILL,true,true);
  gd_pomHierarchy.horizontalIndent=35;
  pomHierarchy.setLayoutData(gd_pomHierarchy);
  pomHierarchy.setEnabled(false);
  pomHierarchy.addSelectionChangedListener(this);
  status=new CLabel(composite,SWT.NONE);
  status.setLayoutData(new GridData(SWT.FILL,SWT.BOTTOM,true,false));
  Display.getCurrent().asyncExec(new Runnable(){
    public void run(){
      pomHierarchy.computeHeirarchy(facade,getContainer());
      ((ExcludeArtifactRefactoring)getRefactoring()).setHierarchy(pomHierarchy.getHierarchy());
    }
  }
);
}",0.3642127509686509
91707,"public static void calculateEffectiveLifecycleMappingMetadata(LifecycleMappingResult result,MavenExecutionRequest templateRequest,List<MappingMetadataSource> metadataSources,MavenProject mavenProject,List<MojoExecution> mojoExecutions){
  IMaven maven=MavenPlugin.getDefault().getMaven();
  MavenSession session=maven.createSession(newMavenExecutionRequest(templateRequest),mavenProject);
  LifecycleMappingMetadata lifecycleMappingMetadata=null;
  MappingMetadataSource originalMetadataSource=null;
  for (int i=0; i < metadataSources.size(); i++) {
    MappingMetadataSource source=metadataSources.get(i);
    try {
      lifecycleMappingMetadata=source.getLifecycleMappingMetadata(mavenProject.getPackaging());
      if (lifecycleMappingMetadata != null) {
        originalMetadataSource=new SimpleMappingMetadataSource(lifecycleMappingMetadata);
        metadataSources.add(i,originalMetadataSource);
        break;
      }
    }
 catch (    DuplicateMappingException e) {
      log.error(""String_Node_Str"",mavenProject.toString());
      result.addProblem(new MavenProblemInfo(1,NLS.bind(Messages.LifecycleDuplicate,mavenProject.getPackaging())));
      return;
    }
  }
  if (lifecycleMappingMetadata == null) {
    lifecycleMappingMetadata=new LifecycleMappingMetadata();
    lifecycleMappingMetadata.setLifecycleMappingId(""String_Node_Str"");
    lifecycleMappingMetadata.setPackagingType(mavenProject.getPackaging());
  }
  result.setLifecycleMappingMetadata(lifecycleMappingMetadata);
  Map<MojoExecutionKey,List<PluginExecutionMetadata>> executionMapping=new LinkedHashMap<MojoExecutionKey,List<PluginExecutionMetadata>>();
  if (mojoExecutions != null) {
    for (    MojoExecution execution : mojoExecutions) {
      MojoExecutionKey executionKey=new MojoExecutionKey(execution);
      PluginExecutionMetadata primaryMetadata=null;
      try {
        for (        MappingMetadataSource source : metadataSources) {
          List<PluginExecutionMetadata> metadatas=applyParametersFilter(session,source.getPluginExecutionMetadata(executionKey),mavenProject,execution);
          for (          PluginExecutionMetadata executionMetadata : metadatas) {
            if (LifecycleMappingFactory.isPrimaryMapping(executionMetadata)) {
              if (primaryMetadata != null) {
                primaryMetadata=null;
                throw new DuplicateMappingException();
              }
              primaryMetadata=executionMetadata;
            }
          }
          if (primaryMetadata != null) {
            break;
          }
        }
      }
 catch (      DuplicateMappingException e) {
        log.debug(""String_Node_Str"",executionKey.toString());
        result.addProblem(new MavenProblemInfo(1,NLS.bind(Messages.PluginExecutionMappingDuplicate,executionKey.toString())));
      }
      if (primaryMetadata != null && !isValidPluginExecutionMetadata(primaryMetadata)) {
        log.debug(""String_Node_Str"",executionKey.toString());
        result.addProblem(new MavenProblemInfo(1,NLS.bind(Messages.PluginExecutionMappingInvalid,executionKey.toString())));
        primaryMetadata=null;
      }
      List<PluginExecutionMetadata> executionMetadatas=new ArrayList<PluginExecutionMetadata>();
      if (primaryMetadata != null) {
        executionMetadatas.add(primaryMetadata);
        if (primaryMetadata.getAction() == PluginExecutionAction.configurator) {
          for (          MappingMetadataSource source : metadataSources) {
            List<PluginExecutionMetadata> metadatas=source.getPluginExecutionMetadata(executionKey);
            metadatas=applyParametersFilter(session,metadatas,mavenProject,execution);
            for (            PluginExecutionMetadata metadata : metadatas) {
              if (isValidPluginExecutionMetadata(metadata)) {
                if (metadata.getAction() == PluginExecutionAction.configurator && isSecondaryMapping(metadata,primaryMetadata)) {
                  executionMetadatas.add(metadata);
                }
              }
 else {
                log.debug(""String_Node_Str"",executionKey.toString());
              }
            }
          }
        }
      }
      executionMapping.put(executionKey,executionMetadatas);
    }
  }
 else {
    log.debug(""String_Node_Str"",mavenProject.toString());
  }
  result.setMojoExecutionMapping(executionMapping);
}","public static void calculateEffectiveLifecycleMappingMetadata(LifecycleMappingResult result,MavenExecutionRequest templateRequest,List<MappingMetadataSource> metadataSources,MavenProject mavenProject,List<MojoExecution> mojoExecutions){
  IMaven maven=MavenPlugin.getDefault().getMaven();
  MavenSession session=maven.createSession(newMavenExecutionRequest(templateRequest),mavenProject);
  LifecycleMappingMetadata lifecycleMappingMetadata=null;
  MappingMetadataSource originalMetadataSource=null;
  for (int i=0; i < metadataSources.size(); i++) {
    MappingMetadataSource source=metadataSources.get(i);
    try {
      lifecycleMappingMetadata=source.getLifecycleMappingMetadata(mavenProject.getPackaging());
      if (lifecycleMappingMetadata != null) {
        originalMetadataSource=new SimpleMappingMetadataSource(lifecycleMappingMetadata);
        metadataSources.add(i,originalMetadataSource);
        break;
      }
    }
 catch (    DuplicateMappingException e) {
      log.error(""String_Node_Str"",mavenProject.toString());
      result.addProblem(new MavenProblemInfo(1,NLS.bind(Messages.LifecycleDuplicate,mavenProject.getPackaging())));
      return;
    }
  }
  if (lifecycleMappingMetadata == null) {
    lifecycleMappingMetadata=new LifecycleMappingMetadata();
    lifecycleMappingMetadata.setLifecycleMappingId(""String_Node_Str"");
    lifecycleMappingMetadata.setPackagingType(mavenProject.getPackaging());
  }
  result.setLifecycleMappingMetadata(lifecycleMappingMetadata);
  Map<MojoExecutionKey,List<PluginExecutionMetadata>> executionMapping=new LinkedHashMap<MojoExecutionKey,List<PluginExecutionMetadata>>();
  if (mojoExecutions != null) {
    for (    MojoExecution execution : mojoExecutions) {
      MojoExecutionKey executionKey=new MojoExecutionKey(execution);
      PluginExecutionMetadata primaryMetadata=null;
      try {
        for (        MappingMetadataSource source : metadataSources) {
          try {
            List<PluginExecutionMetadata> metadatas=applyParametersFilter(session,source.getPluginExecutionMetadata(executionKey),mavenProject,execution);
            for (            PluginExecutionMetadata executionMetadata : metadatas) {
              if (LifecycleMappingFactory.isPrimaryMapping(executionMetadata)) {
                if (primaryMetadata != null) {
                  primaryMetadata=null;
                  throw new DuplicateMappingException();
                }
                primaryMetadata=executionMetadata;
              }
            }
            if (primaryMetadata != null) {
              break;
            }
          }
 catch (          CoreException e) {
            SourceLocation location=SourceLocationHelper.findLocation(mavenProject,executionKey);
            result.addProblem(new MavenProblemInfo(location,e));
          }
        }
      }
 catch (      DuplicateMappingException e) {
        log.debug(""String_Node_Str"",executionKey.toString());
        result.addProblem(new MavenProblemInfo(1,NLS.bind(Messages.PluginExecutionMappingDuplicate,executionKey.toString())));
      }
      if (primaryMetadata != null && !isValidPluginExecutionMetadata(primaryMetadata)) {
        log.debug(""String_Node_Str"",executionKey.toString());
        result.addProblem(new MavenProblemInfo(1,NLS.bind(Messages.PluginExecutionMappingInvalid,executionKey.toString())));
        primaryMetadata=null;
      }
      List<PluginExecutionMetadata> executionMetadatas=new ArrayList<PluginExecutionMetadata>();
      if (primaryMetadata != null) {
        executionMetadatas.add(primaryMetadata);
        if (primaryMetadata.getAction() == PluginExecutionAction.configurator) {
          for (          MappingMetadataSource source : metadataSources) {
            try {
              List<PluginExecutionMetadata> metadatas=source.getPluginExecutionMetadata(executionKey);
              metadatas=applyParametersFilter(session,metadatas,mavenProject,execution);
              for (              PluginExecutionMetadata metadata : metadatas) {
                if (isValidPluginExecutionMetadata(metadata)) {
                  if (metadata.getAction() == PluginExecutionAction.configurator && isSecondaryMapping(metadata,primaryMetadata)) {
                    executionMetadatas.add(metadata);
                  }
                }
 else {
                  log.debug(""String_Node_Str"",executionKey.toString());
                }
              }
            }
 catch (            CoreException e) {
              SourceLocation location=SourceLocationHelper.findLocation(mavenProject,executionKey);
              result.addProblem(new MavenProblemInfo(location,e));
            }
          }
        }
      }
      executionMapping.put(executionKey,executionMetadatas);
    }
  }
 else {
    log.debug(""String_Node_Str"",mavenProject.toString());
  }
  result.setMojoExecutionMapping(executionMapping);
}",0.940908103410819
91708,"private static List<PluginExecutionMetadata> applyParametersFilter(MavenSession session,List<PluginExecutionMetadata> metadatas,MavenProject mavenProject,MojoExecution execution){
  IMaven maven=MavenPlugin.getDefault().getMaven();
  List<PluginExecutionMetadata> result=new ArrayList<PluginExecutionMetadata>();
  all_metadatas:   for (  PluginExecutionMetadata metadata : metadatas) {
    Map<String,String> parameters=metadata.getFilter().getParameters();
    if (!parameters.isEmpty()) {
      for (      String name : parameters.keySet()) {
        String value=parameters.get(name);
        try {
          MojoExecution setupExecution=maven.setupMojoExecution(session,mavenProject,execution);
          if (!eq(value,maven.getMojoParameterValue(session,setupExecution,name,String.class))) {
            continue all_metadatas;
          }
        }
 catch (        CoreException ex) {
          log.warn(""String_Node_Str"",new Object[]{name,execution.toString(),ex});
          continue all_metadatas;
        }
      }
    }
    result.add(metadata);
  }
  return result;
}","private static List<PluginExecutionMetadata> applyParametersFilter(MavenSession session,List<PluginExecutionMetadata> metadatas,MavenProject mavenProject,MojoExecution execution) throws CoreException {
  IMaven maven=MavenPlugin.getDefault().getMaven();
  List<PluginExecutionMetadata> result=new ArrayList<PluginExecutionMetadata>();
  all_metadatas:   for (  PluginExecutionMetadata metadata : metadatas) {
    Map<String,String> parameters=metadata.getFilter().getParameters();
    if (!parameters.isEmpty()) {
      for (      String name : parameters.keySet()) {
        String value=parameters.get(name);
        MojoExecution setupExecution=maven.setupMojoExecution(session,mavenProject,execution);
        if (!eq(value,maven.getMojoParameterValue(session,setupExecution,name,String.class))) {
          continue all_metadatas;
        }
      }
    }
    result.add(metadata);
  }
  return result;
}",0.8470824949698189
91709,"public void run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
  projectScanner.run(monitor);
  ((MavenImportWizard)getWizard()).scanProjects(getProjects(projectScanner.getProjects()),monitor);
}","public void run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
  projectScanner.run(monitor);
  try {
    ((MavenImportWizard)getWizard()).scanProjects(getProjects(projectScanner.getProjects()),monitor);
  }
 catch (  InvocationTargetException x) {
    analyzingExc[0]=x;
  }
}",0.8492647058823529
91710,"protected void scanProjects(){
  final AbstractProjectScanner<MavenProjectInfo> projectScanner=getProjectScanner();
  try {
    getWizard().getContainer().run(true,true,new IRunnableWithProgress(){
      public void run(      IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
        projectScanner.run(monitor);
        ((MavenImportWizard)getWizard()).scanProjects(getProjects(projectScanner.getProjects()),monitor);
      }
      List<MavenProjectInfo> getProjects(      Collection<MavenProjectInfo> input){
        List<MavenProjectInfo> toRet=new ArrayList<MavenProjectInfo>();
        for (        MavenProjectInfo info : input) {
          toRet.add(info);
          toRet.addAll(getProjects(info.getProjects()));
        }
        return toRet;
      }
    }
);
    projectTreeViewer.setInput(projectScanner.getProjects());
    projectTreeViewer.expandAll();
    setAllChecked(true);
    Object[] checkedElements=projectTreeViewer.getCheckedElements();
    setPageComplete(checkedElements != null && checkedElements.length > 0);
    setErrorMessage(null);
    setMessage(null);
    List<Throwable> errors=projectScanner.getErrors();
    if (!errors.isEmpty()) {
      StringBuffer sb=new StringBuffer(NLS.bind(Messages.wizardImportPageScanningErrors,errors.size()));
      int n=1;
      for (      Throwable ex : errors) {
        if (ex instanceof CoreException) {
          String msg=((CoreException)ex).getStatus().getMessage();
          sb.append(""String_Node_Str"").append(n).append(""String_Node_Str"").append(msg.trim());
        }
 else {
          String msg=ex.getMessage() == null ? ex.toString() : ex.getMessage();
          sb.append(""String_Node_Str"").append(n).append(""String_Node_Str"").append(msg.trim());
        }
        n++;
      }
      setMessage(sb.toString(),IMessageProvider.WARNING);
    }
  }
 catch (  InterruptedException ex) {
  }
catch (  InvocationTargetException ex) {
    Throwable e=ex.getTargetException() == null ? ex : ex.getTargetException();
    String msg;
    if (e instanceof CoreException) {
      msg=e.getMessage();
      log.error(msg,e);
    }
 else {
      msg=""String_Node_Str"" + projectScanner.getDescription() + ""String_Node_Str""+ e.toString();
      log.error(msg,e);
    }
    projectTreeViewer.setInput(null);
    setPageComplete(false);
    setErrorMessage(msg);
  }
}","protected void scanProjects(){
  final AbstractProjectScanner<MavenProjectInfo> projectScanner=getProjectScanner();
  final InvocationTargetException[] analyzingExc=new InvocationTargetException[1];
  try {
    getWizard().getContainer().run(true,true,new IRunnableWithProgress(){
      public void run(      IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
        projectScanner.run(monitor);
        try {
          ((MavenImportWizard)getWizard()).scanProjects(getProjects(projectScanner.getProjects()),monitor);
        }
 catch (        InvocationTargetException x) {
          analyzingExc[0]=x;
        }
      }
      List<MavenProjectInfo> getProjects(      Collection<MavenProjectInfo> input){
        List<MavenProjectInfo> toRet=new ArrayList<MavenProjectInfo>();
        for (        MavenProjectInfo info : input) {
          toRet.add(info);
          toRet.addAll(getProjects(info.getProjects()));
        }
        return toRet;
      }
    }
);
    projectTreeViewer.setInput(projectScanner.getProjects());
    projectTreeViewer.expandAll();
    setAllChecked(true);
    Object[] checkedElements=projectTreeViewer.getCheckedElements();
    setPageComplete(checkedElements != null && checkedElements.length > 0);
    setErrorMessage(null);
    setMessage(null);
    List<Throwable> errors=projectScanner.getErrors();
    if (!errors.isEmpty() || analyzingExc[0] != null) {
      StringBuffer sb=new StringBuffer(NLS.bind(Messages.wizardImportPageScanningErrors,errors.size()));
      int n=1;
      for (      Throwable ex : errors) {
        if (ex instanceof CoreException) {
          String msg=((CoreException)ex).getStatus().getMessage();
          sb.append(""String_Node_Str"").append(n).append(""String_Node_Str"").append(msg.trim());
        }
 else {
          String msg=ex.getMessage() == null ? ex.toString() : ex.getMessage();
          sb.append(""String_Node_Str"").append(n).append(""String_Node_Str"").append(msg.trim());
        }
        n++;
      }
      if (analyzingExc[0] != null) {
        sb.append(""String_Node_Str"").append(analyzingExc[0].getCause().getMessage());
      }
      setMessage(sb.toString(),IMessageProvider.WARNING);
    }
  }
 catch (  InterruptedException ex) {
  }
catch (  InvocationTargetException ex) {
    Throwable e=ex.getCause() == null ? ex : ex.getCause();
    String msg;
    if (e instanceof CoreException) {
      msg=e.getMessage();
      log.error(msg,e);
    }
 else {
      msg=""String_Node_Str"" + projectScanner.getDescription() + ""String_Node_Str""+ e.toString();
      log.error(msg,e);
    }
    projectTreeViewer.setInput(null);
    setPageComplete(false);
    setErrorMessage(msg);
  }
}",0.9224086870681144
91711,"private List<MavenProblemInfo> toMavenProblemInfos(SourceLocation location,List<? extends Throwable> exceptions){
  List<MavenProblemInfo> result=new ArrayList<MavenProblemInfo>();
  if (exceptions == null) {
    return result;
  }
  for (  Throwable ex : exceptions) {
    if (ex instanceof org.sonatype.aether.transfer.ArtifactNotFoundException) {
      org.sonatype.aether.transfer.ArtifactNotFoundException artifactNotFoundException=(org.sonatype.aether.transfer.ArtifactNotFoundException)ex;
      ArtifactNotFoundProblemInfo problem=new ArtifactNotFoundProblemInfo(artifactNotFoundException.getArtifact(),mavenConfiguration.isOffline(),location);
      result.add(problem);
    }
 else     if (ex instanceof AbstractArtifactResolutionException) {
      AbstractArtifactResolutionException abstractArtifactResolutionException=(AbstractArtifactResolutionException)ex;
      String errorMessage=getArtifactId(abstractArtifactResolutionException) + ""String_Node_Str"" + getRootErrorMessage(ex);
      result.add(new MavenProblemInfo(errorMessage,location));
    }
 else     if (ex instanceof ProjectBuildingException) {
      Throwable cause=ex.getCause();
      if (cause instanceof ModelBuildingException) {
        ModelBuildingException mbe=(ModelBuildingException)cause;
        for (        ModelProblem problem : mbe.getProblems()) {
          String message=NLS.bind(Messages.pluginMarkerBuildError,problem.getMessage());
          int severity=(Severity.WARNING == problem.getSeverity()) ? IMarker.SEVERITY_WARNING : IMarker.SEVERITY_ERROR;
          SourceLocation problemLocation=new SourceLocation(problem.getLineNumber(),1,1);
          result.add(new MavenProblemInfo(message,severity,problemLocation));
        }
      }
 else {
        result.add(new MavenProblemInfo(getErrorMessage(ex),location));
      }
    }
 else {
      result.add(new MavenProblemInfo(getErrorMessage(ex),location));
    }
  }
  return result;
}","private List<MavenProblemInfo> toMavenProblemInfos(MavenProject mavenProject,SourceLocation location,List<? extends Throwable> exceptions){
  List<MavenProblemInfo> result=new ArrayList<MavenProblemInfo>();
  if (exceptions == null) {
    return result;
  }
  for (  Throwable ex : exceptions) {
    if (ex instanceof org.sonatype.aether.transfer.ArtifactNotFoundException) {
      org.sonatype.aether.transfer.ArtifactNotFoundException artifactNotFoundException=(org.sonatype.aether.transfer.ArtifactNotFoundException)ex;
      ArtifactNotFoundProblemInfo problem=new ArtifactNotFoundProblemInfo(artifactNotFoundException.getArtifact(),mavenConfiguration.isOffline(),location);
      result.add(problem);
    }
 else     if (ex instanceof AbstractArtifactResolutionException) {
      AbstractArtifactResolutionException abstractArtifactResolutionException=(AbstractArtifactResolutionException)ex;
      String errorMessage=getArtifactId(abstractArtifactResolutionException) + ""String_Node_Str"" + getRootErrorMessage(ex);
      result.add(new MavenProblemInfo(errorMessage,location));
    }
 else     if (ex instanceof ProjectBuildingException) {
      Throwable cause=ex.getCause();
      if (cause instanceof ModelBuildingException) {
        ModelBuildingException mbe=(ModelBuildingException)cause;
        for (        ModelProblem problem : mbe.getProblems()) {
          String message=NLS.bind(Messages.pluginMarkerBuildError,problem.getMessage());
          int severity=(Severity.WARNING == problem.getSeverity()) ? IMarker.SEVERITY_WARNING : IMarker.SEVERITY_ERROR;
          SourceLocation problemLocation=SourceLocationHelper.findLocation(mavenProject,problem);
          result.add(new MavenProblemInfo(message,severity,problemLocation));
        }
      }
 else {
        result.add(new MavenProblemInfo(getErrorMessage(ex),location));
      }
    }
 else {
      result.add(new MavenProblemInfo(getErrorMessage(ex),location));
    }
  }
  return result;
}",0.9759467758444216
91712,"public void addMarkers(IResource pomFile,String type,MavenExecutionResult result){
  SourceLocation defaultSourceLocation=new SourceLocation(1,0,0);
  List<MavenProblemInfo> allProblems=new ArrayList<MavenProblemInfo>();
  allProblems.addAll(toMavenProblemInfos(defaultSourceLocation,result.getExceptions()));
  MavenProject mavenProject=result.getProject();
  DependencyResolutionResult resolutionResult=result.getDependencyResolutionResult();
  if (resolutionResult != null) {
    allProblems.addAll(toMavenProblemInfos(defaultSourceLocation,resolutionResult.getCollectionErrors()));
    for (    org.sonatype.aether.graph.Dependency dependency : resolutionResult.getUnresolvedDependencies()) {
      List<Exception> exceptions=resolutionResult.getResolutionErrors(dependency);
      if (exceptions != null && exceptions.size() > 0) {
        SourceLocation sourceLocation=SourceLocationHelper.findLocation(mavenProject,dependency);
        allProblems.addAll(toMavenProblemInfos(sourceLocation,exceptions));
      }
    }
  }
  if (mavenProject != null) {
    addMissingArtifactProblemInfos(mavenProject,defaultSourceLocation,allProblems);
  }
  addErrorMarkers(pomFile,type,allProblems);
}","public void addMarkers(IResource pomFile,String type,MavenExecutionResult result){
  SourceLocation defaultSourceLocation=new SourceLocation(1,0,0);
  List<MavenProblemInfo> allProblems=new ArrayList<MavenProblemInfo>();
  MavenProject mavenProject=result.getProject();
  allProblems.addAll(toMavenProblemInfos(mavenProject,defaultSourceLocation,result.getExceptions()));
  DependencyResolutionResult resolutionResult=result.getDependencyResolutionResult();
  if (resolutionResult != null) {
    allProblems.addAll(toMavenProblemInfos(mavenProject,defaultSourceLocation,resolutionResult.getCollectionErrors()));
    for (    org.sonatype.aether.graph.Dependency dependency : resolutionResult.getUnresolvedDependencies()) {
      List<Exception> exceptions=resolutionResult.getResolutionErrors(dependency);
      if (exceptions != null && exceptions.size() > 0) {
        SourceLocation sourceLocation=SourceLocationHelper.findLocation(mavenProject,dependency);
        allProblems.addAll(toMavenProblemInfos(mavenProject,sourceLocation,exceptions));
      }
    }
  }
  if (mavenProject != null) {
    addMissingArtifactProblemInfos(mavenProject,defaultSourceLocation,allProblems);
  }
  addErrorMarkers(pomFile,type,allProblems);
}",0.9435051546391752
91713,"private String[] parseBundleClasspath(Bundle bundle){
  String[] result=new String[]{""String_Node_Str""};
  String header=bundle.getHeaders().get(Constants.BUNDLE_CLASSPATH);
  ManifestElement[] classpathEntries=null;
  try {
    classpathEntries=ManifestElement.parseHeader(Constants.BUNDLE_CLASSPATH,header);
  }
 catch (  BundleException ex) {
    log.warn(""String_Node_Str"",bundle.toString(),ex);
  }
  if (classpathEntries != null) {
    result=new String[classpathEntries.length];
    for (int i=0; i < classpathEntries.length; i++) {
      result[i]=classpathEntries[i].getValue();
    }
  }
  return result;
}","private String[] parseBundleClasspath(Bundle bundle){
  String[] result=new String[]{""String_Node_Str""};
  String header=(String)bundle.getHeaders().get(Constants.BUNDLE_CLASSPATH);
  ManifestElement[] classpathEntries=null;
  try {
    classpathEntries=ManifestElement.parseHeader(Constants.BUNDLE_CLASSPATH,header);
  }
 catch (  BundleException ex) {
    log.warn(""String_Node_Str"",bundle.toString(),ex);
  }
  if (classpathEntries != null) {
    result=new String[classpathEntries.length];
    for (int i=0; i < classpathEntries.length; i++) {
      result[i]=classpathEntries[i].getValue();
    }
  }
  return result;
}",0.9935483870967742
91714,"public static void decorateMarker(IMarker marker){
  BundleContext context=MavenPlugin.getDefault().getBundleContext();
  ServiceReference ref=context.getServiceReference(IMarkerLocationService.class);
  IMarkerLocationService service=(IMarkerLocationService)context.getService(ref);
  if (service != null) {
    try {
      service.findLocationForMarker(marker);
    }
  finally {
      context.ungetService(ref);
    }
  }
}","public static void decorateMarker(IMarker marker){
  BundleContext context=MavenPlugin.getDefault().getBundleContext();
  ServiceReference ref=context.getServiceReference(IMarkerLocationService.class.getName());
  IMarkerLocationService service=(IMarkerLocationService)context.getService(ref);
  if (service != null) {
    try {
      service.findLocationForMarker(marker);
    }
  finally {
      context.ungetService(ref);
    }
  }
}",0.988399071925754
91715,"/** 
 * @param markerManager
 * @param pom
 * @param mavenProject
 * @param markerPomLoadingId
 */
public static void addEditorHintMarkers(IMavenMarkerManager markerManager,IFile pom,MavenProject mavenProject,String type){
  BundleContext context=MavenPlugin.getDefault().getBundleContext();
  ServiceReference ref=context.getServiceReference(IEditorMarkerService.class);
  IEditorMarkerService service=(IEditorMarkerService)context.getService(ref);
  if (service != null) {
    try {
      service.addEditorHintMarkers(markerManager,pom,mavenProject,type);
    }
  finally {
      context.ungetService(ref);
    }
  }
}","public static void addEditorHintMarkers(IMavenMarkerManager markerManager,IFile pom,MavenProject mavenProject,String type){
  BundleContext context=MavenPlugin.getDefault().getBundleContext();
  ServiceReference ref=context.getServiceReference(IEditorMarkerService.class.getName());
  IEditorMarkerService service=(IEditorMarkerService)context.getService(ref);
  if (service != null) {
    try {
      service.addEditorHintMarkers(markerManager,pom,mavenProject,type);
    }
  finally {
      context.ungetService(ref);
    }
  }
}",0.9052997393570807
91716,"public static void decorateMarker(IMarker marker){
  BundleContext context=MavenPlugin.getDefault().getBundleContext();
  ServiceReference<IMarkerLocationService> ref=context.getServiceReference(IMarkerLocationService.class);
  IMarkerLocationService service=context.getService(ref);
  if (service != null) {
    try {
      service.findLocationForMarker(marker);
    }
  finally {
      context.ungetService(ref);
    }
  }
}","public static void decorateMarker(IMarker marker){
  BundleContext context=MavenPlugin.getDefault().getBundleContext();
  ServiceReference ref=context.getServiceReference(IMarkerLocationService.class);
  IMarkerLocationService service=(IMarkerLocationService)context.getService(ref);
  if (service != null) {
    try {
      service.findLocationForMarker(marker);
    }
  finally {
      context.ungetService(ref);
    }
  }
}",0.823943661971831
91717,"/** 
 * @param markerManager
 * @param pom
 * @param mavenProject
 * @param markerPomLoadingId
 */
public static void addEditorHintMarkers(IMavenMarkerManager markerManager,IFile pom,MavenProject mavenProject,String type){
  BundleContext context=MavenPlugin.getDefault().getBundleContext();
  ServiceReference<IEditorMarkerService> ref=context.getServiceReference(IEditorMarkerService.class);
  IEditorMarkerService service=context.getService(ref);
  if (service != null) {
    try {
      service.addEditorHintMarkers(markerManager,pom,mavenProject,type);
    }
  finally {
      context.ungetService(ref);
    }
  }
}","/** 
 * @param markerManager
 * @param pom
 * @param mavenProject
 * @param markerPomLoadingId
 */
public static void addEditorHintMarkers(IMavenMarkerManager markerManager,IFile pom,MavenProject mavenProject,String type){
  BundleContext context=MavenPlugin.getDefault().getBundleContext();
  ServiceReference ref=context.getServiceReference(IEditorMarkerService.class);
  IEditorMarkerService service=(IEditorMarkerService)context.getService(ref);
  if (service != null) {
    try {
      service.addEditorHintMarkers(markerManager,pom,mavenProject,type);
    }
  finally {
      context.ungetService(ref);
    }
  }
}",0.9129032258064516
91718,"private Command createCommand(Dependency dependency,String value,Object feature,String defaultValue){
  return SetCommand.create(editingDomain,dependency,feature,value.length() == 0 || value.equals(defaultValue) ? SetCommand.UNSET_VALUE : value);
}","private Command createCommand(EditingDomain domain,Dependency dependency,String value,Object feature,String defaultValue){
  return SetCommand.create(domain,dependency,feature,value.length() == 0 || value.equals(defaultValue) ? SetCommand.UNSET_VALUE : value);
}",0.9411764705882352
91719,"protected void computeResult(){
  MavenProject targetPOM=getTargetPOM();
  IMavenProjectFacade facade=MavenPlugin.getDefault().getMavenProjectManager().getMavenProject(targetPOM.getGroupId(),targetPOM.getArtifactId(),targetPOM.getVersion());
  Model targetModel=null;
  if (targetPOM.equals(getProjectHierarchy().getFirst())) {
    targetModel=model;
  }
 else {
    targetModel=loadTargetModel(facade);
    if (targetModel == null) {
      return;
    }
  }
  LinkedList<Dependency> dependencies=getDependenciesList();
  CompoundCommand command=new CompoundCommand();
  for (  Dependency dep : dependencies) {
    Command unset=SetCommand.create(editingDomain,dep,PomPackage.eINSTANCE.getDependency_Version(),SetCommand.UNSET_VALUE);
    command.append(unset);
  }
  DependencyManagement management=targetModel.getDependencyManagement();
  if (management == null) {
    management=PomFactory.eINSTANCE.createDependencyManagement();
    Command createDepManagement=SetCommand.create(editingDomain,targetModel,PomPackage.eINSTANCE.getModel_DependencyManagement(),management);
    command.append(createDepManagement);
  }
 else {
    for (    Dependency depFromTarget : management.getDependencies()) {
      Iterator<Dependency> iter=dependencies.iterator();
      while (iter.hasNext()) {
        Dependency depFromSource=iter.next();
        if (depFromSource.getGroupId().equals(depFromTarget.getGroupId()) && depFromSource.getArtifactId().equals(depFromTarget.getArtifactId())) {
          iter.remove();
        }
      }
    }
  }
  for (  Dependency dep : dependencies) {
    Dependency clone=PomFactory.eINSTANCE.createDependency();
    Command addDepCommand=AddCommand.create(editingDomain,management,PomPackage.eINSTANCE.getDependencyManagement_Dependencies(),clone);
    command.append(addDepCommand);
    command.append(createCommand(clone,dep.getGroupId(),PomPackage.eINSTANCE.getDependency_GroupId(),""String_Node_Str""));
    command.append(createCommand(clone,dep.getArtifactId(),PomPackage.eINSTANCE.getDependency_ArtifactId(),""String_Node_Str""));
    command.append(createCommand(clone,dep.getVersion(),PomPackage.eINSTANCE.getDependency_Version(),""String_Node_Str""));
  }
  editingDomain.getCommandStack().execute(command);
}","protected void computeResult(){
  MavenProject targetPOM=getTargetPOM();
  IMavenProjectFacade facade=MavenPlugin.getDefault().getMavenProjectManager().getMavenProject(targetPOM.getGroupId(),targetPOM.getArtifactId(),targetPOM.getVersion());
  Model targetModel;
  EditingDomain targetEditingDomain;
  CompoundCommand command=new CompoundCommand();
  CompoundCommand targetCommand;
  if (targetPOM.equals(getProjectHierarchy().getFirst())) {
    targetModel=model;
    targetEditingDomain=editingDomain;
    targetCommand=command;
  }
 else {
    targetModel=loadTargetModel(facade);
    if (targetModel == null) {
      return;
    }
    targetEditingDomain=findExistingEditorDomain(facade);
    if (targetEditingDomain == null) {
      targetEditingDomain=createDummyEditingDomain();
    }
    targetCommand=new CompoundCommand();
  }
  LinkedList<Dependency> dependencies=getDependenciesList();
  for (  Dependency dep : dependencies) {
    Command unset=SetCommand.create(editingDomain,dep,PomPackage.eINSTANCE.getDependency_Version(),SetCommand.UNSET_VALUE);
    command.append(unset);
  }
  DependencyManagement management=targetModel.getDependencyManagement();
  if (management == null) {
    management=PomFactory.eINSTANCE.createDependencyManagement();
    Command createDepManagement=SetCommand.create(targetEditingDomain,targetModel,PomPackage.eINSTANCE.getModel_DependencyManagement(),management);
    targetCommand.append(createDepManagement);
  }
 else {
    for (    Dependency depFromTarget : management.getDependencies()) {
      Iterator<Dependency> iter=dependencies.iterator();
      while (iter.hasNext()) {
        Dependency depFromSource=iter.next();
        if (depFromSource.getGroupId().equals(depFromTarget.getGroupId()) && depFromSource.getArtifactId().equals(depFromTarget.getArtifactId())) {
          iter.remove();
        }
      }
    }
  }
  for (  Dependency dep : dependencies) {
    Dependency clone=PomFactory.eINSTANCE.createDependency();
    Command addDepCommand=AddCommand.create(targetEditingDomain,management,PomPackage.eINSTANCE.getDependencyManagement_Dependencies(),clone);
    targetCommand.append(addDepCommand);
    targetCommand.append(createCommand(targetEditingDomain,clone,dep.getGroupId(),PomPackage.eINSTANCE.getDependency_GroupId(),""String_Node_Str""));
    targetCommand.append(createCommand(targetEditingDomain,clone,dep.getArtifactId(),PomPackage.eINSTANCE.getDependency_ArtifactId(),""String_Node_Str""));
    targetCommand.append(createCommand(targetEditingDomain,clone,dep.getVersion(),PomPackage.eINSTANCE.getDependency_Version(),""String_Node_Str""));
  }
  editingDomain.getCommandStack().execute(command);
  if (command != targetCommand) {
    targetEditingDomain.getCommandStack().execute(targetCommand);
  }
}",0.8231306081754736
91720,"private void wipeChunks(){
  File regionFile=worldData.regionFile(currentRegion);
  if (!regionFile.canWrite()) {
    regionFile.setWritable(true);
    if (!regionFile.canWrite()) {
      sendMessage(""String_Node_Str"" + regionFile.getName());
      return;
    }
  }
  int offsetX=CoordXZ.regionToChunk(regionX);
  int offsetZ=CoordXZ.regionToChunk(regionZ);
  long wipePos=0;
  try {
    RandomAccessFile unChunk=new RandomAccessFile(regionFile,""String_Node_Str"");
    for (    CoordXZ wipe : trimChunks) {
      wipePos=4 * ((wipe.x - offsetX) + ((wipe.z - offsetZ) * 32));
      unChunk.seek(wipePos);
      unChunk.writeInt(0);
    }
    unChunk.close();
    reportTrimmedChunks+=trimChunks.size();
  }
 catch (  FileNotFoundException ex) {
    sendMessage(""String_Node_Str"" + regionFile.getName());
  }
catch (  IOException ex) {
    sendMessage(""String_Node_Str"" + regionFile.getName());
  }
  counter+=trimChunks.size();
}","private void wipeChunks(){
  File regionFile=worldData.regionFile(currentRegion);
  if (!regionFile.canWrite()) {
    regionFile.setWritable(true);
    if (!regionFile.canWrite()) {
      sendMessage(""String_Node_Str"" + regionFile.getName());
      return;
    }
  }
  int offsetX=CoordXZ.regionToChunk(regionX);
  int offsetZ=CoordXZ.regionToChunk(regionZ);
  long wipePos=0;
  int chunkCount=0;
  try {
    RandomAccessFile unChunk=new RandomAccessFile(regionFile,""String_Node_Str"");
    for (    CoordXZ wipe : trimChunks) {
      if (!worldData.doesChunkExist(wipe.x,wipe.z))       continue;
      wipePos=4 * ((wipe.x - offsetX) + ((wipe.z - offsetZ) * 32));
      unChunk.seek(wipePos);
      unChunk.writeInt(0);
      chunkCount++;
    }
    unChunk.close();
    reportTrimmedChunks+=chunkCount;
  }
 catch (  FileNotFoundException ex) {
    sendMessage(""String_Node_Str"" + regionFile.getName());
  }
catch (  IOException ex) {
    sendMessage(""String_Node_Str"" + regionFile.getName());
  }
  counter+=trimChunks.size();
}",0.9310872894333844
91721,"@Override public void run(){
  vehicle.setPassenger(player);
}","@Override public void run(){
  handlingPlayers.remove(playerName.toLowerCase());
  if (vehicle == null || player == null)   return;
  vehicle.setPassenger(player);
}",0.5462555066079295
91722,"private static void setPassengerDelayed(final Entity vehicle,final Player player,long delay){
  Bukkit.getServer().getScheduler().scheduleSyncDelayedTask(WorldBorder.plugin,new Runnable(){
    @Override public void run(){
      vehicle.setPassenger(player);
    }
  }
,delay);
}","private static void setPassengerDelayed(final Entity vehicle,final Player player,final String playerName,long delay){
  Bukkit.getServer().getScheduler().scheduleSyncDelayedTask(WorldBorder.plugin,new Runnable(){
    @Override public void run(){
      handlingPlayers.remove(playerName.toLowerCase());
      if (vehicle == null || player == null)       return;
      vehicle.setPassenger(player);
    }
  }
,delay);
}",0.7251798561151079
91723,"@EventHandler(priority=EventPriority.LOWEST,ignoreCancelled=true) public void onPlayerTeleport(PlayerTeleportEvent event){
  if (Config.KnockBack() == 0.0)   return;
  Location newLoc=BorderCheckTask.checkPlayer(event.getPlayer(),event.getTo(),true,true);
  if (newLoc != null)   event.setTo(newLoc);
}","@EventHandler(priority=EventPriority.LOWEST,ignoreCancelled=true) public void onPlayerTeleport(PlayerTeleportEvent event){
  if (Config.KnockBack() == 0.0)   return;
  if (Config.Debug())   Config.LogWarn(""String_Node_Str"" + event.getCause().toString());
  Location newLoc=BorderCheckTask.checkPlayer(event.getPlayer(),event.getTo(),true,true);
  if (newLoc != null)   event.setTo(newLoc);
}",0.8715728715728716
91724,"public static Location checkPlayer(Player player,Location targetLoc,boolean returnLocationOnly){
  if (player == null || !player.isOnline())   return null;
  Location loc=(targetLoc == null) ? player.getLocation() : targetLoc;
  if (loc == null)   return null;
  World world=loc.getWorld();
  if (world == null)   return null;
  BorderData border=Config.Border(world.getName());
  if (border == null)   return null;
  if (border.insideBorder(loc.getX(),loc.getZ(),Config.ShapeRound()))   return null;
  Location newLoc=newLocation(player,loc,border);
  if (Config.whooshEffect()) {
    world.playEffect(loc,Effect.ENDER_SIGNAL,0);
    world.playEffect(loc,Effect.ENDER_SIGNAL,0);
    world.playEffect(loc,Effect.SMOKE,4);
    world.playEffect(loc,Effect.SMOKE,4);
    world.playEffect(loc,Effect.SMOKE,4);
    world.playEffect(loc,Effect.GHAST_SHOOT,0);
  }
  if (returnLocationOnly)   return newLoc;
  if (!player.isInsideVehicle())   player.teleport(newLoc);
 else {
    Vehicle ride=player.getVehicle();
    if (ride != null) {
      double vertOffset=ride.getLocation().getY() - loc.getY();
      newLoc.setY(newLoc.getY() + vertOffset);
      ride.setVelocity(new Vector(0,0,0));
      ride.teleport(newLoc);
    }
 else {
      player.leaveVehicle();
      player.teleport(newLoc);
    }
  }
  return null;
}","public static Location checkPlayer(Player player,Location targetLoc,boolean returnLocationOnly){
  if (player == null || !player.isOnline())   return null;
  Location loc=(targetLoc == null) ? player.getLocation().clone() : targetLoc;
  if (loc == null)   return null;
  World world=loc.getWorld();
  if (world == null)   return null;
  BorderData border=Config.Border(world.getName());
  if (border == null)   return null;
  if (border.insideBorder(loc.getX(),loc.getZ(),Config.ShapeRound()))   return null;
  Location newLoc=newLocation(player,loc,border);
  if (Config.whooshEffect()) {
    world.playEffect(loc,Effect.ENDER_SIGNAL,0);
    world.playEffect(loc,Effect.ENDER_SIGNAL,0);
    world.playEffect(loc,Effect.SMOKE,4);
    world.playEffect(loc,Effect.SMOKE,4);
    world.playEffect(loc,Effect.SMOKE,4);
    world.playEffect(loc,Effect.GHAST_SHOOT,0);
  }
  if (returnLocationOnly)   return newLoc;
  if (!player.isInsideVehicle())   player.teleport(newLoc);
 else {
    Vehicle ride=(Vehicle)player.getVehicle();
    if (ride != null) {
      double vertOffset=ride.getLocation().getY() - loc.getY();
      newLoc.setY(newLoc.getY() + vertOffset);
      ride.setVelocity(new Vector(0,0,0));
      ride.teleport(newLoc);
    }
 else {
      player.leaveVehicle();
      player.teleport(newLoc);
    }
  }
  return null;
}",0.9860113421550094
91725,"public static Location checkPlayer(Player player,Location targetLoc,boolean returnLocationOnly){
  if (player == null || !player.isOnline())   return null;
  Location loc=(targetLoc == null) ? player.getLocation().clone() : targetLoc;
  if (loc == null)   return null;
  World world=loc.getWorld();
  if (world == null)   return null;
  BorderData border=Config.Border(world.getName());
  if (border == null)   return null;
  if (border.insideBorder(loc.getX(),loc.getZ(),Config.ShapeRound()))   return null;
  Location newLoc=newLocation(player,loc,border);
  if (Config.whooshEffect()) {
    world.playEffect(loc,Effect.ENDER_SIGNAL,0);
    world.playEffect(loc,Effect.ENDER_SIGNAL,0);
    world.playEffect(loc,Effect.SMOKE,4);
    world.playEffect(loc,Effect.SMOKE,4);
    world.playEffect(loc,Effect.SMOKE,4);
    world.playEffect(loc,Effect.GHAST_SHOOT,0);
  }
  if (returnLocationOnly)   return newLoc;
  if (!player.isInsideVehicle())   player.teleport(newLoc);
 else {
    Vehicle ride=(Vehicle)player.getVehicle();
    if (ride != null) {
      double vertOffset=ride.getLocation().getY() - loc.getY();
      newLoc.setY(newLoc.getY() + vertOffset);
      ride.setVelocity(new Vector(0,0,0));
      ride.teleport(newLoc);
    }
 else {
      player.leaveVehicle();
      player.teleport(newLoc);
    }
  }
  return null;
}","public static Location checkPlayer(Player player,Location targetLoc,boolean returnLocationOnly){
  if (player == null || !player.isOnline())   return null;
  Location loc=(targetLoc == null) ? player.getLocation().clone() : targetLoc;
  if (loc == null)   return null;
  World world=loc.getWorld();
  if (world == null)   return null;
  BorderData border=Config.Border(world.getName());
  if (border == null)   return null;
  if (border.insideBorder(loc.getX(),loc.getZ(),Config.ShapeRound()))   return null;
  Location newLoc=newLocation(player,loc,border);
  if (Config.whooshEffect()) {
    world.playEffect(loc,Effect.ENDER_SIGNAL,0);
    world.playEffect(loc,Effect.ENDER_SIGNAL,0);
    world.playEffect(loc,Effect.SMOKE,4);
    world.playEffect(loc,Effect.SMOKE,4);
    world.playEffect(loc,Effect.SMOKE,4);
    world.playEffect(loc,Effect.GHAST_SHOOT,0);
  }
  if (returnLocationOnly)   return newLoc;
  if (!player.isInsideVehicle())   player.teleport(newLoc);
 else {
    Entity ride=player.getVehicle();
    if (ride != null) {
      double vertOffset=ride.getLocation().getY() - loc.getY();
      newLoc.setY(newLoc.getY() + vertOffset);
      ride.setVelocity(new Vector(0,0,0));
      ride.teleport(newLoc);
    }
 else {
      player.leaveVehicle();
      player.teleport(newLoc);
    }
  }
  return null;
}",0.7745098039215687
91726,"private void unloadChunks(){
  for (  CoordXZ unload : trimChunks) {
    world.unloadChunk(unload.x,unload.z,false,false);
  }
  counter+=trimChunks.size();
}","private void unloadChunks(){
  for (  CoordXZ unload : trimChunks) {
    if (world.isChunkLoaded(unload.x,unload.z))     world.unloadChunk(unload.x,unload.z,false,false);
  }
  counter+=trimChunks.size();
}",0.8681318681318682
91727,"public void run(){
  if (Config.movedPlayers.isEmpty())   return;
  for (Iterator<String> p=Config.movedPlayers.iterator(); p.hasNext(); ) {
    String playerName=p.next();
    Player player=server.getPlayer(playerName);
    p.remove();
    if (player == null || !player.isOnline())     continue;
    Location loc=player.getLocation();
    if (loc == null)     continue;
    World world=loc.getWorld();
    if (world == null)     continue;
    BorderData border=Config.Border(world.getName());
    if (border == null)     continue;
    if (border.insideBorder(loc.getX(),loc.getZ(),Config.ShapeRound()))     continue;
    Location newLoc=newLocation(player,loc,border);
    if (!player.isInsideVehicle())     player.teleport(newLoc);
 else {
      double vertOffset=player.getVehicle().getLocation().getY() - loc.getY();
      newLoc.setY(newLoc.getY() + vertOffset);
      player.getVehicle().setVelocity(new Vector(0,0,0));
      player.getVehicle().teleport(newLoc);
    }
  }
}","public void run(){
  if (Config.movedPlayers.isEmpty() || server == null)   return;
  for (Iterator<String> p=Config.movedPlayers.iterator(); p.hasNext(); ) {
    Player player=null;
    try {
      String playerName=p.next();
      player=server.getPlayer(playerName);
      p.remove();
    }
 catch (    ConcurrentModificationException ex) {
      continue;
    }
    if (player == null || !player.isOnline())     continue;
    Location loc=player.getLocation();
    if (loc == null)     continue;
    World world=loc.getWorld();
    if (world == null)     continue;
    BorderData border=Config.Border(world.getName());
    if (border == null)     continue;
    if (border.insideBorder(loc.getX(),loc.getZ(),Config.ShapeRound()))     continue;
    Location newLoc=newLocation(player,loc,border);
    if (!player.isInsideVehicle())     player.teleport(newLoc);
 else {
      double vertOffset=player.getVehicle().getLocation().getY() - loc.getY();
      newLoc.setY(newLoc.getY() + vertOffset);
      player.getVehicle().setVelocity(new Vector(0,0,0));
      player.getVehicle().teleport(newLoc);
    }
  }
}",0.8895265423242468
91728,"/** 
 * Retrieves the   {@link IResource} associated with the first element in thegiven  {@code selection}.
 * @param selection the  {@link ISelection} to process
 * @return the corresponding {@link IResource} or <code>null</code> if nonewas found
 */
private static IResource getResourceFromSelection(final ISelection selection){
  final Object selectedElement=((IStructuredSelection)selection).toArray()[0];
  if (selectedElement instanceof IResource) {
    return (IResource)selectedElement;
  }
 else   if (selectedElement instanceof IAdaptable) {
    return ((IAdaptable)selection).getAdapter(IResource.class);
  }
  return null;
}","/** 
 * Retrieves the   {@link IResource} associated with the first element in thegiven  {@code selection}.
 * @param selection the  {@link ISelection} to process
 * @return the corresponding {@link IResource} or <code>null</code> if nonewas found
 */
private static IResource getResourceFromSelection(final ISelection selection){
  final Object selectedElement=((IStructuredSelection)selection).toArray()[0];
  if (selectedElement instanceof IResource) {
    return (IResource)selectedElement;
  }
 else   if (selectedElement instanceof IAdaptable) {
    return ((IAdaptable)selectedElement).getAdapter(IResource.class);
  }
  return null;
}",0.9906103286384976
91729,"public void parseData(DataInput stream) throws IOException, CoreException {
  int magic=0;
  ArrayList<Block> blocks=null;
  SourceFile source=null;
  boolean parseFirstFnctn=false;
  magic=stream.readInt();
  if (magic == GCOV_NOTE_MAGIC) {
    stream=new BEDataInputStream((DataInputStream)stream);
  }
 else {
    magic=(magic >> 16) | (magic << 16);
    magic=((magic & 0xff00ff) << 8) | ((magic >> 8) & 0xff00ff);
    if (magic == GCOV_NOTE_MAGIC) {
      stream=new LEDataInputStream((DataInputStream)stream);
    }
 else {
      String message=NLS.bind(Messages.GcnoRecordsParser_magic_num_error,magic);
      Status status=new Status(IStatus.ERROR,Activator.PLUGIN_ID,message);
      throw new CoreException(status);
    }
  }
  int version=stream.readInt();
  stream.readInt();
  while (true) {
    try {
      int tag;
      while (true) {
        tag=stream.readInt();
        if (tag == GCOV_TAG_FUNCTION || tag == GCOV_TAG_BLOCKS || tag == GCOV_TAG_ARCS || tag == GCOV_TAG_LINES)         break;
      }
      int length=stream.readInt();
      if (tag == GCOV_TAG_FUNCTION) {
        if (parseFirstFnctn) {
          fnctns.add(fnctn);
        }
        long fnctnIdent=(stream.readInt() & MasksGenerator.UNSIGNED_INT_MASK);
        long fnctnChksm=(stream.readInt() & MasksGenerator.UNSIGNED_INT_MASK);
        if (version >= 875575082) {
          stream.readInt();
        }
        String fnctnName=GcovStringReader.readString(stream);
        String fnctnSrcFle=GcovStringReader.readString(stream);
        long fnctnFrstLnNmbr=(stream.readInt() & MasksGenerator.UNSIGNED_INT_MASK);
        fnctn=new GcnoFunction(fnctnIdent,fnctnChksm,fnctnName,fnctnSrcFle,fnctnFrstLnNmbr);
        SourceFile srcFle2=findOrAdd(fnctn.getSrcFile());
        if (fnctn.getFirstLineNmbr() >= srcFle2.getNumLines()) {
          srcFle2.setNumLines((int)fnctn.getFirstLineNmbr() + 1);
        }
        srcFle2.addFnctn(fnctn);
        parseFirstFnctn=true;
        continue;
      }
 else       if (tag == GCOV_TAG_BLOCKS) {
        blocks=new ArrayList<>();
        for (int i=0; i < length; i++) {
          long BlckFlag=stream.readInt() & MasksGenerator.UNSIGNED_INT_MASK;
          Block blck=new Block(BlckFlag);
          blocks.add(blck);
        }
        fnctn.setNumBlocks(length);
        continue;
      }
 else       if (tag == GCOV_TAG_ARCS) {
        int srcBlockIndice=stream.readInt();
        int nmbrArcs=(length - 1) / 2;
        ArrayList<Arc> arcs=new ArrayList<>(nmbrArcs);
        for (int i=0; i < nmbrArcs; i++) {
          int dstnatnBlockIndice=stream.readInt();
          long flag=(stream.readInt() & MasksGenerator.UNSIGNED_INT_MASK);
          Arc arc=new Arc(srcBlockIndice,dstnatnBlockIndice,flag,blocks);
          arcs.add(arc);
        }
        Block srcBlk=blocks.get(srcBlockIndice);
        for (        Arc a : arcs) {
          srcBlk.addExitArcs(a);
          srcBlk.incNumSuccs();
        }
        for (        Arc a : arcs) {
          Block dstntnBlk=a.getDstnatnBlock();
          dstntnBlk.addEntryArcs(a);
          dstntnBlk.incNumPreds();
        }
        for (        Arc a : arcs) {
          if (a.isFake()) {
            if (a.getSrcBlock() != null) {
              srcBlk=blocks.get(srcBlockIndice);
              srcBlk.setCallSite(true);
              a.setCallNonReturn(true);
            }
 else {
              a.setNonLoclaReturn(true);
              Block dstntnBlk=a.getDstnatnBlock();
              dstntnBlk.setNonLocalReturn(true);
            }
          }
          if (!a.isOnTree()) {
            fnctn.incNumCounts();
          }
        }
        fnctn.setFunctionBlocks(blocks);
        continue;
      }
 else       if (tag == GCOV_TAG_LINES) {
        int numBlock=stream.readInt();
        long[] lineNos=new long[length - 1];
        int ix=0;
        do {
          long lineNumber=stream.readInt() & MasksGenerator.UNSIGNED_INT_MASK;
          if (lineNumber != 0) {
            if (ix == 0) {
              lineNos[ix++]=0;
              lineNos[ix++]=source.getIndex();
            }
            lineNos[ix++]=lineNumber;
            if (lineNumber >= source.getNumLines()) {
              source.setNumLines((int)lineNumber + 1);
            }
          }
 else {
            String fileName=GcovStringReader.readString(stream);
            if (fileName.equals(Messages.GcnoRecordsParser_null_string)) {
              break;
            }
            source=findOrAdd(fileName);
            lineNos[ix++]=0;
            lineNos[ix++]=source.getIndex();
          }
        }
 while (true);
        fnctn.getFunctionBlocks().get((numBlock)).setEncoding(lineNos);
        fnctn.getFunctionBlocks().get((numBlock)).setNumLine(ix);
        continue;
      }
    }
 catch (    EOFException e) {
      fnctn.setFunctionBlocks(blocks);
      fnctns.add(fnctn);
      break;
    }
  }
}","public void parseData(DataInput stream) throws IOException, CoreException {
  int magic=0;
  ArrayList<Block> blocks=null;
  SourceFile source=null;
  boolean parseFirstFnctn=false;
  magic=stream.readInt();
  if (magic == GCOV_NOTE_MAGIC) {
    stream=new BEDataInputStream((DataInputStream)stream);
  }
 else {
    magic=(magic >> 16) | (magic << 16);
    magic=((magic & 0xff00ff) << 8) | ((magic >> 8) & 0xff00ff);
    if (magic == GCOV_NOTE_MAGIC) {
      stream=new LEDataInputStream((DataInputStream)stream);
    }
 else {
      String message=NLS.bind(Messages.GcnoRecordsParser_magic_num_error,magic);
      Status status=new Status(IStatus.ERROR,Activator.PLUGIN_ID,message);
      throw new CoreException(status);
    }
  }
  int version=stream.readInt();
  stream.readInt();
  while (true) {
    try {
      int tag;
      while (true) {
        tag=stream.readInt();
        if (tag == GCOV_TAG_FUNCTION || tag == GCOV_TAG_BLOCKS || tag == GCOV_TAG_ARCS || tag == GCOV_TAG_LINES)         break;
      }
      int length=stream.readInt();
      if (tag == GCOV_TAG_FUNCTION) {
        if (parseFirstFnctn) {
          fnctns.add(fnctn);
        }
        long fnctnIdent=(stream.readInt() & MasksGenerator.UNSIGNED_INT_MASK);
        long fnctnChksm=(stream.readInt() & MasksGenerator.UNSIGNED_INT_MASK);
        if (version >= GCC_VER_407) {
          stream.readInt();
        }
        String fnctnName=GcovStringReader.readString(stream);
        if (version >= GCC_VER_810R) {
          stream.readInt();
        }
        String fnctnSrcFle=GcovStringReader.readString(stream);
        long fnctnFrstLnNmbr=(stream.readInt() & MasksGenerator.UNSIGNED_INT_MASK);
        if (version >= GCC_VER_810R) {
          stream.readInt();
          stream.readInt();
        }
        fnctn=new GcnoFunction(fnctnIdent,fnctnChksm,fnctnName,fnctnSrcFle,fnctnFrstLnNmbr);
        SourceFile srcFle2=findOrAdd(fnctn.getSrcFile());
        if (fnctn.getFirstLineNmbr() >= srcFle2.getNumLines()) {
          srcFle2.setNumLines((int)fnctn.getFirstLineNmbr() + 1);
        }
        srcFle2.addFnctn(fnctn);
        parseFirstFnctn=true;
        continue;
      }
 else       if (tag == GCOV_TAG_BLOCKS) {
        if (version >= GCC_VER_810R) {
          length=stream.readInt();
        }
        blocks=new ArrayList<>();
        Block blck;
        for (int i=0; i < length; i++) {
          if (version >= GCC_VER_810R) {
            blck=new Block(0);
          }
 else {
            long BlckFlag=stream.readInt() & MasksGenerator.UNSIGNED_INT_MASK;
            blck=new Block(BlckFlag);
          }
          blocks.add(blck);
        }
        fnctn.setNumBlocks(length);
        continue;
      }
 else       if (tag == GCOV_TAG_ARCS) {
        int srcBlockIndice=stream.readInt();
        int nmbrArcs=(length - 1) / 2;
        ArrayList<Arc> arcs=new ArrayList<>(nmbrArcs);
        for (int i=0; i < nmbrArcs; i++) {
          int dstnatnBlockIndice=stream.readInt();
          long flag=(stream.readInt() & MasksGenerator.UNSIGNED_INT_MASK);
          Arc arc=new Arc(srcBlockIndice,dstnatnBlockIndice,flag,blocks);
          arcs.add(arc);
        }
        Block srcBlk=blocks.get(srcBlockIndice);
        for (        Arc a : arcs) {
          srcBlk.addExitArcs(a);
          srcBlk.incNumSuccs();
        }
        for (        Arc a : arcs) {
          Block dstntnBlk=a.getDstnatnBlock();
          dstntnBlk.addEntryArcs(a);
          dstntnBlk.incNumPreds();
        }
        for (        Arc a : arcs) {
          if (a.isFake()) {
            if (a.getSrcBlock() != null) {
              srcBlk=blocks.get(srcBlockIndice);
              srcBlk.setCallSite(true);
              a.setCallNonReturn(true);
            }
 else {
              a.setNonLoclaReturn(true);
              Block dstntnBlk=a.getDstnatnBlock();
              dstntnBlk.setNonLocalReturn(true);
            }
          }
          if (!a.isOnTree()) {
            fnctn.incNumCounts();
          }
        }
        fnctn.setFunctionBlocks(blocks);
        continue;
      }
 else       if (tag == GCOV_TAG_LINES) {
        int numBlock=stream.readInt();
        long[] lineNos=new long[length - 1];
        int ix=0;
        do {
          long lineNumber=stream.readInt() & MasksGenerator.UNSIGNED_INT_MASK;
          if (lineNumber != 0) {
            if (ix == 0) {
              lineNos[ix++]=0;
              lineNos[ix++]=source.getIndex();
            }
            lineNos[ix++]=lineNumber;
            if (lineNumber >= source.getNumLines()) {
              source.setNumLines((int)lineNumber + 1);
            }
          }
 else {
            String fileName=GcovStringReader.readString(stream);
            if (fileName.equals(Messages.GcnoRecordsParser_null_string)) {
              break;
            }
            source=findOrAdd(fileName);
            lineNos[ix++]=0;
            lineNos[ix++]=source.getIndex();
          }
        }
 while (true);
        fnctn.getFunctionBlocks().get((numBlock)).setEncoding(lineNos);
        fnctn.getFunctionBlocks().get((numBlock)).setNumLine(ix);
        continue;
      }
    }
 catch (    EOFException e) {
      fnctn.setFunctionBlocks(blocks);
      fnctns.add(fnctn);
      break;
    }
  }
}",0.9567108124135204
91730,"@Override public void initializeFrom(ILaunchConfiguration configuration){
  if (model == null)   return;
  try {
    model.removeEnvironmentVariables();
    final List<String> environmentVariables=configuration.getAttribute(IRunDockerImageLaunchConfigurationConstants.ENV_VARIABLES,new ArrayList<String>());
    for (    String environmenVariable : environmentVariables) {
      model.addEnvironmentVariable(EnvironmentVariableModel.createEnvironmentVariableModel(environmenVariable));
    }
  }
 catch (  CoreException e) {
    Activator.logErrorMessage(LaunchMessages.getString(""String_Node_Str""),e);
  }
  model.addPropertyChangeListener(new LaunchConfigurationChangeListener());
}","@Override public void initializeFrom(ILaunchConfiguration configuration){
  if (model == null)   return;
  try {
    final List<String> environmentVariables=configuration.getAttribute(IRunDockerImageLaunchConfigurationConstants.ENV_VARIABLES,new ArrayList<String>());
    model.setEnvironmentVariables(environmentVariables);
  }
 catch (  CoreException e) {
    Activator.logErrorMessage(LaunchMessages.getString(""String_Node_Str""),e);
  }
  model.addPropertyChangeListener(new LaunchConfigurationChangeListener());
}",0.839300582847627
91731,"private void createEnvironmentVariablesContainer(final Composite container){
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).span(3,1).applyTo(new Label(container,SWT.NONE));
  final Label envVarLabel=new Label(container,SWT.NONE);
  envVarLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).span(COLUMNS,1).applyTo(envVarLabel);
  final TableViewer environmentVariablesTableViewer=createEnvironmentVariablesTable(container);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).hint(200,100).applyTo(environmentVariablesTableViewer.getTable());
  final Composite buttonsContainers=new Composite(container,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(false,false).applyTo(buttonsContainers);
  GridLayoutFactory.fillDefaults().numColumns(1).margins(0,0).spacing(SWT.DEFAULT,0).applyTo(buttonsContainers);
  final Button addButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(addButton);
  addButton.setText(WizardMessages.getString(""String_Node_Str""));
  addButton.setEnabled(true);
  addButton.addSelectionListener(onAddEnvironmentVariable(environmentVariablesTableViewer));
  final Button editButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(editButton);
  editButton.setText(WizardMessages.getString(""String_Node_Str""));
  editButton.setEnabled(true);
  editButton.addSelectionListener(onEditEnvironmentVariable(environmentVariablesTableViewer));
  editButton.setEnabled(false);
  final Button removeButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(removeButton);
  removeButton.setText(WizardMessages.getString(""String_Node_Str""));
  removeButton.addSelectionListener(onRemoveEnvironmentVariables(environmentVariablesTableViewer));
  removeButton.setEnabled(false);
  ViewerSupport.bind(environmentVariablesTableViewer,model.getEnvironmentVariables(),BeanProperties.values(EnvironmentVariableModel.class,EnvironmentVariableModel.NAME,EnvironmentVariableModel.VALUE));
  environmentVariablesTableViewer.addSelectionChangedListener(onSelectionChanged(editButton,removeButton));
}","private void createEnvironmentVariablesContainer(final Composite container){
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).span(3,1).applyTo(new Label(container,SWT.NONE));
  final Label envVarLabel=new Label(container,SWT.NONE);
  envVarLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).span(COLUMNS,1).applyTo(envVarLabel);
  final TableViewer environmentVariablesTableViewer=createEnvironmentVariablesTable(container);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,true).hint(200,100).applyTo(environmentVariablesTableViewer.getTable());
  final Composite buttonsContainers=new Composite(container,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(false,false).applyTo(buttonsContainers);
  GridLayoutFactory.fillDefaults().numColumns(1).margins(0,0).spacing(SWT.DEFAULT,0).applyTo(buttonsContainers);
  final Button addButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(addButton);
  addButton.setText(WizardMessages.getString(""String_Node_Str""));
  addButton.setEnabled(true);
  addButton.addSelectionListener(onAddEnvironmentVariable(environmentVariablesTableViewer));
  final Button editButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(editButton);
  editButton.setText(WizardMessages.getString(""String_Node_Str""));
  editButton.setEnabled(true);
  editButton.addSelectionListener(onEditEnvironmentVariable(environmentVariablesTableViewer));
  editButton.setEnabled(false);
  final Button removeButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(removeButton);
  removeButton.setText(WizardMessages.getString(""String_Node_Str""));
  removeButton.addSelectionListener(onRemoveEnvironmentVariables(environmentVariablesTableViewer));
  removeButton.setEnabled(false);
  ViewerSupport.bind(environmentVariablesTableViewer,model.getEnvironmentVariables(),BeanProperties.values(EnvironmentVariableModel.class,EnvironmentVariableModel.NAME,EnvironmentVariableModel.VALUE));
  environmentVariablesTableViewer.addSelectionChangedListener(onSelectionChanged(editButton,removeButton));
}",0.9920235096557516
91732,"private void createLabelVariablesContainer(final Composite container){
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).span(3,1).applyTo(new Label(container,SWT.NONE));
  final Label envVarLabel=new Label(container,SWT.NONE);
  envVarLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).span(COLUMNS,1).applyTo(envVarLabel);
  final TableViewer labelVariablesTableViewer=createLabelVariablesTable(container);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).hint(200,100).applyTo(labelVariablesTableViewer.getTable());
  final Composite buttonsContainers=new Composite(container,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(false,false).applyTo(buttonsContainers);
  GridLayoutFactory.fillDefaults().numColumns(1).margins(0,0).spacing(SWT.DEFAULT,0).applyTo(buttonsContainers);
  final Button addButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(addButton);
  addButton.setText(WizardMessages.getString(""String_Node_Str""));
  addButton.setEnabled(true);
  addButton.addSelectionListener(onAddLabelVariable(labelVariablesTableViewer));
  final Button editButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(editButton);
  editButton.setText(WizardMessages.getString(""String_Node_Str""));
  editButton.setEnabled(true);
  editButton.addSelectionListener(onEditLabelVariable(labelVariablesTableViewer));
  editButton.setEnabled(false);
  final Button removeButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(removeButton);
  removeButton.setText(WizardMessages.getString(""String_Node_Str""));
  removeButton.addSelectionListener(onRemoveLabelVariable(labelVariablesTableViewer));
  removeButton.setEnabled(false);
  ViewerSupport.bind(labelVariablesTableViewer,model.getLabelVariables(),BeanProperties.values(LabelVariableModel.class,LabelVariableModel.NAME,LabelVariableModel.VALUE));
  labelVariablesTableViewer.addSelectionChangedListener(onSelectionChanged(editButton,removeButton));
}","private void createLabelVariablesContainer(final Composite container){
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).span(3,1).applyTo(new Label(container,SWT.NONE));
  final Label envVarLabel=new Label(container,SWT.NONE);
  envVarLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).span(COLUMNS,1).applyTo(envVarLabel);
  final TableViewer labelVariablesTableViewer=createLabelVariablesTable(container);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,true).hint(200,100).applyTo(labelVariablesTableViewer.getTable());
  final Composite buttonsContainers=new Composite(container,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(false,false).applyTo(buttonsContainers);
  GridLayoutFactory.fillDefaults().numColumns(1).margins(0,0).spacing(SWT.DEFAULT,0).applyTo(buttonsContainers);
  final Button addButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(addButton);
  addButton.setText(WizardMessages.getString(""String_Node_Str""));
  addButton.setEnabled(true);
  addButton.addSelectionListener(onAddLabelVariable(labelVariablesTableViewer));
  final Button editButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(editButton);
  editButton.setText(WizardMessages.getString(""String_Node_Str""));
  editButton.setEnabled(true);
  editButton.addSelectionListener(onEditLabelVariable(labelVariablesTableViewer));
  editButton.setEnabled(false);
  final Button removeButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(removeButton);
  removeButton.setText(WizardMessages.getString(""String_Node_Str""));
  removeButton.addSelectionListener(onRemoveLabelVariable(labelVariablesTableViewer));
  removeButton.setEnabled(false);
  ViewerSupport.bind(labelVariablesTableViewer,model.getLabelVariables(),BeanProperties.values(LabelVariableModel.class,LabelVariableModel.NAME,LabelVariableModel.VALUE));
  labelVariablesTableViewer.addSelectionChangedListener(onSelectionChanged(editButton,removeButton));
}",0.9916849015317286
91733,"private void createLinkSettingsSection(final Composite container){
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).span(3,1).applyTo(new Label(container,SWT.NONE));
  final Label linksLabel=new Label(container,SWT.NONE);
  linksLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).span(COLUMNS,1).applyTo(linksLabel);
  final TableViewer linksTableViewer=createLinksTable(container);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,true).hint(200,100).applyTo(linksTableViewer.getTable());
  final Composite buttonsContainers=new Composite(container,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(false,false).applyTo(buttonsContainers);
  GridLayoutFactory.fillDefaults().numColumns(1).margins(0,0).spacing(SWT.DEFAULT,0).applyTo(buttonsContainers);
  final Button addButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(addButton);
  addButton.setText(WizardMessages.getString(""String_Node_Str""));
  addButton.addSelectionListener(onAddLink());
  final Button editButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(editButton);
  editButton.setText(WizardMessages.getString(""String_Node_Str""));
  editButton.setEnabled(false);
  editButton.addSelectionListener(onEditLink(linksTableViewer));
  final Button removeButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(removeButton);
  removeButton.setText(WizardMessages.getString(""String_Node_Str""));
  removeButton.addSelectionListener(onRemoveLinks(linksTableViewer));
  removeButton.setEnabled(false);
  ViewerSupport.bind(linksTableViewer,model.getLinks(),BeanProperties.values(ContainerLinkModel.class,ContainerLinkModel.CONTAINER_NAME,ContainerLinkModel.CONTAINER_ALIAS));
  linksTableViewer.addSelectionChangedListener(onSelectionChanged(editButton,removeButton));
}","private void createLinkSettingsSection(final Composite container){
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).span(3,1).applyTo(new Label(container,SWT.NONE));
  final Label linksLabel=new Label(container,SWT.NONE);
  linksLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).span(COLUMNS,1).applyTo(linksLabel);
  final TableViewer linksTableViewer=createLinksTable(container);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,true).hint(200,100).applyTo(linksTableViewer.getTable());
  final Composite buttonsContainers=new Composite(container,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(false,false).applyTo(buttonsContainers);
  GridLayoutFactory.fillDefaults().numColumns(1).margins(0,0).spacing(SWT.DEFAULT,0).applyTo(buttonsContainers);
  final Button addButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(addButton);
  addButton.setText(WizardMessages.getString(""String_Node_Str""));
  addButton.addSelectionListener(onAddLink());
  final Button editButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(editButton);
  editButton.setText(WizardMessages.getString(""String_Node_Str""));
  editButton.setEnabled(false);
  editButton.addSelectionListener(onEditLink(linksTableViewer));
  final Button removeButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(removeButton);
  removeButton.setText(WizardMessages.getString(""String_Node_Str""));
  removeButton.addSelectionListener(onRemoveLinks(linksTableViewer));
  removeButton.setEnabled(false);
  ViewerSupport.bind(linksTableViewer,model.getLinks(),BeanProperties.values(ContainerLinkModel.class,ContainerLinkModel.CONTAINER_NAME,ContainerLinkModel.CONTAINER_ALIAS));
  linksTableViewer.addSelectionChangedListener(onSelectionChanged(editButton,removeButton));
}",0.9983447623551668
91734,"private void createPortSettingsSection(final Composite container){
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).span(3,1).applyTo(new Label(container,SWT.NONE));
  final Button publishAllPortsButton=new Button(container,SWT.CHECK);
  publishAllPortsButton.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).span(COLUMNS,1).grab(true,false).applyTo(publishAllPortsButton);
  dbc.bindValue(WidgetProperties.selection().observe(publishAllPortsButton),BeanProperties.value(ImageRunSelectionModel.class,ImageRunSelectionModel.PUBLISH_ALL_PORTS).observe(model));
  final Label portSettingsLabel=new Label(container,SWT.NONE);
  portSettingsLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).span(COLUMNS,1).indent(INDENT,0).applyTo(portSettingsLabel);
  final CheckboxTableViewer exposedPortsTableViewer=createPortSettingsTable(container);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).span(COLUMNS - 1,1).indent(INDENT,0).hint(200,70).applyTo(exposedPortsTableViewer.getTable());
  final Composite buttonsContainers=new Composite(container,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(false,false).applyTo(buttonsContainers);
  GridLayoutFactory.fillDefaults().numColumns(1).margins(0,0).spacing(SWT.DEFAULT,0).applyTo(buttonsContainers);
  final Button addButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(addButton);
  addButton.setText(WizardMessages.getString(""String_Node_Str""));
  addButton.addSelectionListener(onAddPort(exposedPortsTableViewer));
  final Button editButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(editButton);
  editButton.setText(WizardMessages.getString(""String_Node_Str""));
  editButton.setEnabled(false);
  editButton.addSelectionListener(onEditPort(exposedPortsTableViewer));
  final Button removeButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(removeButton);
  removeButton.setText(WizardMessages.getString(""String_Node_Str""));
  removeButton.addSelectionListener(onRemovePorts(exposedPortsTableViewer));
  BeanProperties.value(ImageRunSelectionModel.class,ImageRunSelectionModel.PUBLISH_ALL_PORTS).observe(model).addValueChangeListener(onPublishAllPortsChange(exposedPortsTableViewer.getTable(),addButton,removeButton));
  ViewerSupport.bind(exposedPortsTableViewer,model.getExposedPorts(),BeanProperties.values(ExposedPortModel.class,ExposedPortModel.CONTAINER_PORT,ExposedPortModel.PORT_TYPE,ExposedPortModel.HOST_ADDRESS,ExposedPortModel.HOST_PORT));
  dbc.bindSet(ViewersObservables.observeCheckedElements(exposedPortsTableViewer,ExposedPortModel.class),BeanProperties.set(ImageRunSelectionModel.SELECTED_PORTS).observe(model));
  exposedPortsTableViewer.addSelectionChangedListener(onSelectionChanged(editButton,removeButton));
  exposedPortsTableViewer.addCheckStateListener(onCheckStateChanged());
  togglePortMappingControls(exposedPortsTableViewer.getTable(),addButton,removeButton);
}","private void createPortSettingsSection(final Composite container){
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).span(3,1).applyTo(new Label(container,SWT.NONE));
  final Button publishAllPortsButton=new Button(container,SWT.CHECK);
  publishAllPortsButton.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).span(COLUMNS,1).grab(true,false).applyTo(publishAllPortsButton);
  dbc.bindValue(WidgetProperties.selection().observe(publishAllPortsButton),BeanProperties.value(ImageRunSelectionModel.class,ImageRunSelectionModel.PUBLISH_ALL_PORTS).observe(model));
  final Label portSettingsLabel=new Label(container,SWT.NONE);
  portSettingsLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).span(COLUMNS,1).indent(INDENT,0).applyTo(portSettingsLabel);
  final CheckboxTableViewer exposedPortsTableViewer=createPortSettingsTable(container);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,true).span(COLUMNS - 1,1).indent(INDENT,0).hint(200,70).applyTo(exposedPortsTableViewer.getTable());
  final Composite buttonsContainers=new Composite(container,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(false,false).applyTo(buttonsContainers);
  GridLayoutFactory.fillDefaults().numColumns(1).margins(0,0).spacing(SWT.DEFAULT,0).applyTo(buttonsContainers);
  final Button addButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(addButton);
  addButton.setText(WizardMessages.getString(""String_Node_Str""));
  addButton.addSelectionListener(onAddPort(exposedPortsTableViewer));
  final Button editButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(editButton);
  editButton.setText(WizardMessages.getString(""String_Node_Str""));
  editButton.setEnabled(false);
  editButton.addSelectionListener(onEditPort(exposedPortsTableViewer));
  final Button removeButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(removeButton);
  removeButton.setText(WizardMessages.getString(""String_Node_Str""));
  removeButton.addSelectionListener(onRemovePorts(exposedPortsTableViewer));
  BeanProperties.value(ImageRunSelectionModel.class,ImageRunSelectionModel.PUBLISH_ALL_PORTS).observe(model).addValueChangeListener(onPublishAllPortsChange(exposedPortsTableViewer.getTable(),addButton,removeButton));
  ViewerSupport.bind(exposedPortsTableViewer,model.getExposedPorts(),BeanProperties.values(ExposedPortModel.class,ExposedPortModel.CONTAINER_PORT,ExposedPortModel.PORT_TYPE,ExposedPortModel.HOST_ADDRESS,ExposedPortModel.HOST_PORT));
  dbc.bindSet(ViewersObservables.observeCheckedElements(exposedPortsTableViewer,ExposedPortModel.class),BeanProperties.set(ImageRunSelectionModel.SELECTED_PORTS).observe(model));
  exposedPortsTableViewer.addSelectionChangedListener(onSelectionChanged(editButton,removeButton));
  exposedPortsTableViewer.addCheckStateListener(onCheckStateChanged());
  togglePortMappingControls(exposedPortsTableViewer.getTable(),addButton,removeButton);
}",0.9942424242424244
91735,"private void createVolumeSettingsContainer(final Composite container){
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).span(3,1).applyTo(new Label(container,SWT.NONE));
  final Label volumesLabel=new Label(container,SWT.NONE);
  volumesLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).span(COLUMNS,1).applyTo(volumesLabel);
  final CheckboxTableViewer dataVolumesTableViewer=createVolumesTable(container);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).hint(200,100).applyTo(dataVolumesTableViewer.getTable());
  bind(dataVolumesTableViewer,model.getDataVolumes(),BeanProperties.values(DataVolumeModel.class,DataVolumeModel.CONTAINER_PATH,DataVolumeModel.MOUNT,DataVolumeModel.READ_ONLY_VOLUME));
  final IObservableSet selectedVolumesObservable=BeanProperties.set(ImageRunResourceVolumesVariablesModel.SELECTED_DATA_VOLUMES).observe(model);
  dbc.bindSet(ViewersObservables.observeCheckedElements(dataVolumesTableViewer,DataVolumeModel.class),selectedVolumesObservable);
  dataVolumesTableViewer.addCheckStateListener(onCheckStateChanged());
  final Composite buttonsContainers=new Composite(container,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(false,false).applyTo(buttonsContainers);
  GridLayoutFactory.fillDefaults().numColumns(1).margins(0,0).spacing(SWT.DEFAULT,0).applyTo(buttonsContainers);
  final Button addButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(addButton);
  addButton.setText(WizardMessages.getString(""String_Node_Str""));
  addButton.addSelectionListener(onAddDataVolume(dataVolumesTableViewer));
  final Button editButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(editButton);
  editButton.setText(WizardMessages.getString(""String_Node_Str""));
  editButton.addSelectionListener(onEditDataVolume(dataVolumesTableViewer));
  editButton.setEnabled(false);
  final Button removeButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(removeButton);
  removeButton.setText(WizardMessages.getString(""String_Node_Str""));
  removeButton.addSelectionListener(onRemoveDataVolumes(dataVolumesTableViewer));
  removeButton.setEnabled(false);
  dataVolumesTableViewer.addSelectionChangedListener(onSelectionChanged(editButton,removeButton));
}","private void createVolumeSettingsContainer(final Composite container){
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).span(3,1).applyTo(new Label(container,SWT.NONE));
  final Label volumesLabel=new Label(container,SWT.NONE);
  volumesLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).span(COLUMNS,1).applyTo(volumesLabel);
  final CheckboxTableViewer dataVolumesTableViewer=createVolumesTable(container);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,true).hint(200,100).applyTo(dataVolumesTableViewer.getTable());
  bind(dataVolumesTableViewer,model.getDataVolumes(),BeanProperties.values(DataVolumeModel.class,DataVolumeModel.CONTAINER_PATH,DataVolumeModel.MOUNT,DataVolumeModel.READ_ONLY_VOLUME));
  final IObservableSet selectedVolumesObservable=BeanProperties.set(ImageRunResourceVolumesVariablesModel.SELECTED_DATA_VOLUMES).observe(model);
  dbc.bindSet(ViewersObservables.observeCheckedElements(dataVolumesTableViewer,DataVolumeModel.class),selectedVolumesObservable);
  dataVolumesTableViewer.addCheckStateListener(onCheckStateChanged());
  final Composite buttonsContainers=new Composite(container,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(false,false).applyTo(buttonsContainers);
  GridLayoutFactory.fillDefaults().numColumns(1).margins(0,0).spacing(SWT.DEFAULT,0).applyTo(buttonsContainers);
  final Button addButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(addButton);
  addButton.setText(WizardMessages.getString(""String_Node_Str""));
  addButton.addSelectionListener(onAddDataVolume(dataVolumesTableViewer));
  final Button editButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(editButton);
  editButton.setText(WizardMessages.getString(""String_Node_Str""));
  editButton.addSelectionListener(onEditDataVolume(dataVolumesTableViewer));
  editButton.setEnabled(false);
  final Button removeButton=new Button(buttonsContainers,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.TOP).grab(true,false).applyTo(removeButton);
  removeButton.setText(WizardMessages.getString(""String_Node_Str""));
  removeButton.addSelectionListener(onRemoveDataVolumes(dataVolumesTableViewer));
  removeButton.setEnabled(false);
  dataVolumesTableViewer.addSelectionChangedListener(onSelectionChanged(editButton,removeButton));
}",0.992583918813427
91736,"@Override public void dispose(){
  Collection<Job> jobs=Collections.emptyList();
synchronized (openRetryJobs) {
    jobs=openRetryJobs.values();
  }
  for (  Job job : jobs) {
    LoadingJob loadingJob=(LoadingJob)job;
    IProgressMonitor monitor=loadingJob.getMonitor();
    monitor.setCanceled(true);
    job.cancel();
    try {
      job.join();
    }
 catch (    InterruptedException e) {
    }
  }
}","@Override public void dispose(){
  Collection<Job> jobs=Collections.emptyList();
synchronized (openRetryJobs) {
    jobs=new ArrayList<>(openRetryJobs.values());
  }
  for (  Job job : jobs) {
    LoadingJob loadingJob=(LoadingJob)job;
    IProgressMonitor monitor=loadingJob.getMonitor();
    monitor.setCanceled(true);
    job.cancel();
    try {
      job.join();
    }
 catch (    InterruptedException e) {
    }
  }
}",0.9794437726723096
91737,"/** 
 * Perform a launch of a command in a container and output stdout/stderr to console.
 * @param id - id of caller to use to distinguish console owner
 * @param listener - optional listener of the run console
 * @param connectionUri - the specified connection to use
 * @param image - the image to use
 * @param command - command to run
 * @param commandDir - directory command requires or null
 * @param workingDir - working directory or null
 * @param additionalDirs - additional directories to mount or null
 * @param origEnv - original environment if we are appending to our existing environment
 * @param envMap - map of environment variable settings
 * @param ports - ports to expose
 * @param keep - keep container after running
 * @param stdinSupport - true if stdin support is required, false otherwise
 * @param privilegedMode - true if privileged mode is required, false otherwise
 * @param labels - Map of labels for the container
 * @param seccomp - seccomp profile
 * @since 3.0
 */
public void launch(String id,IContainerLaunchListener listener,final String connectionUri,String image,String command,String commandDir,String workingDir,List<String> additionalDirs,Map<String,String> origEnv,Map<String,String> envMap,List<String> ports,boolean keep,boolean stdinSupport,boolean privilegedMode,Map<String,String> labels,String seccomp){
  final String LAUNCH_TITLE=""String_Node_Str"";
  final String LAUNCH_EXITED_TITLE=""String_Node_Str"";
  final List<String> env=new ArrayList<>();
  env.addAll(toList(origEnv));
  env.addAll(toList(envMap));
  final List<String> cmdList=getCmdList(command);
  final Set<String> exposedPorts=new HashSet<>();
  final Map<String,List<IDockerPortBinding>> portBindingsMap=new HashMap<>();
  if (ports != null) {
    for (    String port : ports) {
      port=port.trim();
      if (port.length() > 0) {
        String[] segments=port.split(""String_Node_Str"");
        if (segments.length == 1) {
          exposedPorts.add(segments[0]);
          portBindingsMap.put(segments[0],Arrays.asList((IDockerPortBinding)new DockerPortBinding(""String_Node_Str"",""String_Node_Str"")));
        }
 else         if (segments.length == 2) {
          exposedPorts.add(segments[1]);
          portBindingsMap.put(segments[1],Arrays.asList((IDockerPortBinding)new DockerPortBinding(""String_Node_Str"",segments[0])));
        }
 else         if (segments.length == 3) {
          exposedPorts.add(segments[1]);
          if (segments[1].isEmpty()) {
            portBindingsMap.put(segments[2],Arrays.asList((IDockerPortBinding)new DockerPortBinding(""String_Node_Str"",segments[0])));
          }
 else {
            portBindingsMap.put(segments[2],Arrays.asList((IDockerPortBinding)new DockerPortBinding(segments[0],segments[1])));
          }
        }
      }
    }
  }
  DockerContainerConfig.Builder builder=new DockerContainerConfig.Builder().openStdin(stdinSupport).cmd(cmdList).image(image).workingDir(workingDir);
  if (listener != null && listener.getClass().getName().equals(""String_Node_Str"")) {
    builder=builder.tty(true);
  }
  if (exposedPorts.size() > 0)   builder=builder.exposedPorts(exposedPorts);
  if (labels != null)   builder=builder.labels(labels);
  if (!DockerConnectionManager.getInstance().hasConnections()) {
    Display.getDefault().syncExec(() -> MessageDialog.openError(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell(),DVMessages.getString(ERROR_LAUNCHING_CONTAINER),DVMessages.getString(ERROR_NO_CONNECTIONS)));
    return;
  }
  final IDockerConnection connection=DockerConnectionManager.getInstance().getConnectionByUri(connectionUri);
  if (connection == null) {
    Display.getDefault().syncExec(() -> MessageDialog.openError(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell(),DVMessages.getString(ERROR_LAUNCHING_CONTAINER),DVMessages.getFormattedString(ERROR_NO_CONNECTION_WITH_URI,connectionUri)));
    return;
  }
  if (!connection.isOpen()) {
    connection.getImages();
  }
  DockerHostConfig.Builder hostBuilder=new DockerHostConfig.Builder().privileged(privilegedMode);
  if (seccomp != null) {
    hostBuilder.securityOpt(seccomp);
  }
  final Map<String,String> remoteVolumes=new HashMap<>();
  if (!((DockerConnection)connection).isLocal()) {
    final Set<String> volumes=new HashSet<>();
    if (additionalDirs != null) {
      for (      String dir : additionalDirs) {
        remoteVolumes.put(dir,dir);
        volumes.add(dir);
      }
    }
    if (workingDir != null) {
      remoteVolumes.put(workingDir,workingDir);
      volumes.add(workingDir);
    }
    if (commandDir != null) {
      remoteVolumes.put(commandDir,commandDir);
      volumes.add(commandDir);
    }
    builder=builder.volumes(volumes);
  }
 else {
    final List<String> volumes=new ArrayList<>();
    if (additionalDirs != null) {
      for (      String dir : additionalDirs) {
        volumes.add(dir + ""String_Node_Str"" + dir+ ""String_Node_Str"");
      }
    }
    if (workingDir != null) {
      volumes.add(workingDir + ""String_Node_Str"" + workingDir+ ""String_Node_Str"");
    }
    if (commandDir != null) {
      volumes.add(commandDir + ""String_Node_Str"" + commandDir+ ""String_Node_Str"");
    }
    hostBuilder=hostBuilder.binds(volumes);
  }
  final DockerContainerConfig config=builder.build();
  if (portBindingsMap.size() > 0)   hostBuilder=hostBuilder.portBindings(portBindingsMap);
  final IDockerHostConfig hostConfig=hostBuilder.build();
  final String imageName=image;
  final boolean keepContainer=keep;
  final String consoleId=id;
  final IContainerLaunchListener containerListener=listener;
  Thread t=new Thread(() -> {
    String containerId=null;
    try {
      containerId=((DockerConnection)connection).createContainer(config,hostConfig,null);
      if (!((DockerConnection)connection).isLocal()) {
        if (!remoteVolumes.isEmpty()) {
          CopyVolumesJob job=new CopyVolumesJob(remoteVolumes,connection,containerId);
          job.schedule();
          job.join();
          if (job.getResult() != Status.OK_STATUS)           return;
        }
      }
      if (config.tty()) {
        OutputStream stream=null;
        RunConsole oldConsole=getConsole();
        final RunConsole rc=RunConsole.findConsole(containerId,consoleId);
        setConsole(rc);
        rc.clearConsole();
        if (oldConsole != null)         RunConsole.removeConsole(oldConsole);
        Display.getDefault().syncExec(() -> rc.setTitle(Messages.getFormattedString(LAUNCH_TITLE,new String[]{cmdList.get(0),imageName})));
        if (rc != null) {
          stream=rc.getOutputStream();
        }
        DockerConsoleOutputStream out=new DockerConsoleOutputStream(stream);
        RunConsole.attachToTerminal(connection,containerId,out);
        if (containerListener != null) {
          out.addConsoleListener(new RunConsoleListenerBridge(containerListener));
        }
        ((DockerConnection)connection).startContainer(containerId,null,null);
        IDockerContainerInfo info=((DockerConnection)connection).getContainerInfo(containerId);
        if (containerListener != null) {
          containerListener.containerInfo(info);
        }
        final IDockerContainerExit status=((DockerConnection)connection).waitForContainer(containerId);
        Display.getDefault().syncExec(() -> {
          rc.setTitle(Messages.getFormattedString(LAUNCH_EXITED_TITLE,new String[]{status.statusCode().toString(),cmdList.get(0),imageName}));
          rc.showConsole();
          IWorkbenchPage page=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
          IViewPart terminalView=page.findView(""String_Node_Str"");
          CTabFolder ctabfolder=terminalView.getAdapter(CTabFolder.class);
          if (ctabfolder != null) {
            CTabItem[] items=ctabfolder.getItems();
            for (            CTabItem item : items) {
              if (item.getText().endsWith(info.name())) {
                item.dispose();
                break;
              }
            }
          }
        }
);
        if (containerListener != null)         containerListener.done();
        if (!keepContainer) {
          ((DockerConnection)connection).removeContainer(containerId);
        }
      }
 else {
        OutputStream stream=null;
        RunConsole oldConsole=getConsole();
        final RunConsole rc=RunConsole.findConsole(containerId,consoleId);
        setConsole(rc);
        rc.clearConsole();
        if (oldConsole != null)         RunConsole.removeConsole(oldConsole);
        Display.getDefault().syncExec(() -> rc.setTitle(Messages.getFormattedString(LAUNCH_TITLE,new String[]{cmdList.get(0),imageName})));
        rc.attachToConsole(connection,containerId);
        if (rc != null) {
          stream=rc.getOutputStream();
          if (containerListener != null) {
            ((ConsoleOutputStream)stream).addConsoleListener(containerListener);
          }
        }
        String loggingId=containerId + ""String_Node_Str"" + consoleId;
        ((DockerConnection)connection).startContainer(containerId,loggingId,stream);
        if (rc != null)         rc.showConsole();
        if (containerListener != null) {
          IDockerContainerInfo info=((DockerConnection)connection).getContainerInfo(containerId);
          containerListener.containerInfo(info);
        }
        final IDockerContainerExit status=((DockerConnection)connection).waitForContainer(containerId);
        Display.getDefault().syncExec(() -> {
          rc.setTitle(Messages.getFormattedString(LAUNCH_EXITED_TITLE,new String[]{status.statusCode().toString(),cmdList.get(0),imageName}));
          rc.showConsole();
        }
);
        if (containerListener != null)         containerListener.done();
        if (!keepContainer) {
          Thread.sleep(1000);
          ((DockerConnection)connection).stopLoggingThread(loggingId);
          RunConsole rc2=RunConsole.findConsole(((DockerConnection)connection).getContainer(containerId));
          if (rc2 != null)           RunConsole.removeConsole(rc2);
          ((DockerConnection)connection).removeContainer(containerId);
        }
      }
    }
 catch (    final DockerException e2) {
      if (!keepContainer && containerId != null) {
        try {
          ((DockerConnection)connection).removeContainer(containerId);
        }
 catch (        DockerException|InterruptedException e1) {
        }
      }
      Display.getDefault().syncExec(() -> MessageDialog.openError(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell(),DVMessages.getFormattedString(ERROR_CREATING_CONTAINER,imageName),e2.getMessage()));
    }
catch (    InterruptedException e3) {
    }
    ((DockerConnection)connection).getContainers(true);
  }
);
  t.start();
}","/** 
 * Perform a launch of a command in a container and output stdout/stderr to console.
 * @param id - id of caller to use to distinguish console owner
 * @param listener - optional listener of the run console
 * @param connectionUri - the specified connection to use
 * @param image - the image to use
 * @param cmdList - command to run as list of String
 * @param workingDir - working directory or null
 * @param additionalDirs - additional directories to mount or null
 * @param origEnv - original environment if we are appending to our existing environment
 * @param envMap - map of environment variable settings
 * @param ports - ports to expose
 * @param keep - keep container after running
 * @param stdinSupport - true if stdin support is required, false otherwise
 * @param privilegedMode - true if privileged mode is required, false otherwise
 * @param labels - Map of labels for the container
 * @param seccomp - seccomp profile
 * @since 4.0
 */
public void launch(String id,IContainerLaunchListener listener,final String connectionUri,String image,List<String> cmdList,String workingDir,List<String> additionalDirs,Map<String,String> origEnv,Map<String,String> envMap,List<String> ports,boolean keep,boolean stdinSupport,boolean privilegedMode,Map<String,String> labels,String seccomp){
  final String LAUNCH_TITLE=""String_Node_Str"";
  final String LAUNCH_EXITED_TITLE=""String_Node_Str"";
  final List<String> env=new ArrayList<>();
  env.addAll(toList(origEnv));
  env.addAll(toList(envMap));
  final Set<String> exposedPorts=new HashSet<>();
  final Map<String,List<IDockerPortBinding>> portBindingsMap=new HashMap<>();
  if (ports != null) {
    for (    String port : ports) {
      port=port.trim();
      if (port.length() > 0) {
        String[] segments=port.split(""String_Node_Str"");
        if (segments.length == 1) {
          exposedPorts.add(segments[0]);
          portBindingsMap.put(segments[0],Arrays.asList((IDockerPortBinding)new DockerPortBinding(""String_Node_Str"",""String_Node_Str"")));
        }
 else         if (segments.length == 2) {
          exposedPorts.add(segments[1]);
          portBindingsMap.put(segments[1],Arrays.asList((IDockerPortBinding)new DockerPortBinding(""String_Node_Str"",segments[0])));
        }
 else         if (segments.length == 3) {
          exposedPorts.add(segments[1]);
          if (segments[1].isEmpty()) {
            portBindingsMap.put(segments[2],Arrays.asList((IDockerPortBinding)new DockerPortBinding(""String_Node_Str"",segments[0])));
          }
 else {
            portBindingsMap.put(segments[2],Arrays.asList((IDockerPortBinding)new DockerPortBinding(segments[0],segments[1])));
          }
        }
      }
    }
  }
  DockerContainerConfig.Builder builder=new DockerContainerConfig.Builder().openStdin(stdinSupport).cmd(cmdList).image(image).workingDir(workingDir);
  if (listener != null && listener.getClass().getName().equals(""String_Node_Str"")) {
    builder=builder.tty(true);
  }
  if (exposedPorts.size() > 0)   builder=builder.exposedPorts(exposedPorts);
  if (labels != null)   builder=builder.labels(labels);
  if (!DockerConnectionManager.getInstance().hasConnections()) {
    Display.getDefault().syncExec(() -> MessageDialog.openError(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell(),DVMessages.getString(ERROR_LAUNCHING_CONTAINER),DVMessages.getString(ERROR_NO_CONNECTIONS)));
    return;
  }
  final IDockerConnection connection=DockerConnectionManager.getInstance().getConnectionByUri(connectionUri);
  if (connection == null) {
    Display.getDefault().syncExec(() -> MessageDialog.openError(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell(),DVMessages.getString(ERROR_LAUNCHING_CONTAINER),DVMessages.getFormattedString(ERROR_NO_CONNECTION_WITH_URI,connectionUri)));
    return;
  }
  if (!connection.isOpen()) {
    connection.getImages();
  }
  DockerHostConfig.Builder hostBuilder=new DockerHostConfig.Builder().privileged(privilegedMode);
  if (seccomp != null) {
    hostBuilder.securityOpt(seccomp);
  }
  final Map<String,String> remoteVolumes=new HashMap<>();
  if (!((DockerConnection)connection).isLocal()) {
    final Set<String> volumes=new HashSet<>();
    if (additionalDirs != null) {
      for (      String dir : additionalDirs) {
        remoteVolumes.put(dir,dir);
        volumes.add(dir);
      }
    }
    if (workingDir != null) {
      remoteVolumes.put(workingDir,workingDir);
      volumes.add(workingDir);
    }
    builder=builder.volumes(volumes);
  }
 else {
    final List<String> volumes=new ArrayList<>();
    if (additionalDirs != null) {
      for (      String dir : additionalDirs) {
        volumes.add(dir + ""String_Node_Str"" + dir+ ""String_Node_Str"");
      }
    }
    if (workingDir != null) {
      volumes.add(workingDir + ""String_Node_Str"" + workingDir+ ""String_Node_Str"");
    }
    hostBuilder=hostBuilder.binds(volumes);
  }
  final DockerContainerConfig config=builder.build();
  if (portBindingsMap.size() > 0)   hostBuilder=hostBuilder.portBindings(portBindingsMap);
  final IDockerHostConfig hostConfig=hostBuilder.build();
  final String imageName=image;
  final boolean keepContainer=keep;
  final String consoleId=id;
  final IContainerLaunchListener containerListener=listener;
  Thread t=new Thread(() -> {
    String containerId=null;
    try {
      containerId=((DockerConnection)connection).createContainer(config,hostConfig,null);
      if (!((DockerConnection)connection).isLocal()) {
        if (!remoteVolumes.isEmpty()) {
          CopyVolumesJob job=new CopyVolumesJob(remoteVolumes,connection,containerId);
          job.schedule();
          job.join();
          if (job.getResult() != Status.OK_STATUS)           return;
        }
      }
      if (config.tty()) {
        OutputStream stream=null;
        RunConsole oldConsole=getConsole();
        final RunConsole rc=RunConsole.findConsole(containerId,consoleId);
        setConsole(rc);
        rc.clearConsole();
        if (oldConsole != null)         RunConsole.removeConsole(oldConsole);
        Display.getDefault().syncExec(() -> rc.setTitle(Messages.getFormattedString(LAUNCH_TITLE,new String[]{cmdList.get(0),imageName})));
        if (rc != null) {
          stream=rc.getOutputStream();
        }
        DockerConsoleOutputStream out=new DockerConsoleOutputStream(stream);
        RunConsole.attachToTerminal(connection,containerId,out);
        if (containerListener != null) {
          out.addConsoleListener(new RunConsoleListenerBridge(containerListener));
        }
        ((DockerConnection)connection).startContainer(containerId,null,null);
        IDockerContainerInfo info=((DockerConnection)connection).getContainerInfo(containerId);
        if (containerListener != null) {
          containerListener.containerInfo(info);
        }
        final IDockerContainerExit status=((DockerConnection)connection).waitForContainer(containerId);
        Display.getDefault().syncExec(() -> {
          rc.setTitle(Messages.getFormattedString(LAUNCH_EXITED_TITLE,new String[]{status.statusCode().toString(),cmdList.get(0),imageName}));
          rc.showConsole();
          IWorkbenchPage page=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
          IViewPart terminalView=page.findView(""String_Node_Str"");
          CTabFolder ctabfolder=terminalView.getAdapter(CTabFolder.class);
          if (ctabfolder != null) {
            CTabItem[] items=ctabfolder.getItems();
            for (            CTabItem item : items) {
              if (item.getText().endsWith(info.name())) {
                item.dispose();
                break;
              }
            }
          }
        }
);
        if (containerListener != null)         containerListener.done();
        if (!keepContainer) {
          ((DockerConnection)connection).removeContainer(containerId);
        }
      }
 else {
        OutputStream stream=null;
        RunConsole oldConsole=getConsole();
        final RunConsole rc=RunConsole.findConsole(containerId,consoleId);
        setConsole(rc);
        rc.clearConsole();
        if (oldConsole != null)         RunConsole.removeConsole(oldConsole);
        Display.getDefault().syncExec(() -> rc.setTitle(Messages.getFormattedString(LAUNCH_TITLE,new String[]{cmdList.get(0),imageName})));
        rc.attachToConsole(connection,containerId);
        if (rc != null) {
          stream=rc.getOutputStream();
          if (containerListener != null) {
            ((ConsoleOutputStream)stream).addConsoleListener(containerListener);
          }
        }
        String loggingId=containerId + ""String_Node_Str"" + consoleId;
        ((DockerConnection)connection).startContainer(containerId,loggingId,stream);
        if (rc != null)         rc.showConsole();
        if (containerListener != null) {
          IDockerContainerInfo info=((DockerConnection)connection).getContainerInfo(containerId);
          containerListener.containerInfo(info);
        }
        final IDockerContainerExit status=((DockerConnection)connection).waitForContainer(containerId);
        Display.getDefault().syncExec(() -> {
          rc.setTitle(Messages.getFormattedString(LAUNCH_EXITED_TITLE,new String[]{status.statusCode().toString(),cmdList.get(0),imageName}));
          rc.showConsole();
        }
);
        if (containerListener != null)         containerListener.done();
        if (!keepContainer) {
          Thread.sleep(1000);
          ((DockerConnection)connection).stopLoggingThread(loggingId);
          RunConsole rc2=RunConsole.findConsole(((DockerConnection)connection).getContainer(containerId));
          if (rc2 != null)           RunConsole.removeConsole(rc2);
          ((DockerConnection)connection).removeContainer(containerId);
        }
      }
    }
 catch (    final DockerException e2) {
      if (!keepContainer && containerId != null) {
        try {
          ((DockerConnection)connection).removeContainer(containerId);
        }
 catch (        DockerException|InterruptedException e1) {
        }
      }
      Display.getDefault().syncExec(() -> MessageDialog.openError(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell(),DVMessages.getFormattedString(ERROR_CREATING_CONTAINER,imageName),e2.getMessage()));
    }
catch (    InterruptedException e3) {
    }
    ((DockerConnection)connection).getContainers(true);
  }
);
  t.start();
}",0.9545282303902992
91738,"/** 
 * Create a Process to run an arbitrary command in a Container with uid of caller so any files created are accessible to user.
 * @param connectionName - uri of connection to use
 * @param imageName - name of image to use
 * @param project - Eclipse project
 * @param errMsgHolder - holder for any error messages
 * @param command - command to run
 * @param commandDir - directory path to command
 * @param workingDir - where to run command
 * @param additionalDirs - additional directories to mount
 * @param origEnv - original environment if we are appending to existing
 * @param envMap - new environment
 * @param supportStdin - support using stdin
 * @param privilegedMode - run in privileged mode
 * @param labels - labels to apply to Container
 * @param keepContainer - boolean whether to keep Container when done
 * @return Process that can be used to check for completion and for routingstdout/stderr
 * @since 3.0
 */
public Process runCommand(String connectionName,String imageName,IProject project,IErrorMessageHolder errMsgHolder,String command,String commandDir,String workingDir,List<String> additionalDirs,Map<String,String> origEnv,Properties envMap,boolean supportStdin,boolean privilegedMode,HashMap<String,String> labels,boolean keepContainer){
  Integer uid=null;
  Integer gid=null;
  String os=System.getProperty(""String_Node_Str"");
  if (os.indexOf(""String_Node_Str"") > 0) {
    ID ugid=fidMap.get(project);
    if (ugid == null) {
      try {
        uid=(Integer)Files.getAttribute(project.getLocation().toFile().toPath(),""String_Node_Str"");
        gid=(Integer)Files.getAttribute(project.getLocation().toFile().toPath(),""String_Node_Str"");
        ugid=new ID(uid,gid);
        fidMap.put(project,ugid);
      }
 catch (      IOException e) {
      }
    }
 else {
      uid=ugid.getuid();
      gid=ugid.getgid();
    }
  }
  final List<String> env=new ArrayList<>();
  env.addAll(toList(origEnv));
  env.addAll(toList(envMap));
  final List<String> cmdList=getCmdList(command);
  final Map<String,List<IDockerPortBinding>> portBindingsMap=new HashMap<>();
  IDockerConnection[] connections=DockerConnectionManager.getInstance().getConnections();
  if (connections == null || connections.length == 0) {
    errMsgHolder.setErrorMessage(Messages.getString(""String_Node_Str""));
    return null;
  }
  IDockerConnection connection=null;
  for (  IDockerConnection c : connections) {
    if (c.getUri().equals(connectionName)) {
      connection=c;
      break;
    }
  }
  if (connection == null) {
    errMsgHolder.setErrorMessage(Messages.getFormattedString(""String_Node_Str"",connectionName));
    return null;
  }
  List<IDockerImage> images=connection.getImages();
  if (images.isEmpty()) {
    errMsgHolder.setErrorMessage(Messages.getString(""String_Node_Str""));
    return null;
  }
  IDockerImageInfo info=connection.getImageInfo(imageName);
  if (info == null) {
    errMsgHolder.setErrorMessage(Messages.getFormattedString(""String_Node_Str"",imageName));
    return null;
  }
  DockerContainerConfig.Builder builder=new DockerContainerConfig.Builder().openStdin(supportStdin).cmd(cmdList).image(imageName).workingDir(workingDir);
  if (uid != null) {
    builder=builder.user(uid.toString());
  }
  if (labels != null)   builder=builder.labels(labels);
  DockerHostConfig.Builder hostBuilder=new DockerHostConfig.Builder().privileged(privilegedMode);
  final Set<String> remoteVolumes=new TreeSet<>();
  final Map<String,String> remoteDataVolumes=new HashMap<>();
  final Set<String> readOnlyVolumes=new TreeSet<>();
  if (!((DockerConnection)connection).isLocal()) {
    if (additionalDirs != null) {
      for (      String dir : additionalDirs) {
        IPath p=new Path(dir).removeTrailingSeparator();
        remoteVolumes.add(p.toPortableString());
        remoteDataVolumes.put(p.toPortableString(),p.toPortableString());
        if (dir.contains(""String_Node_Str"")) {
          DataVolumeModel dvm=DataVolumeModel.parseString(dir);
switch (dvm.getMountType()) {
case HOST_FILE_SYSTEM:
            dir=dvm.getHostPathMount();
          remoteDataVolumes.put(dir,dvm.getContainerMount());
        if (dvm.isReadOnly()) {
          readOnlyVolumes.add(dir);
        }
      break;
default :
    continue;
}
}
}
}
if (workingDir != null) {
IPath p=new Path(workingDir).removeTrailingSeparator();
remoteVolumes.add(p.toPortableString());
remoteDataVolumes.put(p.toPortableString(),p.toPortableString());
}
if (commandDir != null) {
IPath p=new Path(commandDir).removeTrailingSeparator();
remoteVolumes.add(p.toPortableString());
remoteDataVolumes.put(p.toPortableString(),p.toPortableString());
}
builder=builder.volumes(remoteVolumes);
}
 else {
final Set<String> volumes=new TreeSet<>();
final List<String> volumesFrom=new ArrayList<>();
if (additionalDirs != null) {
for (String dir : additionalDirs) {
IPath p=new Path(dir).removeTrailingSeparator();
if (dir.contains(""String_Node_Str"")) {
DataVolumeModel dvm=DataVolumeModel.parseString(dir);
switch (dvm.getMountType()) {
case HOST_FILE_SYSTEM:
  String bind=LaunchConfigurationUtils.convertToUnixPath(dvm.getHostPathMount()) + ':' + dvm.getContainerPath()+ ""String_Node_Str"";
if (dvm.isReadOnly()) {
  bind+=""String_Node_Str"";
}
volumes.add(bind);
break;
case CONTAINER:
volumesFrom.add(dvm.getContainerMount());
break;
default :
break;
}
}
 else {
volumes.add(p.toPortableString() + ""String_Node_Str"" + p.toPortableString()+ ""String_Node_Str"");
}
}
}
if (workingDir != null) {
IPath p=new Path(workingDir).removeTrailingSeparator();
volumes.add(p.toPortableString() + ""String_Node_Str"" + p.toPortableString()+ ""String_Node_Str"");
}
if (commandDir != null) {
IPath p=new Path(commandDir).removeTrailingSeparator();
volumes.add(p.toPortableString() + ""String_Node_Str"" + p.toPortableString()+ ""String_Node_Str"");
}
List<String> volumeList=new ArrayList<>(volumes);
hostBuilder=hostBuilder.binds(volumeList);
if (!volumesFrom.isEmpty()) {
hostBuilder=hostBuilder.volumesFrom(volumesFrom);
}
}
final DockerContainerConfig config=builder.build();
if (portBindingsMap.size() > 0) hostBuilder=hostBuilder.portBindings(portBindingsMap);
final IDockerHostConfig hostConfig=hostBuilder.build();
String containerId=null;
try {
containerId=((DockerConnection)connection).createContainer(config,hostConfig,null);
}
 catch (DockerException|InterruptedException e) {
errMsgHolder.setErrorMessage(e.getMessage());
return null;
}
final String id=containerId;
final IDockerConnection conn=connection;
if (!((DockerConnection)conn).isLocal()) {
if (!remoteVolumes.isEmpty()) {
CopyVolumesJob job=new CopyVolumesJob(remoteDataVolumes,conn,id);
job.schedule();
try {
job.join();
}
 catch (InterruptedException e) {
}
}
}
try {
((DockerConnection)conn).startContainer(id,null);
}
 catch (DockerException|InterruptedException e) {
Activator.log(e);
}
for (String readonly : readOnlyVolumes) {
remoteDataVolumes.remove(readonly);
}
return new ContainerCommandProcess(connection,imageName,containerId,remoteDataVolumes,keepContainer);
}","/** 
 * Create a Process to run an arbitrary command in a Container with uid of caller so any files created are accessible to user.
 * @param connectionName - uri of connection to use
 * @param imageName - name of image to use
 * @param project - Eclipse project
 * @param errMsgHolder - holder for any error messages
 * @param cmdList - command to run as list of String
 * @param workingDir - where to run command
 * @param additionalDirs - additional directories to mount
 * @param origEnv - original environment if we are appending to existing
 * @param envMap - new environment
 * @param supportStdin - support using stdin
 * @param privilegedMode - run in privileged mode
 * @param labels - labels to apply to Container
 * @param keepContainer - boolean whether to keep Container when done
 * @return Process that can be used to check for completion and for routingstdout/stderr
 * @since 4.0
 */
public Process runCommand(String connectionName,String imageName,IProject project,IErrorMessageHolder errMsgHolder,List<String> cmdList,String workingDir,List<String> additionalDirs,Map<String,String> origEnv,Properties envMap,boolean supportStdin,boolean privilegedMode,HashMap<String,String> labels,boolean keepContainer){
  Integer uid=null;
  Integer gid=null;
  String os=System.getProperty(""String_Node_Str"");
  if (os.indexOf(""String_Node_Str"") > 0) {
    ID ugid=fidMap.get(project);
    if (ugid == null) {
      try {
        uid=(Integer)Files.getAttribute(project.getLocation().toFile().toPath(),""String_Node_Str"");
        gid=(Integer)Files.getAttribute(project.getLocation().toFile().toPath(),""String_Node_Str"");
        ugid=new ID(uid,gid);
        fidMap.put(project,ugid);
      }
 catch (      IOException e) {
      }
    }
 else {
      uid=ugid.getuid();
      gid=ugid.getgid();
    }
  }
  final List<String> env=new ArrayList<>();
  env.addAll(toList(origEnv));
  env.addAll(toList(envMap));
  final Map<String,List<IDockerPortBinding>> portBindingsMap=new HashMap<>();
  IDockerConnection[] connections=DockerConnectionManager.getInstance().getConnections();
  if (connections == null || connections.length == 0) {
    errMsgHolder.setErrorMessage(Messages.getString(""String_Node_Str""));
    return null;
  }
  IDockerConnection connection=null;
  for (  IDockerConnection c : connections) {
    if (c.getUri().equals(connectionName)) {
      connection=c;
      break;
    }
  }
  if (connection == null) {
    errMsgHolder.setErrorMessage(Messages.getFormattedString(""String_Node_Str"",connectionName));
    return null;
  }
  List<IDockerImage> images=connection.getImages();
  if (images.isEmpty()) {
    errMsgHolder.setErrorMessage(Messages.getString(""String_Node_Str""));
    return null;
  }
  IDockerImageInfo info=connection.getImageInfo(imageName);
  if (info == null) {
    errMsgHolder.setErrorMessage(Messages.getFormattedString(""String_Node_Str"",imageName));
    return null;
  }
  DockerContainerConfig.Builder builder=new DockerContainerConfig.Builder().openStdin(supportStdin).cmd(cmdList).image(imageName).workingDir(workingDir);
  if (uid != null) {
    builder=builder.user(uid.toString());
  }
  if (labels != null)   builder=builder.labels(labels);
  DockerHostConfig.Builder hostBuilder=new DockerHostConfig.Builder().privileged(privilegedMode);
  final Set<String> remoteVolumes=new TreeSet<>();
  final Map<String,String> remoteDataVolumes=new HashMap<>();
  final Set<String> readOnlyVolumes=new TreeSet<>();
  if (!((DockerConnection)connection).isLocal()) {
    if (additionalDirs != null) {
      for (      String dir : additionalDirs) {
        IPath p=new Path(dir).removeTrailingSeparator();
        remoteVolumes.add(p.toPortableString());
        remoteDataVolumes.put(p.toPortableString(),p.toPortableString());
        if (dir.contains(""String_Node_Str"")) {
          DataVolumeModel dvm=DataVolumeModel.parseString(dir);
switch (dvm.getMountType()) {
case HOST_FILE_SYSTEM:
            dir=dvm.getHostPathMount();
          remoteDataVolumes.put(dir,dvm.getContainerMount());
        if (dvm.isReadOnly()) {
          readOnlyVolumes.add(dir);
        }
      break;
default :
    continue;
}
}
}
}
if (workingDir != null) {
IPath p=new Path(workingDir).removeTrailingSeparator();
remoteVolumes.add(p.toPortableString());
remoteDataVolumes.put(p.toPortableString(),p.toPortableString());
}
builder=builder.volumes(remoteVolumes);
}
 else {
final Set<String> volumes=new TreeSet<>();
final List<String> volumesFrom=new ArrayList<>();
if (additionalDirs != null) {
for (String dir : additionalDirs) {
IPath p=new Path(dir).removeTrailingSeparator();
if (dir.contains(""String_Node_Str"")) {
DataVolumeModel dvm=DataVolumeModel.parseString(dir);
switch (dvm.getMountType()) {
case HOST_FILE_SYSTEM:
  String bind=LaunchConfigurationUtils.convertToUnixPath(dvm.getHostPathMount()) + ':' + dvm.getContainerPath()+ ""String_Node_Str"";
if (dvm.isReadOnly()) {
  bind+=""String_Node_Str"";
}
volumes.add(bind);
break;
case CONTAINER:
volumesFrom.add(dvm.getContainerMount());
break;
default :
break;
}
}
 else {
volumes.add(p.toPortableString() + ""String_Node_Str"" + p.toPortableString()+ ""String_Node_Str"");
}
}
}
if (workingDir != null) {
IPath p=new Path(workingDir).removeTrailingSeparator();
volumes.add(p.toPortableString() + ""String_Node_Str"" + p.toPortableString()+ ""String_Node_Str"");
}
List<String> volumeList=new ArrayList<>(volumes);
hostBuilder=hostBuilder.binds(volumeList);
if (!volumesFrom.isEmpty()) {
hostBuilder=hostBuilder.volumesFrom(volumesFrom);
}
}
final DockerContainerConfig config=builder.build();
if (portBindingsMap.size() > 0) hostBuilder=hostBuilder.portBindings(portBindingsMap);
final IDockerHostConfig hostConfig=hostBuilder.build();
String containerId=null;
try {
containerId=((DockerConnection)connection).createContainer(config,hostConfig,null);
}
 catch (DockerException|InterruptedException e) {
errMsgHolder.setErrorMessage(e.getMessage());
return null;
}
final String id=containerId;
final IDockerConnection conn=connection;
if (!((DockerConnection)conn).isLocal()) {
if (!remoteVolumes.isEmpty()) {
CopyVolumesJob job=new CopyVolumesJob(remoteDataVolumes,conn,id);
job.schedule();
try {
job.join();
}
 catch (InterruptedException e) {
}
}
}
try {
((DockerConnection)conn).startContainer(id,null);
}
 catch (DockerException|InterruptedException e) {
Activator.log(e);
}
for (String readonly : readOnlyVolumes) {
remoteDataVolumes.remove(readonly);
}
return new ContainerCommandProcess(connection,imageName,containerId,remoteDataVolumes,keepContainer);
}",0.9590677778597242
91739,"public RepositoryResponse postTaskData(TaskData taskData,Set<TaskAttribute> oldAttributes,TaskRepository repository,IOperationMonitor monitor) throws OSIORestException {
  TaskAttribute spaceIdAttribute=taskData.getRoot().getAttribute(OSIORestTaskSchema.getDefault().SPACE_ID.getKey());
  String spaceId=spaceIdAttribute.getValue();
  Space space=null;
  if (taskData.isNew()) {
    Map<String,Space> spaces=getCachedSpaces(new NullOperationMonitor());
    for (    Space s : spaces.values()) {
      if (s.getId().equals(spaceId)) {
        space=s;
        break;
      }
    }
    String id=null;
    try {
      id=new OSIORestPostNewTask(client,taskData,space,connector,repository).run(monitor);
    }
 catch (    CoreException e1) {
      throw new OSIORestException(e1);
    }
    return new RepositoryResponse(ResponseKind.TASK_CREATED,id);
  }
 else {
    OSIORestConfiguration config;
    try {
      config=connector.getRepositoryConfiguration(repository);
    }
 catch (    CoreException e1) {
      throw new OSIORestException(e1);
    }
    TaskAttribute newComment=taskData.getRoot().getAttribute(OSIORestTaskSchema.getDefault().NEW_COMMENT.getKey());
    if (newComment != null) {
      String value=newComment.getValue();
      if (value != null && !value.isEmpty()) {
        new OSIORestPostNewCommentTask(client,taskData,oldAttributes).run(monitor);
        newComment.setValue(""String_Node_Str"");
      }
    }
    Map<String,Space> spaces=config.getSpaces();
    for (    Space s : spaces.values()) {
      if (s.getId().equals(spaceId)) {
        space=s;
        break;
      }
    }
    if (space == null) {
      Map<String,Space> externalSpaces=config.getExternalSpaces();
      for (      Space s : externalSpaces.values()) {
        if (s.getId().equals(spaceId)) {
          space=s;
          break;
        }
      }
    }
    TaskAttribute removeLinks=taskData.getRoot().getAttribute(OSIORestTaskSchema.getDefault().REMOVE_LINKS.getKey());
    if (removeLinks != null) {
      List<String> links=removeLinks.getValues();
      TaskAttributeMetaData metadata=removeLinks.getMetaData();
      TaskAttribute widAttr=taskData.getRoot().getAttribute(OSIORestTaskSchema.getDefault().UUID.getKey());
      String wid=widAttr.getValue();
      for (      String link : links) {
        try {
          String id=metadata.getValue(link);
          new OSIORestDeleteLink(client,wid,id).run(monitor);
        }
 catch (        Exception e) {
          StatusHandler.log(new Status(IStatus.ERROR,OSIORestCore.ID_PLUGIN,NLS.bind(""String_Node_Str"",link),e));
        }
      }
    }
    TaskAttribute addLink=taskData.getRoot().getAttribute(OSIORestTaskSchema.getDefault().ADD_LINK.getKey());
    TaskAttributeMetaData metadata=addLink.getMetaData();
    String linkid=metadata.getValue(""String_Node_Str"");
    String sourceid=taskData.getRoot().getAttribute(OSIORestTaskSchema.getDefault().UUID.getKey()).getValue();
    String targetid=metadata.getValue(""String_Node_Str"");
    String direction=metadata.getValue(""String_Node_Str"");
    boolean isForward=true;
    if (direction != null && !direction.isEmpty()) {
      isForward=direction.equals(""String_Node_Str"");
    }
    if (linkid != null && targetid != null) {
      new OSIORestPostNewLink(client,linkid,sourceid,targetid,isForward).run(monitor);
    }
    new OSIORestPatchUpdateTask(client,taskData,oldAttributes,space).run(monitor);
    return new RepositoryResponse(ResponseKind.TASK_UPDATED,taskData.getTaskId());
  }
}","public RepositoryResponse postTaskData(TaskData taskData,Set<TaskAttribute> oldAttributes,TaskRepository repository,IOperationMonitor monitor) throws OSIORestException {
  TaskAttribute spaceIdAttribute=taskData.getRoot().getAttribute(OSIORestTaskSchema.getDefault().SPACE_ID.getKey());
  String spaceId=spaceIdAttribute.getValue();
  Space space=null;
  if (taskData.isNew()) {
    Map<String,Space> spaces=getCachedSpaces(new NullOperationMonitor());
    for (    Space s : spaces.values()) {
      if (s.getId().equals(spaceId)) {
        space=s;
        break;
      }
    }
    String id=null;
    try {
      id=new OSIORestPostNewTask(client,taskData,space,connector,repository).run(monitor);
    }
 catch (    CoreException e1) {
      throw new OSIORestException(e1);
    }
    return new RepositoryResponse(ResponseKind.TASK_CREATED,id);
  }
 else {
    OSIORestConfiguration config;
    try {
      config=connector.getRepositoryConfiguration(repository);
      space=getSpaceById(spaceId,repository);
    }
 catch (    CoreException e1) {
      throw new OSIORestException(e1);
    }
    TaskAttribute newComment=taskData.getRoot().getAttribute(OSIORestTaskSchema.getDefault().NEW_COMMENT.getKey());
    if (newComment != null) {
      String value=newComment.getValue();
      if (value != null && !value.isEmpty()) {
        new OSIORestPostNewCommentTask(client,taskData,oldAttributes).run(monitor);
        newComment.setValue(""String_Node_Str"");
      }
    }
    TaskAttribute removeLinks=taskData.getRoot().getAttribute(OSIORestTaskSchema.getDefault().REMOVE_LINKS.getKey());
    if (removeLinks != null) {
      List<String> links=removeLinks.getValues();
      TaskAttributeMetaData metadata=removeLinks.getMetaData();
      TaskAttribute widAttr=taskData.getRoot().getAttribute(OSIORestTaskSchema.getDefault().UUID.getKey());
      String wid=widAttr.getValue();
      for (      String link : links) {
        try {
          String id=metadata.getValue(link);
          new OSIORestDeleteLink(client,wid,id).run(monitor);
        }
 catch (        Exception e) {
          StatusHandler.log(new Status(IStatus.ERROR,OSIORestCore.ID_PLUGIN,NLS.bind(""String_Node_Str"",link),e));
        }
      }
    }
    TaskAttribute addLink=taskData.getRoot().getAttribute(OSIORestTaskSchema.getDefault().ADD_LINK.getKey());
    TaskAttributeMetaData metadata=addLink.getMetaData();
    String linkid=metadata.getValue(""String_Node_Str"");
    String sourceid=taskData.getRoot().getAttribute(OSIORestTaskSchema.getDefault().UUID.getKey()).getValue();
    String targetid=metadata.getValue(""String_Node_Str"");
    String direction=metadata.getValue(""String_Node_Str"");
    boolean isForward=true;
    if (direction != null && !direction.isEmpty()) {
      isForward=direction.equals(""String_Node_Str"");
    }
    if (linkid != null && targetid != null) {
      new OSIORestPostNewLink(client,linkid,sourceid,targetid,isForward).run(monitor);
    }
    new OSIORestPatchUpdateTask(client,taskData,oldAttributes,space).run(monitor);
    return new RepositoryResponse(ResponseKind.TASK_UPDATED,taskData.getTaskId());
  }
}",0.9292929292929292
91740,"public Map<String,String> getSpaceLinkTypes(String spaceId,TaskRepository taskRepository){
  Space s=null;
  OSIORestConfiguration config;
  Map<String,String> linkMap=new LinkedHashMap<>();
  try {
    config=connector.getRepositoryConfiguration(taskRepository);
  }
 catch (  CoreException e1) {
    StatusHandler.log(new Status(IStatus.ERROR,OSIORestCore.ID_PLUGIN,NLS.bind(""String_Node_Str"",taskRepository.getRepositoryUrl()),e1));
    return linkMap;
  }
  try {
    Map<String,Space> spaces=getCachedSpaces(new NullOperationMonitor());
    if (spaces != null) {
      for (      Space space : spaces.values()) {
        if (space.getId().equals(spaceId)) {
          s=space;
          break;
        }
      }
      if (s == null && (spaces=config.getExternalSpaces()) != null) {
        for (        Space space : spaces.values()) {
          if (space.getId().equals(spaceId)) {
            s=space;
            break;
          }
        }
      }
      if (s != null) {
        Map<String,WorkItemLinkTypeData> linkTypes=s.getWorkItemLinkTypes();
        for (        WorkItemLinkTypeData linkType : linkTypes.values()) {
          linkMap.put(linkType.getAttributes().getForwardName(),linkType.getId());
          linkMap.put(linkType.getAttributes().getReverseName(),linkType.getId());
        }
      }
    }
  }
 catch (  OSIORestException e) {
    StatusHandler.log(new Status(IStatus.ERROR,OSIORestCore.ID_PLUGIN,NLS.bind(""String_Node_Str"",spaceId),e));
  }
  return linkMap;
}","public Map<String,String> getSpaceLinkTypes(String spaceId,TaskRepository taskRepository){
  Space s=null;
  Map<String,String> linkMap=new LinkedHashMap<>();
  try {
    s=getSpaceById(spaceId,taskRepository);
  }
 catch (  CoreException e1) {
    StatusHandler.log(new Status(IStatus.ERROR,OSIORestCore.ID_PLUGIN,NLS.bind(""String_Node_Str"",taskRepository.getRepositoryUrl()),e1));
    return linkMap;
  }
  if (s != null) {
    Map<String,WorkItemLinkTypeData> linkTypes=s.getWorkItemLinkTypes();
    for (    WorkItemLinkTypeData linkType : linkTypes.values()) {
      linkMap.put(linkType.getAttributes().getForwardName(),linkType.getId());
      linkMap.put(linkType.getAttributes().getReverseName(),linkType.getId());
    }
  }
  return linkMap;
}",0.6364040943480196
91741,"public void getTaskData(Set<String> taskIds,TaskRepository taskRepository,TaskDataCollector collector,IOperationMonitor monitor) throws OSIORestException {
  OSIORestConfiguration config;
  try {
    config=connector.getRepositoryConfiguration(taskRepository);
  }
 catch (  CoreException e1) {
    throw new OSIORestException(e1);
  }
  for (  String taskId : taskIds) {
    if (taskId.isEmpty()) {
      continue;
    }
    String user=userName;
    String[] tokens=taskId.split(""String_Node_Str"");
    String spaceName=tokens[0];
    String[] spaceTokens=spaceName.split(""String_Node_Str"");
    if (spaceTokens.length > 1) {
      spaceName=spaceTokens[1];
      user=spaceTokens[0];
    }
    String wiNumber=tokens[1];
    try {
      user=URLQueryEncoder.transform(user);
      String query=""String_Node_Str"" + user + ""String_Node_Str""+ spaceName+ ""String_Node_Str""+ wiNumber;
      String wid=""String_Node_Str"";
      try {
        wid=new OSIORestGetWID(client,query,taskRepository).run(monitor);
      }
 catch (      OSIORestResourceMovedPermanentlyException e) {
        Header h=e.getHeader();
        HeaderElement[] elements=h.getElements();
        for (        HeaderElement element : elements) {
          if (""String_Node_Str"".equals(element.getName())) {
            int index=element.getValue().indexOf(""String_Node_Str"");
            wid=element.getValue().substring(index + 9);
          }
        }
      }
      String workitemquery=""String_Node_Str"" + wid;
      TaskData taskData=new OSIORestGetSingleTaskData(client,connector,workitemquery,taskRepository).run(monitor);
      Map<String,Space> spaces=getCachedSpaces(monitor);
      Space space=spaces.get(spaceName);
      if (space == null) {
        Map<String,Space> externalSpaces=config.getExternalSpaces();
        space=externalSpaces.get(spaceName);
      }
      new OSIORestGetTaskComments(getClient(),space,taskData).run(monitor);
      new OSIORestGetTaskCreator(getClient(),taskData).run(monitor);
      new OSIORestGetTaskLabels(getClient(),space,taskData).run(monitor);
      new OSIORestGetTaskLinks(getClient(),this,space,taskData,config).run(monitor);
      setTaskAssignees(taskData);
      config.updateSpaceOptions(taskData);
      config.addValidOperations(taskData);
      collector.accept(taskData);
    }
 catch (    RuntimeException|CoreException e) {
      e.printStackTrace();
      Throwable cause=e.getCause();
      if (cause instanceof CoreException) {
        throw new OSIORestException(cause);
      }
    }
  }
}","public void getTaskData(Set<String> taskIds,TaskRepository taskRepository,TaskDataCollector collector,IOperationMonitor monitor) throws OSIORestException {
  OSIORestConfiguration config;
  try {
    config=connector.getRepositoryConfiguration(taskRepository);
  }
 catch (  CoreException e1) {
    throw new OSIORestException(e1);
  }
  for (  String taskId : taskIds) {
    if (taskId.isEmpty()) {
      continue;
    }
    String user=userName;
    String[] tokens=taskId.split(""String_Node_Str"");
    String spaceName=tokens[0];
    String[] spaceTokens=spaceName.split(""String_Node_Str"");
    if (spaceTokens.length > 1) {
      spaceName=spaceTokens[1];
      user=spaceTokens[0];
    }
    String wiNumber=tokens[1];
    try {
      user=URLQueryEncoder.transform(user);
      String query=""String_Node_Str"" + user + ""String_Node_Str""+ spaceName+ ""String_Node_Str""+ wiNumber;
      String wid=""String_Node_Str"";
      try {
        wid=new OSIORestGetWID(client,query,taskRepository).run(monitor);
      }
 catch (      OSIORestResourceMovedPermanentlyException e) {
        Header h=e.getHeader();
        HeaderElement[] elements=h.getElements();
        for (        HeaderElement element : elements) {
          if (""String_Node_Str"".equals(element.getName())) {
            int index=element.getValue().indexOf(""String_Node_Str"");
            wid=element.getValue().substring(index + 9);
          }
        }
      }
      String workitemquery=""String_Node_Str"" + wid;
      TaskData taskData=new OSIORestGetSingleTaskData(client,connector,workitemquery,taskRepository).run(monitor);
      Map<String,Space> spaces=config.getSpaces();
      Space space=null;
      String spaceId=taskData.getRoot().getAttribute(OSIORestTaskSchema.getDefault().SPACE_ID.getKey()).getValue();
      space=getSpaceById(spaceId,taskRepository);
      new OSIORestGetTaskComments(getClient(),space,taskData).run(monitor);
      new OSIORestGetTaskCreator(getClient(),taskData).run(monitor);
      new OSIORestGetTaskLabels(getClient(),space,taskData).run(monitor);
      new OSIORestGetTaskLinks(getClient(),this,space,taskData,config).run(monitor);
      setTaskAssignees(taskData);
      config.updateSpaceOptions(taskData);
      config.addValidOperations(taskData);
      collector.accept(taskData);
    }
 catch (    RuntimeException|CoreException e) {
      e.printStackTrace();
      Throwable cause=e.getCause();
      if (cause instanceof CoreException) {
        throw new OSIORestException(cause);
      }
    }
  }
}",0.6801426872770512
91742,"private void populateFromAttribute(){
  OSIORestClient client;
  String spaceId=getTaskAttribute().getOption(""String_Node_Str"");
  try {
    client=((OSIORestConnector)connector).getClient(repository);
    linkTypes=client.getSpaceLinkTypes(spaceId,repository);
    workitems=client.getSpaceWorkItems(spaceId);
  }
 catch (  CoreException e) {
  }
  typeCombo.setItems(linkTypes.keySet().toArray(new String[0]));
  typeCombo.add(""String_Node_Str"",0);
  String link=getTaskAttribute().getValue();
  int index=0;
  if (link != null && !link.isEmpty()) {
    int i=1;
    for (    String linkType : linkTypes.keySet()) {
      if (link.startsWith(linkType)) {
        index=i;
      }
      ++i;
    }
  }
  if (index >= 0) {
    typeCombo.select(index);
  }
  workitemCombo.setItems(workitems.keySet().toArray(new String[0]));
  index=-1;
  if (link != null && !link.isEmpty()) {
    int i=0;
    for (    String workitem : workitems.keySet()) {
      if (link.endsWith(workitem)) {
        index=i;
      }
      ++i;
    }
  }
  if (index >= 0) {
    workitemCombo.select(index);
  }
}","private void populateFromAttribute(){
  OSIORestClient client;
  String spaceId=getTaskAttribute().getOption(""String_Node_Str"");
  try {
    client=((OSIORestConnector)connector).getClient(repository);
    linkTypes=client.getSpaceLinkTypes(spaceId,repository);
    workitems=client.getSpaceWorkItems(spaceId);
  }
 catch (  CoreException e) {
  }
  typeCombo.setItems(linkTypes.keySet().toArray(new String[0]));
  typeCombo.add(""String_Node_Str"",0);
  String link=getTaskAttribute().getValue();
  int index=0;
  if (link != null && !link.isEmpty()) {
    int i=1;
    for (    String linkType : linkTypes.keySet()) {
      if (link.startsWith(linkType)) {
        index=i;
      }
      ++i;
    }
  }
  if (index >= 0) {
    typeCombo.select(index);
  }
  ArrayList<String> workitemsList=new ArrayList<>();
  String sourceName=getModel().getTaskData().getRoot().getMappedAttribute(OSIORestTaskSchema.getDefault().SUMMARY.getKey()).getValue();
  for (  String workitemName : workitems.keySet()) {
    if (!workitemName.equals(sourceName)) {
      workitemsList.add(workitemName);
    }
  }
  workitemCombo.setItems(workitemsList.toArray(new String[0]));
  index=-1;
  if (link != null && !link.isEmpty()) {
    int i=0;
    for (    String workitem : workitems.keySet()) {
      if (link.endsWith(workitem)) {
        index=i;
      }
      ++i;
    }
  }
  if (index >= 0) {
    workitemCombo.select(index);
  }
}",0.8608
91743,"public OSIORestConfiguration getConfiguration(TaskRepository repository,IOperationMonitor monitor){
  try {
    OSIORestConfiguration config=new OSIORestConfiguration(repository.getUrl());
    Map<String,Space> spaces=getSpaces(monitor);
    for (    Space space : spaces.values()) {
      Map<String,WorkItemTypeData> workItemTypes=getSpaceWorkItemTypes(new NullOperationMonitor(),space);
      space.setWorkItemTypes(workItemTypes);
      Map<String,WorkItemLinkTypeData> workItemLinkTypes=getSpaceWorkItemLinkTypes(new NullOperationMonitor(),space);
      space.setWorkItemLinkTypes(workItemLinkTypes);
      Map<String,Area> areas=getSpaceAreas(new NullOperationMonitor(),space);
      space.setAreas(areas);
      Map<String,Iteration> iterations=getSpaceIterations(new NullOperationMonitor(),space);
      space.setIterations(iterations);
      Map<String,Label> labels=getSpaceLabels(new NullOperationMonitor(),space);
      space.setLabels(labels);
      Map<String,User> users=getUsers(new NullOperationMonitor(),space);
      space.setUsers(users);
    }
    config.setSpaces(spaces);
    return config;
  }
 catch (  Exception e) {
    StatusHandler.log(new Status(IStatus.ERROR,OSIORestCore.ID_PLUGIN,""String_Node_Str"",e));
    return null;
  }
}","public OSIORestConfiguration getConfiguration(TaskRepository repository,IOperationMonitor monitor){
  try {
    OSIORestConfiguration config=new OSIORestConfiguration(repository.getUrl(),userName);
    Map<String,Space> spaces=getSpaces(monitor);
    for (    Space space : spaces.values()) {
      Map<String,WorkItemTypeData> workItemTypes=getSpaceWorkItemTypes(new NullOperationMonitor(),space);
      space.setWorkItemTypes(workItemTypes);
      Map<String,WorkItemLinkTypeData> workItemLinkTypes=getSpaceWorkItemLinkTypes(new NullOperationMonitor(),space);
      space.setWorkItemLinkTypes(workItemLinkTypes);
      Map<String,Area> areas=getSpaceAreas(new NullOperationMonitor(),space);
      space.setAreas(areas);
      Map<String,Iteration> iterations=getSpaceIterations(new NullOperationMonitor(),space);
      space.setIterations(iterations);
      Map<String,Label> labels=getSpaceLabels(new NullOperationMonitor(),space);
      space.setLabels(labels);
      Map<String,User> users=getUsers(new NullOperationMonitor(),space);
      space.setUsers(users);
    }
    config.setSpaces(spaces);
    return config;
  }
 catch (  Exception e) {
    StatusHandler.log(new Status(IStatus.ERROR,OSIORestCore.ID_PLUGIN,""String_Node_Str"",e));
    return null;
  }
}",0.9964356435643564
91744,"public void updateInitialTaskData(TaskData data) throws CoreException {
  setSpaceOptions(data,getSpaces());
  updateSpaceOptions(data);
  for (  String key : data.getRoot().getAttributes().keySet()) {
    if (key.equals(OSIORestTaskSchema.getDefault().NEW_COMMENT.getKey()) || key.equals(TaskAttribute.OPERATION) || key.equals(OSIORestTaskSchema.getDefault().DATE_MODIFICATION.getKey())) {
      continue;
    }
    TaskAttribute attribute=data.getRoot().getAttribute(key);
    if (key.equals(OSIORestTaskSchema.getDefault().STATUS.getKey())) {
      if (attribute.getOptions().isEmpty()) {
        for (        String status : statusValues) {
          attribute.putOption(status,status);
        }
      }
    }
    if (!key.equals(SCHEMA.SPACE.getKey())) {
      String configName=mapTaskAttributeKey2ConfigurationFields(key);
      if (configName.equals(""String_Node_Str"")) {
        if (attribute.getOptions().size() == 1 && attribute.getValue().isEmpty()) {
          attribute.setValue((String)attribute.getOptions().values().toArray()[0]);
        }
      }
    }
  }
}","public void updateInitialTaskData(TaskData data) throws CoreException {
  setSpaceOptions(data,getSpaces());
  updateSpaceOptions(data);
  for (  String key : data.getRoot().getAttributes().keySet()) {
    if (key.equals(OSIORestTaskSchema.getDefault().NEW_COMMENT.getKey()) || key.equals(TaskAttribute.OPERATION) || key.equals(OSIORestTaskSchema.getDefault().DATE_MODIFICATION.getKey())) {
      continue;
    }
    TaskAttribute attribute=data.getRoot().getAttribute(key);
    if (key.equals(OSIORestTaskSchema.getDefault().STATUS.getKey())) {
      if (attribute.getOptions().isEmpty()) {
        for (        String status : statusValues) {
          attribute.putOption(status,status);
        }
      }
    }
    if (key.equals(OSIORestTaskSchema.getDefault().ASSIGNEES.getKey())) {
      if (attribute.getOptions().isEmpty()) {
        attribute.putOption(userName,userName);
      }
      continue;
    }
    if (!key.equals(SCHEMA.SPACE.getKey())) {
      String configName=mapTaskAttributeKey2ConfigurationFields(key);
      if (configName.equals(""String_Node_Str"")) {
        if (attribute.getOptions().size() == 1 && attribute.getValue().isEmpty()) {
          attribute.setValue((String)attribute.getOptions().values().toArray()[0]);
        }
      }
    }
  }
}",0.9158878504672896
91745,"public OSIORestConfiguration(String repositoryId){
  this.repositoryId=repositoryId;
  statusTransitions.put(""String_Node_Str"",statusValues);
  statusTransitions.put(NEW,newStatusTransitions);
  statusTransitions.put(OPEN,openStatusTransitions);
  statusTransitions.put(IN_PROGRESS,inProgressStatusTransitions);
  statusTransitions.put(RESOLVED,resolvedStatusTransitions);
  statusTransitions.put(CLOSED,closedStatusTransitions);
}","public OSIORestConfiguration(String repositoryId,String userName){
  this.repositoryId=repositoryId;
  this.userName=userName;
  statusTransitions.put(""String_Node_Str"",statusValues);
  statusTransitions.put(NEW,newStatusTransitions);
  statusTransitions.put(OPEN,openStatusTransitions);
  statusTransitions.put(IN_PROGRESS,inProgressStatusTransitions);
  statusTransitions.put(RESOLVED,resolvedStatusTransitions);
  statusTransitions.put(CLOSED,closedStatusTransitions);
}",0.9535398230088497
91746,"public boolean updateSpaceOptions(@NonNull TaskData taskData){
  if (taskData == null) {
    return false;
  }
  TaskAttribute attributeSpaceId=taskData.getRoot().getMappedAttribute(SCHEMA.SPACE_ID.getKey());
  TaskAttribute attributeSpace=taskData.getRoot().getMappedAttribute(SCHEMA.SPACE.getKey());
  if (attributeSpaceId == null) {
    return false;
  }
  if (!attributeSpaceId.getValue().isEmpty()) {
    Space actualSpace=getSpaceById(attributeSpaceId.getValue());
    if (actualSpace == null) {
      return false;
    }
    TaskAttribute attributeWorkItemType=taskData.getRoot().getMappedAttribute(SCHEMA.WORKITEM_TYPE.getKey());
    if (attributeWorkItemType != null) {
      setAttributeOptionsForSpace(attributeWorkItemType,actualSpace);
    }
    TaskAttribute attributeArea=taskData.getRoot().getMappedAttribute(SCHEMA.AREA.getKey());
    if (attributeArea != null) {
      setAttributeOptionsForSpace(attributeArea,actualSpace);
    }
    TaskAttribute attributeIteration=taskData.getRoot().getMappedAttribute(SCHEMA.ITERATION.getKey());
    if (attributeIteration != null) {
      setAttributeOptionsForSpace(attributeIteration,actualSpace);
    }
    TaskAttribute attributeAddAssignee=taskData.getRoot().getMappedAttribute(SCHEMA.ADD_ASSIGNEE.getKey());
    if (attributeAddAssignee != null) {
      setAttributeOptionsForSpace(attributeAddAssignee,actualSpace);
    }
    TaskAttribute attributeAddLabel=taskData.getRoot().getMappedAttribute(SCHEMA.ADD_LABEL.getKey());
    if (attributeAddLabel != null) {
      setAttributeOptionsForSpace(attributeAddLabel,actualSpace);
    }
    TaskAttribute attributeState=taskData.getRoot().getMappedAttribute(SCHEMA.STATUS.getKey());
    if (attributeState != null) {
      setAttributeOptionsForSpace(attributeState,actualSpace);
    }
  }
 else {
    SortedSet<String> workItemTypes=new TreeSet<>();
    SortedSet<String> areas=new TreeSet<>();
    SortedSet<String> iterations=new TreeSet<>();
    SortedSet<String> users=new TreeSet<>();
    Set<String> states=new LinkedHashSet<>();
    for (    Space space : getSpaces().values()) {
      attributeSpace.putOption(space.getName(),space.getName());
      if (space.getWorkItemTypes() != null) {
        if (!space.getWorkItemTypes().isEmpty()) {
          WorkItemTypeData data=space.getWorkItemTypes().values().iterator().next();
          WorkItemTypeAttributes attributes=data.getWorkItemTypeAttributes();
          Map<String,WorkItemTypeField> fields=attributes.getFields();
          WorkItemTypeField state=fields.get(""String_Node_Str"");
          WorkItemTypeFieldType stateType=state.getType();
          String[] values=stateType.getValues();
          if (values != null) {
            for (            String value : values) {
              states.add(value);
            }
          }
        }
        for (        Entry<String,WorkItemTypeData> entry : space.getWorkItemTypes().entrySet()) {
          workItemTypes.add(entry.getKey());
          WorkItemTypeData data=entry.getValue();
        }
      }
      if (space.getAreas() != null) {
        for (        String entry : space.getAreas().keySet()) {
          areas.add(entry);
        }
      }
      if (space.getIterations() != null) {
        for (        String entry : space.getIterations().keySet()) {
          iterations.add(entry);
        }
      }
      if (space.getUsers() != null) {
        for (        String entry : space.getUsers().keySet()) {
          users.add(entry);
        }
      }
    }
    TaskAttribute attributeWorkItemType=taskData.getRoot().getMappedAttribute(SCHEMA.WORKITEM_TYPE.getKey());
    if (attributeWorkItemType != null) {
      setAllAttributeOptions(attributeWorkItemType,workItemTypes);
    }
    TaskAttribute attributeState=taskData.getRoot().getMappedAttribute(SCHEMA.STATUS.getKey());
    if (attributeState != null) {
      setAllAttributeOptions(attributeState,states);
    }
  }
  return true;
}","public boolean updateSpaceOptions(@NonNull TaskData taskData){
  if (taskData == null) {
    return false;
  }
  TaskAttribute attributeSpaceId=taskData.getRoot().getMappedAttribute(SCHEMA.SPACE_ID.getKey());
  TaskAttribute attributeSpace=taskData.getRoot().getMappedAttribute(SCHEMA.SPACE.getKey());
  if (attributeSpaceId != null && !attributeSpaceId.getValue().isEmpty()) {
    Space actualSpace=getSpaceById(attributeSpaceId.getValue());
    if (actualSpace == null) {
      return false;
    }
    TaskAttribute attributeWorkItemType=taskData.getRoot().getMappedAttribute(SCHEMA.WORKITEM_TYPE.getKey());
    if (attributeWorkItemType != null) {
      setAttributeOptionsForSpace(attributeWorkItemType,actualSpace);
    }
    TaskAttribute attributeArea=taskData.getRoot().getMappedAttribute(SCHEMA.AREA.getKey());
    if (attributeArea != null) {
      setAttributeOptionsForSpace(attributeArea,actualSpace);
    }
    TaskAttribute attributeIteration=taskData.getRoot().getMappedAttribute(SCHEMA.ITERATION.getKey());
    if (attributeIteration != null) {
      setAttributeOptionsForSpace(attributeIteration,actualSpace);
    }
    TaskAttribute attributeAddAssignee=taskData.getRoot().getMappedAttribute(SCHEMA.ADD_ASSIGNEE.getKey());
    if (attributeAddAssignee != null) {
      setAttributeOptionsForSpace(attributeAddAssignee,actualSpace);
    }
    TaskAttribute attributeAddLabel=taskData.getRoot().getMappedAttribute(SCHEMA.ADD_LABEL.getKey());
    if (attributeAddLabel != null) {
      setAttributeOptionsForSpace(attributeAddLabel,actualSpace);
    }
    TaskAttribute attributeState=taskData.getRoot().getMappedAttribute(SCHEMA.STATUS.getKey());
    if (attributeState != null) {
      setAttributeOptionsForSpace(attributeState,actualSpace);
    }
  }
 else {
    SortedSet<String> workItemTypes=new TreeSet<>();
    SortedSet<String> areas=new TreeSet<>();
    SortedSet<String> iterations=new TreeSet<>();
    SortedSet<String> users=new TreeSet<>();
    Set<String> states=new LinkedHashSet<>();
    for (    Space space : getSpaces().values()) {
      if (attributeSpace != null) {
        attributeSpace.putOption(space.getName(),space.getName());
      }
      if (space.getWorkItemTypes() != null) {
        if (!space.getWorkItemTypes().isEmpty()) {
          WorkItemTypeData data=space.getWorkItemTypes().values().iterator().next();
          WorkItemTypeAttributes attributes=data.getWorkItemTypeAttributes();
          Map<String,WorkItemTypeField> fields=attributes.getFields();
          WorkItemTypeField state=fields.get(""String_Node_Str"");
          WorkItemTypeFieldType stateType=state.getType();
          String[] values=stateType.getValues();
          if (values != null) {
            for (            String value : values) {
              states.add(value);
            }
          }
        }
        for (        Entry<String,WorkItemTypeData> entry : space.getWorkItemTypes().entrySet()) {
          workItemTypes.add(entry.getKey());
          WorkItemTypeData data=entry.getValue();
        }
      }
      if (space.getAreas() != null) {
        for (        String entry : space.getAreas().keySet()) {
          areas.add(entry);
        }
      }
      if (space.getIterations() != null) {
        for (        String entry : space.getIterations().keySet()) {
          iterations.add(entry);
        }
      }
      if (space.getUsers() != null) {
        for (        String entry : space.getUsers().keySet()) {
          users.add(entry);
        }
      }
    }
    TaskAttribute attributeWorkItemType=taskData.getRoot().getMappedAttribute(SCHEMA.WORKITEM_TYPE.getKey());
    if (attributeWorkItemType != null) {
      setAllAttributeOptions(attributeWorkItemType,workItemTypes);
    }
    TaskAttribute attributeState=taskData.getRoot().getMappedAttribute(SCHEMA.STATUS.getKey());
    if (attributeState != null) {
      setAllAttributeOptions(attributeState,states);
    }
    TaskAttribute attributeAssignees=taskData.getRoot().getMappedAttribute(SCHEMA.ASSIGNEES.getKey());
    if (attributeAssignees != null && attributeAssignees.getOptions().size() == 0) {
      attributeAssignees.putOption(userName,userName);
    }
  }
  return true;
}",0.9576010814796608
91747,"@Override public void write(JsonWriter out,OldAttributes oldValues) throws IOException {
  out.beginObject();
  out.name(""String_Node_Str"");
  out.beginObject();
  out.name(""String_Node_Str"");
  out.beginObject();
  TaskAttribute attribute=taskData.getRoot().getAttribute(taskSchema.DESCRIPTION.getKey());
  String attValue=attribute.getValue() == null ? ""String_Node_Str"" : attribute.getValue();
  out.name(""String_Node_Str"").value(attValue);
  if (taskData.getRoot().getAttribute(TaskAttribute.OPERATION) != null) {
    attribute=taskData.getRoot().getAttribute(TaskAttribute.OPERATION);
  }
 else {
    attribute=taskData.getRoot().getAttribute(taskSchema.STATUS.getKey());
  }
  attValue=attribute.getValue();
  out.name(""String_Node_Str"").value(attValue);
  attribute=taskData.getRoot().getAttribute(taskSchema.SUMMARY.getKey());
  attValue=attribute.getValue();
  out.name(""String_Node_Str"").value(attValue);
  attribute=taskData.getRoot().getAttribute(taskSchema.VERSION.getKey());
  attValue=attribute.getValue();
  out.name(""String_Node_Str"").value(attValue);
  out.endObject();
  attribute=taskData.getRoot().getAttribute(taskSchema.UUID.getKey());
  attValue=attribute.getValue();
  out.name(""String_Node_Str"").value(attValue);
  out.name(""String_Node_Str"");
  out.beginObject();
  out.name(""String_Node_Str"");
  out.beginObject();
  out.name(""String_Node_Str"");
  out.beginObject();
  attribute=taskData.getRoot().getAttribute(taskSchema.SPACE.getKey());
  String spaceName=attribute.getValue();
  out.name(""String_Node_Str"").value(space.getId());
  out.name(""String_Node_Str"").value(""String_Node_Str"");
  out.endObject();
  out.endObject();
  attribute=taskData.getRoot().getAttribute(taskSchema.AREA.getKey());
  String areaName=attribute.getValue();
  if (areaName != null && !areaName.trim().isEmpty()) {
    out.name(""String_Node_Str"");
    out.beginObject();
    out.name(""String_Node_Str"");
    out.beginObject();
    Area area=space.getAreas().get(areaName);
    out.name(""String_Node_Str"").value(area.getId());
    out.name(""String_Node_Str"").value(""String_Node_Str"");
    out.endObject();
    out.endObject();
  }
  attribute=taskData.getRoot().getAttribute(taskSchema.ITERATION.getKey());
  String iterationName=attribute.getValue();
  if (iterationName != null && !iterationName.trim().isEmpty()) {
    out.name(""String_Node_Str"");
    out.beginObject();
    out.name(""String_Node_Str"");
    out.beginObject();
    Iteration iteration=space.getIterations().get(iterationName);
    out.name(""String_Node_Str"").value(iteration.getId());
    out.name(""String_Node_Str"").value(""String_Node_Str"");
    out.endObject();
    out.endObject();
  }
  out.name(""String_Node_Str"");
  out.beginObject();
  attribute=taskData.getRoot().getAttribute(taskSchema.ASSIGNEES.getKey());
  List<String> assignees=attribute.getValues();
  if (assignees == null) {
    assignees=new ArrayList<String>();
  }
 else {
    assignees=new ArrayList<>(assignees);
  }
  attribute=taskData.getRoot().getAttribute(taskSchema.REMOVE_ASSIGNEE.getKey());
  List<String> removals=attribute.getValues();
  if (removals != null) {
    for (    String removal : removals) {
      int index=assignees.indexOf(removal);
      if (index >= 0) {
        assignees.remove(index);
      }
    }
  }
  attribute=taskData.getRoot().getAttribute(taskSchema.ADD_ASSIGNEE.getKey());
  List<String> additions=attribute.getValues();
  if (additions != null) {
    for (    String addition : additions) {
      int index=assignees.indexOf(addition);
      if (index < 0) {
        assignees.add(addition);
      }
    }
  }
  if (assignees.size() > 0 && !assignees.get(0).isEmpty()) {
    Map<String,User> users=space.getUsers();
    out.name(""String_Node_Str"");
    out.beginArray();
    for (    String assignee : assignees) {
      if (assignee != null && !assignee.isEmpty()) {
        User user=users.get(assignee);
        if (user == null) {
          throw new UnsupportedOperationException(OSIORestMessages.getFormattedString(""String_Node_Str"",assignee));
        }
        String userid=user.getId();
        out.beginObject();
        out.name(""String_Node_Str"").value(userid);
        out.name(""String_Node_Str"").value(""String_Node_Str"");
        out.endObject();
      }
    }
    out.endArray();
  }
  out.endObject();
  attribute=taskData.getRoot().getAttribute(taskSchema.LABELS.getKey());
  List<String> labels=attribute.getValues();
  if (labels == null) {
    labels=new ArrayList<String>();
  }
 else {
    labels=new ArrayList<>(labels);
  }
  attribute=taskData.getRoot().getAttribute(taskSchema.REMOVE_LABEL.getKey());
  List<String> labelRemovals=attribute.getValues();
  if (labelRemovals != null) {
    for (    String removal : labelRemovals) {
      int index=labels.indexOf(removal);
      if (index >= 0) {
        labels.remove(index);
      }
    }
  }
  attribute=taskData.getRoot().getAttribute(taskSchema.ADD_LABEL.getKey());
  String labelAddString=attribute.getValue();
  String[] labelAdditions=labelAddString.split(""String_Node_Str"");
  if (labelAdditions != null) {
    for (    String addition : labelAdditions) {
      int index=labels.indexOf(addition);
      if (index < 0) {
        labels.add(addition);
      }
    }
  }
  out.name(""String_Node_Str"");
  out.beginObject();
  out.name(""String_Node_Str"");
  out.beginArray();
  if (labels.size() > 0 && !labels.get(0).isEmpty()) {
    Map<String,Label> spaceLabels=space.getLabels();
    for (    String label : labels) {
      Label l=spaceLabels.get(label);
      if (l == null && !label.trim().isEmpty()) {
        try {
          LabelResponse response=new OSIORestPostNewLabelTask(client,space,label).run(new NullOperationMonitor());
          Label newLabel=response.getData();
          spaceLabels.put(label,newLabel);
        }
 catch (        OSIORestException e) {
          e.printStackTrace();
        }
      }
      l=spaceLabels.get(label);
      if (l != null) {
        String labelid=l.getId();
        out.beginObject();
        out.name(""String_Node_Str"").value(labelid);
        out.name(""String_Node_Str"").value(""String_Node_Str"");
        out.endObject();
      }
    }
  }
  out.endArray();
  out.endObject();
  out.endObject();
  out.name(""String_Node_Str"").value(""String_Node_Str"");
  out.endObject();
  out.name(""String_Node_Str"");
  out.beginArray();
  out.value(true);
  out.endArray();
  out.endObject();
}","@Override public void write(JsonWriter out,OldAttributes oldValues) throws IOException {
  out.beginObject();
  out.name(""String_Node_Str"");
  out.beginObject();
  out.name(""String_Node_Str"");
  out.beginObject();
  TaskAttribute attribute=taskData.getRoot().getAttribute(taskSchema.DESCRIPTION.getKey());
  String attValue=attribute.getValue() == null ? ""String_Node_Str"" : attribute.getValue();
  out.name(""String_Node_Str"").value(attValue);
  if (taskData.getRoot().getAttribute(TaskAttribute.OPERATION) != null) {
    attribute=taskData.getRoot().getAttribute(TaskAttribute.OPERATION);
  }
 else {
    attribute=taskData.getRoot().getAttribute(taskSchema.STATUS.getKey());
  }
  attValue=attribute.getValue();
  out.name(""String_Node_Str"").value(attValue);
  attribute=taskData.getRoot().getAttribute(taskSchema.SUMMARY.getKey());
  attValue=attribute.getValue();
  out.name(""String_Node_Str"").value(attValue);
  attribute=taskData.getRoot().getAttribute(taskSchema.VERSION.getKey());
  attValue=attribute.getValue();
  out.name(""String_Node_Str"").value(attValue);
  out.endObject();
  attribute=taskData.getRoot().getAttribute(taskSchema.UUID.getKey());
  attValue=attribute.getValue();
  out.name(""String_Node_Str"").value(attValue);
  out.name(""String_Node_Str"");
  out.beginObject();
  out.name(""String_Node_Str"");
  out.beginObject();
  out.name(""String_Node_Str"");
  out.beginObject();
  attribute=taskData.getRoot().getAttribute(taskSchema.SPACE.getKey());
  String spaceName=attribute.getValue();
  out.name(""String_Node_Str"").value(space.getId());
  out.name(""String_Node_Str"").value(""String_Node_Str"");
  out.endObject();
  out.endObject();
  attribute=taskData.getRoot().getAttribute(taskSchema.AREA.getKey());
  String areaName=attribute.getValue();
  if (areaName != null && !areaName.trim().isEmpty()) {
    out.name(""String_Node_Str"");
    out.beginObject();
    out.name(""String_Node_Str"");
    out.beginObject();
    Area area=space.getAreas().get(areaName);
    out.name(""String_Node_Str"").value(area.getId());
    out.name(""String_Node_Str"").value(""String_Node_Str"");
    out.endObject();
    out.endObject();
  }
  attribute=taskData.getRoot().getAttribute(taskSchema.ITERATION.getKey());
  String iterationName=attribute.getValue();
  if (iterationName != null && !iterationName.trim().isEmpty()) {
    out.name(""String_Node_Str"");
    out.beginObject();
    out.name(""String_Node_Str"");
    out.beginObject();
    Iteration iteration=space.getIterations().get(iterationName);
    out.name(""String_Node_Str"").value(iteration.getId());
    out.name(""String_Node_Str"").value(""String_Node_Str"");
    out.endObject();
    out.endObject();
  }
  out.name(""String_Node_Str"");
  out.beginObject();
  attribute=taskData.getRoot().getAttribute(taskSchema.ASSIGNEES.getKey());
  List<String> assignees=attribute.getValues();
  if (assignees == null) {
    assignees=new ArrayList<String>();
  }
 else {
    assignees=new ArrayList<>(assignees);
  }
  attribute=taskData.getRoot().getAttribute(taskSchema.REMOVE_ASSIGNEE.getKey());
  List<String> removals=attribute.getValues();
  if (removals != null) {
    for (    String removal : removals) {
      int index=assignees.indexOf(removal);
      if (index >= 0) {
        assignees.remove(index);
      }
    }
  }
  attribute=taskData.getRoot().getAttribute(taskSchema.ADD_ASSIGNEE.getKey());
  List<String> additions=attribute.getValues();
  if (additions != null) {
    for (    String addition : additions) {
      int index=assignees.indexOf(addition);
      if (index < 0) {
        assignees.add(addition);
      }
    }
  }
  if (assignees.size() > 0 && !assignees.get(0).isEmpty()) {
    Map<String,User> users=space.getUsers();
    out.name(""String_Node_Str"");
    out.beginArray();
    for (    String assignee : assignees) {
      if (assignee != null && !assignee.isEmpty()) {
        User user=users.get(assignee);
        if (user == null) {
          throw new UnsupportedOperationException(OSIORestMessages.getFormattedString(""String_Node_Str"",assignee));
        }
        String userid=user.getId();
        out.beginObject();
        out.name(""String_Node_Str"").value(userid);
        out.name(""String_Node_Str"").value(""String_Node_Str"");
        out.endObject();
      }
    }
    out.endArray();
  }
  out.endObject();
  attribute=taskData.getRoot().getAttribute(taskSchema.LABELS.getKey());
  List<String> labels=attribute.getValues();
  if (labels == null) {
    labels=new ArrayList<String>();
  }
 else {
    labels=new ArrayList<>(labels);
  }
  attribute=taskData.getRoot().getAttribute(taskSchema.REMOVE_LABEL.getKey());
  List<String> labelRemovals=attribute.getValues();
  if (labelRemovals != null) {
    for (    String removal : labelRemovals) {
      int index=labels.indexOf(removal);
      if (index >= 0) {
        labels.remove(index);
      }
    }
  }
  attribute=taskData.getRoot().getAttribute(taskSchema.ADD_LABEL.getKey());
  List<String> labelAdditions=attribute.getValues();
  if (labelAdditions != null) {
    for (    String addition : labelAdditions) {
      int index=labels.indexOf(addition);
      if (index < 0) {
        labels.add(addition);
      }
    }
  }
  out.name(""String_Node_Str"");
  out.beginObject();
  out.name(""String_Node_Str"");
  out.beginArray();
  if (labels.size() > 0 && !labels.get(0).isEmpty()) {
    Map<String,Label> spaceLabels=space.getLabels();
    for (    String label : labels) {
      Label l=spaceLabels.get(label);
      if (l == null && !label.trim().isEmpty()) {
        try {
          LabelResponse response=new OSIORestPostNewLabelTask(client,space,label).run(new NullOperationMonitor());
          Label newLabel=response.getData();
          spaceLabels.put(label,newLabel);
        }
 catch (        OSIORestException e) {
          e.printStackTrace();
        }
      }
      l=spaceLabels.get(label);
      if (l != null) {
        String labelid=l.getId();
        out.beginObject();
        out.name(""String_Node_Str"").value(labelid);
        out.name(""String_Node_Str"").value(""String_Node_Str"");
        out.endObject();
      }
    }
  }
  out.endArray();
  out.endObject();
  out.endObject();
  out.name(""String_Node_Str"").value(""String_Node_Str"");
  out.endObject();
  out.name(""String_Node_Str"");
  out.beginArray();
  out.value(true);
  out.endArray();
  out.endObject();
}",0.9921556322560402
91748,"@Override public Map<String,String> getOptions(@NonNull TaskAttribute attribute){
  OSIORestTaskSchema taskSchema=OSIORestTaskSchema.getDefault();
  if (attribute.getId().equals(taskSchema.WORKITEM_TYPE.getKey()) || attribute.getId().equals(taskSchema.AREA.getKey()) || attribute.getId().equals(taskSchema.ASSIGNEES.getKey())|| attribute.getId().equals(taskSchema.ITERATION.getKey())) {
    TaskAttribute spaceAttribute=attribute.getParentAttribute().getAttribute(OSIORestCreateTaskSchema.getDefault().SPACE.getKey());
    OSIORestConfiguration repositoryConfiguration;
    try {
      repositoryConfiguration=connector.getRepositoryConfiguration(this.getTaskRepository());
      if (repositoryConfiguration != null) {
        if (!spaceAttribute.getValue().equals(""String_Node_Str"")) {
          boolean found=false;
          attribute.clearOptions();
          for (          String spaceName : spaceAttribute.getValues()) {
            Space actualSpace=repositoryConfiguration.getSpaceWithName(spaceName);
            String key=attribute.getId();
            internalSetAttributeOptions4Space(attribute,actualSpace.getMapFor(attribute.getId()));
          }
        }
      }
    }
 catch (    CoreException e) {
      StatusHandler.log(new RepositoryStatus(getTaskRepository(),IStatus.ERROR,OSIORestCore.ID_PLUGIN,0,""String_Node_Str"",e));
    }
  }
  return super.getOptions(attribute);
}","@Override public Map<String,String> getOptions(@NonNull TaskAttribute attribute){
  OSIORestTaskSchema taskSchema=OSIORestTaskSchema.getDefault();
  if (attribute.getId().equals(taskSchema.WORKITEM_TYPE.getKey()) || attribute.getId().equals(taskSchema.AREA.getKey()) || attribute.getId().equals(taskSchema.ASSIGNEES.getKey())|| attribute.getId().equals(taskSchema.STATUS.getKey())|| attribute.getId().equals(taskSchema.ITERATION.getKey())) {
    TaskAttribute spaceIdAttribute=attribute.getParentAttribute().getAttribute(OSIORestTaskSchema.getDefault().SPACE_ID.getKey());
    TaskAttribute spaceAttribute=attribute.getParentAttribute().getAttribute(OSIORestCreateTaskSchema.getDefault().SPACE.getKey());
    OSIORestConfiguration repositoryConfiguration;
    try {
      repositoryConfiguration=connector.getRepositoryConfiguration(this.getTaskRepository());
      if (repositoryConfiguration != null) {
        if (spaceIdAttribute != null && !spaceIdAttribute.getValue().equals(""String_Node_Str"")) {
          boolean found=false;
          attribute.clearOptions();
          for (          String spaceId : spaceIdAttribute.getValues()) {
            Space actualSpace=connector.getClient(getTaskRepository()).getSpaceById(spaceId,getTaskRepository());
            String key=attribute.getId();
            internalSetAttributeOptions4Space(attribute,actualSpace.getMapFor(attribute.getId()));
          }
        }
 else {
          attribute.clearOptions();
          for (          String spaceName : spaceAttribute.getValues()) {
            Space actualSpace=repositoryConfiguration.getSpaceWithName(spaceName);
            String key=attribute.getId();
            internalSetAttributeOptions4Space(attribute,actualSpace.getMapFor(attribute.getId()));
          }
          if (attribute.getOptions().size() == 0) {
            if (attribute.getId().equals(taskSchema.ASSIGNEES.getKey())) {
              String userName=repositoryConfiguration.getUserName();
              attribute.putOption(userName,userName);
            }
          }
        }
      }
    }
 catch (    CoreException e) {
      StatusHandler.log(new RepositoryStatus(getTaskRepository(),IStatus.ERROR,OSIORestCore.ID_PLUGIN,0,""String_Node_Str"",e));
    }
  }
  return super.getOptions(attribute);
}",0.7527875985858037
91749,"public Map<String,IdNamed> getMapFor(String member){
  if (""String_Node_Str"".equals(member)) {
    return areasIdNamed;
  }
 else   if (""String_Node_Str"".equals(member)) {
    return workItemTypesIdNamed;
  }
 else   if (""String_Node_Str"".equals(member)) {
    return iterationsIdNamed;
  }
 else   if (""String_Node_Str"".equals(member)) {
    return usersIdNamed;
  }
  return null;
}","public Map<String,IdNamed> getMapFor(String member){
  if (""String_Node_Str"".equals(member)) {
    return areasIdNamed;
  }
 else   if (""String_Node_Str"".equals(member)) {
    return workItemTypesIdNamed;
  }
 else   if (""String_Node_Str"".equals(member)) {
    return iterationsIdNamed;
  }
 else   if (""String_Node_Str"".equals(member)) {
    return usersIdNamed;
  }
 else   if (""String_Node_Str"".equals(member)) {
    if (statusNamed == null) {
      statusNamed=new LinkedHashMap<>();
      statusNamed.put(""String_Node_Str"",new Status(""String_Node_Str""));
      statusNamed.put(""String_Node_Str"",new Status(""String_Node_Str""));
      statusNamed.put(""String_Node_Str"",new Status(""String_Node_Str""));
      statusNamed.put(""String_Node_Str"",new Status(""String_Node_Str""));
      statusNamed.put(""String_Node_Str"",new Status(""String_Node_Str""));
    }
    return statusNamed;
  }
  return null;
}",0.5772230889235569
91750,"@Override public boolean isPageComplete(){
  setMessage(pageDetails.getPageDescription());
  boolean result=super.isPageComplete();
  if (!result) {
    return result;
  }
  setErrorMessage(null);
  setMessage(""String_Node_Str"");
  boolean oneFieldHasValue=false;
  for (  Field field : schema.getFields()) {
    oneFieldHasValue|=(targetTaskData.getRoot().getAttribute(field.getKey()).hasValue() && !targetTaskData.getRoot().getAttribute(field.getKey()).getValue().equals(""String_Node_Str""));
    if (field.isQueryRequired()) {
      String text=targetTaskData.getRoot().getAttribute(field.getKey()).getValue();
      if (text == null || text.length() == 0) {
        setMessage(""String_Node_Str"" + field.getLabel());
        return false;
      }
    }
    if (field.getType().equals(""String_Node_Str"")) {
      String text=targetTaskData.getRoot().getAttribute(field.getKey()).getValue();
      if (text != null && text.length() > 0) {
        Matcher m=URL_PATTERN.matcher(text);
        if (m.find()) {
          setErrorMessage(null);
          return true;
        }
 else {
          setErrorMessage(""String_Node_Str"" + field.getLabel());
          return false;
        }
      }
    }
  }
  if (!oneFieldHasValue) {
    setErrorMessage(""String_Node_Str"");
  }
  return true;
}","@Override public boolean isPageComplete(){
  setMessage(pageDetails.getPageDescription());
  boolean result=super.isPageComplete();
  if (!result) {
    return result;
  }
  setErrorMessage(null);
  setMessage(""String_Node_Str"");
  boolean oneFieldHasValue=false;
  for (  Field field : schema.getFields()) {
    oneFieldHasValue|=(targetTaskData.getRoot().getAttribute(field.getKey()).hasValue() && !targetTaskData.getRoot().getAttribute(field.getKey()).getValue().equals(""String_Node_Str""));
    if (field.isQueryRequired()) {
      String text=targetTaskData.getRoot().getAttribute(field.getKey()).getValue();
      if (text == null || text.length() == 0) {
        setMessage(NLS.bind(Messages.OSIORestQuery_EnterValue,field.getLabel()));
        return false;
      }
    }
    if (field.getType().equals(""String_Node_Str"")) {
      String text=targetTaskData.getRoot().getAttribute(field.getKey()).getValue();
      if (text != null && text.length() > 0) {
        Matcher m=URL_PATTERN.matcher(text);
        if (m.find()) {
          setErrorMessage(null);
          return true;
        }
 else {
          setErrorMessage(NLS.bind(Messages.OSIORestQuery_EnterValidURL,field.getLabel()));
          return false;
        }
      }
    }
  }
  if (!oneFieldHasValue) {
    setErrorMessage(Messages.OSIORestQuery_SpecifyOneField);
  }
  return true;
}",0.8328290468986385
91751,"@Override protected Process exec(String[] cmdLine,File workingDirectory,String[] envp) throws CoreException {
  String connectionUri=DockerConnectionManager.getInstance().getFirstConnection().getUri();
  String command=String.join(""String_Node_Str"",cmdLine);
  String newWD=workingDirectory.getAbsolutePath();
  String[] classPath=extractClassPathFromCommand(cmdLine);
  List<String> additionalDirs=new ArrayList<>();
  additionalDirs.addAll(Arrays.asList(classPath));
  additionalDirs.addAll(getAdditionalDirectories());
  if (Platform.OS_WIN32.equals(Platform.getOS())) {
    newWD=UnixFile.convertDOSPathToUnixPath(workingDirectory.getAbsolutePath());
  }
  ContainerLauncher launch=new ContainerLauncher();
  int port=((ContainerVMInstall)fVMInstance).getPort();
  String[] portMap=port != -1 ? new String[]{String.valueOf(port) + ':' + String.valueOf(port)} : new String[0];
  launch.launch(""String_Node_Str"",new JavaAppInContainerLaunchListener(),connectionUri,fVMInstance.getId(),command,null,newWD,additionalDirs,System.getenv(),null,Arrays.asList(portMap),false,true,true);
  return null;
}","@Override protected Process exec(String[] cmdLine,File workingDirectory,String[] envp) throws CoreException {
  String connectionUri=DockerConnectionManager.getInstance().getFirstConnection().getUri();
  String command=String.join(""String_Node_Str"",cmdLine);
  String newWD=workingDirectory.getAbsolutePath();
  String[] classPath=extractClassPathFromCommand(cmdLine);
  List<String> additionalDirs=new ArrayList<>();
  additionalDirs.addAll(Arrays.asList(classPath));
  additionalDirs.addAll(getAdditionalDirectories());
  if (Platform.OS_WIN32.equals(Platform.getOS())) {
    newWD=UnixFile.convertDOSPathToUnixPath(workingDirectory.getAbsolutePath());
  }
  if (!newWD.endsWith(""String_Node_Str"")) {
    newWD=newWD + ""String_Node_Str"";
  }
  List<String> modAdditionalDirs=new ArrayList<>();
  for (  String addDir : additionalDirs) {
    if (!addDir.endsWith(""String_Node_Str"")) {
      modAdditionalDirs.add(addDir + ""String_Node_Str"");
    }
 else {
      modAdditionalDirs.add(addDir);
    }
  }
  ContainerLauncher launch=new ContainerLauncher();
  int port=((ContainerVMInstall)fVMInstance).getPort();
  String[] portMap=port != -1 ? new String[]{String.valueOf(port) + ':' + String.valueOf(port)} : new String[0];
  launch.launch(""String_Node_Str"",new JavaAppInContainerLaunchListener(),connectionUri,fVMInstance.getId(),command,null,newWD,modAdditionalDirs,System.getenv(),null,Arrays.asList(portMap),false,true,true);
  return null;
}",0.8625294579732914
91752,"@Override protected void doSaveDocument(IProgressMonitor monitor,Object element,IDocument document,boolean overwrite) throws CoreException {
  if (element instanceof FileStoreEditorInput) {
    String encoding=null;
    ElementInfo info=getElementInfo(element);
    Path filePath=Paths.get(((FileStoreEditorInput)element).getURI().getPath());
    encoding=getEncoding(element);
    Charset charset;
    try {
      charset=Charset.forName(encoding);
    }
 catch (    UnsupportedCharsetException ex) {
      String message=NLS.bind(Messages.DockerDocumentProvider_encoding_not_supported,encoding);
      IStatus s=new Status(IStatus.ERROR,EditorsUI.PLUGIN_ID,IStatus.OK,message,ex);
      throw new CoreException(s);
    }
catch (    IllegalCharsetNameException ex) {
      String message=NLS.bind(Messages.DockerDocumentProvider_encoding_not_legal,encoding);
      IStatus s=new Status(IStatus.ERROR,EditorsUI.PLUGIN_ID,IStatus.OK,message,ex);
      throw new CoreException(s);
    }
    CharsetEncoder encoder=charset.newEncoder();
    encoder.onMalformedInput(CodingErrorAction.REPLACE);
    encoder.onUnmappableCharacter(CodingErrorAction.REPORT);
    InputStream stream;
    try {
      byte[] bytes;
      ByteBuffer byteBuffer=encoder.encode(CharBuffer.wrap(document.get()));
      if (byteBuffer.hasArray())       bytes=byteBuffer.array();
 else {
        bytes=new byte[byteBuffer.limit()];
        byteBuffer.get(bytes);
      }
      stream=new ByteArrayInputStream(bytes,0,byteBuffer.limit());
    }
 catch (    CharacterCodingException ex) {
      Assert.isTrue(ex instanceof UnmappableCharacterException);
      String message=NLS.bind(Messages.DockerDocumentProvider_cannot_be_mapped + Messages.DockerDocumentProvider_chars_not_supported,encoding);
      IStatus s=new Status(IStatus.ERROR,EditorsUI.PLUGIN_ID,EditorsUI.CHARSET_MAPPING_FAILED,message,null);
      throw new CoreException(s);
    }
    if (Files.exists(filePath)) {
      fireElementStateChanging(element);
      try (FileWriter fw=new FileWriter(filePath.toFile());InputStreamReader istream=new InputStreamReader(stream)){
        char[] bb=new char[1024];
        int nRead=istream.read(bb);
        while (nRead > 0) {
          fw.write(bb,0,nRead);
          nRead=istream.read(bb);
        }
      }
 catch (      RuntimeException|IOException x) {
        fireElementStateChangeFailed(element);
        throw new CoreException(new Status(IStatus.ERROR,Activator.PLUGIN_ID,x.getMessage()));
      }
      if (info != null) {
        ResourceMarkerAnnotationModel model=(ResourceMarkerAnnotationModel)info.fModel;
        if (model != null)         model.updateMarkers(info.fDocument);
      }
    }
 else {
      try {
        Files.createFile(filePath);
        try (FileWriter fw=new FileWriter(filePath.toFile());InputStreamReader istream=new InputStreamReader(stream)){
          char[] bb=new char[1024];
          int nRead=istream.read(bb);
          while (nRead > 0) {
            fw.write(bb,0,nRead);
            nRead=istream.read(bb);
          }
        }
 catch (        IOException x) {
          throw x;
        }
      }
 catch (      IOException e) {
        throw new CoreException(new Status(IStatus.ERROR,Activator.PLUGIN_ID,e.getMessage()));
      }
 finally {
        monitor.done();
      }
    }
  }
 else {
    super.doSaveDocument(monitor,element,document,overwrite);
  }
}","@Override protected void doSaveDocument(IProgressMonitor monitor,Object element,IDocument document,boolean overwrite) throws CoreException {
  if (element instanceof FileStoreEditorInput) {
    String encoding=null;
    ElementInfo info=getElementInfo(element);
    Path filePath=Paths.get(((FileStoreEditorInput)element).getURI());
    encoding=getEncoding(element);
    Charset charset;
    try {
      charset=Charset.forName(encoding);
    }
 catch (    UnsupportedCharsetException ex) {
      String message=NLS.bind(Messages.DockerDocumentProvider_encoding_not_supported,encoding);
      IStatus s=new Status(IStatus.ERROR,EditorsUI.PLUGIN_ID,IStatus.OK,message,ex);
      throw new CoreException(s);
    }
catch (    IllegalCharsetNameException ex) {
      String message=NLS.bind(Messages.DockerDocumentProvider_encoding_not_legal,encoding);
      IStatus s=new Status(IStatus.ERROR,EditorsUI.PLUGIN_ID,IStatus.OK,message,ex);
      throw new CoreException(s);
    }
    CharsetEncoder encoder=charset.newEncoder();
    encoder.onMalformedInput(CodingErrorAction.REPLACE);
    encoder.onUnmappableCharacter(CodingErrorAction.REPORT);
    InputStream stream;
    try {
      byte[] bytes;
      ByteBuffer byteBuffer=encoder.encode(CharBuffer.wrap(document.get()));
      if (byteBuffer.hasArray())       bytes=byteBuffer.array();
 else {
        bytes=new byte[byteBuffer.limit()];
        byteBuffer.get(bytes);
      }
      stream=new ByteArrayInputStream(bytes,0,byteBuffer.limit());
    }
 catch (    CharacterCodingException ex) {
      Assert.isTrue(ex instanceof UnmappableCharacterException);
      String message=NLS.bind(Messages.DockerDocumentProvider_cannot_be_mapped + Messages.DockerDocumentProvider_chars_not_supported,encoding);
      IStatus s=new Status(IStatus.ERROR,EditorsUI.PLUGIN_ID,EditorsUI.CHARSET_MAPPING_FAILED,message,null);
      throw new CoreException(s);
    }
    if (Files.exists(filePath)) {
      fireElementStateChanging(element);
      try (FileWriter fw=new FileWriter(filePath.toFile());InputStreamReader istream=new InputStreamReader(stream)){
        char[] bb=new char[1024];
        int nRead=istream.read(bb);
        while (nRead > 0) {
          fw.write(bb,0,nRead);
          nRead=istream.read(bb);
        }
      }
 catch (      RuntimeException|IOException x) {
        fireElementStateChangeFailed(element);
        throw new CoreException(new Status(IStatus.ERROR,Activator.PLUGIN_ID,x.getMessage()));
      }
      if (info != null) {
        ResourceMarkerAnnotationModel model=(ResourceMarkerAnnotationModel)info.fModel;
        if (model != null)         model.updateMarkers(info.fDocument);
      }
    }
 else {
      try {
        Files.createFile(filePath);
        try (FileWriter fw=new FileWriter(filePath.toFile());InputStreamReader istream=new InputStreamReader(stream)){
          char[] bb=new char[1024];
          int nRead=istream.read(bb);
          while (nRead > 0) {
            fw.write(bb,0,nRead);
            nRead=istream.read(bb);
          }
        }
 catch (        IOException x) {
          throw x;
        }
      }
 catch (      IOException e) {
        throw new CoreException(new Status(IStatus.ERROR,Activator.PLUGIN_ID,e.getMessage()));
      }
 finally {
        monitor.done();
      }
    }
  }
 else {
    super.doSaveDocument(monitor,element,document,overwrite);
  }
}",0.9985220218740762
91753,"@Override public void dispose(){
  for (  Job job : openRetryJobs.values()) {
    LoadingJob loadingJob=(LoadingJob)job;
    IProgressMonitor monitor=loadingJob.getMonitor();
    monitor.setCanceled(true);
    job.cancel();
    try {
      job.join();
    }
 catch (    InterruptedException e) {
    }
  }
}","@Override public void dispose(){
  Collection<Job> jobs=Collections.emptyList();
synchronized (openRetryJobs) {
    jobs=openRetryJobs.values();
  }
  for (  Job job : jobs) {
    LoadingJob loadingJob=(LoadingJob)job;
    IProgressMonitor monitor=loadingJob.getMonitor();
    monitor.setCanceled(true);
    job.cancel();
    try {
      job.join();
    }
 catch (    InterruptedException e) {
    }
  }
}",0.800561797752809
91754,"@Before public void setUp() throws Exception {
  if (project == null) {
    project=createProjectAndBuild(FrameworkUtil.getBundle(this.getClass()),getTestProjectName()).getProject();
    isCppProject=project.getNature(CCProjectNature.CC_NATURE_ID) != null;
    gcovFiles=new TreeSet<>();
    for (    IResource r : project.members()) {
      if (r.getType() == IResource.FILE && r.exists()) {
        String fileName=r.getName();
        if (fileName.endsWith(""String_Node_Str"") || fileName.endsWith(""String_Node_Str"")) {
          gcovFiles.add(fileName);
        }
      }
    }
  }
}","@Before public void setUp() throws Exception {
  if (project == null) {
    ICProject cproject=createProjectAndBuild(FrameworkUtil.getBundle(this.getClass()),getTestProjectName());
    project=cproject.getProject();
    isCppProject=project.getNature(CCProjectNature.CC_NATURE_ID) != null;
    gcovFiles=new TreeSet<>();
    do {
      for (      IResource r : project.members()) {
        if (r.getType() == IResource.FILE && r.exists()) {
          String fileName=r.getName();
          if (fileName.endsWith(""String_Node_Str"") || fileName.endsWith(""String_Node_Str"")) {
            gcovFiles.add(fileName);
          }
        }
      }
    }
 while (gcovFiles.size() < 1);
  }
}",0.9156816390858944
91755,"protected ICProject createProjectAndBuild(Bundle bundle,String projname) throws CoreException, URISyntaxException, InvocationTargetException, InterruptedException, IOException {
  ICProject proj=createProject(bundle,projname);
  buildProject(proj);
  return proj;
}","protected ICProject createProjectAndBuild(Bundle bundle,String projname) throws CoreException, URISyntaxException, InvocationTargetException, InterruptedException, IOException {
  ICProject proj=createProject(bundle,projname);
  buildProject(proj);
  IBinary[] binaries=null;
  do {
    Thread.sleep(500);
    binaries=proj.getBinaryContainer().getBinaries();
  }
 while (binaries == null || binaries.length < 1);
  return proj;
}",0.7251798561151079
91756,"private void createTableViewer(final Composite container){
  search=new Text(container,SWT.SEARCH | SWT.ICON_SEARCH);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,false).applyTo(search);
  search.addModifyListener(onSearch());
  Composite tableArea=new Composite(container,SWT.NONE);
  GridLayoutFactory.fillDefaults().numColumns(1).margins(0,0).applyTo(tableArea);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,true).applyTo(tableArea);
  final TableColumnLayout tableLayout=new TableColumnLayout();
  tableArea.setLayout(tableLayout);
  this.viewer=new TableViewer(tableArea,SWT.FULL_SELECTION | SWT.MULTI | SWT.H_SCROLL| SWT.V_SCROLL);
  this.viewer.setContentProvider(new DockerImagesContentProvider());
  final Table table=viewer.getTable();
  GridLayoutFactory.fillDefaults().numColumns(1).margins(0,0).applyTo(table);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,true).applyTo(table);
  table.setLinesVisible(true);
  table.setHeaderVisible(true);
  final TableViewerColumn idColumn=createColumn(DVMessages.getString(""String_Node_Str""));
  setLayout(idColumn,tableLayout,150);
  idColumn.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    final Object element){
      if (element instanceof IDockerImage) {
        final String imageId=((IDockerImage)element).id();
        if (imageId.length() > 12) {
          return imageId.substring(0,12);
        }
        return imageId;
      }
      return super.getText(element);
    }
  }
);
  final TableViewerColumn tagsColumn=createColumn(DVMessages.getString(""String_Node_Str""));
  setLayout(tagsColumn,tableLayout,150);
  tagsColumn.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    final Object element){
      if (element instanceof IDockerImage) {
        final IDockerImage image=(IDockerImage)element;
        final StringBuilder messageBuilder=new StringBuilder();
        for (Iterator<String> iterator=image.repoTags().iterator(); iterator.hasNext(); ) {
          final String repoTag=iterator.next();
          messageBuilder.append(repoTag);
          if (iterator.hasNext()) {
            messageBuilder.append('\n');
          }
        }
        return messageBuilder.toString();
      }
      return super.getText(element);
    }
  }
);
  final TableViewerColumn creationDateColumn=createColumn(DVMessages.getString(""String_Node_Str""));
  setLayout(creationDateColumn,tableLayout,150);
  creationDateColumn.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    final Object element){
      if (element instanceof IDockerImage) {
        return LabelUtils.toCreatedDate(Long.parseLong(((IDockerImage)element).created()));
      }
      return super.getText(element);
    }
  }
);
  final TableViewerColumn virtsizeColumn=createColumn(DVMessages.getString(""String_Node_Str""));
  setLayout(virtsizeColumn,tableLayout,150);
  virtsizeColumn.setLabelProvider(new SpecialColumnLabelProvider(){
    @Override public String getText(    final Object element){
      if (element instanceof IDockerImage) {
        Long size=((IDockerImage)element).virtualSize();
        if (size <= 0)         return ""String_Node_Str"";
        final String[] units=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        int digitGroups=(int)(Math.log10(size) / Math.log10(1000));
        return new DecimalFormat(""String_Node_Str"").format(size / Math.pow(1000,digitGroups)) + ""String_Node_Str"" + units[digitGroups];
      }
      return super.getText(element);
    }
    @Override public String getCompareText(    final Object element){
      if (element instanceof IDockerImage) {
        return new DecimalFormat(""String_Node_Str"").format((((IDockerImage)element).virtualSize()));
      }
      return super.getText(element);
    }
  }
);
  final DockerImagesComparator comparator=new DockerImagesComparator(this.viewer);
  comparator.setColumn(creationDateColumn.getColumn());
  comparator.setColumn(creationDateColumn.getColumn());
  viewer.setComparator(comparator);
  this.viewer.addFilter(getImagesFilter());
  setConnection(CommandUtils.getCurrentConnection(null));
  getSite().setSelectionProvider(viewer);
}","private void createTableViewer(final Composite container){
  search=new Text(container,SWT.SEARCH | SWT.ICON_SEARCH);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,false).applyTo(search);
  search.addModifyListener(onSearch());
  Composite tableArea=new Composite(container,SWT.NONE);
  GridLayoutFactory.fillDefaults().numColumns(1).margins(0,0).applyTo(tableArea);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,true).applyTo(tableArea);
  final TableColumnLayout tableLayout=new TableColumnLayout();
  tableArea.setLayout(tableLayout);
  this.viewer=new TableViewer(tableArea,SWT.FULL_SELECTION | SWT.MULTI | SWT.H_SCROLL| SWT.V_SCROLL);
  this.viewer.setContentProvider(new DockerImagesContentProvider());
  final Table table=viewer.getTable();
  GridLayoutFactory.fillDefaults().numColumns(1).margins(0,0).applyTo(table);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,true).applyTo(table);
  table.setLinesVisible(true);
  table.setHeaderVisible(true);
  final TableViewerColumn idColumn=createColumn(DVMessages.getString(""String_Node_Str""));
  setLayout(idColumn,tableLayout,150);
  idColumn.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    final Object element){
      if (element instanceof IDockerImage) {
        String imageId=((IDockerImage)element).id();
        if (imageId.startsWith(""String_Node_Str""))         imageId=imageId.substring(7);
        if (imageId.length() > 12) {
          return imageId.substring(0,12);
        }
        return imageId;
      }
      return super.getText(element);
    }
  }
);
  final TableViewerColumn tagsColumn=createColumn(DVMessages.getString(""String_Node_Str""));
  setLayout(tagsColumn,tableLayout,150);
  tagsColumn.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    final Object element){
      if (element instanceof IDockerImage) {
        final IDockerImage image=(IDockerImage)element;
        final StringBuilder messageBuilder=new StringBuilder();
        for (Iterator<String> iterator=image.repoTags().iterator(); iterator.hasNext(); ) {
          final String repoTag=iterator.next();
          messageBuilder.append(repoTag);
          if (iterator.hasNext()) {
            messageBuilder.append('\n');
          }
        }
        return messageBuilder.toString();
      }
      return super.getText(element);
    }
  }
);
  final TableViewerColumn creationDateColumn=createColumn(DVMessages.getString(""String_Node_Str""));
  setLayout(creationDateColumn,tableLayout,150);
  creationDateColumn.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    final Object element){
      if (element instanceof IDockerImage) {
        return LabelUtils.toCreatedDate(Long.parseLong(((IDockerImage)element).created()));
      }
      return super.getText(element);
    }
  }
);
  final TableViewerColumn virtsizeColumn=createColumn(DVMessages.getString(""String_Node_Str""));
  setLayout(virtsizeColumn,tableLayout,150);
  virtsizeColumn.setLabelProvider(new SpecialColumnLabelProvider(){
    @Override public String getText(    final Object element){
      if (element instanceof IDockerImage) {
        Long size=((IDockerImage)element).virtualSize();
        if (size <= 0)         return ""String_Node_Str"";
        final String[] units=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        int digitGroups=(int)(Math.log10(size) / Math.log10(1000));
        return new DecimalFormat(""String_Node_Str"").format(size / Math.pow(1000,digitGroups)) + ""String_Node_Str"" + units[digitGroups];
      }
      return super.getText(element);
    }
    @Override public String getCompareText(    final Object element){
      if (element instanceof IDockerImage) {
        return new DecimalFormat(""String_Node_Str"").format((((IDockerImage)element).virtualSize()));
      }
      return super.getText(element);
    }
  }
);
  final DockerImagesComparator comparator=new DockerImagesComparator(this.viewer);
  comparator.setColumn(creationDateColumn.getColumn());
  comparator.setColumn(creationDateColumn.getColumn());
  viewer.setComparator(comparator);
  this.viewer.addFilter(getImagesFilter());
  setConnection(CommandUtils.getCurrentConnection(null));
  getSite().setSelectionProvider(viewer);
}",0.9890236857307916
91757,"@Override public Object[] getElements(final Object inputElement){
  if (inputElement instanceof IDockerImage) {
    final IDockerImage image=(IDockerImage)inputElement;
    return new Object[]{new Object[]{""String_Node_Str"",image.id().substring(0,12)},new Object[]{""String_Node_Str"",image.parentId()},new Object[]{""String_Node_Str"",image.createdDate() != null ? image.createdDate() : ""String_Node_Str""},new Object[]{""String_Node_Str"",LabelUtils.reduce(image.repoTags())},new Object[]{""String_Node_Str"",LabelUtils.toString(image.size())},new Object[]{""String_Node_Str"",LabelUtils.toString(image.virtualSize())},new Object[]{""String_Node_Str"",LabelUtils.toString(image.isIntermediateImage())},new Object[]{""String_Node_Str"",LabelUtils.toString(image.isDangling())}};
  }
  return EMPTY;
}","@Override public Object[] getElements(final Object inputElement){
  if (inputElement instanceof IDockerImage) {
    final IDockerImage image=(IDockerImage)inputElement;
    return new Object[]{new Object[]{""String_Node_Str"",image.id()},new Object[]{""String_Node_Str"",image.parentId()},new Object[]{""String_Node_Str"",image.createdDate() != null ? image.createdDate() : ""String_Node_Str""},new Object[]{""String_Node_Str"",LabelUtils.reduce(image.repoTags())},new Object[]{""String_Node_Str"",LabelUtils.toString(image.size())},new Object[]{""String_Node_Str"",LabelUtils.toString(image.virtualSize())},new Object[]{""String_Node_Str"",LabelUtils.toString(image.isIntermediateImage())},new Object[]{""String_Node_Str"",LabelUtils.toString(image.isDangling())}};
  }
  return EMPTY;
}",0.9897172236503856
91758,"@Override public Object[] getElements(Object inputElement){
  if (inputElement instanceof IDockerImageInfo) {
    final IDockerImageInfo info=(IDockerImageInfo)inputElement;
    return new Object[]{new Object[]{""String_Node_Str"",info.id().substring(0,12)},new Object[]{""String_Node_Str"",info.parent()},new Object[]{""String_Node_Str"",info.comment()},new Object[]{""String_Node_Str"",LabelUtils.toCreatedDate(info.created())},new Object[]{""String_Node_Str"",info.container()},new Object[]{""String_Node_Str"",info.containerConfig()},new Object[]{""String_Node_Str"",info.dockerVersion()},new Object[]{""String_Node_Str"",info.author()},new Object[]{""String_Node_Str"",info.config()},new Object[]{""String_Node_Str"",info.architecture()},new Object[]{""String_Node_Str"",info.os()},new Object[]{""String_Node_Str"",LabelUtils.toString(info.size())}};
  }
  return EMPTY;
}","@Override public Object[] getElements(Object inputElement){
  if (inputElement instanceof IDockerImageInfo) {
    final IDockerImageInfo info=(IDockerImageInfo)inputElement;
    return new Object[]{new Object[]{""String_Node_Str"",info.id()},new Object[]{""String_Node_Str"",info.parent()},new Object[]{""String_Node_Str"",info.comment()},new Object[]{""String_Node_Str"",LabelUtils.toCreatedDate(info.created())},new Object[]{""String_Node_Str"",info.container()},new Object[]{""String_Node_Str"",info.containerConfig()},new Object[]{""String_Node_Str"",info.dockerVersion()},new Object[]{""String_Node_Str"",info.author()},new Object[]{""String_Node_Str"",info.config()},new Object[]{""String_Node_Str"",info.architecture()},new Object[]{""String_Node_Str"",info.os()},new Object[]{""String_Node_Str"",LabelUtils.toString(info.size())}};
  }
  return EMPTY;
}",0.9905325443786982
91759,"@Override public List<IDockerImage> listImages() throws DockerException {
  final List<IDockerImage> tempImages=new ArrayList<>();
synchronized (imageLock) {
    List<Image> rawImages=new ArrayList<>();
    try {
synchronized (clientLock) {
        if (client == null)         return tempImages;
        rawImages=client.listImages(DockerClient.ListImagesParam.allImages());
      }
    }
 catch (    DockerTimeoutException e) {
      if (isOpen()) {
        Activator.log(new Status(IStatus.WARNING,Activator.PLUGIN_ID,Messages.Docker_Connection_Timeout,e));
        close();
      }
    }
catch (    com.spotify.docker.client.DockerRequestException e) {
      throw new DockerException(e.message());
    }
catch (    com.spotify.docker.client.DockerException|InterruptedException e) {
      if (isOpen() && e.getCause() != null && e.getCause().getCause() != null && e.getCause().getCause() instanceof ProcessingException) {
        close();
      }
 else {
        throw new DockerException(e.getMessage());
      }
    }
    final Set<String> imageParentIds=new HashSet<>();
    for (    Image rawImage : rawImages) {
      imageParentIds.add(rawImage.parentId());
    }
    for (    Image rawImage : rawImages) {
      final boolean taggedImage=!(rawImage.repoTags() != null && rawImage.repoTags().size() == 1 && rawImage.repoTags().contains(""String_Node_Str""));
      final boolean intermediateImage=!taggedImage && imageParentIds.contains(rawImage.id());
      final boolean danglingImage=!taggedImage && !intermediateImage;
      final List<String> repoTags=rawImage.repoTags() != null ? new ArrayList<>(rawImage.repoTags()) : Arrays.asList(""String_Node_Str"");
      Collections.sort(repoTags);
      final String repo=DockerImage.extractRepo(repoTags.get(0));
      final List<String> tags=Arrays.asList(DockerImage.extractTag(repoTags.get(0)));
      tempImages.add(new DockerImage(this,repoTags,repo,tags,rawImage.id(),rawImage.parentId(),rawImage.created(),rawImage.size(),rawImage.virtualSize(),intermediateImage,danglingImage));
    }
    images=tempImages;
  }
  notifyImageListeners(tempImages);
  return tempImages;
}","@Override public List<IDockerImage> listImages() throws DockerException {
  final List<IDockerImage> tempImages=new ArrayList<>();
synchronized (imageLock) {
    List<Image> rawImages=new ArrayList<>();
    try {
synchronized (clientLock) {
        if (client == null)         return tempImages;
        rawImages=client.listImages(DockerClient.ListImagesParam.allImages());
      }
    }
 catch (    DockerTimeoutException e) {
      if (isOpen()) {
        Activator.log(new Status(IStatus.WARNING,Activator.PLUGIN_ID,Messages.Docker_Connection_Timeout,e));
        close();
      }
    }
catch (    com.spotify.docker.client.DockerRequestException e) {
      throw new DockerException(e.message());
    }
catch (    com.spotify.docker.client.DockerException|InterruptedException e) {
      if (isOpen() && e.getCause() != null && e.getCause().getCause() != null && e.getCause().getCause() instanceof ProcessingException) {
        close();
      }
 else {
        throw new DockerException(e.getMessage());
      }
    }
    final Set<String> imageParentIds=new HashSet<>();
    for (    Image rawImage : rawImages) {
      imageParentIds.add(rawImage.parentId());
    }
    for (    Image rawImage : rawImages) {
      final List<String> repoTags=rawImage.repoTags() != null && rawImage.repoTags().size() > 0 ? new ArrayList<>(rawImage.repoTags()) : Arrays.asList(""String_Node_Str"");
      Collections.sort(repoTags);
      final boolean taggedImage=!(repoTags != null && repoTags.size() == 1 && repoTags.contains(""String_Node_Str""));
      final boolean intermediateImage=!taggedImage && imageParentIds.contains(rawImage.id());
      final boolean danglingImage=!taggedImage && !intermediateImage;
      final String repo=DockerImage.extractRepo(repoTags.get(0));
      final List<String> tags=Arrays.asList(DockerImage.extractTag(repoTags.get(0)));
      tempImages.add(new DockerImage(this,repoTags,repo,tags,rawImage.id(),rawImage.parentId(),rawImage.created(),rawImage.size(),rawImage.virtualSize(),intermediateImage,danglingImage));
    }
    images=tempImages;
  }
  notifyImageListeners(tempImages);
  return tempImages;
}",0.8732130302320131
91760,"/** 
 * Source file
 * @return a source file string
 */
public String getFile(){
  return file;
}","/** 
 * Source file Note: new Valgrind versions (e.g. 3.10) prints the full path of file, not just the source file name.
 * @return a source file string
 */
public String getFile(){
  return file;
}",0.6576271186440678
91761,"/** 
 * Returns the   {@link IValgrindMessage} element from the Valgrind View that representsa given Marker
 * @param marker the marker to which the ValgrindMessage relates
 * @return {@link IValgrindMessage} that represents the {@link IMarker}
 */
private IValgrindMessage getMessage(IMarker marker){
  IValgrindMessage message=null;
  String file=marker.getResource().getName();
  int line=marker.getAttribute(IMarker.LINE_NUMBER,0);
  IValgrindMessage[] wrongDeallocMessages=getMessagesByText(Messages.getString(""String_Node_Str""));
  for (  IValgrindMessage wrongDeallocMessage : wrongDeallocMessages) {
    ValgrindStackFrame stackBottom=getStackBottom(wrongDeallocMessage);
    int stackBottomLine=stackBottom.getLine();
    String stackBottomFile=stackBottom.getFile();
    if (stackBottomLine == line && file != null && file.equals(stackBottomFile)) {
      message=stackBottom;
    }
  }
  return message;
}","/** 
 * Returns the   {@link IValgrindMessage} element from the Valgrind View that representsa given Marker
 * @param marker the marker to which the ValgrindMessage relates
 * @return {@link IValgrindMessage} that represents the {@link IMarker}
 */
private IValgrindMessage getMessage(IMarker marker){
  IValgrindMessage message=null;
  String file=marker.getResource().getName();
  int line=marker.getAttribute(IMarker.LINE_NUMBER,0);
  IValgrindMessage[] wrongDeallocMessages=getMessagesByText(Messages.getString(""String_Node_Str""));
  for (  IValgrindMessage wrongDeallocMessage : wrongDeallocMessages) {
    ValgrindStackFrame stackBottom=getStackBottom(wrongDeallocMessage);
    int stackBottomLine=stackBottom.getLine();
    String stackBottomFile=stackBottom.getFile();
    if (stackBottomLine == line && file != null && stackBottomFile.endsWith(file)) {
      message=stackBottom;
    }
  }
  return message;
}",0.9116684841875682
91762,"/** 
 * Returns the allocation function that relates to the given marker
 * @param marker {@link IMarker} object that points to where the wrong de-allocation function is
 * @return {@link String} object containing the allocation function
 * @throws BadLocationException
 */
private String getAllocFunction(IMarker marker,IDocument document) throws BadLocationException {
  IValgrindMessage allocMessage=null;
  String file=marker.getResource().getName();
  int line=marker.getAttribute(IMarker.LINE_NUMBER,0);
  IValgrindMessage[] wrongDeallocMessages=getMessagesByText(Messages.getString(""String_Node_Str""));
  for (  IValgrindMessage wrongDeallocMessage : wrongDeallocMessages) {
    ValgrindStackFrame stackBottom=getStackBottom(wrongDeallocMessage);
    int stackBottomLine=stackBottom.getLine();
    String stackBottomFile=stackBottom.getFile();
    if (stackBottomLine == line && file != null && file.equals(stackBottomFile)) {
      allocMessage=getStackBottom(getNestedStack(wrongDeallocMessage));
    }
  }
  if (allocMessage instanceof ValgrindStackFrame) {
    int allocLine=((ValgrindStackFrame)allocMessage).getLine() - 1;
    int allocOffset=document.getLineOffset(allocLine);
    int allocLength=document.getLineLength(allocLine);
    return document.get(allocOffset,allocLength);
  }
  return null;
}","/** 
 * Returns the allocation function that relates to the given marker
 * @param marker {@link IMarker} object that points to where the wrong de-allocation function is
 * @return {@link String} object containing the allocation function
 * @throws BadLocationException
 */
private String getAllocFunction(IMarker marker,IDocument document) throws BadLocationException {
  IValgrindMessage allocMessage=null;
  String file=marker.getResource().getName();
  int line=marker.getAttribute(IMarker.LINE_NUMBER,0);
  IValgrindMessage[] wrongDeallocMessages=getMessagesByText(Messages.getString(""String_Node_Str""));
  for (  IValgrindMessage wrongDeallocMessage : wrongDeallocMessages) {
    ValgrindStackFrame stackBottom=getStackBottom(wrongDeallocMessage);
    int stackBottomLine=stackBottom.getLine();
    String stackBottomFile=stackBottom.getFile();
    if (stackBottomLine == line && file != null && stackBottomFile.endsWith(file)) {
      allocMessage=getStackBottom(getNestedStack(wrongDeallocMessage));
    }
  }
  if (allocMessage instanceof ValgrindStackFrame) {
    int allocLine=((ValgrindStackFrame)allocMessage).getLine() - 1;
    int allocOffset=document.getLineOffset(allocLine);
    int allocLength=document.getLineLength(allocLine);
    return document.get(allocOffset,allocLength);
  }
  return null;
}",0.9848139711465452
91763,"private static IFile getFileForPathImpl(IPath path,IProject project){
  IWorkspaceRoot root=ResourcesPlugin.getWorkspace().getRoot();
  if (path.isAbsolute()) {
    return root.getFileForLocation(path);
  }
  if (project != null && project.exists()) {
    ICProject cproject=CoreModel.getDefault().create(project);
    if (cproject != null) {
      try {
        ISourceRoot[] roots=cproject.getAllSourceRoots();
        for (        ISourceRoot sourceRoot : roots) {
          IResource r=sourceRoot.getResource();
          if (r instanceof IContainer) {
            IContainer parent=(IContainer)r;
            IResource res=parent.findMember(path);
            if (res != null && res.exists() && res instanceof IFile) {
              return (IFile)res;
            }
          }
        }
        IOutputEntry entries[]=cproject.getOutputEntries();
        for (        IOutputEntry pathEntry : entries) {
          IPath p=pathEntry.getPath();
          IResource r=root.findMember(p);
          if (r instanceof IContainer) {
            IContainer parent=(IContainer)r;
            IResource res=parent.findMember(path);
            if (res != null && res.exists() && res instanceof IFile) {
              return (IFile)res;
            }
          }
        }
      }
 catch (      CModelException e) {
        Activator.getDefault().getLog().log(e.getStatus());
      }
    }
  }
  return null;
}","private static IFile getFileForPathImpl(IPath path,IProject project){
  IWorkspaceRoot root=ResourcesPlugin.getWorkspace().getRoot();
  if (path.isAbsolute()) {
    return root.getFileForLocation(path);
  }
  if (project != null && project.exists()) {
    ICProject cproject=CoreModel.getDefault().create(project);
    if (cproject != null) {
      try {
        ISourceRoot[] roots=cproject.getAllSourceRoots();
        for (        ISourceRoot sourceRoot : roots) {
          IResource r=sourceRoot.getResource();
          if (r instanceof IContainer) {
            IContainer parent=(IContainer)r;
            IResource res=parent.findMember(path);
            if (res != null && res.exists() && res instanceof IFile) {
              return (IFile)res;
            }
          }
        }
        IOutputEntry entries[]=cproject.getOutputEntries();
        for (        IOutputEntry pathEntry : entries) {
          IPath p=pathEntry.getPath();
          IResource r=root.findMember(p);
          if (r instanceof IContainer) {
            IContainer parent=(IContainer)r;
            IResource res=parent.findMember(path);
            if (res != null && res.exists() && res instanceof IFile) {
              return (IFile)res;
            }
          }
        }
      }
 catch (      CModelException e) {
        Activator.getDefault().getLog().log(e.getStatus());
      }
    }
  }
  IPath realPath=project.getLocation().append(path).makeAbsolute();
  URI realURI=URIUtil.toURI(realPath.toString());
  try {
    FindLinkedResourceVisitor visitor=new STLink2SourceSupport.FindLinkedResourceVisitor(realURI);
    project.accept(visitor,IResource.DEPTH_INFINITE);
    if (visitor.foundElement()) {
      IResource elementResource=visitor.getResource();
      return (IFile)elementResource;
    }
  }
 catch (  CoreException e) {
  }
  return null;
}",0.85451197053407
91764,"@Override public void performApply(ILaunchConfigurationWorkingCopy configuration){
  WritableList<DataVolumeModel> volumes=model.getDataVolumes();
  Set<DataVolumeModel> selectedVolumes=model.getSelectedDataVolumes();
  ArrayList<String> binds=new ArrayList<>();
  ArrayList<String> volumesFrom=new ArrayList<>();
  ArrayList<String> volumesList=new ArrayList<>();
  Set<String> selectedVolumesSet=new TreeSet<>();
  for (Iterator<DataVolumeModel> iterator=volumes.iterator(); iterator.hasNext(); ) {
    DataVolumeModel volume=iterator.next();
    StringBuffer buffer=new StringBuffer();
    volumesList.add(volume.toString());
switch (volume.getMountType()) {
case HOST_FILE_SYSTEM:
      buffer.append(volume.getHostPathMount() + ""String_Node_Str"" + volume.getHostPathMount()+ ""String_Node_Str""+ volume.isReadOnly());
    if (selectedVolumes.contains(volume)) {
      selectedVolumesSet.add(volume.toString());
      String bind=convertToUnixPath(volume.getHostPathMount()) + ':' + volume.getContainerPath()+ ':'+ 'Z';
      if (volume.isReadOnly()) {
        bind+=""String_Node_Str"";
      }
      binds.add(bind);
    }
  break;
case CONTAINER:
if (selectedVolumes.contains(volume)) {
  selectedVolumesSet.add(volume.toString());
  volumesFrom.add(volume.getContainerMount());
}
break;
default :
break;
}
}
configuration.setAttribute(IRunDockerImageLaunchConfigurationConstants.BINDS,binds);
configuration.setAttribute(IRunDockerImageLaunchConfigurationConstants.VOLUMES_FROM,volumesFrom);
configuration.setAttribute(IRunDockerImageLaunchConfigurationConstants.DATA_VOLUMES,volumesList);
}","@Override public void performApply(ILaunchConfigurationWorkingCopy configuration){
  WritableList<DataVolumeModel> volumes=model.getDataVolumes();
  Set<DataVolumeModel> selectedVolumes=model.getSelectedDataVolumes();
  ArrayList<String> binds=new ArrayList<>();
  ArrayList<String> volumesFrom=new ArrayList<>();
  ArrayList<String> volumesList=new ArrayList<>();
  Set<String> selectedVolumesSet=new TreeSet<>();
  for (Iterator<DataVolumeModel> iterator=volumes.iterator(); iterator.hasNext(); ) {
    DataVolumeModel volume=iterator.next();
    StringBuffer buffer=new StringBuffer();
    volumesList.add(volume.toString());
switch (volume.getMountType()) {
case HOST_FILE_SYSTEM:
      buffer.append(volume.getHostPathMount() + ""String_Node_Str"" + volume.getHostPathMount()+ ""String_Node_Str""+ volume.isReadOnly());
    if (selectedVolumes.contains(volume)) {
      selectedVolumesSet.add(volume.toString());
      String bind=LaunchConfigurationUtils.convertToUnixPath(volume.getHostPathMount()) + ':' + volume.getContainerPath()+ ':'+ 'Z';
      if (volume.isReadOnly()) {
        bind+=""String_Node_Str"";
      }
      binds.add(bind);
    }
  break;
case CONTAINER:
if (selectedVolumes.contains(volume)) {
  selectedVolumesSet.add(volume.toString());
  volumesFrom.add(volume.getContainerMount());
}
break;
default :
break;
}
}
configuration.setAttribute(IRunDockerImageLaunchConfigurationConstants.BINDS,binds);
configuration.setAttribute(IRunDockerImageLaunchConfigurationConstants.VOLUMES_FROM,volumesFrom);
configuration.setAttribute(IRunDockerImageLaunchConfigurationConstants.DATA_VOLUMES,volumesList);
}",0.9922191098661688
91765,"/** 
 * Create a DataVolumeModel from a toString() output.
 * @param fromString
 * @return DataVolumeModel
 */
public static DataVolumeModel parseString(final String fromString){
  final DataVolumeModel model=new DataVolumeModel();
  final String[] items=fromString.split(SEPARATOR);
  model.containerPath=items[0];
  model.mountType=MountType.valueOf(items[1]);
switch (model.mountType) {
case CONTAINER:
    model.setContainerMount(items[2]);
  model.setSelected(Boolean.valueOf(items[3]));
break;
case HOST_FILE_SYSTEM:
model.setHostPathMount(items[2]);
model.setReadOnly(Boolean.valueOf(items[3]));
model.setSelected(Boolean.valueOf(items[4]));
break;
case NONE:
model.setSelected(Boolean.valueOf(items[2]));
break;
}
return model;
}","/** 
 * Create a DataVolumeModel from a toString() output.
 * @param fromString
 * @return DataVolumeModel
 */
public static DataVolumeModel parseString(final String fromString){
  final DataVolumeModel model=new DataVolumeModel();
  final String[] items=fromString.split(SEPARATOR);
  model.containerPath=items[0];
  model.mountType=MountType.valueOf(items[1]);
switch (model.mountType) {
case CONTAINER:
    model.setContainerMount(items[2]);
  model.setSelected(Boolean.valueOf(items[3]));
break;
case HOST_FILE_SYSTEM:
if (Platform.OS_WIN32.equals(Platform.getOS())) {
model.setHostPathMount(items[2] + SEPARATOR + items[3]);
model.setReadOnly(Boolean.valueOf(items[4]));
model.setSelected(Boolean.valueOf(items[5]));
}
 else {
model.setHostPathMount(items[2]);
model.setReadOnly(Boolean.valueOf(items[3]));
model.setSelected(Boolean.valueOf(items[4]));
}
break;
case NONE:
model.setSelected(Boolean.valueOf(items[2]));
break;
}
return model;
}",0.8605341246290801
91766,"public IDockerHostConfig getDockerHostConfig(){
  final ImageRunSelectionModel selectionModel=this.imageRunSelectionPage.getModel();
  final ImageRunResourceVolumesVariablesModel resourcesModel=this.imageRunResourceVolumesPage.getModel();
  final DockerHostConfig.Builder hostConfigBuilder=new DockerHostConfig.Builder();
  if (selectionModel.isPublishAllPorts()) {
    hostConfigBuilder.publishAllPorts(true);
  }
 else {
    final Map<String,List<IDockerPortBinding>> portBindings=new HashMap<>();
    for (Iterator<ExposedPortModel> iterator=selectionModel.getExposedPorts().iterator(); iterator.hasNext(); ) {
      final ExposedPortModel exposedPort=iterator.next();
      if (!selectionModel.getSelectedPorts().contains(exposedPort)) {
        continue;
      }
      final DockerPortBinding portBinding=new DockerPortBinding(exposedPort.getHostAddress(),exposedPort.getHostPort());
      portBindings.put(exposedPort.getContainerPort() + exposedPort.getPortType(),Arrays.<IDockerPortBinding>asList(portBinding));
    }
    hostConfigBuilder.portBindings(portBindings);
  }
  final List<String> links=new ArrayList<>();
  for (Iterator<ContainerLinkModel> iterator=selectionModel.getLinks().iterator(); iterator.hasNext(); ) {
    final ContainerLinkModel link=iterator.next();
    links.add(link.getContainerName() + ':' + link.getContainerAlias());
  }
  hostConfigBuilder.links(links);
  final List<String> volumesFrom=new ArrayList<>();
  final List<String> binds=new ArrayList<>();
  for (Iterator<DataVolumeModel> iterator=resourcesModel.getDataVolumes().iterator(); iterator.hasNext(); ) {
    final DataVolumeModel dataVolume=iterator.next();
    if (!resourcesModel.getSelectedDataVolumes().contains(dataVolume)) {
      continue;
    }
switch (dataVolume.getMountType()) {
case HOST_FILE_SYSTEM:
      String bind=convertToUnixPath(dataVolume.getHostPathMount()) + ':' + dataVolume.getContainerPath()+ ""String_Node_Str"";
    if (dataVolume.isReadOnly()) {
      bind+=""String_Node_Str"";
    }
  binds.add(bind);
break;
case CONTAINER:
volumesFrom.add(dataVolume.getContainerMount());
break;
default :
break;
}
}
hostConfigBuilder.binds(binds);
hostConfigBuilder.volumesFrom(volumesFrom);
if (resourcesModel.isEnableResourceLimitations()) {
hostConfigBuilder.memory(resourcesModel.getMemoryLimit() * MB);
hostConfigBuilder.cpuShares(resourcesModel.getCpuShareWeight());
}
return hostConfigBuilder.build();
}","public IDockerHostConfig getDockerHostConfig(){
  final ImageRunSelectionModel selectionModel=this.imageRunSelectionPage.getModel();
  final ImageRunResourceVolumesVariablesModel resourcesModel=this.imageRunResourceVolumesPage.getModel();
  final DockerHostConfig.Builder hostConfigBuilder=new DockerHostConfig.Builder();
  if (selectionModel.isPublishAllPorts()) {
    hostConfigBuilder.publishAllPorts(true);
  }
 else {
    final Map<String,List<IDockerPortBinding>> portBindings=new HashMap<>();
    for (Iterator<ExposedPortModel> iterator=selectionModel.getExposedPorts().iterator(); iterator.hasNext(); ) {
      final ExposedPortModel exposedPort=iterator.next();
      if (!selectionModel.getSelectedPorts().contains(exposedPort)) {
        continue;
      }
      final DockerPortBinding portBinding=new DockerPortBinding(exposedPort.getHostAddress(),exposedPort.getHostPort());
      portBindings.put(exposedPort.getContainerPort() + exposedPort.getPortType(),Arrays.<IDockerPortBinding>asList(portBinding));
    }
    hostConfigBuilder.portBindings(portBindings);
  }
  final List<String> links=new ArrayList<>();
  for (Iterator<ContainerLinkModel> iterator=selectionModel.getLinks().iterator(); iterator.hasNext(); ) {
    final ContainerLinkModel link=iterator.next();
    links.add(link.getContainerName() + ':' + link.getContainerAlias());
  }
  hostConfigBuilder.links(links);
  final List<String> volumesFrom=new ArrayList<>();
  final List<String> binds=new ArrayList<>();
  for (Iterator<DataVolumeModel> iterator=resourcesModel.getDataVolumes().iterator(); iterator.hasNext(); ) {
    final DataVolumeModel dataVolume=iterator.next();
    if (!resourcesModel.getSelectedDataVolumes().contains(dataVolume)) {
      continue;
    }
switch (dataVolume.getMountType()) {
case HOST_FILE_SYSTEM:
      String bind=LaunchConfigurationUtils.convertToUnixPath(dataVolume.getHostPathMount()) + ':' + dataVolume.getContainerPath()+ ""String_Node_Str"";
    if (dataVolume.isReadOnly()) {
      bind+=""String_Node_Str"";
    }
  binds.add(bind);
break;
case CONTAINER:
volumesFrom.add(dataVolume.getContainerMount());
break;
default :
break;
}
}
hostConfigBuilder.binds(binds);
hostConfigBuilder.volumesFrom(volumesFrom);
if (resourcesModel.isEnableResourceLimitations()) {
hostConfigBuilder.memory(resourcesModel.getMemoryLimit() * MB);
hostConfigBuilder.cpuShares(resourcesModel.getCpuShareWeight());
}
return hostConfigBuilder.build();
}",0.9948654754569728
91767,"/** 
 * Some ToolBar items are depend on each other's state as enablement criteria. They must be created programmatically so the state of other buttons may be changed.
 */
private void hookToolBarItems(){
  IToolBarManager mgr=getViewSite().getActionBars().getToolBarManager();
  pauseAction=createAction(DVMessages.getString(""String_Node_Str""),""String_Node_Str"",SWTImagesFactory.DESC_PAUSE);
  unpauseAction=createAction(DVMessages.getString(""String_Node_Str""),""String_Node_Str"",SWTImagesFactory.DESC_RESUME);
  startAction=createAction(DVMessages.getString(""String_Node_Str""),""String_Node_Str"",SWTImagesFactory.DESC_START);
  stopAction=createAction(DVMessages.getString(""String_Node_Str""),""String_Node_Str"",SWTImagesFactory.DESC_STOP);
  killAction=createAction(DVMessages.getString(""String_Node_Str""),""String_Node_Str"",SWTImagesFactory.DESC_KILL);
  removeAction=createAction(DVMessages.getString(""String_Node_Str""),""String_Node_Str"",SWTImagesFactory.DESC_REMOVE);
  mgr.add(startAction);
  mgr.add(stopAction);
  mgr.add(killAction);
  mgr.add(pauseAction);
  mgr.add(unpauseAction);
  mgr.add(removeAction);
}","/** 
 * Some ToolBar items are depend on each other's state as enablement criteria. They must be created programmatically so the state of other buttons may be changed.
 */
private void hookToolBarItems(){
  IToolBarManager mgr=getViewSite().getActionBars().getToolBarManager();
  pauseAction=createAction(DVMessages.getString(""String_Node_Str""),""String_Node_Str"",SWTImagesFactory.DESC_PAUSE);
  unpauseAction=createAction(DVMessages.getString(""String_Node_Str""),""String_Node_Str"",SWTImagesFactory.DESC_RESUME);
  startAction=createAction(DVMessages.getString(""String_Node_Str""),""String_Node_Str"",SWTImagesFactory.DESC_START);
  stopAction=createAction(DVMessages.getString(""String_Node_Str""),""String_Node_Str"",SWTImagesFactory.DESC_STOP);
  killAction=createAction(DVMessages.getString(""String_Node_Str""),""String_Node_Str"",SWTImagesFactory.DESC_KILL);
  removeAction=createAction(DVMessages.getString(""String_Node_Str""),""String_Node_Str"",SWTImagesFactory.DESC_REMOVE);
  mgr.add(startAction);
  mgr.add(pauseAction);
  mgr.add(unpauseAction);
  mgr.add(stopAction);
  mgr.add(killAction);
  mgr.add(removeAction);
}",0.9551569506726456
91768,"/** 
 * Opens a dialog to browse the workspace
 * @return
 */
private SelectionListener onBrowseWorkspace(final Text pathText,final AtomicBoolean workspaceRelativePath,final Class<?> expectedType){
  return new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      final ElementTreeSelectionDialog dialog=new ElementTreeSelectionDialog(getShell(),new WorkbenchLabelProvider(),new WorkbenchContentProvider());
      dialog.setInput(ResourcesPlugin.getWorkspace().getRoot());
      dialog.setTitle(LaunchMessages.getString(BROWSE_WORKSPACE_DIALOG_TITLE));
      dialog.setComparator(new ResourceComparator(ResourceComparator.NAME));
      dialog.setAllowMultiple(false);
      dialog.setValidator(new ISelectionStatusValidator(){
        @Override public IStatus validate(        Object[] selection){
          if (selection.length == 1 && expectedType.isAssignableFrom(selection[0].getClass())) {
            return new Status(IStatus.OK,Activator.PLUGIN_ID,null);
          }
          return new Status(IStatus.ERROR,Activator.PLUGIN_ID,null);
        }
      }
);
      if (dialog.open() == IDialogConstants.OK_ID) {
        final IResource selection=(IResource)dialog.getFirstResult();
        pathText.setText(selection.getFullPath().toOSString());
        workspaceRelativePath.set(true);
      }
    }
  }
;
}","/** 
 * Opens a dialog to browse the workspace
 * @return
 */
private SelectionListener onBrowseWorkspace(final Text pathText,final Class<?> expectedType){
  return new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      final ElementTreeSelectionDialog dialog=new ElementTreeSelectionDialog(getShell(),new WorkbenchLabelProvider(),new WorkbenchContentProvider());
      dialog.setInput(ResourcesPlugin.getWorkspace().getRoot());
      dialog.setTitle(LaunchMessages.getString(BROWSE_WORKSPACE_DIALOG_TITLE));
      dialog.setComparator(new ResourceComparator(ResourceComparator.NAME));
      dialog.setAllowMultiple(false);
      dialog.setValidator(new ISelectionStatusValidator(){
        @Override public IStatus validate(        Object[] selection){
          if (selection.length == 1 && expectedType.isAssignableFrom(selection[0].getClass())) {
            return new Status(IStatus.OK,Activator.PLUGIN_ID,null);
          }
          return new Status(IStatus.ERROR,Activator.PLUGIN_ID,null);
        }
      }
);
      if (dialog.open() == IDialogConstants.OK_ID) {
        final IResource selection=(IResource)dialog.getFirstResult();
        pathText.setText(selection.getFullPath().toOSString());
        buildContextPathWorkspaceRelative=true;
      }
    }
  }
;
}",0.9705113848450916
91769,"private void createBuildContextPathGroup(final Composite container){
  final Group buildContextPathLocationGroup=new Group(container,SWT.BORDER);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,false).applyTo(buildContextPathLocationGroup);
  GridLayoutFactory.fillDefaults().margins(6,6).numColumns(3).applyTo(buildContextPathLocationGroup);
  buildContextPathLocationGroup.setText(LaunchMessages.getString(BUILD_CONTEXT_PATH_LABEL));
  this.buildContextPathText=new Text(buildContextPathLocationGroup,SWT.BORDER);
  this.buildContextPathText.addModifyListener(new LaunchConfigurationChangeListener());
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).span(3,1).applyTo(this.buildContextPathText);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).applyTo(new Label(buildContextPathLocationGroup,SWT.NONE));
  final Button browseWorkspaceButton=new Button(buildContextPathLocationGroup,SWT.NONE);
  browseWorkspaceButton.setText(LaunchMessages.getString(BROWSE_WORKSPACE));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).applyTo(browseWorkspaceButton);
  browseWorkspaceButton.addSelectionListener(onBrowseWorkspace(buildContextPathText,buildContextPathWorkspaceRelative,IContainer.class));
  final Button browseFileSystemButton=new Button(buildContextPathLocationGroup,SWT.NONE);
  browseFileSystemButton.setText(LaunchMessages.getString(BROWSE_FILESYSTEM));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).applyTo(browseFileSystemButton);
  browseFileSystemButton.addSelectionListener(onBrowseFileSystemForDirectory(this.buildContextPathText,this.buildContextPathWorkspaceRelative));
}","private void createBuildContextPathGroup(final Composite container){
  final Group buildContextPathLocationGroup=new Group(container,SWT.BORDER);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,false).applyTo(buildContextPathLocationGroup);
  GridLayoutFactory.fillDefaults().margins(6,6).numColumns(3).applyTo(buildContextPathLocationGroup);
  buildContextPathLocationGroup.setText(LaunchMessages.getString(BUILD_CONTEXT_PATH_LABEL));
  this.buildContextPathText=new Text(buildContextPathLocationGroup,SWT.BORDER);
  this.buildContextPathText.addModifyListener(new LaunchConfigurationChangeListener());
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).span(3,1).applyTo(this.buildContextPathText);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).applyTo(new Label(buildContextPathLocationGroup,SWT.NONE));
  final Button browseWorkspaceButton=new Button(buildContextPathLocationGroup,SWT.NONE);
  browseWorkspaceButton.setText(LaunchMessages.getString(BROWSE_WORKSPACE));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).applyTo(browseWorkspaceButton);
  browseWorkspaceButton.addSelectionListener(onBrowseWorkspace(buildContextPathText,IContainer.class));
  final Button browseFileSystemButton=new Button(buildContextPathLocationGroup,SWT.NONE);
  browseFileSystemButton.setText(LaunchMessages.getString(BROWSE_FILESYSTEM));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).applyTo(browseFileSystemButton);
  browseFileSystemButton.addSelectionListener(onBrowseFileSystemForDirectory(this.buildContextPathText));
}",0.9783703703703704
91770,"@Override public void initializeFrom(final ILaunchConfiguration configuration){
  try {
    this.connectionSelectionComboViewer.setSelection(new StructuredSelection(configuration.getAttribute(DOCKER_CONNECTION,""String_Node_Str"")));
    this.buildContextPathText.setText(configuration.getAttribute(SOURCE_PATH_LOCATION,""String_Node_Str""));
    this.buildContextPathWorkspaceRelative=new AtomicBoolean(configuration.getAttribute(SOURCE_PATH_WORKSPACE_RELATIVE_LOCATION,false));
    this.repoNameText.setText(configuration.getAttribute(REPO_NAME,""String_Node_Str""));
    this.quietBuildButton.setSelection(configuration.getAttribute(QUIET_BUILD,false));
    this.noCacheButton.setSelection(configuration.getAttribute(NO_CACHE,false));
    this.removeIntermediateContainersButton.setSelection(configuration.getAttribute(RM_INTERMEDIATE_CONTAINERS,false));
    this.alwaysRemoveIntermediateContainersButton.setSelection(configuration.getAttribute(FORCE_RM_INTERMEDIATE_CONTAINERS,false));
    toggleRemoveIntermediateContainersButtonState();
  }
 catch (  CoreException e) {
    Activator.log(e);
  }
}","@Override public void initializeFrom(final ILaunchConfiguration configuration){
  try {
    this.connectionSelectionComboViewer.setSelection(new StructuredSelection(configuration.getAttribute(DOCKER_CONNECTION,""String_Node_Str"")));
    this.buildContextPathText.setText(configuration.getAttribute(SOURCE_PATH_LOCATION,""String_Node_Str""));
    this.buildContextPathWorkspaceRelative=configuration.getAttribute(SOURCE_PATH_WORKSPACE_RELATIVE_LOCATION,false);
    this.repoNameText.setText(configuration.getAttribute(REPO_NAME,""String_Node_Str""));
    this.quietBuildButton.setSelection(configuration.getAttribute(QUIET_BUILD,false));
    this.noCacheButton.setSelection(configuration.getAttribute(NO_CACHE,false));
    this.removeIntermediateContainersButton.setSelection(configuration.getAttribute(RM_INTERMEDIATE_CONTAINERS,false));
    this.alwaysRemoveIntermediateContainersButton.setSelection(configuration.getAttribute(FORCE_RM_INTERMEDIATE_CONTAINERS,false));
    toggleRemoveIntermediateContainersButtonState();
  }
 catch (  CoreException e) {
    Activator.log(e);
  }
}",0.991264367816092
91771,"@Override public void performApply(final ILaunchConfigurationWorkingCopy configuration){
  final IStructuredSelection connectionSelection=(IStructuredSelection)this.connectionSelectionComboViewer.getSelection();
  if (connectionSelection.getFirstElement() != null) {
    configuration.setAttribute(DOCKER_CONNECTION,connectionSelection.getFirstElement().toString());
  }
  configuration.setAttribute(SOURCE_PATH_LOCATION,this.buildContextPathText.getText());
  configuration.setAttribute(SOURCE_PATH_WORKSPACE_RELATIVE_LOCATION,this.buildContextPathWorkspaceRelative.get());
  if (!this.repoNameText.getText().isEmpty()) {
    configuration.setAttribute(REPO_NAME,this.repoNameText.getText());
  }
  configuration.setAttribute(QUIET_BUILD,this.quietBuildButton.getSelection());
  configuration.setAttribute(NO_CACHE,this.noCacheButton.getSelection());
  configuration.setAttribute(RM_INTERMEDIATE_CONTAINERS,this.removeIntermediateContainersButton.getSelection());
  configuration.setAttribute(FORCE_RM_INTERMEDIATE_CONTAINERS,this.alwaysRemoveIntermediateContainersButton.getSelection());
}","@Override public void performApply(final ILaunchConfigurationWorkingCopy configuration){
  final IStructuredSelection connectionSelection=(IStructuredSelection)this.connectionSelectionComboViewer.getSelection();
  if (connectionSelection.getFirstElement() != null) {
    configuration.setAttribute(DOCKER_CONNECTION,connectionSelection.getFirstElement().toString());
  }
  configuration.setAttribute(SOURCE_PATH_LOCATION,this.buildContextPathText.getText());
  configuration.setAttribute(SOURCE_PATH_WORKSPACE_RELATIVE_LOCATION,this.buildContextPathWorkspaceRelative);
  if (!this.repoNameText.getText().isEmpty()) {
    configuration.setAttribute(REPO_NAME,this.repoNameText.getText());
  }
  configuration.setAttribute(QUIET_BUILD,this.quietBuildButton.getSelection());
  configuration.setAttribute(NO_CACHE,this.noCacheButton.getSelection());
  configuration.setAttribute(RM_INTERMEDIATE_CONTAINERS,this.removeIntermediateContainersButton.getSelection());
  configuration.setAttribute(FORCE_RM_INTERMEDIATE_CONTAINERS,this.alwaysRemoveIntermediateContainersButton.getSelection());
}",0.9972426470588236
91772,"/** 
 * Opens a dialog to browse the file system and select a directory
 * @return
 */
private SelectionListener onBrowseFileSystemForDirectory(final Text pathText,final AtomicBoolean workspaceRelativePath){
  return new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      final DirectoryDialog dialog=new DirectoryDialog(getShell());
      final String selection=dialog.open();
      if (selection != null) {
        pathText.setText(selection);
        workspaceRelativePath.set(false);
      }
    }
  }
;
}","/** 
 * Opens a dialog to browse the file system and select a directory
 * @return
 */
private SelectionListener onBrowseFileSystemForDirectory(final Text pathText){
  return new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      final DirectoryDialog dialog=new DirectoryDialog(getShell());
      final String selection=dialog.open();
      if (selection != null) {
        pathText.setText(selection);
        buildContextPathWorkspaceRelative=false;
      }
    }
  }
;
}",0.924510717614166
91773,"@Override public boolean equals(Object o){
  if (o instanceof VagrantVM) {
    VagrantVM other=(VagrantVM)o;
    return id.equals(other.id()) && name.equals(other.name()) && provider.equals(other.provider())&& state.equals(other.state())&& state_desc.equals(other.state_desc())&& directory.equals(other.directory());
  }
  return false;
}","@Override public boolean equals(Object o){
  if (o instanceof VagrantVM) {
    VagrantVM other=(VagrantVM)o;
    return id.equals(other.id()) && name.equals(other.name()) && provider.equals(other.provider())&& directory.equals(other.directory());
  }
  return false;
}",0.8844884488448845
91774,"private void performCreateVM(String vmName,String boxRef,String vmFile,Map<String,String> environment){
  final Job createVMJob=new Job(DVMessages.getFormattedString(CREATE_VM_MSG)){
    @Override protected IStatus run(    final IProgressMonitor monitor){
      monitor.beginTask(DVMessages.getFormattedString(CRATE_VM_TITLE,vmName),IProgressMonitor.UNKNOWN);
      IVagrantConnection connection=VagrantService.getInstance();
      IVagrantBox box=null;
      File vagrantDir;
      String boxName=boxRef;
      if (vmFile == null) {
        boolean isValidURL=true;
        try {
          new URL(boxRef);
        }
 catch (        MalformedURLException e1) {
          isValidURL=false;
        }
        if (Paths.get(boxRef).toFile().canRead() || isValidURL) {
          try {
            String boxPath=boxRef;
            boxName=boxRef.substring(boxRef.lastIndexOf(File.separator) + 1).replace(""String_Node_Str"",""String_Node_Str"");
            connection.addBox(boxName,boxPath,isValidURL);
          }
 catch (          VagrantException e) {
          }
catch (          InterruptedException e) {
          }
        }
        vagrantDir=performInit(vmName,boxName,connection);
        box=findBox(connection,boxName);
        while (box == null && isValidURL) {
          try {
            Thread.sleep(1000);
          }
 catch (          InterruptedException e) {
          }
          connection.getVMs(true);
          box=findBox(connection,boxName);
          if (monitor.isCanceled()) {
            CommandUtils.delete(vagrantDir);
            return Status.CANCEL_STATUS;
          }
        }
      }
 else {
        vagrantDir=Paths.get(vmFile).getParent().toFile();
      }
      EnvironmentsManager.getSingleton().setEnvironment(vagrantDir,environment);
      String provider=(box == null ? null : box.getProvider());
      connection.up(vagrantDir,provider);
      connection.getVMs(true);
      return Status.OK_STATUS;
    }
  }
;
  createVMJob.setUser(true);
  createVMJob.schedule();
}","private void performCreateVM(String vmName,String boxRef,String vmFile,Map<String,String> environment){
  final Job createVMJob=new Job(DVMessages.getFormattedString(CREATE_VM_MSG)){
    @Override protected IStatus run(    final IProgressMonitor monitor){
      monitor.beginTask(DVMessages.getFormattedString(CRATE_VM_TITLE,vmName),IProgressMonitor.UNKNOWN);
      IVagrantConnection connection=VagrantService.getInstance();
      if (findVM(connection,vmName) != null) {
        Display.getDefault().syncExec(() -> MessageDialog.openError(Display.getCurrent().getActiveShell(),WizardMessages.getString(""String_Node_Str""),WizardMessages.getString(""String_Node_Str"")));
        return Status.CANCEL_STATUS;
      }
      IVagrantBox box=null;
      File vagrantDir;
      String boxName=boxRef;
      if (vmFile == null) {
        boolean isValidURL=true;
        try {
          new URL(boxRef);
        }
 catch (        MalformedURLException e1) {
          isValidURL=false;
        }
        if (Paths.get(boxRef).toFile().canRead() || isValidURL) {
          try {
            String boxPath=boxRef;
            boxName=boxRef.substring(boxRef.lastIndexOf(File.separator) + 1).replace(""String_Node_Str"",""String_Node_Str"");
            connection.addBox(boxName,boxPath,isValidURL);
          }
 catch (          VagrantException e) {
          }
catch (          InterruptedException e) {
          }
        }
        vagrantDir=performInit(vmName,boxName,connection);
        box=findBox(connection,boxName);
        while (box == null && isValidURL) {
          try {
            Thread.sleep(1000);
          }
 catch (          InterruptedException e) {
          }
          connection.getVMs(true);
          box=findBox(connection,boxName);
          if (monitor.isCanceled()) {
            CommandUtils.delete(vagrantDir);
            return Status.CANCEL_STATUS;
          }
        }
      }
 else {
        vagrantDir=Paths.get(vmFile).getParent().toFile();
      }
      EnvironmentsManager.getSingleton().setEnvironment(vagrantDir,environment);
      String provider=(box == null ? null : box.getProvider());
      connection.up(vagrantDir,provider);
      connection.getVMs(true);
      return Status.OK_STATUS;
    }
  }
;
  createVMJob.setUser(true);
  createVMJob.schedule();
}",0.3171806167400881
91775,"private File performInit(String vmName,String boxName,IVagrantConnection connection){
  String stateLoc=Activator.getDefault().getStateLocation().toOSString();
  File vagrantDir=Paths.get(stateLoc,vmName).toFile();
  vagrantDir.mkdir();
  connection.init(vagrantDir);
  Path vagrantFilePath=Paths.get(stateLoc,vmName,""String_Node_Str"");
  String defaultContent;
  StringBuffer bcontent=new StringBuffer();
  try {
    defaultContent=new String(Files.readAllBytes(vagrantFilePath),StandardCharsets.UTF_8);
    for (    String line : defaultContent.split(""String_Node_Str"")) {
      if (line.contains(""String_Node_Str"")) {
        String defLine=line.replaceAll(""String_Node_Str"",""String_Node_Str"" + vmName);
        String boxLine=line.replaceAll(""String_Node_Str"",""String_Node_Str"" + boxName + ""String_Node_Str"");
        bcontent.append(defLine + '\n');
        bcontent.append(boxLine + '\n');
      }
 else {
        bcontent.append(line + '\n');
      }
    }
    Files.write(vagrantFilePath,bcontent.toString().getBytes(StandardCharsets.UTF_8));
  }
 catch (  IOException e) {
  }
  return vagrantDir;
}","private File performInit(String vmName,String boxName,IVagrantConnection connection){
  String stateLoc=Activator.getDefault().getStateLocation().toOSString();
  File vagrantDir=Paths.get(stateLoc,vmName).toFile();
  if (!vagrantDir.mkdir()) {
    CommandUtils.delete(vagrantDir);
    vagrantDir.mkdir();
  }
  connection.init(vagrantDir);
  Path vagrantFilePath=Paths.get(stateLoc,vmName,""String_Node_Str"");
  String defaultContent;
  StringBuffer bcontent=new StringBuffer();
  try {
    defaultContent=new String(Files.readAllBytes(vagrantFilePath),StandardCharsets.UTF_8);
    for (    String line : defaultContent.split(""String_Node_Str"")) {
      if (line.contains(""String_Node_Str"")) {
        String defLine=line.replaceAll(""String_Node_Str"",""String_Node_Str"" + vmName + ""String_Node_Str"");
        String boxLine=line.replaceAll(""String_Node_Str"",""String_Node_Str"" + boxName + ""String_Node_Str"");
        bcontent.append(defLine + '\n');
        bcontent.append(boxLine + '\n');
      }
 else {
        bcontent.append(line + '\n');
      }
    }
    Files.write(vagrantFilePath,bcontent.toString().getBytes(StandardCharsets.UTF_8));
  }
 catch (  IOException e) {
  }
  return vagrantDir;
}",0.9592720970537262
91776,"@Override protected IStatus run(final IProgressMonitor monitor){
  monitor.beginTask(DVMessages.getFormattedString(CRATE_VM_TITLE,vmName),IProgressMonitor.UNKNOWN);
  IVagrantConnection connection=VagrantService.getInstance();
  IVagrantBox box=null;
  File vagrantDir;
  String boxName=boxRef;
  if (vmFile == null) {
    boolean isValidURL=true;
    try {
      new URL(boxRef);
    }
 catch (    MalformedURLException e1) {
      isValidURL=false;
    }
    if (Paths.get(boxRef).toFile().canRead() || isValidURL) {
      try {
        String boxPath=boxRef;
        boxName=boxRef.substring(boxRef.lastIndexOf(File.separator) + 1).replace(""String_Node_Str"",""String_Node_Str"");
        connection.addBox(boxName,boxPath,isValidURL);
      }
 catch (      VagrantException e) {
      }
catch (      InterruptedException e) {
      }
    }
    vagrantDir=performInit(vmName,boxName,connection);
    box=findBox(connection,boxName);
    while (box == null && isValidURL) {
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException e) {
      }
      connection.getVMs(true);
      box=findBox(connection,boxName);
      if (monitor.isCanceled()) {
        CommandUtils.delete(vagrantDir);
        return Status.CANCEL_STATUS;
      }
    }
  }
 else {
    vagrantDir=Paths.get(vmFile).getParent().toFile();
  }
  EnvironmentsManager.getSingleton().setEnvironment(vagrantDir,environment);
  String provider=(box == null ? null : box.getProvider());
  connection.up(vagrantDir,provider);
  connection.getVMs(true);
  return Status.OK_STATUS;
}","@Override protected IStatus run(final IProgressMonitor monitor){
  monitor.beginTask(DVMessages.getFormattedString(CRATE_VM_TITLE,vmName),IProgressMonitor.UNKNOWN);
  IVagrantConnection connection=VagrantService.getInstance();
  if (findVM(connection,vmName) != null) {
    Display.getDefault().syncExec(() -> MessageDialog.openError(Display.getCurrent().getActiveShell(),WizardMessages.getString(""String_Node_Str""),WizardMessages.getString(""String_Node_Str"")));
    return Status.CANCEL_STATUS;
  }
  IVagrantBox box=null;
  File vagrantDir;
  String boxName=boxRef;
  if (vmFile == null) {
    boolean isValidURL=true;
    try {
      new URL(boxRef);
    }
 catch (    MalformedURLException e1) {
      isValidURL=false;
    }
    if (Paths.get(boxRef).toFile().canRead() || isValidURL) {
      try {
        String boxPath=boxRef;
        boxName=boxRef.substring(boxRef.lastIndexOf(File.separator) + 1).replace(""String_Node_Str"",""String_Node_Str"");
        connection.addBox(boxName,boxPath,isValidURL);
      }
 catch (      VagrantException e) {
      }
catch (      InterruptedException e) {
      }
    }
    vagrantDir=performInit(vmName,boxName,connection);
    box=findBox(connection,boxName);
    while (box == null && isValidURL) {
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException e) {
      }
      connection.getVMs(true);
      box=findBox(connection,boxName);
      if (monitor.isCanceled()) {
        CommandUtils.delete(vagrantDir);
        return Status.CANCEL_STATUS;
      }
    }
  }
 else {
    vagrantDir=Paths.get(vmFile).getParent().toFile();
  }
  EnvironmentsManager.getSingleton().setEnvironment(vagrantDir,environment);
  String provider=(box == null ? null : box.getProvider());
  connection.up(vagrantDir,provider);
  connection.getVMs(true);
  return Status.OK_STATUS;
}",0.231424375917768
91777,"@Override public void widgetSelected(final SelectionEvent e){
  FileDialog fd=new FileDialog(getShell());
  String location=fd.open();
  if (location != null && !location.isEmpty()) {
    if (location.endsWith(""String_Node_Str"")) {
      model.setBoxRef(location);
    }
 else {
      model.setVMFile(location);
      vmFileChanged(location);
    }
  }
}","@Override public void widgetSelected(final SelectionEvent e){
  FileDialog fd=new FileDialog(getShell());
  String location=fd.open();
  if (location != null && !location.isEmpty()) {
    model.setVMFile(location);
    vmFileChanged(location);
  }
}",0.8258706467661692
91778,"/** 
 * Opens the   {@link ImageSearch} dialog with current image name pre-filled.
 * @return
 */
private SelectionListener onSearchImage(){
  return new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      FileDialog fd=new FileDialog(getShell());
      String location=fd.open();
      if (location != null && !location.isEmpty()) {
        if (location.endsWith(""String_Node_Str"")) {
          model.setBoxRef(location);
        }
 else {
          model.setVMFile(location);
          vmFileChanged(location);
        }
      }
    }
  }
;
}","private SelectionListener onSearchImage(){
  return new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent e){
      FileDialog fd=new FileDialog(getShell());
      String location=fd.open();
      if (location != null && !location.isEmpty()) {
        model.setBoxRef(location);
      }
    }
  }
;
}",0.7077922077922078
91779,"@Override public void createControl(Composite parent){
  ScrolledComposite scrollTop=new ScrolledComposite(parent,SWT.H_SCROLL | SWT.V_SCROLL);
  scrollTop.setExpandVertical(true);
  scrollTop.setExpandHorizontal(true);
  final Composite container=new Composite(scrollTop,SWT.NONE);
  GridLayoutFactory.fillDefaults().numColumns(3).margins(6,6).applyTo(container);
  final Label vmNameLabel=new Label(container,SWT.NONE);
  vmNameLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).applyTo(vmNameLabel);
  final Text vmNameText=new Text(container,SWT.BORDER);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).span(2,1).applyTo(vmNameText);
  vmNameText.setToolTipText(WizardMessages.getString(""String_Node_Str""));
  final IObservableValue<String> vmmNameObservable=BeanProperties.value(CreateVMPageModel.class,CreateVMPageModel.VM_NAME).observe(model);
  dbc.bindValue(WidgetProperties.text(SWT.Modify).observe(vmNameText),vmmNameObservable);
  final Label boxRefLabel=new Label(container,SWT.NONE);
  boxRefLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).applyTo(boxRefLabel);
  final Text boxRefText=new Text(container,SWT.BORDER);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).applyTo(boxRefText);
  boxRefText.setToolTipText(WizardMessages.getString(""String_Node_Str""));
  final IObservableValue<String> boxRefObservable=BeanProperties.value(CreateVMPageModel.class,CreateVMPageModel.BOX_REF).observe(model);
  dbc.bindValue(WidgetProperties.text(SWT.Modify).observe(boxRefText),boxRefObservable);
  final Button boxSearchButton=new Button(container,SWT.NONE);
  boxSearchButton.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).applyTo(boxSearchButton);
  boxSearchButton.addSelectionListener(onSearchImage());
  final Button customVMFileButton=new Button(container,SWT.CHECK);
  customVMFileButton.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).span(3,1).applyTo(customVMFileButton);
  final IObservableValue<String> customVMFileObservable=BeanProperties.value(CreateVMPageModel.class,CreateVMPageModel.V_FILE_MODE).observe(model);
  dbc.bindValue(WidgetProperties.selection().observe(customVMFileButton),customVMFileObservable);
  final Label boxLocLabel=new Label(container,SWT.NONE);
  boxLocLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).applyTo(boxLocLabel);
  final Text boxLocText=new Text(container,SWT.BORDER);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).applyTo(boxLocText);
  boxLocText.setToolTipText(WizardMessages.getString(""String_Node_Str""));
  boxLocText.setEnabled(false);
  final IObservableValue<String> boxLocObservable=BeanProperties.value(CreateVMPageModel.class,CreateVMPageModel.VM_FILE).observe(model);
  dbc.bindValue(WidgetProperties.text(SWT.Modify).observe(boxLocText),boxLocObservable);
  boxLocText.addModifyListener(e -> vmFileChanged(boxLocText.getText()));
  final Button vgFilesearchButton=new Button(container,SWT.NONE);
  vgFilesearchButton.setText(WizardMessages.getString(""String_Node_Str""));
  vgFilesearchButton.setEnabled(false);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).applyTo(vgFilesearchButton);
  vgFilesearchButton.addSelectionListener(onSearchImage());
  customVMFileButton.addSelectionListener(onCheckCustomVMFile(vmNameText,boxRefText,boxLocText,vgFilesearchButton,boxSearchButton));
  dbc.addValidationStatusProvider(new CreateVMValidationStatusProvider(vmmNameObservable,boxRefObservable,boxLocObservable));
  advanced=new CreateVMAdvancedComposite(container,scrollTop,model);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).span(3,1).grab(true,false).applyTo(advanced);
  WizardPageSupport.create(this,dbc);
  scrollTop.setContent(container);
  Point point=container.computeSize(SWT.DEFAULT,SWT.DEFAULT);
  scrollTop.setSize(point);
  scrollTop.setMinSize(point);
  setControl(container);
}","@Override public void createControl(Composite parent){
  ScrolledComposite scrollTop=new ScrolledComposite(parent,SWT.H_SCROLL | SWT.V_SCROLL);
  scrollTop.setExpandVertical(true);
  scrollTop.setExpandHorizontal(true);
  final Composite container=new Composite(scrollTop,SWT.NONE);
  GridLayoutFactory.fillDefaults().numColumns(3).margins(6,6).applyTo(container);
  final Label vmNameLabel=new Label(container,SWT.NONE);
  vmNameLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).applyTo(vmNameLabel);
  final Text vmNameText=new Text(container,SWT.BORDER);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).span(2,1).applyTo(vmNameText);
  vmNameText.setToolTipText(WizardMessages.getString(""String_Node_Str""));
  final IObservableValue<String> vmmNameObservable=BeanProperties.value(CreateVMPageModel.class,CreateVMPageModel.VM_NAME).observe(model);
  dbc.bindValue(WidgetProperties.text(SWT.Modify).observe(vmNameText),vmmNameObservable);
  final Label boxRefLabel=new Label(container,SWT.NONE);
  boxRefLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).applyTo(boxRefLabel);
  final Text boxRefText=new Text(container,SWT.BORDER);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).applyTo(boxRefText);
  boxRefText.setToolTipText(WizardMessages.getString(""String_Node_Str""));
  final IObservableValue<String> boxRefObservable=BeanProperties.value(CreateVMPageModel.class,CreateVMPageModel.BOX_REF).observe(model);
  dbc.bindValue(WidgetProperties.text(SWT.Modify).observe(boxRefText),boxRefObservable);
  final Button boxSearchButton=new Button(container,SWT.NONE);
  boxSearchButton.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).applyTo(boxSearchButton);
  boxSearchButton.addSelectionListener(onSearchImage());
  final Button customVMFileButton=new Button(container,SWT.CHECK);
  customVMFileButton.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).span(3,1).applyTo(customVMFileButton);
  final IObservableValue<String> customVMFileObservable=BeanProperties.value(CreateVMPageModel.class,CreateVMPageModel.V_FILE_MODE).observe(model);
  dbc.bindValue(WidgetProperties.selection().observe(customVMFileButton),customVMFileObservable);
  final Label boxLocLabel=new Label(container,SWT.NONE);
  boxLocLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).applyTo(boxLocLabel);
  final Text boxLocText=new Text(container,SWT.BORDER);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).applyTo(boxLocText);
  boxLocText.setToolTipText(WizardMessages.getString(""String_Node_Str""));
  boxLocText.setEnabled(false);
  final IObservableValue<String> boxLocObservable=BeanProperties.value(CreateVMPageModel.class,CreateVMPageModel.VM_FILE).observe(model);
  dbc.bindValue(WidgetProperties.text(SWT.Modify).observe(boxLocText),boxLocObservable);
  boxLocText.addModifyListener(e -> vmFileChanged(boxLocText.getText()));
  final Button vgFilesearchButton=new Button(container,SWT.NONE);
  vgFilesearchButton.setText(WizardMessages.getString(""String_Node_Str""));
  vgFilesearchButton.setEnabled(false);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(false,false).applyTo(vgFilesearchButton);
  vgFilesearchButton.addSelectionListener(onSearchVMFile());
  customVMFileButton.addSelectionListener(onCheckCustomVMFile(vmNameText,boxRefText,boxLocText,vgFilesearchButton,boxSearchButton));
  dbc.addValidationStatusProvider(new CreateVMValidationStatusProvider(vmmNameObservable,boxRefObservable,boxLocObservable));
  advanced=new CreateVMAdvancedComposite(container,scrollTop,model);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).span(3,1).grab(true,false).applyTo(advanced);
  WizardPageSupport.create(this,dbc);
  scrollTop.setContent(container);
  Point point=container.computeSize(SWT.DEFAULT,SWT.DEFAULT);
  scrollTop.setSize(point);
  scrollTop.setMinSize(point);
  setControl(container);
}",0.9989598983011672
91780,"@Override public Object execute(final ExecutionEvent event){
  final IWorkbenchPart activePart=HandlerUtil.getActivePart(event);
  final List<IDockerPortMapping> portMappings=getSelectedPortMappings(activePart);
  if (portMappings == null || portMappings.isEmpty()) {
    return null;
  }
  final Job job=new Job(CommandMessages.getString(""String_Node_Str"")){
    @Override protected IStatus run(    final IProgressMonitor monitor){
      try {
        final IDockerConnection currentConnection=getCurrentConnection(activePart);
        final IDockerPortMapping selectedPort=portMappings.get(0);
        final URI connectionURI=new URI(currentConnection.getUri());
        if (""String_Node_Str"".equalsIgnoreCase(connectionURI.getScheme()) || ""String_Node_Str"".equalsIgnoreCase(connectionURI.getScheme()) || ""String_Node_Str"".equalsIgnoreCase(connectionURI.getScheme())|| ""String_Node_Str"".equalsIgnoreCase(connectionURI.getScheme())) {
          final String host=connectionURI.getHost();
          final URL location=new URL(""String_Node_Str"",host,selectedPort.getPublicPort(),""String_Node_Str"");
          openLocationInWebBrowser(location);
        }
      }
 catch (      URISyntaxException|MalformedURLException e) {
        Activator.logErrorMessage(CommandMessages.getString(""String_Node_Str""),e);
      }
      monitor.done();
      return Status.OK_STATUS;
    }
  }
;
  job.setUser(true);
  job.schedule();
  return null;
}","@Override public Object execute(final ExecutionEvent event){
  final IWorkbenchPart activePart=HandlerUtil.getActivePart(event);
  final List<IDockerPortMapping> portMappings=getSelectedPortMappings(activePart);
  if (portMappings == null || portMappings.isEmpty()) {
    return null;
  }
  final Job job=new Job(CommandMessages.getString(""String_Node_Str"")){
    @Override protected IStatus run(    final IProgressMonitor monitor){
      try {
        final IDockerConnection currentConnection=getCurrentConnection(activePart);
        final IDockerPortMapping selectedPort=portMappings.get(0);
        final URI connectionURI=new URI(currentConnection.getUri());
        if (""String_Node_Str"".equalsIgnoreCase(connectionURI.getScheme()) || ""String_Node_Str"".equalsIgnoreCase(connectionURI.getScheme()) || ""String_Node_Str"".equalsIgnoreCase(connectionURI.getScheme())|| ""String_Node_Str"".equalsIgnoreCase(connectionURI.getScheme())) {
          final String host=""String_Node_Str"".equalsIgnoreCase(connectionURI.getScheme()) ? ""String_Node_Str"" : connectionURI.getHost();
          final URL location=new URL(""String_Node_Str"",host,selectedPort.getPublicPort(),""String_Node_Str"");
          openLocationInWebBrowser(location);
        }
      }
 catch (      URISyntaxException|MalformedURLException e) {
        Activator.logErrorMessage(CommandMessages.getString(""String_Node_Str""),e);
      }
      monitor.done();
      return Status.OK_STATUS;
    }
  }
;
  job.setUser(true);
  job.schedule();
  return null;
}",0.9715254237288136
91781,"/** 
 * Find the location of 'vagrant' on the system by looking under the environment PATH.
 * @return The location of 'vagrant' as a string if it exists underthe PATH, or null if it could not be found.
 */
public static String findVagrantPath(){
  final String envPath=System.getenv(""String_Node_Str"");
  if (envPath != null) {
    for (    String dir : envPath.split(File.pathSeparator)) {
      Path vgPath=Paths.get(dir,VG);
      if (vgPath.toFile().exists()) {
        return vgPath.toString();
      }
    }
  }
  return null;
}","/** 
 * Find the location of 'vagrant' on the system by looking under the environment PATH.
 * @return The location of 'vagrant' as a string if it exists underthe PATH, or null if it could not be found.
 */
public static String findVagrantPath(){
  final String envPath=System.getenv(""String_Node_Str"");
  if (envPath != null) {
    for (    String dir : envPath.split(File.pathSeparator)) {
      final String vgName=Platform.OS_WIN32.equals(Platform.getOS()) ? VG + ""String_Node_Str"" : VG;
      Path vgPath=Paths.get(dir,vgName);
      if (vgPath.toFile().exists()) {
        return vgPath.toString();
      }
    }
  }
  return null;
}",0.868824531516184
91782,"@Override public void run(){
  final ISelection currentSelection=DockerContainersView.this.viewer.getSelection();
  DockerContainersView.this.viewer.refresh();
  if (currentSelection != null) {
    DockerContainersView.this.viewer.setSelection(currentSelection);
  }
  refreshViewTitle();
}","@Override public void run(){
  DockerContainersView.this.viewer.refresh();
  refreshViewTitle();
}",0.5051546391752577
91783,"@Override public void listChanged(final IDockerConnection connection,final List<IDockerContainer> containers){
  if (connection.getName().equals(connection.getName())) {
    Display.getDefault().asyncExec(new Runnable(){
      @Override public void run(){
        final ISelection currentSelection=DockerContainersView.this.viewer.getSelection();
        DockerContainersView.this.viewer.refresh();
        if (currentSelection != null) {
          DockerContainersView.this.viewer.setSelection(currentSelection);
        }
        refreshViewTitle();
      }
    }
);
  }
}","@Override public void listChanged(final IDockerConnection connection,final List<IDockerContainer> containers){
  if (connection.getName().equals(connection.getName())) {
    Display.getDefault().asyncExec(new Runnable(){
      @Override public void run(){
        DockerContainersView.this.viewer.refresh();
        refreshViewTitle();
      }
    }
);
  }
}",0.7532188841201717
91784,"private void refresh(final IDockerConnection connection){
  Display.getDefault().asyncExec(new Runnable(){
    @Override public void run(){
      final ISelection selection=getCommonViewer().getSelection();
      getCommonViewer().refresh(connection,true);
      if (selection != null) {
        getCommonViewer().setSelection(selection,false);
      }
    }
  }
);
}","private void refresh(final IDockerConnection connection){
  Display.getDefault().asyncExec(new Runnable(){
    @Override public void run(){
      getCommonViewer().refresh(connection,true);
    }
  }
);
}",0.6129597197898424
91785,"@Override public void run(){
  final ISelection selection=getCommonViewer().getSelection();
  getCommonViewer().refresh(connection,true);
  if (selection != null) {
    getCommonViewer().setSelection(selection,false);
  }
}","@Override public void run(){
  getCommonViewer().refresh(connection,true);
}",0.5083612040133779
91786,"@Override public void run(){
  final ISelection currentSelection=DockerImagesView.this.viewer.getSelection();
  DockerImagesView.this.viewer.refresh();
  if (currentSelection != null) {
    DockerImagesView.this.viewer.setSelection(currentSelection);
  }
  refreshViewTitle();
}","@Override public void run(){
  DockerImagesView.this.viewer.refresh();
  refreshViewTitle();
}",0.5053763440860215
91787,"@Override public void listChanged(final IDockerConnection connection,final List<IDockerImage> images){
  if (connection.getName().equals(connection.getName())) {
    Display.getDefault().asyncExec(new Runnable(){
      @Override public void run(){
        final ISelection currentSelection=DockerImagesView.this.viewer.getSelection();
        DockerImagesView.this.viewer.refresh();
        if (currentSelection != null) {
          DockerImagesView.this.viewer.setSelection(currentSelection);
        }
        refreshViewTitle();
      }
    }
);
  }
}","@Override public void listChanged(final IDockerConnection connection,final List<IDockerImage> images){
  if (connection.getName().equals(connection.getName())) {
    Display.getDefault().asyncExec(new Runnable(){
      @Override public void run(){
        DockerImagesView.this.viewer.refresh();
        refreshViewTitle();
      }
    }
);
  }
}",0.74
91788,"@Override public void launch(ILaunchConfiguration config,String mode,ILaunch launch,IProgressMonitor monitor) throws CoreException {
  try {
    ConfigUtils configUtils=new ConfigUtils(config);
    project=configUtils.getProject();
    if (!PerfCore.checkPerfInPath(project)) {
      IStatus status=new Status(IStatus.ERROR,PerfPlugin.PLUGIN_ID,""String_Node_Str"");
      throw new CoreException(status);
    }
    URI workingDirURI=new URI(config.getAttribute(RemoteProxyCMainTab.ATTR_REMOTE_WORKING_DIRECTORY_NAME,EMPTY_STRING));
    if (workingDirURI.toString().equals(EMPTY_STRING)) {
      workingDirURI=getWorkingDirectory(config).toURI();
      workingDirPath=Path.fromPortableString(workingDirURI.getPath());
      binPath=CDebugUtils.verifyProgramPath(config);
    }
 else {
      workingDirPath=Path.fromPortableString(workingDirURI.getPath() + IPath.SEPARATOR);
      URI binURI=new URI(configUtils.getExecutablePath());
      binPath=Path.fromPortableString(binURI.getPath().toString());
    }
    PerfPlugin.getDefault().setWorkingDir(workingDirPath);
    if (config.getAttribute(PerfPlugin.ATTR_ShowStat,PerfPlugin.ATTR_ShowStat_default)) {
      showStat(config,launch);
    }
 else {
      String perfPathString=RuntimeProcessFactory.getFactory().whichCommand(PerfPlugin.PERF_COMMAND,project);
      IFileStore workingDir;
      RemoteConnection workingDirRC=new RemoteConnection(workingDirURI);
      IRemoteFileProxy workingDirRFP=workingDirRC.getRmtFileProxy();
      workingDir=workingDirRFP.getResource(workingDirURI.getPath());
      String arguments[]=getProgramArgumentsArray(config);
      ArrayList<String> command=new ArrayList<>(4 + arguments.length);
      command.addAll(Arrays.asList(PerfCore.getRecordString(config)));
      command.add(binPath.toPortableString());
      command.set(0,perfPathString);
      command.add(2,OUTPUT_STR + PerfPlugin.PERF_DEFAULT_DATA);
      command.addAll(Arrays.asList(arguments));
      String[] commandArray=command.toArray(new String[command.size()]);
      Process pProxy=RuntimeProcessFactory.getFactory().exec(commandArray,getEnvironment(config),workingDir,project);
      MessageConsole console=new MessageConsole(""String_Node_Str"",null);
      console.activate();
      ConsolePlugin.getDefault().getConsoleManager().addConsoles(new IConsole[]{console});
      MessageConsoleStream stream=console.newMessageStream();
      if (pProxy != null) {
        try (BufferedReader error=new BufferedReader(new InputStreamReader(pProxy.getErrorStream()))){
          String err=error.readLine();
          while (err != null) {
            stream.println(err);
            err=error.readLine();
          }
        }
       }
      pProxy.destroy();
      PrintStream print=null;
      if (config.getAttribute(IDebugUIConstants.ATTR_CAPTURE_IN_CONSOLE,true)) {
        ConsolePlugin plugin=ConsolePlugin.getDefault();
        IConsoleManager conMan=plugin.getConsoleManager();
        IConsole[] existing=conMan.getConsoles();
        IOConsole binaryOutCons=null;
        for (        IConsole x : existing) {
          if (x.getName().contains(renderProcessLabel(commandArray[0]))) {
            binaryOutCons=(IOConsole)x;
          }
        }
        if ((binaryOutCons == null) && (existing.length != 0)) {
          if (existing[existing.length - 1] instanceof IOConsole)           binaryOutCons=(IOConsole)existing[existing.length - 1];
        }
        OutputStream outputTo;
        if (binaryOutCons != null) {
          outputTo=binaryOutCons.newOutputStream();
          print=new PrintStream(outputTo);
        }
        for (int i=0; i < command.size(); i++) {
          print.print(command.get(i) + ""String_Node_Str"");
        }
        print.println();
        print.println(""String_Node_Str"");
      }
      PerfCore.report(config,workingDirPath,monitor,null,print);
      URI perfDataURI=null;
      IRemoteFileProxy proxy=null;
      perfDataURI=new URI(workingDirURI.toString() + IPath.SEPARATOR + PerfPlugin.PERF_DEFAULT_DATA);
      proxy=RemoteProxyManager.getInstance().getFileProxy(perfDataURI);
      IFileStore perfDataFileStore=proxy.getResource(perfDataURI.getPath());
      IFileInfo info=perfDataFileStore.fetchInfo();
      info.setAttribute(EFS.ATTRIBUTE_READ_ONLY,true);
      perfDataFileStore.putInfo(info,EFS.SET_ATTRIBUTES,null);
      PerfCore.refreshView(renderProcessLabel(binPath.toPortableString()));
      if (config.getAttribute(PerfPlugin.ATTR_ShowSourceDisassembly,PerfPlugin.ATTR_ShowSourceDisassembly_default)) {
        showSourceDisassembly(Path.fromPortableString(workingDirURI.toString() + IPath.SEPARATOR));
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    abort(e.getLocalizedMessage(),null,ICDTLaunchConfigurationConstants.ERR_INTERNAL_ERROR);
  }
catch (  RemoteConnectionException e) {
    e.printStackTrace();
    abort(e.getLocalizedMessage(),null,ICDTLaunchConfigurationConstants.ERR_INTERNAL_ERROR);
  }
catch (  URISyntaxException e) {
    e.printStackTrace();
    abort(e.getLocalizedMessage(),null,ICDTLaunchConfigurationConstants.ERR_INTERNAL_ERROR);
  }
}","@Override public void launch(ILaunchConfiguration config,String mode,ILaunch launch,IProgressMonitor monitor) throws CoreException {
  try {
    ConfigUtils configUtils=new ConfigUtils(config);
    project=configUtils.getProject();
    PerfPlugin.getDefault().setProfiledProject(project);
    if (!PerfCore.checkPerfInPath(project)) {
      IStatus status=new Status(IStatus.ERROR,PerfPlugin.PLUGIN_ID,""String_Node_Str"");
      throw new CoreException(status);
    }
    URI workingDirURI=new URI(config.getAttribute(RemoteProxyCMainTab.ATTR_REMOTE_WORKING_DIRECTORY_NAME,EMPTY_STRING));
    if (workingDirURI.toString().equals(EMPTY_STRING)) {
      workingDirURI=getWorkingDirectory(config).toURI();
      workingDirPath=Path.fromPortableString(workingDirURI.getPath());
      binPath=CDebugUtils.verifyProgramPath(config);
    }
 else {
      workingDirPath=Path.fromPortableString(workingDirURI.getPath() + IPath.SEPARATOR);
      URI binURI=new URI(configUtils.getExecutablePath());
      binPath=Path.fromPortableString(binURI.getPath().toString());
    }
    PerfPlugin.getDefault().setWorkingDir(workingDirPath);
    if (config.getAttribute(PerfPlugin.ATTR_ShowStat,PerfPlugin.ATTR_ShowStat_default)) {
      showStat(config,launch);
    }
 else {
      String perfPathString=RuntimeProcessFactory.getFactory().whichCommand(PerfPlugin.PERF_COMMAND,project);
      IFileStore workingDir;
      RemoteConnection workingDirRC=new RemoteConnection(workingDirURI);
      IRemoteFileProxy workingDirRFP=workingDirRC.getRmtFileProxy();
      workingDir=workingDirRFP.getResource(workingDirURI.getPath());
      String arguments[]=getProgramArgumentsArray(config);
      ArrayList<String> command=new ArrayList<>(4 + arguments.length);
      command.addAll(Arrays.asList(PerfCore.getRecordString(config)));
      command.add(binPath.toPortableString());
      command.set(0,perfPathString);
      command.add(2,OUTPUT_STR + PerfPlugin.PERF_DEFAULT_DATA);
      command.addAll(Arrays.asList(arguments));
      String[] commandArray=command.toArray(new String[command.size()]);
      Process pProxy=RuntimeProcessFactory.getFactory().exec(commandArray,getEnvironment(config),workingDir,project);
      MessageConsole console=new MessageConsole(""String_Node_Str"",null);
      console.activate();
      ConsolePlugin.getDefault().getConsoleManager().addConsoles(new IConsole[]{console});
      MessageConsoleStream stream=console.newMessageStream();
      if (pProxy != null) {
        try (BufferedReader error=new BufferedReader(new InputStreamReader(pProxy.getErrorStream()))){
          String err=error.readLine();
          while (err != null) {
            stream.println(err);
            err=error.readLine();
          }
        }
       }
      pProxy.destroy();
      PrintStream print=null;
      if (config.getAttribute(IDebugUIConstants.ATTR_CAPTURE_IN_CONSOLE,true)) {
        ConsolePlugin plugin=ConsolePlugin.getDefault();
        IConsoleManager conMan=plugin.getConsoleManager();
        IConsole[] existing=conMan.getConsoles();
        IOConsole binaryOutCons=null;
        for (        IConsole x : existing) {
          if (x.getName().contains(renderProcessLabel(commandArray[0]))) {
            binaryOutCons=(IOConsole)x;
          }
        }
        if ((binaryOutCons == null) && (existing.length != 0)) {
          if (existing[existing.length - 1] instanceof IOConsole)           binaryOutCons=(IOConsole)existing[existing.length - 1];
        }
        OutputStream outputTo;
        if (binaryOutCons != null) {
          outputTo=binaryOutCons.newOutputStream();
          print=new PrintStream(outputTo);
        }
        for (int i=0; i < command.size(); i++) {
          print.print(command.get(i) + ""String_Node_Str"");
        }
        print.println();
        print.println(""String_Node_Str"");
      }
      PerfCore.report(config,workingDirPath,monitor,null,print);
      URI perfDataURI=null;
      IRemoteFileProxy proxy=null;
      perfDataURI=new URI(workingDirURI.toString() + IPath.SEPARATOR + PerfPlugin.PERF_DEFAULT_DATA);
      proxy=RemoteProxyManager.getInstance().getFileProxy(perfDataURI);
      IFileStore perfDataFileStore=proxy.getResource(perfDataURI.getPath());
      IFileInfo info=perfDataFileStore.fetchInfo();
      info.setAttribute(EFS.ATTRIBUTE_READ_ONLY,true);
      perfDataFileStore.putInfo(info,EFS.SET_ATTRIBUTES,null);
      PerfCore.refreshView(renderProcessLabel(binPath.toPortableString()));
      if (config.getAttribute(PerfPlugin.ATTR_ShowSourceDisassembly,PerfPlugin.ATTR_ShowSourceDisassembly_default)) {
        showSourceDisassembly(Path.fromPortableString(workingDirURI.toString() + IPath.SEPARATOR));
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    abort(e.getLocalizedMessage(),null,ICDTLaunchConfigurationConstants.ERR_INTERNAL_ERROR);
  }
catch (  RemoteConnectionException e) {
    e.printStackTrace();
    abort(e.getLocalizedMessage(),null,ICDTLaunchConfigurationConstants.ERR_INTERNAL_ERROR);
  }
catch (  URISyntaxException e) {
    e.printStackTrace();
    abort(e.getLocalizedMessage(),null,ICDTLaunchConfigurationConstants.ERR_INTERNAL_ERROR);
  }
}",0.9944557922381092
91789,"@Override public void run(){
  ISelection selection=viewer.getSelection();
  Object obj=((IStructuredSelection)selection).getFirstElement();
  try {
    if (obj instanceof PMLineRef) {
      PMLineRef line=(PMLineRef)obj;
      PMFile file=(PMFile)((PMSymbol)line.getParent()).getParent();
      ProfileUIUtils.openEditorAndSelect(file.getPath(),Integer.parseInt(line.getName()));
    }
 else     if (obj instanceof PMFile) {
      PMFile file=(PMFile)obj;
      ProfileUIUtils.openEditorAndSelect(file.getName(),1);
    }
 else     if (obj instanceof PMSymbol) {
      PMSymbol sym=(PMSymbol)obj;
      PMFile file=(PMFile)sym.getParent();
      PMDso dso=(PMDso)file.getParent();
      if (file.getName().equals(PerfPlugin.STRINGS_UnfiledSymbols))       return;
      String binaryPath=dso.getPath();
      ICProject project;
      project=ProfileUIUtils.findCProjectWithAbsolutePath(binaryPath);
      Map<String,int[]> map=ProfileUIUtils.findFunctionsInProject(project,sym.getFunctionName(),-1,file.getPath(),true);
      boolean bFound=false;
      for (      Map.Entry<String,int[]> entry : map.entrySet()) {
        ProfileUIUtils.openEditorAndSelect(entry.getKey(),entry.getValue()[0],entry.getValue()[1]);
        bFound=true;
      }
      if (!bFound) {
        ProfileUIUtils.openEditorAndSelect(file.getPath(),1,ResourcesPlugin.getWorkspace().getRoot().getProject(dso.getName()));
      }
    }
  }
 catch (  NumberFormatException|BadLocationException|CoreException e) {
  }
}","@Override public void run(){
  ISelection selection=viewer.getSelection();
  Object obj=((IStructuredSelection)selection).getFirstElement();
  try {
    if (obj instanceof PMLineRef) {
      PMLineRef line=(PMLineRef)obj;
      PMFile file=(PMFile)((PMSymbol)line.getParent()).getParent();
      ProfileUIUtils.openEditorAndSelect(file.getPath(),Integer.parseInt(line.getName()),PerfPlugin.getDefault().getProfiledProject());
    }
 else     if (obj instanceof PMFile) {
      PMFile file=(PMFile)obj;
      ProfileUIUtils.openEditorAndSelect(file.getName(),1);
    }
 else     if (obj instanceof PMSymbol) {
      PMSymbol sym=(PMSymbol)obj;
      PMFile file=(PMFile)sym.getParent();
      PMDso dso=(PMDso)file.getParent();
      if (file.getName().equals(PerfPlugin.STRINGS_UnfiledSymbols))       return;
      String binaryPath=dso.getPath();
      ICProject project;
      project=ProfileUIUtils.findCProjectWithAbsolutePath(binaryPath);
      Map<String,int[]> map=ProfileUIUtils.findFunctionsInProject(project,sym.getFunctionName(),-1,file.getPath(),true);
      boolean bFound=false;
      for (      Map.Entry<String,int[]> entry : map.entrySet()) {
        ProfileUIUtils.openEditorAndSelect(entry.getKey(),entry.getValue()[0],entry.getValue()[1]);
        bFound=true;
      }
      if (!bFound) {
        ProfileUIUtils.openEditorAndSelect(file.getPath(),1,ResourcesPlugin.getWorkspace().getRoot().getProject(dso.getName()));
      }
    }
  }
 catch (  NumberFormatException|BadLocationException|CoreException e) {
  }
}",0.9851141250413497
91790,"@Override public void launch(final ILaunchConfiguration config,String mode,final ILaunch launch,IProgressMonitor m) throws CoreException {
  if (m == null) {
    m=new NullProgressMonitor();
  }
  process=null;
  SubMonitor monitor=SubMonitor.convert(m,Messages.getString(""String_Node_Str""),10);
  if (monitor.isCanceled()) {
    return;
  }
  this.config=config;
  this.launch=launch;
  try {
    ValgrindUIPlugin.getDefault().resetView();
    getPlugin().setCurrentLaunchConfiguration(null);
    getPlugin().setCurrentLaunch(null);
    this.configUtils=new ConfigUtils(config);
    IProject project=configUtils.getProject();
    ValgrindUIPlugin.getDefault().setProfiledProject(project);
    URI exeURI=new URI(configUtils.getExecutablePath());
    RemoteConnection exeRC=new RemoteConnection(exeURI);
    monitor.worked(1);
    String valgrindPathString=RuntimeProcessFactory.getFactory().whichCommand(VALGRIND_CMD,project);
    IPath valgrindFullPath=Path.fromOSString(valgrindPathString);
    boolean copyExecutable=configUtils.getCopyExecutable();
    if (copyExecutable) {
      URI copyExeURI=new URI(configUtils.getCopyFromExecutablePath());
      RemoteConnection copyExeRC=new RemoteConnection(copyExeURI);
      IRemoteFileProxy copyExeRFP=copyExeRC.getRmtFileProxy();
      IFileStore copyExeFS=copyExeRFP.getResource(copyExeURI.getPath());
      IRemoteFileProxy exeRFP=exeRC.getRmtFileProxy();
      IFileStore exeFS=exeRFP.getResource(exeURI.getPath());
      IFileInfo exeFI=exeFS.fetchInfo();
      if (exeFI.isDirectory()) {
        IPath copyExePath=Path.fromOSString(copyExeURI.getPath());
        IPath newExePath=Path.fromOSString(exeURI.getPath()).append(copyExePath.lastSegment());
        exeURI=new URI(exeURI.getScheme(),exeURI.getAuthority(),newExePath.toString(),exeURI.getQuery(),exeURI.getFragment());
        exeFS=exeRFP.getResource(exeURI.getPath());
      }
      copyExeFS.copy(exeFS,EFS.OVERWRITE | EFS.SHALLOW,new SubProgressMonitor(monitor,1));
    }
    valgrindVersion=getValgrindVersion(project);
    IPath remoteBinFile=Path.fromOSString(exeURI.getPath());
    String configWorkingDir=configUtils.getWorkingDirectory();
    IFileStore workingDir;
    if (configWorkingDir == null) {
      IPath workingDirPath=remoteBinFile.removeLastSegments(1);
      IRemoteFileProxy workingDirRFP=exeRC.getRmtFileProxy();
      workingDir=workingDirRFP.getResource(workingDirPath.toOSString());
    }
 else {
      URI workingDirURI=new URI(configUtils.getWorkingDirectory());
      RemoteConnection workingDirRC=new RemoteConnection(workingDirURI);
      IRemoteFileProxy workingDirRFP=workingDirRC.getRmtFileProxy();
      workingDir=workingDirRFP.getResource(workingDirURI.getPath());
    }
    IPath remoteLogDir=Path.fromOSString(""String_Node_Str"");
    outputPath=remoteLogDir.append(""String_Node_Str"" + System.currentTimeMillis());
    exeRC.createFolder(outputPath,new SubProgressMonitor(monitor,1));
    IValgrindOutputDirectoryProvider provider=getPlugin().getOutputDirectoryProvider();
    IPath localOutputDir=null;
    try {
      localOutputDir=provider.getOutputPath();
      createDirectory(localOutputDir);
    }
 catch (    IOException e2) {
      throw new CoreException(new Status(IStatus.ERROR,ValgrindLaunchPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e2));
    }
    toolID=getTool(config);
    dynamicDelegate=getDynamicDelegate(toolID);
    String[] valgrindArgs=getValgrindArgumentsArray(config);
    String[] executableArgs=getProgramArgumentsArray(config);
    String[] allArgs=new String[executableArgs.length + valgrindArgs.length + 2];
    int idx=0;
    allArgs[idx++]=VALGRIND_CMD;
    for (    String valgrindArg : valgrindArgs) {
      allArgs[idx++]=valgrindArg;
    }
    allArgs[idx++]=remoteBinFile.toOSString();
    for (    String executableArg : executableArgs) {
      allArgs[idx++]=executableArg;
    }
    Process p=RuntimeProcessFactory.getFactory().exec(allArgs,new String[0],workingDir,project);
    int state=p.waitFor();
    if (state != IRemoteCommandLauncher.OK) {
      abort(Messages.getString(""String_Node_Str"") + ""String_Node_Str"" + state+ ""String_Node_Str""+ NLS.bind(Messages.getString(""String_Node_Str""),""String_Node_Str"")+ ""String_Node_Str"",null,ICDTLaunchConfigurationConstants.ERR_INTERNAL_ERROR);
    }
    if (p.exitValue() != 0) {
      String line=null;
      StringBuilder valgrindOutSB=new StringBuilder();
      BufferedReader valgrindOut=new BufferedReader(new InputStreamReader(p.getInputStream()));
      while ((line=valgrindOut.readLine()) != null) {
        valgrindOutSB.append(line);
      }
      StringBuilder valgrindErrSB=new StringBuilder();
      BufferedReader valgrindErr=new BufferedReader(new InputStreamReader(p.getErrorStream()));
      while ((line=valgrindErr.readLine()) != null) {
        valgrindErrSB.append(line);
      }
      abort(NLS.bind(""String_Node_Str"",valgrindOutSB.toString()) + ""String_Node_Str"" + NLS.bind(""String_Node_Str"",valgrindErrSB.toString()),null,ICDTLaunchConfigurationConstants.ERR_INTERNAL_ERROR);
    }
    exeRC.download(outputPath,localOutputDir,new SubProgressMonitor(monitor,1));
    exeRC.delete(outputPath,new SubProgressMonitor(monitor,1));
    getPlugin().setCurrentLaunchConfiguration(config);
    getPlugin().setCurrentLaunch(launch);
    IValgrindMessage[] messages=parseLogs(localOutputDir);
    launchStr=createLaunchStr(valgrindFullPath);
    ValgrindUIPlugin.getDefault().createView(launchStr,toolID);
    ValgrindViewPart view=ValgrindUIPlugin.getDefault().getView();
    view.setMessages(messages);
    monitor.worked(1);
    dynamicDelegate.handleLaunch(config,launch,localOutputDir,monitor.newChild(2));
    dynamicDelegate.initializeView(view.getDynamicView(),launchStr,monitor.newChild(1));
    ValgrindUIPlugin.getDefault().refreshView();
    ValgrindUIPlugin.getDefault().showView();
    monitor.worked(1);
  }
 catch (  URISyntaxException|IOException|RemoteConnectionException|InterruptedException e) {
    abort(e.getLocalizedMessage(),null,ICDTLaunchConfigurationConstants.ERR_INTERNAL_ERROR);
  }
 finally {
    monitor.done();
    m.done();
  }
}","@Override public void launch(final ILaunchConfiguration config,String mode,final ILaunch launch,IProgressMonitor m) throws CoreException {
  if (m == null) {
    m=new NullProgressMonitor();
  }
  process=null;
  SubMonitor monitor=SubMonitor.convert(m,Messages.getString(""String_Node_Str""),10);
  if (monitor.isCanceled()) {
    return;
  }
  this.config=config;
  this.launch=launch;
  try {
    ValgrindUIPlugin.getDefault().resetView();
    getPlugin().setCurrentLaunchConfiguration(null);
    getPlugin().setCurrentLaunch(null);
    this.configUtils=new ConfigUtils(config);
    IProject project=configUtils.getProject();
    ValgrindUIPlugin.getDefault().setProfiledProject(project);
    URI exeURI=new URI(configUtils.getExecutablePath());
    RemoteConnection exeRC=new RemoteConnection(exeURI);
    monitor.worked(1);
    String valgrindPathString=RuntimeProcessFactory.getFactory().whichCommand(VALGRIND_CMD,project);
    IPath valgrindFullPath=Path.fromOSString(valgrindPathString);
    boolean copyExecutable=configUtils.getCopyExecutable();
    if (copyExecutable) {
      URI copyExeURI=new URI(configUtils.getCopyFromExecutablePath());
      RemoteConnection copyExeRC=new RemoteConnection(copyExeURI);
      IRemoteFileProxy copyExeRFP=copyExeRC.getRmtFileProxy();
      IFileStore copyExeFS=copyExeRFP.getResource(copyExeURI.getPath());
      IRemoteFileProxy exeRFP=exeRC.getRmtFileProxy();
      IFileStore exeFS=exeRFP.getResource(exeURI.getPath());
      IFileInfo exeFI=exeFS.fetchInfo();
      if (exeFI.isDirectory()) {
        IPath copyExePath=Path.fromOSString(copyExeURI.getPath());
        IPath newExePath=Path.fromOSString(exeURI.getPath()).append(copyExePath.lastSegment());
        exeURI=new URI(exeURI.getScheme(),exeURI.getAuthority(),newExePath.toString(),exeURI.getQuery(),exeURI.getFragment());
        exeFS=exeRFP.getResource(exeURI.getPath());
      }
      copyExeFS.copy(exeFS,EFS.OVERWRITE | EFS.SHALLOW,new SubProgressMonitor(monitor,1));
    }
    valgrindVersion=getValgrindVersion(project);
    IPath remoteBinFile=Path.fromOSString(exeURI.getPath());
    String configWorkingDir=configUtils.getWorkingDirectory();
    IFileStore workingDir;
    if (configWorkingDir == null) {
      IPath workingDirPath=remoteBinFile.removeLastSegments(1);
      IRemoteFileProxy workingDirRFP=exeRC.getRmtFileProxy();
      workingDir=workingDirRFP.getResource(workingDirPath.toOSString());
    }
 else {
      URI workingDirURI=new URI(configUtils.getWorkingDirectory());
      RemoteConnection workingDirRC=new RemoteConnection(workingDirURI);
      IRemoteFileProxy workingDirRFP=workingDirRC.getRmtFileProxy();
      workingDir=workingDirRFP.getResource(workingDirURI.getPath());
    }
    IPath remoteLogDir=Path.fromOSString(""String_Node_Str"");
    outputPath=remoteLogDir.append(""String_Node_Str"" + System.currentTimeMillis());
    exeRC.createFolder(outputPath,new SubProgressMonitor(monitor,1));
    IValgrindOutputDirectoryProvider provider=getPlugin().getOutputDirectoryProvider();
    setOutputPath(config,provider.getOutputPath());
    IPath localOutputDir=null;
    try {
      localOutputDir=provider.getOutputPath();
      createDirectory(localOutputDir);
    }
 catch (    IOException e2) {
      throw new CoreException(new Status(IStatus.ERROR,ValgrindLaunchPlugin.PLUGIN_ID,IStatus.OK,""String_Node_Str"",e2));
    }
    toolID=getTool(config);
    dynamicDelegate=getDynamicDelegate(toolID);
    String[] valgrindArgs=getValgrindArgumentsArray(config);
    String[] executableArgs=getProgramArgumentsArray(config);
    String[] allArgs=new String[executableArgs.length + valgrindArgs.length + 2];
    int idx=0;
    allArgs[idx++]=VALGRIND_CMD;
    for (    String valgrindArg : valgrindArgs) {
      allArgs[idx++]=valgrindArg;
    }
    allArgs[idx++]=remoteBinFile.toOSString();
    for (    String executableArg : executableArgs) {
      allArgs[idx++]=executableArg;
    }
    Process p=RuntimeProcessFactory.getFactory().exec(allArgs,new String[0],workingDir,project);
    int state=p.waitFor();
    if (state != IRemoteCommandLauncher.OK) {
      abort(Messages.getString(""String_Node_Str"") + ""String_Node_Str"" + state+ ""String_Node_Str""+ NLS.bind(Messages.getString(""String_Node_Str""),""String_Node_Str"")+ ""String_Node_Str"",null,ICDTLaunchConfigurationConstants.ERR_INTERNAL_ERROR);
    }
    if (p.exitValue() != 0) {
      String line=null;
      StringBuilder valgrindOutSB=new StringBuilder();
      BufferedReader valgrindOut=new BufferedReader(new InputStreamReader(p.getInputStream()));
      while ((line=valgrindOut.readLine()) != null) {
        valgrindOutSB.append(line);
      }
      StringBuilder valgrindErrSB=new StringBuilder();
      BufferedReader valgrindErr=new BufferedReader(new InputStreamReader(p.getErrorStream()));
      while ((line=valgrindErr.readLine()) != null) {
        valgrindErrSB.append(line);
      }
      abort(NLS.bind(""String_Node_Str"",valgrindOutSB.toString()) + ""String_Node_Str"" + NLS.bind(""String_Node_Str"",valgrindErrSB.toString()),null,ICDTLaunchConfigurationConstants.ERR_INTERNAL_ERROR);
    }
    exeRC.download(outputPath,localOutputDir,new SubProgressMonitor(monitor,1));
    exeRC.delete(outputPath,new SubProgressMonitor(monitor,1));
    getPlugin().setCurrentLaunchConfiguration(config);
    getPlugin().setCurrentLaunch(launch);
    IValgrindMessage[] messages=parseLogs(localOutputDir);
    launchStr=createLaunchStr(valgrindFullPath);
    ValgrindUIPlugin.getDefault().createView(launchStr,toolID);
    ValgrindViewPart view=ValgrindUIPlugin.getDefault().getView();
    view.setMessages(messages);
    monitor.worked(1);
    dynamicDelegate.handleLaunch(config,launch,localOutputDir,monitor.newChild(2));
    dynamicDelegate.initializeView(view.getDynamicView(),launchStr,monitor.newChild(1));
    ValgrindUIPlugin.getDefault().refreshView();
    ValgrindUIPlugin.getDefault().showView();
    monitor.worked(1);
  }
 catch (  URISyntaxException|IOException|RemoteConnectionException|InterruptedException e) {
    abort(e.getLocalizedMessage(),null,ICDTLaunchConfigurationConstants.ERR_INTERNAL_ERROR);
  }
 finally {
    monitor.done();
    m.done();
  }
}",0.995773732119636
91791,"protected String[] getCommand(String workingDir){
  return new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",workingDir + ""String_Node_Str""};
}","protected String[] getCommand(String workingDir){
  return new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + workingDir + ""String_Node_Str""+ ""String_Node_Str""};
}",0.9325513196480938
91792,"/** 
 * If a key stored in preferences comes from a non-running VM or came from a Vagrant VM (tracked) but is not longer associated with one, then it is safe to remove it.
 */
private void removeKeysFromInnactiveVMs(){
  final String JSCH_ID=""String_Node_Str"";
  final String KEY=""String_Node_Str"";
  String newKeys=""String_Node_Str"";
  String keys=InstanceScope.INSTANCE.getNode(JSCH_ID).get(KEY,""String_Node_Str"");
  if (keys.isEmpty()) {
    keys=DefaultScope.INSTANCE.getNode(JSCH_ID).get(KEY,""String_Node_Str"");
  }
  for (  String key : keys.split(""String_Node_Str"")) {
    for (    IVagrantVM vm : vms) {
      if (key.equals(vm.identityFile()) && !vm.state().equals(EnumVMStatus.RUNNING)) {
        newKeys=keys.replaceAll(""String_Node_Str"" + key + ""String_Node_Str"",""String_Node_Str"");
        removeFromTrackedKeys(key);
        break;
      }
    }
    if (isTrackedKey(key)) {
      newKeys=keys.replaceAll(""String_Node_Str"" + key + ""String_Node_Str"",""String_Node_Str"");
      removeFromTrackedKeys(key);
    }
  }
  if (!newKeys.isEmpty() && !newKeys.equals(keys)) {
    InstanceScope.INSTANCE.getNode(JSCH_ID).put(KEY,newKeys);
  }
}","/** 
 * If a key stored in preferences comes from a non-running VM or came from a Vagrant VM (tracked) but is not longer associated with one, then it is safe to remove it.
 */
private void removeKeysFromInnactiveVMs(){
  final String JSCH_ID=""String_Node_Str"";
  final String KEY=""String_Node_Str"";
  String newKeys=""String_Node_Str"";
  String keys=InstanceScope.INSTANCE.getNode(JSCH_ID).get(KEY,""String_Node_Str"");
  if (keys.isEmpty()) {
    keys=DefaultScope.INSTANCE.getNode(JSCH_ID).get(KEY,""String_Node_Str"");
  }
  boolean vmFound=false;
  for (  String key : keys.split(""String_Node_Str"")) {
    for (    IVagrantVM vm : vms) {
      if (key.equals(vm.identityFile())) {
        vmFound=true;
        if (!EnumVMStatus.RUNNING.equals(EnumVMStatus.fromStatusMessage(vm.state()))) {
          newKeys=keys.replaceAll(""String_Node_Str"" + key + ""String_Node_Str"",""String_Node_Str"");
          removeFromTrackedKeys(key);
          break;
        }
      }
    }
    if (!vmFound && isTrackedKey(key)) {
      newKeys=keys.replaceAll(""String_Node_Str"" + key + ""String_Node_Str"",""String_Node_Str"");
      removeFromTrackedKeys(key);
    }
  }
  if (!newKeys.isEmpty() && !newKeys.equals(keys)) {
    InstanceScope.INSTANCE.getNode(JSCH_ID).put(KEY,newKeys);
  }
}",0.7741400745959387
91793,"public VagrantVM(String id,String name,String provider,String state,String state_desc,File directory,String ip,String user,String identityFile){
  this.id=id;
  this.name=name;
  this.provider=provider;
  this.state=state;
  this.state_desc=state_desc;
  this.directory=directory;
  this.ip=ip;
  this.user=user;
  this.identityFile=identityFile;
}","public VagrantVM(String id,String name,String provider,String state,String state_desc,File directory,String ip,String user,int port,String identityFile){
  this.id=id;
  this.name=name;
  this.provider=provider;
  this.state=state;
  this.state_desc=state_desc;
  this.directory=directory;
  this.ip=ip;
  this.user=user;
  this.port=port;
  this.identityFile=identityFile;
}",0.9626556016597512
91794,"@Override void executeInJob(final IVagrantVM vm,IProgressMonitor monitor){
  Map<String,Object> properties=new HashMap<>();
  properties.put(""String_Node_Str"",300);
  properties.put(""String_Node_Str"",22);
  properties.put(""String_Node_Str"",""String_Node_Str"");
  properties.put(""String_Node_Str"",null);
  properties.put(""String_Node_Str"",""String_Node_Str"");
  if (!vm.identityFile().isEmpty()) {
    setupKeyPreferences(vm.identityFile());
  }
  properties.put(""String_Node_Str"",""String_Node_Str"");
  properties.put(""String_Node_Str"",vm.ip());
  properties.put(""String_Node_Str"",vm.user());
  properties.put(""String_Node_Str"",null);
  properties.put(""String_Node_Str"",0);
  SshLauncherDelegate delegate=new SshLauncherDelegate();
  delegate.execute(properties,null);
}","@Override void executeInJob(final IVagrantVM vm,IProgressMonitor monitor){
  Map<String,Object> properties=new HashMap<>();
  properties.put(""String_Node_Str"",300);
  properties.put(""String_Node_Str"",vm.port());
  properties.put(""String_Node_Str"",""String_Node_Str"");
  properties.put(""String_Node_Str"",null);
  properties.put(""String_Node_Str"",""String_Node_Str"");
  if (!vm.identityFile().isEmpty()) {
    setupKeyPreferences(vm.identityFile());
  }
  properties.put(""String_Node_Str"",""String_Node_Str"");
  properties.put(""String_Node_Str"",vm.ip());
  properties.put(""String_Node_Str"",vm.user());
  properties.put(""String_Node_Str"",null);
  properties.put(""String_Node_Str"",0);
  SshLauncherDelegate delegate=new SshLauncherDelegate();
  delegate.execute(properties,null);
}",0.9928617780661908
91795,"/** 
 * Creates the connection settings container, where the user can choose how to connect to the docker daemon (using sockets or TCP with SSL - or not)
 * @param parent the parent container (ie, the main container in the preference page)
 */
private void createConnectionSettingsContainer(final Composite parent){
  final int COLUMNS=3;
  final int INDENT=20;
  final Composite container=new Composite(parent,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).span(1,1).grab(true,false).applyTo(container);
  GridLayoutFactory.fillDefaults().numColumns(COLUMNS).margins(6,6).spacing(10,2).applyTo(container);
  final Label connectionNameLabel=new Label(container,SWT.NONE);
  connectionNameLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).applyTo(connectionNameLabel);
  final Text connectionNameText=new Text(container,SWT.BORDER);
  connectionNameText.setToolTipText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).span(2,1).applyTo(connectionNameText);
  final Button customConnectionSettingsButton=new Button(container,SWT.CHECK);
  customConnectionSettingsButton.setText(""String_Node_Str"");
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).indent(0,10).span(COLUMNS,1).applyTo(customConnectionSettingsButton);
  final Group customSettingsGroup=new Group(container,SWT.BORDER);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).span(COLUMNS,1).grab(true,false).applyTo(customSettingsGroup);
  GridLayoutFactory.fillDefaults().numColumns(COLUMNS).margins(6,6).spacing(10,2).applyTo(customSettingsGroup);
  final Button unixSocketBindingModeButton=new Button(customSettingsGroup,SWT.RADIO);
  unixSocketBindingModeButton.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).span(COLUMNS,1).applyTo(unixSocketBindingModeButton);
  final Label unixSocketPathLabel=new Label(customSettingsGroup,SWT.NONE);
  unixSocketPathLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).indent(INDENT,0).applyTo(unixSocketPathLabel);
  final Text unixSocketPathText=new Text(customSettingsGroup,SWT.BORDER);
  unixSocketPathText.setToolTipText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).applyTo(unixSocketPathText);
  final Button unixSocketPathBrowseButton=new Button(customSettingsGroup,SWT.BUTTON1);
  unixSocketPathBrowseButton.setText(WizardMessages.getString(""String_Node_Str""));
  unixSocketPathBrowseButton.addSelectionListener(onBrowseUnixSocketPath());
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).applyTo(unixSocketPathBrowseButton);
  final Button tcpConnectionBindingModeButton=new Button(customSettingsGroup,SWT.RADIO);
  tcpConnectionBindingModeButton.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).span(COLUMNS,1).applyTo(tcpConnectionBindingModeButton);
  final Label tcpHostLabel=new Label(customSettingsGroup,SWT.NONE);
  tcpHostLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).indent(INDENT,0).applyTo(tcpHostLabel);
  final Text tcpHostText=new Text(customSettingsGroup,SWT.BORDER);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).span(2,1).grab(true,false).applyTo(tcpHostText);
  final Button tcpAuthButton=new Button(customSettingsGroup,SWT.CHECK);
  tcpAuthButton.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).indent(INDENT,0).span(3,1).applyTo(tcpAuthButton);
  final Label tcpCertPathLabel=new Label(customSettingsGroup,SWT.NONE);
  tcpCertPathLabel.setText(WizardMessages.getString(""String_Node_Str""));
  tcpCertPathLabel.setToolTipText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).indent(INDENT * 2,0).applyTo(tcpCertPathLabel);
  final Text tcpCertPathText=new Text(customSettingsGroup,SWT.BORDER);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).applyTo(tcpCertPathText);
  final Button tcpCertPathBrowseButton=new Button(customSettingsGroup,SWT.BUTTON1);
  tcpCertPathBrowseButton.setText(WizardMessages.getString(""String_Node_Str""));
  tcpCertPathBrowseButton.addSelectionListener(onBrowseTcpCertPath());
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).applyTo(tcpCertPathBrowseButton);
  final Button testConnectionButton=new Button(container,SWT.NONE);
  testConnectionButton.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).span(COLUMNS,1).align(SWT.END,SWT.CENTER).applyTo(testConnectionButton);
  testConnectionButton.addSelectionListener(onTestConnectionButtonSelection());
  final IObservableValue connectionNameModelObservable=BeanProperties.value(NewDockerConnectionPageModel.class,NewDockerConnectionPageModel.CONNECTION_NAME).observe(model);
  final IObservableValue unixSocketBindingModeModelObservable=BeanProperties.value(NewDockerConnectionPageModel.class,NewDockerConnectionPageModel.UNIX_SOCKET_BINDING_MODE).observe(model);
  final IObservableValue unixSocketPathModelObservable=BeanProperties.value(NewDockerConnectionPageModel.class,NewDockerConnectionPageModel.UNIX_SOCKET_PATH).observe(model);
  final IObservableValue customConnectionSettingsModelObservable=BeanProperties.value(NewDockerConnectionPageModel.class,NewDockerConnectionPageModel.CUSTOM_SETTINGS).observe(model);
  final IObservableValue tcpConnectionBindingModeModelObservable=BeanProperties.value(NewDockerConnectionPageModel.class,NewDockerConnectionPageModel.TCP_CONNECTION_BINDING_MODE).observe(model);
  final IObservableValue tcpCertPathModelObservable=BeanProperties.value(NewDockerConnectionPageModel.class,NewDockerConnectionPageModel.TCP_CERT_PATH).observe(model);
  final IObservableValue tcpTlsVerifyModelObservable=BeanProperties.value(NewDockerConnectionPageModel.class,NewDockerConnectionPageModel.TCP_TLS_VERIFY).observe(model);
  final IObservableValue tcpHostModelObservable=BeanProperties.value(NewDockerConnectionPageModel.class,NewDockerConnectionPageModel.TCP_HOST).observe(model);
  final Control[] bindingModeSelectionControls=new Control[]{unixSocketBindingModeButton,tcpConnectionBindingModeButton};
  final Control[] unixSocketControls=new Control[]{unixSocketPathText,unixSocketPathLabel,unixSocketPathBrowseButton};
  final Control[] tcpConnectionControls=new Control[]{tcpHostText,tcpHostLabel,tcpAuthButton};
  final Control[] tcpAuthControls=new Control[]{tcpCertPathText,tcpCertPathLabel,tcpCertPathBrowseButton};
  customConnectionSettingsModelObservable.addValueChangeListener(onCustomConnectionSettingsSelection(bindingModeSelectionControls,unixSocketControls,tcpAuthControls,tcpConnectionControls));
  unixSocketBindingModeModelObservable.addChangeListener(onUnixSocketBindingSelection(unixSocketControls));
  tcpConnectionBindingModeModelObservable.addChangeListener(onTcpConnectionBindingSelection(tcpConnectionControls,tcpAuthControls));
  tcpTlsVerifyModelObservable.addValueChangeListener(onTcpAuthSelection(tcpAuthControls));
  dbc.bindValue(WidgetProperties.text(SWT.Modify).observe(connectionNameText),connectionNameModelObservable);
  dbc.bindValue(WidgetProperties.selection().observe(customConnectionSettingsButton),customConnectionSettingsModelObservable);
  dbc.bindValue(WidgetProperties.selection().observe(unixSocketBindingModeButton),unixSocketBindingModeModelObservable);
  dbc.bindValue(WidgetProperties.text(SWT.Modify).observe(unixSocketPathText),unixSocketPathModelObservable);
  dbc.bindValue(WidgetProperties.selection().observe(tcpConnectionBindingModeButton),tcpConnectionBindingModeModelObservable);
  dbc.bindValue(WidgetProperties.text(SWT.Modify).observe(tcpHostText),tcpHostModelObservable);
  dbc.bindValue(WidgetProperties.selection().observe(tcpAuthButton),tcpTlsVerifyModelObservable);
  dbc.bindValue(WidgetProperties.text(SWT.Modify).observe(tcpCertPathText),tcpCertPathModelObservable);
  dbc.addValidationStatusProvider(new ConnectionNameValidator(connectionNameModelObservable));
  dbc.addValidationStatusProvider(new UnixSocketValidator(unixSocketBindingModeModelObservable,unixSocketPathModelObservable));
  dbc.addValidationStatusProvider(new TcpHostValidator(tcpConnectionBindingModeModelObservable,tcpHostModelObservable));
  dbc.addValidationStatusProvider(new TcpCertificatesValidator(tcpConnectionBindingModeModelObservable,tcpTlsVerifyModelObservable,tcpCertPathModelObservable));
  connectionNameText.setFocus();
  updateWidgetsState(bindingModeSelectionControls,unixSocketControls,tcpConnectionControls,tcpAuthControls);
}","/** 
 * Creates the connection settings container, where the user can choose how to connect to the docker daemon (using sockets or TCP with SSL - or not)
 * @param parent the parent container (ie, the main container in the preference page)
 */
private void createConnectionSettingsContainer(final Composite parent){
  final int COLUMNS=3;
  final int INDENT=20;
  final Composite container=new Composite(parent,SWT.NONE);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).span(1,1).grab(true,false).applyTo(container);
  GridLayoutFactory.fillDefaults().numColumns(COLUMNS).margins(6,6).spacing(10,2).applyTo(container);
  final Label connectionNameLabel=new Label(container,SWT.NONE);
  connectionNameLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).applyTo(connectionNameLabel);
  final Text connectionNameText=new Text(container,SWT.BORDER);
  connectionNameText.setToolTipText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).span(2,1).applyTo(connectionNameText);
  final Button customConnectionSettingsButton=new Button(container,SWT.CHECK);
  customConnectionSettingsButton.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).indent(0,10).span(COLUMNS,1).applyTo(customConnectionSettingsButton);
  final Group customSettingsGroup=new Group(container,SWT.BORDER);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).span(COLUMNS,1).grab(true,false).applyTo(customSettingsGroup);
  GridLayoutFactory.fillDefaults().numColumns(COLUMNS).margins(6,6).spacing(10,2).applyTo(customSettingsGroup);
  final Button unixSocketBindingModeButton=new Button(customSettingsGroup,SWT.RADIO);
  unixSocketBindingModeButton.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).span(COLUMNS,1).applyTo(unixSocketBindingModeButton);
  final Label unixSocketPathLabel=new Label(customSettingsGroup,SWT.NONE);
  unixSocketPathLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).indent(INDENT,0).applyTo(unixSocketPathLabel);
  final Text unixSocketPathText=new Text(customSettingsGroup,SWT.BORDER);
  unixSocketPathText.setToolTipText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).applyTo(unixSocketPathText);
  final Button unixSocketPathBrowseButton=new Button(customSettingsGroup,SWT.BUTTON1);
  unixSocketPathBrowseButton.setText(WizardMessages.getString(""String_Node_Str""));
  unixSocketPathBrowseButton.addSelectionListener(onBrowseUnixSocketPath());
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).applyTo(unixSocketPathBrowseButton);
  final Button tcpConnectionBindingModeButton=new Button(customSettingsGroup,SWT.RADIO);
  tcpConnectionBindingModeButton.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).span(COLUMNS,1).applyTo(tcpConnectionBindingModeButton);
  final Label tcpHostLabel=new Label(customSettingsGroup,SWT.NONE);
  tcpHostLabel.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).indent(INDENT,0).applyTo(tcpHostLabel);
  final Text tcpHostText=new Text(customSettingsGroup,SWT.BORDER);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).span(2,1).grab(true,false).applyTo(tcpHostText);
  final Button tcpAuthButton=new Button(customSettingsGroup,SWT.CHECK);
  tcpAuthButton.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).indent(INDENT,0).span(3,1).applyTo(tcpAuthButton);
  final Label tcpCertPathLabel=new Label(customSettingsGroup,SWT.NONE);
  tcpCertPathLabel.setText(WizardMessages.getString(""String_Node_Str""));
  tcpCertPathLabel.setToolTipText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).indent(INDENT * 2,0).applyTo(tcpCertPathLabel);
  final Text tcpCertPathText=new Text(customSettingsGroup,SWT.BORDER);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).applyTo(tcpCertPathText);
  final Button tcpCertPathBrowseButton=new Button(customSettingsGroup,SWT.BUTTON1);
  tcpCertPathBrowseButton.setText(WizardMessages.getString(""String_Node_Str""));
  tcpCertPathBrowseButton.addSelectionListener(onBrowseTcpCertPath());
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).applyTo(tcpCertPathBrowseButton);
  final Button testConnectionButton=new Button(container,SWT.NONE);
  testConnectionButton.setText(WizardMessages.getString(""String_Node_Str""));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).span(COLUMNS,1).align(SWT.END,SWT.CENTER).applyTo(testConnectionButton);
  testConnectionButton.addSelectionListener(onTestConnectionButtonSelection());
  final IObservableValue connectionNameModelObservable=BeanProperties.value(NewDockerConnectionPageModel.class,NewDockerConnectionPageModel.CONNECTION_NAME).observe(model);
  final IObservableValue unixSocketBindingModeModelObservable=BeanProperties.value(NewDockerConnectionPageModel.class,NewDockerConnectionPageModel.UNIX_SOCKET_BINDING_MODE).observe(model);
  final IObservableValue unixSocketPathModelObservable=BeanProperties.value(NewDockerConnectionPageModel.class,NewDockerConnectionPageModel.UNIX_SOCKET_PATH).observe(model);
  final IObservableValue customConnectionSettingsModelObservable=BeanProperties.value(NewDockerConnectionPageModel.class,NewDockerConnectionPageModel.CUSTOM_SETTINGS).observe(model);
  final IObservableValue tcpConnectionBindingModeModelObservable=BeanProperties.value(NewDockerConnectionPageModel.class,NewDockerConnectionPageModel.TCP_CONNECTION_BINDING_MODE).observe(model);
  final IObservableValue tcpCertPathModelObservable=BeanProperties.value(NewDockerConnectionPageModel.class,NewDockerConnectionPageModel.TCP_CERT_PATH).observe(model);
  final IObservableValue tcpTlsVerifyModelObservable=BeanProperties.value(NewDockerConnectionPageModel.class,NewDockerConnectionPageModel.TCP_TLS_VERIFY).observe(model);
  final IObservableValue tcpHostModelObservable=BeanProperties.value(NewDockerConnectionPageModel.class,NewDockerConnectionPageModel.TCP_HOST).observe(model);
  final Control[] bindingModeSelectionControls=new Control[]{unixSocketBindingModeButton,tcpConnectionBindingModeButton};
  final Control[] unixSocketControls=new Control[]{unixSocketPathText,unixSocketPathLabel,unixSocketPathBrowseButton};
  final Control[] tcpConnectionControls=new Control[]{tcpHostText,tcpHostLabel,tcpAuthButton};
  final Control[] tcpAuthControls=new Control[]{tcpCertPathText,tcpCertPathLabel,tcpCertPathBrowseButton};
  customConnectionSettingsModelObservable.addValueChangeListener(onCustomConnectionSettingsSelection(bindingModeSelectionControls,unixSocketControls,tcpAuthControls,tcpConnectionControls));
  unixSocketBindingModeModelObservable.addChangeListener(onUnixSocketBindingSelection(unixSocketControls));
  tcpConnectionBindingModeModelObservable.addChangeListener(onTcpConnectionBindingSelection(tcpConnectionControls,tcpAuthControls));
  tcpTlsVerifyModelObservable.addValueChangeListener(onTcpAuthSelection(tcpAuthControls));
  dbc.bindValue(WidgetProperties.text(SWT.Modify).observe(connectionNameText),connectionNameModelObservable);
  dbc.bindValue(WidgetProperties.selection().observe(customConnectionSettingsButton),customConnectionSettingsModelObservable);
  dbc.bindValue(WidgetProperties.selection().observe(unixSocketBindingModeButton),unixSocketBindingModeModelObservable);
  dbc.bindValue(WidgetProperties.text(SWT.Modify).observe(unixSocketPathText),unixSocketPathModelObservable);
  dbc.bindValue(WidgetProperties.selection().observe(tcpConnectionBindingModeButton),tcpConnectionBindingModeModelObservable);
  dbc.bindValue(WidgetProperties.text(SWT.Modify).observe(tcpHostText),tcpHostModelObservable);
  dbc.bindValue(WidgetProperties.selection().observe(tcpAuthButton),tcpTlsVerifyModelObservable);
  dbc.bindValue(WidgetProperties.text(SWT.Modify).observe(tcpCertPathText),tcpCertPathModelObservable);
  dbc.addValidationStatusProvider(new ConnectionNameValidator(connectionNameModelObservable));
  dbc.addValidationStatusProvider(new UnixSocketValidator(unixSocketBindingModeModelObservable,unixSocketPathModelObservable));
  dbc.addValidationStatusProvider(new TcpHostValidator(tcpConnectionBindingModeModelObservable,tcpHostModelObservable));
  dbc.addValidationStatusProvider(new TcpCertificatesValidator(tcpConnectionBindingModeModelObservable,tcpTlsVerifyModelObservable,tcpCertPathModelObservable));
  connectionNameText.setFocus();
  updateWidgetsState(bindingModeSelectionControls,unixSocketControls,tcpConnectionControls,tcpAuthControls);
}",0.9985458612975392
91796,"@Override public void launch(ILaunchConfiguration config,String mode,ILaunch launch,IProgressMonitor monitor) throws CoreException {
  try {
    ConfigUtils configUtils=new ConfigUtils(config);
    project=configUtils.getProject();
    if (!PerfCore.checkPerfInPath(project)) {
      IStatus status=new Status(IStatus.ERROR,PerfPlugin.PLUGIN_ID,""String_Node_Str"");
      throw new CoreException(status);
    }
    URI binURI=new URI(configUtils.getExecutablePath());
    binPath=Path.fromPortableString(binURI.getPath().toString());
    if (binPath == null) {
      CDebugUtils.verifyProgramPath(config);
    }
    if (binPath.removeLastSegments(2).toPortableString().equals(EMPTY_STRING)) {
      workingDirPath=Path.fromPortableString(getWorkingDirectory(config).toURI().getPath());
    }
 else {
      workingDirPath=Path.fromPortableString((binPath.removeLastSegments(2).toPortableString()) + IPath.SEPARATOR);
    }
    PerfPlugin.getDefault().setWorkingDir(workingDirPath);
    if (config.getAttribute(PerfPlugin.ATTR_ShowStat,PerfPlugin.ATTR_ShowStat_default)) {
      showStat(config,launch);
    }
 else {
      String perfPathString=RuntimeProcessFactory.getFactory().whichCommand(PerfPlugin.PERF_COMMAND,project);
      IFileStore workingDir;
      URI workingDirURI=new URI(RemoteProxyManager.getInstance().getRemoteProjectLocation(project));
      RemoteConnection workingDirRC=new RemoteConnection(workingDirURI);
      IRemoteFileProxy workingDirRFP=workingDirRC.getRmtFileProxy();
      workingDir=workingDirRFP.getResource(workingDirURI.getPath());
      String arguments[]=getProgramArgumentsArray(config);
      ArrayList<String> command=new ArrayList<>(4 + arguments.length);
      Version perfVersion=PerfCore.getPerfVersion(config);
      command.addAll(Arrays.asList(PerfCore.getRecordString(config,perfVersion)));
      command.add(binPath.toPortableString());
      command.set(0,perfPathString);
      command.add(2,OUTPUT_STR + PerfPlugin.PERF_DEFAULT_DATA);
      command.addAll(Arrays.asList(arguments));
      String[] commandArray=command.toArray(new String[command.size()]);
      Process pProxy=RuntimeProcessFactory.getFactory().exec(commandArray,getEnvironment(config),workingDir,project);
      MessageConsole console=new MessageConsole(""String_Node_Str"",null);
      console.activate();
      ConsolePlugin.getDefault().getConsoleManager().addConsoles(new IConsole[]{console});
      MessageConsoleStream stream=console.newMessageStream();
      if (pProxy != null) {
        try (BufferedReader error=new BufferedReader(new InputStreamReader(pProxy.getErrorStream()))){
          String err=error.readLine();
          while (err != null) {
            stream.println(err);
            err=error.readLine();
          }
        }
       }
      pProxy.destroy();
      PrintStream print=null;
      if (config.getAttribute(IDebugUIConstants.ATTR_CAPTURE_IN_CONSOLE,true)) {
        ConsolePlugin plugin=ConsolePlugin.getDefault();
        IConsoleManager conMan=plugin.getConsoleManager();
        IConsole[] existing=conMan.getConsoles();
        IOConsole binaryOutCons=null;
        for (        IConsole x : existing) {
          if (x.getName().contains(renderProcessLabel(commandArray[0]))) {
            binaryOutCons=(IOConsole)x;
          }
        }
        if ((binaryOutCons == null) && (existing.length != 0)) {
          if (existing[existing.length - 1] instanceof IOConsole)           binaryOutCons=(IOConsole)existing[existing.length - 1];
        }
        OutputStream outputTo;
        if (binaryOutCons != null) {
          outputTo=binaryOutCons.newOutputStream();
          print=new PrintStream(outputTo);
        }
        for (int i=0; i < command.size(); i++) {
          print.print(command.get(i) + ""String_Node_Str"");
        }
        print.println();
        print.println(""String_Node_Str"");
      }
      PerfCore.report(config,getEnvironment(config),workingDirPath,monitor,null,print);
      URI perfDataURI=null;
      IRemoteFileProxy proxy=null;
      perfDataURI=new URI(RemoteProxyManager.getInstance().getRemoteProjectLocation(project) + IPath.SEPARATOR + PerfPlugin.PERF_DEFAULT_DATA);
      proxy=RemoteProxyManager.getInstance().getFileProxy(perfDataURI);
      IFileStore perfDataFileStore=proxy.getResource(perfDataURI.getPath());
      IFileInfo info=perfDataFileStore.fetchInfo();
      info.setAttribute(EFS.ATTRIBUTE_READ_ONLY,true);
      perfDataFileStore.putInfo(info,EFS.SET_ATTRIBUTES,null);
      PerfCore.refreshView(renderProcessLabel(binPath.toPortableString()));
      if (config.getAttribute(PerfPlugin.ATTR_ShowSourceDisassembly,PerfPlugin.ATTR_ShowSourceDisassembly_default)) {
        showSourceDisassembly(Path.fromPortableString(workingDirURI.toString() + IPath.SEPARATOR));
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    abort(e.getLocalizedMessage(),null,ICDTLaunchConfigurationConstants.ERR_INTERNAL_ERROR);
  }
catch (  RemoteConnectionException e) {
    e.printStackTrace();
    abort(e.getLocalizedMessage(),null,ICDTLaunchConfigurationConstants.ERR_INTERNAL_ERROR);
  }
catch (  URISyntaxException e) {
    e.printStackTrace();
    abort(e.getLocalizedMessage(),null,ICDTLaunchConfigurationConstants.ERR_INTERNAL_ERROR);
  }
}","@Override public void launch(ILaunchConfiguration config,String mode,ILaunch launch,IProgressMonitor monitor) throws CoreException {
  try {
    ConfigUtils configUtils=new ConfigUtils(config);
    project=configUtils.getProject();
    if (!PerfCore.checkPerfInPath(project)) {
      IStatus status=new Status(IStatus.ERROR,PerfPlugin.PLUGIN_ID,""String_Node_Str"");
      throw new CoreException(status);
    }
    URI workingDirURI=new URI(config.getAttribute(RemoteProxyCMainTab.ATTR_REMOTE_WORKING_DIRECTORY_NAME,EMPTY_STRING));
    if (workingDirURI.toString().equals(EMPTY_STRING)) {
      workingDirURI=getWorkingDirectory(config).toURI();
      workingDirPath=Path.fromPortableString(workingDirURI.getPath());
      binPath=CDebugUtils.verifyProgramPath(config);
    }
 else {
      workingDirPath=Path.fromPortableString(workingDirURI.getPath() + IPath.SEPARATOR);
      URI binURI=new URI(configUtils.getExecutablePath());
      binPath=Path.fromPortableString(binURI.getPath().toString());
    }
    PerfPlugin.getDefault().setWorkingDir(workingDirPath);
    if (config.getAttribute(PerfPlugin.ATTR_ShowStat,PerfPlugin.ATTR_ShowStat_default)) {
      showStat(config,launch);
    }
 else {
      String perfPathString=RuntimeProcessFactory.getFactory().whichCommand(PerfPlugin.PERF_COMMAND,project);
      IFileStore workingDir;
      RemoteConnection workingDirRC=new RemoteConnection(workingDirURI);
      IRemoteFileProxy workingDirRFP=workingDirRC.getRmtFileProxy();
      workingDir=workingDirRFP.getResource(workingDirURI.getPath());
      String arguments[]=getProgramArgumentsArray(config);
      ArrayList<String> command=new ArrayList<>(4 + arguments.length);
      Version perfVersion=PerfCore.getPerfVersion(config);
      command.addAll(Arrays.asList(PerfCore.getRecordString(config,perfVersion)));
      command.add(binPath.toPortableString());
      command.set(0,perfPathString);
      command.add(2,OUTPUT_STR + PerfPlugin.PERF_DEFAULT_DATA);
      command.addAll(Arrays.asList(arguments));
      String[] commandArray=command.toArray(new String[command.size()]);
      Process pProxy=RuntimeProcessFactory.getFactory().exec(commandArray,getEnvironment(config),workingDir,project);
      MessageConsole console=new MessageConsole(""String_Node_Str"",null);
      console.activate();
      ConsolePlugin.getDefault().getConsoleManager().addConsoles(new IConsole[]{console});
      MessageConsoleStream stream=console.newMessageStream();
      if (pProxy != null) {
        try (BufferedReader error=new BufferedReader(new InputStreamReader(pProxy.getErrorStream()))){
          String err=error.readLine();
          while (err != null) {
            stream.println(err);
            err=error.readLine();
          }
        }
       }
      pProxy.destroy();
      PrintStream print=null;
      if (config.getAttribute(IDebugUIConstants.ATTR_CAPTURE_IN_CONSOLE,true)) {
        ConsolePlugin plugin=ConsolePlugin.getDefault();
        IConsoleManager conMan=plugin.getConsoleManager();
        IConsole[] existing=conMan.getConsoles();
        IOConsole binaryOutCons=null;
        for (        IConsole x : existing) {
          if (x.getName().contains(renderProcessLabel(commandArray[0]))) {
            binaryOutCons=(IOConsole)x;
          }
        }
        if ((binaryOutCons == null) && (existing.length != 0)) {
          if (existing[existing.length - 1] instanceof IOConsole)           binaryOutCons=(IOConsole)existing[existing.length - 1];
        }
        OutputStream outputTo;
        if (binaryOutCons != null) {
          outputTo=binaryOutCons.newOutputStream();
          print=new PrintStream(outputTo);
        }
        for (int i=0; i < command.size(); i++) {
          print.print(command.get(i) + ""String_Node_Str"");
        }
        print.println();
        print.println(""String_Node_Str"");
      }
      PerfCore.report(config,getEnvironment(config),workingDirPath,monitor,null,print);
      URI perfDataURI=null;
      IRemoteFileProxy proxy=null;
      perfDataURI=new URI(workingDirURI.toString() + IPath.SEPARATOR + PerfPlugin.PERF_DEFAULT_DATA);
      proxy=RemoteProxyManager.getInstance().getFileProxy(perfDataURI);
      IFileStore perfDataFileStore=proxy.getResource(perfDataURI.getPath());
      IFileInfo info=perfDataFileStore.fetchInfo();
      info.setAttribute(EFS.ATTRIBUTE_READ_ONLY,true);
      perfDataFileStore.putInfo(info,EFS.SET_ATTRIBUTES,null);
      PerfCore.refreshView(renderProcessLabel(binPath.toPortableString()));
      if (config.getAttribute(PerfPlugin.ATTR_ShowSourceDisassembly,PerfPlugin.ATTR_ShowSourceDisassembly_default)) {
        showSourceDisassembly(Path.fromPortableString(workingDirURI.toString() + IPath.SEPARATOR));
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    abort(e.getLocalizedMessage(),null,ICDTLaunchConfigurationConstants.ERR_INTERNAL_ERROR);
  }
catch (  RemoteConnectionException e) {
    e.printStackTrace();
    abort(e.getLocalizedMessage(),null,ICDTLaunchConfigurationConstants.ERR_INTERNAL_ERROR);
  }
catch (  URISyntaxException e) {
    e.printStackTrace();
    abort(e.getLocalizedMessage(),null,ICDTLaunchConfigurationConstants.ERR_INTERNAL_ERROR);
  }
}",0.8973354980422118
91797,"/** 
 * Parse annotation file for a dso given a symbol
 * @param monitor monitor
 * @param input annotation file input stream
 * @param workingDir working directory configuration
 * @param currentDso dso
 * @param currentSym symbol
 */
public static void parseAnnotation(IProgressMonitor monitor,BufferedReader input,IPath workingDir,PMDso currentDso,PMSymbol currentSym){
  if (monitor != null && monitor.isCanceled()) {
    return;
  }
  boolean grabBlock=false;
  boolean blockStarted=false;
  String dsoName, lineRef;
  String line=null;
  String items[];
  float percent;
  try {
    while ((line=input.readLine()) != null) {
      if (line.startsWith(""String_Node_Str"")) {
        grabBlock=true;
        dsoName=line.replace(""String_Node_Str"",""String_Node_Str"");
        blockStarted=false;
        if ((workingDir != null) && (dsoName.startsWith(""String_Node_Str""))) {
          if (workingDir.toOSString().endsWith(""String_Node_Str"")) {
            dsoName=workingDir.toOSString() + dsoName.substring(2);
          }
 else {
            dsoName=workingDir.toOSString() + dsoName.substring(1);
          }
        }
        currentDso.setPath(dsoName);
      }
 else       if (line.startsWith(""String_Node_Str"")) {
        if (blockStarted) {
          blockStarted=false;
          grabBlock=false;
        }
 else {
          blockStarted=true;
        }
      }
 else       if (grabBlock && blockStarted) {
        items=line.trim().split(""String_Node_Str"");
        if (items.length != 2) {
          continue;
        }
        percent=Float.parseFloat(items[0]);
        lineRef=items[1];
        items=lineRef.split(""String_Node_Str"");
        if (currentDso == null) {
          break;
        }
 else {
          int lineNum=-1;
          try {
            lineNum=Integer.parseInt(items[1]);
          }
 catch (          NumberFormatException e) {
          }
          currentSym.addPercent(lineNum,percent);
          if (currentSym.getParent().getName().equals(PerfPlugin.STRINGS_UnfiledSymbols)) {
            currentSym.getParent().removeChild(currentSym);
            currentDso.getFile(items[0]).addChild(currentSym);
          }
 else           if (!((PMFile)currentSym.getParent()).getPath().equals(items[0])) {
            currentSym.markConflict();
            currentSym.getParent().removeChild(currentSym);
            currentDso.getFile(PerfPlugin.STRINGS_MultipleFilesForSymbol).addChild(currentSym);
          }
        }
      }
    }
  }
 catch (  IOException e) {
    logException(e);
  }
}","/** 
 * Parse annotation file for a dso given a symbol
 * @param monitor monitor
 * @param input annotation file input stream
 * @param workingDir working directory configuration
 * @param currentDso dso
 * @param currentSym symbol
 */
public static void parseAnnotation(IProgressMonitor monitor,BufferedReader input,IPath workingDir,PMDso currentDso,PMSymbol currentSym){
  if (monitor != null && monitor.isCanceled()) {
    return;
  }
  boolean grabBlock=false;
  boolean blockStarted=false;
  String dsoName, lineRef;
  String line=null;
  String items[];
  float percent;
  try {
    while ((line=input.readLine()) != null) {
      if (line.startsWith(""String_Node_Str"")) {
        grabBlock=true;
        dsoName=line.replace(""String_Node_Str"",""String_Node_Str"");
        blockStarted=false;
        if ((workingDir != null) && (dsoName.startsWith(""String_Node_Str""))) {
          if (workingDir.toOSString().endsWith(""String_Node_Str"")) {
            dsoName=workingDir.toOSString() + dsoName.substring(2);
          }
 else {
            dsoName=workingDir.toOSString() + dsoName.substring(1);
          }
        }
        currentDso.setPath(dsoName);
      }
 else       if (line.startsWith(""String_Node_Str"")) {
        if (blockStarted) {
          blockStarted=false;
          grabBlock=false;
        }
 else {
          blockStarted=true;
        }
      }
 else       if (grabBlock && blockStarted) {
        items=line.trim().split(""String_Node_Str"");
        if (items.length != 2) {
          continue;
        }
        percent=Float.parseFloat(items[0]);
        lineRef=items[1];
        items=lineRef.split(""String_Node_Str"");
        if (currentDso == null) {
          break;
        }
 else {
          int lineNum=-1;
          try {
            if (items.length > 1) {
              lineNum=Integer.parseInt(items[1]);
            }
          }
 catch (          NumberFormatException e) {
          }
          currentSym.addPercent(lineNum,percent);
          if (currentSym.getParent().getName().equals(PerfPlugin.STRINGS_UnfiledSymbols)) {
            currentSym.getParent().removeChild(currentSym);
            currentDso.getFile(items[0]).addChild(currentSym);
          }
 else           if (!((PMFile)currentSym.getParent()).getPath().equals(items[0])) {
            currentSym.markConflict();
            currentSym.getParent().removeChild(currentSym);
            currentDso.getFile(PerfPlugin.STRINGS_MultipleFilesForSymbol).addChild(currentSym);
          }
        }
      }
    }
  }
 catch (  IOException e) {
    logException(e);
  }
}",0.98981989036805
91798,"@Test public void testAnnotateString() throws CoreException {
  ILaunchConfigurationWorkingCopy tempConfig=config.copy(""String_Node_Str"");
  tempConfig.setAttribute(PerfPlugin.ATTR_Kernel_Location,""String_Node_Str"");
  tempConfig.setAttribute(PerfPlugin.ATTR_ModuleSymbols,true);
  String[] annotateString=PerfCore.getAnnotateString(tempConfig,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false);
  String[] expectedString=new String[]{PerfPlugin.PERF_COMMAND,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  assertArrayEquals(expectedString,annotateString);
}","@Test public void testAnnotateString() throws CoreException {
  ILaunchConfigurationWorkingCopy tempConfig=config.copy(""String_Node_Str"");
  tempConfig.setAttribute(PerfPlugin.ATTR_Kernel_Location,""String_Node_Str"");
  tempConfig.setAttribute(PerfPlugin.ATTR_ModuleSymbols,true);
  String[] annotateString=PerfCore.getAnnotateString(tempConfig,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false);
  String[] expectedString=new String[]{PerfPlugin.PERF_COMMAND,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  assertArrayEquals(expectedString,annotateString);
}",0.9647979139504564
91799,"public static String[] getAnnotateString(ILaunchConfiguration config,String dso,String symbol,String perfDataLoc,boolean oldPerfVersion){
  ArrayList<String> base=new ArrayList<>();
  if (oldPerfVersion) {
    base.addAll(Arrays.asList(new String[]{PerfPlugin.PERF_COMMAND,""String_Node_Str"",""String_Node_Str"",symbol,""String_Node_Str"",""String_Node_Str""}));
  }
 else {
    base.addAll(Arrays.asList(new String[]{PerfPlugin.PERF_COMMAND,""String_Node_Str"",""String_Node_Str"",dso,""String_Node_Str"",symbol,""String_Node_Str"",""String_Node_Str""}));
  }
  if (config != null) {
    try {
      String kernelLoc=config.getAttribute(PerfPlugin.ATTR_Kernel_Location,PerfPlugin.ATTR_Kernel_Location_default);
      if (!kernelLoc.equals(PerfPlugin.ATTR_Kernel_Location_default)) {
        base.add(""String_Node_Str"");
        base.add(kernelLoc);
      }
      if (config.getAttribute(PerfPlugin.ATTR_ModuleSymbols,PerfPlugin.ATTR_ModuleSymbols_default)) {
        base.add(""String_Node_Str"");
      }
      if (perfDataLoc != null) {
        base.add(""String_Node_Str"");
        base.add(perfDataLoc);
      }
    }
 catch (    CoreException e) {
    }
  }
  return base.toArray(new String[base.size()]);
}","public static String[] getAnnotateString(ILaunchConfiguration config,String dso,String symbol,String perfDataLoc,boolean oldPerfVersion){
  ArrayList<String> base=new ArrayList<>();
  if (oldPerfVersion) {
    base.addAll(Arrays.asList(new String[]{PerfPlugin.PERF_COMMAND,""String_Node_Str"",""String_Node_Str"",symbol,""String_Node_Str"",""String_Node_Str""}));
  }
 else {
    base.addAll(Arrays.asList(new String[]{PerfPlugin.PERF_COMMAND,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",dso,""String_Node_Str"",symbol,""String_Node_Str"",""String_Node_Str""}));
  }
  if (config != null) {
    try {
      String kernelLoc=config.getAttribute(PerfPlugin.ATTR_Kernel_Location,PerfPlugin.ATTR_Kernel_Location_default);
      if (!kernelLoc.equals(PerfPlugin.ATTR_Kernel_Location_default)) {
        base.add(""String_Node_Str"");
        base.add(kernelLoc);
      }
      if (config.getAttribute(PerfPlugin.ATTR_ModuleSymbols,PerfPlugin.ATTR_ModuleSymbols_default)) {
        base.add(""String_Node_Str"");
      }
      if (perfDataLoc != null) {
        base.add(""String_Node_Str"");
        base.add(perfDataLoc);
      }
    }
 catch (    CoreException e) {
    }
  }
  base.add(""String_Node_Str"");
  base.add(""String_Node_Str"");
  return base.toArray(new String[base.size()]);
}",0.967558799675588
91800,"private static void parseRemoteReport(ILaunchConfiguration config,IPath workingDir,IProgressMonitor monitor,String perfDataLoc,PrintStream print,TreeParent invisibleRoot,boolean oldPerfVersion,BufferedReader input,BufferedReader error,IProject project){
  if (monitor != null && monitor.isCanceled()) {
    return;
  }
  String line=null;
  String items[];
  float percent;
  Process p=null;
  double samples;
  String comm, dso, symbol;
  boolean kernelFlag;
  PMEvent currentEvent=null;
  PMCommand currentCommand=null;
  PMDso currentDso=null;
  PMFile currentFile=null;
  PMSymbol currentSym=null;
  try {
    while ((line=input.readLine()) != null) {
      if (monitor != null && monitor.isCanceled()) {
        return;
      }
      if ((line.startsWith(""String_Node_Str""))) {
        if (line.contains(""String_Node_Str"") || line.contains(""String_Node_Str"")) {
          String[] tmp=line.trim().split(""String_Node_Str"");
          String event=tmp[tmp.length - 1];
          if (line.contains(""String_Node_Str"")) {
            event=event.substring(1,event.length() - 1);
          }
          currentEvent=new PMEvent(event);
          invisibleRoot.addChild(currentEvent);
          currentCommand=null;
          currentDso=null;
        }
 else         if (line.contains(""String_Node_Str"")) {
          if (print != null) {
            print.println(""String_Node_Str"");
          }
          invisibleRoot.addChild(new PMEvent(""String_Node_Str""));
        }
      }
 else {
        items=line.trim().split(""String_Node_Str"" + (char)1);
        if (items.length != 5) {
          continue;
        }
        percent=Float.parseFloat(items[0].replace(""String_Node_Str"",""String_Node_Str""));
        samples=Double.parseDouble(items[1].trim());
        comm=items[2].trim();
        dso=items[3].trim();
        symbol=items[4].trim();
        kernelFlag=(""String_Node_Str"" + symbol.charAt(1)).equals(""String_Node_Str"");
        if ((currentCommand == null) || (!currentCommand.getName().equals(comm))) {
          currentCommand=(PMCommand)currentEvent.getChild(comm);
          if (currentCommand == null) {
            currentCommand=new PMCommand(comm);
            currentEvent.addChild(currentCommand);
          }
        }
        if ((currentDso == null) || (!currentDso.getName().equals(dso))) {
          currentDso=(PMDso)currentCommand.getChild(dso);
          if (currentDso == null) {
            currentDso=new PMDso(dso,kernelFlag);
            currentCommand.addChild(currentDso);
          }
        }
        currentFile=currentDso.getFile(PerfPlugin.STRINGS_UnfiledSymbols);
        currentSym=new PMSymbol(symbol,percent,samples);
        currentFile.addChild(currentSym);
      }
    }
  }
 catch (  IOException e) {
    logException(e);
  }
  spitStream(error,""String_Node_Str"",print);
  boolean SourceLineNumbers=PerfPlugin.ATTR_SourceLineNumbers_default;
  boolean Kernel_SourceLineNumbers=PerfPlugin.ATTR_Kernel_SourceLineNumbers_default;
  try {
    SourceLineNumbers=config.getAttribute(PerfPlugin.ATTR_SourceLineNumbers,PerfPlugin.ATTR_SourceLineNumbers_default);
    Kernel_SourceLineNumbers=config.getAttribute(PerfPlugin.ATTR_Kernel_SourceLineNumbers,PerfPlugin.ATTR_Kernel_SourceLineNumbers_default);
  }
 catch (  CoreException e2) {
    SourceLineNumbers=false;
  }
  if (monitor != null && monitor.isCanceled()) {
    return;
  }
  boolean hasProfileData=invisibleRoot.getChildren().length != 0;
  if (SourceLineNumbers) {
    for (    TreeParent ev : invisibleRoot.getChildren()) {
      if (!(ev instanceof PMEvent))       continue;
      for (      TreeParent cmd : ev.getChildren()) {
        if (!(cmd instanceof PMCommand))         continue;
        for (        TreeParent d : cmd.getChildren()) {
          if (!(d instanceof PMDso))           continue;
          currentDso=(PMDso)d;
          if ((!Kernel_SourceLineNumbers) && currentDso.isKernelDso())           continue;
          for (          TreeParent s : currentDso.getFile(PerfPlugin.STRINGS_UnfiledSymbols).getChildren()) {
            if (!(s instanceof PMSymbol))             continue;
            if (monitor != null && monitor.isCanceled()) {
              return;
            }
            currentSym=(PMSymbol)s;
            String[] annotateCmd;
            if (workingDir == null) {
              annotateCmd=getAnnotateString(config,currentDso.getName(),currentSym.getName().substring(4),perfDataLoc,oldPerfVersion);
            }
 else {
              String perfDefaultDataLoc=workingDir + ""String_Node_Str"" + PerfPlugin.PERF_DEFAULT_DATA;
              annotateCmd=getAnnotateString(config,currentDso.getName(),currentSym.getName().substring(4),perfDefaultDataLoc,oldPerfVersion);
            }
            try {
              if (project == null)               p=Runtime.getRuntime().exec(annotateCmd);
 else               p=RuntimeProcessFactory.getFactory().exec(annotateCmd,project);
              input=new BufferedReader(new InputStreamReader(p.getInputStream()));
              error=new BufferedReader(new InputStreamReader(p.getErrorStream()));
            }
 catch (            IOException e) {
              logException(e);
            }
            PerfCore.parseAnnotation(monitor,input,workingDir,currentDso,currentSym);
          }
          if (currentDso.getFile(PerfPlugin.STRINGS_UnfiledSymbols).getChildren().length == 0) {
            currentDso.removeChild(currentDso.getFile(PerfPlugin.STRINGS_UnfiledSymbols));
          }
          spitStream(error,""String_Node_Str"",print);
        }
      }
    }
  }
  if (print != null) {
    if (hasProfileData) {
      print.println(""String_Node_Str"");
    }
 else {
      print.println(""String_Node_Str"");
    }
  }
}","private static void parseRemoteReport(ILaunchConfiguration config,IPath workingDir,IProgressMonitor monitor,String perfDataLoc,PrintStream print,TreeParent invisibleRoot,boolean oldPerfVersion,BufferedReader input,BufferedReader error,IProject project){
  if (monitor != null && monitor.isCanceled()) {
    return;
  }
  String line=null;
  String items[];
  float percent;
  Process p=null;
  double samples;
  String comm, dso, symbol;
  boolean kernelFlag;
  PMEvent currentEvent=null;
  PMCommand currentCommand=null;
  PMDso currentDso=null;
  PMFile currentFile=null;
  PMSymbol currentSym=null;
  try {
    while ((line=input.readLine()) != null) {
      if (monitor != null && monitor.isCanceled()) {
        return;
      }
      if ((line.startsWith(""String_Node_Str""))) {
        if (line.contains(""String_Node_Str"") || line.contains(""String_Node_Str"")) {
          String[] tmp=line.trim().split(""String_Node_Str"");
          String event=tmp[tmp.length - 1];
          if (line.contains(""String_Node_Str"")) {
            event=event.substring(1,event.length() - 1);
          }
          currentEvent=new PMEvent(event);
          invisibleRoot.addChild(currentEvent);
          currentCommand=null;
          currentDso=null;
        }
 else         if (line.contains(""String_Node_Str"")) {
          if (print != null) {
            print.println(""String_Node_Str"");
          }
          invisibleRoot.addChild(new PMEvent(""String_Node_Str""));
        }
      }
 else {
        items=line.trim().split(""String_Node_Str"" + (char)1);
        if (items.length != 5) {
          continue;
        }
        percent=Float.parseFloat(items[0].replace(""String_Node_Str"",""String_Node_Str""));
        samples=Double.parseDouble(items[1].trim());
        comm=items[2].trim();
        dso=items[3].trim();
        symbol=items[4].trim();
        kernelFlag=(""String_Node_Str"" + symbol.charAt(1)).equals(""String_Node_Str"");
        if ((currentCommand == null) || (!currentCommand.getName().equals(comm))) {
          currentCommand=(PMCommand)currentEvent.getChild(comm);
          if (currentCommand == null) {
            currentCommand=new PMCommand(comm);
            currentEvent.addChild(currentCommand);
          }
        }
        if ((currentDso == null) || (!currentDso.getName().equals(dso))) {
          currentDso=(PMDso)currentCommand.getChild(dso);
          if (currentDso == null) {
            currentDso=new PMDso(dso,kernelFlag);
            currentCommand.addChild(currentDso);
          }
        }
        currentFile=currentDso.getFile(PerfPlugin.STRINGS_UnfiledSymbols);
        currentSym=new PMSymbol(symbol,percent,samples);
        currentFile.addChild(currentSym);
      }
    }
  }
 catch (  IOException e) {
    logException(e);
  }
  spitStream(error,""String_Node_Str"",print);
  boolean SourceLineNumbers=PerfPlugin.ATTR_SourceLineNumbers_default;
  boolean Kernel_SourceLineNumbers=PerfPlugin.ATTR_Kernel_SourceLineNumbers_default;
  try {
    SourceLineNumbers=config.getAttribute(PerfPlugin.ATTR_SourceLineNumbers,PerfPlugin.ATTR_SourceLineNumbers_default);
    Kernel_SourceLineNumbers=config.getAttribute(PerfPlugin.ATTR_Kernel_SourceLineNumbers,PerfPlugin.ATTR_Kernel_SourceLineNumbers_default);
  }
 catch (  CoreException e2) {
    SourceLineNumbers=false;
  }
  if (monitor != null && monitor.isCanceled()) {
    return;
  }
  boolean hasProfileData=invisibleRoot.getChildren().length != 0;
  if (SourceLineNumbers) {
    for (    TreeParent ev : invisibleRoot.getChildren()) {
      if (!(ev instanceof PMEvent))       continue;
      for (      TreeParent cmd : ev.getChildren()) {
        if (!(cmd instanceof PMCommand))         continue;
        for (        TreeParent d : cmd.getChildren()) {
          if (!(d instanceof PMDso))           continue;
          currentDso=(PMDso)d;
          if ((!Kernel_SourceLineNumbers) && currentDso.isKernelDso())           continue;
          for (          TreeParent s : currentDso.getFile(PerfPlugin.STRINGS_UnfiledSymbols).getChildren()) {
            if (!(s instanceof PMSymbol))             continue;
            if (monitor != null && monitor.isCanceled()) {
              return;
            }
            currentSym=(PMSymbol)s;
            String[] annotateCmd;
            if (workingDir == null) {
              annotateCmd=getAnnotateString(config,currentDso.getName(),currentSym.getName().substring(4),perfDataLoc,oldPerfVersion);
            }
 else {
              String perfDefaultDataLoc=workingDir + ""String_Node_Str"" + PerfPlugin.PERF_DEFAULT_DATA;
              annotateCmd=getAnnotateString(config,currentDso.getName(),currentSym.getName().substring(4),perfDefaultDataLoc,oldPerfVersion);
            }
            try {
              if (project == null) {
                p=Runtime.getRuntime().exec(annotateCmd);
              }
 else {
                StringBuffer sb=new StringBuffer();
                ArrayList<String> al=new ArrayList<>();
                al.add(""String_Node_Str"");
                al.add(""String_Node_Str"");
                if (workingDir != null) {
                  sb.append(""String_Node_Str"" + workingDir.toOSString() + ""String_Node_Str"");
                }
                for (int i=0; i < annotateCmd.length; i++) {
                  sb.append(annotateCmd[i]);
                  sb.append(""String_Node_Str"");
                }
                al.add(sb.toString());
                p=RuntimeProcessFactory.getFactory().exec(al.toArray(new String[]{}),project);
              }
              input=new BufferedReader(new InputStreamReader(p.getInputStream()));
              error=new BufferedReader(new InputStreamReader(p.getErrorStream()));
            }
 catch (            IOException e) {
              logException(e);
            }
            PerfCore.parseAnnotation(monitor,input,workingDir,currentDso,currentSym);
          }
          if (currentDso.getFile(PerfPlugin.STRINGS_UnfiledSymbols).getChildren().length == 0) {
            currentDso.removeChild(currentDso.getFile(PerfPlugin.STRINGS_UnfiledSymbols));
          }
          spitStream(error,""String_Node_Str"",print);
        }
      }
    }
  }
  if (print != null) {
    if (hasProfileData) {
      print.println(""String_Node_Str"");
    }
 else {
      print.println(""String_Node_Str"");
    }
  }
}",0.9441582183812532
91801,"public ContainerCommitPage(String container){
  super(WizardMessages.getString(NAME));
  setDescription(WizardMessages.getFormattedString(DESC,container.substring(0,8)));
  setTitle(WizardMessages.getString(TITLE));
  setImageDescriptor(SWTImagesFactory.DESC_DOCKER_LARGE);
}","public ContainerCommitPage(String container){
  super(WizardMessages.getString(NAME));
  setDescription(WizardMessages.getFormattedString(DESC,container.substring(0,8)));
  setTitle(WizardMessages.getString(TITLE));
  setImageDescriptor(SWTImagesFactory.DESC_WIZARD);
}",0.9742647058823528
91802,"public ContainerCreatePage(IDockerConnection connection,String image){
  super(WizardMessages.getString(NAME));
  this.connection=connection;
  this.image=image;
  setDescription(WizardMessages.getString(DESC));
  setTitle(WizardMessages.getString(TITLE));
  setImageDescriptor(SWTImagesFactory.DESC_DOCKER_LARGE);
}","public ContainerCreatePage(IDockerConnection connection,String image){
  super(WizardMessages.getString(NAME));
  this.connection=connection;
  this.image=image;
  setDescription(WizardMessages.getString(DESC));
  setTitle(WizardMessages.getString(TITLE));
  setImageDescriptor(SWTImagesFactory.DESC_WIZARD);
}",0.977635782747604
91803,"public ImageBuildPage(){
  super(WizardMessages.getString(NAME));
  setDescription(WizardMessages.getString(DESC));
  setTitle(WizardMessages.getString(TITLE));
  setImageDescriptor(SWTImagesFactory.DESC_DOCKER_LARGE);
}","public ImageBuildPage(){
  super(WizardMessages.getString(NAME));
  setDescription(WizardMessages.getString(DESC));
  setTitle(WizardMessages.getString(TITLE));
  setImageDescriptor(SWTImagesFactory.DESC_WIZARD);
}",0.967741935483871
91804,"public ImagePullPage(){
  super(WizardMessages.getString(NAME));
  setDescription(WizardMessages.getString(DESC));
  setTitle(WizardMessages.getString(TITLE));
  setImageDescriptor(SWTImagesFactory.DESC_DOCKER_LARGE);
}","public ImagePullPage(){
  super(WizardMessages.getString(NAME));
  setDescription(WizardMessages.getString(DESC));
  setTitle(WizardMessages.getString(TITLE));
  setImageDescriptor(SWTImagesFactory.DESC_WIZARD);
}",0.9675925925925926
91805,"public ImagePushPage(IDockerImage image){
  super(WizardMessages.getString(NAME));
  this.image=image;
  setDescription(WizardMessages.getString(DESC));
  setTitle(WizardMessages.getString(TITLE));
  setImageDescriptor(SWTImagesFactory.DESC_DOCKER_LARGE);
}","public ImagePushPage(IDockerImage image){
  super(WizardMessages.getString(NAME));
  this.image=image;
  setDescription(WizardMessages.getString(DESC));
  setTitle(WizardMessages.getString(TITLE));
  setImageDescriptor(SWTImagesFactory.DESC_WIZARD);
}",0.9724409448818898
91806,"public ImageRemovePage(){
  super(WizardMessages.getString(NAME));
  setDescription(WizardMessages.getString(DESC));
  setTitle(WizardMessages.getString(TITLE));
  setImageDescriptor(SWTImagesFactory.DESC_DOCKER_LARGE);
}","public ImageRemovePage(){
  super(WizardMessages.getString(NAME));
  setDescription(WizardMessages.getString(DESC));
  setTitle(WizardMessages.getString(TITLE));
  setImageDescriptor(SWTImagesFactory.DESC_WIZARD);
}",0.9678899082568808
91807,"public ImageRemoveTagPage(IDockerImage image){
  super(WizardMessages.getString(NAME));
  setDescription(WizardMessages.getString(DESC));
  setTitle(WizardMessages.getString(TITLE));
  setImageDescriptor(SWTImagesFactory.DESC_DOCKER_LARGE);
  this.image=image;
}","public ImageRemoveTagPage(IDockerImage image){
  super(WizardMessages.getString(NAME));
  setDescription(WizardMessages.getString(DESC));
  setTitle(WizardMessages.getString(TITLE));
  setImageDescriptor(SWTImagesFactory.DESC_WIZARD);
  this.image=image;
}",0.972972972972973
91808,"public ImageTagPage(String image){
  super(WizardMessages.getString(NAME));
  setDescription(WizardMessages.getString(DESC));
  setTitle(WizardMessages.getString(TITLE));
  setImageDescriptor(SWTImagesFactory.DESC_DOCKER_LARGE);
}","public ImageTagPage(String image){
  super(WizardMessages.getString(NAME));
  setDescription(WizardMessages.getString(DESC));
  setTitle(WizardMessages.getString(TITLE));
  setImageDescriptor(SWTImagesFactory.DESC_WIZARD);
}",0.9691629955947136
91809,"private void performTagImage(final ImageTag wizard){
  final Job tagImageJob=new Job(DVMessages.getString(TAG_IMAGE_JOB_TITLE)){
    @Override protected IStatus run(    final IProgressMonitor monitor){
      final String tag=wizard.getTag();
      monitor.beginTask(DVMessages.getString(TAG_IMAGE_MSG),2);
      try {
        ((DockerConnection)connection).tagImage(image.id(),tag);
        monitor.worked(1);
        ((DockerConnection)connection).getImages(true);
        monitor.worked(1);
      }
 catch (      final DockerException e) {
        Display.getDefault().syncExec(new Runnable(){
          @Override public void run(){
            MessageDialog.openError(Display.getCurrent().getActiveShell(),DVMessages.getFormattedString(ERROR_TAGGING_IMAGE,tag),e.getMessage());
          }
        }
);
      }
catch (      InterruptedException e) {
      }
 finally {
        monitor.done();
      }
      return Status.OK_STATUS;
    }
  }
;
  tagImageJob.schedule();
}","private void performTagImage(final ImageTag wizard){
  final Job tagImageJob=new Job(DVMessages.getString(TAG_IMAGE_JOB_TITLE)){
    @Override protected IStatus run(    final IProgressMonitor monitor){
      final String tag=wizard.getTag();
      monitor.beginTask(DVMessages.getFormattedString(TAG_IMAGE_MSG,tag),2);
      try {
        ((DockerConnection)connection).tagImage(image.id(),tag);
        monitor.worked(1);
        ((DockerConnection)connection).getImages(true);
        monitor.worked(1);
      }
 catch (      final DockerException e) {
        Display.getDefault().syncExec(new Runnable(){
          @Override public void run(){
            MessageDialog.openError(Display.getCurrent().getActiveShell(),DVMessages.getFormattedString(ERROR_TAGGING_IMAGE,tag),e.getMessage());
          }
        }
);
      }
catch (      InterruptedException e) {
      }
 finally {
        monitor.done();
      }
      return Status.OK_STATUS;
    }
  }
;
  tagImageJob.schedule();
}",0.993370729219786
91810,"private void performPullImage(final ImagePull wizard){
  final Job pullImageJob=new Job(DVMessages.getString(PULL_IMAGE_JOB_TITLE)){
    @Override protected IStatus run(    final IProgressMonitor monitor){
      final String id=wizard.getImageId();
      monitor.beginTask(DVMessages.getString(PULL_IMAGE_JOB_TITLE),1);
      try {
        ((DockerConnection)connection).pullImage(id,new ImagePullProgressHandler(connection,id));
        monitor.worked(1);
      }
 catch (      final DockerException e) {
        Display.getDefault().syncExec(new Runnable(){
          @Override public void run(){
            MessageDialog.openError(Display.getCurrent().getActiveShell(),DVMessages.getFormattedString(ERROR_PULLING_IMAGE,id),e.getMessage());
          }
        }
);
      }
catch (      InterruptedException e) {
      }
 finally {
        monitor.done();
      }
      return Status.OK_STATUS;
    }
  }
;
  pullImageJob.schedule();
}","private void performPullImage(final ImagePull wizard){
  final Job pullImageJob=new Job(DVMessages.getFormattedString(PULL_IMAGE_JOB_TITLE,wizard.getImageId())){
    @Override protected IStatus run(    final IProgressMonitor monitor){
      final String id=wizard.getImageId();
      monitor.beginTask(DVMessages.getString(PULL_IMAGE_JOB_TASK),IProgressMonitor.UNKNOWN);
      try {
        ((DockerConnection)connection).pullImage(id,new ImagePullProgressHandler(connection,id));
      }
 catch (      final DockerException e) {
        Display.getDefault().syncExec(new Runnable(){
          @Override public void run(){
            MessageDialog.openError(Display.getCurrent().getActiveShell(),DVMessages.getFormattedString(ERROR_PULLING_IMAGE,id),e.getMessage());
          }
        }
);
      }
catch (      InterruptedException e) {
      }
 finally {
        monitor.done();
      }
      return Status.OK_STATUS;
    }
  }
;
  pullImageJob.schedule();
}",0.9536842105263158
91811,"private void performPushImage(final ImagePush wizard){
  final Job pushImageJob=new Job(DVMessages.getString(PUSH_IMAGE_JOB_TITLE)){
    @Override protected IStatus run(    final IProgressMonitor monitor){
      final String tag=wizard.getImageTag();
      monitor.beginTask(DVMessages.getString(PUSH_IMAGE_JOB_TITLE),1);
      try {
        ((DockerConnection)connection).pushImage(tag,new ImagePushProgressHandler(connection,tag));
        monitor.worked(1);
      }
 catch (      final DockerException e) {
        Display.getDefault().syncExec(new Runnable(){
          @Override public void run(){
            MessageDialog.openError(Display.getCurrent().getActiveShell(),DVMessages.getFormattedString(ERROR_PUSHING_IMAGE,tag),e.getMessage());
          }
        }
);
      }
catch (      InterruptedException e) {
      }
 finally {
        monitor.done();
      }
      return Status.OK_STATUS;
    }
  }
;
  pushImageJob.schedule();
}","private void performPushImage(final ImagePush wizard){
  final Job pushImageJob=new Job(DVMessages.getFormattedString(PUSH_IMAGE_JOB_TITLE,wizard.getImageTag())){
    @Override protected IStatus run(    final IProgressMonitor monitor){
      final String tag=wizard.getImageTag();
      monitor.beginTask(DVMessages.getString(PUSH_IMAGE_JOB_TASK),IProgressMonitor.UNKNOWN);
      try {
        ((DockerConnection)connection).pushImage(tag,new ImagePushProgressHandler(connection,tag));
      }
 catch (      final DockerException e) {
        Display.getDefault().syncExec(new Runnable(){
          @Override public void run(){
            MessageDialog.openError(Display.getCurrent().getActiveShell(),DVMessages.getFormattedString(ERROR_PUSHING_IMAGE,tag),e.getMessage());
          }
        }
);
      }
catch (      InterruptedException e) {
      }
 finally {
        monitor.done();
      }
      return Status.OK_STATUS;
    }
  }
;
  pushImageJob.schedule();
}",0.9534275248560964
91812,"@Override public void launch(ILaunchConfiguration config,String mode,ILaunch launch,IProgressMonitor monitor) throws CoreException {
  this.config=config;
  Oprofile.OprofileProject.setProject(getProject());
  LaunchOptions options=new LaunchOptions();
  options.loadConfiguration(config);
  IPath exePath=getExePath(config);
  options.setBinaryImage(exePath.toOSString());
  Oprofile.OprofileProject.setProfilingBinary(options.getOprofileComboText());
  String appArgs[]=getProgramArgumentsArray(config);
  String appEnv[]=getEnvironment(config);
  OprofileDaemonEvent[] daemonEvents=null;
  ArrayList<OprofileDaemonEvent> events=new ArrayList<>();
  if (!config.getAttribute(OprofileLaunchPlugin.ATTR_USE_DEFAULT_EVENT,false)) {
    OprofileCounter[] counters=oprofileCounters(config);
    for (int i=0; i < counters.length; ++i) {
      if (counters[i].getEnabled()) {
        OprofileDaemonEvent[] counterEvents=counters[i].getDaemonEvents();
        events.addAll(Arrays.asList(counterEvents));
      }
    }
    daemonEvents=new OprofileDaemonEvent[events.size()];
    events.toArray(daemonEvents);
  }
  if (!preExec(options,daemonEvents,launch)) {
    return;
  }
  Process process=null;
  if (OprofileProject.getProfilingBinary().equals(OprofileProject.OPCONTROL_BINARY)) {
    IRemoteCommandLauncher launcher=RemoteProxyManager.getInstance().getLauncher(oprofileProject());
    IPath workingDirPath=new Path(oprofileWorkingDirURI(config).getPath());
    for (int i=0; i < options.getExecutionsNumber(); i++) {
      process=launcher.execute(exePath,appArgs,appEnv,workingDirPath,monitor);
      DebugPlugin.newProcess(launch,process,renderProcessLabel(exePath.toOSString()));
      try {
        process.waitFor();
      }
 catch (      InterruptedException e) {
        process.destroy();
        Status status=new Status(IStatus.ERROR,OprofileLaunchPlugin.PLUGIN_ID,OprofileLaunchMessages.getString(""String_Node_Str""));
        throw new CoreException(status);
      }
    }
  }
  if (OprofileProject.getProfilingBinary().equals(OprofileProject.OPERF_BINARY)) {
    String eventsString=null;
    StringBuilder spec=new StringBuilder();
    spec.append(EVENTS);
    boolean isCommaAllowed=false;
    for (int i=0; i < events.size(); i++) {
      OprofileDaemonEvent event=events.get(i);
      if (isCommaAllowed) {
        spec.append(',');
      }
      spec.append(event.getEvent().getText());
      spec.append(OPD_SETUP_EVENT_SEPARATOR);
      spec.append(event.getResetCount());
      spec.append(OPD_SETUP_EVENT_SEPARATOR);
      spec.append(event.getEvent().getUnitMask().getMaskValue());
      spec.append(OPD_SETUP_EVENT_SEPARATOR);
      spec.append((event.getProfileKernel() ? OPD_SETUP_EVENT_TRUE : OPD_SETUP_EVENT_FALSE));
      spec.append(OPD_SETUP_EVENT_SEPARATOR);
      spec.append((event.getProfileUser() ? OPD_SETUP_EVENT_TRUE : OPD_SETUP_EVENT_FALSE));
      isCommaAllowed=true;
    }
    eventsString=spec.toString();
    ArrayList<String> argArray=new ArrayList<>(Arrays.asList(appArgs));
    IRemoteFileProxy proxy=RemoteProxyManager.getInstance().getFileProxy(OprofileProject.getProject());
    IFileStore dataFolder=proxy.getResource(oprofileWorkingDirURI(config).getPath() + IPath.SEPARATOR + OPROFILE_DATA);
    if (!dataFolder.fetchInfo().exists()) {
      dataFolder.mkdir(EFS.SHALLOW,null);
    }
    argArray.add(0,exePath.toOSString());
    if (events.size() > 0) {
      argArray.add(0,eventsString);
    }
    argArray.add(0,SESSION_DIR + oprofileWorkingDirURI(config).getPath() + IPath.SEPARATOR+ OPROFILE_DATA);
    argArray.add(0,OprofileProject.OPERF_BINARY);
    for (int i=0; i < options.getExecutionsNumber(); i++) {
      if (i != 0) {
        argArray.add(APPEND);
      }
      String[] arguments=new String[argArray.size()];
      arguments=argArray.toArray(arguments);
      try {
        process=RuntimeProcessFactory.getFactory().exec(arguments,appEnv,OprofileProject.getProject());
      }
 catch (      IOException e1) {
        process.destroy();
        Status status=new Status(IStatus.ERROR,OprofileLaunchPlugin.PLUGIN_ID,OprofileLaunchMessages.getString(""String_Node_Str""));
        throw new CoreException(status);
      }
      DebugPlugin.newProcess(launch,process,renderProcessLabel(exePath.toOSString()));
      try {
        process.waitFor();
      }
 catch (      InterruptedException e) {
        process.destroy();
        Status status=new Status(IStatus.ERROR,OprofileLaunchPlugin.PLUGIN_ID,OprofileLaunchMessages.getString(""String_Node_Str""));
        throw new CoreException(status);
      }
    }
  }
  postExec(options,daemonEvents,process);
}","@Override public void launch(ILaunchConfiguration config,String mode,ILaunch launch,IProgressMonitor monitor) throws CoreException {
  this.config=config;
  Oprofile.OprofileProject.setProject(getProject());
  LaunchOptions options=new LaunchOptions();
  options.loadConfiguration(config);
  IPath exePath=getExePath(config);
  options.setBinaryImage(exePath.toOSString());
  Oprofile.OprofileProject.setProfilingBinary(options.getOprofileComboText());
  String appArgs[]=getProgramArgumentsArray(config);
  String appEnv[]=getEnvironment(config);
  OprofileDaemonEvent[] daemonEvents=null;
  ArrayList<OprofileDaemonEvent> events=new ArrayList<>();
  if (!config.getAttribute(OprofileLaunchPlugin.ATTR_USE_DEFAULT_EVENT,false)) {
    OprofileCounter[] counters=oprofileCounters(config);
    for (int i=0; i < counters.length; ++i) {
      if (counters[i].getEnabled()) {
        OprofileDaemonEvent[] counterEvents=counters[i].getDaemonEvents();
        events.addAll(Arrays.asList(counterEvents));
      }
    }
    daemonEvents=new OprofileDaemonEvent[events.size()];
    events.toArray(daemonEvents);
  }
  if (!preExec(options,daemonEvents,launch)) {
    return;
  }
  Process process=null;
  if (OprofileProject.getProfilingBinary().equals(OprofileProject.OPCONTROL_BINARY)) {
    IRemoteCommandLauncher launcher=RemoteProxyManager.getInstance().getLauncher(oprofileProject());
    IPath workingDirPath=new Path(oprofileWorkingDirURI(config).getPath());
    for (int i=0; i < options.getExecutionsNumber(); i++) {
      process=launcher.execute(exePath,appArgs,appEnv,workingDirPath,monitor);
      DebugPlugin.newProcess(launch,process,renderProcessLabel(exePath.toOSString()));
      try {
        process.waitFor();
      }
 catch (      InterruptedException e) {
        process.destroy();
        Status status=new Status(IStatus.ERROR,OprofileLaunchPlugin.PLUGIN_ID,OprofileLaunchMessages.getString(""String_Node_Str""));
        throw new CoreException(status);
      }
    }
  }
  if (OprofileProject.getProfilingBinary().equals(OprofileProject.OPERF_BINARY)) {
    String eventsString=null;
    StringBuilder spec=new StringBuilder();
    spec.append(EVENTS);
    boolean isCommaAllowed=false;
    for (int i=0; i < events.size(); i++) {
      OprofileDaemonEvent event=events.get(i);
      if (isCommaAllowed) {
        spec.append(',');
      }
      spec.append(event.getEvent().getText());
      spec.append(OPD_SETUP_EVENT_SEPARATOR);
      spec.append(event.getResetCount());
      spec.append(OPD_SETUP_EVENT_SEPARATOR);
      spec.append(event.getEvent().getUnitMask().getMaskValue());
      spec.append(OPD_SETUP_EVENT_SEPARATOR);
      spec.append((event.getProfileKernel() ? OPD_SETUP_EVENT_TRUE : OPD_SETUP_EVENT_FALSE));
      spec.append(OPD_SETUP_EVENT_SEPARATOR);
      spec.append((event.getProfileUser() ? OPD_SETUP_EVENT_TRUE : OPD_SETUP_EVENT_FALSE));
      isCommaAllowed=true;
    }
    eventsString=spec.toString();
    ArrayList<String> argArray=new ArrayList<>(Arrays.asList(appArgs));
    IRemoteFileProxy proxy=RemoteProxyManager.getInstance().getFileProxy(OprofileProject.getProject());
    IFileStore dataFolder=proxy.getResource(oprofileWorkingDirURI(config).getPath() + IPath.SEPARATOR + OPROFILE_DATA);
    if (!dataFolder.fetchInfo().exists()) {
      dataFolder.mkdir(EFS.SHALLOW,null);
    }
    argArray.add(0,exePath.toOSString());
    if (events.size() > 0) {
      argArray.add(0,eventsString);
    }
    argArray.add(0,SESSION_DIR + oprofileWorkingDirURI(config).getPath() + IPath.SEPARATOR+ OPROFILE_DATA);
    argArray.add(0,OprofileProject.OPERF_BINARY);
    boolean appended=false;
    for (int i=0; i < options.getExecutionsNumber(); i++) {
      if (!appended && i != 0) {
        argArray.add(1,APPEND);
        appended=true;
      }
      String[] arguments=new String[argArray.size()];
      arguments=argArray.toArray(arguments);
      try {
        process=RuntimeProcessFactory.getFactory().exec(arguments,appEnv,OprofileProject.getProject());
      }
 catch (      IOException e1) {
        process.destroy();
        Status status=new Status(IStatus.ERROR,OprofileLaunchPlugin.PLUGIN_ID,OprofileLaunchMessages.getString(""String_Node_Str""));
        throw new CoreException(status);
      }
      DebugPlugin.newProcess(launch,process,renderProcessLabel(exePath.toOSString()));
      try {
        process.waitFor();
      }
 catch (      InterruptedException e) {
        process.destroy();
        Status status=new Status(IStatus.ERROR,OprofileLaunchPlugin.PLUGIN_ID,OprofileLaunchMessages.getString(""String_Node_Str""));
        throw new CoreException(status);
      }
    }
  }
  postExec(options,daemonEvents,process);
}",0.9929184549356224
91813,"@Override public void createControl(Composite parent){
  options=new LaunchOptions();
  Composite top=new Composite(parent,SWT.NONE);
  setControl(top);
  top.setLayout(new GridLayout());
  GridData data;
  GridLayout layout;
  createVerticalSpacer(top,1);
  Composite p=new Composite(top,SWT.NONE);
  layout=new GridLayout();
  layout.numColumns=2;
  layout.marginHeight=0;
  layout.marginWidth=0;
  p.setLayout(layout);
  data=new GridData(GridData.FILL_HORIZONTAL);
  p.setLayoutData(data);
  Label l2=new Label(p,SWT.NONE);
  l2.setText(OprofileLaunchMessages.getString(""String_Node_Str""));
  data=new GridData();
  data.horizontalSpan=2;
  l2.setLayoutData(data);
  controlCombo=new CCombo(p,SWT.DROP_DOWN | SWT.READ_ONLY | SWT.BORDER);
  List<String> tools=Arrays.asList(OprofileProject.OPERF_BINARY);
  try {
    Process proc=RuntimeProcessFactory.getFactory().exec(new String[]{""String_Node_Str"",OprofileProject.OPCONTROL_BINARY},null);
    if (proc.waitFor() == 0) {
      tools.add(OprofileProject.OPCONTROL_BINARY);
    }
  }
 catch (  Exception e) {
  }
  controlCombo.setItems(tools.toArray(new String[0]));
  controlCombo.select(0);
  controlCombo.addModifyListener(new ModifyListener(){
    @Override public void modifyText(    ModifyEvent mev){
      OprofileProject.setProfilingBinary(controlCombo.getText());
      options.setOprofileComboText(controlCombo.getText());
      if (controlCombo.getText().equals(OprofileProject.OPERF_BINARY)) {
        checkSeparateLibrary.setEnabled(false);
        checkSeparateKernel.setEnabled(false);
        kernelImageFileText.setEnabled(false);
        kernelLabel.setEnabled(false);
      }
 else {
        checkSeparateLibrary.setEnabled(true);
        checkSeparateKernel.setEnabled(true);
        kernelImageFileText.setEnabled(true);
        kernelLabel.setEnabled(true);
      }
      updateLaunchConfigurationDialog();
    }
  }
);
  data=new GridData();
  data.horizontalSpan=2;
  controlCombo.setLayoutData(data);
  kernelLabel=new Label(p,SWT.NONE);
  kernelLabel.setText(OprofileLaunchMessages.getString(""String_Node_Str""));
  kernelLabel.setEnabled(false);
  data=new GridData();
  data.horizontalSpan=2;
  kernelLabel.setLayoutData(data);
  kernelImageFileText=new Text(p,SWT.SINGLE | SWT.BORDER);
  data=new GridData(GridData.FILL_HORIZONTAL);
  kernelImageFileText.setLayoutData(data);
  kernelImageFileText.addModifyListener(new ModifyListener(){
    @Override public void modifyText(    ModifyEvent mev){
      handleKernelImageFileTextModify(kernelImageFileText);
    }
  }
);
  Button button=createPushButton(p,OprofileLaunchMessages.getString(""String_Node_Str""),null);
  final Shell shell=top.getShell();
  button.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent sev){
      showFileDialog(shell);
    }
  }
);
  createVerticalSpacer(top,1);
  p=new Composite(top,SWT.NONE);
  layout=new GridLayout();
  layout.numColumns=1;
  layout.marginHeight=0;
  layout.marginWidth=0;
  p.setLayout(layout);
  data=new GridData(GridData.FILL_HORIZONTAL);
  data.horizontalSpan=2;
  p.setLayoutData(data);
  checkSeparateLibrary=myCreateCheckButton(p,OprofileLaunchMessages.getString(""String_Node_Str""));
  checkSeparateKernel=myCreateCheckButton(p,OprofileLaunchMessages.getString(""String_Node_Str""));
  Composite executionsComposite=new Composite(top,SWT.NONE);
  GridLayout gridLayout=new GridLayout(2,false);
  executionsComposite.setLayout(gridLayout);
  Label executionsLabel=new Label(executionsComposite,SWT.LEFT);
  executionsLabel.setText(OprofileLaunchMessages.getString(""String_Node_Str""));
  executionsLabel.setToolTipText(OprofileLaunchMessages.getString(""String_Node_Str""));
  executionsSpinner=new Spinner(executionsComposite,SWT.BORDER);
  executionsSpinner.setMinimum(1);
  executionsSpinner.addModifyListener(new ModifyListener(){
    @Override public void modifyText(    ModifyEvent e){
      options.setExecutionsNumber(executionsSpinner.getSelection());
      updateLaunchConfigurationDialog();
    }
  }
);
}","@Override public void createControl(Composite parent){
  options=new LaunchOptions();
  Composite top=new Composite(parent,SWT.NONE);
  setControl(top);
  top.setLayout(new GridLayout());
  GridData data;
  GridLayout layout;
  createVerticalSpacer(top,1);
  Composite p=new Composite(top,SWT.NONE);
  layout=new GridLayout();
  layout.numColumns=2;
  layout.marginHeight=0;
  layout.marginWidth=0;
  p.setLayout(layout);
  data=new GridData(GridData.FILL_HORIZONTAL);
  p.setLayoutData(data);
  Label l2=new Label(p,SWT.NONE);
  l2.setText(OprofileLaunchMessages.getString(""String_Node_Str""));
  data=new GridData();
  data.horizontalSpan=2;
  l2.setLayoutData(data);
  controlCombo=new CCombo(p,SWT.DROP_DOWN | SWT.READ_ONLY | SWT.BORDER);
  List<String> tools=new ArrayList<>(Arrays.asList(OprofileProject.OPERF_BINARY));
  try {
    Process proc=RuntimeProcessFactory.getFactory().exec(new String[]{""String_Node_Str"",OprofileProject.OPCONTROL_BINARY},null);
    if (proc.waitFor() == 0) {
      tools.add(OprofileProject.OPCONTROL_BINARY);
    }
  }
 catch (  Exception e) {
  }
  controlCombo.setItems(tools.toArray(new String[0]));
  controlCombo.select(0);
  controlCombo.addModifyListener(new ModifyListener(){
    @Override public void modifyText(    ModifyEvent mev){
      OprofileProject.setProfilingBinary(controlCombo.getText());
      options.setOprofileComboText(controlCombo.getText());
      if (controlCombo.getText().equals(OprofileProject.OPERF_BINARY)) {
        checkSeparateLibrary.setEnabled(false);
        checkSeparateKernel.setEnabled(false);
        kernelImageFileText.setEnabled(false);
        kernelLabel.setEnabled(false);
      }
 else {
        checkSeparateLibrary.setEnabled(true);
        checkSeparateKernel.setEnabled(true);
        kernelImageFileText.setEnabled(true);
        kernelLabel.setEnabled(true);
      }
      updateLaunchConfigurationDialog();
    }
  }
);
  data=new GridData();
  data.horizontalSpan=2;
  controlCombo.setLayoutData(data);
  kernelLabel=new Label(p,SWT.NONE);
  kernelLabel.setText(OprofileLaunchMessages.getString(""String_Node_Str""));
  kernelLabel.setEnabled(false);
  data=new GridData();
  data.horizontalSpan=2;
  kernelLabel.setLayoutData(data);
  kernelImageFileText=new Text(p,SWT.SINGLE | SWT.BORDER);
  data=new GridData(GridData.FILL_HORIZONTAL);
  kernelImageFileText.setLayoutData(data);
  kernelImageFileText.addModifyListener(new ModifyListener(){
    @Override public void modifyText(    ModifyEvent mev){
      handleKernelImageFileTextModify(kernelImageFileText);
    }
  }
);
  Button button=createPushButton(p,OprofileLaunchMessages.getString(""String_Node_Str""),null);
  final Shell shell=top.getShell();
  button.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent sev){
      showFileDialog(shell);
    }
  }
);
  createVerticalSpacer(top,1);
  p=new Composite(top,SWT.NONE);
  layout=new GridLayout();
  layout.numColumns=1;
  layout.marginHeight=0;
  layout.marginWidth=0;
  p.setLayout(layout);
  data=new GridData(GridData.FILL_HORIZONTAL);
  data.horizontalSpan=2;
  p.setLayoutData(data);
  checkSeparateLibrary=myCreateCheckButton(p,OprofileLaunchMessages.getString(""String_Node_Str""));
  checkSeparateKernel=myCreateCheckButton(p,OprofileLaunchMessages.getString(""String_Node_Str""));
  Composite executionsComposite=new Composite(top,SWT.NONE);
  GridLayout gridLayout=new GridLayout(2,false);
  executionsComposite.setLayout(gridLayout);
  Label executionsLabel=new Label(executionsComposite,SWT.LEFT);
  executionsLabel.setText(OprofileLaunchMessages.getString(""String_Node_Str""));
  executionsLabel.setToolTipText(OprofileLaunchMessages.getString(""String_Node_Str""));
  executionsSpinner=new Spinner(executionsComposite,SWT.BORDER);
  executionsSpinner.setMinimum(1);
  executionsSpinner.addModifyListener(new ModifyListener(){
    @Override public void modifyText(    ModifyEvent e){
      options.setExecutionsNumber(executionsSpinner.getSelection());
      updateLaunchConfigurationDialog();
    }
  }
);
}",0.9979066617411648
91814,"@Override public boolean isEnabled(){
  IWorkbenchWindow window=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
  if (window == null) {
    return false;
  }
  IWorkbenchPage page=window.getActivePage();
  IWorkbenchPart part=page.getActivePart();
  if (part instanceof FilterView) {
    FilterView tcv=(FilterView)part;
    ISelection selection=tcv.getSite().getSelectionProvider().getSelection();
    if (!selection.isEmpty()) {
      return true;
    }
  }
  return false;
}","@Override public boolean isEnabled(){
  IWorkbenchWindow window=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
  if (window == null) {
    return false;
  }
  IWorkbenchPage page=window.getActivePage();
  IWorkbenchPart part=page.getActivePart();
  if (part instanceof FilterView) {
    FilterView tcv=(FilterView)part;
    ISelection selection=tcv.getSite().getSelectionProvider().getSelection();
    if (!selection.isEmpty() && tcv.isTreeInFocus()) {
      return true;
    }
  }
  return false;
}",0.9767441860465116
91815,"@Override public boolean isEnabled(){
  IWorkbenchWindow window=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
  if (window == null) {
    return false;
  }
  IWorkbenchPage page=window.getActivePage();
  IWorkbenchPart part=page.getActivePart();
  if (part instanceof FilterView) {
    FilterView tcv=(FilterView)part;
    ISelection selection=tcv.getSite().getSelectionProvider().getSelection();
    if (!selection.isEmpty()) {
      return true;
    }
  }
  return false;
}","@Override public boolean isEnabled(){
  IWorkbenchWindow window=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
  if (window == null) {
    return false;
  }
  IWorkbenchPage page=window.getActivePage();
  IWorkbenchPart part=page.getActivePart();
  if (part instanceof FilterView) {
    FilterView tcv=(FilterView)part;
    ISelection selection=tcv.getSite().getSelectionProvider().getSelection();
    if (!selection.isEmpty() && tcv.isTreeInFocus()) {
      return true;
    }
  }
  return false;
}",0.9767441860465116
91816,"@Override public boolean isEnabled(){
  IWorkbenchWindow window=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
  if (window == null) {
    return false;
  }
  IWorkbenchPage page=window.getActivePage();
  IWorkbenchPart part=page.getActivePart();
  if (!(part instanceof FilterView)) {
    return false;
  }
  FilterView v=(FilterView)part;
  ITmfFilterTreeNode sel=v.getSelection();
  if (sel == null) {
    sel=v.getFilterRoot();
  }
  ITmfFilterTreeNode objectToPaste=FilterEditUtils.getTransferredTreeNode();
  if (objectToPaste != null && (sel.getValidChildren().contains(objectToPaste.getNodeName()) || TmfFilterNode.NODE_NAME.equals(objectToPaste.getNodeName()))) {
    return true;
  }
  return false;
}","@Override public boolean isEnabled(){
  IWorkbenchWindow window=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
  if (window == null) {
    return false;
  }
  IWorkbenchPage page=window.getActivePage();
  IWorkbenchPart part=page.getActivePart();
  if (!(part instanceof FilterView)) {
    return false;
  }
  FilterView v=(FilterView)part;
  ITmfFilterTreeNode sel=v.getSelection();
  if (sel == null) {
    sel=v.getFilterRoot();
  }
  ITmfFilterTreeNode objectToPaste=FilterEditUtils.getTransferredTreeNode();
  if (v.isTreeInFocus() && objectToPaste != null && (sel.getValidChildren().contains(objectToPaste.getNodeName()) || TmfFilterNode.NODE_NAME.equals(objectToPaste.getNodeName()))) {
    return true;
  }
  return false;
}",0.9855868222374744
91817,"/** 
 * Validates the kernel composite input data.
 * @return true if configured data is valid and can be retrieved.
 */
public boolean isValid(){
  fIsTracepoints=fTracepointsActivateButton.getSelection();
  fIsSysCalls=fSysCallsActivateButton.getSelection();
  fIsDynamicProbe=fProbeActivateButton.getSelection();
  fIsDynamicFunctionProbe=fFunctionActivateButton.getSelection();
  fIsAllTracepoints=false;
  fSelectedEvents=new ArrayList<>();
  if (fIsTracepoints) {
    List<ITraceControlComponent> comps=fProviderGroup.getChildren(KernelProviderComponent.class);
    fIsAllTracepoints=fTracepointsViewer.getChecked(comps.get(0));
    Object[] checkedElements=fTracepointsViewer.getCheckedElements();
    for (int i=0; i < checkedElements.length; i++) {
      ITraceControlComponent component=(ITraceControlComponent)checkedElements[i];
      if (component instanceof BaseEventComponent) {
        fSelectedEvents.add(component.getName());
      }
    }
  }
  if (fIsDynamicProbe) {
    String temp=fProbeEventNameText.getText();
    if (temp.isEmpty() || fProbeText.getText().matches(""String_Node_Str"") || (!temp.matches(""String_Node_Str"") && !temp.matches(""String_Node_Str""))) {
      MessageDialog.openError(getShell(),Messages.TraceControl_EnableEventsDialogTitle,Messages.TraceControl_InvalidProbeNameError + ""String_Node_Str"" + temp+ ""String_Node_Str"");
      return false;
    }
    fProbeEventName=temp;
    fProbeString=fProbeText.getText();
  }
  fFunctionEventName=null;
  fFunctionString=null;
  if (fIsDynamicFunctionProbe) {
    String functionTemp=fFunctionEventNameText.getText();
    if (functionTemp.isEmpty() || functionTemp.matches(""String_Node_Str"") || (!functionTemp.matches(""String_Node_Str"") && !functionTemp.matches(""String_Node_Str""))) {
      MessageDialog.openError(getShell(),Messages.TraceControl_EnableEventsDialogTitle,Messages.TraceControl_InvalidProbeNameError + ""String_Node_Str"" + functionTemp+ ""String_Node_Str"");
      return false;
    }
    fFunctionEventName=functionTemp;
    fFunctionString=fFunctionText.getText();
  }
  return true;
}","/** 
 * Validates the kernel composite input data.
 * @return true if configured data is valid and can be retrieved.
 */
public boolean isValid(){
  fIsTracepoints=fTracepointsActivateButton.getSelection();
  fIsSysCalls=fSysCallsActivateButton.getSelection();
  fIsDynamicProbe=fProbeActivateButton.getSelection();
  fIsDynamicFunctionProbe=fFunctionActivateButton.getSelection();
  fIsAllTracepoints=false;
  fSelectedEvents=new ArrayList<>();
  if (fIsTracepoints) {
    Object[] checkedElements=fTracepointsViewer.getCheckedElements();
    for (int i=0; i < checkedElements.length; i++) {
      ITraceControlComponent component=(ITraceControlComponent)checkedElements[i];
      if (component instanceof BaseEventComponent) {
        fSelectedEvents.add(component.getName());
      }
    }
    int nbEvents=0;
    List<ITraceControlComponent> comps=fProviderGroup.getChildren(KernelProviderComponent.class);
    for (    ITraceControlComponent comp : comps) {
      nbEvents+=comp.getChildren().length;
    }
    fIsAllTracepoints=(nbEvents == fSelectedEvents.size());
  }
  if (fIsDynamicProbe) {
    String temp=fProbeEventNameText.getText();
    if (temp.isEmpty() || fProbeText.getText().matches(""String_Node_Str"") || (!temp.matches(""String_Node_Str"") && !temp.matches(""String_Node_Str""))) {
      MessageDialog.openError(getShell(),Messages.TraceControl_EnableEventsDialogTitle,Messages.TraceControl_InvalidProbeNameError + ""String_Node_Str"" + temp+ ""String_Node_Str"");
      return false;
    }
    fProbeEventName=temp;
    fProbeString=fProbeText.getText();
  }
  fFunctionEventName=null;
  fFunctionString=null;
  if (fIsDynamicFunctionProbe) {
    String functionTemp=fFunctionEventNameText.getText();
    if (functionTemp.isEmpty() || functionTemp.matches(""String_Node_Str"") || (!functionTemp.matches(""String_Node_Str"") && !functionTemp.matches(""String_Node_Str""))) {
      MessageDialog.openError(getShell(),Messages.TraceControl_EnableEventsDialogTitle,Messages.TraceControl_InvalidProbeNameError + ""String_Node_Str"" + functionTemp+ ""String_Node_Str"");
      return false;
    }
    fFunctionEventName=functionTemp;
    fFunctionString=fFunctionText.getText();
  }
  return true;
}",0.8962616822429906
91818,"/** 
 * Validates the UST composite input data.
 * @return true if configured data is valid and can be retrieved.
 */
public boolean isValid(){
  fIsTracepoints=fTracepointsActivateButton.getSelection();
  fIsWildcard=fWildcardActivateButton.getSelection();
  fIsLogLevel=fLogLevelActivateButton.getSelection();
  fIsAllTracepoints=false;
  fSelectedEvents=new ArrayList<>();
  if (fIsTracepoints) {
    fIsAllTracepoints=fTracepointsViewer.getChecked(fProviderGroup);
    Set<String> set=new HashSet<>();
    Object[] checkedElements=fTracepointsViewer.getCheckedElements();
    for (int i=0; i < checkedElements.length; i++) {
      ITraceControlComponent component=(ITraceControlComponent)checkedElements[i];
      if (!set.contains(component.getName()) && (component instanceof BaseEventComponent)) {
        set.add(component.getName());
        fSelectedEvents.add(component.getName());
      }
    }
  }
  fLogLevelType=LogLevelType.LOGLEVEL_NONE;
  fLogLevelEventName=null;
  if (fIsLogLevel) {
    if (fLogLevelButton.getSelection()) {
      fLogLevelType=LogLevelType.LOGLEVEL;
    }
 else     if (fLogLevelOnlyButton.getSelection()) {
      fLogLevelType=LogLevelType.LOGLEVEL_ONLY;
    }
    String temp=fLogLevelEventNameText.getText();
    if (temp.isEmpty() || temp.matches(""String_Node_Str"") || (!temp.matches(""String_Node_Str"") && !temp.matches(""String_Node_Str""))) {
      MessageDialog.openError(getShell(),Messages.TraceControl_EnableEventsDialogTitle,Messages.TraceControl_InvalidLogLevelEventNameError + ""String_Node_Str"" + temp+ ""String_Node_Str"");
      return false;
    }
    fLogLevelEventName=temp;
    TraceLogLevel[] levels=TraceLogLevel.values();
    int id=fLogLevelCombo.getSelectionIndex();
    if (id < 0) {
      MessageDialog.openError(getShell(),Messages.TraceControl_EnableEventsDialogTitle,Messages.TraceControl_InvalidLogLevel + ""String_Node_Str"" + temp+ ""String_Node_Str"");
      return false;
    }
    fLogLevel=levels[id];
  }
  fWildcard=null;
  if (fIsWildcard) {
    String tempWildcard=fWildcardText.getText();
    if (tempWildcard.isEmpty() || tempWildcard.matches(""String_Node_Str"") || (!tempWildcard.matches(""String_Node_Str"") && !tempWildcard.matches(""String_Node_Str""))) {
      MessageDialog.openError(getShell(),Messages.TraceControl_EnableEventsDialogTitle,Messages.TraceControl_InvalidWildcardError + ""String_Node_Str"" + tempWildcard+ ""String_Node_Str"");
      return false;
    }
    fWildcard=tempWildcard;
  }
  fFilterExpression=null;
  if (fProviderGroup.isEventFilteringSupported()) {
    String tempFilter=fFilterText.getText();
    if (!tempFilter.isEmpty() && !tempFilter.matches(""String_Node_Str"")) {
      fFilterExpression=tempFilter;
    }
  }
  return true;
}","/** 
 * Validates the UST composite input data.
 * @return true if configured data is valid and can be retrieved.
 */
public boolean isValid(){
  fIsTracepoints=fTracepointsActivateButton.getSelection();
  fIsWildcard=fWildcardActivateButton.getSelection();
  fIsLogLevel=fLogLevelActivateButton.getSelection();
  fIsAllTracepoints=false;
  fSelectedEvents=new ArrayList<>();
  if (fIsTracepoints) {
    Set<String> set=new HashSet<>();
    Object[] checkedElements=fTracepointsViewer.getCheckedElements();
    int totalNbEvents=0;
    for (int i=0; i < checkedElements.length; i++) {
      ITraceControlComponent component=(ITraceControlComponent)checkedElements[i];
      if (component instanceof BaseEventComponent) {
        totalNbEvents++;
        if (!set.contains(component.getName())) {
          set.add(component.getName());
          fSelectedEvents.add(component.getName());
        }
      }
    }
    int nbUstEvents=0;
    List<ITraceControlComponent> comps=fProviderGroup.getChildren(UstProviderComponent.class);
    for (    ITraceControlComponent comp : comps) {
      nbUstEvents+=comp.getChildren().length;
    }
    fIsAllTracepoints=(nbUstEvents == totalNbEvents);
  }
  fLogLevelType=LogLevelType.LOGLEVEL_NONE;
  fLogLevelEventName=null;
  if (fIsLogLevel) {
    if (fLogLevelButton.getSelection()) {
      fLogLevelType=LogLevelType.LOGLEVEL;
    }
 else     if (fLogLevelOnlyButton.getSelection()) {
      fLogLevelType=LogLevelType.LOGLEVEL_ONLY;
    }
    String temp=fLogLevelEventNameText.getText();
    if (temp.isEmpty() || temp.matches(""String_Node_Str"") || (!temp.matches(""String_Node_Str"") && !temp.matches(""String_Node_Str""))) {
      MessageDialog.openError(getShell(),Messages.TraceControl_EnableEventsDialogTitle,Messages.TraceControl_InvalidLogLevelEventNameError + ""String_Node_Str"" + temp+ ""String_Node_Str"");
      return false;
    }
    fLogLevelEventName=temp;
    TraceLogLevel[] levels=TraceLogLevel.values();
    int id=fLogLevelCombo.getSelectionIndex();
    if (id < 0) {
      MessageDialog.openError(getShell(),Messages.TraceControl_EnableEventsDialogTitle,Messages.TraceControl_InvalidLogLevel + ""String_Node_Str"" + temp+ ""String_Node_Str"");
      return false;
    }
    fLogLevel=levels[id];
  }
  fWildcard=null;
  if (fIsWildcard) {
    String tempWildcard=fWildcardText.getText();
    if (tempWildcard.isEmpty() || tempWildcard.matches(""String_Node_Str"") || (!tempWildcard.matches(""String_Node_Str"") && !tempWildcard.matches(""String_Node_Str""))) {
      MessageDialog.openError(getShell(),Messages.TraceControl_EnableEventsDialogTitle,Messages.TraceControl_InvalidWildcardError + ""String_Node_Str"" + tempWildcard+ ""String_Node_Str"");
      return false;
    }
    fWildcard=tempWildcard;
  }
  fFilterExpression=null;
  if (fProviderGroup.isEventFilteringSupported()) {
    String tempFilter=fFilterText.getText();
    if (!tempFilter.isEmpty() && !tempFilter.matches(""String_Node_Str"")) {
      fFilterExpression=tempFilter;
    }
  }
  return true;
}",0.8758488594811075
91819,"@Override public Process execute(IPath commandPath,String[] args,String[] env,IPath changeToDirectory,IProgressMonitor monitor){
  return execute(commandPath,args,env,changeToDirectory,monitor);
}","@Override public Process execute(IPath commandPath,String[] args,String[] env,IPath changeToDirectory,IProgressMonitor monitor){
  return execute(commandPath,args,env,changeToDirectory,monitor,null);
}",0.9874055415617128
91820,"@Override public Process execute(IPath commandPath,String[] args,String[] env,IPath changeToDirectory,IProgressMonitor monitor) throws CoreException {
  return execute(commandPath,args,env,changeToDirectory,monitor);
}","@Override public Process execute(IPath commandPath,String[] args,String[] env,IPath changeToDirectory,IProgressMonitor monitor) throws CoreException {
  return execute(commandPath,args,env,changeToDirectory,monitor,null);
}",0.9886621315192744
91821,"/** 
 * Executes an Eclipse command with command ID
 * @param commandId
 * @throws ExecutionException
 * @throws NotDefinedException
 * @throws NotEnabledException
 * @throws NotHandledException
 */
public void executeCommand(String commandId) throws ExecutionException, NotDefinedException, NotEnabledException, NotHandledException {
  IHandlerService handlerService=(IHandlerService)fControlView.getSite().getService(IHandlerService.class);
  handlerService.executeCommand(COMMAND_CATEGORY_PREFIX + commandId,null);
  waitForJobs();
}","/** 
 * Executes an Eclipse command with command ID
 * @param commandId
 * @throws ExecutionException
 * @throws NotDefinedException
 * @throws NotEnabledException
 * @throws NotHandledException
 */
public void executeCommand(String commandId) throws ExecutionException, NotDefinedException, NotEnabledException, NotHandledException {
  Object handlerServiceObject=fControlView.getSite().getService(IHandlerService.class);
  IHandlerService handlerService=(IHandlerService)handlerServiceObject;
  handlerService.executeCommand(COMMAND_CATEGORY_PREFIX + commandId,null);
  waitForJobs();
}",0.8701067615658363
91822,"@Override public void run(){
  try {
    IHandlerService handlerService=(IHandlerService)page.getActivePart().getSite().getService(IHandlerService.class);
    boolean executeCommand=((element instanceof TmfTraceElement) || (element instanceof TmfAnalysisOutputElement));
    if (!executeCommand && element instanceof TmfExperimentElement) {
      TmfExperimentElement experiment=(TmfExperimentElement)element;
      executeCommand=(experiment.getTraces().size() > 0);
    }
    if (executeCommand) {
      handlerService.executeCommand(OPEN_COMMAND_ID,null);
    }
  }
 catch (  ExecutionException e) {
    Activator.getDefault().logError(""String_Node_Str"" + element.getName(),e);
  }
catch (  NotDefinedException e) {
    Activator.getDefault().logError(""String_Node_Str"" + element.getName(),e);
  }
catch (  NotEnabledException e) {
    Activator.getDefault().logError(""String_Node_Str"" + element.getName(),e);
  }
catch (  NotHandledException e) {
    Activator.getDefault().logError(""String_Node_Str"" + element.getName(),e);
  }
}","@Override public void run(){
  try {
    Object service=page.getActivePart().getSite().getService(IHandlerService.class);
    IHandlerService handlerService=(IHandlerService)service;
    boolean executeCommand=((element instanceof TmfTraceElement) || (element instanceof TmfAnalysisOutputElement));
    if (!executeCommand && element instanceof TmfExperimentElement) {
      TmfExperimentElement experiment=(TmfExperimentElement)element;
      executeCommand=(experiment.getTraces().size() > 0);
    }
    if (executeCommand) {
      handlerService.executeCommand(OPEN_COMMAND_ID,null);
    }
  }
 catch (  ExecutionException e) {
    Activator.getDefault().logError(""String_Node_Str"" + element.getName(),e);
  }
catch (  NotDefinedException e) {
    Activator.getDefault().logError(""String_Node_Str"" + element.getName(),e);
  }
catch (  NotEnabledException e) {
    Activator.getDefault().logError(""String_Node_Str"" + element.getName(),e);
  }
catch (  NotHandledException e) {
    Activator.getDefault().logError(""String_Node_Str"" + element.getName(),e);
  }
}",0.924618320610687
91823,"/** 
 * Create a pop-up menu.
 */
protected void createPopupMenu(){
  final IAction showTableAction=new Action(Messages.TmfEventsTable_ShowTableActionText){
    @Override public void run(){
      fTable.setVisible(true);
      fSashForm.layout();
    }
  }
;
  final IAction hideTableAction=new Action(Messages.TmfEventsTable_HideTableActionText){
    @Override public void run(){
      fTable.setVisible(false);
      fSashForm.layout();
    }
  }
;
  final IAction showRawAction=new Action(Messages.TmfEventsTable_ShowRawActionText){
    @Override public void run(){
      fRawViewer.setVisible(true);
      fSashForm.layout();
      final int index=fTable.getSelectionIndex();
      if (index >= 1) {
        fRawViewer.selectAndReveal(index - 1);
      }
    }
  }
;
  final IAction hideRawAction=new Action(Messages.TmfEventsTable_HideRawActionText){
    @Override public void run(){
      fRawViewer.setVisible(false);
      fSashForm.layout();
    }
  }
;
  final IAction openCallsiteAction=new Action(Messages.TmfEventsTable_OpenSourceCodeActionText){
    @Override public void run(){
      final TableItem items[]=fTable.getSelection();
      if (items.length != 1) {
        return;
      }
      final TableItem item=items[0];
      final Object data=item.getData();
      if (data instanceof ITmfSourceLookup) {
        ITmfSourceLookup event=(ITmfSourceLookup)data;
        ITmfCallsite cs=event.getCallsite();
        if (cs == null || cs.getFileName() == null) {
          return;
        }
        IMarker marker=null;
        try {
          String fileName=cs.getFileName();
          final String trimmedPath=fileName.replaceAll(""String_Node_Str"",EMPTY_STRING);
          final ArrayList<IFile> files=new ArrayList<>();
          ResourcesPlugin.getWorkspace().getRoot().accept(new IResourceVisitor(){
            @Override public boolean visit(            IResource resource) throws CoreException {
              if (resource instanceof IFile && resource.getFullPath().toString().endsWith(trimmedPath)) {
                files.add((IFile)resource);
              }
              return true;
            }
          }
);
          IFile file=null;
          if (files.size() > 1) {
            ListDialog dialog=new ListDialog(getTable().getShell());
            dialog.setContentProvider(ArrayContentProvider.getInstance());
            dialog.setLabelProvider(new LabelProvider(){
              @Override public String getText(              Object element){
                return ((IFile)element).getFullPath().toString();
              }
            }
);
            dialog.setInput(files);
            dialog.setTitle(Messages.TmfEventsTable_OpenSourceCodeSelectFileDialogTitle);
            dialog.setMessage(Messages.TmfEventsTable_OpenSourceCodeSelectFileDialogTitle + '\n' + cs.toString());
            dialog.open();
            Object[] result=dialog.getResult();
            if (result != null && result.length > 0) {
              file=(IFile)result[0];
            }
          }
 else           if (files.size() == 1) {
            file=files.get(0);
          }
          if (file != null) {
            marker=file.createMarker(IMarker.MARKER);
            marker.setAttribute(IMarker.LINE_NUMBER,Long.valueOf(cs.getLineNumber()).intValue());
            IDE.openEditor(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage(),marker);
            marker.delete();
          }
 else           if (files.size() == 0) {
            displayException(new FileNotFoundException('\'' + cs.toString() + '\''+ '\n'+ Messages.TmfEventsTable_OpenSourceCodeNotFound));
          }
        }
 catch (        CoreException e) {
          displayException(e);
        }
      }
    }
  }
;
  final IAction openModelAction=new Action(Messages.TmfEventsTable_OpenModelActionText){
    @Override public void run(){
      final TableItem items[]=fTable.getSelection();
      if (items.length != 1) {
        return;
      }
      final TableItem item=items[0];
      final Object eventData=item.getData();
      if (eventData instanceof ITmfModelLookup) {
        String modelURI=((ITmfModelLookup)eventData).getModelUri();
        if (modelURI != null) {
          IWorkbenchPage activePage=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
          IFile file=null;
          final URI uri=URI.createURI(modelURI);
          if (uri.isPlatformResource()) {
            IPath path=new Path(uri.toPlatformString(true));
            file=ResourcesPlugin.getWorkspace().getRoot().getFile(path);
          }
 else           if (uri.isFile() && !uri.isRelative()) {
            file=ResourcesPlugin.getWorkspace().getRoot().getFileForLocation(new Path(uri.toFileString()));
          }
          if (file != null) {
            try {
              IMarker marker=file.createMarker(EValidator.MARKER);
              marker.setAttribute(EValidator.URI_ATTRIBUTE,modelURI);
              marker.setAttribute(IMarker.SEVERITY,IMarker.SEVERITY_INFO);
              IDE.openEditor(activePage,marker,OpenStrategy.activateOnOpen());
              marker.delete();
            }
 catch (            CoreException e) {
              displayException(e);
            }
          }
 else {
            displayException(new FileNotFoundException('\'' + modelURI + '\''+ '\n'+ Messages.TmfEventsTable_OpenModelUnsupportedURI));
          }
        }
      }
    }
  }
;
  final IAction exportToTextAction=new Action(Messages.TmfEventsTable_Export_to_text){
    @Override public void run(){
      IWorkbenchPage activePage=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
      IHandlerService handlerService=(IHandlerService)activePage.getActiveEditor().getSite().getService(IHandlerService.class);
      ICommandService cmdService=(ICommandService)activePage.getActiveEditor().getSite().getService(ICommandService.class);
      try {
        HashMap<String,Object> parameters=new HashMap<>();
        Command command=cmdService.getCommand(ExportToTextCommandHandler.COMMAND_ID);
        ParameterizedCommand cmd=ParameterizedCommand.generateCommand(command,parameters);
        IEvaluationContext context=handlerService.getCurrentState();
        List<TmfEventTableColumn> exportColumns=fColumns.subList(EVENT_COLUMNS_START_INDEX,fColumns.size());
        context.addVariable(ExportToTextCommandHandler.TMF_EVENT_TABLE_COLUMNS_ID,exportColumns);
        handlerService.executeCommandInContext(cmd,null,context);
      }
 catch (      ExecutionException e) {
        displayException(e);
      }
catch (      NotDefinedException e) {
        displayException(e);
      }
catch (      NotEnabledException e) {
        displayException(e);
      }
catch (      NotHandledException e) {
        displayException(e);
      }
    }
  }
;
  final IAction showSearchBarAction=new Action(Messages.TmfEventsTable_ShowSearchBarActionText){
    @Override public void run(){
      fHeaderState=HeaderState.SEARCH;
      fTable.refresh();
    }
  }
;
  final IAction showFilterBarAction=new Action(Messages.TmfEventsTable_ShowFilterBarActionText){
    @Override public void run(){
      fHeaderState=HeaderState.FILTER;
      fTable.refresh();
    }
  }
;
  final IAction clearFiltersAction=new Action(Messages.TmfEventsTable_ClearFiltersActionText){
    @Override public void run(){
      clearFilters();
    }
  }
;
  final IAction collapseAction=new Action(Messages.TmfEventsTable_CollapseFilterMenuName){
    @Override public void run(){
      applyFilter(new TmfCollapseFilter());
    }
  }
;
class ToggleBookmarkAction extends Action {
    Long fRank;
    public ToggleBookmarkAction(    final String text,    final Long rank){
      super(text);
      fRank=rank;
    }
    @Override public void run(){
      toggleBookmark(fRank);
    }
  }
  final MenuManager tablePopupMenu=new MenuManager();
  tablePopupMenu.setRemoveAllWhenShown(true);
  tablePopupMenu.addMenuListener(new IMenuListener(){
    @Override public void menuAboutToShow(    final IMenuManager manager){
      if (fTable.getSelectionIndex() == 0) {
        if (fHeaderState == HeaderState.FILTER) {
          tablePopupMenu.add(showSearchBarAction);
        }
 else {
          tablePopupMenu.add(showFilterBarAction);
        }
        return;
      }
      final Point point=fTable.toControl(Display.getDefault().getCursorLocation());
      final TableItem item=fTable.getSelection().length > 0 ? fTable.getSelection()[0] : null;
      if (item != null) {
        final Rectangle imageBounds=item.getImageBounds(0);
        imageBounds.width=BOOKMARK_IMAGE.getBounds().width;
        if (point.x <= (imageBounds.x + imageBounds.width)) {
          final Long rank=(Long)item.getData(Key.RANK);
          if ((rank != null) && (fBookmarksFile != null)) {
            if (fBookmarksMap.containsKey(rank)) {
              tablePopupMenu.add(new ToggleBookmarkAction(Messages.TmfEventsTable_RemoveBookmarkActionText,rank));
            }
 else {
              tablePopupMenu.add(new ToggleBookmarkAction(Messages.TmfEventsTable_AddBookmarkActionText,rank));
            }
          }
          return;
        }
      }
      if (fTable.isVisible() && fRawViewer.isVisible()) {
        tablePopupMenu.add(hideTableAction);
        tablePopupMenu.add(hideRawAction);
      }
 else       if (!fTable.isVisible()) {
        tablePopupMenu.add(showTableAction);
      }
 else       if (!fRawViewer.isVisible()) {
        tablePopupMenu.add(showRawAction);
      }
      tablePopupMenu.add(exportToTextAction);
      tablePopupMenu.add(new Separator());
      if (item != null) {
        final Object data=item.getData();
        Separator separator=null;
        if (data instanceof ITmfSourceLookup) {
          ITmfSourceLookup event=(ITmfSourceLookup)data;
          if (event.getCallsite() != null) {
            tablePopupMenu.add(openCallsiteAction);
            separator=new Separator();
          }
        }
        if (data instanceof ITmfModelLookup) {
          ITmfModelLookup event=(ITmfModelLookup)data;
          if (event.getModelUri() != null) {
            tablePopupMenu.add(openModelAction);
            separator=new Separator();
          }
          if (separator != null) {
            tablePopupMenu.add(separator);
          }
        }
      }
      boolean isCollapsible=false;
      if (fTrace != null) {
        ITmfTrace traces[]=TmfTraceManager.getTraceSet(fTrace);
        for (        ITmfTrace trace : traces) {
          Class<? extends ITmfEvent> eventClass=trace.getEventType();
          isCollapsible=ITmfCollapsibleEvent.class.isAssignableFrom(eventClass);
          if (isCollapsible) {
            break;
          }
        }
      }
      if (isCollapsible && !(fTable.getData(Key.FILTER_OBJ) instanceof TmfCollapseFilter)) {
        tablePopupMenu.add(collapseAction);
        tablePopupMenu.add(new Separator());
      }
      tablePopupMenu.add(clearFiltersAction);
      final ITmfFilterTreeNode[] savedFilters=FilterManager.getSavedFilters();
      if (savedFilters.length > 0) {
        final MenuManager subMenu=new MenuManager(Messages.TmfEventsTable_ApplyPresetFilterMenuName);
        for (        final ITmfFilterTreeNode node : savedFilters) {
          if (node instanceof TmfFilterNode) {
            final TmfFilterNode filter=(TmfFilterNode)node;
            subMenu.add(new Action(filter.getFilterName()){
              @Override public void run(){
                applyFilter(filter);
              }
            }
);
          }
        }
        tablePopupMenu.add(subMenu);
      }
      appendToTablePopupMenu(tablePopupMenu,item);
    }
  }
);
  final MenuManager rawViewerPopupMenu=new MenuManager();
  rawViewerPopupMenu.setRemoveAllWhenShown(true);
  rawViewerPopupMenu.addMenuListener(new IMenuListener(){
    @Override public void menuAboutToShow(    final IMenuManager manager){
      if (fTable.isVisible() && fRawViewer.isVisible()) {
        rawViewerPopupMenu.add(hideTableAction);
        rawViewerPopupMenu.add(hideRawAction);
      }
 else       if (!fTable.isVisible()) {
        rawViewerPopupMenu.add(showTableAction);
      }
 else       if (!fRawViewer.isVisible()) {
        rawViewerPopupMenu.add(showRawAction);
      }
      appendToRawPopupMenu(tablePopupMenu);
    }
  }
);
  Menu menu=tablePopupMenu.createContextMenu(fTable);
  fTable.setMenu(menu);
  menu=rawViewerPopupMenu.createContextMenu(fRawViewer);
  fRawViewer.setMenu(menu);
}","/** 
 * Create a pop-up menu.
 */
protected void createPopupMenu(){
  final IAction showTableAction=new Action(Messages.TmfEventsTable_ShowTableActionText){
    @Override public void run(){
      fTable.setVisible(true);
      fSashForm.layout();
    }
  }
;
  final IAction hideTableAction=new Action(Messages.TmfEventsTable_HideTableActionText){
    @Override public void run(){
      fTable.setVisible(false);
      fSashForm.layout();
    }
  }
;
  final IAction showRawAction=new Action(Messages.TmfEventsTable_ShowRawActionText){
    @Override public void run(){
      fRawViewer.setVisible(true);
      fSashForm.layout();
      final int index=fTable.getSelectionIndex();
      if (index >= 1) {
        fRawViewer.selectAndReveal(index - 1);
      }
    }
  }
;
  final IAction hideRawAction=new Action(Messages.TmfEventsTable_HideRawActionText){
    @Override public void run(){
      fRawViewer.setVisible(false);
      fSashForm.layout();
    }
  }
;
  final IAction openCallsiteAction=new Action(Messages.TmfEventsTable_OpenSourceCodeActionText){
    @Override public void run(){
      final TableItem items[]=fTable.getSelection();
      if (items.length != 1) {
        return;
      }
      final TableItem item=items[0];
      final Object data=item.getData();
      if (data instanceof ITmfSourceLookup) {
        ITmfSourceLookup event=(ITmfSourceLookup)data;
        ITmfCallsite cs=event.getCallsite();
        if (cs == null || cs.getFileName() == null) {
          return;
        }
        IMarker marker=null;
        try {
          String fileName=cs.getFileName();
          final String trimmedPath=fileName.replaceAll(""String_Node_Str"",EMPTY_STRING);
          final ArrayList<IFile> files=new ArrayList<>();
          ResourcesPlugin.getWorkspace().getRoot().accept(new IResourceVisitor(){
            @Override public boolean visit(            IResource resource) throws CoreException {
              if (resource instanceof IFile && resource.getFullPath().toString().endsWith(trimmedPath)) {
                files.add((IFile)resource);
              }
              return true;
            }
          }
);
          IFile file=null;
          if (files.size() > 1) {
            ListDialog dialog=new ListDialog(getTable().getShell());
            dialog.setContentProvider(ArrayContentProvider.getInstance());
            dialog.setLabelProvider(new LabelProvider(){
              @Override public String getText(              Object element){
                return ((IFile)element).getFullPath().toString();
              }
            }
);
            dialog.setInput(files);
            dialog.setTitle(Messages.TmfEventsTable_OpenSourceCodeSelectFileDialogTitle);
            dialog.setMessage(Messages.TmfEventsTable_OpenSourceCodeSelectFileDialogTitle + '\n' + cs.toString());
            dialog.open();
            Object[] result=dialog.getResult();
            if (result != null && result.length > 0) {
              file=(IFile)result[0];
            }
          }
 else           if (files.size() == 1) {
            file=files.get(0);
          }
          if (file != null) {
            marker=file.createMarker(IMarker.MARKER);
            marker.setAttribute(IMarker.LINE_NUMBER,Long.valueOf(cs.getLineNumber()).intValue());
            IDE.openEditor(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage(),marker);
            marker.delete();
          }
 else           if (files.size() == 0) {
            displayException(new FileNotFoundException('\'' + cs.toString() + '\''+ '\n'+ Messages.TmfEventsTable_OpenSourceCodeNotFound));
          }
        }
 catch (        CoreException e) {
          displayException(e);
        }
      }
    }
  }
;
  final IAction openModelAction=new Action(Messages.TmfEventsTable_OpenModelActionText){
    @Override public void run(){
      final TableItem items[]=fTable.getSelection();
      if (items.length != 1) {
        return;
      }
      final TableItem item=items[0];
      final Object eventData=item.getData();
      if (eventData instanceof ITmfModelLookup) {
        String modelURI=((ITmfModelLookup)eventData).getModelUri();
        if (modelURI != null) {
          IWorkbenchPage activePage=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
          IFile file=null;
          final URI uri=URI.createURI(modelURI);
          if (uri.isPlatformResource()) {
            IPath path=new Path(uri.toPlatformString(true));
            file=ResourcesPlugin.getWorkspace().getRoot().getFile(path);
          }
 else           if (uri.isFile() && !uri.isRelative()) {
            file=ResourcesPlugin.getWorkspace().getRoot().getFileForLocation(new Path(uri.toFileString()));
          }
          if (file != null) {
            try {
              IMarker marker=file.createMarker(EValidator.MARKER);
              marker.setAttribute(EValidator.URI_ATTRIBUTE,modelURI);
              marker.setAttribute(IMarker.SEVERITY,IMarker.SEVERITY_INFO);
              IDE.openEditor(activePage,marker,OpenStrategy.activateOnOpen());
              marker.delete();
            }
 catch (            CoreException e) {
              displayException(e);
            }
          }
 else {
            displayException(new FileNotFoundException('\'' + modelURI + '\''+ '\n'+ Messages.TmfEventsTable_OpenModelUnsupportedURI));
          }
        }
      }
    }
  }
;
  final IAction exportToTextAction=new Action(Messages.TmfEventsTable_Export_to_text){
    @Override public void run(){
      IWorkbenchPage activePage=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
      Object handlerServiceObject=activePage.getActiveEditor().getSite().getService(IHandlerService.class);
      IHandlerService handlerService=(IHandlerService)handlerServiceObject;
      Object cmdServiceObject=activePage.getActiveEditor().getSite().getService(ICommandService.class);
      ICommandService cmdService=(ICommandService)cmdServiceObject;
      try {
        HashMap<String,Object> parameters=new HashMap<>();
        Command command=cmdService.getCommand(ExportToTextCommandHandler.COMMAND_ID);
        ParameterizedCommand cmd=ParameterizedCommand.generateCommand(command,parameters);
        IEvaluationContext context=handlerService.getCurrentState();
        List<TmfEventTableColumn> exportColumns=fColumns.subList(EVENT_COLUMNS_START_INDEX,fColumns.size());
        context.addVariable(ExportToTextCommandHandler.TMF_EVENT_TABLE_COLUMNS_ID,exportColumns);
        handlerService.executeCommandInContext(cmd,null,context);
      }
 catch (      ExecutionException e) {
        displayException(e);
      }
catch (      NotDefinedException e) {
        displayException(e);
      }
catch (      NotEnabledException e) {
        displayException(e);
      }
catch (      NotHandledException e) {
        displayException(e);
      }
    }
  }
;
  final IAction showSearchBarAction=new Action(Messages.TmfEventsTable_ShowSearchBarActionText){
    @Override public void run(){
      fHeaderState=HeaderState.SEARCH;
      fTable.refresh();
    }
  }
;
  final IAction showFilterBarAction=new Action(Messages.TmfEventsTable_ShowFilterBarActionText){
    @Override public void run(){
      fHeaderState=HeaderState.FILTER;
      fTable.refresh();
    }
  }
;
  final IAction clearFiltersAction=new Action(Messages.TmfEventsTable_ClearFiltersActionText){
    @Override public void run(){
      clearFilters();
    }
  }
;
  final IAction collapseAction=new Action(Messages.TmfEventsTable_CollapseFilterMenuName){
    @Override public void run(){
      applyFilter(new TmfCollapseFilter());
    }
  }
;
class ToggleBookmarkAction extends Action {
    Long fRank;
    public ToggleBookmarkAction(    final String text,    final Long rank){
      super(text);
      fRank=rank;
    }
    @Override public void run(){
      toggleBookmark(fRank);
    }
  }
  final MenuManager tablePopupMenu=new MenuManager();
  tablePopupMenu.setRemoveAllWhenShown(true);
  tablePopupMenu.addMenuListener(new IMenuListener(){
    @Override public void menuAboutToShow(    final IMenuManager manager){
      if (fTable.getSelectionIndex() == 0) {
        if (fHeaderState == HeaderState.FILTER) {
          tablePopupMenu.add(showSearchBarAction);
        }
 else {
          tablePopupMenu.add(showFilterBarAction);
        }
        return;
      }
      final Point point=fTable.toControl(Display.getDefault().getCursorLocation());
      final TableItem item=fTable.getSelection().length > 0 ? fTable.getSelection()[0] : null;
      if (item != null) {
        final Rectangle imageBounds=item.getImageBounds(0);
        imageBounds.width=BOOKMARK_IMAGE.getBounds().width;
        if (point.x <= (imageBounds.x + imageBounds.width)) {
          final Long rank=(Long)item.getData(Key.RANK);
          if ((rank != null) && (fBookmarksFile != null)) {
            if (fBookmarksMap.containsKey(rank)) {
              tablePopupMenu.add(new ToggleBookmarkAction(Messages.TmfEventsTable_RemoveBookmarkActionText,rank));
            }
 else {
              tablePopupMenu.add(new ToggleBookmarkAction(Messages.TmfEventsTable_AddBookmarkActionText,rank));
            }
          }
          return;
        }
      }
      if (fTable.isVisible() && fRawViewer.isVisible()) {
        tablePopupMenu.add(hideTableAction);
        tablePopupMenu.add(hideRawAction);
      }
 else       if (!fTable.isVisible()) {
        tablePopupMenu.add(showTableAction);
      }
 else       if (!fRawViewer.isVisible()) {
        tablePopupMenu.add(showRawAction);
      }
      tablePopupMenu.add(exportToTextAction);
      tablePopupMenu.add(new Separator());
      if (item != null) {
        final Object data=item.getData();
        Separator separator=null;
        if (data instanceof ITmfSourceLookup) {
          ITmfSourceLookup event=(ITmfSourceLookup)data;
          if (event.getCallsite() != null) {
            tablePopupMenu.add(openCallsiteAction);
            separator=new Separator();
          }
        }
        if (data instanceof ITmfModelLookup) {
          ITmfModelLookup event=(ITmfModelLookup)data;
          if (event.getModelUri() != null) {
            tablePopupMenu.add(openModelAction);
            separator=new Separator();
          }
          if (separator != null) {
            tablePopupMenu.add(separator);
          }
        }
      }
      boolean isCollapsible=false;
      if (fTrace != null) {
        ITmfTrace traces[]=TmfTraceManager.getTraceSet(fTrace);
        for (        ITmfTrace trace : traces) {
          Class<? extends ITmfEvent> eventClass=trace.getEventType();
          isCollapsible=ITmfCollapsibleEvent.class.isAssignableFrom(eventClass);
          if (isCollapsible) {
            break;
          }
        }
      }
      if (isCollapsible && !(fTable.getData(Key.FILTER_OBJ) instanceof TmfCollapseFilter)) {
        tablePopupMenu.add(collapseAction);
        tablePopupMenu.add(new Separator());
      }
      tablePopupMenu.add(clearFiltersAction);
      final ITmfFilterTreeNode[] savedFilters=FilterManager.getSavedFilters();
      if (savedFilters.length > 0) {
        final MenuManager subMenu=new MenuManager(Messages.TmfEventsTable_ApplyPresetFilterMenuName);
        for (        final ITmfFilterTreeNode node : savedFilters) {
          if (node instanceof TmfFilterNode) {
            final TmfFilterNode filter=(TmfFilterNode)node;
            subMenu.add(new Action(filter.getFilterName()){
              @Override public void run(){
                applyFilter(filter);
              }
            }
);
          }
        }
        tablePopupMenu.add(subMenu);
      }
      appendToTablePopupMenu(tablePopupMenu,item);
    }
  }
);
  final MenuManager rawViewerPopupMenu=new MenuManager();
  rawViewerPopupMenu.setRemoveAllWhenShown(true);
  rawViewerPopupMenu.addMenuListener(new IMenuListener(){
    @Override public void menuAboutToShow(    final IMenuManager manager){
      if (fTable.isVisible() && fRawViewer.isVisible()) {
        rawViewerPopupMenu.add(hideTableAction);
        rawViewerPopupMenu.add(hideRawAction);
      }
 else       if (!fTable.isVisible()) {
        rawViewerPopupMenu.add(showTableAction);
      }
 else       if (!fRawViewer.isVisible()) {
        rawViewerPopupMenu.add(showRawAction);
      }
      appendToRawPopupMenu(tablePopupMenu);
    }
  }
);
  Menu menu=tablePopupMenu.createContextMenu(fTable);
  fTable.setMenu(menu);
  menu=rawViewerPopupMenu.createContextMenu(fRawViewer);
  fRawViewer.setMenu(menu);
}",0.9838309453293844
91824,"/** 
 * Sets view part.
 * @param viewSite The view part to set
 */
public void setSite(ViewPart viewSite){
  fSite=viewSite;
  fSite.getSite().setSelectionProvider(fSelProvider);
  IContextService service=(IContextService)fSite.getSite().getWorkbenchWindow().getService(IContextService.class);
  service.activateContext(""String_Node_Str"");
  service.activateContext(IContextIds.CONTEXT_ID_WINDOW);
}","/** 
 * Sets view part.
 * @param viewSite The view part to set
 */
public void setSite(ViewPart viewSite){
  fSite=viewSite;
  fSite.getSite().setSelectionProvider(fSelProvider);
  Object serviceObject=fSite.getSite().getWorkbenchWindow().getService(IContextService.class);
  IContextService service=(IContextService)serviceObject;
  service.activateContext(""String_Node_Str"");
  service.activateContext(IContextIds.CONTEXT_ID_WINDOW);
}",0.8591885441527446
91825,"private void dispose(){
  IWorkbenchWindow window=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
  if (window == null) {
    return;
  }
  IHandlerService service=(IHandlerService)window.getService(IHandlerService.class);
  for (  IHandlerActivation activation : fHandlerActivations) {
    service.deactivateHandler(activation);
  }
  fGoToMessageForKeyBinding=null;
  fFindForKeyBinding=null;
  fMoveUpForKeyBinding=null;
  fMoveDownForKeyBinding=null;
  fMoveLeftForKeyBinding=null;
  fMoveRightForKeyBinding=null;
  fShowNodeStartForKeyBinding=null;
  fShowNodeEndForKeyBinding=null;
}","private void dispose(){
  IWorkbenchWindow window=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
  if (window == null) {
    return;
  }
  Object serviceObject=window.getService(IHandlerService.class);
  IHandlerService service=(IHandlerService)serviceObject;
  for (  IHandlerActivation activation : fHandlerActivations) {
    service.deactivateHandler(activation);
  }
  fGoToMessageForKeyBinding=null;
  fFindForKeyBinding=null;
  fMoveUpForKeyBinding=null;
  fMoveDownForKeyBinding=null;
  fMoveLeftForKeyBinding=null;
  fMoveRightForKeyBinding=null;
  fShowNodeStartForKeyBinding=null;
  fShowNodeEndForKeyBinding=null;
}",0.9120521172638436
91826,"private void initialize(){
  fGoToMessageForKeyBinding=new MoveToMessage();
  IHandlerService service=(IHandlerService)PlatformUI.getWorkbench().getActiveWorkbenchWindow().getService(IHandlerService.class);
  AbstractHandler handler=new AbstractHandler(){
    @Override public Object execute(    ExecutionEvent event) throws ExecutionException {
      fGoToMessageForKeyBinding.run();
      return null;
    }
  }
;
  IHandlerActivation activation=service.activateHandler(fGoToMessageForKeyBinding.getActionDefinitionId(),handler);
  fHandlerActivations.add(activation);
  fMoveUpForKeyBinding=new MoveSDUp();
  handler=new AbstractHandler(){
    @Override public Object execute(    ExecutionEvent event) throws ExecutionException {
      fMoveUpForKeyBinding.run();
      return null;
    }
  }
;
  activation=service.activateHandler(fMoveUpForKeyBinding.getActionDefinitionId(),handler);
  fHandlerActivations.add(activation);
  fMoveDownForKeyBinding=new MoveSDDown();
  handler=new AbstractHandler(){
    @Override public Object execute(    ExecutionEvent event) throws ExecutionException {
      fMoveDownForKeyBinding.run();
      return null;
    }
  }
;
  activation=service.activateHandler(fMoveDownForKeyBinding.getActionDefinitionId(),handler);
  fHandlerActivations.add(activation);
  fMoveLeftForKeyBinding=new MoveSDLeft();
  handler=new AbstractHandler(){
    @Override public Object execute(    ExecutionEvent event) throws ExecutionException {
      fMoveLeftForKeyBinding.run();
      return null;
    }
  }
;
  activation=service.activateHandler(fMoveLeftForKeyBinding.getActionDefinitionId(),handler);
  fHandlerActivations.add(activation);
  fMoveRightForKeyBinding=new MoveSDRight();
  handler=new AbstractHandler(){
    @Override public Object execute(    ExecutionEvent event) throws ExecutionException {
      fMoveRightForKeyBinding.run();
      return null;
    }
  }
;
  activation=service.activateHandler(fMoveRightForKeyBinding.getActionDefinitionId(),handler);
  fHandlerActivations.add(activation);
  fFindForKeyBinding=new OpenSDFindDialog();
  handler=new AbstractHandler(){
    @Override public Object execute(    ExecutionEvent event) throws ExecutionException {
      fFindForKeyBinding.run();
      return null;
    }
  }
;
  activation=service.activateHandler(fFindForKeyBinding.getActionDefinitionId(),handler);
  fFindForKeyBinding.setEnabled(false);
  fHandlerActivations.add(activation);
  fShowNodeStartForKeyBinding=new ShowNodeStart();
  fShowNodeStartForKeyBinding.setText(Messages.SequenceDiagram_ShowNodeStart);
  fShowNodeStartForKeyBinding.setId(""String_Node_Str"");
  fShowNodeStartForKeyBinding.setActionDefinitionId(""String_Node_Str"");
  handler=new AbstractHandler(){
    @Override public Object execute(    ExecutionEvent event) throws ExecutionException {
      fShowNodeStartForKeyBinding.run();
      return null;
    }
  }
;
  activation=service.activateHandler(fShowNodeStartForKeyBinding.getActionDefinitionId(),handler);
  fHandlerActivations.add(activation);
  fShowNodeEndForKeyBinding=new ShowNodeEnd();
  fShowNodeEndForKeyBinding.setText(Messages.SequenceDiagram_ShowNodeEnd);
  fShowNodeEndForKeyBinding.setId(""String_Node_Str"");
  fShowNodeEndForKeyBinding.setActionDefinitionId(""String_Node_Str"");
  handler=new AbstractHandler(){
    @Override public Object execute(    ExecutionEvent event) throws ExecutionException {
      fShowNodeEndForKeyBinding.run();
      return null;
    }
  }
;
  activation=service.activateHandler(fShowNodeEndForKeyBinding.getActionDefinitionId(),handler);
  fHandlerActivations.add(activation);
}","private void initialize(){
  fGoToMessageForKeyBinding=new MoveToMessage();
  Object serviceObject=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getService(IHandlerService.class);
  IHandlerService service=(IHandlerService)serviceObject;
  AbstractHandler handler=new AbstractHandler(){
    @Override public Object execute(    ExecutionEvent event) throws ExecutionException {
      fGoToMessageForKeyBinding.run();
      return null;
    }
  }
;
  IHandlerActivation activation=service.activateHandler(fGoToMessageForKeyBinding.getActionDefinitionId(),handler);
  fHandlerActivations.add(activation);
  fMoveUpForKeyBinding=new MoveSDUp();
  handler=new AbstractHandler(){
    @Override public Object execute(    ExecutionEvent event) throws ExecutionException {
      fMoveUpForKeyBinding.run();
      return null;
    }
  }
;
  activation=service.activateHandler(fMoveUpForKeyBinding.getActionDefinitionId(),handler);
  fHandlerActivations.add(activation);
  fMoveDownForKeyBinding=new MoveSDDown();
  handler=new AbstractHandler(){
    @Override public Object execute(    ExecutionEvent event) throws ExecutionException {
      fMoveDownForKeyBinding.run();
      return null;
    }
  }
;
  activation=service.activateHandler(fMoveDownForKeyBinding.getActionDefinitionId(),handler);
  fHandlerActivations.add(activation);
  fMoveLeftForKeyBinding=new MoveSDLeft();
  handler=new AbstractHandler(){
    @Override public Object execute(    ExecutionEvent event) throws ExecutionException {
      fMoveLeftForKeyBinding.run();
      return null;
    }
  }
;
  activation=service.activateHandler(fMoveLeftForKeyBinding.getActionDefinitionId(),handler);
  fHandlerActivations.add(activation);
  fMoveRightForKeyBinding=new MoveSDRight();
  handler=new AbstractHandler(){
    @Override public Object execute(    ExecutionEvent event) throws ExecutionException {
      fMoveRightForKeyBinding.run();
      return null;
    }
  }
;
  activation=service.activateHandler(fMoveRightForKeyBinding.getActionDefinitionId(),handler);
  fHandlerActivations.add(activation);
  fFindForKeyBinding=new OpenSDFindDialog();
  handler=new AbstractHandler(){
    @Override public Object execute(    ExecutionEvent event) throws ExecutionException {
      fFindForKeyBinding.run();
      return null;
    }
  }
;
  activation=service.activateHandler(fFindForKeyBinding.getActionDefinitionId(),handler);
  fFindForKeyBinding.setEnabled(false);
  fHandlerActivations.add(activation);
  fShowNodeStartForKeyBinding=new ShowNodeStart();
  fShowNodeStartForKeyBinding.setText(Messages.SequenceDiagram_ShowNodeStart);
  fShowNodeStartForKeyBinding.setId(""String_Node_Str"");
  fShowNodeStartForKeyBinding.setActionDefinitionId(""String_Node_Str"");
  handler=new AbstractHandler(){
    @Override public Object execute(    ExecutionEvent event) throws ExecutionException {
      fShowNodeStartForKeyBinding.run();
      return null;
    }
  }
;
  activation=service.activateHandler(fShowNodeStartForKeyBinding.getActionDefinitionId(),handler);
  fHandlerActivations.add(activation);
  fShowNodeEndForKeyBinding=new ShowNodeEnd();
  fShowNodeEndForKeyBinding.setText(Messages.SequenceDiagram_ShowNodeEnd);
  fShowNodeEndForKeyBinding.setId(""String_Node_Str"");
  fShowNodeEndForKeyBinding.setActionDefinitionId(""String_Node_Str"");
  handler=new AbstractHandler(){
    @Override public Object execute(    ExecutionEvent event) throws ExecutionException {
      fShowNodeEndForKeyBinding.run();
      return null;
    }
  }
;
  activation=service.activateHandler(fShowNodeEndForKeyBinding.getActionDefinitionId(),handler);
  fHandlerActivations.add(activation);
}",0.9690351119712468
91827,"/** 
 * @since 3.2
 */
@Override public void partDeactivated(IWorkbenchPart part){
  if (part == this && fPrintHandlerActivation != null) {
    final IHandlerService hs=(IHandlerService)PlatformUI.getWorkbench().getService(IHandlerService.class);
    hs.deactivateHandler(fPrintHandlerActivation);
  }
}","/** 
 * @since 3.2
 */
@Override public void partDeactivated(IWorkbenchPart part){
  if (part == this && fPrintHandlerActivation != null) {
    final Object service=PlatformUI.getWorkbench().getService(IHandlerService.class);
    ((IHandlerService)service).deactivateHandler(fPrintHandlerActivation);
  }
}",0.8735632183908046
91828,"/** 
 * @since 3.2
 */
@Override public void partActivated(IWorkbenchPart part){
  if (part == this) {
    final IHandlerService hs=(IHandlerService)PlatformUI.getWorkbench().getService(IHandlerService.class);
    fPrintHandlerActivation=hs.activateHandler(ActionFactory.PRINT.getCommandId(),fPrintActionHandler);
  }
}","/** 
 * @since 3.2
 */
@Override public void partActivated(IWorkbenchPart part){
  if (part == this) {
    final Object service=PlatformUI.getWorkbench().getService(IHandlerService.class);
    fPrintHandlerActivation=((IHandlerService)service).activateHandler(ActionFactory.PRINT.getCommandId(),fPrintActionHandler);
  }
}",0.8798751950078003
91829,"@Override protected void updateData(long start,long end,int nb,IProgressMonitor monitor){
  try {
    if (getTrace() == null || fModule == null) {
      return;
    }
    fModule.waitForInitialization();
    ITmfStateSystem ss=fModule.getStateSystem();
    if (ss == null) {
      return;
    }
    double[] xvalues=getXAxis(start,end,nb);
    setXAxis(xvalues);
    boolean complete=false;
    long currentEnd=start;
    while (!complete && currentEnd < end) {
      if (monitor.isCanceled()) {
        return;
      }
      complete=ss.waitUntilBuilt(BUILD_UPDATE_TIMEOUT);
      currentEnd=ss.getCurrentEndTime();
      List<Integer> tidQuarks=ss.getSubAttributes(-1,false);
      long traceStart=getStartTime();
      long traceEnd=getEndTime();
      long offset=this.getTimeOffset();
      for (      int quark : tidQuarks) {
        fYValues.put(quark,new double[xvalues.length]);
        fMemoryQuarks.put(quark,ss.getQuarkRelative(quark,UstMemoryStrings.UST_MEMORY_MEMORY_ATTRIBUTE));
        int procNameQuark=ss.getQuarkRelative(quark,UstMemoryStrings.UST_MEMORY_PROCNAME_ATTRIBUTE);
        try {
          ITmfStateValue procnameValue=ss.querySingleState(start,procNameQuark).getStateValue();
          String procname=new String();
          if (!procnameValue.isNull()) {
            procname=procnameValue.unboxStr();
          }
          fSeriesName.put(quark,new String(procname + ' ' + '('+ ss.getAttributeName(quark)+ ')').trim());
        }
 catch (        TimeRangeException e) {
          fSeriesName.put(quark,'(' + ss.getAttributeName(quark) + ')');
        }
      }
      double yvalue=0.0;
      for (int i=0; i < xvalues.length; i++) {
        if (monitor.isCanceled()) {
          return;
        }
        double x=xvalues[i];
        long time=(long)x + offset;
        time=time < traceStart ? traceStart : time;
        time=time > traceEnd ? traceEnd : time;
        for (        int quark : tidQuarks) {
          try {
            yvalue=ss.querySingleState(time,fMemoryQuarks.get(quark)).getStateValue().unboxLong() / BYTES_TO_KB;
            fYValues.get(quark)[i]=yvalue;
          }
 catch (          TimeRangeException e) {
            fYValues.get(quark)[i]=0;
          }
        }
      }
      for (      int quark : tidQuarks) {
        setSeries(fSeriesName.get(quark),fYValues.get(quark));
      }
      updateDisplay();
    }
  }
 catch (  AttributeNotFoundException|StateValueTypeException|StateSystemDisposedException e) {
    Activator.logError(""String_Node_Str"",e);
  }
}","@Override protected void updateData(long start,long end,int nb,IProgressMonitor monitor){
  try {
    if (getTrace() == null || fModule == null) {
      return;
    }
    fModule.waitForInitialization();
    ITmfStateSystem ss=fModule.getStateSystem();
    if (ss == null) {
      return;
    }
    double[] xvalues=getXAxis(start,end,nb);
    setXAxis(xvalues);
    boolean complete=false;
    long currentEnd=start;
    while (!complete && currentEnd < end) {
      if (monitor.isCanceled()) {
        return;
      }
      complete=ss.waitUntilBuilt(BUILD_UPDATE_TIMEOUT);
      currentEnd=ss.getCurrentEndTime();
      List<Integer> tidQuarks=ss.getSubAttributes(-1,false);
      long traceStart=getStartTime();
      long traceEnd=getEndTime();
      long offset=this.getTimeOffset();
      for (      int quark : tidQuarks) {
        fYValues.put(quark,new double[xvalues.length]);
        fMemoryQuarks.put(quark,ss.getQuarkRelative(quark,UstMemoryStrings.UST_MEMORY_MEMORY_ATTRIBUTE));
        int procNameQuark=ss.getQuarkRelative(quark,UstMemoryStrings.UST_MEMORY_PROCNAME_ATTRIBUTE);
        try {
          ITmfStateValue procnameValue=ss.querySingleState(start,procNameQuark).getStateValue();
          String procname=new String();
          if (!procnameValue.isNull()) {
            procname=procnameValue.unboxStr();
          }
          fSeriesName.put(quark,new String(procname + ' ' + '('+ ss.getAttributeName(quark)+ ')').trim());
        }
 catch (        TimeRangeException e) {
          fSeriesName.put(quark,'(' + ss.getAttributeName(quark) + ')');
        }
      }
      double yvalue=0.0;
      for (int i=0; i < xvalues.length; i++) {
        if (monitor.isCanceled()) {
          return;
        }
        double x=xvalues[i];
        long time=(long)x + offset;
        time=time < traceStart ? traceStart : time;
        time=time > traceEnd ? traceEnd : time;
        for (        int quark : tidQuarks) {
          try {
            yvalue=ss.querySingleState(time,fMemoryQuarks.get(quark)).getStateValue().unboxLong() / BYTES_TO_KB;
            fYValues.get(quark)[i]=yvalue;
          }
 catch (          TimeRangeException e) {
            fYValues.get(quark)[i]=0;
          }
        }
      }
      for (      int quark : tidQuarks) {
        setSeries(fSeriesName.get(quark),fYValues.get(quark));
      }
      updateDisplay();
    }
  }
 catch (  AttributeNotFoundException|StateValueTypeException e) {
    Activator.logError(""String_Node_Str"",e);
  }
catch (  StateSystemDisposedException e) {
  }
}",0.9783037475345168
91830,"@Override protected void initializeDataSource(){
  super.initializeDataSource();
  ITmfTrace trace=this.getTrace();
  if (trace == null) {
    return;
  }
  Element viewElement=fViewInfo.getViewElement(TmfXmlUiStrings.XY_VIEW);
  if (viewElement == null) {
    return;
  }
  Iterable<String> analysisIds=fViewInfo.getViewAnalysisIds(viewElement);
  List<ITmfAnalysisModuleWithStateSystems> stateSystemModules=new LinkedList<>();
  if (!analysisIds.iterator().hasNext()) {
    for (    ITmfAnalysisModuleWithStateSystems module : trace.getAnalysisModulesOfClass(ITmfAnalysisModuleWithStateSystems.class)) {
      stateSystemModules.add(module);
    }
  }
 else {
    for (    String moduleId : analysisIds) {
      @SuppressWarnings(""String_Node_Str"") ITmfAnalysisModuleWithStateSystems module=trace.getAnalysisModuleOfClass(ITmfAnalysisModuleWithStateSystems.class,moduleId);
      if (module != null) {
        stateSystemModules.add(module);
      }
    }
  }
  fDisplay=null;
  fSeriesName=null;
  ITmfStateSystem ss=null;
  fEntry=null;
  for (  ITmfAnalysisModuleWithStateSystems module : stateSystemModules) {
    module.schedule();
    if (module instanceof TmfStateSystemAnalysisModule) {
      ((TmfStateSystemAnalysisModule)module).waitForInitialization();
    }
    for (    ITmfStateSystem ssq : module.getStateSystems()) {
      if (ssq != null) {
        ss=ssq;
        break;
      }
    }
  }
  if (ss == null) {
    return;
  }
  List<Element> entries=XmlUtils.getChildElements(viewElement,TmfXmlUiStrings.ENTRY_ELEMENT);
  Element entryElement=entries.get(0);
  String path=entryElement.getAttribute(TmfXmlUiStrings.PATH);
  if (path.isEmpty()) {
    path=TmfXmlStrings.WILDCARD;
  }
  XmlXYEntry entry=new XmlXYEntry(ss,path,entryElement);
  fEntry=entry;
  List<Element> displayElements=XmlUtils.getChildElements(entryElement,TmfXmlUiStrings.DISPLAY_ELEMENT);
  if (displayElements.isEmpty()) {
    Activator.logWarning(String.format(""String_Node_Str"",path));
    return;
  }
  Element displayElement=displayElements.get(0);
  fDisplay=fFactory.createStateAttribute(displayElement,entry);
  List<Element> seriesNameElements=XmlUtils.getChildElements(entryElement,TmfXmlUiStrings.NAME_ELEMENT);
  if (!seriesNameElements.isEmpty()) {
    Element seriesNameElement=seriesNameElements.get(0);
    fSeriesName=fFactory.createStateAttribute(seriesNameElement,entry);
  }
}","@Override protected void initializeDataSource(){
  super.initializeDataSource();
  ITmfTrace trace=this.getTrace();
  if (trace == null) {
    return;
  }
  Element viewElement=fViewInfo.getViewElement(TmfXmlUiStrings.XY_VIEW);
  if (viewElement == null) {
    return;
  }
  Iterable<String> analysisIds=fViewInfo.getViewAnalysisIds(viewElement);
  List<ITmfAnalysisModuleWithStateSystems> stateSystemModules=new LinkedList<>();
  if (!analysisIds.iterator().hasNext()) {
    for (    ITmfAnalysisModuleWithStateSystems module : trace.getAnalysisModulesOfClass(ITmfAnalysisModuleWithStateSystems.class)) {
      stateSystemModules.add(module);
    }
  }
 else {
    for (    String moduleId : analysisIds) {
      @SuppressWarnings(""String_Node_Str"") ITmfAnalysisModuleWithStateSystems module=trace.getAnalysisModuleOfClass(ITmfAnalysisModuleWithStateSystems.class,moduleId);
      if (module != null) {
        stateSystemModules.add(module);
      }
    }
  }
  fDisplay=null;
  fSeriesName=null;
  ITmfStateSystem ss=null;
  fEntry=null;
  for (  ITmfAnalysisModuleWithStateSystems module : stateSystemModules) {
    IStatus status=module.schedule();
    if (status.isOK()) {
      if (module instanceof TmfStateSystemAnalysisModule) {
        ((TmfStateSystemAnalysisModule)module).waitForInitialization();
      }
      for (      ITmfStateSystem ssq : module.getStateSystems()) {
        if (ssq != null) {
          ss=ssq;
          break;
        }
      }
    }
 else {
      return;
    }
  }
  if (ss == null) {
    return;
  }
  List<Element> entries=XmlUtils.getChildElements(viewElement,TmfXmlUiStrings.ENTRY_ELEMENT);
  Element entryElement=entries.get(0);
  String path=entryElement.getAttribute(TmfXmlUiStrings.PATH);
  if (path.isEmpty()) {
    path=TmfXmlStrings.WILDCARD;
  }
  XmlXYEntry entry=new XmlXYEntry(ss,path,entryElement);
  fEntry=entry;
  List<Element> displayElements=XmlUtils.getChildElements(entryElement,TmfXmlUiStrings.DISPLAY_ELEMENT);
  if (displayElements.isEmpty()) {
    Activator.logWarning(String.format(""String_Node_Str"",path));
    return;
  }
  Element displayElement=displayElements.get(0);
  fDisplay=fFactory.createStateAttribute(displayElement,entry);
  List<Element> seriesNameElements=XmlUtils.getChildElements(entryElement,TmfXmlUiStrings.NAME_ELEMENT);
  if (!seriesNameElements.isEmpty()) {
    Element seriesNameElement=seriesNameElements.get(0);
    fSeriesName=fFactory.createStateAttribute(seriesNameElement,entry);
  }
}",0.9786447638603696
91831,"@Override protected void buildEventList(ITmfTrace trace,ITmfTrace parentTrace,IProgressMonitor monitor){
  Element viewElement=fViewInfo.getViewElement(TmfXmlUiStrings.TIME_GRAPH_VIEW);
  if (viewElement == null) {
    return;
  }
  ITimeGraphPresentationProvider2 pres=this.getPresentationProvider();
  if (pres instanceof XmlPresentationProvider) {
    ((XmlPresentationProvider)pres).loadNewStates(viewElement);
  }
  String title=fViewInfo.getViewTitle(viewElement);
  if (title == null) {
    title=Messages.XmlTimeGraphView_DefaultTitle;
  }
  setViewTitle(title);
  Set<String> analysisIds=fViewInfo.getViewAnalysisIds(viewElement);
  List<Element> entries=XmlUtils.getChildElements(viewElement,TmfXmlUiStrings.ENTRY_ELEMENT);
  Set<XmlEntry> entryList=new TreeSet<>(getEntryComparator());
  for (  ITmfTrace aTrace : TmfTraceManager.getTraceSet(trace)) {
    if (monitor.isCanceled()) {
      return;
    }
    List<ITmfAnalysisModuleWithStateSystems> stateSystemModules=new LinkedList<>();
    if (analysisIds.isEmpty()) {
      for (      ITmfAnalysisModuleWithStateSystems module : aTrace.getAnalysisModulesOfClass(ITmfAnalysisModuleWithStateSystems.class)) {
        stateSystemModules.add(module);
      }
    }
 else {
      for (      String moduleId : analysisIds) {
        ITmfAnalysisModuleWithStateSystems module=aTrace.getAnalysisModuleOfClass(ITmfAnalysisModuleWithStateSystems.class,moduleId);
        if (module != null) {
          stateSystemModules.add(module);
        }
      }
    }
    for (    ITmfAnalysisModuleWithStateSystems module : stateSystemModules) {
      module.schedule();
      if (module instanceof TmfStateSystemAnalysisModule) {
        ((TmfStateSystemAnalysisModule)module).waitForInitialization();
      }
      for (      ITmfStateSystem ssq : module.getStateSystems()) {
        if (ssq == null) {
          return;
        }
        ssq.waitUntilBuilt();
        long startTime=ssq.getStartTime();
        long endTime=ssq.getCurrentEndTime();
        XmlEntry groupEntry=new XmlEntry(-1,aTrace,aTrace.getName(),ssq);
        entryList.add(groupEntry);
        setStartTime(Math.min(getStartTime(),startTime));
        setEndTime(Math.max(getEndTime(),endTime));
        for (        Element entry : entries) {
          buildEntry(entry,groupEntry,-1);
        }
      }
    }
  }
  putEntryList(trace,new ArrayList<TimeGraphEntry>(entryList));
  if (trace.equals(getTrace())) {
    refresh();
  }
  for (  XmlEntry traceEntry : entryList) {
    if (monitor.isCanceled()) {
      return;
    }
    long startTime=traceEntry.getStateSystem().getStartTime();
    long endTime=traceEntry.getStateSystem().getCurrentEndTime() + 1;
    buildStatusEvent(traceEntry,monitor,startTime,endTime);
  }
}","@Override protected void buildEventList(ITmfTrace trace,ITmfTrace parentTrace,IProgressMonitor monitor){
  Element viewElement=fViewInfo.getViewElement(TmfXmlUiStrings.TIME_GRAPH_VIEW);
  if (viewElement == null) {
    return;
  }
  ITimeGraphPresentationProvider2 pres=this.getPresentationProvider();
  if (pres instanceof XmlPresentationProvider) {
    ((XmlPresentationProvider)pres).loadNewStates(viewElement);
  }
  String title=fViewInfo.getViewTitle(viewElement);
  if (title == null) {
    title=Messages.XmlTimeGraphView_DefaultTitle;
  }
  setViewTitle(title);
  Set<String> analysisIds=fViewInfo.getViewAnalysisIds(viewElement);
  List<Element> entries=XmlUtils.getChildElements(viewElement,TmfXmlUiStrings.ENTRY_ELEMENT);
  Set<XmlEntry> entryList=new TreeSet<>(getEntryComparator());
  for (  ITmfTrace aTrace : TmfTraceManager.getTraceSet(trace)) {
    if (monitor.isCanceled()) {
      return;
    }
    List<ITmfAnalysisModuleWithStateSystems> stateSystemModules=new LinkedList<>();
    if (analysisIds.isEmpty()) {
      for (      ITmfAnalysisModuleWithStateSystems module : aTrace.getAnalysisModulesOfClass(ITmfAnalysisModuleWithStateSystems.class)) {
        stateSystemModules.add(module);
      }
    }
 else {
      for (      String moduleId : analysisIds) {
        ITmfAnalysisModuleWithStateSystems module=aTrace.getAnalysisModuleOfClass(ITmfAnalysisModuleWithStateSystems.class,moduleId);
        if (module != null) {
          stateSystemModules.add(module);
        }
      }
    }
    for (    ITmfAnalysisModuleWithStateSystems module : stateSystemModules) {
      IStatus status=module.schedule();
      if (status.isOK()) {
        if (module instanceof TmfStateSystemAnalysisModule) {
          ((TmfStateSystemAnalysisModule)module).waitForInitialization();
        }
        for (        ITmfStateSystem ssq : module.getStateSystems()) {
          if (ssq == null) {
            return;
          }
          ssq.waitUntilBuilt();
          long startTime=ssq.getStartTime();
          long endTime=ssq.getCurrentEndTime();
          XmlEntry groupEntry=new XmlEntry(-1,aTrace,aTrace.getName(),ssq);
          entryList.add(groupEntry);
          setStartTime(Math.min(getStartTime(),startTime));
          setEndTime(Math.max(getEndTime(),endTime));
          for (          Element entry : entries) {
            buildEntry(entry,groupEntry,-1);
          }
        }
      }
 else {
        return;
      }
    }
  }
  putEntryList(trace,new ArrayList<TimeGraphEntry>(entryList));
  if (trace.equals(getTrace())) {
    refresh();
  }
  for (  XmlEntry traceEntry : entryList) {
    if (monitor.isCanceled()) {
      return;
    }
    long startTime=traceEntry.getStateSystem().getStartTime();
    long endTime=traceEntry.getStateSystem().getCurrentEndTime() + 1;
    buildStatusEvent(traceEntry,monitor,startTime,endTime);
  }
}",0.9718660968660968
91832,"@Override public void setTrace(ITmfTrace trace) throws TmfAnalysisException {
  if (trace == null) {
    throw new TmfAnalysisException(Messages.TmfAbstractAnalysisModule_NullTrace);
  }
  if (fTrace != null) {
    throw new TmfAnalysisException(NLS.bind(Messages.TmfAbstractAnalysisModule_TraceSetMoreThanOnce,getName()));
  }
  if (!canExecute(trace)) {
    throw new TmfAnalysisException(NLS.bind(Messages.TmfAbstractAnalysisModule_AnalysisCannotExecute,getName()));
  }
  fTrace=trace;
  fParameterProviders=TmfAnalysisManager.getParameterProviders(this,fTrace);
  for (  IAnalysisParameterProvider provider : fParameterProviders) {
    provider.registerModule(this);
  }
  resetAnalysis();
  fStarted=false;
}","@Override public void setTrace(ITmfTrace trace) throws TmfAnalysisException {
  if (trace == null) {
    throw new TmfAnalysisException(Messages.TmfAbstractAnalysisModule_NullTrace);
  }
  if (fTrace != null) {
    throw new TmfAnalysisException(NLS.bind(Messages.TmfAbstractAnalysisModule_TraceSetMoreThanOnce,getName()));
  }
  if (!canExecute(trace)) {
    throw new TmfAnalysisException(NLS.bind(Messages.TmfAbstractAnalysisModule_AnalysisCannotExecute,getName()));
  }
  fTrace=trace;
  fParameterProviders=TmfAnalysisManager.getParameterProviders(this,trace);
  for (  IAnalysisParameterProvider provider : fParameterProviders) {
    provider.registerModule(this);
  }
  resetAnalysis();
  fStarted=false;
}",0.9978976874562018
91833,"@Override protected IStatus run(final IProgressMonitor monitor){
  try {
    monitor.beginTask(""String_Node_Str"",IProgressMonitor.UNKNOWN);
    broadcast(new TmfStartAnalysisSignal(TmfAbstractAnalysisModule.this,TmfAbstractAnalysisModule.this));
    fAnalysisCancelled=!executeAnalysis(monitor);
  }
 catch (  TmfAnalysisException e) {
    Activator.logError(""String_Node_Str"" + getTrace().getName(),e);
  }
 finally {
synchronized (syncObj) {
      monitor.done();
      setAnalysisCompleted();
    }
    TmfTraceManager.refreshSupplementaryFiles(trace);
  }
  if (!fAnalysisCancelled) {
    return Status.OK_STATUS;
  }
  resetAnalysis();
  return Status.CANCEL_STATUS;
}","@Override protected IStatus run(final IProgressMonitor monitor){
  try {
    monitor.beginTask(""String_Node_Str"",IProgressMonitor.UNKNOWN);
    broadcast(new TmfStartAnalysisSignal(TmfAbstractAnalysisModule.this,TmfAbstractAnalysisModule.this));
    fAnalysisCancelled=!executeAnalysis(monitor);
  }
 catch (  TmfAnalysisException e) {
    Activator.logError(""String_Node_Str"" + trace.getName(),e);
  }
 finally {
synchronized (syncObj) {
      monitor.done();
      setAnalysisCompleted();
    }
    TmfTraceManager.refreshSupplementaryFiles(trace);
  }
  if (!fAnalysisCancelled) {
    return Status.OK_STATUS;
  }
  resetAnalysis();
  return Status.CANCEL_STATUS;
}",0.988814317673378
91834,"private void execute(@NonNull final ITmfTrace trace){
  if (fFinishedLatch.getCount() == 0) {
    return;
  }
synchronized (syncObj) {
    if (fStarted) {
      return;
    }
    fStarted=true;
  }
  fJob=new Job(NLS.bind(Messages.TmfAbstractAnalysisModule_RunningAnalysis,getName())){
    @Override protected IStatus run(    final IProgressMonitor monitor){
      try {
        monitor.beginTask(""String_Node_Str"",IProgressMonitor.UNKNOWN);
        broadcast(new TmfStartAnalysisSignal(TmfAbstractAnalysisModule.this,TmfAbstractAnalysisModule.this));
        fAnalysisCancelled=!executeAnalysis(monitor);
      }
 catch (      TmfAnalysisException e) {
        Activator.logError(""String_Node_Str"" + getTrace().getName(),e);
      }
 finally {
synchronized (syncObj) {
          monitor.done();
          setAnalysisCompleted();
        }
        TmfTraceManager.refreshSupplementaryFiles(trace);
      }
      if (!fAnalysisCancelled) {
        return Status.OK_STATUS;
      }
      resetAnalysis();
      return Status.CANCEL_STATUS;
    }
    @Override protected void canceling(){
      TmfAbstractAnalysisModule.this.canceling();
    }
  }
;
  fJob.schedule();
}","private void execute(@NonNull final ITmfTrace trace){
  if (fFinishedLatch.getCount() == 0) {
    return;
  }
synchronized (syncObj) {
    if (fStarted) {
      return;
    }
    fStarted=true;
  }
  fJob=new Job(NLS.bind(Messages.TmfAbstractAnalysisModule_RunningAnalysis,getName())){
    @Override protected IStatus run(    final IProgressMonitor monitor){
      try {
        monitor.beginTask(""String_Node_Str"",IProgressMonitor.UNKNOWN);
        broadcast(new TmfStartAnalysisSignal(TmfAbstractAnalysisModule.this,TmfAbstractAnalysisModule.this));
        fAnalysisCancelled=!executeAnalysis(monitor);
      }
 catch (      TmfAnalysisException e) {
        Activator.logError(""String_Node_Str"" + trace.getName(),e);
      }
 finally {
synchronized (syncObj) {
          monitor.done();
          setAnalysisCompleted();
        }
        TmfTraceManager.refreshSupplementaryFiles(trace);
      }
      if (!fAnalysisCancelled) {
        return Status.OK_STATUS;
      }
      resetAnalysis();
      return Status.CANCEL_STATUS;
    }
    @Override protected void canceling(){
      TmfAbstractAnalysisModule.this.canceling();
    }
  }
;
  fJob.schedule();
}",0.9935649935649936
91835,"@Override public IStatus schedule(){
  final ITmfTrace trace=fTrace;
  if (trace == null) {
    return new Status(IStatus.ERROR,Activator.PLUGIN_ID,String.format(""String_Node_Str"",getName()));
  }
  execute(trace);
  return Status.OK_STATUS;
}","@Override public IStatus schedule(){
synchronized (syncObj) {
    final ITmfTrace trace=getTrace();
    if (trace == null) {
      return new Status(IStatus.ERROR,Activator.PLUGIN_ID,String.format(""String_Node_Str"",getName()));
    }
    execute(trace);
  }
  return Status.OK_STATUS;
}",0.888468809073724
91836,"/** 
 * Signal handler for trace closing
 * @param signal Trace closed signal
 */
@TmfSignalHandler public void traceClosed(TmfTraceClosedSignal signal){
  if (signal.getTrace() == fTrace) {
    cancel();
    fTrace=null;
  }
}","/** 
 * Signal handler for trace closing
 * @param signal Trace closed signal
 */
@TmfSignalHandler public void traceClosed(TmfTraceClosedSignal signal){
synchronized (syncObj) {
    if (signal.getTrace() == fTrace) {
      cancel();
      fTrace=null;
    }
  }
}",0.924643584521385
91837,"@Override protected boolean executeAnalysis(@Nullable final IProgressMonitor monitor){
  IProgressMonitor mon=(monitor == null ? new NullProgressMonitor() : monitor);
  final ITmfStateProvider provider=createStateProvider();
  String id=getId();
  try {
    StateSystemBackendType backend=getBackendType();
    String directory;
    File htFile;
switch (backend) {
case FULL:
      directory=TmfTraceManager.getSupplementaryFileDir(getTrace());
    htFile=new File(directory + getSsFileName());
  createFullHistory(id,provider,htFile);
break;
case PARTIAL:
directory=TmfTraceManager.getSupplementaryFileDir(getTrace());
htFile=new File(directory + getSsFileName());
createPartialHistory(id,provider,htFile);
break;
case INMEM:
createInMemoryHistory(id,provider);
break;
case NULL:
createNullHistory(id,provider);
break;
default :
break;
}
}
 catch (TmfTraceException e) {
return false;
}
return !mon.isCanceled();
}","@Override protected boolean executeAnalysis(@Nullable final IProgressMonitor monitor){
  IProgressMonitor mon=(monitor == null ? new NullProgressMonitor() : monitor);
  final ITmfStateProvider provider=createStateProvider();
  String id=getId();
  try {
    StateSystemBackendType backend=getBackendType();
    String directory;
    File htFile;
    ITmfTrace trace=getTrace();
    if (trace == null) {
      fInitialized.countDown();
      return false;
    }
switch (backend) {
case FULL:
      directory=TmfTraceManager.getSupplementaryFileDir(trace);
    htFile=new File(directory + getSsFileName());
  createFullHistory(id,provider,htFile);
break;
case PARTIAL:
directory=TmfTraceManager.getSupplementaryFileDir(trace);
htFile=new File(directory + getSsFileName());
createPartialHistory(id,provider,htFile);
break;
case INMEM:
createInMemoryHistory(id,provider);
break;
case NULL:
createNullHistory(id,provider);
break;
default :
break;
}
}
 catch (TmfTraceException e) {
fInitialized.countDown();
return false;
}
return !mon.isCanceled();
}",0.912799592044875
91838,"@Override protected boolean executeAnalysis(IProgressMonitor monitor) throws TmfAnalysisException {
  ITmfTrace trace=getTrace();
  if (trace == null) {
    throw new IllegalStateException();
  }
  IStatus status1=totalsModule.schedule();
  IStatus status2=eventTypesModule.schedule();
  if (!(status1.isOK() && status2.isOK())) {
    cancelSubAnalyses();
    return false;
  }
  totalsModule.waitForInitialization();
  eventTypesModule.waitForInitialization();
  ITmfStateSystem totalsSS=totalsModule.getStateSystem();
  ITmfStateSystem eventTypesSS=eventTypesModule.getStateSystem();
  if (totalsSS == null || eventTypesSS == null) {
    throw new IllegalStateException();
  }
  fStatistics=new TmfStateStatistics(totalsSS,eventTypesSS);
  fInitialized.countDown();
  if (!(totalsModule.waitForCompletion(monitor) && eventTypesModule.waitForCompletion(monitor))) {
    return false;
  }
  return true;
}","@Override protected boolean executeAnalysis(IProgressMonitor monitor) throws TmfAnalysisException {
  ITmfTrace trace=getTrace();
  if (trace == null) {
    fInitialized.countDown();
    return false;
  }
  IStatus status1=totalsModule.schedule();
  IStatus status2=eventTypesModule.schedule();
  if (!(status1.isOK() && status2.isOK())) {
    cancelSubAnalyses();
    fInitialized.countDown();
    return false;
  }
  totalsModule.waitForInitialization();
  eventTypesModule.waitForInitialization();
  ITmfStateSystem totalsSS=totalsModule.getStateSystem();
  ITmfStateSystem eventTypesSS=eventTypesModule.getStateSystem();
  if (totalsSS == null || eventTypesSS == null) {
    fInitialized.countDown();
    return false;
  }
  fStatistics=new TmfStateStatistics(totalsSS,eventTypesSS);
  fInitialized.countDown();
  if (!(totalsModule.waitForCompletion(monitor) && eventTypesModule.waitForCompletion(monitor))) {
    return false;
  }
  return true;
}",0.907427341227126
91839,"@Override protected boolean executeAnalysis(@Nullable IProgressMonitor monitor) throws TmfAnalysisException {
  IProgressMonitor mon=(monitor == null ? new NullProgressMonitor() : monitor);
  if (getTrace() == null) {
    return false;
  }
  ITmfEventRequest request=fRequest;
  if ((request != null) && (!request.isCompleted())) {
    request.cancel();
  }
  request=new TmfEventRequest(PcapEvent.class,TmfTimeRange.ETERNITY,0L,ITmfEventRequest.ALL_DATA,ITmfEventRequest.ExecutionType.BACKGROUND){
    @Override public void handleData(    ITmfEvent data){
      super.handleData(data);
      if (!(data instanceof PcapEvent)) {
        return;
      }
      PcapEvent event=(PcapEvent)data;
      for (      TmfPcapProtocol protocol : fBuilders.keySet()) {
        fBuilders.get(protocol).addEventToStream(event);
      }
    }
  }
;
  getTrace().sendRequest(request);
  fRequest=request;
  try {
    request.waitForCompletion();
  }
 catch (  InterruptedException e) {
    return false;
  }
  return !mon.isCanceled() && !request.isCancelled() && !request.isFailed();
}","@Override protected boolean executeAnalysis(@Nullable IProgressMonitor monitor) throws TmfAnalysisException {
  IProgressMonitor mon=(monitor == null ? new NullProgressMonitor() : monitor);
  ITmfTrace trace=getTrace();
  if (trace == null) {
    return false;
  }
  ITmfEventRequest request=fRequest;
  if ((request != null) && (!request.isCompleted())) {
    request.cancel();
  }
  request=new TmfEventRequest(PcapEvent.class,TmfTimeRange.ETERNITY,0L,ITmfEventRequest.ALL_DATA,ITmfEventRequest.ExecutionType.BACKGROUND){
    @Override public void handleData(    ITmfEvent data){
      super.handleData(data);
      if (!(data instanceof PcapEvent)) {
        return;
      }
      PcapEvent event=(PcapEvent)data;
      for (      TmfPcapProtocol protocol : fBuilders.keySet()) {
        fBuilders.get(protocol).addEventToStream(event);
      }
    }
  }
;
  trace.sendRequest(request);
  fRequest=request;
  try {
    request.waitForCompletion();
  }
 catch (  InterruptedException e) {
    return false;
  }
  return !mon.isCanceled() && !request.isCancelled() && !request.isFailed();
}",0.9777983348751156
91840,"@Override public void stop(BundleContext context) throws Exception {
  plugin=null;
  super.stop(context);
}","@Override public void stop(BundleContext context) throws Exception {
  stateLocation=this.getStateLocation();
  preferenceStore=this.getPreferenceStore();
  plugin=null;
  super.stop(context);
}",0.7152317880794702
91841,"private void save(){
  LibHover.saveLibraries();
}","private void save(){
  if (stateLocation == null)   stateLocation=this.getStateLocation();
  if (preferenceStore == null)   preferenceStore=this.getPreferenceStore();
  LibHover.saveLibraries(stateLocation,preferenceStore);
}",0.3636363636363636
91842,"public static void saveLibraries(){
  IPreferenceStore ps=LibhoverPlugin.getDefault().getPreferenceStore();
  if (ps.getBoolean(PreferenceConstants.CACHE_EXT_LIBHOVER)) {
    IPath locationBase=LibhoverPlugin.getDefault().getStateLocation();
    for (Iterator<LibHoverLibrary> i=libraries.values().iterator(); i.hasNext(); ) {
      LibHoverLibrary l=i.next();
      try {
        IPath locationDir=locationBase;
        if (l.isCPP()) {
          locationDir=locationBase.append(""String_Node_Str"");
        }
 else {
          locationDir=locationBase.append(""String_Node_Str"");
        }
        File lDir=new File(locationDir.toOSString());
        lDir.mkdir();
        IPath location=locationDir.append(getTransformedName(l.getName()) + ""String_Node_Str"");
        File target=new File(location.toOSString());
        if (!target.exists()) {
          try (FileOutputStream f=new FileOutputStream(locationDir.append(""String_Node_Str"").toOSString());ObjectOutputStream out=new ObjectOutputStream(f)){
            out.writeObject(l.getHoverInfo());
            out.close();
            File tmp=new File(locationDir.append(""String_Node_Str"").toOSString());
            tmp.renameTo(target);
          }
         }
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
}","public static void saveLibraries(IPath locationBase,IPreferenceStore ps){
  if (ps.getBoolean(PreferenceConstants.CACHE_EXT_LIBHOVER)) {
    for (Iterator<LibHoverLibrary> i=libraries.values().iterator(); i.hasNext(); ) {
      LibHoverLibrary l=i.next();
      try {
        IPath locationDir=locationBase;
        if (l.isCPP()) {
          locationDir=locationBase.append(""String_Node_Str"");
        }
 else {
          locationDir=locationBase.append(""String_Node_Str"");
        }
        File lDir=new File(locationDir.toOSString());
        lDir.mkdir();
        IPath location=locationDir.append(getTransformedName(l.getName()) + ""String_Node_Str"");
        File target=new File(location.toOSString());
        if (!target.exists()) {
          try (FileOutputStream f=new FileOutputStream(locationDir.append(""String_Node_Str"").toOSString());ObjectOutputStream out=new ObjectOutputStream(f)){
            out.writeObject(l.getHoverInfo());
            out.close();
            File tmp=new File(locationDir.append(""String_Node_Str"").toOSString());
            tmp.renameTo(target);
          }
         }
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
}",0.9411764705882352
91843,"public String getXmlElem(){
  return fXmlElem;
}","/** 
 * Get the XML element corresponding to this view type
 * @return The XML element corresponding to this type
 */
public @NonNull String getXmlElem(){
  return fXmlElem;
}",0.4304932735426009
91844,"public String getViewId(){
  return fViewId;
}","private String getViewId(){
  return fViewId;
}",0.9032258064516128
91845,"private void ViewType(String xmlElem,String viewId){
  fXmlElem=xmlElem;
  fViewId=viewId;
}","private void ViewType(@NonNull String xmlElem,String viewId){
  fXmlElem=xmlElem;
  fViewId=viewId;
}",0.9533678756476685
91846,"@Override public void moduleCreated(IAnalysisModule module){
  IPath pathToFiles=XmlUtils.getXmlFilesPath();
  File fFolder=pathToFiles.toFile();
  if (!(fFolder.isDirectory() && fFolder.exists())) {
    return;
  }
  for (  File xmlFile : fFolder.listFiles()) {
    if (!XmlUtils.xmlValidate(xmlFile).isOK()) {
      continue;
    }
    try {
      DocumentBuilderFactory dbFactory=DocumentBuilderFactory.newInstance();
      DocumentBuilder dBuilder=dbFactory.newDocumentBuilder();
      Document doc=dBuilder.parse(xmlFile);
      doc.getDocumentElement().normalize();
      if (module instanceof TmfStateSystemAnalysisModule) {
        for (        ViewType viewType : ViewType.values()) {
          NodeList ssViewNodes=doc.getElementsByTagName(viewType.getXmlElem());
          for (int i=0; i < ssViewNodes.getLength(); i++) {
            Element node=(Element)ssViewNodes.item(i);
            List<Element> headNodes=XmlUtils.getChildElements(node,TmfXmlStrings.HEAD);
            if (headNodes.size() != 1) {
              continue;
            }
            List<Element> analysisNodes=XmlUtils.getChildElements(headNodes.get(0),TmfXmlStrings.ANALYSIS);
            for (            Element analysis : analysisNodes) {
              String analysisId=analysis.getAttribute(TmfXmlStrings.ID);
              if (analysisId.equals(module.getId())) {
                String viewId=viewType.getViewId();
                IAnalysisOutput output=new TmfXmlViewOutput(viewId);
                output.setOutputProperty(TmfXmlUiStrings.XML_OUTPUT_DATA,node.getAttribute(TmfXmlStrings.ID) + DATA_SEPARATOR + xmlFile.getAbsolutePath(),false);
                module.registerOutput(output);
              }
            }
          }
        }
      }
    }
 catch (    ParserConfigurationException|SAXException|IOException e) {
      Activator.logError(""String_Node_Str"",e);
    }
  }
}","@Override public void moduleCreated(IAnalysisModule module){
  IPath pathToFiles=XmlUtils.getXmlFilesPath();
  File fFolder=pathToFiles.toFile();
  if (!(fFolder.isDirectory() && fFolder.exists())) {
    return;
  }
  for (  File xmlFile : fFolder.listFiles()) {
    if (!XmlUtils.xmlValidate(xmlFile).isOK()) {
      continue;
    }
    try {
      DocumentBuilderFactory dbFactory=DocumentBuilderFactory.newInstance();
      DocumentBuilder dBuilder=dbFactory.newDocumentBuilder();
      Document doc=dBuilder.parse(xmlFile);
      doc.getDocumentElement().normalize();
      if (module instanceof TmfStateSystemAnalysisModule) {
        for (        ViewType viewType : ViewType.values()) {
          NodeList ssViewNodes=doc.getElementsByTagName(viewType.getXmlElem());
          for (int i=0; i < ssViewNodes.getLength(); i++) {
            Element node=(Element)ssViewNodes.item(i);
            List<Element> headNodes=XmlUtils.getChildElements(node,TmfXmlStrings.HEAD);
            if (headNodes.size() != 1) {
              continue;
            }
            List<Element> analysisNodes=XmlUtils.getChildElements(headNodes.get(0),TmfXmlStrings.ANALYSIS);
            for (            Element analysis : analysisNodes) {
              String analysisId=analysis.getAttribute(TmfXmlStrings.ID);
              if (analysisId.equals(module.getId())) {
                String viewId=viewType.getViewId();
                IAnalysisOutput output=new TmfXmlViewOutput(viewId,viewType);
                output.setOutputProperty(TmfXmlUiStrings.XML_OUTPUT_DATA,node.getAttribute(TmfXmlStrings.ID) + DATA_SEPARATOR + xmlFile.getAbsolutePath(),false);
                module.registerOutput(output);
              }
            }
          }
        }
      }
    }
 catch (    ParserConfigurationException|SAXException|IOException e) {
      Activator.logError(""String_Node_Str"",e);
    }
  }
}",0.9976146302676916
91847,"/** 
 * Constructor
 * @param viewid id of the view to display as output
 */
public TmfXmlViewOutput(String viewid){
  super(viewid);
}","/** 
 * Constructor
 * @param viewid id of the view to display as output
 * @param viewType type of view this output is for
 * @since 1.1
 */
public TmfXmlViewOutput(String viewid,@NonNull ViewType viewType){
  super(viewid);
  fViewType=viewType;
}",0.703125
91848,"@Override public void setOutputProperty(@NonNull String key,String value,boolean immediate){
  super.setOutputProperty(key,value,immediate);
  if (key.equals(TmfXmlUiStrings.XML_OUTPUT_DATA)) {
    String[] idFile=value.split(TmfXmlAnalysisOutputSource.DATA_SEPARATOR);
    String viewId=(idFile.length > 0) ? idFile[0] : null;
    String filePath=(idFile.length > 1) ? idFile[1] : null;
    if ((viewId == null) || (filePath == null)) {
      return;
    }
    Element viewElement=XmlUtils.getElementInFile(filePath,TmfXmlUiStrings.TIME_GRAPH_VIEW,viewId);
    if (viewElement == null) {
      return;
    }
    List<Element> heads=XmlUtils.getChildElements(viewElement,TmfXmlStrings.HEAD);
    if (heads.size() != 1) {
      return;
    }
    Element headElement=heads.get(0);
    List<Element> label=XmlUtils.getChildElements(headElement,TmfXmlStrings.LABEL);
    if (label.isEmpty()) {
      return;
    }
    Element labelElement=label.get(0);
    fLabel=labelElement.getAttribute(TmfXmlStrings.VALUE);
  }
}","@Override public void setOutputProperty(@NonNull String key,String value,boolean immediate){
  super.setOutputProperty(key,value,immediate);
  if (key.equals(TmfXmlUiStrings.XML_OUTPUT_DATA)) {
    String[] idFile=value.split(TmfXmlAnalysisOutputSource.DATA_SEPARATOR);
    String viewId=(idFile.length > 0) ? idFile[0] : null;
    String filePath=(idFile.length > 1) ? idFile[1] : null;
    if ((viewId == null) || (filePath == null)) {
      return;
    }
    Element viewElement=XmlUtils.getElementInFile(filePath,fViewType.getXmlElem(),viewId);
    if (viewElement == null) {
      return;
    }
    List<Element> heads=XmlUtils.getChildElements(viewElement,TmfXmlStrings.HEAD);
    if (heads.size() != 1) {
      return;
    }
    Element headElement=heads.get(0);
    List<Element> label=XmlUtils.getChildElements(headElement,TmfXmlStrings.LABEL);
    if (label.isEmpty()) {
      return;
    }
    Element labelElement=label.get(0);
    fLabel=labelElement.getAttribute(TmfXmlStrings.VALUE);
  }
}",0.977689638076351
91849,"private SourceFile findSourceCoverageForElement(ICElement element){
  List<SourceFile> sources=new ArrayList<>();
  ICProject cProject=element.getCProject();
  IPath target=GcovAnnotationModelTracker.getInstance().getBinaryPath(cProject.getProject());
  try {
    IBinary[] binaries=cProject.getBinaryContainer().getBinaries();
    for (    IBinary b : binaries) {
      if (b.getResource().getLocation().equals(target)) {
        CovManager covManager=new CovManager(b.getResource().getLocation().toOSString());
        covManager.processCovFiles(covManager.getGCDALocations(),null);
        sources.addAll(covManager.getAllSrcs());
      }
    }
  }
 catch (  IOException|CoreException|InterruptedException e) {
  }
  for (  SourceFile sf : sources) {
    IPath sfPath=new Path(sf.getName());
    IFile file=STLink2SourceSupport.getFileForPath(sfPath,cProject.getProject());
    if (file != null && element.getLocationURI().getPath().equals(file.getLocation().toOSString())) {
      return sf;
    }
  }
  IPath binFolder=target.removeLastSegments(1);
  for (  SourceFile sf : sources) {
    String sfPath=Paths.get(binFolder.toOSString(),sf.getName()).normalize().toString();
    if (sfPath.equals(element.getLocationURI().getPath())) {
      return sf;
    }
  }
  return null;
}","private SourceFile findSourceCoverageForElement(ICElement element){
  List<SourceFile> sources=new ArrayList<>();
  ICProject cProject=element.getCProject();
  IPath target=GcovAnnotationModelTracker.getInstance().getBinaryPath(cProject.getProject());
  try {
    IBinary[] binaries=cProject.getBinaryContainer().getBinaries();
    for (    IBinary b : binaries) {
      if (b.getResource().getLocation().equals(target)) {
        CovManager covManager=new CovManager(b.getResource().getLocation().toOSString());
        covManager.processCovFiles(covManager.getGCDALocations(),null);
        sources.addAll(covManager.getAllSrcs());
      }
    }
  }
 catch (  IOException|CoreException|InterruptedException e) {
  }
  for (  SourceFile sf : sources) {
    IPath sfPath=new Path(sf.getName());
    IFile file=STLink2SourceSupport.getFileForPath(sfPath,cProject.getProject());
    if (file != null && element.getResource().getLocation().equals(file.getLocation())) {
      return sf;
    }
  }
  IPath binFolder=target.removeLastSegments(1);
  for (  SourceFile sf : sources) {
    String sfPath=Paths.get(binFolder.toOSString()).resolve(sf.getName()).normalize().toString();
    if (sfPath.equals(element.getLocationURI().getPath())) {
      return sf;
    }
  }
  return null;
}",0.7569254779555209
91850,"/** 
 * Create opcontrol process
 * @param cmdArray array of opcontrol command and arguments
 * @param project project to be profiled
 * @return p opcontrol process
 * @throws OpcontrolException
 * @since 1.1
 */
protected Process createOpcontrolProcess(String[] cmdArray,IProject project) throws OpcontrolException {
  Process p=null;
  try {
    if (!LinuxtoolsPathProperty.getInstance().getLinuxtoolsPath(project).equals(""String_Node_Str"")) {
      p=RuntimeProcessFactory.getFactory().sudoExec(cmdArray,project);
    }
 else     if (isInstalled) {
      p=Runtime.getRuntime().exec(cmdArray);
    }
 else {
      throw new OpcontrolException(OprofileCorePlugin.createErrorStatus(""String_Node_Str"",null));
    }
  }
 catch (  IOException ioe) {
    throw new OpcontrolException(OprofileCorePlugin.createErrorStatus(""String_Node_Str"",ioe));
  }
  return p;
}","/** 
 * Create opcontrol process
 * @param cmdArray array of opcontrol command and arguments
 * @param project project to be profiled
 * @return p opcontrol process
 * @throws OpcontrolException
 * @since 1.1
 */
protected Process createOpcontrolProcess(String[] cmdArray,IProject project) throws OpcontrolException {
  Process p=null;
  try {
    if (!LinuxtoolsPathProperty.getInstance().getLinuxtoolsPath(project).isEmpty()) {
      p=RuntimeProcessFactory.getFactory().sudoExec(cmdArray,project);
    }
 else     if (isInstalled) {
      p=Runtime.getRuntime().exec(cmdArray);
    }
 else {
      throw new OpcontrolException(OprofileCorePlugin.createErrorStatus(""String_Node_Str"",null));
    }
  }
 catch (  IOException ioe) {
    throw new OpcontrolException(OprofileCorePlugin.createErrorStatus(""String_Node_Str"",ioe));
  }
  return p;
}",0.9812206572769951
91851,"/** 
 * Saves the current (""default"") session
 * @param name    the name to which to save the session
 * @throws OpcontrolException
 */
@Override public void saveSession(String name) throws OpcontrolException {
  SessionManager sessMan;
  try {
    sessMan=new SessionManager(SessionManager.SESSION_LOCATION);
    for (    String event : sessMan.getSessionEvents(SessionManager.CURRENT)) {
      sessMan.addSession(name,event);
      String oldFile=SessionManager.OPXML_PREFIX + SessionManager.MODEL_DATA + event+ SessionManager.CURRENT;
      String newFile=SessionManager.OPXML_PREFIX + SessionManager.MODEL_DATA + event+ name;
      Process p=Runtime.getRuntime().exec(""String_Node_Str"" + oldFile + ""String_Node_Str""+ newFile);
      p.waitFor();
    }
    sessMan.write();
  }
 catch (  FileNotFoundException e) {
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","/** 
 * Saves the current (""default"") session
 * @param name    the name to which to save the session
 * @throws OpcontrolException
 */
@Override public void saveSession(String name) throws OpcontrolException {
  SessionManager sessMan;
  try {
    sessMan=new SessionManager(SessionManager.SESSION_LOCATION);
    for (    String event : sessMan.getSessionEvents(SessionManager.CURRENT)) {
      sessMan.addSession(name,event);
      String oldFile=SessionManager.OPXML_PREFIX + SessionManager.MODEL_DATA + event+ SessionManager.CURRENT;
      String newFile=SessionManager.OPXML_PREFIX + SessionManager.MODEL_DATA + event+ name;
      Process p=Runtime.getRuntime().exec(""String_Node_Str"" + oldFile + ""String_Node_Str""+ newFile);
      p.waitFor();
    }
    sessMan.write();
  }
 catch (  FileNotFoundException e) {
  }
catch (  IOException|InterruptedException e) {
    e.printStackTrace();
  }
}",0.9538294405214556
91852,"/** 
 * Checks if the user has permissions to execute opcontrol as root without providing password and if opcontrol exists in the indicated path
 * @param project The project to be profiled
 * @return true if the user has sudo permission to run opcontrol, false otherwise
 * @throws OpcontrolException if opcontrol not installed
 * @since 1.1
 */
@Override public boolean hasPermissions(IProject project) throws OpcontrolException {
  String linuxtoolsPath=LinuxtoolsPathProperty.getInstance().getLinuxtoolsPath(project);
  try {
    String opcontrolPath=null;
    if (linuxtoolsPath.equals(""String_Node_Str"")) {
      if (!isInstalled()) {
        throw new OpcontrolException(OprofileCorePlugin.createErrorStatus(""String_Node_Str"",null));
      }
 else {
        return true;
      }
    }
 else     if (linuxtoolsPath.endsWith(""String_Node_Str"")) {
      opcontrolPath=linuxtoolsPath + ""String_Node_Str"";
    }
 else {
      opcontrolPath=linuxtoolsPath + ""String_Node_Str"";
    }
    final Process p=RuntimeProcessFactory.getFactory().exec(""String_Node_Str"",project);
    final StringBuffer buffer=new StringBuffer();
    if (p == null) {
      return false;
    }
    Thread t=new Thread(){
      @Override public void run(){
        try {
          BufferedReader input=new BufferedReader(new InputStreamReader(p.getInputStream()));
          String s=null;
          while ((s=input.readLine()) != null) {
            buffer.append(s);
            buffer.append('\n');
          }
          p.waitFor();
          p.destroy();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
;
    t.start();
    t.join(SUDO_TIMEOUT);
    String[] sudoLines=buffer.toString().split(""String_Node_Str"");
    for (    String s : sudoLines) {
      if (s.contains(opcontrolPath) && s.contains(""String_Node_Str"")) {
        return true;
      }
    }
    System.out.println(buffer.toString());
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
  return false;
}","/** 
 * Checks if the user has permissions to execute opcontrol as root without providing password and if opcontrol exists in the indicated path
 * @param project The project to be profiled
 * @return true if the user has sudo permission to run opcontrol, false otherwise
 * @throws OpcontrolException if opcontrol not installed
 * @since 1.1
 */
@Override public boolean hasPermissions(IProject project) throws OpcontrolException {
  String linuxtoolsPath=LinuxtoolsPathProperty.getInstance().getLinuxtoolsPath(project);
  try {
    String opcontrolPath=null;
    if (linuxtoolsPath.isEmpty()) {
      if (!isInstalled()) {
        throw new OpcontrolException(OprofileCorePlugin.createErrorStatus(""String_Node_Str"",null));
      }
 else {
        return true;
      }
    }
 else     if (linuxtoolsPath.endsWith(""String_Node_Str"")) {
      opcontrolPath=linuxtoolsPath + ""String_Node_Str"";
    }
 else {
      opcontrolPath=linuxtoolsPath + ""String_Node_Str"";
    }
    final Process p=RuntimeProcessFactory.getFactory().exec(""String_Node_Str"",project);
    final StringBuffer buffer=new StringBuffer();
    if (p == null) {
      return false;
    }
    Thread t=new Thread(){
      @Override public void run(){
        try {
          BufferedReader input=new BufferedReader(new InputStreamReader(p.getInputStream()));
          String s=null;
          while ((s=input.readLine()) != null) {
            buffer.append(s);
            buffer.append('\n');
          }
          p.waitFor();
          p.destroy();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
;
    t.start();
    t.join(SUDO_TIMEOUT);
    String[] sudoLines=buffer.toString().split(""String_Node_Str"");
    for (    String s : sudoLines) {
      if (s.contains(opcontrolPath) && s.contains(""String_Node_Str"")) {
        return true;
      }
    }
    System.out.println(buffer.toString());
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
  return false;
}",0.9925994449583718
91853,"/** 
 * Search for opcontrol executable on the system
 * @return a string path to opcontrol executable
 * @since 1.1
 */
private String findOpcontrolExecutable(){
  IProject project=Oprofile.OprofileProject.getProject();
  if (!LinuxtoolsPathProperty.getInstance().getLinuxtoolsPath(project).equals(""String_Node_Str"")) {
    return OPCONTROL_EXECUTABLE;
  }
  URL url=FileLocator.find(Platform.getBundle(OprofileCorePlugin.getId()),new Path(OPCONTROL_REL_PATH),null);
  if (url != null) {
    try {
      isInstalled=true;
      return FileLocator.toFileURL(url).getPath();
    }
 catch (    IOException ignore) {
    }
  }
 else {
    isInstalled=false;
    return OPCONTROL_EXECUTABLE;
  }
  return null;
}","/** 
 * Search for opcontrol executable on the system
 * @return a string path to opcontrol executable
 * @since 1.1
 */
private String findOpcontrolExecutable(){
  IProject project=Oprofile.OprofileProject.getProject();
  if (!LinuxtoolsPathProperty.getInstance().getLinuxtoolsPath(project).isEmpty()) {
    return OPCONTROL_EXECUTABLE;
  }
  URL url=FileLocator.find(Platform.getBundle(OprofileCorePlugin.getId()),new Path(OPCONTROL_REL_PATH),null);
  if (url != null) {
    try {
      isInstalled=true;
      return FileLocator.toFileURL(url).getPath();
    }
 catch (    IOException ignore) {
    }
  }
 else {
    isInstalled=false;
    return OPCONTROL_EXECUTABLE;
  }
  return null;
}",0.9771428571428572
91854,"private File saveOpxmlToFile(BufferedReader bi,String[] args){
  String fileName=""String_Node_Str"";
  for (int i=0; i < args.length; i++) {
    fileName+=args[i];
  }
  File file=new File(SessionManager.OPXML_PREFIX + fileName);
  String line;
  try {
    file.createNewFile();
    BufferedWriter bw=new BufferedWriter(new FileWriter(file));
    while ((line=bi.readLine()) != null) {
      bw.write(line + ""String_Node_Str"");
    }
    bi.close();
    bw.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return file;
}","private File saveOpxmlToFile(BufferedReader bi,String[] args){
  String fileName=""String_Node_Str"";
  for (  String arg : args) {
    fileName+=arg;
  }
  File file=new File(SessionManager.OPXML_PREFIX + fileName);
  String line;
  try {
    file.createNewFile();
    BufferedWriter bw=new BufferedWriter(new FileWriter(file));
    while ((line=bi.readLine()) != null) {
      bw.write(line + ""String_Node_Str"");
    }
    bi.close();
    bw.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return file;
}",0.951310861423221
91855,"/** 
 * Run opreport with specified arguments <code>args</code> and return InputStream to output of report for parsing.
 * @param args arguments to run with opreport
 * @return InputStream to output of report
 */
private InputStream runOpReport(String[] args){
  ArrayList<String> cmd=new ArrayList<>();
  cmd.add(""String_Node_Str"");
  if (OprofileProject.getProfilingBinary().equals(OprofileProject.OPERF_BINARY)) {
    String workingDir=""String_Node_Str"";
    RemoteProxyManager proxy=RemoteProxyManager.getInstance();
    try {
      IRemoteFileProxy rfile=proxy.getFileProxy(Oprofile.OprofileProject.getProject());
      workingDir=rfile.getWorkingDir().getPath();
    }
 catch (    CoreException e) {
      e.printStackTrace();
      return null;
    }
    cmd.add(1,""String_Node_Str"" + workingDir + IPath.SEPARATOR+ ""String_Node_Str"");
  }
  Collections.addAll(cmd,args);
  Process p=null;
  try {
    p=RuntimeProcessFactory.getFactory().exec(cmd.toArray(new String[0]),Oprofile.OprofileProject.getProject());
    StringBuilder output=new StringBuilder();
    StringBuilder errorOutput=new StringBuilder();
    String s=null;
    try (BufferedReader stdInput=new BufferedReader(new InputStreamReader(p.getInputStream()));BufferedReader stdError=new BufferedReader(new InputStreamReader(p.getErrorStream()))){
      while ((s=stdInput.readLine()) != null) {
        output.append(s + System.getProperty(""String_Node_Str""));
      }
      while ((s=stdError.readLine()) != null) {
        errorOutput.append(s + System.getProperty(""String_Node_Str""));
      }
      if (!errorOutput.toString().trim().equals(""String_Node_Str"")) {
        OprofileCorePlugin.log(IStatus.ERROR,NLS.bind(OprofileProperties.getString(""String_Node_Str""),""String_Node_Str"",errorOutput.toString().trim()));
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    if (p.waitFor() == 0) {
      try {
        return new ByteArrayInputStream(output.toString().getBytes(""String_Node_Str""));
      }
 catch (      UnsupportedEncodingException e) {
        e.printStackTrace();
      }
    }
  }
 catch (  IOException e1) {
    e1.printStackTrace();
    OprofileCorePlugin.showErrorDialog(""String_Node_Str"",null);
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
  return null;
}","/** 
 * Run opreport with specified arguments <code>args</code> and return InputStream to output of report for parsing.
 * @param args arguments to run with opreport
 * @return InputStream to output of report
 */
private InputStream runOpReport(String[] args){
  ArrayList<String> cmd=new ArrayList<>();
  cmd.add(""String_Node_Str"");
  if (OprofileProject.getProfilingBinary().equals(OprofileProject.OPERF_BINARY)) {
    String workingDir=""String_Node_Str"";
    RemoteProxyManager proxy=RemoteProxyManager.getInstance();
    try {
      IRemoteFileProxy rfile=proxy.getFileProxy(Oprofile.OprofileProject.getProject());
      workingDir=rfile.getWorkingDir().getPath();
    }
 catch (    CoreException e) {
      e.printStackTrace();
      return null;
    }
    cmd.add(1,""String_Node_Str"" + workingDir + IPath.SEPARATOR+ ""String_Node_Str"");
  }
  Collections.addAll(cmd,args);
  Process p=null;
  try {
    p=RuntimeProcessFactory.getFactory().exec(cmd.toArray(new String[0]),Oprofile.OprofileProject.getProject());
    StringBuilder output=new StringBuilder();
    StringBuilder errorOutput=new StringBuilder();
    String s=null;
    try (BufferedReader stdInput=new BufferedReader(new InputStreamReader(p.getInputStream()));BufferedReader stdError=new BufferedReader(new InputStreamReader(p.getErrorStream()))){
      while ((s=stdInput.readLine()) != null) {
        output.append(s + System.getProperty(""String_Node_Str""));
      }
      while ((s=stdError.readLine()) != null) {
        errorOutput.append(s + System.getProperty(""String_Node_Str""));
      }
      if (!errorOutput.toString().trim().equals(""String_Node_Str"")) {
        OprofileCorePlugin.log(IStatus.ERROR,NLS.bind(OprofileProperties.getString(""String_Node_Str""),""String_Node_Str"",errorOutput.toString().trim()));
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    if (p.waitFor() == 0) {
      return new ByteArrayInputStream(output.toString().getBytes(StandardCharsets.UTF_8));
    }
  }
 catch (  IOException e1) {
    e1.printStackTrace();
    OprofileCorePlugin.showErrorDialog(""String_Node_Str"",null);
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
  return null;
}",0.9666073018699912
91856,"/** 
 * @return an InputStream to the newly created XML data.
 */
public InputStream getInputStream(){
  InputStream inp=null;
  Source source=new DOMSource(getDocument());
  StringWriter stw=new StringWriter();
  Result result=new StreamResult(stw);
  TransformerFactory factory=TransformerFactory.newInstance();
  Transformer xformer;
  try {
    xformer=factory.newTransformer();
    xformer.setOutputProperty(""String_Node_Str"",""String_Node_Str"");
    xformer.transform(source,result);
    inp=new ByteArrayInputStream(stw.toString().getBytes(""String_Node_Str""));
  }
 catch (  TransformerException|UnsupportedEncodingException e) {
    e.printStackTrace();
  }
  return inp;
}","/** 
 * @return an InputStream to the newly created XML data.
 */
public InputStream getInputStream(){
  InputStream inp=null;
  Source source=new DOMSource(getDocument());
  StringWriter stw=new StringWriter();
  Result result=new StreamResult(stw);
  TransformerFactory factory=TransformerFactory.newInstance();
  Transformer xformer;
  try {
    xformer=factory.newTransformer();
    xformer.setOutputProperty(""String_Node_Str"",""String_Node_Str"");
    xformer.transform(source,result);
    inp=new ByteArrayInputStream(stw.toString().getBytes(StandardCharsets.UTF_8));
  }
 catch (  TransformerException e) {
    e.printStackTrace();
  }
  return inp;
}",0.9505988023952096
91857,"private void createXML(){
  Element oldImage=(Element)oldRoot.getElementsByTagName(BINARY).item(0);
  Element newImage=newDoc.createElement(IMAGE);
  String binName=oldImage.getAttribute(NAME);
  newImage.setAttribute(NAME,binName);
  Element countTag=(Element)oldImage.getElementsByTagName(COUNT).item(0);
  String imageCount=countTag.getTextContent().trim();
  newImage.setAttribute(COUNT,imageCount);
  if (!InfoAdapter.hasTimerSupport()) {
    Element setupTag=(Element)oldRoot.getElementsByTagName(SETUP).item(0);
    Element eventSetupTag=(Element)setupTag.getElementsByTagName(EVENT_SETUP).item(0);
    String setupcount=eventSetupTag.getAttribute(SETUP_COUNT);
    newImage.setAttribute(SETUP_COUNT,setupcount);
  }
  Element oldSymbolTableTag=(Element)oldRoot.getElementsByTagName(SYMBOL_TABLE).item(0);
  NodeList oldSymbolDataList=oldSymbolTableTag.getElementsByTagName(SYMBOL_DATA);
  Element oldDetailTableTag=(Element)oldRoot.getElementsByTagName(DETAIL_TABLE).item(0);
  NodeList oldDetailTableList=oldDetailTableTag.getElementsByTagName(SYMBOL_DETAILS);
  HashMap<String,HashMap<String,String>> oldSymbolDataListMap=parseDataList(oldSymbolDataList);
  HashMap<String,NodeList> oldDetailTableListMap=parseDetailTable(oldDetailTableList);
  ArrayList<Element> oldImageList=new ArrayList<>();
  oldImageList.add(oldImage);
  NodeList oldModuleList=oldImage.getElementsByTagName(MODULE);
  Element dependentTag=newDoc.createElement(DEPENDENT);
  if (oldModuleList.getLength() > 0) {
    dependentTag.setAttribute(COUNT,""String_Node_Str"");
    for (int t=0; t < oldModuleList.getLength(); t++) {
      oldImageList.add((Element)oldModuleList.item(t));
    }
  }
  for (  Element oldImg : oldImageList) {
    Element newImg;
    if (oldImg.getTagName().equals(BINARY)) {
      newImg=newImage;
    }
 else {
      newImg=newDoc.createElement(IMAGE);
      String imgName=oldImg.getAttribute(NAME);
      newImg.setAttribute(NAME,imgName);
      Element modCountTag=(Element)oldImg.getElementsByTagName(COUNT).item(0);
      String imgCount=modCountTag.getTextContent().trim();
      newImg.setAttribute(COUNT,imgCount);
    }
    Element newSymbolsTag=newDoc.createElement(SYMBOLS);
    NodeList oldSymbolList=oldImg.getElementsByTagName(SYMBOL);
    for (int i=0; i < oldSymbolList.getLength(); i++) {
      Element oldSymbol=(Element)oldSymbolList.item(i);
      if (!oldSymbol.getParentNode().isSameNode(oldImg)) {
        continue;
      }
      Element newSymbol=newDoc.createElement(SYMBOL);
      String idref=oldSymbol.getAttribute(IDREF);
      String symbolCount=((Element)oldSymbol.getElementsByTagName(COUNT).item(0)).getTextContent().trim();
      newSymbol.setAttribute(COUNT,symbolCount);
      HashMap<String,String> symbolData=oldSymbolDataListMap.get(idref);
      newSymbol.setAttribute(NAME,symbolData.get(NAME));
      newSymbol.setAttribute(FILE,symbolData.get(FILE));
      newSymbol.setAttribute(LINE,symbolData.get(LINE));
      NodeList detailDataList=oldDetailTableListMap.get(idref);
      HashMap<String,Element> tmp=new HashMap<>();
      TreeSet<Element> sorted=new TreeSet<>(SAMPLE_COUNT_ORDER);
      for (int l=0; l < detailDataList.getLength(); l++) {
        Element detailData=(Element)detailDataList.item(l);
        String sampleFile=detailData.getAttribute(FILE);
        String sampleLine=detailData.getAttribute(LINE);
        if (sampleFile.equals(""String_Node_Str"") && !sampleLine.equals(""String_Node_Str"")) {
          sampleFile=symbolData.get(FILE);
        }
 else {
          if (sampleFile.equals(""String_Node_Str"")) {
            sampleFile=""String_Node_Str"";
          }
          if (sampleLine.equals(""String_Node_Str"")) {
            sampleLine=""String_Node_Str"";
          }
        }
        Element detailDataCount=(Element)detailData.getElementsByTagName(COUNT).item(0);
        String count=detailDataCount.getTextContent().trim();
        if (tmp.containsKey(sampleLine)) {
          Element elem=(Element)tmp.get(sampleLine).getElementsByTagName(COUNT).item(0);
          int val=Integer.parseInt(elem.getTextContent().trim()) + Integer.parseInt(count);
          elem.setTextContent(String.valueOf(val));
        }
 else {
          Element sampleTag=newDoc.createElement(SAMPLE);
          Element fileTag=newDoc.createElement(FILE);
          fileTag.setTextContent(sampleFile);
          Element lineTag=newDoc.createElement(LINE);
          lineTag.setTextContent(sampleLine);
          Element sampleCountTag=newDoc.createElement(COUNT);
          sampleCountTag.setTextContent(count);
          sampleTag.appendChild(fileTag);
          sampleTag.appendChild(lineTag);
          sampleTag.appendChild(sampleCountTag);
          tmp.put(sampleLine,sampleTag);
        }
      }
      for (      Element elem : tmp.values()) {
        sorted.add(elem);
      }
      for (      Element e : sorted) {
        newSymbol.appendChild(e);
      }
      newSymbolsTag.appendChild(newSymbol);
    }
    newImg.appendChild(newSymbolsTag);
    if (oldImg.getTagName().equals(MODULE)) {
      dependentTag.appendChild(newImg);
      int currVal=Integer.parseInt(dependentTag.getAttribute(COUNT));
      int val=Integer.parseInt(newImg.getAttribute(COUNT));
      dependentTag.setAttribute(COUNT,String.valueOf(currVal + val));
    }
 else {
      newRoot.appendChild(newImg);
    }
  }
  if (oldModuleList.getLength() > 0) {
    newImage.appendChild(dependentTag);
  }
}","private void createXML(){
  Element oldImage=(Element)oldRoot.getElementsByTagName(BINARY).item(0);
  Element newImage=newDoc.createElement(IMAGE);
  String binName=oldImage.getAttribute(NAME);
  newImage.setAttribute(NAME,binName);
  Element countTag=(Element)oldImage.getElementsByTagName(COUNT).item(0);
  String imageCount=countTag.getTextContent().trim();
  newImage.setAttribute(COUNT,imageCount);
  if (!InfoAdapter.hasTimerSupport()) {
    Element setupTag=(Element)oldRoot.getElementsByTagName(SETUP).item(0);
    Element eventSetupTag=(Element)setupTag.getElementsByTagName(EVENT_SETUP).item(0);
    String setupcount=eventSetupTag.getAttribute(SETUP_COUNT);
    newImage.setAttribute(SETUP_COUNT,setupcount);
  }
  Element oldSymbolTableTag=(Element)oldRoot.getElementsByTagName(SYMBOL_TABLE).item(0);
  NodeList oldSymbolDataList=oldSymbolTableTag.getElementsByTagName(SYMBOL_DATA);
  Element oldDetailTableTag=(Element)oldRoot.getElementsByTagName(DETAIL_TABLE).item(0);
  NodeList oldDetailTableList=oldDetailTableTag.getElementsByTagName(SYMBOL_DETAILS);
  HashMap<String,HashMap<String,String>> oldSymbolDataListMap=parseDataList(oldSymbolDataList);
  HashMap<String,NodeList> oldDetailTableListMap=parseDetailTable(oldDetailTableList);
  ArrayList<Element> oldImageList=new ArrayList<>();
  oldImageList.add(oldImage);
  NodeList oldModuleList=oldImage.getElementsByTagName(MODULE);
  Element dependentTag=newDoc.createElement(DEPENDENT);
  if (oldModuleList.getLength() > 0) {
    dependentTag.setAttribute(COUNT,""String_Node_Str"");
    for (int t=0; t < oldModuleList.getLength(); t++) {
      oldImageList.add((Element)oldModuleList.item(t));
    }
  }
  for (  Element oldImg : oldImageList) {
    Element newImg;
    if (oldImg.getTagName().equals(BINARY)) {
      newImg=newImage;
    }
 else {
      newImg=newDoc.createElement(IMAGE);
      String imgName=oldImg.getAttribute(NAME);
      newImg.setAttribute(NAME,imgName);
      Element modCountTag=(Element)oldImg.getElementsByTagName(COUNT).item(0);
      String imgCount=modCountTag.getTextContent().trim();
      newImg.setAttribute(COUNT,imgCount);
    }
    Element newSymbolsTag=newDoc.createElement(SYMBOLS);
    NodeList oldSymbolList=oldImg.getElementsByTagName(SYMBOL);
    for (int i=0; i < oldSymbolList.getLength(); i++) {
      Element oldSymbol=(Element)oldSymbolList.item(i);
      if (!oldSymbol.getParentNode().isSameNode(oldImg)) {
        continue;
      }
      Element newSymbol=newDoc.createElement(SYMBOL);
      String idref=oldSymbol.getAttribute(IDREF);
      String symbolCount=((Element)oldSymbol.getElementsByTagName(COUNT).item(0)).getTextContent().trim();
      newSymbol.setAttribute(COUNT,symbolCount);
      HashMap<String,String> symbolData=oldSymbolDataListMap.get(idref);
      newSymbol.setAttribute(NAME,symbolData.get(NAME));
      newSymbol.setAttribute(FILE,symbolData.get(FILE));
      newSymbol.setAttribute(LINE,symbolData.get(LINE));
      NodeList detailDataList=oldDetailTableListMap.get(idref);
      HashMap<String,Element> tmp=new HashMap<>();
      TreeSet<Element> sorted=new TreeSet<>(SAMPLE_COUNT_ORDER);
      for (int l=0; l < detailDataList.getLength(); l++) {
        Element detailData=(Element)detailDataList.item(l);
        String sampleFile=detailData.getAttribute(FILE);
        String sampleLine=detailData.getAttribute(LINE);
        if (sampleFile.equals(""String_Node_Str"") && !sampleLine.isEmpty()) {
          sampleFile=symbolData.get(FILE);
        }
 else {
          if (sampleFile.equals(""String_Node_Str"")) {
            sampleFile=""String_Node_Str"";
          }
          if (sampleLine.equals(""String_Node_Str"")) {
            sampleLine=""String_Node_Str"";
          }
        }
        Element detailDataCount=(Element)detailData.getElementsByTagName(COUNT).item(0);
        String count=detailDataCount.getTextContent().trim();
        if (tmp.containsKey(sampleLine)) {
          Element elem=(Element)tmp.get(sampleLine).getElementsByTagName(COUNT).item(0);
          int val=Integer.parseInt(elem.getTextContent().trim()) + Integer.parseInt(count);
          elem.setTextContent(String.valueOf(val));
        }
 else {
          Element sampleTag=newDoc.createElement(SAMPLE);
          Element fileTag=newDoc.createElement(FILE);
          fileTag.setTextContent(sampleFile);
          Element lineTag=newDoc.createElement(LINE);
          lineTag.setTextContent(sampleLine);
          Element sampleCountTag=newDoc.createElement(COUNT);
          sampleCountTag.setTextContent(count);
          sampleTag.appendChild(fileTag);
          sampleTag.appendChild(lineTag);
          sampleTag.appendChild(sampleCountTag);
          tmp.put(sampleLine,sampleTag);
        }
      }
      for (      Element elem : tmp.values()) {
        sorted.add(elem);
      }
      for (      Element e : sorted) {
        newSymbol.appendChild(e);
      }
      newSymbolsTag.appendChild(newSymbol);
    }
    newImg.appendChild(newSymbolsTag);
    if (oldImg.getTagName().equals(MODULE)) {
      dependentTag.appendChild(newImg);
      int currVal=Integer.parseInt(dependentTag.getAttribute(COUNT));
      int val=Integer.parseInt(newImg.getAttribute(COUNT));
      dependentTag.setAttribute(COUNT,String.valueOf(currVal + val));
    }
 else {
      newRoot.appendChild(newImg);
    }
  }
  if (oldModuleList.getLength() > 0) {
    newImage.appendChild(dependentTag);
  }
}",0.9970528642475596
91858,"@Override public void run(){
  AutotoolsConfigurationManager.getInstance().syncConfigurations(project);
  ICConfigurationDescription[] cfgds=CoreModel.getDefault().getProjectDescription(project).getConfigurations();
  if (cfgds != null && cfgds.length >= 1) {
    IAConfiguration iaConfig=AutotoolsConfigurationManager.getInstance().getConfiguration(project,cfgds[0].getId());
    iaConfig.setOption(optId,optVal);
    AutotoolsConfigurationManager.getInstance().saveConfigs(project);
  }
}","@Override public void run(){
  AutotoolsConfigurationManager.getInstance().syncConfigurations(project);
  ICConfigurationDescription cfgds=CoreModel.getDefault().getProjectDescription(project).getActiveConfiguration();
  if (cfgds != null) {
    IAConfiguration iaConfig=AutotoolsConfigurationManager.getInstance().getConfiguration(project,cfgds.getId());
    iaConfig.setOption(optId,optVal);
    AutotoolsConfigurationManager.getInstance().saveConfigs(project);
  }
}",0.9384775808133472
91859,"/** 
 * <h1>Option enabled check</h1> <p> Check to see if an option is enabled in the .autotools configuration.</p>
 * @param project  the IProject project which will be read to check if it is c or cpp.
 * @param optionId copy & paste directly from .autotools. pick the 'ID' field value.
 * @return true if it is
 */
public static boolean isOptionCheckedInAutotoolsPrefStore(final IProject project,final String optionId){
  final BooleanWithGetSet userChoiceBool=new BooleanWithGetSet(false);
  Display.getDefault().syncExec(new Runnable(){
    @Override public void run(){
      AutotoolsConfigurationManager.getInstance().syncConfigurations(project);
      ICConfigurationDescription[] cfgds=CoreModel.getDefault().getProjectDescription(project).getConfigurations();
      if (cfgds != null && cfgds.length >= 1) {
        IAConfiguration iaConfig=AutotoolsConfigurationManager.getInstance().getConfiguration(project,cfgds[0].getId());
        IConfigureOption option=iaConfig.getOption(optionId);
        String optValString=option.getValue();
        boolean optVal=Boolean.parseBoolean(optValString);
        userChoiceBool.setVal(optVal);
      }
    }
  }
);
  return userChoiceBool.getVal();
}","/** 
 * <h1>Option enabled check</h1> <p> Check to see if an option is enabled in the .autotools configuration.</p>
 * @param project  the IProject project which will be read to check if it is c or cpp.
 * @param optionId copy & paste directly from .autotools. pick the 'ID' field value.
 * @return true if it is
 */
public static boolean isOptionCheckedInAutotoolsPrefStore(final IProject project,final String optionId){
  final BooleanWithGetSet userChoiceBool=new BooleanWithGetSet(false);
  Display.getDefault().syncExec(new Runnable(){
    @Override public void run(){
      AutotoolsConfigurationManager.getInstance().syncConfigurations(project);
      ICConfigurationDescription cfgds=CoreModel.getDefault().getProjectDescription(project).getActiveConfiguration();
      if (cfgds != null) {
        IAConfiguration iaConfig=AutotoolsConfigurationManager.getInstance().getConfiguration(project,cfgds.getId());
        IConfigureOption option=iaConfig.getOption(optionId);
        String optValString=option.getValue();
        boolean optVal=Boolean.parseBoolean(optValString);
        userChoiceBool.setVal(optVal);
      }
    }
  }
);
  return userChoiceBool.getVal();
}",0.9752204955900882
91860,"/** 
 * <h1>Set Autotools option & write to disk.</h1> <p> Set an option (as well as flags) in the .autotools configuration & update gui. <br> It is oblivious as to whether the option ID is an option or a flag, it just looks at the ID in the xml. </p> <p> It is designed so that it can be ran from a background thread. It syncs with the GUI thread to avoid concurrency exceptions. </p> <p> *this modifies gui checkbox options* <b>as well as</b> *saving the option to disk*. </p>
 * @param project    the IProject project which will be read to check if it is c or cpp.
 * @param optId      Id of option to set. Take directly out of .autotools. a 'flag' is also an option.
 * @param optVal     string value of the option. e.g ""true""  ""1234"";
 */
public static void setOptionInAutotools(final IProject project,final String optId,final String optVal){
  Display.getDefault().syncExec(new Runnable(){
    @Override public void run(){
      AutotoolsConfigurationManager.getInstance().syncConfigurations(project);
      ICConfigurationDescription[] cfgds=CoreModel.getDefault().getProjectDescription(project).getConfigurations();
      if (cfgds != null && cfgds.length >= 1) {
        IAConfiguration iaConfig=AutotoolsConfigurationManager.getInstance().getConfiguration(project,cfgds[0].getId());
        iaConfig.setOption(optId,optVal);
        AutotoolsConfigurationManager.getInstance().saveConfigs(project);
      }
    }
  }
);
}","/** 
 * <h1>Set Autotools option & write to disk.</h1> <p> Set an option (as well as flags) in the .autotools configuration & update gui. <br> It is oblivious as to whether the option ID is an option or a flag, it just looks at the ID in the xml. </p> <p> It is designed so that it can be ran from a background thread. It syncs with the GUI thread to avoid concurrency exceptions. </p> <p> *this modifies gui checkbox options* <b>as well as</b> *saving the option to disk*. </p>
 * @param project    the IProject project which will be read to check if it is c or cpp.
 * @param optId      Id of option to set. Take directly out of .autotools. a 'flag' is also an option.
 * @param optVal     string value of the option. e.g ""true""  ""1234"";
 */
public static void setOptionInAutotools(final IProject project,final String optId,final String optVal){
  Display.getDefault().syncExec(new Runnable(){
    @Override public void run(){
      AutotoolsConfigurationManager.getInstance().syncConfigurations(project);
      ICConfigurationDescription cfgds=CoreModel.getDefault().getProjectDescription(project).getActiveConfiguration();
      if (cfgds != null) {
        IAConfiguration iaConfig=AutotoolsConfigurationManager.getInstance().getConfiguration(project,cfgds.getId());
        iaConfig.setOption(optId,optVal);
        AutotoolsConfigurationManager.getInstance().saveConfigs(project);
      }
    }
  }
);
}",0.9883843717001056
91861,"/** 
 * Downloads a trace from the remote host to the given project.
 * @param trace - trace information of trace to import
 * @param project - project to import to
 * @param monitor - a progress monitor
 * @throws ExecutionException
 */
private static void downloadTrace(ImportFileInfo trace,IProject project,IProgressMonitor monitor) throws ExecutionException {
  try {
    IRemoteFileSubSystem fsss=trace.getImportFile().getParentRemoteFileSubSystem();
    IFolder traceFolder=project.getFolder(TmfTracesFolder.TRACES_FOLDER_NAME);
    if (!traceFolder.exists()) {
      throw new ExecutionException(Messages.TraceControl_ImportDialogInvalidTracingProject + ""String_Node_Str"" + TmfTracesFolder.TRACES_FOLDER_NAME+ ""String_Node_Str"");
    }
    IFolder destinationFolder=trace.getDestinationFolder();
    TraceUtils.createFolder(destinationFolder,monitor);
    String traceName=trace.getLocalTraceName();
    IFolder folder=destinationFolder.getFolder(traceName);
    if (folder.exists()) {
      if (!trace.isOverwrite()) {
        throw new ExecutionException(Messages.TraceControl_ImportDialogTraceAlreadyExistError + ""String_Node_Str"" + traceName);
      }
    }
 else {
      folder.create(true,true,null);
    }
    IRemoteFile[] sources=fsss.list(trace.getImportFile(),IFileService.FILE_TYPE_FILES,new NullProgressMonitor());
    SubMonitor subMonitor=SubMonitor.convert(monitor,sources.length);
    subMonitor.beginTask(Messages.TraceControl_DownloadTask,sources.length);
    for (int i=0; i < sources.length; i++) {
      if (subMonitor.isCanceled()) {
        monitor.setCanceled(true);
        return;
      }
      String destination=folder.getLocation().addTrailingSeparator().append(sources[i].getName()).toString();
      subMonitor.setTaskName(Messages.TraceControl_DownloadTask + ' ' + traceName+ '/'+ sources[i].getName());
      fsss.download(sources[i],destination,null,subMonitor.newChild(1));
    }
  }
 catch (  SystemMessageException e) {
    throw new ExecutionException(e.toString(),e);
  }
catch (  CoreException e) {
    throw new ExecutionException(e.toString(),e);
  }
}","/** 
 * Downloads a trace from the remote host to the given project.
 * @param trace - trace information of trace to import
 * @param project - project to import to
 * @param monitor - a progress monitor
 * @throws ExecutionException
 */
private static void downloadTrace(ImportFileInfo trace,IProject project,IProgressMonitor monitor) throws ExecutionException {
  try {
    IRemoteFileSubSystem fsss=trace.getImportFile().getParentRemoteFileSubSystem();
    IFolder traceFolder=project.getFolder(TmfTracesFolder.TRACES_FOLDER_NAME);
    if (!traceFolder.exists()) {
      throw new ExecutionException(Messages.TraceControl_ImportDialogInvalidTracingProject + ""String_Node_Str"" + TmfTracesFolder.TRACES_FOLDER_NAME+ ""String_Node_Str"");
    }
    IFolder destinationFolder=trace.getDestinationFolder();
    TraceUtils.createFolder(destinationFolder,monitor);
    String traceName=trace.getLocalTraceName();
    IFolder folder=destinationFolder.getFolder(traceName);
    if (folder.exists()) {
      if (!trace.isOverwrite()) {
        throw new ExecutionException(Messages.TraceControl_ImportDialogTraceAlreadyExistError + ""String_Node_Str"" + traceName);
      }
    }
 else {
      folder.create(true,true,null);
    }
    IRemoteFile[] sources=fsss.list(trace.getImportFile(),IFileService.FILE_TYPE_FILES,new NullProgressMonitor());
    SubMonitor subMonitor=SubMonitor.convert(monitor,sources.length);
    subMonitor.beginTask(Messages.TraceControl_DownloadTask,sources.length);
    for (int i=0; i < sources.length; i++) {
      if (subMonitor.isCanceled()) {
        monitor.setCanceled(true);
        return;
      }
      String destination=folder.getLocation().addTrailingSeparator().append(sources[i].getName()).toOSString();
      subMonitor.setTaskName(Messages.TraceControl_DownloadTask + ' ' + traceName+ '/'+ sources[i].getName());
      fsss.download(sources[i],destination,null,subMonitor.newChild(1));
    }
  }
 catch (  SystemMessageException e) {
    throw new ExecutionException(e.toString(),e);
  }
catch (  CoreException e) {
    throw new ExecutionException(e.toString(),e);
  }
}",0.9995244888254874
91862,"@Override public Object execute(ExecutionEvent event) throws ExecutionException {
  IWorkbenchWindow window=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
  if (window == null) {
    return false;
  }
  fLock.lock();
  try {
    final CommandParameter param=fParam.clone();
    IProject project=TmfProjectRegistry.createProject(DEFAULT_REMOTE_PROJECT_NAME,null,null);
    if (param.getSession().isLiveTrace()) {
      importLiveTrace(new LttngRelaydConnectionInfo(param.getSession().getLiveUrl(),param.getSession().getLivePort(),param.getSession().getName()),project);
      return null;
    }
 else     if (param.getSession().isStreamedTrace()) {
      IPreferenceStore store=Activator.getDefault().getPreferenceStore();
      String notify=store.getString(NOTIFY_IMPORT_STREAMED_PREF_KEY);
      if (!MessageDialogWithToggle.ALWAYS.equals(notify)) {
        MessageDialogWithToggle.openInformation(window.getShell(),null,Messages.TraceControl_ImportDialogStreamedTraceNotification,Messages.TraceControl_ImportDialogStreamedTraceNotificationToggle,false,store,NOTIFY_IMPORT_STREAMED_PREF_KEY);
      }
      TmfProjectElement projectElement=TmfProjectRegistry.getProject(project,true);
      TmfTraceFolder traceFolder=projectElement.getTracesFolder();
      ImportTraceWizard wizard=new ImportTraceWizard();
      wizard.init(PlatformUI.getWorkbench(),new StructuredSelection(traceFolder));
      WizardDialog dialog=new WizardDialog(window.getShell(),wizard);
      dialog.open();
      return null;
    }
    final IImportDialog dialog=TraceControlDialogFactory.getInstance().getImportDialog();
    dialog.setSession(param.getSession());
    dialog.setDefaultProject(DEFAULT_REMOTE_PROJECT_NAME);
    if (dialog.open() != Window.OK) {
      return null;
    }
    Job job=new Job(Messages.TraceControl_ImportJob){
      @Override protected IStatus run(      IProgressMonitor monitor){
        MultiStatus status=new MultiStatus(Activator.PLUGIN_ID,IStatus.OK,Messages.TraceControl_ImportFailure,null);
        List<ImportFileInfo> traces=dialog.getTracePathes();
        IProject selectedProject=dialog.getProject();
        for (Iterator<ImportFileInfo> iterator=traces.iterator(); iterator.hasNext(); ) {
          try {
            if (monitor.isCanceled()) {
              status.add(Status.CANCEL_STATUS);
              break;
            }
            ImportFileInfo remoteFile=iterator.next();
            downloadTrace(remoteFile,selectedProject,monitor);
            IFolder traceFolder=remoteFile.getDestinationFolder();
            IResource file=traceFolder.findMember(remoteFile.getLocalTraceName());
            if (file != null) {
              TraceTypeHelper helper=null;
              try {
                helper=TmfTraceTypeUIUtils.selectTraceType(file.getLocationURI().getPath(),null,null);
              }
 catch (              TmfTraceImportException e) {
              }
              if (helper != null) {
                status.add(TmfTraceTypeUIUtils.setTraceType(file,helper));
              }
              try {
                final String scheme=""String_Node_Str"";
                String host=remoteFile.getImportFile().getHost().getName();
                int port=remoteFile.getImportFile().getParentRemoteFileSubSystem().getConnectorService().getPort();
                String path=remoteFile.getImportFile().getAbsolutePath();
                if (file instanceof IFolder) {
                  path+=IPath.SEPARATOR;
                }
                URI uri=new URI(scheme,null,host,port,path,null,null);
                String sourceLocation=URIUtil.toUnencodedString(uri);
                file.setPersistentProperty(TmfCommonConstants.SOURCE_LOCATION,sourceLocation);
              }
 catch (              URISyntaxException e) {
              }
            }
          }
 catch (          ExecutionException e) {
            status.add(new Status(IStatus.ERROR,Activator.PLUGIN_ID,Messages.TraceControl_ImportFailure,e));
          }
catch (          CoreException e) {
            status.add(new Status(IStatus.ERROR,Activator.PLUGIN_ID,Messages.TraceControl_ImportFailure,e));
          }
        }
        return status;
      }
    }
;
    job.setUser(true);
    job.schedule();
  }
  finally {
    fLock.unlock();
  }
  return null;
}","@Override public Object execute(ExecutionEvent event) throws ExecutionException {
  IWorkbenchWindow window=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
  if (window == null) {
    return false;
  }
  fLock.lock();
  try {
    final CommandParameter param=fParam.clone();
    IProject project=TmfProjectRegistry.createProject(DEFAULT_REMOTE_PROJECT_NAME,null,null);
    if (param.getSession().isLiveTrace()) {
      importLiveTrace(new LttngRelaydConnectionInfo(param.getSession().getLiveUrl(),param.getSession().getLivePort(),param.getSession().getName()),project);
      return null;
    }
 else     if (param.getSession().isStreamedTrace()) {
      IPreferenceStore store=Activator.getDefault().getPreferenceStore();
      String notify=store.getString(NOTIFY_IMPORT_STREAMED_PREF_KEY);
      if (!MessageDialogWithToggle.ALWAYS.equals(notify)) {
        MessageDialogWithToggle.openInformation(window.getShell(),null,Messages.TraceControl_ImportDialogStreamedTraceNotification,Messages.TraceControl_ImportDialogStreamedTraceNotificationToggle,false,store,NOTIFY_IMPORT_STREAMED_PREF_KEY);
      }
      TmfProjectElement projectElement=TmfProjectRegistry.getProject(project,true);
      TmfTraceFolder traceFolder=projectElement.getTracesFolder();
      ImportTraceWizard wizard=new ImportTraceWizard();
      wizard.init(PlatformUI.getWorkbench(),new StructuredSelection(traceFolder));
      WizardDialog dialog=new WizardDialog(window.getShell(),wizard);
      dialog.open();
      return null;
    }
    final IImportDialog dialog=TraceControlDialogFactory.getInstance().getImportDialog();
    dialog.setSession(param.getSession());
    dialog.setDefaultProject(DEFAULT_REMOTE_PROJECT_NAME);
    if (dialog.open() != Window.OK) {
      return null;
    }
    Job job=new Job(Messages.TraceControl_ImportJob){
      @Override protected IStatus run(      IProgressMonitor monitor){
        MultiStatus status=new MultiStatus(Activator.PLUGIN_ID,IStatus.OK,Messages.TraceControl_ImportFailure,null);
        List<ImportFileInfo> traces=dialog.getTracePathes();
        IProject selectedProject=dialog.getProject();
        for (Iterator<ImportFileInfo> iterator=traces.iterator(); iterator.hasNext(); ) {
          try {
            if (monitor.isCanceled()) {
              status.add(Status.CANCEL_STATUS);
              break;
            }
            ImportFileInfo remoteFile=iterator.next();
            downloadTrace(remoteFile,selectedProject,monitor);
            IFolder traceFolder=remoteFile.getDestinationFolder();
            IResource file=traceFolder.findMember(remoteFile.getLocalTraceName());
            if (file != null) {
              TraceTypeHelper helper=null;
              try {
                helper=TmfTraceTypeUIUtils.selectTraceType(file.getLocation().toOSString(),null,null);
              }
 catch (              TmfTraceImportException e) {
              }
              if (helper != null) {
                status.add(TmfTraceTypeUIUtils.setTraceType(file,helper));
              }
              try {
                final String scheme=""String_Node_Str"";
                String host=remoteFile.getImportFile().getHost().getName();
                int port=remoteFile.getImportFile().getParentRemoteFileSubSystem().getConnectorService().getPort();
                String path=remoteFile.getImportFile().getAbsolutePath();
                if (file instanceof IFolder) {
                  path+=IPath.SEPARATOR;
                }
                URI uri=new URI(scheme,null,host,port,path,null,null);
                String sourceLocation=URIUtil.toUnencodedString(uri);
                file.setPersistentProperty(TmfCommonConstants.SOURCE_LOCATION,sourceLocation);
              }
 catch (              URISyntaxException e) {
              }
            }
          }
 catch (          ExecutionException e) {
            status.add(new Status(IStatus.ERROR,Activator.PLUGIN_ID,Messages.TraceControl_ImportFailure,e));
          }
catch (          CoreException e) {
            status.add(new Status(IStatus.ERROR,Activator.PLUGIN_ID,Messages.TraceControl_ImportFailure,e));
          }
        }
        return status;
      }
    }
;
    job.setUser(true);
    job.schedule();
  }
  finally {
    fLock.unlock();
  }
  return null;
}",0.9969682835820896
91863,"/** 
 * Run opreport with specified arguments <code>args</code> and return InputStream to output of report for parsing.
 * @param args arguments to run with opreport
 * @return InputStream to output of report
 */
private InputStream runOpReport(String[] args){
  ArrayList<String> cmd=new ArrayList<>();
  cmd.add(""String_Node_Str"");
  if (OprofileProject.getProfilingBinary().equals(OprofileProject.OPERF_BINARY))   cmd.add(1,""String_Node_Str"" + Oprofile.OprofileProject.getProject().getLocationURI().getPath() + IPath.SEPARATOR+ ""String_Node_Str"");
  Collections.addAll(cmd,args);
  Process p=null;
  try {
    p=RuntimeProcessFactory.getFactory().exec(cmd.toArray(new String[0]),Oprofile.OprofileProject.getProject());
    StringBuilder output=new StringBuilder();
    StringBuilder errorOutput=new StringBuilder();
    String s=null;
    try (BufferedReader stdInput=new BufferedReader(new InputStreamReader(p.getInputStream()));BufferedReader stdError=new BufferedReader(new InputStreamReader(p.getErrorStream()))){
      while ((s=stdInput.readLine()) != null) {
        output.append(s + System.getProperty(""String_Node_Str""));
      }
      while ((s=stdError.readLine()) != null) {
        errorOutput.append(s + System.getProperty(""String_Node_Str""));
      }
      if (!errorOutput.toString().trim().equals(""String_Node_Str"")) {
        OprofileCorePlugin.log(IStatus.ERROR,NLS.bind(OprofileProperties.getString(""String_Node_Str""),""String_Node_Str"",errorOutput.toString().trim()));
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    if (p.waitFor() == 0) {
      try {
        return new ByteArrayInputStream(output.toString().getBytes(""String_Node_Str""));
      }
 catch (      UnsupportedEncodingException e) {
        e.printStackTrace();
      }
    }
  }
 catch (  IOException e1) {
    e1.printStackTrace();
    OprofileCorePlugin.showErrorDialog(""String_Node_Str"",null);
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
  return null;
}","/** 
 * Run opreport with specified arguments <code>args</code> and return InputStream to output of report for parsing.
 * @param args arguments to run with opreport
 * @return InputStream to output of report
 */
private InputStream runOpReport(String[] args){
  ArrayList<String> cmd=new ArrayList<>();
  cmd.add(""String_Node_Str"");
  if (OprofileProject.getProfilingBinary().equals(OprofileProject.OPERF_BINARY)) {
    String workingDir=""String_Node_Str"";
    RemoteProxyManager proxy=RemoteProxyManager.getInstance();
    try {
      IRemoteFileProxy rfile=proxy.getFileProxy(Oprofile.OprofileProject.getProject());
      workingDir=rfile.getWorkingDir().getPath();
    }
 catch (    CoreException e) {
      e.printStackTrace();
      return null;
    }
    cmd.add(1,""String_Node_Str"" + workingDir + IPath.SEPARATOR+ ""String_Node_Str"");
  }
  Collections.addAll(cmd,args);
  Process p=null;
  try {
    p=RuntimeProcessFactory.getFactory().exec(cmd.toArray(new String[0]),Oprofile.OprofileProject.getProject());
    StringBuilder output=new StringBuilder();
    StringBuilder errorOutput=new StringBuilder();
    String s=null;
    try (BufferedReader stdInput=new BufferedReader(new InputStreamReader(p.getInputStream()));BufferedReader stdError=new BufferedReader(new InputStreamReader(p.getErrorStream()))){
      while ((s=stdInput.readLine()) != null) {
        output.append(s + System.getProperty(""String_Node_Str""));
      }
      while ((s=stdError.readLine()) != null) {
        errorOutput.append(s + System.getProperty(""String_Node_Str""));
      }
      if (!errorOutput.toString().trim().equals(""String_Node_Str"")) {
        OprofileCorePlugin.log(IStatus.ERROR,NLS.bind(OprofileProperties.getString(""String_Node_Str""),""String_Node_Str"",errorOutput.toString().trim()));
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    if (p.waitFor() == 0) {
      try {
        return new ByteArrayInputStream(output.toString().getBytes(""String_Node_Str""));
      }
 catch (      UnsupportedEncodingException e) {
        e.printStackTrace();
      }
    }
  }
 catch (  IOException e1) {
    e1.printStackTrace();
    OprofileCorePlugin.showErrorDialog(""String_Node_Str"",null);
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
  return null;
}",0.9016050244242848
91864,"@Override public void launch(ILaunchConfiguration config,String mode,ILaunch launch,IProgressMonitor monitor) throws CoreException {
  this.config=config;
  Oprofile.OprofileProject.setProject(getProject());
  LaunchOptions options=new LaunchOptions();
  options.loadConfiguration(config);
  IPath exePath=getExePath(config);
  options.setBinaryImage(exePath.toOSString());
  Oprofile.OprofileProject.setProfilingBinary(options.getOprofileComboText());
  OprofileDaemonEvent[] daemonEvents=null;
  ArrayList<OprofileDaemonEvent> events=new ArrayList<>();
  if (!config.getAttribute(OprofileLaunchPlugin.ATTR_USE_DEFAULT_EVENT,false)) {
    OprofileCounter[] counters=oprofileCounters(config);
    for (int i=0; i < counters.length; ++i) {
      if (counters[i].getEnabled()) {
        OprofileDaemonEvent[] counterEvents=counters[i].getDaemonEvents();
        events.addAll(Arrays.asList(counterEvents));
      }
    }
    daemonEvents=new OprofileDaemonEvent[events.size()];
    events.toArray(daemonEvents);
  }
  if (!preExec(options,daemonEvents,launch)) {
    return;
  }
  Process process=null;
  if (OprofileProject.getProfilingBinary().equals(OprofileProject.OPCONTROL_BINARY)) {
    String arguments[]=getProgramArgumentsArray(config);
    IRemoteCommandLauncher launcher=RemoteProxyManager.getInstance().getLauncher(oprofileProject());
    IPath workingDirPath=new Path(oprofileWorkingDirURI(config).getPath());
    for (int i=0; i < options.getExecutionsNumber(); i++) {
      process=launcher.execute(exePath,arguments,getEnvironment(config),workingDirPath,monitor);
      DebugPlugin.newProcess(launch,process,renderProcessLabel(exePath.toOSString()));
      try {
        process.waitFor();
      }
 catch (      InterruptedException e) {
        process.destroy();
        Status status=new Status(IStatus.ERROR,OprofileLaunchPlugin.PLUGIN_ID,OprofileLaunchMessages.getString(""String_Node_Str""));
        throw new CoreException(status);
      }
    }
  }
  if (OprofileProject.getProfilingBinary().equals(OprofileProject.OPERF_BINARY)) {
    String eventsString=null;
    StringBuilder spec=new StringBuilder();
    spec.append(EVENTS);
    boolean isCommaAllowed=false;
    for (int i=0; i < events.size(); i++) {
      OprofileDaemonEvent event=events.get(i);
      if (isCommaAllowed) {
        spec.append(',');
      }
      spec.append(event.getEvent().getText());
      spec.append(OPD_SETUP_EVENT_SEPARATOR);
      spec.append(event.getResetCount());
      spec.append(OPD_SETUP_EVENT_SEPARATOR);
      spec.append(event.getEvent().getUnitMask().getMaskValue());
      spec.append(OPD_SETUP_EVENT_SEPARATOR);
      spec.append((event.getProfileKernel() ? OPD_SETUP_EVENT_TRUE : OPD_SETUP_EVENT_FALSE));
      spec.append(OPD_SETUP_EVENT_SEPARATOR);
      spec.append((event.getProfileUser() ? OPD_SETUP_EVENT_TRUE : OPD_SETUP_EVENT_FALSE));
      isCommaAllowed=true;
    }
    eventsString=spec.toString();
    ArrayList<String> argArray=new ArrayList<>(Arrays.asList(getProgramArgumentsArray(config)));
    IFolder dataFolder=Oprofile.OprofileProject.getProject().getFolder(OPROFILE_DATA);
    if (!dataFolder.exists()) {
      dataFolder.create(false,true,null);
    }
    argArray.add(0,exePath.toOSString());
    if (events.size() > 0) {
      argArray.add(0,eventsString);
    }
    argArray.add(0,SESSION_DIR + oprofileWorkingDirURI(config).getPath() + IPath.SEPARATOR+ OPROFILE_DATA);
    argArray.add(0,OprofileProject.OPERF_BINARY);
    for (int i=0; i < options.getExecutionsNumber(); i++) {
      if (i != 0) {
        argArray.add(APPEND);
      }
      String[] arguments=new String[argArray.size()];
      arguments=argArray.toArray(arguments);
      try {
        process=RuntimeProcessFactory.getFactory().exec(arguments,OprofileProject.getProject());
      }
 catch (      IOException e1) {
        process.destroy();
        Status status=new Status(IStatus.ERROR,OprofileLaunchPlugin.PLUGIN_ID,OprofileLaunchMessages.getString(""String_Node_Str""));
        throw new CoreException(status);
      }
      DebugPlugin.newProcess(launch,process,renderProcessLabel(exePath.toOSString()));
      try {
        process.waitFor();
      }
 catch (      InterruptedException e) {
        process.destroy();
        Status status=new Status(IStatus.ERROR,OprofileLaunchPlugin.PLUGIN_ID,OprofileLaunchMessages.getString(""String_Node_Str""));
        throw new CoreException(status);
      }
    }
  }
  postExec(options,daemonEvents,process);
}","@Override public void launch(ILaunchConfiguration config,String mode,ILaunch launch,IProgressMonitor monitor) throws CoreException {
  this.config=config;
  Oprofile.OprofileProject.setProject(getProject());
  LaunchOptions options=new LaunchOptions();
  options.loadConfiguration(config);
  IPath exePath=getExePath(config);
  options.setBinaryImage(exePath.toOSString());
  Oprofile.OprofileProject.setProfilingBinary(options.getOprofileComboText());
  OprofileDaemonEvent[] daemonEvents=null;
  ArrayList<OprofileDaemonEvent> events=new ArrayList<>();
  if (!config.getAttribute(OprofileLaunchPlugin.ATTR_USE_DEFAULT_EVENT,false)) {
    OprofileCounter[] counters=oprofileCounters(config);
    for (int i=0; i < counters.length; ++i) {
      if (counters[i].getEnabled()) {
        OprofileDaemonEvent[] counterEvents=counters[i].getDaemonEvents();
        events.addAll(Arrays.asList(counterEvents));
      }
    }
    daemonEvents=new OprofileDaemonEvent[events.size()];
    events.toArray(daemonEvents);
  }
  if (!preExec(options,daemonEvents,launch)) {
    return;
  }
  Process process=null;
  if (OprofileProject.getProfilingBinary().equals(OprofileProject.OPCONTROL_BINARY)) {
    String arguments[]=getProgramArgumentsArray(config);
    IRemoteCommandLauncher launcher=RemoteProxyManager.getInstance().getLauncher(oprofileProject());
    IPath workingDirPath=new Path(oprofileWorkingDirURI(config).getPath());
    for (int i=0; i < options.getExecutionsNumber(); i++) {
      process=launcher.execute(exePath,arguments,getEnvironment(config),workingDirPath,monitor);
      DebugPlugin.newProcess(launch,process,renderProcessLabel(exePath.toOSString()));
      try {
        process.waitFor();
      }
 catch (      InterruptedException e) {
        process.destroy();
        Status status=new Status(IStatus.ERROR,OprofileLaunchPlugin.PLUGIN_ID,OprofileLaunchMessages.getString(""String_Node_Str""));
        throw new CoreException(status);
      }
    }
  }
  if (OprofileProject.getProfilingBinary().equals(OprofileProject.OPERF_BINARY)) {
    String eventsString=null;
    StringBuilder spec=new StringBuilder();
    spec.append(EVENTS);
    boolean isCommaAllowed=false;
    for (int i=0; i < events.size(); i++) {
      OprofileDaemonEvent event=events.get(i);
      if (isCommaAllowed) {
        spec.append(',');
      }
      spec.append(event.getEvent().getText());
      spec.append(OPD_SETUP_EVENT_SEPARATOR);
      spec.append(event.getResetCount());
      spec.append(OPD_SETUP_EVENT_SEPARATOR);
      spec.append(event.getEvent().getUnitMask().getMaskValue());
      spec.append(OPD_SETUP_EVENT_SEPARATOR);
      spec.append((event.getProfileKernel() ? OPD_SETUP_EVENT_TRUE : OPD_SETUP_EVENT_FALSE));
      spec.append(OPD_SETUP_EVENT_SEPARATOR);
      spec.append((event.getProfileUser() ? OPD_SETUP_EVENT_TRUE : OPD_SETUP_EVENT_FALSE));
      isCommaAllowed=true;
    }
    eventsString=spec.toString();
    ArrayList<String> argArray=new ArrayList<>(Arrays.asList(getProgramArgumentsArray(config)));
    IRemoteFileProxy proxy=RemoteProxyManager.getInstance().getFileProxy(OprofileProject.getProject());
    IFileStore dataFolder=proxy.getResource(oprofileWorkingDirURI(config).getPath() + IPath.SEPARATOR + OPROFILE_DATA);
    if (!dataFolder.fetchInfo().exists()) {
      dataFolder.mkdir(EFS.SHALLOW,null);
    }
    argArray.add(0,exePath.toOSString());
    if (events.size() > 0) {
      argArray.add(0,eventsString);
    }
    argArray.add(0,SESSION_DIR + oprofileWorkingDirURI(config).getPath() + IPath.SEPARATOR+ OPROFILE_DATA);
    argArray.add(0,OprofileProject.OPERF_BINARY);
    for (int i=0; i < options.getExecutionsNumber(); i++) {
      if (i != 0) {
        argArray.add(APPEND);
      }
      String[] arguments=new String[argArray.size()];
      arguments=argArray.toArray(arguments);
      try {
        process=RuntimeProcessFactory.getFactory().exec(arguments,OprofileProject.getProject());
      }
 catch (      IOException e1) {
        process.destroy();
        Status status=new Status(IStatus.ERROR,OprofileLaunchPlugin.PLUGIN_ID,OprofileLaunchMessages.getString(""String_Node_Str""));
        throw new CoreException(status);
      }
      DebugPlugin.newProcess(launch,process,renderProcessLabel(exePath.toOSString()));
      try {
        process.waitFor();
      }
 catch (      InterruptedException e) {
        process.destroy();
        Status status=new Status(IStatus.ERROR,OprofileLaunchPlugin.PLUGIN_ID,OprofileLaunchMessages.getString(""String_Node_Str""));
        throw new CoreException(status);
      }
    }
  }
  postExec(options,daemonEvents,process);
}",0.9671464674211624
91865,"@Override public void initializeFrom(ILaunchConfiguration config){
  IProject previousProject=getOprofileProject();
  IProject project=getProject(config);
  setOprofileProject(project);
  updateOprofileInfo();
  String previousHost=null;
  if (previousProject != null) {
    if (previousProject.getLocationURI() != null) {
      previousHost=previousProject.getLocationURI().getHost();
    }
  }
  String host;
  if (project != null) {
    host=project.getLocationURI().getHost();
  }
 else {
    host=null;
  }
  if (previousProject == null || previousHost != host || host == null || counters == null) {
    Control[] children=top.getChildren();
    for (    Control control : children) {
      control.dispose();
    }
    if (getOprofileTimerMode()) {
      Label timerModeLabel=new Label(top,SWT.LEFT);
      timerModeLabel.setText(OprofileLaunchMessages.getString(""String_Node_Str""));
    }
 else {
      createVerticalSpacer(top,1);
      defaultEventCheck=new Button(top,SWT.CHECK);
      defaultEventCheck.setText(OprofileLaunchMessages.getString(""String_Node_Str""));
      defaultEventCheck.setLayoutData(new GridData());
      defaultEventCheck.addSelectionListener(new SelectionAdapter(){
        @Override public void widgetSelected(        SelectionEvent se){
          handleEnabledToggle();
        }
      }
);
      createVerticalSpacer(top,1);
      createCounterTabs(top);
    }
  }
  if (!getOprofileTimerMode()) {
    for (int i=0; i < counters.length; i++) {
      counters[i].loadConfiguration(config);
    }
    for (    CounterSubTab tab : counterSubTabs) {
      tab.initializeTab(config);
      tab.createEventsFilter();
    }
    try {
      boolean enabledState=config.getAttribute(OprofileLaunchPlugin.ATTR_USE_DEFAULT_EVENT,true);
      defaultEventCheck.setSelection(enabledState);
      setEnabledState(!enabledState);
    }
 catch (    CoreException e) {
      e.printStackTrace();
    }
  }
}","@Override public void initializeFrom(ILaunchConfiguration config){
  IProject previousProject=getOprofileProject();
  IProject project=getProject(config);
  setOprofileProject(project);
  updateOprofileInfo();
  String previousHost=null;
  if (previousProject != null) {
    if (previousProject.getLocationURI() != null) {
      previousHost=previousProject.getLocationURI().getHost();
    }
  }
  String host;
  if (project != null) {
    host=project.getLocationURI().getHost();
  }
 else {
    host=null;
  }
  if (previousProject == null || previousHost != host || host == null || counters == null) {
    Control[] children=top.getChildren();
    for (    Control control : children) {
      control.dispose();
    }
    OprofileCounter[] ctrs=getOprofileCounters(null);
    if (getOprofileTimerMode() || (ctrs.length > 0 && ctrs[0].getValidEvents() == null)) {
      Label timerModeLabel=new Label(top,SWT.LEFT);
      timerModeLabel.setText(OprofileLaunchMessages.getString(""String_Node_Str""));
    }
 else {
      createVerticalSpacer(top,1);
      defaultEventCheck=new Button(top,SWT.CHECK);
      defaultEventCheck.setText(OprofileLaunchMessages.getString(""String_Node_Str""));
      defaultEventCheck.setLayoutData(new GridData());
      defaultEventCheck.addSelectionListener(new SelectionAdapter(){
        @Override public void widgetSelected(        SelectionEvent se){
          handleEnabledToggle();
        }
      }
);
      createVerticalSpacer(top,1);
      createCounterTabs(top);
    }
  }
  if (!getOprofileTimerMode()) {
    for (int i=0; i < counters.length; i++) {
      counters[i].loadConfiguration(config);
    }
    for (    CounterSubTab tab : counterSubTabs) {
      tab.initializeTab(config);
      tab.createEventsFilter();
    }
    try {
      boolean enabledState=config.getAttribute(OprofileLaunchPlugin.ATTR_USE_DEFAULT_EVENT,true);
      defaultEventCheck.setSelection(enabledState);
      setEnabledState(!enabledState);
    }
 catch (    CoreException e) {
      e.printStackTrace();
    }
  }
}",0.9684741488020177
91866,"@Override public boolean isValid(ILaunchConfiguration config){
  IProject project=getProject(config);
  setOprofileProject(project);
  if (getOprofileTimerMode() || counterSubTabs == null) {
    return true;
  }
 else {
    return validateEvents(config);
  }
}","@Override public boolean isValid(ILaunchConfiguration config){
  IProject project=getProject(config);
  setOprofileProject(project);
  OprofileCounter[] ctrs=getOprofileCounters(null);
  if (ctrs.length > 0 && ctrs[0].getValidEvents() == null) {
    return false;
  }
  if (getOprofileTimerMode() || counterSubTabs == null) {
    return true;
  }
 else {
    return validateEvents(config);
  }
}",0.7938931297709924
91867,"private OpEvent eventFromString(String str){
  for (int i=0; i < eventList.length; i++) {
    if (eventList[i].getText().equals(str))     return eventList[i];
  }
  return null;
}","private OpEvent eventFromString(String str){
  if (eventList != null) {
    for (int i=0; i < eventList.length; i++) {
      if (eventList[i].getText().equals(str))       return eventList[i];
    }
  }
  return null;
}",0.836272040302267
91868,"private void createAnnotations(SourceFile sourceFile){
  AnnotationModelEvent event=new AnnotationModelEvent(this);
  clear(event);
  List<Line> lines=sourceFile.getLines();
  List<Long> tmp=new ArrayList<>();
  for (  Line line : lines) {
    if (line.getCount() != 0) {
      tmp.add(line.getCount());
    }
  }
  Long[] counts=tmp.toArray(new Long[0]);
  Arrays.sort(counts);
  final int q1=(int)Math.floor(0.25 * counts.length);
  final int q3=(int)Math.ceil(0.75 * counts.length);
  final float outlierThreshold=counts[q3] + (1.5f * (counts[q3] - counts[q1]));
  for (int i=0; i < lines.size(); i++) {
    try {
      Line line=lines.get((i + 1) % lines.size());
      String type=COVERAGE;
      if (line.getCount() == 0) {
        type=NO_COVERAGE;
      }
 else       if (line.getCount() > outlierThreshold) {
        type=THOROUGH_COVERAGE;
      }
      if (line.exists()) {
        GcovAnnotation ca=new GcovAnnotation(document.getLineOffset(i),document.getLineLength(i),line.getCount(),type);
        annotations.add(ca);
        event.annotationAdded(ca);
      }
    }
 catch (    BadLocationException e) {
    }
  }
  fireModelChanged(event);
  annotated=true;
}","private void createAnnotations(SourceFile sourceFile){
  AnnotationModelEvent event=new AnnotationModelEvent(this);
  clear(event);
  List<Line> lines=sourceFile.getLines();
  List<Long> tmp=new ArrayList<>();
  for (  Line line : lines) {
    if (line.getCount() != 0) {
      tmp.add(line.getCount());
    }
  }
  Long[] counts=tmp.toArray(new Long[0]);
  Arrays.sort(counts);
  float outlierThreshold=0;
  if (!tmp.isEmpty()) {
    final int q1=(int)Math.floor(0.25 * counts.length);
    final int q3=(int)Math.floor(0.75 * counts.length);
    outlierThreshold=counts[q3] + (1.5f * (counts[q3] - counts[q1]));
  }
  for (int i=0; i < lines.size(); i++) {
    try {
      Line line=lines.get((i + 1) % lines.size());
      String type=COVERAGE;
      if (line.getCount() == 0) {
        type=NO_COVERAGE;
      }
 else       if (line.getCount() > outlierThreshold) {
        type=THOROUGH_COVERAGE;
      }
      if (line.exists()) {
        GcovAnnotation ca=new GcovAnnotation(document.getLineOffset(i),document.getLineLength(i),line.getCount(),type);
        annotations.add(ca);
        event.annotationAdded(ca);
      }
    }
 catch (    BadLocationException e) {
    }
  }
  fireModelChanged(event);
  annotated=true;
}",0.9663201663201664
91869,"@Override public void createPartControl(Composite parent){
  fTree=new Tree(parent,SWT.NONE);
  TreeColumn nameCol=new TreeColumn(fTree,SWT.NONE,0);
  TreeColumn valueCol=new TreeColumn(fTree,SWT.NONE,1);
  nameCol.setText(Messages.TmfSynchronizationView_NameColumn);
  valueCol.setText(Messages.TmfSynchronizationView_ValueColumn);
  fTree.setItemCount(0);
  fTree.setHeaderVisible(true);
  nameCol.pack();
  valueCol.pack();
}","@Override public void createPartControl(Composite parent){
  fTree=new Tree(parent,SWT.NONE);
  TreeColumn nameCol=new TreeColumn(fTree,SWT.NONE,0);
  TreeColumn valueCol=new TreeColumn(fTree,SWT.NONE,1);
  nameCol.setText(Messages.TmfSynchronizationView_NameColumn);
  valueCol.setText(Messages.TmfSynchronizationView_ValueColumn);
  fTree.setItemCount(0);
  fTree.setHeaderVisible(true);
  nameCol.pack();
  valueCol.pack();
  ITmfTrace trace=TmfTraceManager.getInstance().getActiveTrace();
  if (trace != null) {
    traceSelected(new TmfTraceSelectedSignal(this,trace));
  }
}",0.8492063492063492
91870,"/** 
 * Run the BaseEventInfo() constructor test.
 */
@Test public void testBaseEventInfo(){
  EventInfo fixture=new EventInfo(""String_Node_Str"");
  assertNotNull(fixture);
  TraceEventType result=fixture.getEventType();
  assertEquals(""String_Node_Str"",fixture.getName());
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(4,result.ordinal());
  TraceEnablement state=fixture.getState();
  assertEquals(""String_Node_Str"",state.getInName());
  assertEquals(""String_Node_Str"",state.name());
  assertEquals(""String_Node_Str"",state.toString());
  assertEquals(0,state.ordinal());
}","/** 
 * Run the EventInfo() constructor test.
 */
@Test public void testBaseEventInfo(){
  EventInfo fixture=new EventInfo(""String_Node_Str"");
  assertNotNull(fixture);
  TraceEventType result=fixture.getEventType();
  assertEquals(""String_Node_Str"",fixture.getName());
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(4,result.ordinal());
  TraceEnablement state=fixture.getState();
  assertEquals(""String_Node_Str"",state.getInName());
  assertEquals(""String_Node_Str"",state.name());
  assertEquals(""String_Node_Str"",state.toString());
  assertEquals(0,state.ordinal());
  LogLevelType logType=fixture.getLogLevelType();
  assertEquals(""String_Node_Str"",logType.getShortName());
  assertEquals(""String_Node_Str"",logType.name());
  assertEquals(""String_Node_Str"",logType.toString());
  assertEquals(0,state.ordinal());
}",0.8470444850700792
91871,"/** 
 * Test Copy Constructor
 */
@Test public void testEventInfoCopy(){
  EventInfo info=new EventInfo((EventInfo)fEventInfo1);
  assertEquals(fEventInfo1.getName(),info.getName());
  assertEquals(fEventInfo1.getEventType(),info.getEventType());
  assertEquals(fEventInfo1.getState(),info.getState());
}","/** 
 * Test Copy Constructor
 */
@Test public void testEventInfoCopy(){
  EventInfo info=new EventInfo((EventInfo)fEventInfo1);
  assertEquals(fEventInfo1.getName(),info.getName());
  assertEquals(fEventInfo1.getEventType(),info.getEventType());
  assertEquals(fEventInfo1.getState(),info.getState());
  assertEquals(fEventInfo1.getLogLevelType(),info.getLogLevelType());
}",0.8967551622418879
91872,"/** 
 * Getter/Setter tests
 */
@Test public void testGetAndSetter(){
  EventInfo fixture=new EventInfo(""String_Node_Str"");
  fixture.setEventType(TraceEventType.TRACEPOINT);
  TraceEventType result=fixture.getEventType();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(0,result.ordinal());
  fixture.setEventType(TraceEventType.UNKNOWN);
  result=fixture.getEventType();
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(4,result.ordinal());
  String typeName=""String_Node_Str"";
  fixture.setEventType(typeName);
  result=fixture.getEventType();
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(4,result.ordinal());
  typeName=""String_Node_Str"";
  fixture.setEventType(typeName);
  result=fixture.getEventType();
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(4,result.ordinal());
  fixture.setState(""String_Node_Str"");
  TraceEnablement state=fixture.getState();
  assertEquals(""String_Node_Str"",state.getInName());
  assertEquals(""String_Node_Str"",state.name());
  assertEquals(""String_Node_Str"",state.toString());
  assertEquals(0,state.ordinal());
  fixture.setState(""String_Node_Str"");
  state=fixture.getState();
  assertEquals(""String_Node_Str"",state.getInName());
  assertEquals(""String_Node_Str"",state.name());
  assertEquals(""String_Node_Str"",state.toString());
  assertEquals(0,state.ordinal());
  fixture.setState(""String_Node_Str"");
  state=fixture.getState();
  assertEquals(""String_Node_Str"",state.getInName());
  assertEquals(""String_Node_Str"",state.name());
  assertEquals(""String_Node_Str"",state.toString());
  assertEquals(1,state.ordinal());
  fixture.setState(TraceEnablement.DISABLED);
  state=fixture.getState();
  assertEquals(""String_Node_Str"",state.getInName());
  assertEquals(""String_Node_Str"",state.name());
  assertEquals(""String_Node_Str"",state.toString());
  assertEquals(0,state.ordinal());
  fixture.setState(TraceEnablement.ENABLED);
  state=fixture.getState();
  assertEquals(""String_Node_Str"",state.getInName());
  assertEquals(""String_Node_Str"",state.name());
  assertEquals(""String_Node_Str"",state.toString());
  assertEquals(1,state.ordinal());
}","/** 
 * Getter/Setter tests
 */
@Test public void testGetAndSetter(){
  EventInfo fixture=new EventInfo(""String_Node_Str"");
  fixture.setEventType(TraceEventType.TRACEPOINT);
  TraceEventType result=fixture.getEventType();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(0,result.ordinal());
  fixture.setEventType(TraceEventType.UNKNOWN);
  result=fixture.getEventType();
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(4,result.ordinal());
  String typeName=""String_Node_Str"";
  fixture.setEventType(typeName);
  result=fixture.getEventType();
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(4,result.ordinal());
  typeName=""String_Node_Str"";
  fixture.setEventType(typeName);
  result=fixture.getEventType();
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(4,result.ordinal());
  fixture.setState(""String_Node_Str"");
  TraceEnablement state=fixture.getState();
  assertEquals(""String_Node_Str"",state.getInName());
  assertEquals(""String_Node_Str"",state.name());
  assertEquals(""String_Node_Str"",state.toString());
  assertEquals(0,state.ordinal());
  fixture.setState(""String_Node_Str"");
  state=fixture.getState();
  assertEquals(""String_Node_Str"",state.getInName());
  assertEquals(""String_Node_Str"",state.name());
  assertEquals(""String_Node_Str"",state.toString());
  assertEquals(0,state.ordinal());
  fixture.setState(""String_Node_Str"");
  state=fixture.getState();
  assertEquals(""String_Node_Str"",state.getInName());
  assertEquals(""String_Node_Str"",state.name());
  assertEquals(""String_Node_Str"",state.toString());
  assertEquals(1,state.ordinal());
  fixture.setState(TraceEnablement.DISABLED);
  state=fixture.getState();
  assertEquals(""String_Node_Str"",state.getInName());
  assertEquals(""String_Node_Str"",state.name());
  assertEquals(""String_Node_Str"",state.toString());
  assertEquals(0,state.ordinal());
  fixture.setState(TraceEnablement.ENABLED);
  state=fixture.getState();
  assertEquals(""String_Node_Str"",state.getInName());
  assertEquals(""String_Node_Str"",state.name());
  assertEquals(""String_Node_Str"",state.toString());
  assertEquals(1,state.ordinal());
  fixture.setLogLevelType(""String_Node_Str"");
  assertEquals(""String_Node_Str"",fixture.getLogLevelType().name());
  assertEquals(""String_Node_Str"",fixture.getLogLevelType().getShortName());
  fixture.setLogLevelType(""String_Node_Str"");
  assertEquals(""String_Node_Str"",fixture.getLogLevelType().name());
  assertEquals(""String_Node_Str"",fixture.getLogLevelType().getShortName());
  fixture.setLogLevelType(""String_Node_Str"");
  assertEquals(""String_Node_Str"",fixture.getLogLevelType().name());
  assertEquals(""String_Node_Str"",fixture.getLogLevelType().getShortName());
  fixture.setLogLevelType(LogLevelType.LOGLEVEL_ONLY);
  assertEquals(""String_Node_Str"",fixture.getLogLevelType().name());
  assertEquals(""String_Node_Str"",fixture.getLogLevelType().getShortName());
}",0.8712970711297071
91873,"public ModelImplFactory(){
  fFieldInfo1=new FieldInfo(""String_Node_Str"");
  fFieldInfo1.setFieldType(""String_Node_Str"");
  fFieldInfo2=new FieldInfo(""String_Node_Str"");
  fFieldInfo2.setFieldType(""String_Node_Str"");
  fBaseEventInfo1=new BaseEventInfo(""String_Node_Str"");
  fBaseEventInfo1.setEventType(TraceEventType.UNKNOWN);
  fBaseEventInfo1.setLogLevel(TraceLogLevel.TRACE_ERR);
  fBaseEventInfo1.addField(fFieldInfo1);
  fBaseEventInfo1.addField(fFieldInfo2);
  fBaseEventInfo1.setFilterExpression(""String_Node_Str"");
  fBaseEventInfo2=new BaseEventInfo(""String_Node_Str"");
  fBaseEventInfo2.setEventType(TraceEventType.TRACEPOINT);
  fBaseEventInfo1.setLogLevel(TraceLogLevel.TRACE_DEBUG);
  fEventInfo1=new EventInfo(""String_Node_Str"");
  fEventInfo1.setEventType(TraceEventType.TRACEPOINT);
  fEventInfo1.setState(TraceEnablement.ENABLED);
  fEventInfo2=new EventInfo(""String_Node_Str"");
  fEventInfo2.setEventType(TraceEventType.UNKNOWN);
  fEventInfo2.setState(TraceEnablement.DISABLED);
  fEventInfo3=new EventInfo(""String_Node_Str"");
  fEventInfo3.setEventType(TraceEventType.TRACEPOINT);
  fEventInfo3.setState(TraceEnablement.DISABLED);
  fUstProviderInfo1=new UstProviderInfo(""String_Node_Str"");
  fUstProviderInfo1.setPid(1234);
  fUstProviderInfo1.addEvent(fBaseEventInfo1);
  fUstProviderInfo2=new UstProviderInfo(""String_Node_Str"");
  fUstProviderInfo2.setPid(2345);
  fUstProviderInfo2.addEvent(fBaseEventInfo1);
  fUstProviderInfo2.addEvent(fBaseEventInfo2);
  fChannelInfo1=new ChannelInfo(""String_Node_Str"");
  fChannelInfo1.setSwitchTimer(10L);
  fChannelInfo1.setOverwriteMode(true);
  fChannelInfo1.setReadTimer(11L);
  fChannelInfo1.setState(TraceEnablement.DISABLED);
  fChannelInfo1.setNumberOfSubBuffers(12);
  fChannelInfo1.setOutputType(""String_Node_Str"");
  fChannelInfo1.setSubBufferSize(13L);
  fChannelInfo1.addEvent(fEventInfo1);
  fChannelInfo2=new ChannelInfo(""String_Node_Str"");
  fChannelInfo2.setSwitchTimer(1L);
  fChannelInfo2.setOverwriteMode(false);
  fChannelInfo2.setReadTimer(2L);
  fChannelInfo2.setState(TraceEnablement.ENABLED);
  fChannelInfo2.setNumberOfSubBuffers(3);
  fChannelInfo2.setOutputType(""String_Node_Str"");
  fChannelInfo2.setSubBufferSize(4L);
  fChannelInfo2.addEvent(fEventInfo2);
  fChannelInfo2.addEvent(fEventInfo3);
  fDomainInfo1=new DomainInfo(""String_Node_Str"");
  fDomainInfo1.addChannel(fChannelInfo1);
  fDomainInfo2=new DomainInfo(""String_Node_Str"");
  fDomainInfo2.addChannel(fChannelInfo1);
  fDomainInfo2.addChannel(fChannelInfo2);
  fSessionInfo1=new SessionInfo(""String_Node_Str"");
  fSessionInfo1.setSessionPath(""String_Node_Str"");
  fSessionInfo1.setSessionState(TraceSessionState.ACTIVE);
  fSessionInfo1.addDomain(fDomainInfo1);
  fSessionInfo2=new SessionInfo(""String_Node_Str"");
  fSessionInfo2.setSessionPath(""String_Node_Str"");
  fSessionInfo2.setSessionState(TraceSessionState.INACTIVE);
  fSessionInfo2.addDomain(fDomainInfo1);
  fSessionInfo2.addDomain(fDomainInfo2);
  fSessionInfo2.setStreamedTrace(true);
  fProbeEventInfo1=new ProbeEventInfo(""String_Node_Str"");
  fProbeEventInfo1.setEventType(TraceEventType.TRACEPOINT);
  fProbeEventInfo1.setState(TraceEnablement.ENABLED);
  fProbeEventInfo1.setAddress(""String_Node_Str"");
  fProbeEventInfo2=new ProbeEventInfo(""String_Node_Str"");
  fProbeEventInfo2.setEventType(TraceEventType.FUNCTION);
  fProbeEventInfo2.setState(TraceEnablement.DISABLED);
  fProbeEventInfo2.setOffset(""String_Node_Str"");
  fProbeEventInfo2.setSymbol(""String_Node_Str"");
  fSnapshotInfo1=new SnapshotInfo(""String_Node_Str"");
  fSnapshotInfo1.setId(1);
  fSnapshotInfo1.setSnapshotPath(""String_Node_Str"");
  fSnapshotInfo2=new SnapshotInfo(""String_Node_Str"");
  fSnapshotInfo2.setId(1);
  fSnapshotInfo2.setSnapshotPath(""String_Node_Str"");
  fSnapshotInfo2.setStreamedSnapshot(true);
  fSessionInfo1.setSnapshotInfo(fSnapshotInfo1);
}","public ModelImplFactory(){
  fFieldInfo1=new FieldInfo(""String_Node_Str"");
  fFieldInfo1.setFieldType(""String_Node_Str"");
  fFieldInfo2=new FieldInfo(""String_Node_Str"");
  fFieldInfo2.setFieldType(""String_Node_Str"");
  fBaseEventInfo1=new BaseEventInfo(""String_Node_Str"");
  fBaseEventInfo1.setEventType(TraceEventType.UNKNOWN);
  fBaseEventInfo1.setLogLevel(TraceLogLevel.TRACE_ERR);
  fBaseEventInfo1.addField(fFieldInfo1);
  fBaseEventInfo1.addField(fFieldInfo2);
  fBaseEventInfo1.setFilterExpression(""String_Node_Str"");
  fBaseEventInfo2=new BaseEventInfo(""String_Node_Str"");
  fBaseEventInfo2.setEventType(TraceEventType.TRACEPOINT);
  fBaseEventInfo1.setLogLevel(TraceLogLevel.TRACE_DEBUG);
  fEventInfo1=new EventInfo(""String_Node_Str"");
  fEventInfo1.setEventType(TraceEventType.TRACEPOINT);
  fEventInfo1.setLogLevelType(""String_Node_Str"");
  fEventInfo1.setLogLevel(TraceLogLevel.TRACE_DEBUG);
  fEventInfo1.setState(TraceEnablement.ENABLED);
  fEventInfo2=new EventInfo(""String_Node_Str"");
  fEventInfo2.setLogLevelType(""String_Node_Str"");
  fEventInfo2.setLogLevel(TraceLogLevel.TRACE_INFO);
  fEventInfo2.setEventType(TraceEventType.UNKNOWN);
  fEventInfo2.setState(TraceEnablement.DISABLED);
  fEventInfo3=new EventInfo(""String_Node_Str"");
  fEventInfo3.setEventType(TraceEventType.TRACEPOINT);
  fEventInfo3.setState(TraceEnablement.DISABLED);
  fUstProviderInfo1=new UstProviderInfo(""String_Node_Str"");
  fUstProviderInfo1.setPid(1234);
  fUstProviderInfo1.addEvent(fBaseEventInfo1);
  fUstProviderInfo2=new UstProviderInfo(""String_Node_Str"");
  fUstProviderInfo2.setPid(2345);
  fUstProviderInfo2.addEvent(fBaseEventInfo1);
  fUstProviderInfo2.addEvent(fBaseEventInfo2);
  fChannelInfo1=new ChannelInfo(""String_Node_Str"");
  fChannelInfo1.setSwitchTimer(10L);
  fChannelInfo1.setOverwriteMode(true);
  fChannelInfo1.setReadTimer(11L);
  fChannelInfo1.setState(TraceEnablement.DISABLED);
  fChannelInfo1.setNumberOfSubBuffers(12);
  fChannelInfo1.setOutputType(""String_Node_Str"");
  fChannelInfo1.setSubBufferSize(13L);
  fChannelInfo1.addEvent(fEventInfo1);
  fChannelInfo2=new ChannelInfo(""String_Node_Str"");
  fChannelInfo2.setSwitchTimer(1L);
  fChannelInfo2.setOverwriteMode(false);
  fChannelInfo2.setReadTimer(2L);
  fChannelInfo2.setState(TraceEnablement.ENABLED);
  fChannelInfo2.setNumberOfSubBuffers(3);
  fChannelInfo2.setOutputType(""String_Node_Str"");
  fChannelInfo2.setSubBufferSize(4L);
  fChannelInfo2.addEvent(fEventInfo2);
  fChannelInfo2.addEvent(fEventInfo3);
  fDomainInfo1=new DomainInfo(""String_Node_Str"");
  fDomainInfo1.addChannel(fChannelInfo1);
  fDomainInfo2=new DomainInfo(""String_Node_Str"");
  fDomainInfo2.addChannel(fChannelInfo1);
  fDomainInfo2.addChannel(fChannelInfo2);
  fSessionInfo1=new SessionInfo(""String_Node_Str"");
  fSessionInfo1.setSessionPath(""String_Node_Str"");
  fSessionInfo1.setSessionState(TraceSessionState.ACTIVE);
  fSessionInfo1.addDomain(fDomainInfo1);
  fSessionInfo2=new SessionInfo(""String_Node_Str"");
  fSessionInfo2.setSessionPath(""String_Node_Str"");
  fSessionInfo2.setSessionState(TraceSessionState.INACTIVE);
  fSessionInfo2.addDomain(fDomainInfo1);
  fSessionInfo2.addDomain(fDomainInfo2);
  fSessionInfo2.setStreamedTrace(true);
  fProbeEventInfo1=new ProbeEventInfo(""String_Node_Str"");
  fProbeEventInfo1.setEventType(TraceEventType.TRACEPOINT);
  fProbeEventInfo1.setState(TraceEnablement.ENABLED);
  fProbeEventInfo1.setAddress(""String_Node_Str"");
  fProbeEventInfo2=new ProbeEventInfo(""String_Node_Str"");
  fProbeEventInfo2.setEventType(TraceEventType.FUNCTION);
  fProbeEventInfo2.setState(TraceEnablement.DISABLED);
  fProbeEventInfo2.setOffset(""String_Node_Str"");
  fProbeEventInfo2.setSymbol(""String_Node_Str"");
  fSnapshotInfo1=new SnapshotInfo(""String_Node_Str"");
  fSnapshotInfo1.setId(1);
  fSnapshotInfo1.setSnapshotPath(""String_Node_Str"");
  fSnapshotInfo2=new SnapshotInfo(""String_Node_Str"");
  fSnapshotInfo2.setId(1);
  fSnapshotInfo2.setSnapshotPath(""String_Node_Str"");
  fSnapshotInfo2.setStreamedSnapshot(true);
  fSessionInfo1.setSnapshotInfo(fSnapshotInfo1);
}",0.9738801261829652
91874,"/** 
 * Copy constructor
 * @param other - the instance to copy
 */
public BaseEventInfo(BaseEventInfo other){
  super(other);
  fEventType=other.fEventType;
  for (Iterator<IFieldInfo> iterator=other.fFields.iterator(); iterator.hasNext(); ) {
    IFieldInfo field=iterator.next();
    if (field instanceof FieldInfo) {
      fFields.add(new FieldInfo((FieldInfo)field));
    }
 else {
      fFields.add(field);
    }
  }
  fFilterExpression=other.fFilterExpression;
}","/** 
 * Copy constructor
 * @param other - the instance to copy
 */
public BaseEventInfo(BaseEventInfo other){
  super(other);
  fEventType=other.fEventType;
  fLogLevel=other.fLogLevel;
  for (Iterator<IFieldInfo> iterator=other.fFields.iterator(); iterator.hasNext(); ) {
    IFieldInfo field=iterator.next();
    if (field instanceof FieldInfo) {
      fFields.add(new FieldInfo((FieldInfo)field));
    }
 else {
      fFields.add(field);
    }
  }
  fFilterExpression=other.fFilterExpression;
}",0.970010341261634
91875,"/** 
 * Copy constructor
 * @param other - the instance to copy
 */
public EventInfo(EventInfo other){
  super(other);
  fState=other.fState;
}","/** 
 * Copy constructor
 * @param other - the instance to copy
 */
public EventInfo(EventInfo other){
  super(other);
  fState=other.fState;
  fLogLevelType=other.fLogLevelType;
}",0.8854489164086687
91876,"@Override public int hashCode(){
  final int prime=31;
  int result=super.hashCode();
  result=prime * result + ((fState == null) ? 0 : (fState.ordinal() + 1));
  return result;
}","@Override public int hashCode(){
  final int prime=31;
  int result=super.hashCode();
  result=prime * result + ((fState == null) ? 0 : (fState.ordinal() + 1));
  result=prime * result + ((fLogLevelType == null) ? 0 : fLogLevelType.hashCode());
  return result;
}",0.8099547511312217
91877,"@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (!super.equals(obj)) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  EventInfo other=(EventInfo)obj;
  if (fState != other.fState) {
    return false;
  }
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (!super.equals(obj)) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  EventInfo other=(EventInfo)obj;
  if (fState != other.fState) {
    return false;
  }
  if (fLogLevelType != other.fLogLevelType) {
    return false;
  }
  return true;
}",0.8567164179104477
91878,"@SuppressWarnings(""String_Node_Str"") @Override public String toString(){
  StringBuffer output=new StringBuffer();
  output.append(""String_Node_Str"");
  output.append(super.toString());
  output.append(""String_Node_Str"");
  output.append(fState);
  output.append(""String_Node_Str"");
  return output.toString();
}","@SuppressWarnings(""String_Node_Str"") @Override public String toString(){
  StringBuffer output=new StringBuffer();
  output.append(""String_Node_Str"");
  output.append(super.toString());
  output.append(""String_Node_Str"");
  output.append(fState);
  output.append(""String_Node_Str"");
  output.append(fLogLevelType);
  output.append(""String_Node_Str"");
  return output.toString();
}",0.9017341040462428
91879,"/** 
 * Run the TraceControlComponent.
 * @throws Exception This will fail the test
 */
@Test public void testComponentProperties() throws Exception {
  TestRemoteSystemProxy proxy=new TestRemoteSystemProxy();
  URL location=FileLocator.find(FrameworkUtil.getBundle(this.getClass()),new Path(DIRECTORY + File.separator + TEST_STREAM),null);
  File testfile=new File(FileLocator.toFileURL(location).toURI());
  proxy.setTestFile(testfile.getAbsolutePath());
  proxy.setScenario(SCEN_LIST_INFO_TEST);
  ITraceControlComponent root=TraceControlTestFacility.getInstance().getControlView().getTraceControlRoot();
  ISystemRegistry registry=RSECorePlugin.getTheSystemRegistry();
  ISystemProfile profile=registry.createSystemProfile(""String_Node_Str"",true);
  IHost host=registry.createLocalHost(profile,""String_Node_Str"",""String_Node_Str"");
  TargetNodeComponent node=new TargetNodeComponent(""String_Node_Str"",root,host,proxy);
  root.addChild(node);
  node.connect();
  TraceControlTestFacility.getInstance().waitForJobs();
  Object adapter=node.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof TargetNodePropertySource);
  TargetNodePropertySource source=(TargetNodePropertySource)adapter;
  assertNull(source.getEditableValue());
  assertFalse(source.isPropertySet(TargetNodePropertySource.TARGET_NODE_NAME_PROPERTY_ID));
  assertNotNull(source.getPropertyDescriptors());
  assertEquals(""String_Node_Str"",source.getPropertyValue(TargetNodePropertySource.TARGET_NODE_NAME_PROPERTY_ID));
  assertEquals(""String_Node_Str"",source.getPropertyValue(TargetNodePropertySource.TARGET_NODE_ADDRESS_PROPERTY_ID));
  assertEquals(TargetNodeState.CONNECTED.name(),source.getPropertyValue(TargetNodePropertySource.TARGET_NODE_STATE_PROPERTY_ID));
  assertEquals(""String_Node_Str"",source.getPropertyValue(TargetNodePropertySource.TARGET_NODE_VERSION_PROPERTY_ID));
  assertNull(source.getPropertyValue(""String_Node_Str""));
  adapter=node.getAdapter(IChannelInfo.class);
  assertNull(adapter);
  ITraceControlComponent[] groups=node.getChildren();
  assertNotNull(groups);
  assertEquals(2,groups.length);
  ITraceControlComponent[] providers=groups[0].getChildren();
  assertNotNull(providers);
  assertEquals(3,providers.length);
  KernelProviderComponent kernelProvider=(KernelProviderComponent)providers[0];
  adapter=kernelProvider.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof KernelProviderPropertySource);
  KernelProviderPropertySource kernelSource=(KernelProviderPropertySource)adapter;
  assertNotNull(kernelSource.getPropertyDescriptors());
  assertEquals(""String_Node_Str"",kernelSource.getPropertyValue(KernelProviderPropertySource.KERNEL_PROVIDER_NAME_PROPERTY_ID));
  UstProviderComponent ustProvider=(UstProviderComponent)providers[1];
  adapter=ustProvider.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof UstProviderPropertySource);
  UstProviderPropertySource ustSource=(UstProviderPropertySource)adapter;
  assertNotNull(ustSource.getPropertyDescriptors());
  assertEquals(""String_Node_Str"",ustSource.getPropertyValue(UstProviderPropertySource.UST_PROVIDER_NAME_PROPERTY_ID));
  assertEquals(String.valueOf(9379),ustSource.getPropertyValue(UstProviderPropertySource.UST_PROVIDER_PID_PROPERTY_ID));
  ITraceControlComponent[] events=ustProvider.getChildren();
  assertNotNull(events);
  assertEquals(2,events.length);
  BaseEventComponent baseEventInfo=(BaseEventComponent)events[0];
  assertNotNull(baseEventInfo);
  adapter=baseEventInfo.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof BaseEventPropertySource);
  BaseEventPropertySource baseSource=(BaseEventPropertySource)adapter;
  assertNotNull(baseSource.getPropertyDescriptors());
  assertEquals(""String_Node_Str"",baseSource.getPropertyValue(BaseEventPropertySource.BASE_EVENT_NAME_PROPERTY_ID));
  assertEquals(TraceEventType.TRACEPOINT.name(),baseSource.getPropertyValue(BaseEventPropertySource.BASE_EVENT_TYPE_PROPERTY_ID));
  assertEquals(TraceLogLevel.TRACE_DEBUG_MODULE.name(),baseSource.getPropertyValue(BaseEventPropertySource.BASE_EVENT_LOGLEVEL_PROPERTY_ID));
  baseEventInfo=(BaseEventComponent)events[1];
  assertNotNull(baseEventInfo);
  adapter=baseEventInfo.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof BaseEventPropertySource);
  baseSource=(BaseEventPropertySource)adapter;
  assertNotNull(baseSource.getPropertyDescriptors());
  assertEquals(""String_Node_Str"",baseSource.getPropertyValue(BaseEventPropertySource.BASE_EVENT_FIELDS_PROPERTY_ID));
  ITraceControlComponent[] sessions=groups[1].getChildren();
  assertNotNull(sessions);
  assertEquals(2,sessions.length);
  TraceSessionComponent session=(TraceSessionComponent)sessions[1];
  adapter=session.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof TraceSessionPropertySource);
  TraceSessionPropertySource sessionSource=(TraceSessionPropertySource)adapter;
  assertNotNull(sessionSource.getPropertyDescriptors());
  assertEquals(""String_Node_Str"",sessionSource.getPropertyValue(TraceSessionPropertySource.TRACE_SESSION_NAME_PROPERTY_ID));
  assertEquals(""String_Node_Str"",sessionSource.getPropertyValue(TraceSessionPropertySource.TRACE_SESSION_PATH_PROPERTY_ID));
  assertEquals(TraceSessionState.ACTIVE.name(),sessionSource.getPropertyValue(TraceSessionPropertySource.TRACE_SESSION_STATE_PROPERTY_ID));
  ITraceControlComponent[] domains=session.getChildren();
  assertNotNull(domains);
  assertEquals(2,domains.length);
  TraceDomainComponent domain=(TraceDomainComponent)domains[0];
  adapter=domain.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof TraceDomainPropertySource);
  TraceDomainPropertySource domainSource=(TraceDomainPropertySource)adapter;
  assertNotNull(domainSource.getPropertyDescriptors());
  assertEquals(""String_Node_Str"",domainSource.getPropertyValue(TraceDomainPropertySource.TRACE_DOMAIN_NAME_PROPERTY_ID));
  assertEquals(BufferType.BUFFER_SHARED.getInName(),domainSource.getPropertyValue(TraceDomainPropertySource.BUFFER_TYPE_PROPERTY_ID));
  ITraceControlComponent[] channels=domains[0].getChildren();
  assertNotNull(channels);
  assertEquals(2,channels.length);
  assertTrue(channels[0] instanceof TraceChannelComponent);
  TraceChannelComponent channel=(TraceChannelComponent)channels[0];
  adapter=channel.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof TraceChannelPropertySource);
  TraceChannelPropertySource channelSource=(TraceChannelPropertySource)adapter;
  assertNotNull(channelSource.getPropertyDescriptors());
  assertEquals(""String_Node_Str"",channelSource.getPropertyValue(TraceChannelPropertySource.TRACE_CHANNEL_NAME_PROPERTY_ID));
  assertEquals(String.valueOf(4),channelSource.getPropertyValue(TraceChannelPropertySource.TRACE_CHANNEL_NO_SUBBUFFERS_PROPERTY_ID));
  assertEquals(TraceEnablement.ENABLED.name(),channelSource.getPropertyValue(TraceChannelPropertySource.TRACE_CHANNEL_STATE_PROPERTY_ID));
  assertEquals(String.valueOf(false),channelSource.getPropertyValue(TraceChannelPropertySource.TRACE_CHANNEL_OVERWRITE_MODE_PROPERTY_ID));
  assertEquals(""String_Node_Str"",channelSource.getPropertyValue(TraceChannelPropertySource.TRACE_CHANNEL_OUTPUT_TYPE_PROPERTY_ID));
  assertEquals(String.valueOf(200),channelSource.getPropertyValue(TraceChannelPropertySource.TRACE_CHANNEL_READ_TIMER_PROPERTY_ID));
  assertEquals(String.valueOf(262144),channelSource.getPropertyValue(TraceChannelPropertySource.TRACE_CHANNEL_SUBBUFFER_SIZE_PROPERTY_ID));
  assertEquals(String.valueOf(0),channelSource.getPropertyValue(TraceChannelPropertySource.TRACE_CHANNEL_SWITCH_TIMER_PROPERTY_ID));
  ITraceControlComponent[] channel0Events=channel.getChildren();
  assertNotNull(channel0Events);
  assertEquals(5,channel0Events.length);
  assertTrue(channel0Events[0] instanceof TraceEventComponent);
  TraceEventComponent event=(TraceEventComponent)channel0Events[0];
  adapter=event.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof TraceEventPropertySource);
  TraceEventPropertySource eventSource=(TraceEventPropertySource)adapter;
  assertNotNull(eventSource.getPropertyDescriptors());
  assertEquals(""String_Node_Str"",eventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_NAME_PROPERTY_ID));
  assertEquals(TraceLogLevel.TRACE_EMERG.name(),eventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_LOGLEVEL_PROPERTY_ID));
  assertEquals(TraceEventType.TRACEPOINT.name(),eventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_TYPE_PROPERTY_ID));
  assertEquals(TraceEnablement.ENABLED.name(),eventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_STATE_PROPERTY_ID));
  assertTrue(channel0Events[2] instanceof TraceProbeEventComponent);
  TraceProbeEventComponent probeEvent=(TraceProbeEventComponent)channel0Events[2];
  adapter=probeEvent.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof TraceProbeEventPropertySource);
  TraceProbeEventPropertySource probeEventSource=(TraceProbeEventPropertySource)adapter;
  assertNotNull(probeEventSource.getPropertyDescriptors());
  assertEquals(4,probeEventSource.getPropertyDescriptors().length);
  assertEquals(""String_Node_Str"",probeEventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_NAME_PROPERTY_ID));
  assertEquals(TraceEventType.PROBE.name(),probeEventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_TYPE_PROPERTY_ID));
  assertEquals(TraceEnablement.ENABLED.name(),probeEventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_STATE_PROPERTY_ID));
  assertEquals(""String_Node_Str"",probeEventSource.getPropertyValue(TraceProbeEventPropertySource.TRACE_EVENT_PROBE_ADDRESS_PROPERTY_ID));
  assertTrue(channel0Events[3] instanceof TraceProbeEventComponent);
  probeEvent=(TraceProbeEventComponent)channel0Events[3];
  adapter=probeEvent.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof TraceProbeEventPropertySource);
  probeEventSource=(TraceProbeEventPropertySource)adapter;
  assertNotNull(probeEventSource.getPropertyDescriptors());
  assertEquals(5,probeEventSource.getPropertyDescriptors().length);
  assertEquals(""String_Node_Str"",probeEventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_NAME_PROPERTY_ID));
  assertEquals(TraceEventType.PROBE.name(),probeEventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_TYPE_PROPERTY_ID));
  assertEquals(TraceEnablement.ENABLED.name(),probeEventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_STATE_PROPERTY_ID));
  assertEquals(""String_Node_Str"",probeEventSource.getPropertyValue(TraceProbeEventPropertySource.TRACE_EVENT_PROBE_OFFSET_PROPERTY_ID));
  assertEquals(""String_Node_Str"",probeEventSource.getPropertyValue(TraceProbeEventPropertySource.TRACE_EVENT_PROBE_SYMBOL_PROPERTY_ID));
  event=(TraceEventComponent)domains[1].getChildren()[1].getChildren()[0];
  adapter=event.getAdapter(IPropertySource.class);
  assertEquals(""String_Node_Str"",event.getFilterExpression());
  node.disconnect();
  node.getParent().removeChild(node);
}","/** 
 * Run the TraceControlComponent.
 * @throws Exception This will fail the test
 */
@Test public void testComponentProperties() throws Exception {
  TestRemoteSystemProxy proxy=new TestRemoteSystemProxy();
  URL location=FileLocator.find(FrameworkUtil.getBundle(this.getClass()),new Path(DIRECTORY + File.separator + TEST_STREAM),null);
  File testfile=new File(FileLocator.toFileURL(location).toURI());
  proxy.setTestFile(testfile.getAbsolutePath());
  proxy.setScenario(SCEN_LIST_INFO_TEST);
  ITraceControlComponent root=TraceControlTestFacility.getInstance().getControlView().getTraceControlRoot();
  ISystemRegistry registry=RSECorePlugin.getTheSystemRegistry();
  ISystemProfile profile=registry.createSystemProfile(""String_Node_Str"",true);
  IHost host=registry.createLocalHost(profile,""String_Node_Str"",""String_Node_Str"");
  TargetNodeComponent node=new TargetNodeComponent(""String_Node_Str"",root,host,proxy);
  root.addChild(node);
  node.connect();
  TraceControlTestFacility.getInstance().waitForJobs();
  Object adapter=node.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof TargetNodePropertySource);
  TargetNodePropertySource source=(TargetNodePropertySource)adapter;
  assertNull(source.getEditableValue());
  assertFalse(source.isPropertySet(TargetNodePropertySource.TARGET_NODE_NAME_PROPERTY_ID));
  assertNotNull(source.getPropertyDescriptors());
  assertEquals(""String_Node_Str"",source.getPropertyValue(TargetNodePropertySource.TARGET_NODE_NAME_PROPERTY_ID));
  assertEquals(""String_Node_Str"",source.getPropertyValue(TargetNodePropertySource.TARGET_NODE_ADDRESS_PROPERTY_ID));
  assertEquals(TargetNodeState.CONNECTED.name(),source.getPropertyValue(TargetNodePropertySource.TARGET_NODE_STATE_PROPERTY_ID));
  assertEquals(""String_Node_Str"",source.getPropertyValue(TargetNodePropertySource.TARGET_NODE_VERSION_PROPERTY_ID));
  assertNull(source.getPropertyValue(""String_Node_Str""));
  adapter=node.getAdapter(IChannelInfo.class);
  assertNull(adapter);
  ITraceControlComponent[] groups=node.getChildren();
  assertNotNull(groups);
  assertEquals(2,groups.length);
  ITraceControlComponent[] providers=groups[0].getChildren();
  assertNotNull(providers);
  assertEquals(3,providers.length);
  KernelProviderComponent kernelProvider=(KernelProviderComponent)providers[0];
  adapter=kernelProvider.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof KernelProviderPropertySource);
  KernelProviderPropertySource kernelSource=(KernelProviderPropertySource)adapter;
  assertNotNull(kernelSource.getPropertyDescriptors());
  assertEquals(""String_Node_Str"",kernelSource.getPropertyValue(KernelProviderPropertySource.KERNEL_PROVIDER_NAME_PROPERTY_ID));
  UstProviderComponent ustProvider=(UstProviderComponent)providers[1];
  adapter=ustProvider.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof UstProviderPropertySource);
  UstProviderPropertySource ustSource=(UstProviderPropertySource)adapter;
  assertNotNull(ustSource.getPropertyDescriptors());
  assertEquals(""String_Node_Str"",ustSource.getPropertyValue(UstProviderPropertySource.UST_PROVIDER_NAME_PROPERTY_ID));
  assertEquals(String.valueOf(9379),ustSource.getPropertyValue(UstProviderPropertySource.UST_PROVIDER_PID_PROPERTY_ID));
  ITraceControlComponent[] events=ustProvider.getChildren();
  assertNotNull(events);
  assertEquals(2,events.length);
  BaseEventComponent baseEventInfo=(BaseEventComponent)events[0];
  assertNotNull(baseEventInfo);
  adapter=baseEventInfo.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof BaseEventPropertySource);
  BaseEventPropertySource baseSource=(BaseEventPropertySource)adapter;
  assertNotNull(baseSource.getPropertyDescriptors());
  assertEquals(""String_Node_Str"",baseSource.getPropertyValue(BaseEventPropertySource.BASE_EVENT_NAME_PROPERTY_ID));
  assertEquals(TraceEventType.TRACEPOINT.name(),baseSource.getPropertyValue(BaseEventPropertySource.BASE_EVENT_TYPE_PROPERTY_ID));
  assertEquals(TraceLogLevel.TRACE_DEBUG_MODULE.name(),baseSource.getPropertyValue(BaseEventPropertySource.BASE_EVENT_LOGLEVEL_PROPERTY_ID));
  baseEventInfo=(BaseEventComponent)events[1];
  assertNotNull(baseEventInfo);
  adapter=baseEventInfo.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof BaseEventPropertySource);
  baseSource=(BaseEventPropertySource)adapter;
  assertNotNull(baseSource.getPropertyDescriptors());
  assertEquals(""String_Node_Str"",baseSource.getPropertyValue(BaseEventPropertySource.BASE_EVENT_FIELDS_PROPERTY_ID));
  ITraceControlComponent[] sessions=groups[1].getChildren();
  assertNotNull(sessions);
  assertEquals(2,sessions.length);
  TraceSessionComponent session=(TraceSessionComponent)sessions[1];
  adapter=session.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof TraceSessionPropertySource);
  TraceSessionPropertySource sessionSource=(TraceSessionPropertySource)adapter;
  assertNotNull(sessionSource.getPropertyDescriptors());
  assertEquals(""String_Node_Str"",sessionSource.getPropertyValue(TraceSessionPropertySource.TRACE_SESSION_NAME_PROPERTY_ID));
  assertEquals(""String_Node_Str"",sessionSource.getPropertyValue(TraceSessionPropertySource.TRACE_SESSION_PATH_PROPERTY_ID));
  assertEquals(TraceSessionState.ACTIVE.name(),sessionSource.getPropertyValue(TraceSessionPropertySource.TRACE_SESSION_STATE_PROPERTY_ID));
  ITraceControlComponent[] domains=session.getChildren();
  assertNotNull(domains);
  assertEquals(2,domains.length);
  TraceDomainComponent domain=(TraceDomainComponent)domains[0];
  adapter=domain.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof TraceDomainPropertySource);
  TraceDomainPropertySource domainSource=(TraceDomainPropertySource)adapter;
  assertNotNull(domainSource.getPropertyDescriptors());
  assertEquals(""String_Node_Str"",domainSource.getPropertyValue(TraceDomainPropertySource.TRACE_DOMAIN_NAME_PROPERTY_ID));
  assertEquals(BufferType.BUFFER_SHARED.getInName(),domainSource.getPropertyValue(TraceDomainPropertySource.BUFFER_TYPE_PROPERTY_ID));
  ITraceControlComponent[] channels=domains[0].getChildren();
  assertNotNull(channels);
  assertEquals(2,channels.length);
  assertTrue(channels[0] instanceof TraceChannelComponent);
  TraceChannelComponent channel=(TraceChannelComponent)channels[0];
  adapter=channel.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof TraceChannelPropertySource);
  TraceChannelPropertySource channelSource=(TraceChannelPropertySource)adapter;
  assertNotNull(channelSource.getPropertyDescriptors());
  assertEquals(""String_Node_Str"",channelSource.getPropertyValue(TraceChannelPropertySource.TRACE_CHANNEL_NAME_PROPERTY_ID));
  assertEquals(String.valueOf(4),channelSource.getPropertyValue(TraceChannelPropertySource.TRACE_CHANNEL_NO_SUBBUFFERS_PROPERTY_ID));
  assertEquals(TraceEnablement.ENABLED.name(),channelSource.getPropertyValue(TraceChannelPropertySource.TRACE_CHANNEL_STATE_PROPERTY_ID));
  assertEquals(String.valueOf(false),channelSource.getPropertyValue(TraceChannelPropertySource.TRACE_CHANNEL_OVERWRITE_MODE_PROPERTY_ID));
  assertEquals(""String_Node_Str"",channelSource.getPropertyValue(TraceChannelPropertySource.TRACE_CHANNEL_OUTPUT_TYPE_PROPERTY_ID));
  assertEquals(String.valueOf(200),channelSource.getPropertyValue(TraceChannelPropertySource.TRACE_CHANNEL_READ_TIMER_PROPERTY_ID));
  assertEquals(String.valueOf(262144),channelSource.getPropertyValue(TraceChannelPropertySource.TRACE_CHANNEL_SUBBUFFER_SIZE_PROPERTY_ID));
  assertEquals(String.valueOf(0),channelSource.getPropertyValue(TraceChannelPropertySource.TRACE_CHANNEL_SWITCH_TIMER_PROPERTY_ID));
  ITraceControlComponent[] channel0Events=channel.getChildren();
  assertNotNull(channel0Events);
  assertEquals(5,channel0Events.length);
  assertTrue(channel0Events[0] instanceof TraceEventComponent);
  TraceEventComponent event=(TraceEventComponent)channel0Events[0];
  adapter=event.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof TraceEventPropertySource);
  TraceEventPropertySource eventSource=(TraceEventPropertySource)adapter;
  assertNotNull(eventSource.getPropertyDescriptors());
  assertEquals(""String_Node_Str"",eventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_NAME_PROPERTY_ID));
  assertEquals(TraceLogLevel.TRACE_EMERG.name(),eventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_LOGLEVEL_PROPERTY_ID));
  assertEquals(TraceEventType.TRACEPOINT.name(),eventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_TYPE_PROPERTY_ID));
  assertEquals(TraceEnablement.ENABLED.name(),eventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_STATE_PROPERTY_ID));
  assertTrue(channel0Events[2] instanceof TraceProbeEventComponent);
  TraceProbeEventComponent probeEvent=(TraceProbeEventComponent)channel0Events[2];
  adapter=probeEvent.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof TraceProbeEventPropertySource);
  TraceProbeEventPropertySource probeEventSource=(TraceProbeEventPropertySource)adapter;
  assertNotNull(probeEventSource.getPropertyDescriptors());
  assertEquals(4,probeEventSource.getPropertyDescriptors().length);
  assertEquals(""String_Node_Str"",probeEventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_NAME_PROPERTY_ID));
  assertEquals(TraceEventType.PROBE.name(),probeEventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_TYPE_PROPERTY_ID));
  assertEquals(TraceEnablement.ENABLED.name(),probeEventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_STATE_PROPERTY_ID));
  assertEquals(""String_Node_Str"",probeEventSource.getPropertyValue(TraceProbeEventPropertySource.TRACE_EVENT_PROBE_ADDRESS_PROPERTY_ID));
  assertTrue(channel0Events[3] instanceof TraceProbeEventComponent);
  probeEvent=(TraceProbeEventComponent)channel0Events[3];
  adapter=probeEvent.getAdapter(IPropertySource.class);
  assertNotNull(adapter);
  assertTrue(adapter instanceof TraceProbeEventPropertySource);
  probeEventSource=(TraceProbeEventPropertySource)adapter;
  assertNotNull(probeEventSource.getPropertyDescriptors());
  assertEquals(5,probeEventSource.getPropertyDescriptors().length);
  assertEquals(""String_Node_Str"",probeEventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_NAME_PROPERTY_ID));
  assertEquals(TraceEventType.PROBE.name(),probeEventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_TYPE_PROPERTY_ID));
  assertEquals(TraceEnablement.ENABLED.name(),probeEventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_STATE_PROPERTY_ID));
  assertEquals(""String_Node_Str"",probeEventSource.getPropertyValue(TraceProbeEventPropertySource.TRACE_EVENT_PROBE_OFFSET_PROPERTY_ID));
  assertEquals(""String_Node_Str"",probeEventSource.getPropertyValue(TraceProbeEventPropertySource.TRACE_EVENT_PROBE_SYMBOL_PROPERTY_ID));
  event=(TraceEventComponent)domains[1].getChildren()[1].getChildren()[0];
  adapter=event.getAdapter(IPropertySource.class);
  assertEquals(""String_Node_Str"",event.getFilterExpression());
  event=(TraceEventComponent)domains[1].getChildren()[1].getChildren()[0];
  adapter=event.getAdapter(IPropertySource.class);
  eventSource=(TraceEventPropertySource)adapter;
  assertEquals(""String_Node_Str"",eventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_LOGLEVEL_PROPERTY_ID));
  event=(TraceEventComponent)domains[1].getChildren()[1].getChildren()[1];
  adapter=event.getAdapter(IPropertySource.class);
  eventSource=(TraceEventPropertySource)adapter;
  assertEquals(""String_Node_Str"",eventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_LOGLEVEL_PROPERTY_ID));
  event=(TraceEventComponent)domains[1].getChildren()[1].getChildren()[2];
  adapter=event.getAdapter(IPropertySource.class);
  eventSource=(TraceEventPropertySource)adapter;
  assertEquals(""String_Node_Str"",eventSource.getPropertyValue(TraceEventPropertySource.TRACE_EVENT_LOGLEVEL_PROPERTY_ID));
  node.disconnect();
  node.getParent().removeChild(node);
}",0.9583227013693968
91880,"@Override public void run(){
  for (int i=0; i < tl.size(); i++) {
    TmfTraceElement traceel=tl.get(i);
    ITmfTrace expTrace=null;
    for (    ITmfTrace t : experiment.getTraces()) {
      if (t.getResource().equals(traceel.getResource())) {
        expTrace=t;
        break;
      }
    }
    try {
      if ((expTrace != null) && syncAlgo.isTraceSynced(expTrace.getHostId())) {
        TmfTraceElement origtrace=traceel.getElementUnderTraceFolder();
        if (origtrace != null) {
          String newname=traceel.getName();
          IContainer parentFolder=origtrace.getResource().getParent();
          boolean traceexists;
          do {
            traceexists=false;
            newname+=""String_Node_Str"";
            if (parentFolder.findMember(newname) != null) {
              traceexists=true;
            }
          }
 while (traceexists);
          TmfTraceElement newtrace=origtrace.copy(newname);
          if (newtrace != null) {
            ITmfTrace trace=newtrace.instantiateTrace();
            ITmfEvent traceEvent=newtrace.instantiateEvent();
            trace.initTrace(newtrace.getResource(),newtrace.getLocation().getPath(),traceEvent.getClass());
            trace.setTimestampTransform(syncAlgo.getTimestampTransform(trace));
            exp.addTrace(newtrace);
            exp.removeTrace(traceel);
          }
 else {
            TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title,Messages.SynchronizeTracesHandler_Error + CR + CR+ String.format(Messages.SynchronizeTracesHandler_CopyProblem,origtrace.getName()));
          }
        }
      }
    }
 catch (    CoreException e) {
      Activator.getDefault().logError(String.format(Messages.SynchronizeTracesHandler_ErrorSynchingForTrace,exp.getName(),traceel.getName()),e);
      TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title,Messages.SynchronizeTracesHandler_Error + CR + CR+ e.getMessage());
    }
catch (    TmfTraceException e) {
      Activator.getDefault().logError(String.format(Messages.SynchronizeTracesHandler_ErrorSynchingForTrace,exp.getName(),traceel.getName()),e);
      TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title,Messages.SynchronizeTracesHandler_Error + CR + CR+ e.getMessage());
    }
  }
}","@Override public void run(){
  List<TmfTraceElement> tracesToAdd=new ArrayList<>();
  List<TmfTraceElement> tracesToRemove=new ArrayList<>();
  for (  TmfTraceElement traceel : tl) {
    ITmfTrace expTrace=null;
    for (    ITmfTrace t : experiment.getTraces()) {
      if (t.getResource().equals(traceel.getResource())) {
        expTrace=t;
        break;
      }
    }
    if ((expTrace != null) && syncAlgo.isTraceSynced(expTrace.getHostId())) {
      TmfTraceElement origtrace=traceel.getElementUnderTraceFolder();
      String newname=traceel.getName();
      IContainer parentFolder=origtrace.getResource().getParent();
      boolean traceexists;
      do {
        traceexists=false;
        newname+=""String_Node_Str"";
        if (parentFolder.findMember(newname) != null) {
          traceexists=true;
        }
      }
 while (traceexists);
      TmfTraceElement newtrace=origtrace.copy(newname);
      if (newtrace == null) {
        TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title,Messages.SynchronizeTracesHandler_Error + CR + CR+ String.format(Messages.SynchronizeTracesHandler_CopyProblem,origtrace.getName()));
        continue;
      }
      ITmfTrace trace=newtrace.instantiateTrace();
      ITmfEvent traceEvent=newtrace.instantiateEvent();
      try {
        trace.initTrace(newtrace.getResource(),newtrace.getLocation().getPath(),traceEvent.getClass());
      }
 catch (      TmfTraceException e) {
        Activator.getDefault().logError(String.format(Messages.SynchronizeTracesHandler_ErrorSynchingForTrace,exp.getName(),traceel.getName()),e);
        TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title,Messages.SynchronizeTracesHandler_Error + CR + CR+ e.getMessage());
      }
      trace.setTimestampTransform(syncAlgo.getTimestampTransform(trace));
      TmfTraceManager.refreshSupplementaryFiles(trace);
      trace.dispose();
      tracesToAdd.add(newtrace);
      tracesToRemove.add(traceel);
    }
  }
  experiment.dispose();
  IFolder tmpFolder=exp.getTraceSupplementaryFolder(""String_Node_Str"");
  IResource syncFile=null;
  for (  IResource resource : exp.getSupplementaryResources()) {
    if (resource.getName().equals(TmfExperiment.SYNCHRONIZATION_FILE_NAME)) {
      try {
        resource.move(tmpFolder.getFile(exp.getName() + '.' + TmfExperiment.SYNCHRONIZATION_FILE_NAME).getFullPath(),false,null);
        syncFile=resource;
        break;
      }
 catch (      CoreException e) {
        Activator.getDefault().logError(String.format(Messages.SynchronizeTracesHandler_ErrorSynchingExperiment,exp.getName()),e);
      }
    }
  }
  for (  TmfTraceElement trace : tracesToRemove) {
    try {
      exp.removeTrace(trace);
    }
 catch (    CoreException e) {
      Activator.getDefault().logError(String.format(Messages.SynchronizeTracesHandler_ErrorSynchingForTrace,exp.getName(),trace.getName()),e);
      TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title,Messages.SynchronizeTracesHandler_Error + CR + CR+ e.getMessage());
    }
  }
  for (  TmfTraceElement trace : tracesToAdd) {
    exp.addTrace(trace);
  }
  IResource resource=tmpFolder.getFile(exp.getName() + '.' + TmfExperiment.SYNCHRONIZATION_FILE_NAME);
  if (resource.exists() && syncFile != null) {
    try {
      resource.move(syncFile.getFullPath(),false,null);
    }
 catch (    CoreException e) {
      Activator.getDefault().logError(String.format(Messages.SynchronizeTracesHandler_ErrorSynchingExperiment,exp.getName()),e);
    }
  }
}",0.520471894517696
91881,"@Override public Object execute(ExecutionEvent event) throws ExecutionException {
  IWorkbenchWindow window=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
  if (window == null) {
    return null;
  }
  IWorkbenchPage page=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
  IWorkbenchPart part=page.getActivePart();
  if (part == null) {
    return Boolean.FALSE;
  }
  ISelectionProvider selectionProvider=part.getSite().getSelectionProvider();
  if (selectionProvider == null) {
    return Boolean.FALSE;
  }
  ISelection selection=selectionProvider.getSelection();
  fSelection=null;
  final ArrayList<TmfTraceElement> tl=new ArrayList<>();
  final ArrayList<TmfExperimentElement> uiexperiment=new ArrayList<>();
  if (selection instanceof TreeSelection) {
    fSelection=(TreeSelection)selection;
    Iterator<Object> iterator=fSelection.iterator();
    while (iterator.hasNext()) {
      Object element=iterator.next();
      if (element instanceof TmfTraceElement) {
        tl.add((TmfTraceElement)element);
      }
 else       if (element instanceof TmfExperimentElement) {
        TmfExperimentElement exp=(TmfExperimentElement)element;
        uiexperiment.add(exp);
        for (        TmfTraceElement trace : exp.getTraces()) {
          tl.add(trace);
        }
      }
    }
  }
  if ((uiexperiment.size() == 1) && (tl.size() > 1)) {
    Thread thread=new Thread(){
      @Override public void run(){
        final ITmfTrace[] traces=new ITmfTrace[tl.size()];
        final TmfExperimentElement exp=uiexperiment.get(0);
        for (int i=0; i < tl.size(); i++) {
          ITmfTrace trace=tl.get(i).instantiateTrace();
          ITmfEvent traceEvent=tl.get(i).instantiateEvent();
          if (trace == null) {
            TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title,Messages.SynchronizeTracesHandler_WrongType + tl.get(i).getName());
            for (int j=0; j < i; j++) {
              traces[j].dispose();
            }
            return;
          }
          try {
            trace.initTrace(tl.get(i).getResource(),tl.get(i).getLocation().getPath(),traceEvent.getClass());
          }
 catch (          TmfTraceException e) {
            TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title,Messages.SynchronizeTracesHandler_InitError + CR + CR+ e);
            trace.dispose();
            for (int j=0; j < i; j++) {
              traces[j].dispose();
            }
            return;
          }
          traces[i]=trace;
        }
        exp.refreshSupplementaryFolder();
        final TmfExperiment experiment=new TmfExperiment(ITmfEvent.class,exp.getName(),traces,exp.getResource());
        try {
          final SynchronizationAlgorithm syncAlgo=experiment.synchronizeTraces(true);
          Display.getDefault().asyncExec(new Runnable(){
            @Override public void run(){
              for (int i=0; i < tl.size(); i++) {
                TmfTraceElement traceel=tl.get(i);
                ITmfTrace expTrace=null;
                for (                ITmfTrace t : experiment.getTraces()) {
                  if (t.getResource().equals(traceel.getResource())) {
                    expTrace=t;
                    break;
                  }
                }
                try {
                  if ((expTrace != null) && syncAlgo.isTraceSynced(expTrace.getHostId())) {
                    TmfTraceElement origtrace=traceel.getElementUnderTraceFolder();
                    if (origtrace != null) {
                      String newname=traceel.getName();
                      IContainer parentFolder=origtrace.getResource().getParent();
                      boolean traceexists;
                      do {
                        traceexists=false;
                        newname+=""String_Node_Str"";
                        if (parentFolder.findMember(newname) != null) {
                          traceexists=true;
                        }
                      }
 while (traceexists);
                      TmfTraceElement newtrace=origtrace.copy(newname);
                      if (newtrace != null) {
                        ITmfTrace trace=newtrace.instantiateTrace();
                        ITmfEvent traceEvent=newtrace.instantiateEvent();
                        trace.initTrace(newtrace.getResource(),newtrace.getLocation().getPath(),traceEvent.getClass());
                        trace.setTimestampTransform(syncAlgo.getTimestampTransform(trace));
                        exp.addTrace(newtrace);
                        exp.removeTrace(traceel);
                      }
 else {
                        TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title,Messages.SynchronizeTracesHandler_Error + CR + CR+ String.format(Messages.SynchronizeTracesHandler_CopyProblem,origtrace.getName()));
                      }
                    }
                  }
                }
 catch (                CoreException e) {
                  Activator.getDefault().logError(String.format(Messages.SynchronizeTracesHandler_ErrorSynchingForTrace,exp.getName(),traceel.getName()),e);
                  TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title,Messages.SynchronizeTracesHandler_Error + CR + CR+ e.getMessage());
                }
catch (                TmfTraceException e) {
                  Activator.getDefault().logError(String.format(Messages.SynchronizeTracesHandler_ErrorSynchingForTrace,exp.getName(),traceel.getName()),e);
                  TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title,Messages.SynchronizeTracesHandler_Error + CR + CR+ e.getMessage());
                }
              }
            }
          }
);
        }
 catch (        TmfTraceException e) {
          Activator.getDefault().logError(String.format(Messages.SynchronizeTracesHandler_ErrorSynchingExperiment,exp.getName()),e);
          TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title,Messages.SynchronizeTracesHandler_Error + CR + CR+ e.getMessage());
        }
      }
    }
;
    thread.start();
  }
 else {
    TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title,Messages.SynchronizeTracesHandler_WrongTraceNumber);
  }
  return null;
}","@Override public Object execute(ExecutionEvent event) throws ExecutionException {
  IWorkbenchWindow window=PlatformUI.getWorkbench().getActiveWorkbenchWindow();
  if (window == null) {
    return null;
  }
  IWorkbenchPage page=PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
  IWorkbenchPart part=page.getActivePart();
  if (part == null) {
    return Boolean.FALSE;
  }
  ISelectionProvider selectionProvider=part.getSite().getSelectionProvider();
  if (selectionProvider == null) {
    return Boolean.FALSE;
  }
  ISelection selection=selectionProvider.getSelection();
  fSelection=null;
  final ArrayList<TmfTraceElement> tl=new ArrayList<>();
  final ArrayList<TmfExperimentElement> uiexperiment=new ArrayList<>();
  if (selection instanceof TreeSelection) {
    fSelection=(TreeSelection)selection;
    Iterator<Object> iterator=fSelection.iterator();
    while (iterator.hasNext()) {
      Object element=iterator.next();
      if (element instanceof TmfTraceElement) {
        tl.add((TmfTraceElement)element);
      }
 else       if (element instanceof TmfExperimentElement) {
        TmfExperimentElement exp=(TmfExperimentElement)element;
        uiexperiment.add(exp);
        for (        TmfTraceElement trace : exp.getTraces()) {
          tl.add(trace);
        }
      }
    }
  }
  if ((uiexperiment.size() != 1) || (tl.size() < 2)) {
    TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title,Messages.SynchronizeTracesHandler_WrongTraceNumber);
    return null;
  }
  Thread thread=new Thread(){
    @Override public void run(){
      final ITmfTrace[] traces=new ITmfTrace[tl.size()];
      final TmfExperimentElement exp=uiexperiment.get(0);
      for (int i=0; i < tl.size(); i++) {
        ITmfTrace trace=tl.get(i).instantiateTrace();
        ITmfEvent traceEvent=tl.get(i).instantiateEvent();
        if (trace == null) {
          TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title,Messages.SynchronizeTracesHandler_WrongType + tl.get(i).getName());
          for (int j=0; j < i; j++) {
            traces[j].dispose();
          }
          return;
        }
        try {
          trace.initTrace(tl.get(i).getResource(),tl.get(i).getLocation().getPath(),traceEvent.getClass());
          TmfTraceManager.refreshSupplementaryFiles(trace);
        }
 catch (        TmfTraceException e) {
          TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title,Messages.SynchronizeTracesHandler_InitError + CR + CR+ e);
          trace.dispose();
          for (int j=0; j < i; j++) {
            traces[j].dispose();
          }
          return;
        }
        traces[i]=trace;
      }
      exp.refreshSupplementaryFolder();
      final TmfExperiment experiment=new TmfExperiment(ITmfEvent.class,exp.getName(),traces,exp.getResource());
      try {
        final SynchronizationAlgorithm syncAlgo=experiment.synchronizeTraces(true);
        TmfTraceManager.refreshSupplementaryFiles(experiment);
        Display.getDefault().asyncExec(new Runnable(){
          @Override public void run(){
            List<TmfTraceElement> tracesToAdd=new ArrayList<>();
            List<TmfTraceElement> tracesToRemove=new ArrayList<>();
            for (            TmfTraceElement traceel : tl) {
              ITmfTrace expTrace=null;
              for (              ITmfTrace t : experiment.getTraces()) {
                if (t.getResource().equals(traceel.getResource())) {
                  expTrace=t;
                  break;
                }
              }
              if ((expTrace != null) && syncAlgo.isTraceSynced(expTrace.getHostId())) {
                TmfTraceElement origtrace=traceel.getElementUnderTraceFolder();
                String newname=traceel.getName();
                IContainer parentFolder=origtrace.getResource().getParent();
                boolean traceexists;
                do {
                  traceexists=false;
                  newname+=""String_Node_Str"";
                  if (parentFolder.findMember(newname) != null) {
                    traceexists=true;
                  }
                }
 while (traceexists);
                TmfTraceElement newtrace=origtrace.copy(newname);
                if (newtrace == null) {
                  TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title,Messages.SynchronizeTracesHandler_Error + CR + CR+ String.format(Messages.SynchronizeTracesHandler_CopyProblem,origtrace.getName()));
                  continue;
                }
                ITmfTrace trace=newtrace.instantiateTrace();
                ITmfEvent traceEvent=newtrace.instantiateEvent();
                try {
                  trace.initTrace(newtrace.getResource(),newtrace.getLocation().getPath(),traceEvent.getClass());
                }
 catch (                TmfTraceException e) {
                  Activator.getDefault().logError(String.format(Messages.SynchronizeTracesHandler_ErrorSynchingForTrace,exp.getName(),traceel.getName()),e);
                  TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title,Messages.SynchronizeTracesHandler_Error + CR + CR+ e.getMessage());
                }
                trace.setTimestampTransform(syncAlgo.getTimestampTransform(trace));
                TmfTraceManager.refreshSupplementaryFiles(trace);
                trace.dispose();
                tracesToAdd.add(newtrace);
                tracesToRemove.add(traceel);
              }
            }
            experiment.dispose();
            IFolder tmpFolder=exp.getTraceSupplementaryFolder(""String_Node_Str"");
            IResource syncFile=null;
            for (            IResource resource : exp.getSupplementaryResources()) {
              if (resource.getName().equals(TmfExperiment.SYNCHRONIZATION_FILE_NAME)) {
                try {
                  resource.move(tmpFolder.getFile(exp.getName() + '.' + TmfExperiment.SYNCHRONIZATION_FILE_NAME).getFullPath(),false,null);
                  syncFile=resource;
                  break;
                }
 catch (                CoreException e) {
                  Activator.getDefault().logError(String.format(Messages.SynchronizeTracesHandler_ErrorSynchingExperiment,exp.getName()),e);
                }
              }
            }
            for (            TmfTraceElement trace : tracesToRemove) {
              try {
                exp.removeTrace(trace);
              }
 catch (              CoreException e) {
                Activator.getDefault().logError(String.format(Messages.SynchronizeTracesHandler_ErrorSynchingForTrace,exp.getName(),trace.getName()),e);
                TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title,Messages.SynchronizeTracesHandler_Error + CR + CR+ e.getMessage());
              }
            }
            for (            TmfTraceElement trace : tracesToAdd) {
              exp.addTrace(trace);
            }
            IResource resource=tmpFolder.getFile(exp.getName() + '.' + TmfExperiment.SYNCHRONIZATION_FILE_NAME);
            if (resource.exists() && syncFile != null) {
              try {
                resource.move(syncFile.getFullPath(),false,null);
              }
 catch (              CoreException e) {
                Activator.getDefault().logError(String.format(Messages.SynchronizeTracesHandler_ErrorSynchingExperiment,exp.getName()),e);
              }
            }
          }
        }
);
      }
 catch (      TmfTraceException e) {
        Activator.getDefault().logError(String.format(Messages.SynchronizeTracesHandler_ErrorSynchingExperiment,exp.getName()),e);
        TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title,Messages.SynchronizeTracesHandler_Error + CR + CR+ e.getMessage());
      }
    }
  }
;
  thread.start();
  return null;
}",0.7189505204619991
91882,"/** 
 * Copy this trace in the trace folder. No other parameters are mentioned so the trace is copied in this element's project trace folder
 * @param string The new trace name
 * @return the new Resource object
 * @since 2.0
 */
public TmfTraceElement copy(String string){
  TmfTraceFolder folder=this.getProject().getTracesFolder();
  IResource res=super.copy(string,false);
  return new TmfTraceElement(string,res,folder);
}","/** 
 * Copy this trace in the trace folder. No other parameters are mentioned so the trace is copied in this element's project trace folder
 * @param newName The new trace name
 * @return the new Resource object
 * @since 2.0
 */
public TmfTraceElement copy(String newName){
  TmfTraceFolder folder=(TmfTraceFolder)getParent();
  IResource res=super.copy(newName,false);
  for (  TmfTraceElement trace : folder.getTraces()) {
    if (trace.getResource().equals(res)) {
      return trace;
    }
  }
  return null;
}",0.5853658536585366
91883,"private static void openTraceIfNecessary(IProject project){
  String traceToOpen=TracingRcpPlugin.getDefault().getCli().getArgument(CliParser.OPEN_FILE_LOCATION);
  if (traceToOpen != null) {
    try {
      TmfTraceFolder destinationFolder=TmfProjectRegistry.getProject(project).getTracesFolder();
      TmfOpenTraceHelper.openTraceFromPath(destinationFolder,traceToOpen,TracingRcpPlugin.getDefault().getWorkbench().getActiveWorkbenchWindow().getShell());
    }
 catch (    CoreException e) {
      TracingRcpPlugin.getDefault().logError(e.getMessage());
    }
  }
}","private static void openTraceIfNecessary(IProject project){
  String traceToOpen=TracingRcpPlugin.getDefault().getCli().getArgument(CliParser.OPEN_FILE_LOCATION);
  if (traceToOpen != null) {
    try {
      TmfTraceFolder destinationFolder=TmfProjectRegistry.getProject(project,true).getTracesFolder();
      TmfOpenTraceHelper.openTraceFromPath(destinationFolder,traceToOpen,TracingRcpPlugin.getDefault().getWorkbench().getActiveWorkbenchWindow().getShell());
    }
 catch (    CoreException e) {
      TracingRcpPlugin.getDefault().logError(e.getMessage());
    }
  }
}",0.9956101843722563
91884,"private static ITmfTrace openTraceElement(final TmfTraceElement traceElement){
  final ITmfTrace trace=traceElement.instantiateTrace();
  final ITmfEvent traceEvent=traceElement.instantiateEvent();
  if ((trace == null) || (traceEvent == null)) {
    TraceUtils.displayErrorMsg(NLS.bind(Messages.TmfOpenTraceHelper_OpenElement,traceElement.getTypeName()),NLS.bind(Messages.TmfOpenTraceHelper_NoTraceOrExperimentType,traceElement.getTypeName()));
    if (trace != null) {
      trace.dispose();
    }
    return null;
  }
  try {
    trace.initTrace(traceElement.getResource(),traceElement.getLocation().getPath(),traceEvent.getClass(),traceElement.getElementPath());
  }
 catch (  final TmfTraceException e) {
    TraceUtils.displayErrorMsg(NLS.bind(Messages.TmfOpenTraceHelper_OpenElement,traceElement.getTypeName()),Messages.TmfOpenTraceHelper_InitError + ENDL + ENDL+ e);
    trace.dispose();
    return null;
  }
  return trace;
}","private static ITmfTrace openTraceElement(final TmfTraceElement traceElement){
  final ITmfTrace trace=traceElement.instantiateTrace();
  final ITmfEvent traceEvent=traceElement.instantiateEvent();
  if ((trace == null) || (traceEvent == null)) {
    TraceUtils.displayErrorMsg(NLS.bind(Messages.TmfOpenTraceHelper_OpenElement,traceElement.getTypeName()),Messages.TmfOpenTraceHelper_NoTraceType);
    if (trace != null) {
      trace.dispose();
    }
    return null;
  }
  try {
    trace.initTrace(traceElement.getResource(),traceElement.getLocation().getPath(),traceEvent.getClass(),traceElement.getElementPath());
  }
 catch (  final TmfTraceException e) {
    TraceUtils.displayErrorMsg(NLS.bind(Messages.TmfOpenTraceHelper_OpenElement,traceElement.getTypeName()),Messages.TmfOpenTraceHelper_InitError + ENDL + ENDL+ e);
    trace.dispose();
    return null;
  }
  return trace;
}",0.9730621220450796
91885,"/** 
 * Gets a callsite using the event name and instruction pointer O(log(n))
 * @param eventName the name of the event
 * @param ip the instruction pointer
 * @return the closest matching callsite, can be null
 */
public CTFCallsite getCallsite(String eventName,long ip){
  final TreeSet<CTFCallsite> candidates=fCallsitesByName.get(eventName);
  final CTFCallsite dummyCs=new CTFCallsite(null,null,ip,null,-1);
  final CTFCallsite callsite=candidates.ceiling(dummyCs);
  if (callsite == null) {
    return candidates.floor(dummyCs);
  }
  return callsite;
}","/** 
 * Gets a callsite using the event name and instruction pointer O(log(n))
 * @param eventName the name of the event
 * @param ip the instruction pointer
 * @return the closest matching callsite, can be null
 */
public CTFCallsite getCallsite(String eventName,long ip){
  final TreeSet<CTFCallsite> candidates=fCallsitesByName.get(eventName);
  if (candidates == null) {
    return null;
  }
  final CTFCallsite dummyCs=new CTFCallsite(null,null,ip,null,-1);
  final CTFCallsite callsite=candidates.ceiling(dummyCs);
  if (callsite == null) {
    return candidates.floor(dummyCs);
  }
  return callsite;
}",0.9580838323353292
91886,"@Override protected Control createDialogArea(Composite parent){
  fDialogComposite=new Composite(parent,SWT.NONE);
  GridLayout layout=new GridLayout(1,true);
  fDialogComposite.setLayout(layout);
  fDialogComposite.setLayoutData(new GridData(GridData.FILL_BOTH));
  Group domainGroup=new Group(fDialogComposite,SWT.SHADOW_NONE);
  domainGroup.setText(Messages.TraceControl_DomainDisplayName);
  layout=new GridLayout(2,true);
  domainGroup.setLayout(layout);
  fKernelButton=new Button(domainGroup,SWT.RADIO);
  fKernelButton.setText(Messages.TraceControl_KernelDomainDisplayName);
  fKernelButton.setSelection(fIsKernel);
  fUstButton=new Button(domainGroup,SWT.RADIO);
  fUstButton.setText(Messages.TraceControl_UstDisplayName);
  fUstButton.setSelection(!fIsKernel);
  if ((fDomain != null) || ((fProviderGroup != null) && (!fProviderGroup.hasKernelProvider()))) {
    fKernelButton.setEnabled(false);
    fUstButton.setEnabled(false);
  }
  GridData data=new GridData(GridData.FILL_HORIZONTAL);
  domainGroup.setLayoutData(data);
  data=new GridData(SWT.BEGINNING,SWT.BEGINNING,true,true);
  fKernelButton.setLayoutData(data);
  data=new GridData(SWT.BEGINNING,SWT.BEGINNING,true,true);
  fUstButton.setLayoutData(data);
  fUstComposite=null;
  fKernelComposite=null;
  if (fIsKernel) {
    createKernelComposite();
    fUstComposite=null;
  }
 else {
    createUstComposite();
  }
  fKernelButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      if (fKernelButton.getSelection()) {
        disposeUstComposite();
        createKernelComposite();
        fDialogComposite.layout();
      }
    }
  }
);
  fUstButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      if (fUstButton.getSelection()) {
        disposeKernelComposite();
        createUstComposite();
        fDialogComposite.layout();
      }
    }
  }
);
  fDialogComposite.layout();
  getShell().setMinimumSize(new Point(500,650));
  return fDialogComposite;
}","@Override protected Control createDialogArea(Composite parent){
  fDialogComposite=new Composite(parent,SWT.NONE);
  GridLayout layout=new GridLayout(1,true);
  fDialogComposite.setLayout(layout);
  fDialogComposite.setLayoutData(new GridData(GridData.FILL_BOTH));
  Group domainGroup=new Group(fDialogComposite,SWT.SHADOW_NONE);
  domainGroup.setText(Messages.TraceControl_DomainDisplayName);
  layout=new GridLayout(2,true);
  domainGroup.setLayout(layout);
  fKernelButton=new Button(domainGroup,SWT.RADIO);
  fKernelButton.setText(Messages.TraceControl_KernelDomainDisplayName);
  fKernelButton.setSelection(fIsKernel);
  fUstButton=new Button(domainGroup,SWT.RADIO);
  fUstButton.setText(Messages.TraceControl_UstDisplayName);
  fUstButton.setSelection(!fIsKernel);
  if ((fDomain != null) || ((fProviderGroup != null) && (!fProviderGroup.hasKernelProvider()))) {
    fKernelButton.setEnabled(false);
    fUstButton.setEnabled(false);
  }
  GridData data=new GridData(GridData.FILL_HORIZONTAL);
  domainGroup.setLayoutData(data);
  data=new GridData(SWT.BEGINNING,SWT.BEGINNING,true,true);
  fKernelButton.setLayoutData(data);
  data=new GridData(SWT.BEGINNING,SWT.BEGINNING,true,true);
  fUstButton.setLayoutData(data);
  fUstComposite=null;
  fKernelComposite=null;
  if (fIsKernel) {
    createKernelComposite();
    fUstComposite=null;
  }
 else {
    createUstComposite();
  }
  fKernelButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      if (fKernelButton.getSelection()) {
        disposeUstComposite();
        createKernelComposite();
        fDialogComposite.layout();
      }
    }
  }
);
  fUstButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      if (fUstButton.getSelection()) {
        disposeKernelComposite();
        createUstComposite();
        fDialogComposite.layout();
      }
    }
  }
);
  getShell().setMinimumSize(new Point(500,650));
  return fDialogComposite;
}",0.9929147324700708
91887,"/** 
 * Set the trace type of a   {@Link TraceTypeHelper}. Should only be used internally by this project.
 * @param resource the resource to set
 * @param traceType the  {@link TraceTypeHelper} to set the trace type to.
 * @return Status.OK_Status if successful, error is otherwise.
 * @throws CoreException An exception caused by accessing eclipse project items.
 */
public static IStatus setTraceType(IResource resource,TraceTypeHelper traceType) throws CoreException {
  String traceTypeId=traceType.getCanonicalName();
  resource.setPersistentProperty(TmfCommonConstants.TRACETYPE,traceTypeId);
  TmfProjectElement tmfProject=TmfProjectRegistry.getProject(resource.getProject(),true);
  if (resource.getParent().equals(tmfProject.getTracesFolder().getResource())) {
    refreshTraceElement(tmfProject.getTracesFolder().getTraces(),resource.getName());
  }
 else {
    for (    TmfExperimentElement experimentElement : tmfProject.getExperimentsFolder().getExperiments()) {
      if (resource.getParent().equals(experimentElement.getResource())) {
        refreshTraceElement(experimentElement.getTraces(),resource.getName());
        break;
      }
    }
  }
  tmfProject.refresh();
  return Status.OK_STATUS;
}","/** 
 * Set the trace type of a   {@Link TraceTypeHelper}. Should only be used internally by this project.
 * @param resource the resource to set
 * @param traceType the  {@link TraceTypeHelper} to set the trace type to.
 * @return Status.OK_Status if successful, error is otherwise.
 * @throws CoreException An exception caused by accessing eclipse project items.
 */
public static IStatus setTraceType(IResource resource,TraceTypeHelper traceType) throws CoreException {
  String traceTypeId=traceType.getCanonicalName();
  resource.setPersistentProperty(TmfCommonConstants.TRACETYPE,traceTypeId);
  TmfProjectElement tmfProject=TmfProjectRegistry.getProject(resource.getProject(),true);
  if (resource.getParent().equals(tmfProject.getTracesFolder().getResource())) {
    refreshTraceElement(tmfProject.getTracesFolder().getTraces(),resource.getName());
  }
 else   if (resource.getParent().equals(tmfProject.getExperimentsFolder().getResource())) {
    for (    TmfExperimentElement experimentElement : tmfProject.getExperimentsFolder().getExperiments()) {
      if (resource.equals(experimentElement.getResource())) {
        experimentElement.refreshTraceType();
        break;
      }
    }
  }
 else {
    for (    TmfExperimentElement experimentElement : tmfProject.getExperimentsFolder().getExperiments()) {
      if (resource.getParent().equals(experimentElement.getResource())) {
        refreshTraceElement(experimentElement.getTraces(),resource.getName());
        break;
      }
    }
  }
  tmfProject.refresh();
  return Status.OK_STATUS;
}",0.8769397329483941
91888,"/** 
 * Test the   {@link XmlUtils#getChildElements(Element)} and{@link XmlUtils#getChildElements(Element,String)} methods
 */
@Test public void testGetChildElements(){
  File testXmlFile=TmfXmlTestFiles.VALID_FILE.getFile();
  if ((testXmlFile == null) || !testXmlFile.exists()) {
    fail(""String_Node_Str"");
  }
  if (testXmlFile == null) {
    return;
  }
  Element analysis=XmlUtils.getElementInFile(testXmlFile.getAbsolutePath(),TmfXmlStrings.STATE_PROVIDER,ANALYSIS_ID);
  List<Element> values=XmlUtils.getChildElements(analysis,TmfXmlStrings.DEFINED_VALUE);
  assertEquals(12,values.size());
  values=XmlUtils.getChildElements(analysis,TmfXmlStrings.HEAD);
  assertEquals(1,values.size());
  Element head=values.get(0);
  values=XmlUtils.getChildElements(head);
  assertEquals(2,values.size());
}","/** 
 * Test the   {@link XmlUtils#getChildElements(Element)} and{@link XmlUtils#getChildElements(Element,String)} methods
 */
@Test public void testGetChildElements(){
  File testXmlFile=TmfXmlTestFiles.VALID_FILE.getFile();
  if ((testXmlFile == null) || !testXmlFile.exists()) {
    fail(""String_Node_Str"");
  }
  if (testXmlFile == null) {
    return;
  }
  Element analysis=XmlUtils.getElementInFile(testXmlFile.getAbsolutePath(),TmfXmlStrings.STATE_PROVIDER,ANALYSIS_ID);
  List<Element> values=XmlUtils.getChildElements(analysis,TmfXmlStrings.LOCATION);
  assertEquals(5,values.size());
  Element aLocation=values.get(0);
  List<Element> attributes=XmlUtils.getChildElements(aLocation,TmfXmlStrings.STATE_ATTRIBUTE);
  assertEquals(2,attributes.size());
  values=XmlUtils.getChildElements(analysis,TmfXmlStrings.HEAD);
  assertEquals(1,values.size());
  Element head=values.get(0);
  values=XmlUtils.getChildElements(head);
  assertEquals(2,values.size());
}",0.6659129451667609
91889,"/** 
 * Get the XML children element of an XML element, but only those of a certain type
 * @param parent The parent element to get the children from
 * @param elementTag The tag of the elements to return
 * @return The list of children {@link Element} of the parent
 */
public static List<Element> getChildElements(Element parent,String elementTag){
  NodeList nodes=parent.getElementsByTagName(elementTag);
  List<Element> childElements=new ArrayList<>();
  for (int i=0; i < nodes.getLength(); i++) {
    Element node=(Element)nodes.item(i);
    childElements.add(node);
  }
  return childElements;
}","/** 
 * Get the XML children element of an XML element, but only those of a certain type
 * @param parent The parent element to get the children from
 * @param elementTag The tag of the elements to return
 * @return The list of children {@link Element} of the parent
 */
public static List<Element> getChildElements(Element parent,String elementTag){
  NodeList nodes=parent.getElementsByTagName(elementTag);
  List<Element> childElements=new ArrayList<>();
  for (int i=0; i < nodes.getLength(); i++) {
    Element node=(Element)nodes.item(i);
    if (node.getParentNode().equals(parent)) {
      childElements.add(node);
    }
  }
  return childElements;
}",0.9357652656621728
91890,"@Override public void run(){
  if (entries != fTreeViewer.getInput()) {
    fTreeViewer.setInput(entries);
  }
 else {
    fTreeViewer.refresh();
  }
  for (  TreeColumn column : fTreeViewer.getTree().getColumns()) {
    column.pack();
  }
}","@Override public void run(){
  if (rootEntry != fTreeViewer.getInput()) {
    fTreeViewer.setInput(rootEntry);
  }
 else {
    fTreeViewer.refresh();
  }
  for (  TreeColumn column : fTreeViewer.getTree().getColumns()) {
    column.pack();
  }
}",0.934156378600823
91891,"/** 
 * Get the current input displayed by the viewer
 * @return The input of the tree viewer
 */
protected Object getInput(){
  return fTreeViewer.getInput();
}","/** 
 * Get the current input displayed by the viewer
 * @return The input of the tree viewer, the root entry
 */
protected ITmfTreeViewerEntry getInput(){
  return (ITmfTreeViewerEntry)fTreeViewer.getInput();
}",0.8333333333333334
91892,"@Override public Object[] getElements(Object inputElement){
  if (inputElement != null) {
    try {
      return ((List<?>)inputElement).toArray(new ITmfTreeViewerEntry[0]);
    }
 catch (    ClassCastException e) {
    }
  }
  return new ITmfTreeViewerEntry[0];
}","@Override public Object[] getElements(Object inputElement){
  if (inputElement instanceof ITmfTreeViewerEntry) {
    return ((ITmfTreeViewerEntry)inputElement).getChildren().toArray(new ITmfTreeViewerEntry[0]);
  }
  return new ITmfTreeViewerEntry[0];
}",0.6499032882011605
91893,"/** 
 * Requests an update of the viewer's content in a given time range or selection time range. An extra parameter defines whether these times correspond to the selection or the visible range, as the viewer may update differently in those cases.
 * @param start The start time of the requested content
 * @param end The end time of the requested content
 * @param isSelection <code>true</code> if this time range is for a selection, <code>false</code> for the visible time range
 */
protected void updateContent(final long start,final long end,final boolean isSelection){
  Thread thread=new Thread(){
    @Override public void run(){
      final List<ITmfTreeViewerEntry> entries=updateElements(start,end,isSelection);
      if (entries != null) {
        Display.getDefault().asyncExec(new Runnable(){
          @Override public void run(){
            if (entries != fTreeViewer.getInput()) {
              fTreeViewer.setInput(entries);
            }
 else {
              fTreeViewer.refresh();
            }
            for (            TreeColumn column : fTreeViewer.getTree().getColumns()) {
              column.pack();
            }
          }
        }
);
      }
    }
  }
;
  thread.start();
}","/** 
 * Requests an update of the viewer's content in a given time range or selection time range. An extra parameter defines whether these times correspond to the selection or the visible range, as the viewer may update differently in those cases.
 * @param start The start time of the requested content
 * @param end The end time of the requested content
 * @param isSelection <code>true</code> if this time range is for a selection, <code>false</code> for the visible time range
 */
protected void updateContent(final long start,final long end,final boolean isSelection){
  Thread thread=new Thread(){
    @Override public void run(){
      final ITmfTreeViewerEntry rootEntry=updateElements(start,end,isSelection);
      if (rootEntry != null) {
        Display.getDefault().asyncExec(new Runnable(){
          @Override public void run(){
            if (rootEntry != fTreeViewer.getInput()) {
              fTreeViewer.setInput(rootEntry);
            }
 else {
              fTreeViewer.refresh();
            }
            for (            TreeColumn column : fTreeViewer.getTree().getColumns()) {
              column.pack();
            }
          }
        }
);
      }
    }
  }
;
  thread.start();
}",0.9702725020644096
91894,"/** 
 * Update the entries to the given start/end time. An extra parameter defines whether these times correspond to the selection or the visible range, as the viewer may update differently in those cases. If no update is necessary, the method should return <code>null</code>. To empty the tree, an empty list should be returned. This method is not called in the UI thread when using the default viewer content update. Resource-intensive calculations here should not block the UI.
 * @param start The start time of the requested content
 * @param end The end time of the requested content
 * @param isSelection <code>true</code> if this time range is for a selection, <code>false</code> for the visible time range
 * @return The list of entries to display or <code>null</code> if no updatenecessary
 */
protected abstract List<ITmfTreeViewerEntry> updateElements(long start,long end,boolean isSelection);","/** 
 * Update the entries to the given start/end time. An extra parameter defines whether these times correspond to the selection or the visible range, as the viewer may update differently in those cases. This methods returns a root node that is not meant to be visible. The children of this 'fake' root node are the first level of entries that will appear in the tree. If no update is necessary, the method should return <code>null</code>. To empty the tree, a root node containing an empty list of children should be returned. This method is not called in the UI thread when using the default viewer content update. Resource-intensive calculations here should not block the UI.
 * @param start The start time of the requested content
 * @param end The end time of the requested content
 * @param isSelection <code>true</code> if this time range is for a selection, <code>false</code> for the visible time range
 * @return The root entry of the list of entries to display or<code>null</code> if no update necessary
 */
protected abstract ITmfTreeViewerEntry updateElements(long start,long end,boolean isSelection);",0.8623762376237624
91895,"/** 
 * Returns the child elements of this entry.
 * @return an array of child elements
 */
List<? extends ITmfTreeViewerEntry> getChildren();","/** 
 * Returns the child elements of this entry.
 * @return an array of child elements
 */
@NonNull List<? extends ITmfTreeViewerEntry> getChildren();",0.969283276450512
91896,"private List<ITmfTreeViewerEntry> updateEntriesList(List<ITmfTreeViewerEntry> entries,long timestamp){
  for (  final ITmfTrace trace : TmfTraceManager.getTraceSet(getTrace())) {
    if (trace == null) {
      continue;
    }
    ITmfTreeViewerEntry traceEntry=null;
    for (    ITmfTreeViewerEntry entry : entries) {
      if (entry.getName().equals(trace.getName())) {
        traceEntry=entry;
      }
    }
    if (traceEntry == null) {
      traceEntry=buildEntriesForTrace(trace,timestamp,entries);
    }
    Iterable<ITmfAnalysisModuleWithStateSystems> modules=trace.getAnalysisModulesOfClass(ITmfAnalysisModuleWithStateSystems.class);
    for (    ITmfAnalysisModuleWithStateSystems module : modules) {
      module.schedule();
      for (      ITmfStateSystem ss : module.getStateSystems()) {
        if (ss == null) {
          continue;
        }
        ITmfTreeViewerEntry ssEntry=null;
        for (        ITmfTreeViewerEntry entry : traceEntry.getChildren()) {
          if (entry.getName().equals(ss.getSSID())) {
            ssEntry=entry;
          }
        }
        if (ssEntry == null) {
          buildEntriesForStateSystem(ss,timestamp,(TmfTreeViewerEntry)traceEntry);
        }
 else         if (ssEntry.hasChildren()) {
          updateEntriesForStateSystem(ss,timestamp,(TmfTreeViewerEntry)ssEntry);
        }
 else {
          fillEntriesForStateSystem(ss,timestamp,(TmfTreeViewerEntry)ssEntry);
        }
      }
    }
  }
  return entries;
}","private void updateEntriesList(List<ITmfTreeViewerEntry> entries,long timestamp){
  for (  final ITmfTrace trace : TmfTraceManager.getTraceSet(getTrace())) {
    if (trace == null) {
      continue;
    }
    ITmfTreeViewerEntry traceEntry=null;
    for (    ITmfTreeViewerEntry entry : entries) {
      if (entry.getName().equals(trace.getName())) {
        traceEntry=entry;
      }
    }
    if (traceEntry == null) {
      traceEntry=buildEntriesForTrace(trace,timestamp,entries);
    }
    Iterable<ITmfAnalysisModuleWithStateSystems> modules=trace.getAnalysisModulesOfClass(ITmfAnalysisModuleWithStateSystems.class);
    for (    ITmfAnalysisModuleWithStateSystems module : modules) {
      module.schedule();
      for (      ITmfStateSystem ss : module.getStateSystems()) {
        if (ss == null) {
          continue;
        }
        ITmfTreeViewerEntry ssEntry=null;
        for (        ITmfTreeViewerEntry entry : traceEntry.getChildren()) {
          if (entry.getName().equals(ss.getSSID())) {
            ssEntry=entry;
          }
        }
        if (ssEntry == null) {
          buildEntriesForStateSystem(ss,timestamp,(TmfTreeViewerEntry)traceEntry);
        }
 else         if (ssEntry.hasChildren()) {
          updateEntriesForStateSystem(ss,timestamp,(TmfTreeViewerEntry)ssEntry);
        }
 else {
          fillEntriesForStateSystem(ss,timestamp,(TmfTreeViewerEntry)ssEntry);
        }
      }
    }
  }
}",0.3405572755417956
91897,"@Override protected List<ITmfTreeViewerEntry> updateElements(long start,long end,boolean selection){
  if (getTrace() == null) {
    return null;
  }
  List<ITmfTreeViewerEntry> entries=(List<ITmfTreeViewerEntry>)getInput();
  if ((!selection) && (entries != null)) {
    return null;
  }
  if (entries == null || fFilterStatus) {
    entries=buildEntriesList(start);
  }
 else {
    entries=updateEntriesList(entries,start);
  }
  return entries;
}","@Override protected ITmfTreeViewerEntry updateElements(long start,long end,boolean selection){
  if (getTrace() == null) {
    return null;
  }
  ITmfTreeViewerEntry root=getInput();
  if ((!selection) && (root != null)) {
    return null;
  }
  if (root == null || fFilterStatus) {
    root=buildEntries(start);
  }
 else   if (root instanceof TmfTreeViewerEntry) {
    updateEntriesList(((TmfTreeViewerEntry)root).getChildren(),start);
  }
  return root;
}",0.6725468577728776
91898,"/** 
 * Run the Long getLocation() method test.
 */
@Test public void testGetLocation(){
  CtfLocationInfo location=fixture.getLocationInfo();
  Long result=location.getTimestamp();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals((byte)1,result.byteValue());
  assertEquals((short)1,result.shortValue());
  assertEquals(1,result.intValue());
  assertEquals(1L,result.longValue());
  assertEquals(1.0f,result.floatValue(),1.0f);
  assertEquals(1.0,result.doubleValue(),1.0);
}","/** 
 * Run the Long getLocation() method test.
 */
@Test public void testGetLocation(){
  CtfLocationInfo location=fixture.getLocationInfo();
  long result=location.getTimestamp();
  assertEquals(1L,result);
}",0.5671232876712329
91899,"/** 
 * Run the CtfLocation(ITmfTimestamp) constructor test.
 */
@Test public void testCtfLocation_timestamp(){
  ITmfTimestamp timestamp=new TmfTimestamp();
  CtfLocation result=new CtfLocation(timestamp);
  assertNotNull(result);
  assertEquals(new Long(0L),(Long)result.getLocationInfo().getTimestamp());
}","/** 
 * Run the CtfLocation(ITmfTimestamp) constructor test.
 */
@Test public void testCtfLocation_timestamp(){
  ITmfTimestamp timestamp=new TmfTimestamp();
  CtfLocation result=new CtfLocation(timestamp);
  assertNotNull(result);
  assertEquals(0L,result.getLocationInfo().getTimestamp());
}",0.973421926910299
91900,"/** 
 * Run the CtfLocation(Long) constructor test.
 */
@Test public void testCtfLocation_long(){
  CtfLocationInfo location=new CtfLocationInfo(1,0);
  CtfLocation result=new CtfLocation(location);
  assertNotNull(result);
  assertEquals(Long.valueOf(1),(Long)result.getLocationInfo().getTimestamp());
}","/** 
 * Run the CtfLocation(Long) constructor test.
 */
@Test public void testCtfLocation_long(){
  CtfLocationInfo location=new CtfLocationInfo(1,0);
  CtfLocation result=new CtfLocation(location);
  assertNotNull(result);
  assertEquals(1L,result.getLocationInfo().getTimestamp());
}",0.9643463497453312
91901,"/** 
 * Context fuzzer. Use an amount of contexts greater than the size of the iterator cache and have them access the trace in parallel.
 * @throws InterruptedException Would fail the test
 */
@Test public void testTooManyContexts() throws InterruptedException {
  final int lwcCount=101;
  double increment=(end - begin) / lwcCount;
  final ArrayList<Long> vals=new ArrayList<>();
  final ArrayList<Thread> threads=new ArrayList<>();
  final ArrayList<CtfTmfContext> tooManyContexts=new ArrayList<>();
  for (double i=begin; i < end; i+=increment) {
    SeekerThread thread=new SeekerThread(){
      @Override public void run(){
        CtfTmfContext lwc=new CtfTmfContext(trace);
        lwc.seek(val);
        trace.getNext(lwc);
synchronized (trace) {
          if (lwc.getCurrentEvent() != null) {
            vals.add(lwc.getCurrentEvent().getTimestamp().getValue());
          }
          tooManyContexts.add(lwc);
        }
      }
    }
;
    thread.setVal((long)i);
    threads.add(thread);
    thread.start();
  }
  for (  Thread t : threads) {
    t.join();
  }
  for (  Long val : vals) {
    assertTrue(val >= begin);
    assertTrue(val <= end);
  }
}","/** 
 * Context fuzzer. Use an amount of contexts greater than the size of the iterator cache and have them access the trace in parallel.
 * @throws InterruptedException Would fail the test
 */
@Test public void testTooManyContexts() throws InterruptedException {
  final int lwcCount=101;
  double increment=(end - begin) / lwcCount;
  final ArrayList<Long> vals=new ArrayList<>();
  final ArrayList<Thread> threads=new ArrayList<>();
  final ArrayList<CtfTmfContext> tooManyContexts=new ArrayList<>();
  for (double i=begin; i < end; i+=increment) {
    SeekerThread thread=new SeekerThread(){
      @Override public void run(){
        CtfTmfContext lwc=new CtfTmfContext(trace);
        lwc.seek(val);
        trace.getNext(lwc);
synchronized (trace) {
          if (lwc.getCurrentEvent() != null) {
            vals.add(lwc.getCurrentEvent().getTimestamp().getValue());
          }
          tooManyContexts.add(lwc);
        }
      }
    }
;
    thread.setVal((long)i);
    threads.add(thread);
    thread.start();
  }
  for (  Thread t : threads) {
    t.join();
  }
  for (  long val : vals) {
    assertTrue(val >= begin);
    assertTrue(val <= end);
  }
}",0.9991423670668954
91902,"/** 
 * Run the benchmark.
 * @param args The command-line arguments
 */
public static void main(final String[] args){
  final String TRACE_PATH=""String_Node_Str"";
  final int NUM_LOOPS=100;
  final boolean USE_TEXT=true;
  Long nbEvent=0L;
  final Vector<Double> benchs=new Vector<>();
  CtfTmfTrace trace=null;
  long start, stop;
  for (int loops=0; loops < NUM_LOOPS; loops++) {
    nbEvent=0L;
    trace=new CtfTmfTrace();
    try {
      trace.initTrace(null,TRACE_PATH,CtfTmfEvent.class);
    }
 catch (    final TmfTraceException e) {
      loops=NUM_LOOPS + 1;
      break;
    }
    start=System.nanoTime();
    if (nbEvent != -1) {
      final CtfTmfContext traceReader=(CtfTmfContext)trace.seekEvent(0);
      start=System.nanoTime();
      CtfTmfEvent current=traceReader.getCurrentEvent();
      while (current != null) {
        nbEvent++;
        if (USE_TEXT) {
          System.out.println(""String_Node_Str"" + nbEvent + ""String_Node_Str""+ current.getTimestamp().toString()+ ""String_Node_Str""+ current.getType().getName()+ ""String_Node_Str""+ current.getSource()+ ""String_Node_Str""+ current.getContent().toString());
        }
        boolean hasMore=traceReader.advance();
        if (hasMore) {
        }
        current=traceReader.getCurrentEvent();
      }
    }
    stop=System.nanoTime();
    System.out.print('.');
    final double time=(stop - start) / (double)nbEvent;
    benchs.add(time);
  }
  System.out.println(""String_Node_Str"");
  double avg=0;
  for (  final Double val : benchs) {
    avg+=val;
  }
  avg/=benchs.size();
  System.out.println(""String_Node_Str"" + avg + ""String_Node_Str"");
  for (  final Double val : benchs) {
    System.out.print(val);
    System.out.print(""String_Node_Str"");
  }
}","/** 
 * Run the benchmark.
 * @param args The command-line arguments
 */
public static void main(final String[] args){
  final String TRACE_PATH=""String_Node_Str"";
  final int NUM_LOOPS=100;
  final boolean USE_TEXT=true;
  long nbEvent=0L;
  final Vector<Double> benchs=new Vector<>();
  CtfTmfTrace trace=null;
  long start, stop;
  for (int loops=0; loops < NUM_LOOPS; loops++) {
    nbEvent=0L;
    trace=new CtfTmfTrace();
    try {
      trace.initTrace(null,TRACE_PATH,CtfTmfEvent.class);
    }
 catch (    final TmfTraceException e) {
      loops=NUM_LOOPS + 1;
      break;
    }
    start=System.nanoTime();
    if (nbEvent != -1) {
      final CtfTmfContext traceReader=(CtfTmfContext)trace.seekEvent(0);
      start=System.nanoTime();
      CtfTmfEvent current=traceReader.getCurrentEvent();
      while (current != null) {
        nbEvent++;
        if (USE_TEXT) {
          System.out.println(""String_Node_Str"" + nbEvent + ""String_Node_Str""+ current.getTimestamp().toString()+ ""String_Node_Str""+ current.getType().getName()+ ""String_Node_Str""+ current.getSource()+ ""String_Node_Str""+ current.getContent().toString());
        }
        boolean hasMore=traceReader.advance();
        if (hasMore) {
        }
        current=traceReader.getCurrentEvent();
      }
    }
    stop=System.nanoTime();
    System.out.print('.');
    final double time=(stop - start) / (double)nbEvent;
    benchs.add(time);
  }
  System.out.println(""String_Node_Str"");
  double avg=0;
  for (  final double val : benchs) {
    avg+=val;
  }
  avg/=benchs.size();
  System.out.println(""String_Node_Str"" + avg + ""String_Node_Str"");
  for (  final Double val : benchs) {
    System.out.print(val);
    System.out.print(""String_Node_Str"");
  }
}",0.8800461361014994
91903,"/** 
 * Test the   {@link ITmfStatistics#histogramQuery} method over the wholetrace.
 */
@Test public void testHistogramQueryFull(){
  final int NB_REQ=10;
  List<Long> results=backend.histogramQuery(tStart,tEnd,NB_REQ);
  assertEquals(NB_REQ,results.size());
  long count=0;
  for (  Long val : results) {
    count+=val;
  }
  assertEquals(totalNbEvents,count);
  assertEquals(94161,results.get(0).longValue());
  assertEquals(87348,results.get(1).longValue());
  assertEquals(58941,results.get(2).longValue());
  assertEquals(59879,results.get(3).longValue());
  assertEquals(66941,results.get(4).longValue());
  assertEquals(68939,results.get(5).longValue());
  assertEquals(72746,results.get(6).longValue());
  assertEquals(60749,results.get(7).longValue());
  assertEquals(61208,results.get(8).longValue());
  assertEquals(64407,results.get(9).longValue());
}","/** 
 * Test the   {@link ITmfStatistics#histogramQuery} method over the wholetrace.
 */
@Test public void testHistogramQueryFull(){
  final int NB_REQ=10;
  List<Long> results=backend.histogramQuery(tStart,tEnd,NB_REQ);
  assertEquals(NB_REQ,results.size());
  long count=0;
  for (  long val : results) {
    count+=val;
  }
  assertEquals(totalNbEvents,count);
  assertEquals(94161,results.get(0).longValue());
  assertEquals(87348,results.get(1).longValue());
  assertEquals(58941,results.get(2).longValue());
  assertEquals(59879,results.get(3).longValue());
  assertEquals(66941,results.get(4).longValue());
  assertEquals(68939,results.get(5).longValue());
  assertEquals(72746,results.get(6).longValue());
  assertEquals(60749,results.get(7).longValue());
  assertEquals(61208,results.get(8).longValue());
  assertEquals(64407,results.get(9).longValue());
}",0.998843930635838
91904,"private static long sumOfEvents(Map<String,Long> map){
  long count=0;
  for (  Long val : map.values()) {
    count+=val;
  }
  return count;
}","private static long sumOfEvents(Map<String,Long> map){
  long count=0;
  for (  long val : map.values()) {
    count+=val;
  }
  return count;
}",0.9930555555555556
91905,"/** 
 * Tests that binarySearch finds the correct checkpoint when searching for a checkpoint with a null location. It should return the previous checkpoint from the first checkpoint that matches the timestamp.
 */
@Test public void testBinarySearchInBetweenSameTimestamp(){
  int checkpointNum=0;
  for (; checkpointNum < 100; checkpointNum++) {
    TmfCheckpoint checkpoint=new TmfCheckpoint(new TmfTimestamp(0),new TmfLongLocation((long)checkpointNum),checkpointNum);
    fCheckpointCollection.insert(checkpoint);
  }
  for (; checkpointNum < 200; checkpointNum++) {
    TmfCheckpoint checkpoint=new TmfCheckpoint(new TmfTimestamp(1),new TmfLongLocation((long)checkpointNum),checkpointNum);
    fCheckpointCollection.insert(checkpoint);
  }
  final TmfCheckpoint searchedCheckpoint=new TmfCheckpoint(new TmfTimestamp(1),null,0);
  long found=fCheckpointCollection.binarySearch(searchedCheckpoint);
  int expectedInsertionPoint=99;
  int expectedRank=-(expectedInsertionPoint + 2);
  assertEquals(expectedRank,found);
}","/** 
 * Tests that binarySearch finds the correct checkpoint when searching for a checkpoint with a null location. It should return the previous checkpoint from the first checkpoint that matches the timestamp.
 */
@Test public void testBinarySearchInBetweenSameTimestamp(){
  int checkpointNum=0;
  for (; checkpointNum < 100; checkpointNum++) {
    TmfCheckpoint checkpoint=new TmfCheckpoint(new TmfTimestamp(0),new TmfLongLocation(checkpointNum),checkpointNum);
    fCheckpointCollection.insert(checkpoint);
  }
  for (; checkpointNum < 200; checkpointNum++) {
    TmfCheckpoint checkpoint=new TmfCheckpoint(new TmfTimestamp(1),new TmfLongLocation(checkpointNum),checkpointNum);
    fCheckpointCollection.insert(checkpoint);
  }
  final TmfCheckpoint searchedCheckpoint=new TmfCheckpoint(new TmfTimestamp(1),null,0);
  long found=fCheckpointCollection.binarySearch(searchedCheckpoint);
  int expectedInsertionPoint=99;
  int expectedRank=-(expectedInsertionPoint + 2);
  assertEquals(expectedRank,found);
}",0.9940828402366864
91906,"/** 
 * Tests that accepts find the correct checkpoint and ends with a perfect match
 */
@Test public void testAccept(){
  for (int i=0; i < CHECKPOINTS_INSERT_NUM; i++) {
    TmfCheckpoint checkpoint=new TmfCheckpoint(new TmfTimestamp(i),new TmfLongLocation((long)i),0);
    fBTree.insert(checkpoint);
  }
  final TmfCheckpoint checkpoint=new TmfCheckpoint(new TmfTimestamp(123),new TmfLongLocation(123L),0);
class TestVisitor implements IBTreeVisitor {
    public int fLastCompare=0;
    ITmfCheckpoint fFoundCheckpoint;
    @Override public int compare(    ITmfCheckpoint checkRec){
      fLastCompare=checkRec.compareTo(checkpoint);
      if (fLastCompare == 0) {
        fFoundCheckpoint=checkRec;
      }
      return fLastCompare;
    }
  }
  final TestVisitor t=new TestVisitor();
  fBTree.accept(t);
  assertEquals(checkpoint,t.fFoundCheckpoint);
  assertEquals(0,t.fLastCompare);
}","/** 
 * Tests that accepts find the correct checkpoint and ends with a perfect match
 */
@Test public void testAccept(){
  for (int i=0; i < CHECKPOINTS_INSERT_NUM; i++) {
    TmfCheckpoint checkpoint=new TmfCheckpoint(new TmfTimestamp(i),new TmfLongLocation(i),0);
    fBTree.insert(checkpoint);
  }
  final TmfCheckpoint checkpoint=new TmfCheckpoint(new TmfTimestamp(123),new TmfLongLocation(123L),0);
class TestVisitor implements IBTreeVisitor {
    public int fLastCompare=0;
    ITmfCheckpoint fFoundCheckpoint;
    @Override public int compare(    ITmfCheckpoint checkRec){
      fLastCompare=checkRec.compareTo(checkpoint);
      if (fLastCompare == 0) {
        fFoundCheckpoint=checkRec;
      }
      return fLastCompare;
    }
  }
  final TestVisitor t=new TestVisitor();
  fBTree.accept(t);
  assertEquals(checkpoint,t.fFoundCheckpoint);
  assertEquals(0,t.fLastCompare);
}",0.9966216216216216
91907,"/** 
 * Test many checkpoint insertions. Make sure they can be found after re-opening the file
 */
@Test public void testInsertAlotCheckEquals(){
  ArrayList<Integer> list=insertAlot();
  fFlatArray=createCollection();
  for (int i=0; i < CHECKPOINTS_INSERT_NUM; i++) {
    Integer checkpointIndex=list.get(i);
    TmfCheckpoint checkpoint=new TmfCheckpoint(new TmfTimestamp(12345 + checkpointIndex),new TmfLongLocation(123456L + checkpointIndex),checkpointIndex);
    ITmfCheckpoint found=fFlatArray.get(checkpointIndex);
    assertEquals(checkpoint,found);
  }
}","/** 
 * Test many checkpoint insertions. Make sure they can be found after re-opening the file
 */
@Test public void testInsertAlotCheckEquals(){
  ArrayList<Integer> list=insertAlot();
  fFlatArray=createCollection();
  for (int i=0; i < CHECKPOINTS_INSERT_NUM; i++) {
    int checkpointIndex=list.get(i);
    TmfCheckpoint checkpoint=new TmfCheckpoint(new TmfTimestamp(12345 + checkpointIndex),new TmfLongLocation(123456L + checkpointIndex),checkpointIndex);
    ITmfCheckpoint found=fFlatArray.get(checkpointIndex);
    assertEquals(checkpoint,found);
  }
}",0.9911032028469752
91908,"@Override public Object getParameter(String name){
  Object value=super.getParameter(name);
  if ((value != null) && name.equals(PARAM_TEST) && (value instanceof String)) {
    return Integer.parseInt((String)value);
  }
  return value;
}","@Override public Object getParameter(String name){
  Object value=super.getParameter(name);
  if ((value != null) && name.equals(PARAM_TEST) && (value instanceof String)) {
    return Integer.decode((String)value);
  }
  return value;
}",0.9704641350210972
91909,"@Override public ITmfEvent parseEvent(final ITmfContext context){
  if (!(fEventStream instanceof TmfTraceStub)) {
    return null;
  }
  final RandomAccessFile stream=((TmfTraceStub)fEventStream).getStream();
  if (stream == null) {
    return null;
  }
  long location=0;
  if (context != null && context.getLocation() != null) {
    location=(Long)context.getLocation().getLocationInfo();
    try {
      stream.seek(location);
      final long ts=stream.readLong();
      final String source=stream.readUTF();
      final String type=stream.readUTF();
      final Integer reference=stream.readInt();
      final int typeIndex=Integer.parseInt(type.substring(typePrefix.length()));
      final String[] fields=new String[typeIndex];
      for (int i=0; i < typeIndex; i++) {
        fields[i]=stream.readUTF();
      }
      final StringBuffer content=new StringBuffer(""String_Node_Str"");
      if (typeIndex > 0) {
        content.append(fields[0]);
      }
      for (int i=1; i < typeIndex; i++) {
        content.append(""String_Node_Str"").append(fields[i]);
      }
      content.append(""String_Node_Str"");
      final TmfEventField root=new TmfEventField(ITmfEventField.ROOT_FIELD_ID,content.toString(),null);
      final ITmfEvent event=new TmfEvent(fEventStream,new TmfTimestamp(ts,-3,0),source,fTypes[typeIndex],root,reference.toString());
      return event;
    }
 catch (    final EOFException e) {
    }
catch (    final IOException e) {
    }
  }
  return null;
}","@Override public ITmfEvent parseEvent(final ITmfContext context){
  if (!(fEventStream instanceof TmfTraceStub)) {
    return null;
  }
  final RandomAccessFile stream=((TmfTraceStub)fEventStream).getStream();
  if (stream == null) {
    return null;
  }
  long location=0;
  if (context != null && context.getLocation() != null) {
    location=(Long)context.getLocation().getLocationInfo();
    try {
      stream.seek(location);
      final long ts=stream.readLong();
      final String source=stream.readUTF();
      final String type=stream.readUTF();
      final int reference=stream.readInt();
      final int typeIndex=Integer.parseInt(type.substring(typePrefix.length()));
      final String[] fields=new String[typeIndex];
      for (int i=0; i < typeIndex; i++) {
        fields[i]=stream.readUTF();
      }
      final StringBuffer content=new StringBuffer(""String_Node_Str"");
      if (typeIndex > 0) {
        content.append(fields[0]);
      }
      for (int i=1; i < typeIndex; i++) {
        content.append(""String_Node_Str"").append(fields[i]);
      }
      content.append(""String_Node_Str"");
      final TmfEventField root=new TmfEventField(ITmfEventField.ROOT_FIELD_ID,content.toString(),null);
      final ITmfEvent event=new TmfEvent(fEventStream,new TmfTimestamp(ts,-3,0),source,fTypes[typeIndex],root,String.valueOf(reference));
      return event;
    }
 catch (    final EOFException e) {
    }
catch (    final IOException e) {
    }
  }
  return null;
}",0.9820885434268334
91910,"@Override public double getLocationRatio(ITmfLocation location){
  fLock.lock();
  try {
    if (fTrace != null) {
      if (location.getLocationInfo() instanceof Long) {
        return (double)((Long)location.getLocationInfo()) / fTrace.length();
      }
    }
  }
 catch (  final IOException e) {
    e.printStackTrace();
  }
 finally {
    fLock.unlock();
  }
  return 0;
}","@Override public double getLocationRatio(ITmfLocation location){
  fLock.lock();
  try {
    if (fTrace != null) {
      if (location.getLocationInfo() instanceof Long) {
        return ((Long)location.getLocationInfo()).doubleValue() / fTrace.length();
      }
    }
  }
 catch (  final IOException e) {
    e.printStackTrace();
  }
 finally {
    fLock.unlock();
  }
  return 0;
}",0.9023746701846964
91911,"@Override public void removeAttribute(long t,int attributeQuark) throws TimeRangeException, AttributeNotFoundException {
  assert(attributeQuark >= 0);
  List<Integer> childAttributes;
  childAttributes=getSubAttributes(attributeQuark,false);
  for (  Integer childNodeQuark : childAttributes) {
    assert(attributeQuark != childNodeQuark);
    removeAttribute(t,childNodeQuark);
  }
  try {
    transState.processStateChange(t,TmfStateValue.nullValue(),attributeQuark);
  }
 catch (  StateValueTypeException e) {
    throw new IllegalStateException(e);
  }
}","@Override public void removeAttribute(long t,int attributeQuark) throws TimeRangeException, AttributeNotFoundException {
  assert(attributeQuark >= 0);
  List<Integer> childAttributes;
  childAttributes=getSubAttributes(attributeQuark,false);
  for (  int childNodeQuark : childAttributes) {
    assert(attributeQuark != childNodeQuark);
    removeAttribute(t,childNodeQuark);
  }
  try {
    transState.processStateChange(t,TmfStateValue.nullValue(),attributeQuark);
  }
 catch (  StateValueTypeException e) {
    throw new IllegalStateException(e);
  }
}",0.9910394265232976
91912,"@Override public void pushAttribute(long t,ITmfStateValue value,int attributeQuark) throws TimeRangeException, AttributeNotFoundException, StateValueTypeException {
  Integer stackDepth;
  int subAttributeQuark;
  ITmfStateValue previousSV=transState.getOngoingStateValue(attributeQuark);
  if (previousSV.isNull()) {
    stackDepth=0;
  }
 else   if (previousSV.getType() == Type.INTEGER) {
    stackDepth=previousSV.unboxInt();
  }
 else {
    throw new StateValueTypeException();
  }
  if (stackDepth >= 100000) {
    String message=""String_Node_Str"";
    throw new AttributeNotFoundException(message);
  }
  stackDepth++;
  subAttributeQuark=getQuarkRelativeAndAdd(attributeQuark,stackDepth.toString());
  modifyAttribute(t,TmfStateValue.newValueInt(stackDepth),attributeQuark);
  modifyAttribute(t,value,subAttributeQuark);
}","@Override public void pushAttribute(long t,ITmfStateValue value,int attributeQuark) throws TimeRangeException, AttributeNotFoundException, StateValueTypeException {
  int stackDepth;
  int subAttributeQuark;
  ITmfStateValue previousSV=transState.getOngoingStateValue(attributeQuark);
  if (previousSV.isNull()) {
    stackDepth=0;
  }
 else   if (previousSV.getType() == Type.INTEGER) {
    stackDepth=previousSV.unboxInt();
  }
 else {
    throw new StateValueTypeException();
  }
  if (stackDepth >= 100000) {
    String message=""String_Node_Str"";
    throw new AttributeNotFoundException(message);
  }
  stackDepth++;
  subAttributeQuark=getQuarkRelativeAndAdd(attributeQuark,String.valueOf(stackDepth));
  modifyAttribute(t,TmfStateValue.newValueInt(stackDepth),attributeQuark);
  modifyAttribute(t,value,subAttributeQuark);
}",0.9789283564118
91913,"@Override public ITmfStateValue popAttribute(long t,int attributeQuark) throws AttributeNotFoundException, TimeRangeException, StateValueTypeException {
  ITmfStateValue previousSV=queryOngoingState(attributeQuark);
  if (previousSV.isNull()) {
    return null;
  }
  if (previousSV.getType() != Type.INTEGER) {
    throw new StateValueTypeException();
  }
  Integer stackDepth=previousSV.unboxInt();
  if (stackDepth <= 0) {
    String message=""String_Node_Str"" + ""String_Node_Str"";
    throw new StateValueTypeException(message);
  }
  int subAttributeQuark=getQuarkRelative(attributeQuark,stackDepth.toString());
  ITmfStateValue poppedValue=queryOngoingState(subAttributeQuark);
  ITmfStateValue nextSV;
  if (--stackDepth == 0) {
    nextSV=TmfStateValue.nullValue();
  }
 else {
    nextSV=TmfStateValue.newValueInt(stackDepth);
  }
  modifyAttribute(t,nextSV,attributeQuark);
  removeAttribute(t,subAttributeQuark);
  return poppedValue;
}","@Override public ITmfStateValue popAttribute(long t,int attributeQuark) throws AttributeNotFoundException, TimeRangeException, StateValueTypeException {
  ITmfStateValue previousSV=queryOngoingState(attributeQuark);
  if (previousSV.isNull()) {
    return null;
  }
  if (previousSV.getType() != Type.INTEGER) {
    throw new StateValueTypeException();
  }
  int stackDepth=previousSV.unboxInt();
  if (stackDepth <= 0) {
    String message=""String_Node_Str"" + ""String_Node_Str"";
    throw new StateValueTypeException(message);
  }
  int subAttributeQuark=getQuarkRelative(attributeQuark,String.valueOf(stackDepth));
  ITmfStateValue poppedValue=queryOngoingState(subAttributeQuark);
  ITmfStateValue nextSV;
  if (--stackDepth == 0) {
    nextSV=TmfStateValue.nullValue();
  }
 else {
    nextSV=TmfStateValue.newValueInt(stackDepth);
  }
  modifyAttribute(t,nextSV,attributeQuark);
  removeAttribute(t,subAttributeQuark);
  return poppedValue;
}",0.9815108293713682
91914,"@Override public ITmfStateInterval querySingleStackTop(long t,int stackAttributeQuark) throws StateValueTypeException, AttributeNotFoundException, TimeRangeException, StateSystemDisposedException {
  ITmfStateValue curStackStateValue=querySingleState(t,stackAttributeQuark).getStateValue();
  if (curStackStateValue.isNull()) {
    return null;
  }
  Integer curStackDepth=curStackStateValue.unboxInt();
  if (curStackDepth <= 0) {
    throw new StateValueTypeException();
  }
  int subAttribQuark=getQuarkRelative(stackAttributeQuark,curStackDepth.toString());
  return querySingleState(t,subAttribQuark);
}","@Override public ITmfStateInterval querySingleStackTop(long t,int stackAttributeQuark) throws StateValueTypeException, AttributeNotFoundException, TimeRangeException, StateSystemDisposedException {
  ITmfStateValue curStackStateValue=querySingleState(t,stackAttributeQuark).getStateValue();
  if (curStackStateValue.isNull()) {
    return null;
  }
  int curStackDepth=curStackStateValue.unboxInt();
  if (curStackDepth <= 0) {
    throw new StateValueTypeException();
  }
  int subAttribQuark=getQuarkRelative(stackAttributeQuark,String.valueOf(curStackDepth));
  return querySingleState(t,subAttribQuark);
}",0.971240755957272
91915,"@Override public int compareTo(TmfLocationArray o){
  for (int i=0; i < fRanks.length; i++) {
    Long rank1=fRanks[i];
    Long rank2=o.fRanks[i];
    int result=rank1.compareTo(rank2);
    if (result != 0) {
      return result;
    }
  }
  return 0;
}","@Override public int compareTo(TmfLocationArray o){
  for (int i=0; i < fRanks.length; i++) {
    long rank1=fRanks[i];
    long rank2=o.fRanks[i];
    if (rank1 < rank2) {
      return -1;
    }
 else     if (rank1 > rank2) {
      return 1;
    }
  }
  return 0;
}",0.6115384615384616
91916,"@Override public boolean appliesToTraceType(Class<? extends ITmfTrace> traceclass){
  boolean applies=false;
  final IConfigurationElement[] tracetypeCE=fCe.getChildren(TmfAnalysisModuleSourceConfigElement.TRACETYPE_ELEM);
  for (  IConfigurationElement element : tracetypeCE) {
    Class<?> applyclass;
    try {
      applyclass=getBundle().loadClass(element.getAttribute(TmfAnalysisModuleSourceConfigElement.CLASS_ATTR));
      String classAppliesVal=element.getAttribute(TmfAnalysisModuleSourceConfigElement.APPLIES_ATTR);
      boolean classApplies=true;
      if (classAppliesVal != null) {
        classApplies=Boolean.valueOf(classAppliesVal);
      }
      if (classApplies) {
        applies=applyclass.isAssignableFrom(traceclass);
      }
 else {
        applies=!applyclass.isAssignableFrom(traceclass);
      }
    }
 catch (    ClassNotFoundException e) {
      Activator.logError(""String_Node_Str"",e);
    }
catch (    InvalidRegistryObjectException e) {
      Activator.logError(""String_Node_Str"",e);
    }
  }
  return applies;
}","@Override public boolean appliesToTraceType(Class<? extends ITmfTrace> traceclass){
  boolean applies=false;
  final IConfigurationElement[] tracetypeCE=fCe.getChildren(TmfAnalysisModuleSourceConfigElement.TRACETYPE_ELEM);
  for (  IConfigurationElement element : tracetypeCE) {
    Class<?> applyclass;
    try {
      applyclass=getBundle().loadClass(element.getAttribute(TmfAnalysisModuleSourceConfigElement.CLASS_ATTR));
      String classAppliesVal=element.getAttribute(TmfAnalysisModuleSourceConfigElement.APPLIES_ATTR);
      boolean classApplies=true;
      if (classAppliesVal != null) {
        classApplies=Boolean.parseBoolean(classAppliesVal);
      }
      if (classApplies) {
        applies=applyclass.isAssignableFrom(traceclass);
      }
 else {
        applies=!applyclass.isAssignableFrom(traceclass);
      }
    }
 catch (    ClassNotFoundException e) {
      Activator.logError(""String_Node_Str"",e);
    }
catch (    InvalidRegistryObjectException e) {
      Activator.logError(""String_Node_Str"",e);
    }
  }
  return applies;
}",0.9909480705097664
91917,"@Override public boolean isAutomatic(){
  return Boolean.valueOf(fCe.getAttribute(TmfAnalysisModuleSourceConfigElement.AUTOMATIC_ATTR));
}","@Override public boolean isAutomatic(){
  return Boolean.parseBoolean(fCe.getAttribute(TmfAnalysisModuleSourceConfigElement.AUTOMATIC_ATTR));
}",0.9537366548042704
91918,"/** 
 * Constructor for CTFEnumField.
 * @param enumValue The Enum value consisting of a pair of Enum value name and its long value
 * @param name The name of this field
 */
CTFEnumField(String name,CtfEnumPair enumValue){
  super(name,new CtfEnumPair(enumValue.getFirst(),enumValue.getSecond().longValue()),null);
}","/** 
 * Constructor for CTFEnumField.
 * @param enumValue The Enum value consisting of a pair of Enum value name and its long value
 * @param name The name of this field
 */
CTFEnumField(String name,CtfEnumPair enumValue){
  super(name,new CtfEnumPair(enumValue.getFirst(),enumValue.getSecond()),null);
}",0.9806451612903224
91919,"@Override public boolean matches(ITmfEvent event){
  Object value=getFieldValue(event,fField);
  if (value == null) {
    return false ^ fNot;
  }
  if (fType == Type.NUM) {
    if (fValueNumber != null) {
      if (value instanceof Number) {
        Double valueDouble=((Number)value).doubleValue();
        return (valueDouble.compareTo(fValueNumber.doubleValue()) == fResult) ^ fNot;
      }
      try {
        Double valueDouble=NumberFormat.getInstance().parse(value.toString()).doubleValue();
        return (valueDouble.compareTo(fValueNumber.doubleValue()) == fResult) ^ fNot;
      }
 catch (      ParseException e) {
      }
    }
  }
 else   if (fType == Type.ALPHA) {
    String valueString=value.toString();
    int comp=valueString.compareTo(fValue.toString());
    if (comp < -1) {
      comp=-1;
    }
 else     if (comp > 1) {
      comp=1;
    }
    return (comp == fResult) ^ fNot;
  }
 else   if (fType == Type.TIMESTAMP) {
    if (fValueTimestamp != null) {
      if (value instanceof TmfTimestamp) {
        TmfTimestamp valueTimestamp=(TmfTimestamp)value;
        return (valueTimestamp.compareTo(fValueTimestamp,false) == fResult) ^ fNot;
      }
      try {
        TmfTimestamp valueTimestamp=new TmfTimestamp((long)(1E9 * NumberFormat.getInstance().parse(value.toString()).doubleValue()));
        return (valueTimestamp.compareTo(fValueTimestamp,false) == fResult) ^ fNot;
      }
 catch (      ParseException e) {
      }
    }
  }
  return false ^ fNot;
}","@Override public boolean matches(ITmfEvent event){
  Object value=getFieldValue(event,fField);
  if (value == null) {
    return false ^ fNot;
  }
  if (fType == Type.NUM) {
    if (fValueNumber != null) {
      if (value instanceof Number) {
        double valueDouble=((Number)value).doubleValue();
        return (Double.compare(valueDouble,fValueNumber.doubleValue()) == fResult) ^ fNot;
      }
      try {
        double valueDouble=NumberFormat.getInstance().parse(value.toString()).doubleValue();
        return (Double.compare(valueDouble,fValueNumber.doubleValue()) == fResult) ^ fNot;
      }
 catch (      ParseException e) {
      }
    }
  }
 else   if (fType == Type.ALPHA) {
    String valueString=value.toString();
    int comp=valueString.compareTo(fValue.toString());
    if (comp < -1) {
      comp=-1;
    }
 else     if (comp > 1) {
      comp=1;
    }
    return (comp == fResult) ^ fNot;
  }
 else   if (fType == Type.TIMESTAMP) {
    if (fValueTimestamp != null) {
      if (value instanceof TmfTimestamp) {
        TmfTimestamp valueTimestamp=(TmfTimestamp)value;
        return (valueTimestamp.compareTo(fValueTimestamp,false) == fResult) ^ fNot;
      }
      try {
        TmfTimestamp valueTimestamp=new TmfTimestamp((long)(1E9 * NumberFormat.getInstance().parse(value.toString()).doubleValue()));
        return (valueTimestamp.compareTo(fValueTimestamp,false) == fResult) ^ fNot;
      }
 catch (      ParseException e) {
      }
    }
  }
  return false ^ fNot;
}",0.8477531857813548
91920,"@Override public synchronized double getLocationRatio(final ITmfLocation location){
  if (fFile == null) {
    return 0;
  }
  try {
    if (location.getLocationInfo() instanceof Long) {
      return (double)((Long)location.getLocationInfo()) / fFile.length();
    }
  }
 catch (  final IOException e) {
    Activator.logError(""String_Node_Str"" + getPath(),e);
  }
  return 0;
}","@Override public synchronized double getLocationRatio(final ITmfLocation location){
  if (fFile == null) {
    return 0;
  }
  try {
    if (location.getLocationInfo() instanceof Long) {
      return ((Long)location.getLocationInfo()).doubleValue() / fFile.length();
    }
  }
 catch (  final IOException e) {
    Activator.logError(""String_Node_Str"" + getPath(),e);
  }
  return 0;
}",0.9028871391076116
91921,"@Override public String toString(){
  return ""String_Node_Str"" + (min >= 0 ? min : ""String_Node_Str"") + ""String_Node_Str""+ (max == INF ? ""String_Node_Str"" : (max >= 0 ? max : ""String_Node_Str""))+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + (min >= 0 ? min : ""String_Node_Str"") + ','+ (max == INF ? ""String_Node_Str"" : (max >= 0 ? max : ""String_Node_Str""))+ ')';
}",0.900990099009901
91922,"@Override public synchronized double getLocationRatio(final ITmfLocation location){
  if (fFile == null) {
    return 0;
  }
  try {
    if (location.getLocationInfo() instanceof Long) {
      return (double)((Long)location.getLocationInfo()) / fFile.length();
    }
  }
 catch (  final IOException e) {
    Activator.logError(""String_Node_Str"" + getPath(),e);
  }
  return 0;
}","@Override public synchronized double getLocationRatio(final ITmfLocation location){
  if (fFile == null) {
    return 0;
  }
  try {
    if (location.getLocationInfo() instanceof Long) {
      return ((Long)location.getLocationInfo()).doubleValue() / fFile.length();
    }
  }
 catch (  final IOException e) {
    Activator.logError(""String_Node_Str"" + getPath(),e);
  }
  return 0;
}",0.9028871391076116
91923,"/** 
 * Starts the <code>Thread</code> that the new <code>Process</code> will run in. This must be called in order to get the process to start running.
 * @throws CoreException
 */
public void start() throws CoreException {
  IStatus status=init();
  if (status.isOK()) {
    Thread t=new Thread(this,cmd[0]);
    t.start();
  }
 else {
    stop();
    returnVal=Integer.MIN_VALUE;
    throw new CoreException(status);
  }
}","/** 
 * Starts the <code>Thread</code> that the new <code>Process</code> will run in. This must be called in order to get the process to start running.
 * @throws CoreException
 */
public void start() throws CoreException {
  IStatus status=init();
  if (status.isOK()) {
    Thread t=new Thread(this,cmd[0]);
    t.start();
    started=true;
  }
 else {
    stop();
    returnVal=Integer.MIN_VALUE;
    throw new CoreException(status);
  }
}",0.979214780600462
91924,"@Override public void runningStateChanged(boolean running){
  setEnabled(!running);
}","@Override public void runningStateChanged(boolean started,boolean stopped){
  setEnabled(stopped);
}",0.7783783783783784
91925,"/** 
 * @since 2.0
 */
@Override public void runningStateChanged(boolean running){
  setEnabled(running);
}","/** 
 * @since 2.0
 */
@Override public void runningStateChanged(boolean started,boolean stopped){
  setEnabled(!stopped);
}",0.8225108225108225
91926,"/** 
 * Test that XML modules are available through the analysis manager
 */
@Test public void testPopulateModulesWithAnalysisManager(){
  TmfAnalysisManager.initializeModuleSources();
  Map<String,IAnalysisModuleHelper> modules=TmfAnalysisManager.getAnalysisModules();
  assertFalse(findStateSystemModule(modules.values()));
  File testXmlFile=TmfXmlTestFiles.VALID_FILE.getFile();
  if ((testXmlFile == null) || !testXmlFile.exists()) {
    fail(""String_Node_Str"");
  }
  XmlUtils.addXmlFile(testXmlFile);
  XmlAnalysisModuleSource.notifyModuleChange();
  modules=TmfAnalysisManager.getAnalysisModules();
  assertTrue(findStateSystemModule(modules.values()));
}","/** 
 * Test that XML modules are available through the analysis manager
 */
@Test public void testPopulateModulesWithAnalysisManager(){
  TmfAnalysisManager.initialize();
  Map<String,IAnalysisModuleHelper> modules=TmfAnalysisManager.getAnalysisModules();
  assertFalse(findStateSystemModule(modules.values()));
  File testXmlFile=TmfXmlTestFiles.VALID_FILE.getFile();
  if ((testXmlFile == null) || !testXmlFile.exists()) {
    fail(""String_Node_Str"");
  }
  XmlUtils.addXmlFile(testXmlFile);
  XmlAnalysisModuleSource.notifyModuleChange();
  modules=TmfAnalysisManager.getAnalysisModules();
  assertTrue(findStateSystemModule(modules.values()));
}",0.99009900990099
91927,"/** 
 * Format the timestamp according to its pattern.
 * @param value the timestamp value to format (in ns)
 * @return the formatted timestamp
 */
public synchronized String format(long value){
  long date=value / 1000000;
  long sec=value / 1000000000;
  long ms=Math.abs(value) % 1000000000 / 1000000;
  long cs=Math.abs(value) % 1000000 / 1000;
  long ns=Math.abs(value) % 1000;
  if (value < 0 && ms + cs + ns > 0 && !fPattern.contains(""String_Node_Str"")) {
    date-=1;
    long nanosec=1000000000 - (1000000 * ms + 1000 * cs + ns);
    ms=nanosec / 1000000;
    cs=nanosec % 1000000 / 1000;
    ns=nanosec % 1000;
  }
  StringBuffer result=new StringBuffer(super.format(date));
  int loc=result.indexOf(fCloseBracket + ""String_Node_Str"" + fOpenBracket);
  while (loc != -1) {
    result.deleteCharAt(loc + fCloseBracket.length());
    loc=result.indexOf(fCloseBracket + ""String_Node_Str"" + fOpenBracket);
  }
  for (  String pattern : fSupplPatterns) {
    int length=pattern.length();
    StringBuffer fmt=new StringBuffer(length);
    for (int i=0; i < length; i++) {
      fmt.append(""String_Node_Str"");
    }
    DecimalFormat dfmt=new DecimalFormat(fmt.toString());
    String fmtVal=""String_Node_Str"";
switch (pattern.charAt(0)) {
case 'T':
      if (value < 0 && sec == 0) {
        result.insert(0,'-');
      }
    fmtVal=dfmt.format(sec);
  break;
case 'S':
fmtVal=dfmt.format(ms);
break;
case 'C':
fmtVal=dfmt.format(cs);
break;
case 'N':
fmtVal=dfmt.format(ns);
break;
default :
break;
}
String ph=new StringBuffer(fOpenBracket + pattern + fCloseBracket).toString();
loc=result.indexOf(ph);
result.replace(loc,loc + length + fOpenBracket.length()+ fCloseBracket.length(),fmtVal);
}
return result.toString();
}","/** 
 * Format the timestamp according to its pattern.
 * @param value the timestamp value to format (in ns)
 * @return the formatted timestamp
 */
public synchronized String format(long value){
  long date=value / 1000000;
  long sec=value / 1000000000;
  long ms=Math.abs((value % 1000000000) / 1000000);
  long cs=Math.abs((value % 1000000) / 1000);
  long ns=Math.abs(value % 1000);
  if (value < 0 && ms + cs + ns > 0 && !super.toPattern().contains(fOpenBracket + ""String_Node_Str"")) {
    date-=1;
    long nanosec=1000000000 - (1000000 * ms + 1000 * cs + ns);
    ms=nanosec / 1000000;
    cs=(nanosec % 1000000) / 1000;
    ns=nanosec % 1000;
  }
  StringBuffer result=new StringBuffer(super.format(date));
  result.append(fSubSecPattern);
  for (  String pattern : fSupplPatterns) {
    int length=pattern.length();
    StringBuffer fmt=new StringBuffer(length);
    for (int i=0; i < length; i++) {
      fmt.append(""String_Node_Str"");
    }
    DecimalFormat dfmt=new DecimalFormat(fmt.toString());
    String fmtVal=""String_Node_Str"";
switch (pattern.charAt(0)) {
case 'T':
      if (value < 0 && sec == 0) {
        result.insert(0,'-');
      }
    fmtVal=dfmt.format(sec);
  break;
case 'S':
fmtVal=dfmt.format(ms);
break;
case 'C':
fmtVal=dfmt.format(cs);
break;
case 'N':
fmtVal=dfmt.format(ns);
break;
default :
break;
}
String ph=new StringBuffer(fOpenBracket + pattern + fCloseBracket).toString();
int loc=result.indexOf(ph);
result.replace(loc,loc + length + fOpenBracket.length()+ fCloseBracket.length(),fmtVal);
}
return result.toString();
}",0.9027946537059538
91928,"/** 
 * Copy the pattern but quote (bracket with ""[&"" and ""&]"") the TmfTimestampFormat specific tags so these fields are treated as comments by the base class. It also keeps track of the corresponding quoted fields so they can be properly populated later on (by format()).
 * @param pattern the 'extended' pattern
 * @return the quoted and bracketed pattern
 */
private String quoteSpecificTags(final String pattern){
  StringBuffer result=new StringBuffer();
  int length=pattern.length();
  boolean inQuote=false;
  for (int i=0; i < length; i++) {
    char c=pattern.charAt(i);
    result.append(c);
    if (c == '\'') {
      if ((i + 1) < length) {
        c=pattern.charAt(i + 1);
        if (c == '\'') {
          i++;
          result.append(c);
          continue;
        }
      }
      inQuote=!inQuote;
      continue;
    }
    if (!inQuote) {
      if (fSupplPatternLetters.indexOf(c) != -1) {
        StringBuilder pat=new StringBuilder();
        pat.append(c);
        result.insert(result.length() - 1,""String_Node_Str"" + fOpenBracket);
        while ((i + 1) < length && pattern.charAt(i + 1) == c) {
          result.append(c);
          pat.append(c);
          i++;
        }
        result.append(fCloseBracket + ""String_Node_Str"");
        fSupplPatterns.add(pat.toString());
      }
    }
  }
  return result.toString();
}","/** 
 * Copy the pattern but quote (bracket with ""[&"" and ""&]"") the TmfTimestampFormat specific tags. Optionally surround tags with single quotes so these fields are treated as comments by the base class. It also keeps track of the corresponding quoted fields so they can be properly populated later on (by format()).
 * @param pattern the 'extended' pattern
 * @param addQuotes true to add single quotes around tags
 * @return the quoted and bracketed pattern
 */
private String quoteSpecificTags(final String pattern,boolean addQuotes){
  StringBuffer result=new StringBuffer();
  int length=pattern.length();
  boolean inQuote=false;
  for (int i=0; i < length; i++) {
    char c=pattern.charAt(i);
    result.append(c);
    if (c == '\'') {
      if ((i + 1) < length) {
        c=pattern.charAt(i + 1);
        if (c == '\'') {
          i++;
          result.append(c);
          continue;
        }
      }
      inQuote=!inQuote;
      continue;
    }
    if (!inQuote) {
      if (fSupplPatternLetters.indexOf(c) != -1) {
        StringBuilder pat=new StringBuilder();
        pat.append(c);
        if (addQuotes) {
          result.insert(result.length() - 1,""String_Node_Str"");
        }
        result.insert(result.length() - 1,fOpenBracket);
        while ((i + 1) < length && pattern.charAt(i + 1) == c) {
          result.append(c);
          pat.append(c);
          i++;
        }
        result.append(fCloseBracket);
        if (addQuotes) {
          result.append(""String_Node_Str"");
        }
        fSupplPatterns.add(pat.toString());
      }
    }
  }
  return result.toString();
}",0.9083530605343252
91929,"/** 
 * Parse a string according to the format pattern
 * @param string the source string
 * @return the parsed value
 * @throws ParseException if the string has an invalid format
 */
public long parseValue(final String string) throws ParseException {
  long result=parseValue(string,0);
  return result;
}","/** 
 * Parse a string according to the format pattern
 * @param string the source string
 * @return the parsed value (in ns)
 * @throws ParseException if the string has an invalid format
 */
public long parseValue(final String string) throws ParseException {
  long result=parseValue(string,0);
  return result;
}",0.9870967741935484
91930,"@Override public void applyPattern(String pattern){
  fPattern=pattern;
  String quotedPattern=quoteSpecificTags(pattern);
  super.applyPattern(quotedPattern);
}","@Override public void applyPattern(String pattern){
  fPattern=pattern;
  int dot=pattern.indexOf('.');
  if (dot == -1) {
    dot=pattern.length();
  }
  super.applyPattern(quoteSpecificTags(pattern.substring(0,dot),true));
  fSubSecPattern=quoteSpecificTags(pattern.substring(dot),false);
}",0.5121412803532008
91931,"/** 
 * FIXME The ID's should be saved in the state system themselves (ITmfStateSystem.getId()), so this will eventually not be needed. Return the ID of a given state system.
 * @param ss The state system for which you want the ID, null if there is no match.
 * @return The corresponding state system
 */
@Nullable String getStateSystemId(ITmfStateSystem ss);","/** 
 * FIXME The ID's should be saved in the state system themselves (ITmfStateSystem.getId()), so this will eventually not be needed. Return the ID of a given state system.
 * @param ss The state system for which you want the ID, null if there is no match.
 * @return The corresponding state system
 */
@Nullable String getStateSystemId(@NonNull ITmfStateSystem ss);",0.9876203576341128
91932,"/** 
 * Return a specific state system provided by this analysis.
 * @param id The ID of the state system
 * @return The state system corresponding to the given ID, null if there isno match.
 */
@Nullable ITmfStateSystem getStateSystem(String id);","/** 
 * Return a specific state system provided by this analysis.
 * @param id The ID of the state system
 * @return The state system corresponding to the given ID, null if there isno match.
 */
@Nullable ITmfStateSystem getStateSystem(@NonNull String id);",0.9821073558648112
91933,"/** 
 * Gets a project element with traces all initialized
 * @return A project stub element
 * @throws CoreException If something happened with the project creation
 */
public static TmfProjectElement getFilledProject() throws CoreException {
  assumeTrue(CtfTmfTestTrace.KERNEL.exists());
  IProject project=TmfProjectRegistry.createProject(PROJECT_NAME,null,null);
  IFolder traceFolder=project.getFolder(TmfTraceFolder.TRACE_FOLDER_NAME);
  File file=new File(testTrace.getPath());
  String path=file.getAbsolutePath();
  final IPath pathString=Path.fromOSString(path);
  IResource linkedTrace=TmfImportHelper.createLink(traceFolder,pathString,pathString.lastSegment());
  if (!(linkedTrace != null && linkedTrace.exists())) {
    return null;
  }
  linkedTrace.setPersistentProperty(TmfCommonConstants.TRACETYPE,""String_Node_Str"");
  final TmfProjectElement projectElement=TmfProjectRegistry.getProject(project,true);
  TmfTraceElement traceElement=projectElement.getTracesFolder().getTraces().get(0);
  traceElement.refreshTraceType();
  return projectElement;
}","/** 
 * Gets a project element with traces all initialized
 * @return A project stub element
 * @throws CoreException If something happened with the project creation
 */
public static TmfProjectElement getFilledProject() throws CoreException {
  assumeTrue(CtfTmfTestTrace.KERNEL.exists());
  IProject project=TmfProjectRegistry.createProject(PROJECT_NAME,null,null);
  IFolder traceFolder=project.getFolder(TmfTraceFolder.TRACE_FOLDER_NAME);
  File file=new File(testTrace.getPath());
  String path=file.getAbsolutePath();
  final IPath pathString=Path.fromOSString(path);
  IResource linkedTrace=TmfImportHelper.createLink(traceFolder,pathString,pathString.lastSegment());
  if (!(linkedTrace != null && linkedTrace.exists())) {
    return null;
  }
  linkedTrace.setPersistentProperty(TmfCommonConstants.TRACETYPE,""String_Node_Str"");
  final TmfProjectElement projectElement=TmfProjectRegistry.getProject(project,true);
  TmfTraceElement traceElement=projectElement.getTracesFolder().getTraces().get(0);
  traceElement.refreshTraceType();
  projectElement.refresh();
  return projectElement;
}",0.9870609981515712
91934,"/** 
 * Get the list of analysis elements
 * @return Array of analysis elements
 */
public List<TmfAnalysisOutputElement> getAvailableOutputs(){
  List<TmfAnalysisOutputElement> list=new ArrayList<>();
  IAnalysisModuleHelper helper=TmfAnalysisManager.getAnalysisModule(fAnalysisId);
  if (helper == null) {
    return list;
  }
  IPath path=getProject().getTracesFolder().getPath();
  if (fResource instanceof IFolder) {
    path=((IFolder)fResource).getFullPath();
  }
  ITmfProjectModelElement parent=getParent();
  if (parent instanceof TmfTraceElement) {
    ITmfTrace trace=((TmfTraceElement)parent).getTrace();
    if (trace == null) {
      return list;
    }
    IAnalysisModule module=trace.getAnalysisModule(fAnalysisId);
    if (module == null) {
      return list;
    }
    for (    IAnalysisOutput output : module.getOutputs()) {
      if (fResource instanceof IFolder) {
        IFolder newresource=ResourcesPlugin.getWorkspace().getRoot().getFolder(path.append(output.getName()));
        TmfAnalysisOutputElement out=new TmfAnalysisOutputElement(output.getName(),newresource,this,output);
        list.add(out);
      }
    }
  }
  return list;
}","/** 
 * Get the list of analysis output model elements under this analysis
 * @return Array of analysis output elements
 */
public List<TmfAnalysisOutputElement> getAvailableOutputs(){
  List<ITmfProjectModelElement> children=getChildren();
  List<TmfAnalysisOutputElement> outputs=new ArrayList<>();
  for (  ITmfProjectModelElement child : children) {
    if (child instanceof TmfAnalysisOutputElement) {
      outputs.add((TmfAnalysisOutputElement)child);
    }
  }
  return outputs;
}",0.2506053268765133
91935,"/** 
 * Constructor
 * @param name Name of the analysis
 * @param resource The resource
 * @param parent Parent of the analysis
 * @param id The analysis module id
 */
protected TmfAnalysisElement(String name,IResource resource,ITmfProjectModelElement parent,String id){
  super(name,resource,parent);
  fAnalysisId=id;
  refreshOutputs();
}","/** 
 * Constructor
 * @param name Name of the analysis
 * @param resource The resource
 * @param parent Parent of the analysis
 * @param id The analysis module id
 */
protected TmfAnalysisElement(String name,IResource resource,ITmfProjectModelElement parent,String id){
  super(name,resource,parent);
  fAnalysisId=id;
  parent.addChild(this);
}",0.9519650655021834
91936,"/** 
 * Constructor
 * @param name Name of the view
 * @param resource Resource for the view
 * @param parent Parent analysis of the view
 * @param output The output object
 */
protected TmfAnalysisOutputElement(String name,IResource resource,ITmfProjectModelElement parent,IAnalysisOutput output){
  super(name,resource,parent);
  fOutput=output;
}","/** 
 * Constructor
 * @param name Name of the view
 * @param resource Resource for the view
 * @param parent Parent analysis of the view
 * @param output The output object
 */
protected TmfAnalysisOutputElement(String name,IResource resource,ITmfProjectModelElement parent,IAnalysisOutput output){
  super(name,resource,parent);
  fOutput=output;
  parent.addChild(this);
}",0.9654218533886584
91937,"/** 
 * Get the list of analysis elements
 * @return Array of analysis elements
 * @since 3.0
 */
public List<TmfAnalysisElement> getAvailableAnalysis(){
  List<TmfAnalysisElement> list=new ArrayList<>();
  return list;
}","/** 
 * Get the list of analysis model elements under this experiment
 * @return Array of analysis elements
 * @since 3.0
 */
public List<TmfAnalysisElement> getAvailableAnalysis(){
  List<TmfAnalysisElement> list=new ArrayList<>();
  return list;
}",0.9063829787234042
91938,"/** 
 * Refreshes the trace type filed by reading the trace type persistent property of the resource referenece.
 */
public void refreshTraceType(){
  try {
    fTraceTypeId=getResource().getPersistentProperty(TmfCommonConstants.TRACETYPE);
    refreshAnalysis();
  }
 catch (  CoreException e) {
    Activator.getDefault().logError(""String_Node_Str"" + getName(),e);
  }
}","/** 
 * Refreshes the trace type filed by reading the trace type persistent property of the resource referenece.
 */
public void refreshTraceType(){
  try {
    fTraceTypeId=getResource().getPersistentProperty(TmfCommonConstants.TRACETYPE);
  }
 catch (  CoreException e) {
    Activator.getDefault().logError(""String_Node_Str"" + getName(),e);
  }
}",0.9680998613037448
91939,"/** 
 * Handler for the Trace Opened signal
 * @param signal The incoming signal
 * @since 3.0
 */
@TmfSignalHandler public void traceOpened(TmfTraceOpenedSignal signal){
  IResource resource=signal.getTrace().getResource();
  if ((resource == null) || !resource.equals(getResource())) {
    return;
  }
  refreshAnalysis();
  getParent().refresh();
}","/** 
 * Handler for the Trace Opened signal
 * @param signal The incoming signal
 * @since 3.0
 */
@TmfSignalHandler public void traceOpened(TmfTraceOpenedSignal signal){
  IResource resource=signal.getTrace().getResource();
  if ((resource == null) || !resource.equals(getResource())) {
    return;
  }
  getParent().refresh();
}",0.933920704845815
91940,"/** 
 * Get the list of analysis elements
 * @return Array of analysis elements
 * @since 3.0
 */
public List<TmfAnalysisElement> getAvailableAnalysis(){
  List<TmfAnalysisElement> list=new ArrayList<>();
  TraceTypeHelper helper=TmfTraceType.getInstance().getTraceType(getTraceType());
  Class<? extends ITmfTrace> traceClass=null;
  if (helper == null && fTraceTypeId != null) {
    if (fTraceTypeId.startsWith(CustomTxtTrace.class.getCanonicalName())) {
      for (      CustomTxtTraceDefinition def : CustomTxtTraceDefinition.loadAll()) {
        if (fTraceTypeId.equals(CustomTxtTrace.class.getCanonicalName() + ""String_Node_Str"" + def.definitionName)) {
          traceClass=CustomTxtTrace.class;
        }
      }
    }
    if (fTraceTypeId.startsWith(CustomXmlTrace.class.getCanonicalName())) {
      for (      CustomXmlTraceDefinition def : CustomXmlTraceDefinition.loadAll()) {
        if (fTraceTypeId.equals(CustomXmlTrace.class.getCanonicalName() + ""String_Node_Str"" + def.definitionName)) {
          traceClass=CustomTxtTrace.class;
        }
      }
    }
  }
 else   if (helper != null) {
    traceClass=helper.getTraceClass();
  }
  if (traceClass == null) {
    return list;
  }
  IPath path=fResource.getFullPath();
  for (  IAnalysisModuleHelper module : TmfAnalysisManager.getAnalysisModules(traceClass).values()) {
    IFolder newresource=ResourcesPlugin.getWorkspace().getRoot().getFolder(path.append(module.getId()));
    TmfAnalysisElement analysis=new TmfAnalysisElement(module.getName(),newresource,this,module.getId());
    list.add(analysis);
  }
  return list;
}","/** 
 * Get the list of analysis model elements under this trace
 * @return Array of analysis elements
 * @since 3.0
 */
public List<TmfAnalysisElement> getAvailableAnalysis(){
  List<ITmfProjectModelElement> children=getChildren();
  List<TmfAnalysisElement> analysis=new ArrayList<>();
  for (  ITmfProjectModelElement child : children) {
    if (child instanceof TmfAnalysisElement) {
      analysis.add((TmfAnalysisElement)child);
    }
  }
  return analysis;
}",0.1884409907722195
91941,"@Override void refreshChildren(){
  refreshAnalysis();
}","@Override void refreshChildren(){
  Map<String,TmfAnalysisElement> childrenMap=new HashMap<>();
  for (  TmfAnalysisElement analysis : getAvailableAnalysis()) {
    childrenMap.put(analysis.getAnalysisId(),analysis);
  }
  TraceTypeHelper helper=TmfTraceType.getInstance().getTraceType(getTraceType());
  Class<? extends ITmfTrace> traceClass=null;
  if (helper == null && fTraceTypeId != null) {
    if (fTraceTypeId.startsWith(CustomTxtTrace.class.getCanonicalName())) {
      for (      CustomTxtTraceDefinition def : CustomTxtTraceDefinition.loadAll()) {
        if (fTraceTypeId.equals(CustomTxtTrace.class.getCanonicalName() + ""String_Node_Str"" + def.definitionName)) {
          traceClass=CustomTxtTrace.class;
        }
      }
    }
    if (fTraceTypeId.startsWith(CustomXmlTrace.class.getCanonicalName())) {
      for (      CustomXmlTraceDefinition def : CustomXmlTraceDefinition.loadAll()) {
        if (fTraceTypeId.equals(CustomXmlTrace.class.getCanonicalName() + ""String_Node_Str"" + def.definitionName)) {
          traceClass=CustomTxtTrace.class;
        }
      }
    }
  }
 else   if (helper != null) {
    traceClass=helper.getTraceClass();
  }
  if (traceClass == null) {
    for (    TmfAnalysisElement analysis : childrenMap.values()) {
      removeChild(analysis);
    }
    return;
  }
  IPath path=fResource.getFullPath();
  for (  IAnalysisModuleHelper module : TmfAnalysisManager.getAnalysisModules(traceClass).values()) {
    TmfAnalysisElement analysis=childrenMap.remove(module.getId());
    if (analysis == null) {
      IFolder newresource=ResourcesPlugin.getWorkspace().getRoot().getFolder(path.append(module.getId()));
      analysis=new TmfAnalysisElement(module.getName(),newresource,this,module.getId());
    }
    analysis.refreshChildren();
  }
  for (  TmfAnalysisElement analysis : childrenMap.values()) {
    removeChild(analysis);
  }
}",0.050593701600413
91942,"/** 
 * Sets the time range of the full histogram.
 * @param startTime A start time
 * @param endTime A end time
 */
public void setFullRange(long startTime,long endTime){
  fZoom.setFullRange(startTime,endTime);
}","/** 
 * Sets the time range of the full histogram.
 * @param startTime A start time
 * @param endTime A end time
 */
public void setFullRange(long startTime,long endTime){
  fZoom.setFullRange(startTime,endTime);
  fZoom.setNewRange(fRangeStartTime,fRangeDuration);
}",0.8898128898128899
91943,"@Override public void mouseMove(MouseEvent event){
  if (fDragState == DRAG_RANGE) {
    int nbBuckets=event.x - fStartPosition;
    long delta=nbBuckets * fScaledData.fBucketDuration;
    long newStart=fZoom.getStartTime() + delta;
    if (newStart < getStartTime()) {
      newStart=getStartTime();
    }
    long newEnd=newStart + fZoom.getDuration();
    if (newEnd > getEndTime()) {
      newEnd=getEndTime();
      newStart=newEnd - fZoom.getDuration();
    }
    fRangeStartTime=newStart;
    fCanvas.redraw();
    fMouseMoved=true;
    return;
  }
 else   if (fDragState == DRAG_ZOOM) {
    long endTime=Math.max(getStartTime(),Math.min(getEndTime(),getTimestamp(event.x)));
    fRangeDuration=endTime - fRangeStartTime;
    fCanvas.redraw();
    return;
  }
  super.mouseMove(event);
}","@Override public void mouseMove(MouseEvent event){
  if (fDragState == DRAG_RANGE) {
    int center=event.x + fStartDelta;
    long newStart=getTimestamp(center) - fRangeDuration / 2;
    fRangeStartTime=Math.max(getStartTime(),Math.min(getEndTime() - fRangeDuration,newStart));
    fCanvas.redraw();
    fMouseMoved=true;
    return;
  }
 else   if (fDragState == DRAG_ZOOM) {
    long endTime=Math.max(getStartTime(),Math.min(getEndTime(),getTimestamp(event.x)));
    fRangeDuration=endTime - fRangeStartTime;
    fCanvas.redraw();
    return;
  }
  super.mouseMove(event);
}",0.6039387308533917
91944,"@Override public void mouseDown(MouseEvent event){
  if (fScaledData != null && fDragState == DRAG_NONE && fDataModel.getStartTime() < fDataModel.getEndTime()) {
    if (event.button == 2 || (event.button == 1 && (event.stateMask & SWT.MODIFIER_MASK) == SWT.CTRL)) {
      fDragState=DRAG_RANGE;
      fDragButton=event.button;
      fStartPosition=event.x;
      fMouseMoved=false;
      return;
    }
 else     if (event.button == 3) {
      fDragState=DRAG_ZOOM;
      fDragButton=event.button;
      long time=Math.min(getTimestamp(event.x),getEndTime());
      if ((event.stateMask & SWT.MODIFIER_MASK) == SWT.SHIFT) {
        if (time < fRangeStartTime + fRangeDuration / 2) {
          fRangeStartTime=fRangeStartTime + fRangeDuration;
        }
      }
 else {
        fRangeStartTime=time;
      }
      fRangeDuration=time - fRangeStartTime;
      fCanvas.redraw();
      return;
    }
  }
  super.mouseDown(event);
}","@Override public void mouseDown(MouseEvent event){
  if (fScaledData != null && fDragState == DRAG_NONE && fDataModel.getStartTime() < fDataModel.getEndTime()) {
    if (event.button == 2 || (event.button == 1 && (event.stateMask & SWT.MODIFIER_MASK) == SWT.CTRL)) {
      fDragState=DRAG_RANGE;
      fDragButton=event.button;
      int center=(int)(((fRangeStartTime + fRangeDuration / 2) - fScaledData.fFirstBucketTime) / fScaledData.fBucketDuration);
      fStartDelta=center - event.x;
      fMouseMoved=false;
      return;
    }
 else     if (event.button == 3) {
      fDragState=DRAG_ZOOM;
      fDragButton=event.button;
      long time=Math.min(getTimestamp(event.x),getEndTime());
      if ((event.stateMask & SWT.MODIFIER_MASK) == SWT.SHIFT) {
        if (time < fRangeStartTime + fRangeDuration / 2) {
          fRangeStartTime=fRangeStartTime + fRangeDuration;
        }
      }
 else {
        fRangeStartTime=time;
      }
      fRangeDuration=time - fRangeStartTime;
      fCanvas.redraw();
      return;
    }
  }
  super.mouseDown(event);
}",0.917966784096628
91945,"/** 
 * Clear the histogram and reset the data
 */
public void clear(){
  fDataModel.clear();
synchronized (fDataModel) {
    fScaledData=null;
  }
}","/** 
 * Clear the histogram and reset the data
 */
public void clear(){
  fDataModel.clear();
  fDragState=DRAG_NONE;
  fDragButton=0;
synchronized (fDataModel) {
    fScaledData=null;
  }
}",0.8790560471976401
91946,"/** 
 * Handles the trace updated signal. Used to update time limits (start and end time)
 * @param signal the trace updated signal
 * @since 2.0
 */
@TmfSignalHandler public void traceUpdated(TmfTraceUpdatedSignal signal){
  if (signal.getTrace() != fTrace) {
    return;
  }
  TmfTimeRange fullRange=signal.getTrace().getTimeRange();
  fTraceStartTime=fullRange.getStartTime().normalize(0,ITmfTimestamp.NANOSECOND_SCALE).getValue();
  fTraceEndTime=fullRange.getEndTime().normalize(0,ITmfTimestamp.NANOSECOND_SCALE).getValue();
  fFullTraceHistogram.setFullRange(fTraceStartTime,fTraceEndTime);
  fTimeRangeHistogram.setFullRange(fTraceStartTime,fTraceEndTime);
  fFullTraceHistogram.setTimeRange(fTimeRangeHistogram.getStartTime(),fWindowSpan);
  fTimeRangeHistogram.setTimeRange(fTimeRangeHistogram.getStartTime(),fWindowSpan);
  if ((fFullTraceRequest != null) && fFullTraceRequest.getRange().getEndTime().compareTo(signal.getRange().getEndTime()) < 0) {
    sendFullRangeRequest(fullRange);
  }
}","/** 
 * Handles the trace updated signal. Used to update time limits (start and end time)
 * @param signal the trace updated signal
 * @since 2.0
 */
@TmfSignalHandler public void traceUpdated(TmfTraceUpdatedSignal signal){
  if (signal.getTrace() != fTrace) {
    return;
  }
  TmfTimeRange fullRange=signal.getTrace().getTimeRange();
  fTraceStartTime=fullRange.getStartTime().normalize(0,ITmfTimestamp.NANOSECOND_SCALE).getValue();
  fTraceEndTime=fullRange.getEndTime().normalize(0,ITmfTimestamp.NANOSECOND_SCALE).getValue();
  fFullTraceHistogram.setFullRange(fTraceStartTime,fTraceEndTime);
  fTimeRangeHistogram.setFullRange(fTraceStartTime,fTraceEndTime);
  if ((fFullTraceRequest != null) && fFullTraceRequest.getRange().getEndTime().compareTo(signal.getRange().getEndTime()) < 0) {
    sendFullRangeRequest(fullRange);
  }
}",0.9084967320261438
91947,"@Override public void run(){
  HistogramScaledData.hideLostEvents=hideLostEventsAction.isChecked();
  long maxNbEvents=HistogramScaledData.hideLostEvents ? fFullTraceHistogram.fScaledData.fMaxValue : fFullTraceHistogram.fScaledData.fMaxCombinedValue;
  fFullTraceHistogram.getMaxNbEventsText().setText(Long.toString(maxNbEvents));
  fFullTraceHistogram.getMaxNbEventsText().getParent().layout();
  fFullTraceHistogram.fCanvas.redraw();
  maxNbEvents=HistogramScaledData.hideLostEvents ? fTimeRangeHistogram.fScaledData.fMaxValue : fTimeRangeHistogram.fScaledData.fMaxCombinedValue;
  fTimeRangeHistogram.getMaxNbEventsText().setText(Long.toString(maxNbEvents));
  fTimeRangeHistogram.getMaxNbEventsText().getParent().layout();
  fTimeRangeHistogram.fCanvas.redraw();
}","@Override public void run(){
  if (fParent.isDisposed()) {
    return;
  }
  timeRangeUpdated(signal);
}",0.1536697247706422
91948,"/** 
 * Handles the current time updated signal. Sets the current time in the time range histogram as well as the full histogram.
 * @param signal the signal to process
 */
@TmfSignalHandler public void currentTimeUpdated(TmfTimeSynchSignal signal){
  assert(signal != null);
  ITmfTimestamp beginTime=signal.getBeginTime().normalize(0,ITmfTimestamp.NANOSECOND_SCALE);
  ITmfTimestamp endTime=signal.getEndTime().normalize(0,ITmfTimestamp.NANOSECOND_SCALE);
  updateDisplayedSelectionTime(beginTime.getValue(),endTime.getValue());
}","/** 
 * Handles the current time updated signal. Sets the current time in the time range histogram as well as the full histogram.
 * @param signal the signal to process
 */
@TmfSignalHandler public void currentTimeUpdated(final TmfTimeSynchSignal signal){
  if (Display.getCurrent() == null) {
    Display.getDefault().asyncExec(new Runnable(){
      @Override public void run(){
        if (fParent.isDisposed()) {
          return;
        }
        currentTimeUpdated(signal);
      }
    }
);
    return;
  }
  ITmfTimestamp beginTime=signal.getBeginTime().normalize(0,ITmfTimestamp.NANOSECOND_SCALE);
  ITmfTimestamp endTime=signal.getEndTime().normalize(0,ITmfTimestamp.NANOSECOND_SCALE);
  updateDisplayedSelectionTime(beginTime.getValue(),endTime.getValue());
}",0.7855495772482706
91949,"/** 
 * Updates the current time range in the time range histogram and full range histogram.
 * @param signal the signal to process
 */
@TmfSignalHandler public void timeRangeUpdated(TmfRangeSynchSignal signal){
  assert(signal != null);
  if (fTrace != null) {
    TmfTimeRange range=signal.getCurrentRange().getIntersection(fTrace.getTimeRange());
    if (range == null) {
      return;
    }
    updateDisplayedTimeRange(range.getStartTime().normalize(0,ITmfTimestamp.NANOSECOND_SCALE).getValue(),range.getEndTime().normalize(0,ITmfTimestamp.NANOSECOND_SCALE).getValue());
    sendTimeRangeRequest(fWindowStartTime,fWindowEndTime);
    fTimeSpanControl.setValue(fWindowSpan);
  }
}","/** 
 * Updates the current time range in the time range histogram and full range histogram.
 * @param signal the signal to process
 */
@TmfSignalHandler public void timeRangeUpdated(final TmfRangeSynchSignal signal){
  if (Display.getCurrent() == null) {
    Display.getDefault().asyncExec(new Runnable(){
      @Override public void run(){
        if (fParent.isDisposed()) {
          return;
        }
        timeRangeUpdated(signal);
      }
    }
);
    return;
  }
  if (fTrace != null) {
    TmfTimeRange range=signal.getCurrentRange().getIntersection(fTrace.getTimeRange());
    if (range == null) {
      return;
    }
    updateDisplayedTimeRange(range.getStartTime().normalize(0,ITmfTimestamp.NANOSECOND_SCALE).getValue(),range.getEndTime().normalize(0,ITmfTimestamp.NANOSECOND_SCALE).getValue());
    sendTimeRangeRequest(fWindowStartTime,fWindowEndTime);
    fTimeSpanControl.setValue(fWindowSpan);
  }
}",0.827199001871491
91950,"/** 
 * Sets the full time range of the whole trace.
 * @param startTime The start time
 * @param endTime The end time
 */
public void setFullRange(long startTime,long endTime){
  fFullRangeStartTime=startTime;
  fFullRangeEndTime=endTime;
  long currentFirstEvent=getStartTime();
  fZoom.setFullRange((currentFirstEvent == 0) ? startTime : currentFirstEvent,endTime);
}","/** 
 * Sets the full time range of the whole trace.
 * @param startTime The start time
 * @param endTime The end time
 */
public void setFullRange(long startTime,long endTime){
  fFullRangeStartTime=startTime;
  fFullRangeEndTime=endTime;
  fZoom.setFullRange(startTime,endTime);
  fZoom.setNewRange(fRangeStartTime,fRangeDuration);
}",0.7687943262411348
91951,"/** 
 * Tell the Attribute Tree to write itself somewhere. The passed FileOutputStream defines where (which file/position).
 * @param fos Where to write. Make sure it's seeked at the right position you want.
 * @return The total number of bytes written.
 */
int writeSelf(File file,long pos){
  RandomAccessFile raf=null;
  int total=0;
  byte[] curByteArray;
  try {
    raf=new RandomAccessFile(file,""String_Node_Str"");
    raf.seek(pos);
    raf.writeInt(ATTRIB_TREE_MAGIC_NUMBER);
    raf.writeInt(-8000);
    raf.writeInt(this.attributeList.size());
    total+=12;
    for (    Attribute entry : this.attributeList) {
      curByteArray=entry.getFullAttributeName().getBytes();
      if (curByteArray.length > Byte.MAX_VALUE) {
        throw new IOException(""String_Node_Str"" + Arrays.toString(curByteArray) + ""String_Node_Str"");
      }
      raf.writeByte((byte)curByteArray.length);
      raf.write(curByteArray);
      raf.writeByte((byte)0);
      total+=curByteArray.length + 2;
    }
    raf.seek(pos + 4);
    raf.writeInt(total);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    if (raf != null) {
      try {
        raf.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  return total;
}","/** 
 * Tell the Attribute Tree to write itself somewhere. The passed FileOutputStream defines where (which file/position).
 * @param fos Where to write. Make sure it's sought at the right position you want.
 * @return The total number of bytes written.
 */
int writeSelf(File file,long pos){
  RandomAccessFile raf=null;
  int total=0;
  byte[] curByteArray;
  try {
    raf=new RandomAccessFile(file,""String_Node_Str"");
    raf.seek(pos);
    raf.writeInt(ATTRIB_TREE_MAGIC_NUMBER);
    raf.writeInt(-8000);
    raf.writeInt(this.attributeList.size());
    total+=12;
    for (    Attribute entry : this.attributeList) {
      curByteArray=entry.getFullAttributeName().getBytes();
      if (curByteArray.length > Byte.MAX_VALUE) {
        throw new IOException(""String_Node_Str"" + Arrays.toString(curByteArray) + ""String_Node_Str"");
      }
      raf.writeByte((byte)curByteArray.length);
      raf.write(curByteArray);
      raf.writeByte((byte)0);
      total+=curByteArray.length + 2;
    }
    raf.seek(pos + 4);
    raf.writeInt(total);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    if (raf != null) {
      try {
        raf.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  return total;
}",0.9960753532182104
91952,"/** 
 * ""Existing file"" constructor Builds a attribute tree from a ""mapping file"" or mapping section previously saved somewhere.
 * @param ss StateSystem to which this AT is attached
 * @param fis File stream where to read the AT information. Make sure it's seeked at the right place!
 * @throws IOException
 */
AttributeTree(StateSystem ss,FileInputStream fis) throws IOException {
  this(ss);
  DataInputStream in=new DataInputStream(new BufferedInputStream(fis));
  final String errorMessage=""String_Node_Str"";
  ArrayList<String[]> list=new ArrayList<String[]>();
  byte[] curByteArray;
  String curFullString;
  String[] curStringArray;
  int res, remain, size;
  int expectedSize=0;
  int total=0;
  res=in.readInt();
  if (res != ATTRIB_TREE_MAGIC_NUMBER) {
    throw new IOException(errorMessage);
  }
  expectedSize=in.readInt();
  if (expectedSize <= 12) {
    throw new IOException(errorMessage);
  }
  remain=in.readInt();
  total+=12;
  for (; remain > 0; remain--) {
    size=in.readByte();
    curByteArray=new byte[size];
    res=in.read(curByteArray);
    if (res != size) {
      throw new IOException(errorMessage);
    }
    curFullString=new String(curByteArray);
    curStringArray=curFullString.split(""String_Node_Str"");
    list.add(curStringArray);
    res=in.readByte();
    if (res != 0) {
      throw new IOException(errorMessage);
    }
    total+=curByteArray.length + 2;
  }
  if (total != expectedSize) {
    throw new IOException(errorMessage);
  }
  for (  String[] attrib : list) {
    this.getQuarkAndAdd(-1,attrib);
  }
}","/** 
 * ""Existing file"" constructor. Builds an attribute tree from a ""mapping file"" or mapping section previously saved somewhere.
 * @param ss StateSystem to which this AT is attached
 * @param fis File stream where to read the AT information. Make sure it's sought at the right place!
 * @throws IOException
 */
AttributeTree(StateSystem ss,FileInputStream fis) throws IOException {
  this(ss);
  DataInputStream in=new DataInputStream(new BufferedInputStream(fis));
  final String errorMessage=""String_Node_Str"";
  ArrayList<String[]> list=new ArrayList<String[]>();
  byte[] curByteArray;
  String curFullString;
  String[] curStringArray;
  int res, remain, size;
  int expectedSize=0;
  int total=0;
  res=in.readInt();
  if (res != ATTRIB_TREE_MAGIC_NUMBER) {
    throw new IOException(errorMessage);
  }
  expectedSize=in.readInt();
  if (expectedSize <= 12) {
    throw new IOException(errorMessage);
  }
  remain=in.readInt();
  total+=12;
  for (; remain > 0; remain--) {
    size=in.readByte();
    curByteArray=new byte[size];
    res=in.read(curByteArray);
    if (res != size) {
      throw new IOException(errorMessage);
    }
    curFullString=new String(curByteArray);
    curStringArray=curFullString.split(""String_Node_Str"");
    list.add(curStringArray);
    res=in.readByte();
    if (res != 0) {
      throw new IOException(errorMessage);
    }
    total+=curByteArray.length + 2;
  }
  if (total != expectedSize) {
    throw new IOException(errorMessage);
  }
  for (  String[] attrib : list) {
    this.getQuarkAndAdd(-1,attrib);
  }
}",0.9961513790891596
91953,"/** 
 * Standard constructor.
 * @param file File object. This is passed as-is to the RandomeAccessFile's constructor.
 * @param mode File open mode (""r"", ""rw"", etc.). This is passed as-is to RandomAccessFile's constructor.
 * @param bufsize Buffer size to use, in bytes
 * @throws IOException If the file was not found or couldn't be opened with the request permissions
 */
public BufferedRandomAccessFile(File file,String mode,int bufsize) throws IOException {
  super(file,mode);
  invalidate();
  BUF_SIZE=bufsize;
  buffer=new byte[BUF_SIZE];
}","/** 
 * Standard constructor.
 * @param file File object. This is passed as-is to the RandomAccessFile's constructor.
 * @param mode File open mode (""r"", ""rw"", etc.). This is passed as-is to RandomAccessFile's constructor.
 * @param bufsize Buffer size to use, in bytes
 * @throws IOException If the file was not found or couldn't be opened with the request permissions
 */
public BufferedRandomAccessFile(File file,String mode,int bufsize) throws IOException {
  super(file,mode);
  invalidate();
  BUF_SIZE=bufsize;
  buffer=new byte[BUF_SIZE];
}",0.9990884229717412
91954,"/** 
 * Seeks to a given timestamp It will go to the event just after the timestamp or the timestamp itself. if a if a trace is 10 20 30 40 and you're looking for 19, it'll give you 20, it you want 20, you'll get 20, if you want 21, you'll get 30. You want -inf, you'll get the first element, you want +inf, you'll get the end of the file with no events.
 * @param timestamp the timestamp to seek to
 * @return true if the trace has more events following the timestamp
 */
public boolean seek(long timestamp){
  this.prio.clear();
  for (  StreamInputReader streamInputReader : this.streamInputReaders) {
    streamInputReader.seek(timestamp);
  }
  for (  StreamInputReader streamInputReader : this.streamInputReaders) {
    if (streamInputReader.getCurrentEvent() != null) {
      this.prio.add(streamInputReader);
    }
  }
  return hasMoreEvents();
}","/** 
 * Seeks to a given timestamp. It will seek to the nearest event greater or equal to timestamp. If a trace is [10 20 30 40] and you are looking for 19, it will give you 20. If you want 20, you will get 20, if you want 21, you will get 30. The value -inf will seek to the first element and the value +inf will seek to the end of the file (past the last event).
 * @param timestamp the timestamp to seek to
 * @return true if there are events above or equal the seek timestamp,false if seek at the end of the trace (no valid event).
 */
public boolean seek(long timestamp){
  this.prio.clear();
  for (  StreamInputReader streamInputReader : this.streamInputReaders) {
    streamInputReader.seek(timestamp);
    if (streamInputReader.getCurrentEvent() != null) {
      this.prio.add(streamInputReader);
    }
  }
  return hasMoreEvents();
}",0.5621685327047732
91955,"/** 
 * gets the last event timestamp that was read. This is NOT necessarily the last event in a trace, just the last one read so far.
 * @return the last event
 */
public long getEndTime(){
  return this.endTime;
}","/** 
 * Gets the last event timestamp that was read. This is NOT necessarily the last event in a trace, just the last one read so far.
 * @return the last event
 */
public long getEndTime(){
  return this.endTime;
}",0.9953488372093025
91956,"/** 
 * gets the stream with the oldest event
 * @return the stream with the oldest event
 */
public StreamInputReader getTopStream(){
  return this.prio.peek();
}","/** 
 * Gets the stream with the oldest event
 * @return the stream with the oldest event
 */
public StreamInputReader getTopStream(){
  return this.prio.peek();
}",0.9938650306748468
91957,"/** 
 * the common streamInput Index
 * @return the stream input Index
 */
StreamInputPacketIndex getIndex(){
  return index;
}","/** 
 * The common streamInput Index
 * @return the stream input Index
 */
StreamInputPacketIndex getIndex(){
  return index;
}",0.9921259842519684
91958,"/** 
 * gets the last read timestamp of a stream. (this is not necessarily the last time in the stream.)
 * @return the last read timestamp
 */
public long getTimestampEnd(){
  return timestampEnd;
}","/** 
 * Gets the last read timestamp of a stream. (this is not necessarily the last time in the stream.)
 * @return the last read timestamp
 */
public long getTimestampEnd(){
  return timestampEnd;
}",0.9949748743718592
91959,"/** 
 * useless for streaminputs
 */
@Override public String getPath(){
  return ""String_Node_Str"";
}","/** 
 * Useless for streaminputs
 */
@Override public String getPath(){
  return ""String_Node_Str"";
}",0.99009900990099
91960,"/** 
 * Gets the filechannel of the streamInput. This is a limited Java ressource.
 * @return the filechannel
 */
public FileChannel getFileChannel(){
  return fileChannel;
}","/** 
 * Gets the filechannel of the streamInput. This is a limited Java resource.
 * @return the filechannel
 */
public FileChannel getFileChannel(){
  return fileChannel;
}",0.9971181556195964
91961,"/** 
 * gets the current packet context
 * @return the current packet context (size, lost events and such)
 */
public StructDefinition getCurrentPacketContext(){
  return this.packetReader.getStreamPacketContextDef();
}","/** 
 * Gets the current packet context
 * @return the current packet context (size, lost events and such)
 */
public StructDefinition getCurrentPacketContext(){
  return this.packetReader.getStreamPacketContextDef();
}",0.9954337899543378
91962,"/** 
 * Changes the location of the trace file reader so that the current event is the first event with a timestamp greater than the given timestamp.
 * @param timestamp The timestamp to seek to.
 * @return The offset compared to the current position
 */
public long seek(long timestamp){
  long offset=0;
  gotoPacket(timestamp);
  while ((this.packetReader.getCurrentPacket() != null) && (this.packetReader.getCurrentPacket().getTimestampEnd() < timestamp)) {
    try {
      this.streamInput.addPacketHeaderIndex();
      goToNextPacket();
    }
 catch (    CTFReaderException e) {
    }
  }
  if (this.packetReader.getCurrentPacket() == null) {
    gotoPacket(timestamp);
  }
  readNextEvent();
  boolean done=(this.getCurrentEvent() == null);
  while (!done && (this.getCurrentEvent().getTimestamp() < timestamp)) {
    readNextEvent();
    done=(this.getCurrentEvent() == null);
    offset++;
  }
  return offset;
}","/** 
 * Changes the location of the trace file reader so that the current event is the first event with a timestamp greater or equal the given timestamp.
 * @param timestamp The timestamp to seek to.
 * @return The offset compared to the current position
 */
public long seek(long timestamp){
  long offset=0;
  gotoPacket(timestamp);
  while ((this.packetReader.getCurrentPacket() != null) && (this.packetReader.getCurrentPacket().getTimestampEnd() < timestamp)) {
    try {
      this.streamInput.addPacketHeaderIndex();
      goToNextPacket();
    }
 catch (    CTFReaderException e) {
    }
  }
  if (this.packetReader.getCurrentPacket() == null) {
    gotoPacket(timestamp);
  }
  readNextEvent();
  boolean done=(this.getCurrentEvent() == null);
  while (!done && (this.getCurrentEvent().getTimestamp() < timestamp)) {
    readNextEvent();
    done=(this.getCurrentEvent() == null);
    offset++;
  }
  return offset;
}",0.9934994582881906
91963,"/** 
 * Sets the id of am event declaration
 * @param id the id
 */
public void setId(long id){
  this.id=id;
}","/** 
 * Sets the id of an event declaration
 * @param id the id
 */
public void setId(long id){
  this.id=id;
}",0.990990990990991
91964,"/** 
 * Sets the stream of am event declaration
 * @param stream the stream
 * @since 2.0
 */
public void setStream(Stream stream){
  this.stream=stream;
}","/** 
 * Sets the stream of an event declaration
 * @param stream the stream
 * @since 2.0
 */
public void setStream(Stream stream){
  this.stream=stream;
}",0.9935483870967742
91965,"/** 
 * Constuctor
 * @param tree the tree (ANTLR generated) with the parsed TSDL data.
 * @param trace the trace containing the places to put all the read metadata
 */
public IOStructGen(CommonTree tree,CTFTrace trace){
  this.trace=trace;
  this.tree=tree;
}","/** 
 * Constructor
 * @param tree the tree (ANTLR generated) with the parsed TSDL data.
 * @param trace the trace containing the places to put all the read metadata
 */
public IOStructGen(CommonTree tree,CTFTrace trace){
  this.trace=trace;
  this.tree=tree;
}",0.9980806142034548
91966,"/** 
 * This method returns the first packet with the end timestamp greater or equal to the given timestamp. The returned packet is the first one that could include the timestamp.
 * @param timestamp The timestamp to look for.
 * @return The StreamInputPacketEntry that corresponds to the packet thatincludes the given timestamp.
 */
public ListIterator<StreamInputPacketIndexEntry> search(final long timestamp){
  int max=this.entries.size() - 1;
  int min=0;
  int guessI;
  StreamInputPacketIndexEntry guessEntry=null;
  if (this.getEntries().isEmpty()) {
    return this.getEntries().listIterator();
  }
  if (timestamp < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (; ; ) {
    guessI=min + ((max - min) / 2);
    guessEntry=this.entries.get(guessI);
    if (min == max) {
      break;
    }
    if (timestamp <= guessEntry.getTimestampEnd()) {
      max=guessI;
    }
 else {
      min=guessI + 1;
    }
  }
  return this.entries.listIterator(guessI);
}","/** 
 * Returns the first PacketIndexEntry that could include the timestamp, that is the last packet with a begin timestamp smaller than the given timestamp.
 * @param timestamp The timestamp to look for.
 * @return The StreamInputPacketEntry that corresponds to the packet thatincludes the given timestamp.
 */
public ListIterator<StreamInputPacketIndexEntry> search(final long timestamp){
  int max=this.entries.size() - 1;
  int min=0;
  int guessI;
  StreamInputPacketIndexEntry guessEntry=null;
  if (this.getEntries().isEmpty()) {
    return this.getEntries().listIterator();
  }
  if (timestamp < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (; ; ) {
    guessI=min + ((max - min) / 2);
    guessEntry=this.entries.get(guessI);
    if (min == max) {
      break;
    }
    if (timestamp <= guessEntry.getTimestampEnd()) {
      max=guessI;
    }
 else {
      min=guessI + 1;
    }
  }
  return this.entries.listIterator(guessI);
}",0.8742331288343558
91967,"/** 
 * Adds an entry to the index.
 * @param entry The entry to add
 * @throws CTFReaderException If there was a problem reading the entry
 */
public void addEntry(StreamInputPacketIndexEntry entry) throws CTFReaderException {
  assert(entry.getContentSizeBits() != 0);
  assert(entry.getContentSizeBits() != 0);
  if (entry.getTimestampBegin() > entry.getTimestampEnd()) {
    throw new CTFReaderException(""String_Node_Str"");
  }
  if (!this.entries.isEmpty()) {
    if (entry.getTimestampBegin() < this.entries.lastElement().getTimestampBegin()) {
      throw new CTFReaderException(""String_Node_Str"");
    }
  }
  this.entries.add(entry);
}","/** 
 * Adds an entry to the index.
 * @param entry The entry to add
 * @throws CTFReaderException If there was a problem reading the entry
 */
public void addEntry(StreamInputPacketIndexEntry entry) throws CTFReaderException {
  assert(entry.getContentSizeBits() != 0);
  if (entry.getTimestampBegin() > entry.getTimestampEnd()) {
    throw new CTFReaderException(""String_Node_Str"");
  }
  if (!this.entries.isEmpty()) {
    if (entry.getTimestampBegin() < this.entries.lastElement().getTimestampBegin()) {
      throw new CTFReaderException(""String_Node_Str"");
    }
  }
  this.entries.add(entry);
}",0.9654618473895582
91968,"/** 
 * This needs explaining: the iterator table is effectively a cache. Originally the contexts had a 1 to 1 structure with the file handles of a trace. This failed since there is a limit to how many file handles we can have opened simultaneously. Then a round-robin scheme was implemented, this lead up to a two competing contexts syncing up and using the same file handler, causing horrible slowdowns. Now a random replacement algorithm is selected. This is the same as used by arm processors, and it works quite well when many cores so this looks promising for very multi-threaded systems.
 * @param context the context to look up
 * @return the iterator refering to the context
 */
public CtfIterator getIterator(final CtfTmfContext context){
  CtfIterator retVal=fMap.get(context);
  if (retVal == null) {
    if (fRandomAccess.size() < MAX_SIZE) {
      retVal=fTrace.createIterator();
      addElement(context,retVal);
    }
 else {
      retVal=replaceRandomElement(context);
    }
    if (context.getLocation() != null) {
      final CtfLocationInfo location=(CtfLocationInfo)context.getLocation().getLocationInfo();
      retVal.seek(location);
    }
  }
  return retVal;
}","/** 
 * This needs explaining: the iterator table is effectively a cache. Originally the contexts had a 1 to 1 structure with the file handles of a trace. This failed since there is a limit to how many file handles we can have opened simultaneously. Then a round-robin scheme was implemented, this lead up to a two competing contexts syncing up and using the same file handler, causing horrible slowdowns. Now a random replacement algorithm is selected. This is the same as used by arm processors, and it works quite well when many cores so this looks promising for very multi-threaded systems.
 * @param context the context to look up
 * @return the iterator referring to the context
 */
public CtfIterator getIterator(final CtfTmfContext context){
  CtfIterator retVal=fMap.get(context);
  if (retVal == null) {
    if (fRandomAccess.size() < MAX_SIZE) {
      retVal=fTrace.createIterator();
      addElement(context,retVal);
    }
 else {
      retVal=replaceRandomElement(context);
    }
    if (context.getLocation() != null) {
      final CtfLocationInfo location=(CtfLocationInfo)context.getLocation().getLocationInfo();
      retVal.seek(location);
    }
  }
  return retVal;
}",0.9995782370307889
91969,"/** 
 * Constructor. Only   {@link CtfTmfEventFactory} should call this.
 * @param trace The origin trace
 * @param rank The rank of the event in the trace
 * @param content The event's payload (fields). In case this event has some.
 * @param fileName The name of the trace file from which this event comes
 * @param cpu The CPU on which this event happend
 * @param declaration The CTF Event Declaration object that created this event
 * @param timeRange The time range of lost events indicated by this one
 * @param nbLost The number of lost events in the range
 */
CtfTmfLostEvent(CtfTmfTrace trace,long rank,ITmfEventField content,String fileName,int cpu,IEventDeclaration declaration,TmfTimeRange timeRange,long nbLost){
  super(trace,rank,(CtfTmfTimestamp)timeRange.getStartTime(),content,fileName,cpu,declaration);
  fTimeRange=timeRange;
  fNbLost=nbLost;
}","/** 
 * Constructor. Only   {@link CtfTmfEventFactory} should call this.
 * @param trace The origin trace
 * @param rank The rank of the event in the trace
 * @param content The event's payload (fields). In case this event has some.
 * @param fileName The name of the trace file from which this event comes
 * @param cpu The CPU on which this event happened
 * @param declaration The CTF Event Declaration object that created this event
 * @param timeRange The time range of lost events indicated by this one
 * @param nbLost The number of lost events in the range
 */
CtfTmfLostEvent(CtfTmfTrace trace,long rank,ITmfEventField content,String fileName,int cpu,IEventDeclaration declaration,TmfTimeRange timeRange,long nbLost){
  super(trace,rank,(CtfTmfTimestamp)timeRange.getStartTime(),content,fileName,cpu,declaration);
  fTimeRange=timeRange;
  fNbLost=nbLost;
}",0.9994222992489892
91970,"/** 
 * return the first label that matches a value
 * @param value the value to query
 * @return the label corresponding to that value
 */
public String query(long value){
  for (  Range r : ranges) {
    if (r.intersects(value)) {
      return r.str;
    }
  }
  return null;
}","/** 
 * Return the first label that matches a value
 * @param value the value to query
 * @return the label corresponding to that value
 */
public String query(long value){
  for (  Range r : ranges) {
    if (r.intersects(value)) {
      return r.str;
    }
  }
  return null;
}",0.996415770609319
91971,"/** 
 * THe value of a float stored, fit into a double. This should be extended for exotic floats if this is necessary.
 * @return the value of the float field fit into a double.
 */
public double getValue(){
  return value;
}","/** 
 * The value of a float stored, fit into a double. This should be extended for exotic floats if this is necessary.
 * @return the value of the float field fit into a double.
 */
public double getValue(){
  return value;
}",0.995575221238938
91972,"/** 
 * is the integer a character (8 bits and encoded?)
 * @return is the integer a char
 */
public boolean isCharacter(){
  return (length == 8) && (encoding != Encoding.NONE);
}","/** 
 * Is the integer a character (8 bits and encoded?)
 * @return is the integer a char
 */
public boolean isCharacter(){
  return (length == 8) && (encoding != Encoding.NONE);
}",0.9944444444444444
91973,"/** 
 * get encoding, chars are 8 bit ints
 * @return the encoding
 */
public Encoding getEncoding(){
  return encoding;
}","/** 
 * Get encoding, chars are 8 bit ints
 * @return the encoding
 */
public Encoding getEncoding(){
  return encoding;
}",0.9918032786885246
91974,"/** 
 * Contructor
 * @param len The length in bits
 * @param signed Is the integer signed? false == unsigned
 * @param base The base (10-16 are most common)
 * @param byteOrder Big endian little endian or other
 * @param encoding ascii, utf8 or none.
 * @param clock The clock path, can be null
 * @param alignment The minimum alignment. Should be >= 1
 */
public IntegerDeclaration(int len,boolean signed,int base,ByteOrder byteOrder,Encoding encoding,String clock,long alignment){
  if (len <= 0 || len == 1 && signed) {
    throw new IllegalArgumentException();
  }
  this.length=len;
  this.signed=signed;
  this.base=base;
  this.byteOrder=byteOrder;
  this.encoding=encoding;
  this.clock=clock;
  this.alignment=Math.max(alignment,1);
}","/** 
 * Constructor
 * @param len The length in bits
 * @param signed Is the integer signed? false == unsigned
 * @param base The base (10-16 are most common)
 * @param byteOrder Big-endian little-endian or other
 * @param encoding ascii, utf8 or none.
 * @param clock The clock path, can be null
 * @param alignment The minimum alignment. Should be >= 1
 */
public IntegerDeclaration(int len,boolean signed,int base,ByteOrder byteOrder,Encoding encoding,String clock,long alignment){
  if (len <= 0 || len == 1 && signed) {
    throw new IllegalArgumentException();
  }
  this.length=len;
  this.signed=signed;
  this.base=base;
  this.byteOrder=byteOrder;
  this.encoding=encoding;
  this.clock=clock;
  this.alignment=Math.max(alignment,1);
}",0.9791806581598388
91975,"/** 
 * gets the byte order
 * @return the byte order
 */
public ByteOrder getByteOrder(){
  return byteOrder;
}","/** 
 * Gets the byte order
 * @return the byte order
 */
public ByteOrder getByteOrder(){
  return byteOrder;
}",0.9910714285714286
91976,"/** 
 * get the integer base commonly decimal or hex
 * @return the integer base
 */
public int getBase(){
  return base;
}","/** 
 * Get the integer base commonly decimal or hex
 * @return the integer base
 */
public int getBase(){
  return base;
}",0.991869918699187
91977,"/** 
 * gets the value in integer form
 * @return the integer in a Long, can be null
 */
public Long getIntegerValue(){
  return null;
}","/** 
 * Gets the value in integer form
 * @return the integer in a Long, can be null
 */
public Long getIntegerValue(){
  return null;
}",0.9926470588235294
91978,"/** 
 * gets the value in string form
 * @return the integer in a String, can be null
 */
public String getStringValue(){
  return null;
}","/** 
 * Gets the value in string form
 * @return the integer in a String, can be null
 */
public String getStringValue(){
  return null;
}",0.9927536231884058
91979,"/** 
 * generate an encoded string declaration
 * @param encoding the encoding, utf8 or ascii
 */
public StringDeclaration(Encoding encoding){
  this.encoding=encoding;
}","/** 
 * Generate an encoded string declaration
 * @param encoding the encoding, utf8 or ascii
 */
public StringDeclaration(Encoding encoding){
  this.encoding=encoding;
}",0.9941176470588236
91980,"/** 
 * Lookup a string in a struct. if the name returns a non-string (like an int) than the method returns null
 * @param name the name of the string
 * @return the string or null.
 */
public StringDefinition lookupString(String name){
  Definition def=lookupDefinition(name);
  return (StringDefinition)((def instanceof StringDefinition) ? def : null);
}","/** 
 * Lookup a string in a struct. If the name returns a non-string (like an int) than the method returns null
 * @param name the name of the string
 * @return the string or null.
 */
public StringDefinition lookupString(String name){
  Definition def=lookupDefinition(name);
  return (StringDefinition)((def instanceof StringDefinition) ? def : null);
}",0.9971910112359552
91981,"/** 
 * Lookup an array in a struct. if the name returns a non-array (like an int) than the method returns null
 * @param name the name of the array
 * @return the array or null.
 */
public ArrayDefinition lookupArray(String name){
  Definition def=lookupDefinition(name);
  return (ArrayDefinition)((def instanceof ArrayDefinition) ? def : null);
}","/** 
 * Lookup an array in a struct. If the name returns a non-array (like an int) than the method returns null
 * @param name the name of the array
 * @return the array or null.
 */
public ArrayDefinition lookupArray(String name){
  Definition def=lookupDefinition(name);
  return (ArrayDefinition)((def instanceof ArrayDefinition) ? def : null);
}",0.997134670487106
91982,"/** 
 * Lookup a variant in a struct. if the name returns a non-variant (like an int) than the method returns null
 * @param name the name of the variant
 * @return the variant or null.
 */
public VariantDefinition lookupVariant(String name){
  Definition def=lookupDefinition(name);
  return (VariantDefinition)((def instanceof VariantDefinition) ? def : null);
}","/** 
 * Lookup a variant in a struct. If the name returns a non-variant (like an int) than the method returns null
 * @param name the name of the variant
 * @return the variant or null.
 */
public VariantDefinition lookupVariant(String name){
  Definition def=lookupDefinition(name);
  return (VariantDefinition)((def instanceof VariantDefinition) ? def : null);
}",0.9972527472527472
91983,"/** 
 * Lookup a struct in a struct. if the name returns a non-struct (like an int) than the method returns null
 * @param name the name of the struct
 * @return the struct or null.
 */
public StructDefinition lookupStruct(String name){
  Definition def=lookupDefinition(name);
  return (StructDefinition)((def instanceof StructDefinition) ? def : null);
}","/** 
 * Lookup a struct in a struct. If the name returns a non-struct (like an int) than the method returns null
 * @param name the name of the struct
 * @return the struct or null.
 */
public StructDefinition lookupStruct(String name){
  Definition def=lookupDefinition(name);
  return (StructDefinition)((def instanceof StructDefinition) ? def : null);
}",0.9971910112359552
91984,"/** 
 * Lookup an integer in a struct. if the name returns a non-integer (like an float) than the method returns null
 * @param name the name of the integer
 * @return the integer or null.
 */
public IntegerDefinition lookupInteger(String name){
  Definition def=lookupDefinition(name);
  return (IntegerDefinition)((def instanceof IntegerDefinition) ? def : null);
}","/** 
 * Lookup an integer in a struct. If the name returns a non-integer (like an float) than the method returns null
 * @param name the name of the integer
 * @return the integer or null.
 */
public IntegerDefinition lookupInteger(String name){
  Definition def=lookupDefinition(name);
  return (IntegerDefinition)((def instanceof IntegerDefinition) ? def : null);
}",0.997275204359673
91985,"/** 
 * Lookup an enum in a struct. if the name returns a non-enum (like an int) than the method returns null
 * @param name the name of the enum
 * @return the enum or null.
 */
public EnumDefinition lookupEnum(String name){
  Definition def=lookupDefinition(name);
  return (EnumDefinition)((def instanceof EnumDefinition) ? def : null);
}","/** 
 * Lookup an enum in a struct. If the name returns a non-enum (like an int) than the method returns null
 * @param name the name of the enum
 * @return the enum or null.
 */
public EnumDefinition lookupEnum(String name){
  Definition def=lookupDefinition(name);
  return (EnumDefinition)((def instanceof EnumDefinition) ? def : null);
}",0.997067448680352
91986,"/** 
 * Lookup a sequence in a struct. if the name returns a non-sequence (like an int) than the method returns null
 * @param name the name of the sequence
 * @return the sequence or null.
 */
public SequenceDefinition lookupSequence(String name){
  Definition def=lookupDefinition(name);
  return (SequenceDefinition)((def instanceof SequenceDefinition) ? def : null);
}","/** 
 * Lookup a sequence in a struct. If the name returns a non-sequence (like an int) than the method returns null
 * @param name the name of the sequence
 * @return the sequence or null.
 */
public SequenceDefinition lookupSequence(String name){
  Definition def=lookupDefinition(name);
  return (SequenceDefinition)((def instanceof SequenceDefinition) ? def : null);
}",0.9973118279569892
91987,"/** 
 * gets current variant tag
 * @return the variant tag.
 */
public String getTag(){
  return this.tag;
}","/** 
 * Gets current variant tag
 * @return the variant tag.
 */
public String getTag(){
  return this.tag;
}",0.9908256880733946
91988,"/** 
 * constructor
 */
public VariantDeclaration(){
}","/** 
 * Constructor
 */
public VariantDeclaration(){
}",0.9814814814814816
91989,"/** 
 * resets the bitbuffer.
 */
public void clear(){
  position(0);
  if (this.buf == null) {
    return;
  }
  this.buf.clear();
}","/** 
 * Resets the bitbuffer.
 */
public void clear(){
  position(0);
  if (this.buf == null) {
    return;
  }
  this.buf.clear();
}",0.9924812030075189
91990,"/** 
 * Relative <i>get</i> method for reading integer of <i>length</i> bits. Reads <i>length</i> bits starting at the current position. The result is signed extended if <i>signed</i> is true. The current position is increased of <i>length</i> bits.
 * @param length The length in bits of this integer
 * @param signed The sign extended flag
 * @return The int value read from the buffer
 */
public int getInt(int length,boolean signed){
  int val=0;
  if (!canRead(length)) {
    throw new BufferOverflowException();
  }
  if (length == 0) {
    return 0;
  }
  boolean gotIt=false;
  if (this.pos % BitBuffer.BIT_CHAR == 0) {
switch (length) {
case BitBuffer.BIT_CHAR:
      if (signed) {
        val=this.buf.get((int)(this.pos / 8));
      }
 else {
        val=(this.buf.get((int)(this.pos / 8))) & 0xff;
      }
    gotIt=true;
  break;
case BitBuffer.BIT_SHORT:
if (signed) {
  val=this.buf.getShort((int)(this.pos / 8));
}
 else {
  short a=this.buf.getShort((int)(this.pos / 8));
  val=a & 0xffff;
}
gotIt=true;
break;
case BitBuffer.BIT_INT:
val=this.buf.getInt((int)(this.pos / 8));
gotIt=true;
break;
default :
break;
}
}
if (!gotIt) {
if (this.byteOrder == ByteOrder.LITTLE_ENDIAN) {
val=getIntLE(this.pos,length,signed);
}
 else {
val=getIntBE(this.pos,length,signed);
}
}
this.pos+=length;
return val;
}","/** 
 * Relative <i>get</i> method for reading integer of <i>length</i> bits. Reads <i>length</i> bits starting at the current position. The result is signed extended if <i>signed</i> is true. The current position is increased of <i>length</i> bits.
 * @param length The length in bits of this integer
 * @param signed The sign extended flag
 * @return The int value read from the buffer
 */
public int getInt(int length,boolean signed){
  if (length == 0) {
    return 0;
  }
  if (!canRead(length)) {
    throw new BufferOverflowException();
  }
  int val=0;
  boolean gotIt=false;
  if (this.pos % BitBuffer.BIT_CHAR == 0) {
switch (length) {
case BitBuffer.BIT_CHAR:
      val=this.buf.get((int)(this.pos / 8));
    if (!signed) {
      val=val & 0xff;
    }
  gotIt=true;
break;
case BitBuffer.BIT_SHORT:
val=this.buf.getShort((int)(this.pos / 8));
if (!signed) {
val=val & 0xffff;
}
gotIt=true;
break;
case BitBuffer.BIT_INT:
val=this.buf.getInt((int)(this.pos / 8));
gotIt=true;
break;
default :
break;
}
}
if (!gotIt) {
if (this.byteOrder == ByteOrder.LITTLE_ENDIAN) {
val=getIntLE(this.pos,length,signed);
}
 else {
val=getIntBE(this.pos,length,signed);
}
}
this.pos+=length;
return val;
}",0.8211446740858506
91991,"/** 
 * Constructor that is fully parametrisable
 * @param buf the buffer to read
 * @param order the byte order (big endian, little endian, network?)
 */
public BitBuffer(ByteBuffer buf,ByteOrder order){
  setByteBuffer(buf);
  setByteOrder(order);
  position(0);
}","/** 
 * Constructor that is fully parameterizable
 * @param buf the buffer to read
 * @param order the byte order (big-endian, little-endian, network?)
 */
public BitBuffer(ByteBuffer buf,ByteOrder order){
  setByteBuffer(buf);
  setByteOrder(order);
  position(0);
}",0.9793621013133208
91992,"/** 
 * Suspend the thread
 */
public synchronized void suspend(){
  pausedLatch=new CountDownLatch(1);
  TmfCoreTracer.traceRequest(fRequest,""String_Node_Str"");
}","/** 
 * Suspend the thread
 */
public void suspend(){
  fIsPaused=true;
  TmfCoreTracer.traceRequest(fRequest,""String_Node_Str"");
}",0.8435374149659864
91993,"/** 
 * Resume the thread
 */
public synchronized void resume(){
  pausedLatch.countDown();
  TmfCoreTracer.traceRequest(fRequest,""String_Node_Str"");
}","/** 
 * Resume the thread
 */
public void resume(){
  fIsPaused=false;
synchronized (fSynchObject) {
    fSynchObject.notifyAll();
  }
  TmfCoreTracer.traceRequest(fRequest,""String_Node_Str"");
}",0.7420289855072464
91994,"/** 
 * @return The request execution state
 */
public synchronized boolean isPaused(){
  return (pausedLatch.getCount() > 0);
}","/** 
 * @return The request execution state
 */
public boolean isPaused(){
  return fIsPaused;
}",0.8214285714285714
91995,"@Override public void run(){
  TmfCoreTracer.traceRequest(fRequest,""String_Node_Str"" + fProvider.getName());
  fRequest.start();
  int nbRequested=fRequest.getNbRequested();
  int nbRead=0;
  isCompleted=false;
  ITmfContext context=fProvider.armRequest(fRequest);
  if (context == null) {
    fRequest.cancel();
    return;
  }
  try {
    ITmfEvent event=fProvider.getNext(context);
    TmfCoreTracer.traceRequest(fRequest,""String_Node_Str"");
    while (event != null && !fProvider.isCompleted(fRequest,event,nbRead)) {
      TmfCoreTracer.traceEvent(fProvider,fRequest,event);
      if (fRequest.getDataType().isInstance(event)) {
        fRequest.handleData(event);
      }
      pausedLatch.await();
      if (++nbRead < nbRequested) {
        event=fProvider.getNext(context);
      }
    }
    isCompleted=true;
    if (fRequest.isCancelled()) {
      fRequest.cancel();
    }
 else {
      fRequest.done();
    }
  }
 catch (  Exception e) {
    Activator.logError(""String_Node_Str"" + fProvider.getName() + ""String_Node_Str""+ fRequest,e);
    fRequest.fail();
  }
  context.dispose();
}","@Override public void run(){
  TmfCoreTracer.traceRequest(fRequest,""String_Node_Str"" + fProvider.getName());
  fRequest.start();
  int nbRequested=fRequest.getNbRequested();
  int nbRead=0;
  isCompleted=false;
  ITmfContext context=fProvider.armRequest(fRequest);
  if (context == null) {
    fRequest.cancel();
    return;
  }
  try {
    ITmfEvent event=fProvider.getNext(context);
    TmfCoreTracer.traceRequest(fRequest,""String_Node_Str"");
    while (event != null && !fProvider.isCompleted(fRequest,event,nbRead)) {
      TmfCoreTracer.traceEvent(fProvider,fRequest,event);
      if (fRequest.getDataType().isInstance(event)) {
        fRequest.handleData(event);
      }
      while (fIsPaused) {
synchronized (fSynchObject) {
          try {
            fSynchObject.wait();
          }
 catch (          InterruptedException e) {
          }
        }
      }
      if (++nbRead < nbRequested) {
        event=fProvider.getNext(context);
      }
    }
    isCompleted=true;
    if (fRequest.isCancelled()) {
      fRequest.cancel();
    }
 else {
      fRequest.done();
    }
  }
 catch (  Exception e) {
    Activator.logError(""String_Node_Str"" + fProvider.getName() + ""String_Node_Str""+ fRequest,e);
    fRequest.fail();
  }
  context.dispose();
}",0.9141156462585034
91996,"@Override public void handleData(final ITmfEvent event){
  super.handleData(event);
  if (fOrderList.isEmpty() || !fOrderList.get(fOrderList.size() - 1).equals(foregroundName)) {
    fOrderList.add(foregroundName);
  }
  ++nbEvents;
}","@Override public void handleData(final ITmfEvent event){
  super.handleData(event);
synchronized (fOrderList) {
    if (fOrderList.isEmpty() || !fOrderList.get(fOrderList.size() - 1).equals(foregroundName)) {
      fOrderList.add(foregroundName);
    }
  }
  ++nbEvents;
}",0.924901185770751
91997,"/** 
 * Run the void setEventType(TraceEventType) method test.
 */
@Test public void testSetEventType_2(){
  BaseEventInfo fixture=new BaseEventInfo(""String_Node_Str"");
  fixture.setEventType(TraceEventType.TRACEPOINT);
  TraceEventType result=fixture.getEventType();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(0,result.ordinal());
  fixture.setEventType(TraceEventType.UNKNOWN);
  result=fixture.getEventType();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(3,result.ordinal());
  fixture.setEventType(TraceEventType.SYSCALL);
  result=fixture.getEventType();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(1,result.ordinal());
  fixture.setEventType(TraceEventType.PROBE);
  result=fixture.getEventType();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(2,result.ordinal());
}","/** 
 * Run the void setEventType(TraceEventType) method test.
 */
@Test public void testSetEventType_2(){
  BaseEventInfo fixture=new BaseEventInfo(""String_Node_Str"");
  fixture.setEventType(TraceEventType.TRACEPOINT);
  TraceEventType result=fixture.getEventType();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(0,result.ordinal());
  fixture.setEventType(TraceEventType.UNKNOWN);
  result=fixture.getEventType();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(4,result.ordinal());
  fixture.setEventType(TraceEventType.SYSCALL);
  result=fixture.getEventType();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(1,result.ordinal());
  fixture.setEventType(TraceEventType.PROBE);
  result=fixture.getEventType();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(2,result.ordinal());
  fixture.setEventType(TraceEventType.FUNCTION);
  result=fixture.getEventType();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(3,result.ordinal());
}",0.9014729950900164
91998,"/** 
 * Run the BaseEventInfo() constructor test.
 */
@Test public void testBaseEventInfo(){
  BaseEventInfo fixture=new BaseEventInfo(""String_Node_Str"");
  assertNotNull(fixture);
  TraceEventType result=fixture.getEventType();
  assertEquals(""String_Node_Str"",fixture.getName());
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(3,result.ordinal());
  TraceLogLevel level=fixture.getLogLevel();
  assertEquals(""String_Node_Str"",level.getInName());
  assertEquals(""String_Node_Str"",level.name());
  assertEquals(""String_Node_Str"",level.toString());
  assertEquals(14,level.ordinal());
}","/** 
 * Run the BaseEventInfo() constructor test.
 */
@Test public void testBaseEventInfo(){
  BaseEventInfo fixture=new BaseEventInfo(""String_Node_Str"");
  assertNotNull(fixture);
  TraceEventType result=fixture.getEventType();
  assertEquals(""String_Node_Str"",fixture.getName());
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(4,result.ordinal());
  TraceLogLevel level=fixture.getLogLevel();
  assertEquals(""String_Node_Str"",level.getInName());
  assertEquals(""String_Node_Str"",level.name());
  assertEquals(""String_Node_Str"",level.toString());
  assertEquals(14,level.ordinal());
}",0.998589562764457
91999,"/** 
 * Run the TraceEventType getEventType() method test.
 */
@Test public void testGetEventType_1(){
  BaseEventInfo fixture=new BaseEventInfo(""String_Node_Str"");
  fixture.setEventType(""String_Node_Str"");
  TraceEventType result=fixture.getEventType();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(3,result.ordinal());
  fixture.setEventType(""String_Node_Str"");
  result=fixture.getEventType();
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(3,result.ordinal());
  fixture.setEventType(""String_Node_Str"");
  result=fixture.getEventType();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(0,result.ordinal());
  fixture.setEventType(""String_Node_Str"");
  result=fixture.getEventType();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(1,result.ordinal());
  fixture.setEventType(""String_Node_Str"");
  result=fixture.getEventType();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(2,result.ordinal());
}","/** 
 * Run the TraceEventType getEventType() method test.
 */
@Test public void testGetEventType_1(){
  BaseEventInfo fixture=new BaseEventInfo(""String_Node_Str"");
  fixture.setEventType(""String_Node_Str"");
  TraceEventType result=fixture.getEventType();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(4,result.ordinal());
  fixture.setEventType(""String_Node_Str"");
  result=fixture.getEventType();
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(4,result.ordinal());
  fixture.setEventType(""String_Node_Str"");
  result=fixture.getEventType();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(0,result.ordinal());
  fixture.setEventType(""String_Node_Str"");
  result=fixture.getEventType();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(1,result.ordinal());
  fixture.setEventType(""String_Node_Str"");
  result=fixture.getEventType();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(2,result.ordinal());
  fixture.setEventType(""String_Node_Str"");
  result=fixture.getEventType();
  assertNotNull(result);
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(3,result.ordinal());
}",0.915983026874116
92000,"/** 
 * Run the BaseEventInfo() constructor test.
 */
@Test public void testBaseEventInfo(){
  EventInfo fixture=new EventInfo(""String_Node_Str"");
  assertNotNull(fixture);
  TraceEventType result=fixture.getEventType();
  assertEquals(""String_Node_Str"",fixture.getName());
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(3,result.ordinal());
  TraceEnablement state=fixture.getState();
  assertEquals(""String_Node_Str"",state.getInName());
  assertEquals(""String_Node_Str"",state.name());
  assertEquals(""String_Node_Str"",state.toString());
  assertEquals(0,state.ordinal());
}","/** 
 * Run the BaseEventInfo() constructor test.
 */
@Test public void testBaseEventInfo(){
  EventInfo fixture=new EventInfo(""String_Node_Str"");
  assertNotNull(fixture);
  TraceEventType result=fixture.getEventType();
  assertEquals(""String_Node_Str"",fixture.getName());
  assertEquals(""String_Node_Str"",result.getInName());
  assertEquals(""String_Node_Str"",result.name());
  assertEquals(""String_Node_Str"",result.toString());
  assertEquals(4,result.ordinal());
  TraceEnablement state=fixture.getState();
  assertEquals(""String_Node_Str"",state.getInName());
  assertEquals(""String_Node_Str"",state.name());
  assertEquals(""String_Node_Str"",state.toString());
  assertEquals(0,state.ordinal());
}",0.9985693848354792
